{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/configure.ac": "# Process this file with autoconf to produce a configure script.\n#AC_PREREQ([2.62])\n\nAC_INIT(mono, [5.10.1.57],\n        [http://bugzilla.xamarin.com/enter_bug.cgi?classification=Mono])\n\nAC_CONFIG_SRCDIR([README.md])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CANONICAL_SYSTEM\nAC_CANONICAL_HOST\n\n# Gross hack to enable 'make dist' on automake 1.9+tar 1.14.\n# The extra brackets are to foil regex-based scans.\nm4_ifdef([_A][M_PROG_TAR],[_A][M_SET_OPTION([tar-ustar])])\n\nAM_INIT_AUTOMAKE([1.9 dist-bzip2 tar-ustar no-dist-gzip foreign subdir-objects]\n                 m4_esyscmd([case `automake --version | head -n 1` in    # parallel-tests is default in automake 1.13+, we need to explicitly enable it\n                             *1.11*|*1.12*) echo parallel-tests;;        # for 1.11 and 1.12 but not below as those versions don't recognize the flag\n                             esac]))                                     # TODO: remove this hack once we require automake 1.11+\n\nAC_CONFIG_HEADERS([config.h])\nAM_MAINTAINER_MODE\n\nAPI_VER=2.0\nAC_SUBST(API_VER)\n\nAC_PROG_LN_S\n\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n\nMONO_VERSION_MAJOR=`echo $VERSION | cut -d . -f 1`\nMONO_VERSION_MINOR=`echo $VERSION | cut -d . -f 2`\nMONO_VERSION_BUILD=`echo $VERSION | cut -d . -f 3`\n\n# This is the version number of the corlib-runtime interface. When\n# making changes to this interface (by changing the layout\n# of classes the runtime knows about, changing icall signature or\n# semantics etc), increment this variable.\n#\n# This can be reset to 0 when Mono's version number is bumped\n# since it's part of the corlib version (the prefix '1' in the full\n# version number is to ensure the number isn't treated as octal in C)\nMONO_CORLIB_COUNTER=4\nMONO_CORLIB_VERSION=`printf \"1%02d%02d%02d%03d\" $MONO_VERSION_MAJOR $MONO_VERSION_MINOR 0 $MONO_CORLIB_COUNTER`\n\nAC_DEFINE_UNQUOTED(MONO_CORLIB_VERSION,$MONO_CORLIB_VERSION,[Version of the corlib-runtime interface])\nAC_SUBST(MONO_CORLIB_VERSION)\n\ncase $host_os in\n*cygwin* )\n\t\t echo \"Run configure using ./configure --host=i686-pc-mingw32\"\n\t\t exit 1\nesac\n\n# In case of cygwin, override LN_S, irrespective of what it determines.\n# The build uses cygwin, but the actual runtime doesn't.\ncase $host_os in\n*cygwin* ) LN_S='cp -p';;\nesac\n\n#\n# libgc defaults\n#\nlibgc_configure_args=\n\n# These variables are the CPPFLAGS/CFLAGS passed to libgc's configure\n# libgc should inherit the original CFLAGS/CPPFLAGS passed to configure, i.e. -O0\nCPPFLAGS_FOR_LIBGC=$CPPFLAGS\nCFLAGS_FOR_LIBGC=$CFLAGS\nCPPFLAGS_FOR_BTLS=$CPPFLAGS\nCFLAGS_FOR_BTLS=$CFLAGS\n\n# libgc uses some deprecated APIs\nCFLAGS_FOR_LIBGC=\"$CFLAGS -Wno-deprecated-declarations\"\n\n#\n# These are the flags that need to be stored in the mono.pc file for \n# compiling code that will embed Mono\n#\nlibmono_cflags=\"\"\nlibmono_ldflags=\"\"\nAC_SUBST(libmono_cflags)\nAC_SUBST(libmono_ldflags)\n\n# Variable to have relocatable .pc files (lib, or lib64)\n# realpath isn't always available, and requires that all but the tip of the provided\n# path exists. Fall back to the old behaviour, but realpath allows depth >1\n# e.g. Debian puts Mono in /usr/bin and libs in /usr/lib/x86_64-linux-gnu/ which is\n# too deep for the old method to work\nreloc_libdir=`realpath --relative-to=${prefix} ${libdir} 2> /dev/null || basename ${libdir}`\nAC_SUBST(reloc_libdir)\n\n# Set to yes if Unix sockets cannot be created in an anonymous namespace\nneed_link_unlink=no\n\n#Set to extra linker flags to be passed to the runtime binaries (mono /mono-sgen)\nextra_runtime_ldflags=\"\"\n\n\n# Hack for WASM\n# Current autotools (v1.15) doesn't have a triplet we can use for wasm so the kludge we do is to\n# work around it by using a feature flag instead\nAC_ARG_ENABLE(wasm,[  --enable-wasm\tHack to set the current runtime to target wasm], enable_wasm=$enableval)\n\n# Thread configuration inspired by sleepycat's db\nAC_MSG_CHECKING([host platform characteristics])\n\nlibgc_threads=no\nhas_dtrace=no\nparallel_mark=yes\nikvm_native=yes\n\nhost_win32=no\ntarget_win32=no\nplatform_android=no\nplatform_tizen=no\nplatform_ios=no\nhost_darwin=no\n\n\nif test \"x$enable_wasm\" = \"xyes\"; then\nCFLAGS=\"$CFLAGS -D_REENTRANT -D_GNU_SOURCE -DNO_UNALIGNED_ACCESS -s WASM=1\"\nCPPFLAGS=\"$CPPFLAGS -D_REENTRANT -DUSE_MMAP -D_GNU_SOURCE -DNO_UNALIGNED_ACCESS -s WASM=1\"\nlibdl=\"-ldl\"\nlibgc_threads=pthreads\n\nelse\n\ncase \"$host\" in\n\t*-mingw*|*-*-cygwin*)\n\t\tAC_DEFINE(DISABLE_PORTABILITY,1,[Disable the io-portability layer])\n\t\tAC_DEFINE(HOST_NO_SYMLINKS,1,[This platform does not support symlinks])\n\t\thost_win32=yes\n\t\tmono_cv_clang=no\n\t\tif test \"x$cross_compiling\" = \"xno\"; then\n\t\t\tif test \"x$host\" = \"x$build\" -a \"x$host\" = \"x$target\"; then\n\t\t\t\ttarget_win32=yes\n\t\t\tfi\n\t\telse\n\t\t\tif test \"x$host\" = \"x$target\"; then\n\t\t\t\ttarget_win32=yes\n\t\t\tfi\n\t\tfi\n\t\tHOST_CC=\"gcc\"\n\t\t# Windows Vista or later is required\n\t\tCPPFLAGS=\"$CPPFLAGS -DWINVER=0x0600 -D_WIN32_WINNT=0x0600 -D_WIN32_IE=0x0501 -D_UNICODE -DUNICODE -DWIN32_THREADS -DFD_SETSIZE=1024\"\n\t\tLDFLAGS=\"$LDFLAGS -lmswsock -lws2_32 -lole32 -loleaut32 -lpsapi -lversion -ladvapi32 -lwinmm -lkernel32 -liphlpapi\"\n\t\tlibmono_cflags=\"-mms-bitfields -mwindows\"\n\t\tlibmono_ldflags=\"-mms-bitfields -mwindows\"\n\t\tlibdl=\n\t\tlibgc_threads=win32\n\t\twith_sigaltstack=no\n\t\twith_tls=pthread\n\t\twith_sgen_default_concurrent=yes\n\t\tLN_S=cp\n\t\t# This forces libgc to use the DllMain based thread registration code on win32\n\t\tlibgc_configure_args=\"$libgc_configure_args --enable-win32-dllmain=yes\"\n\t\t;;\n\t*-*-*netbsd*)\n\t\tCPPFLAGS=\"$CPPFLAGS -D_REENTRANT -DGC_NETBSD_THREADS -D_GNU_SOURCE\"\n\t\tlibmono_cflags=\"-D_REENTRANT\"\n\t\tLDFLAGS=\"$LDFLAGS -pthread\"\n\t\tCPPFLAGS=\"$CPPFLAGS -DHOST_BSD\"\n\t\tlibmono_ldflags=\"-pthread\"\n\t\tneed_link_unlink=yes\n\t\tlibdl=\"-ldl\"\n\t\tlibgc_threads=pthreads\n\t\twith_sigaltstack=no\n\t\tuse_sigposix=yes\n\t\twith_sgen_default_concurrent=yes\n\t\t;;\n\t*-*-kfreebsd*-gnu)\n\t\tCPPFLAGS=\"$CPPFLAGS -DGC_FREEBSD_THREADS -D_GNU_SOURCE -D_REENTRANT -DUSE_MMAP -DUSE_MUNMAP -DTHREAD_LOCAL_ALLOC -pthread\"\n\t\tlibmono_cflags=\"-D_REENTRANT -DTHREAD_LOCAL_ALLOC -pthread\"\n\t\tlibmono_ldflags=\"-lpthread -pthread\"\n\t\tlibdl=\"-ldl\"\n\t\tlibgc_threads=pthreads\n\t\tneed_link_unlink=yes\n\t\twith_sigaltstack=no\n\t\tuse_sigposix=yes\n\t\twith_sgen_default_concurrent=yes\n\t\t;;\n\t*-*-*freebsd*)\n\t\tif test \"x$PTHREAD_CFLAGS\" = \"x\"; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS -DGC_FREEBSD_THREADS\"\n\t\t\tlibmono_cflags=\n\t\telse\n\t\t\tCPPFLAGS=\"$CPPFLAGS $PTHREAD_CFLAGS -DGC_FREEBSD_THREADS\"\n\t\t\tlibmono_cflags=\"$PTHREAD_CFLAGS\"\n\t\tfi\n\t\tif test \"x$PTHREAD_LIBS\" = \"x\"; then\n\t\t\tLDFLAGS=\"$LDFLAGS -pthread -L/usr/local/lib\"\n\t\t\tlibmono_ldflags=\"-pthread\"\n\t\telse\n\t\t\tLDFLAGS=\"$LDFLAGS $PTHREAD_LIBS -L/usr/local/lib\"\n\t\t\tlibmono_ldflags=\"$PTHREAD_LIBS\"\n\t\tfi\n\t\tCPPFLAGS=\"$CPPFLAGS -DHOST_BSD\"\n\t\tneed_link_unlink=yes\n\t\tAC_DEFINE(PTHREAD_POINTER_ID, 1, [pthread is a pointer])\n\t\tlibdl=\n\t\tlibgc_threads=pthreads\n\t\tuse_sigposix=yes\n\t\thas_dtrace=yes\n\t\twith_sgen_default_concurrent=yes\n\t\t;;\n\t*-*-*openbsd*)\n\t\tCPPFLAGS=\"$CPPFLAGS -D_THREAD_SAFE -DGC_OPENBSD_THREADS -DHOST_BSD -D_REENTRANT -DUSE_MMAP\"\n\t\tif test \"x$disable_munmap\" != \"xyes\"; then\n\t\tCPPFLAGS=\"$CPPFLAGS -DUSE_MUNMAP\"\n\t\tfi\n\t\tlibmono_cflags=\"-D_THREAD_SAFE -D_REENTRANT\"\n\t\tLDFLAGS=\"$LDFLAGS -pthread\"\n\t\tneed_link_unlink=yes\n\t\tAC_DEFINE(PTHREAD_POINTER_ID)\n\t\tlibdl=\n\t\tlibgc_threads=pthreads\n\t\twith_sigaltstack=no\n\t\tuse_sigposix=yes\n\t\twith_sgen_default_concurrent=yes\n\t\t;;\n\t*-*-linux-android*)\n\t\tplatform_android=yes\n\t\tAC_DEFINE(HOST_ANDROID,1,[Targeting the Android platform])\n\t\tAC_DEFINE(TARGET_ANDROID,1,[Targeting the Android platform])\n\n\t\tCPPFLAGS=\"$CPPFLAGS -DGC_LINUX_THREADS -D_GNU_SOURCE -D_REENTRANT -DUSE_MMAP\"\n\t\tif test \"x$disable_munmap\" != \"xyes\"; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS -DUSE_MUNMAP\"\n\t\tfi\n\t\tlibmono_cflags=\"-D_REENTRANT\"\n\t\tlibdl=\"-ldl\"\n\t\tlibgc_threads=pthreads\n\t\tuse_sigposix=yes\n\n\t\twith_tls=pthread\n\t\twith_sigaltstack=no\n\t\twith_static_mono=no\n\n\t\t# Android doesn't support boehm, as it's missing <link.h>\n\t\tsupport_boehm=no\n\t\twith_gc=sgen\n\n\t\t# isinf(3) requires -lm; see isinf check below\n\t\tLDFLAGS=\"$LDFLAGS -lm\"\n\n\t\t# Bionic's <pthread.h> sets PTHREAD_STACK_MIN=2*PAGE_SIZE; doesn't define\n\t\t# PAGE_SIZE; breaks mono/io-layer/collection.c\n\t\t# Bionic doesn't provide S_IWRITE; breaks io-layer/io.c\n\t\tCFLAGS=\"$CFLAGS -DPAGE_SIZE=4096 -DS_IWRITE=S_IWUSR\"\n\t\tCXXFLAGS=\"$CXXFLAGS -DPAGE_SIZE=4096 -DS_IWRITE=S_IWUSR\"\n\n\t\t# to bypass the underscore linker check, can't work when cross-compiling\n\t\tmono_cv_uscore=yes\n\t\tmono_cv_clang=no\n\t\t;;\n\t*-*-linux*)\n\t\tCPPFLAGS=\"$CPPFLAGS -DGC_LINUX_THREADS -D_GNU_SOURCE -D_REENTRANT -DUSE_MMAP\"\n\t\tif test \"x$disable_munmap\" != \"xyes\"; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS -DUSE_MUNMAP\"\n\t\tfi\n\t\tlibmono_cflags=\"-D_REENTRANT\"\n\t\tlibdl=\"-ldl\"\n\t\tlibgc_threads=pthreads\n\t\tuse_sigposix=yes\n\t\tif test \"x$cross_compiling\" != \"xno\"; then\n                \t# to bypass the underscore linker check, not\n                \t# available during cross-compilation\n                \tmono_cv_uscore=no\n                fi\n\t\tcase \"$host\" in\n\t\t*-tizen-linux-*)\n\t\t\tplatform_tizen=yes\n\t\t\t;;\n\t\tesac\n\t\tcase \"$host\" in\n\t\taarch64-*)\n\t\t\tsupport_boehm=no\n\t\t\twith_gc=sgen\n\t\t\t;;\n\t\tpowerpc*-*-linux*)\n\t\t\t# https://bugzilla.novell.com/show_bug.cgi?id=504411\n\t\t\tdisable_munmap=yes\n\t\t\t;;\n\t\tesac\n\t\twith_sgen_default_concurrent=yes\n\t\t;;\n\t*-*-nacl*)\n\t\techo \"nacl no longer supported.\"\n\t\texit 1\n\t\t;;\n\t*-*-hpux*)\n\t\tCPPFLAGS=\"$CPPFLAGS -DGC_HPUX_THREADS -D_HPUX_SOURCE -D_XOPEN_SOURCE_EXTENDED -D_REENTRANT\"\n\t\t# +ESdbgasm only valid on bundled cc on RISC\n\t\t# silently ignored for ia64\n\t\tif test $GCC != \"yes\"; then\n\t\t\tCFLAGS=\"$CFLAGS +ESdbgasm\"\n\t\t\t# Arrange for run-time dereferencing of null\n\t\t\t# pointers to produce a SIGSEGV signal.\n\t\t\tLDFLAGS=\"$LDFLAGS -z\"\n\t\tfi\n\t\tCFLAGS=\"$CFLAGS +ESdbgasm\"\n\t\tLDFLAGS=\"$LDFLAGS -z\"\n\t\tlibmono_cflags=\"-D_REENTRANT\"\n\t\tlibmono_ldflags=\"-lpthread\"\n\t\tlibgc_threads=pthreads\n\t\tneed_link_unlink=yes\n\t\tuse_sigposix=yes\n\t\t;;\n\t*-*-solaris*)\n\t\tCPPFLAGS=\"$CPPFLAGS -DGC_SOLARIS_THREADS -DGC_SOLARIS_PTHREADS -D_REENTRANT -D_POSIX_PTHREAD_SEMANTICS -DUSE_MMAP -DUSE_MUNMAP -DHOST_SOLARIS\"\n\t\tneed_link_unlink=yes\n\t\tlibmono_cflags=\"-D_REENTRANT\"\n\t\tlibgc_threads=pthreads\n\t\thas_dtrace=yes\n\t\tuse_sigposix=yes\n\t\tenable_solaris_tar_check=yes\n\t\t;;\n\t*-*-darwin*)\n\t\tparallel_mark=\"Disabled_Currently_Hangs_On_MacOSX\"\n\t\thost_darwin=yes\n\t\ttarget_mach=yes\n\t\tCPPFLAGS=\"$CPPFLAGS -D_THREAD_SAFE -DGC_MACOSX_THREADS -DUSE_MMAP -DUSE_MUNMAP\"\n\t\tlibmono_cflags=\"-D_THREAD_SAFE\"\n\t\tneed_link_unlink=yes\n\t\tAC_DEFINE(PTHREAD_POINTER_ID)\n\t\tAC_DEFINE(USE_MACH_SEMA, 1, [...])\n\t\tlibdl=\n\t\tlibgc_threads=pthreads\n\t\thas_dtrace=yes\n\t\tif test \"x$cross_compiling\" = \"xyes\"; then\n\t\t\thas_broken_apple_cpp=yes\n\t\tfi\n\t\tdnl Snow Leopard is horribly broken -- it reports itself as i386-apple-darwin*, but\n\t\tdnl its gcc defaults to 64-bit mode.  They have also deprecated the usage of ucontext\n\t\tdnl we need to set some flags to build our 32-bit binaries on 10.6 properly\n\t\tcase \"$host\" in\n\t\t\tdnl Snow Leopard and newer config.guess reports as this\n\t\t\ti*86-*-darwin*)\n\t\t\t\tBROKEN_DARWIN_FLAGS=\"-arch i386 -D_XOPEN_SOURCE\"\n\t\t\t\tBROKEN_DARWIN_CPPFLAGS=\"-D_XOPEN_SOURCE\"\n\t\t\t\tCPPFLAGS=\"$CPPFLAGS $BROKEN_DARWIN_CPPFLAGS\"\n\t\t\t\tCFLAGS=\"$CFLAGS $BROKEN_DARWIN_FLAGS\"\n\t\t\t\tCXXFLAGS=\"$CXXFLAGS $BROKEN_DARWIN_FLAGS\"\n\t\t\t\tCCASFLAGS=\"$CCASFLAGS $BROKEN_DARWIN_FLAGS\"\n\t\t\t\tCPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC $BROKEN_DARWIN_CPPFLAGS\"\n\t\t\t\tCFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC $BROKEN_DARWIN_FLAGS\"\n\t\t\t\twith_sgen_default_concurrent=yes\n\t\t\t\t;;\n\t\t\tx*64-*-darwin*)\n\t\t\t\twith_sgen_default_concurrent=yes\n\t\t\t\t;;\n\t\t\tarm*-darwin*)\n\t\t\t\tplatform_ios=yes\n\t\t\t\thas_dtrace=no\n\t\t\t\t;;\n\t\t\taarch64*-darwin*)\n\t\t\t\tplatform_ios=yes\n\t\t\t\t;;\n\t\tesac\n\t\t;;\n\t*-*-haiku*)\n\t\tCPPFLAGS=\"$CPPFLAGS -D_REENTRANT -D_THREAD_SAFE\"\n\t\tlibmono_cflags=\"-D_REENTRANT -D_THREAD_SAFE\"\n\t\tlibdl=\n\t\tLIBS=\"$LIBS -lnetwork -ltextencoding\"\n\t\tneed_link_unlink=yes\n\t\tAC_DEFINE(PTHREAD_POINTER_ID)\n\t\tdnl Haiku does not support static TLS with __thread\n\t\twith_tls=pthread\n\t\tdnl Boehm is too much work to backport Haiku support for\n\t\tsupport_boehm=no\n\t\tlibgc_threads=pthreads\n\t\tuse_sigposix=yes\n\t\t;;\n\t*)\n\t\tAC_MSG_WARN([*** Please add $host to configure.ac checks!])\n\t\tlibdl=\"-ldl\"\n\t\t;;\nesac\n\n# WASM hack\nfi\n\nAC_MSG_RESULT(ok)\n\nif test x$need_link_unlink = xyes; then\n   AC_DEFINE(NEED_LINK_UNLINK, 1, [Define if Unix sockets cannot be created in an anonymous namespace])\nfi\n\nif test x$host_win32 = xyes; then\n   AC_DEFINE(HOST_WIN32, 1, [Host Platform is Win32])\nfi\n\nif test x$target_win32 = xyes; then\n   AC_DEFINE(TARGET_WIN32, 1, [Target Platform is Win32])\nfi\n\nif test x$host_darwin = xyes; then\n   AC_DEFINE(HOST_DARWIN, 1, [Host Platform is Darwin])\nfi\n\n# Defined for all targets/platforms using classic Windows API support.\nAC_DEFINE(HAVE_CLASSIC_WINAPI_SUPPORT, 1, [Use classic Windows API support])\nAC_DEFINE(HAVE_UWP_WINAPI_SUPPORT, 0, [Don't use UWP Windows API support])\n\nAC_SUBST(extra_runtime_ldflags)\nAM_CONDITIONAL(HOST_WIN32, test x$host_win32 = xyes)\nAM_CONDITIONAL(TARGET_WIN32, test x$target_win32 = xyes)\nAM_CONDITIONAL(HOST_LINUX, echo x$target_os | grep -q linux)\nAM_CONDITIONAL(HOST_DARWIN, test x$host_darwin = xyes)\nAM_CONDITIONAL(HOST_SIGPOSIX, test x$use_sigposix = xyes)\nAM_CONDITIONAL(HOST_ANDROID, test x$platform_android = xyes)\nAM_CONDITIONAL(HOST_TIZEN, test x$platform_tizen = xyes)\nAM_CONDITIONAL(HOST_IOS, test x$platform_ios = xyes)\n\nif test -z \"$HOST_DARWIN_TRUE\"; then :\nPLATFORM_AOT_SUFFIX=.dylib\nfi\n\nif test -z \"$HOST_LINUX_TRUE\"; then :\nPLATFORM_AOT_SUFFIX=.so\nfi\n\nif test -z \"$HOST_WIN32_TRUE\"; then :\nPLATFORM_AOT_SUFFIX=.dll\nfi\n\nAC_SUBST(PLATFORM_AOT_SUFFIX)\n\n## PLATFORM_AOT_SUFFIX not so simple for windows :-)\n\nAC_CHECK_TOOL(CC, gcc, gcc)\nAC_PROG_CC\nAC_CHECK_TOOL(CXX, g++, g++)\nAC_PROG_CXX\nAM_PROG_AS\nAC_PROG_INSTALL\nAC_PROG_AWK\nAM_PROG_CC_C_O\ndnl We should use AM_PROG_AS, but it's not available on automake/aclocal 1.4\n: ${CCAS='$(CC)'}\n# Set ASFLAGS if not already set.\n: ${CCASFLAGS='$(CFLAGS)'}\nAC_SUBST(CCAS)\nAC_SUBST(CCASFLAGS)\n\n# AC_PROG_CXX helpfully sets CXX to g++ even if no c++ compiler is found so check\n# GXX instead. See http://lists.gnu.org/archive/html/bug-autoconf/2002-04/msg00056.html\nif test \"x$CXX\" = \"xg++\"; then\n\tif test \"x$GXX\" != \"xyes\"; then\n\t\t# automake/libtool is so broken, it requires g++ even if the c++ sources\n\t\t# are inside automake conditionals\n\t\tAC_MSG_ERROR([You need to install g++])\n\tfi\nfi\n\ndnl may require a specific autoconf version\ndnl AC_PROG_CC_FOR_BUILD\ndnl CC_FOR_BUILD not automatically detected\nCC_FOR_BUILD=$CC\nCFLAGS_FOR_BUILD=$CFLAGS\nBUILD_EXEEXT=\nif test \"x$cross_compiling\" = \"xyes\"; then\n\tCC_FOR_BUILD=cc\n\tCFLAGS_FOR_BUILD=\n\tBUILD_EXEEXT=\"\"\nfi\nAC_SUBST(CC_FOR_BUILD)\nAC_SUBST(CFLAGS_FOR_BUILD)\nAC_SUBST(HOST_CC)\nAC_SUBST(BUILD_EXEEXT)\n\nAM_CONDITIONAL(CROSS_COMPILING, [test x$cross_compiling = xyes])\nAM_CONDITIONAL(USE_BATCH_FILES, [test x$host_win32 = xyes -a x$cross_compiling = xyes])\n\n# Set STDC_HEADERS\nAC_HEADER_STDC\nAC_LIBTOOL_WIN32_DLL\n# This causes monodis to not link correctly\n#AC_DISABLE_FAST_INSTALL\n\n#lookup makedev() header\nAC_HEADER_MAJOR\n\nAM_PROG_LIBTOOL\n# Use dolt (http://dolt.freedesktop.org/) instead of libtool for building.\nDOLT\n\nexport_ldflags=`(./libtool --config; echo eval echo \\\\$export_dynamic_flag_spec) | sh`\nAC_SUBST(export_ldflags)\n\n# Test whenever ld supports -version-script\nAC_PROG_LD\nAC_PROG_LD_GNU\n\nAM_ICONV()\n\nAC_CHECK_HEADERS(sys/filio.h sys/sockio.h netdb.h utime.h sys/utime.h semaphore.h sys/un.h linux/rtc.h sys/syscall.h sys/mkdev.h sys/uio.h sys/param.h sys/sysctl.h libproc.h sys/prctl.h)\nAC_CHECK_HEADERS(sys/param.h sys/socket.h sys/ipc.h sys/utsname.h alloca.h ucontext.h pwd.h sys/select.h netinet/tcp.h netinet/in.h unistd.h sys/types.h link.h asm/sigcontext.h sys/inotify.h arpa/inet.h complex.h unwind.h)\nAC_CHECK_HEADERS([linux/netlink.h linux/rtnetlink.h],\n                  [], [], [#include <stddef.h>\n\t\t  #include <sys/socket.h>\n\t\t  #include <linux/socket.h>])\n\nAC_CHECK_HEADERS(sys/user.h, [], [],\n[\n#ifdef HAVE_SYS_PARAM_H\n# include <sys/param.h>\n#endif\n])\n\nAC_CHECK_HEADERS(linux/serial.h)\n\nAC_CHECK_HEADER(zlib.h, [have_zlib=yes], [have_zlib=no])\nif test x$have_zlib = xyes; then\n   AC_TRY_COMPILE([#include <zlib.h>], [\n   #if defined(ZLIB_VERNUM) && (ZLIB_VERNUM >= 0x1230)\n   return 0;\n   #else\n   #error No good zlib found\n   #endif\n   ],[\n\tAC_MSG_RESULT(Using system zlib)\n\tzlib_msg=\"system zlib\"\n\tAC_DEFINE(HAVE_SYS_ZLIB,1,[Have system zlib])\n   ],[\n\tAC_MSG_RESULT(Using embedded zlib)\n\thave_zlib=no\n\tzlib_msg=\"bundled zlib\"\n   ])\nfi\n\nAM_CONDITIONAL(HAVE_ZLIB, test x$have_zlib = xyes)\nAC_DEFINE(HAVE_ZLIB,1,[Have system zlib])\n\n# for mono/metadata/debug-symfile.c\nAC_CHECK_HEADERS(elf.h)\n\n# for support\nAC_CHECK_HEADERS(poll.h)\nAC_CHECK_HEADERS(sys/poll.h)\nAC_CHECK_HEADERS(sys/wait.h)\nAC_CHECK_HEADERS(grp.h)\nAC_CHECK_HEADERS(syslog.h)\n\n# for mono/dis\nAC_CHECK_HEADERS(wchar.h)\nAC_CHECK_HEADERS(ieeefp.h)\nAC_MSG_CHECKING(for isinf)\nAC_TRY_LINK([#include <math.h>], [\n\tint f = isinf (1.0);\n], [\n\tAC_MSG_RESULT(yes)\n\tAC_DEFINE(HAVE_ISINF, 1, [isinf available])\n], [\n\t# We'll have to use signals\n\tAC_MSG_RESULT(no)\n])\n# mingw\nAC_CHECK_FUNCS(_finite, , AC_MSG_CHECKING(for _finite in math.h)\n\tAC_TRY_LINK([#include <math.h>], \n\t[ _finite(0.0); ], \n\tAC_DEFINE(HAVE__FINITE, 1, [Have _finite in -lm]) AC_MSG_RESULT(yes),\n\tAC_MSG_RESULT(no)))\n\n# for Linux statfs support\nAC_CHECK_HEADERS(linux/magic.h)\n\n# For Android NDK unified headers\nif test x$platform_android = xyes; then\n\tAC_CHECK_HEADERS(machine/endian.h sys/endian.h)\n\tAC_CHECK_HEADERS(android/legacy_signal_inlines.h, [have_android_signal_inlines=yes], [have_android_signal_inlines=no])\n\n\t# Make sure SIGRT{MIN,MAX} work - they will fail to work with unified headers if building for\n\t# API level < 21 *and* android/legacy_signal_inlines.h doesn't declare (and define) the required\n\t# libc APIs to obtain values for SIGRT{MIN,MAX}. We perform the check only if android/legacy_signal_inlines.h\n\t# is found because in other cases the macros will either work (for NDK < 14) or fail if the legacy header\n\t# doesn't contain the required definitions (NDK 14)\n\tif test x$have_android_signal_inlines = xyes; then\n\t\tAC_MSG_CHECKING([Whether Android SIGRTMIN/SGRTMAX macros are valid])\n\t\tAC_COMPILE_IFELSE([\n\t\t\tAC_LANG_PROGRAM([#include <android/legacy_signal_inlines.h>],[\n\t\t\t\tint i;\n\t\t\t\tfor (i = SIGRTMIN + 1; i < SIGRTMAX; ++i) {\n\t\t\t\t}\n\t\t\t])],[\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tandroid_sigrtminmax_work=yes\n\t\t\t],[\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\tandroid_sigrtminmax_work=no\n\t\t\t]\n\t\t)\n\n\t\tif test x$android_sigrtminmax_work = xno; then\n\t\t\tAC_MSG_ERROR([Android SIGRTMIN/SIGRTMAX macros don't work in this NDK])\n\t\tfi\n\tfi\n\n\t# Attempt to detect whether we're using Android NDK unified headers\n\tAC_CHECK_HEADERS(android/api-level.h, [have_android_api_level=yes], [have_android_api_level=no])\n\tAC_CHECK_HEADERS(android/versioning.h, [have_android_versioning=yes], [have_android_versioning=no])\n\n\tandroid_unified_headers=no\n\tif test x$have_android_api_level = xyes; then\n\t\tif test x$have_android_versioning = xyes; then\n\t\t\tAC_MSG_CHECKING([whether using Android NDK unified headers])\n\n\t\t\t# Both macros are defined only in the NDK unified headers\n\t\t\tAC_COMPILE_IFELSE([\n\t\t\t\tAC_LANG_PROGRAM([\n\t\t\t\t\t#include <android/api-level.h>\n\t\t\t\t\t#include <android/versioning.h>\n\t\t\t\t],[\n\t\t\t\t\t#if __ANDROID_API_O__ == 26 && defined(__INTRODUCED_IN)\n\t\t\t\t\t\treturn 0\n\t\t\t\t\t#else\n\t\t\t\t\t\t#error __ANDROID_API_O__ != 26 or the __INTRODUCED_IN macro not defined\n\t\t\t\t\t#endif\n\t\t\t\t])],[\n\t\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\t\tandroid_unified_headers=yes\n\t\t\t\t],[\n\t\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\t\tandroid_unified_headers=no\n\t\t\t\t]\n\t\t\t)\n\t\tfi\n\tfi\n\n\tif test x$android_unified_headers = xyes; then\n\t\tAC_DEFINE(ANDROID_UNIFIED_HEADERS, 1, [Whether Android NDK unified headers are used])\n\tfi\nfi # Android\n\n# not 64 bit clean in cross-compile\nif test \"x$enable_wasm\" = \"xyes\"; then\nAC_DEFINE(SIZEOF_VOID_P,4)\nAC_DEFINE(SIZEOF_LONG,4)\nac_cv_sizeof_void_p=\"4\"\nac_cv_sizeof_long=\"4\"\nelse\nAC_CHECK_SIZEOF(void *)\nAC_CHECK_SIZEOF(long)\nfi\n\nAC_CHECK_SIZEOF(int)\nAC_CHECK_SIZEOF(long long)\n\nAC_CACHE_CHECK([for clang],\n\tmono_cv_clang,[\n\tAC_TRY_COMPILE([], [\n\t\t#ifdef __clang__\n\t\t#else\n\t\t#error \"FAILED\"\n\t\t#endif\n\t\treturn 0;\n\t],\n\t[mono_cv_clang=yes],\n\t[mono_cv_clang=no],\n\t[])\n])\n\nAC_ARG_ENABLE(visibility-hidden,\n[  --disable-visibility-hidden    disable usage of -fvisiblity=hidden],\n   disable_visibility_hidden=yes, disable_visibility_hidden=no)\n\nWARN=''\nif test x\"$GCC\" = xyes; then\n        WARN='-Wall -Wunused -Wmissing-prototypes -Wmissing-declarations -Wstrict-prototypes  -Wmissing-prototypes -Wnested-externs -Wpointer-arith -Wno-cast-qual -Wwrite-strings -Wno-switch -Wno-switch-enum -Wno-unused-value -Wno-attributes -Wno-format-zero-length'\n\n\t\t# We require C99 with some GNU extensions, e.g. `linux` macro\n\t\tCFLAGS=\"$CFLAGS -std=gnu99\"\n\n\t\t# The runtime code does not respect ANSI C strict aliasing rules\n\t\tCFLAGS=\"$CFLAGS -fno-strict-aliasing\"\n\n\t\t# We rely on signed overflow to behave\n\t\tCFLAGS=\"$CFLAGS -fwrapv\"\n\n\t\tCFLAGS=\"$CFLAGS -DMONO_DLL_EXPORT\"\n\t\tif test x\"$disable_visibility_hidden\" = xno; then\n\t\t   # Don't export any symbols by default\n\t\t   SHARED_CFLAGS=\"-fvisibility=hidden\"\n\t\t   CXXFLAGS=\"$CXXFLAGS -fvisibility=hidden\"\n\t\tfi\n\n\t\tORIG_CFLAGS=$CFLAGS\n\t\t# Check for the normal version, since gcc ignores unknown -Wno options\n\t\tCFLAGS=\"$CFLAGS -Wunused-but-set-variable -Werror\"\n\t\tAC_MSG_CHECKING(for -Wno-unused-but-set-variable option to gcc)\n\t\tAC_TRY_COMPILE([],[\n\t\t\t\treturn 0;\n\t\t], [\n\t\t   AC_MSG_RESULT(yes)\n\t\t   CFLAGS=\"$ORIG_CFLAGS -Wno-unused-but-set-variable\"\n\t\t], [\n\t\t   AC_MSG_RESULT(no)\n\t\t   CFLAGS=$ORIG_CFLAGS\n\t\t])\n\n\t\tif test \"x$mono_cv_clang\" = \"xyes\"; then\n\t   \t   # https://bugzilla.samba.org/show_bug.cgi?id=8118\n\t   \t   WARN=\"$WARN -Qunused-arguments\"\n\t\t   WARN=\"$WARN -Wno-unused-function -Wno-tautological-compare -Wno-parentheses-equality -Wno-self-assign -Wno-return-stack-address -Wno-constant-logical-operand\"\n\t\t   # We rely on zero length arrays in structs\n\t\t   WARN=\"$WARN -Wno-zero-length-array\"\n\t\tfi\nelse\n\t# The Sun Forte compiler complains about inline functions that access static variables\n\t# so disable all inlining.\n\tcase \"$host\" in\n\t*-*-solaris*)\n\t\tCFLAGS=\"$CFLAGS -Dinline=\"\n\t\t;;\n\tesac\nfi\nCFLAGS=\"$CFLAGS -g $WARN\"\nCFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -g\"\nCPPFLAGS=\"$CPPFLAGS -g $WARN\"\n\n# Where's the 'mcs' source tree?\nif test -d $srcdir/mcs; then\n  mcsdir=mcs\nelse\n  mcsdir=../mcs\nfi\n\nAC_ARG_WITH(mcs-path, [  --with-mcs-path=/path/to/mcs      Specify an alternate mcs source tree],\n\tif test x$with_mcs_path != \"x\" -a -d $with_mcs_path ; then\n\t\tmcsdir=$with_mcs_path\n\tfi\n)\n\nAC_ARG_WITH(jumptables, [  --with-jumptables=yes,no      enable/disable support for jumptables (ARM-only for now) (defaults to no)],[],[with_jumptables=no])\n\n#\n# A sanity check to catch cases where the package was unpacked\n# with an ancient tar program (Solaris)\n#\nAC_ARG_ENABLE(solaris-tar-check,\n[  --disable-solaris-tar-check    disable solaris tar check],\n   do_solaris_tar_check=no, do_solaris_tar_check=yes)\n\nif test x\"$do_solaris_tar_check\" = xyes -a x\"$enable_solaris_tar_check\" = xyes; then\n   \tAC_MSG_CHECKING(integrity of package)\n\tif test -f $mcsdir/class/System.Runtime.Serialization.Formatters.Soap/System.Runtime.Serialization.Formatters.Soap/SoapTypeMapper.cs\n   \tthen\n\t\tAC_MSG_RESULT(ok)\n   \telse\n\t\terrorm=\"Your mono distribution is incomplete;  if unpacking from a tar file, make sure you use GNU tar;  see http://www.mono-project.com/IncompletePackage for more details\"\n\t\tAC_MSG_ERROR([$errorm])\n\tfi\nfi\n\nif test \"x$with_mcs_path\" != \"x\"; then\nmcs_topdir=$(cd \"$mcsdir\" && pwd)\nmcs_topdir_from_srcdir=$mcs_topdir\nelse\nmcs_topdir=$(cd \"$srcdir/$mcsdir\" && pwd)\nmcs_topdir_from_srcdir='$(top_builddir)'/$mcsdir\nfi\n\n# Convert mcs_topdir* paths to Windows syntax.\nif test x$cross_compiling$host_win32 = xnoyes; then\n  mcs_topdir=$(cygpath -m $mcs_topdir)\n  case $mcs_topdir_from_srcdir in\n    /cygdrive/*)\n\tmcs_topdir_from_srcdir=$(cygpath -m $mcs_topdir_from_srcdir)\n\t;;\n  esac\nfi\n\nAC_SUBST([mcs_topdir])\nAC_SUBST([mcs_topdir_from_srcdir])\n\n# gettext: prepare the translation directories. \n# we do not configure the full gettext, as we consume it dynamically from C#\nAM_PO_SUBDIRS\n\nif test \"x$USE_NLS\" = \"xyes\"; then\n   AC_CHECK_PROG(HAVE_MSGFMT, msgfmt,yes,no)\n\n   if test \"x$HAVE_MSGFMT\" = \"xno\"; then\n\t  AC_MSG_ERROR([msgfmt not found. You need to install the 'gettext' package, or pass --enable-nls=no to configure.])\n   fi\nfi\n\nAC_PATH_PROG(PKG_CONFIG, pkg-config, no)\n\npkg_config_path=\nAC_ARG_WITH(crosspkgdir, [  --with-crosspkgdir=/path/to/pkg-config/dir      Change pkg-config dir to custom dir],\n\tif test x$with_crosspkgdir = \"x\"; then\n\t\tif test -s $PKG_CONFIG_PATH; then\n\t\t\tpkg_config_path=$PKG_CONFIG_PATH\n\t\tfi\n\telse\n\t\tpkg_config_path=$with_crosspkgdir\n\t\tPKG_CONFIG_PATH=$pkg_config_path\n\t\texport PKG_CONFIG_PATH\n\tfi\n)\n\nAC_CHECK_PROG(ninja, ninja, yes, no)\nAM_CONDITIONAL(NINJA, test x$ninja != xno)\n\nAC_ARG_ENABLE(werror, [  --enable-werror Pass -Werror to the C compiler], werror_flag=$enableval, werror_flag=no)\nif test x$werror_flag = xyes; then\n\tWERROR_CFLAGS=\"-Werror\"\nfi\nAC_SUBST([WERROR_CFLAGS])\nAC_SUBST([SHARED_CFLAGS])\n\nGLIB_CFLAGS='-I$(top_srcdir)/mono/eglib -I$(top_builddir)/mono/eglib'\nGLIB_LIBS='$(top_builddir)/mono/eglib/libeglib.la -lm'\n  \nAC_SUBST(GLIB_CFLAGS)\nAC_SUBST(GLIB_LIBS)\n\n# Enable support for fast thread-local storage\n# Some systems have broken support, so we allow to disable it.\nAC_ARG_WITH(tls, [  --with-tls=__thread,pthread    select Thread Local Storage implementation (defaults to __thread)],[],[with_tls=__thread])\n\n# Enable support for using sigaltstack for SIGSEGV and stack overflow handling\n# This does not work on some platforms (bug #55253)\nAC_ARG_WITH(sigaltstack, [  --with-sigaltstack=yes,no      enable/disable support for sigaltstack (defaults to yes)],[],[with_sigaltstack=yes])\n\nAC_ARG_WITH(static_mono, [  --with-static_mono=yes,no      link mono statically to libmono (faster) (defaults to yes)],[],[with_static_mono=yes])\nAC_ARG_WITH(shared_mono, [  --with-shared_mono=yes,no      build a shared libmono library (defaults to yes)],[],[with_shared_mono=yes])\n# Same as --with-shared_mono=no\nAC_ARG_ENABLE(libraries, [  --disable-libraries disable the build of libmono], enable_libraries=$enableval, enable_libraries=yes)\n\nif test \"x$enable_static\" = \"xno\"; then\n   with_static_mono=no\nfi\n\nif test \"x$enable_shared\" = \"xno\"; then\n   with_shared_mono=no\nfi\n\nif test \"x$enable_libraries\" = \"xno\"; then\n   with_shared_mono=no\nfi\n\nAM_CONDITIONAL(DISABLE_LIBRARIES, test x$enable_libraries = xno)\n\nif test \"x$host_win32\" = \"xyes\"; then\n   # Boehm GC requires the runtime to be in its own dll\n   with_static_mono=no\nfi\n\nAM_CONDITIONAL(STATIC_MONO, test x$with_static_mono != xno)\nAM_CONDITIONAL(SHARED_MONO, test x$with_shared_mono != xno)\nAC_ARG_ENABLE(mcs-build, [  --disable-mcs-build disable the build of the mcs directory], try_mcs_build=$enableval, enable_mcs_build=yes)\nAC_ARG_ENABLE(support-build, [  --disable-support-build disable the build of the support directory], try_support_build=$enableval, enable_support_build=yes)\n\nAC_ARG_WITH(xen_opt,   [  --with-xen_opt=yes,no          Enable Xen-specific behaviour (defaults to yes)],[],[with_xen_opt=yes])\nif test \"x$with_xen_opt\" = \"xyes\" -a \"x$mono_cv_clang\" = \"xno\"; then\n\tAC_DEFINE(MONO_XEN_OPT, 1, [Xen-specific behaviour])\n\tORIG_CFLAGS=$CFLAGS\n\tCFLAGS=\"$CFLAGS -mno-tls-direct-seg-refs\"\n\tAC_MSG_CHECKING(for -mno-tls-direct-seg-refs option to gcc)\n\tAC_TRY_COMPILE([], [\n\t\treturn 0;\n\t], [\n\t   AC_MSG_RESULT(yes)\n\t   # Pass it to libgc as well\n\t   CFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -mno-tls-direct-seg-refs\"\n\t], [\n\t   AC_MSG_RESULT(no)\n\t   CFLAGS=$ORIG_CFLAGS\n\t])\nfi\n\nAC_ARG_ENABLE(small-config, [  --enable-small-config Enable tweaks to reduce requirements (and capabilities)], enable_small_config=$enableval, enable_small_config=no)\n\nif test x$enable_small_config = xyes; then\n\tAC_DEFINE(MONO_SMALL_CONFIG,1,[Reduce runtime requirements (and capabilities)])\n\tCFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DSMALL_CONFIG\"\nfi\n\nAC_ARG_ENABLE(system-aot, [  --enable-system-aot  Enable the Ahead-Of-Time compilation of system assemblies during the build (on by default on some platforms)], enable_system_aot=$enableval, enable_system_aot=default)\n\nDISABLED_FEATURES=none\ncsc_compiler=default\nendian=unknown\nAC_C_BIGENDIAN([endian=big],[endian=little],[endian=unknown])\nAC_MSG_CHECKING([CSharp compiler to use])\nAC_ARG_WITH(csc, [  --with-csc=mcs,roslyn,default      Configures the CSharp compiler to use],[\n   if test x$withval = xmcs; then\n       csc_compiler=mcs\n   elif test x$withval = xroslyn; then\n       csc_compiler=roslyn\n   elif test x$withval = xdefault; then\n       :\n   else\n       AC_MSG_ERROR([You must supply one of \"mcs\", \"roslyn\" or \"default\" to the --with-csc option])\n   fi\n],[csc_compiler=default])\n\nif test $csc_compiler = default; then\n   if test $endian = big; then\n      csc_compiler=mcs\n   elif test $endian = little; then\n      case \"$host\" in\n        powerpc*) csc_compiler=mcs ;;\n        *) csc_compiler=roslyn ;;\n      esac\n   else\n      csc_compiler=mcs\n   fi\nfi\nAC_MSG_RESULT($csc_compiler)\n\n#\n# Set the build profiles and options before things which use them\n#\n\nAC_ARG_WITH(profile4_x,          [  --with-profile4_x=yes,no            If you want to install the 4.x FX (defaults to yes)],                       [], [with_profile4_x=default])\nAC_ARG_WITH(monodroid,           [  --with-monodroid=yes,no             If you want to build the MonoDroid assemblies (defaults to no)],            [], [with_monodroid=default])\nAC_ARG_WITH(monotouch,           [  --with-monotouch=yes,no             If you want to build the Xamarin.iOS assemblies (defaults to no)],          [], [with_monotouch=default])\nAC_ARG_WITH(monotouch_watch,     [  --with-monotouch_watch=yes,no       If you want to build the Xamarin.WatchOS assemblies (defaults to no)],      [], [with_monotouch_watch=default])\nAC_ARG_WITH(monotouch_tv,        [  --with-monotouch_tv=yes,no          If you want to build the Xamarin.TVOS assemblies (defaults to no)],         [], [with_monotouch_tv=default])\nAC_ARG_WITH(bitcode,             [  --with-bitcode=yes,no               If bitcode is enabled (defaults to no)],                                    [], [with_bitcode=default])\nAC_ARG_WITH(xammac,              [  --with-xammac=yes,no                If you want to build the Xamarin.Mac assemblies (defaults to no)],          [], [with_xammac=default])\nAC_ARG_WITH(testing_aot_hybrid,  [  --with-testing_aot_hybrid=yes,no    If you want to build the testing_aot_hybrid assemblies (defaults to no)],   [], [with_testing_aot_hybrid=default])\nAC_ARG_WITH(testing_aot_full,    [  --with-testing_aot_full=yes,no      If you want to build the testing_aot_full assemblies (defaults to no)],     [], [with_testing_aot_full=default])\nAC_ARG_WITH(winaot,              [  --with-winaot=yes,no                If you want to build the Windows friendly AOT assemblies (defaults to no)], [], [with_winaot=default])\nAC_ARG_WITH(orbis,               [  --with-orbis=yes,no                 If you want to build the Orbis assemblies (defaults to no)], [], [with_orbis=default])\nAC_ARG_WITH(unreal,              [  --with-unreal=yes,no                If you want to build the Unreal assemblies (defaults to no)], [], [with_unreal=default])\nAC_ARG_WITH(wasm,                [  --with-wasm=yes,no                  If you want to build the WebAssembly (defaults to no)], [], [with_wasm=default])\n\n\nAC_ARG_WITH(runtime_preset, [  --with-runtime_preset=net_4_x,all,aot,hybridaot,fullaot,bitcode,unreal   Which default profile to build (defaults to net_4_x)],  [], [with_runtime_preset=net_4_x])\n\ndnl\ndnl Profile defaults\ndnl\nTEST_PROFILE=default\nenable_llvm_default=no\n\nwith_profile4_x_default=no\nwith_monodroid_default=no\nwith_monotouch_default=no\nwith_monotouch_watch_default=no\nwith_monotouch_tv_default=no\nwith_xammac_default=no\nwith_testing_aot_hybrid_default=no\nwith_testing_aot_full_default=no\nwith_winaot_default=no\nwith_orbis_default=no\nwith_unreal_default=no\nwith_wasm_default=no\n\nwith_bitcode_default=no\nwith_cooperative_gc_default=no\n\nINVARIANT_AOT_OPTIONS=nimt-trampolines=2000,ntrampolines=9000,nrgctx-fetch-trampolines=256,ngsharedvt-trampolines=4000\n\nAOT_BUILD_ATTRS=$INVARIANT_AOT_OPTIONS\n\nif test x$cross_compiling = xyes -o x$enable_mcs_build = xno; then\n   DISABLE_MCS_DOCS_default=yes\nelif test x$with_runtime_preset = xnet_4_x; then\n   with_profile4_x_default=yes\nelif test x$with_runtime_preset = xall; then\n   with_profile4_x_default=yes\n   with_monodroid_default=yes\n   with_monotouch_default=yes\n   with_monotouch_watch_default=yes\n   with_monotouch_tv_default=yes\n   with_xammac_default=yes\n   with_winaot_default=yes\n   with_orbis_default=yes\n   with_unreal_default=yes\n   with_wasm_default=yes\nelif test x$with_runtime_preset = xfullaot; then\n   DISABLE_MCS_DOCS_default=yes\n   with_testing_aot_full_default=yes\n   TEST_PROFILE=testing_aot_full\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile -O=gsharedvt --aot=full,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --full-aot\"\n   AOT_MODE=\"full\"\nelif test x$with_runtime_preset = xbitcode; then\n   DISABLE_MCS_DOCS_default=yes\n   with_testing_aot_full_default=yes\n   with_bitcode_default=yes\n   with_cooperative_gc_default=yes\n   TEST_PROFILE=testing_aot_full\n   enable_llvm_default=yes\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=llvmonly,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --llvmonly\"\n   AOT_MODE=\"llvmonly\"\nelif test x$with_runtime_preset = xhybridaot; then\n   DISABLE_MCS_DOCS_default=yes\n   with_testing_aot_hybrid_default=yes\n   TEST_PROFILE=testing_aot_hybrid \n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=hybrid,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --hybrid-aot\"\nelif test x$with_runtime_preset = xaot; then\n   with_profile4_x_default=yes\n\n   AOT_BUILD_FLAGS=\"--aot=$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"\"\n\n   DISABLE_MCS_DOCS_default=yes\nelif test x$with_runtime_preset = xwinaot; then\n   DISABLE_MCS_DOCS_default=yes\n   with_winaot_default=yes\n   TEST_PROFILE=winaot\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=full,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --full-aot\"\n   AOT_MODE=\"llvmonly\"\nelif test x$with_runtime_preset = xorbis; then\n   DISABLE_MCS_DOCS_default=yes\n   with_orbis_default=yes\n   TEST_PROFILE=orbis\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=full,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --full-aot\"\n   AOT_MODE=\"full\"\nelif test x$with_runtime_preset = xunreal; then\n   DISABLE_MCS_DOCS_default=yes\n   with_unreal_default=yes\n   TEST_PROFILE=unreal\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_appdomains='no'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=hybrid,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --hybrid-aot\"\nelif test x$with_runtime_preset = xwasm; then\n   DISABLE_MCS_DOCS_default=yes\n   with_wasm_default=yes\n   TEST_PROFILE=wasm\n\n   mono_feature_disable_com='yes'\n   mono_feature_disable_remoting='yes'\n   mono_feature_disable_reflection_emit_save='yes'\n   mono_feature_disable_reflection_emit='yes'\n   mono_feature_disable_appdomains='yes'\n\n   AOT_BUILD_FLAGS=\"--runtime=mobile --aot=full,$INVARIANT_AOT_OPTIONS\"\n   AOT_RUN_FLAGS=\"--runtime=mobile --full-aot\"\nelse\n   with_profile4_x_default=yes\nfi\n\nif test \"x$AOT_BUILD_FLAGS\" != \"x\"; then :\n   AC_SUBST(AOT_BUILD_FLAGS)\n   AC_SUBST(AOT_RUN_FLAGS)\n   # For llvmonlycheck + fullaotcheck\n   AC_SUBST(INVARIANT_AOT_OPTIONS)\nfi\n\nAC_SUBST(TEST_PROFILE)\n\nif test \"x$with_profile4_x\" = \"xdefault\"; then\n   with_profile4_x=$with_profile4_x_default\nfi\nif test \"x$with_monodroid\" = \"xdefault\"; then\n   with_monodroid=$with_monodroid_default\nfi\nif test \"x$with_monotouch\" = \"xdefault\"; then\n   with_monotouch=$with_monotouch_default\nfi\nif test \"x$with_monotouch_watch\" = \"xdefault\"; then\n   with_monotouch_watch=$with_monotouch_watch_default\nfi\nif test \"x$with_monotouch_tv\" = \"xdefault\"; then\n   with_monotouch_tv=$with_monotouch_tv_default\nfi\nif test \"x$with_bitcode\" = \"xdefault\"; then\n   with_bitcode=$with_bitcode_default\nfi\nif test \"x$with_xammac\" = \"xdefault\"; then\n   with_xammac=$with_xammac_default\nfi\nif test \"x$with_testing_aot_hybrid\" = \"xdefault\"; then\n   with_testing_aot_hybrid=$with_testing_aot_hybrid_default\nfi\nif test \"x$with_testing_aot_full\" = \"xdefault\"; then\n   with_testing_aot_full=$with_testing_aot_full_default\nfi\nif test \"x$with_winaot\" = \"xdefault\"; then\n   with_winaot=$with_winaot_default\nfi\nif test \"x$with_orbis\" = \"xdefault\"; then\n   with_orbis=$with_orbis_default\nfi\nif test \"x$with_unreal\" = \"xdefault\"; then\n   with_unreal=$with_unreal_default\nfi\nif test \"x$with_wasm\" = \"xdefault\"; then\n   with_wasm=$with_wasm_default\nfi\n\n\nAM_CONDITIONAL(INSTALL_4_x, [test \"x$with_profile4_x\" = \"xyes\"])\nAM_CONDITIONAL(INSTALL_MONODROID, [test \"x$with_monodroid\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_MONOTOUCH, [test \"x$with_monotouch\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_MONOTOUCH_WATCH, [test \"x$with_monotouch_watch\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_MONOTOUCH_TV, [test \"x$with_monotouch_tv\" != \"xno\"])\nAM_CONDITIONAL(BITCODE, test \"x$with_bitcode\" = \"xyes\")\nAM_CONDITIONAL(INSTALL_XAMMAC, [test \"x$with_xammac\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_TESTING_AOT_HYBRID, [test \"x$with_testing_aot_hybrid\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_TESTING_AOT_FULL, [test \"x$with_testing_aot_full\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_WINAOT, [test \"x$with_winaot\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_ORBIS, [test \"x$with_orbis\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_UNREAL, [test \"x$with_unreal\" != \"xno\"])\nAM_CONDITIONAL(INSTALL_WASM, [test \"x$with_wasm\" != \"xno\"])\nAM_CONDITIONAL(FULL_AOT_TESTS, [test \"x$TEST_PROFILE\" = \"xtesting_aot_full\"] || [test \"x$TEST_PROFILE\" = \"xwinaot\"] || [test \"x$TEST_PROFILE\" = \"xorbis\"] || [test \"x$TEST_PROFILE\" = \"xwasm\"])\nAM_CONDITIONAL(HYBRID_AOT_TESTS, [test \"x$TEST_PROFILE\" = \"xtesting_aot_hybrid\"] || [test \"x$TEST_PROFILE\" = \"xunreal\"])\n\ndefault_profile=net_4_x\nif test -z \"$INSTALL_MONODROID_TRUE\"; then :\n   default_profile=monodroid\nfi\nif test -z \"$INSTALL_MONOTOUCH_TRUE\"; then :\n   default_profile=monotouch\nfi\nif test -z \"$INSTALL_XAMMAC_TRUE\"; then :\n   default_profile=xammac\nfi\nif test -z \"$INSTALL_TESTING_AOT_HYBRID_TRUE\"; then :\n   default_profile=testing_aot_hybrid\nfi\nif test -z \"$INSTALL_TESTING_AOT_FULL_TRUE\"; then :\n   default_profile=testing_aot_full\nfi\nif test -z \"$INSTALL_WINAOT_TRUE\"; then :\n   default_profile=winaot\nfi\nif test -z \"$INSTALL_ORBIS_TRUE\"; then :\n   default_profile=orbis\nfi\nif test -z \"$INSTALL_UNREAL_TRUE\"; then :\n   default_profile=unreal\nfi\nif test -z \"$INSTALL_WASM_TRUE\"; then :\n   default_profile=wasm\nfi\nif test -z \"$INSTALL_4_x_TRUE\"; then :\n   default_profile=net_4_x\nfi\nDEFAULT_PROFILE=$default_profile\nAC_SUBST(DEFAULT_PROFILE)\n\n#\n# End build profile configuration\n#\n\nif test x$USE_NLS = xprofile_default; then\n\n\tAC_MSG_CHECKING([NLS used])\n\n\t# We make the default value for USE_NLS\n\t# \"no\" on OSX because it isn't available on most\n\t# default OSX installs. The most common configurations will\n\t# all disable it, so this saves us typing.\n\tif test x$host_darwin = xyes; then\n\t\tUSE_NLS=no;\n\telse\n\t\tUSE_NLS=yes;\n\tfi\n\n\tAC_SUBST([USE_NLS])\n\tAC_MSG_RESULT([$USE_NLS])\nfi\n\nAC_ARG_ENABLE(minimal, [  --enable-minimal=LIST      drop support for LIST subsystems.\n     LIST is a comma-separated list from: aot, profiler, decimal, pinvoke, debug, appdomains, verifier, \n     reflection_emit, reflection_emit_save, large_code, logging, com, ssa, generics, attach, jit, interpreter, simd, soft_debug, perfcounters, normalization, desktop_loader, shared_perfcounters, remoting,\n\t security, lldb, mdb, sgen_remset, sgen_marksweep_par, sgen_marksweep_fixed, sgen_marksweep_fixed_par, sgen_copying.],\n[\n\tfor feature in `echo \"$enable_minimal\" | sed -e \"s/,/ /g\"`; do\n\t\teval \"mono_feature_disable_$feature='yes'\"\n\tdone\n\tDISABLED_FEATURES=$enable_minimal\n\tdisabled=\"Disabled:      $enable_minimal\"\n],[])\n\nAC_DEFINE_UNQUOTED(DISABLED_FEATURES, \"$DISABLED_FEATURES\", [String of disabled features])\n\nif test \"x$mono_feature_disable_aot\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_AOT, 1, [Disable AOT Compiler])\n\tenable_system_aot=no\n\tAC_MSG_NOTICE([Disabled AOT compiler])\nfi\n\nif test \"x$mono_feature_disable_profiler\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_PROFILER, 1, [Disable default profiler support])\n\tAC_MSG_NOTICE([Disabled support for the profiler])\nfi\nAM_CONDITIONAL(DISABLE_PROFILER, test x$mono_feature_disable_profiler = xyes)\n\nif test \"x$mono_feature_disable_decimal\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_DECIMAL, 1, [Disable System.Decimal support])\n\tAC_MSG_NOTICE([Disabled support for decimal])\nfi\n\nif test \"x$mono_feature_disable_pinvoke\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_PINVOKE, 1, [Disable P/Invoke support])\n\tAC_MSG_NOTICE([Disabled support for P/Invoke])\nfi\n\nif test \"x$mono_feature_disable_debug\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_DEBUG, 1, [Disable runtime debugging support])\n\tAC_MSG_NOTICE([Disabled support for runtime debugging])\nfi\n\nif test \"x$mono_feature_disable_reflection_emit\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_REFLECTION_EMIT, 1, [Disable reflection emit support])\n\tmono_feature_disable_reflection_emit_save=yes\n\tAC_MSG_NOTICE([Disabled support for Reflection.Emit])\nfi\n\nif test \"x$mono_feature_disable_reflection_emit_save\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_REFLECTION_EMIT_SAVE, 1, [Disable assembly saving support in reflection emit])\n\tAC_MSG_NOTICE([Disabled support for Reflection.Emit.Save])\nfi\n\nif test \"x$mono_feature_disable_large_code\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_LARGE_CODE, 1, [Disable support for huge assemblies])\n\tAC_MSG_NOTICE([Disabled support for large assemblies])\nfi\n\nif test \"x$mono_feature_disable_logging\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_LOGGING, 1, [Disable support debug logging])\n\tAC_MSG_NOTICE([Disabled support for logging])\nfi\n\nif test \"x$mono_feature_disable_com\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_COM, 1, [Disable COM support])\n\tAC_MSG_NOTICE([Disabled COM support])\nfi\n\nif test \"x$mono_feature_disable_ssa\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SSA, 1, [Disable advanced SSA JIT optimizations])\n\tAC_MSG_NOTICE([Disabled SSA JIT optimizations])\nfi\n\nif test \"x$mono_feature_disable_generics\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_GENERICS, 1, [Disable generics support])\n\tAC_MSG_NOTICE([Disabled Generics Support])\nfi\n\nif test \"x$mono_feature_disable_shadowcopy\" = \"xyes\"; then\n   \tAC_DEFINE(DISABLE_SHADOW_COPY, 1, [Disable Shadow Copy for AppDomains])\n\tAC_MSG_NOTICE([Disabled Shadow copy for AppDomains])\nfi\n\nif test \"x$mono_feature_disable_portability\" = \"xyes\"; then\n   \tAC_DEFINE(DISABLE_PORTABILITY, 1, [Disables the IO portability layer])\n\tAC_MSG_NOTICE([Disabled IO Portability layer])\nfi\n\nif test \"x$mono_feature_disable_attach\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_ATTACH, 1, [Disable agent attach support])\n\tAC_MSG_NOTICE([Disabled agent attach])\nfi\n\nif test \"x$mono_feature_disable_verifier\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_VERIFIER, 1, [Disables the verifier])\n\tAC_MSG_NOTICE([Disabled the metadata and IL verifiers])\nfi\n\nif test \"x$mono_feature_disable_jit\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_JIT, 1, [Disable the JIT, only full-aot mode or interpreter will be supported by the runtime.])\n\tAC_MSG_NOTICE([Disabled the JIT engine, only full AOT or interpreter will be supported])\nfi\n\nAM_CONDITIONAL(DISABLE_JIT, test x$mono_feature_disable_jit = xyes)\n\nif test \"x$mono_feature_disable_interpreter\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_INTERPRETER, 1, [Disable the interpreter.])\n\tAC_MSG_NOTICE([Disabled the interpreter])\nfi\n\nAM_CONDITIONAL(DISABLE_INTERPRETER, test x$mono_feature_disable_interpreter = xyes)\n\nif test \"x$mono_feature_disable_simd\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SIMD, 1, [Disable SIMD intrinsics related optimizations.])\n\tAC_MSG_NOTICE([Disabled SIMD support])\nfi\n\nif test \"x$mono_feature_disable_soft_debug\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SOFT_DEBUG, 1, [Disable Soft Debugger Agent.])\n\tAC_MSG_NOTICE([Disabled Soft Debugger.])\nfi\n\nif test \"x$mono_feature_disable_perfcounters\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_PERFCOUNTERS, 1, [Disable Performance Counters.])\n\tAC_MSG_NOTICE([Disabled Performance Counters.])\nfi\nif test \"x$mono_feature_disable_normalization\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_NORMALIZATION, 1, [Disable String normalization support.])\n\tAC_MSG_NOTICE([Disabled String normalization support.])\nfi\n\n#TODO: remove assembly_remapping feature name once everyone is using desktop_loader\nif test \"x$mono_feature_disable_assembly_remapping\" = \"xyes\" || test \"x$mono_feature_disable_desktop_loader\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_DESKTOP_LOADER, 1, [Disable desktop assembly loader semantics.])\n\tAC_MSG_NOTICE([Disabled desktop assembly loader semantics.])\nfi\n\nif test \"x$mono_feature_disable_shared_perfcounters\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SHARED_PERFCOUNTERS, 1, [Disable shared perfcounters.])\n\tAC_MSG_NOTICE([Disabled Shared perfcounters.])\nfi\n\nif test \"x$mono_feature_disable_appdomains\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_APPDOMAINS, 1, [Disable support for multiple appdomains.])\n\tAC_MSG_NOTICE([Disabled support for multiple appdomains.])\nfi\n\nif test \"x$mono_feature_disable_remoting\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_REMOTING, 1, [Disable remoting support (This disables type proxies and make com non-functional)])\n\tAC_MSG_NOTICE([Disabled remoting])\nfi\n\nif test \"x$mono_feature_disable_security\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SECURITY, 1, [Disable CAS/CoreCLR security])\n\tAC_MSG_NOTICE([Disabled CAS/CoreCLR security manager (used e.g. for Moonlight)])\nfi\n\nif test \"x$mono_feature_disable_lldb\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_LLDB, 1, [Disable support code for the LLDB plugin.])\n\tAC_MSG_NOTICE([Disabled LLDB plugin support code.])\nfi\n\nif test \"x$mono_feature_disable_mdb\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_MDB, 1, [Disable support for .mdb symbol files.])\n\tAC_MSG_NOTICE([Disabled support for .mdb symbol files.])\nfi\n\nif test \"x$mono_feature_disable_sgen_remset\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SGEN_REMSET, 1, [Disable wbarrier=remset support in SGEN.])\n\tAC_MSG_NOTICE([Disabled wbarrier=remset support in SGEN.])\nfi\n\nif test \"x$mono_feature_disable_sgen_marksweep_par\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SGEN_MAJOR_MARKSWEEP_PAR, 1, [Disable major=marksweep-par support in SGEN.])\n\tAC_MSG_NOTICE([Disabled major=marksweep-par support in SGEN.])\nfi\n\nif test \"x$mono_feature_disable_sgen_marksweep_fixed\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SGEN_MAJOR_MARKSWEEP_FIXED, 1, [Disable major=marksweep-fixed support in SGEN.])\n\tAC_MSG_NOTICE([Disabled major=marksweep-fixed support in SGEN.])\nfi\n\nif test \"x$mono_feature_disable_sgen_marksweep_fixed_par\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SGEN_MAJOR_MARKSWEEP_FIXED_PAR, 1, [Disable major=marksweep-fixed-par support in SGEN.])\n\tAC_MSG_NOTICE([Disabled major=marksweep-fixed-par support in SGEN.])\nfi\n\nif test \"x$mono_feature_disable_sgen_copying\" = \"xyes\"; then\n\tAC_DEFINE(DISABLE_SGEN_MAJOR_COPYING, 1, [Disable major=copying support in SGEN.])\n\tAC_MSG_NOTICE([Disabled major=copying support in SGEN.])\nfi\n\nAC_ARG_ENABLE(executables, [  --disable-executables disable the build of the runtime executables], enable_executables=$enableval, enable_executables=yes)\nAM_CONDITIONAL(DISABLE_EXECUTABLES, test x$enable_executables = xno)\n\nhas_extension_module=no\nAC_ARG_ENABLE(extension-module, [  --enable-extension-module=LIST enable the core-extensions from LIST],\n[\n\tfor extension in `echo \"$enable_extension_module\" | sed -e \"s/,/ /g\"`; do\n\t\tif test x$extension = xdefault ; then\n\t\t\thas_extension_module=yes;\n\t\tfi\n\tdone\n\tif test x$enable_extension_module = xyes; then\n\t\thas_extension_module=yes;\n\tfi\n], [])\n\nAM_CONDITIONAL([HAS_EXTENSION_MODULE], [test x$has_extension_module != xno])\n\nif test x$has_extension_module != xno ; then\n\tAC_DEFINE([ENABLE_EXTENSION_MODULE], 1, [Extension module enabled])\n\tAC_MSG_NOTICE([Enabling mono extension module.])\nfi\n\n# Deprecated\nAC_ARG_ENABLE(gsharedvt, [  --enable-gsharedvt Enable generic valuetype sharing (Deprecated)], enable_gsharedvt=$enableval, enable_gsharedvt=no)\n\nAC_MSG_CHECKING(for visibility __attribute__)\nAC_COMPILE_IFELSE([\n\tAC_LANG_SOURCE([[\n\t\tvoid __attribute__ ((visibility (\"hidden\"))) doit (void) {}\n   \t\tint main () { doit (); return 0; }\n   \t]])\n], [\n   have_visibility_hidden=yes\n   AC_MSG_RESULT(yes)\n], [\n   have_visibility_hidden=no\n   AC_MSG_RESULT(no)\n])\n\ndnl\ndnl Boehm GC configuration\ndnl\n\nAC_ARG_WITH(libgc,   [  --with-libgc=included,none  Controls the Boehm GC config, default=included],[libgc=$with_libgc],[libgc=included])\n\nAC_ARG_ENABLE(boehm, [  --disable-boehm            Disable the Boehm GC.], support_boehm=$enableval,support_boehm=${support_boehm:-yes})\nAM_CONDITIONAL(SUPPORT_BOEHM, test x$support_boehm = xyes)\n\nif test \"x$support_boehm\" = \"xyes\"; then\n\n\tAC_ARG_ENABLE(parallel-mark, [  --enable-parallel-mark     Enables Boehm GC Parallel Marking], enable_parallel_mark=$enableval, enable_parallel_mark=$parallel_mark)\n\tif test x$enable_parallel_mark = xyes; then\n\t\tlibgc_configure_args=\"$libgc_configure_args --enable-parallel-mark\"\n\tfi\n\n\tgc_msg=\"\"\n\tLIBGC_CPPFLAGS=\n\tLIBGC_LIBS=\n\tLIBGC_STATIC_LIBS=\n\tlibgc_dir=\n\tcase \"x$libgc\" in\n\t\txincluded)\n\t\t\tif test \"x$support_boehm\" = \"xyes\"; then\n\t\t\t\tlibgc_dir=libgc\n\t\t\tfi\n\n\t\t\tLIBGC_CPPFLAGS='-I$(top_srcdir)/libgc/include'\n\t\t\tLIBGC_LIBS='$(top_builddir)/libgc/libmonogc.la'\n\t\t\tLIBGC_STATIC_LIBS='$(top_builddir)/libgc/libmonogc-static.la'\n\n\t\t\tBOEHM_DEFINES=\"-DHAVE_BOEHM_GC\"\n\n\t\t\tif test x$target_win32 = xyes; then\n\t\t\t\tBOEHM_DEFINES=\"$BOEHM_DEFINES -DGC_NOT_DLL\"\n\t\t\t\tCFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DGC_BUILD -DGC_NOT_DLL\"\n\t\t\tfi\n\n\t\t\tgc_msg=\"Included Boehm GC with typed GC\"\n\t\t\tif test x$enable_parallel_mark = xyes; then\n\t\t\t\tAC_DEFINE_UNQUOTED(DEFAULT_GC_NAME, \"Included Boehm (with typed GC and Parallel Mark)\", [GC description])\n\t\t\t\tgc_msg=\"$gc_msg and parallel mark\"\n\t\t\telse\n\t\t\t\tAC_DEFINE_UNQUOTED(DEFAULT_GC_NAME, \"Included Boehm (with typed GC)\", [GC description])\n\t\t\tfi\n\t\t\t;;\n\n\t\txboehm|xbohem|xyes)\n\t\t\tAC_MSG_WARN(\"External Boehm is no longer supported\")\n\t\t\t;;\n\n\t\txsgen)\n\t\t\tAC_MSG_WARN(\"Use --with-sgen instead, --with-libgc= controls Boehm configuration\")\n\t\t\t;;\n\n\t\txnone)\n\t\t\tAC_MSG_WARN(\"Compiling mono without GC.\")\n\t\t\tAC_DEFINE_UNQUOTED(DEFAULT_GC_NAME, \"none\", [GC description])\n\t\t\tAC_DEFINE(HAVE_NULL_GC,1,[No GC support.])\n\t\t\tgc_msg=\"none\"\n\t\t\t;;\n\t\t*)\n\t\t\tAC_MSG_ERROR([Invalid argument $libgc to --with-libgc.])\n\t\t\t;;\n\tesac\n\n\tAC_ARG_WITH(large-heap, [  --with-large-heap=yes,no       Enable support for GC heaps larger than 3GB (defaults to no)], [large_heap=$withval], [large_heap=no])\n\tif test \"x$large_heap\" = \"xyes\"; then\n\t   CPPFLAGS=\"$CPPFLAGS -DLARGE_CONFIG\"\n\tfi\n\n\tAC_SUBST(LIBGC_CPPFLAGS)\n\tAC_SUBST(LIBGC_LIBS)\n\tAC_SUBST(LIBGC_STATIC_LIBS)\n\tAC_SUBST(libgc_dir)\n\tAC_SUBST(BOEHM_DEFINES)\n\nfi\nAM_CONDITIONAL(SUPPORT_NULLGC, test \"x$libgc\" = \"xnone\")\n\ndnl\ndnl End of Boehm GC Configuration\ndnl\n\ndnl *************************************\ndnl *** Checks for zero length arrays ***\ndnl *************************************\nAC_MSG_CHECKING(whether $CC supports zero length arrays)\nAC_TRY_COMPILE([\n\tstruct s {\n\t\tint  length;\n\t\tchar data [0];\n\t};\n], [], [\n\tAC_MSG_RESULT(yes)\n\tAC_DEFINE_UNQUOTED(MONO_ZERO_LEN_ARRAY, 0, [Length of zero length arrays])\n], [\n\tAC_MSG_RESULT(no)\n\tAC_DEFINE_UNQUOTED(MONO_ZERO_LEN_ARRAY, 1, [Length of zero length arrays])\n])\n\ndnl ***********************************\ndnl *** Checks for signals\ndnl ***********************************\nAC_CHECK_HEADERS(signal.h)\nAC_CHECK_FUNCS(sigaction)\nAC_CHECK_FUNCS(kill)\nAC_CHECK_FUNCS(signal)\n\n# signal() is declared inline in Android headers\n# so we need to workaround it by overriding the check.\nif test x$platform_android = xyes; then\n\tAC_DEFINE(HAVE_SIGNAL,1)\nfi\n\nif test x$host_win32 = xno; then\n\tdnl *************************************\n\tdnl *** Checks for time capabilities ***\n\tdnl *************************************\n\n\tAC_MSG_CHECKING(for CLOCK_MONOTONIC)\n\tAC_TRY_COMPILE([#include <time.h>], [\n\t\tconst int foo = CLOCK_MONOTONIC;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_CLOCK_MONOTONIC, 1, [CLOCK_MONOTONIC])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_MSG_CHECKING(for CLOCK_MONOTONIC_COARSE)\n\tAC_TRY_COMPILE([#include <time.h>], [\n\t\tconst int foo = CLOCK_MONOTONIC_COARSE;\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_CLOCK_MONOTONIC_COARSE, 1, [CLOCK_MONOTONIC_COARSE])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_CHECK_FUNC(mach_absolute_time, [AC_DEFINE(HAVE_MACH_ABSOLUTE_TIME, 1, [mach_absolute_time])])\n\tAC_CHECK_FUNC(gethrtime, [AC_DEFINE(HAVE_GETHRTIME, 1, [gethrtime])])\n\tAC_CHECK_FUNC(read_real_time, [AC_DEFINE(HAVE_READ_REAL_TIME, 1, [read_real_time])])\n\n\tdnl hires monotonic clock support\n\tAC_SEARCH_LIBS(clock_gettime, rt)\n\tAC_CHECK_FUNCS(clock_nanosleep)\n\n\tdnl dynamic loader support\n\tAC_CHECK_FUNC(dlopen, DL_LIB=\"\",\n\t\tAC_CHECK_LIB(dl, dlopen, DL_LIB=\"-ldl\", dl_support=no)\n\t)\n\tif test x$dl_support = xno; then\n\t\tAC_MSG_WARN([No dynamic loading support available])\n\telse\n\t\tLIBS=\"$LIBS $DL_LIB\"\n\t\tAC_DEFINE(HAVE_DL_LOADER,1,[dlopen-based dynamic loader available])\n\t\tdnl from glib's configure.ac\n\t\tAC_CACHE_CHECK([for preceeding underscore in symbols],\n\t\t\tmono_cv_uscore,[\n\t\t\tAC_TRY_RUN([#include <dlfcn.h>\n\t\t\tint mono_underscore_test (void) { return 42; }\n\t\t\tint main() {\n\t\t\t  void *f1 = (void*)0, *f2 = (void*)0, *handle;\n\t\t\t  handle = dlopen ((void*)0, 0);\n\t\t\t  if (handle) {\n\t\t\t    f1 = dlsym (handle, \"mono_underscore_test\");\n\t\t\t    f2 = dlsym (handle, \"_mono_underscore_test\");\n\t\t\t  } return (!f2 || f1);\n\t\t\t}],\n\t\t\t\t[mono_cv_uscore=yes],\n\t\t\t\t[mono_cv_uscore=no],\n\t\t\t[])\n\t\t])\n\t\tif test \"x$mono_cv_uscore\" = \"xyes\"; then\n\t\t\tMONO_DL_NEED_USCORE=1\n\t\telse\n\t\t\tMONO_DL_NEED_USCORE=0\n\t\tfi\n\t\tAC_SUBST(MONO_DL_NEED_USCORE)\n\t\tAC_CHECK_FUNC(dlerror)\n\tfi\n\n\tdnl ******************************************************************\n\tdnl *** Checks for the IKVM JNI interface library                  ***\n\tdnl ******************************************************************\n\tAC_ARG_WITH(ikvm-native, [  --with-ikvm-native=yes,no      build the IKVM JNI interface library (defaults to yes)],[with_ikvm_native=$withval],[with_ikvm_native=$ikvm_native])\n\n\tikvm_native_dir=\n\tif test x$with_ikvm_native = xyes; then\n\t\tikvm_native_dir=ikvm-native\n\t\tjdk_headers_found=\"IKVM Native\"\n\tfi\n\n\tAC_SUBST(ikvm_native_dir)\n\n\tAC_CHECK_HEADERS(execinfo.h)\n\n\tAC_CHECK_HEADERS(sys/auxv.h sys/resource.h)\n\n\tAC_CHECK_FUNCS(getgrgid_r)\n\tAC_CHECK_FUNCS(getgrnam_r)\n\tAC_CHECK_FUNCS(getresuid)\n\tAC_CHECK_FUNCS(setresuid)\n\tAC_CHECK_FUNCS(kqueue)\n\tAC_CHECK_FUNCS(backtrace_symbols)\n\tAC_CHECK_FUNCS(mkstemp)\n\tAC_CHECK_FUNCS(mmap)\n\tAC_CHECK_FUNCS(madvise)\n\tAC_CHECK_FUNCS(getrusage)\n\tAC_CHECK_FUNCS(getpriority)\n\tAC_CHECK_FUNCS(setpriority)\n\tAC_CHECK_FUNCS(dl_iterate_phdr)\n\tAC_CHECK_FUNCS(dladdr)\n\tAC_CHECK_FUNCS(sysconf)\n\tAC_CHECK_FUNCS(getrlimit)\n\tAC_CHECK_FUNCS(prctl)\n\n\tAC_CHECK_FUNCS(sched_getaffinity)\n\tAC_CHECK_FUNCS(sched_setaffinity)\n\tAC_CHECK_FUNCS(sched_getcpu)\n\n\tif test x$platform_android != xyes; then\n\t\tAC_CHECK_FUNCS(getpwnam_r)\n\t\tAC_CHECK_FUNCS(getpwuid_r)\n\tfi\n\n\tAC_FUNC_STRERROR_R()\n\n\tdnl ****************************************************************\n\tdnl *** Check for sched_setaffinity from glibc versions before   ***\n\tdnl *** 2.3.4. The older versions of the function only take 2    ***\n\tdnl *** parameters, not 3.                                       ***\n\tdnl ***                                                          ***\n\tdnl *** Because the interface change was not made in a minor     ***\n\tdnl *** version rev, the __GLIBC__ and __GLIBC_MINOR__ macros    ***\n\tdnl *** won't always indicate the interface sched_affinity has.  ***\n\tdnl ****************************************************************\n\tAC_MSG_CHECKING(for sched_setaffinity from glibc < 2.3.4)\n\tAC_TRY_COMPILE([#include <sched.h>], [\n            int mask = 1; \n            sched_setaffinity(0, &mask);\n\t\t\treturn 0;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(GLIBC_BEFORE_2_3_4_SCHED_SETAFFINITY, 1, [Have GLIBC_BEFORE_2_3_4_SCHED_SETAFFINITY])\n\t], [\n\t\t# We have the new, three-parameter version\n\t\tAC_MSG_RESULT(no)\n\t])\n\tAC_TRY_COMPILE([#include <sched.h>], [\n\t     CPU_COUNT((void *) 0);\n\t], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(GLIBC_HAS_CPU_COUNT, 1, [GLIBC has CPU_COUNT macro in sched.h])\n\t], [\n\t\t# We have the new, three-parameter version\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl ******************************************************************\n\tdnl *** Check for large file support                               ***\n\tdnl *** (If we were using autoconf 2.50 we'd use AC_SYS_LARGEFILE) ***\n\tdnl ******************************************************************\n\t\n\t# Check that off_t can represent 2**63 - 1 correctly, working around\n\t# potential compiler bugs.  Defines LARGE_FILE_SUPPORT, adds $1 to\n\t# CPPFLAGS and sets $large_offt to yes if the test succeeds\n\tlarge_offt=no\n\tAC_DEFUN([LARGE_FILES], [\n\t\tlarge_CPPFLAGS=$CPPFLAGS\n\t\tCPPFLAGS=\"$CPPFLAGS $1\"\n\t\tAC_TRY_COMPILE([\n\t\t\t#include <sys/types.h>\n\t\t\t#include <limits.h>\n\t\t], [\n\t\t\t/* Lifted this compile time assert method from: http://www.jaggersoft.com/pubs/CVu11_3.html */\n\t\t\t#define COMPILE_TIME_ASSERT(pred) \\\n\t\t\t\tswitch(0){case 0:case pred:;}\n\t\t\tCOMPILE_TIME_ASSERT(sizeof(off_t) * CHAR_BIT == 64);\n\t\t], [\n\t\t\tAC_MSG_RESULT(ok)\n\t\t\tAC_DEFINE(HAVE_LARGE_FILE_SUPPORT, 1, [Have large file support])\n\t\t\tlarge_CPPFLAGS=\"$large_CPPFLAGS $1\"\n\t\t\tlarge_offt=yes\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\t\tCPPFLAGS=$large_CPPFLAGS\n\t])\n\n\tAC_MSG_CHECKING(if off_t is 64 bits wide)\n\tLARGE_FILES(\"\")\n\tif test $large_offt = no; then\n\t\tAC_MSG_CHECKING(if _FILE_OFFSET_BITS=64 gives 64 bit off_t)\n\t\tLARGE_FILES(\"-D_FILE_OFFSET_BITS=64\")\n\tfi\n\tif test $large_offt = no; then\n\t\tAC_MSG_WARN([No 64 bit file size support available])\n\tfi\n\t\n\tdnl *****************************\n\tdnl *** Checks for libsocket  ***\n\tdnl *****************************\n\tAC_CHECK_LIB(socket, socket, LIBS=\"$LIBS -lsocket\")\n\n\tcase \"$host\" in\n\t\t*-*-*freebsd*)\n\t\t\tdnl *****************************\n\t\t\tdnl *** Checks for libinotify ***\n\t\t\tdnl *****************************\n\t\t\tAC_CHECK_LIB(inotify, inotify_init, LIBS=\"$LIBS -linotify\")\n\tesac\n\n\tdnl *******************************\n\tdnl *** Checks for MSG_NOSIGNAL ***\n\tdnl *******************************\n\tAC_MSG_CHECKING(for MSG_NOSIGNAL)\n\tAC_TRY_COMPILE([#include <sys/socket.h>], [\n\t\tint f = MSG_NOSIGNAL;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_MSG_NOSIGNAL, 1, [Have MSG_NOSIGNAL])\n\t], [\n\t\t# We'll have to use signals\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for IPPROTO_IP ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for IPPROTO_IP)\n\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\tint level = IPPROTO_IP;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IPPROTO_IP, 1, [Have IPPROTO_IP])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *******************************\n\tdnl *** Checks for IPPROTO_IPV6 ***\n\tdnl *******************************\n\tAC_MSG_CHECKING(for IPPROTO_IPV6)\n\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\tint level = IPPROTO_IPV6;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IPPROTO_IPV6, 1, [Have IPPROTO_IPV6])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl ******************************\n\tdnl *** Checks for IPPROTO_TCP ***\n\tdnl ******************************\n\tAC_MSG_CHECKING(for IPPROTO_TCP)\n\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\tint level = IPPROTO_TCP;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IPPROTO_TCP, 1, [Have IPPROTO_TCP])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for SOL_IP     ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for SOL_IP)\n\tAC_TRY_COMPILE([#include <netdb.h>], [\n\t\tint level = SOL_IP;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SOL_IP, 1, [Have SOL_IP])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for SOL_IPV6     ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for SOL_IPV6)\n\tAC_TRY_COMPILE([#include <netdb.h>], [\n\t\tint level = SOL_IPV6;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SOL_IPV6, 1, [Have SOL_IPV6])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for SOL_TCP    ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for SOL_TCP)\n\tAC_TRY_COMPILE([#include <netdb.h>], [\n\t\tint level = SOL_TCP;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SOL_TCP, 1, [Have SOL_TCP])\n\t], [\n\t\t# We'll have to use getprotobyname\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for IP_PKTINFO ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for IP_PKTINFO)\n\tAC_TRY_COMPILE([#include <linux/in.h>], [\n\t\tint level = IP_PKTINFO;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_PKTINFO, 1, [Have IP_PKTINFO])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for IPV6_PKTINFO ***\n\tdnl *****************************\n\tAC_MSG_CHECKING(for IPV6_PKTINFO)\n\tAC_TRY_COMPILE([#include <netdb.h>], [\n\t\tint level = IPV6_PKTINFO;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IPV6_PKTINFO, 1, [Have IPV6_PKTINFO])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Checks for IP_DONTFRAG     ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for IP_DONTFRAG)\n\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\tint level = IP_DONTFRAG;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_DONTFRAG, 1, [Have IP_DONTFRAG])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Checks for IP_DONTFRAGMENT ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for IP_DONTFRAGMENT)\n\tAC_TRY_COMPILE([#include <Ws2ipdef.h>], [\n\t\tint level = IP_DONTFRAGMENT;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_DONTFRAGMENT, 1, [Have IP_DONTFRAGMENT])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Checks for IP_MTU_DISCOVER ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for IP_MTU_DISCOVER)\n\tAC_TRY_COMPILE([#include <linux/in.h>], [\n\t\tint level = IP_MTU_DISCOVER;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_MTU_DISCOVER, 1, [Have IP_MTU_DISCOVER])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Checks for  IP_PMTUDISC_DO ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for IP_PMTUDISC_DO)\n\tAC_TRY_COMPILE([#include <linux/in.h>], [\n\t\tint level = IP_PMTUDISC_DO;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IP_PMTUDISC_DO, 1, [Have IP_PMTUDISC_DO])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n \tdnl *********************************\n\tdnl *** Check for struct ip_mreqn ***\n\tdnl *********************************\n\tAC_MSG_CHECKING(for struct ip_mreqn)\n\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\tstruct ip_mreqn mreq;\n\t\tmreq.imr_address.s_addr = 0;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_STRUCT_IP_MREQN, 1, [Have struct ip_mreqn])\n\t], [\n\t\t# We'll just have to try and use struct ip_mreq\n\t\tAC_MSG_RESULT(no)\n\t\tAC_MSG_CHECKING(for struct ip_mreq)\n\t\tAC_TRY_COMPILE([#include <netinet/in.h>], [\n\t\t\tstruct ip_mreq mreq;\n\t\t\tmreq.imr_interface.s_addr = 0;\n\t\t], [\n\t\t\t# Yes, we have it...\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_STRUCT_IP_MREQ, 1, [Have struct ip_mreq])\n\t\t], [\n\t\t\t# No multicast support\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\t])\n\t\n\tdnl **********************************\n\tdnl *** Check for getaddrinfo ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getaddrinfo)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgetaddrinfo(NULL,NULL,NULL,NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETADDRINFO, 1, [Have getaddrinfo])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for gethostbyname2_r ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for gethostbyname2_r)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\n\t\tgethostbyname2_r(NULL,0,NULL,NULL,0,NULL,NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETHOSTBYNAME2_R, 1, [Have gethostbyname2_r])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for gethostbyname2 ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for gethostbyname2)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgethostbyname2(NULL,0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETHOSTBYNAME2, 1, [Have gethostbyname2])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for gethostbyname ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for gethostbyname)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgethostbyname(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETHOSTBYNAME, 1, [Have gethostbyname])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getprotobyname ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getprotobyname)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgetprotobyname(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETPROTOBYNAME, 1, [Have getprotobyname])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getnameinfo ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getnameinfo)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <netdb.h>\n\t], [\n\t\tgetnameinfo (NULL, 0, NULL, 0, NULL, 0, 0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETNAMEINFO, 1, [Have getnameinfo])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\n\tdnl **********************************\n\tdnl *** Check for inet_ntop ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for inet_ntop)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <arpa/inet.h>\n\t], [\n\t\tinet_ntop (0, NULL, NULL, 0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_INET_NTOP, 1, [Have inet_ntop])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl *****************************\n\tdnl *** Checks for libnsl     ***\n\tdnl *****************************\n\tAC_CHECK_FUNC(gethostbyaddr, , AC_CHECK_LIB(nsl, gethostbyaddr, LIBS=\"$LIBS -lnsl\"))\n\n\tAC_CHECK_FUNCS(inet_pton inet_aton)\n\n\tdnl *****************************\n\tdnl *** Checks for libxnet    ***\n\tdnl *****************************\n\tcase \"${host}\" in\n\t\t*solaris* )\n\t\t\tAC_MSG_CHECKING(for Solaris XPG4 support)\n\t\t\tif test -f /usr/lib/libxnet.so; then\n\t\t\t\tCPPFLAGS=\"$CPPFLAGS -D_XOPEN_SOURCE=500\"\n\t    \t\t\tCPPFLAGS=\"$CPPFLAGS -D__EXTENSIONS__\"\n\t\t\t\tCPPFLAGS=\"$CPPFLAGS -D_XOPEN_SOURCE_EXTENDED=1\"\n           \t\t\tLIBS=\"$LIBS -lxnet\"\n  \t    \t\t\tAC_MSG_RESULT(yes)\n\t\t\telse\n  \t    \t\t\tAC_MSG_RESULT(no)\n\t\t\tfi\n\n\t\t\tif test \"$GCC\" = \"yes\"; then\n\t\t    \t\tCFLAGS=\"$CFLAGS -Wno-char-subscripts\"\n\t\t\tfi\n    \t\t;;\n\tesac\n\n\tdnl *****************************\n\tdnl *** Checks for libpthread ***\n\tdnl *****************************\n# on FreeBSD -STABLE, the pthreads functions all reside in libc_r\n# and libpthread does not exist\n#\n\tcase \"${host}\" in\n\t\t*-*-*haiku*)\n\t\t\tdnl Haiku has pthread in libroot (libc equiv)\n\t\t\tAC_CHECK_LIB(pthread, main, LIBS=\"$LIBS\")\n\t\t;;\n\t\t*-*-*freebsd*)\n\t\t\tAC_CHECK_LIB(pthread, main, LIBS=\"$LIBS -pthread\")\n\t\t;;\n\t\t*-*-*openbsd*)\n\t\t\tAC_CHECK_LIB(pthread, main, LIBS=\"$LIBS -pthread\")\n\t\t;;\n\t\t*)\n\t\t\tAC_CHECK_LIB(pthread, main, LIBS=\"$LIBS -lpthread\")\n\t\t;;\n\tesac\n\tAC_CHECK_HEADERS(pthread.h)\n\tAC_CHECK_HEADERS(pthread_np.h)\n\tAC_CHECK_FUNCS(pthread_mutex_timedlock)\n\tAC_CHECK_FUNCS(pthread_getattr_np pthread_attr_get_np pthread_setname_np pthread_cond_timedwait_relative_np)\n\tAC_CHECK_FUNCS(pthread_kill)\n\tAC_MSG_CHECKING(for PTHREAD_MUTEX_RECURSIVE)\n\tAC_TRY_COMPILE([ #include <pthread.h>], [\n\t\tpthread_mutexattr_t attr;\n\t\tpthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n\t], [\n\t\tAC_MSG_RESULT(ok)\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t\tAC_ERROR(Posix system lacks support for recursive mutexes)\n\t])\n\tAC_CHECK_FUNCS(pthread_attr_setstacksize)\n\tAC_CHECK_FUNCS(pthread_attr_getstack pthread_attr_getstacksize)\n\tAC_CHECK_FUNCS(pthread_get_stacksize_np pthread_get_stackaddr_np)\n\n\tdnl **********************************\n\tdnl *** Check for mincore ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for mincore)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <sys/types.h>\n\t\t#include <sys/mman.h>\n\t], [\n\t\tmincore(NULL, 0, NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_MINCORE, 1, [Have mincore])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl ***********************************\n\tdnl *** Checks for working __thread ***\n\tdnl ***********************************\n\tAC_MSG_CHECKING(for working __thread)\n\tif test \"x$with_tls\" != \"x__thread\"; then\n\t\tAC_MSG_RESULT(disabled)\n\telif test \"x$cross_compiling\" = \"xyes\"; then\n\t\tAC_MSG_RESULT(cross compiling, assuming yes)\n\telse\n\t\tAC_TRY_RUN([\n\t\t\t#if defined(__APPLE__) && defined(__clang__)\n\t\t\t#error \"__thread does not currently work with clang on Mac OS X\"\n\t\t\t#endif\n\t\t\t\n\t\t\t#include <pthread.h>\n\t\t\t__thread int i;\n\t\t\tstatic int res1, res2;\n\n\t\t\tvoid thread_main (void *arg)\n\t\t\t{\n\t\t\t\ti = arg;\n\t\t\t\tsleep (1);\n\t\t\t\tif (arg == 1)\n\t\t\t\t\tres1 = (i == arg);\n\t\t\t\telse\n\t\t\t\t\tres2 = (i == arg);\n\t\t\t}\n\n\t\t\tint main () {\n\t\t\t\tpthread_t t1, t2;\n\n\t\t\t\ti = 5;\n\n\t\t\t\tpthread_create (&t1, NULL, thread_main, 1);\n\t\t\t\tpthread_create (&t2, NULL, thread_main, 2);\n\n\t\t\t\tpthread_join (t1, NULL);\n\t\t\t\tpthread_join (t2, NULL);\n\n\t\t\t\treturn !(res1 + res2 == 2);\n\t\t\t}\n\t\t], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t], [\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\twith_tls=pthread\n\t\t])\n\tfi\n\n\tdnl **************************************\n\tdnl *** Checks for working sigaltstack ***\n\tdnl **************************************\n\tAC_MSG_CHECKING(for working sigaltstack)\n\tif test \"x$with_sigaltstack\" != \"xyes\"; then\n\t\tAC_MSG_RESULT(disabled)\n\telif test \"x$cross_compiling\" = \"xyes\"; then\n\t\tAC_MSG_RESULT(cross compiling, assuming yes)\n\telse\n\t\tAC_TRY_RUN([\n\t\t\t#include <stdio.h>\n\t\t\t#include <stdlib.h>\n\t\t\t#include <unistd.h>\n\t\t\t#include <signal.h>\n\t\t\t#include <pthread.h>\n\t\t\t#include <sys/wait.h>\n\t\t\t#if defined(__FreeBSD__) || defined(__NetBSD__)\n\t\t\t#define SA_STACK SA_ONSTACK\n\t\t\t#endif\n\t\t\tstatic void\n\t\t\tsigsegv_signal_handler (int _dummy, siginfo_t *info, void *context)\n\t\t\t{\n\t\t\t\texit (0);\n\t\t\t}\n\n\t\t\tvolatile char*__ptr = NULL;\n\t\t\tstatic void *\n\t\t\tloop (void *ignored)\n\t\t\t{\n\t\t\t\t*__ptr = 0;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tstatic void\n\t\t\tchild ()\n\t\t\t{\n\t\t\t\tstruct sigaction sa;\n\t\t\t#ifdef __APPLE__\n\t\t\t\tstack_t sas;\n\t\t\t#else\n\t\t\t\tstruct sigaltstack sas;\n\t\t\t#endif\n\t\t\t\tpthread_t id;\n\t\t\t\tpthread_attr_t attr;\n\n\t\t\t\tsa.sa_sigaction = sigsegv_signal_handler;\n\t\t\t\tsigemptyset (&sa.sa_mask);\n\t\t\t\tsa.sa_flags = SA_SIGINFO | SA_ONSTACK;\n\t\t\t\tif (sigaction (SIGSEGV, &sa, NULL) == -1) {\n\t\t\t\t\tperror (\"sigaction\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t/* x86 darwin deliver segfaults using SIGBUS */\n\t\t\t\tif (sigaction (SIGBUS, &sa, NULL) == -1) {\n\t\t\t\t\tperror (\"sigaction\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsas.ss_sp = malloc (SIGSTKSZ);\n\t\t\t\tsas.ss_size = SIGSTKSZ;\n\t\t\t\tsas.ss_flags = 0;\n\t\t\t\tif (sigaltstack (&sas, NULL) == -1) {\n\t\t\t\t\tperror (\"sigaltstack\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tpthread_attr_init (&attr);\n\t\t\t\tif (pthread_create(&id, &attr, loop, &attr) != 0) {\n\t\t\t\t\tprintf (\"pthread_create\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tsleep (100);\n\t\t\t}\n\n\t\t\tint\n\t\t\tmain ()\n\t\t\t{\n\t\t\t\tpid_t son;\n\t\t\t\tint status;\n\t\t\t\tint i;\n\n\t\t\t\tson = fork ();\n\t\t\t\tif (son == -1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (son == 0) {\n\t\t\t\t\tchild ();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 300; ++i) {\n\t\t\t\t\twaitpid (son, &status, WNOHANG);\n\t\t\t\t\tif (WIFEXITED (status) && WEXITSTATUS (status) == 0)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tusleep (10000);\n\t\t\t\t}\n\n\t\t\t\tkill (son, SIGKILL);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_WORKING_SIGALTSTACK, 1, [Have a working sigaltstack])\n\t\t], [\n\t\t\t\twith_sigaltstack=no\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\tfi\n\n\tdnl ********************************\n\tdnl *** Checks for semaphore lib ***\n\tdnl ********************************\n\t# 'Real Time' functions on Solaris\n\t# posix4 on Solaris 2.6\n\t# pthread (first!) on Linux\n\tAC_SEARCH_LIBS(sem_init, pthread rt posix4) \n\n\tAC_SEARCH_LIBS(shm_open, pthread rt posix4) \n\tAC_CHECK_FUNCS(shm_open)\n\n\tdnl ********************************\n\tdnl *** Checks for timezone stuff **\n\tdnl ********************************\n\tAC_CACHE_CHECK(for tm_gmtoff in struct tm, ac_cv_struct_tm_gmtoff,\n\t\tAC_TRY_COMPILE([\n\t\t\t#include <time.h>\n\t\t\t], [\n\t\t\tstruct tm tm;\n\t\t\ttm.tm_gmtoff = 1;\n\t\t\t], ac_cv_struct_tm_gmtoff=yes, ac_cv_struct_tm_gmtoff=no))\n\tif test $ac_cv_struct_tm_gmtoff = yes; then\n\t\tAC_DEFINE(HAVE_TM_GMTOFF, 1, [Have tm_gmtoff])\n\telse\n\t\tAC_CACHE_CHECK(for timezone variable, ac_cv_var_timezone,\n\t\t\tAC_TRY_COMPILE([\n\t\t\t\t#include <time.h>\n\t\t\t], [\n\t\t\t\ttimezone = 1;\n\t\t\t], ac_cv_var_timezone=yes, ac_cv_var_timezone=no))\n\t\tif test $ac_cv_var_timezone = yes; then\n\t\t\tAC_DEFINE(HAVE_TIMEZONE, 1, [Have timezone variable])\n\t\telse\n\t\t\tAC_ERROR(unable to find a way to determine timezone)\n\t\tfi\n\tfi\n\n\tdnl *********************************\n\tdnl *** Checks for math functions ***\n\tdnl *********************************\n\tAC_SEARCH_LIBS(sqrtf, m)\n\tif test \"x$has_broken_apple_cpp\" != \"xyes\"; then\n\t        AC_CHECK_FUNCS(finite, , AC_MSG_CHECKING(for finite in math.h)\n\t                AC_TRY_LINK([#include <math.h>], \n\t                [ finite(0.0); ], \n\t                AC_DEFINE(HAVE_FINITE, 1, [Have finite in -lm]) AC_MSG_RESULT(yes),\n\t                AC_MSG_RESULT(no)))\n\tfi\n        AC_CHECK_FUNCS(isfinite, , AC_MSG_CHECKING(for isfinite in math.h)\n                AC_TRY_LINK([#include <math.h>], \n                [ isfinite(0.0); ], \n                AC_DEFINE(HAVE_ISFINITE, 1, [Have isfinite]) AC_MSG_RESULT(yes),\n                AC_MSG_RESULT(no)))\n\n\tdnl ****************************************************************\n\tdnl *** Checks for working poll() (macosx defines it but doesn't ***\n\tdnl *** have it in the library (duh))                            ***\n\tdnl ****************************************************************\n\tAC_CHECK_FUNCS(poll)\n\n\tdnl *************************\n\tdnl *** Check for signbit ***\n\tdnl *************************\n\tAC_MSG_CHECKING(for signbit)\n\tAC_TRY_LINK([#include <math.h>], [\n\t\tint s = signbit(1.0);\n\t], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SIGNBIT, 1, [Have signbit])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t]) \n\n\tdnl **********************************\n\tdnl *** epoll\t\t\t   ***\n\tdnl **********************************\n\tAC_CHECK_HEADERS(sys/epoll.h)\n\thaveepoll=no\n\tAC_CHECK_FUNCS(epoll_ctl, [haveepoll=yes], )\n\tif test \"x$haveepoll\" = \"xyes\" -a \"x$ac_cv_header_sys_epoll_h\" = \"xyes\"; then\n\t\tAC_DEFINE(HAVE_EPOLL, 1, [epoll supported])\n\tfi\n\n\thavekqueue=no\n\n\tAC_CHECK_HEADERS(sys/event.h)\n\tAC_CHECK_FUNCS(kqueue, [havekqueue=yes], )\n\n\tdnl **************************************\n\tdnl * Darwin has a race that prevents us from using reliably:\n\tdnl * http://lists.apple.com/archives/darwin-dev/2011/Jun/msg00016.html\n\tdnl * Since kqueue is mostly used for scaling large web servers, \n\tdnl * and very few folks run Mono on large web servers on OSX, falling\n\tdnl * back \n\tdnl **************************************\n\tif test \"x$havekqueue\" = \"xyes\" -a \"x$ac_cv_header_sys_event_h\" = \"xyes\"; then\n\t\tif test \"x$host_darwin\" = \"xno\"; then\n\t\t\tAC_DEFINE(USE_KQUEUE_FOR_THREADPOOL, 1, [Use kqueue for the threadpool])\n\t\tfi\n\tfi\n\n\tdnl ******************************\n\tdnl *** Checks for SIOCGIFCONF ***\n\tdnl ******************************\n\tAC_CHECK_HEADERS(sys/ioctl.h)\n\tAC_CHECK_HEADERS(net/if.h, [], [],\n\t   [\n\t   #ifdef HAVE_SYS_TYPES_H\n\t   # include <sys/types.h>\n\t   #endif\n\t   #ifdef HAVE_SYS_SOCKET_H\n\t   # include <sys/socket.h>\n\t   #endif\n\t   ])\n\tAC_MSG_CHECKING(for ifreq)\n\tAC_TRY_COMPILE([\n\t\t#include <stdio.h>\n\t\t#include <sys/ioctl.h>\n\t\t#include <net/if.h>\n\t\t], [\n\t\tstruct ifconf ifc;\n\t\tstruct ifreq *ifr;\n\t\tvoid *x;\n\t\tifc.ifc_len = 0;\n\t\tifc.ifc_buf = NULL;\n\t\tx = (void *) &ifr->ifr_addr;\n\t\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SIOCGIFCONF, 1, [Can get interface list])\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\tdnl **********************************\n\tdnl ***     Checks for sin_len     ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for sockaddr_in.sin_len)\n\tAC_TRY_COMPILE([\n\t\t#include <netinet/in.h>\n\t\t], [\n\t\tstruct sockaddr_in saddr;\n\t\tsaddr.sin_len = sizeof (saddr);\n\t\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SOCKADDR_IN_SIN_LEN, 1, [sockaddr_in has sin_len])\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\t\n\tdnl **********************************\n\tdnl ***    Checks for sin6_len     ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for sockaddr_in6.sin6_len)\n\tAC_TRY_COMPILE([\n\t\t#include <netinet/in.h>\n\t\t], [\n\t\tstruct sockaddr_in6 saddr6;\n\t\tsaddr6.sin6_len = sizeof (saddr6);\n\t\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SOCKADDR_IN6_SIN_LEN, 1, [sockaddr_in6 has sin6_len])\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\tdnl **********************************\n\tdnl *** Check for getifaddrs       ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getifaddrs)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <sys/types.h>\n\t\t#include <sys/socket.h>\n\t\t#include <ifaddrs.h>\n\t], [\n\t\tgetifaddrs(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETIFADDRS, 1, [Have getifaddrs])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\tdnl **********************************\n\tdnl *** Check for if_nametoindex   ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for if_nametoindex)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <sys/types.h>\n\t\t#include <sys/socket.h>\n\t\t#include <net/if.h>\n\t], [\n\t\tif_nametoindex(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IF_NAMETOINDEX, 1, [Have if_nametoindex])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\t\t\t\n\tdnl **********************************\n\tdnl *** Checks for proclib         ***\n\tdnl **********************************\n\tAC_CHECK_HEADER(sys/errno.h, [AC_DEFINE(HAVE_SYS_ERRNO_H, 1, Define to 1 if you have the <sys/errno.h> header file.)])\n\tdnl **********************************\n\tdnl *** Checks for MonoPosixHelper ***\n\tdnl **********************************\n\tAC_CHECK_HEADERS(checklist.h)\n\tAC_CHECK_HEADERS(pathconf.h)\n\tAC_CHECK_HEADERS(fstab.h)\n\tAC_CHECK_HEADERS(attr/xattr.h)\n\tAC_CHECK_HEADERS(sys/extattr.h)\n\tAC_CHECK_HEADERS(sys/sendfile.h)\n\tAC_CHECK_HEADERS(sys/statvfs.h)\n\tAC_CHECK_HEADERS(sys/statfs.h)\n\tAC_CHECK_HEADERS(sys/vfstab.h)\n\tAC_CHECK_HEADERS(sys/xattr.h)\n\tAC_CHECK_HEADERS(sys/mman.h)\n\tAC_CHECK_HEADERS(sys/param.h)\n\tAC_CHECK_HEADERS(sys/mount.h, [], [],\n\t\t[\n\t\t#ifdef HAVE_SYS_PARAM_H\n\t\t# include <sys/param.h>\n\t\t#endif\n\t\t])\n\tAC_CHECK_HEADERS(sys/mount.h)\n\tAC_CHECK_FUNCS(confstr)\n\tAC_CHECK_FUNCS(seekdir telldir)\n\tAC_CHECK_FUNCS(getdomainname)\n\tAC_CHECK_FUNCS(setdomainname)\n\tAC_CHECK_FUNCS(endgrent getgrent fgetgrent setgrent)\n\tAC_CHECK_FUNCS(setgroups)\n\tAC_CHECK_FUNCS(endpwent getpwent fgetpwent setpwent)\n\tAC_CHECK_FUNCS(getfsstat)\n\tAC_CHECK_FUNCS(lutimes futimes)\n\tAC_CHECK_FUNCS(mremap)\n\tAC_CHECK_FUNCS(remap_file_pages)\n\tAC_CHECK_FUNCS(posix_fadvise)\n\tAC_CHECK_FUNCS(posix_fallocate)\n\tAC_CHECK_FUNCS(posix_madvise)\n\tAC_CHECK_FUNCS(vsnprintf)\n\tAC_CHECK_FUNCS(sendfile)\n\tAC_CHECK_FUNCS(gethostid sethostid)\n\tAC_CHECK_FUNCS(sethostname)\n\tAC_CHECK_FUNCS(statfs)\n\tAC_CHECK_FUNCS(fstatfs)\n\tAC_CHECK_FUNCS(statvfs)\n\tAC_CHECK_FUNCS(fstatvfs)\n\tAC_CHECK_FUNCS(stime)\n\tAC_CHECK_FUNCS(strerror_r)\n\tAC_CHECK_FUNCS(ttyname_r)\n\tAC_CHECK_FUNCS(psignal)\n\tAC_CHECK_FUNCS(getlogin_r)\n\tAC_CHECK_FUNCS(lockf)\n\tAC_CHECK_FUNCS(swab)\n\tAC_CHECK_FUNCS(setusershell endusershell)\n\tAC_CHECK_FUNCS(futimens utimensat)\n\tAC_CHECK_FUNCS(fstatat mknodat readlinkat)\n\tAC_CHECK_FUNCS(readv writev preadv pwritev)\n\tAC_CHECK_FUNCS(setpgid)\n\tAC_CHECK_FUNCS(system)\n\tAC_CHECK_FUNCS(fork execv execve)\n\tAC_CHECK_FUNCS(accept4)\n\tAC_CHECK_FUNCS(localtime_r)\n\tAC_CHECK_FUNCS(mkdtemp)\n\tAC_CHECK_SIZEOF(size_t)\n\tAC_CHECK_TYPES([blksize_t], [AC_DEFINE(HAVE_BLKSIZE_T)], , \n\t\t[#include <sys/types.h>\n\t\t #include <sys/stat.h>\n\t\t #include <unistd.h>])\n\tAC_CHECK_TYPES([blkcnt_t], [AC_DEFINE(HAVE_BLKCNT_T)], ,\n\t\t[#include <sys/types.h>\n\t\t #include <sys/stat.h>\n\t\t #include <unistd.h>])\n\tAC_CHECK_TYPES([suseconds_t], [AC_DEFINE(HAVE_SUSECONDS_T)], ,\n\t\t[#include <sys/time.h>])\n\tAC_CHECK_TYPES([struct cmsghdr], [AC_DEFINE(HAVE_STRUCT_CMSGHDR)], ,\n\t\t[#include <sys/socket.h>])\n\tAC_CHECK_TYPES([struct flock], [AC_DEFINE(HAVE_STRUCT_FLOCK)], ,\n\t\t[#include <unistd.h>\n\t\t #include <fcntl.h>])\n\tAC_CHECK_TYPES([struct iovec], [AC_DEFINE(HAVE_STRUCT_IOVEC)], ,\n\t\t[#include <sys/uio.h>])\n\tAC_CHECK_TYPES([struct linger], [AC_DEFINE(HAVE_STRUCT_LINGER)], ,\n\t\t[#include <sys/socket.h>])\n\tAC_CHECK_TYPES([struct pollfd], [AC_DEFINE(HAVE_STRUCT_POLLFD)], ,\n\t\t[#include <sys/poll.h>])\n\tAC_CHECK_TYPES([struct sockaddr], [AC_DEFINE(HAVE_STRUCT_SOCKADDR)], ,\n\t\t[#include <sys/socket.h>])\n\tAC_CHECK_TYPES([struct sockaddr_storage], [AC_DEFINE(HAVE_STRUCT_SOCKADDR_STORAGE)], ,\n\t\t[#include <sys/socket.h>])\n\tAC_CHECK_TYPES([struct sockaddr_in], [AC_DEFINE(HAVE_STRUCT_SOCKADDR_IN)], ,\n\t\t[#include <netinet/in.h>])\n\tAC_CHECK_TYPES([struct sockaddr_in6], [AC_DEFINE(HAVE_STRUCT_SOCKADDR_IN6)], ,\n\t\t[#include <netinet/in.h>])\n\tAC_CHECK_TYPES([struct sockaddr_un], [AC_DEFINE(HAVE_STRUCT_SOCKADDR_UN)], ,\n\t\t[#include <sys/un.h>])\n\tAC_CHECK_TYPES([struct stat], [AC_DEFINE(HAVE_STRUCT_STAT)], ,\n\t\t[#include <sys/types.h>\n\t\t #include <sys/stat.h>\n\t\t #include <unistd.h>])\n\tAC_CHECK_TYPES([struct timespec], [AC_DEFINE(HAVE_STRUCT_TIMESPEC)], ,\n\t\t[#include <time.h>])\n\tAC_CHECK_TYPES([struct timeval], [AC_DEFINE(HAVE_STRUCT_TIMEVAL)], ,\n\t\t[#include <sys/time.h>\n\t\t #include <sys/types.h>\n\t\t #include <utime.h>])\n\tAC_CHECK_TYPES([struct timezone], [AC_DEFINE(HAVE_STRUCT_TIMEZONE)], ,\n\t\t[#include <sys/time.h>])\n\tAC_CHECK_TYPES([struct utimbuf], [AC_DEFINE(HAVE_STRUCT_UTIMBUF)], ,\n\t\t[#include <sys/types.h>\n\t\t #include <utime.h>])\n\tAC_CHECK_MEMBERS(\n\t\t[struct dirent.d_off, struct dirent.d_reclen, struct dirent.d_type],,, \n\t\t[#include <sys/types.h>\n\t\t #include <dirent.h>])\n\tAC_CHECK_MEMBERS(\n\t\t[struct passwd.pw_gecos],,, \n\t\t[#include <sys/types.h>\n\t\t #include <pwd.h>])\n\tAC_CHECK_MEMBERS(\n\t\t[struct statfs.f_flags],,, \n\t\t[#include <sys/types.h>\n\t\t #include <sys/vfs.h>])\n\tAC_CHECK_MEMBERS(\n\t\t[struct stat.st_atim, struct stat.st_mtim, struct stat.st_ctim],,, \n\t\t[#include <sys/types.h>\n\t\t #include <sys/stat.h>\n\t\t #include <unistd.h>])\n\n\tdnl Favour xattr through glibc, but use libattr if we have to\n\tAC_CHECK_FUNC(lsetxattr, ,\n\t\tAC_CHECK_LIB(attr, lsetxattr, XATTR_LIB=\"-lattr\",)\n\t)\n\tAC_SUBST(XATTR_LIB)\n\n\tdnl kinfo_proc.kp_proc works on darwin but fails on other simil-bsds\n\tAC_CHECK_MEMBERS(\n\t\t[struct kinfo_proc.kp_proc],,, \n\t\t[#include <sys/types.h>\n\t\t #include <sys/param.h>\n\t\t #include <sys/sysctl.h>\n\t\t #include <sys/proc.h>\n\t\t ])\n\n\tdnl *********************************\n\tdnl *** Checks for Windows compilation ***\n\tdnl *********************************\n\tAC_CHECK_HEADERS(sys/time.h)\n\tAC_CHECK_HEADERS(sys/param.h)\n\tAC_CHECK_HEADERS(dirent.h)\n\n\tdnl ******************************************\n\tdnl *** Checks for OSX and iOS compilation ***\n\tdnl ******************************************\n\tAC_CHECK_HEADERS(CommonCrypto/CommonDigest.h)\n\n\tdnl *********************************\n\tdnl *** Check for Console 2.0 I/O ***\n\tdnl *********************************\n\tAC_CHECK_HEADERS([curses.h])\n\tAC_CHECK_HEADERS([term.h], [], [],\n\t[#if HAVE_CURSES_H\n\t #include <curses.h>\n\t #endif\n\t])\n\tAC_CHECK_HEADERS([termios.h])\n\n\tdnl *********************************\n\tdnl *** Checks for random         ***\n\tdnl *********************************\n\tif test x$host_darwin = xno; then\n\t\tAC_CHECK_HEADERS(sys/random.h)\n\t\tAC_CHECK_FUNCS(getrandom getentropy)\n\tfi\nelse\n\tdnl *********************************\n\tdnl *** Checks for Windows compilation ***\n\tdnl *********************************\n\tAC_CHECK_HEADERS(winternl.h)\n\n\tjdk_headers_found=no\n\tAC_CHECK_LIB(ws2_32, main, LIBS=\"$LIBS -lws2_32\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(psapi, main, LIBS=\"$LIBS -lpsapi\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(ole32, main, LIBS=\"$LIBS -lole32\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(winmm, main, LIBS=\"$LIBS -lwinmm\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(oleaut32, main, LIBS=\"$LIBS -loleaut32\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(advapi32, main, LIBS=\"$LIBS -ladvapi32\", AC_ERROR(bad mingw install?))\n\tAC_CHECK_LIB(version, main, LIBS=\"$LIBS -lversion\", AC_ERROR(bad mingw install?))\n\n\tdnl *********************************\n\tdnl *** Check for struct ip_mreqn ***\n\tdnl *********************************\n\tAC_MSG_CHECKING(for struct ip_mreqn)\n\tAC_TRY_COMPILE([#include <ws2tcpip.h>], [\n\t\tstruct ip_mreqn mreq;\n\t\tmreq.imr_address.s_addr = 0;\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_STRUCT_IP_MREQN)\n\t], [\n\t\t# We'll just have to try and use struct ip_mreq\n\t\tAC_MSG_RESULT(no)\n\t\tAC_MSG_CHECKING(for struct ip_mreq)\n\t\tAC_TRY_COMPILE([#include <ws2tcpip.h>], [\n\t\t\tstruct ip_mreq mreq;\n\t\t\tmreq.imr_interface.s_addr = 0;\n\t\t], [\n\t\t\t# Yes, we have it...\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_STRUCT_IP_MREQ)\n\t\t], [\n\t\t\t# No multicast support\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getaddrinfo ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getaddrinfo)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\tgetaddrinfo(NULL,NULL,NULL,NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETADDRINFO, 1, [Have getaddrinfo])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for gethostbyname ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for gethostbyname)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\tgethostbyname(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETHOSTBYNAME, 1, [Have gethostbyname])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getprotobyname ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getprotobyname)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\tgetprotobyname(NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETPROTOBYNAME, 1, [Have getprotobyname])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for getnameinfo ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for getnameinfo)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\tgetnameinfo (NULL, 0, NULL, 0, NULL, 0, 0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GETNAMEINFO, 1, [Have getnameinfo])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for inet_ntop ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for inet_ntop)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\tinet_ntop (0, NULL, NULL, 0);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_INET_NTOP, 1, [Have inet_ntop])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl **********************************\n\tdnl *** Check for inet_pton ***\n\tdnl **********************************\n\tAC_MSG_CHECKING(for inet_pton)\n\t\tAC_TRY_LINK([\n\t\t#include <stdio.h>\n\t\t#include <winsock2.h>\n\t\t#include <ws2tcpip.h>\n\t], [\n\t\t#ifndef inet_pton\n\t\t(void) inet_pton;\n\t\t#endif\n\t\tinet_pton (0, NULL, NULL);\n\t], [\n\t\t# Yes, we have it...\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_INET_PTON, 1, [Have inet_pton])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tAC_CHECK_DECLS(InterlockedExchange64, [], [], [[#include <windows.h>]])\n\tAC_CHECK_DECLS(InterlockedCompareExchange64, [], [], [[#include <windows.h>]])\n\tAC_CHECK_DECLS(InterlockedDecrement64, [], [], [[#include <windows.h>]])\n\tAC_CHECK_DECLS(InterlockedIncrement64, [], [], [[#include <windows.h>]])\n\tAC_CHECK_DECLS(InterlockedAdd, [], [], [[#include <windows.h>]])\n\tAC_CHECK_DECLS(InterlockedAdd64, [], [], [[#include <windows.h>]])\n\tAC_CHECK_DECLS(__readfsdword, [], [], [[#include <windows.h>]])\nfi\n\ndnl socklen_t check\nAC_MSG_CHECKING(for socklen_t)\nAC_TRY_COMPILE([\n#include <sys/types.h>\n#include <sys/socket.h>\n],[\n  socklen_t foo;\n],[\nac_cv_c_socklen_t=yes\n\tAC_DEFINE(HAVE_SOCKLEN_T, 1, [Have socklen_t])\n\tAC_MSG_RESULT(yes)\n],[\n\tAC_MSG_RESULT(no)\n])\n\nAC_MSG_CHECKING(for array element initializer support)\nAC_TRY_COMPILE([#include <sys/socket.h>], [\n\tconst int array[] = {[1] = 2,};\n], [\n\t# Yes, we have it...\n\tAC_MSG_RESULT(yes)\n\tAC_DEFINE(HAVE_ARRAY_ELEM_INIT,1,[Supports C99 array initialization])\n], [\n\t# We'll have to use signals\n\tAC_MSG_RESULT(no)\n])\n\nAC_CHECK_FUNCS(trunc, , AC_MSG_CHECKING(for trunc in math.h)\n\t# Simply calling trunc (0.0) is no good since gcc will optimize the call away\n\tAC_TRY_LINK([#include <math.h>], \n\t[ static void *p = &trunc; ],\n\t[\n\t\tAC_DEFINE(HAVE_TRUNC) \n\t\tAC_MSG_RESULT(yes)\n\t\tac_cv_trunc=yes\n\t],\n\tAC_MSG_RESULT(no)))\n\nif test \"x$ac_cv_truncl\" != \"xyes\"; then\n   AC_CHECK_LIB(sunmath, aintl, [ AC_DEFINE(HAVE_AINTL, 1, [Has the 'aintl' function]) LIBS=\"$LIBS -lsunmath\"])\nfi\n\nAC_CHECK_FUNCS(execvp)\n\ndnl ****************************\ndnl *** Look for /dev/random ***\ndnl ****************************\n\nAC_MSG_CHECKING([if usage of random device is requested])\nAC_ARG_ENABLE(dev-random,\n[  --disable-dev-random    disable the use of the random device (enabled by default)],\ntry_dev_random=$enableval, try_dev_random=yes)\n\nAC_MSG_RESULT($try_dev_random)\n\ncase \"{$build}\" in\n    *-openbsd*)\n    NAME_DEV_RANDOM=\"/dev/srandom\"\n    ;;\n\ndnl Win32 does not have /dev/random, they have their own method...\n\n    *-mingw*|*-*-cygwin*)\n    ac_cv_have_dev_random=no\n    ;;\n\ndnl Everywhere else, it's /dev/random\n\n    *)\n    NAME_DEV_RANDOM=\"/dev/random\"\n    ;;\nesac\n\nAC_DEFINE_UNQUOTED(NAME_DEV_RANDOM, \"$NAME_DEV_RANDOM\", [Name of /dev/random])\n\ndnl Now check if the device actually exists\n\nif test \"x$try_dev_random\" = \"xyes\"; then\n    AC_CACHE_CHECK(for random device, ac_cv_have_dev_random,\n    [if test -r \"$NAME_DEV_RANDOM\" ; then\n        ac_cv_have_dev_random=yes; else ac_cv_have_dev_random=no; fi])\n    if test \"x$ac_cv_have_dev_random\" = \"xyes\"; then\n        AC_DEFINE(HAVE_CRYPT_RNG, 1, [Have /dev/random])\n    fi\nelse\n    AC_MSG_CHECKING(for random device)\n    ac_cv_have_dev_random=no\n    AC_MSG_RESULT(has been disabled)\nfi\n\nif test \"x$host_win32\" = \"xyes\"; then\n    AC_DEFINE(HAVE_CRYPT_RNG)\nfi\n\nif test \"x$ac_cv_have_dev_random\" = \"xno\" \\\n    && test \"x$host_win32\" = \"xno\"; then\n    AC_MSG_WARN([[\n***\n*** A system-provided entropy source was not found on this system.\n*** Because of this, the System.Security.Cryptography random number generator\n*** will throw a NotImplemented exception.\n***\n*** If you are seeing this message, and you know your system DOES have an\n*** entropy collection in place, please contact <crichton@gimp.org> and\n*** provide information about the system and how to access the random device.\n***\n*** Otherwise you can install either egd or prngd and set the environment\n*** variable MONO_EGD_SOCKET to point to the daemon's socket to use that.\n***]])\nfi\n\nAC_ARG_ENABLE(bcl-opt, [  --disable-bcl-opt\tBCL is compiled with no optimizations (allows accurate BCL debugging)], test_bcl_opt=$enableval, test_bcl_opt=yes)\n\nAC_MSG_CHECKING([if big-arrays are to be enabled])\nAC_ARG_ENABLE(big-arrays,  [  --enable-big-arrays\tEnable the allocation and indexing of arrays greater than Int32.MaxValue], enable_big_arrays=$enableval, enable_big_arrays=no)\nif test \"x$enable_big_arrays\" = \"xyes\" ; then\n    if  test \"x$ac_cv_sizeof_void_p\" = \"x8\"; then\n\tAC_DEFINE(MONO_BIG_ARRAYS,1,[Enable the allocation and indexing of arrays greater than Int32.MaxValue])\n    else\n        AC_MSG_ERROR([The allocation and indexing of arrays greater than Int32.MaxValue is not supported on this platform.])\n    fi\nfi\nAC_MSG_RESULT($enable_big_arrays)\n\ndnl **************\ndnl *** DTRACE ***\ndnl **************\n\nAC_ARG_ENABLE(dtrace,[  --enable-dtrace\tEnable DTrace probes], enable_dtrace=$enableval, enable_dtrace=$has_dtrace)\n\nif test \"x$enable_dtrace\" = \"xyes\"; then\n   if test \"x$has_dtrace\" = \"xno\"; then\n   \t  AC_MSG_ERROR([DTrace probes are not supported on this platform.])\n   fi\n   AC_PATH_PROG(DTRACE, [dtrace], [no], [$PATH:/usr/sbin])\n   if test \"x$DTRACE\" = \"xno\"; then\n   \t  AC_MSG_RESULT([dtrace utility not found, dtrace support disabled.])\n\t  enable_dtrace=no\n   elif ! $DTRACE -h -s $srcdir/data/mono.d > /dev/null 2>&1; then\n\t  AC_MSG_RESULT([dtrace doesn't support -h option, dtrace support disabled.])\n\t  enable_dtrace=no\n   fi\nfi\n\ndtrace_g=no\nif test \"x$enable_dtrace\" = \"xyes\"; then\n\tAC_DEFINE(ENABLE_DTRACE, 1, [Enable DTrace probes])\n\tDTRACEFLAGS=\n\tif test \"x$ac_cv_sizeof_void_p\" = \"x8\"; then\n\t\tcase \"$host\" in\n\t\t\tpowerpc-*-darwin*)\n\t\t\tDTRACEFLAGS=\"-arch ppc64\"\n\t\t\t;;\n\t\t\ti*86-*-darwin*)\n\t\t\tDTRACEFLAGS=\"-arch x86_64\"\n\t\t\t;;\n\t\t\t*)\n\t\t\tDTRACEFLAGS=-64\n\t\t\t;;\n\t\tesac\n\telse\n\t\tcase \"$host\" in\n\t\t\tpowerpc-*-darwin*)\n\t\t\tDTRACEFLAGS=\"-arch ppc\"\n\t\t\t;;\n\t\t\ti*86-*-darwin*)\n\t\t\tDTRACEFLAGS=\"-arch i386\"\n\t\t\t;;\n\t\t\t*)\n\t\t\tDTRACEFLAGS=-32\n\t\t\t;;\n\t\tesac\n\tfi\n\tAC_SUBST(DTRACEFLAGS)\n\tcase \"$host\" in\n\t\t*-*-solaris*)\n\t\tdtrace_g=yes\n\t\t;;\n\tesac\n\tAC_CHECK_HEADERS([sys/sdt.h])\nfi\nAM_CONDITIONAL(ENABLE_DTRACE, [test x$enable_dtrace = xyes])\nAM_CONDITIONAL(DTRACE_G_REQUIRED, [test x$dtrace_g = xyes])\n\ndnl **************************\ndnl *** AOT cross offsets  ***\ndnl **************************\n\nAC_ARG_WITH(cross-offsets, [  --with-cross-offsets=<offsets file path>    Explicit AOT cross offsets file],\n    AC_DEFINE_UNQUOTED(MONO_OFFSETS_FILE, \"$withval\", [AOT cross offsets file]))\n\ndnl **************\ndnl ***  LLVM  ***\ndnl **************\n\nAC_ARG_ENABLE(llvm,[  --enable-llvm\tEnable the LLVM back-end], enable_llvm=$enableval, enable_llvm=default)\nAC_ARG_ENABLE(loadedllvm,[  --enable-loadedllvm\tLoad the LLVM back-end dynamically], enable_llvm=$enableval && enable_loadedllvm=$enableval, enable_loadedllvm=no)\nAC_ARG_ENABLE(llvm-version-check,[  --enable-llvm-version-check Check that the LLVM matches the version expected by mono], enable_llvm_version_check=$enableval, enable_llvm_version_check=no)\nAC_ARG_ENABLE(llvm-runtime,[  --enable-llvm-runtime\tEnable runtime support for llvmonly code], enable_llvm_runtime=$enableval, enable_llvm_runtime=no)\n\nAC_ARG_WITH(llvm, [  --with-llvm=<llvm prefix>    Enable the LLVM back-end], enable_llvm=yes,)\n\nif test \"x$enable_llvm\" = \"xdefault\"; then\n   enable_llvm=$enable_llvm_default\nfi\n\nif test \"x$enable_llvm\" = \"xyes\"; then\n   if test \"x$with_llvm\" != \"x\"; then\n   \t  LLVM_CONFIG=$with_llvm/bin/llvm-config\n   \t  if test x$host_win32 = xyes; then\n   \t  \tLLVM_CONFIG=$LLVM_CONFIG.exe\n   \t  fi\n\t  if test ! -x $LLVM_CONFIG; then\n\t  \t AC_MSG_ERROR([LLVM executable $LLVM_CONFIG not found.])\n      fi\n   else\n      AC_PATH_PROG(LLVM_CONFIG, llvm-config, no)\n      if test \"x$LLVM_CONFIG\" = \"xno\"; then\n   \t     AC_MSG_ERROR([llvm-config not found.])\n      fi\n   fi\n\n   llvm_codegen=\"x86codegen\"\n   case \"$target\" in\n   arm*)\n\t\tllvm_codegen=\"armcodegen\"\n\t\t;;\n   esac\n\n   if test \"x$host_win32\" = \"xno\"; then\n\n   # Should be something like '2.6' or '2.7svn'\n   llvm_version=`$LLVM_CONFIG --version`\n   llvm_api_version=`$LLVM_CONFIG --mono-api-version 2>/dev/null`\n   AC_MSG_CHECKING(LLVM version)\n   AC_MSG_RESULT($llvm_version $llvm_api_version)\n   if echo $llvm_version | grep -q 'mono'; then\n\t  if test \"x$enable_llvm_version_check\" = \"xyes\"; then\n\t  \t if test \"$llvm_version\" != \"$expected_llvm_version\"; then\n\t\t \tAC_MSG_ERROR([Expected llvm version $expected_llvm_version, but llvm-config --version returned $llvm_version\"])\n\t  \t fi\n\t  fi\n   else\n\t  AC_MSG_ERROR([Compiling with stock LLVM is not supported, please use the Mono LLVM repo at https://github.com/mono/llvm, with the GIT branch which matches this version of mono, i.e. 'mono-2-10' for Mono 2.10.])\n   fi\n\n   # The output of --cflags seems to include optimizations flags too\n   if test $llvm_api_version -gt 100; then\n   \t  # The --cflags argument includes all kinds of warnings -pendantic etc.\n\t  LLVM_CFLAGS=\"-I$with_llvm/include -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS\"\n\t  LLVM_CXXFLAGS=\"-I$with_llvm/include -std=c++11 -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS\"\n   else\n\t  LLVM_CFLAGS=`$LLVM_CONFIG --cflags | sed -e 's/-O2//g' | sed -e 's/-O0//g' | sed -e 's/-fomit-frame-pointer//g' | sed -e 's/-fPIC//g'`\n      LLVM_CXXFLAGS=`$LLVM_CONFIG --cxxflags | sed -e 's/-O2//g' | sed -e 's/-O0//g' | sed -e 's/-fomit-frame-pointer//g' | sed -e 's/-fPIC//g'`\n   fi\n   # LLVM is compiled with -fno-rtti, so we need this too, since our classes inherit\n   # from LLVM classes.\n   LLVM_CXXFLAGS=\"$LLVM_CXXFLAGS -fno-rtti -fexceptions\"\n   LLVM_LDFLAGS=`$LLVM_CONFIG --ldflags`\n   # This might include empty lines\n   LLVM_SYSTEM_LIBS=`$LLVM_CONFIG --system-libs 2>/dev/null | grep -- -`\n   llvm_jit_supported=yes\n   llvm_jit_libs=\"jit mcjit $llvm_codegen\"\n   if test \"x$host\" != \"x$target\"; then\n      # No need for jit libs\n\t  llvm_jit_supported=no\n      llvm_jit_libs=\"\"\n   elif test $llvm_api_version -gt 100; then\n      llvm_jit_libs=\"orcjit $llvm_codegen\"\n   fi\n   LLVM_LIBS=`$LLVM_CONFIG --libs analysis core bitwriter $llvm_jit_libs`\n   if test \"x$LLVM_LIBS\" = \"x\"; then\n   \t  echo \"$LLVM_CONFIG --libs failed.\"\n\t  exit 1\n   fi\n   LLVM_LIBS=\"$LLVM_LIBS $LLVM_LDFLAGS $LLVM_SYSTEM_LIBS\"\n   # The c++ standard library used by llvm doesn't show up in $LLVM_SYSTEM_LIBS so add it manually\n   if echo $LLVM_CXXFLAGS | grep -q -- '-stdlib=libc++'; then\n      LLVM_LIBS=\"$LLVM_LIBS -lc++\"\n   else\n      LLVM_LIBS=\"$LLVM_LIBS -lstdc++\"\n   fi\n\n   expected_llvm_version=\"3.4svn-mono-mono/e656cac\"\n\n   else\n       LLVM_CFLAGS=\"-I$with_llvm/include -DNDEBUG -D__NO_CTYPE_INLINE -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS\"\n       LLVM_CXXFLAGS=\"$LLVM_CFLAGS -std=gnu++11 -fvisibility-inlines-hidden -fno-rtti -Woverloaded-virtual -Wcast-qual\"\n       LLVM_LDFLAGS=\"-L$with_llvm/lib\"\n       LLVM_SYSTEM_LIBS=\"-lshell32 -lpsapi -limagehlp -ldbghelp -lm\"\n       LLVM_LIBS=\"-lLLVMLTO -lLLVMObjCARCOpts -lLLVMLinker -lLLVMipo -lLLVMVectorize -lLLVMBitWriter \\\n         -lLLVMARMDisassembler -lLLVMARMCodeGen -lLLVMARMAsmParser -lLLVMARMDesc -lLLVMARMInfo \\\n         -lLLVMARMAsmPrinter -lLLVMTableGen -lLLVMDebugInfo -lLLVMOption -lLLVMX86Disassembler \\\n         -lLLVMX86AsmParser -lLLVMX86CodeGen -lLLVMSelectionDAG -lLLVMAsmPrinter -lLLVMX86Desc \\\n         -lLLVMMCDisassembler -lLLVMX86Info -lLLVMX86AsmPrinter -lLLVMX86Utils -lLLVMJIT \\\n         -lLLVMAnalysis -lLLVMTarget \\\n         -lLLVMIRReader -lLLVMAsmParser -lLLVMLineEditor -lLLVMMCAnalysis -lLLVMInstrumentation \\\n         -lLLVMInterpreter -lLLVMCodeGen -lLLVMScalarOpts -lLLVMInstCombine -lLLVMTransformUtils \\\n         -lLLVMipa -lLLVMAnalysis -lLLVMProfileData -lLLVMMCJIT -lLLVMTarget -lLLVMRuntimeDyld \\\n         -lLLVMObject -lLLVMMCParser -lLLVMBitReader -lLLVMExecutionEngine -lLLVMMC -lLLVMCore \\\n         -lLLVMSupport -lstdc++\"\n       LLVM_LIBS=\"$LLVM_LIBS $LLVM_SYSTEM_LIBS\"\n\n       llvm_config_path=$with_llvm/include/llvm/Config/llvm-config.h\n       llvm_api_version=`awk '/MONO_API_VERSION/ { print $3 }' $llvm_config_path`\n   fi  \n\n   if test \"x$llvm_api_version\" = \"x\"; then\n\t  LLVM_CFLAGS=\"$LLVM_CFLAGS -DLLVM_API_VERSION=0\"\n\t  LLVM_CXXFLAGS=\"$LLVM_CXXFLAGS -DLLVM_API_VERSION=0\"\n   else\n\t  LLVM_CFLAGS=\"$LLVM_CFLAGS -DLLVM_API_VERSION=$llvm_api_version\"\n\t  LLVM_CXXFLAGS=\"$LLVM_CXXFLAGS -DLLVM_API_VERSION=$llvm_api_version\"\n   fi   \n\n   AC_DEFINE_UNQUOTED(LLVM_VERSION, \"$llvm_version\", [Full version of LLVM libraries])\n\n   AC_SUBST(LLVM_CFLAGS)\n   AC_SUBST(LLVM_CXXFLAGS)\n   AC_SUBST(LLVM_LIBS)\n   AC_SUBST(LLVM_LDFLAGS)\n   AC_DEFINE(ENABLE_LLVM, 1, [Enable the LLVM back end])\nfi\n\nAM_CONDITIONAL(ENABLE_LLVM, [test x$enable_llvm = xyes])\nif test \"x$enable_loadedllvm\" = \"xyes\"; then\n   AC_DEFINE(MONO_LLVM_LOADED, 1, [The LLVM back end is dynamically loaded])\nfi\nAM_CONDITIONAL(LOADED_LLVM, [test x$enable_loadedllvm = xyes])\n\nif test \"x$enable_llvm\" = \"xyes\"; then\n   enable_llvm_runtime=yes\nfi\nif test \"x$enable_llvm_runtime\" = \"xyes\"; then\n   AC_DEFINE(ENABLE_LLVM_RUNTIME, 1, [Runtime support code for llvm enabled])\nfi\nAM_CONDITIONAL(ENABLE_LLVM_RUNTIME, [test x$enable_llvm_runtime = xyes])\n\nTARGET=\"unknown\"\nACCESS_UNALIGNED=\"yes\"\n\nLIBC=\"libc.so.6\"\nINTL=\"libc.so.6\"\nSQLITE=\"libsqlite.so.0\"\nSQLITE3=\"libsqlite3.so.0\"\nX11=\"libX11.so\"\nGDKX11=\"libgdk-x11-2.0.so.0\"\nGTKX11=\"libgtk-x11-2.0.so.0\"\nXINERAMA=\"libXinerama.so.1\"\n\nsizeof_register=\"SIZEOF_VOID_P\"\n\njit_wanted=true\nboehm_supported=true\nBTLS_SUPPORTED=no\nBTLS_PLATFORM=\n\nif test \"x$enable_wasm\" = \"xyes\"; then\nTARGET=WASM\nHOST=WASM\narch_target=wasm\nAC_DEFINE(TARGET_WASM, 1, [Target wasm])\nAC_DEFINE(HOST_WASM, 1, [Host wasm])\nBTLS_SUPPORTED=no\nwith_tls=pthread\ntarget_mach=no\n\nelse\n\ncase \"$host\" in\n\tmips*)\n\t\tTARGET=MIPS;\n\t\tarch_target=mips;\n\t\twith_tls=pthread;\n\t\tACCESS_UNALIGNED=\"no\"\n\n\t\tAC_MSG_CHECKING(for mips n32)\n\t\tAC_TRY_COMPILE([],[\n\t\t#if _MIPS_SIM != _ABIN32\n\t\t#error Not mips n32\n\t\t#endif\n\t\treturn 0;\n\t\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tsizeof_register=8\n\t\t],[\n\t\tAC_MSG_RESULT(no)\n\t\t])\n\t\t;;\n\ti*86-*-*)\n\t\tTARGET=X86;\n\t\tarch_target=x86;\n\t\tcase $host_os in\n\t\t  solaris*)\n\t\t\tLIBC=\"libc.so\"\n\t\t\tINTL=\"libintl.so\"\n\t\t\tif test \"x$ac_cv_sizeof_void_p\" = \"x8\"; then\n\t\t\t\tTARGET=AMD64\n\t\t\t\tarch_target=amd64\n\t\t\tfi\n\n\t\t\t# On solaris 10 x86, gcc prints a warning saying 'visibility attribute not supported on this configuration; ignored', but linking fails. A test case:\n\t\t\t# int astruct __attribute__ ((visibility (\"hidden\")));\n\t\t\t# void foo ()\n\t\t\t# {\n\t\t\t#\tvoid *p = &astruct;\n\t\t\t# }\n\t\t\t# gcc -fPIC --shared -o libfoo.so foo.c\n\t\t\t# yields:\n\t\t\t# foo.c:6: warning: visibility attribute not supported in this configuration; ignored\n\t\t\t# ld: fatal: relocation error: R_386_GOTOFF: file /var/tmp//ccxYR96k.o: symbol astruct: relocation must bind locally\n\t\t\thave_visibility_hidden=no\n\t\t\t;;\n\t\t  mingw*|cygwin*)\n\t\t\thave_visibility_hidden=no\t\t  \n\t\t\t;;\n\t\t  haiku*)\n\t\t\tLIBC=libroot.so\n\t\t\t;;\n\t\t  linux*)\n\t\t\tAOT_SUPPORTED=\"yes\"\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=i386\n\t\t\tAC_CHECK_HEADER(stdalign.h,[],[BTLS_SUPPORTED=no])\n\t\t\t;;\n\t\t  darwin*)\n\t\t\tAOT_SUPPORTED=\"yes\"\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=i386\n\t\t\t;;\n\t\t  openbsd*|freebsd*|kfreebsd-gnu*)\n\t\t        ;;\n\t\tesac\n\t\t;;\n\tx86_64-*-* | amd64-*-*)\n\t\tTARGET=AMD64;\n\t\tarch_target=amd64;\n\t\tif test \"x$ac_cv_sizeof_void_p\" = \"x4\"; then\n\t\t\tAC_DEFINE(__mono_ilp32__, 1, [64 bit mode with 4 byte longs and pointers])\n\t\t\tsizeof_register=8\n\t\tfi\n\t\tcase $host_os in\n\t\t  linux*)\n\t\t\tAOT_SUPPORTED=\"yes\"\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=x86_64\n\t\t\tAC_CHECK_HEADER(stdalign.h,[],[BTLS_SUPPORTED=no])\n\t\t\t;;\n\t\t  darwin*)\n\t\t\tAOT_SUPPORTED=\"yes\"\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=x86_64\n\t\t\tboehm_supported=false\n\t\t\t;;\n\t\t  openbsd*|freebsd*|kfreebsd-gnu*)\n\t\t\t;;\n\t\t  mingw*)\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tsparc*-*-*)\n\t\tif test \"x$ac_cv_sizeof_void_p\" = \"x8\"; then\n\t\t   TARGET=SPARC64\n\t\telse\n\t\t\tTARGET=SPARC\n\t\tfi\n\t\tarch_target=sparc;\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tcase $host_os in\n\t\t  linux*) ;;\n\t\t  *)\n\t\t\tLIBC=\"libc.so\"\n\t\t\tINTL=\"libintl.so\"\n\t\tesac\n\t\tif test x\"$GCC\" = xyes; then\n\t\t\t# We don't support v8 cpus\n\t\t\tCFLAGS=\"$CFLAGS -Wno-cast-align -mcpu=v9\"\n\t\tfi\n\t\tif test x\"$AR\" = xfalse; then\n\t\t\tAC_MSG_ERROR([The required utility 'ar' is not found in your PATH. Usually it can be found in /usr/ccs/bin.])\n\t\tfi\n\t\t;;\n\t*-mingw*|*-*-cygwin*)\n\t\t# When this is enabled, it leads to very strange crashes at runtime (gcc-3.4.4)\n\t\thave_visibility_hidden=no\n\t\tINTL=\"intl\"\n\t\t;;\n\tmacppc-*-openbsd* | powerpc*-*-linux* | powerpc-*-openbsd* | \\\n        powerpc-*-sysv* | powerpc-*-darwin* | powerpc-*-netbsd* | powerpc-*-freebsd* )\n\t\tif test \"x$ac_cv_sizeof_void_p\" = \"x8\"; then\n\t\t\tTARGET=POWERPC64;\n\t\t\tCPPFLAGS=\"$CPPFLAGS -D__mono_ppc__ -D__mono_ppc64__\"\n\t\t\tCFLAGS=\"$CFLAGS -mminimal-toc\"\n\t\telse\n\t\t\tTARGET=POWERPC;\n\t\t\tCPPFLAGS=\"$CPPFLAGS -D__mono_ppc__\"\n\t\tfi\n\t\tarch_target=ppc;\n\t\tcase $host_os in\n\t\t  linux*|darwin*)\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tarmv7k-*-darwin*)\n\t\tTARGET=ARM;\n\t\tTARGET_SYS=WATCHOS\n\t\tarch_target=arm;\n\t\tarm_fpu=VFP_HARD\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t;;\n\n\tarm*-darwin*)\n\t\tTARGET=ARM;\n\t\tarch_target=arm;\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t;;\n\tarm*-linux*)\n\t\tTARGET=ARM;\n\t\tarch_target=arm;\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tAOT_SUPPORTED=\"yes\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=arm\n\t\tAC_CHECK_HEADER(stdalign.h,[],[BTLS_SUPPORTED=no])\n\t\tcase \"$target\" in\n\t\tarm*-linux*-gnueabi)\n\t\t\tBTLS_PLATFORM=armsoft\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tarm*-netbsd*-eabi*)\n\t\tTARGET=ARM;\n\t\tarch_target=arm;\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t;;\n\taarch64-*)\n\t\t# https://lkml.org/lkml/2012/7/15/133\n\t\tTARGET=ARM64\n\t\tarch_target=arm64\n\t\tboehm_supported=false\n\t\tAOT_SUPPORTED=\"yes\"\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=aarch64\n\t\tAC_CHECK_HEADER(stdalign.h,[],[BTLS_SUPPORTED=no])\n\t\t;;\n\ts390x-*-linux*)\n\t\tTARGET=S390X;\n\t\tarch_target=s390x;\n\t\tACCESS_UNALIGNED=\"yes\"\n\t\tCFLAGS=\"$CFLAGS -mbackchain -D__USE_STRING_INLINES\"\n\t\t;;\nesac\n\nHOST=$TARGET\n\nif test \"x$host\" != \"x$target\"; then\n   AC_DEFINE(MONO_CROSS_COMPILE,1,[The runtime is compiled for cross-compiling mode])\n   enable_mcs_build=no\n   enable_support_build=no\n   BTLS_SUPPORTED=no\n   case \"$target\" in\n   arm*-darwin*)\n\t\tTARGET=ARM;\n\t\tarch_target=arm;\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t# Can't use tls, since it depends on the runtime detection of tls offsets\n\t\t# in mono-compiler.h\n\t\twith_tls=pthread\n\t\tcase \"$target\" in\n\t\tarmv7k-*)\n\t\t\tarm_fpu=VFP_HARD\n\t\t\tAC_DEFINE(TARGET_WATCHOS, 1, [...])\n\t\t\t;;\n\t\tesac\t\t\n\t\t;;\n   powerpc64-ps3-linux-gnu)\n\t\tTARGET=POWERPC64\n\t\tarch_target=powerpc64\n\t\tAC_DEFINE(TARGET_PS3, 1, [...])\n\t\t# It would be better to just use TARGET_POWERPC64, but lots of code already\n\t\t# uses this define\n\t\tAC_DEFINE(__mono_ppc64__, 1, [...])\n\t\tAC_DEFINE(__mono_ilp32__, 1, [64 bit mode with 4 byte longs and pointers])\n\t\tsizeof_register=8\n\t\ttarget_byte_order=G_BIG_ENDIAN\n\t\t;;\n   powerpc64-xbox360-linux-gnu)\n\t\tTARGET=POWERPC64\n\t\tarch_target=powerpc64\n\t\tAC_DEFINE(TARGET_XBOX360, 1, [...])\n\t\t# It would be better to just use TARGET_POWERPC64, but lots of code already\n\t\t# uses this define\n\t\tsizeof_register=8\n\t\ttarget_byte_order=G_BIG_ENDIAN\n\t\t;;\n   arm*-linux-*)\n\t\tTARGET=ARM;\n\t\tarch_target=arm;\n\t\tAC_DEFINE(TARGET_ARM, 1, [...])\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t# Can't use tls, since it depends on the runtime detection of tls offsets\n\t\t# in mono-compiler.h\n\t\twith_tls=pthread\n\t\ttarget_mach=no\n\t\tcase \"$target\" in\n\t\tarmv7l-unknown-linux-gnueabi*)\n\t\t\t# TEGRA\n\t\t\tCPPFLAGS=\"$CPPFLAGS\"\n\t\t\t;;\n   \t\tarmv5-*-linux-androideabi*)\n\t\t\tAC_DEFINE(TARGET_ANDROID, 1, [...])\n\t\t\tCPPFLAGS=\"$CPPFLAGS\"\n\t\t\t;;\n   \t\t*-linux-androideabi*)\n\t\t\tAC_DEFINE(TARGET_ANDROID, 1, [...])\n\t\t\tCPPFLAGS=\"$CPPFLAGS\"\n\t\t\t;;\n\t\tesac\n\t\t;;\n   arm*-netbsd*-eabi*)\n\t\tTARGET=ARM;\n\t\tarch_target=arm;\n\t\tAC_DEFINE(TARGET_ARM, 1, [...])\n\t\tACCESS_UNALIGNED=\"no\"\n\t\tCPPFLAGS=\"$CPPFLAGS -D__ARM_EABI__\"\n\t\t# Can't use tls, since it depends on the runtime detection of tls offsets\n\t\t# in mono-compiler.h\n\t\twith_tls=pthread\n\t\ttarget_mach=no\n\t\t;;\n   i686*-linux-*)\n\t\tTARGET=X86;\n\t\tarch_target=x86;\n\t\tAC_DEFINE(TARGET_X86, 1, [...])\n\t\tCPPFLAGS=\"$CPPFLAGS\"\n\t\t# Can't use tls, since it depends on the runtime detection of tls offsets\n\t\t# in mono-compiler.h\t\t\n\t\twith_tls=pthread\n\t\ttarget_mach=no\n\n\t\tcase \"$target\" in\n\t\t*-linux-android*)\n\t\t\tAC_DEFINE(TARGET_ANDROID, 1, [...])\n\t\t\t;;\n\t\tesac\n\t\t;;\n   x86_64*-linux-*)\n\t\tTARGET=AMD64;\n\t\tarch_target=amd64;\n\t\tAC_DEFINE(TARGET_AMD64, 1, [...])\n\t\tCPPFLAGS=\"$CPPFLAGS\"\n\t\t# Can't use tls, since it depends on the runtime detection of tls offsets\n\t\t# in mono-compiler.h\n\t\twith_tls=pthread\n\t\ttarget_mach=no\n\n\t\tcase \"$target\" in\n\t\t*-linux-android*)\n\t\t\tAC_DEFINE(TARGET_ANDROID, 1, [...])\n\t\t\t;;\n\t\tesac\n\t\t;;\n   x86_64-ps4-freebsd)\n\t\tTARGET=AMD64;\n\t\tarch_target=amd64;\n\t\tAC_DEFINE(TARGET_AMD64, 1, [...])\n\t\tAC_DEFINE(TARGET_PS4, 1, [...])\n\t\tAC_DEFINE(DISABLE_HW_TRAPS, 1, [...])\n\t\tCPPFLAGS=\"$CPPFLAGS\"\n\t\t# Can't use tls, since it depends on the runtime detection of tls offsets\n\t\t# in mono-compiler.h\n\t\twith_tls=pthread\n\t\ttarget_mach=no\n\t\ttarget_win32=no\n\t\t;;\n   aarch64*-linux-*)\n\t\tTARGET=ARM64;\n\t\tarch_target=arm64;\n\t\tAC_DEFINE(TARGET_ARM64, 1, [...])\n\t\tCPPFLAGS=\"$CPPFLAGS\"\n\t\t# Can't use tls, since it depends on the runtime detection of tls offsets\n\t\t# in mono-compiler.h\n\t\twith_tls=pthread\n\t\ttarget_mach=no\n\t\tcase \"$target\" in\n\t\t*-linux-android*)\n\t\t\tAC_DEFINE(TARGET_ANDROID, 1, [...])\n\t\t\t;;\n\t\tesac\n\t\t;;\n\taarch64-*)\n\t\tTARGET=ARM64\n\t\t;;\n\t*)\n\t\tAC_MSG_ERROR([Cross compiling is not supported for target $target])\n\tesac\nfi\n\ncase \"$TARGET\" in\nX86)\n\tAC_DEFINE(TARGET_X86, 1, [...])\n\t;;\nAMD64)\n\tAC_DEFINE(TARGET_AMD64, 1, [...])\n\t;;\nARM)\n\tAC_DEFINE(TARGET_ARM, 1, [...])\n\t;;\nARM64)\n\tAC_DEFINE(TARGET_ARM64, 1, [...])\n\t;;\nPOWERPC)\n\tAC_DEFINE(TARGET_POWERPC, 1, [...])\n\t;;\nPOWERPC64)\n\tAC_DEFINE(TARGET_POWERPC, 1, [...])\n\tAC_DEFINE(TARGET_POWERPC64, 1, [...])\n\t;;\nS390X)\n\tAC_DEFINE(TARGET_S390X, 1, [...])\n\t;;\nMIPS)\n\tAC_DEFINE(TARGET_MIPS, 1, [...])\n\t;;\nSPARC)\n\tAC_DEFINE(TARGET_SPARC, 1, [...])\n\t;;\nSPARC64)\n\tAC_DEFINE(TARGET_SPARC64, 1, [...])\n\t;;\nesac\n\ncase \"$HOST\" in\nX86)\n\tAC_DEFINE(HOST_X86, 1, [...])\n\t;;\nAMD64)\n\tAC_DEFINE(HOST_AMD64, 1, [...])\n\t;;\nARM)\n\tAC_DEFINE(HOST_ARM, 1, [...])\n\t;;\nARM64)\n\tAC_DEFINE(HOST_ARM64, 1, [...])\n\t;;\nPOWERPC)\n\tAC_DEFINE(HOST_POWERPC, 1, [...])\n\t;;\nPOWERPC64)\n\tAC_DEFINE(HOST_POWERPC, 1, [...])\n\tAC_DEFINE(HOST_POWERPC64, 1, [...])\n\t;;\nS390X)\n\tAC_DEFINE(HOST_S390X, 1, [...])\n\t;;\nMIPS)\n\tAC_DEFINE(HOST_MIPS, 1, [...])\n\t;;\nSPARC)\n\tAC_DEFINE(HOST_SPARC, 1, [...])\n\t;;\nSPARC64)\n\tAC_DEFINE(HOST_SPARC64, 1, [...])\n\t;;\nesac\n\n#WASM hack\nfi\n\n\ndnl *************\ndnl *** VTUNE ***\ndnl *************\n\nAC_ARG_ENABLE(vtune,[  --enable-vtune\tEnable the VTUNE back-end], enable_vtune=$enableval, enable_vtune=no)\nAC_ARG_WITH(vtune, [  --with-vtune=<vtune prefix>\tEnable jit vtune profiling], enable_vtune=yes,)\n\nAM_CONDITIONAL(HAVE_VTUNE, test x$enable_vtune = xyes)\n\nif test \"x$enable_vtune\" = \"xyes\"; then\n\tif test \"x$with_vtune\" = \"x\"; then\n\t\tVTUNE_PATH=/opt/intel/vtune_amplifier_xe\n\telse\n\t\tVTUNE_PATH=$with_vtune\n\tfi\n\tVTUNE_INCLUDE=$VTUNE_PATH/include\n\tcase \"$TARGET\" in\n\tX86)\n\t\tVTUNE_LIB=$VTUNE_PATH/lib32\n\t\t;;\n\tAMD64)\n\t\tVTUNE_LIB=$VTUNE_PATH/lib64\n\t\t;;\n\t*)\n\t\tAC_MSG_ERROR([Unsupported target $TARGET for VTUNE.])\n\t\t;;\n\tesac\n\tif test ! -f $VTUNE_INCLUDE/jitprofiling.h; then\n\t\tAC_MSG_ERROR([VTUNE $VTUNE_INCLUDE/jitprofiling.h not found.])\n\tfi\n\tif test ! -f $VTUNE_LIB/libjitprofiling.a; then\n\t\tAC_MSG_ERROR([VTUNE $VTUNE_LIB/libjitprofiling.a not found.])\n\tfi\n\n\tVTUNE_CFLAGS=-I$VTUNE_INCLUDE\n\tVTUNE_LIBS=\"-L/$VTUNE_LIB/ -ljitprofiling\"\n\n\tAC_SUBST(VTUNE_LIBS)\n\tAC_SUBST(VTUNE_CFLAGS)\nfi\ndnl Use GCC atomic ops if they work on the target.\nif test x$GCC = \"xyes\"; then\n\tcase $TARGET in\n\tX86 | AMD64 | ARM | ARM64 | POWERPC | POWERPC64 | MIPS | S390X | SPARC | SPARC64)\n\t\tAC_DEFINE(USE_GCC_ATOMIC_OPS, 1, [...])\n\t\t;;\n\tesac\nfi\n\nif test \"x$target_mach\" = \"xyes\"; then\n\n   if test \"x$TARGET_SYS\" = \"xWATCHOS\"; then\n\t  AC_DEFINE(TARGET_WATCHOS,1,[The JIT/AOT targets WatchOS])\n\t  CPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DTARGET_WATCHOS\"\n\t  CFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DTARGET_WATCHOS\"\n\t  BTLS_SUPPORTED=no\n   elif test \"x$TARGET\" = \"xARM\" -o \"x$TARGET\" = \"xARM64\"; then\n   \t  AC_DEFINE(TARGET_IOS,1,[The JIT/AOT targets iOS])\n\t  CPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DTARGET_IOS\"\n\t  CFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DTARGET_IOS\"\n\t  BTLS_SUPPORTED=no\n   else\n       AC_TRY_COMPILE([#include \"TargetConditionals.h\"],[\n       #if TARGET_IPHONE_SIMULATOR == 1 || TARGET_OS_IPHONE == 1\n       #error fail this for ios\n       #endif\n       return 0;\n       ], [\n\t   \t  AC_DEFINE(TARGET_OSX,1,[The JIT/AOT targets OSX])\n          CPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DTARGET_OSX\"\n          CFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DTARGET_OSX\"\n          target_osx=yes\n       ], [\n          AC_DEFINE(TARGET_IOS,1,[The JIT/AOT targets iOS])\n          CPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DTARGET_IOS\"\n          CFLAGS_FOR_LIBGC=\"$CFLAGS_FOR_LIBGC -DTARGET_IOS\"\n          BTLS_SUPPORTED=no\n\t\t  target_ios=yes\n       ])\n\tfi\n   AC_DEFINE(TARGET_MACH,1,[The JIT/AOT targets Apple platforms])\nfi\n\nAM_CONDITIONAL(TARGET_OSX, test x$target_osx = xyes)\n\nif test \"x$sizeof_register\" = \"x4\"; then\n   AC_DEFINE(SIZEOF_REGISTER,4,[size of machine integer registers])\nelif test \"x$sizeof_register\" = \"x8\"; then\n   AC_DEFINE(SIZEOF_REGISTER,8,[size of machine integer registers])\nelse\n   AC_DEFINE(SIZEOF_REGISTER,SIZEOF_VOID_P,[size of machine integer registers])\nfi\n\nAC_SUBST(SIZEOF_VOID_P,[$ac_cv_sizeof_void_p])\n\nif test \"x$target_byte_order\" = \"xG_BIG_ENDIAN\"; then\n   AC_DEFINE(TARGET_BYTE_ORDER,G_BIG_ENDIAN,[byte order of target])\nelif test \"x$target_byte_order\" = \"xG_LITTLE_ENDIAN\"; then\n   AC_DEFINE(TARGET_BYTE_ORDER,G_LITTLE_ENDIAN,[byte order of target])\nelse\n   AC_DEFINE(TARGET_BYTE_ORDER,G_BYTE_ORDER,[byte order of target])\nfi\n\nif test \"x$have_visibility_hidden\" = \"xyes\"; then\n   AC_DEFINE(HAVE_VISIBILITY_HIDDEN, 1, [Support for the visibility (\"hidden\") attribute])\nfi\n\nif test \"x$have_deprecated\" = \"xyes\"; then\n   AC_DEFINE(HAVE_DEPRECATED, 1, [Support for the deprecated attribute])\nfi\n\ndnl \ndnl Simple Generational checks (sgen)\ndnl\nSGEN_DEFINES=\nAC_ARG_WITH(sgen,                    [  --with-sgen=yes,no             Extra Generational GC, default=yes],[buildsgen=$with_sgen],[buildsgen=yes])\nAC_ARG_WITH(sgen-default-concurrent, [  --with-sgen-default-concurrent=yes,no             Use Concurrent GC, default=no],[],[with_sgen_default_concurrent=no])\nif test x$buildsgen = xyes; then\n   AC_DEFINE(HAVE_MOVING_COLLECTOR, 1, [Moving collector])\n   SGEN_DEFINES=\"-DHAVE_SGEN_GC\"\n\n\tconc_gc_msg=\"\"\n   if test x$with_sgen_default_concurrent != xno; then\n       AC_DEFINE(HAVE_CONC_GC_AS_DEFAULT, 1, [Defaults to concurrent GC])\n\t   conc_gc_msg=\" (concurrent by default)\"\n   fi\n\n   if test \"x$gc_msg\" = \"x\"; then\n      gc_msg=\"sgen$conc_gc_msg\"\n   else\n      gc_msg=\"sgen$conc_gc_msg and $gc_msg\"\n   fi\nfi\nAC_SUBST(SGEN_DEFINES)\nAM_CONDITIONAL(SUPPORT_SGEN, test x$buildsgen = xyes)\n\njit_status=\"Building and using the JIT\"\n\nlibsuffix=\".so\"\n\ncase \"$host\" in\n     *-*-darwin*)\n\tlibsuffix=\".dylib\"\n\tLIBC=\"libc.dylib\"\n\tINTL=\"libintl.dylib\"\n\tSQLITE=\"libsqlite.0.dylib\"\n\tSQLITE3=\"libsqlite3.0.dylib\"\n\tX11=\"libX11.dylib\"\n\tGDKX11=\"libgdk-x11-2.0.dylib\"\n\tGTKX11=\"libgtk-x11-2.0.dylib\"\n\t;;\n     *-*-*netbsd*)\n\tLIBC=\"libc.so\"\n\tINTL=\"libintl.so\"\n\tSQLITE=\"libsqlite.so\"\n\tSQLITE3=\"libsqlite3.so\"\n\t;;\n     *-*-kfreebsd*-gnu)\n\tLIBC=\"libc.so.0.1\"\n\tINTL=\"libc.so.0.1\"\n\tX11=\"libX11.so.6\"\n\t;;\n    *-*-*freebsd*)\n    \tLIBC=\"libc.so.7\"\n\tINTL=\"libintl.so\"\n\tSQLITE=\"libsqlite.so\"\n\tSQLITE3=\"libsqlite3.so\"\n\t;;\n    *-*-*openbsd*)\n    \tLIBC=\"libc.so\"\n\tINTL=\"libintl.so\"\n        SQLITE=\"libsqlite.so\"\n        SQLITE3=\"libsqlite3.so\"\n\t;;\n    *-*-*linux*)\n\tAC_PATH_X\n\tdlsearch_path=`(libtool --config ; echo eval echo \\\\$sys_lib_dlsearch_path_spec) | sh`\n\tAC_MSG_CHECKING(for the soname of libX11.so)\n\tfor i in $x_libraries $dlsearch_path; do\n\t\tfor r in 4 5 6; do\n\t\t\tif test -f $i/libX11.so.$r; then\n\t\t\t\tX11=libX11.so.$r\n\t\t\t\tAC_MSG_RESULT($X11)\n\t\t\tfi\n\t\tdone\n\tdone\n\t\n\tif test \"x$X11\" = \"xlibX11.so\"; then\n\t\tAC_MSG_WARN([Could not find libX11.so. Do you have X.org or XFree86 installed? Assuming libX11.so.6...]);\n\t\tX11=libX11.so.6\n\tfi\n\t;;\nesac\n\nAC_SUBST(libsuffix)\n\n######################################\n# EGLIB CHECKS\n######################################\n\nGNUC_PRETTY=\nGNUC_UNUSED=\nBREAKPOINT=\"G_STMT_START { raise (SIGTRAP); } G_STMT_END\"\nif test x$GCC = xyes; then\n   GNUC_UNUSED='__attribute__((__unused__))'\n   GNUC_NORETURN='__attribute__((__noreturn__))'\n   case $host_cpu in\n     i*86|x86_64) BREAKPOINT=\"G_STMT_START { __asm__ (\\\"int \\$03\\\"); } G_STMT_END\" ;;\n   esac\nfi\nAC_SUBST(GNUC_PRETTY)\nAC_SUBST(GNUC_UNUSED)\nAC_SUBST(GNUC_NORETURN)\nAC_SUBST(BREAKPOINT)\n\nAC_C_BIGENDIAN([ORDER=G_BIG_ENDIAN],[ORDER=G_LITTLE_ENDIAN])\n\ncase $host in\n*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)\n    PATHSEP='\\\\'\n    SEARCHSEP=';'\n    OS=\"WIN32\"\n    PIDTYPE='void *'\n    ;;\n*)\n    PATHSEP='/'\n    SEARCHSEP=':'\n    OS=\"UNIX\"\n    PIDTYPE='int'\n    ;;\nesac\n\ncase $host in\n\t*-*-solaris*)\n\tCFLAGS=\"$CFLAGS -D_POSIX_PTHREAD_SEMANTICS\"\n\t;;\nesac\n\ncase $target in\narm*-darwin*|aarch64*-*)\n    CFLAGS=\"$CFLAGS -U_FORTIFY_SOURCE\"\n    ;;\ni*86-*-darwin*)\n    ORDER=G_LITTLE_ENDIAN\n    ;;\n*-*-haiku*)\n    LDFLAGS=\"$LDFLAGS -ltextencoding\"\n    ;;\n*-*-openbsd*)\n    CFLAGS=\"$CFLAGS -pthread\"\n    LDFLAGS=\"$LDFLAGS -pthread\"\n    ;;\nesac\n\nAC_SUBST(ORDER)\nAC_SUBST(CFLAGS)\nAC_SUBST(PATHSEP)\nAC_SUBST(SEARCHSEP)\nAC_SUBST(OS)\nAC_SUBST(PIDTYPE)\n\n# Defined for all targets/platforms using classic Windows API support.\nAC_DEFINE(HAVE_CLASSIC_WINAPI_SUPPORT, 1, [Use classic Windows API support])\nAC_DEFINE(HAVE_UWP_WINAPI_SUPPORT, 0, [Don't use UWP Windows API support])\n\nAC_CHECK_FUNCS(strlcpy stpcpy strtok_r rewinddir vasprintf strerror_r)\nAC_CHECK_FUNCS(getrlimit)\nAC_CHECK_FUNCS(fork execv execve)\n\nAC_ARG_WITH([overridable-allocators], [  --with-overridable-allocators\tallow g_*alloc/g_free to call custom allocators set via g_mem_set_vtable])\n\nif test x$with_overridable_allocators = xyes; then\n\tAC_DEFINE(ENABLE_OVERRIDABLE_ALLOCATORS,1,[Overridable allocator support enabled])\n  AC_MSG_NOTICE([Overridable allocator support enabled])\nelse\n  AC_MSG_NOTICE([Overridable allocator support disabled])\nfi\n\n#\n# Mono currently supports 10.6, but strndup is not available prior to 10.7; avoiding\n# the detection of strndup on OS X so Mono built on 10.7+ still runs on 10.6. This can be\n# removed once support for 10.6 is dropped.\n#\n# iOS detection of strndup and getpwuid_r is faulty for some reason so let's simply avoid it\n#\nif test x$target_osx = xyes; then\nAC_CHECK_FUNCS(getpwuid_r)\nelif test x$target_ios = xno; then\nAC_CHECK_FUNCS(strndup getpwuid_r)\nfi\n\nAM_CONDITIONAL(NEED_VASPRINTF, test x$ac_cv_func_vasprintf = xno || test x$with_overridable_allocators = xyes)\nAM_ICONV()\nAC_SEARCH_LIBS(sqrtf, m)\n\n# nanosleep may not be part of libc, also search it in other libraries\nAC_SEARCH_LIBS(nanosleep, rt)\n\nAC_SEARCH_LIBS(dlopen, dl)\nold_ldflags=\"${LDFLAGS}\"\nLDFLAGS=\"${LDFLAGS} -Wl,-export-dynamic\"\nAC_TRY_LINK(, [int i;], found_export_dynamic=yes, found_export_dynamic=no)\nif test $found_export_dynamic = no; then\n\tLDFLAGS=\"${old_ldflags}\"\nfi\n\nAC_MSG_CHECKING(for varargs macros)\nAC_TRY_COMPILE([],[\nint foo (int i, int j);\n#define bar(...) foo (1, __VA_ARGS__)\nvoid main () {\n\t bar (2);\n}\n],have_iso_varargs=yes,have_iso_varargs=no)\nAC_MSG_RESULT($have_iso_varargs)\nG_HAVE_ISO_VARARGS=0\nif test \"x$have_iso_varargs\" = \"xyes\"; then\n   G_HAVE_ISO_VARARGS=1\nfi\nAC_SUBST(G_HAVE_ISO_VARARGS)\n\nAC_CHECK_HEADERS(getopt.h sys/select.h sys/time.h sys/wait.h pwd.h iconv.h localcharset.h sys/types.h sys/resource.h)\nAC_CHECK_LIB([iconv], [locale_charset],[],[AC_CHECK_LIB([charset], [locale_charset],[LIBS+=\"-liconv -lcharset\"])])\nAC_CHECK_HEADER(alloca.h, [HAVE_ALLOCA_H=1], [HAVE_ALLOCA_H=0])\nAC_SUBST(HAVE_ALLOCA_H)\n\nif test $ac_cv_sizeof_void_p = $ac_cv_sizeof_int; then\n   GPOINTER_TO_INT=\"((gint) (ptr))\"\n   GPOINTER_TO_UINT=\"((guint) (ptr))\"\n   GINT_TO_POINTER=\"((gpointer) (v))\"\n   GUINT_TO_POINTER=\"((gpointer) (v))\"\n   GSIZE=\"int\"\n   GSIZE_FORMAT='\"u\"'\nelif test $ac_cv_sizeof_void_p = $ac_cv_sizeof_long; then\n   GPOINTER_TO_INT=\"((gint)(long) (ptr))\"\n   GPOINTER_TO_UINT=\"((guint)(long) (ptr))\"\n   GINT_TO_POINTER=\"((gpointer)(glong) (v))\"\n   GUINT_TO_POINTER=\"((gpointer)(gulong) (v))\"\n   GSIZE=\"long\"\n   GSIZE_FORMAT='\"lu\"'\nelif test $ac_cv_sizeof_void_p = $ac_cv_sizeof_long_long; then\n   GPOINTER_TO_INT=\"((gint)(long long) (ptr))\"\n   GPOINTER_TO_UINT=\"((guint)(unsigned long long) (ptr))\"\n   GINT_TO_POINTER=\"((gpointer)(long long) (v))\"\n   GUINT_TO_POINTER=\"((gpointer)(unsigned long long) (v))\"\n   GSIZE=\"long long\"\n   GSIZE_FORMAT='\"I64u\"'\nelse\n   AC_MSG_ERROR([unsupported pointer size])\nfi\n\nAC_SUBST(GPOINTER_TO_INT)\nAC_SUBST(GPOINTER_TO_UINT)\nAC_SUBST(GINT_TO_POINTER)\nAC_SUBST(GUINT_TO_POINTER)\nAC_SUBST(GSIZE)\nAC_SUBST(GSIZE_FORMAT)\nAC_SUBST(G_GUINT64_FORMAT)\nAC_SUBST(G_GINT64_FORMAT)\nAC_SUBST(G_GUINT32_FORMAT)\nAC_SUBST(G_GINT32_FORMAT)\n\n#\n# END OF EGLIB CHECKS\n#\n\nAC_ARG_WITH([libgdiplus],\n\t[  --with-libgdiplus=installed|sibling|<path>\tOverride the libgdiplus used for System.Drawing tests (defaults to installed)],\n\t[], [with_libgdiplus=installed])\n\n# default install location\nlibgdiplus_install_loc=libgdiplus${libsuffix}\ncase \"$host\" in\n    *-*-*linux*)\n    libgdiplus_install_loc=libgdiplus${libsuffix}.0\n    ;;\nesac\n\ncase $with_libgdiplus in\n    no|installed)\n    libgdiplus_loc=\n    ;;\n\n    yes|sibling)\n    libgdiplus_loc=`cd ../libgdiplus && pwd`/src/libgdiplus.la\n    ;;\n\n    /*) # absolute path, assume it is an install location\n    libgdiplus_loc=$with_libgdiplus\n    libgdiplus_install_loc=$with_libgdiplus\n    ;;\n\n    *)\n    libgdiplus_loc=`pwd`/$with_libgdiplus\n    ;;\nesac\nAC_SUBST([libgdiplus_loc])\nAC_SUBST([libgdiplus_install_loc])\n\nAC_ARG_ENABLE(icall-symbol-map,[  --enable-icall-symbol-map Generate tables which map icall functions to their C symbols], icall_symbol_map=$enableval, icall_symbol_map=no)\nif test \"x$icall_symbol_map\" = \"xyes\"; then\n   AC_DEFINE(ENABLE_ICALL_SYMBOL_MAP, 1, [Icall symbol map enabled])\nfi\n\nAC_ARG_ENABLE(icall-export,[  --enable-icall-export Export icall functions], icall_export=$enableval, icall_export=no)\nif test \"x$icall_export\" = \"xyes\"; then\n   AC_DEFINE(ENABLE_ICALL_EXPORT, 1, [Icall export enabled])\nfi\n\nAC_ARG_ENABLE(icall-tables,[  --disable-icall-tables Disable the runtime lookup of icalls], icall_tables=$enableval, icall_tables=yes)\nif test \"x$icall_tables\" = \"xno\"; then\n   AC_DEFINE(DISABLE_ICALL_TABLES, 1, [Icall tables disabled])\nfi\n\nif test \"x$with_tls\" = \"x__thread\"; then\n\tAC_DEFINE(HAVE_KW_THREAD, 1, [Have __thread keyword])\n\t# Pass the information to libgc\n\tCPPFLAGS=\"$CPPFLAGS -DUSE_COMPILER_TLS\"\n\tAC_MSG_CHECKING(if the tls_model attribute is supported)\n\tAC_TRY_COMPILE([static __thread int foo __attribute__((tls_model(\"initial-exec\")));], [\n\t\t], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_TLS_MODEL_ATTR, 1, [tls_model available])\n\t\t], [\n\t\t\tAC_MSG_RESULT(no)\n\t])\nfi\n\nif test ${TARGET} = ARM; then\n\tdnl ******************************************\n\tdnl *** Check to see what FPU is available ***\n\tdnl ******************************************\n\tAC_MSG_CHECKING(which FPU to use)\n\n\t#\n\t# This is a bit tricky:\n\t#\n\t# if (__ARM_PCS_VFP) {\n\t# \t/* mfloat-abi=hard == VFP with hard ABI */\n\t# } elif (!__SOFTFP__) {\n\t# \t/* mfloat-abi=softfp == VFP with soft ABI */\n\t# } else {\n\t# \t/* mfloat-abi=soft == no VFP */\n\t# }\n\t#\n\t# The exception is iOS (w/ GCC) where none of the above\n\t# are defined (but iOS always uses the 'softfp' ABI).\n\t#\n\t# No support for FPA.\n\t#\n\n\tfpu=NONE\n\n\t# iOS GCC always uses the 'softfp' ABI.\n\tif test x\"$GCC\" = xyes && test x$host_darwin = xyes; then\n\t\tfpu=VFP\n\tfi\n\n\t# Are we using the 'hard' ABI?\n\tif test x$fpu = xNONE; then\n\t\tAC_TRY_COMPILE([], [\n\t\t\t#ifndef __ARM_PCS_VFP\n\t\t\t#error \"Float ABI is not 'hard'\"\n\t\t\t#endif\n\t\t\treturn 0;\n\t\t], [\n\t\t\tfpu=VFP_HARD\n\t\t], [\n\t\t\tfpu=NONE\n\t\t])\n\tfi\n\n\t# No 'hard' ABI. 'soft' or 'softfp'?\n\tif test x$fpu = xNONE; then\n\t\tAC_TRY_COMPILE([], [\n\t\t\t#ifdef __SOFTFP__\n\t\t\t#error \"Float ABI is not 'softfp'\"\n\t\t\t#endif\n\t\t\treturn 0;\n\t\t], [\n\t\t\tfpu=VFP\n\t\t], [\n\t\t\tfpu=NONE\n\t\t])\n\tfi\n\n\tif test x$arm_fpu != x; then\n\t   fpu=$arm_fpu\n\tfi\n\n\tAC_MSG_RESULT($fpu)\n\tCPPFLAGS=\"$CPPFLAGS -DARM_FPU_$fpu=1\"\n\tunset fpu\n\n\tdnl *********************************************\n\tdnl *** Check which ARM version(s) we can use ***\n\tdnl *********************************************\n\tAC_MSG_CHECKING(which ARM version to use)\n\n\tAC_TRY_COMPILE([], [\n\t\t#if !defined(__ARM_ARCH_5T__) && !defined(__ARM_ARCH_5TE__) && !defined(__ARM_ARCH_5TEJ__)\n\t\t#error Not on ARM v5.\n\t\t#endif\n\t\treturn 0;\n\t], [\n\t\tarm_v5=yes\n\n\t\tarm_ver=ARMv5\n\t], [])\n\n\tAC_TRY_COMPILE([], [\n\t\t#if !defined(__ARM_ARCH_6J__) && !defined(__ARM_ARCH_6ZK__) && !defined(__ARM_ARCH_6K__) && !defined(__ARM_ARCH_6T2__) && !defined(__ARM_ARCH_6M__)\n\t\t#error Not on ARM v6.\n\t\t#endif\n\t\treturn 0;\n\t], [\n\t\tarm_v5=yes\n\t\tarm_v6=yes\n\n\t\tarm_ver=ARMv6\n\t], [])\n\n\tAC_TRY_COMPILE([], [\n\t\t#if !defined(__ARM_ARCH_7A__) && !defined(__ARM_ARCH_7R__) && !defined(__ARM_ARCH_7EM__) && !defined(__ARM_ARCH_7M__) && !defined(__ARM_ARCH_7S__)\n\t\t#error Not on ARM v7.\n\t\t#endif\n\t\treturn 0;\n\t], [\n\t\tarm_v5=yes\n\t\tarm_v6=yes\n\t\tarm_v7=yes\n\n\t\tarm_ver=ARMv7\n\t], [])\n\n\tAC_MSG_RESULT($arm_ver)\n\n\tif test x$arm_v5 = xyes; then\n\t\tAC_DEFINE(HAVE_ARMV5, 1, [ARM v5])\n\t\tCPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DHAVE_ARMV5=1\"\n\tfi\n\n\tif test x$arm_v6 = xyes; then\n\t\tAC_DEFINE(HAVE_ARMV6, 1, [ARM v6])\n\t\tCPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DHAVE_ARMV6=1\"\n\tfi\n\n\tif test x$arm_v7 = xyes; then\n\t\tAC_DEFINE(HAVE_ARMV7, 1, [ARM v7])\n\t\tCPPFLAGS_FOR_LIBGC=\"$CPPFLAGS_FOR_LIBGC -DHAVE_ARMV7=1\"\n\tfi\nfi\n\nif test ${TARGET} = unknown; then\n\tCPPFLAGS=\"$CPPFLAGS -DNO_PORT\"\n\tAC_MSG_WARN(\"mono has not been ported to $host: some things may not work.\")\nfi\n\nif test \"x$platform_android\" = \"xyes\"; then\n\tcase \"x${TARGET}\" in\n\txARM)\n\t\tcase \"x$arm_ver\" in\n\t\txARMv5)\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=android-armv5\n\t\t\t;;\n\t\txARMv6)\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=android-armv6\n\t\t\t;;\n\t\txARMv7)\n\t\t\tBTLS_SUPPORTED=yes\n\t\t\tBTLS_PLATFORM=android-armv7\n\t\t\t;;\n\t\t*)\n\t\t\tBTLS_SUPPORTED=no\n\t\t\t;;\n\t\tesac\n\t\t;;\n\txARM64)\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=android-v8a\n\t\t;;\n\txX86)\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=android-x86\n\t\t;;\n\txAMD64)\n\t\tBTLS_SUPPORTED=yes\n\t\tBTLS_PLATFORM=android-x64\n\t\t;;\n\t*)\n\t\tBTLS_SUPPORTED=no\n\t\t;;\n\tesac\nfi\n\nif test ${ACCESS_UNALIGNED} = no; then\n\tCPPFLAGS=\"$CPPFLAGS -DNO_UNALIGNED_ACCESS\"\nfi\n\nif test x$host_darwin = xyes; then\n\tAC_MSG_CHECKING([for ranlib that supports -no_warning_for_no_symbols option])\n\tAS_IF(\n\t\t[$RANLIB -no_warning_for_no_symbols 2>&1 | grep -q \"unknown option\"],\n\t\t[AC_MSG_RESULT([no])],\n\t\t[\n\t\t\t# avoid AR calling ranlib, libtool calls it anyway. suppress no symbols warning.\n\t\t\tAR_FLAGS=\"Scru\"\n\t\t\tRANLIB=\"$RANLIB -no_warning_for_no_symbols\"\n\t\t\tAC_MSG_RESULT([yes])\n\t\t]\n\t)\nfi\n\ncase \"x$libgc\" in\n\txincluded)\n\t\t# Pass CPPFLAGS to libgc configure\n\t\t# We should use a separate variable for this to avoid passing useless and\n\t\t# potentially problematic defines to libgc (like -D_FILE_OFFSET_BITS=64)\n\t\t# This should be executed late so we pick up the final version of CPPFLAGS\n\t\t# The problem with this approach, is that during a reconfigure, the main\n\t\t# configure scripts gets invoked with these arguments, so we use separate\n\t\t# variables understood by libgc's configure to pass CPPFLAGS and CFLAGS.\n\t\tTMP_CPPFLAGS=\"$CPPFLAGS $CPPFLAGS_FOR_LIBGC\"\n\t\tif test x$TARGET = xSPARC -o x$TARGET = xSPARC64; then\n\t\t\tTMP_CPPFLAGS=`echo $TMP_CPPFLAGS | sed -e 's/-D_FILE_OFFSET_BITS=64//g'`\n\t\tfi\n\t\t# Don't pass -finstrument-for-thread-suspension in, \n\t\t# if these are instrumented it will be very bad news \n\t\t# (infinite recursion, undefined parking behavior, etc)\n\t\tTMP_CPPFLAGS=`echo $TMP_CPPFLAGS | sed -e 's/-finstrument-for-thread-suspension//g'`\n\t\tac_configure_args=\"$ac_configure_args --disable-embed-check --with-libgc-threads=$libgc_threads $libgc_configure_args \\\"CPPFLAGS_FOR_LIBGC=$TMP_CPPFLAGS\\\" \\\"CFLAGS_FOR_LIBGC=$CFLAGS_FOR_LIBGC\\\"\"\n\t\tif test \"x$support_boehm\" = \"xyes\"; then\n\t\t\tAC_CONFIG_SUBDIRS(libgc)\n\t\tfi\n\t\t;;\nesac\n\nMALLOC_MEMPOOLS=no\nAC_ARG_WITH(malloc_mempools,[  --with-malloc-mempools=yes,no  Use malloc for each single mempool allocation (only for runtime debugging, defaults to no)],[\n\tif test x$with_malloc_mempools = xyes; then\n\t\tMALLOC_MEMPOOLS=yes\n\t\tAC_DEFINE(USE_MALLOC_FOR_MEMPOOLS,1,[Use malloc for each single mempool allocation])\n\tfi\n])\n\n\nDISABLE_MCS_DOCS=default\nAC_ARG_WITH(mcs_docs,[  --with-mcs-docs=yes,no         If you want to build the documentation under mcs (defaults to yes)],[\n\tif test x$with_mcs_docs != xyes; then\n\t\tDISABLE_MCS_DOCS=yes\n\tfi\n])\nif test -n \"$INSTALL_4_x_TRUE\"; then :\n\tDISABLE_MCS_DOCS=yes\nfi\nif test \"x$DISABLE_MCS_DOCS\" = \"xdefault\"; then\n   DISABLE_MCS_DOCS=$DISABLE_MCS_DOCS_default\nfi\n\nAC_ARG_WITH(lazy_gc_thread_creation, [  --with-lazy-gc-thread-creation=yes|no      Enable lazy runtime thread creation, embedding host must do it explicitly (defaults to no)],[\n\tif test x$with_lazy_gc_thread_creation != xno ; then\n\t\tAC_DEFINE(LAZY_GC_THREAD_CREATION,1,[Enable lazy gc thread creation by the embedding host.])\n\tfi\n], [with_lazy_gc_thread_creation=no])\n\nAC_ARG_WITH(cooperative_gc, [  --with-cooperative-gc=yes|no      Enable cooperative stop-the-world garbage collection (sgen only) (defaults to no)], [], [with_cooperative_gc=default])\n\nif test x$with_cooperative_gc = xdefault; then\n\twith_cooperative_gc=$with_cooperative_gc_default\nfi\n\nif test x$with_cooperative_gc != xno; then\n\tAC_DEFINE(USE_COOP_GC,1,[Enable cooperative stop-the-world garbage collection.])\nfi\n\nAM_CONDITIONAL([ENABLE_COOP], [test x$with_cooperative_gc != xno])\n\nAC_ARG_ENABLE(checked_build, [  --enable-checked-build=LIST      To enable checked build (expensive asserts), configure with a comma-separated LIST of checked build modules and then include that same list in the environment variable MONO_CHECK_MODE at runtime. Recognized checked build modules: all, gc, metadata, thread],[\n\n\tif test x$enable_checked_build != x ; then\n\t\tAC_DEFINE(ENABLE_CHECKED_BUILD,1,[Enable checked build])\n\tfi\n\tfor feature in `echo \"$enable_checked_build\" | sed -e \"s/,/ /g\"`; do\n\t\teval \"mono_checked_build_test_enable_$feature='yes'\"\n\tdone\n\n\tif test \"x$mono_checked_build_test_enable_all\" = \"xyes\"; then\n\t\teval \"mono_checked_build_test_enable_gc='yes'\"\n\t\teval \"mono_checked_build_test_enable_metadata='yes'\"\n\t\teval \"mono_checked_build_test_enable_thread='yes'\"\n\tfi\n\n\tif test \"x$mono_checked_build_test_enable_gc\" = \"xyes\"; then\n\t\tAC_DEFINE(ENABLE_CHECKED_BUILD_GC, 1, [Enable GC checked build])\n\tfi\n\n\tif test \"x$mono_checked_build_test_enable_metadata\" = \"xyes\"; then\n\t\tAC_DEFINE(ENABLE_CHECKED_BUILD_METADATA, 1, [Enable metadata checked build])\n\tfi\n\n\tif test \"x$mono_checked_build_test_enable_thread\" = \"xyes\"; then\n\t\tAC_DEFINE(ENABLE_CHECKED_BUILD_THREAD, 1, [Enable thread checked build])\n\tfi\n\n], [])\n\nAC_CHECK_HEADER([malloc.h], \n\t\t[AC_DEFINE([HAVE_USR_INCLUDE_MALLOC_H], [1], \n\t\t\t[Define to 1 if you have /usr/include/malloc.h.])],,)\n\nif test x\"$GCC\" = xyes; then\n   \t# Implicit function declarations are not 64 bit safe\n\t# Do this late, since this causes lots of configure tests to fail\n\tCFLAGS=\"$CFLAGS -Werror-implicit-function-declaration\"\n\t# jay has a lot of implicit declarations\n\tJAY_CFLAGS=\"-Wno-implicit-function-declaration\"\nfi\n\n# When --disable-shared is used, libtool transforms libmono-2.0.la into libmono-2.0.so\n# instead of libmono-static.a\nif test \"x$enable_shared\" = \"xno\" -a \"x$enable_executables\" = \"xyes\"; then\n   LIBMONO_LA=libmini-static.la\nelse\n   if test x$buildsgen = xyes; then\n      LIBMONO_LA=libmonosgen-$API_VER.la\n   else\n      LIBMONO_LA=libmonoboehm-$API_VER.la\n   fi\nfi\nAC_SUBST(LIBMONO_LA)\n\ndnl **************\ndnl ***  Btls  ***\ndnl **************\n\nAC_ARG_ENABLE(btls, [  --disable-btls             Disable the BoringTls provider], enable_btls=$enableval, enable_btls=$BTLS_SUPPORTED)\nAC_ARG_ENABLE(btls-lib, [  --disable-btls-lib             Disable building the BTLS native library], enable_btls_lib=$enableval, enable_btls_lib=$BTLS_SUPPORTED)\nAC_ARG_WITH(btls_android_ndk, [  --with-btls-android-ndk        Android NDK for BoringTls])\n\nif test \"x$enable_btls\" = \"xno\"; then\n   enable_btls_lib=no\nfi\n\nAM_CONDITIONAL(BTLS, test x$enable_btls_lib = xyes)\n\nbtls_android=no\nif test \"x$enable_btls\" = \"xyes\"; then\n\tAC_PATH_PROG(CMAKE, [cmake], [no], [$PATH:/Applications/CMake.app/Contents/bin:/usr/local/bin])\n\tif test \"x$CMAKE\" = \"xno\"; then\n\t\tAC_MSG_ERROR(\"cmake not found\")\n\tfi\n\n\tBTLS_ROOT=`cd $srcdir && pwd`/external/boringssl\n\tAC_SUBST(BTLS_ROOT)\n\n\tbtls_arch=\n\tbtls_cflags=\n\tBTLS_CMAKE_ARGS=\n\n\tcase \"$BTLS_PLATFORM\" in\n\ti386)\n\t\tbtls_arch=i386\n\t\tbtls_cflags=\"-m32\"\n\t\tcase $host_os in\n\t\t\tdarwin*)\n\t\t\t\tbtls_cflags=\"$btls_cflags -arch i386\"\n\t\tesac\n\t\t;;\n\tx86_64)\n\t\tbtls_arch=x86_64\n\t\t;;\n\tarm)\n\t\tbtls_arch=arm\n\t\t;;\n\tarmsoft)\n\t\tbtls_arch=arm\n\t\tbtls_cflags=\"-DOPENSSL_NO_ASM=1\"\n\t\t;;\n\taarch64)\n\t\tbtls_arch=aarch64\n\t\t;;\n\tandroid-armv5)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"armeabi\\\" -DANDROID_NATIVE_API_LEVEL=14\"\n\t\t;;\n\tandroid-armv6)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"armeabi\\\" -DANDROID_NATIVE_API_LEVEL=14\"\n\t\t;;\n\tandroid-armv7)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"armeabi-v7a\\\" -DANDROID_NATIVE_API_LEVEL=14\"\n\t\t;;\n\tandroid-v8a)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"arm64-v8a\\\" -DANDROID_NATIVE_API_LEVEL=21\"\n\t\t;;\n\tandroid-x86)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"x86\\\" -DANDROID_NATIVE_API_LEVEL=14\"\n\t\t;;\n\tandroid-x64)\n\t\tBTLS_CMAKE_ARGS=\"-DANDROID_ABI=\\\"x86_64\\\" -DANDROID_NATIVE_API_LEVEL=21\"\n\t\t;;\n\t*)\n\t\tAC_MSG_ERROR(Invalid BTLS platform)\n\tesac\n\n\tif test \"x$platform_android\" = \"xyes\"; then\n\t\tbtls_android=yes\n\t\tBTLS_CMAKE_ARGS=\"$BTLS_CMAKE_ARGS -DCMAKE_TOOLCHAIN_FILE=$BTLS_ROOT/util/android-cmake/android.toolchain.cmake\"\n\t\tif test \"x$with_btls_android_ndk\" != \"x\"; then\n\t\t\tBTLS_CMAKE_ARGS=\"$BTLS_CMAKE_ARGS -DANDROID_NDK=\\\"$with_btls_android_ndk\\\"\"\n\t\telse\n\t\t\tAC_MSG_ERROR([Need to pass the --with-btls-android-ndk argument when building with BTLS support on Android.])\n\t\tfi\n\tfi\n\n\tif test \"x$btls_arch\" != \"x\"; then\n\t\tBTLS_CMAKE_ARGS=\"$BTLS_CMAKE_ARGS -DBTLS_ARCH=\\\"$btls_arch\\\"\"\n\tfi\n\n\tBTLS_CFLAGS=\"$CPPFLAGS_FOR_BTLS $btls_cflags\"\n\tAC_SUBST(BTLS_ARCH)\n\tAC_SUBST(BTLS_CFLAGS)\n\tAC_SUBST(BTLS_PLATFORM)\n\tAC_SUBST(BTLS_CMAKE_ARGS)\n\n\tAC_DEFINE(HAVE_BTLS, 1, [BoringTls is supported])\nelse\n\tenable_btls=no\nfi\n\nAM_CONDITIONAL(BTLS_ANDROID, test x$btls_android = xyes)\n\nif test x$DISABLE_MCS_DOCS = xyes; then\n   docs_dir=\"\"\nelse\n   docs_dir=docs\nfi\nAC_SUBST(docs_dir)\n\n## Maybe should also disable if mcsdir is invalid.  Let's punt the issue for now.\nAM_CONDITIONAL(BUILD_MCS, [test x$cross_compiling = xno && test x$enable_mcs_build != xno])\nAM_CONDITIONAL(BUILD_SUPPORT, [test x$enable_support_build != xno])\n\nlibmono_ldflags=\"$libmono_ldflags $LIBS\"\n\nAM_CONDITIONAL(MIPS_GCC, test ${TARGET}${ac_cv_prog_gcc} = MIPSyes)\nAM_CONDITIONAL(MIPS_SGI, test ${TARGET}${ac_cv_prog_gcc} = MIPSno)\nAM_CONDITIONAL(SPARC, test x$TARGET = xSPARC)\nAM_CONDITIONAL(SPARC64, test x$TARGET = xSPARC64)\nAM_CONDITIONAL(X86, test x$TARGET = xX86)\nAM_CONDITIONAL(AMD64, test x$TARGET = xAMD64)\nAM_CONDITIONAL(MIPS, test x$TARGET = xMIPS)\nAM_CONDITIONAL(POWERPC, test x$TARGET = xPOWERPC)\nAM_CONDITIONAL(POWERPC64, test x$TARGET = xPOWERPC64)\nAM_CONDITIONAL(ARM, test x$TARGET = xARM)\nAM_CONDITIONAL(ARM64, test x$TARGET = xARM64)\nAM_CONDITIONAL(S390X, test x$TARGET = xS390X)\nAM_CONDITIONAL(WASM, test x$TARGET = xWASM)\nAM_CONDITIONAL(HOST_X86, test x$HOST = xX86)\nAM_CONDITIONAL(HOST_AMD64, test x$HOST = xAMD64)\nAM_CONDITIONAL(HOST_ARM, test x$HOST = xARM)\nAM_CONDITIONAL(HOST_ARM64, test x$HOST = xARM64)\nAM_CONDITIONAL(HOST_WASM, test x$HOST = xWASM)\n\nAM_CONDITIONAL(CROSS_COMPILE, test \"x$host\" != \"x$target\")\n\nAC_SUBST(LIBC)\nAC_SUBST(INTL)\nAC_SUBST(SQLITE)\nAC_SUBST(SQLITE3)\nAC_SUBST(X11)\nAC_SUBST(GDKX11)\nAC_SUBST(GTKX11)\nAC_SUBST(XINERAMA)\nAC_DEFINE_UNQUOTED(MONO_ARCHITECTURE,\"$arch_target\",[The architecture this is running on])\nAC_SUBST(arch_target)\nAC_SUBST(CFLAGS)\nAC_SUBST(CPPFLAGS)\nAC_SUBST(LDFLAGS)\n\n#This must always be defined when building the runtime\nAC_DEFINE(MONO_INSIDE_RUNTIME,1, [Disable banned functions from being used by the runtime])\n\nmono_build_root=`pwd`\nAC_SUBST(mono_build_root)\n\nmono_runtime=mono/mini/mono\nAC_SUBST(mono_runtime)\n\nCSC_LOCATION=`cd $srcdir && pwd`/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/csc.exe\n\nif test $csc_compiler = mcs; then\n  CSC=$mcs_topdir/class/lib/build/mcs.exe\nelse\n  CSC=$CSC_LOCATION\nfi\n\nmono_cfg_root=$mono_build_root/runtime\nif test x$host_win32 = xyes; then\n  if test \"x$cross_compiling\" = \"xno\"; then\n    mono_cfg_dir=`cygpath -w -a $mono_cfg_root`\\\\etc\n    CSC=`cygpath -m -a $CSC`\n    CSC_LOCATION=`cygpath -m -a $CSC_LOCATION`\n  else\n    mono_cfg_dir=`echo $mono_cfg_root | tr '/' '\\\\'`\\\\etc\n  fi\nelse\n  mono_cfg_dir=$mono_cfg_root/etc\nfi\nAC_SUBST(mono_cfg_dir)\n\nAC_SUBST(CSC)\n\nAC_CONFIG_FILES([po/mcs/Makefile.in])\n\nAC_CONFIG_FILES([runtime/mono-wrapper],[chmod +x runtime/mono-wrapper])\nAC_CONFIG_FILES([runtime/monodis-wrapper],[chmod +x runtime/monodis-wrapper])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/1.0/machine.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/1.0\n    cd runtime/etc/mono/1.0\n    rm -f machine.config\n    $LN_S $reldir/data/net_1_1/machine.config machine.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/2.0/machine.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/2.0\n    cd runtime/etc/mono/2.0\n    rm -f machine.config\n    $LN_S $reldir/data/net_2_0/machine.config machine.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/2.0/web.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/2.0\n    cd runtime/etc/mono/2.0\n    rm -f web.config\n    $LN_S $reldir/data/net_2_0/web.config web.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/browscap.ini],\n[   depth=../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/\n    cd runtime/etc/mono/\n    rm -f browscap.ini\n    $LN_S $reldir/data/browscap.ini browscap.ini\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/2.0/Browsers/Compat.browser],\n[   depth=../../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/2.0/Browsers/\n    cd runtime/etc/mono/2.0/Browsers\n    rm -f Compat.browser\n    $LN_S $reldir/data/Browsers/Compat.browser Compat.browser\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.0/Browsers/Compat.browser],\n[   depth=../../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.0/Browsers/\n    cd runtime/etc/mono/4.0/Browsers\n    rm -f Compat.browser\n    $LN_S $reldir/data/Browsers/Compat.browser Compat.browser\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.5/Browsers/Compat.browser],\n[   depth=../../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.5/Browsers/\n    cd runtime/etc/mono/4.5/Browsers\n    rm -f Compat.browser\n    $LN_S $reldir/data/Browsers/Compat.browser Compat.browser\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.0/machine.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.0\n    cd runtime/etc/mono/4.0\n    rm -f machine.config\n    $LN_S $reldir/data/net_4_0/machine.config machine.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.0/web.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.0\n    cd runtime/etc/mono/4.0\n    rm -f web.config\n    $LN_S $reldir/data/net_4_0/web.config web.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.5/machine.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.5\n    cd runtime/etc/mono/4.5\n    rm -f machine.config\n    $LN_S $reldir/data/net_4_5/machine.config machine.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([runtime/etc/mono/4.5/web.config],\n[   depth=../../../..\n    case $srcdir in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) reldir=$srcdir ;;\n    .) reldir=$depth ;;\n    *) reldir=$depth/$srcdir ;;\n    esac\n    $ac_aux_dir/install-sh -d runtime/etc/mono/4.5\n    cd runtime/etc/mono/4.5\n    rm -f web.config\n    $LN_S $reldir/data/net_4_5/web.config web.config\n    cd $depth\n],[LN_S='$LN_S'])\n\nAC_CONFIG_COMMANDS([quiet-libtool], [sed -e 's/echo \"copying selected/# \"copying selected/g' < libtool > libtool.tmp && mv libtool.tmp libtool && chmod a+x libtool; sed -e 's/$ECHO \"copying selected/# \"copying selected/g' < libtool > libtool.tmp && mv libtool.tmp libtool && chmod a+x libtool])\nAC_CONFIG_COMMANDS([nolock-libtool], [sed -e 's/lock_old_archive_extraction=yes/lock_old_archive_extraction=no/g' < libtool > libtool.tmp && mv libtool.tmp libtool && chmod a+x libtool])\n\nAC_OUTPUT([\nMakefile\nmono-uninstalled.pc\nacceptance-tests/Makefile\nllvm/Makefile\nscripts/mono-find-provides\nscripts/mono-find-requires\nmono/Makefile\nmono/btls/Makefile\nmono/utils/Makefile\nmono/metadata/Makefile\nmono/dis/Makefile\nmono/cil/Makefile\nmono/arch/Makefile\nmono/arch/x86/Makefile\nmono/arch/amd64/Makefile\nmono/arch/ppc/Makefile\nmono/arch/sparc/Makefile\nmono/arch/s390x/Makefile\nmono/arch/arm/Makefile\nmono/arch/arm64/Makefile\nmono/arch/mips/Makefile\nmono/sgen/Makefile\nmono/tests/Makefile\nmono/tests/tests-config\nmono/tests/gc-descriptors/Makefile\nmono/tests/testing_gac/Makefile\nmono/unit-tests/Makefile\nmono/benchmark/Makefile\nmono/mini/Makefile\nmono/profiler/Makefile\nmono/eglib/Makefile\nmono/eglib/eglib-config.h\nm4/Makefile\nikvm-native/Makefile\nscripts/Makefile\nman/Makefile\ndocs/Makefile\ndata/Makefile\ndata/net_2_0/Makefile\ndata/net_4_0/Makefile\ndata/net_4_5/Makefile\ndata/net_2_0/Browsers/Makefile\ndata/net_4_0/Browsers/Makefile\ndata/net_4_5/Browsers/Makefile\ndata/mint.pc\ndata/mono-2.pc\ndata/monosgen-2.pc\ndata/mono.pc\ndata/mono-cairo.pc\ndata/mono-nunit.pc\ndata/mono-options.pc\ndata/mono-lineeditor.pc\ndata/monodoc.pc\ndata/dotnet.pc\ndata/dotnet35.pc\ndata/wcf.pc\ndata/cecil.pc\ndata/system.web.extensions_1.0.pc\ndata/system.web.extensions.design_1.0.pc\ndata/system.web.mvc.pc\ndata/system.web.mvc2.pc\ndata/system.web.mvc3.pc\ndata/aspnetwebstack.pc\ndata/reactive.pc\nsamples/Makefile\nsupport/Makefile\ndata/config\ntools/Makefile\ntools/locale-builder/Makefile\ntools/sgen/Makefile\ntools/monograph/Makefile\ntools/pedump/Makefile\nruntime/Makefile\nmsvc/Makefile\npo/Makefile\n])\n\n# Update all submodules recursively to ensure everything is checked out\n$srcdir/scripts/update_submodules.sh\n\nif test x$host_win32 = xyes; then\n   # Get rid of 'cyg' prefixes in library names\n   sed -e \"s/\\/cyg\\//\\/\\//\" libtool > libtool.new; mv libtool.new libtool; chmod 755 libtool\n   # libtool seems to inherit -mno-cygwin from our CFLAGS, and uses it to compile its executable\n   # wrapper scripts which use exec(). gcc has no problem compiling+linking this, but the resulting\n   # executable doesn't work...\n   sed -e \"s,-mno-cygwin,,g\" libtool > libtool.new; mv libtool.new libtool; chmod 755 libtool\nfi\n\nif test x$host_darwin = xyes; then\n   # This doesn't seem to be required and it slows down parallel builds\n   sed -e 's,lock_old_archive_extraction=yes,lock_old_archive_extraction=no,g' < libtool > libtool.new && mv libtool.new libtool && chmod +x libtool\nfi\n\n(\n  case $prefix in\n  NONE) prefix=$ac_default_prefix ;;\n  esac\n  case $exec_prefix in\n  NONE) exec_prefix='${prefix}' ;;\n  esac\n\n  #\n  # If we are cross compiling, we don't build in the mcs/ tree.  Let us not clobber\n  # any existing config.make.  This allows people to share the same source tree\n  # with different build directories, one native and one cross\n  #\n  if test x$cross_compiling = xno && test x$enable_mcs_build != xno; then\n\n    test -w $mcs_topdir/build || chmod +w $mcs_topdir/build\n\n    echo \"prefix=$prefix\" > $mcs_topdir/build/config.make\n    echo \"exec_prefix=$exec_prefix\" >> $mcs_topdir/build/config.make\n    echo \"sysconfdir=$sysconfdir\" >> $mcs_topdir/build/config.make\n    echo 'mono_libdir=${exec_prefix}/lib' >> $mcs_topdir/build/config.make\n    echo \"mono_build_root=$mono_build_root\" >> $mcs_topdir/build/config.make\n    echo 'IL_FLAGS = /debug' >> $mcs_topdir/build/config.make\n    echo \"RUNTIME = $mono_build_root/runtime/mono-wrapper\" >> $mcs_topdir/build/config.make\n    echo \"ILDISASM = $mono_build_root/runtime/monodis-wrapper\" >> $mcs_topdir/build/config.make\n    echo \"JAY_CFLAGS = $JAY_CFLAGS\" >> $mcs_topdir/build/config.make\n\n    case $INSTALL in\n    [[\\\\/$]]* | ?:[[\\\\/]]* ) mcs_INSTALL=$INSTALL ;;\n    *) mcs_INSTALL=$mono_build_root/$INSTALL ;;\n    esac\n\n    echo \"INSTALL = $mcs_INSTALL\" >> $mcs_topdir/build/config.make\n\n    export VERSION\n    [myver=$($AWK 'BEGIN {\n      split (ENVIRON[\"VERSION\"] \".0.0.0\", vsplit, \".\")\n      if(length(vsplit [1]) > 4) {\n        split (substr(ENVIRON[\"VERSION\"], 0, 4) \".\" substr(ENVIRON[\"VERSION\"], 5) \".0.0\", vsplit, \".\")\n      }\n      print vsplit [1] \".\" vsplit [2] \".\" vsplit [3] \".\" vsplit [4]\n    }')]\n\n    echo \"MONO_VERSION = $myver\" >> $mcs_topdir/build/config.make\n    echo \"MONO_CORLIB_VERSION = $MONO_CORLIB_VERSION\" >> $mcs_topdir/build/config.make\n\n    if test x$host_darwin = xyes; then\n      echo \"BUILD_PLATFORM = darwin\" >> $mcs_topdir/build/config.make\n    elif test x$host_win32 = xyes; then\n      echo \"BUILD_PLATFORM = win32\" >> $mcs_topdir/build/config.make\n    else\n      echo \"BUILD_PLATFORM = linux\" >> $mcs_topdir/build/config.make\n    fi\n\n    if test x$host_darwin = xyes; then\n      echo \"HOST_PLATFORM ?= darwin\" >> $mcs_topdir/build/config.make\n    elif test x$host_win32 = xyes; then\n      echo \"HOST_PLATFORM ?= win32\" >> $mcs_topdir/build/config.make\n    else\n      echo \"HOST_PLATFORM ?= linux\" >> $mcs_topdir/build/config.make\n    fi\n\n    if test \"x$PLATFORM_AOT_SUFFIX\" != \"x\"; then\n      echo \"PLATFORM_AOT_SUFFIX = $PLATFORM_AOT_SUFFIX\" >> $mcs_topdir/build/config.make\n    fi\n\n\tif test x$AOT_SUPPORTED = xyes -a x$enable_system_aot = xdefault; then\n\t   enable_system_aot=yes\n\tfi\n\n    if test x$host_win32 = xno -a x$enable_system_aot = xyes; then\n      echo \"ENABLE_AOT = 1\" >> $mcs_topdir/build/config.make\n    fi\n\n    if test x$DISABLE_MCS_DOCS = xyes; then\n      echo \"DISABLE_MCS_DOCS = yes\" >> $mcs_topdir/build/config.make\n    fi\n\n    if test x$has_extension_module != xno; then\n        echo \"EXTENSION_MODULE = 1\" >> $srcdir/$mcsdir/build/config.make\n    fi\n    \n    echo \"DEFAULT_PROFILE = $default_profile\" >> $srcdir/$mcsdir/build/config.make\n    \n    if test \"x$test_bcl_opt\" = \"xyes\"; then    \n      echo \"BCL_OPTIMIZE = 1\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n    echo \"CSC_LOCATION = $CSC_LOCATION\" >> $srcdir/$mcsdir/build/config.make\n\n    if test $csc_compiler = mcs; then\n      echo \"MCS_MODE = 1\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n    if test \"x$AOT_BUILD_FLAGS\" != \"x\" ; then\n      echo \"AOT_RUN_FLAGS=$AOT_RUN_FLAGS\" >> $srcdir/$mcsdir/build/config.make\n      echo \"AOT_BUILD_FLAGS=$AOT_BUILD_FLAGS\" >> $srcdir/$mcsdir/build/config.make\n      echo \"AOT_BUILD_ATTRS=$AOT_BUILD_ATTRS\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n    if test \"x$AOT_MODE\" != \"x\" ; then\n      echo \"AOT_MODE=$AOT_MODE\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n    if test \"x$enable_btls\" = \"xyes\"; then\n      echo \"HAVE_BTLS=1\" >> $srcdir/$mcsdir/build/config.make\n    fi\n\n  fi\n\n)\n\nlibgdiplus_msg=${libgdiplus_loc:-assumed to be installed}\n\nbtls_platform_string=\nif test x$enable_btls = xyes; then\n\tif test x$btls_android = xyes; then\n\t\tbtls_platform_string=\" (android:$BTLS_PLATFORM)\"\n\telse\n\t\tbtls_platform_string=\" ($BTLS_PLATFORM)\"\n\tfi\nfi\n\necho \"\n        mcs source:    $mcsdir\n\tC# Compiler:   $csc_compiler\n\n   Engine:\n\tHost:\t       $host\n\tTarget:\t       $target\n\tGC:\t       $gc_msg \n\tTLS:           $with_tls\n\tSIGALTSTACK:   $with_sigaltstack\n\tEngine:        $jit_status\n\tBigArrays:     $enable_big_arrays\n\tDTrace:        $enable_dtrace\n\tLLVM Back End: $enable_llvm (dynamically loaded: $enable_loadedllvm)\n\n   Libraries:\n\t.NET 4.x:        $with_profile4_x\n\tXamarin.Android: $with_monodroid\n\tXamarin.iOS:     $with_monotouch\n\tXamarin.WatchOS: $with_monotouch_watch\n\tXamarin.TVOS:    $with_monotouch_tv\n\tXamarin.Mac:     $with_xammac\n\tWindows AOT:     $with_winaot\n\tOrbis:           $with_orbis\n\tUnreal:          $with_unreal\n\tWebAssembly:     $with_wasm\n\tTest profiles:   AOT Full ($with_testing_aot_full), AOT Hybrid ($with_testing_aot_hybrid)\n\tJNI support:     $jdk_headers_found\n\tlibgdiplus:      $libgdiplus_msg\n\tzlib:            $zlib_msg\n\tBTLS:            $enable_btls$btls_platform_string\n\t$disabled\n\"\nif test x$with_static_mono = xno -a \"x$host_win32\" != \"xyes\"; then\n   AC_MSG_WARN(Turning off static Mono is a risk, you might run into unexpected bugs)\nfi\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/ltmain.sh": "\n# libtool (GNU libtool) 2.4.2\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006,\n# 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html,\n# or obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\n# Usage: $progname [OPTION]... [MODE-ARG]...\n#\n# Provide generalized library-building support services.\n#\n#       --config             show all configuration variables\n#       --debug              enable verbose shell tracing\n#   -n, --dry-run            display commands without modifying any files\n#       --features           display basic configuration information and exit\n#       --mode=MODE          use operation mode MODE\n#       --preserve-dup-deps  don't remove duplicate dependency libraries\n#       --quiet, --silent    don't print informational messages\n#       --no-quiet, --no-silent\n#                            print informational messages (default)\n#       --no-warn            don't display warning messages\n#       --tag=TAG            use configuration variables from tag TAG\n#   -v, --verbose            print more informational messages than default\n#       --no-verbose         don't print the extra informational messages\n#       --version            print version information\n#   -h, --help, --help-all   print short, long, or detailed help message\n#\n# MODE must be one of the following:\n#\n#         clean              remove files from the build directory\n#         compile            compile a source file into a libtool object\n#         execute            automatically set library path, then run a program\n#         finish             complete the installation of libtool libraries\n#         install            install libraries or executables\n#         link               create a library or an executable\n#         uninstall          remove libraries from an installed directory\n#\n# MODE-ARGS vary depending on the MODE.  When passed as first option,\n# `--mode=MODE' may be abbreviated as `MODE' or a unique abbreviation of that.\n# Try `$progname --help --mode=MODE' for a more detailed description of MODE.\n#\n# When reporting a bug, please describe a test case to reproduce it and\n# include the following information:\n#\n#         host-triplet:\t$host\n#         shell:\t\t$SHELL\n#         compiler:\t\t$LTCC\n#         compiler flags:\t\t$LTCFLAGS\n#         linker:\t\t$LD (gnu? $with_gnu_ld)\n#         $progname:\t(GNU libtool) 2.4.2 Debian-2.4.2-1.7ubuntu1\n#         automake:\t$automake_version\n#         autoconf:\t$autoconf_version\n#\n# Report bugs to <bug-libtool@gnu.org>.\n# GNU libtool home page: <http://www.gnu.org/software/libtool/>.\n# General help using GNU software: <http://www.gnu.org/gethelp/>.\n\nPROGRAM=libtool\nPACKAGE=libtool\nVERSION=\"2.4.2 Debian-2.4.2-1.7ubuntu1\"\nTIMESTAMP=\"\"\npackage_revision=1.3337\n\n# Be Bourne compatible\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n$1\n_LTECHO_EOF'\n}\n\n# NLS nuisances: We save the old values to restore during execute mode.\nlt_user_locale=\nlt_safe_locale=\nfor lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test \\\"\\${$lt_var+set}\\\" = set; then\n          save_$lt_var=\\$$lt_var\n          $lt_var=C\n\t  export $lt_var\n\t  lt_user_locale=\\\"$lt_var=\\\\\\$save_\\$lt_var; \\$lt_user_locale\\\"\n\t  lt_safe_locale=\\\"$lt_var=C; \\$lt_safe_locale\\\"\n\tfi\"\ndone\nLC_ALL=C\nLANGUAGE=C\nexport LANGUAGE LC_ALL\n\n$lt_unset CDPATH\n\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=\"$0\"\n\n\n\n: ${CP=\"cp -f\"}\ntest \"${ECHO+set}\" = set || ECHO=${as_echo-'printf %s\\n'}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n: ${Xsed=\"$SED -e 1s/^X//\"}\n\n# Global variables:\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\nexit_status=$EXIT_SUCCESS\n\n# Make sure IFS has a sensible default\nlt_nl='\n'\nIFS=\" \t$lt_nl\"\n\ndirname=\"s,/[^/]*$,,\"\nbasename=\"s,^.*/,,\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n    func_dirname_result=`$ECHO \"${1}\" | $SED \"$dirname\"`\n    if test \"X$func_dirname_result\" = \"X${1}\"; then\n      func_dirname_result=\"${3}\"\n    else\n      func_dirname_result=\"$func_dirname_result${2}\"\n    fi\n} # func_dirname may be replaced by extended shell implementation\n\n\n# func_basename file\nfunc_basename ()\n{\n    func_basename_result=`$ECHO \"${1}\" | $SED \"$basename\"`\n} # func_basename may be replaced by extended shell implementation\n\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n    # Extract subdirectory from the argument.\n    func_dirname_result=`$ECHO \"${1}\" | $SED -e \"$dirname\"`\n    if test \"X$func_dirname_result\" = \"X${1}\"; then\n      func_dirname_result=\"${3}\"\n    else\n      func_dirname_result=\"$func_dirname_result${2}\"\n    fi\n    func_basename_result=`$ECHO \"${1}\" | $SED -e \"$basename\"`\n} # func_dirname_and_basename may be replaced by extended shell implementation\n\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n# func_strip_suffix prefix name\nfunc_stripname ()\n{\n    case ${2} in\n      .*) func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%\\\\\\\\${2}\\$%%\"`;;\n      *)  func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%${2}\\$%%\"`;;\n    esac\n} # func_stripname may be replaced by extended shell implementation\n\n\n# These SED scripts presuppose an absolute path with a trailing slash.\npathcar='s,^/\\([^/]*\\).*$,\\1,'\npathcdr='s,^/[^/]*,,'\nremovedotparts=':dotsl\n\t\ts@/\\./@/@g\n\t\tt dotsl\n\t\ts,/\\.$,/,'\ncollapseslashes='s@/\\{1,\\}@/@g'\nfinalslash='s,/*$,/,'\n\n# func_normal_abspath PATH\n# Remove doubled-up and trailing slashes, \".\" path components,\n# and cancel out any \"..\" path components in PATH after making\n# it an absolute path.\n#             value returned in \"$func_normal_abspath_result\"\nfunc_normal_abspath ()\n{\n  # Start from root dir and reassemble the path.\n  func_normal_abspath_result=\n  func_normal_abspath_tpath=$1\n  func_normal_abspath_altnamespace=\n  case $func_normal_abspath_tpath in\n    \"\")\n      # Empty path, that just means $cwd.\n      func_stripname '' '/' \"`pwd`\"\n      func_normal_abspath_result=$func_stripname_result\n      return\n    ;;\n    # The next three entries are used to spot a run of precisely\n    # two leading slashes without using negated character classes;\n    # we take advantage of case's first-match behaviour.\n    ///*)\n      # Unusual form of absolute path, do nothing.\n    ;;\n    //*)\n      # Not necessarily an ordinary path; POSIX reserves leading '//'\n      # and for example Cygwin uses it to access remote file shares\n      # over CIFS/SMB, so we conserve a leading double slash if found.\n      func_normal_abspath_altnamespace=/\n    ;;\n    /*)\n      # Absolute path, do nothing.\n    ;;\n    *)\n      # Relative path, prepend $cwd.\n      func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath\n    ;;\n  esac\n  # Cancel out all the simple stuff to save iterations.  We also want\n  # the path to end with a slash for ease of parsing, so make sure\n  # there is one (and only one) here.\n  func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$removedotparts\" -e \"$collapseslashes\" -e \"$finalslash\"`\n  while :; do\n    # Processed it all yet?\n    if test \"$func_normal_abspath_tpath\" = / ; then\n      # If we ascended to the root using \"..\" the result may be empty now.\n      if test -z \"$func_normal_abspath_result\" ; then\n        func_normal_abspath_result=/\n      fi\n      break\n    fi\n    func_normal_abspath_tcomponent=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcar\"`\n    func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcdr\"`\n    # Figure out what to do with it\n    case $func_normal_abspath_tcomponent in\n      \"\")\n        # Trailing empty path component, ignore it.\n      ;;\n      ..)\n        # Parent dir; strip last assembled component from result.\n        func_dirname \"$func_normal_abspath_result\"\n        func_normal_abspath_result=$func_dirname_result\n      ;;\n      *)\n        # Actual path component, append it.\n        func_normal_abspath_result=$func_normal_abspath_result/$func_normal_abspath_tcomponent\n      ;;\n    esac\n  done\n  # Restore leading double-slash if one was found on entry.\n  func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result\n}\n\n# func_relative_path SRCDIR DSTDIR\n# generates a relative path from SRCDIR to DSTDIR, with a trailing\n# slash if non-empty, suitable for immediately appending a filename\n# without needing to append a separator.\n#             value returned in \"$func_relative_path_result\"\nfunc_relative_path ()\n{\n  func_relative_path_result=\n  func_normal_abspath \"$1\"\n  func_relative_path_tlibdir=$func_normal_abspath_result\n  func_normal_abspath \"$2\"\n  func_relative_path_tbindir=$func_normal_abspath_result\n\n  # Ascend the tree starting from libdir\n  while :; do\n    # check if we have found a prefix of bindir\n    case $func_relative_path_tbindir in\n      $func_relative_path_tlibdir)\n        # found an exact match\n        func_relative_path_tcancelled=\n        break\n        ;;\n      $func_relative_path_tlibdir*)\n        # found a matching prefix\n        func_stripname \"$func_relative_path_tlibdir\" '' \"$func_relative_path_tbindir\"\n        func_relative_path_tcancelled=$func_stripname_result\n        if test -z \"$func_relative_path_result\"; then\n          func_relative_path_result=.\n        fi\n        break\n        ;;\n      *)\n        func_dirname $func_relative_path_tlibdir\n        func_relative_path_tlibdir=${func_dirname_result}\n        if test \"x$func_relative_path_tlibdir\" = x ; then\n          # Have to descend all the way to the root!\n          func_relative_path_result=../$func_relative_path_result\n          func_relative_path_tcancelled=$func_relative_path_tbindir\n          break\n        fi\n        func_relative_path_result=../$func_relative_path_result\n        ;;\n    esac\n  done\n\n  # Now calculate path; take care to avoid doubling-up slashes.\n  func_stripname '' '/' \"$func_relative_path_result\"\n  func_relative_path_result=$func_stripname_result\n  func_stripname '/' '/' \"$func_relative_path_tcancelled\"\n  if test \"x$func_stripname_result\" != x ; then\n    func_relative_path_result=${func_relative_path_result}/${func_stripname_result}\n  fi\n\n  # Normalisation. If bindir is libdir, return empty string,\n  # else relative path ending with a slash; either way, target\n  # file name can be directly appended.\n  if test ! -z \"$func_relative_path_result\"; then\n    func_stripname './' '' \"$func_relative_path_result/\"\n    func_relative_path_result=$func_stripname_result\n  fi\n}\n\n# The name of this program:\nfunc_dirname_and_basename \"$progpath\"\nprogname=$func_basename_result\n\n# Make sure we have an absolute path for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=$func_dirname_result\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\n  *)\n     save_IFS=\"$IFS\"\n     IFS=${PATH_SEPARATOR-:}\n     for progdir in $PATH; do\n       IFS=\"$save_IFS\"\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=\"$save_IFS\"\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed=\"${SED}\"' -e 1s/^X//'\nsed_quote_subst='s/\\([`\"$\\\\]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Sed substitution that turns a string into a regex matching for the\n# string literally.\nsed_make_literal_regex='s,[].[^$\\\\*\\/],\\\\&,g'\n\n# Sed substitution that converts a w32 file name or path\n# which contains forward slashes, into one that contains\n# (escaped) backslashes.  A very naive implementation.\nlt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n\n# Re-`\\' parameter expansions in output of double_quote_subst that were\n# `\\'-ed in input to the same.  If an odd number of `\\' preceded a '$'\n# in input to double_quote_subst, that '$' was protected from expansion.\n# Since each input `\\' is now two `\\'s, look for any number of runs of\n# four `\\'s followed by two `\\'s and then a '$'.  `\\' that '$'.\nbs='\\\\'\nbs2='\\\\\\\\'\nbs4='\\\\\\\\\\\\\\\\'\ndollar='\\$'\nsed_double_backslash=\"\\\n  s/$bs4/&\\\\\n/g\n  s/^$bs2$dollar/$bs&/\n  s/\\\\([^$bs]\\\\)$bs2$dollar/\\\\1$bs2$bs$dollar/g\n  s/\\n//g\"\n\n# Standard options:\nopt_dry_run=false\nopt_help=false\nopt_quiet=false\nopt_verbose=false\nopt_warning=:\n\n# func_echo arg...\n# Echo program name prefixed message, along with the current mode\n# name if it has been set yet.\nfunc_echo ()\n{\n    $ECHO \"$progname: ${opt_mode+$opt_mode: }$*\"\n}\n\n# func_verbose arg...\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $opt_verbose && func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\n# func_error arg...\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $ECHO \"$progname: ${opt_mode+$opt_mode: }\"${1+\"$@\"} 1>&2\n}\n\n# func_warning arg...\n# Echo program name prefixed warning message to standard error.\nfunc_warning ()\n{\n    $opt_warning && $ECHO \"$progname: ${opt_mode+$opt_mode: }warning: \"${1+\"$@\"} 1>&2\n\n    # bash bug again:\n    :\n}\n\n# func_fatal_error arg...\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n# func_fatal_help arg...\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    func_error ${1+\"$@\"}\n    func_fatal_error \"$help\"\n}\nhelp=\"Try \\`$progname --help' for more information.\"  ## default\n\n\n# func_grep expression filename\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_mkdir_p directory-path\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    my_directory_path=\"$1\"\n    my_dir_list=\n\n    if test -n \"$my_directory_path\" && test \"$opt_dry_run\" != \":\"; then\n\n      # Protect directory names starting with `-'\n      case $my_directory_path in\n        -*) my_directory_path=\"./$my_directory_path\" ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$my_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        my_dir_list=\"$my_directory_path:$my_dir_list\"\n\n        # If the last portion added has no slash in it, the list is done\n        case $my_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        my_directory_path=`$ECHO \"$my_directory_path\" | $SED -e \"$dirname\"`\n      done\n      my_dir_list=`$ECHO \"$my_dir_list\" | $SED 's,:*$,,'`\n\n      save_mkdir_p_IFS=\"$IFS\"; IFS=':'\n      for my_dir in $my_dir_list; do\n\tIFS=\"$save_mkdir_p_IFS\"\n        # mkdir can fail with a `File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$my_dir\" 2>/dev/null || :\n      done\n      IFS=\"$save_mkdir_p_IFS\"\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$my_directory_path\" || \\\n        func_fatal_error \"Failed to create \\`$1'\"\n    fi\n}\n\n\n# func_mktempdir [string]\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, STRING is the basename for that directory.\nfunc_mktempdir ()\n{\n    my_template=\"${TMPDIR-/tmp}/${1-$progname}\"\n\n    if test \"$opt_dry_run\" = \":\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      my_tmpdir=\"${my_template}-$$\"\n    else\n\n      # If mktemp works, use that first and foremost\n      my_tmpdir=`mktemp -d \"${my_template}-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$my_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        my_tmpdir=\"${my_template}-${RANDOM-0}$$\"\n\n        save_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$my_tmpdir\"\n        umask $save_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$my_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory \\`$my_tmpdir'\"\n    fi\n\n    $ECHO \"$my_tmpdir\"\n}\n\n\n# func_quote_for_eval arg\n# Aesthetically quote ARG to be evaled later.\n# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT\n# is double-quoted, suitable for a subsequent eval, whereas\n# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters\n# which are still active within double quotes backslashified.\nfunc_quote_for_eval ()\n{\n    case $1 in\n      *[\\\\\\`\\\"\\$]*)\n\tfunc_quote_for_eval_unquoted_result=`$ECHO \"$1\" | $SED \"$sed_quote_subst\"` ;;\n      *)\n        func_quote_for_eval_unquoted_result=\"$1\" ;;\n    esac\n\n    case $func_quote_for_eval_unquoted_result in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting, command substitution and and variable\n      # expansion for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        func_quote_for_eval_result=\"\\\"$func_quote_for_eval_unquoted_result\\\"\"\n        ;;\n      *)\n        func_quote_for_eval_result=\"$func_quote_for_eval_unquoted_result\"\n    esac\n}\n\n\n# func_quote_for_expand arg\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\tmy_arg=`$ECHO \"$1\" | $SED \\\n\t    -e \"$double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        my_arg=\"$1\" ;;\n    esac\n\n    case $my_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        my_arg=\"\\\"$my_arg\\\"\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=\"$my_arg\"\n}\n\n\n# func_show_eval cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$my_cmd\"\n      my_status=$?\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n# func_show_eval_locale cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$lt_user_locale\n\t    $my_cmd\"\n      my_status=$?\n      eval \"$lt_safe_locale\"\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n# func_tr_sh\n# Turn $1 into a string suitable for a shell variable name.\n# Result is stored in $func_tr_sh_result.  All characters\n# not in the set a-zA-Z0-9_ are replaced with '_'. Further,\n# if $1 begins with a digit, a '_' is prepended as well.\nfunc_tr_sh ()\n{\n  case $1 in\n  [0-9]* | *[!a-zA-Z0-9_]*)\n    func_tr_sh_result=`$ECHO \"$1\" | $SED 's/^\\([0-9]\\)/_\\1/; s/[^a-zA-Z0-9_]/_/g'`\n    ;;\n  * )\n    func_tr_sh_result=$1\n    ;;\n  esac\n}\n\n\n# func_version\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $opt_debug\n\n    $SED -n '/(C)/!b go\n\t:more\n\t/\\./!{\n\t  N\n\t  s/\\n# / /\n\t  b more\n\t}\n\t:go\n\t/^# '$PROGRAM' (GNU /,/# warranty; / {\n        s/^# //\n\ts/^# *$//\n        s/\\((C)\\)[ 0-9,-]*\\( [1-9][0-9]*\\)/\\1\\2/\n        p\n     }' < \"$progpath\"\n     exit $?\n}\n\n# func_usage\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $opt_debug\n\n    $SED -n '/^# Usage:/,/^#  *.*--help/ {\n        s/^# //\n\ts/^# *$//\n\ts/\\$progname/'$progname'/\n\tp\n    }' < \"$progpath\"\n    echo\n    $ECHO \"run \\`$progname --help | more' for full usage\"\n    exit $?\n}\n\n# func_help [NOEXIT]\n# Echo long help message to standard output and exit,\n# unless 'noexit' is passed as argument.\nfunc_help ()\n{\n    $opt_debug\n\n    $SED -n '/^# Usage:/,/# Report bugs to/ {\n\t:print\n        s/^# //\n\ts/^# *$//\n\ts*\\$progname*'$progname'*\n\ts*\\$host*'\"$host\"'*\n\ts*\\$SHELL*'\"$SHELL\"'*\n\ts*\\$LTCC*'\"$LTCC\"'*\n\ts*\\$LTCFLAGS*'\"$LTCFLAGS\"'*\n\ts*\\$LD*'\"$LD\"'*\n\ts/\\$with_gnu_ld/'\"$with_gnu_ld\"'/\n\ts/\\$automake_version/'\"`(${AUTOMAKE-automake} --version) 2>/dev/null |$SED 1q`\"'/\n\ts/\\$autoconf_version/'\"`(${AUTOCONF-autoconf} --version) 2>/dev/null |$SED 1q`\"'/\n\tp\n\td\n     }\n     /^# .* home page:/b print\n     /^# General help using/b print\n     ' < \"$progpath\"\n    ret=$?\n    if test -z \"$1\"; then\n      exit $ret\n    fi\n}\n\n# func_missing_arg argname\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    $opt_debug\n\n    func_error \"missing argument for $1.\"\n    exit_cmd=exit\n}\n\n\n# func_split_short_opt shortopt\n# Set func_split_short_opt_name and func_split_short_opt_arg shell\n# variables after splitting SHORTOPT after the 2nd character.\nfunc_split_short_opt ()\n{\n    my_sed_short_opt='1s/^\\(..\\).*$/\\1/;q'\n    my_sed_short_rest='1s/^..\\(.*\\)$/\\1/;q'\n\n    func_split_short_opt_name=`$ECHO \"$1\" | $SED \"$my_sed_short_opt\"`\n    func_split_short_opt_arg=`$ECHO \"$1\" | $SED \"$my_sed_short_rest\"`\n} # func_split_short_opt may be replaced by extended shell implementation\n\n\n# func_split_long_opt longopt\n# Set func_split_long_opt_name and func_split_long_opt_arg shell\n# variables after splitting LONGOPT at the `=' sign.\nfunc_split_long_opt ()\n{\n    my_sed_long_opt='1s/^\\(--[^=]*\\)=.*/\\1/;q'\n    my_sed_long_arg='1s/^--[^=]*=//'\n\n    func_split_long_opt_name=`$ECHO \"$1\" | $SED \"$my_sed_long_opt\"`\n    func_split_long_opt_arg=`$ECHO \"$1\" | $SED \"$my_sed_long_arg\"`\n} # func_split_long_opt may be replaced by extended shell implementation\n\nexit_cmd=:\n\n\n\n\n\nmagic=\"%%%MAGIC variable%%%\"\nmagic_exe=\"%%%MAGIC EXE variable%%%\"\n\n# Global variables.\nnonopt=\npreserve_args=\nlo2o=\"s/\\\\.lo\\$/.${objext}/\"\no2lo=\"s/\\\\.${objext}\\$/.lo/\"\nextracted_archives=\nextracted_serial=0\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n    eval \"${1}=\\$${1}\\${2}\"\n} # func_append may be replaced by extended shell implementation\n\n# func_append_quoted var value\n# Quote VALUE and append to the end of shell variable VAR, separated\n# by a space.\nfunc_append_quoted ()\n{\n    func_quote_for_eval \"${2}\"\n    eval \"${1}=\\$${1}\\\\ \\$func_quote_for_eval_result\"\n} # func_append_quoted may be replaced by extended shell implementation\n\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n    func_arith_result=`expr \"${@}\"`\n} # func_arith may be replaced by extended shell implementation\n\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n    func_len_result=`expr \"${1}\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n} # func_len may be replaced by extended shell implementation\n\n\n# func_lo2o object\nfunc_lo2o ()\n{\n    func_lo2o_result=`$ECHO \"${1}\" | $SED \"$lo2o\"`\n} # func_lo2o may be replaced by extended shell implementation\n\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n    func_xform_result=`$ECHO \"${1}\" | $SED 's/\\.[^.]*$/.lo/'`\n} # func_xform may be replaced by extended shell implementation\n\n\n# func_fatal_configuration arg...\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func_error ${1+\"$@\"}\n    func_error \"See the $PACKAGE documentation for more information.\"\n    func_fatal_error \"Fatal configuration error.\"\n}\n\n\n# func_config\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n# func_features\n# Display the features supported by this script.\nfunc_features ()\n{\n    echo \"host: $host\"\n    if test \"$build_libtool_libs\" = yes; then\n      echo \"enable shared libraries\"\n    else\n      echo \"disable shared libraries\"\n    fi\n    if test \"$build_old_libs\" = yes; then\n      echo \"enable static libraries\"\n    else\n      echo \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n# func_enable_tag tagname\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n  # Global variable:\n  tagname=\"$1\"\n\n  re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n  re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n  sed_extractcf=\"/$re_begincf/,/$re_endcf/p\"\n\n  # Validate tagname.\n  case $tagname in\n    *[!-_A-Za-z0-9,/]*)\n      func_fatal_error \"invalid tag name: $tagname\"\n      ;;\n  esac\n\n  # Don't test for the \"default\" C tag, as we know it's\n  # there but not specially marked.\n  case $tagname in\n    CC) ;;\n    *)\n      if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\ttaglist=\"$taglist $tagname\"\n\n\t# Evaluate the configuration.  Be careful to quote the path\n\t# and the sed script, to avoid splitting on whitespace, but\n\t# also don't use non-portable quotes within backquotes within\n\t# quotes we have to do it in 2 steps:\n\textractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\teval \"$extractedcf\"\n      else\n\tfunc_error \"ignoring unknown tag $tagname\"\n      fi\n      ;;\n  esac\n}\n\n# func_check_version_match\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n  if test \"$package_revision\" != \"$macro_revision\"; then\n    if test \"$VERSION\" != \"$macro_version\"; then\n      if test -z \"$macro_version\"; then\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      fi\n    else\n      cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n    fi\n\n    exit $EXIT_MISMATCH\n  fi\n}\n\n\n# Shorthand for --mode=foo, only valid as the first argument\ncase $1 in\nclean|clea|cle|cl)\n  shift; set dummy --mode clean ${1+\"$@\"}; shift\n  ;;\ncompile|compil|compi|comp|com|co|c)\n  shift; set dummy --mode compile ${1+\"$@\"}; shift\n  ;;\nexecute|execut|execu|exec|exe|ex|e)\n  shift; set dummy --mode execute ${1+\"$@\"}; shift\n  ;;\nfinish|finis|fini|fin|fi|f)\n  shift; set dummy --mode finish ${1+\"$@\"}; shift\n  ;;\ninstall|instal|insta|inst|ins|in|i)\n  shift; set dummy --mode install ${1+\"$@\"}; shift\n  ;;\nlink|lin|li|l)\n  shift; set dummy --mode link ${1+\"$@\"}; shift\n  ;;\nuninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n  shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n  ;;\nesac\n\n\n\n# Option defaults:\nopt_debug=:\nopt_dry_run=false\nopt_config=false\nopt_preserve_dup_deps=false\nopt_features=false\nopt_finish=false\nopt_help=false\nopt_help_all=false\nopt_silent=:\nopt_warning=:\nopt_verbose=:\nopt_silent=false\nopt_verbose=false\n\n\n# Parse options once, thoroughly.  This comes as soon as possible in the\n# script to make things like `--version' happen as quickly as we can.\n{\n  # this just eases exit handling\n  while test $# -gt 0; do\n    opt=\"$1\"\n    shift\n    case $opt in\n      --debug|-x)\topt_debug='set -x'\n\t\t\tfunc_echo \"enabling shell trace mode\"\n\t\t\t$opt_debug\n\t\t\t;;\n      --dry-run|--dryrun|-n)\n\t\t\topt_dry_run=:\n\t\t\t;;\n      --config)\n\t\t\topt_config=:\nfunc_config\n\t\t\t;;\n      --dlopen|-dlopen)\n\t\t\toptarg=\"$1\"\n\t\t\topt_dlopen=\"${opt_dlopen+$opt_dlopen\n}$optarg\"\n\t\t\tshift\n\t\t\t;;\n      --preserve-dup-deps)\n\t\t\topt_preserve_dup_deps=:\n\t\t\t;;\n      --features)\n\t\t\topt_features=:\nfunc_features\n\t\t\t;;\n      --finish)\n\t\t\topt_finish=:\nset dummy --mode finish ${1+\"$@\"}; shift\n\t\t\t;;\n      --help)\n\t\t\topt_help=:\n\t\t\t;;\n      --help-all)\n\t\t\topt_help_all=:\nopt_help=': help-all'\n\t\t\t;;\n      --mode)\n\t\t\ttest $# = 0 && func_missing_arg $opt && break\n\t\t\toptarg=\"$1\"\n\t\t\topt_mode=\"$optarg\"\ncase $optarg in\n  # Valid mode arguments:\n  clean|compile|execute|finish|install|link|relink|uninstall) ;;\n\n  # Catch anything else as an error\n  *) func_error \"invalid argument for $opt\"\n     exit_cmd=exit\n     break\n     ;;\nesac\n\t\t\tshift\n\t\t\t;;\n      --no-silent|--no-quiet)\n\t\t\topt_silent=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --no-warning|--no-warn)\n\t\t\topt_warning=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --no-verbose)\n\t\t\topt_verbose=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --silent|--quiet)\n\t\t\topt_silent=:\nfunc_append preserve_args \" $opt\"\n        opt_verbose=false\n\t\t\t;;\n      --verbose|-v)\n\t\t\topt_verbose=:\nfunc_append preserve_args \" $opt\"\nopt_silent=false\n\t\t\t;;\n      --tag)\n\t\t\ttest $# = 0 && func_missing_arg $opt && break\n\t\t\toptarg=\"$1\"\n\t\t\topt_tag=\"$optarg\"\nfunc_append preserve_args \" $opt $optarg\"\nfunc_enable_tag \"$optarg\"\n\t\t\tshift\n\t\t\t;;\n\n      -\\?|-h)\t\tfunc_usage\t\t\t\t;;\n      --help)\t\tfunc_help\t\t\t\t;;\n      --version)\tfunc_version\t\t\t\t;;\n\n      # Separate optargs to long options:\n      --*=*)\n\t\t\tfunc_split_long_opt \"$opt\"\n\t\t\tset dummy \"$func_split_long_opt_name\" \"$func_split_long_opt_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      # Separate non-argument short options:\n      -\\?*|-h*|-n*|-v*)\n\t\t\tfunc_split_short_opt \"$opt\"\n\t\t\tset dummy \"$func_split_short_opt_name\" \"-$func_split_short_opt_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      --)\t\tbreak\t\t\t\t\t;;\n      -*)\t\tfunc_fatal_help \"unrecognized option \\`$opt'\" ;;\n      *)\t\tset dummy \"$opt\" ${1+\"$@\"};\tshift; break  ;;\n    esac\n  done\n\n  # Validate options:\n\n  # save first non-option argument\n  if test \"$#\" -gt 0; then\n    nonopt=\"$opt\"\n    shift\n  fi\n\n  # preserve --debug\n  test \"$opt_debug\" = : || func_append preserve_args \" --debug\"\n\n  case $host in\n    *cygwin* | *mingw* | *pw32* | *cegcc*)\n      # don't eliminate duplications in $postdeps and $predeps\n      opt_duplicate_compiler_generated_deps=:\n      ;;\n    *)\n      opt_duplicate_compiler_generated_deps=$opt_preserve_dup_deps\n      ;;\n  esac\n\n  $opt_help || {\n    # Sanity checks first:\n    func_check_version_match\n\n    if test \"$build_libtool_libs\" != yes && test \"$build_old_libs\" != yes; then\n      func_fatal_configuration \"not configured to build any kind of library\"\n    fi\n\n    # Darwin sucks\n    eval std_shrext=\\\"$shrext_cmds\\\"\n\n    # Only execute mode is allowed to have -dlopen flags.\n    if test -n \"$opt_dlopen\" && test \"$opt_mode\" != execute; then\n      func_error \"unrecognized option \\`-dlopen'\"\n      $ECHO \"$help\" 1>&2\n      exit $EXIT_FAILURE\n    fi\n\n    # Change the help message to a mode-specific one.\n    generic_help=\"$help\"\n    help=\"Try \\`$progname --help --mode=$opt_mode' for more information.\"\n  }\n\n\n  # Bail if the options were screwed\n  $exit_cmd $EXIT_FAILURE\n}\n\n\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\n# func_lalib_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null \\\n        | $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if `file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case \"$lalib_p_line\" in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test \"$lalib_p\" = yes\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    func_lalib_p \"$1\"\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_dirname_and_basename \"$1\" \"\" \".\"\n    func_stripname '' '.exe' \"$func_basename_result\"\n    func_ltwrapper_scriptname_result=\"$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\"\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $opt_debug\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$save_ifs\n      eval cmd=\\\"$cmd\\\"\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# `FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $opt_debug\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_resolve_sysroot PATH\n# Replace a leading = in PATH with a sysroot.  Store the result into\n# func_resolve_sysroot_result\nfunc_resolve_sysroot ()\n{\n  func_resolve_sysroot_result=$1\n  case $func_resolve_sysroot_result in\n  =*)\n    func_stripname '=' '' \"$func_resolve_sysroot_result\"\n    func_resolve_sysroot_result=$lt_sysroot$func_stripname_result\n    ;;\n  esac\n}\n\n# func_replace_sysroot PATH\n# If PATH begins with the sysroot, replace it with = and\n# store the result into func_replace_sysroot_result.\nfunc_replace_sysroot ()\n{\n  case \"$lt_sysroot:$1\" in\n  ?*:\"$lt_sysroot\"*)\n    func_stripname \"$lt_sysroot\" '' \"$1\"\n    func_replace_sysroot_result=\"=$func_stripname_result\"\n    ;;\n  *)\n    # Including no sysroot.\n    func_replace_sysroot_result=$1\n    ;;\n  esac\n}\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $opt_debug\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n\tfunc_append_quoted CC_quoted \"$arg\"\n      done\n      CC_expanded=`func_echo_all $CC`\n      CC_quoted_expanded=`func_echo_all $CC_quoted`\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n      \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_append_quoted CC_quoted \"$arg\"\n\t    done\n\t    CC_expanded=`func_echo_all $CC`\n\t    CC_quoted_expanded=`func_echo_all $CC_quoted`\n\t    case \"$@ \" in\n\t    \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n\t    \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with \\`--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=${1}\n    if test \"$build_libtool_libs\" = yes; then\n      write_lobj=\\'${2}\\'\n    else\n      write_lobj=none\n    fi\n\n    if test \"$build_old_libs\" = yes; then\n      write_oldobj=\\'${3}\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"${write_libobj}\"\n    }\n}\n\n\n##################################################\n# FILE NAME AND PATH CONVERSION HELPER FUNCTIONS #\n##################################################\n\n# func_convert_core_file_wine_to_w32 ARG\n# Helper function used by file name conversion functions when $build is *nix,\n# and $host is mingw, cygwin, or some other w32 environment. Relies on a\n# correctly configured wine environment available, with the winepath program\n# in $build's $PATH.\n#\n# ARG is the $build file name to be converted to w32 format.\n# Result is available in $func_convert_core_file_wine_to_w32_result, and will\n# be empty on error (or when ARG is empty)\nfunc_convert_core_file_wine_to_w32 ()\n{\n  $opt_debug\n  func_convert_core_file_wine_to_w32_result=\"$1\"\n  if test -n \"$1\"; then\n    # Unfortunately, winepath does not exit with a non-zero error code, so we\n    # are forced to check the contents of stdout. On the other hand, if the\n    # command is not found, the shell will set an exit code of 127 and print\n    # *an error message* to stdout. So we must check for both error code of\n    # zero AND non-empty stdout, which explains the odd construction:\n    func_convert_core_file_wine_to_w32_tmp=`winepath -w \"$1\" 2>/dev/null`\n    if test \"$?\" -eq 0 && test -n \"${func_convert_core_file_wine_to_w32_tmp}\"; then\n      func_convert_core_file_wine_to_w32_result=`$ECHO \"$func_convert_core_file_wine_to_w32_tmp\" |\n        $SED -e \"$lt_sed_naive_backslashify\"`\n    else\n      func_convert_core_file_wine_to_w32_result=\n    fi\n  fi\n}\n# end: func_convert_core_file_wine_to_w32\n\n\n# func_convert_core_path_wine_to_w32 ARG\n# Helper function used by path conversion functions when $build is *nix, and\n# $host is mingw, cygwin, or some other w32 environment. Relies on a correctly\n# configured wine environment available, with the winepath program in $build's\n# $PATH. Assumes ARG has no leading or trailing path separator characters.\n#\n# ARG is path to be converted from $build format to win32.\n# Result is available in $func_convert_core_path_wine_to_w32_result.\n# Unconvertible file (directory) names in ARG are skipped; if no directory names\n# are convertible, then the result may be empty.\nfunc_convert_core_path_wine_to_w32 ()\n{\n  $opt_debug\n  # unfortunately, winepath doesn't convert paths, only file names\n  func_convert_core_path_wine_to_w32_result=\"\"\n  if test -n \"$1\"; then\n    oldIFS=$IFS\n    IFS=:\n    for func_convert_core_path_wine_to_w32_f in $1; do\n      IFS=$oldIFS\n      func_convert_core_file_wine_to_w32 \"$func_convert_core_path_wine_to_w32_f\"\n      if test -n \"$func_convert_core_file_wine_to_w32_result\" ; then\n        if test -z \"$func_convert_core_path_wine_to_w32_result\"; then\n          func_convert_core_path_wine_to_w32_result=\"$func_convert_core_file_wine_to_w32_result\"\n        else\n          func_append func_convert_core_path_wine_to_w32_result \";$func_convert_core_file_wine_to_w32_result\"\n        fi\n      fi\n    done\n    IFS=$oldIFS\n  fi\n}\n# end: func_convert_core_path_wine_to_w32\n\n\n# func_cygpath ARGS...\n# Wrapper around calling the cygpath program via LT_CYGPATH. This is used when\n# when (1) $build is *nix and Cygwin is hosted via a wine environment; or (2)\n# $build is MSYS and $host is Cygwin, or (3) $build is Cygwin. In case (1) or\n# (2), returns the Cygwin file name or path in func_cygpath_result (input\n# file name or path is assumed to be in w32 format, as previously converted\n# from $build's *nix or MSYS format). In case (3), returns the w32 file name\n# or path in func_cygpath_result (input file name or path is assumed to be in\n# Cygwin format). Returns an empty string on error.\n#\n# ARGS are passed to cygpath, with the last one being the file name or path to\n# be converted.\n#\n# Specify the absolute *nix (or w32) name to cygpath in the LT_CYGPATH\n# environment variable; do not put it in $PATH.\nfunc_cygpath ()\n{\n  $opt_debug\n  if test -n \"$LT_CYGPATH\" && test -f \"$LT_CYGPATH\"; then\n    func_cygpath_result=`$LT_CYGPATH \"$@\" 2>/dev/null`\n    if test \"$?\" -ne 0; then\n      # on failure, ensure result is empty\n      func_cygpath_result=\n    fi\n  else\n    func_cygpath_result=\n    func_error \"LT_CYGPATH is empty or specifies non-existent file: \\`$LT_CYGPATH'\"\n  fi\n}\n#end: func_cygpath\n\n\n# func_convert_core_msys_to_w32 ARG\n# Convert file name or path ARG from MSYS format to w32 format.  Return\n# result in func_convert_core_msys_to_w32_result.\nfunc_convert_core_msys_to_w32 ()\n{\n  $opt_debug\n  # awkward: cmd appends spaces to result\n  func_convert_core_msys_to_w32_result=`( cmd //c echo \"$1\" ) 2>/dev/null |\n    $SED -e 's/[ ]*$//' -e \"$lt_sed_naive_backslashify\"`\n}\n#end: func_convert_core_msys_to_w32\n\n\n# func_convert_file_check ARG1 ARG2\n# Verify that ARG1 (a file name in $build format) was converted to $host\n# format in ARG2. Otherwise, emit an error message, but continue (resetting\n# func_to_host_file_result to ARG1).\nfunc_convert_file_check ()\n{\n  $opt_debug\n  if test -z \"$2\" && test -n \"$1\" ; then\n    func_error \"Could not determine host file name corresponding to\"\n    func_error \"  \\`$1'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback:\n    func_to_host_file_result=\"$1\"\n  fi\n}\n# end func_convert_file_check\n\n\n# func_convert_path_check FROM_PATHSEP TO_PATHSEP FROM_PATH TO_PATH\n# Verify that FROM_PATH (a path in $build format) was converted to $host\n# format in TO_PATH. Otherwise, emit an error message, but continue, resetting\n# func_to_host_file_result to a simplistic fallback value (see below).\nfunc_convert_path_check ()\n{\n  $opt_debug\n  if test -z \"$4\" && test -n \"$3\"; then\n    func_error \"Could not determine the host path corresponding to\"\n    func_error \"  \\`$3'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback.  This is a deliberately simplistic \"conversion\" and\n    # should not be \"improved\".  See libtool.info.\n    if test \"x$1\" != \"x$2\"; then\n      lt_replace_pathsep_chars=\"s|$1|$2|g\"\n      func_to_host_path_result=`echo \"$3\" |\n        $SED -e \"$lt_replace_pathsep_chars\"`\n    else\n      func_to_host_path_result=\"$3\"\n    fi\n  fi\n}\n# end func_convert_path_check\n\n\n# func_convert_path_front_back_pathsep FRONTPAT BACKPAT REPL ORIG\n# Modifies func_to_host_path_result by prepending REPL if ORIG matches FRONTPAT\n# and appending REPL if ORIG matches BACKPAT.\nfunc_convert_path_front_back_pathsep ()\n{\n  $opt_debug\n  case $4 in\n  $1 ) func_to_host_path_result=\"$3$func_to_host_path_result\"\n    ;;\n  esac\n  case $4 in\n  $2 ) func_append func_to_host_path_result \"$3\"\n    ;;\n  esac\n}\n# end func_convert_path_front_back_pathsep\n\n\n##################################################\n# $build to $host FILE NAME CONVERSION FUNCTIONS #\n##################################################\n# invoked via `$to_host_file_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# Result will be available in $func_to_host_file_result.\n\n\n# func_to_host_file ARG\n# Converts the file name ARG from $build format to $host format. Return result\n# in func_to_host_file_result.\nfunc_to_host_file ()\n{\n  $opt_debug\n  $to_host_file_cmd \"$1\"\n}\n# end func_to_host_file\n\n\n# func_to_tool_file ARG LAZY\n# converts the file name ARG from $build format to toolchain format. Return\n# result in func_to_tool_file_result.  If the conversion in use is listed\n# in (the comma separated) LAZY, no conversion takes place.\nfunc_to_tool_file ()\n{\n  $opt_debug\n  case ,$2, in\n    *,\"$to_tool_file_cmd\",*)\n      func_to_tool_file_result=$1\n      ;;\n    *)\n      $to_tool_file_cmd \"$1\"\n      func_to_tool_file_result=$func_to_host_file_result\n      ;;\n  esac\n}\n# end func_to_tool_file\n\n\n# func_convert_file_noop ARG\n# Copy ARG to func_to_host_file_result.\nfunc_convert_file_noop ()\n{\n  func_to_host_file_result=\"$1\"\n}\n# end func_convert_file_noop\n\n\n# func_convert_file_msys_to_w32 ARG\n# Convert file name ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_msys_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_to_host_file_result=\"$func_convert_core_msys_to_w32_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_w32\n\n\n# func_convert_file_cygwin_to_w32 ARG\n# Convert file name ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_cygwin_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    # because $build is cygwin, we call \"the\" cygpath in $PATH; no need to use\n    # LT_CYGPATH in this case.\n    func_to_host_file_result=`cygpath -m \"$1\"`\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_cygwin_to_w32\n\n\n# func_convert_file_nix_to_w32 ARG\n# Convert file name ARG from *nix to w32 format.  Requires a wine environment\n# and a working winepath. Returns result in func_to_host_file_result.\nfunc_convert_file_nix_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_to_host_file_result=\"$func_convert_core_file_wine_to_w32_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_w32\n\n\n# func_convert_file_msys_to_cygwin ARG\n# Convert file name ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_file_msys_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_file_result=\"$func_cygpath_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_cygwin\n\n\n# func_convert_file_nix_to_cygwin ARG\n# Convert file name ARG from *nix to Cygwin format.  Requires Cygwin installed\n# in a wine environment, working winepath, and LT_CYGPATH set.  Returns result\n# in func_to_host_file_result.\nfunc_convert_file_nix_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_file_wine_to_w32_result\"\n    func_to_host_file_result=\"$func_cygpath_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_cygwin\n\n\n#############################################\n# $build to $host PATH CONVERSION FUNCTIONS #\n#############################################\n# invoked via `$to_host_path_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# The result will be available in $func_to_host_path_result.\n#\n# Path separators are also converted from $build format to $host format.  If\n# ARG begins or ends with a path separator character, it is preserved (but\n# converted to $host format) on output.\n#\n# All path conversion functions are named using the following convention:\n#   file name conversion function    : func_convert_file_X_to_Y ()\n#   path conversion function         : func_convert_path_X_to_Y ()\n# where, for any given $build/$host combination the 'X_to_Y' value is the\n# same.  If conversion functions are added for new $build/$host combinations,\n# the two new functions must follow this pattern, or func_init_to_host_path_cmd\n# will break.\n\n\n# func_init_to_host_path_cmd\n# Ensures that function \"pointer\" variable $to_host_path_cmd is set to the\n# appropriate value, based on the value of $to_host_file_cmd.\nto_host_path_cmd=\nfunc_init_to_host_path_cmd ()\n{\n  $opt_debug\n  if test -z \"$to_host_path_cmd\"; then\n    func_stripname 'func_convert_file_' '' \"$to_host_file_cmd\"\n    to_host_path_cmd=\"func_convert_path_${func_stripname_result}\"\n  fi\n}\n\n\n# func_to_host_path ARG\n# Converts the path ARG from $build format to $host format. Return result\n# in func_to_host_path_result.\nfunc_to_host_path ()\n{\n  $opt_debug\n  func_init_to_host_path_cmd\n  $to_host_path_cmd \"$1\"\n}\n# end func_to_host_path\n\n\n# func_convert_path_noop ARG\n# Copy ARG to func_to_host_path_result.\nfunc_convert_path_noop ()\n{\n  func_to_host_path_result=\"$1\"\n}\n# end func_convert_path_noop\n\n\n# func_convert_path_msys_to_w32 ARG\n# Convert path ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_path_result.\nfunc_convert_path_msys_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from ARG.  MSYS\n    # behavior is inconsistent here; cygpath turns them into '.;' and ';.';\n    # and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=\"$func_convert_core_msys_to_w32_result\"\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_w32\n\n\n# func_convert_path_cygwin_to_w32 ARG\n# Convert path ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_cygwin_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_to_host_path_result=`cygpath -m -p \"$func_to_host_path_tmp1\"`\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_cygwin_to_w32\n\n\n# func_convert_path_nix_to_w32 ARG\n# Convert path ARG from *nix to w32 format.  Requires a wine environment and\n# a working winepath.  Returns result in func_to_host_file_result.\nfunc_convert_path_nix_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=\"$func_convert_core_path_wine_to_w32_result\"\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_w32\n\n\n# func_convert_path_msys_to_cygwin ARG\n# Convert path ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_path_msys_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_path_result=\"$func_cygpath_result\"\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_cygwin\n\n\n# func_convert_path_nix_to_cygwin ARG\n# Convert path ARG from *nix to Cygwin format.  Requires Cygwin installed in a\n# a wine environment, working winepath, and LT_CYGPATH set.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_nix_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from\n    # ARG. msys behavior is inconsistent here, cygpath turns them\n    # into '.;' and ';.', and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_path_wine_to_w32_result\"\n    func_to_host_path_result=\"$func_cygpath_result\"\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_cygwin\n\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $opt_debug\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=\"$nonopt\"  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=\"$arg\"\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=\"$arg\"\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify \\`-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          func_append pie_flag \" $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  func_append later \" $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=\"$IFS\"; IFS=','\n\t  for arg in $args; do\n\t    IFS=\"$save_ifs\"\n\t    func_append_quoted lastarg \"$arg\"\n\t  done\n\t  IFS=\"$save_ifs\"\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  func_append base_compile \" $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=\"$srcfile\"\n\t  srcfile=\"$arg\"\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_append_quoted base_compile \"$lastarg\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with \\`-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=\"$func_basename_result\"\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from \\`$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name \\`$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=\"$func_basename_result\"\n    xdir=\"$func_dirname_result\"\n    lobj=${xdir}$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test \"$build_old_libs\" = yes; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test \"$pic_mode\" = no && test \"$deplibs_check_method\" != pass_all; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test \"$compiler_c_o\" = no; then\n      output_obj=`$ECHO \"$srcfile\" | $SED 's%^.*/%%; s%\\.[^.]*$%%'`.${objext}\n      lockfile=\"$output_obj.lock\"\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test \"$need_locks\" = yes; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test \"$need_locks\" = warn; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      func_append removelist \" $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    func_append removelist \" $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    func_to_tool_file \"$srcfile\" func_convert_file_msys_to_w32\n    srcfile=$func_to_tool_file_result\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test \"$build_libtool_libs\" = yes; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test \"$pic_mode\" != no; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tfunc_append command \" -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test \"$suppress_opt\" = yes; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test \"$build_old_libs\" = yes; then\n      if test \"$pic_mode\" != yes; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test \"$compiler_c_o\" = yes; then\n\tfunc_append command \" -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      func_append command \"$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test \"$need_locks\" != no; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\n  test \"$opt_mode\" = compile && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $opt_mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to build PIC objects only\n  -prefer-non-pic   try to build non-PIC objects only\n  -shared           do not build a \\`.o' file suitable for static linking\n  -static           only build a \\`.o' file suitable for static linking\n  -Wc,FLAG          pass FLAG directly to the compiler\n\nCOMPILE-COMMAND is a command to be used in creating a \\`standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix \\`.c' with the\nlibrary object suffix, \\`.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to \\`-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe \\`--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the \\`install' or \\`cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -bindir BINDIR    specify path to binaries directory (for systems where\n                    libraries must be found in the PATH setting at runtime)\n  -dlopen FILE      \\`-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  Use a list of object files found in FILE to specify objects\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n  -Wc,FLAG\n  -Xcompiler FLAG   pass linker-specific FLAG directly to the compiler\n  -Wl,FLAG\n  -Xlinker FLAG     pass linker-specific FLAG directly to the linker\n  -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)\n\nAll other options (arguments beginning with \\`-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in \\`.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in \\`.la', then a libtool library is created,\nonly library objects (\\`.lo' files) may be specified, and \\`-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in \\`.a' or \\`.lib', then a standard library is created\nusing \\`ar' and \\`ranlib', or on Windows using \\`lib'.\n\nIf OUTPUT-FILE ends in \\`.lo' or \\`.${objext}', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode \\`$opt_mode'\"\n        ;;\n    esac\n\n    echo\n    $ECHO \"Try \\`$progname --help' for more information about other modes.\"\n}\n\n# Now that we've collected a possible --mode arg, show help if necessary\nif $opt_help; then\n  if test \"$opt_help\" = :; then\n    func_mode_help\n  else\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\tfunc_mode_help\n      done\n    } | sed -n '1p; 2,$s/^Usage:/  or: /p'\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\techo\n\tfunc_mode_help\n      done\n    } |\n    sed '1d\n      /^When reporting/,/^Report/{\n\tH\n\td\n      }\n      $x\n      /information about other modes/d\n      /more detailed .*MODE/d\n      s/^Usage:.*--mode=\\([^ ]*\\) .*/Description of \\1 mode:/'\n  fi\n  exit $?\nfi\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $opt_debug\n    # The first argument is the command name.\n    cmd=\"$nonopt\"\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $opt_dlopen; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"\\`$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"\\`$file' was not linked with \\`-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  func_append dir \"/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find \\`$dlname' in \\`$dir' or \\`$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\t;;\n\n      *)\n\tfunc_warning \"\\`-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=\"$absdir\"\n\n      # Now add the directory to shlibpath_var.\n      if eval \"test -z \\\"\\$$shlibpath_var\\\"\"; then\n\teval \"$shlibpath_var=\\\"\\$dir\\\"\"\n      else\n\teval \"$shlibpath_var=\\\"\\$dir:\\$$shlibpath_var\\\"\"\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=\"$magic\"\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -* | *.la | *.lo ) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_append_quoted args \"$file\"\n    done\n\n    if test \"X$opt_dry_run\" = Xfalse; then\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\"\\$cmd$args\"\n    else\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\techo \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$opt_mode\" = execute && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $opt_debug\n    libs=\n    libdirs=\n    admincmds=\n\n    for opt in \"$nonopt\" ${1+\"$@\"}\n    do\n      if test -d \"$opt\"; then\n\tfunc_append libdirs \" $opt\"\n\n      elif test -f \"$opt\"; then\n\tif func_lalib_unsafe_p \"$opt\"; then\n\t  func_append libs \" $opt\"\n\telse\n\t  func_warning \"\\`$opt' is not a valid libtool archive\"\n\tfi\n\n      else\n\tfunc_fatal_error \"invalid argument \\`$opt'\"\n      fi\n    done\n\n    if test -n \"$libs\"; then\n      if test -n \"$lt_sysroot\"; then\n        sysroot_regex=`$ECHO \"$lt_sysroot\" | $SED \"$sed_make_literal_regex\"`\n        sysroot_cmd=\"s/\\([ ']\\)$sysroot_regex/\\1/g;\"\n      else\n        sysroot_cmd=\n      fi\n\n      # Remove sysroot references\n      if $opt_dry_run; then\n        for lib in $libs; do\n          echo \"removing references to $lt_sysroot and \\`=' prefixes from $lib\"\n        done\n      else\n        tmpdir=`func_mktempdir`\n        for lib in $libs; do\n\t  sed -e \"${sysroot_cmd} s/\\([ ']-[LR]\\)=/\\1/g; s/\\([ ']\\)=/\\1/g\" $lib \\\n\t    > $tmpdir/tmp-la\n\t  mv -f $tmpdir/tmp-la $lib\n\tdone\n        ${RM}r \"$tmpdir\"\n      fi\n    fi\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || func_append admincmds \"\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_silent && exit $EXIT_SUCCESS\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      echo \"----------------------------------------------------------------------\"\n      echo \"Libraries have been installed in:\"\n      for libdir in $libdirs; do\n\t$ECHO \"   $libdir\"\n      done\n      echo\n      echo \"If you ever happen to want to link against installed libraries\"\n      echo \"in a given directory, LIBDIR, you must either use libtool, and\"\n      echo \"specify the full pathname of the library, or use the \\`-LLIBDIR'\"\n      echo \"flag during linking and do at least one of the following:\"\n      if test -n \"$shlibpath_var\"; then\n\techo \"   - add LIBDIR to the \\`$shlibpath_var' environment variable\"\n\techo \"     during execution\"\n      fi\n      if test -n \"$runpath_var\"; then\n\techo \"   - add LIBDIR to the \\`$runpath_var' environment variable\"\n\techo \"     during linking\"\n      fi\n      if test -n \"$hardcode_libdir_flag_spec\"; then\n\tlibdir=LIBDIR\n\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\n\t$ECHO \"   - use the \\`$flag' linker flag\"\n      fi\n      if test -n \"$admincmds\"; then\n\t$ECHO \"   - have your system administrator run these commands:$admincmds\"\n      fi\n      if test -f /etc/ld.so.conf; then\n\techo \"   - have your system administrator add LIBDIR to \\`/etc/ld.so.conf'\"\n      fi\n      echo\n\n      echo \"See any operating system documentation about shared libraries for\"\n      case $host in\n\tsolaris2.[6789]|solaris2.1[0-9])\n\t  echo \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\t  echo \"pages.\"\n\t  ;;\n\t*)\n\t  echo \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n\t  ;;\n      esac\n      echo \"----------------------------------------------------------------------\"\n    fi\n    exit $EXIT_SUCCESS\n}\n\ntest \"$opt_mode\" = finish && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $opt_debug\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$nonopt\" = \"$SHELL\" || test \"$nonopt\" = /bin/sh ||\n       # Allow the use of GNU shtool's install command.\n       case $nonopt in *shtool*) :;; *) false;; esac; then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    func_append install_prog \"$func_quote_for_eval_result\"\n    install_shared_prog=$install_prog\n    case \" $install_prog \" in\n      *[\\\\\\ /]cp\\ *) install_cp=: ;;\n      *) install_cp=false ;;\n    esac\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=no\n    stripme=\n    no_mode=:\n    for arg\n    do\n      arg2=\n      if test -n \"$dest\"; then\n\tfunc_append files \" $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=yes ;;\n      -f)\n\tif $install_cp; then :; else\n\t  prev=$arg\n\tfi\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  if test \"x$prev\" = x-m && test -n \"$install_override_mode\"; then\n\t    arg2=$install_override_mode\n\t    no_mode=false\n\t  fi\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      func_append install_prog \" $func_quote_for_eval_result\"\n      if test -n \"$arg2\"; then\n\tfunc_quote_for_eval \"$arg2\"\n      fi\n      func_append install_shared_prog \" $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prev' option requires an argument\"\n\n    if test -n \"$install_override_mode\" && $no_mode; then\n      if $install_cp; then :; else\n\tfunc_quote_for_eval \"$install_override_mode\"\n\tfunc_append install_shared_prog \" -m $func_quote_for_eval_result\"\n      fi\n    fi\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=yes\n    if test \"$isdir\" = yes; then\n      destdir=\"$dest\"\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=\"$func_dirname_result\"\n      destname=\"$func_basename_result\"\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"\\`$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"\\`$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tfunc_append staticlibs \" $file\"\n\t;;\n\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append current_libdirs \" $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append future_libdirs \" $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=\"$func_dirname_result\"\n\tfunc_append dir \"$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"$destdir\" | $SED -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install \\`$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking \\`$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink \\`$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=\"$1\"\n\t  shift\n\n\t  srcname=\"$realname\"\n\t  test -n \"$relink_command\" && srcname=\"$realname\"T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_shared_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=\"$stripme\"\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\"\"\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try `ln -sf' first, because the `ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=\"$destdir/$realname\"\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=\"$func_basename_result\"\n\tinstname=\"$dir/$name\"i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && func_append staticlibs \" $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=\"$destfile\"\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to \\`$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test \"$build_old_libs\" = yes; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\"\"\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=\".exe\"\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script \\`$wrapper'\"\n\n\t  finalize=yes\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=\"$libdir/\"`$ECHO \"$lib\" | $SED 's%^.*/%%g'` ### testsuite: skip nested quoting test\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"\\`$lib' has not been installed in \\`$libdir'\"\n\t      finalize=no\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test \"$fast_install\" = no && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if test \"$finalize\" = yes; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=\"$func_basename_result\"\n\t        outputname=\"$tmpdir/$file\"\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"$relink_command\" | $SED 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_silent || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink \\`$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=\"$outputname\"\n\t      else\n\t        func_warning \"cannot relink \\`$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"$file$stripped_ext\" | $SED \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n\n      # Set up the ranlib parameters.\n      oldlib=\"$destdir/$name\"\n      func_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n      tool_oldlib=$func_to_tool_file_result\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $tool_oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run \\`$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\"; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$opt_mode\" = install && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $opt_debug\n    my_outputname=\"$1\"\n    my_originator=\"$2\"\n    my_pic_p=\"${3-no}\"\n    my_prefix=`$ECHO \"$my_originator\" | sed 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=\"${my_outputname}S.c\"\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=\"$output_objdir/${my_outputname}.nm\"\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for \\`$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))\n#pragma GCC diagnostic ignored \\\"-Wstrict-prototypes\\\"\n#endif\n\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)\n/* DATA imports from DLLs on WIN32 con't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT_DLSYM_CONST\n#elif defined(__osf__)\n/* This system does not cope well with relocations in const data.  */\n# define LT_DLSYM_CONST\n#else\n# define LT_DLSYM_CONST const\n#endif\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test \"$dlself\" = yes; then\n\t  func_verbose \"generating symbol list for \\`$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"$objs$old_deplibs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_to_tool_file \"$progfile\" func_convert_file_msys_to_w32\n\t    func_verbose \"extracting global C symbols from \\`$func_to_tool_file_result'\"\n\t    $opt_dry_run || eval \"$NM $func_to_tool_file_result | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=\"$output_objdir/$outputname.exp\"\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      eval \"${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' \"'< \"$nlist\" > \"$export_symbols\"'\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n                eval 'cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"'\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      eval \"${SED} -e 's/\\([].[*^$]\\)/\\\\\\\\\\1/g' -e 's/^/ /' -e 's/$/$/'\"' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"'\n\t      eval '$GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t      case $host in\n\t        *cygwin* | *mingw* | *cegcc* )\n\t          eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n\t          eval 'cat \"$nlist\" >> \"$output_objdir/$outputname.def\"'\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from \\`$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=\"$func_basename_result\"\n          case $host in\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # if an import library, we need to obtain dlname\n\t      if func_win32_import_lib_p \"$dlprefile\"; then\n\t        func_tr_sh \"$dlprefile\"\n\t        eval \"curr_lafile=\\$libfile_$func_tr_sh_result\"\n\t        dlprefile_dlbasename=\"\"\n\t        if test -n \"$curr_lafile\" && func_lalib_p \"$curr_lafile\"; then\n\t          # Use subshell, to avoid clobbering current variable values\n\t          dlprefile_dlname=`source \"$curr_lafile\" && echo \"$dlname\"`\n\t          if test -n \"$dlprefile_dlname\" ; then\n\t            func_basename \"$dlprefile_dlname\"\n\t            dlprefile_dlbasename=\"$func_basename_result\"\n\t          else\n\t            # no lafile. user explicitly requested -dlpreopen <import library>.\n\t            $sharedlib_from_linklib_cmd \"$dlprefile\"\n\t            dlprefile_dlbasename=$sharedlib_from_linklib_result\n\t          fi\n\t        fi\n\t        $opt_dry_run || {\n\t          if test -n \"$dlprefile_dlbasename\" ; then\n\t            eval '$ECHO \": $dlprefile_dlbasename\" >> \"$nlist\"'\n\t          else\n\t            func_warning \"Could not compute DLL name from $name\"\n\t            eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          fi\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe |\n\t            $SED -e '/I __imp/d' -e 's/I __nm_/D /;s/_nm__//' >> '$nlist'\"\n\t        }\n\t      else # not an import lib\n\t        $opt_dry_run || {\n\t          eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t        }\n\t      fi\n\t    ;;\n\t    *)\n\t      $opt_dry_run || {\n\t        eval '$ECHO \": $name \" >> \"$nlist\"'\n\t        func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t        eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t      }\n\t    ;;\n          esac\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    echo '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\nextern LT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\nLT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{\\\n  { \\\"$my_originator\\\", (void *) 0 },\"\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2.*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    if test \"X$my_pic_p\" != Xno; then\n\t      pic_flag_for_symtable=\" $pic_flag\"\n\t    fi\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) func_append symtab_cflags \" $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=\"$output_objdir/${my_outputname}S.$objext\"\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for \\`$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"$compile_command\" | $SED \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"$finalize_command\" | $SED \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\n# Despite the name, also deal with 64 bit binaries.\nfunc_win32_libid ()\n{\n  $opt_debug\n  win32_libid_type=\"unknown\"\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    # Keep the egrep pattern in sync with the one in _LT_CHECK_MAGIC_METHOD.\n    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then\n      func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n      win32_nmres=`eval $NM -f posix -A \\\"$func_to_tool_file_result\\\" |\n\t$SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s,.*,import,\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n# func_cygming_dll_for_implib ARG\n#\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib ()\n{\n  $opt_debug\n  sharedlib_from_linklib_result=`$DLLTOOL --identify-strict --identify \"$1\"`\n}\n\n# func_cygming_dll_for_implib_fallback_core SECTION_NAME LIBNAMEs\n#\n# The is the core of a fallback implementation of a\n# platform-specific function to extract the name of the\n# DLL associated with the specified import library LIBNAME.\n#\n# SECTION_NAME is either .idata$6 or .idata$7, depending\n# on the platform and compiler that created the implib.\n#\n# Echos the name of the DLL associated with the\n# specified import library.\nfunc_cygming_dll_for_implib_fallback_core ()\n{\n  $opt_debug\n  match_literal=`$ECHO \"$1\" | $SED \"$sed_make_literal_regex\"`\n  $OBJDUMP -s --section \"$1\" \"$2\" 2>/dev/null |\n    $SED '/^Contents of section '\"$match_literal\"':/{\n      # Place marker at beginning of archive member dllname section\n      s/.*/====MARK====/\n      p\n      d\n    }\n    # These lines can sometimes be longer than 43 characters, but\n    # are always uninteresting\n    /:[\t ]*file format pe[i]\\{,1\\}-/d\n    /^In archive [^:]*:/d\n    # Ensure marker is printed\n    /^====MARK====/p\n    # Remove all lines with less than 43 characters\n    /^.\\{43\\}/!d\n    # From remaining lines, remove first 43 characters\n    s/^.\\{43\\}//' |\n    $SED -n '\n      # Join marker and all lines until next marker into a single line\n      /^====MARK====/ b para\n      H\n      $ b para\n      b\n      :para\n      x\n      s/\\n//g\n      # Remove the marker\n      s/^====MARK====//\n      # Remove trailing dots and whitespace\n      s/[\\. \\t]*$//\n      # Print\n      /./p' |\n    # we now have a list, one entry per line, of the stringified\n    # contents of the appropriate section of all members of the\n    # archive which possess that section. Heuristic: eliminate\n    # all those which have a first or second character that is\n    # a '.' (that is, objdump's representation of an unprintable\n    # character.) This should work for all archives with less than\n    # 0x302f exports -- but will fail for DLLs whose name actually\n    # begins with a literal '.' or a single character followed by\n    # a '.'.\n    #\n    # Of those that remain, print the first one.\n    $SED -e '/^\\./d;/^.\\./d;q'\n}\n\n# func_cygming_gnu_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is a GNU/binutils-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_gnu_implib_p ()\n{\n  $opt_debug\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_gnu_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $EGREP ' (_head_[A-Za-z0-9_]+_[ad]l*|[A-Za-z0-9_]+_[ad]l*_iname)$'`\n  test -n \"$func_cygming_gnu_implib_tmp\"\n}\n\n# func_cygming_ms_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is an MS-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_ms_implib_p ()\n{\n  $opt_debug\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_ms_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $GREP '_NULL_IMPORT_DESCRIPTOR'`\n  test -n \"$func_cygming_ms_implib_tmp\"\n}\n\n# func_cygming_dll_for_implib_fallback ARG\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n#\n# This fallback implementation is for use when $DLLTOOL\n# does not support the --identify-strict option.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib_fallback ()\n{\n  $opt_debug\n  if func_cygming_gnu_implib_p \"$1\" ; then\n    # binutils import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$7' \"$1\"`\n  elif func_cygming_ms_implib_p \"$1\" ; then\n    # ms-generated import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$6' \"$1\"`\n  else\n    # unknown\n    sharedlib_from_linklib_result=\"\"\n  fi\n}\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $opt_debug\n    f_ex_an_ar_dir=\"$1\"; shift\n    f_ex_an_ar_oldlib=\"$1\"\n    if test \"$lock_old_archive_extraction\" = yes; then\n      lockfile=$f_ex_an_ar_oldlib.lock\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    fi\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" \\\n\t\t   'stat=$?; rm -f \"$lockfile\"; exit $stat'\n    if test \"$lock_old_archive_extraction\" = yes; then\n      $opt_dry_run || rm -f \"$lockfile\"\n    fi\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $opt_debug\n    my_gentop=\"$1\"; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\"\"\n    my_xlib=\"\"\n    my_xabs=\"\"\n    my_xdir=\"\"\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=\"$my_xlib\" ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=\"$func_basename_result\"\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=\"$my_gentop/$my_xlib_u\"\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  darwin_base_archive=`basename \"$darwin_archive\"`\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches ; do\n\t      func_mkdir_p \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\" \"${darwin_archive}\"\n\t      cd \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      func_extract_an_archive \"`pwd`\" \"${darwin_base_archive}\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | sort | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | sort | $NL2SP`\n    done\n\n    func_extract_archives_result=\"$my_oldobjs\"\n}\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory in which it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=${1-no}\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    file=\\\"\\$0\\\"\"\n\n    qECHO=`$ECHO \"$ECHO\" | $SED \"$sed_quote_subst\"`\n    $ECHO \"\\\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$1\n_LTECHO_EOF'\n}\n    ECHO=\\\"$qECHO\\\"\n  fi\n\n# Very basic option parsing. These options are (a) specific to\n# the libtool wrapper, (b) are identical between the wrapper\n# /script/ and the wrapper /executable/ which is used only on\n# windows platforms, and (c) all begin with the string \"--lt-\"\n# (application programs are unlikely to have options which match\n# this pattern).\n#\n# There are only two supported options: --lt-debug and\n# --lt-dump-script. There is, deliberately, no --lt-help.\n#\n# The first argument to this parsing function should be the\n# script's $0 value, followed by \"$@\".\nlt_option_debug=\nfunc_parse_lt_options ()\n{\n  lt_script_arg0=\\$0\n  shift\n  for lt_opt\n  do\n    case \\\"\\$lt_opt\\\" in\n    --lt-debug) lt_option_debug=1 ;;\n    --lt-dump-script)\n        lt_dump_D=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%/[^/]*$%%'\\`\n        test \\\"X\\$lt_dump_D\\\" = \\\"X\\$lt_script_arg0\\\" && lt_dump_D=.\n        lt_dump_F=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%^.*/%%'\\`\n        cat \\\"\\$lt_dump_D/\\$lt_dump_F\\\"\n        exit 0\n      ;;\n    --lt-*)\n        \\$ECHO \\\"Unrecognized --lt- option: '\\$lt_opt'\\\" 1>&2\n        exit 1\n      ;;\n    esac\n  done\n\n  # Print the debug banner immediately:\n  if test -n \\\"\\$lt_option_debug\\\"; then\n    echo \\\"${outputname}:${output}:\\${LINENO}: libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\\\" 1>&2\n  fi\n}\n\n# Used when --lt-debug. Prints its arguments to stdout\n# (redirection is the responsibility of the caller)\nfunc_lt_dump_args ()\n{\n  lt_dump_args_N=1;\n  for lt_arg\n  do\n    \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[\\$lt_dump_args_N]: \\$lt_arg\\\"\n    lt_dump_args_N=\\`expr \\$lt_dump_args_N + 1\\`\n  done\n}\n\n# Core function for launching the target application\nfunc_exec_program_core ()\n{\n\"\n  case $host in\n  # Backslashes separate directories on plain windows\n  *-*-mingw | *-*-os2* | *-cegcc*)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[0]: \\$progdir\\\\\\\\\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n\n  *)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[0]: \\$progdir/\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n  esac\n  $ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n}\n\n# A function to encapsulate launching the target application\n# Strips options in the --lt-* namespace from \\$@ and\n# launches target application with the remaining arguments.\nfunc_exec_program ()\n{\n  case \\\" \\$* \\\" in\n  *\\\\ --lt-*)\n    for lt_wr_arg\n    do\n      case \\$lt_wr_arg in\n      --lt-*) ;;\n      *) set x \\\"\\$@\\\" \\\"\\$lt_wr_arg\\\"; shift;;\n      esac\n      shift\n    done ;;\n  esac\n  func_exec_program_core \\${1+\\\"\\$@\\\"}\n}\n\n  # Parse options\n  func_parse_lt_options \\\"\\$0\\\" \\${1+\\\"\\$@\\\"}\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  done\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"\\$thisdir\\\" | $SED 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test \"$fast_install\" = yes; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | ${SED} 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\$relink_command 2>&1\\`; then :\n      else\n\t$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# fixup the dll searchpath if we need to.\n\t#\n\t# Fix the DLL searchpath if we need to.  Do this before prepending\n\t# to shlibpath, because on Windows, both are PATH and uninstalled\n\t# libraries must come first.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t# Export our shlibpath_var if we have one.\n\tif test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" | $SED 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n      func_exec_program \\${1+\\\"\\$@\\\"}\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: \\\\\\`\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    \\$ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#ifdef _MSC_VER\n# define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n/* declarations of non-ANSI functions */\n#if defined(__MINGW32__)\n# ifdef __STRICT_ANSI__\nint _putenv (const char *);\n# endif\n#elif defined(__CYGWIN__)\n# ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n# endif\n/* #elif defined (other platforms) ... */\n#endif\n\n/* portability defines, excluding path handling macros */\n#if defined(_MSC_VER)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n# define S_IXUSR _S_IEXEC\n# ifndef _INTPTR_T_DEFINED\n#  define _INTPTR_T_DEFINED\n#  define intptr_t int\n# endif\n#elif defined(__MINGW32__)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n#elif defined(__CYGWIN__)\n# define HAVE_SETENV\n# define FOPEN_WB \"wb\"\n/* #elif defined (other platforms) ... */\n#endif\n\n#if defined(PATH_MAX)\n# define LT_PATHMAX PATH_MAX\n#elif defined(MAXPATHLEN)\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n/* path handling portability macros */\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \\\n  defined (__OS2__)\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free ((void *) stale); stale = 0; } \\\n} while (0)\n\n#if defined(LT_DEBUGWRAPPER)\nstatic int lt_debug = 1;\n#else\nstatic int lt_debug = 0;\n#endif\n\nconst char *program_name = \"libtool-wrapper\"; /* in case xstrdup fails */\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_debugprintf (const char *file, int line, const char *fmt, ...);\nvoid lt_fatal (const char *file, int line, const char *message, ...);\nstatic const char *nonnull (const char *s);\nstatic const char *nonempty (const char *s);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\nchar **prepare_spawn (char **argv);\nvoid lt_dump_script (FILE *f);\nEOF\n\n\t    cat <<EOF\nvolatile const char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_path \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_path \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test \"$fast_install\" = yes; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\nstatic const char *debug_opt            = LTWRAPPER_OPTION_PREFIX \"debug\";\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  intptr_t rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  newargz = XMALLOC (char *, argc + 1);\n\n  /* very simple arg parsing; don't want to rely on getopt\n   * also, copy all non cwrapper options to newargz, except\n   * argz[0], which is handled differently\n   */\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], dumpscript_opt) == 0)\n\t{\nEOF\n\t    case \"$host\" in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  lt_dump_script (stdout);\n\t  return 0;\n\t}\n      if (strcmp (argv[i], debug_opt) == 0)\n\t{\n          lt_debug = 1;\n          continue;\n\t}\n      if (strcmp (argv[i], ltwrapper_option_prefix) == 0)\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (__FILE__, __LINE__,\n\t\t    \"unrecognized %s option: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\nEOF\n\t    cat <<EOF\n  /* The GNU banner must be the first non-error debug message */\n  lt_debugprintf (__FILE__, __LINE__, \"libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\\n\");\nEOF\n\t    cat <<\"EOF\"\n  lt_debugprintf (__FILE__, __LINE__, \"(main) argv[0]: %s\\n\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__, \"(main) program_name: %s\\n\", program_name);\n\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (__FILE__, __LINE__, \"couldn't find %s\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (before symlink chase) at: %s\\n\",\n\t\t  tmp_pathspec);\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (after symlink chase) at: %s\\n\",\n\t\t  actual_cwrapper_path);\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup (base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(main) libtool target name: %s\\n\",\n\t\t  target_name);\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  /* Update the DLL searchpath.  EXE_PATH_VALUE ($dllsearchpath) must\n     be prepended before (that is, appear after) LIB_PATH_VALUE ($temp_rpath)\n     because on Windows, both *_VARNAMEs are PATH but uninstalled\n     libraries must come first. */\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n\n  lt_debugprintf (__FILE__, __LINE__, \"(main) lt_argv_zero: %s\\n\",\n\t\t  nonnull (lt_argv_zero));\n  for (i = 0; i < newargc; i++)\n    {\n      lt_debugprintf (__FILE__, __LINE__, \"(main) newargz[%d]: %s\\n\",\n\t\t      i, nonnull (newargz[i]));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  newargz = prepare_spawn (newargz);\n  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"(main) failed to launch target \\\"%s\\\": %s\\n\",\n\t\t      lt_argv_zero, nonnull (strerror (errno)));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (__FILE__, __LINE__, \"memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(check_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(make_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  int tmp_len;\n  char *concat_name;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(find_executable): %s\\n\",\n                  nonempty (wrapper));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = q - p;\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n                              nonnull (strerror (errno)));\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n              nonnull (strerror (errno)));\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"checking path component for symlinks: %s\\n\",\n\t\t      tmp_pathspec);\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  lt_fatal (__FILE__, __LINE__,\n\t\t    \"error accessing file \\\"%s\\\": %s\",\n\t\t    tmp_pathspec, nonnull (strerror (errno)));\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (__FILE__, __LINE__,\n\t\t\"could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (strcmp (str, pat) == 0)\n\t*str = '\\0';\n    }\n  return str;\n}\n\nvoid\nlt_debugprintf (const char *file, int line, const char *fmt, ...)\n{\n  va_list args;\n  if (lt_debug)\n    {\n      (void) fprintf (stderr, \"%s:%s:%d: \", program_name, file, line);\n      va_start (args, fmt);\n      (void) vfprintf (stderr, fmt, args);\n      va_end (args);\n    }\n}\n\nstatic void\nlt_error_core (int exit_status, const char *file,\n\t       int line, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s:%s:%d: %s: \", program_name, file, line, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *file, int line, const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, file, line, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nstatic const char *\nnonnull (const char *s)\n{\n  return s ? s : \"(null)\";\n}\n\nstatic const char *\nnonempty (const char *s)\n{\n  return (s && !*s) ? \"(empty)\" : nonnull (s);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_setenv) setting '%s' to '%s'\\n\",\n                  nonnull (name), nonnull (value));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    int len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      int orig_value_len = strlen (orig_value);\n      int add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      int len = strlen (new_value);\n      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[len-1] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nEOF\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n\n/* Prepares an argument vector before calling spawn().\n   Note that spawn() does not by itself call the command interpreter\n     (getenv (\"COMSPEC\") != NULL ? getenv (\"COMSPEC\") :\n      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n         GetVersionEx(&v);\n         v.dwPlatformId == VER_PLATFORM_WIN32_NT;\n      }) ? \"cmd.exe\" : \"command.com\").\n   Instead it simply concatenates the arguments, separated by ' ', and calls\n   CreateProcess().  We must quote the arguments since Win32 CreateProcess()\n   interprets characters like ' ', '\\t', '\\\\', '\"' (but not '<' and '>') in a\n   special way:\n   - Space and tab are interpreted as delimiters. They are not treated as\n     delimiters if they are surrounded by double quotes: \"...\".\n   - Unescaped double quotes are removed from the input. Their only effect is\n     that within double quotes, space and tab are treated like normal\n     characters.\n   - Backslashes not followed by double quotes are not special.\n   - But 2*n+1 backslashes followed by a double quote become\n     n backslashes followed by a double quote (n >= 0):\n       \\\" -> \"\n       \\\\\\\" -> \\\"\n       \\\\\\\\\\\" -> \\\\\"\n */\n#define SHELL_SPECIAL_CHARS \"\\\"\\\\ \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\n#define SHELL_SPACE_CHARS \" \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\nchar **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XMALLOC (char *, argc + 1);\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n\tnew_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n\t{\n\t  int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n\t  size_t length;\n\t  unsigned int backslashes;\n\t  const char *s;\n\t  char *quoted_string;\n\t  char *p;\n\n\t  length = 0;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    length++;\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\tlength += backslashes + 1;\n\t      length++;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    length += backslashes + 1;\n\n\t  quoted_string = XMALLOC (char, length + 1);\n\n\t  p = quoted_string;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    *p++ = '\"';\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\t{\n\t\t  unsigned int j;\n\t\t  for (j = backslashes + 1; j > 0; j--)\n\t\t    *p++ = '\\\\';\n\t\t}\n\t      *p++ = c;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    {\n\t      unsigned int j;\n\t      for (j = backslashes; j > 0; j--)\n\t\t*p++ = '\\\\';\n\t      *p++ = '\"';\n\t    }\n\t  *p = '\\0';\n\n\t  new_argv[i] = quoted_string;\n\t}\n      else\n\tnew_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}\nEOF\n\t\t;;\n\t    esac\n\n            cat <<\"EOF\"\nvoid lt_dump_script (FILE* f)\n{\nEOF\n\t    func_emit_wrapper yes |\n\t      $SED -n -e '\ns/^\\(.\\{79\\}\\)\\(..*\\)/\\1\\\n\\2/\nh\ns/\\([\\\\\"]\\)/\\\\\\1/g\ns/$/\\\\n/\ns/\\([^\\n]*\\).*/  fputs (\"\\1\", f);/p\ng\nD'\n            cat <<\"EOF\"\n}\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_win32_import_lib_p ARG\n# True if ARG is an import lib, as indicated by $file_magic_cmd\nfunc_win32_import_lib_p ()\n{\n    $opt_debug\n    case `eval $file_magic_cmd \\\"\\$1\\\" 2>/dev/null | $SED -e 10q` in\n    *import*) : ;;\n    *) false ;;\n    esac\n}\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $opt_debug\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # which system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll which has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    bindir=\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=no\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=\"${wl}-single_module\"\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test \"$build_libtool_libs\" = yes && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=\"$1\"\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tbindir)\n\t  bindir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tdlfiles|dlprefiles)\n\t  if test \"$preload\" = no; then\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=yes\n\t  fi\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test \"$dlself\" = no; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test \"$prev\" = dlprefiles; then\n\t      dlself=yes\n\t    elif test \"$prev\" = dlfiles && test \"$dlopen_self\" != yes; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test \"$prev\" = dlfiles; then\n\t      func_append dlfiles \" $arg\"\n\t    else\n\t      func_append dlprefiles \" $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=\"$arg\"\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file \\`$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) func_append deplibs \" $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      func_append moreargs \" $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test \"$pic_object\" = none &&\n\t\t   test \"$non_pic_object\" = none; then\n\t\t  func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=\"$func_dirname_result\"\n\n\t\tif test \"$pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=\"$xdir$pic_object\"\n\n\t\t  if test \"$prev\" = dlfiles; then\n\t\t    if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\t      func_append dlfiles \" $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test \"$prev\" = dlprefiles; then\n\t\t    # Preload the old-style object.\n\t\t    func_append dlprefiles \" $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=\"$pic_object\"\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test \"$non_pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=\"$xdir$non_pic_object\"\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t\t    arg=\"$non_pic_object\"\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=\"$pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=\"$func_dirname_result\"\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file \\`$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=\"-$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test \"$prev\" = rpath; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append rpath \" $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append xrpath \" $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  func_append weak_libs \" $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=\"$arg\"\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"\\`-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -bindir)\n\tprev=bindir\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test \"X$arg\" = \"X-export-symbols\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname \"-L\" '' \"$arg\"\n\tif test -z \"$func_stripname_result\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between \\`-L' and \\`$1'\"\n\t  else\n\t    func_fatal_error \"need path for \\`-L' option\"\n\t  fi\n\tfi\n\tfunc_resolve_sysroot \"$func_stripname_result\"\n\tdir=$func_resolve_sysroot_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of \\`$dir'\"\n\t  dir=\"$absdir\"\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"* | *\" $arg \"*)\n\t  # Will only happen for absolute or sysroot arguments\n\t  ;;\n\t*)\n\t  # Preserve sysroot, but never include relative directories\n\t  case $dir in\n\t    [\\\\/]* | [A-Za-z]:[\\\\/]* | =*) func_append deplibs \" $arg\" ;;\n\t    *) func_append deplibs \" -L$dir\" ;;\n\t  esac\n\t  func_append lib_search_path \" $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$dir\" | $SED 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) func_append dllsearchpath \":$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test \"X$arg\" = \"X-lc\" || test \"X$arg\" = \"X-lm\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  esac\n\telif test \"X$arg\" = \"X-lc_r\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tfunc_append deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot|--sysroot)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n      |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) func_append new_inherited_linker_flags \" $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=\"${wl}-multi_module\"\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"\\`-no-install' is ignored for $host\"\n\t  func_warning \"assuming \\`-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t=*)\n\t  func_stripname '=' '' \"$dir\"\n\t  dir=$lt_sysroot$func_stripname_result\n\t  ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) func_append xrpath \" $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $wl$func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $wl$func_quote_for_eval_result\"\n\t  func_append linker_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      # Flags to be passed through unchanged, with rationale:\n      # -64, -mips[0-9]      enable 64-bit mode for the SGI compiler\n      # -r[0-9][0-9]*        specify processor for the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode for the Sun compiler\n      # +DA*, +DD*           enable 64-bit mode for the HP compiler\n      # -q*                  compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* architecture-specific flags for GCC\n      # -F/path              path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-*  profiling flags for GCC\n      # @file                GCC response files\n      # -tp=*                Portland pgcc target processor selection\n      # --sysroot=*          for sysroot support\n      # -O*, -flto*, -fwhopr*, -fuse-linker-plugin GCC link-time optimization\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \\\n      -O*|-flto*|-fwhopr*|-fuse-linker-plugin)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        func_append compiler_flags \" $arg\"\n        continue\n        ;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tfunc_append objs \" $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test \"$pic_object\" = none &&\n\t     test \"$non_pic_object\" = none; then\n\t    func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=\"$func_dirname_result\"\n\n\t  if test \"$pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=\"$xdir$pic_object\"\n\n\t    if test \"$prev\" = dlfiles; then\n\t      if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\tfunc_append dlfiles \" $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test \"$prev\" = dlprefiles; then\n\t      # Preload the old-style object.\n\t      func_append dlprefiles \" $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=\"$pic_object\"\n\t  fi\n\n\t  # Non-PIC object.\n\t  if test \"$non_pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=\"$xdir$non_pic_object\"\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t      arg=\"$non_pic_object\"\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=\"$pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=\"$func_dirname_result\"\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tfunc_append deplibs \" $arg\"\n\tfunc_append old_deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tfunc_resolve_sysroot \"$arg\"\n\tif test \"$prev\" = dlfiles; then\n\t  # This library was specified with -dlopen.\n\t  func_append dlfiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telif test \"$prev\" = dlprefiles; then\n\t  # The library was specified with -dlpreopen.\n\t  func_append dlprefiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telse\n\t  func_append deplibs \" $func_resolve_sysroot_result\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prevarg' option requires an argument\"\n\n    if test \"$export_dynamic\" = yes && test -n \"$export_dynamic_flag_spec\"; then\n      eval arg=\\\"$export_dynamic_flag_spec\\\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=\"$func_basename_result\"\n    libobjs_save=\"$libobjs\"\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"\\${$shlibpath_var}\\\" \\| \\$SED \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\n    eval sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=\"$func_dirname_result$objdir\"\n    func_to_tool_file \"$output_objdir/\"\n    tool_output_objdir=$func_to_tool_file_result\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_preserve_dup_deps ; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\tesac\n      fi\n      func_append libs \" $deplib\"\n    done\n\n    if test \"$linkmode\" = lib; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) func_append specialdeplibs \" $pre_post_deps\" ;;\n\t  esac\n\t  func_append pre_post_deps \" $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can \\`-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=no\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test \"$linkmode,$pass\" = \"lib,link\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n      fi\n\n      if test \"$linkmode,$pass\" = \"lib,link\" ||\n\t test \"$linkmode,$pass\" = \"prog,scan\"; then\n\tlibs=\"$deplibs\"\n\tdeplibs=\n      fi\n      if test \"$linkmode\" = prog; then\n\tcase $pass in\n\tdlopen) libs=\"$dlfiles\" ;;\n\tdlpreopen) libs=\"$dlprefiles\" ;;\n\tlink)\n\t  libs=\"$deplibs %DEPLIBS%\"\n\t  test \"X$link_all_deplibs\" != Xno && libs=\"$libs $dependency_libs\"\n\t  ;;\n\tesac\n      fi\n      if test \"$linkmode,$pass\" = \"lib,dlpreopen\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  func_resolve_sysroot \"$lib\"\n\t  case $lib in\n\t  *.la)\tfunc_source \"$func_resolve_sysroot_result\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n\t    func_basename \"$deplib\"\n            deplib_base=$func_basename_result\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) func_append deplibs \" $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=\"$dlprefiles\"\n      fi\n      if test \"$pass\" = dlopen; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=\"$deplibs\"\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=no\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n        |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    func_append compiler_flags \" $deplib\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test \"$linkmode\" != lib && test \"$linkmode\" != prog; then\n\t    func_warning \"\\`-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test \"$linkmode\" = lib; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=\"$searchdir/lib${name}${search_ext}\"\n\t      if test -f \"$lib\"; then\n\t\tif test \"$search_ext\" = \".la\"; then\n\t\t  found=yes\n\t\telse\n\t\t  found=no\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if test \"$found\" != yes; then\n\t    # deplib doesn't seem to be a libtool library\n\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  else # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=\"$l\"\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\" ; then # only static version available\n\t\t    found=no\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=\"$func_dirname_result\"\n\t\t    lib=$ladir/$old_library\n\t\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test \"$pass\" = conv && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" = conv; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test \"$pass\" = scan; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"\\`-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test \"$pass\" = link; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    dir=$func_resolve_sysroot_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append xrpath \" $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la)\n\t  func_resolve_sysroot \"$deplib\"\n\t  lib=$func_resolve_sysroot_result\n\t  ;;\n\t*.$libext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=no\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"$deplib\\\"\" 2>/dev/null | $SED 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=yes\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=yes\n\t\t;;\n\t      esac\n\t      if test \"$valid_a_lib\" != yes; then\n\t\techo\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\techo \"*** that it is just a static archive that I should not use here.\"\n\t      else\n\t\techo\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" != link; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test \"$linkmode\" = prog; then\n\t    if test \"$pass\" = dlpreopen || test \"$dlopen_support\" != yes || test \"$build_libtool_libs\" = no; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      func_append newdlprefiles \" $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      func_append newdlfiles \" $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=yes\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\tif test \"$found\" = yes || test -f \"$lib\"; then :\n\telse\n\t  func_fatal_error \"cannot find the library \\`$lib' or unhandled argument \\`$deplib'\"\n\tfi\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=\"$func_dirname_result\"\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"$inherited_linker_flags\" | $SED 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) func_append new_inherited_linker_flags \" $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \" $dependency_libs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test \"$linkmode,$pass\" = \"lib,link\" ||\n\t   test \"$linkmode,$pass\" = \"prog,scan\" ||\n\t   { test \"$linkmode\" != prog && test \"$linkmode\" != lib; }; then\n\t  test -n \"$dlopen\" && func_append dlfiles \" $dlopen\"\n\t  test -n \"$dlpreopen\" && func_append dlprefiles \" $dlpreopen\"\n\tfi\n\n\tif test \"$pass\" = conv; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    func_append convenience \" $ladir/$objdir/$old_library\"\n\t    func_append old_convenience \" $ladir/$objdir/$old_library\"\n\t    tmp_libs=\n\t    for deplib in $dependency_libs; do\n\t      deplibs=\"$deplib $deplibs\"\n\t      if $opt_preserve_dup_deps ; then\n\t\tcase \"$tmp_libs \" in\n\t\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t\tesac\n\t      fi\n\t      func_append tmp_libs \" $deplib\"\n\t    done\n\t  elif test \"$linkmode\" != prog && test \"$linkmode\" != lib; then\n\t    func_fatal_error \"\\`$lib' is not a convenience library\"\n\t  fi\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tif test -n \"$old_library\" &&\n\t   { test \"$prefer_static_libs\" = yes ||\n\t     test \"$prefer_static_libs,$installed\" = \"built,no\"; }; then\n\t  linklib=$old_library\n\telse\n\t  for l in $old_library $library_names; do\n\t    linklib=\"$l\"\n\t  done\n\tfi\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test \"$pass\" = dlopen; then\n\t  if test -z \"$libdir\"; then\n\t    func_fatal_error \"cannot -dlopen a convenience library: \\`$lib'\"\n\t  fi\n\t  if test -z \"$dlname\" ||\n\t     test \"$dlopen_support\" != yes ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    func_append dlprefiles \" $lib $dependency_libs\"\n\t  else\n\t    func_append newdlfiles \" $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=\"$ladir\" ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of \\`$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=\"$ladir\"\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=\"$func_basename_result\"\n\n\t# Find the relevant object directory and library name.\n\tif test \"X$installed\" = Xyes; then\n\t  if test ! -f \"$lt_sysroot$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library \\`$lib' was moved.\"\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    libdir=\"$abs_ladir\"\n\t  else\n\t    dir=\"$lt_sysroot$libdir\"\n\t    absdir=\"$lt_sysroot$libdir\"\n\t  fi\n\t  test \"X$hardcode_automatic\" = Xyes && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  else\n\t    dir=\"$ladir/$objdir\"\n\t    absdir=\"$abs_ladir/$objdir\"\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test \"$pass\" = dlpreopen; then\n\t  if test -z \"$libdir\" && test \"$linkmode\" = prog; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: \\`$lib'\"\n\t  fi\n\t  case \"$host\" in\n\t    # special handling for platforms with PE-DLLs.\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # Linker will automatically link against shared library if both\n\t      # static and shared are present.  Therefore, ensure we extract\n\t      # symbols from the import library if a shared library is present\n\t      # (otherwise, the dlopen module name will be incorrect).  We do\n\t      # this by putting the import library name into $newdlprefiles.\n\t      # We recover the dlopen module name by 'saving' the la file\n\t      # name in a special purpose variable, and (later) extracting the\n\t      # dlname from the la file.\n\t      if test -n \"$dlname\"; then\n\t        func_tr_sh \"$dir/$linklib\"\n\t        eval \"libfile_$func_tr_sh_result=\\$abs_ladir/\\$laname\"\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      fi\n\t    ;;\n\t    * )\n\t      # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t      # are required to link).\n\t      if test -n \"$old_library\"; then\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t      elif test -n \"$dlname\"; then\n\t        func_append newdlprefiles \" $dir/$dlname\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      fi\n\t    ;;\n\t  esac\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test \"$linkmode\" = lib; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test \"$linkmode\" = prog && test \"$pass\" != link; then\n\t  func_append newlib_search_path \" $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=no\n\t  if test \"$link_all_deplibs\" != no || test -z \"$library_names\" ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    linkalldeplibs=yes\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         func_resolve_sysroot \"$func_stripname_result\"\n\t         func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if test \"$linkalldeplibs\" = yes; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_preserve_dup_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test \"$prefer_static_libs\" = no ||\n\t         test \"$prefer_static_libs,$installed\" = \"built,yes\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\" ; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case \"$temp_rpath:\" in\n\t      *\"$absdir:\"*) ;;\n\t      *) func_append temp_rpath \"$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if test \"$alldeplibs\" = yes &&\n\t     { test \"$deplibs_check_method\" = pass_all ||\n\t       { test \"$build_libtool_libs\" = yes &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test \"$use_static_libs\" = built && test \"$installed\" = yes; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test \"$use_static_libs\" = no || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test \"$installed\" = no; then\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\"\"\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=\"$dlpremoduletest\"\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test \"$shouldnotlink\" = yes && test \"$pass\" = link; then\n\t    echo\n\t    if test \"$linkmode\" = prog; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test \"$linkmode\" = lib &&\n\t     test \"$hardcode_into_libs\" = yes; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=\"$1\"\n\t    shift\n\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=\"$dlname\"\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=\"-$major\"\n\t\t;;\n\t      esac\n\t      eval soname=\\\"$soname_spec\\\"\n\t    else\n\t      soname=\"$realname\"\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=\"$soname\"\n\t    func_basename \"$soroot\"\n\t    soname=\"$func_basename_result\"\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from \\`$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for \\`$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test \"$linkmode\" = prog || test \"$opt_mode\" != relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test \"$hardcode_direct\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv4*uw2*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we can not\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null ; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\" ; then\n\t\t\t  echo\n\t\t\t  echo \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  echo \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=\"$dir/$old_library\"\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=\"$dir/$old_library\"\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test \"$hardcode_minus_L\" = no; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=\"$dir\" ;;\n\t\tesac\n\t\tadd_dir=\"-L$dir\"\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = no; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test \"$hardcode_direct\" = yes &&\n\t         test \"$hardcode_direct_absolute\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t      elif test \"$hardcode_minus_L\" = yes; then\n\t\tadd_dir=\"-L$absdir\"\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = yes; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test \"$lib_linked\" != yes; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) func_append compile_shlibpath \"$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test \"$hardcode_direct\" != yes &&\n\t\t test \"$hardcode_minus_L\" != yes &&\n\t\t test \"$hardcode_shlibpath_var\" = yes; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) func_append finalize_shlibpath \"$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test \"$linkmode\" = prog || test \"$opt_mode\" = relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test \"$hardcode_direct\" = yes &&\n\t       test \"$hardcode_direct_absolute\" = no; then\n\t      add=\"$libdir/$linklib\"\n\t    elif test \"$hardcode_minus_L\" = yes; then\n\t      add_dir=\"-L$libdir\"\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_shlibpath_var\" = yes; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) func_append finalize_shlibpath \"$libdir:\" ;;\n\t      esac\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_automatic\" = yes; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\" ; then\n\t\tadd=\"$inst_prefix_dir$libdir/$linklib\"\n\t      else\n\t\tadd=\"$libdir/$linklib\"\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=\"-L$libdir\"\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=\"-l$name\"\n\t    fi\n\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test \"$linkmode\" = prog; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test \"$hardcode_direct\" != unsupported; then\n\t    test -n \"$old_library\" && linklib=\"$old_library\"\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test \"$build_libtool_libs\" = yes; then\n\t  # Not a shared library\n\t  if test \"$deplibs_check_method\" != pass_all; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    echo\n\t    $ECHO \"*** Warning: This system can not link to static lib archive $lib.\"\n\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t    echo \"*** shared version of the library, which you do not appear to have.\"\n\t    if test \"$module\" = yes; then\n\t      echo \"*** But as you try to build a module library, libtool will still create \"\n\t      echo \"*** a static module, that should work as long as the dlopening application\"\n\t      echo \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\techo\n\t\techo \"*** However, this would only work if libtool was able to extract symbol\"\n\t\techo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t\techo \"*** not find such a program.  So, this module is probably useless.\"\n\t\techo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test \"$build_old_libs\" = no; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test \"$linkmode\" = lib; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test \"$hardcode_into_libs\" != yes ||\n\t       test \"$build_old_libs\" = yes ||\n\t       test \"$link_static\" = yes; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) func_append xrpath \" $temp_xrpath\";;\n\t\t   esac;;\n\t      *) func_append temp_deplibs \" $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=\"$temp_deplibs\"\n\t  fi\n\n\t  func_append newlib_search_path \" $absdir\"\n\t  # Link against this library\n\t  test \"$link_static\" = no && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    case $deplib in\n              -L*) func_stripname '-L' '' \"$deplib\"\n                   func_resolve_sysroot \"$func_stripname_result\";;\n              *) func_resolve_sysroot \"$deplib\" ;;\n            esac\n\t    if $opt_preserve_dup_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $func_resolve_sysroot_result \"*)\n                func_append specialdeplibs \" $func_resolve_sysroot_result\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $func_resolve_sysroot_result\"\n\t  done\n\n\t  if test \"$link_all_deplibs\" != no; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      path=\n\t      case $deplib in\n\t      -L*) path=\"$deplib\" ;;\n\t      *.la)\n\t        func_resolve_sysroot \"$deplib\"\n\t        deplib=$func_resolve_sysroot_result\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=$func_dirname_result\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=\"$dir\" ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of \\`$dir'\"\n\t\t    absdir=\"$dir\"\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  eval deplibrary_names=`${SED} -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\" ; then\n\t\t    for tmp in $deplibrary_names ; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\" ; then\n\t\t      depdepl=\"$absdir/$objdir/$depdepl\"\n\t\t      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      func_append compiler_flags \" ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}\"\n\t\t      func_append linker_flags \" -dylib_file ${darwin_install_name}:${depdepl}\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=\"-L$absdir/$objdir\"\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  eval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"\\`$deplib' seems to be moved\"\n\n\t\t  path=\"-L$absdir\"\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test \"$pass\" = link; then\n\tif test \"$linkmode\" = \"prog\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=\"$newdependency_libs\"\n      if test \"$pass\" = dlpreopen; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test \"$pass\" != dlopen; then\n\tif test \"$pass\" != conv; then\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append lib_search_path \" $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\tfi\n\n\tif test \"$linkmode,$pass\" != \"prog,link\"; then\n\t  vars=\"deplibs\"\n\telse\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\\"\\$$var\\\"\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) func_append tmp_libs \" $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) func_append tmp_libs \" $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\\"$tmp_libs\\\"\n\tdone # for var\n      fi\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs ; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\"\"\n\t  ;;\n\tesac\n\tif test -n \"$i\" ; then\n\t  func_append tmp_libs \" $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test \"$linkmode\" = prog; then\n      dlfiles=\"$newdlfiles\"\n    fi\n    if test \"$linkmode\" = prog || test \"$linkmode\" = lib; then\n      dlprefiles=\"$newdlprefiles\"\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"\\`-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=\"$output\"\n      func_append objs \"$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form `libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval libname=\\\"$libname_spec\\\"\n\t;;\n      *)\n\ttest \"$module\" = no && \\\n\t  func_fatal_help \"libtool library \\`$output' must begin with \\`lib'\"\n\n\tif test \"$need_lib_prefix\" != no; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval shared_ext=\\\"$shrext_cmds\\\"\n\t  eval libname=\\\"$libname_spec\\\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test \"$deplibs_check_method\" != pass_all; then\n\t  func_fatal_error \"cannot build libtool library \\`$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  echo\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  func_append libobjs \" $objs\"\n\tfi\n      fi\n\n      test \"$dlself\" != no && \\\n\tfunc_warning \"\\`-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test \"$#\" -gt 1 && \\\n\tfunc_warning \"ignoring multiple \\`-rpath's for a libtool library\"\n\n      install_libdir=\"$1\"\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test \"$build_libtool_libs\" = yes; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a `.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"\\`-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"\\`-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=\"$IFS\"; IFS=':'\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=\"$save_ifs\"\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to \\`-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=\"$1\"\n\t  number_minor=\"$2\"\n\t  number_revision=\"$3\"\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # which has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  # correct linux to gnu/linux during the next big refactor\n\t  darwin|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_revision\"\n\t    ;;\n\t  freebsd-aout|freebsd-elf|qnx|sunos)\n\t    current=\"$number_major\"\n\t    revision=\"$number_minor\"\n\t    age=\"0\"\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_minor\"\n\t    lt_irix_increment=no\n\t    ;;\n\t  *)\n\t    func_fatal_configuration \"$modename: unknown library version type \\`$version_type'\"\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=\"$1\"\n\t  revision=\"$2\"\n\t  age=\"$3\"\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT \\`$current' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION \\`$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE \\`$age' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE \\`$age' is greater than the current interface number \\`$current'\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\";\n\t  ;;\n\n\tfreebsd-elf)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test \"X$lt_irix_increment\" = \"Xno\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=\"$verstring_prefix$major.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring_prefix$major.$iface:$verstring\"\n\t  done\n\n\t  # Before this point, $major must not contain `.'.\n\t  major=.$major\n\t  versuffix=\"$major.$revision\"\n\t  ;;\n\n\tlinux) # correct to gnu/linux during the next big refactor\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\".$current.$age.$revision\"\n\t  verstring=\"$current.$age.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring:${iface}.0\"\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  func_append verstring \":${current}.0\"\n\t  ;;\n\n\tqnx)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tsunos)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\"\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 filesystems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=\"-$major\"\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type \\`$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=\"0.0\"\n\t    ;;\n\t  esac\n\t  if test \"$need_version\" = no; then\n\t    versuffix=\n\t  else\n\t    versuffix=\".0.0\"\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test \"$avoid_version\" = yes && test \"$need_version\" = no; then\n\t  major=\n\t  versuffix=\n\t  verstring=\"\"\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test \"$allow_undefined\" = yes; then\n\t  if test \"$allow_undefined_flag\" = unsupported; then\n\t    func_warning \"undefined symbols not allowed in $host shared libraries\"\n\t    build_libtool_libs=no\n\t    build_old_libs=yes\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=\"$no_undefined_flag\"\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" \"yes\"\n      func_append libobjs \" $symfileobj\"\n      test \"X$libobjs\" = \"X \" && libobjs=\n\n      if test \"$opt_mode\" != relink; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)\n\t       if test \"X$precious_files_regex\" != \"X\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       func_append removelist \" $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test \"$build_old_libs\" = yes && test \"$build_libtool_libs\" != convenience ; then\n\tfunc_append oldlibs \" $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; $lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"$lib_search_path \" | $SED \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"$deplibs \" | $SED \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"$dependency_libs \" | $SED \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  func_replace_sysroot \"$libdir\"\n\t  func_append temp_xrpath \" -R$func_replace_sysroot_result\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n\tif test \"$hardcode_into_libs\" != yes || test \"$build_old_libs\" = yes; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=\"$dlfiles\"\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlfiles \" $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=\"$dlprefiles\"\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlprefiles \" $lib\" ;;\n\tesac\n      done\n\n      if test \"$build_libtool_libs\" = yes; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test \"$build_libtool_need_lc\" = \"yes\"; then\n\t      func_append deplibs \" -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\"\"\n\tversuffix=\"\"\n\tmajor=\"\"\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    func_append newdeplibs \" $i\"\n\t\t    i=\"\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\" ; then\n\t\t  libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t  deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t    func_append newdeplibs \" $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    echo\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    echo \"*** shared version of the library, which I believe you do not have\"\n\t\t    echo \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    echo \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      func_append newdeplibs \" $i\"\n\t\t      i=\"\"\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\" ; then\n\t\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t    deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t      func_append newdeplibs \" $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      echo\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      echo \"*** I have the capability to make that library automatically link in when\"\n\t\t      echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      echo \"*** shared version of the library, which you do not appear to have\"\n\t\t      echo \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      echo \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  echo\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  echo \"*** make it link in!  You will probably need to install it or some\"\n\t\t  echo \"*** library that it depends on before this library will be fully\"\n\t\t  echo \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tif test -n \"$file_magic_glob\"; then\n\t\t  libnameglob=`func_echo_all \"$libname\" | $SED -e $file_magic_glob`\n\t\telse\n\t\t  libnameglob=$libname\n\t\tfi\n\t\ttest \"$want_nocaseglob\" = yes && nocaseglob=`shopt -p nocaseglob`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  if test \"$want_nocaseglob\" = yes; then\n\t\t    shopt -s nocaseglob\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t    $nocaseglob\n\t\t  else\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t  fi\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=\"$potent_lib\"\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=\"$potliblink\";;\n\t\t\t*) potlib=`$ECHO \"$potlib\" | $SED 's,[^/]*$,,'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval $file_magic_cmd \\\"\\$potlib\\\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tfunc_append newdeplibs \" $a_deplib\"\n\t\t\ta_deplib=\"\"\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=\"$potent_lib\" # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"$potent_lib\\\"\" 2>/dev/null | $SED 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      func_append newdeplibs \" $a_deplib\"\n\t\t      a_deplib=\"\"\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\"\"\n\t  tmp_deplibs=`$ECHO \" $deplibs\" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`\n\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t    for i in $predeps $postdeps ; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \" $tmp_deplibs\" | $SED \"s,$i,,\"`\n\t    done\n\t  fi\n\t  case $tmp_deplibs in\n\t  *[!\\\t\\ ]*)\n\t    echo\n\t    if test \"X$deplibs_check_method\" = \"Xnone\"; then\n\t      echo \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      echo \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    echo \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test \"$droppeddeps\" = yes; then\n\t  if test \"$module\" = yes; then\n\t    echo\n\t    echo \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    echo \"*** a static module, that should work as long as the dlopening\"\n\t    echo \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      echo\n\t      echo \"*** However, this would only work if libtool was able to extract symbol\"\n\t      echo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t      echo \"*** not find such a program.  So, this module is probably useless.\"\n\t      echo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test \"$build_old_libs\" = no; then\n\t      oldlibs=\"$output_objdir/$libname.$libext\"\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    echo \"*** The inter-library dependencies that have been dropped here will be\"\n\t    echo \"*** automatically added whenever a program is linked with this library\"\n\t    echo \"*** or is declared to -dlopen it.\"\n\n\t    if test \"$allow_undefined\" = no; then\n\t      echo\n\t      echo \"*** Since this library must not contain undefined symbols,\"\n\t      echo \"*** because either the platform does not support them or\"\n\t      echo \"*** it was explicitly requested with -no-undefined,\"\n\t      echo \"*** libtool will only create a static version of it.\"\n\t      if test \"$build_old_libs\" = no; then\n\t\toldlibs=\"$output_objdir/$libname.$libext\"\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \" $deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      deplibs=\"$new_libs\"\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test \"$build_libtool_libs\" = yes; then\n\t# Remove ${wl} instances when linking with ld.\n\t# FIXME: should test the right _cmds variable.\n\tcase $archive_cmds in\n\t  *\\$LD\\ *) wl= ;;\n        esac\n\tif test \"$hardcode_into_libs\" = yes; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=\"$finalize_rpath\"\n\t  test \"$opt_mode\" != relink && rpath=\"$compile_rpath$rpath\"\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tfunc_replace_sysroot \"$libdir\"\n\t\tlibdir=$func_replace_sysroot_result\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=\"$libdir\"\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    func_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t\tfunc_append dep_rpath \" $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append perm_rpath \" $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=\"$hardcode_libdirs\"\n\t    eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      func_append rpath \"$dir:\"\n\t    done\n\t    eval \"$runpath_var='$rpath\\$$runpath_var'; export $runpath_var\"\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=\"$finalize_shlibpath\"\n\ttest \"$opt_mode\" != relink && shlibpath=\"$compile_shlibpath$shlibpath\"\n\tif test -n \"$shlibpath\"; then\n\t  eval \"$shlibpath_var='$shlibpath\\$$shlibpath_var'; export $shlibpath_var\"\n\tfi\n\n\t# Get the real and link names of the library.\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval library_names=\\\"$library_names_spec\\\"\n\tset dummy $library_names\n\tshift\n\trealname=\"$1\"\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval soname=\\\"$soname_spec\\\"\n\telse\n\t  soname=\"$realname\"\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=\"$output_objdir/$realname\"\n\tlinknames=\n\tfor link\n\tdo\n\t  func_append linknames \" $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"$libobjs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=\"$output_objdir/$libname.uexp\"\n\t  func_append delfiles \" $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    if test \"x`$SED 1q $export_symbols`\" != xEXPORTS; then\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=\"$export_symbols\"\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    fi\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test \"$always_export_symbols\" = yes || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for \\`$libname.la'\"\n\t    export_symbols=\"$output_objdir/$libname.exp\"\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd1 in $cmds; do\n\t      IFS=\"$save_ifs\"\n\t      # Take the normal branch if the nm_file_list_spec branch\n\t      # doesn't work or if tool conversion is not needed.\n\t      case $nm_file_list_spec~$to_tool_file_cmd in\n\t\t*~func_convert_file_noop | *~func_convert_file_msys_to_w32 | ~*)\n\t\t  try_normal_branch=yes\n\t\t  eval cmd=\\\"$cmd1\\\"\n\t\t  func_len \" $cmd\"\n\t\t  len=$func_len_result\n\t\t  ;;\n\t\t*)\n\t\t  try_normal_branch=no\n\t\t  ;;\n\t      esac\n\t      if test \"$try_normal_branch\" = yes \\\n\t\t && { test \"$len\" -lt \"$max_cmd_len\" \\\n\t\t      || test \"$max_cmd_len\" -le -1; }\n\t      then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      elif test -n \"$nm_file_list_spec\"; then\n\t\tfunc_basename \"$output\"\n\t\toutput_la=$func_basename_result\n\t\tsave_libobjs=$libobjs\n\t\tsave_output=$output\n\t\toutput=${output_objdir}/${output_la}.nm\n\t\tfunc_to_tool_file \"$output\"\n\t\tlibobjs=$nm_file_list_spec$func_to_tool_file_result\n\t\tfunc_append delfiles \" $output\"\n\t\tfunc_verbose \"creating $NM input file list: $output\"\n\t\tfor obj in $save_libobjs; do\n\t\t  func_to_tool_file \"$obj\"\n\t\t  $ECHO \"$func_to_tool_file_result\"\n\t\tdone > \"$output\"\n\t\teval cmd=\\\"$cmd1\\\"\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\toutput=$save_output\n\t\tlibobjs=$save_libobjs\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=\"$save_ifs\"\n\t    if test -n \"$export_symbols_regex\" && test \"X$skipped_export\" != \"X:\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=\"$export_symbols\"\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t  $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    func_append tmp_deplibs \" $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test \"$compiler_needs_object\" = yes &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=\"$output_objdir/${outputname}x\"\n\t    func_append generated \" $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    func_append libobjs \" $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test \"$thread_safe\" = yes && test -n \"$thread_safe_flag_spec\"; then\n\t  eval flag=\\\"$thread_safe_flag_spec\\\"\n\t  func_append linker_flags \" $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test \"$opt_mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$module_expsym_cmds\\\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$module_cmds\\\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$archive_expsym_cmds\\\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$archive_cmds\\\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  func_basename \"$output\"\n\t  output_la=$func_basename_result\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"$with_gnu_ld\" = yes; then\n\t    output=${output_objdir}/${output_la}.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    echo 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    echo ')' >> $output\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$func_to_tool_file_result\n\t  elif test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"X$file_list_spec\" != X; then\n\t    output=${output_objdir}/${output_la}.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test \"$compiler_needs_object\" = yes; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$firstobj\\\"$file_list_spec$func_to_tool_file_result\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-${k}.$objext\n\t      eval test_cmds=\\\"$reload_cmds\\\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test \"X$objlist\" = X ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test \"$k\" -eq 1 ; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    reload_objs=$objlist\n\t\t    eval concat_cmds=\\\"$reload_cmds\\\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    reload_objs=\"$objlist $last_robj\"\n\t\t    eval concat_cmds=\\\"\\$concat_cmds~$reload_cmds~\\$RM $last_robj\\\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-${k}.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-${k}.$objext\n\t\t  objlist=\" $obj\"\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      reload_objs=\"$objlist $last_robj\"\n\t      eval concat_cmds=\\\"\\${concat_cmds}$reload_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t        eval concat_cmds=\\\"\\${concat_cmds}~\\$RM $last_robj\\\"\n\t      fi\n\t      func_append delfiles \" $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    if ${skipped_export-false}; then\n\t      func_verbose \"generating symbol list for \\`$libname.la'\"\n\t      export_symbols=\"$output_objdir/$libname.exp\"\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t\teval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t    fi\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=\"$save_ifs\"\n\t      $opt_silent || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test \"$opt_mode\" = relink; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=\"$save_ifs\"\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          if ${skipped_export-false}; then\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=\"$export_symbols\"\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t      $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  fi\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append libobjs \" $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=\"$IFS\"; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=\"$save_ifs\"\n\t  eval cmd=\\\"$cmd\\\"\n\t  $opt_silent || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test \"$opt_mode\" = relink; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=\"$save_ifs\"\n\n\t# Restore the uninstalled library and exit\n\tif test \"$opt_mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test \"$module\" = yes || test \"$export_dynamic\" = yes; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=\"$soname\"\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object \\`$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=\"$output\"\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # reload_cmds runs $LD directly, so let us get rid of\n      # -Wl from whole_archive_flag_spec and hope we can get by with\n      # turning comma into space..\n      wl=\n\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\n\t  reload_conv_objs=$reload_objs\\ `$ECHO \"$tmp_whole_archive_flags\" | $SED 's|,| |g'`\n\telse\n\t  gentop=\"$output_objdir/${obj}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # If we're not building shared, we need to use non_pic_objs\n      test \"$build_libtool_libs\" != yes && libobjs=\"$non_pic_objects\"\n\n      # Create the old-style object.\n      reload_objs=\"$objs$old_deplibs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; /\\.lib$/d; $lo2o\" | $NL2SP`\" $reload_conv_objs\" ### testsuite: skip nested quoting test\n\n      output=\"$obj\"\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$build_libtool_libs\" != yes; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || eval \"echo timestamp > $libobj\" || exit $?\n\texit $EXIT_SUCCESS\n      fi\n\n      if test -n \"$pic_flag\" || test \"$pic_mode\" != default; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=\"$libobj\"\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for programs\"\n\n      test \"$preload\" = yes \\\n        && test \"$dlopen_support\" = unknown \\\n\t&& test \"$dlopen_self\" = unknown \\\n\t&& test \"$dlopen_self_static\" = unknown && \\\n\t  func_warning \"\\`LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test \"$tagname\" = CXX ; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      func_append compile_command \" ${wl}-bind_at_load\"\n\t      func_append finalize_command \" ${wl}-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=\"$new_libs\"\n\n\n      func_append compile_command \" $compile_deplibs\"\n      func_append finalize_command \" $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`${ECHO} \"$libdir\" | ${SED} -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) func_append dllsearchpath \":$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      compile_rpath=\"$rpath\"\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      finalize_rpath=\"$rpath\"\n\n      if test -n \"$libobjs\" && test \"$build_old_libs\" = yes; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"$compile_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"$finalize_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" \"no\"\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=yes\n      case $host in\n      *cegcc* | *mingw32ce*)\n        # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.\n        wrappers_required=no\n        ;;\n      *cygwin* | *mingw* )\n        if test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      *)\n        if test \"$need_relink\" = no || test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      esac\n      if test \"$wrappers_required\" = no; then\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"$compile_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=\"$compile_command$compile_rpath\"\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.${objext}\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.${objext}\"'\n\tfi\n\n\texit $exit_status\n      fi\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test \"$no_install\" = yes; then\n\t# We don't need to create a wrapper script.\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$hardcode_action\" = relink; then\n\t# Fast installation is not supported\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\trelink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\n\tfunc_warning \"this platform does not like uninstalled shared libraries\"\n\tfunc_warning \"\\`$output' will be relinked during installation\"\n      else\n\tif test \"$fast_install\" != no; then\n\t  link_command=\"$finalize_var$compile_command$finalize_rpath\"\n\t  if test \"$fast_install\" = yes; then\n\t    relink_command=`$ECHO \"$compile_var$compile_command$compile_rpath\" | $SED 's%@OUTPUT@%\\$progdir/\\$file%g'`\n\t  else\n\t    # fast_install is set to needless\n\t    relink_command=\n\t  fi\n\telse\n\t  link_command=\"$compile_var$compile_command$compile_rpath\"\n\t  relink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\tfi\n      fi\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      if test -n \"$postlink_cmds\"; then\n\tfunc_to_tool_file \"$output_objdir/$outputname\"\n\tpostlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\tfunc_execute_cmds \"$postlink_cmds\" 'exit $?'\n      fi\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=\"$output_path/$objdir/lt-$output_name.c\"\n\t    cwrapper=\"$output_path/$output_name.exe\"\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\" ; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      if test \"$build_libtool_libs\" = convenience; then\n\toldobjs=\"$libobjs_save $symfileobj\"\n\taddlibs=\"$convenience\"\n\tbuild_libtool_libs=no\n      else\n\tif test \"$build_libtool_libs\" = module; then\n\t  oldobjs=\"$libobjs_save\"\n\t  build_libtool_libs=no\n\telse\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  if test \"$preload\" = yes && test -f \"$symfileobj\"; then\n\t    func_append oldobjs \" $symfileobj\"\n\t  fi\n\tfi\n\taddlibs=\"$old_convenience\"\n      fi\n\n      if test -n \"$addlibs\"; then\n\tgentop=\"$output_objdir/${outputname}x\"\n\tfunc_append generated \" $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\tfunc_append oldobjs \" $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test \"$build_libtool_libs\" = yes; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append oldobjs \" $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  echo \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=\"$func_basename_result\"\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      func_append oldobjs \" $gentop/$newobj\"\n\t      ;;\n\t    *) func_append oldobjs \" $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\tfunc_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n\ttool_oldlib=$func_to_tool_file_result\n\teval cmds=\\\"$old_archive_cmds\\\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telif test -n \"$archiver_list_spec\"; then\n\t  func_verbose \"using command file archive linking...\"\n\t  for obj in $oldobjs\n\t  do\n\t    func_to_tool_file \"$obj\"\n\t    $ECHO \"$func_to_tool_file_result\"\n\t  done > $output_objdir/$libname.libcmd\n\t  func_to_tool_file \"$output_objdir/$libname.libcmd\"\n\t  oldobjs=\" $archiver_list_spec$func_to_tool_file_result\"\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval test_cmds=\\\"$old_archive_cmds\\\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\" ; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\${concat_cmds}$old_archive_cmds\\\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test \"X$oldobjs\" = \"X\" ; then\n\t    eval cmds=\\\"\\$concat_cmds\\\"\n\t  else\n\t    eval cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test \"$build_old_libs\" = yes && old_library=\"$libname.$libext\"\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      if test \"$hardcode_automatic\" = yes ; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test \"$installed\" = yes; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=\"$output_objdir/$outputname\"i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=\"$func_basename_result\"\n\t\tfunc_resolve_sysroot \"$deplib\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $func_resolve_sysroot_result`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\tfunc_append newdependency_libs \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      -L*)\n\t\tfunc_stripname -L '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -L$func_replace_sysroot_result\"\n\t\t;;\n\t      -R*)\n\t\tfunc_stripname -R '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -R$func_replace_sysroot_result\"\n\t\t;;\n\t      *) func_append newdependency_libs \" $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=\"$newdependency_libs\"\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlfiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      *) func_append newdlfiles \" $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlprefiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlfiles \" $abs\"\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlprefiles \" $abs\"\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  # In fact, it would be nice if we could use this code for all target\n\t  # systems that can't hard-code library paths into their executables\n\t  # and that have no shared library path variable independent of PATH,\n\t  # but it turns out we can't easily determine that from inspecting\n\t  # libtool variables, so we have to hard-code the OSs to which it\n\t  # applies here; at the moment, that means platforms that use the PE\n\t  # object format with DLL files.  See the long comment at the top of\n\t  # tests/bindir.at for full details.\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)\n\t      # If a -bindir argument was supplied, place the dll there.\n\t      if test \"x$bindir\" != x ;\n\t      then\n\t\tfunc_relative_path \"$install_libdir\" \"$bindir\"\n\t\ttdlname=$func_relative_path_result$dlname\n\t      else\n\t\t# Otherwise fall back on heuristic.\n\t\ttdlname=../bin/$dlname\n\t      fi\n\t      ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that can not go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test \"$installed\" = no && test \"$need_relink\" = yes; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\n{ test \"$opt_mode\" = link || test \"$opt_mode\" = relink; } &&\n    func_mode_link ${1+\"$@\"}\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $opt_debug\n    RM=\"$nonopt\"\n    files=\n    rmforce=\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    for arg\n    do\n      case $arg in\n      -f) func_append RM \" $arg\"; rmforce=yes ;;\n      -*) func_append RM \" $arg\" ;;\n      *) func_append files \" $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=\"$func_dirname_result\"\n      if test \"X$dir\" = X.; then\n\todir=\"$objdir\"\n      else\n\todir=\"$dir/$objdir\"\n      fi\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n      test \"$opt_mode\" = uninstall && odir=\"$dir\"\n\n      # Remember odir for removal later, being careful to avoid duplicates\n      if test \"$opt_mode\" = clean; then\n\tcase \" $rmdirs \" in\n\t  *\" $odir \"*) ;;\n\t  *) func_append rmdirs \" $odir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif test \"$rmforce\" = yes; then\n\tcontinue\n      fi\n\n      rmfiles=\"$file\"\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    func_append rmfiles \" $odir/$n\"\n\t  done\n\t  test -n \"$old_library\" && func_append rmfiles \" $odir/$old_library\"\n\n\t  case \"$opt_mode\" in\n\t  clean)\n\t    case \" $library_names \" in\n\t    *\" $dlname \"*) ;;\n\t    *) test -n \"$dlname\" && func_append rmfiles \" $odir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && func_append rmfiles \" $odir/$name $odir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" &&\n\t     test \"$pic_object\" != none; then\n\t    func_append rmfiles \" $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" &&\n\t     test \"$non_pic_object\" != none; then\n\t    func_append rmfiles \" $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test \"$opt_mode\" = clean ; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    func_append rmfiles \" $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      func_append rmfiles \" $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    func_append rmfiles \" $odir/$name $odir/${name}S.${objext}\"\n\t    if test \"$fast_install\" = yes && test -n \"$relink_command\"; then\n\t      func_append rmfiles \" $odir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\" ; then\n\t      func_append rmfiles \" $odir/lt-${noexename}.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n\n    # Try to remove the ${objdir}s in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\n{ test \"$opt_mode\" = uninstall || test \"$opt_mode\" = clean; } &&\n    func_mode_uninstall ${1+\"$@\"}\n\ntest -z \"$opt_mode\" && {\n  help=\"$generic_help\"\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode \\`$opt_mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# in which we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n# vi:sw=2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mono/utils/mono-dl-posix.c": "/**\n * \\file\n * Interface to the dynamic linker\n *\n * Author:\n *    Mono Team (http://www.mono-project.com)\n *\n * Copyright 2001-2004 Ximian, Inc.\n * Copyright 2004-2009 Novell, Inc.\n * Licensed under the MIT license. See LICENSE file in the project root for full license information.\n */\n#include <config.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#if defined(_POSIX_VERSION) && !defined (HOST_WASM)\n\n#include \"mono/utils/mono-dl.h\"\n#include \"mono/utils/mono-embed.h\"\n#include \"mono/utils/mono-path.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <glib.h>\n#include <dlfcn.h>\n\n#if !defined (TARGET_MACH)\nconst char *\nmono_dl_get_so_prefix (void)\n{\n\treturn \"lib\";\n}\nconst char **\nmono_dl_get_so_suffixes (void)\n{\n\tstatic const char *suffixes[] = {\n\t\t\".so\",\n\t\t\"\",\n\t};\n\treturn suffixes;\n}\n\nint\nmono_dl_get_executable_path (char *buf, int buflen)\n{\n\treturn readlink (\"/proc/self/exe\", buf, buflen - 1);\n}\n\nconst char*\nmono_dl_get_system_dir (void)\n{\n\treturn NULL;\n}\n\n#endif\n\nvoid *\nmono_dl_open_file (const char *file, int flags)\n{\n#ifdef HOST_ANDROID\n\t/* Bionic doesn't support NULL filenames */\n\tif (!file)\n\t\treturn NULL;\n#endif\n\treturn dlopen (file, flags);\n}\n\nvoid\nmono_dl_close_handle (MonoDl *module)\n{\n\tdlclose (module->handle);\n}\n\nvoid*\nmono_dl_lookup_symbol (MonoDl *module, const char *name)\n{\n\treturn dlsym (module->handle, name);\n}\n\nint\nmono_dl_convert_flags (int flags)\n{\n\tint lflags = flags & MONO_DL_LOCAL? 0: RTLD_GLOBAL;\n\n\tif (flags & MONO_DL_LAZY)\n\t\tlflags |= RTLD_LAZY;\n\telse\n\t\tlflags |= RTLD_NOW;\n\treturn lflags;\n}\n\nchar*\nmono_dl_current_error_string (void)\n{\n\treturn g_strdup (dlerror ());\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mono/mini/mini-llvm.c": "/**\n * \\file\n * llvm \"Backend\" for the mono JIT\n *\n * Copyright 2009-2011 Novell Inc (http://www.novell.com)\n * Copyright 2011 Xamarin Inc (http://www.xamarin.com)\n * Licensed under the MIT license. See LICENSE file in the project root for full license information.\n */\n\n#include \"config.h\"\n\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/debug-internals.h>\n#include <mono/metadata/mempool-internals.h>\n#include <mono/metadata/environment.h>\n#include <mono/metadata/object-internals.h>\n#include <mono/metadata/abi-details.h>\n#include <mono/utils/mono-tls.h>\n#include <mono/utils/mono-dl.h>\n#include <mono/utils/mono-time.h>\n#include <mono/utils/freebsd-dwarf.h>\n\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#endif\n#ifndef __STDC_CONSTANT_MACROS\n#define __STDC_CONSTANT_MACROS\n#endif\n\n#include \"llvm-c/BitWriter.h\"\n#include \"llvm-c/Analysis.h\"\n\n#include \"mini-llvm-cpp.h\"\n#include \"llvm-jit.h\"\n#include \"aot-compiler.h\"\n#include \"mini-llvm.h\"\n#include \"mini-runtime.h\"\n\n#ifndef DISABLE_JIT\n\n#ifdef __MINGW32__\n\n#include <stddef.h>\nextern void *memset(void *, int, size_t);\nvoid bzero (void *to, size_t count) { memset (to, 0, count); }\n\n#endif\n\n#if LLVM_API_VERSION < 4\n#error \"The version of the mono llvm repository is too old.\"\n#endif\n\n#define ALIGN_PTR_TO(ptr,align) (gpointer)((((gssize)(ptr)) + (align - 1)) & (~(align - 1)))\n\n /*\n  * Information associated by mono with LLVM modules.\n  */\ntypedef struct {\n\tLLVMModuleRef lmodule;\n\tLLVMValueRef throw_icall, rethrow, match_exc, throw_corlib_exception, resume_eh;\n\tGHashTable *llvm_types;\n\tLLVMValueRef got_var;\n\tconst char *got_symbol;\n\tconst char *get_method_symbol;\n\tconst char *get_unbox_tramp_symbol;\n\tGHashTable *plt_entries;\n\tGHashTable *plt_entries_ji;\n\tGHashTable *method_to_lmethod;\n\tGHashTable *direct_callables;\n\tchar **bb_names;\n\tint bb_names_len;\n\tGPtrArray *used;\n\tLLVMTypeRef ptr_type;\n\tGPtrArray *subprogram_mds;\n\tMonoEERef *mono_ee;\n\tLLVMExecutionEngineRef ee;\n\tgboolean external_symbols;\n\tgboolean emit_dwarf;\n\tint max_got_offset;\n\tLLVMValueRef personality;\n\n\t/* For AOT */\n\tMonoAssembly *assembly;\n\tchar *global_prefix;\n\tMonoAotFileInfo aot_info;\n\tconst char *jit_got_symbol;\n\tconst char *eh_frame_symbol;\n\tLLVMValueRef get_method, get_unbox_tramp;\n\tLLVMValueRef init_method, init_method_gshared_mrgctx, init_method_gshared_this, init_method_gshared_vtable;\n\tLLVMValueRef code_start, code_end;\n\tLLVMValueRef inited_var;\n\tint max_inited_idx, max_method_idx;\n\tgboolean has_jitted_code;\n\tgboolean static_link;\n\tgboolean llvm_only;\n\tGHashTable *idx_to_lmethod;\n\tGHashTable *idx_to_unbox_tramp;\n\t/* Maps a MonoMethod to LLVM instructions representing it */\n\tGHashTable *method_to_callers;\n\tLLVMContextRef context;\n\tLLVMValueRef sentinel_exception;\n\tvoid *di_builder, *cu;\n\tGHashTable *objc_selector_to_var;\n} MonoLLVMModule;\n\n/*\n * Information associated by the backend with mono basic blocks.\n */\ntypedef struct {\n\tLLVMBasicBlockRef bblock, end_bblock;\n\tLLVMValueRef finally_ind;\n\tgboolean added, invoke_target;\n\t/* \n\t * If this bblock is the start of a finally clause, this is a list of bblocks it\n\t * needs to branch to in ENDFINALLY.\n\t */\n\tGSList *call_handler_return_bbs;\n\t/*\n\t * If this bblock is the start of a finally clause, this is the bblock that\n\t * CALL_HANDLER needs to branch to.\n\t */\n\tLLVMBasicBlockRef call_handler_target_bb;\n\t/* The list of switch statements generated by ENDFINALLY instructions */\n\tGSList *endfinally_switch_ins_list;\n\tGSList *phi_nodes;\n} BBInfo;\n\n/*\n * Structure containing emit state\n */\ntypedef struct {\n\tMonoMemPool *mempool;\n\n\t/* Maps method names to the corresponding LLVMValueRef */\n\tGHashTable *emitted_method_decls;\n\n\tMonoCompile *cfg;\n\tLLVMValueRef lmethod;\n\tMonoLLVMModule *module;\n\tLLVMModuleRef lmodule;\n\tBBInfo *bblocks;\n\tint sindex, default_index, ex_index;\n\tLLVMBuilderRef builder;\n\tLLVMValueRef *values, *addresses;\n\tMonoType **vreg_cli_types;\n\tLLVMCallInfo *linfo;\n\tMonoMethodSignature *sig;\n\tGSList *builders;\n\tGHashTable *region_to_handler;\n\tGHashTable *clause_to_handler;\n\tLLVMBuilderRef alloca_builder;\n\tLLVMValueRef last_alloca;\n\tLLVMValueRef rgctx_arg;\n\tLLVMValueRef this_arg;\n\tLLVMTypeRef *vreg_types;\n\tgboolean *is_vphi;\n\tLLVMTypeRef method_type;\n\tLLVMBasicBlockRef init_bb, inited_bb;\n\tgboolean *is_dead;\n\tgboolean *unreachable;\n\tgboolean llvm_only;\n\tgboolean has_got_access;\n\tgboolean is_linkonce;\n\tint this_arg_pindex, rgctx_arg_pindex;\n\tLLVMValueRef imt_rgctx_loc;\n\tGHashTable *llvm_types;\n\tLLVMValueRef dbg_md;\n\tMonoDebugMethodInfo *minfo;\n\tchar temp_name [32];\n\t/* For every clause, the clauses it is nested in */\n\tGSList **nested_in;\n\tLLVMValueRef ex_var;\n\tGHashTable *exc_meta;\n\tGHashTable *method_to_callers;\n\tGPtrArray *phi_values;\n\tGPtrArray *bblock_list;\n\tchar *method_name;\n\tGHashTable *jit_callees;\n\tLLVMValueRef long_bb_break_var;\n} EmitContext;\n\ntypedef struct {\n\tMonoBasicBlock *bb;\n\tMonoInst *phi;\n\tMonoBasicBlock *in_bb;\n\tint sreg;\n} PhiNode;\n\n/*\n * Instruction metadata\n * This is the same as ins_info, but LREG != IREG.\n */\n#ifdef MINI_OP\n#undef MINI_OP\n#endif\n#ifdef MINI_OP3\n#undef MINI_OP3\n#endif\n#define MINI_OP(a,b,dest,src1,src2) dest, src1, src2, ' ',\n#define MINI_OP3(a,b,dest,src1,src2,src3) dest, src1, src2, src3,\n#define NONE ' '\n#define IREG 'i'\n#define FREG 'f'\n#define VREG 'v'\n#define XREG 'x'\n#define LREG 'l'\n/* keep in sync with the enum in mini.h */\nconst char\nllvm_ins_info[] = {\n#include \"mini-ops.h\"\n};\n#undef MINI_OP\n#undef MINI_OP3\n\n#if SIZEOF_VOID_P == 4\n#define GET_LONG_IMM(ins) (((guint64)(ins)->inst_ms_word << 32) | (guint64)(guint32)(ins)->inst_ls_word)\n#else\n#define GET_LONG_IMM(ins) ((ins)->inst_imm)\n#endif\n\n#define LLVM_INS_INFO(opcode) (&llvm_ins_info [((opcode) - OP_START - 1) * 4])\n\n#if 0\n#define TRACE_FAILURE(msg) do { printf (\"%s\\n\", msg); } while (0)\n#else\n#define TRACE_FAILURE(msg)\n#endif\n\n#ifdef TARGET_X86\n#define IS_TARGET_X86 1\n#else\n#define IS_TARGET_X86 0\n#endif\n\n#ifdef TARGET_AMD64\n#define IS_TARGET_AMD64 1\n#else\n#define IS_TARGET_AMD64 0\n#endif\n\n#define ctx_ok(ctx) (!(ctx)->cfg->disable_llvm)\n\nstatic LLVMIntPredicate cond_to_llvm_cond [] = {\n\tLLVMIntEQ,\n\tLLVMIntNE,\n\tLLVMIntSLE,\n\tLLVMIntSGE,\n\tLLVMIntSLT,\n\tLLVMIntSGT,\n\tLLVMIntULE,\n\tLLVMIntUGE,\n\tLLVMIntULT,\n\tLLVMIntUGT,\n};\n\nstatic LLVMRealPredicate fpcond_to_llvm_cond [] = {\n\tLLVMRealOEQ,\n\tLLVMRealUNE,\n\tLLVMRealOLE,\n\tLLVMRealOGE,\n\tLLVMRealOLT,\n\tLLVMRealOGT,\n\tLLVMRealULE,\n\tLLVMRealUGE,\n\tLLVMRealULT,\n\tLLVMRealUGT,\n};\n\nstatic MonoNativeTlsKey current_cfg_tls_id;\n\nstatic MonoLLVMModule aot_module;\n\nstatic GHashTable *intrins_id_to_name;\nstatic GHashTable *intrins_name_to_id;\n\nstatic void init_jit_module (MonoDomain *domain);\n\nstatic void emit_dbg_loc (EmitContext *ctx, LLVMBuilderRef builder, const unsigned char *cil_code);\nstatic LLVMValueRef emit_dbg_subprogram (EmitContext *ctx, MonoCompile *cfg, LLVMValueRef method, const char *name);\nstatic void emit_dbg_info (MonoLLVMModule *module, const char *filename, const char *cu_name);\nstatic void emit_cond_system_exception (EmitContext *ctx, MonoBasicBlock *bb, const char *exc_type, LLVMValueRef cmp);\nstatic LLVMValueRef get_intrinsic (EmitContext *ctx, const char *name);\nstatic void decode_llvm_eh_info (EmitContext *ctx, gpointer eh_frame);\n\nstatic inline void\nset_failure (EmitContext *ctx, const char *message)\n{\n\tTRACE_FAILURE (reason);\n\tctx->cfg->exception_message = g_strdup (message);\n\tctx->cfg->disable_llvm = TRUE;\n}\n\n/*\n * IntPtrType:\n *\n *   The LLVM type with width == sizeof (gpointer)\n */\nstatic LLVMTypeRef\nIntPtrType (void)\n{\n\treturn sizeof (gpointer) == 8 ? LLVMInt64Type () : LLVMInt32Type ();\n}\n\nstatic LLVMTypeRef\nObjRefType (void)\n{\n\treturn sizeof (gpointer) == 8 ? LLVMPointerType (LLVMInt64Type (), 0) : LLVMPointerType (LLVMInt32Type (), 0);\n}\n\nstatic LLVMTypeRef\nThisType (void)\n{\n\treturn sizeof (gpointer) == 8 ? LLVMPointerType (LLVMInt64Type (), 0) : LLVMPointerType (LLVMInt32Type (), 0);\n}\n\n/*\n * get_vtype_size:\n *\n *   Return the size of the LLVM representation of the vtype T.\n */\nstatic guint32\nget_vtype_size (MonoType *t)\n{\n\tint size;\n\n\tsize = mono_class_value_size (mono_class_from_mono_type (t), NULL);\n\n\t/* LLVMArgAsIArgs depends on this since it stores whole words */\n\twhile (size < 2 * sizeof (gpointer) && mono_is_power_of_two (size) == -1)\n\t\tsize ++;\n\n\treturn size;\n}\n\n/*\n * simd_class_to_llvm_type:\n *\n *   Return the LLVM type corresponding to the Mono.SIMD class KLASS\n */\nstatic LLVMTypeRef\nsimd_class_to_llvm_type (EmitContext *ctx, MonoClass *klass)\n{\n\tif (!strcmp (klass->name, \"Vector2d\")) {\n\t\treturn LLVMVectorType (LLVMDoubleType (), 2);\n\t} else if (!strcmp (klass->name, \"Vector2l\")) {\n\t\treturn LLVMVectorType (LLVMInt64Type (), 2);\n\t} else if (!strcmp (klass->name, \"Vector2ul\")) {\n\t\treturn LLVMVectorType (LLVMInt64Type (), 2);\n\t} else if (!strcmp (klass->name, \"Vector4i\")) {\n\t\treturn LLVMVectorType (LLVMInt32Type (), 4);\n\t} else if (!strcmp (klass->name, \"Vector4ui\")) {\n\t\treturn LLVMVectorType (LLVMInt32Type (), 4);\n\t} else if (!strcmp (klass->name, \"Vector4f\")) {\n\t\treturn LLVMVectorType (LLVMFloatType (), 4);\n\t} else if (!strcmp (klass->name, \"Vector8s\")) {\n\t\treturn LLVMVectorType (LLVMInt16Type (), 8);\n\t} else if (!strcmp (klass->name, \"Vector8us\")) {\n\t\treturn LLVMVectorType (LLVMInt16Type (), 8);\n\t} else if (!strcmp (klass->name, \"Vector16sb\")) {\n\t\treturn LLVMVectorType (LLVMInt8Type (), 16);\n\t} else if (!strcmp (klass->name, \"Vector16b\")) {\n\t\treturn LLVMVectorType (LLVMInt8Type (), 16);\n\t} else if (!strcmp (klass->name, \"Vector2\")) {\n\t\t/* System.Numerics */\n\t\treturn LLVMVectorType (LLVMFloatType (), 4);\n\t} else if (!strcmp (klass->name, \"Vector3\")) {\n\t\treturn LLVMVectorType (LLVMFloatType (), 4);\n\t} else if (!strcmp (klass->name, \"Vector4\")) {\n\t\treturn LLVMVectorType (LLVMFloatType (), 4);\n\t} else if (!strcmp (klass->name, \"Vector`1\")) {\n\t\tMonoType *etype = mono_class_get_generic_class (klass)->context.class_inst->type_argv [0];\n\t\tswitch (etype->type) {\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_U1:\n\t\t\treturn LLVMVectorType (LLVMInt8Type (), 16);\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_U2:\n\t\t\treturn LLVMVectorType (LLVMInt16Type (), 8);\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_U4:\n\t\t\treturn LLVMVectorType (LLVMInt32Type (), 4);\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_U8:\n\t\t\treturn LLVMVectorType (LLVMInt64Type (), 2);\n\t\tcase MONO_TYPE_R4:\n\t\t\treturn LLVMVectorType (LLVMFloatType (), 4);\n\t\tcase MONO_TYPE_R8:\n\t\t\treturn LLVMVectorType (LLVMDoubleType (), 2);\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tprintf (\"%s\\n\", klass->name);\n\t\tNOT_IMPLEMENTED;\n\t\treturn NULL;\n\t}\n}\n\n/* Return the 128 bit SIMD type corresponding to the mono type TYPE */\nstatic inline G_GNUC_UNUSED LLVMTypeRef\ntype_to_simd_type (int type)\n{\n\tswitch (type) {\n\tcase MONO_TYPE_I1:\n\t\treturn LLVMVectorType (LLVMInt8Type (), 16);\n\tcase MONO_TYPE_I2:\n\t\treturn LLVMVectorType (LLVMInt16Type (), 8);\n\tcase MONO_TYPE_I4:\n\t\treturn LLVMVectorType (LLVMInt32Type (), 4);\n\tcase MONO_TYPE_I8:\n\t\treturn LLVMVectorType (LLVMInt64Type (), 2);\n\tcase MONO_TYPE_R8:\n\t\treturn LLVMVectorType (LLVMDoubleType (), 2);\n\tcase MONO_TYPE_R4:\n\t\treturn LLVMVectorType (LLVMFloatType (), 4);\n\tdefault:\n\t\tg_assert_not_reached ();\n\t\treturn NULL;\n\t}\n}\n\nstatic LLVMTypeRef\ncreate_llvm_type_for_type (MonoLLVMModule *module, MonoClass *klass)\n{\n\tint i, size, nfields, esize;\n\tLLVMTypeRef *eltypes;\n\tchar *name;\n\tMonoType *t;\n\tLLVMTypeRef ltype;\n\n\tt = &klass->byval_arg;\n\n\tif (mini_type_is_hfa (t, &nfields, &esize)) {\n\t\t/*\n\t\t * This is needed on arm64 where HFAs are returned in\n\t\t * registers.\n\t\t */\n\t\t/* SIMD types have size 16 in mono_class_value_size () */\n\t\tif (klass->simd_type)\n\t\t\tnfields = 16/ esize;\n\t\tsize = nfields;\n\t\teltypes = g_new (LLVMTypeRef, size);\n\t\tfor (i = 0; i < size; ++i)\n\t\t\teltypes [i] = esize == 4 ? LLVMFloatType () : LLVMDoubleType ();\n\t} else {\n\t\tsize = get_vtype_size (t);\n\n\t\teltypes = g_new (LLVMTypeRef, size);\n\t\tfor (i = 0; i < size; ++i)\n\t\t\teltypes [i] = LLVMInt8Type ();\n\t}\n\n\tname = mono_type_full_name (&klass->byval_arg);\n\tltype = LLVMStructCreateNamed (module->context, name);\n\tLLVMStructSetBody (ltype, eltypes, size, FALSE);\n\tg_free (eltypes);\n\tg_free (name);\n\n\treturn ltype;\n}\n\n/*\n * type_to_llvm_type:\n *\n *   Return the LLVM type corresponding to T.\n */\nstatic LLVMTypeRef\ntype_to_llvm_type (EmitContext *ctx, MonoType *t)\n{\n\tif (t->byref)\n\t\treturn ThisType ();\n\n\tt = mini_get_underlying_type (t);\n\n\tswitch (t->type) {\n\tcase MONO_TYPE_VOID:\n\t\treturn LLVMVoidType ();\n\tcase MONO_TYPE_I1:\n\t\treturn LLVMInt8Type ();\n\tcase MONO_TYPE_I2:\n\t\treturn LLVMInt16Type ();\n\tcase MONO_TYPE_I4:\n\t\treturn LLVMInt32Type ();\n\tcase MONO_TYPE_U1:\n\t\treturn LLVMInt8Type ();\n\tcase MONO_TYPE_U2:\n\t\treturn LLVMInt16Type ();\n\tcase MONO_TYPE_U4:\n\t\treturn LLVMInt32Type ();\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\t\treturn LLVMInt64Type ();\n\tcase MONO_TYPE_R4:\n\t\treturn LLVMFloatType ();\n\tcase MONO_TYPE_R8:\n\t\treturn LLVMDoubleType ();\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\t\treturn IntPtrType ();\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_PTR:\n\t\treturn ObjRefType ();\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\t/* Because of generic sharing */\n\t\treturn ObjRefType ();\n\tcase MONO_TYPE_GENERICINST:\n\t\tif (!mono_type_generic_inst_is_valuetype (t))\n\t\t\treturn ObjRefType ();\n\t\t/* Fall through */\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_TYPEDBYREF: {\n\t\tMonoClass *klass;\n\t\tLLVMTypeRef ltype;\n\n\t\tklass = mono_class_from_mono_type (t);\n\n\t\tif (MONO_CLASS_IS_SIMD (ctx->cfg, klass))\n\t\t\treturn simd_class_to_llvm_type (ctx, klass);\n\n\t\tif (klass->enumtype)\n\t\t\treturn type_to_llvm_type (ctx, mono_class_enum_basetype (klass));\n\n\t\tltype = (LLVMTypeRef)g_hash_table_lookup (ctx->module->llvm_types, klass);\n\t\tif (!ltype) {\n\t\t\tltype = create_llvm_type_for_type (ctx->module, klass);\n\t\t\tg_hash_table_insert (ctx->module->llvm_types, klass, ltype);\n\t\t}\n\t\treturn ltype;\n\t}\n\n\tdefault:\n\t\tprintf (\"X: %d\\n\", t->type);\n\t\tctx->cfg->exception_message = g_strdup_printf (\"type %s\", mono_type_full_name (t));\n\t\tctx->cfg->disable_llvm = TRUE;\n\t\treturn NULL;\n\t}\n}\n\n/*\n * type_is_unsigned:\n *\n *   Return whenever T is an unsigned int type.\n */\nstatic gboolean\ntype_is_unsigned (EmitContext *ctx, MonoType *t)\n{\n\tt = mini_get_underlying_type (t);\n\tif (t->byref)\n\t\treturn FALSE;\n\tswitch (t->type) {\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_U8:\n\t\treturn TRUE;\n\tdefault:\n\t\treturn FALSE;\n\t}\n}\n\n/*\n * type_to_llvm_arg_type:\n *\n *   Same as type_to_llvm_type, but treat i8/i16 as i32.\n */\nstatic LLVMTypeRef\ntype_to_llvm_arg_type (EmitContext *ctx, MonoType *t)\n{\n\tLLVMTypeRef ptype = type_to_llvm_type (ctx, t);\n\n\tif (ctx->cfg->llvm_only)\n\t\treturn ptype;\n\n\t/*\n\t * This works on all abis except arm64/ios which passes multiple\n\t * arguments in one stack slot.\n\t */\n#ifndef TARGET_ARM64\n\tif (ptype == LLVMInt8Type () || ptype == LLVMInt16Type ()) {\n\t\t/* \n\t\t * LLVM generates code which only sets the lower bits, while JITted\n\t\t * code expects all the bits to be set.\n\t\t */\n\t\tptype = LLVMInt32Type ();\n\t}\n#endif\n\n\treturn ptype;\n}\n\n/*\n * llvm_type_to_stack_type:\n *\n *   Return the LLVM type which needs to be used when a value of type TYPE is pushed\n * on the IL stack.\n */\nstatic G_GNUC_UNUSED LLVMTypeRef\nllvm_type_to_stack_type (MonoCompile *cfg, LLVMTypeRef type)\n{\n\tif (type == NULL)\n\t\treturn NULL;\n\tif (type == LLVMInt8Type ())\n\t\treturn LLVMInt32Type ();\n\telse if (type == LLVMInt16Type ())\n\t\treturn LLVMInt32Type ();\n\telse if (!cfg->r4fp && type == LLVMFloatType ())\n\t\treturn LLVMDoubleType ();\n\telse\n\t\treturn type;\n}\n\n/*\n * regtype_to_llvm_type:\n *\n *   Return the LLVM type corresponding to the regtype C used in instruction \n * descriptions.\n */\nstatic LLVMTypeRef\nregtype_to_llvm_type (char c)\n{\n\tswitch (c) {\n\tcase 'i':\n\t\treturn LLVMInt32Type ();\n\tcase 'l':\n\t\treturn LLVMInt64Type ();\n\tcase 'f':\n\t\treturn LLVMDoubleType ();\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n/*\n * op_to_llvm_type:\n *\n *   Return the LLVM type corresponding to the unary/binary opcode OPCODE.\n */\nstatic LLVMTypeRef\nop_to_llvm_type (int opcode)\n{\n\tswitch (opcode) {\n\tcase OP_ICONV_TO_I1:\n\tcase OP_LCONV_TO_I1:\n\t\treturn LLVMInt8Type ();\n\tcase OP_ICONV_TO_U1:\n\tcase OP_LCONV_TO_U1:\n\t\treturn LLVMInt8Type ();\n\tcase OP_ICONV_TO_I2:\n\tcase OP_LCONV_TO_I2:\n\t\treturn LLVMInt16Type ();\n\tcase OP_ICONV_TO_U2:\n\tcase OP_LCONV_TO_U2:\n\t\treturn LLVMInt16Type ();\n\tcase OP_ICONV_TO_I4:\n\tcase OP_LCONV_TO_I4:\n\t\treturn LLVMInt32Type ();\n\tcase OP_ICONV_TO_U4:\n\tcase OP_LCONV_TO_U4:\n\t\treturn LLVMInt32Type ();\n\tcase OP_ICONV_TO_I8:\n\t\treturn LLVMInt64Type ();\n\tcase OP_ICONV_TO_R4:\n\t\treturn LLVMFloatType ();\n\tcase OP_ICONV_TO_R8:\n\t\treturn LLVMDoubleType ();\n\tcase OP_ICONV_TO_U8:\n\t\treturn LLVMInt64Type ();\n\tcase OP_FCONV_TO_I4:\n\t\treturn LLVMInt32Type ();\n\tcase OP_FCONV_TO_I8:\n\t\treturn LLVMInt64Type ();\n\tcase OP_FCONV_TO_I1:\n\tcase OP_FCONV_TO_U1:\n\tcase OP_RCONV_TO_I1:\n\tcase OP_RCONV_TO_U1:\n\t\treturn LLVMInt8Type ();\n\tcase OP_FCONV_TO_I2:\n\tcase OP_FCONV_TO_U2:\n\tcase OP_RCONV_TO_I2:\n\tcase OP_RCONV_TO_U2:\n\t\treturn LLVMInt16Type ();\n\tcase OP_RCONV_TO_U4:\n\t\treturn LLVMInt32Type ();\n\tcase OP_FCONV_TO_I:\n\tcase OP_FCONV_TO_U:\n\t\treturn sizeof (gpointer) == 8 ? LLVMInt64Type () : LLVMInt32Type ();\n\tcase OP_IADD_OVF:\n\tcase OP_IADD_OVF_UN:\n\tcase OP_ISUB_OVF:\n\tcase OP_ISUB_OVF_UN:\n\tcase OP_IMUL_OVF:\n\tcase OP_IMUL_OVF_UN:\n\t\treturn LLVMInt32Type ();\n\tcase OP_LADD_OVF:\n\tcase OP_LADD_OVF_UN:\n\tcase OP_LSUB_OVF:\n\tcase OP_LSUB_OVF_UN:\n\tcase OP_LMUL_OVF:\n\tcase OP_LMUL_OVF_UN:\n\t\treturn LLVMInt64Type ();\n\tdefault:\n\t\tprintf (\"%s\\n\", mono_inst_name (opcode));\n\t\tg_assert_not_reached ();\n\t\treturn NULL;\n\t}\n}\t\t\n\n#define CLAUSE_START(clause) ((clause)->try_offset)\n#define CLAUSE_END(clause) (((clause))->try_offset + ((clause))->try_len)\n\n/*\n * load_store_to_llvm_type:\n *\n *   Return the size/sign/zero extension corresponding to the load/store opcode\n * OPCODE.\n */\nstatic LLVMTypeRef\nload_store_to_llvm_type (int opcode, int *size, gboolean *sext, gboolean *zext)\n{\n\t*sext = FALSE;\n\t*zext = FALSE;\n\n\tswitch (opcode) {\n\tcase OP_LOADI1_MEMBASE:\n\tcase OP_STOREI1_MEMBASE_REG:\n\tcase OP_STOREI1_MEMBASE_IMM:\n\tcase OP_ATOMIC_LOAD_I1:\n\tcase OP_ATOMIC_STORE_I1:\n\t\t*size = 1;\n\t\t*sext = TRUE;\n\t\treturn LLVMInt8Type ();\n\tcase OP_LOADU1_MEMBASE:\n\tcase OP_LOADU1_MEM:\n\tcase OP_ATOMIC_LOAD_U1:\n\tcase OP_ATOMIC_STORE_U1:\n\t\t*size = 1;\n\t\t*zext = TRUE;\n\t\treturn LLVMInt8Type ();\n\tcase OP_LOADI2_MEMBASE:\n\tcase OP_STOREI2_MEMBASE_REG:\n\tcase OP_STOREI2_MEMBASE_IMM:\n\tcase OP_ATOMIC_LOAD_I2:\n\tcase OP_ATOMIC_STORE_I2:\n\t\t*size = 2;\n\t\t*sext = TRUE;\n\t\treturn LLVMInt16Type ();\n\tcase OP_LOADU2_MEMBASE:\n\tcase OP_LOADU2_MEM:\n\tcase OP_ATOMIC_LOAD_U2:\n\tcase OP_ATOMIC_STORE_U2:\n\t\t*size = 2;\n\t\t*zext = TRUE;\n\t\treturn LLVMInt16Type ();\n\tcase OP_LOADI4_MEMBASE:\n\tcase OP_LOADU4_MEMBASE:\n\tcase OP_LOADI4_MEM:\n\tcase OP_LOADU4_MEM:\n\tcase OP_STOREI4_MEMBASE_REG:\n\tcase OP_STOREI4_MEMBASE_IMM:\n\tcase OP_ATOMIC_LOAD_I4:\n\tcase OP_ATOMIC_STORE_I4:\n\tcase OP_ATOMIC_LOAD_U4:\n\tcase OP_ATOMIC_STORE_U4:\n\t\t*size = 4;\n\t\treturn LLVMInt32Type ();\n\tcase OP_LOADI8_MEMBASE:\n\tcase OP_LOADI8_MEM:\n\tcase OP_STOREI8_MEMBASE_REG:\n\tcase OP_STOREI8_MEMBASE_IMM:\n\tcase OP_ATOMIC_LOAD_I8:\n\tcase OP_ATOMIC_STORE_I8:\n\tcase OP_ATOMIC_LOAD_U8:\n\tcase OP_ATOMIC_STORE_U8:\n\t\t*size = 8;\n\t\treturn LLVMInt64Type ();\n\tcase OP_LOADR4_MEMBASE:\n\tcase OP_STORER4_MEMBASE_REG:\n\tcase OP_ATOMIC_LOAD_R4:\n\tcase OP_ATOMIC_STORE_R4:\n\t\t*size = 4;\n\t\treturn LLVMFloatType ();\n\tcase OP_LOADR8_MEMBASE:\n\tcase OP_STORER8_MEMBASE_REG:\n\tcase OP_ATOMIC_LOAD_R8:\n\tcase OP_ATOMIC_STORE_R8:\n\t\t*size = 8;\n\t\treturn LLVMDoubleType ();\n\tcase OP_LOAD_MEMBASE:\n\tcase OP_LOAD_MEM:\n\tcase OP_STORE_MEMBASE_REG:\n\tcase OP_STORE_MEMBASE_IMM:\n\t\t*size = sizeof (gpointer);\n\t\treturn IntPtrType ();\n\tdefault:\n\t\tg_assert_not_reached ();\n\t\treturn NULL;\n\t}\n}\n\n/*\n * ovf_op_to_intrins:\n *\n *   Return the LLVM intrinsics corresponding to the overflow opcode OPCODE.\n */\nstatic const char*\novf_op_to_intrins (int opcode)\n{\n\tswitch (opcode) {\n\tcase OP_IADD_OVF:\n\t\treturn \"llvm.sadd.with.overflow.i32\";\n\tcase OP_IADD_OVF_UN:\n\t\treturn \"llvm.uadd.with.overflow.i32\";\n\tcase OP_ISUB_OVF:\n\t\treturn \"llvm.ssub.with.overflow.i32\";\n\tcase OP_ISUB_OVF_UN:\n\t\treturn \"llvm.usub.with.overflow.i32\";\n\tcase OP_IMUL_OVF:\n\t\treturn \"llvm.smul.with.overflow.i32\";\n\tcase OP_IMUL_OVF_UN:\n\t\treturn \"llvm.umul.with.overflow.i32\";\n\tcase OP_LADD_OVF:\n\t\treturn \"llvm.sadd.with.overflow.i64\";\n\tcase OP_LADD_OVF_UN:\n\t\treturn \"llvm.uadd.with.overflow.i64\";\n\tcase OP_LSUB_OVF:\n\t\treturn \"llvm.ssub.with.overflow.i64\";\n\tcase OP_LSUB_OVF_UN:\n\t\treturn \"llvm.usub.with.overflow.i64\";\n\tcase OP_LMUL_OVF:\n\t\treturn \"llvm.smul.with.overflow.i64\";\n\tcase OP_LMUL_OVF_UN:\n\t\treturn \"llvm.umul.with.overflow.i64\";\n\tdefault:\n\t\tg_assert_not_reached ();\n\t\treturn NULL;\n\t}\n}\n\nstatic const char*\nsimd_op_to_intrins (int opcode)\n{\n\tswitch (opcode) {\n#if defined(TARGET_X86) || defined(TARGET_AMD64)\n\tcase OP_MINPD:\n\t\treturn \"llvm.x86.sse2.min.pd\";\n\tcase OP_MINPS:\n\t\treturn \"llvm.x86.sse.min.ps\";\n\tcase OP_MAXPD:\n\t\treturn \"llvm.x86.sse2.max.pd\";\n\tcase OP_MAXPS:\n\t\treturn \"llvm.x86.sse.max.ps\";\n\tcase OP_HADDPD:\n\t\treturn \"llvm.x86.sse3.hadd.pd\";\n\tcase OP_HADDPS:\n\t\treturn \"llvm.x86.sse3.hadd.ps\";\n\tcase OP_HSUBPD:\n\t\treturn \"llvm.x86.sse3.hsub.pd\";\n\tcase OP_HSUBPS:\n\t\treturn \"llvm.x86.sse3.hsub.ps\";\n\tcase OP_ADDSUBPS:\n\t\treturn \"llvm.x86.sse3.addsub.ps\";\n\tcase OP_ADDSUBPD:\n\t\treturn \"llvm.x86.sse3.addsub.pd\";\n\tcase OP_EXTRACT_MASK:\n\t\treturn \"llvm.x86.sse2.pmovmskb.128\";\n\tcase OP_PSHRW:\n\tcase OP_PSHRW_REG:\n\t\treturn \"llvm.x86.sse2.psrli.w\";\n\tcase OP_PSHRD:\n\tcase OP_PSHRD_REG:\n\t\treturn \"llvm.x86.sse2.psrli.d\";\n\tcase OP_PSHRQ:\n\tcase OP_PSHRQ_REG:\n\t\treturn \"llvm.x86.sse2.psrli.q\";\n\tcase OP_PSHLW:\n\tcase OP_PSHLW_REG:\n\t\treturn \"llvm.x86.sse2.pslli.w\";\n\tcase OP_PSHLD:\n\tcase OP_PSHLD_REG:\n\t\treturn \"llvm.x86.sse2.pslli.d\";\n\tcase OP_PSHLQ:\n\tcase OP_PSHLQ_REG:\n\t\treturn \"llvm.x86.sse2.pslli.q\";\n\tcase OP_PSARW:\n\tcase OP_PSARW_REG:\n\t\treturn \"llvm.x86.sse2.psrai.w\";\n\tcase OP_PSARD:\n\tcase OP_PSARD_REG:\n\t\treturn \"llvm.x86.sse2.psrai.d\";\n\tcase OP_PADDB_SAT:\n\t\treturn \"llvm.x86.sse2.padds.b\";\n\tcase OP_PADDW_SAT:\n\t\treturn \"llvm.x86.sse2.padds.w\";\n\tcase OP_PSUBB_SAT:\n\t\treturn \"llvm.x86.sse2.psubs.b\";\n\tcase OP_PSUBW_SAT:\n\t\treturn \"llvm.x86.sse2.psubs.w\";\n\tcase OP_PADDB_SAT_UN:\n\t\treturn \"llvm.x86.sse2.paddus.b\";\n\tcase OP_PADDW_SAT_UN:\n\t\treturn \"llvm.x86.sse2.paddus.w\";\n\tcase OP_PSUBB_SAT_UN:\n\t\treturn \"llvm.x86.sse2.psubus.b\";\n\tcase OP_PSUBW_SAT_UN:\n\t\treturn \"llvm.x86.sse2.psubus.w\";\n\tcase OP_PAVGB_UN:\n\t\treturn \"llvm.x86.sse2.pavg.b\";\n\tcase OP_PAVGW_UN:\n\t\treturn \"llvm.x86.sse2.pavg.w\";\n\tcase OP_SQRTPS:\n\t\treturn \"llvm.x86.sse.sqrt.ps\";\n\tcase OP_SQRTPD:\n\t\treturn \"llvm.x86.sse2.sqrt.pd\";\n\tcase OP_RSQRTPS:\n\t\treturn \"llvm.x86.sse.rsqrt.ps\";\n\tcase OP_RCPPS:\n\t\treturn \"llvm.x86.sse.rcp.ps\";\n\tcase OP_CVTDQ2PD:\n\t\treturn \"llvm.x86.sse2.cvtdq2pd\";\n\tcase OP_CVTDQ2PS:\n\t\treturn \"llvm.x86.sse2.cvtdq2ps\";\n\tcase OP_CVTPD2DQ:\n\t\treturn \"llvm.x86.sse2.cvtpd2dq\";\n\tcase OP_CVTPS2DQ:\n\t\treturn \"llvm.x86.sse2.cvtps2dq\";\n\tcase OP_CVTPD2PS:\n\t\treturn \"llvm.x86.sse2.cvtpd2ps\";\n\tcase OP_CVTPS2PD:\n\t\treturn \"llvm.x86.sse2.cvtps2pd\";\n\tcase OP_CVTTPD2DQ:\n\t\treturn \"llvm.x86.sse2.cvttpd2dq\";\n\tcase OP_CVTTPS2DQ:\n\t\treturn \"llvm.x86.sse2.cvttps2dq\";\n\tcase OP_PACKW:\n\t\treturn \"llvm.x86.sse2.packsswb.128\";\n\tcase OP_PACKD:\n\t\treturn \"llvm.x86.sse2.packssdw.128\";\n\tcase OP_PACKW_UN:\n\t\treturn \"llvm.x86.sse2.packuswb.128\";\n\tcase OP_PACKD_UN:\n\t\treturn \"llvm.x86.sse41.packusdw\";\n\tcase OP_PMULW_HIGH:\n\t\treturn \"llvm.x86.sse2.pmulh.w\";\n\tcase OP_PMULW_HIGH_UN:\n\t\treturn \"llvm.x86.sse2.pmulhu.w\";\n\tcase OP_DPPS:\n\t\treturn \"llvm.x86.sse41.dpps\";\n#endif\n\tdefault:\n\t\tg_assert_not_reached ();\n\t\treturn NULL;\n\t}\n}\n\nstatic LLVMTypeRef\nsimd_op_to_llvm_type (int opcode)\n{\n#if defined(TARGET_X86) || defined(TARGET_AMD64)\n\tswitch (opcode) {\n\tcase OP_EXTRACT_R8:\n\tcase OP_EXPAND_R8:\n\t\treturn type_to_simd_type (MONO_TYPE_R8);\n\tcase OP_EXTRACT_I8:\n\tcase OP_EXPAND_I8:\n\t\treturn type_to_simd_type (MONO_TYPE_I8);\n\tcase OP_EXTRACT_I4:\n\tcase OP_EXPAND_I4:\n\t\treturn type_to_simd_type (MONO_TYPE_I4);\n\tcase OP_EXTRACT_I2:\n\tcase OP_EXTRACT_U2:\n\tcase OP_EXTRACTX_U2:\n\tcase OP_EXPAND_I2:\n\t\treturn type_to_simd_type (MONO_TYPE_I2);\n\tcase OP_EXTRACT_I1:\n\tcase OP_EXTRACT_U1:\n\tcase OP_EXPAND_I1:\n\t\treturn type_to_simd_type (MONO_TYPE_I1);\n\tcase OP_EXPAND_R4:\n\t\treturn type_to_simd_type (MONO_TYPE_R4);\n\tcase OP_CVTDQ2PD:\n\tcase OP_CVTDQ2PS:\n\t\treturn type_to_simd_type (MONO_TYPE_I4);\n\tcase OP_CVTPD2DQ:\n\tcase OP_CVTPD2PS:\n\tcase OP_CVTTPD2DQ:\n\t\treturn type_to_simd_type (MONO_TYPE_R8);\n\tcase OP_CVTPS2DQ:\n\tcase OP_CVTPS2PD:\n\tcase OP_CVTTPS2DQ:\n\t\treturn type_to_simd_type (MONO_TYPE_R4);\n\tcase OP_EXTRACT_MASK:\n\t\treturn type_to_simd_type (MONO_TYPE_I1);\n\tcase OP_SQRTPS:\n\tcase OP_RSQRTPS:\n\tcase OP_RCPPS:\n\tcase OP_DUPPS_LOW:\n\tcase OP_DUPPS_HIGH:\n\t\treturn type_to_simd_type (MONO_TYPE_R4);\n\tcase OP_SQRTPD:\n\tcase OP_DUPPD:\n\t\treturn type_to_simd_type (MONO_TYPE_R8);\n\tdefault:\n\t\tg_assert_not_reached ();\n\t\treturn NULL;\n\t}\n#else\n\treturn NULL;\n#endif\n}\n\n/*\n * get_bb:\n *\n *   Return the LLVM basic block corresponding to BB.\n */\nstatic LLVMBasicBlockRef\nget_bb (EmitContext *ctx, MonoBasicBlock *bb)\n{\n\tchar bb_name_buf [128];\n\tchar *bb_name;\n\n\tif (ctx->bblocks [bb->block_num].bblock == NULL) {\n\t\tif (bb->flags & BB_EXCEPTION_HANDLER) {\n\t\t\tint clause_index = (mono_get_block_region_notry (ctx->cfg, bb->region) >> 8) - 1;\n\t\t\tsprintf (bb_name_buf, \"EH_CLAUSE%d_BB%d\", clause_index, bb->block_num);\n\t\t\tbb_name = bb_name_buf;\n\t\t} else if (bb->block_num < 256) {\n\t\t\tif (!ctx->module->bb_names) {\n\t\t\t\tctx->module->bb_names_len = 256;\n\t\t\t\tctx->module->bb_names = g_new0 (char*, ctx->module->bb_names_len);\n\t\t\t}\n\t\t\tif (!ctx->module->bb_names [bb->block_num]) {\n\t\t\t\tchar *n;\n\n\t\t\t\tn = g_strdup_printf (\"BB%d\", bb->block_num);\n\t\t\t\tmono_memory_barrier ();\n\t\t\t\tctx->module->bb_names [bb->block_num] = n;\n\t\t\t}\n\t\t\tbb_name = ctx->module->bb_names [bb->block_num];\n\t\t} else {\n\t\t\tsprintf (bb_name_buf, \"BB%d\", bb->block_num);\n\t\t\tbb_name = bb_name_buf;\n\t\t}\n\n\t\tctx->bblocks [bb->block_num].bblock = LLVMAppendBasicBlock (ctx->lmethod, bb_name);\n\t\tctx->bblocks [bb->block_num].end_bblock = ctx->bblocks [bb->block_num].bblock;\n\t}\n\n\treturn ctx->bblocks [bb->block_num].bblock;\n}\n\n/* \n * get_end_bb:\n *\n *   Return the last LLVM bblock corresponding to BB.\n * This might not be equal to the bb returned by get_bb () since we need to generate\n * multiple LLVM bblocks for a mono bblock to handle throwing exceptions.\n */\nstatic LLVMBasicBlockRef\nget_end_bb (EmitContext *ctx, MonoBasicBlock *bb)\n{\n\tget_bb (ctx, bb);\n\treturn ctx->bblocks [bb->block_num].end_bblock;\n}\n\nstatic LLVMBasicBlockRef\ngen_bb (EmitContext *ctx, const char *prefix)\n{\n\tchar bb_name [128];\n\n\tsprintf (bb_name, \"%s%d\", prefix, ++ ctx->ex_index);\n\treturn LLVMAppendBasicBlock (ctx->lmethod, bb_name);\n}\n\n/*\n * resolve_patch:\n *\n *   Return the target of the patch identified by TYPE and TARGET.\n */\nstatic gpointer\nresolve_patch (MonoCompile *cfg, MonoJumpInfoType type, gconstpointer target)\n{\n\tMonoJumpInfo ji;\n\tMonoError error;\n\tgpointer res;\n\n\tmemset (&ji, 0, sizeof (ji));\n\tji.type = type;\n\tji.data.target = target;\n\n\tres = mono_resolve_patch_target (cfg->method, cfg->domain, NULL, &ji, FALSE, &error);\n\tmono_error_assert_ok (&error);\n\n\treturn res;\n}\n\n/*\n * convert_full:\n *\n *   Emit code to convert the LLVM value V to DTYPE.\n */\nstatic LLVMValueRef\nconvert_full (EmitContext *ctx, LLVMValueRef v, LLVMTypeRef dtype, gboolean is_unsigned)\n{\n\tLLVMTypeRef stype = LLVMTypeOf (v);\n\n\tif (stype != dtype) {\n\t\tgboolean ext = FALSE;\n\n\t\t/* Extend */\n\t\tif (dtype == LLVMInt64Type () && (stype == LLVMInt32Type () || stype == LLVMInt16Type () || stype == LLVMInt8Type ()))\n\t\t\text = TRUE;\n\t\telse if (dtype == LLVMInt32Type () && (stype == LLVMInt16Type () || stype == LLVMInt8Type ()))\n\t\t\text = TRUE;\n\t\telse if (dtype == LLVMInt16Type () && (stype == LLVMInt8Type ()))\n\t\t\text = TRUE;\n\n\t\tif (ext)\n\t\t\treturn is_unsigned ? LLVMBuildZExt (ctx->builder, v, dtype, \"\") : LLVMBuildSExt (ctx->builder, v, dtype, \"\");\n\n\t\tif (dtype == LLVMDoubleType () && stype == LLVMFloatType ())\n\t\t\treturn LLVMBuildFPExt (ctx->builder, v, dtype, \"\");\n\n\t\t/* Trunc */\n\t\tif (stype == LLVMInt64Type () && (dtype == LLVMInt32Type () || dtype == LLVMInt16Type () || dtype == LLVMInt8Type ()))\n\t\t\treturn LLVMBuildTrunc (ctx->builder, v, dtype, \"\");\n\t\tif (stype == LLVMInt32Type () && (dtype == LLVMInt16Type () || dtype == LLVMInt8Type ()))\n\t\t\treturn LLVMBuildTrunc (ctx->builder, v, dtype, \"\");\n\t\tif (stype == LLVMInt16Type () && dtype == LLVMInt8Type ())\n\t\t\treturn LLVMBuildTrunc (ctx->builder, v, dtype, \"\");\n\t\tif (stype == LLVMDoubleType () && dtype == LLVMFloatType ())\n\t\t\treturn LLVMBuildFPTrunc (ctx->builder, v, dtype, \"\");\n\n\t\tif (LLVMGetTypeKind (stype) == LLVMPointerTypeKind && LLVMGetTypeKind (dtype) == LLVMPointerTypeKind)\n\t\t\treturn LLVMBuildBitCast (ctx->builder, v, dtype, \"\");\n\t\tif (LLVMGetTypeKind (dtype) == LLVMPointerTypeKind)\n\t\t\treturn LLVMBuildIntToPtr (ctx->builder, v, dtype, \"\");\n\t\tif (LLVMGetTypeKind (stype) == LLVMPointerTypeKind)\n\t\t\treturn LLVMBuildPtrToInt (ctx->builder, v, dtype, \"\");\n\n\t\tif (mono_arch_is_soft_float ()) {\n\t\t\tif (stype == LLVMInt32Type () && dtype == LLVMFloatType ())\n\t\t\t\treturn LLVMBuildBitCast (ctx->builder, v, dtype, \"\");\n\t\t\tif (stype == LLVMInt32Type () && dtype == LLVMDoubleType ())\n\t\t\t\treturn LLVMBuildBitCast (ctx->builder, LLVMBuildZExt (ctx->builder, v, LLVMInt64Type (), \"\"), dtype, \"\");\n\t\t}\n\n\t\tif (LLVMGetTypeKind (stype) == LLVMVectorTypeKind && LLVMGetTypeKind (dtype) == LLVMVectorTypeKind)\n\t\t\treturn LLVMBuildBitCast (ctx->builder, v, dtype, \"\");\n\n\t\tLLVMDumpValue (v);\n\t\tLLVMDumpValue (LLVMConstNull (dtype));\n\t\tg_assert_not_reached ();\n\t\treturn NULL;\n\t} else {\n\t\treturn v;\n\t}\n}\n\nstatic LLVMValueRef\nconvert (EmitContext *ctx, LLVMValueRef v, LLVMTypeRef dtype)\n{\n\treturn convert_full (ctx, v, dtype, FALSE);\n}\n\n/*\n * emit_volatile_load:\n *\n *   If vreg is volatile, emit a load from its address.\n */\nstatic LLVMValueRef\nemit_volatile_load (EmitContext *ctx, int vreg)\n{\n\tMonoType *t;\n\tLLVMValueRef v;\n\n#ifdef TARGET_ARM64\n\t// FIXME: This hack is required because we pass the rgctx in a callee saved\n\t// register on arm64 (x15), and llvm might keep the value in that register\n\t// even through the register is marked as 'reserved' inside llvm.\n\tif (ctx->cfg->rgctx_var && ctx->cfg->rgctx_var->dreg == vreg)\n\t\tv = mono_llvm_build_load (ctx->builder, ctx->addresses [vreg], \"\", TRUE);\n\telse\n\t\tv = LLVMBuildLoad (ctx->builder, ctx->addresses [vreg], \"\");\n#else\n\tv = LLVMBuildLoad (ctx->builder, ctx->addresses [vreg], \"\");\n#endif\n\tt = ctx->vreg_cli_types [vreg];\n\tif (t && !t->byref) {\n\t\t/* \n\t\t * Might have to zero extend since llvm doesn't have \n\t\t * unsigned types.\n\t\t */\n\t\tif (t->type == MONO_TYPE_U1 || t->type == MONO_TYPE_U2 || t->type == MONO_TYPE_CHAR || t->type == MONO_TYPE_BOOLEAN)\n\t\t\tv = LLVMBuildZExt (ctx->builder, v, LLVMInt32Type (), \"\");\n\t\telse if (t->type == MONO_TYPE_I1 || t->type == MONO_TYPE_I2)\n\t\t\tv = LLVMBuildSExt (ctx->builder, v, LLVMInt32Type (), \"\");\n\t\telse if (t->type == MONO_TYPE_U8)\n\t\t\tv = LLVMBuildZExt (ctx->builder, v, LLVMInt64Type (), \"\");\n\t}\n\n\treturn v;\n}\n\n/*\n * emit_volatile_store:\n *\n *   If VREG is volatile, emit a store from its value to its address.\n */\nstatic void\nemit_volatile_store (EmitContext *ctx, int vreg)\n{\n\tMonoInst *var = get_vreg_to_inst (ctx->cfg, vreg);\n\n\tif (var && var->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT)) {\n\t\tg_assert (ctx->addresses [vreg]);\n\t\tLLVMBuildStore (ctx->builder, convert (ctx, ctx->values [vreg], type_to_llvm_type (ctx, var->inst_vtype)), ctx->addresses [vreg]);\n\t}\n}\n\nstatic LLVMTypeRef\nsig_to_llvm_sig_no_cinfo (EmitContext *ctx, MonoMethodSignature *sig)\n{\n\tLLVMTypeRef ret_type;\n\tLLVMTypeRef *param_types = NULL;\n\tLLVMTypeRef res;\n\tint i, pindex;\n\tMonoType *rtype;\n\n\tret_type = type_to_llvm_type (ctx, sig->ret);\n\tif (!ctx_ok (ctx))\n\t\treturn NULL;\n\trtype = mini_get_underlying_type (sig->ret);\n\n\tparam_types = g_new0 (LLVMTypeRef, (sig->param_count * 8) + 3);\n\tpindex = 0;\n\n\tif (sig->hasthis)\n\t\tparam_types [pindex ++] = ThisType ();\n\tfor (i = 0; i < sig->param_count; ++i)\n\t\tparam_types [pindex ++] = type_to_llvm_arg_type (ctx, sig->params [i]);\n\n\tif (!ctx_ok (ctx)) {\n\t\tg_free (param_types);\n\t\treturn NULL;\n\t}\n\n\tres = LLVMFunctionType (ret_type, param_types, pindex, FALSE);\n\tg_free (param_types);\n\n\treturn res;\n}\n\n/*\n * sig_to_llvm_sig_full:\n *\n *   Return the LLVM signature corresponding to the mono signature SIG using the\n * calling convention information in CINFO. Fill out the parameter mapping information in CINFO.\n */\nstatic LLVMTypeRef\nsig_to_llvm_sig_full (EmitContext *ctx, MonoMethodSignature *sig, LLVMCallInfo *cinfo)\n{\n\tLLVMTypeRef ret_type;\n\tLLVMTypeRef *param_types = NULL;\n\tLLVMTypeRef res;\n\tint i, j, pindex, vret_arg_pindex = 0;\n\tgboolean vretaddr = FALSE;\n\tMonoType *rtype;\n\n\tif (!cinfo)\n\t\treturn sig_to_llvm_sig_no_cinfo (ctx, sig);\n\n\tret_type = type_to_llvm_type (ctx, sig->ret);\n\tif (!ctx_ok (ctx))\n\t\treturn NULL;\n\trtype = mini_get_underlying_type (sig->ret);\n\n\tswitch (cinfo->ret.storage) {\n\tcase LLVMArgVtypeInReg:\n\t\t/* LLVM models this by returning an aggregate value */\n\t\tif (cinfo->ret.pair_storage [0] == LLVMArgInIReg && cinfo->ret.pair_storage [1] == LLVMArgNone) {\n\t\t\tLLVMTypeRef members [2];\n\n\t\t\tmembers [0] = IntPtrType ();\n\t\t\tret_type = LLVMStructType (members, 1, FALSE);\n\t\t} else if (cinfo->ret.pair_storage [0] == LLVMArgNone && cinfo->ret.pair_storage [1] == LLVMArgNone) {\n\t\t\t/* Empty struct */\n\t\t\tret_type = LLVMVoidType ();\n\t\t} else if (cinfo->ret.pair_storage [0] == LLVMArgInIReg && cinfo->ret.pair_storage [1] == LLVMArgInIReg) {\n\t\t\tLLVMTypeRef members [2];\n\n\t\t\tmembers [0] = IntPtrType ();\n\t\t\tmembers [1] = IntPtrType ();\n\t\t\tret_type = LLVMStructType (members, 2, FALSE);\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t\tbreak;\n\tcase LLVMArgVtypeByVal:\n\t\t/* Vtype returned normally by val */\n\t\tbreak;\n\tcase LLVMArgVtypeAsScalar: {\n\t\tint size = mono_class_value_size (mono_class_from_mono_type (rtype), NULL);\n\t\t/* LLVM models this by returning an int */\n\t\tif (size < SIZEOF_VOID_P) {\n\t\t\tg_assert (cinfo->ret.nslots == 1);\n\t\t\tret_type = LLVMIntType (size * 8);\n\t\t} else {\n\t\t\tg_assert (cinfo->ret.nslots == 1 || cinfo->ret.nslots == 2);\n\t\t\tret_type = LLVMIntType (cinfo->ret.nslots * sizeof (mgreg_t) * 8);\n\t\t}\n\t\tbreak;\n\t}\n\tcase LLVMArgAsIArgs:\n\t\tret_type = LLVMArrayType (IntPtrType (), cinfo->ret.nslots);\n\t\tbreak;\n\tcase LLVMArgFpStruct: {\n\t\t/* Vtype returned as a fp struct */\n\t\tLLVMTypeRef members [16];\n\n\t\t/* Have to create our own structure since we don't map fp structures to LLVM fp structures yet */\n\t\tfor (i = 0; i < cinfo->ret.nslots; ++i)\n\t\t\tmembers [i] = cinfo->ret.esize == 8 ? LLVMDoubleType () : LLVMFloatType ();\n\t\tret_type = LLVMStructType (members, cinfo->ret.nslots, FALSE);\n\t\tbreak;\n\t}\n\tcase LLVMArgVtypeByRef:\n\t\t/* Vtype returned using a hidden argument */\n\t\tret_type = LLVMVoidType ();\n\t\tbreak;\n\tcase LLVMArgVtypeRetAddr:\n\tcase LLVMArgGsharedvtFixed:\n\tcase LLVMArgGsharedvtFixedVtype:\n\tcase LLVMArgGsharedvtVariable:\n\t\tvretaddr = TRUE;\n\t\tret_type = LLVMVoidType ();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tparam_types = g_new0 (LLVMTypeRef, (sig->param_count * 8) + 3);\n\tpindex = 0;\n\tif (cinfo->ret.storage == LLVMArgVtypeByRef) {\n\t\t/*\n\t\t * Has to be the first argument because of the sret argument attribute\n\t\t * FIXME: This might conflict with passing 'this' as the first argument, but\n\t\t * this is only used on arm64 which has a dedicated struct return register.\n\t\t */\n\t\tcinfo->vret_arg_pindex = pindex;\n\t\tparam_types [pindex] = type_to_llvm_arg_type (ctx, sig->ret);\n\t\tif (!ctx_ok (ctx)) {\n\t\t\tg_free (param_types);\n\t\t\treturn NULL;\n\t\t}\n\t\tparam_types [pindex] = LLVMPointerType (param_types [pindex], 0);\n\t\tpindex ++;\n\t}\n\tif (!ctx->llvm_only && cinfo->rgctx_arg) {\n\t\tcinfo->rgctx_arg_pindex = pindex;\n\t\tparam_types [pindex] = ctx->module->ptr_type;\n\t\tpindex ++;\n\t}\n\tif (cinfo->imt_arg) {\n\t\tcinfo->imt_arg_pindex = pindex;\n\t\tparam_types [pindex] = ctx->module->ptr_type;\n\t\tpindex ++;\n\t}\n\tif (vretaddr) {\n\t\t/* Compute the index in the LLVM signature where the vret arg needs to be passed */\n\t\tvret_arg_pindex = pindex;\n\t\tif (cinfo->vret_arg_index == 1) {\n\t\t\t/* Add the slots consumed by the first argument */\n\t\t\tLLVMArgInfo *ainfo = &cinfo->args [0];\n\t\t\tswitch (ainfo->storage) {\n\t\t\tcase LLVMArgVtypeInReg:\n\t\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\t\tif (ainfo->pair_storage [j] == LLVMArgInIReg)\n\t\t\t\t\t\tvret_arg_pindex ++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvret_arg_pindex ++;\n\t\t\t}\n\t\t}\n\n\t\tcinfo->vret_arg_pindex = vret_arg_pindex;\n\t}\t\t\t\t\n\n\tif (vretaddr && vret_arg_pindex == pindex)\n\t\tparam_types [pindex ++] = IntPtrType ();\n\tif (sig->hasthis) {\n\t\tcinfo->this_arg_pindex = pindex;\n\t\tparam_types [pindex ++] = ThisType ();\n\t\tcinfo->args [0].pindex = cinfo->this_arg_pindex;\n\t}\n\tif (vretaddr && vret_arg_pindex == pindex)\n\t\tparam_types [pindex ++] = IntPtrType ();\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tLLVMArgInfo *ainfo = &cinfo->args [i + sig->hasthis];\n\n\t\tif (vretaddr && vret_arg_pindex == pindex)\n\t\t\tparam_types [pindex ++] = IntPtrType ();\n\t\tainfo->pindex = pindex;\n\n\t\tswitch (ainfo->storage) {\n\t\tcase LLVMArgVtypeInReg:\n\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\tswitch (ainfo->pair_storage [j]) {\n\t\t\t\tcase LLVMArgInIReg:\n\t\t\t\t\tparam_types [pindex ++] = LLVMIntType (sizeof (gpointer) * 8);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLVMArgNone:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LLVMArgVtypeByVal:\n\t\t\tparam_types [pindex] = type_to_llvm_arg_type (ctx, ainfo->type);\n\t\t\tif (!ctx_ok (ctx))\n\t\t\t\tbreak;\n\t\t\tparam_types [pindex] = LLVMPointerType (param_types [pindex], 0);\n\t\t\tpindex ++;\n\t\t\tbreak;\n\t\tcase LLVMArgAsIArgs:\n\t\t\tif (ainfo->esize == 8)\n\t\t\t\tparam_types [pindex] = LLVMArrayType (LLVMInt64Type (), ainfo->nslots);\n\t\t\telse\n\t\t\t\tparam_types [pindex] = LLVMArrayType (IntPtrType (), ainfo->nslots);\n\t\t\tpindex ++;\n\t\t\tbreak;\n\t\tcase LLVMArgVtypeByRef:\n\t\t\tparam_types [pindex] = type_to_llvm_arg_type (ctx, ainfo->type);\n\t\t\tif (!ctx_ok (ctx))\n\t\t\t\tbreak;\n\t\t\tparam_types [pindex] = LLVMPointerType (param_types [pindex], 0);\n\t\t\tpindex ++;\n\t\t\tbreak;\n\t\tcase LLVMArgAsFpArgs: {\n\t\t\tint j;\n\n\t\t\t/* Emit dummy fp arguments if needed so the rest is passed on the stack */\n\t\t\tfor (j = 0; j < ainfo->ndummy_fpargs; ++j)\n\t\t\t\tparam_types [pindex ++] = LLVMDoubleType ();\n\t\t\tfor (j = 0; j < ainfo->nslots; ++j)\n\t\t\t\tparam_types [pindex ++] = ainfo->esize == 8 ? LLVMDoubleType () : LLVMFloatType ();\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgVtypeAsScalar:\n\t\t\tg_assert_not_reached ();\n\t\t\tbreak;\n\t\tcase LLVMArgGsharedvtFixed:\n\t\tcase LLVMArgGsharedvtFixedVtype:\n\t\t\tparam_types [pindex ++] = LLVMPointerType (type_to_llvm_arg_type (ctx, ainfo->type), 0);\n\t\t\tbreak;\n\t\tcase LLVMArgGsharedvtVariable:\n\t\t\tparam_types [pindex ++] = LLVMPointerType (IntPtrType (), 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparam_types [pindex ++] = type_to_llvm_arg_type (ctx, ainfo->type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!ctx_ok (ctx)) {\n\t\tg_free (param_types);\n\t\treturn NULL;\n\t}\n\tif (vretaddr && vret_arg_pindex == pindex)\n\t\tparam_types [pindex ++] = IntPtrType ();\n\tif (ctx->llvm_only && cinfo->rgctx_arg) {\n\t\t/* Pass the rgctx as the last argument */\n\t\tcinfo->rgctx_arg_pindex = pindex;\n\t\tparam_types [pindex] = ctx->module->ptr_type;\n\t\tpindex ++;\n\t}\n\n\tres = LLVMFunctionType (ret_type, param_types, pindex, FALSE);\n\tg_free (param_types);\n\n\treturn res;\n}\n\nstatic LLVMTypeRef\nsig_to_llvm_sig (EmitContext *ctx, MonoMethodSignature *sig)\n{\n\treturn sig_to_llvm_sig_full (ctx, sig, NULL);\n}\n\n/*\n * LLVMFunctionType1:\n *\n *   Create an LLVM function type from the arguments.\n */\nstatic G_GNUC_UNUSED LLVMTypeRef\nLLVMFunctionType0 (LLVMTypeRef ReturnType,\n\t\t\t\t   int IsVarArg)\n{\n\treturn LLVMFunctionType (ReturnType, NULL, 0, IsVarArg);\n}\n\n/*\n * LLVMFunctionType1:\n *\n *   Create an LLVM function type from the arguments.\n */\nstatic G_GNUC_UNUSED LLVMTypeRef \nLLVMFunctionType1 (LLVMTypeRef ReturnType,\n\t\t\t\t   LLVMTypeRef ParamType1,\n\t\t\t\t   int IsVarArg)\n{\n\tLLVMTypeRef param_types [1];\n\n\tparam_types [0] = ParamType1;\n\n\treturn LLVMFunctionType (ReturnType, param_types, 1, IsVarArg);\n}\n\n/*\n * LLVMFunctionType2:\n *\n *   Create an LLVM function type from the arguments.\n */\nstatic G_GNUC_UNUSED LLVMTypeRef\nLLVMFunctionType2 (LLVMTypeRef ReturnType,\n\t\t\t\t   LLVMTypeRef ParamType1,\n\t\t\t\t   LLVMTypeRef ParamType2,\n\t\t\t\t   int IsVarArg)\n{\n\tLLVMTypeRef param_types [2];\n\n\tparam_types [0] = ParamType1;\n\tparam_types [1] = ParamType2;\n\n\treturn LLVMFunctionType (ReturnType, param_types, 2, IsVarArg);\n}\n\n/*\n * LLVMFunctionType3:\n *\n *   Create an LLVM function type from the arguments.\n */\nstatic G_GNUC_UNUSED LLVMTypeRef\nLLVMFunctionType3 (LLVMTypeRef ReturnType,\n\t\t\t\t   LLVMTypeRef ParamType1,\n\t\t\t\t   LLVMTypeRef ParamType2,\n\t\t\t\t   LLVMTypeRef ParamType3,\n\t\t\t\t   int IsVarArg)\n{\n\tLLVMTypeRef param_types [3];\n\n\tparam_types [0] = ParamType1;\n\tparam_types [1] = ParamType2;\n\tparam_types [2] = ParamType3;\n\n\treturn LLVMFunctionType (ReturnType, param_types, 3, IsVarArg);\n}\n\nstatic G_GNUC_UNUSED LLVMTypeRef\nLLVMFunctionType5 (LLVMTypeRef ReturnType,\n\t\t\t\t   LLVMTypeRef ParamType1,\n\t\t\t\t   LLVMTypeRef ParamType2,\n\t\t\t\t   LLVMTypeRef ParamType3,\n\t\t\t\t   LLVMTypeRef ParamType4,\n\t\t\t\t   LLVMTypeRef ParamType5,\n\t\t\t\t   int IsVarArg)\n{\n\tLLVMTypeRef param_types [5];\n\n\tparam_types [0] = ParamType1;\n\tparam_types [1] = ParamType2;\n\tparam_types [2] = ParamType3;\n\tparam_types [3] = ParamType4;\n\tparam_types [4] = ParamType5;\n\n\treturn LLVMFunctionType (ReturnType, param_types, 5, IsVarArg);\n}\n\n/*\n * create_builder:\n *\n *   Create an LLVM builder and remember it so it can be freed later.\n */\nstatic LLVMBuilderRef\ncreate_builder (EmitContext *ctx)\n{\n\tLLVMBuilderRef builder = LLVMCreateBuilder ();\n\n\tctx->builders = g_slist_prepend_mempool (ctx->cfg->mempool, ctx->builders, builder);\n\n\treturn builder;\n}\n\nstatic char*\nget_aotconst_name (MonoJumpInfoType type, gconstpointer data, int got_offset)\n{\n\tchar *name;\n\n\tswitch (type) {\n\tcase MONO_PATCH_INFO_INTERNAL_METHOD:\n\t\tname = g_strdup_printf (\"jit_icall_%s\", data);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_RGCTX_SLOT_INDEX: {\n\t\tMonoJumpInfoRgctxEntry *entry = (MonoJumpInfoRgctxEntry*)data;\n\t\tname = g_strdup_printf (\"RGCTX_SLOT_INDEX_%s\", mono_rgctx_info_type_to_str (entry->info_type));\n\t\tbreak;\n\t}\n\tdefault:\n\t\tname = g_strdup_printf (\"%s_%d\", mono_ji_type_to_string (type), got_offset);\n\t\tbreak;\n\t}\n\n\treturn name;\n}\n\nstatic LLVMValueRef\nget_aotconst_typed (EmitContext *ctx, MonoJumpInfoType type, gconstpointer data, LLVMTypeRef llvm_type)\n{\n\tMonoCompile *cfg;\n\tguint32 got_offset;\n\tLLVMValueRef indexes [2];\n\tLLVMValueRef got_entry_addr, load;\n\tLLVMBuilderRef builder = ctx->builder;\n\tchar *name = NULL;\n\n\tcfg = ctx->cfg;\n\n\tMonoJumpInfo tmp_ji;\n\ttmp_ji.type = type;\n\ttmp_ji.data.target = data;\n\n\tMonoJumpInfo *ji = mono_aot_patch_info_dup (&tmp_ji);\n\n\tji->next = cfg->patch_info;\n\tcfg->patch_info = ji;\n\n\tgot_offset = mono_aot_get_got_offset (cfg->patch_info);\n\tctx->module->max_got_offset = MAX (ctx->module->max_got_offset, got_offset);\n\t/* \n\t * If the got slot is shared, it means its initialized when the aot image is loaded, so we don't need to\n\t * explicitly initialize it.\n\t */\n\tif (!mono_aot_is_shared_got_offset (got_offset)) {\n\t\t//mono_print_ji (ji);\n\t\t//printf (\"\\n\");\n\t\tctx->has_got_access = TRUE;\n\t}\n\n\tindexes [0] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\tindexes [1] = LLVMConstInt (LLVMInt32Type (), (gssize)got_offset, FALSE);\n\tgot_entry_addr = LLVMBuildGEP (builder, ctx->module->got_var, indexes, 2, \"\");\n\n\tname = get_aotconst_name (type, data, got_offset);\n\tif (llvm_type) {\n\t\tload = LLVMBuildLoad (builder, got_entry_addr, \"\");\n\t\tload = convert (ctx, load, llvm_type);\n\t\tLLVMSetValueName (load, name ? name : \"\");\n\t} else {\n\t\tload = LLVMBuildLoad (builder, got_entry_addr, name ? name : \"\");\n\t}\n\tg_free (name);\n\t//set_invariant_load_flag (load);\n\n\treturn load;\n}\n\nstatic LLVMValueRef\nget_aotconst (EmitContext *ctx, MonoJumpInfoType type, gconstpointer data)\n{\n\treturn get_aotconst_typed (ctx, type, data, NULL);\n}\n\nstatic LLVMValueRef\nget_callee (EmitContext *ctx, LLVMTypeRef llvm_sig, MonoJumpInfoType type, gconstpointer data)\n{\n\tLLVMValueRef callee;\n\tchar *callee_name;\n\tif (ctx->llvm_only) {\n\t\tcallee_name = mono_aot_get_direct_call_symbol (type, data);\n\t\tif (callee_name) {\n\t\t\t/* Directly callable */\n\t\t\t// FIXME: Locking\n\t\t\tcallee = (LLVMValueRef)g_hash_table_lookup (ctx->module->direct_callables, callee_name);\n\t\t\tif (!callee) {\n\t\t\t\tcallee = LLVMAddFunction (ctx->lmodule, callee_name, llvm_sig);\n\n\t\t\t\tLLVMSetVisibility (callee, LLVMHiddenVisibility);\n\n\t\t\t\tg_hash_table_insert (ctx->module->direct_callables, (char*)callee_name, callee);\n\t\t\t} else {\n\t\t\t\t/* LLVMTypeRef's are uniqued */\n\t\t\t\tif (LLVMGetElementType (LLVMTypeOf (callee)) != llvm_sig)\n\t\t\t\t\treturn LLVMConstBitCast (callee, LLVMPointerType (llvm_sig, 0));\n\n\t\t\t\tg_free (callee_name);\n\t\t\t}\n\t\t\treturn callee;\n\t\t}\n\n\t\t/*\n\t\t * Calls are made through the GOT.\n\t\t */\n\t\treturn get_aotconst_typed (ctx, type, data, LLVMPointerType (llvm_sig, 0));\n\t} else {\n\t\tMonoJumpInfo *ji = NULL;\n\n\t\tcallee_name = mono_aot_get_plt_symbol (type, data);\n\t\tif (!callee_name)\n\t\t\treturn NULL;\n\n\t\tif (ctx->cfg->compile_aot)\n\t\t\t/* Add a patch so referenced wrappers can be compiled in full aot mode */\n\t\t\tmono_add_patch_info (ctx->cfg, 0, type, data);\n\n\t\t// FIXME: Locking\n\t\tcallee = (LLVMValueRef)g_hash_table_lookup (ctx->module->plt_entries, callee_name);\n\t\tif (!callee) {\n\t\t\tcallee = LLVMAddFunction (ctx->lmodule, callee_name, llvm_sig);\n\n\t\t\tLLVMSetVisibility (callee, LLVMHiddenVisibility);\n\n\t\t\tg_hash_table_insert (ctx->module->plt_entries, (char*)callee_name, callee);\n\t\t}\n\n\t\tif (ctx->cfg->compile_aot) {\n\t\t\tji = g_new0 (MonoJumpInfo, 1);\n\t\t\tji->type = type;\n\t\t\tji->data.target = data;\n\n\t\t\tg_hash_table_insert (ctx->module->plt_entries_ji, ji, callee);\n\t\t}\n\n\t\treturn callee;\n\t}\n}\n\nstatic LLVMValueRef\nemit_jit_callee (EmitContext *ctx, const char *name, LLVMTypeRef llvm_sig, gpointer target)\n{\n#if LLVM_API_VERSION > 100\n\tLLVMValueRef tramp_var = LLVMAddGlobal (ctx->lmodule, LLVMPointerType (llvm_sig, 0), name);\n\tLLVMSetInitializer (tramp_var, LLVMConstIntToPtr (LLVMConstInt (LLVMInt64Type (), (guint64)(size_t)target, FALSE), LLVMPointerType (llvm_sig, 0)));\n\tLLVMSetLinkage (tramp_var, LLVMExternalLinkage);\n\tLLVMValueRef callee = LLVMBuildLoad (ctx->builder, tramp_var, \"\");\n\treturn callee;\n#else\n\tLLVMValueRef callee = LLVMAddFunction (ctx->lmodule, \"\", llvm_sig);\n\tLLVMAddGlobalMapping (ctx->module->ee, callee, target);\n\treturn callee;\n#endif\n}\n\nstatic int\nget_handler_clause (MonoCompile *cfg, MonoBasicBlock *bb)\n{\n\tMonoMethodHeader *header = cfg->header;\n\tMonoExceptionClause *clause;\n\tint i;\n\n\t/* Directly */\n\tif (bb->region != -1 && MONO_BBLOCK_IS_IN_REGION (bb, MONO_REGION_TRY))\n\t\treturn (bb->region >> 8) - 1;\n\n\t/* Indirectly */\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\t\t   \n\t\tif (MONO_OFFSET_IN_CLAUSE (clause, bb->real_offset) && clause->flags == MONO_EXCEPTION_CLAUSE_NONE)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nstatic MonoExceptionClause *\nget_most_deep_clause (MonoCompile *cfg, EmitContext *ctx, MonoBasicBlock *bb)\n{\n\tif (bb == cfg->bb_init)\n\t\treturn NULL;\n\t// Since they're sorted by nesting we just need\n\t// the first one that the bb is a member of\n\tfor (int i = 0; i < cfg->header->num_clauses; i++) {\n\t\tMonoExceptionClause *curr = &cfg->header->clauses [i];\n\n\t\tif (MONO_OFFSET_IN_CLAUSE (curr, bb->real_offset))\n\t\t\treturn curr;\n\t}\n\n\treturn NULL;\n}\n\t\nstatic void\nset_metadata_flag (LLVMValueRef v, const char *flag_name)\n{\n\tLLVMValueRef md_arg;\n\tint md_kind;\n\n\tmd_kind = LLVMGetMDKindID (flag_name, strlen (flag_name));\n\tmd_arg = LLVMMDString (\"mono\", 4);\n\tLLVMSetMetadata (v, md_kind, LLVMMDNode (&md_arg, 1));\n}\n\nstatic void\nset_invariant_load_flag (LLVMValueRef v)\n{\n\tLLVMValueRef md_arg;\n\tint md_kind;\n\tconst char *flag_name;\n\n\t// FIXME: Cache this\n\tflag_name = \"invariant.load\";\n\tmd_kind = LLVMGetMDKindID (flag_name, strlen (flag_name));\n\tmd_arg = LLVMMDString (\"<index>\", strlen (\"<index>\"));\n\tLLVMSetMetadata (v, md_kind, LLVMMDNode (&md_arg, 1));\n}\n\n/*\n * emit_call:\n *\n *   Emit an LLVM call or invoke instruction depending on whenever the call is inside\n * a try region.\n */\nstatic LLVMValueRef\nemit_call (EmitContext *ctx, MonoBasicBlock *bb, LLVMBuilderRef *builder_ref, LLVMValueRef callee, LLVMValueRef *args, int pindex)\n{\n\tMonoCompile *cfg = ctx->cfg;\n\tLLVMValueRef lcall = NULL;\n\tLLVMBuilderRef builder = *builder_ref;\n\tMonoExceptionClause *clause;\n\n\tif (ctx->llvm_only) {\n\t\tclause = get_most_deep_clause (cfg, ctx, bb);\n\n\t\tif (clause) {\n\t\t\tg_assert (clause->flags == MONO_EXCEPTION_CLAUSE_NONE || clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY || clause->flags == MONO_EXCEPTION_CLAUSE_FAULT);\n\n\t\t\t/*\n\t\t\t * Have to use an invoke instead of a call, branching to the\n\t\t\t * handler bblock of the clause containing this bblock.\n\t\t\t */\n\t\t\tintptr_t key = CLAUSE_END(clause);\n\n\t\t\tLLVMBasicBlockRef lpad_bb = (LLVMBasicBlockRef)g_hash_table_lookup (ctx->exc_meta, (gconstpointer)key);\n\n\t\t\t// FIXME: Find the one that has the lowest end bound for the right start address\n\t\t\t// FIXME: Finally + nesting\n\n\t\t\tif (lpad_bb) {\n\t\t\t\tLLVMBasicBlockRef noex_bb = gen_bb (ctx, \"CALL_NOEX_BB\");\n\n\t\t\t\t/* Use an invoke */\n\t\t\t\tlcall = LLVMBuildInvoke (builder, callee, args, pindex, noex_bb, lpad_bb, \"\");\n\n\t\t\t\tbuilder = ctx->builder = create_builder (ctx);\n\t\t\t\tLLVMPositionBuilderAtEnd (ctx->builder, noex_bb);\n\n\t\t\t\tctx->bblocks [bb->block_num].end_bblock = noex_bb;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint clause_index = get_handler_clause (cfg, bb);\n\n\t\tif (clause_index != -1) {\n\t\t\tMonoMethodHeader *header = cfg->header;\n\t\t\tMonoExceptionClause *ec = &header->clauses [clause_index];\n\t\t\tMonoBasicBlock *tblock;\n\t\t\tLLVMBasicBlockRef ex_bb, noex_bb;\n\n\t\t\t/*\n\t\t\t * Have to use an invoke instead of a call, branching to the\n\t\t\t * handler bblock of the clause containing this bblock.\n\t\t\t */\n\n\t\t\tg_assert (ec->flags == MONO_EXCEPTION_CLAUSE_NONE || ec->flags == MONO_EXCEPTION_CLAUSE_FINALLY || ec->flags == MONO_EXCEPTION_CLAUSE_FAULT);\n\n\t\t\ttblock = cfg->cil_offset_to_bb [ec->handler_offset];\n\t\t\tg_assert (tblock);\n\n\t\t\tctx->bblocks [tblock->block_num].invoke_target = TRUE;\n\n\t\t\tex_bb = get_bb (ctx, tblock);\n\n\t\t\tnoex_bb = gen_bb (ctx, \"NOEX_BB\");\n\n\t\t\t/* Use an invoke */\n\t\t\tlcall = LLVMBuildInvoke (builder, callee, args, pindex, noex_bb, ex_bb, \"\");\n\n\t\t\tbuilder = ctx->builder = create_builder (ctx);\n\t\t\tLLVMPositionBuilderAtEnd (ctx->builder, noex_bb);\n\n\t\t\tctx->bblocks [bb->block_num].end_bblock = noex_bb;\n\t\t}\n\t}\n\t\n\tif (!lcall) {\n\t\tlcall = LLVMBuildCall (builder, callee, args, pindex, \"\");\n\t\tctx->builder = builder;\n\t}\n\n\tif (builder_ref)\n\t\t*builder_ref = ctx->builder;\n\n\treturn lcall;\n}\n\nstatic LLVMValueRef\nemit_load_general (EmitContext *ctx, MonoBasicBlock *bb, LLVMBuilderRef *builder_ref, int size, LLVMValueRef addr, LLVMValueRef base, const char *name, gboolean is_faulting, BarrierKind barrier)\n{\n\tconst char *intrins_name;\n\tLLVMValueRef args [16], res;\n\tLLVMTypeRef addr_type;\n\tgboolean use_intrinsics = TRUE;\n\n#if LLVM_API_VERSION > 100\n\tif (is_faulting && bb->region != -1 && !ctx->cfg->llvm_only) {\n\t\t/* The llvm.mono.load/store intrinsics are not supported by this llvm version, emit an explicit null check instead */\n\t\tLLVMValueRef cmp;\n\n\t\tcmp = LLVMBuildICmp (*builder_ref, LLVMIntEQ, base, LLVMConstNull (LLVMTypeOf (base)), \"\");\n\t\temit_cond_system_exception (ctx, bb, \"NullReferenceException\", cmp);\n\t\t*builder_ref = ctx->builder;\n\t\tuse_intrinsics = FALSE;\n\t}\n#endif\n\n\tif (is_faulting && bb->region != -1 && !ctx->cfg->llvm_only && use_intrinsics) {\n\t\tLLVMAtomicOrdering ordering;\n\n\t\tswitch (barrier) {\n\t\tcase LLVM_BARRIER_NONE:\n\t\t\tordering = LLVMAtomicOrderingNotAtomic;\n\t\t\tbreak;\n\t\tcase LLVM_BARRIER_ACQ:\n\t\t\tordering = LLVMAtomicOrderingAcquire;\n\t\t\tbreak;\n\t\tcase LLVM_BARRIER_SEQ:\n\t\t\tordering = LLVMAtomicOrderingSequentiallyConsistent;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We handle loads which can fault by calling a mono specific intrinsic\n\t\t * using an invoke, so they are handled properly inside try blocks.\n\t\t * We can't use this outside clauses, since LLVM optimizes intrinsics which\n\t\t * are marked with IntrReadArgMem.\n\t\t */\n\t\tswitch (size) {\n\t\tcase 1:\n\t\t\tintrins_name = \"llvm.mono.load.i8.p0i8\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tintrins_name = \"llvm.mono.load.i16.p0i16\";\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tintrins_name = \"llvm.mono.load.i32.p0i32\";\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tintrins_name = \"llvm.mono.load.i64.p0i64\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\taddr_type = LLVMTypeOf (addr);\n\t\tif (addr_type == LLVMPointerType (LLVMDoubleType (), 0) || addr_type == LLVMPointerType (LLVMFloatType (), 0))\n\t\t\taddr = LLVMBuildBitCast (*builder_ref, addr, LLVMPointerType (LLVMIntType (size * 8), 0), \"\");\n\n\t\targs [0] = addr;\n\t\targs [1] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t\targs [2] = LLVMConstInt (LLVMInt1Type (), TRUE, FALSE);\n\t\targs [3] = LLVMConstInt (LLVMInt32Type (), ordering, FALSE);\n\t\tres = emit_call (ctx, bb, builder_ref, get_intrinsic (ctx, intrins_name), args, 4);\n\n\t\tif (addr_type == LLVMPointerType (LLVMDoubleType (), 0))\n\t\t\tres = LLVMBuildBitCast (*builder_ref, res, LLVMDoubleType (), \"\");\n\t\telse if (addr_type == LLVMPointerType (LLVMFloatType (), 0))\n\t\t\tres = LLVMBuildBitCast (*builder_ref, res, LLVMFloatType (), \"\");\n\t\t\n\t\treturn res;\n\t} else {\n\t\tLLVMValueRef res;\n\n\t\t/* \n\t\t * We emit volatile loads for loads which can fault, because otherwise\n\t\t * LLVM will generate invalid code when encountering a load from a\n\t\t * NULL address.\n\t\t */\n\t\tif (barrier != LLVM_BARRIER_NONE)\n\t\t\tres = mono_llvm_build_atomic_load (*builder_ref, addr, name, is_faulting, size, barrier);\n\t\telse\n\t\t\tres = mono_llvm_build_load (*builder_ref, addr, name, is_faulting);\n\n\t\t/* Mark it with a custom metadata */\n\t\t/*\n\t\t  if (is_faulting)\n\t\t  set_metadata_flag (res, \"mono.faulting.load\");\n\t\t*/\n\n\t\treturn res;\n\t}\n}\n\nstatic LLVMValueRef\nemit_load (EmitContext *ctx, MonoBasicBlock *bb, LLVMBuilderRef *builder_ref, int size, LLVMValueRef addr, const char *name, gboolean is_faulting)\n{\n\treturn emit_load_general (ctx, bb, builder_ref, size, addr, addr, name, is_faulting, LLVM_BARRIER_NONE);\n}\n\nstatic void\nemit_store_general (EmitContext *ctx, MonoBasicBlock *bb, LLVMBuilderRef *builder_ref, int size, LLVMValueRef value, LLVMValueRef addr, LLVMValueRef base, gboolean is_faulting, BarrierKind barrier)\n{\n\tconst char *intrins_name;\n\tLLVMValueRef args [16];\n\tgboolean use_intrinsics = TRUE;\n\n#if LLVM_API_VERSION > 100\n\tif (is_faulting && bb->region != -1 && !ctx->cfg->llvm_only) {\n\t\t/* The llvm.mono.load/store intrinsics are not supported by this llvm version, emit an explicit null check instead */\n\t\tLLVMValueRef cmp = LLVMBuildICmp (*builder_ref, LLVMIntEQ, base, LLVMConstNull (LLVMTypeOf (base)), \"\");\n\t\temit_cond_system_exception (ctx, bb, \"NullReferenceException\", cmp);\n\t\t*builder_ref = ctx->builder;\n\t\tuse_intrinsics = FALSE;\n\t}\n#endif\n\n\tif (is_faulting && bb->region != -1 && !ctx->cfg->llvm_only && use_intrinsics) {\n\t\tLLVMAtomicOrdering ordering;\n\n\t\tswitch (barrier) {\n\t\tcase LLVM_BARRIER_NONE:\n\t\t\tordering = LLVMAtomicOrderingNotAtomic;\n\t\t\tbreak;\n\t\tcase LLVM_BARRIER_REL:\n\t\t\tordering = LLVMAtomicOrderingRelease;\n\t\t\tbreak;\n\t\tcase LLVM_BARRIER_SEQ:\n\t\t\tordering = LLVMAtomicOrderingSequentiallyConsistent;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (size) {\n\t\tcase 1:\n\t\t\tintrins_name = \"llvm.mono.store.i8.p0i8\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tintrins_name = \"llvm.mono.store.i16.p0i16\";\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tintrins_name = \"llvm.mono.store.i32.p0i32\";\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tintrins_name = \"llvm.mono.store.i64.p0i64\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tif (LLVMTypeOf (value) == LLVMDoubleType () || LLVMTypeOf (value) == LLVMFloatType ()) {\n\t\t\tvalue = LLVMBuildBitCast (*builder_ref, value, LLVMIntType (size * 8), \"\");\n\t\t\taddr = LLVMBuildBitCast (*builder_ref, addr, LLVMPointerType (LLVMIntType (size * 8), 0), \"\");\n\t\t}\n\n\t\targs [0] = value;\n\t\targs [1] = addr;\n\t\targs [2] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t\targs [3] = LLVMConstInt (LLVMInt1Type (), TRUE, FALSE);\n\t\targs [4] = LLVMConstInt (LLVMInt32Type (), ordering, FALSE);\n\t\temit_call (ctx, bb, builder_ref, get_intrinsic (ctx, intrins_name), args, 5);\n\t} else {\n\t\tif (barrier != LLVM_BARRIER_NONE)\n\t\t\tmono_llvm_build_aligned_store (*builder_ref, value, addr, barrier, size);\n\t\telse\n\t\t\tmono_llvm_build_store (*builder_ref, value, addr, is_faulting, barrier);\n\t}\n}\n\nstatic void\nemit_store (EmitContext *ctx, MonoBasicBlock *bb, LLVMBuilderRef *builder_ref, int size, LLVMValueRef value, LLVMValueRef addr, LLVMValueRef base, gboolean is_faulting)\n{\n\temit_store_general (ctx, bb, builder_ref, size, value, addr, base, is_faulting, LLVM_BARRIER_NONE);\n}\n\n/*\n * emit_cond_system_exception:\n *\n *   Emit code to throw the exception EXC_TYPE if the condition CMP is false.\n * Might set the ctx exception.\n */\nstatic void\nemit_cond_system_exception (EmitContext *ctx, MonoBasicBlock *bb, const char *exc_type, LLVMValueRef cmp)\n{\n\tLLVMBasicBlockRef ex_bb, ex2_bb = NULL, noex_bb;\n\tLLVMBuilderRef builder;\n\tMonoClass *exc_class;\n\tLLVMValueRef args [2];\n\tLLVMValueRef callee;\n\tgboolean no_pc = FALSE;\n\n\tif (IS_TARGET_AMD64)\n\t\t/* Some platforms don't require the pc argument */\n\t\tno_pc = TRUE;\n\t\n\tex_bb = gen_bb (ctx, \"EX_BB\");\n\tif (ctx->llvm_only)\n\t\tex2_bb = gen_bb (ctx, \"EX2_BB\");\n\tnoex_bb = gen_bb (ctx, \"NOEX_BB\");\n\n\tLLVMBuildCondBr (ctx->builder, cmp, ex_bb, noex_bb);\n\n\texc_class = mono_class_load_from_name (mono_get_corlib (), \"System\", exc_type);\n\n\t/* Emit exception throwing code */\n\tctx->builder = builder = create_builder (ctx);\n\tLLVMPositionBuilderAtEnd (builder, ex_bb);\n\n\tif (ctx->cfg->llvm_only) {\n\t\tstatic LLVMTypeRef sig;\n\n\t\tif (!sig)\n\t\t\tsig = LLVMFunctionType1 (LLVMVoidType (), LLVMInt32Type (), FALSE);\n\t\tcallee = get_callee (ctx, sig, MONO_PATCH_INFO_JIT_ICALL_ADDR, \"mono_llvm_throw_corlib_exception\");\n\n\t\tLLVMBuildBr (builder, ex2_bb);\n\n\t\tctx->builder = builder = create_builder (ctx);\n\t\tLLVMPositionBuilderAtEnd (ctx->builder, ex2_bb);\n\n\t\targs [0] = LLVMConstInt (LLVMInt32Type (), exc_class->type_token - MONO_TOKEN_TYPE_DEF, FALSE);\n\t\temit_call (ctx, bb, &builder, callee, args, 1);\n\t\tLLVMBuildUnreachable (builder);\n\n\t\tctx->builder = builder = create_builder (ctx);\n\t\tLLVMPositionBuilderAtEnd (ctx->builder, noex_bb);\n\n\t\tctx->bblocks [bb->block_num].end_bblock = noex_bb;\n\n\t\tctx->ex_index ++;\n\t\treturn;\n\t}\n\n\tcallee = ctx->module->throw_corlib_exception;\n\tif (!callee) {\n\t\tLLVMTypeRef sig;\n\t\tconst char *icall_name;\n\n\t\tif (no_pc)\n\t\t\tsig = LLVMFunctionType1 (LLVMVoidType (), LLVMInt32Type (), FALSE);\n\t\telse\n\t\t\tsig = LLVMFunctionType2 (LLVMVoidType (), LLVMInt32Type (), LLVMPointerType (LLVMInt8Type (), 0), FALSE);\n\t\ticall_name = \"llvm_throw_corlib_exception_abs_trampoline\";\n\n\t\tif (ctx->cfg->compile_aot) {\n\t\t\tcallee = get_callee (ctx, sig, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Differences between the LLVM/non-LLVM throw corlib exception trampoline:\n\t\t\t * - On x86, LLVM generated code doesn't push the arguments\n\t\t\t * - The trampoline takes the throw address as an arguments, not a pc offset.\n\t\t\t */\n\t\t\tgpointer target = resolve_patch (ctx->cfg, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name);\n\t\t\tcallee = emit_jit_callee (ctx, \"llvm_throw_corlib_exception_trampoline\", sig, target);\n\n#if LLVM_API_VERSION > 100\n\t\t\t/*\n\t\t\t * Make sure that ex_bb starts with the invoke, so the block address points to it, and not to the load \n\t\t\t * added by emit_jit_callee ().\n\t\t\t */\n\t\t\tex2_bb = gen_bb (ctx, \"EX2_BB\");\n\t\t\tLLVMBuildBr (builder, ex2_bb);\n\t\t\tex_bb = ex2_bb;\n\n\t\t\tctx->builder = builder = create_builder (ctx);\n\t\t\tLLVMPositionBuilderAtEnd (ctx->builder, ex2_bb);\n#else\n\t\t\tmono_memory_barrier ();\n\t\t\tctx->module->throw_corlib_exception = callee;\n#endif\n\t\t}\n\t}\n\n\targs [0] = LLVMConstInt (LLVMInt32Type (), exc_class->type_token - MONO_TOKEN_TYPE_DEF, FALSE);\n\n\t/*\n\t * The LLVM mono branch contains changes so a block address can be passed as an\n\t * argument to a call.\n\t */\n\tif (no_pc) {\n\t\temit_call (ctx, bb, &builder, callee, args, 1);\n\t} else {\n\t\targs [1] = LLVMBlockAddress (ctx->lmethod, ex_bb);\n\t\temit_call (ctx, bb, &builder, callee, args, 2);\n\t}\n\n\tLLVMBuildUnreachable (builder);\n\n\tctx->builder = builder = create_builder (ctx);\n\tLLVMPositionBuilderAtEnd (ctx->builder, noex_bb);\n\n\tctx->bblocks [bb->block_num].end_bblock = noex_bb;\n\n\tctx->ex_index ++;\n\treturn;\n}\n\n/*\n * emit_args_to_vtype:\n *\n *   Emit code to store the vtype in the arguments args to the address ADDRESS.\n */\nstatic void\nemit_args_to_vtype (EmitContext *ctx, LLVMBuilderRef builder, MonoType *t, LLVMValueRef address, LLVMArgInfo *ainfo, LLVMValueRef *args)\n{\n\tint j, size, nslots;\n\n\tsize = mono_class_value_size (mono_class_from_mono_type (t), NULL);\n\n\tif (MONO_CLASS_IS_SIMD (ctx->cfg, mono_class_from_mono_type (t))) {\n\t\taddress = LLVMBuildBitCast (ctx->builder, address, LLVMPointerType (LLVMInt8Type (), 0), \"\");\n\t}\n\n\tif (ainfo->storage == LLVMArgAsFpArgs)\n\t\tnslots = ainfo->nslots;\n\telse\n\t\tnslots = 2;\n\n\tfor (j = 0; j < nslots; ++j) {\n\t\tLLVMValueRef index [2], addr, daddr;\n\t\tint part_size = size > sizeof (gpointer) ? sizeof (gpointer) : size;\n\t\tLLVMTypeRef part_type;\n\n\t\twhile (part_size != 1 && part_size != 2 && part_size != 4 && part_size < 8)\n\t\t\tpart_size ++;\n\n\t\tif (ainfo->pair_storage [j] == LLVMArgNone)\n\t\t\tcontinue;\n\n\t\tswitch (ainfo->pair_storage [j]) {\n\t\tcase LLVMArgInIReg: {\n\t\t\tpart_type = LLVMIntType (part_size * 8);\n\t\t\tif (MONO_CLASS_IS_SIMD (ctx->cfg, mono_class_from_mono_type (t))) {\n\t\t\t\tindex [0] = LLVMConstInt (LLVMInt32Type (), j * sizeof (gpointer), FALSE);\n\t\t\t\taddr = LLVMBuildGEP (builder, address, index, 1, \"\");\n\t\t\t} else {\n\t\t\t\tdaddr = LLVMBuildBitCast (ctx->builder, address, LLVMPointerType (IntPtrType (), 0), \"\");\n\t\t\t\tindex [0] = LLVMConstInt (LLVMInt32Type (), j, FALSE);\n\t\t\t\taddr = LLVMBuildGEP (builder, daddr, index, 1, \"\");\n\t\t\t}\n\t\t\tLLVMBuildStore (builder, convert (ctx, args [j], part_type), LLVMBuildBitCast (ctx->builder, addr, LLVMPointerType (part_type, 0), \"\"));\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgInFPReg: {\n\t\t\tLLVMTypeRef arg_type;\n\n\t\t\tif (ainfo->esize == 8)\n\t\t\t\targ_type = LLVMDoubleType ();\n\t\t\telse\n\t\t\t\targ_type = LLVMFloatType ();\n\n\t\t\tindex [0] = LLVMConstInt (LLVMInt32Type (), j, FALSE);\n\t\t\tdaddr = LLVMBuildBitCast (ctx->builder, address, LLVMPointerType (arg_type, 0), \"\");\n\t\t\taddr = LLVMBuildGEP (builder, daddr, index, 1, \"\");\n\t\t\tLLVMBuildStore (builder, args [j], addr);\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgNone:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tsize -= sizeof (gpointer);\n\t}\n}\n\n/*\n * emit_vtype_to_args:\n *\n *   Emit code to load a vtype at address ADDRESS into scalar arguments. Store the arguments\n * into ARGS, and the number of arguments into NARGS.\n */\nstatic void\nemit_vtype_to_args (EmitContext *ctx, LLVMBuilderRef builder, MonoType *t, LLVMValueRef address, LLVMArgInfo *ainfo, LLVMValueRef *args, guint32 *nargs)\n{\n\tint pindex = 0;\n\tint j, size, nslots;\n\tLLVMTypeRef arg_type;\n\n\tsize = get_vtype_size (t);\n\n\tif (MONO_CLASS_IS_SIMD (ctx->cfg, mono_class_from_mono_type (t)))\n\t\taddress = LLVMBuildBitCast (ctx->builder, address, LLVMPointerType (LLVMInt8Type (), 0), \"\");\n\n\tif (ainfo->storage == LLVMArgAsFpArgs)\n\t\tnslots = ainfo->nslots;\n\telse\n\t\tnslots = 2;\n\tfor (j = 0; j < nslots; ++j) {\n\t\tLLVMValueRef index [2], addr, daddr;\n\t\tint partsize = size > sizeof (gpointer) ? sizeof (gpointer) : size;\n\n\t\tif (ainfo->pair_storage [j] == LLVMArgNone)\n\t\t\tcontinue;\n\n\t\tswitch (ainfo->pair_storage [j]) {\n\t\tcase LLVMArgInIReg:\n\t\t\tif (MONO_CLASS_IS_SIMD (ctx->cfg, mono_class_from_mono_type (t))) {\n\t\t\t\tindex [0] = LLVMConstInt (LLVMInt32Type (), j * sizeof (gpointer), FALSE);\n\t\t\t\taddr = LLVMBuildGEP (builder, address, index, 1, \"\");\n\t\t\t} else {\n\t\t\t\tdaddr = LLVMBuildBitCast (ctx->builder, address, LLVMPointerType (IntPtrType (), 0), \"\");\n\t\t\t\tindex [0] = LLVMConstInt (LLVMInt32Type (), j, FALSE);\n\t\t\t\taddr = LLVMBuildGEP (builder, daddr, index, 1, \"\");\n\t\t\t}\n\t\t\targs [pindex ++] = convert (ctx, LLVMBuildLoad (builder, LLVMBuildBitCast (ctx->builder, addr, LLVMPointerType (LLVMIntType (partsize * 8), 0), \"\"), \"\"), IntPtrType ());\n\t\t\tbreak;\n\t\tcase LLVMArgInFPReg:\n\t\t\tif (ainfo->esize == 8)\n\t\t\t\targ_type = LLVMDoubleType ();\n\t\t\telse\n\t\t\t\targ_type = LLVMFloatType ();\n\t\t\tdaddr = LLVMBuildBitCast (ctx->builder, address, LLVMPointerType (arg_type, 0), \"\");\n\t\t\tindex [0] = LLVMConstInt (LLVMInt32Type (), j, FALSE);\n\t\t\taddr = LLVMBuildGEP (builder, daddr, index, 1, \"\");\n\t\t\targs [pindex ++] = LLVMBuildLoad (builder, addr, \"\");\n\t\t\tbreak;\n\t\tcase LLVMArgNone:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t\tsize -= sizeof (gpointer);\n\t}\n\n\t*nargs = pindex;\n}\n\nstatic LLVMValueRef\nbuild_alloca_llvm_type_name (EmitContext *ctx, LLVMTypeRef t, int align, const char *name)\n{\n\t/*\n\t * Have to place all alloca's at the end of the entry bb, since otherwise they would\n\t * get executed every time control reaches them.\n\t */\n\tLLVMPositionBuilder (ctx->alloca_builder, get_bb (ctx, ctx->cfg->bb_entry), ctx->last_alloca);\n\n\tctx->last_alloca = mono_llvm_build_alloca (ctx->alloca_builder, t, NULL, align, name);\n\treturn ctx->last_alloca;\n}\n\nstatic LLVMValueRef\nbuild_alloca_llvm_type (EmitContext *ctx, LLVMTypeRef t, int align)\n{\n\treturn build_alloca_llvm_type_name (ctx, t, align, \"\");\n}\n\nstatic LLVMValueRef\nbuild_alloca (EmitContext *ctx, MonoType *t)\n{\n\tMonoClass *k = mono_class_from_mono_type (t);\n\tint align;\n\n\tg_assert (!mini_is_gsharedvt_variable_type (t));\n\n\tif (MONO_CLASS_IS_SIMD (ctx->cfg, k))\n\t\talign = 16;\n\telse\n\t\talign = mono_class_min_align (k);\n\n\t/* Sometimes align is not a power of 2 */\n\twhile (mono_is_power_of_two (align) == -1)\n\t\talign ++;\n\n\treturn build_alloca_llvm_type (ctx, type_to_llvm_type (ctx, t), align);\n}\n\nstatic LLVMValueRef\nemit_gsharedvt_ldaddr (EmitContext *ctx, int vreg)\n{\n\t/*\n\t * gsharedvt local.\n\t * Compute the address of the local as gsharedvt_locals_var + gsharedvt_info_var->locals_offsets [idx].\n\t */\n\tMonoCompile *cfg = ctx->cfg;\n\tLLVMBuilderRef builder = ctx->builder;\n\tLLVMValueRef offset, offset_var;\n\tLLVMValueRef info_var = ctx->values [cfg->gsharedvt_info_var->dreg];\n\tLLVMValueRef locals_var = ctx->values [cfg->gsharedvt_locals_var->dreg];\n\tLLVMValueRef ptr;\n\tchar *name;\n\n\tg_assert (info_var);\n\tg_assert (locals_var);\n\n\tint idx = cfg->gsharedvt_vreg_to_idx [vreg] - 1;\n\n\toffset = LLVMConstInt (LLVMInt32Type (), MONO_STRUCT_OFFSET (MonoGSharedVtMethodRuntimeInfo, entries) + (idx * sizeof (gpointer)), FALSE);\n\tptr = LLVMBuildAdd (builder, convert (ctx, info_var, IntPtrType ()), convert (ctx, offset, IntPtrType ()), \"\");\n\n\tname = g_strdup_printf (\"gsharedvt_local_%d_offset\", vreg);\n\toffset_var = LLVMBuildLoad (builder, convert (ctx, ptr, LLVMPointerType (LLVMInt32Type (), 0)), name);\n\n\treturn LLVMBuildAdd (builder, convert (ctx, locals_var, IntPtrType ()), convert (ctx, offset_var, IntPtrType ()), \"\");\n}\n\n/*\n * Put the global into the 'llvm.used' array to prevent it from being optimized away.\n */\nstatic void\nmark_as_used (MonoLLVMModule *module, LLVMValueRef global)\n{\n\tif (!module->used)\n\t\tmodule->used = g_ptr_array_sized_new (16);\n\tg_ptr_array_add (module->used, global);\n}\n\nstatic void\nemit_llvm_used (MonoLLVMModule *module)\n{\n\tLLVMModuleRef lmodule = module->lmodule;\n\tLLVMTypeRef used_type;\n\tLLVMValueRef used, *used_elem;\n\tint i;\n\t\t\n\tif (!module->used)\n\t\treturn;\n\n\tused_type = LLVMArrayType (LLVMPointerType (LLVMInt8Type (), 0), module->used->len);\n\tused = LLVMAddGlobal (lmodule, used_type, \"llvm.used\");\n\tused_elem = g_new0 (LLVMValueRef, module->used->len);\n\tfor (i = 0; i < module->used->len; ++i)\n\t\tused_elem [i] = LLVMConstBitCast ((LLVMValueRef)g_ptr_array_index (module->used, i), LLVMPointerType (LLVMInt8Type (), 0));\n\tLLVMSetInitializer (used, LLVMConstArray (LLVMPointerType (LLVMInt8Type (), 0), used_elem, module->used->len));\n\tLLVMSetLinkage (used, LLVMAppendingLinkage);\n\tLLVMSetSection (used, \"llvm.metadata\");\n}\n\n/*\n * emit_get_method:\n *\n *   Emit a function mapping method indexes to their code\n */\nstatic void\nemit_get_method (MonoLLVMModule *module)\n{\n\tLLVMModuleRef lmodule = module->lmodule;\n\tLLVMValueRef func, switch_ins, m;\n\tLLVMBasicBlockRef entry_bb, fail_bb, bb, code_start_bb, code_end_bb;\n\tLLVMBasicBlockRef *bbs;\n\tLLVMTypeRef rtype;\n\tLLVMBuilderRef builder = LLVMCreateBuilder ();\n\tchar *name;\n\tint i;\n\n\t/*\n\t * Emit a switch statement. Emitting a table of function addresses is smaller/faster,\n\t * but generating code seems safer.\n\t */\n\trtype = LLVMPointerType (LLVMInt8Type (), 0);\n\tfunc = LLVMAddFunction (lmodule, module->get_method_symbol, LLVMFunctionType1 (rtype, LLVMInt32Type (), FALSE));\n\tLLVMSetLinkage (func, LLVMExternalLinkage);\n\tLLVMSetVisibility (func, LLVMHiddenVisibility);\n\tmono_llvm_add_func_attr (func, LLVM_ATTR_NO_UNWIND);\n\tmodule->get_method = func;\n\n\tentry_bb = LLVMAppendBasicBlock (func, \"ENTRY\");\n\n\t/*\n\t * Return llvm_code_start/llvm_code_end when called with -1/-2.\n\t * Hopefully, the toolchain doesn't reorder these functions. If it does,\n\t * then we will have to find another solution.\n\t */\n\n\tname = g_strdup_printf (\"BB_CODE_START\");\n\tcode_start_bb = LLVMAppendBasicBlock (func, name);\n\tg_free (name);\n\tLLVMPositionBuilderAtEnd (builder, code_start_bb);\n\tLLVMBuildRet (builder, LLVMBuildBitCast (builder, module->code_start, rtype, \"\"));\n\n\tname = g_strdup_printf (\"BB_CODE_END\");\n\tcode_end_bb = LLVMAppendBasicBlock (func, name);\n\tg_free (name);\n\tLLVMPositionBuilderAtEnd (builder, code_end_bb);\n\tLLVMBuildRet (builder, LLVMBuildBitCast (builder, module->code_end, rtype, \"\"));\n\n\tbbs = g_new0 (LLVMBasicBlockRef, module->max_method_idx + 1);\n\tfor (i = 0; i < module->max_method_idx + 1; ++i) {\n\t\tname = g_strdup_printf (\"BB_%d\", i);\n\t\tbb = LLVMAppendBasicBlock (func, name);\n\t\tg_free (name);\n\t\tbbs [i] = bb;\n\n\t\tLLVMPositionBuilderAtEnd (builder, bb);\n\n\t\tm = (LLVMValueRef)g_hash_table_lookup (module->idx_to_lmethod, GINT_TO_POINTER (i));\n\t\tif (m)\n\t\t\tLLVMBuildRet (builder, LLVMBuildBitCast (builder, m, rtype, \"\"));\n\t\telse\n\t\t\tLLVMBuildRet (builder, LLVMConstNull (rtype));\n\t}\n\n\tfail_bb = LLVMAppendBasicBlock (func, \"FAIL\");\n\tLLVMPositionBuilderAtEnd (builder, fail_bb);\n\tLLVMBuildRet (builder, LLVMConstNull (rtype));\n\n\tLLVMPositionBuilderAtEnd (builder, entry_bb);\n\n\tswitch_ins = LLVMBuildSwitch (builder, LLVMGetParam (func, 0), fail_bb, 0);\n\tLLVMAddCase (switch_ins, LLVMConstInt (LLVMInt32Type (), -1, FALSE), code_start_bb);\n\tLLVMAddCase (switch_ins, LLVMConstInt (LLVMInt32Type (), -2, FALSE), code_end_bb);\n\tfor (i = 0; i < module->max_method_idx + 1; ++i) {\n\t\tLLVMAddCase (switch_ins, LLVMConstInt (LLVMInt32Type (), i, FALSE), bbs [i]);\n\t}\n\n\tmark_as_used (module, func);\n\n\tLLVMDisposeBuilder (builder);\n}\n\n/*\n * emit_get_unbox_tramp:\n *\n *   Emit a function mapping method indexes to their unbox trampoline\n */\nstatic void\nemit_get_unbox_tramp (MonoLLVMModule *module)\n{\n\tLLVMModuleRef lmodule = module->lmodule;\n\tLLVMValueRef func, switch_ins, m;\n\tLLVMBasicBlockRef entry_bb, fail_bb, bb;\n\tLLVMBasicBlockRef *bbs;\n\tLLVMTypeRef rtype;\n\tLLVMBuilderRef builder = LLVMCreateBuilder ();\n\tchar *name;\n\tint i;\n\n\t/* Similar to emit_get_method () */\n\n\trtype = LLVMPointerType (LLVMInt8Type (), 0);\n\tfunc = LLVMAddFunction (lmodule, module->get_unbox_tramp_symbol, LLVMFunctionType1 (rtype, LLVMInt32Type (), FALSE));\n\tLLVMSetLinkage (func, LLVMExternalLinkage);\n\tLLVMSetVisibility (func, LLVMHiddenVisibility);\n\tmono_llvm_add_func_attr (func, LLVM_ATTR_NO_UNWIND);\n\tmodule->get_unbox_tramp = func;\n\n\tentry_bb = LLVMAppendBasicBlock (func, \"ENTRY\");\n\n\tbbs = g_new0 (LLVMBasicBlockRef, module->max_method_idx + 1);\n\tfor (i = 0; i < module->max_method_idx + 1; ++i) {\n\t\tm = (LLVMValueRef)g_hash_table_lookup (module->idx_to_unbox_tramp, GINT_TO_POINTER (i));\n\t\tif (!m)\n\t\t\tcontinue;\n\n\t\tname = g_strdup_printf (\"BB_%d\", i);\n\t\tbb = LLVMAppendBasicBlock (func, name);\n\t\tg_free (name);\n\t\tbbs [i] = bb;\n\n\t\tLLVMPositionBuilderAtEnd (builder, bb);\n\n\t\tLLVMBuildRet (builder, LLVMBuildBitCast (builder, m, rtype, \"\"));\n\t}\n\n\tfail_bb = LLVMAppendBasicBlock (func, \"FAIL\");\n\tLLVMPositionBuilderAtEnd (builder, fail_bb);\n\tLLVMBuildRet (builder, LLVMConstNull (rtype));\n\n\tLLVMPositionBuilderAtEnd (builder, entry_bb);\n\n\tswitch_ins = LLVMBuildSwitch (builder, LLVMGetParam (func, 0), fail_bb, 0);\n\tfor (i = 0; i < module->max_method_idx + 1; ++i) {\n\t\tm = (LLVMValueRef)g_hash_table_lookup (module->idx_to_unbox_tramp, GINT_TO_POINTER (i));\n\t\tif (!m)\n\t\t\tcontinue;\n\n\t\tLLVMAddCase (switch_ins, LLVMConstInt (LLVMInt32Type (), i, FALSE), bbs [i]);\n\t}\n\n\tmark_as_used (module, func);\n\tLLVMDisposeBuilder (builder);\n}\n\n/* Add a function to mark the beginning of LLVM code */\nstatic void\nemit_llvm_code_start (MonoLLVMModule *module)\n{\n\tLLVMModuleRef lmodule = module->lmodule;\n\tLLVMValueRef func;\n\tLLVMBasicBlockRef entry_bb;\n\tLLVMBuilderRef builder;\n\n\tfunc = LLVMAddFunction (lmodule, \"llvm_code_start\", LLVMFunctionType (LLVMVoidType (), NULL, 0, FALSE));\n\tLLVMSetLinkage (func, LLVMInternalLinkage);\n\tmono_llvm_add_func_attr (func, LLVM_ATTR_NO_UNWIND);\n\tmodule->code_start = func;\n\tentry_bb = LLVMAppendBasicBlock (func, \"ENTRY\");\n\tbuilder = LLVMCreateBuilder ();\n\tLLVMPositionBuilderAtEnd (builder, entry_bb);\n\tLLVMBuildRetVoid (builder);\n\tLLVMDisposeBuilder (builder);\n}\n\nstatic LLVMValueRef\nemit_init_icall_wrapper (MonoLLVMModule *module, const char *name, const char *icall_name, int subtype)\n{\n\tLLVMModuleRef lmodule = module->lmodule;\n\tLLVMValueRef func, indexes [2], got_entry_addr, args [16], callee;\n\tLLVMBasicBlockRef entry_bb;\n\tLLVMBuilderRef builder;\n\tLLVMTypeRef sig;\n\tMonoJumpInfo *ji;\n\tint got_offset;\n\n\tswitch (subtype) {\n\tcase 0:\n\t\tfunc = LLVMAddFunction (lmodule, name, LLVMFunctionType1 (LLVMVoidType (), LLVMInt32Type (), FALSE));\n\t\tsig = LLVMFunctionType2 (LLVMVoidType (), IntPtrType (), LLVMInt32Type (), FALSE);\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\t\t/* mrgctx/vtable */\n\t\tfunc = LLVMAddFunction (lmodule, name, LLVMFunctionType2 (LLVMVoidType (), LLVMInt32Type (), IntPtrType (), FALSE));\n\t\tsig = LLVMFunctionType3 (LLVMVoidType (), IntPtrType (), LLVMInt32Type (), IntPtrType (), FALSE);\n\t\tbreak;\n\tcase 2:\n\t\tfunc = LLVMAddFunction (lmodule, name, LLVMFunctionType2 (LLVMVoidType (), LLVMInt32Type (), ObjRefType (), FALSE));\n\t\tsig = LLVMFunctionType3 (LLVMVoidType (), IntPtrType (), LLVMInt32Type (), ObjRefType (), FALSE);\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\tLLVMSetLinkage (func, LLVMInternalLinkage);\n\tmono_llvm_add_func_attr (func, LLVM_ATTR_NO_INLINE);\n\tmono_llvm_set_preserveall_cc (func);\n\tentry_bb = LLVMAppendBasicBlock (func, \"ENTRY\");\n\tbuilder = LLVMCreateBuilder ();\n\tLLVMPositionBuilderAtEnd (builder, entry_bb);\n\n\t/* get_aotconst */\n\tji = g_new0 (MonoJumpInfo, 1);\n\tji->type = MONO_PATCH_INFO_AOT_MODULE;\n\tji = mono_aot_patch_info_dup (ji);\n\tgot_offset = mono_aot_get_got_offset (ji);\n\tmodule->max_got_offset = MAX (module->max_got_offset, got_offset);\n\tindexes [0] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\tindexes [1] = LLVMConstInt (LLVMInt32Type (), got_offset, FALSE);\n\tgot_entry_addr = LLVMBuildGEP (builder, module->got_var, indexes, 2, \"\");\n\targs [0] = LLVMBuildPtrToInt (builder, LLVMBuildLoad (builder, got_entry_addr, \"\"), IntPtrType (), \"\");\n\targs [1] = LLVMGetParam (func, 0);\n\tif (subtype)\n\t\targs [2] = LLVMGetParam (func, 1);\n\n\tji = g_new0 (MonoJumpInfo, 1);\n\tji->type = MONO_PATCH_INFO_INTERNAL_METHOD;\n\tji->data.name = icall_name;\n\tji = mono_aot_patch_info_dup (ji);\n\tgot_offset = mono_aot_get_got_offset (ji);\n\tmodule->max_got_offset = MAX (module->max_got_offset, got_offset);\n\tindexes [0] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\tindexes [1] = LLVMConstInt (LLVMInt32Type (), got_offset, FALSE);\n\tgot_entry_addr = LLVMBuildGEP (builder, module->got_var, indexes, 2, \"\");\n\tcallee = LLVMBuildLoad (builder, got_entry_addr, \"\");\n\tcallee = LLVMBuildBitCast (builder, callee, LLVMPointerType (sig, 0), \"\");\n\tLLVMBuildCall (builder, callee, args, LLVMCountParamTypes (sig), \"\");\n\n\t// Set the inited flag\n\tindexes [0] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\tindexes [1] = LLVMGetParam (func, 0);\n\tLLVMBuildStore (builder, LLVMConstInt (LLVMInt8Type (), 1, FALSE), LLVMBuildGEP (builder, module->inited_var, indexes, 2, \"\"));\n\n\tLLVMBuildRetVoid (builder);\n\n\tLLVMVerifyFunction(func, LLVMAbortProcessAction);\n\tLLVMDisposeBuilder (builder);\n\treturn func;\n}\n\n/*\n * Emit wrappers around the C icalls used to initialize llvm methods, to\n * make the calling code smaller and to enable usage of the llvm\n * PreserveAll calling convention.\n */\nstatic void\nemit_init_icall_wrappers (MonoLLVMModule *module)\n{\n\tmodule->init_method = emit_init_icall_wrapper (module, \"init_method\", \"mono_aot_init_llvm_method\", 0);\n\tmodule->init_method_gshared_mrgctx = emit_init_icall_wrapper (module, \"init_method_gshared_mrgctx\", \"mono_aot_init_gshared_method_mrgctx\", 1);\n\tmodule->init_method_gshared_this = emit_init_icall_wrapper (module, \"init_method_gshared_this\", \"mono_aot_init_gshared_method_this\", 2);\n\tmodule->init_method_gshared_vtable = emit_init_icall_wrapper (module, \"init_method_gshared_vtable\", \"mono_aot_init_gshared_method_vtable\", 3);\n}\n\nstatic void\nemit_llvm_code_end (MonoLLVMModule *module)\n{\n\tLLVMModuleRef lmodule = module->lmodule;\n\tLLVMValueRef func;\n\tLLVMBasicBlockRef entry_bb;\n\tLLVMBuilderRef builder;\n\n\tfunc = LLVMAddFunction (lmodule, \"llvm_code_end\", LLVMFunctionType (LLVMVoidType (), NULL, 0, FALSE));\n\tLLVMSetLinkage (func, LLVMInternalLinkage);\n\tmono_llvm_add_func_attr (func, LLVM_ATTR_NO_UNWIND);\n\tmodule->code_end = func;\n\tentry_bb = LLVMAppendBasicBlock (func, \"ENTRY\");\n\tbuilder = LLVMCreateBuilder ();\n\tLLVMPositionBuilderAtEnd (builder, entry_bb);\n\tLLVMBuildRetVoid (builder);\n\tLLVMDisposeBuilder (builder);\n}\n\nstatic void\nemit_div_check (EmitContext *ctx, LLVMBuilderRef builder, MonoBasicBlock *bb, MonoInst *ins, LLVMValueRef lhs, LLVMValueRef rhs)\n{\n\tgboolean need_div_check = ctx->cfg->backend->need_div_check;\n\n\tif (bb->region)\n\t\t/* LLVM doesn't know that these can throw an exception since they are not called through an intrinsic */\n\t\tneed_div_check = TRUE;\n\n\tif (!need_div_check)\n\t\treturn;\n\n\tswitch (ins->opcode) {\n\tcase OP_IDIV:\n\tcase OP_LDIV:\n\tcase OP_IREM:\n\tcase OP_LREM:\n\tcase OP_IDIV_UN:\n\tcase OP_LDIV_UN:\n\tcase OP_IREM_UN:\n\tcase OP_LREM_UN:\n\tcase OP_IDIV_IMM:\n\tcase OP_LDIV_IMM:\n\tcase OP_IREM_IMM:\n\tcase OP_LREM_IMM:\n\tcase OP_IDIV_UN_IMM:\n\tcase OP_LDIV_UN_IMM:\n\tcase OP_IREM_UN_IMM:\n\tcase OP_LREM_UN_IMM: {\n\t\tLLVMValueRef cmp;\n\t\tgboolean is_signed = (ins->opcode == OP_IDIV || ins->opcode == OP_LDIV || ins->opcode == OP_IREM || ins->opcode == OP_LREM ||\n\t\t\t\t\t\t\t  ins->opcode == OP_IDIV_IMM || ins->opcode == OP_LDIV_IMM || ins->opcode == OP_IREM_IMM || ins->opcode == OP_LREM_IMM);\n\n\t\tcmp = LLVMBuildICmp (builder, LLVMIntEQ, rhs, LLVMConstInt (LLVMTypeOf (rhs), 0, FALSE), \"\");\n\t\temit_cond_system_exception (ctx, bb, \"DivideByZeroException\", cmp);\n\t\tif (!ctx_ok (ctx))\n\t\t\tbreak;\n\t\tbuilder = ctx->builder;\n\n\t\t/* b == -1 && a == 0x80000000 */\n\t\tif (is_signed) {\n\t\t\tLLVMValueRef c = (LLVMTypeOf (lhs) == LLVMInt32Type ()) ? LLVMConstInt (LLVMTypeOf (lhs), 0x80000000, FALSE) : LLVMConstInt (LLVMTypeOf (lhs), 0x8000000000000000LL, FALSE);\n\t\t\tLLVMValueRef cond1 = LLVMBuildICmp (builder, LLVMIntEQ, rhs, LLVMConstInt (LLVMTypeOf (rhs), -1, FALSE), \"\");\n\t\t\tLLVMValueRef cond2 = LLVMBuildICmp (builder, LLVMIntEQ, lhs, c, \"\");\n\n\t\t\tcmp = LLVMBuildICmp (builder, LLVMIntEQ, LLVMBuildAnd (builder, cond1, cond2, \"\"), LLVMConstInt (LLVMInt1Type (), 1, FALSE), \"\");\n\t\t\temit_cond_system_exception (ctx, bb, \"OverflowException\", cmp);\n\t\t\tif (!ctx_ok (ctx))\n\t\t\t\tbreak;\n\t\t\tbuilder = ctx->builder;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/*\n * emit_init_method:\n *\n *   Emit code to initialize the GOT slots used by the method.\n */\nstatic void\nemit_init_method (EmitContext *ctx)\n{\n\tLLVMValueRef indexes [16], args [16], callee;\n\tLLVMValueRef inited_var, cmp, call;\n\tLLVMBasicBlockRef inited_bb, notinited_bb;\n\tLLVMBuilderRef builder = ctx->builder;\n\tMonoCompile *cfg = ctx->cfg;\n\n\tctx->module->max_inited_idx = MAX (ctx->module->max_inited_idx, cfg->method_index);\n\n\tindexes [0] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\tindexes [1] = LLVMConstInt (LLVMInt32Type (), cfg->method_index, FALSE);\n\tinited_var = LLVMBuildLoad (builder, LLVMBuildGEP (builder, ctx->module->inited_var, indexes, 2, \"\"), \"is_inited\");\n\n\targs [0] = inited_var;\n\targs [1] = LLVMConstInt (LLVMInt8Type (), 1, FALSE);\n\tinited_var = LLVMBuildCall (ctx->builder, get_intrinsic (ctx, \"llvm.expect.i8\"), args, 2, \"\");\n\n\tcmp = LLVMBuildICmp (builder, LLVMIntEQ, inited_var, LLVMConstInt (LLVMTypeOf (inited_var), 0, FALSE), \"\");\n\n\tinited_bb = ctx->inited_bb;\n\tnotinited_bb = gen_bb (ctx, \"NOTINITED_BB\");\n\n\tLLVMBuildCondBr (ctx->builder, cmp, notinited_bb, inited_bb);\n\n\tbuilder = ctx->builder = create_builder (ctx);\n\tLLVMPositionBuilderAtEnd (ctx->builder, notinited_bb);\n\n\t// FIXME: Cache\n\tif (ctx->rgctx_arg && cfg->method->is_inflated && mono_method_get_context (cfg->method)->method_inst) {\n\t\targs [0] = LLVMConstInt (LLVMInt32Type (), cfg->method_index, 0);\n\t\targs [1] = convert (ctx, ctx->rgctx_arg, IntPtrType ());\n\t\tcallee = ctx->module->init_method_gshared_mrgctx;\n\t\tcall = LLVMBuildCall (builder, callee, args, 2, \"\");\n\t} else if (ctx->rgctx_arg) {\n\t\t/* A vtable is passed as the rgctx argument */\n\t\targs [0] = LLVMConstInt (LLVMInt32Type (), cfg->method_index, 0);\n\t\targs [1] = convert (ctx, ctx->rgctx_arg, IntPtrType ());\n\t\tcallee = ctx->module->init_method_gshared_vtable;\n\t\tcall = LLVMBuildCall (builder, callee, args, 2, \"\");\n\t} else if (cfg->gshared) {\n\t\targs [0] = LLVMConstInt (LLVMInt32Type (), cfg->method_index, 0);\n\t\targs [1] = convert (ctx, ctx->this_arg, ObjRefType ());\n\t\tcallee = ctx->module->init_method_gshared_this;\n\t\tcall = LLVMBuildCall (builder, callee, args, 2, \"\");\n\t} else {\n\t\targs [0] = LLVMConstInt (LLVMInt32Type (), cfg->method_index, 0);\n\t\tcallee = ctx->module->init_method;\n\t\tcall = LLVMBuildCall (builder, callee, args, 1, \"\");\n\t}\n\n\t/*\n\t * This enables llvm to keep arguments in their original registers/\n\t * scratch registers, since the call will not clobber them.\n\t */\n\tmono_llvm_set_call_preserveall_cc (call);\n\n\tLLVMBuildBr (builder, inited_bb);\n\tctx->bblocks [cfg->bb_entry->block_num].end_bblock = inited_bb;\n\n\tbuilder = ctx->builder = create_builder (ctx);\n\tLLVMPositionBuilderAtEnd (ctx->builder, inited_bb);\n}\n\nstatic void\nemit_unbox_tramp (EmitContext *ctx, const char *method_name, LLVMTypeRef method_type, LLVMValueRef method, int method_index)\n{\n\t/*\n\t * Emit unbox trampoline using a tail call\n\t */\n\tLLVMValueRef tramp, call, *args;\n\tLLVMBuilderRef builder;\n\tLLVMBasicBlockRef lbb;\n\tLLVMCallInfo *linfo;\n\tchar *tramp_name;\n\tint i, nargs;\n\n\ttramp_name = g_strdup_printf (\"ut_%s\", method_name);\n\ttramp = LLVMAddFunction (ctx->module->lmodule, tramp_name, method_type);\n\tLLVMSetLinkage (tramp, LLVMInternalLinkage);\n\tmono_llvm_add_func_attr (tramp, LLVM_ATTR_OPTIMIZE_FOR_SIZE);\n\t//mono_llvm_add_func_attr (tramp, LLVM_ATTR_NO_UNWIND);\n\tlinfo = ctx->linfo;\n\t// FIXME: Reduce code duplication with mono_llvm_compile_method () etc.\n\tif (!ctx->llvm_only && ctx->rgctx_arg_pindex != -1)\n\t\tmono_llvm_add_param_attr (LLVMGetParam (tramp, ctx->rgctx_arg_pindex), LLVM_ATTR_IN_REG);\n\tif (ctx->cfg->vret_addr) {\n\t\tLLVMSetValueName (LLVMGetParam (tramp, linfo->vret_arg_pindex), \"vret\");\n\t\tif (linfo->ret.storage == LLVMArgVtypeByRef) {\n\t\t\tmono_llvm_add_param_attr (LLVMGetParam (tramp, linfo->vret_arg_pindex), LLVM_ATTR_STRUCT_RET);\n\t\t\tmono_llvm_add_param_attr (LLVMGetParam (tramp, linfo->vret_arg_pindex), LLVM_ATTR_NO_ALIAS);\n\t\t}\n\t}\n\n\tlbb = LLVMAppendBasicBlock (tramp, \"\");\n\tbuilder = LLVMCreateBuilder ();\n\tLLVMPositionBuilderAtEnd (builder, lbb);\n\n\tnargs = LLVMCountParamTypes (method_type);\n\targs = g_new0 (LLVMValueRef, nargs);\n\tfor (i = 0; i < nargs; ++i) {\n\t\targs [i] = LLVMGetParam (tramp, i);\n\t\tif (i == ctx->this_arg_pindex) {\n\t\t\tLLVMTypeRef arg_type = LLVMTypeOf (args [i]);\n\n\t\t\targs [i] = LLVMBuildPtrToInt (builder, args [i], IntPtrType (), \"\");\n\t\t\targs [i] = LLVMBuildAdd (builder, args [i], LLVMConstInt (IntPtrType (), sizeof (MonoObject), FALSE), \"\");\n\t\t\targs [i] = LLVMBuildIntToPtr (builder, args [i], arg_type, \"\");\n\t\t}\n\t}\n\tcall = LLVMBuildCall (builder, method, args, nargs, \"\");\n\tif (!ctx->llvm_only && ctx->rgctx_arg_pindex != -1)\n\t\tmono_llvm_add_instr_attr (call, 1 + ctx->rgctx_arg_pindex, LLVM_ATTR_IN_REG);\n\tif (linfo->ret.storage == LLVMArgVtypeByRef)\n\t\tmono_llvm_add_instr_attr (call, 1 + linfo->vret_arg_pindex, LLVM_ATTR_STRUCT_RET);\n\n\t// FIXME: This causes assertions in clang\n\t//mono_llvm_set_must_tail (call);\n\tif (LLVMGetReturnType (method_type) == LLVMVoidType ())\n\t\tLLVMBuildRetVoid (builder);\n\telse\n\t\tLLVMBuildRet (builder, call);\n\n\tg_hash_table_insert (ctx->module->idx_to_unbox_tramp, GINT_TO_POINTER (method_index), tramp);\n\tLLVMDisposeBuilder (builder);\n}\n\n/*\n * emit_entry_bb:\n *\n *   Emit code to load/convert arguments.\n */\nstatic void\nemit_entry_bb (EmitContext *ctx, LLVMBuilderRef builder)\n{\n\tint i, j, pindex;\n\tMonoCompile *cfg = ctx->cfg;\n\tMonoMethodSignature *sig = ctx->sig;\n\tLLVMCallInfo *linfo = ctx->linfo;\n\tMonoBasicBlock *bb;\n\tchar **names;\n\n\tLLVMBuilderRef old_builder = ctx->builder;\n\tctx->builder = builder;\n\n\tctx->alloca_builder = create_builder (ctx);\n\n\t/*\n\t * Handle indirect/volatile variables by allocating memory for them\n\t * using 'alloca', and storing their address in a temporary.\n\t */\n\tfor (i = 0; i < cfg->num_varinfo; ++i) {\n\t\tMonoInst *var = cfg->varinfo [i];\n\t\tLLVMTypeRef vtype;\n\n\t\tif (var->opcode == OP_GSHAREDVT_LOCAL || var->opcode == OP_GSHAREDVT_ARG_REGOFFSET) {\n\t\t} else if (var->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT) || (mini_type_is_vtype (var->inst_vtype) && !MONO_CLASS_IS_SIMD (ctx->cfg, var->klass))) {\n\t\t\tvtype = type_to_llvm_type (ctx, var->inst_vtype);\n\t\t\tif (!ctx_ok (ctx))\n\t\t\t\treturn;\n\t\t\t/* Could be already created by an OP_VPHI */\n\t\t\tif (!ctx->addresses [var->dreg]) {\n\t\t\t\tctx->addresses [var->dreg] = build_alloca (ctx, var->inst_vtype);\n\t\t\t\t//LLVMSetValueName (ctx->addresses [var->dreg], g_strdup_printf (\"vreg_loc_%d\", var->dreg));\n\t\t\t}\n\t\t\tctx->vreg_cli_types [var->dreg] = var->inst_vtype;\n\t\t}\n\t}\n\n\tnames = g_new (char *, sig->param_count);\n\tmono_method_get_param_names (cfg->method, (const char **) names);\n\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tLLVMArgInfo *ainfo = &linfo->args [i + sig->hasthis];\n\t\tint reg = cfg->args [i + sig->hasthis]->dreg;\n\t\tchar *name;\n\n\t\tpindex = ainfo->pindex;\n\n\t\tswitch (ainfo->storage) {\n\t\tcase LLVMArgVtypeInReg:\n\t\tcase LLVMArgAsFpArgs: {\n\t\t\tLLVMValueRef args [8];\n\t\t\tint j;\n\n\t\t\tpindex += ainfo->ndummy_fpargs;\n\n\t\t\t/* The argument is received as a set of int/fp arguments, store them into the real argument */\n\t\t\tmemset (args, 0, sizeof (args));\n\t\t\tif (ainfo->storage == LLVMArgVtypeInReg) {\n\t\t\t\targs [0] = LLVMGetParam (ctx->lmethod, pindex);\n\t\t\t\tif (ainfo->pair_storage [1] != LLVMArgNone)\n\t\t\t\t\targs [1] = LLVMGetParam (ctx->lmethod, pindex + 1);\n\t\t\t} else {\n\t\t\t\tg_assert (ainfo->nslots <= 8);\n\t\t\t\tfor (j = 0; j < ainfo->nslots; ++j)\n\t\t\t\t\targs [j] = LLVMGetParam (ctx->lmethod, pindex + j);\n\t\t\t}\n\t\t\tctx->addresses [reg] = build_alloca (ctx, ainfo->type);\n\n\t\t\temit_args_to_vtype (ctx, builder, ainfo->type, ctx->addresses [reg], ainfo, args);\n\n\t\t\tif (ainfo->storage == LLVMArgVtypeInReg && MONO_CLASS_IS_SIMD (ctx->cfg, mono_class_from_mono_type (ainfo->type))) {\n\t\t\t\t/* Treat these as normal values */\n\t\t\t\tctx->values [reg] = LLVMBuildLoad (builder, ctx->addresses [reg], \"\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgVtypeByVal: {\n\t\t\tctx->addresses [reg] = LLVMGetParam (ctx->lmethod, pindex);\n\n\t\t\tif (MONO_CLASS_IS_SIMD (ctx->cfg, mono_class_from_mono_type (ainfo->type))) {\n\t\t\t\t/* Treat these as normal values */\n\t\t\t\tctx->values [reg] = LLVMBuildLoad (builder, ctx->addresses [reg], \"\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgVtypeByRef: {\n\t\t\t/* The argument is passed by ref */\n\t\t\tctx->addresses [reg] = LLVMGetParam (ctx->lmethod, pindex);\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgAsIArgs: {\n\t\t\tLLVMValueRef arg = LLVMGetParam (ctx->lmethod, pindex);\n\t\t\tint size;\n\n\t\t\t/* The argument is received as an array of ints, store it into the real argument */\n\t\t\tctx->addresses [reg] = build_alloca (ctx, ainfo->type);\n\n\t\t\tsize = mono_class_value_size (mono_class_from_mono_type (ainfo->type), NULL);\n\t\t\tif (size < SIZEOF_VOID_P) {\n\t\t\t\t/* The upper bits of the registers might not be valid */\n\t\t\t\tLLVMValueRef val = LLVMBuildExtractValue (builder, arg, 0, \"\");\n\t\t\t\tLLVMValueRef dest = convert (ctx, ctx->addresses [reg], LLVMPointerType (LLVMIntType (size * 8), 0));\n\t\t\t\tLLVMBuildStore (ctx->builder, LLVMBuildTrunc (builder, val, LLVMIntType (size * 8), \"\"), dest);\n\t\t\t} else {\n\t\t\t\tLLVMBuildStore (ctx->builder, arg, convert (ctx, ctx->addresses [reg], LLVMPointerType (LLVMTypeOf (arg), 0)));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgVtypeAsScalar:\n\t\t\tg_assert_not_reached ();\n\t\t\tbreak;\n\t\tcase LLVMArgGsharedvtFixed: {\n\t\t\t/* These are non-gsharedvt arguments passed by ref, the rest of the IR treats them as scalars */\n\t\t\tLLVMValueRef arg = LLVMGetParam (ctx->lmethod, pindex);\n\n\t\t\tif (names [i])\n\t\t\t\tname = g_strdup_printf (\"arg_%s\", names [i]);\n\t\t\telse\n\t\t\t\tname = g_strdup_printf (\"arg_%d\", i);\n\n\t\t\tctx->values [reg] = LLVMBuildLoad (builder, convert (ctx, arg, LLVMPointerType (type_to_llvm_type (ctx, ainfo->type), 0)), name);\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgGsharedvtFixedVtype: {\n\t\t\tLLVMValueRef arg = LLVMGetParam (ctx->lmethod, pindex);\n\n\t\t\tif (names [i])\n\t\t\t\tname = g_strdup_printf (\"vtype_arg_%s\", names [i]);\n\t\t\telse\n\t\t\t\tname = g_strdup_printf (\"vtype_arg_%d\", i);\n\n\t\t\t/* Non-gsharedvt vtype argument passed by ref, the rest of the IR treats it as a vtype */\n\t\t\tg_assert (ctx->addresses [reg]);\n\t\t\tLLVMSetValueName (ctx->addresses [reg], name);\n\t\t\tLLVMBuildStore (builder, LLVMBuildLoad (builder, convert (ctx, arg, LLVMPointerType (type_to_llvm_type (ctx, ainfo->type), 0)), \"\"), ctx->addresses [reg]);\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgGsharedvtVariable:\n\t\t\t/* The IR treats these as variables with addresses */\n\t\t\tctx->addresses [reg] = LLVMGetParam (ctx->lmethod, pindex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tctx->values [reg] = convert_full (ctx, ctx->values [reg], llvm_type_to_stack_type (cfg, type_to_llvm_type (ctx, ainfo->type)), type_is_unsigned (ctx, ainfo->type));\n\t\t\tbreak;\n\t\t}\n\t}\n\tg_free (names);\n\n\tif (cfg->vret_addr)\n\t\temit_volatile_store (ctx, cfg->vret_addr->dreg);\n\tif (sig->hasthis)\n\t\temit_volatile_store (ctx, cfg->args [0]->dreg);\n\tfor (i = 0; i < sig->param_count; ++i)\n\t\tif (!mini_type_is_vtype (sig->params [i]))\n\t\t\temit_volatile_store (ctx, cfg->args [i + sig->hasthis]->dreg);\n\n\tif (sig->hasthis && !cfg->rgctx_var && cfg->gshared) {\n\t\tLLVMValueRef this_alloc;\n\n\t\t/*\n\t\t * The exception handling code needs the location where the this argument was\n\t\t * stored for gshared methods. We create a separate alloca to hold it, and mark it\n\t\t * with the \"mono.this\" custom metadata to tell llvm that it needs to save its\n\t\t * location into the LSDA.\n\t\t */\n\t\tthis_alloc = mono_llvm_build_alloca (builder, ThisType (), LLVMConstInt (LLVMInt32Type (), 1, FALSE), 0, \"\");\n\t\t/* This volatile store will keep the alloca alive */\n\t\tmono_llvm_build_store (builder, ctx->values [cfg->args [0]->dreg], this_alloc, TRUE, LLVM_BARRIER_NONE);\n\n\t\tset_metadata_flag (this_alloc, \"mono.this\");\n\t}\n\n\tif (cfg->rgctx_var) {\n\t\tLLVMValueRef rgctx_alloc, store;\n\n\t\t/*\n\t\t * We handle the rgctx arg similarly to the this pointer.\n\t\t */\n\t\tg_assert (ctx->addresses [cfg->rgctx_var->dreg]);\n\t\trgctx_alloc = ctx->addresses [cfg->rgctx_var->dreg];\n\t\t/* This volatile store will keep the alloca alive */\n\t\tstore = mono_llvm_build_store (builder, convert (ctx, ctx->rgctx_arg, IntPtrType ()), rgctx_alloc, TRUE, LLVM_BARRIER_NONE);\n\n\t\tset_metadata_flag (rgctx_alloc, \"mono.this\");\n\t}\n\n\t/* Initialize the method if needed */\n\tif (cfg->compile_aot && ctx->llvm_only) {\n\t\t/* Emit a location for the initialization code */\n\t\tctx->init_bb = gen_bb (ctx, \"INIT_BB\");\n\t\tctx->inited_bb = gen_bb (ctx, \"INITED_BB\");\n\n\t\tLLVMBuildBr (ctx->builder, ctx->init_bb);\n\t\tbuilder = ctx->builder = create_builder (ctx);\n\t\tLLVMPositionBuilderAtEnd (ctx->builder, ctx->inited_bb);\n\t\tctx->bblocks [cfg->bb_entry->block_num].end_bblock = ctx->inited_bb;\n\t}\n\n\t/* Compute nesting between clauses */\n\tctx->nested_in = (GSList**)mono_mempool_alloc0 (cfg->mempool, sizeof (GSList*) * cfg->header->num_clauses);\n\tfor (i = 0; i < cfg->header->num_clauses; ++i) {\n\t\tfor (j = 0; j < cfg->header->num_clauses; ++j) {\n\t\t\tMonoExceptionClause *clause1 = &cfg->header->clauses [i];\n\t\t\tMonoExceptionClause *clause2 = &cfg->header->clauses [j];\n\n\t\t\tif (i != j && clause1->try_offset >= clause2->try_offset && clause1->handler_offset <= clause2->handler_offset)\n\t\t\t\tctx->nested_in [i] = g_slist_prepend_mempool (cfg->mempool, ctx->nested_in [i], GINT_TO_POINTER (j));\n\t\t}\n\t}\n\n\t/*\n\t * For finally clauses, create an indicator variable telling OP_ENDFINALLY whenever\n\t * it needs to continue normally, or return back to the exception handling system.\n\t */\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb) {\n\t\tint clause_index;\n\t\tchar name [128];\n\n\t\tif (!(bb->region != -1 && (bb->flags & BB_EXCEPTION_HANDLER)))\n\t\t\tcontinue;\n\n\t\tclause_index = MONO_REGION_CLAUSE_INDEX (bb->region);\n\t\tg_hash_table_insert (ctx->region_to_handler, GUINT_TO_POINTER (mono_get_block_region_notry (cfg, bb->region)), bb);\n\t\tg_hash_table_insert (ctx->clause_to_handler, GINT_TO_POINTER (clause_index), bb);\n\n\t\tif (bb->in_scount == 0) {\n\t\t\tLLVMValueRef val;\n\n\t\t\tsprintf (name, \"finally_ind_bb%d\", bb->block_num);\n\t\t\tval = LLVMBuildAlloca (builder, LLVMInt32Type (), name);\n\t\t\tLLVMBuildStore (builder, LLVMConstInt (LLVMInt32Type (), 0, FALSE), val);\n\n\t\t\tctx->bblocks [bb->block_num].finally_ind = val;\n\t\t} else {\n\t\t\t/* Create a variable to hold the exception var */\n\t\t\tif (!ctx->ex_var)\n\t\t\t\tctx->ex_var = LLVMBuildAlloca (builder, ObjRefType (), \"exvar\");\n\t\t}\n\n\t\t/*\n\t\t * Create a new bblock which CALL_HANDLER/landing pads can branch to, because branching to the\n\t\t * LLVM bblock containing a landing pad causes problems for the\n\t\t * LLVM optimizer passes.\n\t\t */\n\t\tsprintf (name, \"BB%d_CALL_HANDLER_TARGET\", bb->block_num);\n\t\tctx->bblocks [bb->block_num].call_handler_target_bb = LLVMAppendBasicBlock (ctx->lmethod, name);\n\t}\n\tctx->builder = old_builder;\n}\n\nstatic void\nprocess_call (EmitContext *ctx, MonoBasicBlock *bb, LLVMBuilderRef *builder_ref, MonoInst *ins)\n{\n\tMonoCompile *cfg = ctx->cfg;\n\tLLVMValueRef *values = ctx->values;\n\tLLVMValueRef *addresses = ctx->addresses;\n\tMonoCallInst *call = (MonoCallInst*)ins;\n\tMonoMethodSignature *sig = call->signature;\n\tLLVMValueRef callee = NULL, lcall;\n\tLLVMValueRef *args;\n\tLLVMCallInfo *cinfo;\n\tGSList *l;\n\tint i, len, nargs;\n\tgboolean vretaddr;\n\tLLVMTypeRef llvm_sig;\n\tgpointer target;\n\tgboolean is_virtual, calli, preserveall;\n\tLLVMBuilderRef builder = *builder_ref;\n\n\tif ((call->signature->call_convention != MONO_CALL_DEFAULT) && !((call->signature->call_convention == MONO_CALL_C) && ctx->llvm_only)) {\n\t\tset_failure (ctx, \"non-default callconv\");\n\t\treturn;\n\t}\n\n\tcinfo = call->cinfo;\n\tg_assert (cinfo);\n\tif (call->rgctx_arg_reg)\n\t\tcinfo->rgctx_arg = TRUE;\n\tif (call->imt_arg_reg)\n\t\tcinfo->imt_arg = TRUE;\n\n\tvretaddr = (cinfo->ret.storage == LLVMArgVtypeRetAddr || cinfo->ret.storage == LLVMArgVtypeByRef || cinfo->ret.storage == LLVMArgGsharedvtFixed || cinfo->ret.storage == LLVMArgGsharedvtVariable || cinfo->ret.storage == LLVMArgGsharedvtFixedVtype);\n\n\tllvm_sig = sig_to_llvm_sig_full (ctx, sig, cinfo);\n\tif (!ctx_ok (ctx))\n\t\treturn;\n\n\tis_virtual = (ins->opcode == OP_VOIDCALL_MEMBASE || ins->opcode == OP_CALL_MEMBASE || ins->opcode == OP_VCALL_MEMBASE || ins->opcode == OP_LCALL_MEMBASE || ins->opcode == OP_FCALL_MEMBASE || ins->opcode == OP_RCALL_MEMBASE);\n\tcalli = !call->fptr_is_patch && (ins->opcode == OP_VOIDCALL_REG || ins->opcode == OP_CALL_REG || ins->opcode == OP_VCALL_REG || ins->opcode == OP_LCALL_REG || ins->opcode == OP_FCALL_REG || ins->opcode == OP_RCALL_REG);\n\t/* Unused */\n\tpreserveall = FALSE;\n\n\t/* FIXME: Avoid creating duplicate methods */\n\n\tif (ins->flags & MONO_INST_HAS_METHOD) {\n\t\tif (is_virtual) {\n\t\t\tcallee = NULL;\n\t\t} else {\n\t\t\tif (cfg->compile_aot) {\n\t\t\t\tcallee = get_callee (ctx, llvm_sig, MONO_PATCH_INFO_METHOD, call->method);\n\t\t\t\tif (!callee) {\n\t\t\t\t\tset_failure (ctx, \"can't encode patch\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (cfg->llvm_only && call->method->klass->image->assembly == ctx->module->assembly) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Collect instructions representing the callee into a hash so they can be replaced\n\t\t\t\t\t * by the llvm method for the callee if the callee turns out to be direct\n\t\t\t\t\t * callable. Currently this only requires it to not fail llvm compilation.\n\t\t\t\t\t */\n\t\t\t\t\tGSList *l = (GSList*)g_hash_table_lookup (ctx->method_to_callers, call->method);\n\t\t\t\t\tl = g_slist_prepend (l, callee);\n\t\t\t\t\tg_hash_table_insert (ctx->method_to_callers, call->method, l);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tMonoError error;\n\t\t\t\tstatic int tramp_index;\n\t\t\t\tchar *name;\n\n\t\t\t\tname = g_strdup_printf (\"tramp_%d\", tramp_index);\n\t\t\t\ttramp_index ++;\n\n#if LLVM_API_VERSION > 100\n\t\t\t\t/*\n\t\t\t\t * Use our trampoline infrastructure for lazy compilation instead of llvm's.\n\t\t\t\t * Make all calls through a global. The address of the global will be saved in\n\t\t\t\t * MonoJitDomainInfo.llvm_jit_callees and updated when the method it refers to is\n\t\t\t\t * compiled.\n\t\t\t\t */\n\t\t\t\tLLVMValueRef tramp_var = g_hash_table_lookup (ctx->jit_callees, call->method);\n\t\t\t\tif (!tramp_var) {\n\t\t\t\t\ttarget =\n\t\t\t\t\t\tmono_create_jit_trampoline (mono_domain_get (),\n\t\t\t\t\t\t\t\t\t\t\t\t\tcall->method, &error);\n\t\t\t\t\tif (!is_ok (&error)) {\n\t\t\t\t\t\tset_failure (ctx, mono_error_get_message (&error));\n\t\t\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttramp_var = LLVMAddGlobal (ctx->lmodule, LLVMPointerType (llvm_sig, 0), name);\n\t\t\t\t\tLLVMSetInitializer (tramp_var, LLVMConstIntToPtr (LLVMConstInt (LLVMInt64Type (), (guint64)(size_t)target, FALSE), LLVMPointerType (llvm_sig, 0)));\n\t\t\t\t\tLLVMSetLinkage (tramp_var, LLVMExternalLinkage);\n\t\t\t\t\tg_hash_table_insert (ctx->jit_callees, call->method, tramp_var);\n\t\t\t\t}\n\t\t\t\tcallee = LLVMBuildLoad (builder, tramp_var, \"\");\n#else\n\t\t\t\ttarget =\n\t\t\t\t\tmono_create_jit_trampoline (mono_domain_get (),\n\t\t\t\t\t\t\t\t    call->method, &error);\n\t\t\t\tif (!is_ok (&error)) {\n\t\t\t\t\tg_free (name);\n\t\t\t\t\tset_failure (ctx, mono_error_get_message (&error));\n\t\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcallee = LLVMAddFunction (ctx->lmodule, name, llvm_sig);\n\t\t\t\tg_free (name);\n\n\t\t\t\tLLVMAddGlobalMapping (ctx->module->ee, callee, target);\n#endif\n\t\t\t}\n\t\t}\n\n\t\tif (!cfg->llvm_only && call->method && strstr (call->method->klass->name, \"AsyncVoidMethodBuilder\")) {\n\t\t\t/* LLVM miscompiles async methods */\n\t\t\tset_failure (ctx, \"#13734\");\n\t\t\treturn;\n\t\t}\n\t} else if (calli) {\n\t} else {\n\t\tMonoJitICallInfo *info = mono_find_jit_icall_by_addr (call->fptr);\n\n\t\tif (info) {\n\t\t\t/*\n\t\t\t  MonoJumpInfo ji;\n\n\t\t\t  memset (&ji, 0, sizeof (ji));\n\t\t\t  ji.type = MONO_PATCH_INFO_JIT_ICALL_ADDR;\n\t\t\t  ji.data.target = info->name;\n\n\t\t\t  target = mono_resolve_patch_target (cfg->method, cfg->domain, NULL, &ji, FALSE);\n\t\t\t*/\n\t\t\tif (cfg->compile_aot) {\n\t\t\t\tcallee = get_callee (ctx, llvm_sig, MONO_PATCH_INFO_INTERNAL_METHOD, (char*)info->name);\n\t\t\t\tif (!callee) {\n\t\t\t\t\tset_failure (ctx, \"can't encode patch\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttarget = (gpointer)mono_icall_get_wrapper (info);\n\t\t\t\tcallee = emit_jit_callee (ctx, \"\", llvm_sig, target);\n\t\t\t}\n\t\t} else {\n\t\t\tif (cfg->compile_aot) {\n\t\t\t\tcallee = NULL;\n\t\t\t\tif (cfg->abs_patches) {\n\t\t\t\t\tMonoJumpInfo *abs_ji = (MonoJumpInfo*)g_hash_table_lookup (cfg->abs_patches, call->fptr);\n\t\t\t\t\tif (abs_ji) {\n\t\t\t\t\t\tcallee = get_callee (ctx, llvm_sig, abs_ji->type, abs_ji->data.target);\n\t\t\t\t\t\tif (!callee) {\n\t\t\t\t\t\t\tset_failure (ctx, \"can't encode patch\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!callee) {\n\t\t\t\t\tset_failure (ctx, \"aot\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n#if LLVM_API_VERSION > 100\n\t\t\t\tif (cfg->abs_patches) {\n\t\t\t\t\tMonoJumpInfo *abs_ji = (MonoJumpInfo*)g_hash_table_lookup (cfg->abs_patches, call->fptr);\n\t\t\t\t\tif (abs_ji) {\n\t\t\t\t\t\tMonoError error;\n\n\t\t\t\t\t\ttarget = mono_resolve_patch_target (cfg->method, cfg->domain, NULL, abs_ji, FALSE, &error);\n\t\t\t\t\t\tmono_error_assert_ok (&error);\n\t\t\t\t\t\tcallee = emit_jit_callee (ctx, \"\", llvm_sig, target);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n#else\n\t\t\t\tcallee = LLVMAddFunction (ctx->lmodule, \"\", llvm_sig);\n\t\t\t\ttarget = NULL;\n\t\t\t\tif (cfg->abs_patches) {\n\t\t\t\t\tMonoJumpInfo *abs_ji = (MonoJumpInfo*)g_hash_table_lookup (cfg->abs_patches, call->fptr);\n\t\t\t\t\tif (abs_ji) {\n\t\t\t\t\t\tMonoError error;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * FIXME: Some trampolines might have\n\t\t\t\t\t\t * their own calling convention on some platforms.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttarget = mono_resolve_patch_target (cfg->method, cfg->domain, NULL, abs_ji, FALSE, &error);\n\t\t\t\t\t\tmono_error_assert_ok (&error);\n\t\t\t\t\t\tLLVMAddGlobalMapping (ctx->module->ee, callee, target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!target)\n\t\t\t\t\tLLVMAddGlobalMapping (ctx->module->ee, callee, (gpointer)call->fptr);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_virtual) {\n\t\tint size = sizeof (gpointer);\n\t\tLLVMValueRef index;\n\n\t\tg_assert (ins->inst_offset % size == 0);\n\t\tindex = LLVMConstInt (LLVMInt32Type (), ins->inst_offset / size, FALSE);\n\n\t\tcallee = convert (ctx, LLVMBuildLoad (builder, LLVMBuildGEP (builder, convert (ctx, values [ins->inst_basereg], LLVMPointerType (LLVMPointerType (IntPtrType (), 0), 0)), &index, 1, \"\"), \"\"), LLVMPointerType (llvm_sig, 0));\n\t} else if (calli) {\n\t\tcallee = convert (ctx, values [ins->sreg1], LLVMPointerType (llvm_sig, 0));\n\t} else {\n\t\tif (ins->flags & MONO_INST_HAS_METHOD) {\n\t\t}\n\t}\n\n\t/* \n\t * Collect and convert arguments\n\t */\n\tnargs = (sig->param_count * 16) + sig->hasthis + vretaddr + call->rgctx_reg + call->imt_arg_reg;\n\tlen = sizeof (LLVMValueRef) * nargs;\n\targs = (LLVMValueRef*)alloca (len);\n\tmemset (args, 0, len);\n\tl = call->out_ireg_args;\n\n\tif (call->rgctx_arg_reg) {\n\t\tg_assert (values [call->rgctx_arg_reg]);\n\t\tg_assert (cinfo->rgctx_arg_pindex < nargs);\n\t\t/*\n\t\t * On ARM, the imt/rgctx argument is passed in a caller save register, but some of our trampolines etc. clobber it, leading to\n\t\t * problems is LLVM moves the arg assignment earlier. To work around this, save the argument into a stack slot and load\n\t\t * it using a volatile load.\n\t\t */\n#ifdef TARGET_ARM\n\t\tif (!ctx->imt_rgctx_loc)\n\t\t\tctx->imt_rgctx_loc = build_alloca_llvm_type (ctx, ctx->module->ptr_type, sizeof (gpointer));\n\t\tLLVMBuildStore (builder, convert (ctx, ctx->values [call->rgctx_arg_reg], ctx->module->ptr_type), ctx->imt_rgctx_loc);\n\t\targs [cinfo->rgctx_arg_pindex] = mono_llvm_build_load (builder, ctx->imt_rgctx_loc, \"\", TRUE);\n#else\n\t\targs [cinfo->rgctx_arg_pindex] = convert (ctx, values [call->rgctx_arg_reg], ctx->module->ptr_type);\n#endif\n\t}\n\tif (call->imt_arg_reg) {\n\t\tg_assert (!ctx->llvm_only);\n\t\tg_assert (values [call->imt_arg_reg]);\n\t\tg_assert (cinfo->imt_arg_pindex < nargs);\n#ifdef TARGET_ARM\n\t\tif (!ctx->imt_rgctx_loc)\n\t\t\tctx->imt_rgctx_loc = build_alloca_llvm_type (ctx, ctx->module->ptr_type, sizeof (gpointer));\n\t\tLLVMBuildStore (builder, convert (ctx, ctx->values [call->imt_arg_reg], ctx->module->ptr_type), ctx->imt_rgctx_loc);\n\t\targs [cinfo->imt_arg_pindex] = mono_llvm_build_load (builder, ctx->imt_rgctx_loc, \"\", TRUE);\n#else\n\t\targs [cinfo->imt_arg_pindex] = convert (ctx, values [call->imt_arg_reg], ctx->module->ptr_type);\n#endif\n\t}\n\tswitch (cinfo->ret.storage) {\n\tcase LLVMArgGsharedvtVariable: {\n\t\tMonoInst *var = get_vreg_to_inst (cfg, call->inst.dreg);\n\n\t\tif (var && var->opcode == OP_GSHAREDVT_LOCAL) {\n\t\t\targs [cinfo->vret_arg_pindex] = convert (ctx, emit_gsharedvt_ldaddr (ctx, var->dreg), IntPtrType ());\n\t\t} else {\n\t\t\tg_assert (addresses [call->inst.dreg]);\n\t\t\targs [cinfo->vret_arg_pindex] = addresses [call->inst.dreg];\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tif (vretaddr) {\n\t\t\tif (!addresses [call->inst.dreg])\n\t\t\t\taddresses [call->inst.dreg] = build_alloca (ctx, sig->ret);\n\t\t\tg_assert (cinfo->vret_arg_pindex < nargs);\n\t\t\tif (cinfo->ret.storage == LLVMArgVtypeByRef)\n\t\t\t\targs [cinfo->vret_arg_pindex] = addresses [call->inst.dreg];\n\t\t\telse\n\t\t\t\targs [cinfo->vret_arg_pindex] = LLVMBuildPtrToInt (builder, addresses [call->inst.dreg], IntPtrType (), \"\");\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Sometimes the same method is called with two different signatures (i.e. with and without 'this'), so\n\t * use the real callee for argument type conversion.\n\t */\n\tLLVMTypeRef callee_type = LLVMGetElementType (LLVMTypeOf (callee));\n\tLLVMTypeRef *param_types = (LLVMTypeRef*)g_alloca (sizeof (LLVMTypeRef) * LLVMCountParamTypes (callee_type));\n\tLLVMGetParamTypes (callee_type, param_types);\n\n\tfor (i = 0; i < sig->param_count + sig->hasthis; ++i) {\n\t\tguint32 regpair;\n\t\tint reg, pindex;\n\t\tLLVMArgInfo *ainfo = &call->cinfo->args [i];\n\n\t\tpindex = ainfo->pindex;\n\n\t\tregpair = (guint32)(gssize)(l->data);\n\t\treg = regpair & 0xffffff;\n\t\targs [pindex] = values [reg];\n\t\tswitch (ainfo->storage) {\n\t\tcase LLVMArgVtypeInReg:\n\t\tcase LLVMArgAsFpArgs: {\n\t\t\tguint32 nargs;\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < ainfo->ndummy_fpargs; ++j)\n\t\t\t\targs [pindex + j] = LLVMConstNull (LLVMDoubleType ());\n\t\t\tpindex += ainfo->ndummy_fpargs;\n\n\t\t\tg_assert (addresses [reg]);\n\t\t\temit_vtype_to_args (ctx, builder, ainfo->type, addresses [reg], ainfo, args + pindex, &nargs);\n\t\t\tpindex += nargs;\n\n\t\t\t// FIXME: alignment\n\t\t\t// FIXME: Get rid of the VMOVE\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgVtypeByVal:\n\t\t\tg_assert (addresses [reg]);\n\t\t\targs [pindex] = addresses [reg];\n\t\t\tbreak;\n\t\tcase LLVMArgVtypeByRef: {\n\t\t\tg_assert (addresses [reg]);\n\t\t\targs [pindex] = convert (ctx, addresses [reg], LLVMPointerType (type_to_llvm_arg_type (ctx, ainfo->type), 0));\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgAsIArgs:\n\t\t\tg_assert (addresses [reg]);\n\t\t\tif (ainfo->esize == 8)\n\t\t\t\targs [pindex] = LLVMBuildLoad (ctx->builder, convert (ctx, addresses [reg], LLVMPointerType (LLVMArrayType (LLVMInt64Type (), ainfo->nslots), 0)), \"\");\n\t\t\telse\n\t\t\t\targs [pindex] = LLVMBuildLoad (ctx->builder, convert (ctx, addresses [reg], LLVMPointerType (LLVMArrayType (IntPtrType (), ainfo->nslots), 0)), \"\");\n\t\t\tbreak;\n\t\tcase LLVMArgVtypeAsScalar:\n\t\t\tg_assert_not_reached ();\n\t\t\tbreak;\n\t\tcase LLVMArgGsharedvtFixed:\n\t\tcase LLVMArgGsharedvtFixedVtype:\n\t\t\tg_assert (addresses [reg]);\n\t\t\targs [pindex] = convert (ctx, addresses [reg], LLVMPointerType (type_to_llvm_arg_type (ctx, ainfo->type), 0));\n\t\t\tbreak;\n\t\tcase LLVMArgGsharedvtVariable:\n\t\t\tg_assert (addresses [reg]);\n\t\t\targs [pindex] = convert (ctx, addresses [reg], LLVMPointerType (IntPtrType (), 0));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert (args [pindex]);\n\t\t\tif (i == 0 && sig->hasthis)\n\t\t\t\targs [pindex] = convert (ctx, args [pindex], param_types [pindex]);\n\t\t\telse\n\t\t\t\targs [pindex] = convert (ctx, args [pindex], type_to_llvm_arg_type (ctx, ainfo->type));\n\t\t\tbreak;\n\t\t}\n\t\tg_assert (pindex <= nargs);\n\n\t\tl = l->next;\n\t}\n\n\t// FIXME: Align call sites\n\n\t/*\n\t * Emit the call\n\t */\n\n\tlcall = emit_call (ctx, bb, &builder, callee, args, LLVMCountParamTypes (llvm_sig));\n\n\tif (ins->opcode != OP_TAILCALL && LLVMGetInstructionOpcode (lcall) == LLVMCall)\n\t\tmono_llvm_set_call_notail (lcall);\n\n\t/*\n\t * Modify cconv and parameter attributes to pass rgctx/imt correctly.\n\t */\n#if defined(MONO_ARCH_IMT_REG) && defined(MONO_ARCH_RGCTX_REG)\n\tg_assert (MONO_ARCH_IMT_REG == MONO_ARCH_RGCTX_REG);\n#endif\n\t/* The two can't be used together, so use only one LLVM calling conv to pass them */\n\tg_assert (!(call->rgctx_arg_reg && call->imt_arg_reg));\n\tif (!sig->pinvoke && !cfg->llvm_only)\n\t\tLLVMSetInstructionCallConv (lcall, LLVMMono1CallConv);\n\tif (preserveall)\n\t\tmono_llvm_set_call_preserveall_cc (lcall);\n\n\tif (cinfo->ret.storage == LLVMArgVtypeByRef)\n\t\tmono_llvm_add_instr_attr (lcall, 1 + cinfo->vret_arg_pindex, LLVM_ATTR_STRUCT_RET);\n\tif (!ctx->llvm_only && call->rgctx_arg_reg)\n\t\tmono_llvm_add_instr_attr (lcall, 1 + cinfo->rgctx_arg_pindex, LLVM_ATTR_IN_REG);\n\tif (call->imt_arg_reg)\n\t\tmono_llvm_add_instr_attr (lcall, 1 + cinfo->imt_arg_pindex, LLVM_ATTR_IN_REG);\n\n\t/* Add byval attributes if needed */\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tLLVMArgInfo *ainfo = &call->cinfo->args [i + sig->hasthis];\n\n\t\tif (ainfo && ainfo->storage == LLVMArgVtypeByVal)\n\t\t\tmono_llvm_add_instr_attr (lcall, 1 + ainfo->pindex, LLVM_ATTR_BY_VAL);\n\t}\n\n\t/*\n\t * Convert the result\n\t */\n\tswitch (cinfo->ret.storage) {\n\tcase LLVMArgVtypeInReg: {\n\t\tLLVMValueRef regs [2];\n\n\t\tif (LLVMTypeOf (lcall) == LLVMVoidType ())\n\t\t\t/* Empty struct */\n\t\t\tbreak;\n\n\t\tif (!addresses [ins->dreg])\n\t\t\taddresses [ins->dreg] = build_alloca (ctx, sig->ret);\n\n\t\tregs [0] = LLVMBuildExtractValue (builder, lcall, 0, \"\");\n\t\tif (cinfo->ret.pair_storage [1] != LLVMArgNone)\n\t\t\tregs [1] = LLVMBuildExtractValue (builder, lcall, 1, \"\");\n\t\temit_args_to_vtype (ctx, builder, sig->ret, addresses [ins->dreg], &cinfo->ret, regs);\n\t\tbreak;\n\t}\n\tcase LLVMArgVtypeByVal:\n\t\tif (!addresses [call->inst.dreg])\n\t\t\taddresses [call->inst.dreg] = build_alloca (ctx, sig->ret);\n\t\tLLVMBuildStore (builder, lcall, addresses [call->inst.dreg]);\n\t\tbreak;\n\tcase LLVMArgAsIArgs:\n\tcase LLVMArgFpStruct:\n\t\tif (!addresses [call->inst.dreg])\n\t\t\taddresses [call->inst.dreg] = build_alloca (ctx, sig->ret);\n\t\tLLVMBuildStore (builder, lcall, convert_full (ctx, addresses [call->inst.dreg], LLVMPointerType (LLVMTypeOf (lcall), 0), FALSE));\n\t\tbreak;\n\tcase LLVMArgVtypeAsScalar:\n\t\tif (!addresses [call->inst.dreg])\n\t\t\taddresses [call->inst.dreg] = build_alloca (ctx, sig->ret);\n\t\tLLVMBuildStore (builder, lcall, convert_full (ctx, addresses [call->inst.dreg], LLVMPointerType (LLVMTypeOf (lcall), 0), FALSE));\n\t\tbreak;\n\tcase LLVMArgVtypeRetAddr:\n\tcase LLVMArgVtypeByRef:\n\t\tif (MONO_CLASS_IS_SIMD (ctx->cfg, mono_class_from_mono_type (sig->ret))) {\n\t\t\t/* Some opcodes like STOREX_MEMBASE access these by value */\n\t\t\tg_assert (addresses [call->inst.dreg]);\n\t\t\tvalues [ins->dreg] = LLVMBuildLoad (builder, convert_full (ctx, addresses [call->inst.dreg], LLVMPointerType (type_to_llvm_type (ctx, sig->ret), 0), FALSE), \"\");\n\t\t}\n\t\tbreak;\n\tcase LLVMArgGsharedvtVariable:\n\t\tbreak;\n\tcase LLVMArgGsharedvtFixed:\n\tcase LLVMArgGsharedvtFixedVtype:\n\t\tvalues [ins->dreg] = LLVMBuildLoad (builder, convert_full (ctx, addresses [call->inst.dreg], LLVMPointerType (type_to_llvm_type (ctx, sig->ret), 0), FALSE), \"\");\n\t\tbreak;\n\tdefault:\n\t\tif (sig->ret->type != MONO_TYPE_VOID)\n\t\t\t/* If the method returns an unsigned value, need to zext it */\n\t\t\tvalues [ins->dreg] = convert_full (ctx, lcall, llvm_type_to_stack_type (cfg, type_to_llvm_type (ctx, sig->ret)), type_is_unsigned (ctx, sig->ret));\n\t\tbreak;\n\t}\n\n\t*builder_ref = ctx->builder;\n}\n\nstatic void\nemit_llvmonly_throw (EmitContext *ctx, MonoBasicBlock *bb, gboolean rethrow, LLVMValueRef exc)\n{\n\tconst char *icall_name = rethrow ? \"mono_llvm_rethrow_exception\" : \"mono_llvm_throw_exception\";\n\tLLVMValueRef callee = rethrow ? ctx->module->rethrow : ctx->module->throw_icall;\n\n\tLLVMTypeRef exc_type = type_to_llvm_type (ctx, &mono_get_exception_class ()->byval_arg);\n\n\tif (!callee) {\n\t\tLLVMTypeRef fun_sig = LLVMFunctionType1 (LLVMVoidType (), exc_type, FALSE);\n\n\t\tif (ctx->cfg->compile_aot) {\n\t\t\tcallee = get_callee (ctx, fun_sig, MONO_PATCH_INFO_JIT_ICALL_ADDR, icall_name);\n\t\t} else {\n\t\t\tcallee = LLVMAddFunction (ctx->lmodule, icall_name, fun_sig);\n\t\t\tLLVMAddGlobalMapping (ctx->module->ee, callee, resolve_patch (ctx->cfg, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name));\n\t\t\tmono_memory_barrier ();\n\n\t\t\tif (rethrow)\n\t\t\t\tctx->module->rethrow = callee;\n\t\t\telse\n\t\t\t\tctx->module->throw_icall = callee;\n\t\t}\n\t}\n\n\tLLVMValueRef args [2];\n\n\targs [0] = convert (ctx, exc, exc_type);\n\temit_call (ctx, bb, &ctx->builder, callee, args, 1);\n\n\tLLVMBuildUnreachable (ctx->builder);\n\n\tctx->builder = create_builder (ctx);\n}\n\nstatic void\nemit_throw (EmitContext *ctx, MonoBasicBlock *bb, gboolean rethrow, LLVMValueRef exc)\n{\n\tMonoMethodSignature *throw_sig;\n\tLLVMValueRef callee, arg;\n\tconst char *icall_name;\n\t\t\t\t\n\tcallee = rethrow ? ctx->module->rethrow : ctx->module->throw_icall;\n\ticall_name = rethrow ? \"mono_arch_rethrow_exception\" : \"mono_arch_throw_exception\";\n\n\tif (!callee) {\n\t\tthrow_sig = mono_metadata_signature_alloc (mono_get_corlib (), 1);\n\t\tthrow_sig->ret = &mono_get_void_class ()->byval_arg;\n\t\tthrow_sig->params [0] = &mono_get_object_class ()->byval_arg;\n\t\tif (ctx->cfg->compile_aot) {\n\t\t\tcallee = get_callee (ctx, sig_to_llvm_sig (ctx, throw_sig), MONO_PATCH_INFO_INTERNAL_METHOD, icall_name);\n\t\t} else {\n\t\t\tgpointer target;\n#ifdef TARGET_X86\n\t\t\t/* \n\t\t\t * LLVM doesn't push the exception argument, so we need a different\n\t\t\t * trampoline.\n\t\t\t */\n\t\t\ttarget = resolve_patch (ctx->cfg, MONO_PATCH_INFO_INTERNAL_METHOD, rethrow ? \"llvm_rethrow_exception_trampoline\" : \"llvm_throw_exception_trampoline\");\n#else\n\t\t\ttarget = resolve_patch (ctx->cfg, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name);\n#endif\n\t\t\tcallee = emit_jit_callee (ctx, icall_name, sig_to_llvm_sig (ctx, throw_sig), target);\n\t\t}\n\n\t\tmono_memory_barrier ();\n#if LLVM_API_VERSION < 100\n\t\tif (rethrow)\n\t\t\tctx->module->rethrow = callee;\n\t\telse\n\t\t\tctx->module->throw_icall = callee;\n#endif\n\t}\n\targ = convert (ctx, exc, type_to_llvm_type (ctx, &mono_get_object_class ()->byval_arg));\n\temit_call (ctx, bb, &ctx->builder, callee, &arg, 1);\n}\n\nstatic void\nemit_resume_eh (EmitContext *ctx, MonoBasicBlock *bb)\n{\n\tconst char *icall_name = \"mono_llvm_resume_exception\";\n\tLLVMValueRef callee = ctx->module->resume_eh;\n\n\tLLVMTypeRef fun_sig = LLVMFunctionType0 (LLVMVoidType (), FALSE);\n\n\tif (!callee) {\n\t\tif (ctx->cfg->compile_aot) {\n\t\t\tcallee = get_callee (ctx, fun_sig, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name);\n\t\t} else {\n\t\t\tcallee = LLVMAddFunction (ctx->lmodule, icall_name, fun_sig);\n\t\t\tLLVMAddGlobalMapping (ctx->module->ee, callee, resolve_patch (ctx->cfg, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name));\n\t\t\tmono_memory_barrier ();\n\n\t\t\tctx->module->resume_eh = callee;\n\t\t}\n\t}\n\n\temit_call (ctx, bb, &ctx->builder, callee, NULL, 0);\n\n\tLLVMBuildUnreachable (ctx->builder);\n\n\tctx->builder = create_builder (ctx);\n}\n\nstatic LLVMValueRef\nmono_llvm_emit_clear_exception_call (EmitContext *ctx, LLVMBuilderRef builder)\n{\n\tconst char *icall_name = \"mono_llvm_clear_exception\";\n\n\tLLVMTypeRef call_sig = LLVMFunctionType (LLVMVoidType (), NULL, 0, FALSE);\n\tLLVMValueRef callee = NULL;\n\n\tif (!callee) {\n\t\tif (ctx->cfg->compile_aot) {\n\t\t\tcallee = get_callee (ctx, call_sig, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name);\n\t\t} else {\n\t\t\t// FIXME: This is broken.\n\t\t\tcallee = LLVMAddFunction (ctx->lmodule, icall_name, call_sig);\n\t\t}\n\t}\n\n\tg_assert (builder && callee);\n\n\treturn LLVMBuildCall (builder, callee, NULL, 0, \"\");\n}\n\nstatic LLVMValueRef\nmono_llvm_emit_load_exception_call (EmitContext *ctx, LLVMBuilderRef builder)\n{\n\tconst char *icall_name = \"mono_llvm_load_exception\";\n\n\tLLVMTypeRef call_sig = LLVMFunctionType (ObjRefType (), NULL, 0, FALSE);\n\tLLVMValueRef callee = NULL;\n\n\tif (!callee) {\n\t\tif (ctx->cfg->compile_aot) {\n\t\t\tcallee = get_callee (ctx, call_sig, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name);\n\t\t} else {\n\t\t\t// FIXME: This is broken.\n\t\t\tcallee = LLVMAddFunction (ctx->lmodule, icall_name, call_sig);\n\t\t}\n\t}\n\n\tg_assert (builder && callee);\n\n\treturn LLVMBuildCall (builder, callee, NULL, 0, icall_name);\n}\n\n\nstatic LLVMValueRef\nmono_llvm_emit_match_exception_call (EmitContext *ctx, LLVMBuilderRef builder, gint32 region_start, gint32 region_end)\n{\n\tconst char *icall_name = \"mono_llvm_match_exception\";\n\n\tctx->builder = builder;\n\n\tconst int num_args = 5;\n\tLLVMValueRef args [num_args];\n\targs [0] = convert (ctx, get_aotconst (ctx, MONO_PATCH_INFO_AOT_JIT_INFO, GINT_TO_POINTER (ctx->cfg->method_index)), IntPtrType ());\n\targs [1] = LLVMConstInt (LLVMInt32Type (), region_start, 0);\n\targs [2] = LLVMConstInt (LLVMInt32Type (), region_end, 0);\n\tif (ctx->cfg->rgctx_var) {\n\t\tLLVMValueRef rgctx_alloc = ctx->addresses [ctx->cfg->rgctx_var->dreg];\n\t\tg_assert (rgctx_alloc);\n\t\targs [3] = LLVMBuildLoad (builder, convert (ctx, rgctx_alloc, LLVMPointerType (IntPtrType (), 0)), \"\");\n\t} else {\n\t\targs [3] = LLVMConstInt (IntPtrType (), 0, 0);\n\t}\n\tif (ctx->this_arg)\n\t\targs [4] = convert (ctx, ctx->this_arg, IntPtrType ());\n\telse\n\t\targs [4] = LLVMConstInt (IntPtrType (), 0, 0);\n\n\tLLVMTypeRef match_sig = LLVMFunctionType5 (LLVMInt32Type (), IntPtrType (), LLVMInt32Type (), LLVMInt32Type (), IntPtrType (), IntPtrType (), FALSE);\n\tLLVMValueRef callee = ctx->module->match_exc;\n\n\tif (!callee) {\n\t\tif (ctx->cfg->compile_aot) {\n\t\t\tctx->builder = builder;\n\t\t\t// get_callee expects ctx->builder to be the emitting builder\n\t\t\tcallee = get_callee (ctx, match_sig, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name);\n\t\t} else {\n\t\t\tcallee = ctx->module->match_exc = LLVMAddFunction (ctx->lmodule, icall_name, match_sig);\n\t\t\tLLVMAddGlobalMapping (ctx->module->ee, ctx->module->match_exc, resolve_patch (ctx->cfg, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name));\n\t\t\tctx->module->match_exc = callee;\n\t\t\tmono_memory_barrier ();\n\t\t}\n\t}\n\n\tg_assert (builder && callee);\n\n\tg_assert (ctx->ex_var);\n\n\treturn LLVMBuildCall (builder, callee, args, num_args, icall_name);\n}\n\n// FIXME: This won't work because the code-finding makes this\n// not a constant.\n/*#define MONO_PERSONALITY_DEBUG*/\n\n#ifdef MONO_PERSONALITY_DEBUG\nstatic const gboolean use_debug_personality = TRUE;\nstatic const char *default_personality_name = \"mono_debug_personality\";\n#else\nstatic const gboolean use_debug_personality = FALSE;\nstatic const char *default_personality_name = \"__gxx_personality_v0\";\n#endif\n\nstatic LLVMTypeRef\ndefault_cpp_lpad_exc_signature (void)\n{\n\tstatic gboolean inited = FALSE;\n\tstatic LLVMTypeRef sig;\n\n\tif (!sig) {\n\t\tLLVMTypeRef signature [2];\n\t\tsignature [0] = LLVMPointerType (LLVMInt8Type (), 0);\n\t\tsignature [1] = LLVMInt32Type ();\n\t\tsig = LLVMStructType (signature, 2, FALSE);\n\t\tinited = TRUE;\n\t}\n\n\treturn sig;\n}\n\nstatic LLVMValueRef\nget_mono_personality (EmitContext *ctx)\n{\n\tLLVMValueRef personality = NULL;\n\tstatic gint32 mapping_inited = FALSE;\n\tLLVMTypeRef personality_type = LLVMFunctionType (LLVMInt32Type (), NULL, 0, TRUE);\n\n\tif (!use_debug_personality) {\n\t\tif (ctx->cfg->compile_aot) {\n\t\t\t\tpersonality = get_intrinsic (ctx, default_personality_name);\n\t\t} else if (mono_atomic_cas_i32 (&mapping_inited, 1, 0) == 0) {\n\t\t\t\tpersonality = LLVMAddFunction (ctx->lmodule, default_personality_name, personality_type);\n\t\t\t\tLLVMAddGlobalMapping (ctx->module->ee, personality, personality);\n\t\t}\n\t} else {\n\t\tif (ctx->cfg->compile_aot) {\n\t\t\tpersonality = get_callee (ctx, personality_type, MONO_PATCH_INFO_INTERNAL_METHOD, default_personality_name);\n\t\t} else {\n\t\t\tpersonality = LLVMAddFunction (ctx->lmodule, default_personality_name, personality_type);\n\t\t\tLLVMAddGlobalMapping (ctx->module->ee, personality, resolve_patch (ctx->cfg, MONO_PATCH_INFO_INTERNAL_METHOD, default_personality_name));\n\t\t\tmono_memory_barrier ();\n\t\t}\n\t}\n\n\tg_assert (personality);\n\treturn personality;\n}\n\nstatic LLVMBasicBlockRef\nemit_landing_pad (EmitContext *ctx, int group_index, int group_size)\n{\n\tMonoCompile *cfg = ctx->cfg;\n\tLLVMBuilderRef old_builder = ctx->builder;\n\tMonoExceptionClause *group_start = cfg->header->clauses + group_index;\n\n\tLLVMBuilderRef lpadBuilder = create_builder (ctx);\n\tctx->builder = lpadBuilder;\n\n\tMonoBasicBlock *handler_bb = cfg->cil_offset_to_bb [CLAUSE_START (group_start)];\n\tg_assert (handler_bb);\n\n\t// <resultval> = landingpad <somety> personality <type> <pers_fn> <clause>+\n\tLLVMValueRef personality = get_mono_personality (ctx);\n\tg_assert (personality);\n\n\tchar *bb_name = g_strdup_printf (\"LPAD%d_BB\", group_index);\n\tLLVMBasicBlockRef lpad_bb = gen_bb (ctx, bb_name);\n\tg_free (bb_name);\n\tLLVMPositionBuilderAtEnd (lpadBuilder, lpad_bb);\n\tLLVMValueRef landing_pad = LLVMBuildLandingPad (lpadBuilder, default_cpp_lpad_exc_signature (), personality, 0, \"\");\n\tg_assert (landing_pad);\n\n\tLLVMValueRef cast = LLVMBuildBitCast (lpadBuilder, ctx->module->sentinel_exception, LLVMPointerType (LLVMInt8Type (), 0), \"int8TypeInfo\");\n\tLLVMAddClause (landing_pad, cast);\n\n\tLLVMBasicBlockRef resume_bb = gen_bb (ctx, \"RESUME_BB\");\n\tLLVMBuilderRef resume_builder = create_builder (ctx);\n\tctx->builder = resume_builder;\n\tLLVMPositionBuilderAtEnd (resume_builder, resume_bb);\n\n\temit_resume_eh (ctx, handler_bb);\n\n\t// Build match\n\tctx->builder = lpadBuilder;\n\tLLVMPositionBuilderAtEnd (lpadBuilder, lpad_bb);\n\n\tgboolean finally_only = TRUE;\n\n\tMonoExceptionClause *group_cursor = group_start;\n\n\tfor (int i = 0; i < group_size; i ++) {\n\t\tif (!(group_cursor->flags & MONO_EXCEPTION_CLAUSE_FINALLY || group_cursor->flags & MONO_EXCEPTION_CLAUSE_FAULT))\n\t\t\tfinally_only = FALSE;\n\n\t\tgroup_cursor++;\n\t}\n\n\t// FIXME:\n\t// Handle landing pad inlining\n\n\tif (!finally_only) {\n\t\t// So at each level of the exception stack we will match the exception again.\n\t\t// During that match, we need to compare against the handler types for the current\n\t\t// protected region. We send the try start and end so that we can only check against\n\t\t// handlers for this lexical protected region.\n\t\tLLVMValueRef match = mono_llvm_emit_match_exception_call (ctx, lpadBuilder, group_start->try_offset, group_start->try_offset + group_start->try_len);\n\n\t\t// if returns -1, resume\n\t\tLLVMValueRef switch_ins = LLVMBuildSwitch (lpadBuilder, match, resume_bb, group_size);\n\n\t\t// else move to that target bb\n\t\tfor (int i = 0; i < group_size; i++) {\n\t\t\tMonoExceptionClause *clause = group_start + i;\n\t\t\tint clause_index = clause - cfg->header->clauses;\n\t\t\tMonoBasicBlock *handler_bb = (MonoBasicBlock*)g_hash_table_lookup (ctx->clause_to_handler, GINT_TO_POINTER (clause_index));\n\t\t\tg_assert (handler_bb);\n\t\t\tg_assert (ctx->bblocks [handler_bb->block_num].call_handler_target_bb);\n\t\t\tLLVMAddCase (switch_ins, LLVMConstInt (LLVMInt32Type (), clause_index, FALSE), ctx->bblocks [handler_bb->block_num].call_handler_target_bb);\n\t\t}\n\t} else {\n\t\tint clause_index = group_start - cfg->header->clauses;\n\t\tMonoBasicBlock *finally_bb = (MonoBasicBlock*)g_hash_table_lookup (ctx->clause_to_handler, GINT_TO_POINTER (clause_index));\n\t\tg_assert (finally_bb);\n\n\t\tLLVMBuildBr (ctx->builder, ctx->bblocks [finally_bb->block_num].call_handler_target_bb);\n\t}\n\n\tctx->builder = old_builder;\n\n\treturn lpad_bb;\n}\n\n\nstatic void\nemit_llvmonly_handler_start (EmitContext *ctx, MonoBasicBlock *bb, LLVMBasicBlockRef cbb)\n{\n\tint clause_index = MONO_REGION_CLAUSE_INDEX (bb->region);\n\tMonoExceptionClause *clause = &ctx->cfg->header->clauses [clause_index];\n\n\t// Make exception available to catch blocks\n\tif (!(clause->flags & MONO_EXCEPTION_CLAUSE_FINALLY || clause->flags & MONO_EXCEPTION_CLAUSE_FAULT)) {\n\t\tLLVMValueRef mono_exc = mono_llvm_emit_load_exception_call (ctx, ctx->builder);\n\n\t\tg_assert (ctx->ex_var);\n\t\tLLVMBuildStore (ctx->builder, LLVMBuildBitCast (ctx->builder, mono_exc, ObjRefType (), \"\"), ctx->ex_var);\n\n\t\tif (bb->in_scount == 1) {\n\t\t\tMonoInst *exvar = bb->in_stack [0];\n\t\t\tg_assert (!ctx->values [exvar->dreg]);\n\t\t\tg_assert (ctx->ex_var);\n\t\t\tctx->values [exvar->dreg] = LLVMBuildLoad (ctx->builder, ctx->ex_var, \"save_exception\");\n\t\t\temit_volatile_store (ctx, exvar->dreg);\n\t\t}\n\n\t\tmono_llvm_emit_clear_exception_call (ctx, ctx->builder);\n\t}\n\n\tLLVMBuilderRef handler_builder = create_builder (ctx);\n\tLLVMBasicBlockRef target_bb = ctx->bblocks [bb->block_num].call_handler_target_bb;\n\tLLVMPositionBuilderAtEnd (handler_builder, target_bb);\n\n\t// Make the handler code end with a jump to cbb\n\tLLVMBuildBr (handler_builder, cbb);\n}\n\nstatic void\nemit_handler_start (EmitContext *ctx, MonoBasicBlock *bb, LLVMBuilderRef builder)\n{\n\tMonoCompile *cfg = ctx->cfg;\n\tLLVMValueRef *values = ctx->values;\n\tLLVMModuleRef lmodule = ctx->lmodule;\n\tBBInfo *bblocks = ctx->bblocks;\n\tLLVMTypeRef i8ptr;\n\tLLVMValueRef personality;\n\tLLVMValueRef landing_pad;\n\tLLVMBasicBlockRef target_bb;\n\tMonoInst *exvar;\n\tstatic int ti_generator;\n\tchar ti_name [128];\n\tLLVMValueRef type_info;\n\tint clause_index;\n\tGSList *l;\n\n\t// <resultval> = landingpad <somety> personality <type> <pers_fn> <clause>+\n\n\tif (cfg->compile_aot) {\n\t\t/* Use a dummy personality function */\n\t\tpersonality = LLVMGetNamedFunction (lmodule, \"mono_personality\");\n\t\tg_assert (personality);\n\t} else {\n#if LLVM_API_VERSION > 100\n\t\t/* Can't cache this as each method is in its own llvm module */\n\t\tLLVMTypeRef personality_type = LLVMFunctionType (LLVMInt32Type (), NULL, 0, TRUE);\n\t\tpersonality = LLVMAddFunction (ctx->lmodule, \"mono_personality\", personality_type);\n\t\tmono_llvm_add_func_attr (personality, LLVM_ATTR_NO_UNWIND);\n\t\tLLVMBasicBlockRef entry_bb = LLVMAppendBasicBlock (personality, \"ENTRY\");\n\t\tLLVMBuilderRef builder2 = LLVMCreateBuilder ();\n\t\tLLVMPositionBuilderAtEnd (builder2, entry_bb);\n\t\tLLVMBuildRet (builder2, LLVMConstInt (LLVMInt32Type (), 0, FALSE));\n\t\tLLVMDisposeBuilder (builder2);\n#else\n\t\tstatic gint32 mapping_inited;\n\n\t\tpersonality = LLVMGetNamedFunction (lmodule, \"mono_personality\");\n\n\t\tif (mono_atomic_cas_i32 (&mapping_inited, 1, 0) == 0)\n\t\t\tLLVMAddGlobalMapping (ctx->module->ee, personality, (gpointer)mono_personality);\n#endif\n\t}\n\n\ti8ptr = LLVMPointerType (LLVMInt8Type (), 0);\n\n\tclause_index = (mono_get_block_region_notry (cfg, bb->region) >> 8) - 1;\n\n\t/*\n\t * Create the type info\n\t */\n\tsprintf (ti_name, \"type_info_%d\", ti_generator);\n\tti_generator ++;\n\n\tif (cfg->compile_aot) {\n\t\t/* decode_eh_frame () in aot-runtime.c will decode this */\n\t\ttype_info = LLVMAddGlobal (lmodule, LLVMInt32Type (), ti_name);\n\t\tLLVMSetInitializer (type_info, LLVMConstInt (LLVMInt32Type (), clause_index, FALSE));\n\n\t\t/*\n\t\t * These symbols are not really used, the clause_index is embedded into the EH tables generated by DwarfMonoException in LLVM.\n\t\t */\n\t\tLLVMSetLinkage (type_info, LLVMInternalLinkage);\n\t} else {\n#if LLVM_API_VERSION > 100\n\t\ttype_info = LLVMAddGlobal (lmodule, LLVMInt32Type (), ti_name);\n\t\tLLVMSetInitializer (type_info, LLVMConstInt (LLVMInt32Type (), clause_index, FALSE));\n#else\n\t\tgint32 *ti;\n\n\t\t/*\n\t\t * After the cfg mempool is freed, the type info will point to stale memory,\n\t\t * but this is not a problem, since we decode it once in exception_cb during\n\t\t * compilation.\n\t\t */\n\t\tti = (gint32*)mono_mempool_alloc (cfg->mempool, sizeof (gint32));\n\t\t*(gint32*)ti = clause_index;\n\n\t\ttype_info = LLVMAddGlobal (lmodule, i8ptr, ti_name);\n\n\t\tLLVMAddGlobalMapping (ctx->module->ee, type_info, ti);\n#endif\n\t}\n\n\t{\n\t\tLLVMTypeRef members [2], ret_type;\n\n\t\tmembers [0] = i8ptr;\n\t\tmembers [1] = LLVMInt32Type ();\n\t\tret_type = LLVMStructType (members, 2, FALSE);\n\n\t\tlanding_pad = LLVMBuildLandingPad (builder, ret_type, personality, 1, \"\");\n\t\tLLVMAddClause (landing_pad, type_info);\n\n\t\t/* Store the exception into the exvar */\n\t\tif (ctx->ex_var)\n\t\t\tLLVMBuildStore (builder, convert (ctx, LLVMBuildExtractValue (builder, landing_pad, 0, \"ex_obj\"), ObjRefType ()), ctx->ex_var);\n\t}\n\n\t/*\n\t * LLVM throw sites are associated with a one landing pad, and LLVM generated\n\t * code expects control to be transferred to this landing pad even in the\n\t * presence of nested clauses. The landing pad needs to branch to the landing\n\t * pads belonging to nested clauses based on the selector value returned by\n\t * the landing pad instruction, which is passed to the landing pad in a\n\t * register by the EH code.\n\t */\n\ttarget_bb = bblocks [bb->block_num].call_handler_target_bb;\n\tg_assert (target_bb);\n\n\t/*\n\t * Branch to the correct landing pad\n\t */\n\tLLVMValueRef ex_selector = LLVMBuildExtractValue (builder, landing_pad, 1, \"ex_selector\");\n\tLLVMValueRef switch_ins = LLVMBuildSwitch (builder, ex_selector, target_bb, 0);\n\n\tfor (l = ctx->nested_in [clause_index]; l; l = l->next) {\n\t\tint nesting_clause_index = GPOINTER_TO_INT (l->data);\n\t\tMonoBasicBlock *handler_bb;\n\n\t\thandler_bb = (MonoBasicBlock*)g_hash_table_lookup (ctx->clause_to_handler, GINT_TO_POINTER (nesting_clause_index));\n\t\tg_assert (handler_bb);\n\n\t\tg_assert (ctx->bblocks [handler_bb->block_num].call_handler_target_bb);\n\t\tLLVMAddCase (switch_ins, LLVMConstInt (LLVMInt32Type (), nesting_clause_index, FALSE), ctx->bblocks [handler_bb->block_num].call_handler_target_bb);\n\t}\n\n\t/* Start a new bblock which CALL_HANDLER can branch to */\n\tctx->builder = builder = create_builder (ctx);\n\tLLVMPositionBuilderAtEnd (ctx->builder, target_bb);\n\n\tctx->bblocks [bb->block_num].end_bblock = target_bb;\n\n\t/* Store the exception into the IL level exvar */\n\tif (bb->in_scount == 1) {\n\t\tg_assert (bb->in_scount == 1);\n\t\texvar = bb->in_stack [0];\n\n\t\t// FIXME: This is shared with filter clauses ?\n\t\tg_assert (!values [exvar->dreg]);\n\n\t\tg_assert (ctx->ex_var);\n\t\tvalues [exvar->dreg] = LLVMBuildLoad (builder, ctx->ex_var, \"\");\n\t\temit_volatile_store (ctx, exvar->dreg);\n\t}\n\n\t/* Make normal branches to the start of the clause branch to the new bblock */\n\tbblocks [bb->block_num].bblock = target_bb;\n}\n\nstatic void\nprocess_bb (EmitContext *ctx, MonoBasicBlock *bb)\n{\n\tMonoCompile *cfg = ctx->cfg;\n\tMonoMethodSignature *sig = ctx->sig;\n\tLLVMValueRef method = ctx->lmethod;\n\tLLVMValueRef *values = ctx->values;\n\tLLVMValueRef *addresses = ctx->addresses;\n\tLLVMCallInfo *linfo = ctx->linfo;\n\tBBInfo *bblocks = ctx->bblocks;\n\tMonoInst *ins;\n\tLLVMBasicBlockRef cbb;\n\tLLVMBuilderRef builder, starting_builder;\n\tgboolean has_terminator;\n\tLLVMValueRef v;\n\tLLVMValueRef lhs, rhs;\n\tint nins = 0;\n\n\tcbb = get_end_bb (ctx, bb);\n\n\tbuilder = create_builder (ctx);\n\tctx->builder = builder;\n\tLLVMPositionBuilderAtEnd (builder, cbb);\n\n\tif (!ctx_ok (ctx))\n\t\treturn;\n\n\tif (bb->flags & BB_EXCEPTION_HANDLER) {\n\t\tif (!ctx->llvm_only && !bblocks [bb->block_num].invoke_target) {\n\t\t\tset_failure (ctx, \"handler without invokes\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (ctx->llvm_only)\n\t\t\temit_llvmonly_handler_start (ctx, bb, cbb);\n\t\telse\n\t\t\temit_handler_start (ctx, bb, builder);\n\t\tif (!ctx_ok (ctx))\n\t\t\treturn;\n\t\tbuilder = ctx->builder;\n\t}\n\n\thas_terminator = FALSE;\n\tstarting_builder = builder;\n\tfor (ins = bb->code; ins; ins = ins->next) {\n\t\tconst char *spec = LLVM_INS_INFO (ins->opcode);\n\t\tchar *dname = NULL;\n\t\tchar dname_buf [128];\n\n\t\temit_dbg_loc (ctx, builder, ins->cil_code);\n\n\t\tnins ++;\n\t\tif (nins > 1000) {\n\t\t\t/*\n\t\t\t * Some steps in llc are non-linear in the size of basic blocks, see #5714.\n\t\t\t * Start a new bblock.\n\t\t\t * Prevent the bblocks to be merged by doing a volatile load + cond branch\n\t\t\t * from localloc-ed memory.\n\t\t\t */\n\t\t\tif (!cfg->llvm_only)\n\t\t\t\t;//set_failure (ctx, \"basic block too long\");\n\n\t\t\tif (!ctx->long_bb_break_var) {\n\t\t\t\tctx->long_bb_break_var = build_alloca_llvm_type_name (ctx, LLVMInt32Type (), 0, \"long_bb_break\");\n\t\t\t\tmono_llvm_build_store (ctx->alloca_builder, LLVMConstInt (LLVMInt32Type (), 0, FALSE), ctx->long_bb_break_var, TRUE, LLVM_BARRIER_NONE);\n\t\t\t}\n\n\t\t\tcbb = gen_bb (ctx, \"CONT_LONG_BB\");\n\t\t\tLLVMBasicBlockRef dummy_bb = gen_bb (ctx, \"CONT_LONG_BB_DUMMY\");\n\n\t\t\tLLVMValueRef load = mono_llvm_build_load (builder, ctx->long_bb_break_var, \"\", TRUE);\n\t\t\t/*\n\t\t\t * The long_bb_break_var is initialized to 0 in the prolog, so this branch will always go to 'cbb'\n\t\t\t * but llvm doesn't know that, so the branch is not going to be eliminated.\n\t\t\t */\n\t\t\tLLVMValueRef cmp = LLVMBuildICmp (builder, LLVMIntEQ, load, LLVMConstInt (LLVMInt32Type (), 0, FALSE), \"\");\n\n\t\t\tLLVMBuildCondBr (builder, cmp, cbb, dummy_bb);\n\n\t\t\t/* Emit a dummy false bblock which does nothing but contains a volatile store so it cannot be eliminated */\n\t\t\tctx->builder = builder = create_builder (ctx);\n\t\t\tLLVMPositionBuilderAtEnd (builder, dummy_bb);\n\t\t\tmono_llvm_build_store (builder, LLVMConstInt (LLVMInt32Type (), 1, FALSE), ctx->long_bb_break_var, TRUE, LLVM_BARRIER_NONE);\n\t\t\tLLVMBuildBr (builder, cbb);\n\n\t\t\tctx->builder = builder = create_builder (ctx);\n\t\t\tLLVMPositionBuilderAtEnd (builder, cbb);\n\t\t\tctx->bblocks [bb->block_num].end_bblock = cbb;\n\t\t\tnins = 0;\n\t\t}\n\n\t\tif (has_terminator)\n\t\t\t/* There could be instructions after a terminator, skip them */\n\t\t\tbreak;\n\n\t\tif (spec [MONO_INST_DEST] != ' ' && !MONO_IS_STORE_MEMBASE (ins)) {\n\t\t\tsprintf (dname_buf, \"t%d\", ins->dreg);\n\t\t\tdname = dname_buf;\n\t\t}\n\n\t\tif (spec [MONO_INST_SRC1] != ' ' && spec [MONO_INST_SRC1] != 'v') {\n\t\t\tMonoInst *var = get_vreg_to_inst (cfg, ins->sreg1);\n\n\t\t\tif (var && var->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT) && var->opcode != OP_GSHAREDVT_ARG_REGOFFSET) {\n\t\t\t\tlhs = emit_volatile_load (ctx, ins->sreg1);\n\t\t\t} else {\n\t\t\t\t/* It is ok for SETRET to have an uninitialized argument */\n\t\t\t\tif (!values [ins->sreg1] && ins->opcode != OP_SETRET) {\n\t\t\t\t\tset_failure (ctx, \"sreg1\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlhs = values [ins->sreg1];\n\t\t\t}\n\t\t} else {\n\t\t\tlhs = NULL;\n\t\t}\n\n\t\tif (spec [MONO_INST_SRC2] != ' ' && spec [MONO_INST_SRC2] != ' ') {\n\t\t\tMonoInst *var = get_vreg_to_inst (cfg, ins->sreg2);\n\t\t\tif (var && var->flags & (MONO_INST_VOLATILE|MONO_INST_INDIRECT)) {\n\t\t\t\trhs = emit_volatile_load (ctx, ins->sreg2);\n\t\t\t} else {\n\t\t\t\tif (!values [ins->sreg2]) {\n\t\t\t\t\tset_failure (ctx, \"sreg2\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\trhs = values [ins->sreg2];\n\t\t\t}\n\t\t} else {\n\t\t\trhs = NULL;\n\t\t}\n\n\t\t//mono_print_ins (ins);\n\t\tswitch (ins->opcode) {\n\t\tcase OP_NOP:\n\t\tcase OP_NOT_NULL:\n\t\tcase OP_LIVERANGE_START:\n\t\tcase OP_LIVERANGE_END:\n\t\t\tbreak;\n\t\tcase OP_ICONST:\n\t\t\tvalues [ins->dreg] = LLVMConstInt (LLVMInt32Type (), ins->inst_c0, FALSE);\n\t\t\tbreak;\n\t\tcase OP_I8CONST:\n#if SIZEOF_VOID_P == 4\n\t\t\tvalues [ins->dreg] = LLVMConstInt (LLVMInt64Type (), GET_LONG_IMM (ins), FALSE);\n#else\n\t\t\tvalues [ins->dreg] = LLVMConstInt (LLVMInt64Type (), (gint64)ins->inst_c0, FALSE);\n#endif\n\t\t\tbreak;\n\t\tcase OP_R8CONST:\n\t\t\tvalues [ins->dreg] = LLVMConstReal (LLVMDoubleType (), *(double*)ins->inst_p0);\n\t\t\tbreak;\n\t\tcase OP_R4CONST:\n\t\t\tif (cfg->r4fp)\n\t\t\t\tvalues [ins->dreg] = LLVMConstReal (LLVMFloatType (), *(float*)ins->inst_p0);\n\t\t\telse\n\t\t\t\tvalues [ins->dreg] = LLVMConstFPExt (LLVMConstReal (LLVMFloatType (), *(float*)ins->inst_p0), LLVMDoubleType ());\n\t\t\tbreak;\n\t\tcase OP_DUMMY_ICONST:\n\t\t\tvalues [ins->dreg] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t\t\tbreak;\n\t\tcase OP_DUMMY_I8CONST:\n\t\t\tvalues [ins->dreg] = LLVMConstInt (LLVMInt64Type (), 0, FALSE);\n\t\t\tbreak;\n\t\tcase OP_DUMMY_R8CONST:\n\t\t\tvalues [ins->dreg] = LLVMConstReal (LLVMDoubleType (), 0.0f);\n\t\t\tbreak;\n\t\tcase OP_BR: {\n\t\t\tLLVMBasicBlockRef target_bb = get_bb (ctx, ins->inst_target_bb);\n\t\t\tLLVMBuildBr (builder, target_bb);\n\t\t\thas_terminator = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_SWITCH: {\n\t\t\tint i;\n\t\t\tLLVMValueRef v;\n\t\t\tchar bb_name [128];\n\t\t\tLLVMBasicBlockRef new_bb;\n\t\t\tLLVMBuilderRef new_builder;\n\n\t\t\t// The default branch is already handled\n\t\t\t// FIXME: Handle it here\n\n\t\t\t/* Start new bblock */\n\t\t\tsprintf (bb_name, \"SWITCH_DEFAULT_BB%d\", ctx->default_index ++);\n\t\t\tnew_bb = LLVMAppendBasicBlock (ctx->lmethod, bb_name);\n\n\t\t\tlhs = convert (ctx, lhs, LLVMInt32Type ());\n\t\t\tv = LLVMBuildSwitch (builder, lhs, new_bb, GPOINTER_TO_UINT (ins->klass));\n\t\t\tfor (i = 0; i < GPOINTER_TO_UINT (ins->klass); ++i) {\n\t\t\t\tMonoBasicBlock *target_bb = ins->inst_many_bb [i];\n\n\t\t\t\tLLVMAddCase (v, LLVMConstInt (LLVMInt32Type (), i, FALSE), get_bb (ctx, target_bb));\n\t\t\t}\n\n\t\t\tnew_builder = create_builder (ctx);\n\t\t\tLLVMPositionBuilderAtEnd (new_builder, new_bb);\n\t\t\tLLVMBuildUnreachable (new_builder);\n\n\t\t\thas_terminator = TRUE;\n\t\t\tg_assert (!ins->next);\n\t\t\t\t\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_SETRET:\n\t\t\tswitch (linfo->ret.storage) {\n\t\t\tcase LLVMArgVtypeInReg: {\n\t\t\t\tLLVMTypeRef ret_type = LLVMGetReturnType (LLVMGetElementType (LLVMTypeOf (method)));\n\t\t\t\tLLVMValueRef val, addr, retval;\n\t\t\t\tint i;\n\n\t\t\t\tretval = LLVMGetUndef (ret_type);\n\n\t\t\t\tif (!addresses [ins->sreg1]) {\n\t\t\t\t\t/*\n\t\t\t\t\t * The return type is an LLVM vector type, have to convert between it and the\n\t\t\t\t\t * real return type which is a struct type.\n\t\t\t\t\t */\n\t\t\t\t\tg_assert (MONO_CLASS_IS_SIMD (ctx->cfg, mono_class_from_mono_type (sig->ret)));\n\t\t\t\t\t/* Convert to 2xi64 first */\n\t\t\t\t\tval = LLVMBuildBitCast (builder, values [ins->sreg1], LLVMVectorType (IntPtrType (), 2), \"\");\n\n\t\t\t\t\tfor (i = 0; i < 2; ++i) {\n\t\t\t\t\t\tif (linfo->ret.pair_storage [i] == LLVMArgInIReg) {\n\t\t\t\t\t\t\tretval = LLVMBuildInsertValue (builder, retval, LLVMBuildExtractElement (builder, val, LLVMConstInt (LLVMInt32Type (), i, FALSE), \"\"), i, \"\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tg_assert (linfo->ret.pair_storage [i] == LLVMArgNone);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taddr = LLVMBuildBitCast (builder, addresses [ins->sreg1], LLVMPointerType (ret_type, 0), \"\");\n\t\t\t\t\tfor (i = 0; i < 2; ++i) {\n\t\t\t\t\t\tif (linfo->ret.pair_storage [i] == LLVMArgInIReg) {\n\t\t\t\t\t\t\tLLVMValueRef indexes [2], part_addr;\n\n\t\t\t\t\t\t\tindexes [0] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t\t\t\t\t\t\tindexes [1] = LLVMConstInt (LLVMInt32Type (), i, FALSE);\n\t\t\t\t\t\t\tpart_addr = LLVMBuildGEP (builder, addr, indexes, 2, \"\");\n\n\t\t\t\t\t\t\tretval = LLVMBuildInsertValue (builder, retval, LLVMBuildLoad (builder, part_addr, \"\"), i, \"\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tg_assert (linfo->ret.pair_storage [i] == LLVMArgNone);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tLLVMBuildRet (builder, retval);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase LLVMArgVtypeAsScalar: {\n\t\t\t\tLLVMTypeRef ret_type = LLVMGetReturnType (LLVMGetElementType (LLVMTypeOf (method)));\n\t\t\t\tLLVMValueRef retval;\n\n\t\t\t\tg_assert (addresses [ins->sreg1]);\n\n\t\t\t\tretval = LLVMBuildLoad (builder, LLVMBuildBitCast (builder, addresses [ins->sreg1], LLVMPointerType (ret_type, 0), \"\"), \"\");\n\t\t\t\tLLVMBuildRet (builder, retval);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase LLVMArgVtypeByVal: {\n\t\t\t\tLLVMValueRef retval;\n\n\t\t\t\tg_assert (addresses [ins->sreg1]);\n\t\t\t\tretval = LLVMBuildLoad (builder, addresses [ins->sreg1], \"\");\n\t\t\t\tLLVMBuildRet (builder, retval);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase LLVMArgVtypeByRef: {\n\t\t\t\tLLVMBuildRetVoid (builder);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase LLVMArgGsharedvtFixed: {\n\t\t\t\tLLVMTypeRef ret_type = type_to_llvm_type (ctx, sig->ret);\n\t\t\t\t/* The return value is in lhs, need to store to the vret argument */\n\t\t\t\t/* sreg1 might not be set */\n\t\t\t\tif (lhs) {\n\t\t\t\t\tg_assert (cfg->vret_addr);\n\t\t\t\t\tg_assert (values [cfg->vret_addr->dreg]);\n\t\t\t\t\tLLVMBuildStore (builder, convert (ctx, lhs, ret_type), convert (ctx, values [cfg->vret_addr->dreg], LLVMPointerType (ret_type, 0)));\n\t\t\t\t}\n\t\t\t\tLLVMBuildRetVoid (builder);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase LLVMArgGsharedvtFixedVtype: {\n\t\t\t\t/* Already set */\n\t\t\t\tLLVMBuildRetVoid (builder);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase LLVMArgGsharedvtVariable: {\n\t\t\t\t/* Already set */\n\t\t\t\tLLVMBuildRetVoid (builder);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase LLVMArgVtypeRetAddr: {\n\t\t\t\tLLVMBuildRetVoid (builder);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase LLVMArgAsIArgs:\n\t\t\tcase LLVMArgFpStruct: {\n\t\t\t\tLLVMTypeRef ret_type = LLVMGetReturnType (LLVMGetElementType (LLVMTypeOf (method)));\n\t\t\t\tLLVMValueRef retval;\n\n\t\t\t\tg_assert (addresses [ins->sreg1]);\n\t\t\t\tretval = LLVMBuildLoad (builder, convert (ctx, addresses [ins->sreg1], LLVMPointerType (ret_type, 0)), \"\");\n\t\t\t\tLLVMBuildRet (builder, retval);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase LLVMArgNone:\n\t\t\tcase LLVMArgNormal: {\n\t\t\t\tif (!lhs || ctx->is_dead [ins->sreg1]) {\n\t\t\t\t\t/*\n\t\t\t\t\t * The method did not set its return value, probably because it\n\t\t\t\t\t * ends with a throw.\n\t\t\t\t\t */\n\t\t\t\t\tif (cfg->vret_addr)\n\t\t\t\t\t\tLLVMBuildRetVoid (builder);\n\t\t\t\t\telse\n\t\t\t\t\t\tLLVMBuildRet (builder, LLVMConstNull (type_to_llvm_type (ctx, sig->ret)));\n\t\t\t\t} else {\n\t\t\t\t\tLLVMBuildRet (builder, convert (ctx, lhs, type_to_llvm_type (ctx, sig->ret)));\n\t\t\t\t}\n\t\t\t\thas_terminator = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_ICOMPARE:\n\t\tcase OP_FCOMPARE:\n\t\tcase OP_RCOMPARE:\n\t\tcase OP_LCOMPARE:\n\t\tcase OP_COMPARE:\n\t\tcase OP_ICOMPARE_IMM:\n\t\tcase OP_LCOMPARE_IMM:\n\t\tcase OP_COMPARE_IMM: {\n\t\t\tCompRelation rel;\n\t\t\tLLVMValueRef cmp, args [16];\n\t\t\tgboolean likely = (ins->flags & MONO_INST_LIKELY) != 0;\n\n\t\t\tif (ins->next->opcode == OP_NOP)\n\t\t\t\tbreak;\n\n\t\t\tif (ins->next->opcode == OP_BR)\n\t\t\t\t/* The comparison result is not needed */\n\t\t\t\tcontinue;\n\n\t\t\trel = mono_opcode_to_cond (ins->next->opcode);\n\n\t\t\tif (ins->opcode == OP_ICOMPARE_IMM) {\n\t\t\t\tlhs = convert (ctx, lhs, LLVMInt32Type ());\n\t\t\t\trhs = LLVMConstInt (LLVMInt32Type (), ins->inst_imm, FALSE);\n\t\t\t}\n\t\t\tif (ins->opcode == OP_LCOMPARE_IMM) {\n\t\t\t\tlhs = convert (ctx, lhs, LLVMInt64Type ());\n\t\t\t\trhs = LLVMConstInt (LLVMInt64Type (), GET_LONG_IMM (ins), FALSE);\n\t\t\t}\n\t\t\tif (ins->opcode == OP_LCOMPARE) {\n\t\t\t\tlhs = convert (ctx, lhs, LLVMInt64Type ());\n\t\t\t\trhs = convert (ctx, rhs, LLVMInt64Type ());\n\t\t\t}\n\t\t\tif (ins->opcode == OP_ICOMPARE) {\n\t\t\t\tlhs = convert (ctx, lhs, LLVMInt32Type ());\n\t\t\t\trhs = convert (ctx, rhs, LLVMInt32Type ());\n\t\t\t}\n\n\t\t\tif (lhs && rhs) {\n\t\t\t\tif (LLVMGetTypeKind (LLVMTypeOf (lhs)) == LLVMPointerTypeKind)\n\t\t\t\t\trhs = convert (ctx, rhs, LLVMTypeOf (lhs));\n\t\t\t\telse if (LLVMGetTypeKind (LLVMTypeOf (rhs)) == LLVMPointerTypeKind)\n\t\t\t\t\tlhs = convert (ctx, lhs, LLVMTypeOf (rhs));\n\t\t\t}\n\n\t\t\t/* We use COMPARE+SETcc/Bcc, llvm uses SETcc+br cond */\n\t\t\tif (ins->opcode == OP_FCOMPARE) {\n\t\t\t\tcmp = LLVMBuildFCmp (builder, fpcond_to_llvm_cond [rel], convert (ctx, lhs, LLVMDoubleType ()), convert (ctx, rhs, LLVMDoubleType ()), \"\");\n\t\t\t} else if (ins->opcode == OP_RCOMPARE) {\n\t\t\t\tcmp = LLVMBuildFCmp (builder, fpcond_to_llvm_cond [rel], convert (ctx, lhs, LLVMFloatType ()), convert (ctx, rhs, LLVMFloatType ()), \"\");\n\t\t\t} else if (ins->opcode == OP_COMPARE_IMM) {\n\t\t\t\tif (LLVMGetTypeKind (LLVMTypeOf (lhs)) == LLVMPointerTypeKind && ins->inst_imm == 0)\n\t\t\t\t\tcmp = LLVMBuildICmp (builder, cond_to_llvm_cond [rel], lhs, LLVMConstNull (LLVMTypeOf (lhs)), \"\");\n\t\t\t\telse\n\t\t\t\t\tcmp = LLVMBuildICmp (builder, cond_to_llvm_cond [rel], convert (ctx, lhs, IntPtrType ()), LLVMConstInt (IntPtrType (), ins->inst_imm, FALSE), \"\");\n\t\t\t} else if (ins->opcode == OP_LCOMPARE_IMM) {\n\t\t\t\tif (SIZEOF_REGISTER == 4 && COMPILE_LLVM (cfg))  {\n\t\t\t\t\t/* The immediate is encoded in two fields */\n\t\t\t\t\tguint64 l = ((guint64)(guint32)ins->inst_offset << 32) | ((guint32)ins->inst_imm);\n\t\t\t\t\tcmp = LLVMBuildICmp (builder, cond_to_llvm_cond [rel], convert (ctx, lhs, LLVMInt64Type ()), LLVMConstInt (LLVMInt64Type (), l, FALSE), \"\");\n\t\t\t\t} else {\n\t\t\t\t\tcmp = LLVMBuildICmp (builder, cond_to_llvm_cond [rel], convert (ctx, lhs, LLVMInt64Type ()), LLVMConstInt (LLVMInt64Type (), ins->inst_imm, FALSE), \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ins->opcode == OP_COMPARE) {\n\t\t\t\tif (LLVMGetTypeKind (LLVMTypeOf (lhs)) == LLVMPointerTypeKind && LLVMTypeOf (lhs) == LLVMTypeOf (rhs))\n\t\t\t\t\tcmp = LLVMBuildICmp (builder, cond_to_llvm_cond [rel], lhs, rhs, \"\");\n\t\t\t\telse\n\t\t\t\t\tcmp = LLVMBuildICmp (builder, cond_to_llvm_cond [rel], convert (ctx, lhs, IntPtrType ()), convert (ctx, rhs, IntPtrType ()), \"\");\n\t\t\t} else\n\t\t\t\tcmp = LLVMBuildICmp (builder, cond_to_llvm_cond [rel], lhs, rhs, \"\");\n\n\t\t\tif (likely) {\n\t\t\t\targs [0] = cmp;\n\t\t\t\targs [1] = LLVMConstInt (LLVMInt1Type (), 1, FALSE);\n\t\t\t\tcmp = LLVMBuildCall (ctx->builder, get_intrinsic (ctx, \"llvm.expect.i1\"), args, 2, \"\");\n\t\t\t}\n\n\t\t\tif (MONO_IS_COND_BRANCH_OP (ins->next)) {\n\t\t\t\tif (ins->next->inst_true_bb == ins->next->inst_false_bb) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If the target bb contains PHI instructions, LLVM requires\n\t\t\t\t\t * two PHI entries for this bblock, while we only generate one.\n\t\t\t\t\t * So convert this to an unconditional bblock. (bxc #171).\n\t\t\t\t\t */\n\t\t\t\t\tLLVMBuildBr (builder, get_bb (ctx, ins->next->inst_true_bb));\n\t\t\t\t} else {\n\t\t\t\t\tLLVMBuildCondBr (builder, cmp, get_bb (ctx, ins->next->inst_true_bb), get_bb (ctx, ins->next->inst_false_bb));\n\t\t\t\t}\n\t\t\t\thas_terminator = TRUE;\n\t\t\t} else if (MONO_IS_SETCC (ins->next)) {\n\t\t\t\tsprintf (dname_buf, \"t%d\", ins->next->dreg);\n\t\t\t\tdname = dname_buf;\n\t\t\t\tvalues [ins->next->dreg] = LLVMBuildZExt (builder, cmp, LLVMInt32Type (), dname);\n\n\t\t\t\t/* Add stores for volatile variables */\n\t\t\t\temit_volatile_store (ctx, ins->next->dreg);\n\t\t\t} else if (MONO_IS_COND_EXC (ins->next)) {\n\t\t\t\temit_cond_system_exception (ctx, bb, (const char*)ins->next->inst_p1, cmp);\n\t\t\t\tif (!ctx_ok (ctx))\n\t\t\t\t\tbreak;\n\t\t\t\tbuilder = ctx->builder;\n\t\t\t} else {\n\t\t\t\tset_failure (ctx, \"next\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tins = ins->next;\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_FCEQ:\n\t\tcase OP_FCNEQ:\n\t\tcase OP_FCLT:\n\t\tcase OP_FCLT_UN:\n\t\tcase OP_FCGT:\n\t\tcase OP_FCGT_UN:\n\t\tcase OP_FCGE:\n\t\tcase OP_FCLE: {\n\t\t\tCompRelation rel;\n\t\t\tLLVMValueRef cmp;\n\n\t\t\trel = mono_opcode_to_cond (ins->opcode);\n\n\t\t\tcmp = LLVMBuildFCmp (builder, fpcond_to_llvm_cond [rel], convert (ctx, lhs, LLVMDoubleType ()), convert (ctx, rhs, LLVMDoubleType ()), \"\");\n\t\t\tvalues [ins->dreg] = LLVMBuildZExt (builder, cmp, LLVMInt32Type (), dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_RCEQ:\n\t\tcase OP_RCLT:\n\t\tcase OP_RCLT_UN:\n\t\tcase OP_RCGT:\n\t\tcase OP_RCGT_UN: {\n\t\t\tCompRelation rel;\n\t\t\tLLVMValueRef cmp;\n\n\t\t\trel = mono_opcode_to_cond (ins->opcode);\n\n\t\t\tcmp = LLVMBuildFCmp (builder, fpcond_to_llvm_cond [rel], convert (ctx, lhs, LLVMFloatType ()), convert (ctx, rhs, LLVMFloatType ()), \"\");\n\t\t\tvalues [ins->dreg] = LLVMBuildZExt (builder, cmp, LLVMInt32Type (), dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_PHI:\n\t\tcase OP_FPHI:\n\t\tcase OP_VPHI:\n\t\tcase OP_XPHI: {\n\t\t\tint i;\n\t\t\tgboolean empty = TRUE;\n\n\t\t\t/* Check that all input bblocks really branch to us */\n\t\t\tfor (i = 0; i < bb->in_count; ++i) {\n\t\t\t\tif (bb->in_bb [i]->last_ins && bb->in_bb [i]->last_ins->opcode == OP_NOT_REACHED)\n\t\t\t\t\tins->inst_phi_args [i + 1] = -1;\n\t\t\t\telse\n\t\t\t\t\tempty = FALSE;\n\t\t\t}\n\n\t\t\tif (empty) {\n\t\t\t\t/* LLVM doesn't like phi instructions with zero operands */\n\t\t\t\tctx->is_dead [ins->dreg] = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\t\t\n\n\t\t\t/* Created earlier, insert it now */\n\t\t\tLLVMInsertIntoBuilder (builder, values [ins->dreg]);\n\n\t\t\tfor (i = 0; i < ins->inst_phi_args [0]; i++) {\n\t\t\t\tint sreg1 = ins->inst_phi_args [i + 1];\n\t\t\t\tint count, j;\n\n\t\t\t\t/* \n\t\t\t\t * Count the number of times the incoming bblock branches to us,\n\t\t\t\t * since llvm requires a separate entry for each.\n\t\t\t\t */\n\t\t\t\tif (bb->in_bb [i]->last_ins && bb->in_bb [i]->last_ins->opcode == OP_SWITCH) {\n\t\t\t\t\tMonoInst *switch_ins = bb->in_bb [i]->last_ins;\n\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tfor (j = 0; j < GPOINTER_TO_UINT (switch_ins->klass); ++j) {\n\t\t\t\t\t\tif (switch_ins->inst_many_bb [j] == bb)\n\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcount = 1;\n\t\t\t\t}\n\n\t\t\t\t/* Remember for later */\n\t\t\t\tfor (j = 0; j < count; ++j) {\n\t\t\t\t\tPhiNode *node = (PhiNode*)mono_mempool_alloc0 (ctx->mempool, sizeof (PhiNode));\n\t\t\t\t\tnode->bb = bb;\n\t\t\t\t\tnode->phi = ins;\n\t\t\t\t\tnode->in_bb = bb->in_bb [i];\n\t\t\t\t\tnode->sreg = sreg1;\n\t\t\t\t\tbblocks [bb->in_bb [i]->block_num].phi_nodes = g_slist_prepend_mempool (ctx->mempool, bblocks [bb->in_bb [i]->block_num].phi_nodes, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_MOVE:\n\t\tcase OP_LMOVE:\n\t\tcase OP_XMOVE:\n\t\tcase OP_SETFRET:\n\t\t\tg_assert (lhs);\n\t\t\tvalues [ins->dreg] = lhs;\n\t\t\tbreak;\n\t\tcase OP_FMOVE:\n\t\tcase OP_RMOVE: {\n\t\t\tMonoInst *var = get_vreg_to_inst (cfg, ins->dreg);\n\t\t\t\t\n\t\t\tg_assert (lhs);\n\t\t\tvalues [ins->dreg] = lhs;\n\n\t\t\tif (var && var->klass->byval_arg.type == MONO_TYPE_R4) {\n\t\t\t\t/* \n\t\t\t\t * This is added by the spilling pass in case of the JIT,\n\t\t\t\t * but we have to do it ourselves.\n\t\t\t\t */\n\t\t\t\tvalues [ins->dreg] = convert (ctx, values [ins->dreg], LLVMFloatType ());\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_MOVE_F_TO_I4: {\n\t\t\tvalues [ins->dreg] = LLVMBuildBitCast (builder, LLVMBuildFPTrunc (builder, lhs, LLVMFloatType (), \"\"), LLVMInt32Type (), \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_MOVE_I4_TO_F: {\n\t\t\tvalues [ins->dreg] = LLVMBuildFPExt (builder, LLVMBuildBitCast (builder, lhs, LLVMFloatType (), \"\"), LLVMDoubleType (), \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_MOVE_F_TO_I8: {\n\t\t\tvalues [ins->dreg] = LLVMBuildBitCast (builder, lhs, LLVMInt64Type (), \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_MOVE_I8_TO_F: {\n\t\t\tvalues [ins->dreg] = LLVMBuildBitCast (builder, lhs, LLVMDoubleType (), \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_IADD:\n\t\tcase OP_ISUB:\n\t\tcase OP_IAND:\n\t\tcase OP_IMUL:\n\t\tcase OP_IDIV:\n\t\tcase OP_IDIV_UN:\n\t\tcase OP_IREM:\n\t\tcase OP_IREM_UN:\n\t\tcase OP_IOR:\n\t\tcase OP_IXOR:\n\t\tcase OP_ISHL:\n\t\tcase OP_ISHR:\n\t\tcase OP_ISHR_UN:\n\t\tcase OP_FADD:\n\t\tcase OP_FSUB:\n\t\tcase OP_FMUL:\n\t\tcase OP_FDIV:\n\t\tcase OP_LADD:\n\t\tcase OP_LSUB:\n\t\tcase OP_LMUL:\n\t\tcase OP_LDIV:\n\t\tcase OP_LDIV_UN:\n\t\tcase OP_LREM:\n\t\tcase OP_LREM_UN:\n\t\tcase OP_LAND:\n\t\tcase OP_LOR:\n\t\tcase OP_LXOR:\n\t\tcase OP_LSHL:\n\t\tcase OP_LSHR:\n\t\tcase OP_LSHR_UN:\n\t\t\tlhs = convert (ctx, lhs, regtype_to_llvm_type (spec [MONO_INST_DEST]));\n\t\t\trhs = convert (ctx, rhs, regtype_to_llvm_type (spec [MONO_INST_DEST]));\n\n\t\t\temit_div_check (ctx, builder, bb, ins, lhs, rhs);\n\t\t\tif (!ctx_ok (ctx))\n\t\t\t\tbreak;\n\t\t\tbuilder = ctx->builder;\n\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_IADD:\n\t\t\tcase OP_LADD:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildAdd (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_ISUB:\n\t\t\tcase OP_LSUB:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildSub (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IMUL:\n\t\t\tcase OP_LMUL:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildMul (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IREM:\n\t\t\tcase OP_LREM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildSRem (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IREM_UN:\n\t\t\tcase OP_LREM_UN:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildURem (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IDIV:\n\t\t\tcase OP_LDIV:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildSDiv (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IDIV_UN:\n\t\t\tcase OP_LDIV_UN:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildUDiv (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_FDIV:\n\t\t\tcase OP_RDIV:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFDiv (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IAND:\n\t\t\tcase OP_LAND:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildAnd (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IOR:\n\t\t\tcase OP_LOR:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildOr (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IXOR:\n\t\t\tcase OP_LXOR:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildXor (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_ISHL:\n\t\t\tcase OP_LSHL:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildShl (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_ISHR:\n\t\t\tcase OP_LSHR:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildAShr (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_ISHR_UN:\n\t\t\tcase OP_LSHR_UN:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildLShr (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\n\t\t\tcase OP_FADD:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFAdd (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_FSUB:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFSub (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_FMUL:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFMul (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OP_RADD:\n\t\tcase OP_RSUB:\n\t\tcase OP_RMUL:\n\t\tcase OP_RDIV: {\n\t\t\tlhs = convert (ctx, lhs, LLVMFloatType ());\n\t\t\trhs = convert (ctx, rhs, LLVMFloatType ());\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_RADD:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFAdd (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_RSUB:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFSub (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_RMUL:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFMul (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_RDIV:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFDiv (builder, lhs, rhs, dname);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_IADD_IMM:\n\t\tcase OP_ISUB_IMM:\n\t\tcase OP_IMUL_IMM:\n\t\tcase OP_IREM_IMM:\n\t\tcase OP_IREM_UN_IMM:\n\t\tcase OP_IDIV_IMM:\n\t\tcase OP_IDIV_UN_IMM:\n\t\tcase OP_IAND_IMM:\n\t\tcase OP_IOR_IMM:\n\t\tcase OP_IXOR_IMM:\n\t\tcase OP_ISHL_IMM:\n\t\tcase OP_ISHR_IMM:\n\t\tcase OP_ISHR_UN_IMM:\n\t\tcase OP_LADD_IMM:\n\t\tcase OP_LSUB_IMM:\n\t\tcase OP_LMUL_IMM:\n\t\tcase OP_LREM_IMM:\n\t\tcase OP_LAND_IMM:\n\t\tcase OP_LOR_IMM:\n\t\tcase OP_LXOR_IMM:\n\t\tcase OP_LSHL_IMM:\n\t\tcase OP_LSHR_IMM:\n\t\tcase OP_LSHR_UN_IMM:\n\t\tcase OP_ADD_IMM:\n\t\tcase OP_AND_IMM:\n\t\tcase OP_MUL_IMM:\n\t\tcase OP_SHL_IMM:\n\t\tcase OP_SHR_IMM:\n\t\tcase OP_SHR_UN_IMM: {\n\t\t\tLLVMValueRef imm;\n\n\t\t\tif (spec [MONO_INST_SRC1] == 'l') {\n\t\t\t\timm = LLVMConstInt (LLVMInt64Type (), GET_LONG_IMM (ins), FALSE);\n\t\t\t} else {\n\t\t\t\timm = LLVMConstInt (LLVMInt32Type (), ins->inst_imm, FALSE);\n\t\t\t}\n\n\t\t\temit_div_check (ctx, builder, bb, ins, lhs, imm);\n\t\t\tif (!ctx_ok (ctx))\n\t\t\t\tbreak;\n\t\t\tbuilder = ctx->builder;\n\n#if SIZEOF_VOID_P == 4\n\t\t\tif (ins->opcode == OP_LSHL_IMM || ins->opcode == OP_LSHR_IMM || ins->opcode == OP_LSHR_UN_IMM)\n\t\t\t\timm = LLVMConstInt (LLVMInt32Type (), ins->inst_imm, FALSE);\n#endif\n\n\t\t\tif (LLVMGetTypeKind (LLVMTypeOf (lhs)) == LLVMPointerTypeKind)\n\t\t\t\tlhs = convert (ctx, lhs, IntPtrType ());\n\t\t\timm = convert (ctx, imm, LLVMTypeOf (lhs));\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_IADD_IMM:\n\t\t\tcase OP_LADD_IMM:\n\t\t\tcase OP_ADD_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildAdd (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_ISUB_IMM:\n\t\t\tcase OP_LSUB_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildSub (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IMUL_IMM:\n\t\t\tcase OP_MUL_IMM:\n\t\t\tcase OP_LMUL_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildMul (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IDIV_IMM:\n\t\t\tcase OP_LDIV_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildSDiv (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IDIV_UN_IMM:\n\t\t\tcase OP_LDIV_UN_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildUDiv (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IREM_IMM:\n\t\t\tcase OP_LREM_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildSRem (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IREM_UN_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildURem (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IAND_IMM:\n\t\t\tcase OP_LAND_IMM:\n\t\t\tcase OP_AND_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildAnd (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IOR_IMM:\n\t\t\tcase OP_LOR_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildOr (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_IXOR_IMM:\n\t\t\tcase OP_LXOR_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildXor (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_ISHL_IMM:\n\t\t\tcase OP_LSHL_IMM:\n\t\t\tcase OP_SHL_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildShl (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_ISHR_IMM:\n\t\t\tcase OP_LSHR_IMM:\n\t\t\tcase OP_SHR_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildAShr (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_ISHR_UN_IMM:\n\t\t\t\t/* This is used to implement conv.u4, so the lhs could be an i8 */\n\t\t\t\tlhs = convert (ctx, lhs, LLVMInt32Type ());\n\t\t\t\timm = convert (ctx, imm, LLVMInt32Type ());\n\t\t\t\tvalues [ins->dreg] = LLVMBuildLShr (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tcase OP_LSHR_UN_IMM:\n\t\t\tcase OP_SHR_UN_IMM:\n\t\t\t\tvalues [ins->dreg] = LLVMBuildLShr (builder, lhs, imm, dname);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_INEG:\n\t\t\tvalues [ins->dreg] = LLVMBuildSub (builder, LLVMConstInt (LLVMInt32Type (), 0, FALSE), convert (ctx, lhs, LLVMInt32Type ()), dname);\n\t\t\tbreak;\n\t\tcase OP_LNEG:\n\t\t\tvalues [ins->dreg] = LLVMBuildSub (builder, LLVMConstInt (LLVMInt64Type (), 0, FALSE), lhs, dname);\n\t\t\tbreak;\n\t\tcase OP_FNEG:\n\t\t\tlhs = convert (ctx, lhs, LLVMDoubleType ());\n\t\t\tvalues [ins->dreg] = LLVMBuildFSub (builder, LLVMConstReal (LLVMDoubleType (), 0.0), lhs, dname);\n\t\t\tbreak;\n\t\tcase OP_RNEG:\n\t\t\tlhs = convert (ctx, lhs, LLVMFloatType ());\n\t\t\tvalues [ins->dreg] = LLVMBuildFSub (builder, LLVMConstReal (LLVMFloatType (), 0.0), lhs, dname);\n\t\t\tbreak;\n\t\tcase OP_INOT: {\n\t\t\tguint32 v = 0xffffffff;\n\t\t\tvalues [ins->dreg] = LLVMBuildXor (builder, LLVMConstInt (LLVMInt32Type (), v, FALSE), convert (ctx, lhs, LLVMInt32Type ()), dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_LNOT: {\n\t\t\tguint64 v = 0xffffffffffffffffLL;\n\t\t\tvalues [ins->dreg] = LLVMBuildXor (builder, LLVMConstInt (LLVMInt64Type (), v, FALSE), lhs, dname);\n\t\t\tbreak;\n\t\t}\n#if defined(TARGET_X86) || defined(TARGET_AMD64)\n\t\tcase OP_X86_LEA: {\n\t\t\tLLVMValueRef v1, v2;\n\n\t\t\trhs = LLVMBuildSExt (builder, convert (ctx, rhs, LLVMInt32Type ()), LLVMInt64Type (), \"\");\n\n\t\t\tv1 = LLVMBuildMul (builder, convert (ctx, rhs, IntPtrType ()), LLVMConstInt (IntPtrType (), (1 << ins->backend.shift_amount), FALSE), \"\");\n\t\t\tv2 = LLVMBuildAdd (builder, convert (ctx, lhs, IntPtrType ()), v1, \"\");\n\t\t\tvalues [ins->dreg] = LLVMBuildAdd (builder, v2, LLVMConstInt (IntPtrType (), ins->inst_imm, FALSE), dname);\n\t\t\tbreak;\n\t\t}\n#endif\n\n\t\tcase OP_ICONV_TO_I1:\n\t\tcase OP_ICONV_TO_I2:\n\t\tcase OP_ICONV_TO_I4:\n\t\tcase OP_ICONV_TO_U1:\n\t\tcase OP_ICONV_TO_U2:\n\t\tcase OP_ICONV_TO_U4:\n\t\tcase OP_LCONV_TO_I1:\n\t\tcase OP_LCONV_TO_I2:\n\t\tcase OP_LCONV_TO_U1:\n\t\tcase OP_LCONV_TO_U2:\n\t\tcase OP_LCONV_TO_U4: {\n\t\t\tgboolean sign;\n\n\t\t\tsign = (ins->opcode == OP_ICONV_TO_I1) || (ins->opcode == OP_ICONV_TO_I2) || (ins->opcode == OP_ICONV_TO_I4) || (ins->opcode == OP_LCONV_TO_I1) || (ins->opcode == OP_LCONV_TO_I2);\n\n\t\t\t/* Have to do two casts since our vregs have type int */\n\t\t\tv = LLVMBuildTrunc (builder, lhs, op_to_llvm_type (ins->opcode), \"\");\n\t\t\tif (sign)\n\t\t\t\tvalues [ins->dreg] = LLVMBuildSExt (builder, v, LLVMInt32Type (), dname);\n\t\t\telse\n\t\t\t\tvalues [ins->dreg] = LLVMBuildZExt (builder, v, LLVMInt32Type (), dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_ICONV_TO_I8:\n\t\t\tvalues [ins->dreg] = LLVMBuildSExt (builder, lhs, LLVMInt64Type (), dname);\n\t\t\tbreak;\n\t\tcase OP_ICONV_TO_U8:\n\t\t\tvalues [ins->dreg] = LLVMBuildZExt (builder, lhs, LLVMInt64Type (), dname);\n\t\t\tbreak;\n\t\tcase OP_FCONV_TO_I4:\n\t\tcase OP_RCONV_TO_I4:\n\t\t\tvalues [ins->dreg] = LLVMBuildFPToSI (builder, lhs, LLVMInt32Type (), dname);\n\t\t\tbreak;\n\t\tcase OP_FCONV_TO_I1:\n\t\tcase OP_RCONV_TO_I1:\n\t\t\tvalues [ins->dreg] = LLVMBuildSExt (builder, LLVMBuildFPToSI (builder, lhs, LLVMInt8Type (), dname), LLVMInt32Type (), \"\");\n\t\t\tbreak;\n\t\tcase OP_FCONV_TO_U1:\n\t\tcase OP_RCONV_TO_U1:\n\t\t\tvalues [ins->dreg] = LLVMBuildZExt (builder, LLVMBuildTrunc (builder, LLVMBuildFPToUI (builder, lhs, IntPtrType (), dname), LLVMInt8Type (), \"\"), LLVMInt32Type (), \"\");\n\t\t\tbreak;\n\t\tcase OP_FCONV_TO_I2:\n\t\tcase OP_RCONV_TO_I2:\n\t\t\tvalues [ins->dreg] = LLVMBuildSExt (builder, LLVMBuildFPToSI (builder, lhs, LLVMInt16Type (), dname), LLVMInt32Type (), \"\");\n\t\t\tbreak;\n\t\tcase OP_FCONV_TO_U2:\n\t\tcase OP_RCONV_TO_U2:\n\t\t\tvalues [ins->dreg] = LLVMBuildZExt (builder, LLVMBuildFPToUI (builder, lhs, LLVMInt16Type (), dname), LLVMInt32Type (), \"\");\n\t\t\tbreak;\n\t\tcase OP_RCONV_TO_U4:\n\t\t\tvalues [ins->dreg] = LLVMBuildFPToUI (builder, lhs, LLVMInt32Type (), dname);\n\t\t\tbreak;\n\t\tcase OP_FCONV_TO_I8:\n\t\tcase OP_RCONV_TO_I8:\n\t\t\tvalues [ins->dreg] = LLVMBuildFPToSI (builder, lhs, LLVMInt64Type (), dname);\n\t\t\tbreak;\n\t\tcase OP_FCONV_TO_I:\n\t\t\tvalues [ins->dreg] = LLVMBuildFPToSI (builder, lhs, IntPtrType (), dname);\n\t\t\tbreak;\n\t\tcase OP_ICONV_TO_R8:\n\t\tcase OP_LCONV_TO_R8:\n\t\t\tvalues [ins->dreg] = LLVMBuildSIToFP (builder, lhs, LLVMDoubleType (), dname);\n\t\t\tbreak;\n\t\tcase OP_ICONV_TO_R_UN:\n\t\tcase OP_LCONV_TO_R_UN:\n\t\t\tvalues [ins->dreg] = LLVMBuildUIToFP (builder, lhs, LLVMDoubleType (), dname);\n\t\t\tbreak;\n#if SIZEOF_VOID_P == 4\n\t\tcase OP_LCONV_TO_U:\n#endif\n\t\tcase OP_LCONV_TO_I4:\n\t\t\tvalues [ins->dreg] = LLVMBuildTrunc (builder, lhs, LLVMInt32Type (), dname);\n\t\t\tbreak;\n\t\tcase OP_ICONV_TO_R4:\n\t\tcase OP_LCONV_TO_R4:\n\t\t\tv = LLVMBuildSIToFP (builder, lhs, LLVMFloatType (), \"\");\n\t\t\tif (cfg->r4fp)\n\t\t\t\tvalues [ins->dreg] = v;\n\t\t\telse\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFPExt (builder, v, LLVMDoubleType (), dname);\n\t\t\tbreak;\n\t\tcase OP_FCONV_TO_R4:\n\t\t\tv = LLVMBuildFPTrunc (builder, lhs, LLVMFloatType (), \"\");\n\t\t\tif (cfg->r4fp)\n\t\t\t\tvalues [ins->dreg] = v;\n\t\t\telse\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFPExt (builder, v, LLVMDoubleType (), dname);\n\t\t\tbreak;\n\t\tcase OP_RCONV_TO_R8:\n\t\t\tvalues [ins->dreg] = LLVMBuildFPExt (builder, lhs, LLVMDoubleType (), dname);\n\t\t\tbreak;\n\t\tcase OP_RCONV_TO_R4:\n\t\t\tvalues [ins->dreg] = lhs;\n\t\t\tbreak;\n\t\tcase OP_SEXT_I4:\n\t\t\tvalues [ins->dreg] = LLVMBuildSExt (builder, convert (ctx, lhs, LLVMInt32Type ()), LLVMInt64Type (), dname);\n\t\t\tbreak;\n\t\tcase OP_ZEXT_I4:\n\t\t\tvalues [ins->dreg] = LLVMBuildZExt (builder, convert (ctx, lhs, LLVMInt32Type ()), LLVMInt64Type (), dname);\n\t\t\tbreak;\n\t\tcase OP_TRUNC_I4:\n\t\t\tvalues [ins->dreg] = LLVMBuildTrunc (builder, lhs, LLVMInt32Type (), dname);\n\t\t\tbreak;\n\t\tcase OP_LOCALLOC_IMM: {\n\t\t\tLLVMValueRef v;\n\n\t\t\tguint32 size = ins->inst_imm;\n\t\t\tsize = (size + (MONO_ARCH_FRAME_ALIGNMENT - 1)) & ~ (MONO_ARCH_FRAME_ALIGNMENT - 1);\n\n\t\t\tv = mono_llvm_build_alloca (builder, LLVMInt8Type (), LLVMConstInt (LLVMInt32Type (), size, FALSE), MONO_ARCH_FRAME_ALIGNMENT, \"\");\n\n\t\t\tif (ins->flags & MONO_INST_INIT) {\n\t\t\t\tLLVMValueRef args [5];\n\n\t\t\t\targs [0] = v;\n\t\t\t\targs [1] = LLVMConstInt (LLVMInt8Type (), 0, FALSE);\n\t\t\t\targs [2] = LLVMConstInt (LLVMInt32Type (), size, FALSE);\n\t\t\t\targs [3] = LLVMConstInt (LLVMInt32Type (), MONO_ARCH_FRAME_ALIGNMENT, FALSE);\n\t\t\t\targs [4] = LLVMConstInt (LLVMInt1Type (), 0, FALSE);\n\t\t\t\tLLVMBuildCall (builder, get_intrinsic (ctx, \"llvm.memset.p0i8.i32\"), args, 5, \"\");\n\t\t\t}\n\n\t\t\tvalues [ins->dreg] = v;\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_LOCALLOC: {\n\t\t\tLLVMValueRef v, size;\n\t\t\t\t\n\t\t\tsize = LLVMBuildAnd (builder, LLVMBuildAdd (builder, convert (ctx, lhs, LLVMInt32Type ()), LLVMConstInt (LLVMInt32Type (), MONO_ARCH_FRAME_ALIGNMENT - 1, FALSE), \"\"), LLVMConstInt (LLVMInt32Type (), ~ (MONO_ARCH_FRAME_ALIGNMENT - 1), FALSE), \"\");\n\n\t\t\tv = mono_llvm_build_alloca (builder, LLVMInt8Type (), size, MONO_ARCH_FRAME_ALIGNMENT, \"\");\n\n\t\t\tif (ins->flags & MONO_INST_INIT) {\n\t\t\t\tLLVMValueRef args [5];\n\n\t\t\t\targs [0] = v;\n\t\t\t\targs [1] = LLVMConstInt (LLVMInt8Type (), 0, FALSE);\n\t\t\t\targs [2] = size;\n\t\t\t\targs [3] = LLVMConstInt (LLVMInt32Type (), MONO_ARCH_FRAME_ALIGNMENT, FALSE);\n\t\t\t\targs [4] = LLVMConstInt (LLVMInt1Type (), 0, FALSE);\n\t\t\t\tLLVMBuildCall (builder, get_intrinsic (ctx, \"llvm.memset.p0i8.i32\"), args, 5, \"\");\n\t\t\t}\n\t\t\tvalues [ins->dreg] = v;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_LOADI1_MEMBASE:\n\t\tcase OP_LOADU1_MEMBASE:\n\t\tcase OP_LOADI2_MEMBASE:\n\t\tcase OP_LOADU2_MEMBASE:\n\t\tcase OP_LOADI4_MEMBASE:\n\t\tcase OP_LOADU4_MEMBASE:\n\t\tcase OP_LOADI8_MEMBASE:\n\t\tcase OP_LOADR4_MEMBASE:\n\t\tcase OP_LOADR8_MEMBASE:\n\t\tcase OP_LOAD_MEMBASE:\n\t\tcase OP_LOADI8_MEM:\n\t\tcase OP_LOADU1_MEM:\n\t\tcase OP_LOADU2_MEM:\n\t\tcase OP_LOADI4_MEM:\n\t\tcase OP_LOADU4_MEM:\n\t\tcase OP_LOAD_MEM: {\n\t\t\tint size = 8;\n\t\t\tLLVMValueRef base, index, addr;\n\t\t\tLLVMTypeRef t;\n\t\t\tgboolean sext = FALSE, zext = FALSE;\n\t\t\tgboolean is_volatile = (ins->flags & MONO_INST_FAULT);\n\n\t\t\tt = load_store_to_llvm_type (ins->opcode, &size, &sext, &zext);\n\n\t\t\tif (sext || zext)\n\t\t\t\tdname = (char*)\"\";\n\n\t\t\tif ((ins->opcode == OP_LOADI8_MEM) || (ins->opcode == OP_LOAD_MEM) || (ins->opcode == OP_LOADI4_MEM) || (ins->opcode == OP_LOADU4_MEM) || (ins->opcode == OP_LOADU1_MEM) || (ins->opcode == OP_LOADU2_MEM)) {\n\t\t\t\taddr = LLVMConstInt (IntPtrType (), ins->inst_imm, FALSE);\n\t\t\t\tbase = addr;\n\t\t\t} else {\n\t\t\t\t/* _MEMBASE */\n\t\t\t\tbase = lhs;\n\n\t\t\t\tif (ins->inst_offset == 0) {\n\t\t\t\t\taddr = base;\n\t\t\t\t} else if (ins->inst_offset % size != 0) {\n\t\t\t\t\t/* Unaligned load */\n\t\t\t\t\tindex = LLVMConstInt (LLVMInt32Type (), ins->inst_offset, FALSE);\n\t\t\t\t\taddr = LLVMBuildGEP (builder, convert (ctx, base, LLVMPointerType (LLVMInt8Type (), 0)), &index, 1, \"\");\n\t\t\t\t} else {\n\t\t\t\t\tindex = LLVMConstInt (LLVMInt32Type (), ins->inst_offset / size, FALSE);\n\t\t\t\t\taddr = LLVMBuildGEP (builder, convert (ctx, base, LLVMPointerType (t, 0)), &index, 1, \"\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taddr = convert (ctx, addr, LLVMPointerType (t, 0));\n\n\t\t\tvalues [ins->dreg] = emit_load_general (ctx, bb, &builder, size, addr, base, dname, is_volatile, LLVM_BARRIER_NONE);\n\n\t\t\tif (!is_volatile && (ins->flags & MONO_INST_INVARIANT_LOAD)) {\n\t\t\t\t/*\n\t\t\t\t * These will signal LLVM that these loads do not alias any stores, and\n\t\t\t\t * they can't fail, allowing them to be hoisted out of loops.\n\t\t\t\t */\n\t\t\t\tset_invariant_load_flag (values [ins->dreg]);\n#if LLVM_API_VERSION < 100\n\t\t\t\tset_metadata_flag (values [ins->dreg], \"mono.nofail.load\");\n#endif\n\t\t\t}\n\n\t\t\tif (sext)\n\t\t\t\tvalues [ins->dreg] = LLVMBuildSExt (builder, values [ins->dreg], LLVMInt32Type (), dname);\n\t\t\telse if (zext)\n\t\t\t\tvalues [ins->dreg] = LLVMBuildZExt (builder, values [ins->dreg], LLVMInt32Type (), dname);\n\t\t\telse if (!cfg->r4fp && ins->opcode == OP_LOADR4_MEMBASE)\n\t\t\t\tvalues [ins->dreg] = LLVMBuildFPExt (builder, values [ins->dreg], LLVMDoubleType (), dname);\n\t\t\tbreak;\n\t\t}\n\t\t\t\t\n\t\tcase OP_STOREI1_MEMBASE_REG:\n\t\tcase OP_STOREI2_MEMBASE_REG:\n\t\tcase OP_STOREI4_MEMBASE_REG:\n\t\tcase OP_STOREI8_MEMBASE_REG:\n\t\tcase OP_STORER4_MEMBASE_REG:\n\t\tcase OP_STORER8_MEMBASE_REG:\n\t\tcase OP_STORE_MEMBASE_REG: {\n\t\t\tint size = 8;\n\t\t\tLLVMValueRef index, addr, base;\n\t\t\tLLVMTypeRef t;\n\t\t\tgboolean sext = FALSE, zext = FALSE;\n\t\t\tgboolean is_volatile = (ins->flags & MONO_INST_FAULT);\n\n\t\t\tif (!values [ins->inst_destbasereg]) {\n\t\t\t\tset_failure (ctx, \"inst_destbasereg\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tt = load_store_to_llvm_type (ins->opcode, &size, &sext, &zext);\n\n\t\t\tbase = values [ins->inst_destbasereg];\n\t\t\tif (ins->inst_offset % size != 0) {\n\t\t\t\t/* Unaligned store */\n\t\t\t\tindex = LLVMConstInt (LLVMInt32Type (), ins->inst_offset, FALSE);\n\t\t\t\taddr = LLVMBuildGEP (builder, convert (ctx, base, LLVMPointerType (LLVMInt8Type (), 0)), &index, 1, \"\");\n\t\t\t} else {\n\t\t\t\tindex = LLVMConstInt (LLVMInt32Type (), ins->inst_offset / size, FALSE);\t\t\t\t\n\t\t\t\taddr = LLVMBuildGEP (builder, convert (ctx, base, LLVMPointerType (t, 0)), &index, 1, \"\");\n\t\t\t}\n\t\t\temit_store (ctx, bb, &builder, size, convert (ctx, values [ins->sreg1], t), convert (ctx, addr, LLVMPointerType (t, 0)), base, is_volatile);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_STOREI1_MEMBASE_IMM:\n\t\tcase OP_STOREI2_MEMBASE_IMM:\n\t\tcase OP_STOREI4_MEMBASE_IMM:\n\t\tcase OP_STOREI8_MEMBASE_IMM:\n\t\tcase OP_STORE_MEMBASE_IMM: {\n\t\t\tint size = 8;\n\t\t\tLLVMValueRef index, addr, base;\n\t\t\tLLVMTypeRef t;\n\t\t\tgboolean sext = FALSE, zext = FALSE;\n\t\t\tgboolean is_volatile = (ins->flags & MONO_INST_FAULT);\n\n\t\t\tt = load_store_to_llvm_type (ins->opcode, &size, &sext, &zext);\n\n\t\t\tbase = values [ins->inst_destbasereg];\n\t\t\tif (ins->inst_offset % size != 0) {\n\t\t\t\t/* Unaligned store */\n\t\t\t\tindex = LLVMConstInt (LLVMInt32Type (), ins->inst_offset, FALSE);\n\t\t\t\taddr = LLVMBuildGEP (builder, convert (ctx, base, LLVMPointerType (LLVMInt8Type (), 0)), &index, 1, \"\");\n\t\t\t} else {\n\t\t\t\tindex = LLVMConstInt (LLVMInt32Type (), ins->inst_offset / size, FALSE);\t\t\t\t\n\t\t\t\taddr = LLVMBuildGEP (builder, convert (ctx, base, LLVMPointerType (t, 0)), &index, 1, \"\");\n\t\t\t}\n\t\t\temit_store (ctx, bb, &builder, size, convert (ctx, LLVMConstInt (IntPtrType (), ins->inst_imm, FALSE), t), convert (ctx, addr, LLVMPointerType (t, 0)), base, is_volatile);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_CHECK_THIS:\n\t\t\temit_load_general (ctx, bb, &builder, sizeof (gpointer), convert (ctx, lhs, LLVMPointerType (IntPtrType (), 0)), lhs, \"\", TRUE, LLVM_BARRIER_NONE);\n\t\t\tbreak;\n\t\tcase OP_OUTARG_VTRETADDR:\n\t\t\tbreak;\n\t\tcase OP_VOIDCALL:\n\t\tcase OP_CALL:\n\t\tcase OP_LCALL:\n\t\tcase OP_FCALL:\n\t\tcase OP_RCALL:\n\t\tcase OP_VCALL:\n\t\tcase OP_VOIDCALL_MEMBASE:\n\t\tcase OP_CALL_MEMBASE:\n\t\tcase OP_LCALL_MEMBASE:\n\t\tcase OP_FCALL_MEMBASE:\n\t\tcase OP_RCALL_MEMBASE:\n\t\tcase OP_VCALL_MEMBASE:\n\t\tcase OP_VOIDCALL_REG:\n\t\tcase OP_CALL_REG:\n\t\tcase OP_LCALL_REG:\n\t\tcase OP_FCALL_REG:\n\t\tcase OP_RCALL_REG:\n\t\tcase OP_VCALL_REG: {\n\t\t\tprocess_call (ctx, bb, &builder, ins);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_AOTCONST: {\n\t\t\tguint32 got_offset;\n\t\t\tLLVMValueRef indexes [2];\n\t\t\tMonoJumpInfo *tmp_ji, *ji;\n\t\t\tLLVMValueRef got_entry_addr;\n\t\t\tchar *name;\n\n\t\t\t/* \n\t\t\t * FIXME: Can't allocate from the cfg mempool since that is freed if\n\t\t\t * the LLVM compile fails.\n\t\t\t */\n\t\t\ttmp_ji = g_new0 (MonoJumpInfo, 1);\n\t\t\ttmp_ji->type = (MonoJumpInfoType)ins->inst_c1;\n\t\t\ttmp_ji->data.target = ins->inst_p0;\n\n\t\t\tji = mono_aot_patch_info_dup (tmp_ji);\n\t\t\tg_free (tmp_ji);\n\n\t\t\tif (ji->type == MONO_PATCH_INFO_ICALL_ADDR) {\n\t\t\t\tchar *symbol = mono_aot_get_direct_call_symbol (MONO_PATCH_INFO_ICALL_ADDR_CALL, ji->data.target);\n\t\t\t\tif (symbol) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Avoid emitting a got entry for these since the method is directly called, and it might not be\n\t\t\t\t\t * resolvable at runtime using dlsym ().\n\t\t\t\t\t */\n\t\t\t\t\tg_free (symbol);\n\t\t\t\t\tvalues [ins->dreg] = LLVMConstInt (IntPtrType (), 0, FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tji->next = cfg->patch_info;\n\t\t\tcfg->patch_info = ji;\n\t\t\t\t   \n\t\t\t//mono_add_patch_info (cfg, 0, (MonoJumpInfoType)ins->inst_i1, ins->inst_p0);\n\t\t\tgot_offset = mono_aot_get_got_offset (cfg->patch_info);\n\t\t\tctx->module->max_got_offset = MAX (ctx->module->max_got_offset, got_offset);\n\t\t\tif (!mono_aot_is_shared_got_offset (got_offset)) {\n\t\t\t\t//mono_print_ji (ji);\n\t\t\t\t//printf (\"\\n\");\n\t\t\t\tctx->has_got_access = TRUE;\n\t\t\t}\n \n\t\t\tindexes [0] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t\t\tindexes [1] = LLVMConstInt (LLVMInt32Type (), (gssize)got_offset, FALSE);\n\t\t\tgot_entry_addr = LLVMBuildGEP (builder, ctx->module->got_var, indexes, 2, \"\");\n\n\t\t\tname = get_aotconst_name (ji->type, ji->data.target, got_offset);\n\t\t\tvalues [ins->dreg] = LLVMBuildLoad (builder, got_entry_addr, name);\n\t\t\tg_free (name);\n\t\t\t/* Can't use this in llvmonly mode since the got slots are initialized by the methods themselves */\n\t\t\tif (!cfg->llvm_only)\n\t\t\t\tset_invariant_load_flag (values [ins->dreg]);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_NOT_REACHED:\n\t\t\tLLVMBuildUnreachable (builder);\n\t\t\thas_terminator = TRUE;\n\t\t\tg_assert (bb->block_num < cfg->max_block_num);\n\t\t\tctx->unreachable [bb->block_num] = TRUE;\n\t\t\t/* Might have instructions after this */\n\t\t\twhile (ins->next) {\n\t\t\t\tMonoInst *next = ins->next;\n\t\t\t\t/* \n\t\t\t\t * FIXME: If later code uses the regs defined by these instructions,\n\t\t\t\t * compilation will fail.\n\t\t\t\t */\n\t\t\t\tMONO_DELETE_INS (bb, next);\n\t\t\t}\t\t\t\t\n\t\t\tbreak;\n\t\tcase OP_LDADDR: {\n\t\t\tMonoInst *var = ins->inst_i0;\n\n\t\t\tif (var->opcode == OP_VTARG_ADDR) {\n\t\t\t\t/* The variable contains the vtype address */\n\t\t\t\tvalues [ins->dreg] = values [var->dreg];\n\t\t\t} else if (var->opcode == OP_GSHAREDVT_LOCAL) {\n\t\t\t\tvalues [ins->dreg] = emit_gsharedvt_ldaddr (ctx, var->dreg);\n\t\t\t} else {\n\t\t\t\tvalues [ins->dreg] = addresses [var->dreg];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_SIN: {\n\t\t\tLLVMValueRef args [1];\n\n\t\t\targs [0] = convert (ctx, lhs, LLVMDoubleType ());\n\t\t\tvalues [ins->dreg] = LLVMBuildCall (builder, get_intrinsic (ctx, \"llvm.sin.f64\"), args, 1, dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_COS: {\n\t\t\tLLVMValueRef args [1];\n\n\t\t\targs [0] = convert (ctx, lhs, LLVMDoubleType ());\n\t\t\tvalues [ins->dreg] = LLVMBuildCall (builder, get_intrinsic (ctx, \"llvm.cos.f64\"), args, 1, dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_SQRT: {\n\t\t\tLLVMValueRef args [1];\n\n\t\t\targs [0] = convert (ctx, lhs, LLVMDoubleType ());\n\t\t\tvalues [ins->dreg] = LLVMBuildCall (builder, get_intrinsic (ctx, \"llvm.sqrt.f64\"), args, 1, dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_ABS: {\n\t\t\tLLVMValueRef args [1];\n\n\t\t\targs [0] = convert (ctx, lhs, LLVMDoubleType ());\n\t\t\tvalues [ins->dreg] = LLVMBuildCall (builder, get_intrinsic (ctx, \"fabs\"), args, 1, dname);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_IMIN:\n\t\tcase OP_LMIN:\n\t\tcase OP_IMAX:\n\t\tcase OP_LMAX:\n\t\tcase OP_IMIN_UN:\n\t\tcase OP_LMIN_UN:\n\t\tcase OP_IMAX_UN:\n\t\tcase OP_LMAX_UN: {\n\t\t\tLLVMValueRef v;\n\n\t\t\tlhs = convert (ctx, lhs, regtype_to_llvm_type (spec [MONO_INST_DEST]));\n\t\t\trhs = convert (ctx, rhs, regtype_to_llvm_type (spec [MONO_INST_DEST]));\n\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_IMIN:\n\t\t\tcase OP_LMIN:\n\t\t\t\tv = LLVMBuildICmp (builder, LLVMIntSLE, lhs, rhs, \"\");\n\t\t\t\tbreak;\n\t\t\tcase OP_IMAX:\n\t\t\tcase OP_LMAX:\n\t\t\t\tv = LLVMBuildICmp (builder, LLVMIntSGE, lhs, rhs, \"\");\n\t\t\t\tbreak;\n\t\t\tcase OP_IMIN_UN:\n\t\t\tcase OP_LMIN_UN:\n\t\t\t\tv = LLVMBuildICmp (builder, LLVMIntULE, lhs, rhs, \"\");\n\t\t\t\tbreak;\n\t\t\tcase OP_IMAX_UN:\n\t\t\tcase OP_LMAX_UN:\n\t\t\t\tv = LLVMBuildICmp (builder, LLVMIntUGE, lhs, rhs, \"\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalues [ins->dreg] = LLVMBuildSelect (builder, v, lhs, rhs, dname);\n\t\t\tbreak;\n\t\t}\n\n/*\n * See the ARM64 comment in mono/utils/atomic.h for an explanation of why this\n * hack is necessary (for now).\n */\n#ifdef TARGET_ARM64\n#define ARM64_ATOMIC_FENCE_FIX mono_llvm_build_fence (builder, LLVM_BARRIER_SEQ)\n#else\n#define ARM64_ATOMIC_FENCE_FIX\n#endif\n\n\t\tcase OP_ATOMIC_EXCHANGE_I4:\n\t\tcase OP_ATOMIC_EXCHANGE_I8: {\n\t\t\tLLVMValueRef args [2];\n\t\t\tLLVMTypeRef t;\n\t\t\t\t\n\t\t\tif (ins->opcode == OP_ATOMIC_EXCHANGE_I4)\n\t\t\t\tt = LLVMInt32Type ();\n\t\t\telse\n\t\t\t\tt = LLVMInt64Type ();\n\n\t\t\tg_assert (ins->inst_offset == 0);\n\n\t\t\targs [0] = convert (ctx, lhs, LLVMPointerType (t, 0));\n\t\t\targs [1] = convert (ctx, rhs, t);\n\n\t\t\tARM64_ATOMIC_FENCE_FIX;\n\t\t\tvalues [ins->dreg] = mono_llvm_build_atomic_rmw (builder, LLVM_ATOMICRMW_OP_XCHG, args [0], args [1]);\n\t\t\tARM64_ATOMIC_FENCE_FIX;\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_ATOMIC_ADD_I4:\n\t\tcase OP_ATOMIC_ADD_I8: {\n\t\t\tLLVMValueRef args [2];\n\t\t\tLLVMTypeRef t;\n\t\t\t\t\n\t\t\tif (ins->opcode == OP_ATOMIC_ADD_I4)\n\t\t\t\tt = LLVMInt32Type ();\n\t\t\telse\n\t\t\t\tt = LLVMInt64Type ();\n\n\t\t\tg_assert (ins->inst_offset == 0);\n\n\t\t\targs [0] = convert (ctx, lhs, LLVMPointerType (t, 0));\n\t\t\targs [1] = convert (ctx, rhs, t);\n\t\t\tARM64_ATOMIC_FENCE_FIX;\n\t\t\tvalues [ins->dreg] = LLVMBuildAdd (builder, mono_llvm_build_atomic_rmw (builder, LLVM_ATOMICRMW_OP_ADD, args [0], args [1]), args [1], dname);\n\t\t\tARM64_ATOMIC_FENCE_FIX;\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_ATOMIC_CAS_I4:\n\t\tcase OP_ATOMIC_CAS_I8: {\n\t\t\tLLVMValueRef args [3], val;\n\t\t\tLLVMTypeRef t;\n\t\t\t\t\n\t\t\tif (ins->opcode == OP_ATOMIC_CAS_I4)\n\t\t\t\tt = LLVMInt32Type ();\n\t\t\telse\n\t\t\t\tt = LLVMInt64Type ();\n\n\t\t\targs [0] = convert (ctx, lhs, LLVMPointerType (t, 0));\n\t\t\t/* comparand */\n\t\t\targs [1] = convert (ctx, values [ins->sreg3], t);\n\t\t\t/* new value */\n\t\t\targs [2] = convert (ctx, values [ins->sreg2], t);\n\t\t\tARM64_ATOMIC_FENCE_FIX;\n\t\t\tval = mono_llvm_build_cmpxchg (builder, args [0], args [1], args [2]);\n\t\t\tARM64_ATOMIC_FENCE_FIX;\n\t\t\t/* cmpxchg returns a pair */\n\t\t\tvalues [ins->dreg] = LLVMBuildExtractValue (builder, val, 0, \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_MEMORY_BARRIER: {\n\t\t\tmono_llvm_build_fence (builder, (BarrierKind) ins->backend.memory_barrier_kind);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_ATOMIC_LOAD_I1:\n\t\tcase OP_ATOMIC_LOAD_I2:\n\t\tcase OP_ATOMIC_LOAD_I4:\n\t\tcase OP_ATOMIC_LOAD_I8:\n\t\tcase OP_ATOMIC_LOAD_U1:\n\t\tcase OP_ATOMIC_LOAD_U2:\n\t\tcase OP_ATOMIC_LOAD_U4:\n\t\tcase OP_ATOMIC_LOAD_U8:\n\t\tcase OP_ATOMIC_LOAD_R4:\n\t\tcase OP_ATOMIC_LOAD_R8: {\n#if LLVM_API_VERSION > 100\n\t\t\tint size;\n\t\t\tgboolean sext, zext;\n\t\t\tLLVMTypeRef t;\n\t\t\tgboolean is_volatile = (ins->flags & MONO_INST_FAULT);\n\t\t\tBarrierKind barrier = (BarrierKind) ins->backend.memory_barrier_kind;\n\t\t\tLLVMValueRef index, addr;\n\n\t\t\tt = load_store_to_llvm_type (ins->opcode, &size, &sext, &zext);\n\n\t\t\tif (sext || zext)\n\t\t\t\tdname = (char *)\"\";\n\n\t\t\tif (ins->inst_offset != 0) {\n\t\t\t\tindex = LLVMConstInt (LLVMInt32Type (), ins->inst_offset / size, FALSE);\n\t\t\t\taddr = LLVMBuildGEP (builder, convert (ctx, lhs, LLVMPointerType (t, 0)), &index, 1, \"\");\n\t\t\t} else {\n\t\t\t\taddr = lhs;\n\t\t\t}\n\n\t\t\taddr = convert (ctx, addr, LLVMPointerType (t, 0));\n\n\t\t\tARM64_ATOMIC_FENCE_FIX;\n\t\t\tvalues [ins->dreg] = emit_load_general (ctx, bb, &builder, size, addr, lhs, dname, is_volatile, barrier);\n\t\t\tARM64_ATOMIC_FENCE_FIX;\n\n\t\t\tif (sext)\n\t\t\t\tvalues [ins->dreg] = LLVMBuildSExt (builder, values [ins->dreg], LLVMInt32Type (), dname);\n\t\t\telse if (zext)\n\t\t\t\tvalues [ins->dreg] = LLVMBuildZExt (builder, values [ins->dreg], LLVMInt32Type (), dname);\n\t\t\tbreak;\n#else\n\t\t\tset_failure (ctx, \"atomic mono.load intrinsic\");\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tcase OP_ATOMIC_STORE_I1:\n\t\tcase OP_ATOMIC_STORE_I2:\n\t\tcase OP_ATOMIC_STORE_I4:\n\t\tcase OP_ATOMIC_STORE_I8:\n\t\tcase OP_ATOMIC_STORE_U1:\n\t\tcase OP_ATOMIC_STORE_U2:\n\t\tcase OP_ATOMIC_STORE_U4:\n\t\tcase OP_ATOMIC_STORE_U8:\n\t\tcase OP_ATOMIC_STORE_R4:\n\t\tcase OP_ATOMIC_STORE_R8: {\n\t\t\tint size;\n\t\t\tgboolean sext, zext;\n\t\t\tLLVMTypeRef t;\n\t\t\tgboolean is_volatile = (ins->flags & MONO_INST_FAULT);\n\t\t\tBarrierKind barrier = (BarrierKind) ins->backend.memory_barrier_kind;\n\t\t\tLLVMValueRef index, addr, value, base;\n\n#if LLVM_API_VERSION < 100\n\t\t\tif (!cfg->llvm_only) {\n\t\t\t\tset_failure (ctx, \"atomic mono.store intrinsic\");\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\t\tif (!values [ins->inst_destbasereg]) {\n\t\t\t    set_failure (ctx, \"inst_destbasereg\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tt = load_store_to_llvm_type (ins->opcode, &size, &sext, &zext);\n\n\t\t\tbase = values [ins->inst_destbasereg];\n\t\t\tindex = LLVMConstInt (LLVMInt32Type (), ins->inst_offset / size, FALSE);\n\t\t\taddr = LLVMBuildGEP (builder, convert (ctx, base, LLVMPointerType (t, 0)), &index, 1, \"\");\n\t\t\tvalue = convert (ctx, values [ins->sreg1], t);\n\n\t\t\tARM64_ATOMIC_FENCE_FIX;\n\t\t\temit_store_general (ctx, bb, &builder, size, value, addr, base, is_volatile, barrier);\n\t\t\tARM64_ATOMIC_FENCE_FIX;\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_RELAXED_NOP: {\n#if defined(TARGET_AMD64) || defined(TARGET_X86)\n\t\t\temit_call (ctx, bb, &builder, get_intrinsic (ctx, \"llvm.x86.sse2.pause\"), NULL, 0);\n\t\t\tbreak;\n#else\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tcase OP_TLS_GET: {\n#if (defined(TARGET_AMD64) || defined(TARGET_X86)) && defined(__linux__)\n#ifdef TARGET_AMD64\n\t\t\t// 257 == FS segment register\n\t\t\tLLVMTypeRef ptrtype = LLVMPointerType (IntPtrType (), 257);\n#else\n\t\t\t// 256 == GS segment register\n\t\t\tLLVMTypeRef ptrtype = LLVMPointerType (IntPtrType (), 256);\n#endif\n\t\t\t// FIXME: XEN\n\t\t\tvalues [ins->dreg] = LLVMBuildLoad (builder, LLVMBuildIntToPtr (builder, LLVMConstInt (IntPtrType (), ins->inst_offset, TRUE), ptrtype, \"\"), \"\");\n#elif defined(TARGET_AMD64) && defined(TARGET_OSX)\n\t\t\t/* See mono_amd64_emit_tls_get () */\n\t\t\tint offset = mono_amd64_get_tls_gs_offset () + (ins->inst_offset * 8);\n\n\t\t\t// 256 == GS segment register\n\t\t\tLLVMTypeRef ptrtype = LLVMPointerType (IntPtrType (), 256);\n\t\t\tvalues [ins->dreg] = LLVMBuildLoad (builder, LLVMBuildIntToPtr (builder, LLVMConstInt (IntPtrType (), offset, TRUE), ptrtype, \"\"), \"\");\n#else\n\t\t\tset_failure (ctx, \"opcode tls-get\");\n\t\t\tbreak;\n#endif\n\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_GC_SAFE_POINT: {\n\t\t\tLLVMValueRef val, cmp, callee;\n\t\t\tLLVMBasicBlockRef poll_bb, cont_bb;\n\t\t\tstatic LLVMTypeRef sig;\n\t\t\tconst char *icall_name = \"mono_threads_state_poll\";\n\n\t\t\tif (!sig)\n\t\t\t\tsig = LLVMFunctionType0 (LLVMVoidType (), FALSE);\n\n\t\t\t/*\n\t\t\t * if (!*sreg1)\n\t\t\t *   mono_threads_state_poll ();\n\t\t\t * FIXME: Use a preserveall wrapper\n\t\t\t */\n\t\t\tval = mono_llvm_build_load (builder, convert (ctx, lhs, LLVMPointerType (IntPtrType (), 0)), \"\", TRUE);\n\t\t\tcmp = LLVMBuildICmp (builder, LLVMIntEQ, val, LLVMConstNull (LLVMTypeOf (val)), \"\");\n\t\t\tpoll_bb = gen_bb (ctx, \"POLL_BB\");\n\t\t\tcont_bb = gen_bb (ctx, \"CONT_BB\");\n\t\t\tLLVMBuildCondBr (builder, cmp, cont_bb, poll_bb);\n\n\t\t\tctx->builder = builder = create_builder (ctx);\n\t\t\tLLVMPositionBuilderAtEnd (builder, poll_bb);\n\n\t\t\tif (ctx->cfg->compile_aot) {\n\t\t\t\tcallee = get_callee (ctx, sig, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name);\n\t\t\t} else {\n\t\t\t\tgpointer target = resolve_patch (ctx->cfg, MONO_PATCH_INFO_INTERNAL_METHOD, icall_name);\n\t\t\t\tcallee = emit_jit_callee (ctx, icall_name, sig, target);\n\t\t\t}\n\t\t\tLLVMBuildCall (builder, callee, NULL, 0, \"\");\n\t\t\tLLVMBuildBr (builder, cont_bb);\n\n\t\t\tctx->builder = builder = create_builder (ctx);\n\t\t\tLLVMPositionBuilderAtEnd (builder, cont_bb);\n\t\t\tctx->bblocks [bb->block_num].end_bblock = cont_bb;\n\t\t\tbreak;\n\t\t}\n\n\t\t\t/*\n\t\t\t * Overflow opcodes.\n\t\t\t */\n\t\tcase OP_IADD_OVF:\n\t\tcase OP_IADD_OVF_UN:\n\t\tcase OP_ISUB_OVF:\n\t\tcase OP_ISUB_OVF_UN:\n\t\tcase OP_IMUL_OVF:\n\t\tcase OP_IMUL_OVF_UN:\n\t\tcase OP_LADD_OVF:\n\t\tcase OP_LADD_OVF_UN:\n\t\tcase OP_LSUB_OVF:\n\t\tcase OP_LSUB_OVF_UN:\n\t\tcase OP_LMUL_OVF:\n\t\tcase OP_LMUL_OVF_UN:\n\t\t\t{\n\t\t\t\tLLVMValueRef args [2], val, ovf, func;\n\n\t\t\t\targs [0] = convert (ctx, lhs, op_to_llvm_type (ins->opcode));\n\t\t\t\targs [1] = convert (ctx, rhs, op_to_llvm_type (ins->opcode));\n\t\t\t\tfunc = get_intrinsic (ctx, ovf_op_to_intrins (ins->opcode));\n\t\t\t\tg_assert (func);\n\t\t\t\tval = LLVMBuildCall (builder, func, args, 2, \"\");\n\t\t\t\tvalues [ins->dreg] = LLVMBuildExtractValue (builder, val, 0, dname);\n\t\t\t\tovf = LLVMBuildExtractValue (builder, val, 1, \"\");\n\t\t\t\temit_cond_system_exception (ctx, bb, \"OverflowException\", ovf);\n\t\t\t\tif (!ctx_ok (ctx))\n\t\t\t\t\tbreak;\n\t\t\t\tbuilder = ctx->builder;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* \n\t\t\t * Valuetypes.\n\t\t\t *   We currently model them using arrays. Promotion to local vregs is \n\t\t\t * disabled for them in mono_handle_global_vregs () in the LLVM case, \n\t\t\t * so we always have an entry in cfg->varinfo for them.\n\t\t\t * FIXME: Is this needed ?\n\t\t\t */\n\t\tcase OP_VZERO: {\n\t\t\tMonoClass *klass = ins->klass;\n\t\t\tLLVMValueRef args [5];\n\n\t\t\tif (!klass) {\n\t\t\t\t// FIXME:\n\t\t\t\tset_failure (ctx, \"!klass\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!addresses [ins->dreg])\n\t\t\t\taddresses [ins->dreg] = build_alloca (ctx, &klass->byval_arg);\n\t\t\targs [0] = LLVMBuildBitCast (builder, addresses [ins->dreg], LLVMPointerType (LLVMInt8Type (), 0), \"\");\n\t\t\targs [1] = LLVMConstInt (LLVMInt8Type (), 0, FALSE);\n\t\t\targs [2] = LLVMConstInt (LLVMInt32Type (), mono_class_value_size (klass, NULL), FALSE);\n\t\t\t// FIXME: Alignment\n\t\t\targs [3] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t\t\targs [4] = LLVMConstInt (LLVMInt1Type (), 0, FALSE);\n\t\t\tLLVMBuildCall (builder, get_intrinsic (ctx, \"llvm.memset.p0i8.i32\"), args, 5, \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_DUMMY_VZERO:\n\t\t\tbreak;\n\n\t\tcase OP_STOREV_MEMBASE:\n\t\tcase OP_LOADV_MEMBASE:\n\t\tcase OP_VMOVE: {\n\t\t\tMonoClass *klass = ins->klass;\n\t\t\tLLVMValueRef src = NULL, dst, args [5];\n\t\t\tgboolean done = FALSE;\n\n\t\t\tif (!klass) {\n\t\t\t\t// FIXME:\n\t\t\t\tset_failure (ctx, \"!klass\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mini_is_gsharedvt_klass (klass)) {\n\t\t\t\t// FIXME:\n\t\t\t\tset_failure (ctx, \"gsharedvt\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_STOREV_MEMBASE:\n\t\t\t\tif (cfg->gen_write_barriers && klass->has_references && ins->inst_destbasereg != cfg->frame_reg &&\n\t\t\t\t\tLLVMGetInstructionOpcode (values [ins->inst_destbasereg]) != LLVMAlloca) {\n\t\t\t\t\t/* Decomposed earlier */\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!addresses [ins->sreg1]) {\n\t\t\t\t\t/* SIMD */\n\t\t\t\t\tg_assert (values [ins->sreg1]);\n\t\t\t\t\tdst = convert (ctx, LLVMBuildAdd (builder, convert (ctx, values [ins->inst_destbasereg], IntPtrType ()), LLVMConstInt (IntPtrType (), ins->inst_offset, FALSE), \"\"), LLVMPointerType (type_to_llvm_type (ctx, &klass->byval_arg), 0));\n\t\t\t\t\tLLVMBuildStore (builder, values [ins->sreg1], dst);\n\t\t\t\t\tdone = TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tsrc = LLVMBuildBitCast (builder, addresses [ins->sreg1], LLVMPointerType (LLVMInt8Type (), 0), \"\");\n\t\t\t\t\tdst = convert (ctx, LLVMBuildAdd (builder, convert (ctx, values [ins->inst_destbasereg], IntPtrType ()), LLVMConstInt (IntPtrType (), ins->inst_offset, FALSE), \"\"), LLVMPointerType (LLVMInt8Type (), 0));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OP_LOADV_MEMBASE:\n\t\t\t\tif (!addresses [ins->dreg])\n\t\t\t\t\taddresses [ins->dreg] = build_alloca (ctx, &klass->byval_arg);\n\t\t\t\tsrc = convert (ctx, LLVMBuildAdd (builder, convert (ctx, values [ins->inst_basereg], IntPtrType ()), LLVMConstInt (IntPtrType (), ins->inst_offset, FALSE), \"\"), LLVMPointerType (LLVMInt8Type (), 0));\n\t\t\t\tdst = LLVMBuildBitCast (builder, addresses [ins->dreg], LLVMPointerType (LLVMInt8Type (), 0), \"\");\n\t\t\t\tbreak;\n\t\t\tcase OP_VMOVE:\n\t\t\t\tif (!addresses [ins->sreg1])\n\t\t\t\t\taddresses [ins->sreg1] = build_alloca (ctx, &klass->byval_arg);\n\t\t\t\tif (!addresses [ins->dreg])\n\t\t\t\t\taddresses [ins->dreg] = build_alloca (ctx, &klass->byval_arg);\n\t\t\t\tsrc = LLVMBuildBitCast (builder, addresses [ins->sreg1], LLVMPointerType (LLVMInt8Type (), 0), \"\");\n\t\t\t\tdst = LLVMBuildBitCast (builder, addresses [ins->dreg], LLVMPointerType (LLVMInt8Type (), 0), \"\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tif (!ctx_ok (ctx))\n\t\t\t\tbreak;\n\n\t\t\tif (done)\n\t\t\t\tbreak;\n\n\t\t\targs [0] = dst;\n\t\t\targs [1] = src;\n\t\t\targs [2] = LLVMConstInt (LLVMInt32Type (), mono_class_value_size (klass, NULL), FALSE);\n\t\t\targs [3] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t\t\t// FIXME: Alignment\n\t\t\targs [3] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t\t\targs [4] = LLVMConstInt (LLVMInt1Type (), 0, FALSE);\n\t\t\tLLVMBuildCall (builder, get_intrinsic (ctx, \"llvm.memcpy.p0i8.p0i8.i32\"), args, 5, \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_LLVM_OUTARG_VT: {\n\t\t\tLLVMArgInfo *ainfo = (LLVMArgInfo*)ins->inst_p0;\n\t\t\tMonoType *t = mini_get_underlying_type (ins->inst_vtype);\n\n\t\t\tif (ainfo->storage == LLVMArgGsharedvtVariable) {\n\t\t\t\t\tMonoInst *var = get_vreg_to_inst (cfg, ins->sreg1);\n\n\t\t\t\t\tif (var && var->opcode == OP_GSHAREDVT_LOCAL) {\n\t\t\t\t\t\taddresses [ins->dreg] = convert (ctx, emit_gsharedvt_ldaddr (ctx, var->dreg), LLVMPointerType (IntPtrType (), 0));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tg_assert (addresses [ins->sreg1]);\n\t\t\t\t\t\taddresses [ins->dreg] = addresses [ins->sreg1];\n\t\t\t\t\t}\n\t\t\t} else if (ainfo->storage == LLVMArgGsharedvtFixed) {\n\t\t\t\tif (!addresses [ins->sreg1]) {\n\t\t\t\t\taddresses [ins->sreg1] = build_alloca (ctx, t);\n\t\t\t\t\tg_assert (values [ins->sreg1]);\n\t\t\t\t}\n\t\t\t\tLLVMBuildStore (builder, convert (ctx, values [ins->sreg1], LLVMGetElementType (LLVMTypeOf (addresses [ins->sreg1]))), addresses [ins->sreg1]);\n\t\t\t\taddresses [ins->dreg] = addresses [ins->sreg1];\n\t\t\t} else {\n\t\t\t\tif (!addresses [ins->sreg1]) {\n\t\t\t\t\taddresses [ins->sreg1] = build_alloca (ctx, t);\n\t\t\t\t\tg_assert (values [ins->sreg1]);\n\t\t\t\t\tLLVMBuildStore (builder, convert (ctx, values [ins->sreg1], type_to_llvm_type (ctx, t)), addresses [ins->sreg1]);\n\t\t\t\t}\n\t\t\t\taddresses [ins->dreg] = addresses [ins->sreg1];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_OBJC_GET_SELECTOR: {\n\t\t\tconst char *name = (const char*)ins->inst_p0;\n\t\t\tLLVMValueRef var;\n\n\t\t\tif (!ctx->module->objc_selector_to_var) {\n\t\t\t\tctx->module->objc_selector_to_var = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n\n\t\t\t\tLLVMValueRef info_var = LLVMAddGlobal (ctx->lmodule, LLVMArrayType (LLVMInt8Type (), 8), \"@OBJC_IMAGE_INFO\");\n\t\t\t\tint32_t objc_imageinfo [] = { 0, 16 };\n\t\t\t\tLLVMSetInitializer (info_var, mono_llvm_create_constant_data_array ((uint8_t *) &objc_imageinfo, 8));\n\t\t\t\tLLVMSetLinkage (info_var, LLVMPrivateLinkage);\n\t\t\t\tLLVMSetExternallyInitialized (info_var, TRUE);\n\t\t\t\tLLVMSetSection (info_var, \"__DATA, __objc_imageinfo,regular,no_dead_strip\");\n\t\t\t\tLLVMSetAlignment (info_var, sizeof (mgreg_t));\n\t\t\t\tmark_as_used (ctx->module, info_var);\n\t\t\t}\n\n\t\t\tvar = g_hash_table_lookup (ctx->module->objc_selector_to_var, name);\n\t\t\tif (!var) {\n\t\t\t\tLLVMValueRef indexes [16];\n\n\t\t\t\tLLVMValueRef name_var = LLVMAddGlobal (ctx->lmodule, LLVMArrayType (LLVMInt8Type (), strlen (name) + 1), \"@OBJC_METH_VAR_NAME_\");\n\t\t\t\tLLVMSetInitializer (name_var, mono_llvm_create_constant_data_array ((const uint8_t*)name, strlen (name) + 1));\n\t\t\t\tLLVMSetLinkage (name_var, LLVMPrivateLinkage);\n\t\t\t\tLLVMSetSection (name_var, \"__TEXT,__objc_methname,cstring_literals\");\n\t\t\t\tmark_as_used (ctx->module, name_var);\n\n\t\t\t\tLLVMValueRef ref_var = LLVMAddGlobal (ctx->lmodule, LLVMPointerType (LLVMInt8Type (), 0), \"@OBJC_SELECTOR_REFERENCES_\");\n\n\t\t\t\tindexes [0] = LLVMConstInt (LLVMInt32Type (), 0, 0);\n\t\t\t\tindexes [1] = LLVMConstInt (LLVMInt32Type (), 0, 0);\n\t\t\t\tLLVMSetInitializer (ref_var, LLVMConstGEP (name_var, indexes, 2));\n\t\t\t\tLLVMSetLinkage (ref_var, LLVMPrivateLinkage);\n\t\t\t\tLLVMSetExternallyInitialized (ref_var, TRUE);\n\t\t\t\tLLVMSetSection (ref_var, \"__DATA, __objc_selrefs, literal_pointers, no_dead_strip\");\n\t\t\t\tLLVMSetAlignment (ref_var, sizeof (mgreg_t));\n\t\t\t\tmark_as_used (ctx->module, ref_var);\n\n\t\t\t\tg_hash_table_insert (ctx->module->objc_selector_to_var, g_strdup (name), ref_var);\n\t\t\t\tvar = ref_var;\n\t\t\t}\n\n\t\t\tvalues [ins->dreg] = LLVMBuildLoad (builder, var, \"\");\n\t\t\tbreak;\n\t\t}\n\n\t\t\t/* \n\t\t\t * SIMD\n\t\t\t */\n#if defined(TARGET_X86) || defined(TARGET_AMD64)\n\t\tcase OP_XZERO: {\n\t\t\tvalues [ins->dreg] = LLVMConstNull (type_to_llvm_type (ctx, &ins->klass->byval_arg));\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_LOADX_MEMBASE: {\n\t\t\tLLVMTypeRef t = type_to_llvm_type (ctx, &ins->klass->byval_arg);\n\t\t\tLLVMValueRef src;\n\n\t\t\tsrc = convert (ctx, LLVMBuildAdd (builder, convert (ctx, values [ins->inst_basereg], IntPtrType ()), LLVMConstInt (IntPtrType (), ins->inst_offset, FALSE), \"\"), LLVMPointerType (t, 0));\n\t\t\tvalues [ins->dreg] = mono_llvm_build_aligned_load (builder, src, \"\", FALSE, 1);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_STOREX_MEMBASE: {\n\t\t\tLLVMTypeRef t = LLVMTypeOf (values [ins->sreg1]);\n\t\t\tLLVMValueRef dest;\n\n\t\t\tdest = convert (ctx, LLVMBuildAdd (builder, convert (ctx, values [ins->inst_destbasereg], IntPtrType ()), LLVMConstInt (IntPtrType (), ins->inst_offset, FALSE), \"\"), LLVMPointerType (t, 0));\n\t\t\tmono_llvm_build_aligned_store (builder, values [ins->sreg1], dest, FALSE, 1);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_PADDB:\n\t\tcase OP_PADDW:\n\t\tcase OP_PADDD:\n\t\tcase OP_PADDQ:\n\t\t\tvalues [ins->dreg] = LLVMBuildAdd (builder, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\tcase OP_ADDPD:\n\t\tcase OP_ADDPS:\n\t\t\tvalues [ins->dreg] = LLVMBuildFAdd (builder, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\tcase OP_PSUBB:\n\t\tcase OP_PSUBW:\n\t\tcase OP_PSUBD:\n\t\tcase OP_PSUBQ:\n\t\t\tvalues [ins->dreg] = LLVMBuildSub (builder, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\tcase OP_SUBPD:\n\t\tcase OP_SUBPS:\n\t\t\tvalues [ins->dreg] = LLVMBuildFSub (builder, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\tcase OP_MULPD:\n\t\tcase OP_MULPS:\n\t\t\tvalues [ins->dreg] = LLVMBuildFMul (builder, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\tcase OP_DIVPD:\n\t\tcase OP_DIVPS:\n\t\t\tvalues [ins->dreg] = LLVMBuildFDiv (builder, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\tcase OP_PAND:\n\t\t\tvalues [ins->dreg] = LLVMBuildAnd (builder, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\tcase OP_POR:\n\t\t\tvalues [ins->dreg] = LLVMBuildOr (builder, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\tcase OP_PXOR:\n\t\t\tvalues [ins->dreg] = LLVMBuildXor (builder, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\tcase OP_PMULW:\n\t\tcase OP_PMULD:\n\t\t\tvalues [ins->dreg] = LLVMBuildMul (builder, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\tcase OP_ANDPS:\n\t\tcase OP_ANDNPS:\n\t\tcase OP_ORPS:\n\t\tcase OP_XORPS:\n\t\tcase OP_ANDPD:\n\t\tcase OP_ANDNPD:\n\t\tcase OP_ORPD:\n\t\tcase OP_XORPD: {\n\t\t\tLLVMTypeRef t, rt;\n\t\t\tLLVMValueRef v = NULL;\n\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_ANDPS:\n\t\t\tcase OP_ANDNPS:\n\t\t\tcase OP_ORPS:\n\t\t\tcase OP_XORPS:\n\t\t\t\tt = LLVMVectorType (LLVMInt32Type (), 4);\n\t\t\t\trt = LLVMVectorType (LLVMFloatType (), 4);\n\t\t\t\tbreak;\n\t\t\tcase OP_ANDPD:\n\t\t\tcase OP_ANDNPD:\n\t\t\tcase OP_ORPD:\n\t\t\tcase OP_XORPD:\n\t\t\t\tt = LLVMVectorType (LLVMInt64Type (), 2);\n\t\t\t\trt = LLVMVectorType (LLVMDoubleType (), 2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tt = LLVMInt32Type ();\n\t\t\t\trt = LLVMInt32Type ();\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\n\t\t\tlhs = LLVMBuildBitCast (builder, lhs, t, \"\");\n\t\t\trhs = LLVMBuildBitCast (builder, rhs, t, \"\");\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_ANDPS:\n\t\t\tcase OP_ANDPD:\n\t\t\t\tv = LLVMBuildAnd (builder, lhs, rhs, \"\");\n\t\t\t\tbreak;\n\t\t\tcase OP_ORPS:\n\t\t\tcase OP_ORPD:\n\t\t\t\tv = LLVMBuildOr (builder, lhs, rhs, \"\");\n\t\t\t\tbreak;\n\t\t\tcase OP_XORPS:\n\t\t\tcase OP_XORPD:\n\t\t\t\tv = LLVMBuildXor (builder, lhs, rhs, \"\");\n\t\t\t\tbreak;\n\t\t\tcase OP_ANDNPS:\n\t\t\tcase OP_ANDNPD:\n\t\t\t\tv = LLVMBuildAnd (builder, rhs, LLVMBuildNot (builder, lhs, \"\"), \"\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalues [ins->dreg] = LLVMBuildBitCast (builder, v, rt, \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_PMIND_UN:\n\t\tcase OP_PMINW_UN:\n\t\tcase OP_PMINB_UN: {\n\t\t\tLLVMValueRef cmp = LLVMBuildICmp (builder, LLVMIntULT, lhs, rhs, \"\");\n\t\t\tvalues [ins->dreg] = LLVMBuildSelect (builder, cmp, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_PMAXD_UN:\n\t\tcase OP_PMAXW_UN:\n\t\tcase OP_PMAXB_UN: {\n\t\t\tLLVMValueRef cmp = LLVMBuildICmp (builder, LLVMIntUGT, lhs, rhs, \"\");\n\t\t\tvalues [ins->dreg] = LLVMBuildSelect (builder, cmp, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_PMINW: {\n\t\t\tLLVMValueRef cmp = LLVMBuildICmp (builder, LLVMIntSLT, lhs, rhs, \"\");\n\t\t\tvalues [ins->dreg] = LLVMBuildSelect (builder, cmp, lhs, rhs, \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_MINPD:\n\t\tcase OP_MINPS:\n\t\tcase OP_MAXPD:\n\t\tcase OP_MAXPS:\n\t\tcase OP_ADDSUBPD:\n\t\tcase OP_ADDSUBPS:\n\t\tcase OP_HADDPD:\n\t\tcase OP_HADDPS:\n\t\tcase OP_HSUBPD:\n\t\tcase OP_HSUBPS:\n\t\tcase OP_PADDB_SAT:\n\t\tcase OP_PADDW_SAT:\n\t\tcase OP_PSUBB_SAT:\n\t\tcase OP_PSUBW_SAT:\n\t\tcase OP_PADDB_SAT_UN:\n\t\tcase OP_PADDW_SAT_UN:\n\t\tcase OP_PSUBB_SAT_UN:\n\t\tcase OP_PSUBW_SAT_UN:\n\t\tcase OP_PAVGB_UN:\n\t\tcase OP_PAVGW_UN:\n\t\tcase OP_PACKW:\n\t\tcase OP_PACKD:\n\t\tcase OP_PACKW_UN:\n\t\tcase OP_PACKD_UN:\n\t\tcase OP_PMULW_HIGH:\n\t\tcase OP_PMULW_HIGH_UN: {\n\t\t\tLLVMValueRef args [2];\n\n\t\t\targs [0] = lhs;\n\t\t\targs [1] = rhs;\n\n\t\t\tvalues [ins->dreg] = LLVMBuildCall (builder, get_intrinsic (ctx, simd_op_to_intrins (ins->opcode)), args, 2, dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_PCMPEQB:\n\t\tcase OP_PCMPEQW:\n\t\tcase OP_PCMPEQD:\n\t\tcase OP_PCMPEQQ: {\n\t\t\tvalues [ins->dreg] = LLVMBuildSExt (builder, LLVMBuildICmp (builder, LLVMIntEQ, lhs, rhs, \"\"), LLVMTypeOf (lhs), \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_PCMPGTB: {\n\t\t\tvalues [ins->dreg] = LLVMBuildSExt (builder, LLVMBuildICmp (builder, LLVMIntSGT, lhs, rhs, \"\"), LLVMTypeOf (lhs), \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_EXTRACT_R8:\n\t\tcase OP_EXTRACT_I8:\n\t\tcase OP_EXTRACT_I4:\n\t\tcase OP_EXTRACT_I2:\n\t\tcase OP_EXTRACT_U2:\n\t\tcase OP_EXTRACTX_U2:\n\t\tcase OP_EXTRACT_I1:\n\t\tcase OP_EXTRACT_U1: {\n\t\t\tLLVMTypeRef t;\n\t\t\tgboolean zext = FALSE;\n\n\t\t\tt = simd_op_to_llvm_type (ins->opcode);\n\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_EXTRACT_R8:\n\t\t\tcase OP_EXTRACT_I8:\n\t\t\tcase OP_EXTRACT_I4:\n\t\t\tcase OP_EXTRACT_I2:\n\t\t\tcase OP_EXTRACT_I1:\n\t\t\t\tbreak;\n\t\t\tcase OP_EXTRACT_U2:\n\t\t\tcase OP_EXTRACTX_U2:\n\t\t\tcase OP_EXTRACT_U1:\n\t\t\t\tzext = TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tt = LLVMInt32Type ();\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\n\t\t\tlhs = LLVMBuildBitCast (builder, lhs, t, \"\");\n\t\t\tvalues [ins->dreg] = LLVMBuildExtractElement (builder, lhs, LLVMConstInt (LLVMInt32Type (), ins->inst_c0, FALSE), \"\");\n\t\t\tif (zext)\n\t\t\t\tvalues [ins->dreg] = LLVMBuildZExt (builder, values [ins->dreg], LLVMInt32Type (), \"\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_EXPAND_I1:\n\t\tcase OP_EXPAND_I2:\n\t\tcase OP_EXPAND_I4:\n\t\tcase OP_EXPAND_I8:\n\t\tcase OP_EXPAND_R4:\n\t\tcase OP_EXPAND_R8: {\n\t\t\tLLVMTypeRef t = simd_op_to_llvm_type (ins->opcode);\n\t\t\tLLVMValueRef mask [16], v;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 16; ++i)\n\t\t\t\tmask [i] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\n\t\t\tv = convert (ctx, values [ins->sreg1], LLVMGetElementType (t));\n\n\t\t\tvalues [ins->dreg] = LLVMBuildInsertElement (builder, LLVMConstNull (t), v, LLVMConstInt (LLVMInt32Type (), 0, FALSE), \"\");\n\t\t\tvalues [ins->dreg] = LLVMBuildShuffleVector (builder, values [ins->dreg], LLVMGetUndef (t), LLVMConstVector (mask, LLVMGetVectorSize (t)), \"\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_INSERT_I1:\n\t\t\tvalues [ins->dreg] = LLVMBuildInsertElement (builder, values [ins->sreg1], convert (ctx, values [ins->sreg2], LLVMInt8Type ()), LLVMConstInt (LLVMInt32Type (), ins->inst_c0, FALSE), dname);\n\t\t\tbreak;\n\t\tcase OP_INSERT_I2:\n\t\t\tvalues [ins->dreg] = LLVMBuildInsertElement (builder, values [ins->sreg1], convert (ctx, values [ins->sreg2], LLVMInt16Type ()), LLVMConstInt (LLVMInt32Type (), ins->inst_c0, FALSE), dname);\n\t\t\tbreak;\n\t\tcase OP_INSERT_I4:\n\t\t\tvalues [ins->dreg] = LLVMBuildInsertElement (builder, values [ins->sreg1], convert (ctx, values [ins->sreg2], LLVMInt32Type ()), LLVMConstInt (LLVMInt32Type (), ins->inst_c0, FALSE), dname);\n\t\t\tbreak;\n\t\tcase OP_INSERT_I8:\n\t\t\tvalues [ins->dreg] = LLVMBuildInsertElement (builder, values [ins->sreg1], convert (ctx, values [ins->sreg2], LLVMInt64Type ()), LLVMConstInt (LLVMInt32Type (), ins->inst_c0, FALSE), dname);\n\t\t\tbreak;\n\t\tcase OP_INSERT_R4:\n\t\t\tvalues [ins->dreg] = LLVMBuildInsertElement (builder, values [ins->sreg1], convert (ctx, values [ins->sreg2], LLVMFloatType ()), LLVMConstInt (LLVMInt32Type (), ins->inst_c0, FALSE), dname);\n\t\t\tbreak;\n\t\tcase OP_INSERT_R8:\n\t\t\tvalues [ins->dreg] = LLVMBuildInsertElement (builder, values [ins->sreg1], convert (ctx, values [ins->sreg2], LLVMDoubleType ()), LLVMConstInt (LLVMInt32Type (), ins->inst_c0, FALSE), dname);\n\t\t\tbreak;\n\n#if LLVM_API_VERSION > 100\n\t\tcase OP_CVTDQ2PD: {\n\t\t\tLLVMValueRef indexes [16];\n\n\t\t\tindexes [0] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t\t\tindexes [1] = LLVMConstInt (LLVMInt32Type (), 1, FALSE);\n\t\t\tLLVMValueRef mask = LLVMConstVector (indexes, 2);\n\t\t\tLLVMValueRef shuffle = LLVMBuildShuffleVector (builder, lhs, LLVMConstNull (LLVMTypeOf (lhs)), mask, \"\");\n\t\t\tvalues [ins->dreg] = LLVMBuildSIToFP (builder, shuffle, LLVMVectorType (LLVMDoubleType (), 2), dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_CVTPS2PD: {\n\t\t\tLLVMValueRef indexes [16];\n\n\t\t\tindexes [0] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t\t\tindexes [1] = LLVMConstInt (LLVMInt32Type (), 1, FALSE);\n\t\t\tLLVMValueRef mask = LLVMConstVector (indexes, 2);\n\t\t\tLLVMValueRef shuffle = LLVMBuildShuffleVector (builder, lhs, LLVMConstNull (LLVMTypeOf (lhs)), mask, \"\");\n\t\t\tvalues [ins->dreg] = LLVMBuildFPExt (builder, shuffle, LLVMVectorType (LLVMDoubleType (), 2), dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_CVTTPS2DQ:\n\t\t\tvalues [ins->dreg] = LLVMBuildFPToSI (builder, lhs, LLVMVectorType (LLVMInt32Type (), 4), dname);\n\t\t\tbreak;\n#endif\n\n#if LLVM_API_VERSION <= 100\n\t\tcase OP_CVTDQ2PD:\n\t\tcase OP_CVTPS2PD:\n\t\tcase OP_CVTTPS2DQ:\n#endif\n\t\tcase OP_CVTDQ2PS:\n\t\tcase OP_CVTPD2DQ:\n\t\tcase OP_CVTPS2DQ:\n\t\tcase OP_CVTPD2PS:\n\t\tcase OP_CVTTPD2DQ:\n\t\tcase OP_EXTRACT_MASK:\n\t\tcase OP_SQRTPS:\n\t\tcase OP_SQRTPD:\n\t\tcase OP_RSQRTPS:\n\t\tcase OP_RCPPS: {\n\t\t\tLLVMValueRef v;\n\n\t\t\tv = convert (ctx, values [ins->sreg1], simd_op_to_llvm_type (ins->opcode));\n\n\t\t\tvalues [ins->dreg] = LLVMBuildCall (builder, get_intrinsic (ctx, simd_op_to_intrins (ins->opcode)), &v, 1, dname);\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_COMPPS:\n\t\tcase OP_COMPPD: {\n\t\t\tLLVMRealPredicate op;\n\n\t\t\tswitch (ins->inst_c0) {\n\t\t\tcase SIMD_COMP_EQ:\n\t\t\t\top = LLVMRealOEQ;\n\t\t\t\tbreak;\n\t\t\tcase SIMD_COMP_LT:\n\t\t\t\top = LLVMRealOLT;\n\t\t\t\tbreak;\n\t\t\tcase SIMD_COMP_LE:\n\t\t\t\top = LLVMRealOLE;\n\t\t\t\tbreak;\n\t\t\tcase SIMD_COMP_UNORD:\n\t\t\t\top = LLVMRealUNO;\n\t\t\t\tbreak;\n\t\t\tcase SIMD_COMP_NEQ:\n\t\t\t\top = LLVMRealUNE;\n\t\t\t\tbreak;\n\t\t\tcase SIMD_COMP_NLT:\n\t\t\t\top = LLVMRealUGE;\n\t\t\t\tbreak;\n\t\t\tcase SIMD_COMP_NLE:\n\t\t\t\top = LLVMRealUGT;\n\t\t\t\tbreak;\n\t\t\tcase SIMD_COMP_ORD:\n\t\t\t\top = LLVMRealORD;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\n\t\t\tLLVMValueRef cmp = LLVMBuildFCmp (builder, op, lhs, rhs, \"\");\n\t\t\tif (ins->opcode == OP_COMPPD)\n\t\t\t\tvalues [ins->dreg] = LLVMBuildBitCast (builder, LLVMBuildSExt (builder, cmp, LLVMVectorType (LLVMInt64Type (), 2), \"\"), LLVMTypeOf (lhs), \"\");\n\t\t\telse\n\t\t\t\tvalues [ins->dreg] = LLVMBuildBitCast (builder, LLVMBuildSExt (builder, cmp, LLVMVectorType (LLVMInt32Type (), 4), \"\"), LLVMTypeOf (lhs), \"\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_ICONV_TO_X:\n\t\t\t/* This is only used for implementing shifts by non-immediate */\n\t\t\tvalues [ins->dreg] = lhs;\n\t\t\tbreak;\n\n\t\tcase OP_PSHRW:\n\t\tcase OP_PSHRD:\n\t\tcase OP_PSHRQ:\n\t\tcase OP_PSARW:\n\t\tcase OP_PSARD:\n\t\tcase OP_PSHLW:\n\t\tcase OP_PSHLD:\n\t\tcase OP_PSHLQ: {\n\t\t\tLLVMValueRef args [3];\n\n\t\t\targs [0] = lhs;\n\t\t\targs [1] = LLVMConstInt (LLVMInt32Type (), ins->inst_imm, FALSE);\n\n\t\t\tvalues [ins->dreg] = LLVMBuildCall (builder, get_intrinsic (ctx, simd_op_to_intrins (ins->opcode)), args, 2, dname);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_PSHRW_REG:\n\t\tcase OP_PSHRD_REG:\n\t\tcase OP_PSHRQ_REG:\n\t\tcase OP_PSARW_REG:\n\t\tcase OP_PSARD_REG:\n\t\tcase OP_PSHLW_REG:\n\t\tcase OP_PSHLD_REG:\n\t\tcase OP_PSHLQ_REG: {\n\t\t\tLLVMValueRef args [3];\n\n\t\t\targs [0] = lhs;\n\t\t\targs [1] = values [ins->sreg2];\n\n\t\t\tvalues [ins->dreg] = LLVMBuildCall (builder, get_intrinsic (ctx, simd_op_to_intrins (ins->opcode)), args, 2, dname);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_SHUFPS:\n\t\tcase OP_SHUFPD:\n\t\tcase OP_PSHUFLED:\n\t\tcase OP_PSHUFLEW_LOW:\n\t\tcase OP_PSHUFLEW_HIGH: {\n\t\t\tint mask [16];\n\t\t\tLLVMValueRef v1 = NULL, v2 = NULL, mask_values [16];\n\t\t\tint i, mask_size = 0;\n\t\t\tint imask = ins->inst_c0;\n\t\n\t\t\t/* Convert the x86 shuffle mask to LLVM's */\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_SHUFPS:\n\t\t\t\tmask_size = 4;\n\t\t\t\tmask [0] = ((imask >> 0) & 3);\n\t\t\t\tmask [1] = ((imask >> 2) & 3);\n\t\t\t\tmask [2] = ((imask >> 4) & 3) + 4;\n\t\t\t\tmask [3] = ((imask >> 6) & 3) + 4;\n\t\t\t\tv1 = values [ins->sreg1];\n\t\t\t\tv2 = values [ins->sreg2];\n\t\t\t\tbreak;\n\t\t\tcase OP_SHUFPD:\n\t\t\t\tmask_size = 2;\n\t\t\t\tmask [0] = ((imask >> 0) & 1);\n\t\t\t\tmask [1] = ((imask >> 1) & 1) + 2;\n\t\t\t\tv1 = values [ins->sreg1];\n\t\t\t\tv2 = values [ins->sreg2];\n\t\t\t\tbreak;\n\t\t\tcase OP_PSHUFLEW_LOW:\n\t\t\t\tmask_size = 8;\n\t\t\t\tmask [0] = ((imask >> 0) & 3);\n\t\t\t\tmask [1] = ((imask >> 2) & 3);\n\t\t\t\tmask [2] = ((imask >> 4) & 3);\n\t\t\t\tmask [3] = ((imask >> 6) & 3);\n\t\t\t\tmask [4] = 4 + 0;\n\t\t\t\tmask [5] = 4 + 1;\n\t\t\t\tmask [6] = 4 + 2;\n\t\t\t\tmask [7] = 4 + 3;\n\t\t\t\tv1 = values [ins->sreg1];\n\t\t\t\tv2 = LLVMGetUndef (LLVMTypeOf (v1));\n\t\t\t\tbreak;\n\t\t\tcase OP_PSHUFLEW_HIGH:\n\t\t\t\tmask_size = 8;\n\t\t\t\tmask [0] = 0;\n\t\t\t\tmask [1] = 1;\n\t\t\t\tmask [2] = 2;\n\t\t\t\tmask [3] = 3;\n\t\t\t\tmask [4] = 4 + ((imask >> 0) & 3);\n\t\t\t\tmask [5] = 4 + ((imask >> 2) & 3);\n\t\t\t\tmask [6] = 4 + ((imask >> 4) & 3);\n\t\t\t\tmask [7] = 4 + ((imask >> 6) & 3);\n\t\t\t\tv1 = values [ins->sreg1];\n\t\t\t\tv2 = LLVMGetUndef (LLVMTypeOf (v1));\n\t\t\t\tbreak;\n\t\t\tcase OP_PSHUFLED:\n\t\t\t\tmask_size = 4;\n\t\t\t\tmask [0] = ((imask >> 0) & 3);\n\t\t\t\tmask [1] = ((imask >> 2) & 3);\n\t\t\t\tmask [2] = ((imask >> 4) & 3);\n\t\t\t\tmask [3] = ((imask >> 6) & 3);\n\t\t\t\tv1 = values [ins->sreg1];\n\t\t\t\tv2 = LLVMGetUndef (LLVMTypeOf (v1));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tfor (i = 0; i < mask_size; ++i)\n\t\t\t\tmask_values [i] = LLVMConstInt (LLVMInt32Type (), mask [i], FALSE);\n\n\t\t\tvalues [ins->dreg] =\n\t\t\t\tLLVMBuildShuffleVector (builder, v1, v2,\n\t\t\t\t\t\t\t\t\t\tLLVMConstVector (mask_values, mask_size), dname);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_UNPACK_LOWB:\n\t\tcase OP_UNPACK_LOWW:\n\t\tcase OP_UNPACK_LOWD:\n\t\tcase OP_UNPACK_LOWQ:\n\t\tcase OP_UNPACK_LOWPS:\n\t\tcase OP_UNPACK_LOWPD:\n\t\tcase OP_UNPACK_HIGHB:\n\t\tcase OP_UNPACK_HIGHW:\n\t\tcase OP_UNPACK_HIGHD:\n\t\tcase OP_UNPACK_HIGHQ:\n\t\tcase OP_UNPACK_HIGHPS:\n\t\tcase OP_UNPACK_HIGHPD: {\n\t\t\tint mask [16];\n\t\t\tLLVMValueRef mask_values [16];\n\t\t\tint i, mask_size = 0;\n\t\t\tgboolean low = FALSE;\n\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_UNPACK_LOWB:\n\t\t\t\tmask_size = 16;\n\t\t\t\tlow = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase OP_UNPACK_LOWW:\n\t\t\t\tmask_size = 8;\n\t\t\t\tlow = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase OP_UNPACK_LOWD:\n\t\t\tcase OP_UNPACK_LOWPS:\n\t\t\t\tmask_size = 4;\n\t\t\t\tlow = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase OP_UNPACK_LOWQ:\n\t\t\tcase OP_UNPACK_LOWPD:\n\t\t\t\tmask_size = 2;\n\t\t\t\tlow = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase OP_UNPACK_HIGHB:\n\t\t\t\tmask_size = 16;\n\t\t\t\tbreak;\n\t\t\tcase OP_UNPACK_HIGHW:\n\t\t\t\tmask_size = 8;\n\t\t\t\tbreak;\n\t\t\tcase OP_UNPACK_HIGHD:\n\t\t\tcase OP_UNPACK_HIGHPS:\n\t\t\t\tmask_size = 4;\n\t\t\t\tbreak;\n\t\t\tcase OP_UNPACK_HIGHQ:\n\t\t\tcase OP_UNPACK_HIGHPD:\n\t\t\t\tmask_size = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\n\t\t\tif (low) {\n\t\t\t\tfor (i = 0; i < (mask_size / 2); ++i) {\n\t\t\t\t\tmask [(i * 2)] = i;\n\t\t\t\t\tmask [(i * 2) + 1] = mask_size + i;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < (mask_size / 2); ++i) {\n\t\t\t\t\tmask [(i * 2)] = (mask_size / 2) + i;\n\t\t\t\t\tmask [(i * 2) + 1] = mask_size + (mask_size / 2) + i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < mask_size; ++i)\n\t\t\t\tmask_values [i] = LLVMConstInt (LLVMInt32Type (), mask [i], FALSE);\n\t\t\t\n\t\t\tvalues [ins->dreg] =\n\t\t\t\tLLVMBuildShuffleVector (builder, values [ins->sreg1], values [ins->sreg2],\n\t\t\t\t\t\t\t\t\t\tLLVMConstVector (mask_values, mask_size), dname);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_DUPPD: {\n\t\t\tLLVMTypeRef t = simd_op_to_llvm_type (ins->opcode);\n\t\t\tLLVMValueRef v, val;\n\n\t\t\tv = LLVMBuildExtractElement (builder, lhs, LLVMConstInt (LLVMInt32Type (), 0, FALSE), \"\");\n\t\t\tval = LLVMConstNull (t);\n\t\t\tval = LLVMBuildInsertElement (builder, val, v, LLVMConstInt (LLVMInt32Type (), 0, FALSE), \"\");\n\t\t\tval = LLVMBuildInsertElement (builder, val, v, LLVMConstInt (LLVMInt32Type (), 1, FALSE), dname);\n\n\t\t\tvalues [ins->dreg] = val;\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_DUPPS_LOW:\n\t\tcase OP_DUPPS_HIGH: {\n\t\t\tLLVMTypeRef t = simd_op_to_llvm_type (ins->opcode);\n\t\t\tLLVMValueRef v1, v2, val;\n\t\t\t\n\n\t\t\tif (ins->opcode == OP_DUPPS_LOW) {\n\t\t\t\tv1 = LLVMBuildExtractElement (builder, lhs, LLVMConstInt (LLVMInt32Type (), 0, FALSE), \"\");\n\t\t\t\tv2 = LLVMBuildExtractElement (builder, lhs, LLVMConstInt (LLVMInt32Type (), 2, FALSE), \"\");\n\t\t\t} else {\n\t\t\t\tv1 = LLVMBuildExtractElement (builder, lhs, LLVMConstInt (LLVMInt32Type (), 1, FALSE), \"\");\n\t\t\t\tv2 = LLVMBuildExtractElement (builder, lhs, LLVMConstInt (LLVMInt32Type (), 3, FALSE), \"\");\n\t\t\t}\n\t\t\tval = LLVMConstNull (t);\n\t\t\tval = LLVMBuildInsertElement (builder, val, v1, LLVMConstInt (LLVMInt32Type (), 0, FALSE), \"\");\n\t\t\tval = LLVMBuildInsertElement (builder, val, v1, LLVMConstInt (LLVMInt32Type (), 1, FALSE), \"\");\n\t\t\tval = LLVMBuildInsertElement (builder, val, v2, LLVMConstInt (LLVMInt32Type (), 2, FALSE), \"\");\n\t\t\tval = LLVMBuildInsertElement (builder, val, v2, LLVMConstInt (LLVMInt32Type (), 3, FALSE), \"\");\n\t\t\t\n\t\t\tvalues [ins->dreg] = val;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase OP_DPPS: {\n\t\t\tLLVMValueRef args [3];\n\n\t\t\targs [0] = lhs;\n\t\t\targs [1] = rhs;\n\t\t\t/* 0xf1 == multiply all 4 elements, add them together, and store the result to the lowest element */\n#if LLVM_API_VERSION >= 500\n\t\t\targs [2] = LLVMConstInt (LLVMInt8Type (), 0xf1, FALSE);\n#else\n\t\t\targs [2] = LLVMConstInt (LLVMInt32Type (), 0xf1, FALSE);\n#endif\n\n\t\t\tvalues [ins->dreg] = LLVMBuildCall (builder, get_intrinsic (ctx, simd_op_to_intrins (ins->opcode)), args, 3, dname);\n\t\t\tbreak;\n\t\t}\n\n#endif /* SIMD */\n\n\t\tcase OP_DUMMY_USE:\n\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * EXCEPTION HANDLING\n\t\t\t */\n\t\tcase OP_IMPLICIT_EXCEPTION:\n\t\t\t/* This marks a place where an implicit exception can happen */\n\t\t\tif (bb->region != -1)\n\t\t\t\tset_failure (ctx, \"implicit-exception\");\n\t\t\tbreak;\n\t\tcase OP_THROW:\n\t\tcase OP_RETHROW: {\n\t\t\tgboolean rethrow = (ins->opcode == OP_RETHROW);\n\t\t\tif (ctx->llvm_only) {\n\t\t\t\temit_llvmonly_throw (ctx, bb, rethrow, lhs);\n\t\t\t\thas_terminator = TRUE;\n\t\t\t\tctx->unreachable [bb->block_num] = TRUE;\n\t\t\t} else {\n\t\t\t\temit_throw (ctx, bb, rethrow, lhs);\n\t\t\t\tbuilder = ctx->builder;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_CALL_HANDLER: {\n\t\t\t/* \n\t\t\t * We don't 'call' handlers, but instead simply branch to them.\n\t\t\t * The code generated by ENDFINALLY will branch back to us.\n\t\t\t */\n\t\t\tLLVMBasicBlockRef noex_bb;\n\t\t\tGSList *bb_list;\n\t\t\tBBInfo *info = &bblocks [ins->inst_target_bb->block_num];\n\n\t\t\tbb_list = info->call_handler_return_bbs;\n\n\t\t\t/* \n\t\t\t * Set the indicator variable for the finally clause.\n\t\t\t */\n\t\t\tlhs = info->finally_ind;\n\t\t\tg_assert (lhs);\n\t\t\tLLVMBuildStore (builder, LLVMConstInt (LLVMInt32Type (), g_slist_length (bb_list) + 1, FALSE), lhs);\n\t\t\t\t\n\t\t\t/* Branch to the finally clause */\n\t\t\tLLVMBuildBr (builder, info->call_handler_target_bb);\n\n\t\t\tnoex_bb = gen_bb (ctx, \"CALL_HANDLER_CONT_BB\");\n\t\t\tinfo->call_handler_return_bbs = g_slist_append_mempool (cfg->mempool, info->call_handler_return_bbs, noex_bb);\n\n\t\t\tbuilder = ctx->builder = create_builder (ctx);\n\t\t\tLLVMPositionBuilderAtEnd (ctx->builder, noex_bb);\n\n\t\t\tbblocks [bb->block_num].end_bblock = noex_bb;\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_START_HANDLER: {\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_ENDFINALLY: {\n\t\t\tLLVMBasicBlockRef resume_bb;\n\t\t\tMonoBasicBlock *handler_bb;\n\t\t\tLLVMValueRef val, switch_ins, callee;\n\t\t\tGSList *bb_list;\n\t\t\tBBInfo *info;\n\t\t\tgboolean is_fault = MONO_REGION_FLAGS (bb->region) == MONO_EXCEPTION_CLAUSE_FAULT;\n\n\t\t\t/*\n\t\t\t * Fault clauses are like finally clauses, but they are only called if an exception is thrown.\n\t\t\t */\n\t\t\tif (!is_fault) {\n\t\t\t\thandler_bb = (MonoBasicBlock*)g_hash_table_lookup (ctx->region_to_handler, GUINT_TO_POINTER (mono_get_block_region_notry (cfg, bb->region)));\n\t\t\t\tg_assert (handler_bb);\n\t\t\t\tinfo = &bblocks [handler_bb->block_num];\n\t\t\t\tlhs = info->finally_ind;\n\t\t\t\tg_assert (lhs);\n\n\t\t\t\tbb_list = info->call_handler_return_bbs;\n\n\t\t\t\tresume_bb = gen_bb (ctx, \"ENDFINALLY_RESUME_BB\");\n\n\t\t\t\t/* Load the finally variable */\n\t\t\t\tval = LLVMBuildLoad (builder, lhs, \"\");\n\n\t\t\t\t/* Reset the variable */\n\t\t\t\tLLVMBuildStore (builder, LLVMConstInt (LLVMInt32Type (), 0, FALSE), lhs);\n\n\t\t\t\t/* Branch to either resume_bb, or to the bblocks in bb_list */\n\t\t\t\tswitch_ins = LLVMBuildSwitch (builder, val, resume_bb, g_slist_length (bb_list));\n\t\t\t\t/*\n\t\t\t\t * The other targets are added at the end to handle OP_CALL_HANDLER\n\t\t\t\t * opcodes processed later.\n\t\t\t\t */\n\t\t\t\tinfo->endfinally_switch_ins_list = g_slist_append_mempool (cfg->mempool, info->endfinally_switch_ins_list, switch_ins);\n\n\t\t\t\tbuilder = ctx->builder = create_builder (ctx);\n\t\t\t\tLLVMPositionBuilderAtEnd (ctx->builder, resume_bb);\n\t\t\t}\n\n\t\t\tif (ctx->llvm_only) {\n\t\t\t\temit_resume_eh (ctx, bb);\n\t\t\t} else {\n\t\t\t\tif (ctx->cfg->compile_aot) {\n\t\t\t\t\tcallee = get_callee (ctx, LLVMFunctionType (LLVMVoidType (), NULL, 0, FALSE), MONO_PATCH_INFO_INTERNAL_METHOD, \"llvm_resume_unwind_trampoline\");\n\t\t\t\t} else {\n#if LLVM_API_VERSION > 100\n\t\t\t\t\tMonoJitICallInfo *info;\n\n\t\t\t\t\tinfo = mono_find_jit_icall_by_name (\"llvm_resume_unwind_trampoline\");\n\t\t\t\t\tg_assert (info);\n\t\t\t\t\tgpointer target = (void*)info->func;\n\t\t\t\t\tLLVMTypeRef icall_sig = LLVMFunctionType (LLVMVoidType (), NULL, 0, FALSE);\n\t\t\t\t\tcallee = emit_jit_callee (ctx, \"llvm_resume_unwind_trampoline\", icall_sig, target);\n#else\n\t\t\t\t\tcallee = LLVMGetNamedFunction (ctx->lmodule, \"llvm_resume_unwind_trampoline\");\n#endif\n\t\t\t\t}\n\t\t\t\tLLVMBuildCall (builder, callee, NULL, 0, \"\");\n\t\t\t\tLLVMBuildUnreachable (builder);\n\t\t\t}\n\n\t\t\thas_terminator = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tcase OP_IL_SEQ_POINT:\n\t\t\tbreak;\n\t\tdefault: {\n\t\t\tchar reason [128];\n\n\t\t\tsprintf (reason, \"opcode %s\", mono_inst_name (ins->opcode));\n\t\t\tset_failure (ctx, reason);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t\tif (!ctx_ok (ctx))\n\t\t\tbreak;\n\n\t\t/* Convert the value to the type required by phi nodes */\n\t\tif (spec [MONO_INST_DEST] != ' ' && !MONO_IS_STORE_MEMBASE (ins) && ctx->vreg_types [ins->dreg]) {\n\t\t\tif (ctx->is_vphi [ins->dreg])\n\t\t\t\t/* vtypes */\n\t\t\t\tvalues [ins->dreg] = addresses [ins->dreg];\n\t\t\telse\n\t\t\t\tvalues [ins->dreg] = convert (ctx, values [ins->dreg], ctx->vreg_types [ins->dreg]);\n\t\t}\n\n\t\t/* Add stores for volatile variables */\n\t\tif (spec [MONO_INST_DEST] != ' ' && spec [MONO_INST_DEST] != 'v' && !MONO_IS_STORE_MEMBASE (ins))\n\t\t\temit_volatile_store (ctx, ins->dreg);\n\t}\n\n\tif (!ctx_ok (ctx))\n\t\treturn;\n\n\tif (!has_terminator && bb->next_bb && (bb == cfg->bb_entry || bb->in_count > 0)) {\n\t\tLLVMBuildBr (builder, get_bb (ctx, bb->next_bb));\n\t}\n\n\tif (bb == cfg->bb_exit && sig->ret->type == MONO_TYPE_VOID) {\n\t\temit_dbg_loc (ctx, builder, cfg->header->code + cfg->header->code_size - 1);\n\t\tLLVMBuildRetVoid (builder);\n\t}\n\n\tif (bb == cfg->bb_entry)\n\t\tctx->last_alloca = LLVMGetLastInstruction (get_bb (ctx, cfg->bb_entry));\n}\n\n/*\n * mono_llvm_check_method_supported:\n *\n *   Do some quick checks to decide whenever cfg->method can be compiled by LLVM, to avoid\n * compiling a method twice.\n */\nvoid\nmono_llvm_check_method_supported (MonoCompile *cfg)\n{\n\tint i, j;\n\n\tif (cfg->llvm_only)\n\t\treturn;\n\n\tif (cfg->method->save_lmf) {\n\t\tcfg->exception_message = g_strdup (\"lmf\");\n\t\tcfg->disable_llvm = TRUE;\n\t}\n\tif (cfg->disable_llvm)\n\t\treturn;\n\n\t/*\n\t * Nested clauses where one of the clauses is a finally clause is\n\t * not supported, because LLVM can't figure out the control flow,\n\t * probably because we resume exception handling by calling our\n\t * own function instead of using the 'resume' llvm instruction.\n\t */\n\tfor (i = 0; i < cfg->header->num_clauses; ++i) {\n\t\tfor (j = 0; j < cfg->header->num_clauses; ++j) {\n\t\t\tMonoExceptionClause *clause1 = &cfg->header->clauses [i];\n\t\t\tMonoExceptionClause *clause2 = &cfg->header->clauses [j];\n\n\t\t\t// FIXME: Nested try clauses fail in some cases too, i.e. #37273\n\t\t\tif (i != j && clause1->try_offset >= clause2->try_offset && clause1->handler_offset <= clause2->handler_offset) {\n\t\t\t\t//(clause1->flags == MONO_EXCEPTION_CLAUSE_FINALLY || clause2->flags == MONO_EXCEPTION_CLAUSE_FINALLY)) {\n\t\t\t\tcfg->exception_message = g_strdup (\"nested clauses\");\n\t\t\t\tcfg->disable_llvm = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (cfg->disable_llvm)\n\t\treturn;\n\n\t/* FIXME: */\n\tif (cfg->method->dynamic) {\n\t\tcfg->exception_message = g_strdup (\"dynamic.\");\n\t\tcfg->disable_llvm = TRUE;\n\t}\n\tif (cfg->disable_llvm)\n\t\treturn;\n}\n\nstatic LLVMCallInfo*\nget_llvm_call_info (MonoCompile *cfg, MonoMethodSignature *sig)\n{\n\tLLVMCallInfo *linfo;\n\tint i;\n\n\tif (cfg->gsharedvt && cfg->llvm_only && mini_is_gsharedvt_variable_signature (sig)) {\n\t\tint i, n, pindex;\n\n\t\t/*\n\t\t * Gsharedvt methods have the following calling convention:\n\t\t * - all arguments are passed by ref, even non generic ones\n\t\t * - the return value is returned by ref too, using a vret\n\t\t *   argument passed after 'this'.\n\t\t */\n\t\tn = sig->param_count + sig->hasthis;\n\t\tlinfo = (LLVMCallInfo*)mono_mempool_alloc0 (cfg->mempool, sizeof (LLVMCallInfo) + (sizeof (LLVMArgInfo) * n));\n\n\t\tpindex = 0;\n\t\tif (sig->hasthis)\n\t\t\tlinfo->args [pindex ++].storage = LLVMArgNormal;\n\n\t\tif (sig->ret->type != MONO_TYPE_VOID) {\n\t\t\tif (mini_is_gsharedvt_variable_type (sig->ret))\n\t\t\t\tlinfo->ret.storage = LLVMArgGsharedvtVariable;\n\t\t\telse if (mini_type_is_vtype (sig->ret))\n\t\t\t\tlinfo->ret.storage = LLVMArgGsharedvtFixedVtype;\n\t\t\telse\n\t\t\t\tlinfo->ret.storage = LLVMArgGsharedvtFixed;\n\t\t\tlinfo->vret_arg_index = pindex;\n\t\t} else {\n\t\t\tlinfo->ret.storage = LLVMArgNone;\n\t\t}\n\n\t\tfor (i = 0; i < sig->param_count; ++i) {\n\t\t\tif (sig->params [i]->byref)\n\t\t\t\tlinfo->args [pindex].storage = LLVMArgNormal;\n\t\t\telse if (mini_is_gsharedvt_variable_type (sig->params [i]))\n\t\t\t\tlinfo->args [pindex].storage = LLVMArgGsharedvtVariable;\n\t\t\telse if (mini_type_is_vtype (sig->params [i]))\n\t\t\t\tlinfo->args [pindex].storage = LLVMArgGsharedvtFixedVtype;\n\t\t\telse\n\t\t\t\tlinfo->args [pindex].storage = LLVMArgGsharedvtFixed;\n\t\t\tlinfo->args [pindex].type = sig->params [i];\n\t\t\tpindex ++;\n\t\t}\n\t\treturn linfo;\n\t}\n\n\n\tlinfo = mono_arch_get_llvm_call_info (cfg, sig);\n\tfor (i = 0; i < sig->param_count; ++i)\n\t\tlinfo->args [i + sig->hasthis].type = sig->params [i];\n\n\treturn linfo;\n}\n\nstatic void\nemit_method_inner (EmitContext *ctx);\n\nstatic void\nfree_ctx (EmitContext *ctx)\n{\n\tGSList *l;\n\n\tg_free (ctx->values);\n\tg_free (ctx->addresses);\n\tg_free (ctx->vreg_types);\n\tg_free (ctx->is_vphi);\n\tg_free (ctx->vreg_cli_types);\n\tg_free (ctx->is_dead);\n\tg_free (ctx->unreachable);\n\tg_ptr_array_free (ctx->phi_values, TRUE);\n\tg_free (ctx->bblocks);\n\tg_hash_table_destroy (ctx->region_to_handler);\n\tg_hash_table_destroy (ctx->clause_to_handler);\n\tg_hash_table_destroy (ctx->jit_callees);\n\n\tGHashTableIter iter;\n\tg_hash_table_iter_init (&iter, ctx->method_to_callers);\n\twhile (g_hash_table_iter_next (&iter, NULL, (gpointer)&l))\n\t\tg_slist_free (l);\n\n\tg_hash_table_destroy (ctx->method_to_callers);\n\n\tg_free (ctx->method_name);\n\tg_ptr_array_free (ctx->bblock_list, TRUE);\n\n\tfor (l = ctx->builders; l; l = l->next) {\n\t\tLLVMBuilderRef builder = (LLVMBuilderRef)l->data;\n\t\tLLVMDisposeBuilder (builder);\n\t}\n\n\tg_free (ctx);\n}\n\n/*\n * mono_llvm_emit_method:\n *\n *   Emit LLVM IL from the mono IL, and compile it to native code using LLVM.\n */\nvoid\nmono_llvm_emit_method (MonoCompile *cfg)\n{\n\tEmitContext *ctx;\n\tchar *method_name;\n\tgboolean is_linkonce = FALSE;\n\tint i;\n\n\tif (cfg->skip)\n\t\treturn;\n\n\t/* The code below might acquire the loader lock, so use it for global locking */\n\tmono_loader_lock ();\n\n\t/* Used to communicate with the callbacks */\n\tmono_native_tls_set_value (current_cfg_tls_id, cfg);\n\n\tctx = g_new0 (EmitContext, 1);\n\tctx->cfg = cfg;\n\tctx->mempool = cfg->mempool;\n\n\t/*\n\t * This maps vregs to the LLVM instruction defining them\n\t */\n\tctx->values = g_new0 (LLVMValueRef, cfg->next_vreg);\n\t/*\n\t * This maps vregs for volatile variables to the LLVM instruction defining their\n\t * address.\n\t */\n\tctx->addresses = g_new0 (LLVMValueRef, cfg->next_vreg);\n\tctx->vreg_types = g_new0 (LLVMTypeRef, cfg->next_vreg);\n\tctx->is_vphi = g_new0 (gboolean, cfg->next_vreg);\n\tctx->vreg_cli_types = g_new0 (MonoType*, cfg->next_vreg);\n\tctx->phi_values = g_ptr_array_sized_new (256);\n\t/* \n\t * This signals whenever the vreg was defined by a phi node with no input vars\n\t * (i.e. all its input bblocks end with NOT_REACHABLE).\n\t */\n\tctx->is_dead = g_new0 (gboolean, cfg->next_vreg);\n\t/* Whenever the bblock is unreachable */\n\tctx->unreachable = g_new0 (gboolean, cfg->max_block_num);\n\tctx->bblock_list = g_ptr_array_sized_new (256);\n\n\tctx->region_to_handler = g_hash_table_new (NULL, NULL);\n\tctx->clause_to_handler = g_hash_table_new (NULL, NULL);\n\tctx->method_to_callers = g_hash_table_new (NULL, NULL);\n\tctx->jit_callees = g_hash_table_new (NULL, NULL);\n \tif (cfg->compile_aot) {\n\t\tctx->module = &aot_module;\n\n\t\tmethod_name = NULL;\n\t\t/*\n\t\t * Allow the linker to discard duplicate copies of wrappers, generic instances etc. by using the 'linkonce'\n\t\t * linkage for them. This requires the following:\n\t\t * - the method needs to have a unique mangled name\n\t\t * - llvmonly mode, since the code in aot-runtime.c would initialize got slots in the wrong aot image etc.\n\t\t */\n\t\tis_linkonce = ctx->module->llvm_only && ctx->module->static_link && mono_aot_is_linkonce_method (cfg->method);\n\t\tif (is_linkonce) {\n\t\t\tmethod_name = mono_aot_get_mangled_method_name (cfg->method);\n\t\t\tif (!method_name)\n\t\t\t\tis_linkonce = FALSE;\n\t\t\t/*\n\t\t\tif (method_name)\n\t\t\t\tprintf (\"%s %s\\n\", mono_method_full_name (cfg->method, 1), method_name);\n\t\t\telse\n\t\t\t\tprintf (\"%s\\n\", mono_method_full_name (cfg->method, 1));\n\t\t\t*/\n\t\t}\n\t\tif (!method_name)\n\t\t\tmethod_name = mono_aot_get_method_name (cfg);\n\t\tcfg->llvm_method_name = g_strdup (method_name);\n\t} else {\n\t\tinit_jit_module (cfg->domain);\n\t\tctx->module = (MonoLLVMModule*)domain_jit_info (cfg->domain)->llvm_module;\n\t\tmethod_name = mono_method_full_name (cfg->method, TRUE);\n\t}\n\tctx->method_name = method_name;\n\tctx->is_linkonce = is_linkonce;\n\n#if LLVM_API_VERSION > 100\n\tif (cfg->compile_aot)\n\t\tctx->lmodule = ctx->module->lmodule;\n\telse\n\t\tctx->lmodule = LLVMModuleCreateWithName (g_strdup_printf (\"jit-module-%s\", cfg->method->name));\n#else\n\tctx->lmodule = ctx->module->lmodule;\n#endif\n\tctx->llvm_only = ctx->module->llvm_only;\n\n\temit_method_inner (ctx);\n\n\tif (!ctx_ok (ctx)) {\n\t\tif (ctx->lmethod) {\n\t\t\t/* Need to add unused phi nodes as they can be referenced by other values */\n\t\t\tLLVMBasicBlockRef phi_bb = LLVMAppendBasicBlock (ctx->lmethod, \"PHI_BB\");\n\t\t\tLLVMBuilderRef builder;\n\n\t\t\tbuilder = create_builder (ctx);\n\t\t\tLLVMPositionBuilderAtEnd (builder, phi_bb);\n\n\t\t\tfor (i = 0; i < ctx->phi_values->len; ++i) {\n\t\t\t\tLLVMValueRef v = (LLVMValueRef)g_ptr_array_index (ctx->phi_values, i);\n\t\t\t\tif (LLVMGetInstructionParent (v) == NULL)\n\t\t\t\t\tLLVMInsertIntoBuilder (builder, v);\n\t\t\t}\n\t\t\n\t\t\tLLVMDeleteFunction (ctx->lmethod);\n\t\t}\n\t}\n\n\tfree_ctx (ctx);\n\n\tmono_native_tls_set_value (current_cfg_tls_id, NULL);\n\n\tmono_loader_unlock ();\n}\n\nstatic void\nemit_method_inner (EmitContext *ctx)\n{\n\tMonoCompile *cfg = ctx->cfg;\n\tMonoMethodSignature *sig;\n\tMonoBasicBlock *bb;\n\tLLVMTypeRef method_type;\n\tLLVMValueRef method = NULL;\n\tLLVMValueRef *values = ctx->values;\n\tint i, max_block_num, bb_index;\n\tgboolean last = FALSE;\n\tLLVMCallInfo *linfo;\n\tLLVMModuleRef lmodule = ctx->lmodule;\n\tBBInfo *bblocks;\n\tGPtrArray *bblock_list = ctx->bblock_list;\n\tMonoMethodHeader *header;\n\tMonoExceptionClause *clause;\n\tchar **names;\n\n\tif (cfg->gsharedvt && !cfg->llvm_only) {\n\t\tset_failure (ctx, \"gsharedvt\");\n\t\treturn;\n\t}\n\n#if 1\n\t{\n\t\tstatic int count = 0;\n\t\tcount ++;\n\n\t\tchar *llvm_count_str = g_getenv (\"LLVM_COUNT\");\n\t\tif (llvm_count_str) {\n\t\t\tint lcount = atoi (llvm_count_str);\n\t\t\tg_free (llvm_count_str);\n\t\t\tif (count == lcount) {\n\t\t\t\tprintf (\"LAST: %s\\n\", mono_method_full_name (cfg->method, TRUE));\n\t\t\t\tfflush (stdout);\n\t\t\t\tlast = TRUE;\n\t\t\t}\n\t\t\tif (count > lcount) {\n\t\t\t\tset_failure (ctx, \"count\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tsig = mono_method_signature (cfg->method);\n\tctx->sig = sig;\n\n\tlinfo = get_llvm_call_info (cfg, sig);\n\tctx->linfo = linfo;\n\tif (!ctx_ok (ctx))\n\t\treturn;\n\n\tif (cfg->rgctx_var)\n\t\tlinfo->rgctx_arg = TRUE;\n\tctx->method_type = method_type = sig_to_llvm_sig_full (ctx, sig, linfo);\n\tif (!ctx_ok (ctx))\n\t\treturn;\n\n\tmethod = LLVMAddFunction (lmodule, ctx->method_name, method_type);\n\tctx->lmethod = method;\n\n\tif (!cfg->llvm_only)\n\t\tLLVMSetFunctionCallConv (method, LLVMMono1CallConv);\n\tLLVMSetLinkage (method, LLVMPrivateLinkage);\n\n\tmono_llvm_add_func_attr (method, LLVM_ATTR_UW_TABLE);\n\n\tif (cfg->compile_aot) {\n\t\tLLVMSetLinkage (method, LLVMInternalLinkage);\n\t\tif (ctx->module->external_symbols) {\n\t\t\tLLVMSetLinkage (method, LLVMExternalLinkage);\n\t\t\tLLVMSetVisibility (method, LLVMHiddenVisibility);\n\t\t}\n\t\tif (ctx->is_linkonce) {\n\t\t\tLLVMSetLinkage (method, LLVMLinkOnceAnyLinkage);\n\t\t\tLLVMSetVisibility (method, LLVMDefaultVisibility);\n\t\t}\n\t} else {\n#if LLVM_API_VERSION > 100\n\t\tLLVMSetLinkage (method, LLVMExternalLinkage);\n#else\n\t\tLLVMSetLinkage (method, LLVMPrivateLinkage);\n#endif\n\t}\n\n\tif (cfg->method->save_lmf && !cfg->llvm_only) {\n\t\tset_failure (ctx, \"lmf\");\n\t\treturn;\n\t}\n\n\tif (sig->pinvoke && cfg->method->wrapper_type != MONO_WRAPPER_RUNTIME_INVOKE && !cfg->llvm_only) {\n\t\tset_failure (ctx, \"pinvoke signature\");\n\t\treturn;\n\t}\n\n\theader = cfg->header;\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_FINALLY && clause->flags != MONO_EXCEPTION_CLAUSE_FAULT && clause->flags != MONO_EXCEPTION_CLAUSE_NONE) {\n\t\t    set_failure (ctx, \"non-finally/catch/fault clause.\");\n\t\t\treturn;\n\t\t}\n\t}\n\tif (header->num_clauses || (cfg->method->iflags & METHOD_IMPL_ATTRIBUTE_NOINLINING) || cfg->no_inline)\n\t\t/* We can't handle inlined methods with clauses */\n\t\tmono_llvm_add_func_attr (method, LLVM_ATTR_NO_INLINE);\n\n\tif (linfo->rgctx_arg) {\n\t\tctx->rgctx_arg = LLVMGetParam (method, linfo->rgctx_arg_pindex);\n\t\tctx->rgctx_arg_pindex = linfo->rgctx_arg_pindex;\n\t\t/*\n\t\t * We mark the rgctx parameter with the inreg attribute, which is mapped to\n\t\t * MONO_ARCH_RGCTX_REG in the Mono calling convention in llvm, i.e.\n\t\t * CC_X86_64_Mono in X86CallingConv.td.\n\t\t */\n\t\tif (!ctx->llvm_only)\n\t\t\tmono_llvm_add_param_attr (ctx->rgctx_arg, LLVM_ATTR_IN_REG);\n\t\tLLVMSetValueName (ctx->rgctx_arg, \"rgctx\");\n\t} else {\n\t\tctx->rgctx_arg_pindex = -1;\n\t}\n\tif (cfg->vret_addr) {\n\t\tvalues [cfg->vret_addr->dreg] = LLVMGetParam (method, linfo->vret_arg_pindex);\n\t\tLLVMSetValueName (values [cfg->vret_addr->dreg], \"vret\");\n\t\tif (linfo->ret.storage == LLVMArgVtypeByRef) {\n\t\t\tmono_llvm_add_param_attr (LLVMGetParam (method, linfo->vret_arg_pindex), LLVM_ATTR_STRUCT_RET);\n\t\t\tmono_llvm_add_param_attr (LLVMGetParam (method, linfo->vret_arg_pindex), LLVM_ATTR_NO_ALIAS);\n\t\t}\n\t}\n\n\tif (sig->hasthis) {\n\t\tctx->this_arg_pindex = linfo->this_arg_pindex;\n\t\tctx->this_arg = LLVMGetParam (method, linfo->this_arg_pindex);\n\t\tvalues [cfg->args [0]->dreg] = ctx->this_arg;\n\t\tLLVMSetValueName (values [cfg->args [0]->dreg], \"this\");\n\t}\n\n\tnames = g_new (char *, sig->param_count);\n\tmono_method_get_param_names (cfg->method, (const char **) names);\n\n\t/* Set parameter names/attributes */\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tLLVMArgInfo *ainfo = &linfo->args [i + sig->hasthis];\n\t\tchar *name;\n\t\tint pindex = ainfo->pindex + ainfo->ndummy_fpargs;\n\t\tint j;\n\n\t\tfor (j = 0; j < ainfo->ndummy_fpargs; ++j) {\n\t\t\tname = g_strdup_printf (\"dummy_%d_%d\", i, j);\n\t\t\tLLVMSetValueName (LLVMGetParam (method, ainfo->pindex + j), name);\n\t\t\tg_free (name);\n\t\t}\n\n\t\tif (ainfo->storage == LLVMArgVtypeInReg && ainfo->pair_storage [0] == LLVMArgNone && ainfo->pair_storage [1] == LLVMArgNone)\n\t\t\tcontinue;\n\n\t\tvalues [cfg->args [i + sig->hasthis]->dreg] = LLVMGetParam (method, pindex);\n\t\tif (ainfo->storage == LLVMArgGsharedvtFixed || ainfo->storage == LLVMArgGsharedvtFixedVtype) {\n\t\t\tif (names [i] && names [i][0] != '\\0')\n\t\t\t\tname = g_strdup_printf (\"p_arg_%s\", names [i]);\n\t\t\telse\n\t\t\t\tname = g_strdup_printf (\"p_arg_%d\", i);\n\t\t} else {\n\t\t\tif (names [i] && names [i][0] != '\\0')\n\t\t\t\tname = g_strdup_printf (\"arg_%s\", names [i]);\n\t\t\telse\n\t\t\t\tname = g_strdup_printf (\"arg_%d\", i);\n\t\t}\n\t\tLLVMSetValueName (values [cfg->args [i + sig->hasthis]->dreg], name);\n\t\tg_free (name);\n\t\tif (ainfo->storage == LLVMArgVtypeByVal)\n\t\t\tmono_llvm_add_param_attr (LLVMGetParam (method, pindex), LLVM_ATTR_BY_VAL);\n\n\t\tif (ainfo->storage == LLVMArgVtypeByRef) {\n\t\t\t/* For OP_LDADDR */\n\t\t\tcfg->args [i + sig->hasthis]->opcode = OP_VTARG_ADDR;\n\t\t}\n\t}\n\tg_free (names);\n\n\tif (ctx->module->emit_dwarf && cfg->compile_aot && mono_debug_enabled ()) {\n\t\tctx->minfo = mono_debug_lookup_method (cfg->method);\n\t\tctx->dbg_md = emit_dbg_subprogram (ctx, cfg, method, ctx->method_name);\n\t}\n\n\tmax_block_num = 0;\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb)\n\t\tmax_block_num = MAX (max_block_num, bb->block_num);\n\tctx->bblocks = bblocks = g_new0 (BBInfo, max_block_num + 1);\n\n\t/* Add branches between non-consecutive bblocks */\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb) {\n\t\tif (bb->last_ins && MONO_IS_COND_BRANCH_OP (bb->last_ins) &&\n\t\t\tbb->next_bb != bb->last_ins->inst_false_bb) {\n\t\t\t\n\t\t\tMonoInst *inst = (MonoInst*)mono_mempool_alloc0 (cfg->mempool, sizeof (MonoInst));\n\t\t\tinst->opcode = OP_BR;\n\t\t\tinst->inst_target_bb = bb->last_ins->inst_false_bb;\n\t\t\tmono_bblock_add_inst (bb, inst);\n\t\t}\n\t}\n\n\t/*\n\t * Make a first pass over the code to precreate PHI nodes/set INDIRECT flags.\n\t */\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb) {\n\t\tMonoInst *ins;\n\t\tLLVMBuilderRef builder;\n\t\tchar *dname;\n\t\tchar dname_buf[128];\n\n\t\tbuilder = create_builder (ctx);\n\n\t\tfor (ins = bb->code; ins; ins = ins->next) {\n\t\t\tswitch (ins->opcode) {\n\t\t\tcase OP_PHI:\n\t\t\tcase OP_FPHI:\n\t\t\tcase OP_VPHI:\n\t\t\tcase OP_XPHI: {\n\t\t\t\tLLVMTypeRef phi_type = llvm_type_to_stack_type (cfg, type_to_llvm_type (ctx, &ins->klass->byval_arg));\n\n\t\t\t\tif (!ctx_ok (ctx))\n\t\t\t\t\treturn;\n\n\t\t\t\tif (ins->opcode == OP_VPHI) {\n\t\t\t\t\t/* Treat valuetype PHI nodes as operating on the address itself */\n\t\t\t\t\tg_assert (ins->klass);\n\t\t\t\t\tphi_type = LLVMPointerType (type_to_llvm_type (ctx, &ins->klass->byval_arg), 0);\n\t\t\t\t}\n\n\t\t\t\t/* \n\t\t\t\t * Have to precreate these, as they can be referenced by\n\t\t\t\t * earlier instructions.\n\t\t\t\t */\n\t\t\t\tsprintf (dname_buf, \"t%d\", ins->dreg);\n\t\t\t\tdname = dname_buf;\n\t\t\t\tvalues [ins->dreg] = LLVMBuildPhi (builder, phi_type, dname);\n\n\t\t\t\tif (ins->opcode == OP_VPHI)\n\t\t\t\t\tctx->addresses [ins->dreg] = values [ins->dreg];\n\n\t\t\t\tg_ptr_array_add (ctx->phi_values, values [ins->dreg]);\n\n\t\t\t\t/* \n\t\t\t\t * Set the expected type of the incoming arguments since these have\n\t\t\t\t * to have the same type.\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < ins->inst_phi_args [0]; i++) {\n\t\t\t\t\tint sreg1 = ins->inst_phi_args [i + 1];\n\t\t\t\t\t\n\t\t\t\t\tif (sreg1 != -1) {\n\t\t\t\t\t\tif (ins->opcode == OP_VPHI)\n\t\t\t\t\t\t\tctx->is_vphi [sreg1] = TRUE;\n\t\t\t\t\t\tctx->vreg_types [sreg1] = phi_type;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase OP_LDADDR:\n\t\t\t\t((MonoInst*)ins->inst_p0)->flags |= MONO_INST_INDIRECT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* \n\t * Create an ordering for bblocks, use the depth first order first, then\n\t * put the exception handling bblocks last.\n\t */\n\tfor (bb_index = 0; bb_index < cfg->num_bblocks; ++bb_index) {\n\t\tbb = cfg->bblocks [bb_index];\n\t\tif (!(bb->region != -1 && !MONO_BBLOCK_IS_IN_REGION (bb, MONO_REGION_TRY))) {\n\t\t\tg_ptr_array_add (bblock_list, bb);\n\t\t\tbblocks [bb->block_num].added = TRUE;\n\t\t}\n\t}\n\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb) {\n\t\tif (!bblocks [bb->block_num].added)\n\t\t\tg_ptr_array_add (bblock_list, bb);\n\t}\n\n\t/*\n\t * Second pass: generate code.\n\t */\n\t// Emit entry point\n\tLLVMBuilderRef entry_builder = create_builder (ctx);\n\tLLVMBasicBlockRef entry_bb = get_bb (ctx, cfg->bb_entry);\n\tLLVMPositionBuilderAtEnd (entry_builder, entry_bb);\n\temit_entry_bb (ctx, entry_builder);\n\n\t// Make landing pads first\n\tctx->exc_meta = g_hash_table_new_full (NULL, NULL, NULL, NULL);\n\n\tif (ctx->llvm_only) {\n\t\tsize_t group_index = 0;\n\t\twhile (group_index < cfg->header->num_clauses) {\n\t\t\tint count = 0;\n\t\t\tsize_t cursor = group_index;\n\t\t\twhile (cursor < cfg->header->num_clauses &&\n\t\t\t\t   CLAUSE_START (&cfg->header->clauses [cursor]) == CLAUSE_START (&cfg->header->clauses [group_index]) &&\n\t\t\t\t   CLAUSE_END (&cfg->header->clauses [cursor]) == CLAUSE_END (&cfg->header->clauses [group_index])) {\n\t\t\t\tcount++;\n\t\t\t\tcursor++;\n\t\t\t}\n\n\t\t\tLLVMBasicBlockRef lpad_bb = emit_landing_pad (ctx, group_index, count);\n\t\t\tintptr_t key = CLAUSE_END (&cfg->header->clauses [group_index]);\n\t\t\tg_hash_table_insert (ctx->exc_meta, (gpointer)key, lpad_bb);\n\n\t\t\tgroup_index = cursor;\n\t\t}\n\t}\n\n\tfor (bb_index = 0; bb_index < bblock_list->len; ++bb_index) {\n\t\tbb = (MonoBasicBlock*)g_ptr_array_index (bblock_list, bb_index);\n\n\t\t// Prune unreachable mono BBs.\n\t\tif (!(bb == cfg->bb_entry || bb->in_count > 0))\n\t\t\tcontinue;\n\n\t\tprocess_bb (ctx, bb);\n\t\tif (!ctx_ok (ctx))\n\t\t\treturn;\n\t}\n\tg_hash_table_destroy (ctx->exc_meta);\n\n\tmono_memory_barrier ();\n\n\t/* Add incoming phi values */\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb) {\n\t\tGSList *l, *ins_list;\n\n\t\tins_list = bblocks [bb->block_num].phi_nodes;\n\n\t\tfor (l = ins_list; l; l = l->next) {\n\t\t\tPhiNode *node = (PhiNode*)l->data;\n\t\t\tMonoInst *phi = node->phi;\n\t\t\tint sreg1 = node->sreg;\n\t\t\tLLVMBasicBlockRef in_bb;\n\n\t\t\tif (sreg1 == -1)\n\t\t\t\tcontinue;\n\n\t\t\tin_bb = get_end_bb (ctx, node->in_bb);\n\n\t\t\tif (ctx->unreachable [node->in_bb->block_num])\n\t\t\t\tcontinue;\n\n\t\t\tif (!values [sreg1]) {\n\t\t\t\t/* Can happen with values in EH clauses */\n\t\t\t\tset_failure (ctx, \"incoming phi sreg1\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (phi->opcode == OP_VPHI) {\n\t\t\t\tg_assert (LLVMTypeOf (ctx->addresses [sreg1]) == LLVMTypeOf (values [phi->dreg]));\n\t\t\t\tLLVMAddIncoming (values [phi->dreg], &ctx->addresses [sreg1], &in_bb, 1);\n\t\t\t} else {\n\t\t\t\tif (LLVMTypeOf (values [sreg1]) != LLVMTypeOf (values [phi->dreg])) {\n\t\t\t\t\tset_failure (ctx, \"incoming phi arg type mismatch\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tg_assert (LLVMTypeOf (values [sreg1]) == LLVMTypeOf (values [phi->dreg]));\n\t\t\t\tLLVMAddIncoming (values [phi->dreg], &values [sreg1], &in_bb, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Nullify empty phi instructions */\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb) {\n\t\tGSList *l, *ins_list;\n\n\t\tins_list = bblocks [bb->block_num].phi_nodes;\n\n\t\tfor (l = ins_list; l; l = l->next) {\n\t\t\tPhiNode *node = (PhiNode*)l->data;\n\t\t\tMonoInst *phi = node->phi;\n\t\t\tLLVMValueRef phi_ins = values [phi->dreg];\n\n\t\t\tif (!phi_ins)\n\t\t\t\t/* Already removed */\n\t\t\t\tcontinue;\n\n\t\t\tif (LLVMCountIncoming (phi_ins) == 0) {\n\t\t\t\tmono_llvm_replace_uses_of (phi_ins, LLVMConstNull (LLVMTypeOf (phi_ins)));\n\t\t\t\tLLVMInstructionEraseFromParent (phi_ins);\n\t\t\t\tvalues [phi->dreg] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Create the SWITCH statements for ENDFINALLY instructions */\n\tfor (bb = cfg->bb_entry; bb; bb = bb->next_bb) {\n\t\tBBInfo *info = &bblocks [bb->block_num];\n\t\tGSList *l;\n\t\tfor (l = info->endfinally_switch_ins_list; l; l = l->next) {\n\t\t\tLLVMValueRef switch_ins = (LLVMValueRef)l->data;\n\t\t\tGSList *bb_list = info->call_handler_return_bbs;\n\n\t\t\tGSList *bb_list_iter;\n\t\t\ti = 0;\n\t\t\tfor (bb_list_iter = bb_list; bb_list_iter; bb_list_iter = g_slist_next (bb_list_iter)) {\n\t\t\t\tLLVMAddCase (switch_ins, LLVMConstInt (LLVMInt32Type (), i + 1, FALSE), (LLVMBasicBlockRef)bb_list_iter->data);\n\t\t\t\ti ++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Initialize the method if needed */\n\tif (cfg->compile_aot && ctx->llvm_only) {\n\t\t// FIXME: Add more shared got entries\n\t\tctx->builder = create_builder (ctx);\n\t\tLLVMPositionBuilderAtEnd (ctx->builder, ctx->init_bb);\n\n\t\tctx->module->max_method_idx = MAX (ctx->module->max_method_idx, cfg->method_index);\n\n\t\t// FIXME: beforefieldinit\n\t\t/*\n\t\t * NATIVE_TO_MANAGED methods might be called on a thread not attached to the runtime, so they are initialized when loaded\n\t\t * in load_method ().\n\t\t */\n\t\tif ((ctx->has_got_access || mono_class_get_cctor (cfg->method->klass)) && !(cfg->method->wrapper_type == MONO_WRAPPER_NATIVE_TO_MANAGED)) {\n\t\t\t/*\n\t\t\t * linkonce methods shouldn't have initialization,\n\t\t\t * because they might belong to assemblies which\n\t\t\t * haven't been loaded yet.\n\t\t\t */\n\t\t\tg_assert (!ctx->is_linkonce);\n\t\t\temit_init_method (ctx);\n\t\t} else {\n\t\t\tLLVMBuildBr (ctx->builder, ctx->inited_bb);\n\t\t}\n\t}\n\n\tif (cfg->llvm_only) {\n\t\tGHashTableIter iter;\n\t\tMonoMethod *method;\n\t\tGSList *callers, *l, *l2;\n\n\t\t/*\n\t\t * Add the contents of ctx->method_to_callers to module->method_to_callers.\n\t\t * We can't do this earlier, as it contains llvm instructions which can be\n\t\t * freed if compilation fails.\n\t\t * FIXME: Get rid of this when all methods can be llvm compiled.\n\t\t */\n\t\tg_hash_table_iter_init (&iter, ctx->method_to_callers);\n\t\twhile (g_hash_table_iter_next (&iter, (void**)&method, (void**)&callers)) {\n\t\t\tfor (l = callers; l; l = l->next) {\n\t\t\t\tl2 = (GSList*)g_hash_table_lookup (ctx->module->method_to_callers, method);\n\t\t\t\tl2 = g_slist_prepend (l2, l->data);\n\t\t\t\tg_hash_table_insert (ctx->module->method_to_callers, method, l2);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cfg->verbose_level > 1)\n\t\tmono_llvm_dump_value (method);\n\n\tif (cfg->compile_aot && !cfg->llvm_only)\n\t\tmark_as_used (ctx->module, method);\n\n\tif (!cfg->llvm_only) {\n\t\tLLVMValueRef md_args [16];\n\t\tLLVMValueRef md_node;\n\t\tint method_index;\n\n\t\tif (cfg->compile_aot)\n\t\t\tmethod_index = mono_aot_get_method_index (cfg->orig_method);\n\t\telse\n\t\t\tmethod_index = 1;\n\t\tmd_args [0] = LLVMMDString (ctx->method_name, strlen (ctx->method_name));\n\t\tmd_args [1] = LLVMConstInt (LLVMInt32Type (), method_index, FALSE);\n\t\tmd_node = LLVMMDNode (md_args, 2);\n\t\tLLVMAddNamedMetadataOperand (lmodule, \"mono.function_indexes\", md_node);\n\t\t//LLVMSetMetadata (method, md_kind, LLVMMDNode (&md_arg, 1));\n\t}\n\n\tif (cfg->compile_aot) {\n\t\t/* Don't generate native code, keep the LLVM IR */\n\t\tif (cfg->verbose_level)\n\t\t\tprintf (\"%s emitted as %s\\n\", mono_method_full_name (cfg->method, TRUE), ctx->method_name);\n\n#if LLVM_API_VERSION < 100\n\t\t/* VerifyFunction can't handle some of the debug info created by DIBuilder in llvm 3.9 */\n\t\tint err = LLVMVerifyFunction(ctx->lmethod, LLVMPrintMessageAction);\n\t\tg_assert (err == 0);\n#endif\n\t} else {\n\t\t//LLVMVerifyFunction(method, 0);\n#if LLVM_API_VERSION > 100\n\t\tMonoDomain *domain = mono_domain_get ();\n\t\tMonoJitDomainInfo *domain_info;\n\t\tint nvars = g_hash_table_size (ctx->jit_callees);\n\t\tLLVMValueRef *callee_vars = g_new0 (LLVMValueRef, nvars); \n\t\tgpointer *callee_addrs = g_new0 (gpointer, nvars);\n\t\tGHashTableIter iter;\n\t\tLLVMValueRef var;\n\t\tMonoMethod *callee;\n\t\tgpointer eh_frame;\n\n\t\t/*\n\t\t * Compute the addresses of the LLVM globals pointing to the\n\t\t * methods called by the current method. Pass it to the trampoline\n\t\t * code so it can update them after their corresponding method was\n\t\t * compiled.\n\t\t */\n\t\tg_hash_table_iter_init (&iter, ctx->jit_callees);\n\t\ti = 0;\n\t\twhile (g_hash_table_iter_next (&iter, NULL, (void**)&var))\n\t\t\tcallee_vars [i ++] = var;\n\n\t\tcfg->native_code = mono_llvm_compile_method (ctx->module->mono_ee, ctx->lmethod, nvars, callee_vars, callee_addrs, &eh_frame);\n\n\t\tdecode_llvm_eh_info (ctx, eh_frame);\n\n\t\tmono_domain_lock (domain);\n\t\tdomain_info = domain_jit_info (domain);\n\t\tif (!domain_info->llvm_jit_callees)\n\t\t\tdomain_info->llvm_jit_callees = g_hash_table_new (NULL, NULL);\n\t\tg_hash_table_iter_init (&iter, ctx->jit_callees);\n\t\ti = 0;\n\t\twhile (g_hash_table_iter_next (&iter, (void**)&callee, (void**)&var)) {\n\t\t\tGSList *addrs = g_hash_table_lookup (domain_info->llvm_jit_callees, callee);\n\t\t\taddrs = g_slist_prepend (addrs, callee_addrs [i]);\n\t\t\tg_hash_table_insert (domain_info->llvm_jit_callees, callee, addrs);\n\t\t\ti ++;\n\t\t}\n\t\tmono_domain_unlock (domain);\n#else\n\t\tmono_llvm_optimize_method (ctx->module->mono_ee, ctx->lmethod);\n\n\t\tif (cfg->verbose_level > 1)\n\t\t\tmono_llvm_dump_value (ctx->lmethod);\n\n\t\tcfg->native_code = (unsigned char*)LLVMGetPointerToGlobal (ctx->module->ee, ctx->lmethod);\n\n\t\t/* Set by emit_cb */\n\t\tg_assert (cfg->code_len);\n#endif\n\t}\n\n\tif (ctx->module->method_to_lmethod)\n\t\tg_hash_table_insert (ctx->module->method_to_lmethod, cfg->method, ctx->lmethod);\n\tif (ctx->module->idx_to_lmethod)\n\t\tg_hash_table_insert (ctx->module->idx_to_lmethod, GINT_TO_POINTER (cfg->method_index), ctx->lmethod);\n\n\tif (ctx->llvm_only && cfg->orig_method->klass->valuetype && !(cfg->orig_method->flags & METHOD_ATTRIBUTE_STATIC))\n\t\temit_unbox_tramp (ctx, ctx->method_name, ctx->method_type, ctx->lmethod, cfg->method_index);\n}\n\n/*\n * mono_llvm_create_vars:\n *\n *   Same as mono_arch_create_vars () for LLVM.\n */\nvoid\nmono_llvm_create_vars (MonoCompile *cfg)\n{\n\tMonoMethodSignature *sig;\n\n\tsig = mono_method_signature (cfg->method);\n\tif (cfg->gsharedvt && cfg->llvm_only) {\n\t\tgboolean vretaddr = FALSE;\n\n\t\tif (mini_is_gsharedvt_variable_signature (sig) && sig->ret->type != MONO_TYPE_VOID) {\n\t\t\tvretaddr = TRUE;\n\t\t} else {\n\t\t\tMonoMethodSignature *sig = mono_method_signature (cfg->method);\n\t\t\tLLVMCallInfo *linfo;\n\n\t\t\tlinfo = get_llvm_call_info (cfg, sig);\n\t\t\tvretaddr = (linfo->ret.storage == LLVMArgVtypeRetAddr || linfo->ret.storage == LLVMArgVtypeByRef || linfo->ret.storage == LLVMArgGsharedvtFixed || linfo->ret.storage == LLVMArgGsharedvtVariable || linfo->ret.storage == LLVMArgGsharedvtFixedVtype);\n\t\t}\n\t\tif (vretaddr) {\n\t\t\t/*\n\t\t\t * Creating vret_addr forces CEE_SETRET to store the result into it,\n\t\t\t * so we don't have to generate any code in our OP_SETRET case.\n\t\t\t */\n\t\t\tcfg->vret_addr = mono_compile_create_var (cfg, &mono_get_intptr_class ()->byval_arg, OP_ARG);\n\t\t\tif (G_UNLIKELY (cfg->verbose_level > 1)) {\n\t\t\t\tprintf (\"vret_addr = \");\n\t\t\t\tmono_print_ins (cfg->vret_addr);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmono_arch_create_vars (cfg);\n\t}\n}\n\n/*\n * mono_llvm_emit_call:\n *\n *   Same as mono_arch_emit_call () for LLVM.\n */\nvoid\nmono_llvm_emit_call (MonoCompile *cfg, MonoCallInst *call)\n{\n\tMonoInst *in;\n\tMonoMethodSignature *sig;\n\tint i, n, stack_size;\n\tLLVMArgInfo *ainfo;\n\n\tstack_size = 0;\n\n\tsig = call->signature;\n\tn = sig->param_count + sig->hasthis;\n\n\tcall->cinfo = get_llvm_call_info (cfg, sig);\n\n\tif (cfg->disable_llvm)\n\t\treturn;\n\n\tif (sig->call_convention == MONO_CALL_VARARG) {\n\t\tcfg->exception_message = g_strdup (\"varargs\");\n\t\tcfg->disable_llvm = TRUE;\n\t}\n\n\tfor (i = 0; i < n; ++i) {\n\t\tMonoInst *ins;\n\n\t\tainfo = call->cinfo->args + i;\n\n\t\tin = call->args [i];\n\t\t\t\n\t\t/* Simply remember the arguments */\n\t\tswitch (ainfo->storage) {\n\t\tcase LLVMArgNormal: {\n\t\t\tMonoType *t = (sig->hasthis && i == 0) ? &mono_get_intptr_class ()->byval_arg : ainfo->type;\n\t\t\tint opcode;\n\n\t\t\topcode = mono_type_to_regmove (cfg, t);\n\t\t\tif (opcode == OP_FMOVE) {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_FMOVE);\n\t\t\t\tins->dreg = mono_alloc_freg (cfg);\n\t\t\t} else if (opcode == OP_LMOVE) {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_LMOVE);\n\t\t\t\tins->dreg = mono_alloc_lreg (cfg);\n\t\t\t} else if (opcode == OP_RMOVE) {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_RMOVE);\n\t\t\t\tins->dreg = mono_alloc_freg (cfg);\n\t\t\t} else {\n\t\t\t\tMONO_INST_NEW (cfg, ins, OP_MOVE);\n\t\t\t\tins->dreg = mono_alloc_ireg (cfg);\n\t\t\t}\n\t\t\tins->sreg1 = in->dreg;\n\t\t\tbreak;\n\t\t}\n\t\tcase LLVMArgVtypeByVal:\n\t\tcase LLVMArgVtypeByRef:\n\t\tcase LLVMArgVtypeInReg:\n\t\tcase LLVMArgVtypeAsScalar:\n\t\tcase LLVMArgAsIArgs:\n\t\tcase LLVMArgAsFpArgs:\n\t\tcase LLVMArgGsharedvtVariable:\n\t\tcase LLVMArgGsharedvtFixed:\n\t\tcase LLVMArgGsharedvtFixedVtype:\n\t\t\tMONO_INST_NEW (cfg, ins, OP_LLVM_OUTARG_VT);\n\t\t\tins->dreg = mono_alloc_ireg (cfg);\n\t\t\tins->sreg1 = in->dreg;\n\t\t\tins->inst_p0 = mono_mempool_alloc0 (cfg->mempool, sizeof (LLVMArgInfo));\n\t\t\tmemcpy (ins->inst_p0, ainfo, sizeof (LLVMArgInfo));\n\t\t\tins->inst_vtype = ainfo->type;\n\t\t\tins->klass = mono_class_from_mono_type (ainfo->type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcfg->exception_message = g_strdup (\"ainfo->storage\");\n\t\t\tcfg->disable_llvm = TRUE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (!cfg->disable_llvm) {\n\t\t\tMONO_ADD_INS (cfg->cbb, ins);\n\t\t\tmono_call_inst_add_outarg_reg (cfg, call, ins->dreg, 0, FALSE);\n\t\t}\n\t}\n}\n\nstatic unsigned char*\nalloc_cb (LLVMValueRef function, int size)\n{\n\tMonoCompile *cfg;\n\n\tcfg = (MonoCompile*)mono_native_tls_get_value (current_cfg_tls_id);\n\n\tif (cfg) {\n\t\t// FIXME: dynamic\n\t\treturn (unsigned char*)mono_domain_code_reserve (cfg->domain, size);\n\t} else {\n\t\treturn (unsigned char*)mono_domain_code_reserve (mono_domain_get (), size);\n\t}\n}\n\nstatic void\nemitted_cb (LLVMValueRef function, void *start, void *end)\n{\n\tMonoCompile *cfg;\n\n\tcfg = (MonoCompile*)mono_native_tls_get_value (current_cfg_tls_id);\n\tg_assert (cfg);\n\tcfg->code_len = (guint8*)end - (guint8*)start;\n}\n\nstatic void\nexception_cb (void *data)\n{\n\tMonoCompile *cfg;\n\tMonoJitExceptionInfo *ei;\n\tguint32 ei_len, i, j, nested_len, nindex;\n\tgpointer *type_info;\n\tint this_reg, this_offset;\n\n\tcfg = (MonoCompile*)mono_native_tls_get_value (current_cfg_tls_id);\n\tg_assert (cfg);\n\n\t/*\n\t * data points to a DWARF FDE structure, convert it to our unwind format and\n\t * save it.\n\t * An alternative would be to save it directly, and modify our unwinder to work\n\t * with it.\n\t */\n\tcfg->encoded_unwind_ops = mono_unwind_decode_fde ((guint8*)data, &cfg->encoded_unwind_ops_len, NULL, &ei, &ei_len, &type_info, &this_reg, &this_offset);\n\tif (cfg->verbose_level > 1)\n\t\tmono_print_unwind_info (cfg->encoded_unwind_ops, cfg->encoded_unwind_ops_len);\n\n\t/* Count nested clauses */\n\tnested_len = 0;\n\tfor (i = 0; i < ei_len; ++i) {\n\t\tgint32 cindex1 = *(gint32*)type_info [i];\n\t\tMonoExceptionClause *clause1 = &cfg->header->clauses [cindex1];\n\n\t\tfor (j = 0; j < cfg->header->num_clauses; ++j) {\n\t\t\tint cindex2 = j;\n\t\t\tMonoExceptionClause *clause2 = &cfg->header->clauses [cindex2];\n\n\t\t\tif (cindex1 != cindex2 && clause1->try_offset >= clause2->try_offset && clause1->handler_offset <= clause2->handler_offset) {\n\t\t\t\tnested_len ++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcfg->llvm_ex_info = (MonoJitExceptionInfo*)mono_mempool_alloc0 (cfg->mempool, (ei_len + nested_len) * sizeof (MonoJitExceptionInfo));\n\tcfg->llvm_ex_info_len = ei_len + nested_len;\n\tmemcpy (cfg->llvm_ex_info, ei, ei_len * sizeof (MonoJitExceptionInfo));\n\t/* Fill the rest of the information from the type info */\n\tfor (i = 0; i < ei_len; ++i) {\n\t\tgint32 clause_index = *(gint32*)type_info [i];\n\t\tMonoExceptionClause *clause = &cfg->header->clauses [clause_index];\n\n\t\tcfg->llvm_ex_info [i].flags = clause->flags;\n\t\tcfg->llvm_ex_info [i].data.catch_class = clause->data.catch_class;\n\t\tcfg->llvm_ex_info [i].clause_index = clause_index;\n\t}\n\n\t/*\n\t * For nested clauses, the LLVM produced exception info associates the try interval with\n\t * the innermost handler, while mono expects it to be associated with all nesting clauses.\n\t * So add new clauses which use the IL info (catch class etc.) from the nesting clause,\n\t * and everything else from the nested clause.\n\t */\n\tnindex = ei_len;\n\tfor (i = 0; i < ei_len; ++i) {\n\t\tgint32 cindex1 = *(gint32*)type_info [i];\n\t\tMonoExceptionClause *clause1 = &cfg->header->clauses [cindex1];\n\n\t\tfor (j = 0; j < cfg->header->num_clauses; ++j) {\n\t\t\tint cindex2 = j;\n\t\t\tMonoExceptionClause *clause2 = &cfg->header->clauses [cindex2];\n\t\t\tMonoJitExceptionInfo *nesting_ei, *nested_ei;\n\n\t\t\tif (cindex1 != cindex2 && clause1->try_offset >= clause2->try_offset && clause1->handler_offset <= clause2->handler_offset) {\n\t\t\t\t/* clause1 is the nested clause */\n\t\t\t\tnested_ei = &cfg->llvm_ex_info [i];\n\t\t\t\tnesting_ei = &cfg->llvm_ex_info [nindex];\n\t\t\t\tnindex ++;\n\n\t\t\t\tmemcpy (nesting_ei, nested_ei, sizeof (MonoJitExceptionInfo));\n\n\t\t\t\tnesting_ei->flags = clause2->flags;\n\t\t\t\tnesting_ei->data.catch_class = clause2->data.catch_class;\n\t\t\t\tnesting_ei->clause_index = cindex2;\n\t\t\t}\n\t\t}\n\t}\n\tg_assert (nindex == ei_len + nested_len);\n\tcfg->llvm_this_reg = this_reg;\n\tcfg->llvm_this_offset = this_offset;\n\n\t/* type_info [i] is cfg mempool allocated, no need to free it */\n\n\tg_free (ei);\n\tg_free (type_info);\n}\n\n#if LLVM_API_VERSION > 100\n/*\n * decode_llvm_eh_info:\n *\n *   Decode the EH table emitted by llvm in jit mode, and store\n * the result into cfg.\n */\nstatic void\ndecode_llvm_eh_info (EmitContext *ctx, gpointer eh_frame)\n{\n\tMonoCompile *cfg = ctx->cfg;\n\tguint8 *cie, *fde;\n\tint fde_len;\n\tMonoLLVMFDEInfo info;\n\tMonoJitExceptionInfo *ei;\n\tguint8 *p = eh_frame;\n\tint version, fde_count, fde_offset;\n\tguint32 ei_len, i, nested_len;\n\tgpointer *type_info;\n\tgint32 *table;\n\tguint8 *unw_info;\n\n\t/*\n\t * Decode the one element EH table emitted by the MonoException class\n\t * in llvm.\n\t */\n\n\t/* Similar to decode_llvm_mono_eh_frame () in aot-runtime.c */\n\n\tversion = *p;\n\tg_assert (version == 3);\n\tp ++;\n\tp ++;\n\tp = (guint8 *)ALIGN_PTR_TO (p, 4);\n\n\tfde_count = *(guint32*)p;\n\tp += 4;\n\ttable = (gint32*)p;\n\n\tg_assert (fde_count <= 2);\n\n\t/* The first entry is the real method */\n\tg_assert (table [0] == 1);\n\tfde_offset = table [1];\n\ttable += fde_count * 2;\n\t/* Extra entry */\n\tcfg->code_len = table [0];\n\tfde_len = table [1] - fde_offset;\n\ttable += 2;\n\n\tfde = (guint8*)eh_frame + fde_offset;\n\tcie = (guint8*)table;\n\n\t/* Compute lengths */\n\tmono_unwind_decode_llvm_mono_fde (fde, fde_len, cie, cfg->native_code, &info, NULL, NULL, NULL);\n\n\tei = (MonoJitExceptionInfo *)g_malloc0 (info.ex_info_len * sizeof (MonoJitExceptionInfo));\n\ttype_info = (gpointer *)g_malloc0 (info.ex_info_len * sizeof (gpointer));\n\tunw_info = (guint8*)g_malloc0 (info.unw_info_len);\n\n\tmono_unwind_decode_llvm_mono_fde (fde, fde_len, cie, cfg->native_code, &info, ei, type_info, unw_info);\n\n\tcfg->encoded_unwind_ops = unw_info;\n\tcfg->encoded_unwind_ops_len = info.unw_info_len;\n\tif (cfg->verbose_level > 1)\n\t\tmono_print_unwind_info (cfg->encoded_unwind_ops, cfg->encoded_unwind_ops_len);\n\tif (info.this_reg != -1) {\n\t\tcfg->llvm_this_reg = info.this_reg;\n\t\tcfg->llvm_this_offset = info.this_offset;\n\t}\n\n\tei_len = info.ex_info_len;\n\n\t// Nested clauses are currently disabled\n\tnested_len = 0;\n\n\tcfg->llvm_ex_info = (MonoJitExceptionInfo*)mono_mempool_alloc0 (cfg->mempool, (ei_len + nested_len) * sizeof (MonoJitExceptionInfo));\n\tcfg->llvm_ex_info_len = ei_len + nested_len;\n\tmemcpy (cfg->llvm_ex_info, ei, ei_len * sizeof (MonoJitExceptionInfo));\n\t/* Fill the rest of the information from the type info */\n\tfor (i = 0; i < ei_len; ++i) {\n\t\tgint32 clause_index = *(gint32*)type_info [i];\n\t\tMonoExceptionClause *clause = &cfg->header->clauses [clause_index];\n\n\t\tcfg->llvm_ex_info [i].flags = clause->flags;\n\t\tcfg->llvm_ex_info [i].data.catch_class = clause->data.catch_class;\n\t\tcfg->llvm_ex_info [i].clause_index = clause_index;\n\t}\n}\n#endif\n\nstatic char*\ndlsym_cb (const char *name, void **symbol)\n{\n\tMonoDl *current;\n\tchar *err;\n\n\terr = NULL;\n\tif (!strcmp (name, \"__bzero\")) {\n\t\t*symbol = (void*)bzero;\n\t} else {\n\t\tcurrent = mono_dl_open (NULL, 0, NULL);\n\t\tg_assert (current);\n\n\t\terr = mono_dl_symbol (current, name, symbol);\n\n\t\tmono_dl_close (current);\n\t}\n#ifdef MONO_ARCH_HAVE_CREATE_LLVM_NATIVE_THUNK\n\t*symbol = (char*)mono_arch_create_llvm_native_thunk (mono_domain_get (), (guint8*)(*symbol));\n#endif\n\treturn err;\n}\n\nstatic inline void\nAddFunc (LLVMModuleRef module, const char *name, LLVMTypeRef ret_type, LLVMTypeRef *param_types, int nparams)\n{\n\tLLVMAddFunction (module, name, LLVMFunctionType (ret_type, param_types, nparams, FALSE));\n}\n\nstatic inline void\nAddFunc2 (LLVMModuleRef module, const char *name, LLVMTypeRef ret_type, LLVMTypeRef param_type1, LLVMTypeRef param_type2)\n{\n\tLLVMTypeRef param_types [4];\n\n\tparam_types [0] = param_type1;\n\tparam_types [1] = param_type2;\n\n\tAddFunc (module, name, ret_type, param_types, 2);\n}\n\ntypedef enum {\n\tINTRINS_MEMSET,\n\tINTRINS_MEMCPY,\n\tINTRINS_SADD_OVF_I32,\n\tINTRINS_UADD_OVF_I32,\n\tINTRINS_SSUB_OVF_I32,\n\tINTRINS_USUB_OVF_I32,\n\tINTRINS_SMUL_OVF_I32,\n\tINTRINS_UMUL_OVF_I32,\n\tINTRINS_SADD_OVF_I64,\n\tINTRINS_UADD_OVF_I64,\n\tINTRINS_SSUB_OVF_I64,\n\tINTRINS_USUB_OVF_I64,\n\tINTRINS_SMUL_OVF_I64,\n\tINTRINS_UMUL_OVF_I64,\n\tINTRINS_SIN,\n\tINTRINS_COS,\n\tINTRINS_SQRT,\n\tINTRINS_FABS,\n\tINTRINS_EXPECT_I8,\n\tINTRINS_EXPECT_I1,\n#if defined(TARGET_AMD64) || defined(TARGET_X86)\n\tINTRINS_SSE_PMOVMSKB,\n\tINTRINS_SSE_PSRLI_W,\n\tINTRINS_SSE_PSRAI_W,\n\tINTRINS_SSE_PSLLI_W,\n\tINTRINS_SSE_PSRLI_D,\n\tINTRINS_SSE_PSRAI_D,\n\tINTRINS_SSE_PSLLI_D,\n\tINTRINS_SSE_PSRLI_Q,\n\tINTRINS_SSE_PSLLI_Q,\n\tINTRINS_SSE_SQRT_PD,\n\tINTRINS_SSE_SQRT_PS,\n\tINTRINS_SSE_RSQRT_PS,\n\tINTRINS_SSE_RCP_PS,\n\tINTRINS_SSE_CVTTPD2DQ,\n\tINTRINS_SSE_CVTTPS2DQ,\n\tINTRINS_SSE_CVTDQ2PD,\n\tINTRINS_SSE_CVTDQ2PS,\n\tINTRINS_SSE_CVTPD2DQ,\n\tINTRINS_SSE_CVTPS2DQ,\n\tINTRINS_SSE_CVTPD2PS,\n\tINTRINS_SSE_CVTPS2PD,\n\tINTRINS_SSE_CMPPD,\n\tINTRINS_SSE_CMPPS,\n\tINTRINS_SSE_PACKSSWB,\n\tINTRINS_SSE_PACKUSWB,\n\tINTRINS_SSE_PACKSSDW,\n\tINTRINS_SSE_PACKUSDW,\n\tINTRINS_SSE_MINPS,\n\tINTRINS_SSE_MAXPS,\n\tINTRINS_SSE_HADDPS,\n\tINTRINS_SSE_HSUBPS,\n\tINTRINS_SSE_ADDSUBPS,\n\tINTRINS_SSE_MINPD,\n\tINTRINS_SSE_MAXPD,\n\tINTRINS_SSE_HADDPD,\n\tINTRINS_SSE_HSUBPD,\n\tINTRINS_SSE_ADDSUBPD,\n\tINTRINS_SSE_PADDSW,\n\tINTRINS_SSE_PSUBSW,\n\tINTRINS_SSE_PADDUSW,\n\tINTRINS_SSE_PSUBUSW,\n\tINTRINS_SSE_PAVGW,\n\tINTRINS_SSE_PMULHW,\n\tINTRINS_SSE_PMULHU,\n\tINTRINS_SE_PADDSB,\n\tINTRINS_SSE_PSUBSB,\n\tINTRINS_SSE_PADDUSB,\n\tINTRINS_SSE_PSUBUSB,\n\tINTRINS_SSE_PAVGB,\n\tINTRINS_SSE_PAUSE,\n\tINTRINS_SSE_DPPS,\n#endif\n\tINTRINS_NUM\n} IntrinsicId;\n\ntypedef struct {\n\tIntrinsicId id;\n\tconst char *name;\n} IntrinsicDesc;\n\nstatic IntrinsicDesc intrinsics[] = {\n\t{INTRINS_MEMSET, \"llvm.memset.p0i8.i32\"},\n\t{INTRINS_MEMCPY, \"llvm.memcpy.p0i8.p0i8.i32\"},\n\t{INTRINS_SADD_OVF_I32, \"llvm.sadd.with.overflow.i32\"},\n\t{INTRINS_UADD_OVF_I32, \"llvm.uadd.with.overflow.i32\"},\n\t{INTRINS_SSUB_OVF_I32, \"llvm.ssub.with.overflow.i32\"},\n\t{INTRINS_USUB_OVF_I32, \"llvm.usub.with.overflow.i32\"},\n\t{INTRINS_SMUL_OVF_I32, \"llvm.smul.with.overflow.i32\"},\n\t{INTRINS_UMUL_OVF_I32, \"llvm.umul.with.overflow.i32\"},\n\t{INTRINS_SADD_OVF_I64, \"llvm.sadd.with.overflow.i64\"},\n\t{INTRINS_UADD_OVF_I64, \"llvm.uadd.with.overflow.i64\"},\n\t{INTRINS_SSUB_OVF_I64, \"llvm.ssub.with.overflow.i64\"},\n\t{INTRINS_USUB_OVF_I64, \"llvm.usub.with.overflow.i64\"},\n\t{INTRINS_SMUL_OVF_I64, \"llvm.smul.with.overflow.i64\"},\n\t{INTRINS_UMUL_OVF_I64, \"llvm.umul.with.overflow.i64\"},\n\t{INTRINS_SIN, \"llvm.sin.f64\"},\n\t{INTRINS_COS, \"llvm.cos.f64\"},\n\t{INTRINS_SQRT, \"llvm.sqrt.f64\"},\n\t/* This isn't an intrinsic, instead llvm seems to special case it by name */\n\t{INTRINS_FABS, \"fabs\"},\n\t{INTRINS_EXPECT_I8, \"llvm.expect.i8\"},\n\t{INTRINS_EXPECT_I1, \"llvm.expect.i1\"},\n#if defined(TARGET_AMD64) || defined(TARGET_X86)\n\t{INTRINS_SSE_PMOVMSKB, \"llvm.x86.sse2.pmovmskb.128\"},\n\t{INTRINS_SSE_PSRLI_W, \"llvm.x86.sse2.psrli.w\"},\n\t{INTRINS_SSE_PSRAI_W, \"llvm.x86.sse2.psrai.w\"},\n\t{INTRINS_SSE_PSLLI_W, \"llvm.x86.sse2.pslli.w\"},\n\t{INTRINS_SSE_PSRLI_D, \"llvm.x86.sse2.psrli.d\"},\n\t{INTRINS_SSE_PSRAI_D, \"llvm.x86.sse2.psrai.d\"},\n\t{INTRINS_SSE_PSLLI_D, \"llvm.x86.sse2.pslli.d\"},\n\t{INTRINS_SSE_PSRLI_Q, \"llvm.x86.sse2.psrli.q\"},\n\t{INTRINS_SSE_PSLLI_Q, \"llvm.x86.sse2.pslli.q\"},\n\t{INTRINS_SSE_SQRT_PD, \"llvm.x86.sse2.sqrt.pd\"},\n\t{INTRINS_SSE_SQRT_PS, \"llvm.x86.sse.sqrt.ps\"},\n\t{INTRINS_SSE_RSQRT_PS, \"llvm.x86.sse.rsqrt.ps\"},\n\t{INTRINS_SSE_RCP_PS, \"llvm.x86.sse.rcp.ps\"},\n\t{INTRINS_SSE_CVTTPD2DQ, \"llvm.x86.sse2.cvttpd2dq\"},\n\t{INTRINS_SSE_CVTTPS2DQ, \"llvm.x86.sse2.cvttps2dq\"},\n\t{INTRINS_SSE_CVTDQ2PD, \"llvm.x86.sse2.cvtdq2pd\"},\n\t{INTRINS_SSE_CVTDQ2PS, \"llvm.x86.sse2.cvtdq2ps\"},\n\t{INTRINS_SSE_CVTPD2DQ, \"llvm.x86.sse2.cvtpd2dq\"},\n\t{INTRINS_SSE_CVTPS2DQ, \"llvm.x86.sse2.cvtps2dq\"},\n\t{INTRINS_SSE_CVTPD2PS, \"llvm.x86.sse2.cvtpd2ps\"},\n\t{INTRINS_SSE_CVTPS2PD, \"llvm.x86.sse2.cvtps2pd\"},\n\t{INTRINS_SSE_CMPPD, \"llvm.x86.sse2.cmp.pd\"},\n\t{INTRINS_SSE_CMPPS, \"llvm.x86.sse.cmp.ps\"},\n\t{INTRINS_SSE_PACKSSWB, \"llvm.x86.sse2.packsswb.128\"},\n\t{INTRINS_SSE_PACKUSWB, \"llvm.x86.sse2.packuswb.128\"},\n\t{INTRINS_SSE_PACKSSDW, \"llvm.x86.sse2.packssdw.128\"},\n\t{INTRINS_SSE_PACKUSDW, \"llvm.x86.sse41.packusdw\"},\n\t{INTRINS_SSE_MINPS, \"llvm.x86.sse.min.ps\"},\n\t{INTRINS_SSE_MAXPS, \"llvm.x86.sse.max.ps\"},\n\t{INTRINS_SSE_HADDPS, \"llvm.x86.sse3.hadd.ps\"},\n\t{INTRINS_SSE_HSUBPS, \"llvm.x86.sse3.hsub.ps\"},\n\t{INTRINS_SSE_ADDSUBPS, \"llvm.x86.sse3.addsub.ps\"},\n\t{INTRINS_SSE_MINPD, \"llvm.x86.sse2.min.pd\"},\n\t{INTRINS_SSE_MAXPD, \"llvm.x86.sse2.max.pd\"},\n\t{INTRINS_SSE_HADDPD, \"llvm.x86.sse3.hadd.pd\"},\n\t{INTRINS_SSE_HSUBPD, \"llvm.x86.sse3.hsub.pd\"},\n\t{INTRINS_SSE_ADDSUBPD, \"llvm.x86.sse3.addsub.pd\"},\n\t{INTRINS_SSE_PADDSW, \"llvm.x86.sse2.padds.w\"},\n\t{INTRINS_SSE_PSUBSW, \"llvm.x86.sse2.psubs.w\"},\n\t{INTRINS_SSE_PADDUSW, \"llvm.x86.sse2.paddus.w\"},\n\t{INTRINS_SSE_PSUBUSW, \"llvm.x86.sse2.psubus.w\"},\n\t{INTRINS_SSE_PAVGW, \"llvm.x86.sse2.pavg.w\"},\n\t{INTRINS_SSE_PMULHW, \"llvm.x86.sse2.pmulh.w\"},\n\t{INTRINS_SSE_PMULHU, \"llvm.x86.sse2.pmulhu.w\"},\n\t{INTRINS_SE_PADDSB, \"llvm.x86.sse2.padds.b\"},\n\t{INTRINS_SSE_PSUBSB, \"llvm.x86.sse2.psubs.b\"},\n\t{INTRINS_SSE_PADDUSB, \"llvm.x86.sse2.paddus.b\"},\n\t{INTRINS_SSE_PSUBUSB, \"llvm.x86.sse2.psubus.b\"},\n\t{INTRINS_SSE_PAVGB, \"llvm.x86.sse2.pavg.b\"},\n\t{INTRINS_SSE_PAUSE, \"llvm.x86.sse2.pause\"},\n\t{INTRINS_SSE_DPPS, \"llvm.x86.sse41.dpps\"}\n#endif\n};\n\nstatic void\nadd_sse_binary (LLVMModuleRef module, const char *name, int type)\n{\n\tLLVMTypeRef ret_type = type_to_simd_type (type);\n\tAddFunc2 (module, name, ret_type, ret_type, ret_type);\n}\n\nstatic void\nadd_intrinsic (LLVMModuleRef module, int id)\n{\n\tconst char *name;\n#if defined(TARGET_AMD64) || defined(TARGET_X86)\n\tLLVMTypeRef ret_type, arg_types [16];\n#endif\n\n\tname = g_hash_table_lookup (intrins_id_to_name, GINT_TO_POINTER (id));\n\tg_assert (name);\n\n\tswitch (id) {\n\tcase INTRINS_MEMSET: {\n\t\tLLVMTypeRef params [] = { LLVMPointerType (LLVMInt8Type (), 0), LLVMInt8Type (), LLVMInt32Type (), LLVMInt32Type (), LLVMInt1Type () };\n\n\t\tAddFunc (module, name, LLVMVoidType (), params, 5);\n\t\tbreak;\n\t}\n\tcase INTRINS_MEMCPY: {\n\t\tLLVMTypeRef params [] = { LLVMPointerType (LLVMInt8Type (), 0), LLVMPointerType (LLVMInt8Type (), 0), LLVMInt32Type (), LLVMInt32Type (), LLVMInt1Type () };\n\n\t\tAddFunc (module, name, LLVMVoidType (), params, 5);\n\t\tbreak;\n\t}\n\tcase INTRINS_SADD_OVF_I32:\n\tcase INTRINS_UADD_OVF_I32:\n\tcase INTRINS_SSUB_OVF_I32:\n\tcase INTRINS_USUB_OVF_I32:\n\tcase INTRINS_SMUL_OVF_I32:\n\tcase INTRINS_UMUL_OVF_I32: {\n\t\tLLVMTypeRef ovf_res_i32 [] = { LLVMInt32Type (), LLVMInt1Type () };\n\t\tLLVMTypeRef params [] = { LLVMInt32Type (), LLVMInt32Type () };\n\t\tLLVMTypeRef ret_type = LLVMStructType (ovf_res_i32, 2, FALSE);\n\n\t\tAddFunc (module, name, ret_type, params, 2);\n\t\tbreak;\n\t}\n\tcase INTRINS_SADD_OVF_I64:\n\tcase INTRINS_UADD_OVF_I64:\n\tcase INTRINS_SSUB_OVF_I64:\n\tcase INTRINS_USUB_OVF_I64:\n\tcase INTRINS_SMUL_OVF_I64:\n\tcase INTRINS_UMUL_OVF_I64: {\n\t\tLLVMTypeRef ovf_res_i64 [] = { LLVMInt64Type (), LLVMInt1Type () };\n\t\tLLVMTypeRef params [] = { LLVMInt64Type (), LLVMInt64Type () };\n\t\tLLVMTypeRef ret_type = LLVMStructType (ovf_res_i64, 2, FALSE);\n\n\t\tAddFunc (module, name, ret_type, params, 2);\n\t\tbreak;\n\t}\n\tcase INTRINS_SIN:\n\tcase INTRINS_COS:\n\tcase INTRINS_SQRT:\n\tcase INTRINS_FABS: {\n\t\tLLVMTypeRef params [] = { LLVMDoubleType () };\n\n\t\tAddFunc (module, name, LLVMDoubleType (), params, 1);\n\t\tbreak;\n\t}\n\tcase INTRINS_EXPECT_I8:\n\t\tAddFunc2 (module, name, LLVMInt8Type (), LLVMInt8Type (), LLVMInt8Type ());\n\t\tbreak;\n\tcase INTRINS_EXPECT_I1:\n\t\tAddFunc2 (module, name, LLVMInt1Type (), LLVMInt1Type (), LLVMInt1Type ());\n\t\tbreak;\n#if defined(TARGET_AMD64) || defined(TARGET_X86)\n\tcase INTRINS_SSE_PMOVMSKB:\n\t\t/* pmovmskb */\n\t\tret_type = LLVMInt32Type ();\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_I1);\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_PSRLI_W:\n\tcase INTRINS_SSE_PSRAI_W:\n\tcase INTRINS_SSE_PSLLI_W:\n\t\t/* shifts */\n\t\tret_type = type_to_simd_type (MONO_TYPE_I2);\n\t\targ_types [0] = ret_type;\n\t\targ_types [1] = LLVMInt32Type ();\n\t\tAddFunc (module, name, ret_type, arg_types, 2);\n\t\tbreak;\n\tcase INTRINS_SSE_PSRLI_D:\n\tcase INTRINS_SSE_PSRAI_D:\n\tcase INTRINS_SSE_PSLLI_D:\n\t\tret_type = type_to_simd_type (MONO_TYPE_I4);\n\t\targ_types [0] = ret_type;\n\t\targ_types [1] = LLVMInt32Type ();\n\t\tAddFunc (module, name, ret_type, arg_types, 2);\n\t\tbreak;\n\tcase INTRINS_SSE_PSRLI_Q:\n\tcase INTRINS_SSE_PSLLI_Q:\n\t\tret_type = type_to_simd_type (MONO_TYPE_I8);\n\t\targ_types [0] = ret_type;\n\t\targ_types [1] = LLVMInt32Type ();\n\t\tAddFunc (module, name, ret_type, arg_types, 2);\n\t\tbreak;\n\tcase INTRINS_SSE_SQRT_PD:\n\t\t/* Unary ops */\n\t\tret_type = type_to_simd_type (MONO_TYPE_R8);\n\t\targ_types [0] = ret_type;\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_SQRT_PS:\n\t\tret_type = type_to_simd_type (MONO_TYPE_R4);\n\t\targ_types [0] = ret_type;\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_RSQRT_PS:\n\t\tret_type = type_to_simd_type (MONO_TYPE_R4);\n\t\targ_types [0] = ret_type;\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_RCP_PS:\n\t\tret_type = type_to_simd_type (MONO_TYPE_R4);\n\t\targ_types [0] = ret_type;\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_CVTTPD2DQ:\n\t\tret_type = type_to_simd_type (MONO_TYPE_I4);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_R8);\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_CVTTPS2DQ:\n\t\tret_type = type_to_simd_type (MONO_TYPE_I4);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_R4);\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_CVTDQ2PD:\n\t\t/* Conversion ops */\n\t\tret_type = type_to_simd_type (MONO_TYPE_R8);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_I4);\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_CVTDQ2PS:\n\t\tret_type = type_to_simd_type (MONO_TYPE_R4);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_I4);\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_CVTPD2DQ:\n\t\tret_type = type_to_simd_type (MONO_TYPE_I4);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_R8);\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_CVTPS2DQ:\n\t\tret_type = type_to_simd_type (MONO_TYPE_I4);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_R4);\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_CVTPD2PS:\n\t\tret_type = type_to_simd_type (MONO_TYPE_R4);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_R8);\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_CVTPS2PD:\n\t\tret_type = type_to_simd_type (MONO_TYPE_R8);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_R4);\n\t\tAddFunc (module, name, ret_type, arg_types, 1);\n\t\tbreak;\n\tcase INTRINS_SSE_CMPPD:\n\t\t/* cmp pd/ps */\n\t\tret_type = type_to_simd_type (MONO_TYPE_R8);\n\t\targ_types [0] = ret_type;\n\t\targ_types [1] = ret_type;\n\t\targ_types [2] = LLVMInt8Type ();\n\t\tAddFunc (module, name, ret_type, arg_types, 3);\n\t\tbreak;\n\tcase INTRINS_SSE_CMPPS:\n\t\tret_type = type_to_simd_type (MONO_TYPE_R4);\n\t\targ_types [0] = ret_type;\n\t\targ_types [1] = ret_type;\n\t\targ_types [2] = LLVMInt8Type ();\n\t\tAddFunc (module, name, ret_type, arg_types, 3);\n\t\tbreak;\n\tcase INTRINS_SSE_PACKSSWB:\n\tcase INTRINS_SSE_PACKUSWB:\n\tcase INTRINS_SSE_PACKSSDW:\n\t\t/* pack */\n\t\tret_type = type_to_simd_type (MONO_TYPE_I1);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_I2);\n\t\targ_types [1] = type_to_simd_type (MONO_TYPE_I2);\n\t\tAddFunc (module, name, ret_type, arg_types, 2);\n\t\tbreak;\n\tcase INTRINS_SSE_PACKUSDW:\n\t\tret_type = type_to_simd_type (MONO_TYPE_I2);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_I4);\n\t\targ_types [1] = type_to_simd_type (MONO_TYPE_I4);\n\t\tAddFunc (module, name, ret_type, arg_types, 2);\n\t\tbreak;\n\t\t/* SSE Binary ops */\n\tcase INTRINS_SSE_PADDSW:\n\tcase INTRINS_SSE_PSUBSW:\n\tcase INTRINS_SSE_PADDUSW:\n\tcase INTRINS_SSE_PSUBUSW:\n\tcase INTRINS_SSE_PAVGW:\n\tcase INTRINS_SSE_PMULHW:\n\tcase INTRINS_SSE_PMULHU:\n\t\tadd_sse_binary (module, name, MONO_TYPE_I2);\n\t\tbreak;\n\tcase INTRINS_SSE_MINPS:\n\tcase INTRINS_SSE_MAXPS:\n\tcase INTRINS_SSE_HADDPS:\n\tcase INTRINS_SSE_HSUBPS:\n\tcase INTRINS_SSE_ADDSUBPS:\n\t\tadd_sse_binary (module, name, MONO_TYPE_R4);\n\t\tbreak;\n\tcase INTRINS_SSE_MINPD:\n\tcase INTRINS_SSE_MAXPD:\n\tcase INTRINS_SSE_HADDPD:\n\tcase INTRINS_SSE_HSUBPD:\n\tcase INTRINS_SSE_ADDSUBPD:\n\t\tadd_sse_binary (module, name, MONO_TYPE_R8);\n\t\tbreak;\n\tcase INTRINS_SE_PADDSB:\n\tcase INTRINS_SSE_PSUBSB:\n\tcase INTRINS_SSE_PADDUSB:\n\tcase INTRINS_SSE_PSUBUSB:\n\tcase INTRINS_SSE_PAVGB:\n\t\tadd_sse_binary (module, name, MONO_TYPE_I1);\n\t\tbreak;\n\tcase INTRINS_SSE_PAUSE:\n\t\tAddFunc (module, \"llvm.x86.sse2.pause\", LLVMVoidType (), NULL, 0);\n\t\tbreak;\n\tcase INTRINS_SSE_DPPS:\n\t\tret_type = type_to_simd_type (MONO_TYPE_R4);\n\t\targ_types [0] = type_to_simd_type (MONO_TYPE_R4);\n\t\targ_types [1] = type_to_simd_type (MONO_TYPE_R4);\n#if LLVM_API_VERSION >= 500\n\t\targ_types [2] = LLVMInt8Type ();\n#else\n\t\targ_types [2] = LLVMInt32Type ();\n#endif\n\t\tAddFunc (module, name, ret_type, arg_types, 3);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tg_assert_not_reached ();\n\t\tbreak;\n\t}\n}\n\nstatic LLVMValueRef\nget_intrinsic (EmitContext *ctx, const char *name)\n{\n#if LLVM_API_VERSION > 100\n\tLLVMValueRef res;\n\n\t/*\n\t * Every method is emitted into its own module so\n\t * we can add intrinsics on demand.\n\t */\n\tres = LLVMGetNamedFunction (ctx->lmodule, name);\n\tif (!res) {\n\t\tint id = -1;\n\n\t\t/* No locking needed */\n\t\tid = GPOINTER_TO_INT (g_hash_table_lookup (intrins_name_to_id, name));\n\t\tid --;\n\t\tif (id == -1)\n\t\t\tprintf (\"%s\\n\", name);\n\t\tg_assert (id != -1);\n\t\tadd_intrinsic (ctx->lmodule, id);\n\t\tres = LLVMGetNamedFunction (ctx->lmodule, name);\n\t\tg_assert (res);\n\t}\n\n\treturn res;\n#else\n\tLLVMValueRef res;\n\n\tres = LLVMGetNamedFunction (ctx->lmodule, name);\n\tg_assert (res);\n\treturn res;\n#endif\n}\n\nstatic void\nadd_intrinsics (LLVMModuleRef module)\n{\n\tint i;\n\n\t/* Emit declarations of instrinsics */\n\t/*\n\t * It would be nicer to emit only the intrinsics actually used, but LLVM's Module\n\t * type doesn't seem to do any locking.\n\t */\n\tfor (i = 0; i < INTRINS_NUM; ++i)\n\t\tadd_intrinsic (module, i);\n\n\t/* EH intrinsics */\n\t{\n\t\tAddFunc (module, \"mono_personality\", LLVMVoidType (), NULL, 0);\n\n\t\tAddFunc (module, \"llvm_resume_unwind_trampoline\", LLVMVoidType (), NULL, 0);\n\t}\n\n\t/* Load/Store intrinsics */\n\t{\n\t\tLLVMTypeRef arg_types [5];\n\t\tint i;\n\t\tchar name [128];\n\n\t\tfor (i = 1; i <= 8; i *= 2) {\n\t\t\targ_types [0] = LLVMPointerType (LLVMIntType (i * 8), 0);\n\t\t\targ_types [1] = LLVMInt32Type ();\n\t\t\targ_types [2] = LLVMInt1Type ();\n\t\t\targ_types [3] = LLVMInt32Type ();\n\t\t\tsprintf (name, \"llvm.mono.load.i%d.p0i%d\", i * 8, i * 8);\n\t\t\tAddFunc (module, name, LLVMIntType (i * 8), arg_types, 4);\n\n\t\t\targ_types [0] = LLVMIntType (i * 8);\n\t\t\targ_types [1] = LLVMPointerType (LLVMIntType (i * 8), 0);\n\t\t\targ_types [2] = LLVMInt32Type ();\n\t\t\targ_types [3] = LLVMInt1Type ();\n\t\t\targ_types [4] = LLVMInt32Type ();\n\t\t\tsprintf (name, \"llvm.mono.store.i%d.p0i%d\", i * 8, i * 8);\n\t\t\tAddFunc (module, name, LLVMVoidType (), arg_types, 5);\n\t\t}\n\t}\n}\n\nstatic void\nadd_types (MonoLLVMModule *module)\n{\n\tmodule->ptr_type = LLVMPointerType (sizeof (gpointer) == 8 ? LLVMInt64Type () : LLVMInt32Type (), 0);\n}\n\nvoid\nmono_llvm_init (void)\n{\n\tGHashTable *h;\n\tint i;\n\n\tmono_native_tls_alloc (&current_cfg_tls_id, NULL);\n\n\th = g_hash_table_new (NULL, NULL);\n\tfor (i = 0; i < INTRINS_NUM; ++i)\n\t\tg_hash_table_insert (h, GINT_TO_POINTER (intrinsics [i].id), (gpointer)intrinsics [i].name);\n\tintrins_id_to_name = h;\n\n\th = g_hash_table_new (g_str_hash, g_str_equal);\n\tfor (i = 0; i < INTRINS_NUM; ++i)\n\t\tg_hash_table_insert (h, (gpointer)intrinsics [i].name, GINT_TO_POINTER (intrinsics [i].id + 1));\n\tintrins_name_to_id = h;\n}\n\nstatic void\ninit_jit_module (MonoDomain *domain)\n{\n\tMonoJitDomainInfo *dinfo;\n\tMonoLLVMModule *module;\n\tchar *name;\n\n\tdinfo = domain_jit_info (domain);\n\tif (dinfo->llvm_module)\n\t\treturn;\n\n\tmono_loader_lock ();\n\n\tif (dinfo->llvm_module) {\n\t\tmono_loader_unlock ();\n\t\treturn;\n\t}\n\n\tmodule = g_new0 (MonoLLVMModule, 1);\n\n\tname = g_strdup_printf (\"mono-%s\", domain->friendly_name);\n\tmodule->lmodule = LLVMModuleCreateWithName (name);\n\tmodule->context = LLVMGetGlobalContext ();\n\n\tmodule->mono_ee = (MonoEERef*)mono_llvm_create_ee (LLVMCreateModuleProviderForExistingModule (module->lmodule), alloc_cb, emitted_cb, exception_cb, dlsym_cb, &module->ee);\n\n\tadd_intrinsics (module->lmodule);\n\tadd_types (module);\n\n\tmodule->llvm_types = g_hash_table_new (NULL, NULL);\n\n#if LLVM_API_VERSION < 100\n\tMonoJitICallInfo *info;\n\n\tinfo = mono_find_jit_icall_by_name (\"llvm_resume_unwind_trampoline\");\n\tg_assert (info);\n\tLLVMAddGlobalMapping (module->ee, LLVMGetNamedFunction (module->lmodule, \"llvm_resume_unwind_trampoline\"), (void*)info->func);\n#endif\n\n\tmono_memory_barrier ();\n\n\tdinfo->llvm_module = module;\n\n\tmono_loader_unlock ();\n}\n\nvoid\nmono_llvm_cleanup (void)\n{\n\tMonoLLVMModule *module = &aot_module;\n\n\tif (module->lmodule)\n\t\tLLVMDisposeModule (module->lmodule);\n\n\tif (module->context)\n\t\tLLVMContextDispose (module->context);\n}\n\nvoid\nmono_llvm_free_domain_info (MonoDomain *domain)\n{\n\tMonoJitDomainInfo *info = domain_jit_info (domain);\n\tMonoLLVMModule *module = (MonoLLVMModule*)info->llvm_module;\n\tint i;\n\n\tif (!module)\n\t\treturn;\n\n\tif (module->llvm_types)\n\t\tg_hash_table_destroy (module->llvm_types);\n\n\tmono_llvm_dispose_ee (module->mono_ee);\n\n\tif (module->bb_names) {\n\t\tfor (i = 0; i < module->bb_names_len; ++i)\n\t\t\tg_free (module->bb_names [i]);\n\t\tg_free (module->bb_names);\n\t}\n\t//LLVMDisposeModule (module->module);\n\n\tg_free (module);\n\n\tinfo->llvm_module = NULL;\n}\n\nvoid\nmono_llvm_create_aot_module (MonoAssembly *assembly, const char *global_prefix, int initial_got_size, gboolean emit_dwarf, gboolean static_link, gboolean llvm_only)\n{\n\tMonoLLVMModule *module = &aot_module;\n\n\t/* Delete previous module */\n\tif (module->plt_entries)\n\t\tg_hash_table_destroy (module->plt_entries);\n\tif (module->lmodule)\n\t\tLLVMDisposeModule (module->lmodule);\n\n\tmemset (module, 0, sizeof (aot_module));\n\n\tmodule->lmodule = LLVMModuleCreateWithName (\"aot\");\n\tmodule->assembly = assembly;\n\tmodule->global_prefix = g_strdup (global_prefix);\n\tmodule->got_symbol = g_strdup_printf (\"%s_llvm_got\", global_prefix);\n\tmodule->eh_frame_symbol = g_strdup_printf (\"%s_eh_frame\", global_prefix);\n\tmodule->get_method_symbol = g_strdup_printf (\"%s_get_method\", global_prefix);\n\tmodule->get_unbox_tramp_symbol = g_strdup_printf (\"%s_get_unbox_tramp\", global_prefix);\n\tmodule->external_symbols = TRUE;\n\tmodule->emit_dwarf = emit_dwarf;\n\tmodule->static_link = static_link;\n\tmodule->llvm_only = llvm_only;\n\t/* The first few entries are reserved */\n\tmodule->max_got_offset = initial_got_size;\n\tmodule->context = LLVMGetGlobalContext ();\n\n\tif (llvm_only)\n\t\t/* clang ignores our debug info because it has an invalid version */\n\t\tmodule->emit_dwarf = FALSE;\n\n\tadd_intrinsics (module->lmodule);\n\tadd_types (module);\n\n#if LLVM_API_VERSION > 100\n\tif (module->emit_dwarf) {\n\t\tchar *dir, *build_info, *s, *cu_name;\n\n\t\tmodule->di_builder = mono_llvm_create_di_builder (module->lmodule);\n\n\t\t// FIXME:\n\t\tdir = g_strdup (\".\");\n\t\tbuild_info = mono_get_runtime_build_info ();\n\t\ts = g_strdup_printf (\"Mono AOT Compiler %s (LLVM)\", build_info);\n\t\tcu_name = g_path_get_basename (assembly->image->name);\n\t\tmodule->cu = mono_llvm_di_create_compile_unit (module->di_builder, cu_name, dir, s);\n\t\tg_free (dir);\n\t\tg_free (build_info);\n\t\tg_free (s);\n\t}\n#endif\n\n\t/* Add GOT */\n\t/*\n\t * We couldn't compute the type of the LLVM global representing the got because\n\t * its size is only known after all the methods have been emitted. So create\n\t * a dummy variable, and replace all uses it with the real got variable when\n\t * its size is known in mono_llvm_emit_aot_module ().\n\t */\n\t{\n\t\tLLVMTypeRef got_type = LLVMArrayType (module->ptr_type, 0);\n\n\t\tmodule->got_var = LLVMAddGlobal (module->lmodule, got_type, \"mono_dummy_got\");\n\t\tLLVMSetInitializer (module->got_var, LLVMConstNull (got_type));\n\t}\n\n\t/* Add initialization array */\n\tif (llvm_only) {\n\t\tLLVMTypeRef inited_type = LLVMArrayType (LLVMInt8Type (), 0);\n\n\t\tmodule->inited_var = LLVMAddGlobal (aot_module.lmodule, inited_type, \"mono_inited_tmp\");\n\t\tLLVMSetInitializer (module->inited_var, LLVMConstNull (inited_type));\n\t}\n\n\tif (llvm_only)\n\t\temit_init_icall_wrappers (module);\n\n\temit_llvm_code_start (module);\n\n\t/* Add a dummy personality function */\n\tif (!use_debug_personality) {\n\t\tLLVMValueRef personality = LLVMAddFunction (module->lmodule, default_personality_name, LLVMFunctionType (LLVMInt32Type (), NULL, 0, TRUE));\n\t\tLLVMSetLinkage (personality, LLVMExternalLinkage);\n\t\tmark_as_used (module, personality);\n\t}\n\n\t/* Add a reference to the c++ exception we throw/catch */\n\t{\n\t\tLLVMTypeRef exc = LLVMPointerType (LLVMInt8Type (), 0);\n\t\tmodule->sentinel_exception = LLVMAddGlobal (module->lmodule, exc, \"_ZTIPi\");\n\t\tLLVMSetLinkage (module->sentinel_exception, LLVMExternalLinkage);\n\t\tmono_llvm_set_is_constant (module->sentinel_exception);\n\t}\n\n\tmodule->llvm_types = g_hash_table_new (NULL, NULL);\n\tmodule->plt_entries = g_hash_table_new (g_str_hash, g_str_equal);\n\tmodule->plt_entries_ji = g_hash_table_new (NULL, NULL);\n\tmodule->direct_callables = g_hash_table_new (g_str_hash, g_str_equal);\n\tmodule->method_to_lmethod = g_hash_table_new (NULL, NULL);\n\tmodule->idx_to_lmethod = g_hash_table_new (NULL, NULL);\n\tmodule->idx_to_unbox_tramp = g_hash_table_new (NULL, NULL);\n\tmodule->method_to_callers = g_hash_table_new (NULL, NULL);\n}\n\nstatic LLVMValueRef\nllvm_array_from_uints (LLVMTypeRef el_type, guint32 *values, int nvalues)\n{\n\tint i;\n\tLLVMValueRef res, *vals;\n\n\tvals = g_new0 (LLVMValueRef, nvalues);\n\tfor (i = 0; i < nvalues; ++i)\n\t\tvals [i] = LLVMConstInt (LLVMInt32Type (), values [i], FALSE);\n\tres = LLVMConstArray (LLVMInt32Type (), vals, nvalues);\n\tg_free (vals);\n\treturn res;\n}\n\nstatic LLVMValueRef\nllvm_array_from_bytes (guint8 *values, int nvalues)\n{\n\tint i;\n\tLLVMValueRef res, *vals;\n\n\tvals = g_new0 (LLVMValueRef, nvalues);\n\tfor (i = 0; i < nvalues; ++i)\n\t\tvals [i] = LLVMConstInt (LLVMInt8Type (), values [i], FALSE);\n\tres = LLVMConstArray (LLVMInt8Type (), vals, nvalues);\n\tg_free (vals);\n\treturn res;\n}\n/*\n * mono_llvm_emit_aot_file_info:\n *\n *   Emit the MonoAotFileInfo structure.\n * Same as emit_aot_file_info () in aot-compiler.c.\n */\nvoid\nmono_llvm_emit_aot_file_info (MonoAotFileInfo *info, gboolean has_jitted_code)\n{\n\tMonoLLVMModule *module = &aot_module;\n\n\t/* Save these for later */\n\tmemcpy (&module->aot_info, info, sizeof (MonoAotFileInfo));\n\tmodule->has_jitted_code = has_jitted_code;\n}\n\n/*\n * mono_llvm_emit_aot_data:\n *\n *   Emit the binary data DATA pointed to by symbol SYMBOL.\n */\nvoid\nmono_llvm_emit_aot_data (const char *symbol, guint8 *data, int data_len)\n{\n\tMonoLLVMModule *module = &aot_module;\n\tLLVMTypeRef type;\n\tLLVMValueRef d;\n\n\ttype = LLVMArrayType (LLVMInt8Type (), data_len);\n\td = LLVMAddGlobal (module->lmodule, type, symbol);\n\tLLVMSetVisibility (d, LLVMHiddenVisibility);\n\tLLVMSetLinkage (d, LLVMInternalLinkage);\n\tLLVMSetInitializer (d, mono_llvm_create_constant_data_array (data, data_len));\n\tLLVMSetAlignment (d, 8);\n\tmono_llvm_set_is_constant (d);\n}\n\n/* Add a reference to a global defined in JITted code */\nstatic LLVMValueRef\nAddJitGlobal (MonoLLVMModule *module, LLVMTypeRef type, const char *name)\n{\n\tchar *s;\n\tLLVMValueRef v;\n\n\ts = g_strdup_printf (\"%s%s\", module->global_prefix, name);\n\tv = LLVMAddGlobal (module->lmodule, LLVMInt8Type (), s);\n\tg_free (s);\n\treturn v;\n}\n\nstatic void\nemit_aot_file_info (MonoLLVMModule *module)\n{\n\tLLVMTypeRef file_info_type;\n\tLLVMTypeRef *eltypes, eltype;\n\tLLVMValueRef info_var;\n\tLLVMValueRef *fields;\n\tint i, nfields, tindex;\n\tMonoAotFileInfo *info;\n\tLLVMModuleRef lmodule = module->lmodule;\n\n\tinfo = &module->aot_info;\n\n\t/* Create an LLVM type to represent MonoAotFileInfo */\n\tnfields = 2 + MONO_AOT_FILE_INFO_NUM_SYMBOLS + 16 + 5;\n\teltypes = g_new (LLVMTypeRef, nfields);\n\ttindex = 0;\n\teltypes [tindex ++] = LLVMInt32Type ();\n\teltypes [tindex ++] = LLVMInt32Type ();\n\t/* Symbols */\n\tfor (i = 0; i < MONO_AOT_FILE_INFO_NUM_SYMBOLS; ++i)\n\t\teltypes [tindex ++] = LLVMPointerType (LLVMInt8Type (), 0);\n\t/* Scalars */\n\tfor (i = 0; i < 15; ++i)\n\t\teltypes [tindex ++] = LLVMInt32Type ();\n\t/* Arrays */\n\teltypes [tindex ++] = LLVMArrayType (LLVMInt32Type (), MONO_AOT_TABLE_NUM);\n\tfor (i = 0; i < 4; ++i)\n\t\teltypes [tindex ++] = LLVMArrayType (LLVMInt32Type (), MONO_AOT_TRAMP_NUM);\n\teltypes [tindex ++] = LLVMArrayType (LLVMInt8Type (), 16);\n\tg_assert (tindex == nfields);\n\tfile_info_type = LLVMStructCreateNamed (module->context, \"MonoAotFileInfo\");\n\tLLVMStructSetBody (file_info_type, eltypes, nfields, FALSE);\n\n\tinfo_var = LLVMAddGlobal (lmodule, file_info_type, \"mono_aot_file_info\");\n\tif (module->static_link) {\n\t\tLLVMSetVisibility (info_var, LLVMHiddenVisibility);\n\t\tLLVMSetLinkage (info_var, LLVMInternalLinkage);\n\t}\n\tfields = g_new (LLVMValueRef, nfields);\n\ttindex = 0;\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->version, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->dummy, FALSE);\n\n\t/* Symbols */\n\t/*\n\t * We use LLVMGetNamedGlobal () for symbol which are defined in LLVM code, and LLVMAddGlobal ()\n\t * for symbols defined in the .s file emitted by the aot compiler.\n\t */\n\teltype = eltypes [tindex];\n\tif (module->llvm_only)\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\telse\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"jit_got\");\n\tfields [tindex ++] = module->got_var;\n\t/* llc defines this directly */\n\tif (!module->llvm_only) {\n\t\tfields [tindex ++] = LLVMAddGlobal (lmodule, eltype, module->eh_frame_symbol);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t} else {\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = module->get_method;\n\t\tfields [tindex ++] = module->get_unbox_tramp;\n\t}\n\tif (module->has_jitted_code) {\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"jit_code_start\");\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"jit_code_end\");\n\t} else {\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t}\n\tif (!module->llvm_only)\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"method_addresses\");\n\telse\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\tif (info->flags & MONO_AOT_FILE_FLAG_SEPARATE_DATA) {\n\t\tfor (i = 0; i < MONO_AOT_TABLE_NUM; ++i)\n\t\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t} else {\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"blob\");\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"class_name_table\");\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"class_info_offsets\");\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"method_info_offsets\");\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"ex_info_offsets\");\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"extra_method_info_offsets\");\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"extra_method_table\");\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"got_info_offsets\");\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"llvm_got_info_offsets\");\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"image_table\");\n\t\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"weak_field_indexes\");\n\t}\n\t/* Not needed (mem_end) */\n\tfields [tindex ++] = LLVMConstNull (eltype);\n\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"assembly_guid\");\n\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"runtime_version\");\n\tif (info->trampoline_size [0]) {\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"specific_trampolines\");\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"static_rgctx_trampolines\");\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"imt_trampolines\");\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"gsharedvt_arg_trampolines\");\n\t} else {\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t}\n\tif (module->static_link && !module->llvm_only)\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"globals\");\n\telse\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\tfields [tindex ++] = LLVMGetNamedGlobal (lmodule, \"assembly_name\");\n\tif (!module->llvm_only) {\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"plt\");\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"plt_end\");\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"unwind_info\");\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"unbox_trampolines\");\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"unbox_trampolines_end\");\n\t\tfields [tindex ++] = AddJitGlobal (module, eltype, \"unbox_trampoline_addresses\");\n\t} else {\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t\tfields [tindex ++] = LLVMConstNull (eltype);\n\t}\n\n\tfor (i = 0; i < MONO_AOT_FILE_INFO_NUM_SYMBOLS; ++i) {\n\t\tg_assert (fields [2 + i]);\n\t\tfields [2 + i] = LLVMConstBitCast (fields [2 + i], eltype);\n\t}\n\n\t/* Scalars */\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->plt_got_offset_base, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->got_size, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->plt_size, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->nmethods, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->flags, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->opts, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->simd_opts, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->gc_name_index, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->num_rgctx_fetch_trampolines, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->double_align, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->long_align, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->generic_tramp_num, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->tramp_page_size, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->nshared_got_entries, FALSE);\n\tfields [tindex ++] = LLVMConstInt (LLVMInt32Type (), info->datafile_size, FALSE);\n\t/* Arrays */\n\tfields [tindex ++] = llvm_array_from_uints (LLVMInt32Type (), info->table_offsets, MONO_AOT_TABLE_NUM);\n\tfields [tindex ++] = llvm_array_from_uints (LLVMInt32Type (), info->num_trampolines, MONO_AOT_TRAMP_NUM);\n\tfields [tindex ++] = llvm_array_from_uints (LLVMInt32Type (), info->trampoline_got_offset_base, MONO_AOT_TRAMP_NUM);\n\tfields [tindex ++] = llvm_array_from_uints (LLVMInt32Type (), info->trampoline_size, MONO_AOT_TRAMP_NUM);\n\tfields [tindex ++] = llvm_array_from_uints (LLVMInt32Type (), info->tramp_page_code_offsets, MONO_AOT_TRAMP_NUM);\n\n\tfields [tindex ++] = llvm_array_from_bytes (info->aotid, 16);\n\tg_assert (tindex == nfields);\n\n\tLLVMSetInitializer (info_var, LLVMConstNamedStruct (file_info_type, fields, nfields));\n\n\tif (module->static_link) {\n\t\tchar *s, *p;\n\t\tLLVMValueRef var;\n\n\t\ts = g_strdup_printf (\"mono_aot_module_%s_info\", module->assembly->aname.name);\n\t\t/* Get rid of characters which cannot occur in symbols */\n\t\tp = s;\n\t\tfor (p = s; *p; ++p) {\n\t\t\tif (!(isalnum (*p) || *p == '_'))\n\t\t\t\t*p = '_';\n\t\t}\n\t\tvar = LLVMAddGlobal (module->lmodule, LLVMPointerType (LLVMInt8Type (), 0), s);\n\t\tg_free (s);\n\t\tLLVMSetInitializer (var, LLVMConstBitCast (LLVMGetNamedGlobal (module->lmodule, \"mono_aot_file_info\"), LLVMPointerType (LLVMInt8Type (), 0)));\n\t\tLLVMSetLinkage (var, LLVMExternalLinkage);\n\t}\n}\n\n/*\n * Emit the aot module into the LLVM bitcode file FILENAME.\n */\nvoid\nmono_llvm_emit_aot_module (const char *filename, const char *cu_name)\n{\n\tLLVMTypeRef got_type, inited_type;\n\tLLVMValueRef real_got, real_inited;\n\tMonoLLVMModule *module = &aot_module;\n\n\temit_llvm_code_end (module);\n\n\t/* \n\t * Create the real got variable and replace all uses of the dummy variable with\n\t * the real one.\n\t */\n\tgot_type = LLVMArrayType (module->ptr_type, module->max_got_offset + 1);\n\treal_got = LLVMAddGlobal (module->lmodule, got_type, module->got_symbol);\n\tLLVMSetInitializer (real_got, LLVMConstNull (got_type));\n\tif (module->external_symbols) {\n\t\tLLVMSetLinkage (real_got, LLVMExternalLinkage);\n\t\tLLVMSetVisibility (real_got, LLVMHiddenVisibility);\n\t} else {\n\t\tLLVMSetLinkage (real_got, LLVMInternalLinkage);\n\t}\n\tmono_llvm_replace_uses_of (module->got_var, real_got);\n\n\tmark_as_used (&aot_module, real_got);\n\n\t/* Delete the dummy got so it doesn't become a global */\n\tLLVMDeleteGlobal (module->got_var);\n\tmodule->got_var = real_got;\n\n\t/*\n\t * Same for the init_var\n\t */\n\tif (module->llvm_only) {\n\t\tinited_type = LLVMArrayType (LLVMInt8Type (), module->max_inited_idx + 1);\n\t\treal_inited = LLVMAddGlobal (module->lmodule, inited_type, \"mono_inited\");\n\t\tLLVMSetInitializer (real_inited, LLVMConstNull (inited_type));\n\t\tLLVMSetLinkage (real_inited, LLVMInternalLinkage);\n\t\tmono_llvm_replace_uses_of (module->inited_var, real_inited);\n\t\tLLVMDeleteGlobal (module->inited_var);\n\t}\n\n\tif (module->llvm_only) {\n\t\temit_get_method (&aot_module);\n\t\temit_get_unbox_tramp (&aot_module);\n\t}\n\n\temit_llvm_used (&aot_module);\n\temit_dbg_info (&aot_module, filename, cu_name);\n\temit_aot_file_info (&aot_module);\n\n\t/*\n\t * Replace GOT entries for directly callable methods with the methods themselves.\n\t * It would be easier to implement this by predefining all methods before compiling\n\t * their bodies, but that couldn't handle the case when a method fails to compile\n\t * with llvm.\n\t */\n\tif (module->llvm_only) {\n\t\tGHashTableIter iter;\n\t\tMonoMethod *method;\n\t\tGSList *callers, *l;\n\n\t\tg_hash_table_iter_init (&iter, module->method_to_callers);\n\t\twhile (g_hash_table_iter_next (&iter, (void**)&method, (void**)&callers)) {\n\t\t\tLLVMValueRef lmethod;\n\n\t\t\tif (method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED)\n\t\t\t\tcontinue;\n\n\t\t\tlmethod = (LLVMValueRef)g_hash_table_lookup (module->method_to_lmethod, method);\n\t\t\tif (lmethod) {\n\t\t\t\tfor (l = callers; l; l = l->next) {\n\t\t\t\t\tLLVMValueRef caller = (LLVMValueRef)l->data;\n\n\t\t\t\t\tmono_llvm_replace_uses_of (caller, lmethod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Replace PLT entries for directly callable methods with the methods themselves */\n\t{\n\t\tGHashTableIter iter;\n\t\tMonoJumpInfo *ji;\n\t\tLLVMValueRef callee;\n\n\t\tg_hash_table_iter_init (&iter, module->plt_entries_ji);\n\t\twhile (g_hash_table_iter_next (&iter, (void**)&ji, (void**)&callee)) {\n\t\t\tif (mono_aot_is_direct_callable (ji)) {\n\t\t\t\tLLVMValueRef lmethod;\n\n\t\t\t\tlmethod = (LLVMValueRef)g_hash_table_lookup (module->method_to_lmethod, ji->data.method);\n\t\t\t\t/* The types might not match because the caller might pass an rgctx */\n\t\t\t\tif (lmethod && LLVMTypeOf (callee) == LLVMTypeOf (lmethod)) {\n\t\t\t\t\tmono_llvm_replace_uses_of (callee, lmethod);\n\t\t\t\t\tmono_aot_mark_unused_llvm_plt_entry (ji);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#if 1\n\t{\n\t\tchar *verifier_err;\n\n\t\tif (LLVMVerifyModule (module->lmodule, LLVMReturnStatusAction, &verifier_err)) {\n\t\t\tprintf (\"%s\\n\", verifier_err);\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n#endif\n\n\tLLVMWriteBitcodeToFile (module->lmodule, filename);\n}\n\n\nstatic LLVMValueRef\nmd_string (const char *s)\n{\n\treturn LLVMMDString (s, strlen (s));\n}\n\n/* Debugging support */\n\nstatic void\nemit_dbg_info (MonoLLVMModule *module, const char *filename, const char *cu_name)\n{\n\tLLVMModuleRef lmodule = module->lmodule;\n\tLLVMValueRef args [16], ver;\n\n\t/*\n\t * This can only be enabled when LLVM code is emitted into a separate object\n\t * file, since the AOT compiler also emits dwarf info,\n\t * and the abbrev indexes will not be correct since llvm has added its own\n\t * abbrevs.\n\t */\n\tif (!module->emit_dwarf)\n\t\treturn;\n\n#if LLVM_API_VERSION > 100\n\tmono_llvm_di_builder_finalize (module->di_builder);\n#else\n\tLLVMValueRef cu_args [16], cu;\n\tint n_cuargs;\n\tchar *build_info, *s, *dir;\n\n\t/*\n\t * Emit dwarf info in the form of LLVM metadata. There is some\n\t * out-of-date documentation at:\n\t * http://llvm.org/docs/SourceLevelDebugging.html\n\t * but most of this was gathered from the llvm and\n\t * clang sources.\n\t */\n\n\tn_cuargs = 0;\n\tcu_args [n_cuargs ++] = LLVMConstInt (LLVMInt32Type (), DW_TAG_compile_unit, FALSE);\n\t/* CU name/compilation dir */\n\tdir = g_path_get_dirname (filename);\n\targs [0] = LLVMMDString (cu_name, strlen (cu_name));\n\targs [1] = LLVMMDString (dir, strlen (dir));\n\tcu_args [n_cuargs ++] = LLVMMDNode (args, 2);\n\tg_free (dir);\n\t/* Language */\n\tcu_args [n_cuargs ++] = LLVMConstInt (LLVMInt32Type (), DW_LANG_C99, FALSE);\n\t/* Producer */\n\tbuild_info = mono_get_runtime_build_info ();\n\ts = g_strdup_printf (\"Mono AOT Compiler %s (LLVM)\", build_info);\n\tcu_args [n_cuargs ++] = LLVMMDString (s, strlen (s));\n\tg_free (build_info);\n\t/* Optimized */\n\tcu_args [n_cuargs ++] = LLVMConstInt (LLVMInt32Type (), 1, FALSE);\n\t/* Flags */\n\tcu_args [n_cuargs ++] = LLVMMDString (\"\", strlen (\"\"));\n\t/* Runtime version */\n\tcu_args [n_cuargs ++] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t/* Enums */\n\tcu_args [n_cuargs ++] = LLVMMDNode (args, 0);\n\tcu_args [n_cuargs ++] = LLVMMDNode (args, 0);\n\t/* Subprograms */\n\tif (module->subprogram_mds) {\n\t\tLLVMValueRef *mds;\n\t\tint i;\n\n\t\tmds = g_new0 (LLVMValueRef, module->subprogram_mds->len);\n\t\tfor (i = 0; i < module->subprogram_mds->len; ++i)\n\t\t\tmds [i] = (LLVMValueRef)g_ptr_array_index (module->subprogram_mds, i);\n\t\tcu_args [n_cuargs ++] = LLVMMDNode (mds, module->subprogram_mds->len);\n\t} else {\n\t\tcu_args [n_cuargs ++] = LLVMMDNode (args, 0);\n\t}\n\t/* GVs */\n\tcu_args [n_cuargs ++] = LLVMMDNode (args, 0);\n\t/* Imported modules */\n\tcu_args [n_cuargs ++] = LLVMMDNode (args, 0);\n\t/* SplitName */\n\tcu_args [n_cuargs ++] = LLVMMDString (\"\", strlen (\"\"));\n\t/* DebugEmissionKind = FullDebug */\n\tcu_args [n_cuargs ++] = LLVMConstInt (LLVMInt32Type (), 1, FALSE);\n\tcu = LLVMMDNode (cu_args, n_cuargs);\n\tLLVMAddNamedMetadataOperand (lmodule, \"llvm.dbg.cu\", cu);\n#endif\n\n#if LLVM_API_VERSION > 100\n\targs [0] = LLVMConstInt (LLVMInt32Type (), 2, FALSE);\n\targs [1] = LLVMMDString (\"Dwarf Version\", strlen (\"Dwarf Version\"));\n\targs [2] = LLVMConstInt (LLVMInt32Type (), 2, FALSE);\n\tver = LLVMMDNode (args, 3);\n\tLLVMAddNamedMetadataOperand (lmodule, \"llvm.module.flags\", ver);\n\n\targs [0] = LLVMConstInt (LLVMInt32Type (), 2, FALSE);\n\targs [1] = LLVMMDString (\"Debug Info Version\", strlen (\"Debug Info Version\"));\n\targs [2] = LLVMConstInt (LLVMInt64Type (), 3, FALSE);\n\tver = LLVMMDNode (args, 3);\n\tLLVMAddNamedMetadataOperand (lmodule, \"llvm.module.flags\", ver);\n#else\n\targs [0] = LLVMConstInt (LLVMInt32Type (), 1, FALSE);\n\targs [1] = LLVMMDString (\"Dwarf Version\", strlen (\"Dwarf Version\"));\n\targs [2] = LLVMConstInt (LLVMInt32Type (), 2, FALSE);\n\tver = LLVMMDNode (args, 3);\n\tLLVMAddNamedMetadataOperand (lmodule, \"llvm.module.flags\", ver);\n\n\targs [0] = LLVMConstInt (LLVMInt32Type (), 1, FALSE);\n\targs [1] = LLVMMDString (\"Debug Info Version\", strlen (\"Debug Info Version\"));\n\targs [2] = LLVMConstInt (LLVMInt32Type (), 1, FALSE);\n\tver = LLVMMDNode (args, 3);\n\tLLVMAddNamedMetadataOperand (lmodule, \"llvm.module.flags\", ver);\n#endif\n}\n\nstatic LLVMValueRef\nemit_dbg_subprogram (EmitContext *ctx, MonoCompile *cfg, LLVMValueRef method, const char *name)\n{\n\tMonoLLVMModule *module = ctx->module;\n\tMonoDebugMethodInfo *minfo = ctx->minfo;\n\tchar *source_file, *dir, *filename;\n\tLLVMValueRef md, args [16], ctx_args [16], md_args [64], type_args [16], ctx_md, type_md;\n\tMonoSymSeqPoint *sym_seq_points;\n\tint n_seq_points;\n\n\tif (!minfo)\n\t\treturn NULL;\n\n\tmono_debug_get_seq_points (minfo, &source_file, NULL, NULL, &sym_seq_points, &n_seq_points);\n\tif (!source_file)\n\t\tsource_file = g_strdup (\"<unknown>\");\n\tdir = g_path_get_dirname (source_file);\n\tfilename = g_path_get_basename (source_file);\n\n#if LLVM_API_VERSION > 100\n\treturn mono_llvm_di_create_function (module->di_builder, module->cu, method, cfg->method->name, name, dir, filename, n_seq_points ? sym_seq_points [0].line : 1);\n#endif\n\n\tctx_args [0] = LLVMConstInt (LLVMInt32Type (), 0x29, FALSE);\n\targs [0] = md_string (filename);\n\targs [1] = md_string (dir);\n\tctx_args [1] = LLVMMDNode (args, 2);\n\tctx_md = LLVMMDNode (ctx_args, 2);\n\n\ttype_args [0] = LLVMConstInt (LLVMInt32Type (), DW_TAG_subroutine_type, FALSE);\n\ttype_args [1] = NULL;\n\ttype_args [2] = NULL;\n\ttype_args [3] = LLVMMDString (\"\", 0);\n\ttype_args [4] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\ttype_args [5] = LLVMConstInt (LLVMInt64Type (), 0, FALSE);\n\ttype_args [6] = LLVMConstInt (LLVMInt64Type (), 0, FALSE);\n\ttype_args [7] = LLVMConstInt (LLVMInt64Type (), 0, FALSE);\n\ttype_args [8] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\ttype_args [9] = NULL;\n\ttype_args [10] = NULL;\n\ttype_args [11] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\ttype_args [12] = NULL;\n\ttype_args [13] = NULL;\n\ttype_args [14] = NULL;\n\ttype_md = LLVMMDNode (type_args, 14);\n\n\t/* http://llvm.org/docs/SourceLevelDebugging.html#subprogram-descriptors */\n\tmd_args [0] = LLVMConstInt (LLVMInt32Type (), DW_TAG_subprogram, FALSE);\n\t/* Source directory + file pair */\n\targs [0] = md_string (filename);\n\targs [1] = md_string (dir);\n\tmd_args [1] = LLVMMDNode (args ,2);\n\tmd_args [2] = ctx_md;\n\tmd_args [3] = md_string (cfg->method->name);\n\tmd_args [4] = md_string (name);\n\tmd_args [5] = md_string (name);\n\t/* Line number */\n\tif (n_seq_points)\n\t\tmd_args [6] = LLVMConstInt (LLVMInt32Type (), sym_seq_points [0].line, FALSE);\n\telse\n\t\tmd_args [6] = LLVMConstInt (LLVMInt32Type (), 1, FALSE);\n\t/* Type */\n\tmd_args [7] = type_md;\n\t/* static */\n\tmd_args [8] = LLVMConstInt (LLVMInt1Type (), 0, FALSE);\n\t/* not extern */\n\tmd_args [9] = LLVMConstInt (LLVMInt1Type (), 1, FALSE);\n\t/* Virtuality */\n\tmd_args [10] = LLVMConstInt (LLVMInt32Type (), 0, FALSE);\n\t/* Index into a virtual function */\n\tmd_args [11] = NULL;\n\tmd_args [12] = NULL;\n\t/* Flags */\n\tmd_args [13] = LLVMConstInt (LLVMInt1Type (), 0, FALSE);\n\t/* isOptimized */\n\tmd_args [14] = LLVMConstInt (LLVMInt1Type (), 1, FALSE);\n\t/* Pointer to LLVM function */\n\tmd_args [15] = method;\n\t/* Function template parameter */\n\tmd_args [16] = NULL;\n\t/* Function declaration descriptor */\n\tmd_args [17] = NULL;\n\t/* List of function variables */\n\tmd_args [18] = LLVMMDNode (args, 0);\n\t/* Line number */\n\tmd_args [19] = LLVMConstInt (LLVMInt32Type (), 1, FALSE);\n\tmd = LLVMMDNode (md_args, 20);\n\n\tif (!module->subprogram_mds)\n\t\tmodule->subprogram_mds = g_ptr_array_new ();\n\tg_ptr_array_add (module->subprogram_mds, md);\n\n\tg_free (dir);\n\tg_free (filename);\n\tg_free (source_file);\n\tg_free (sym_seq_points);\n\n\treturn md;\n}\n\nstatic void\nemit_dbg_loc (EmitContext *ctx, LLVMBuilderRef builder, const unsigned char *cil_code)\n{\n\tMonoCompile *cfg = ctx->cfg;\n\n\tif (ctx->minfo && cil_code && cil_code >= cfg->header->code && cil_code < cfg->header->code + cfg->header->code_size) {\n\t\tMonoDebugSourceLocation *loc;\n\t\tLLVMValueRef loc_md;\n\n\t\tloc = mono_debug_method_lookup_location (ctx->minfo, cil_code - cfg->header->code);\n\n\t\tif (loc) {\n#if LLVM_API_VERSION > 100\n\t\t\tloc_md = mono_llvm_di_create_location (ctx->module->di_builder, ctx->dbg_md, loc->row, loc->column);\n\t\t\tmono_llvm_di_set_location (builder, loc_md);\n#else\n\t\t\tLLVMValueRef md_args [16];\n\t\t\tint nmd_args;\n\n\t\t\tnmd_args = 0;\n\t\t\tmd_args [nmd_args ++] = LLVMConstInt (LLVMInt32Type (), loc->row, FALSE);\n\t\t\tmd_args [nmd_args ++] = LLVMConstInt (LLVMInt32Type (), loc->column, FALSE);\n\t\t\tmd_args [nmd_args ++] = ctx->dbg_md;\n\t\t\tmd_args [nmd_args ++] = NULL;\n\t\t\tloc_md = LLVMMDNode (md_args, nmd_args);\n\t\t\tLLVMSetCurrentDebugLocation (builder, loc_md);\n#endif\n\t\t\tmono_debug_free_source_location (loc);\n\t\t}\n\t}\n}\n\nvoid\ndefault_mono_llvm_unhandled_exception (void)\n{\n\tMonoJitTlsData *jit_tls = mono_get_jit_tls ();\n\tMonoObject *target = mono_gchandle_get_target (jit_tls->thrown_exc);\n\n\tmono_unhandled_exception (target);\n\tmono_invoke_unhandled_exception_hook (target);\n\tg_assert_not_reached ();\n}\n\n/*\n  DESIGN:\n  - Emit LLVM IR from the mono IR using the LLVM C API.\n  - The original arch specific code remains, so we can fall back to it if we run\n    into something we can't handle.\n*/\n\n/*  \n  A partial list of issues:\n  - Handling of opcodes which can throw exceptions.\n\n      In the mono JIT, these are implemented using code like this:\n\t  method:\n      <compare>\n\t  throw_pos:\n\t  b<cond> ex_label\n\t  <rest of code>\n      ex_label:\n\t  push throw_pos - method\n\t  call <exception trampoline>\n\n\t  The problematic part is push throw_pos - method, which cannot be represented\n      in the LLVM IR, since it does not support label values.\n\t  -> this can be implemented in AOT mode using inline asm + labels, but cannot\n\t  be implemented in JIT mode ?\n\t  -> a possible but slower implementation would use the normal exception \n      throwing code but it would need to control the placement of the throw code\n      (it needs to be exactly after the compare+branch).\n\t  -> perhaps add a PC offset intrinsics ?\n\n  - efficient implementation of .ovf opcodes.\n\n\t  These are currently implemented as:\n\t  <ins which sets the condition codes>\n\t  b<cond> ex_label\n\n\t  Some overflow opcodes are now supported by LLVM SVN.\n\n  - exception handling, unwinding.\n    - SSA is disabled for methods with exception handlers    \n\t- How to obtain unwind info for LLVM compiled methods ?\n\t  -> this is now solved by converting the unwind info generated by LLVM\n\t     into our format.\n\t- LLVM uses the c++ exception handling framework, while we use our home grown\n      code, and couldn't use the c++ one:\n      - its not supported under VC++, other exotic platforms.\n\t  - it might be impossible to support filter clauses with it.\n\n  - trampolines.\n  \n    The trampolines need a predictable call sequence, since they need to disasm\n    the calling code to obtain register numbers / offsets.\n\n    LLVM currently generates this code in non-JIT mode:\n\t   mov    -0x98(%rax),%eax\n\t   callq  *%rax\n    Here, the vtable pointer is lost. \n    -> solution: use one vtable trampoline per class.\n\n  - passing/receiving the IMT pointer/RGCTX.\n    -> solution: pass them as normal arguments ?\n\n  - argument passing.\n  \n\t  LLVM does not allow the specification of argument registers etc. This means\n      that all calls are made according to the platform ABI.\n\n  - passing/receiving vtypes.\n\n      Vtypes passed/received in registers are handled by the front end by using\n\t  a signature with scalar arguments, and loading the parts of the vtype into those\n\t  arguments.\n\n\t  Vtypes passed on the stack are handled using the 'byval' attribute.\n\n  - ldaddr.\n\n    Supported though alloca, we need to emit the load/store code.\n\n  - types.\n\n    The mono JIT uses pointer sized iregs/double fregs, while LLVM uses precisely\n    typed registers, so we have to keep track of the precise LLVM type of each vreg.\n    This is made easier because the IR is already in SSA form.\n    An additional problem is that our IR is not consistent with types, i.e. i32/i64 \n\ttypes are frequently used incorrectly.\n*/\n\n/*\n  AOT SUPPORT:\n  Emit LLVM bytecode into a .bc file, compile it using llc into a .s file, then link\n  it with the file containing the methods emitted by the JIT and the AOT data\n  structures.\n*/\n\n/* FIXME: Normalize some aspects of the mono IR to allow easier translation, like:\n *   - each bblock should end with a branch\n *   - setting the return value, making cfg->ret non-volatile\n * - avoid some transformations in the JIT which make it harder for us to generate\n *   code.\n * - use pointer types to help optimizations.\n */\n\n#else /* DISABLE_JIT */\n\nvoid\nmono_llvm_cleanup (void)\n{\n}\n\nvoid\nmono_llvm_free_domain_info (MonoDomain *domain)\n{\n}\n\nvoid\nmono_llvm_init (void)\n{\n}\n\nvoid\ndefault_mono_llvm_unhandled_exception (void)\n{\n}\n\n#endif /* DISABLE_JIT */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mono/mini/llvm-jit.h": "/**\n * \\file\n * LLVM backend\n *\n * Authors:\n *   Zoltan Varga (vargaz@gmail.com)\n *\n * (C) 2009 Novell, Inc.\n */\n\n#ifndef __MONO_LLVM_JIT_H__\n#define __MONO_LLVM_JIT_H__\n\n#include <glib.h>\n\n#include \"llvm-c/Core.h\"\n#include \"llvm-c/ExecutionEngine.h\"\n\n#include <unwind.h>\n\nG_BEGIN_DECLS\n\ntypedef unsigned char * (AllocCodeMemoryCb) (LLVMValueRef function, int size);\ntypedef void (FunctionEmittedCb) (LLVMValueRef function, void *start, void *end);\ntypedef void (ExceptionTableCb) (void *data);\ntypedef char* (DlSymCb) (const char *name, void **symbol);\n\ntypedef void* MonoEERef;\n\nMonoEERef\nmono_llvm_create_ee (LLVMModuleProviderRef MP, AllocCodeMemoryCb *alloc_cb, FunctionEmittedCb *emitted_cb, ExceptionTableCb *exception_cb, DlSymCb *dlsym_cb, LLVMExecutionEngineRef *ee);\n\nvoid\nmono_llvm_dispose_ee (MonoEERef *mono_ee);\n\ngpointer\nmono_llvm_compile_method (MonoEERef mono_ee, LLVMValueRef method, int nvars, LLVMValueRef *callee_vars, gpointer *callee_addrs, gpointer *eh_frame);\n\nvoid\nmono_llvm_optimize_method (MonoEERef mono_ee, LLVMValueRef method);\n\nvoid\nmono_llvm_set_unhandled_exception_handler (void);\n\nG_END_DECLS\n\n#endif /* __MONO_LLVM_JIT_H__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mono/mini/aot-compiler.c": "/**\n * \\file\n * mono Ahead of Time compiler\n *\n * Author:\n *   Dietmar Maurer (dietmar@ximian.com)\n *   Zoltan Varga (vargaz@gmail.com)\n *   Johan Lorensson (lateralusx.github@gmail.com)\n *\n * (C) 2002 Ximian, Inc.\n * Copyright 2003-2011 Novell, Inc \n * Copyright 2011 Xamarin Inc (http://www.xamarin.com)\n * Licensed under the MIT license. See LICENSE file in the project root for full license information.\n */\n\n#include \"config.h\"\n#include <sys/types.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <fcntl.h>\n#include <ctype.h>\n#include <string.h>\n#ifndef HOST_WIN32\n#include <sys/time.h>\n#else\n#include <winsock2.h>\n#include <windows.h>\n#endif\n\n#include <errno.h>\n#include <sys/stat.h>\n\n#include <mono/metadata/abi-details.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/class.h>\n#include <mono/metadata/object.h>\n#include <mono/metadata/tokentype.h>\n#include <mono/metadata/appdomain.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/assembly.h>\n#include <mono/metadata/metadata-internals.h>\n#include <mono/metadata/reflection-internals.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/gc-internals.h>\n#include <mono/metadata/mempool-internals.h>\n#include <mono/metadata/mono-endian.h>\n#include <mono/metadata/threads-types.h>\n#include <mono/metadata/custom-attrs-internals.h>\n#include <mono/utils/mono-logger-internals.h>\n#include <mono/utils/mono-compiler.h>\n#include <mono/utils/mono-time.h>\n#include <mono/utils/mono-mmap.h>\n#include <mono/utils/mono-rand.h>\n#include <mono/utils/json.h>\n#include <mono/utils/mono-threads-coop.h>\n#include <mono/profiler/aot.h>\n#include <mono/utils/w32api.h>\n\n#include \"aot-compiler.h\"\n#include \"aot-runtime.h\"\n#include \"seq-points.h\"\n#include \"image-writer.h\"\n#include \"dwarfwriter.h\"\n#include \"mini-gc.h\"\n#include \"mini-llvm.h\"\n#include \"mini-runtime.h\"\n\n#if !defined(DISABLE_AOT) && !defined(DISABLE_JIT)\n\n// Use MSVC toolchain, Clang for MSVC using MSVC codegen and linker, when compiling for AMD64\n// targeting WIN32 platforms running AOT compiler on WIN32 platform with VS installation.\n#if defined(TARGET_AMD64) && defined(TARGET_WIN32) && defined(HOST_WIN32) && defined(_MSC_VER)\n#define TARGET_X86_64_WIN32_MSVC\n#endif\n\n#if defined(TARGET_X86_64_WIN32_MSVC)\n#define TARGET_WIN32_MSVC\n#endif\n\n// Emit native unwind info on Windows platforms (different from DWARF). Emitted unwind info\n// works when using the MSVC toolchain using Clang for MSVC codegen and linker. Only supported when\n// compiling for AMD64 (Windows x64 platforms).\n#if defined(TARGET_WIN32_MSVC) && defined(MONO_ARCH_HAVE_UNWIND_TABLE)\n#define EMIT_WIN32_UNWIND_INFO\n#endif\n\n#if defined(__linux__)\n#define RODATA_SECT \".rodata\"\n#elif defined(TARGET_MACH)\n#define RODATA_SECT \".section __TEXT, __const\"\n#elif defined(TARGET_WIN32_MSVC)\n#define RODATA_SECT \".rdata\"\n#else\n#define RODATA_SECT \".text\"\n#endif\n\n#define TV_DECLARE(name) gint64 name\n#define TV_GETTIME(tv) tv = mono_100ns_ticks ()\n#define TV_ELAPSED(start,end) (((end) - (start)) / 10)\n\n#define ALIGN_TO(val,align) ((((guint64)val) + ((align) - 1)) & ~((align) - 1))\n#define ALIGN_PTR_TO(ptr,align) (gpointer)((((gssize)(ptr)) + (align - 1)) & (~(align - 1)))\n#define ROUND_DOWN(VALUE,SIZE)\t((VALUE) & ~((SIZE) - 1))\n\ntypedef struct {\n\tchar *name;\n\tMonoImage *image;\n} ImageProfileData;\n\ntypedef struct ClassProfileData ClassProfileData;\n\ntypedef struct {\n\tint argc;\n\tClassProfileData **argv;\n\tMonoGenericInst *inst;\n} GInstProfileData;\n\nstruct ClassProfileData {\n\tImageProfileData *image;\n\tchar *ns, *name;\n\tGInstProfileData *inst;\n\tMonoClass *klass;\n};\n\ntypedef struct {\n\tClassProfileData *klass;\n\tint id;\n\tchar *name;\n\tint param_count;\n\tchar *signature;\n\tGInstProfileData *inst;\n\tMonoMethod *method;\n} MethodProfileData;\n\ntypedef struct {\n\tGHashTable *images, *classes, *ginsts, *methods;\n} ProfileData;\n\n/* predefined values for static readonly fields without needed to run the .cctor */\ntypedef struct _ReadOnlyValue ReadOnlyValue;\nstruct _ReadOnlyValue {\n\tReadOnlyValue *next;\n\tchar *name;\n\tint type; /* to be used later for typechecking to prevent user errors */\n\tunion {\n\t\tguint8 i1;\n\t\tguint16 i2;\n\t\tguint32 i4;\n\t\tguint64 i8;\n\t\tgpointer ptr;\n\t} value;\n};\nstatic ReadOnlyValue *readonly_values;\n\ntypedef struct MonoAotOptions {\n\tchar *outfile;\n\tchar *llvm_outfile;\n\tchar *data_outfile;\n\tGList *profile_files;\n\tgboolean save_temps;\n\tgboolean write_symbols;\n\tgboolean metadata_only;\n\tgboolean bind_to_runtime_version;\n\tMonoAotMode mode;\n\tgboolean no_dlsym;\n\tgboolean static_link;\n\tgboolean asm_only;\n\tgboolean asm_writer;\n\tgboolean nodebug;\n\tgboolean dwarf_debug;\n\tgboolean soft_debug;\n\tgboolean log_generics;\n\tgboolean log_instances;\n\tgboolean gen_msym_dir;\n\tchar *gen_msym_dir_path;\n\tgboolean direct_pinvoke;\n\tgboolean direct_icalls;\n\tgboolean no_direct_calls;\n\tgboolean use_trampolines_page;\n\tgboolean no_instances;\n\t// We are collecting inflated methods and emitting non-inflated\n\tgboolean dedup; \n\t// The name of the assembly for which the AOT module is going to have all deduped methods moved to. \n\t// When set, we are emitting inflated methods only\n\tchar *dedup_include; \n\tgboolean gnu_asm;\n\tgboolean llvm;\n\tgboolean llvm_only;\n\tint nthreads;\n\tint ntrampolines;\n\tint nrgctx_trampolines;\n\tint nimt_trampolines;\n\tint ngsharedvt_arg_trampolines;\n\tint nrgctx_fetch_trampolines;\n\tgboolean print_skipped_methods;\n\tgboolean stats;\n\tgboolean verbose;\n\tchar *tool_prefix;\n\tchar *ld_flags;\n\tchar *mtriple;\n\tchar *llvm_path;\n\tchar *temp_path;\n\tchar *instances_logfile_path;\n\tchar *logfile;\n\tgboolean dump_json;\n\tgboolean profile_only;\n} MonoAotOptions;\n\ntypedef enum {\n\tMETHOD_CAT_NORMAL,\n\tMETHOD_CAT_GSHAREDVT,\n\tMETHOD_CAT_INST,\n\tMETHOD_CAT_WRAPPER,\n\tMETHOD_CAT_NUM\n} MethodCategory;\n\ntypedef struct MonoAotStats {\n\tint ccount, mcount, lmfcount, abscount, gcount, ocount, genericcount;\n\tgint64 code_size, info_size, ex_info_size, unwind_info_size, got_size, class_info_size, got_info_size, plt_size;\n\tint methods_without_got_slots, direct_calls, all_calls, llvm_count;\n\tint got_slots, offsets_size;\n\tint method_categories [METHOD_CAT_NUM];\n\tint got_slot_types [MONO_PATCH_INFO_NUM];\n\tint got_slot_info_sizes [MONO_PATCH_INFO_NUM];\n\tint jit_time, gen_time, link_time;\n} MonoAotStats;\n\ntypedef struct GotInfo {\n\tGHashTable *patch_to_got_offset;\n\tGHashTable **patch_to_got_offset_by_type;\n\tGPtrArray *got_patches;\n} GotInfo;\n\n#ifdef EMIT_WIN32_UNWIND_INFO\ntypedef struct _UnwindInfoSectionCacheItem {\n\tchar *xdata_section_label;\n\tPUNWIND_INFO unwind_info;\n\tgboolean xdata_section_emitted;\n} UnwindInfoSectionCacheItem;\n#endif\n\ntypedef struct MonoAotCompile {\n\tMonoImage *image;\n\tGPtrArray *methods;\n\tGHashTable *method_indexes;\n\tGHashTable *method_depth;\n\tMonoCompile **cfgs;\n\tint cfgs_size;\n\tGHashTable **patch_to_plt_entry;\n\tGHashTable *plt_offset_to_entry;\n\t//GHashTable *patch_to_got_offset;\n\t//GHashTable **patch_to_got_offset_by_type;\n\t//GPtrArray *got_patches;\n\tGotInfo got_info, llvm_got_info;\n\tGHashTable *image_hash;\n\tGHashTable *method_to_cfg;\n\tGHashTable *token_info_hash;\n\tGHashTable *method_to_pinvoke_import;\n\tGPtrArray *extra_methods;\n\tGPtrArray *image_table;\n\tGPtrArray *globals;\n\tGPtrArray *method_order;\n\tGHashTable *dedup_stats;\n\tGHashTable *dedup_cache;\n\tgboolean dedup_cache_changed;\n\tGHashTable *export_names;\n\t/* Maps MonoClass* -> blob offset */\n\tGHashTable *klass_blob_hash;\n\t/* Maps MonoMethod* -> blob offset */\n\tGHashTable *method_blob_hash;\n\tGHashTable *gsharedvt_in_signatures;\n\tGHashTable *gsharedvt_out_signatures;\n\tguint32 *plt_got_info_offsets;\n\tguint32 got_offset, llvm_got_offset, plt_offset, plt_got_offset_base, nshared_got_entries;\n\t/* Number of GOT entries reserved for trampolines */\n\tguint32 num_trampoline_got_entries;\n\tguint32 tramp_page_size;\n\n\tguint32 table_offsets [MONO_AOT_TABLE_NUM];\n\tguint32 num_trampolines [MONO_AOT_TRAMP_NUM];\n\tguint32 trampoline_got_offset_base [MONO_AOT_TRAMP_NUM];\n\tguint32 trampoline_size [MONO_AOT_TRAMP_NUM];\n\tguint32 tramp_page_code_offsets [MONO_AOT_TRAMP_NUM];\n\n\tMonoAotOptions aot_opts;\n\tguint32 nmethods;\n\tguint32 opts;\n\tguint32 simd_opts;\n\tMonoMemPool *mempool;\n\tMonoAotStats stats;\n\tint method_index;\n\tchar *static_linking_symbol;\n\tmono_mutex_t mutex;\n\tgboolean gas_line_numbers;\n\t/* Whenever to emit an object file directly from llc */\n\tgboolean llvm_owriter;\n\tgboolean llvm_owriter_supported;\n\tMonoImageWriter *w;\n\tMonoDwarfWriter *dwarf;\n\tFILE *fp;\n\tchar *tmpbasename;\n\tchar *tmpfname;\n\tchar *llvm_sfile;\n\tchar *llvm_ofile;\n\tGSList *cie_program;\n\tGHashTable *unwind_info_offsets;\n\tGPtrArray *unwind_ops;\n\tguint32 unwind_info_offset;\n\tchar *global_prefix;\n\tchar *got_symbol;\n\tchar *llvm_got_symbol;\n\tchar *plt_symbol;\n\tchar *llvm_eh_frame_symbol;\n\tGHashTable *method_label_hash;\n\tconst char *temp_prefix;\n\tconst char *user_symbol_prefix;\n\tconst char *llvm_label_prefix;\n\tconst char *inst_directive;\n\tint align_pad_value;\n\tguint32 label_generator;\n\tgboolean llvm;\n\tgboolean has_jitted_code;\n\tgboolean is_full_aot;\n\tMonoAotFileFlags flags;\n\tMonoDynamicStream blob;\n\tgboolean blob_closed;\n\tGHashTable *typespec_classes;\n\tGString *llc_args;\n\tGString *as_args;\n\tchar *assembly_name_sym;\n\tGHashTable *plt_entry_debug_sym_cache;\n\tgboolean thumb_mixed, need_no_dead_strip, need_pt_gnu_stack;\n\tGHashTable *ginst_hash;\n\tGHashTable *dwarf_ln_filenames;\n\tgboolean global_symbols;\n\tint objc_selector_index, objc_selector_index_2;\n\tGPtrArray *objc_selectors;\n\tGHashTable *objc_selector_to_index;\n\tGList *profile_data;\n\tGHashTable *profile_methods;\n#ifdef EMIT_WIN32_UNWIND_INFO\n\tGList *unwind_info_section_cache;\n#endif\n\tFILE *logfile;\n\tFILE *instances_logfile;\n\tFILE *data_outfile;\n\tint datafile_offset;\n\tint gc_name_offset;\n\t// In this mode, we are emitting dedupable methods that we encounter\n\tgboolean dedup_emit_mode;\n} MonoAotCompile;\n\ntypedef struct {\n\tint plt_offset;\n\tchar *symbol, *llvm_symbol, *debug_sym;\n\tMonoJumpInfo *ji;\n\tgboolean jit_used, llvm_used;\n} MonoPltEntry;\n\n#define mono_acfg_lock(acfg) mono_os_mutex_lock (&((acfg)->mutex))\n#define mono_acfg_unlock(acfg) mono_os_mutex_unlock (&((acfg)->mutex))\n\n/* This points to the current acfg in LLVM mode */\nstatic MonoAotCompile *llvm_acfg;\n\n#ifdef HAVE_ARRAY_ELEM_INIT\n#define MSGSTRFIELD(line) MSGSTRFIELD1(line)\n#define MSGSTRFIELD1(line) str##line\nstatic const struct msgstr_t {\n#define PATCH_INFO(a,b) char MSGSTRFIELD(__LINE__) [sizeof (b)];\n#include \"patch-info.h\"\n#undef PATCH_INFO\n} opstr = {\n#define PATCH_INFO(a,b) b,\n#include \"patch-info.h\"\n#undef PATCH_INFO\n};\nstatic const gint16 opidx [] = {\n#define PATCH_INFO(a,b) [MONO_PATCH_INFO_ ## a] = offsetof (struct msgstr_t, MSGSTRFIELD(__LINE__)),\n#include \"patch-info.h\"\n#undef PATCH_INFO\n};\n\nstatic G_GNUC_UNUSED const char*\nget_patch_name (int info)\n{\n\treturn (const char*)&opstr + opidx [info];\n}\n\n#else\n#define PATCH_INFO(a,b) b,\nstatic const char* const\npatch_types [MONO_PATCH_INFO_NUM + 1] = {\n#include \"patch-info.h\"\n\tNULL\n};\n\nstatic G_GNUC_UNUSED const char*\nget_patch_name (int info)\n{\n\treturn patch_types [info];\n}\n\n#endif\n\nstatic void \nmono_flush_method_cache (MonoAotCompile *acfg);\n\nstatic void \nmono_read_method_cache (MonoAotCompile *acfg);\n\nstatic guint32\nget_unwind_info_offset (MonoAotCompile *acfg, guint8 *encoded, guint32 encoded_len);\n\nstatic char*\nget_plt_entry_debug_sym (MonoAotCompile *acfg, MonoJumpInfo *ji, GHashTable *cache);\n\nstatic void\nadd_gsharedvt_wrappers (MonoAotCompile *acfg, MonoMethodSignature *sig, gboolean gsharedvt_in, gboolean gsharedvt_out);\n\nstatic void\nadd_profile_instances (MonoAotCompile *acfg, ProfileData *data);\n\nstatic inline gboolean\nignore_cfg (MonoCompile *cfg)\n{\n\treturn !cfg || cfg->skip;\n}\n\nstatic void\naot_printf (MonoAotCompile *acfg, const gchar *format, ...)\n{\n\tFILE *output;\n\tva_list args;\n\n\tif (acfg->logfile)\n\t\toutput = acfg->logfile;\n\telse\n\t\toutput = stdout;\n\n\tva_start (args, format);\n\tvfprintf (output, format, args);\n\tva_end (args);\n}\n\nstatic void\naot_printerrf (MonoAotCompile *acfg, const gchar *format, ...)\n{\n\tFILE *output;\n\tva_list args;\n\n\tif (acfg->logfile)\n\t\toutput = acfg->logfile;\n\telse\n\t\toutput = stderr;\n\n\tva_start (args, format);\n\tvfprintf (output, format, args);\n\tva_end (args);\n}\n\nstatic void\nreport_loader_error (MonoAotCompile *acfg, MonoError *error, gboolean fatal, const char *format, ...)\n{\n\tFILE *output;\n\tva_list args;\n\n\tif (mono_error_ok (error))\n\t\treturn;\n\n\tif (acfg->logfile)\n\t\toutput = acfg->logfile;\n\telse\n\t\toutput = stderr;\n\n\tva_start (args, format);\n\tvfprintf (output, format, args);\n\tva_end (args);\n\tmono_error_cleanup (error);\n\n\tif (acfg->is_full_aot && fatal) {\n\t\tfprintf (output, \"FullAOT cannot continue if there are loader errors.\\n\");\n\t\texit (1);\n\t}\n}\n\n/* Wrappers around the image writer functions */\n\n#define MAX_SYMBOL_SIZE 256\n\nstatic inline const char *\nmangle_symbol (const char * symbol, char * mangled_symbol, gsize length)\n{\n\tgsize needed_size = length;\n\n\tg_assert (NULL != symbol);\n\tg_assert (NULL != mangled_symbol);\n\tg_assert (0 != length);\n\n#if defined(TARGET_WIN32) && defined(TARGET_X86)\n\tif (symbol && '_' != symbol [0]) {\n\t\tneeded_size = g_snprintf (mangled_symbol, length, \"_%s\", symbol);\n\t} else {\n\t\tneeded_size = g_snprintf (mangled_symbol, length, \"%s\", symbol);\n\t}\n#else\n\tneeded_size = g_snprintf (mangled_symbol, length, \"%s\", symbol);\n#endif\n\n\tg_assert (0 <= needed_size && needed_size < length);\n\treturn mangled_symbol;\n}\n\nstatic inline char *\nmangle_symbol_alloc (const char * symbol)\n{\n\tg_assert (NULL != symbol);\n\n#if defined(TARGET_WIN32) && defined(TARGET_X86)\n\tif (symbol && '_' != symbol [0]) {\n\t\treturn g_strdup_printf (\"_%s\", symbol);\n\t}\n\telse {\n\t\treturn g_strdup_printf (\"%s\", symbol);\n\t}\n#else\n\treturn g_strdup_printf (\"%s\", symbol);\n#endif\n}\n\nstatic inline void\nemit_section_change (MonoAotCompile *acfg, const char *section_name, int subsection_index)\n{\n\tmono_img_writer_emit_section_change (acfg->w, section_name, subsection_index);\n}\n\n#if defined(TARGET_WIN32) && defined(TARGET_X86)\n\nstatic inline void\nemit_local_symbol (MonoAotCompile *acfg, const char *name, const char *end_label, gboolean func)\n{\n\tconst char * mangled_symbol_name = name;\n\tchar * mangled_symbol_name_alloc = NULL;\n\n\tif (TRUE == func) {\n\t\tmangled_symbol_name_alloc = mangle_symbol_alloc (name);\n\t\tmangled_symbol_name = mangled_symbol_name_alloc;\n\t}\n\n\tif (name != mangled_symbol_name && 0 != g_strcasecmp (name, mangled_symbol_name)) {\n\t\tmono_img_writer_emit_label (acfg->w, mangled_symbol_name);\n\t}\n\tmono_img_writer_emit_local_symbol (acfg->w, mangled_symbol_name, end_label, func);\n\n\tif (NULL != mangled_symbol_name_alloc) {\n\t\tg_free (mangled_symbol_name_alloc);\n\t}\n}\n\n#else\n\nstatic inline void\nemit_local_symbol (MonoAotCompile *acfg, const char *name, const char *end_label, gboolean func) \n{ \n\tmono_img_writer_emit_local_symbol (acfg->w, name, end_label, func);\n}\n\n#endif\n\nstatic inline void\nemit_label (MonoAotCompile *acfg, const char *name) \n{ \n\tmono_img_writer_emit_label (acfg->w, name); \n}\n\nstatic inline void\nemit_bytes (MonoAotCompile *acfg, const guint8* buf, int size) \n{ \n\tmono_img_writer_emit_bytes (acfg->w, buf, size); \n}\n\nstatic inline void\nemit_string (MonoAotCompile *acfg, const char *value) \n{ \n\tmono_img_writer_emit_string (acfg->w, value); \n}\n\nstatic inline void\nemit_line (MonoAotCompile *acfg) \n{ \n\tmono_img_writer_emit_line (acfg->w); \n}\n\nstatic inline void\nemit_alignment (MonoAotCompile *acfg, int size)\n{ \n\tmono_img_writer_emit_alignment (acfg->w, size);\n}\n\nstatic inline void\nemit_alignment_code (MonoAotCompile *acfg, int size)\n{\n\tif (acfg->align_pad_value)\n\t\tmono_img_writer_emit_alignment_fill (acfg->w, size, acfg->align_pad_value);\n\telse\n\t\tmono_img_writer_emit_alignment (acfg->w, size);\n}\n\nstatic inline void\nemit_padding (MonoAotCompile *acfg, int size)\n{\n\tint i;\n\tguint8 buf [16];\n\n\tif (acfg->align_pad_value) {\n\t\tfor (i = 0; i < 16; ++i)\n\t\t\tbuf [i] = acfg->align_pad_value;\n\t} else {\n\t\tmemset (buf, 0, sizeof (buf));\n\t}\n\n\tfor (i = 0; i < size; i += 16) {\n\t\tif (size - i < 16)\n\t\t\temit_bytes (acfg, buf, size - i);\n\t\telse\n\t\t\temit_bytes (acfg, buf, 16);\n\t}\n}\n\nstatic inline void\nemit_pointer (MonoAotCompile *acfg, const char *target) \n{ \n\tmono_img_writer_emit_pointer (acfg->w, target); \n}\n\nstatic inline void\nemit_pointer_2 (MonoAotCompile *acfg, const char *prefix, const char *target) \n{ \n\tif (prefix [0] != '\\0') {\n\t\tchar *s = g_strdup_printf (\"%s%s\", prefix, target);\n\t\tmono_img_writer_emit_pointer (acfg->w, s);\n\t\tg_free (s);\n\t} else {\n\t\tmono_img_writer_emit_pointer (acfg->w, target);\n\t}\n}\n\nstatic inline void\nemit_int16 (MonoAotCompile *acfg, int value) \n{ \n\tmono_img_writer_emit_int16 (acfg->w, value); \n}\n\nstatic inline void\nemit_int32 (MonoAotCompile *acfg, int value) \n{ \n\tmono_img_writer_emit_int32 (acfg->w, value); \n}\n\nstatic inline void\nemit_symbol_diff (MonoAotCompile *acfg, const char *end, const char* start, int offset) \n{ \n\tmono_img_writer_emit_symbol_diff (acfg->w, end, start, offset); \n}\n\nstatic inline void\nemit_zero_bytes (MonoAotCompile *acfg, int num) \n{ \n\tmono_img_writer_emit_zero_bytes (acfg->w, num); \n}\n\nstatic inline void\nemit_byte (MonoAotCompile *acfg, guint8 val) \n{ \n\tmono_img_writer_emit_byte (acfg->w, val); \n}\n\n#if defined(TARGET_WIN32) && defined(TARGET_X86)\n\nstatic G_GNUC_UNUSED void\nemit_global_inner (MonoAotCompile *acfg, const char *name, gboolean func)\n{\n\tconst char * mangled_symbol_name = name;\n\tchar * mangled_symbol_name_alloc = NULL;\n\n\tmangled_symbol_name_alloc = mangle_symbol_alloc (name);\n\tmangled_symbol_name = mangled_symbol_name_alloc;\n\t\n\tif (0 != g_strcasecmp (name, mangled_symbol_name)) {\n\t\tmono_img_writer_emit_label (acfg->w, mangled_symbol_name);\n\t}\n\tmono_img_writer_emit_global (acfg->w, mangled_symbol_name, func);\n\n\tif (NULL != mangled_symbol_name_alloc) {\n\t\tg_free (mangled_symbol_name_alloc);\n\t}\n}\n\n#else\n\nstatic G_GNUC_UNUSED void\nemit_global_inner (MonoAotCompile *acfg, const char *name, gboolean func)\n{\n\tmono_img_writer_emit_global (acfg->w, name, func);\n}\n\n#endif\n\nstatic inline gboolean\nlink_shared_library (MonoAotCompile *acfg)\n{\n\treturn !acfg->aot_opts.static_link && !acfg->aot_opts.asm_only;\n}\n\nstatic inline gboolean\nadd_to_global_symbol_table (MonoAotCompile *acfg)\n{\n#ifdef TARGET_WIN32_MSVC\n\treturn acfg->aot_opts.no_dlsym || link_shared_library (acfg);\n#else\n\treturn acfg->aot_opts.no_dlsym;\n#endif\n}\n\nstatic void\nemit_global (MonoAotCompile *acfg, const char *name, gboolean func)\n{\n\tif (add_to_global_symbol_table (acfg))\n\t\tg_ptr_array_add (acfg->globals, g_strdup (name));\n\n\tif (acfg->aot_opts.no_dlsym) {\n\t\tmono_img_writer_emit_local_symbol (acfg->w, name, NULL, func);\n\t} else {\n\t\temit_global_inner (acfg, name, func);\n\t}\n}\n\nstatic void\nemit_symbol_size (MonoAotCompile *acfg, const char *name, const char *end_label)\n{\n\tmono_img_writer_emit_symbol_size (acfg->w, name, end_label);\n}\n\n/* Emit a symbol which is referenced by the MonoAotFileInfo structure */\nstatic void\nemit_info_symbol (MonoAotCompile *acfg, const char *name)\n{\n\tchar symbol [MAX_SYMBOL_SIZE];\n\n\tif (acfg->llvm) {\n\t\temit_label (acfg, name);\n\t\t/* LLVM generated code references this */\n\t\tsprintf (symbol, \"%s%s%s\", acfg->user_symbol_prefix, acfg->global_prefix, name);\n\t\temit_label (acfg, symbol);\n\t\temit_global_inner (acfg, symbol, FALSE);\n\t} else {\n\t\temit_label (acfg, name);\n\t}\n}\n\nstatic void\nemit_string_symbol (MonoAotCompile *acfg, const char *name, const char *value)\n{\n\tif (acfg->llvm) {\n\t\tmono_llvm_emit_aot_data (name, (guint8*)value, strlen (value) + 1);\n\t\treturn;\n\t}\n\n\tmono_img_writer_emit_section_change (acfg->w, RODATA_SECT, 1);\n#ifdef TARGET_MACH\n\t/* On apple, all symbols need to be aligned to avoid warnings from ld */\n\temit_alignment (acfg, 4);\n#endif\n\tmono_img_writer_emit_label (acfg->w, name);\n\tmono_img_writer_emit_string (acfg->w, value);\n}\n\nstatic G_GNUC_UNUSED void\nemit_uleb128 (MonoAotCompile *acfg, guint32 value)\n{\n\tdo {\n\t\tguint8 b = value & 0x7f;\n\t\tvalue >>= 7;\n\t\tif (value != 0) /* more bytes to come */\n\t\t\tb |= 0x80;\n\t\temit_byte (acfg, b);\n\t} while (value);\n}\n\nstatic G_GNUC_UNUSED void\nemit_sleb128 (MonoAotCompile *acfg, gint64 value)\n{\n\tgboolean more = 1;\n\tgboolean negative = (value < 0);\n\tguint32 size = 64;\n\tguint8 byte;\n\n\twhile (more) {\n\t\tbyte = value & 0x7f;\n\t\tvalue >>= 7;\n\t\t/* the following is unnecessary if the\n\t\t * implementation of >>= uses an arithmetic rather\n\t\t * than logical shift for a signed left operand\n\t\t */\n\t\tif (negative)\n\t\t\t/* sign extend */\n\t\t\tvalue |= - ((gint64)1 <<(size - 7));\n\t\t/* sign bit of byte is second high order bit (0x40) */\n\t\tif ((value == 0 && !(byte & 0x40)) ||\n\t\t\t(value == -1 && (byte & 0x40)))\n\t\t\tmore = 0;\n\t\telse\n\t\t\tbyte |= 0x80;\n\t\temit_byte (acfg, byte);\n\t}\n}\n\nstatic G_GNUC_UNUSED void\nencode_uleb128 (guint32 value, guint8 *buf, guint8 **endbuf)\n{\n\tguint8 *p = buf;\n\n\tdo {\n\t\tguint8 b = value & 0x7f;\n\t\tvalue >>= 7;\n\t\tif (value != 0) /* more bytes to come */\n\t\t\tb |= 0x80;\n\t\t*p ++ = b;\n\t} while (value);\n\n\t*endbuf = p;\n}\n\nstatic G_GNUC_UNUSED void\nencode_sleb128 (gint32 value, guint8 *buf, guint8 **endbuf)\n{\n\tgboolean more = 1;\n\tgboolean negative = (value < 0);\n\tguint32 size = 32;\n\tguint8 byte;\n\tguint8 *p = buf;\n\n\twhile (more) {\n\t\tbyte = value & 0x7f;\n\t\tvalue >>= 7;\n\t\t/* the following is unnecessary if the\n\t\t * implementation of >>= uses an arithmetic rather\n\t\t * than logical shift for a signed left operand\n\t\t */\n\t\tif (negative)\n\t\t\t/* sign extend */\n\t\t\tvalue |= - (1 <<(size - 7));\n\t\t/* sign bit of byte is second high order bit (0x40) */\n\t\tif ((value == 0 && !(byte & 0x40)) ||\n\t\t\t(value == -1 && (byte & 0x40)))\n\t\t\tmore = 0;\n\t\telse\n\t\t\tbyte |= 0x80;\n\t\t*p ++= byte;\n\t}\n\n\t*endbuf = p;\n}\n\nstatic void\nencode_int (gint32 val, guint8 *buf, guint8 **endbuf)\n{\n\t// FIXME: Big-endian\n\tbuf [0] = (val >> 0) & 0xff;\n\tbuf [1] = (val >> 8) & 0xff;\n\tbuf [2] = (val >> 16) & 0xff;\n\tbuf [3] = (val >> 24) & 0xff;\n\n\t*endbuf = buf + 4;\n}\n\nstatic void\nencode_int16 (guint16 val, guint8 *buf, guint8 **endbuf)\n{\n\tbuf [0] = (val >> 0) & 0xff;\n\tbuf [1] = (val >> 8) & 0xff;\n\n\t*endbuf = buf + 2;\n}\n\nstatic void\nencode_string (const char *s, guint8 *buf, guint8 **endbuf)\n{\n\tint len = strlen (s);\n\n\tmemcpy (buf, s, len + 1);\n\t*endbuf = buf + len + 1;\n}\n\nstatic void\nemit_unset_mode (MonoAotCompile *acfg)\n{\n\tmono_img_writer_emit_unset_mode (acfg->w);\n}\n\nstatic G_GNUC_UNUSED void\nemit_set_thumb_mode (MonoAotCompile *acfg)\n{\n\temit_unset_mode (acfg);\n\tfprintf (acfg->fp, \".code 16\\n\");\n}\n\nstatic G_GNUC_UNUSED void\nemit_set_arm_mode (MonoAotCompile *acfg)\n{\n\temit_unset_mode (acfg);\n\tfprintf (acfg->fp, \".code 32\\n\");\n}\n\nstatic inline void\nemit_code_bytes (MonoAotCompile *acfg, const guint8* buf, int size)\n{\n#ifdef TARGET_ARM64\n\tint i;\n\n\tg_assert (size % 4 == 0);\n\temit_unset_mode (acfg);\n\tfor (i = 0; i < size; i += 4)\n\t\tfprintf (acfg->fp, \"%s 0x%x\\n\", acfg->inst_directive, *(guint32*)(buf + i));\n#else\n\temit_bytes (acfg, buf, size);\n#endif\n}\n\n/* ARCHITECTURE SPECIFIC CODE */\n\n#if defined(TARGET_X86) || defined(TARGET_AMD64) || defined(TARGET_ARM) || defined(TARGET_POWERPC) || defined(TARGET_ARM64)\n#define EMIT_DWARF_INFO 1\n#endif\n\n#ifdef TARGET_WIN32_MSVC\n#undef EMIT_DWARF_INFO\n#define EMIT_WIN32_CODEVIEW_INFO\n#endif\n\n#ifdef EMIT_WIN32_UNWIND_INFO\nstatic UnwindInfoSectionCacheItem *\nget_cached_unwind_info_section_item_win32 (MonoAotCompile *acfg, const char *function_start, const char *function_end, GSList *unwind_ops);\n\nstatic void\nfree_unwind_info_section_cache_win32 (MonoAotCompile *acfg);\n\nstatic void\nemit_unwind_info_data_win32 (MonoAotCompile *acfg, PUNWIND_INFO unwind_info);\n\nstatic void\nemit_unwind_info_sections_win32 (MonoAotCompile *acfg, const char *function_start, const char *function_end, GSList *unwind_ops);\n#endif\n\nstatic void\narch_free_unwind_info_section_cache (MonoAotCompile *acfg)\n{\n#ifdef EMIT_WIN32_UNWIND_INFO\n\tfree_unwind_info_section_cache_win32 (acfg);\n#endif\n}\n\nstatic void\narch_emit_unwind_info_sections (MonoAotCompile *acfg, const char *function_start, const char *function_end, GSList *unwind_ops)\n{\n#ifdef EMIT_WIN32_UNWIND_INFO\n\tgboolean own_unwind_ops = FALSE;\n\tif (!unwind_ops) {\n\t\tunwind_ops = mono_unwind_get_cie_program ();\n\t\town_unwind_ops = TRUE;\n\t}\n\n\temit_unwind_info_sections_win32 (acfg, function_start, function_end, unwind_ops);\n\n\tif (own_unwind_ops)\n\t\tmono_free_unwind_info (unwind_ops);\n#endif\n}\n\n#if defined(TARGET_ARM)\n#define AOT_FUNC_ALIGNMENT 4\n#else\n#define AOT_FUNC_ALIGNMENT 16\n#endif\n \n#if defined(TARGET_POWERPC64) && !defined(__mono_ilp32__)\n#define PPC_LD_OP \"ld\"\n#define PPC_LDX_OP \"ldx\"\n#else\n#define PPC_LD_OP \"lwz\"\n#define PPC_LDX_OP \"lwzx\"\n#endif\n\n#ifdef TARGET_X86_64_WIN32_MSVC\n#define AOT_TARGET_STR \"AMD64 (WIN32) (MSVC codegen)\"\n#elif TARGET_AMD64\n#define AOT_TARGET_STR \"AMD64\"\n#endif\n\n#ifdef TARGET_ARM\n#ifdef TARGET_MACH\n#define AOT_TARGET_STR \"ARM (MACH)\"\n#else\n#define AOT_TARGET_STR \"ARM (!MACH)\"\n#endif\n#endif\n\n#ifdef TARGET_ARM64\n#ifdef TARGET_MACH\n#define AOT_TARGET_STR \"ARM64 (MACH)\"\n#else\n#define AOT_TARGET_STR \"ARM64 (!MACH)\"\n#endif\n#endif\n\n#ifdef TARGET_POWERPC64\n#ifdef __mono_ilp32__\n#define AOT_TARGET_STR \"POWERPC64 (mono ilp32)\"\n#else\n#define AOT_TARGET_STR \"POWERPC64 (!mono ilp32)\"\n#endif\n#else\n#ifdef TARGET_POWERPC\n#ifdef __mono_ilp32__\n#define AOT_TARGET_STR \"POWERPC (mono ilp32)\"\n#else\n#define AOT_TARGET_STR \"POWERPC (!mono ilp32)\"\n#endif\n#endif\n#endif\n\n#ifdef TARGET_X86\n#ifdef TARGET_WIN32\n#define AOT_TARGET_STR \"X86 (WIN32)\"\n#else\n#define AOT_TARGET_STR \"X86\"\n#endif\n#endif\n\n#ifndef AOT_TARGET_STR\n#define AOT_TARGET_STR \"\"\n#endif\n\nstatic void\narch_init (MonoAotCompile *acfg)\n{\n\tacfg->llc_args = g_string_new (\"\");\n\tacfg->as_args = g_string_new (\"\");\n\tacfg->llvm_owriter_supported = TRUE;\n\n\t/*\n\t * The prefix LLVM likes to put in front of symbol names on darwin.\n\t * The mach-os specs require this for globals, but LLVM puts them in front of all\n\t * symbols. We need to handle this, since we need to refer to LLVM generated\n\t * symbols.\n\t */\n\tacfg->llvm_label_prefix = \"\";\n\tacfg->user_symbol_prefix = \"\";\n\n#if defined(TARGET_X86)\n\tg_string_append (acfg->llc_args, \" -march=x86 -mattr=sse4.1\");\n#endif\n\n#if defined(TARGET_AMD64)\n\tg_string_append (acfg->llc_args, \" -march=x86-64 -mattr=sse4.1\");\n\t/* NOP */\n\tacfg->align_pad_value = 0x90;\n#endif\n\n#ifdef TARGET_ARM\n\tif (acfg->aot_opts.mtriple && strstr (acfg->aot_opts.mtriple, \"darwin\")) {\n\t\tg_string_append (acfg->llc_args, \"-mattr=+v6\");\n\t} else {\n#if defined(ARM_FPU_VFP_HARD)\n\t\tg_string_append (acfg->llc_args, \" -mattr=+vfp2,-neon,+d16 -float-abi=hard\");\n\t\tg_string_append (acfg->as_args, \" -mfpu=vfp3\");\n#elif defined(ARM_FPU_VFP)\n\t\tg_string_append (acfg->llc_args, \" -mattr=+vfp2,-neon,+d16\");\n\t\tg_string_append (acfg->as_args, \" -mfpu=vfp3\");\n#else\n\t\tg_string_append (acfg->llc_args, \" -soft-float\");\n#endif\n\t}\n\tif (acfg->aot_opts.mtriple && strstr (acfg->aot_opts.mtriple, \"thumb\"))\n\t\tacfg->thumb_mixed = TRUE;\n\n\tif (acfg->aot_opts.mtriple)\n\t\tmono_arch_set_target (acfg->aot_opts.mtriple);\n#endif\n\n#ifdef TARGET_ARM64\n\tacfg->inst_directive = \".inst\";\n\tif (acfg->aot_opts.mtriple)\n\t\tmono_arch_set_target (acfg->aot_opts.mtriple);\n#endif\n\n#ifdef TARGET_MACH\n\tacfg->user_symbol_prefix = \"_\";\n\tacfg->llvm_label_prefix = \"_\";\n\tacfg->inst_directive = \".word\";\n\tacfg->need_no_dead_strip = TRUE;\n\tacfg->aot_opts.gnu_asm = TRUE;\n#endif\n\n#if defined(__linux__) && !defined(TARGET_ARM)\n\tacfg->need_pt_gnu_stack = TRUE;\n#endif\n\n#ifdef MONOTOUCH\n\tacfg->global_symbols = TRUE;\n#endif\n\n#ifdef TARGET_ANDROID\n\tacfg->llvm_owriter_supported = FALSE;\n#endif\n}\n\n#ifdef TARGET_ARM64\n\n\n/* Load the contents of GOT_SLOT into dreg, clobbering ip0 */\nstatic void\narm64_emit_load_got_slot (MonoAotCompile *acfg, int dreg, int got_slot)\n{\n\tint offset;\n\n\tg_assert (acfg->fp);\n\temit_unset_mode (acfg);\n\t/* r16==ip0 */\n\toffset = (int)(got_slot * sizeof (gpointer));\n#ifdef TARGET_MACH\n\t/* clang's integrated assembler */\n\tfprintf (acfg->fp, \"adrp x16, %s@PAGE+%d\\n\", acfg->got_symbol, offset & 0xfffff000);\n\tfprintf (acfg->fp, \"add x16, x16, %s@PAGEOFF\\n\", acfg->got_symbol);\n\tfprintf (acfg->fp, \"ldr x%d, [x16, #%d]\\n\", dreg, offset & 0xfff);\n#else\n\t/* Linux GAS */\n\tfprintf (acfg->fp, \"adrp x16, %s+%d\\n\", acfg->got_symbol, offset & 0xfffff000);\n\tfprintf (acfg->fp, \"add x16, x16, :lo12:%s\\n\", acfg->got_symbol);\n\tfprintf (acfg->fp, \"ldr x%d, [x16, %d]\\n\", dreg, offset & 0xfff);\n#endif\n}\n\nstatic void\narm64_emit_objc_selector_ref (MonoAotCompile *acfg, guint8 *code, int index, int *code_size)\n{\n\tint reg;\n\n\tg_assert (acfg->fp);\n\temit_unset_mode (acfg);\n\n\t/* ldr rt, target */\n\treg = arm_get_ldr_lit_reg (code);\n\n\tfprintf (acfg->fp, \"adrp x%d, L_OBJC_SELECTOR_REFERENCES_%d@PAGE\\n\", reg, index);\n\tfprintf (acfg->fp, \"add x%d, x%d, L_OBJC_SELECTOR_REFERENCES_%d@PAGEOFF\\n\", reg, reg, index);\n\tfprintf (acfg->fp, \"ldr x%d, [x%d]\\n\", reg, reg);\n\n\t*code_size = 12;\n}\n\nstatic void\narm64_emit_direct_call (MonoAotCompile *acfg, const char *target, gboolean external, gboolean thumb, MonoJumpInfo *ji, int *call_size)\n{\n\tg_assert (acfg->fp);\n\temit_unset_mode (acfg);\n\tif (ji && ji->relocation == MONO_R_ARM64_B) {\n\t\tfprintf (acfg->fp, \"b %s\\n\", target);\n\t} else {\n\t\tif (ji)\n\t\t\tg_assert (ji->relocation == MONO_R_ARM64_BL);\n\t\tfprintf (acfg->fp, \"bl %s\\n\", target);\n\t}\n\t*call_size = 4;\n}\n\nstatic void\narm64_emit_got_access (MonoAotCompile *acfg, guint8 *code, int got_slot, int *code_size)\n{\n\tint reg;\n\n\t/* ldr rt, target */\n\treg = arm_get_ldr_lit_reg (code);\n\tarm64_emit_load_got_slot (acfg, reg, got_slot);\n\t*code_size = 12;\n}\n\nstatic void\narm64_emit_plt_entry (MonoAotCompile *acfg, const char *got_symbol, int offset, int info_offset)\n{\n\tarm64_emit_load_got_slot (acfg, ARMREG_R16, offset / sizeof (gpointer));\n\tfprintf (acfg->fp, \"br x16\\n\");\n\t/* Used by mono_aot_get_plt_info_offset () */\n\tfprintf (acfg->fp, \"%s %d\\n\", acfg->inst_directive, info_offset);\n}\n\nstatic void\narm64_emit_tramp_page_common_code (MonoAotCompile *acfg, int pagesize, int arg_reg, int *size)\n{\n\tguint8 buf [256];\n\tguint8 *code;\n\tint imm;\n\n\t/* The common code */\n\tcode = buf;\n\timm = pagesize;\n\t/* The trampoline address is in IP0 */\n\tarm_movzx (code, ARMREG_IP1, imm & 0xffff, 0);\n\tarm_movkx (code, ARMREG_IP1, (imm >> 16) & 0xffff, 16);\n\t/* Compute the data slot address */\n\tarm_subx (code, ARMREG_IP0, ARMREG_IP0, ARMREG_IP1);\n\t/* Trampoline argument */\n\tarm_ldrx (code, arg_reg, ARMREG_IP0, 0);\n\t/* Address */\n\tarm_ldrx (code, ARMREG_IP0, ARMREG_IP0, 8);\n\tarm_brx (code, ARMREG_IP0);\n\n\t/* Emit it */\n\temit_code_bytes (acfg, buf, code - buf);\n\n\t*size = code - buf;\n}\n\nstatic void\narm64_emit_tramp_page_specific_code (MonoAotCompile *acfg, int pagesize, int common_tramp_size, int specific_tramp_size)\n{\n\tguint8 buf [256];\n\tguint8 *code;\n\tint i, count;\n\n\tcount = (pagesize - common_tramp_size) / specific_tramp_size;\n\tfor (i = 0; i < count; ++i) {\n\t\tcode = buf;\n\t\tarm_adrx (code, ARMREG_IP0, code);\n\t\t/* Branch to the generic code */\n\t\tarm_b (code, code - 4 - (i * specific_tramp_size) - common_tramp_size);\n\t\t/* This has to be 2 pointers long */\n\t\tarm_nop (code);\n\t\tarm_nop (code);\n\t\tg_assert (code - buf == specific_tramp_size);\n\t\temit_code_bytes (acfg, buf, code - buf);\n\t}\n}\n\nstatic void\narm64_emit_specific_trampoline_pages (MonoAotCompile *acfg)\n{\n\tguint8 buf [128];\n\tguint8 *code;\n\tguint8 *labels [16];\n\tint common_tramp_size;\n\tint specific_tramp_size = 2 * 8;\n\tint imm, pagesize;\n\tchar symbol [128];\n\n\tif (!acfg->aot_opts.use_trampolines_page)\n\t\treturn;\n\n#ifdef TARGET_MACH\n\t/* Have to match the target pagesize */\n\tpagesize = 16384;\n#else\n\tpagesize = mono_pagesize ();\n#endif\n\tacfg->tramp_page_size = pagesize;\n\n\t/* The specific trampolines */\n\tsprintf (symbol, \"%sspecific_trampolines_page\", acfg->user_symbol_prefix);\n\temit_alignment (acfg, pagesize);\n\temit_global (acfg, symbol, TRUE);\n\temit_label (acfg, symbol);\n\n\t/* The common code */\n\tarm64_emit_tramp_page_common_code (acfg, pagesize, ARMREG_IP1, &common_tramp_size);\n\tacfg->tramp_page_code_offsets [MONO_AOT_TRAMP_SPECIFIC] = common_tramp_size;\n\n\tarm64_emit_tramp_page_specific_code (acfg, pagesize, common_tramp_size, specific_tramp_size);\n\n\t/* The rgctx trampolines */\n\t/* These are the same as the specific trampolines, but they load the argument into MONO_ARCH_RGCTX_REG */\n\tsprintf (symbol, \"%srgctx_trampolines_page\", acfg->user_symbol_prefix);\n\temit_alignment (acfg, pagesize);\n\temit_global (acfg, symbol, TRUE);\n\temit_label (acfg, symbol);\n\n\t/* The common code */\n\tarm64_emit_tramp_page_common_code (acfg, pagesize, MONO_ARCH_RGCTX_REG, &common_tramp_size);\n\tacfg->tramp_page_code_offsets [MONO_AOT_TRAMP_STATIC_RGCTX] = common_tramp_size;\n\n\tarm64_emit_tramp_page_specific_code (acfg, pagesize, common_tramp_size, specific_tramp_size);\n\n\t/* The gsharedvt arg trampolines */\n\t/* These are the same as the specific trampolines */\n\tsprintf (symbol, \"%sgsharedvt_arg_trampolines_page\", acfg->user_symbol_prefix);\n\temit_alignment (acfg, pagesize);\n\temit_global (acfg, symbol, TRUE);\n\temit_label (acfg, symbol);\n\n\tarm64_emit_tramp_page_common_code (acfg, pagesize, ARMREG_IP1, &common_tramp_size);\n\tacfg->tramp_page_code_offsets [MONO_AOT_TRAMP_GSHAREDVT_ARG] = common_tramp_size;\n\n\tarm64_emit_tramp_page_specific_code (acfg, pagesize, common_tramp_size, specific_tramp_size);\n\n\t/* The IMT trampolines */\n\tsprintf (symbol, \"%simt_trampolines_page\", acfg->user_symbol_prefix);\n\temit_alignment (acfg, pagesize);\n\temit_global (acfg, symbol, TRUE);\n\temit_label (acfg, symbol);\n\n\tcode = buf;\n\timm = pagesize;\n\t/* The trampoline address is in IP0 */\n\tarm_movzx (code, ARMREG_IP1, imm & 0xffff, 0);\n\tarm_movkx (code, ARMREG_IP1, (imm >> 16) & 0xffff, 16);\n\t/* Compute the data slot address */\n\tarm_subx (code, ARMREG_IP0, ARMREG_IP0, ARMREG_IP1);\n\t/* Trampoline argument */\n\tarm_ldrx (code, ARMREG_IP1, ARMREG_IP0, 0);\n\n\t/* Same as arch_emit_imt_trampoline () */\n\tlabels [0] = code;\n\tarm_ldrx (code, ARMREG_IP0, ARMREG_IP1, 0);\n\tarm_cmpx (code, ARMREG_IP0, MONO_ARCH_RGCTX_REG);\n\tlabels [1] = code;\n\tarm_bcc (code, ARMCOND_EQ, 0);\n\n\t/* End-of-loop check */\n\tlabels [2] = code;\n\tarm_cbzx (code, ARMREG_IP0, 0);\n\n\t/* Loop footer */\n\tarm_addx_imm (code, ARMREG_IP1, ARMREG_IP1, 2 * 8);\n\tarm_b (code, labels [0]);\n\n\t/* Match */\n\tmono_arm_patch (labels [1], code, MONO_R_ARM64_BCC);\n\t/* Load vtable slot addr */\n\tarm_ldrx (code, ARMREG_IP0, ARMREG_IP1, 8);\n\t/* Load vtable slot */\n\tarm_ldrx (code, ARMREG_IP0, ARMREG_IP0, 0);\n\tarm_brx (code, ARMREG_IP0);\n\n\t/* No match */\n\tmono_arm_patch (labels [2], code, MONO_R_ARM64_CBZ);\n\t/* Load fail addr */\n\tarm_ldrx (code, ARMREG_IP0, ARMREG_IP1, 8);\n\tarm_brx (code, ARMREG_IP0);\n\n\temit_code_bytes (acfg, buf, code - buf);\n\n\tcommon_tramp_size = code - buf;\n\tacfg->tramp_page_code_offsets [MONO_AOT_TRAMP_IMT] = common_tramp_size;\n\n\tarm64_emit_tramp_page_specific_code (acfg, pagesize, common_tramp_size, specific_tramp_size);\n}\n\nstatic void\narm64_emit_specific_trampoline (MonoAotCompile *acfg, int offset, int *tramp_size)\n{\n\t/* Load argument from second GOT slot */\n\tarm64_emit_load_got_slot (acfg, ARMREG_R17, offset + 1);\n\t/* Load generic trampoline address from first GOT slot */\n\tarm64_emit_load_got_slot (acfg, ARMREG_R16, offset);\n\tfprintf (acfg->fp, \"br x16\\n\");\n\t*tramp_size = 7 * 4;\n}\n\nstatic void\narm64_emit_unbox_trampoline (MonoAotCompile *acfg, MonoCompile *cfg, MonoMethod *method, const char *call_target)\n{\n\temit_unset_mode (acfg);\n\tfprintf (acfg->fp, \"add x0, x0, %d\\n\", (int)(sizeof (MonoObject)));\n\tfprintf (acfg->fp, \"b %s\\n\", call_target);\n}\n\nstatic void\narm64_emit_static_rgctx_trampoline (MonoAotCompile *acfg, int offset, int *tramp_size)\n{\n\t/* Similar to the specific trampolines, but use the rgctx reg instead of ip1 */\n\n\t/* Load argument from first GOT slot */\n\tarm64_emit_load_got_slot (acfg, MONO_ARCH_RGCTX_REG, offset);\n\t/* Load generic trampoline address from second GOT slot */\n\tarm64_emit_load_got_slot (acfg, ARMREG_R16, offset + 1);\n\tfprintf (acfg->fp, \"br x16\\n\");\n\t*tramp_size = 7 * 4;\n}\n\nstatic void\narm64_emit_imt_trampoline (MonoAotCompile *acfg, int offset, int *tramp_size)\n{\n\tguint8 buf [128];\n\tguint8 *code, *labels [16];\n\n\t/* Load parameter from GOT slot into ip1 */\n\tarm64_emit_load_got_slot (acfg, ARMREG_R17, offset);\n\n\tcode = buf;\n\tlabels [0] = code;\n\tarm_ldrx (code, ARMREG_IP0, ARMREG_IP1, 0);\n\tarm_cmpx (code, ARMREG_IP0, MONO_ARCH_RGCTX_REG);\n\tlabels [1] = code;\n\tarm_bcc (code, ARMCOND_EQ, 0);\n\n\t/* End-of-loop check */\n\tlabels [2] = code;\n\tarm_cbzx (code, ARMREG_IP0, 0);\n\n\t/* Loop footer */\n\tarm_addx_imm (code, ARMREG_IP1, ARMREG_IP1, 2 * 8);\n\tarm_b (code, labels [0]);\n\n\t/* Match */\n\tmono_arm_patch (labels [1], code, MONO_R_ARM64_BCC);\n\t/* Load vtable slot addr */\n\tarm_ldrx (code, ARMREG_IP0, ARMREG_IP1, 8);\n\t/* Load vtable slot */\n\tarm_ldrx (code, ARMREG_IP0, ARMREG_IP0, 0);\n\tarm_brx (code, ARMREG_IP0);\n\n\t/* No match */\n\tmono_arm_patch (labels [2], code, MONO_R_ARM64_CBZ);\n\t/* Load fail addr */\n\tarm_ldrx (code, ARMREG_IP0, ARMREG_IP1, 8);\n\tarm_brx (code, ARMREG_IP0);\n\n\temit_code_bytes (acfg, buf, code - buf);\n\n\t*tramp_size = code - buf + (3 * 4);\n}\n\nstatic void\narm64_emit_gsharedvt_arg_trampoline (MonoAotCompile *acfg, int offset, int *tramp_size)\n{\n\t/* Similar to the specific trampolines, but the address is in the second slot */\n\t/* Load argument from first GOT slot */\n\tarm64_emit_load_got_slot (acfg, ARMREG_R17, offset);\n\t/* Load generic trampoline address from second GOT slot */\n\tarm64_emit_load_got_slot (acfg, ARMREG_R16, offset + 1);\n\tfprintf (acfg->fp, \"br x16\\n\");\n\t*tramp_size = 7 * 4;\n}\n\n\n#endif\n\n#ifdef MONO_ARCH_AOT_SUPPORTED\n/*\n * arch_emit_direct_call:\n *\n *   Emit a direct call to the symbol TARGET. CALL_SIZE is set to the size of the\n * calling code.\n */\nstatic void\narch_emit_direct_call (MonoAotCompile *acfg, const char *target, gboolean external, gboolean thumb, MonoJumpInfo *ji, int *call_size)\n{\n#if defined(TARGET_X86) || defined(TARGET_AMD64)\n\t/* Need to make sure this is exactly 5 bytes long */\n\temit_unset_mode (acfg);\n\tfprintf (acfg->fp, \"call %s\\n\", target);\n\t*call_size = 5;\n#elif defined(TARGET_ARM)\n\temit_unset_mode (acfg);\n\tif (thumb)\n\t\tfprintf (acfg->fp, \"blx %s\\n\", target);\n\telse\n\t\tfprintf (acfg->fp, \"bl %s\\n\", target);\n\t*call_size = 4;\n#elif defined(TARGET_ARM64)\n\tarm64_emit_direct_call (acfg, target, external, thumb, ji, call_size);\n#elif defined(TARGET_POWERPC)\n\temit_unset_mode (acfg);\n\tfprintf (acfg->fp, \"bl %s\\n\", target);\n\t*call_size = 4;\n#else\n\tg_assert_not_reached ();\n#endif\n}\n#endif\n\n/*\n * PPC32 design:\n * - we use an approach similar to the x86 abi: reserve a register (r30) to hold \n *   the GOT pointer.\n * - The full-aot trampolines need access to the GOT of mscorlib, so we store\n *   in in the 2. slot of every GOT, and require every method to place the GOT\n *   address in r30, even when it doesn't access the GOT otherwise. This way,\n *   the trampolines can compute the mscorlib GOT address by loading 4(r30).\n */\n\n/*\n * PPC64 design:\n * PPC64 uses function descriptors which greatly complicate all code, since\n * these are used very inconsistently in the runtime. Some functions like \n * mono_compile_method () return ftn descriptors, while others like the\n * trampoline creation functions do not.\n * We assume that all GOT slots contain function descriptors, and create \n * descriptors in aot-runtime.c when needed.\n * The ppc64 abi uses r2 to hold the address of the TOC/GOT, which is loaded\n * from function descriptors, we could do the same, but it would require \n * rewriting all the ppc/aot code to handle function descriptors properly.\n * So instead, we use the same approach as on PPC32.\n * This is a horrible mess, but fixing it would probably lead to an even bigger\n * one.\n */\n\n/*\n * X86 design:\n * - similar to the PPC32 design, we reserve EBX to hold the GOT pointer.\n */\n\n#ifdef MONO_ARCH_AOT_SUPPORTED\n/*\n * arch_emit_got_offset:\n *\n *   The memory pointed to by CODE should hold native code for computing the GOT\n * address (OP_LOAD_GOTADDR). Emit this code while patching it with the offset\n * between code and the GOT. CODE_SIZE is set to the number of bytes emitted.\n */\nstatic void\narch_emit_got_offset (MonoAotCompile *acfg, guint8 *code, int *code_size)\n{\n#if defined(TARGET_POWERPC64)\n\temit_unset_mode (acfg);\n\t/* \n\t * The ppc32 code doesn't seem to work on ppc64, the assembler complains about\n\t * unsupported relocations. So we store the got address into the .Lgot_addr\n\t * symbol which is in the text segment, compute its address, and load it.\n\t */\n\tfprintf (acfg->fp, \".L%d:\\n\", acfg->label_generator);\n\tfprintf (acfg->fp, \"lis 0, (.Lgot_addr + 4 - .L%d)@h\\n\", acfg->label_generator);\n\tfprintf (acfg->fp, \"ori 0, 0, (.Lgot_addr + 4 - .L%d)@l\\n\", acfg->label_generator);\n\tfprintf (acfg->fp, \"add 30, 30, 0\\n\");\n\tfprintf (acfg->fp, \"%s 30, 0(30)\\n\", PPC_LD_OP);\n\tacfg->label_generator ++;\n\t*code_size = 16;\n#elif defined(TARGET_POWERPC)\n\temit_unset_mode (acfg);\n\tfprintf (acfg->fp, \".L%d:\\n\", acfg->label_generator);\n\tfprintf (acfg->fp, \"lis 0, (%s + 4 - .L%d)@h\\n\", acfg->got_symbol, acfg->label_generator);\n\tfprintf (acfg->fp, \"ori 0, 0, (%s + 4 - .L%d)@l\\n\", acfg->got_symbol, acfg->label_generator);\n\tacfg->label_generator ++;\n\t*code_size = 8;\n#else\n\tguint32 offset = mono_arch_get_patch_offset (code);\n\temit_bytes (acfg, code, offset);\n\temit_symbol_diff (acfg, acfg->got_symbol, \".\", offset);\n\n\t*code_size = offset + 4;\n#endif\n}\n\n/*\n * arch_emit_got_access:\n *\n *   The memory pointed to by CODE should hold native code for loading a GOT\n * slot (OP_AOTCONST/OP_GOT_ENTRY). Emit this code while patching it so it accesses the\n * GOT slot GOT_SLOT. CODE_SIZE is set to the number of bytes emitted.\n */\nstatic void\narch_emit_got_access (MonoAotCompile *acfg, const char *got_symbol, guint8 *code, int got_slot, int *code_size)\n{\n#ifdef TARGET_AMD64\n\t/* mov reg, got+offset(%rip) */\n\tif (acfg->llvm) {\n\t\t/* The GOT symbol is in the LLVM module, the clang assembler has problems emitting symbol diffs for it */\n\t\tint dreg;\n\t\tint rex_r;\n\n\t\t/* Decode reg, see amd64_mov_reg_membase () */\n\t\trex_r = code [0] & AMD64_REX_R;\n\t\tg_assert (code [0] == 0x49 + rex_r);\n\t\tg_assert (code [1] == 0x8b);\n\t\tdreg = ((code [2] >> 3) & 0x7) + (rex_r ? 8 : 0);\n\n\t\temit_unset_mode (acfg);\n\t\tfprintf (acfg->fp, \"mov %s+%d(%%rip), %s\\n\", got_symbol, (unsigned int) ((got_slot * sizeof (gpointer))), mono_arch_regname (dreg));\n\t\t*code_size = 7;\n\t} else {\n\t\temit_bytes (acfg, code, mono_arch_get_patch_offset (code));\n\t\temit_symbol_diff (acfg, got_symbol, \".\", (unsigned int) ((got_slot * sizeof (gpointer)) - 4));\n\t\t*code_size = mono_arch_get_patch_offset (code) + 4;\n\t}\n#elif defined(TARGET_X86)\n\temit_bytes (acfg, code, mono_arch_get_patch_offset (code));\n\temit_int32 (acfg, (unsigned int) ((got_slot * sizeof (gpointer))));\n\t*code_size = mono_arch_get_patch_offset (code) + 4;\n#elif defined(TARGET_ARM)\n\temit_bytes (acfg, code, mono_arch_get_patch_offset (code));\n\temit_symbol_diff (acfg, got_symbol, \".\", (unsigned int) ((got_slot * sizeof (gpointer))) - 12);\n\t*code_size = mono_arch_get_patch_offset (code) + 4;\n#elif defined(TARGET_ARM64)\n\temit_bytes (acfg, code, mono_arch_get_patch_offset (code));\n\tarm64_emit_got_access (acfg, code, got_slot, code_size);\n#elif defined(TARGET_POWERPC)\n\t{\n\t\tguint8 buf [32];\n\n\t\temit_bytes (acfg, code, mono_arch_get_patch_offset (code));\n\t\tcode = buf;\n\t\tppc_load32 (code, ppc_r0, got_slot * sizeof (gpointer));\n\t\tg_assert (code - buf == 8);\n\t\temit_bytes (acfg, buf, code - buf);\n\t\t*code_size = code - buf;\n\t}\n#else\n\tg_assert_not_reached ();\n#endif\n}\n\n#endif\n\n#ifdef MONO_ARCH_AOT_SUPPORTED\n/*\n * arch_emit_objc_selector_ref:\n *\n *   Emit the implementation of OP_OBJC_GET_SELECTOR, which itself implements @selector(foo:) in objective-c.\n */\nstatic void\narch_emit_objc_selector_ref (MonoAotCompile *acfg, guint8 *code, int index, int *code_size)\n{\n#if defined(TARGET_ARM)\n\tchar symbol1 [MAX_SYMBOL_SIZE];\n\tchar symbol2 [MAX_SYMBOL_SIZE];\n\tint lindex = acfg->objc_selector_index_2 ++;\n\n\t/* Emit ldr.imm/b */\n\temit_bytes (acfg, code, 8);\n\n\tsprintf (symbol1, \"L_OBJC_SELECTOR_%d\", lindex);\n\tsprintf (symbol2, \"L_OBJC_SELECTOR_REFERENCES_%d\", index);\n\n\temit_label (acfg, symbol1);\n\tmono_img_writer_emit_unset_mode (acfg->w);\n\tfprintf (acfg->fp, \".long %s-(%s+12)\", symbol2, symbol1);\n\n\t*code_size = 12;\n#elif defined(TARGET_ARM64)\n\tarm64_emit_objc_selector_ref (acfg, code, index, code_size);\n#else\n\tg_assert_not_reached ();\n#endif\n}\n#endif\n\n/*\n * arch_emit_plt_entry:\n *\n *   Emit code for the PLT entry.\n * The plt entry should look like this:\n * <indirect jump to GOT_SYMBOL + OFFSET>\n * <INFO_OFFSET embedded into the instruction stream>\n */\nstatic void\narch_emit_plt_entry (MonoAotCompile *acfg, const char *got_symbol, int offset, int info_offset)\n{\n#if defined(TARGET_X86)\n\t\t/* jmp *<offset>(%ebx) */\n\t\temit_byte (acfg, 0xff);\n\t\temit_byte (acfg, 0xa3);\n\t\temit_int32 (acfg, offset);\n\t\t/* Used by mono_aot_get_plt_info_offset */\n\t\temit_int32 (acfg, info_offset);\n#elif defined(TARGET_AMD64)\n\t\temit_unset_mode (acfg);\n\t\tfprintf (acfg->fp, \"jmp *%s+%d(%%rip)\\n\", got_symbol, offset);\n\t\t/* Used by mono_aot_get_plt_info_offset */\n\t\temit_int32 (acfg, info_offset);\n\t\tacfg->stats.plt_size += 10;\n#elif defined(TARGET_ARM)\n\t\tguint8 buf [256];\n\t\tguint8 *code;\n\n\t\tcode = buf;\n\t\tARM_LDR_IMM (code, ARMREG_IP, ARMREG_PC, 0);\n\t\tARM_LDR_REG_REG (code, ARMREG_PC, ARMREG_PC, ARMREG_IP);\n\t\temit_bytes (acfg, buf, code - buf);\n\t\temit_symbol_diff (acfg, got_symbol, \".\", offset - 4);\n\t\t/* Used by mono_aot_get_plt_info_offset */\n\t\temit_int32 (acfg, info_offset);\n#elif defined(TARGET_ARM64)\n\t\tarm64_emit_plt_entry (acfg, got_symbol, offset, info_offset);\n#elif defined(TARGET_POWERPC)\n\t\t/* The GOT address is guaranteed to be in r30 by OP_LOAD_GOTADDR */\n\t\temit_unset_mode (acfg);\n\t\tfprintf (acfg->fp, \"lis 11, %d@h\\n\", offset);\n\t\tfprintf (acfg->fp, \"ori 11, 11, %d@l\\n\", offset);\n\t\tfprintf (acfg->fp, \"add 11, 11, 30\\n\");\n\t\tfprintf (acfg->fp, \"%s 11, 0(11)\\n\", PPC_LD_OP);\n#ifdef PPC_USES_FUNCTION_DESCRIPTOR\n\t\tfprintf (acfg->fp, \"%s 2, %d(11)\\n\", PPC_LD_OP, (int)sizeof (gpointer));\n\t\tfprintf (acfg->fp, \"%s 11, 0(11)\\n\", PPC_LD_OP);\n#endif\n\t\tfprintf (acfg->fp, \"mtctr 11\\n\");\n\t\tfprintf (acfg->fp, \"bctr\\n\");\n\t\temit_int32 (acfg, info_offset);\n#else\n\t\tg_assert_not_reached ();\n#endif\n}\n\n/*\n * arch_emit_llvm_plt_entry:\n *\n *   Same as arch_emit_plt_entry, but handles calls from LLVM generated code.\n * This is only needed on arm to handle thumb interop.\n */\nstatic void\narch_emit_llvm_plt_entry (MonoAotCompile *acfg, const char *got_symbol, int offset, int info_offset)\n{\n#if defined(TARGET_ARM)\n\t/* LLVM calls the PLT entries using bl, so these have to be thumb2 */\n\t/* The caller already transitioned to thumb */\n\t/* The code below should be 12 bytes long */\n\t/* clang has trouble encoding these instructions, so emit the binary */\n#if 0\n\tfprintf (acfg->fp, \"ldr ip, [pc, #8]\\n\");\n\t/* thumb can't encode ld pc, [pc, ip] */\n\tfprintf (acfg->fp, \"add ip, pc, ip\\n\");\n\tfprintf (acfg->fp, \"ldr ip, [ip, #0]\\n\");\n\tfprintf (acfg->fp, \"bx ip\\n\");\n#endif\n\temit_set_thumb_mode (acfg);\n\tfprintf (acfg->fp, \".4byte 0xc008f8df\\n\");\n\tfprintf (acfg->fp, \".2byte 0x44fc\\n\");\n\tfprintf (acfg->fp, \".4byte 0xc000f8dc\\n\");\n\tfprintf (acfg->fp, \".2byte 0x4760\\n\");\n\temit_symbol_diff (acfg, got_symbol, \".\", offset + 4);\n\temit_int32 (acfg, info_offset);\n\temit_unset_mode (acfg);\n\temit_set_arm_mode (acfg);\n#else\n\tg_assert_not_reached ();\n#endif\n}\n\n/* Save unwind_info in the module and emit the offset to the information at symbol */\nstatic void save_unwind_info (MonoAotCompile *acfg, char *symbol, GSList *unwind_ops)\n{\n\tguint32 uw_offset, encoded_len;\n\tguint8 *encoded;\n\n\temit_section_change (acfg, RODATA_SECT, 0);\n\temit_global (acfg, symbol, FALSE);\n\temit_label (acfg, symbol);\n\n\tencoded = mono_unwind_ops_encode (unwind_ops, &encoded_len);\n\tuw_offset = get_unwind_info_offset (acfg, encoded, encoded_len);\n\tg_free (encoded);\n\temit_int32 (acfg, uw_offset);\n}\n\n/*\n * arch_emit_specific_trampoline_pages:\n *\n * Emits a page full of trampolines: each trampoline uses its own address to\n * lookup both the generic trampoline code and the data argument.\n * This page can be remapped in process multiple times so we can get an\n * unlimited number of trampolines.\n * Specifically this implementation uses the following trick: two memory pages\n * are allocated, with the first containing the data and the second containing the trampolines.\n * To reduce trampoline size, each trampoline jumps at the start of the page where a common\n * implementation does all the lifting.\n * Note that the ARM single trampoline size is 8 bytes, exactly like the data that needs to be stored\n * on the arm 32 bit system.\n */\nstatic void\narch_emit_specific_trampoline_pages (MonoAotCompile *acfg)\n{\n#if defined(TARGET_ARM)\n\tguint8 buf [128];\n\tguint8 *code;\n\tguint8 *loop_start, *loop_branch_back, *loop_end_check, *imt_found_check;\n\tint i;\n\tint pagesize = MONO_AOT_TRAMP_PAGE_SIZE;\n\tGSList *unwind_ops = NULL;\n#define COMMON_TRAMP_SIZE 16\n\tint count = (pagesize - COMMON_TRAMP_SIZE) / 8;\n\tint imm8, rot_amount;\n\tchar symbol [128];\n\n\tif (!acfg->aot_opts.use_trampolines_page)\n\t\treturn;\n\n\tacfg->tramp_page_size = pagesize;\n\n\tsprintf (symbol, \"%sspecific_trampolines_page\", acfg->user_symbol_prefix);\n\temit_alignment (acfg, pagesize);\n\temit_global (acfg, symbol, TRUE);\n\temit_label (acfg, symbol);\n\n\t/* emit the generic code first, the trampoline address + 8 is in the lr register */\n\tcode = buf;\n\timm8 = mono_arm_is_rotated_imm8 (pagesize, &rot_amount);\n\tARM_SUB_REG_IMM (code, ARMREG_LR, ARMREG_LR, imm8, rot_amount);\n\tARM_LDR_IMM (code, ARMREG_R1, ARMREG_LR, -8);\n\tARM_LDR_IMM (code, ARMREG_PC, ARMREG_LR, -4);\n\tARM_NOP (code);\n\tg_assert (code - buf == COMMON_TRAMP_SIZE);\n\n\t/* Emit it */\n\temit_bytes (acfg, buf, code - buf);\n\n\tfor (i = 0; i < count; ++i) {\n\t\tcode = buf;\n\t\tARM_PUSH (code, 0x5fff);\n\t\tARM_BL (code, 0);\n\t\tarm_patch (code - 4, code - COMMON_TRAMP_SIZE - 8 * (i + 1));\n\t\tg_assert (code - buf == 8);\n\t\temit_bytes (acfg, buf, code - buf);\n\t}\n\n\t/* now the rgctx trampolines: each specific trampolines puts in the ip register\n\t * the instruction pointer address, so the generic trampoline at the start of the page\n\t * subtracts 4096 to get to the data page and loads the values\n\t * We again fit the generic trampiline in 16 bytes.\n\t */\n\tsprintf (symbol, \"%srgctx_trampolines_page\", acfg->user_symbol_prefix);\n\temit_global (acfg, symbol, TRUE);\n\temit_label (acfg, symbol);\n\tcode = buf;\n\timm8 = mono_arm_is_rotated_imm8 (pagesize, &rot_amount);\n\tARM_SUB_REG_IMM (code, ARMREG_IP, ARMREG_IP, imm8, rot_amount);\n\tARM_LDR_IMM (code, MONO_ARCH_RGCTX_REG, ARMREG_IP, -8);\n\tARM_LDR_IMM (code, ARMREG_PC, ARMREG_IP, -4);\n\tARM_NOP (code);\n\tg_assert (code - buf == COMMON_TRAMP_SIZE);\n\n\t/* Emit it */\n\temit_bytes (acfg, buf, code - buf);\n\n\tfor (i = 0; i < count; ++i) {\n\t\tcode = buf;\n\t\tARM_MOV_REG_REG (code, ARMREG_IP, ARMREG_PC);\n\t\tARM_B (code, 0);\n\t\tarm_patch (code - 4, code - COMMON_TRAMP_SIZE - 8 * (i + 1));\n\t\tg_assert (code - buf == 8);\n\t\temit_bytes (acfg, buf, code - buf);\n\t}\n\n\t/*\n\t * gsharedvt arg trampolines: see arch_emit_gsharedvt_arg_trampoline ()\n\t */\n\tsprintf (symbol, \"%sgsharedvt_arg_trampolines_page\", acfg->user_symbol_prefix);\n\temit_global (acfg, symbol, TRUE);\n\temit_label (acfg, symbol);\n\tcode = buf;\n\tARM_PUSH (code, (1 << ARMREG_R0) | (1 << ARMREG_R1) | (1 << ARMREG_R2) | (1 << ARMREG_R3));\n\timm8 = mono_arm_is_rotated_imm8 (pagesize, &rot_amount);\n\tARM_SUB_REG_IMM (code, ARMREG_IP, ARMREG_IP, imm8, rot_amount);\n\tARM_LDR_IMM (code, ARMREG_R0, ARMREG_IP, -8);\n\tARM_LDR_IMM (code, ARMREG_PC, ARMREG_IP, -4);\n\tg_assert (code - buf == COMMON_TRAMP_SIZE);\n\t/* Emit it */\n\temit_bytes (acfg, buf, code - buf);\n\n\tfor (i = 0; i < count; ++i) {\n\t\tcode = buf;\n\t\tARM_MOV_REG_REG (code, ARMREG_IP, ARMREG_PC);\n\t\tARM_B (code, 0);\n\t\tarm_patch (code - 4, code - COMMON_TRAMP_SIZE - 8 * (i + 1));\n\t\tg_assert (code - buf == 8);\n\t\temit_bytes (acfg, buf, code - buf);\n\t}\n\n\t/* now the imt trampolines: each specific trampolines puts in the ip register\n\t * the instruction pointer address, so the generic trampoline at the start of the page\n\t * subtracts 4096 to get to the data page and loads the values\n\t */\n#define IMT_TRAMP_SIZE 72\n\tsprintf (symbol, \"%simt_trampolines_page\", acfg->user_symbol_prefix);\n\temit_global (acfg, symbol, TRUE);\n\temit_label (acfg, symbol);\n\tcode = buf;\n\t/* Need at least two free registers, plus a slot for storing the pc */\n\tARM_PUSH (code, (1 << ARMREG_R0)|(1 << ARMREG_R1)|(1 << ARMREG_R2));\n\n\timm8 = mono_arm_is_rotated_imm8 (pagesize, &rot_amount);\n\tARM_SUB_REG_IMM (code, ARMREG_IP, ARMREG_IP, imm8, rot_amount);\n\tARM_LDR_IMM (code, ARMREG_R0, ARMREG_IP, -8);\n\n\t/* The IMT method is in v5, r0 has the imt array address */\n\n\tloop_start = code;\n\tARM_LDR_IMM (code, ARMREG_R1, ARMREG_R0, 0);\n\tARM_CMP_REG_REG (code, ARMREG_R1, ARMREG_V5);\n\timt_found_check = code;\n\tARM_B_COND (code, ARMCOND_EQ, 0);\n\n\t/* End-of-loop check */\n\tARM_CMP_REG_IMM (code, ARMREG_R1, 0, 0);\n\tloop_end_check = code;\n\tARM_B_COND (code, ARMCOND_EQ, 0);\n\n\t/* Loop footer */\n\tARM_ADD_REG_IMM8 (code, ARMREG_R0, ARMREG_R0, sizeof (gpointer) * 2);\n\tloop_branch_back = code;\n\tARM_B (code, 0);\n\tarm_patch (loop_branch_back, loop_start);\n\n\t/* Match */\n\tarm_patch (imt_found_check, code);\n\tARM_LDR_IMM (code, ARMREG_R0, ARMREG_R0, 4);\n\tARM_LDR_IMM (code, ARMREG_R0, ARMREG_R0, 0);\n\t/* Save it to the third stack slot */\n\tARM_STR_IMM (code, ARMREG_R0, ARMREG_SP, 8);\n\t/* Restore the registers and branch */\n\tARM_POP (code, (1 << ARMREG_R0)|(1 << ARMREG_R1)|(1 << ARMREG_PC));\n\n\t/* No match */\n\tarm_patch (loop_end_check, code);\n\tARM_LDR_IMM (code, ARMREG_R0, ARMREG_R0, 4);\n\tARM_STR_IMM (code, ARMREG_R0, ARMREG_SP, 8);\n\tARM_POP (code, (1 << ARMREG_R0)|(1 << ARMREG_R1)|(1 << ARMREG_PC));\n\tARM_NOP (code);\n\n\t/* Emit it */\n\tg_assert (code - buf == IMT_TRAMP_SIZE);\n\temit_bytes (acfg, buf, code - buf);\n\n\tfor (i = 0; i < count; ++i) {\n\t\tcode = buf;\n\t\tARM_MOV_REG_REG (code, ARMREG_IP, ARMREG_PC);\n\t\tARM_B (code, 0);\n\t\tarm_patch (code - 4, code - IMT_TRAMP_SIZE - 8 * (i + 1));\n\t\tg_assert (code - buf == 8);\n\t\temit_bytes (acfg, buf, code - buf);\n\t}\n\n\tacfg->tramp_page_code_offsets [MONO_AOT_TRAMP_SPECIFIC] = 16;\n\tacfg->tramp_page_code_offsets [MONO_AOT_TRAMP_STATIC_RGCTX] = 16;\n\tacfg->tramp_page_code_offsets [MONO_AOT_TRAMP_IMT] = 72;\n\tacfg->tramp_page_code_offsets [MONO_AOT_TRAMP_GSHAREDVT_ARG] = 16;\n\n\t/* Unwind info for specifc trampolines */\n\tsprintf (symbol, \"%sspecific_trampolines_page_gen_p\", acfg->user_symbol_prefix);\n\t/* We unwind to the original caller, from the stack, since lr is clobbered */\n\tmono_add_unwind_op_def_cfa (unwind_ops, 0, 0, ARMREG_SP, 14 * sizeof (mgreg_t));\n\tmono_add_unwind_op_offset (unwind_ops, 0, 0, ARMREG_LR, -4);\n\tsave_unwind_info (acfg, symbol, unwind_ops);\n\tmono_free_unwind_info (unwind_ops);\n\n\tsprintf (symbol, \"%sspecific_trampolines_page_sp_p\", acfg->user_symbol_prefix);\n\tmono_add_unwind_op_def_cfa (unwind_ops, 0, 0, ARMREG_SP, 0);\n\tmono_add_unwind_op_def_cfa_offset (unwind_ops, 4, 0, 14 * sizeof (mgreg_t));\n\tsave_unwind_info (acfg, symbol, unwind_ops);\n\tmono_free_unwind_info (unwind_ops);\n\n\t/* Unwind info for rgctx trampolines */\n\tsprintf (symbol, \"%srgctx_trampolines_page_gen_p\", acfg->user_symbol_prefix);\n\tmono_add_unwind_op_def_cfa (unwind_ops, 0, 0, ARMREG_SP, 0);\n\tsave_unwind_info (acfg, symbol, unwind_ops);\n\n\tsprintf (symbol, \"%srgctx_trampolines_page_sp_p\", acfg->user_symbol_prefix);\n\tsave_unwind_info (acfg, symbol, unwind_ops);\n\tmono_free_unwind_info (unwind_ops);\n\n\t/* Unwind info for gsharedvt trampolines */\n\tsprintf (symbol, \"%sgsharedvt_trampolines_page_gen_p\", acfg->user_symbol_prefix);\n\tmono_add_unwind_op_def_cfa (unwind_ops, 0, 0, ARMREG_SP, 0);\n\tmono_add_unwind_op_def_cfa_offset (unwind_ops, 4, 0, 4 * sizeof (mgreg_t));\n\tsave_unwind_info (acfg, symbol, unwind_ops);\n\tmono_free_unwind_info (unwind_ops);\n\n\tsprintf (symbol, \"%sgsharedvt_trampolines_page_sp_p\", acfg->user_symbol_prefix);\n\tmono_add_unwind_op_def_cfa (unwind_ops, 0, 0, ARMREG_SP, 0);\n\tsave_unwind_info (acfg, symbol, unwind_ops);\n\tmono_free_unwind_info (unwind_ops);\n\n\t/* Unwind info for imt trampolines */\n\tsprintf (symbol, \"%simt_trampolines_page_gen_p\", acfg->user_symbol_prefix);\n\tmono_add_unwind_op_def_cfa (unwind_ops, 0, 0, ARMREG_SP, 0);\n\tmono_add_unwind_op_def_cfa_offset (unwind_ops, 4, 0, 3 * sizeof (mgreg_t));\n\tsave_unwind_info (acfg, symbol, unwind_ops);\n\tmono_free_unwind_info (unwind_ops);\n\n\tsprintf (symbol, \"%simt_trampolines_page_sp_p\", acfg->user_symbol_prefix);\n\tmono_add_unwind_op_def_cfa (unwind_ops, 0, 0, ARMREG_SP, 0);\n\tsave_unwind_info (acfg, symbol, unwind_ops);\n\tmono_free_unwind_info (unwind_ops);\n#elif defined(TARGET_ARM64)\n\tarm64_emit_specific_trampoline_pages (acfg);\n#endif\n}\n\n/*\n * arch_emit_specific_trampoline:\n *\n *   Emit code for a specific trampoline. OFFSET is the offset of the first of\n * two GOT slots which contain the generic trampoline address and the trampoline\n * argument. TRAMP_SIZE is set to the size of the emitted trampoline.\n */\nstatic void\narch_emit_specific_trampoline (MonoAotCompile *acfg, int offset, int *tramp_size)\n{\n\t/*\n\t * The trampolines created here are variations of the specific \n\t * trampolines created in mono_arch_create_specific_trampoline (). The \n\t * differences are:\n\t * - the generic trampoline address is taken from a got slot.\n\t * - the offset of the got slot where the trampoline argument is stored\n\t *   is embedded in the instruction stream, and the generic trampoline\n\t *   can load the argument by loading the offset, adding it to the\n\t *   address of the trampoline to get the address of the got slot, and\n\t *   loading the argument from there.\n\t * - all the trampolines should be of the same length.\n\t */\n#if defined(TARGET_AMD64)\n\t/* This should be exactly 8 bytes long */\n\t*tramp_size = 8;\n\t/* call *<offset>(%rip) */\n\tif (acfg->llvm) {\n\t\temit_unset_mode (acfg);\n\t\tfprintf (acfg->fp, \"call *%s+%d(%%rip)\\n\", acfg->got_symbol, (int)(offset * sizeof (gpointer)));\n\t\temit_zero_bytes (acfg, 2);\n\t} else {\n\t\temit_byte (acfg, '\\x41');\n\t\temit_byte (acfg, '\\xff');\n\t\temit_byte (acfg, '\\x15');\n\t\temit_symbol_diff (acfg, acfg->got_symbol, \".\", (offset * sizeof (gpointer)) - 4);\n\t\temit_zero_bytes (acfg, 1);\n\t}\n#elif defined(TARGET_ARM)\n\tguint8 buf [128];\n\tguint8 *code;\n\n\t/* This should be exactly 20 bytes long */\n\t*tramp_size = 20;\n\tcode = buf;\n\tARM_PUSH (code, 0x5fff);\n\tARM_LDR_IMM (code, ARMREG_R1, ARMREG_PC, 4);\n\t/* Load the value from the GOT */\n\tARM_LDR_REG_REG (code, ARMREG_R1, ARMREG_PC, ARMREG_R1);\n\t/* Branch to it */\n\tARM_BLX_REG (code, ARMREG_R1);\n\n\tg_assert (code - buf == 16);\n\n\t/* Emit it */\n\temit_bytes (acfg, buf, code - buf);\n\t/* \n\t * Only one offset is needed, since the second one would be equal to the\n\t * first one.\n\t */\n\temit_symbol_diff (acfg, acfg->got_symbol, \".\", (offset * sizeof (gpointer)) - 4 + 4);\n\t//emit_symbol_diff (acfg, acfg->got_symbol, \".\", ((offset + 1) * sizeof (gpointer)) - 4 + 8);\n#elif defined(TARGET_ARM64)\n\tarm64_emit_specific_trampoline (acfg, offset, tramp_size);\n#elif defined(TARGET_POWERPC)\n\tguint8 buf [128];\n\tguint8 *code;\n\n\t*tramp_size = 4;\n\tcode = buf;\n\n\t/*\n\t * PPC has no ip relative addressing, so we need to compute the address\n\t * of the mscorlib got. That is slow and complex, so instead, we store it\n\t * in the second got slot of every aot image. The caller already computed\n\t * the address of its got and placed it into r30.\n\t */\n\temit_unset_mode (acfg);\n\t/* Load mscorlib got address */\n\tfprintf (acfg->fp, \"%s 0, %d(30)\\n\", PPC_LD_OP, (int)sizeof (gpointer));\n\t/* Load generic trampoline address */\n\tfprintf (acfg->fp, \"lis 11, %d@h\\n\", (int)(offset * sizeof (gpointer)));\n\tfprintf (acfg->fp, \"ori 11, 11, %d@l\\n\", (int)(offset * sizeof (gpointer)));\n\tfprintf (acfg->fp, \"%s 11, 11, 0\\n\", PPC_LDX_OP);\n#ifdef PPC_USES_FUNCTION_DESCRIPTOR\n\tfprintf (acfg->fp, \"%s 11, 0(11)\\n\", PPC_LD_OP);\n#endif\n\tfprintf (acfg->fp, \"mtctr 11\\n\");\n\t/* Load trampoline argument */\n\t/* On ppc, we pass it normally to the generic trampoline */\n\tfprintf (acfg->fp, \"lis 11, %d@h\\n\", (int)((offset + 1) * sizeof (gpointer)));\n\tfprintf (acfg->fp, \"ori 11, 11, %d@l\\n\", (int)((offset + 1) * sizeof (gpointer)));\n\tfprintf (acfg->fp, \"%s 0, 11, 0\\n\", PPC_LDX_OP);\n\t/* Branch to generic trampoline */\n\tfprintf (acfg->fp, \"bctr\\n\");\n\n#ifdef PPC_USES_FUNCTION_DESCRIPTOR\n\t*tramp_size = 10 * 4;\n#else\n\t*tramp_size = 9 * 4;\n#endif\n#elif defined(TARGET_X86)\n\tguint8 buf [128];\n\tguint8 *code;\n\n\t/* Similar to the PPC code above */\n\n\t/* FIXME: Could this clobber the register needed by get_vcall_slot () ? */\n\n\tcode = buf;\n\t/* Load mscorlib got address */\n\tx86_mov_reg_membase (code, X86_ECX, MONO_ARCH_GOT_REG, sizeof (gpointer), 4);\n\t/* Push trampoline argument */\n\tx86_push_membase (code, X86_ECX, (offset + 1) * sizeof (gpointer));\n\t/* Load generic trampoline address */\n\tx86_mov_reg_membase (code, X86_ECX, X86_ECX, offset * sizeof (gpointer), 4);\n\t/* Branch to generic trampoline */\n\tx86_jump_reg (code, X86_ECX);\n\n\temit_bytes (acfg, buf, code - buf);\n\n\t*tramp_size = 17;\n\tg_assert (code - buf == *tramp_size);\n#else\n\tg_assert_not_reached ();\n#endif\n}\n\n/*\n * arch_emit_unbox_trampoline:\n *\n *   Emit code for the unbox trampoline for METHOD used in the full-aot case.\n * CALL_TARGET is the symbol pointing to the native code of METHOD.\n */\nstatic void\narch_emit_unbox_trampoline (MonoAotCompile *acfg, MonoCompile *cfg, MonoMethod *method, const char *call_target)\n{\n#if defined(TARGET_AMD64)\n\tguint8 buf [32];\n\tguint8 *code;\n\tint this_reg;\n\n\tthis_reg = mono_arch_get_this_arg_reg (NULL);\n\tcode = buf;\n\tamd64_alu_reg_imm (code, X86_ADD, this_reg, sizeof (MonoObject));\n\n\temit_bytes (acfg, buf, code - buf);\n\t/* jump <method> */\n\tif (acfg->llvm) {\n\t\temit_unset_mode (acfg);\n\t\tfprintf (acfg->fp, \"jmp %s\\n\", call_target);\n\t} else {\n\t\temit_byte (acfg, '\\xe9');\n\t\temit_symbol_diff (acfg, call_target, \".\", -4);\n\t}\n#elif defined(TARGET_X86)\n\tguint8 buf [32];\n\tguint8 *code;\n\tint this_pos = 4;\n\n\tcode = buf;\n\n\tx86_alu_membase_imm (code, X86_ADD, X86_ESP, this_pos, sizeof (MonoObject));\n\n\temit_bytes (acfg, buf, code - buf);\n\n\t/* jump <method> */\n\temit_byte (acfg, '\\xe9');\n\temit_symbol_diff (acfg, call_target, \".\", -4);\n#elif defined(TARGET_ARM)\n\tguint8 buf [128];\n\tguint8 *code;\n\n\tif (acfg->thumb_mixed && cfg->compile_llvm) {\n\t\tfprintf (acfg->fp, \"add r0, r0, #%d\\n\", (int)sizeof (MonoObject));\n\t\tfprintf (acfg->fp, \"b %s\\n\", call_target);\n\t\tfprintf (acfg->fp, \".arm\\n\");\n\t\tfprintf (acfg->fp, \".align 2\\n\");\n\t\treturn;\n\t}\n\n\tcode = buf;\n\n\tARM_ADD_REG_IMM8 (code, ARMREG_R0, ARMREG_R0, sizeof (MonoObject));\n\n\temit_bytes (acfg, buf, code - buf);\n\t/* jump to method */\n\tif (acfg->thumb_mixed && cfg->compile_llvm)\n\t\tfprintf (acfg->fp, \"\\n\\tbx %s\\n\", call_target);\n\telse\n\t\tfprintf (acfg->fp, \"\\n\\tb %s\\n\", call_target);\n#elif defined(TARGET_ARM64)\n\tarm64_emit_unbox_trampoline (acfg, cfg, method, call_target);\n#elif defined(TARGET_POWERPC)\n\tint this_pos = 3;\n\n\tfprintf (acfg->fp, \"\\n\\taddi %d, %d, %d\\n\", this_pos, this_pos, (int)sizeof (MonoObject));\n\tfprintf (acfg->fp, \"\\n\\tb %s\\n\", call_target);\n#else\n\tg_assert_not_reached ();\n#endif\n}\n\n/*\n * arch_emit_static_rgctx_trampoline:\n *\n *   Emit code for a static rgctx trampoline. OFFSET is the offset of the first of\n * two GOT slots which contain the rgctx argument, and the method to jump to.\n * TRAMP_SIZE is set to the size of the emitted trampoline.\n * These kinds of trampolines cannot be enumerated statically, since there could\n * be one trampoline per method instantiation, so we emit the same code for all\n * trampolines, and parameterize them using two GOT slots.\n */\nstatic void\narch_emit_static_rgctx_trampoline (MonoAotCompile *acfg, int offset, int *tramp_size)\n{\n#if defined(TARGET_AMD64)\n\t/* This should be exactly 13 bytes long */\n\t*tramp_size = 13;\n\n\tif (acfg->llvm) {\n\t\temit_unset_mode (acfg);\n\t\tfprintf (acfg->fp, \"mov %s+%d(%%rip), %%r10\\n\", acfg->got_symbol, (int)(offset * sizeof (gpointer)));\n\t\tfprintf (acfg->fp, \"jmp *%s+%d(%%rip)\\n\", acfg->got_symbol, (int)((offset + 1) * sizeof (gpointer)));\n\t} else {\n\t\t/* mov <OFFSET>(%rip), %r10 */\n\t\temit_byte (acfg, '\\x4d');\n\t\temit_byte (acfg, '\\x8b');\n\t\temit_byte (acfg, '\\x15');\n\t\temit_symbol_diff (acfg, acfg->got_symbol, \".\", (offset * sizeof (gpointer)) - 4);\n\n\t\t/* jmp *<offset>(%rip) */\n\t\temit_byte (acfg, '\\xff');\n\t\temit_byte (acfg, '\\x25');\n\t\temit_symbol_diff (acfg, acfg->got_symbol, \".\", ((offset + 1) * sizeof (gpointer)) - 4);\n\t}\n#elif defined(TARGET_ARM)\n\tguint8 buf [128];\n\tguint8 *code;\n\n\t/* This should be exactly 24 bytes long */\n\t*tramp_size = 24;\n\tcode = buf;\n\t/* Load rgctx value */\n\tARM_LDR_IMM (code, ARMREG_IP, ARMREG_PC, 8);\n\tARM_LDR_REG_REG (code, MONO_ARCH_RGCTX_REG, ARMREG_PC, ARMREG_IP);\n\t/* Load branch addr + branch */\n\tARM_LDR_IMM (code, ARMREG_IP, ARMREG_PC, 4);\n\tARM_LDR_REG_REG (code, ARMREG_PC, ARMREG_PC, ARMREG_IP);\n\n\tg_assert (code - buf == 16);\n\n\t/* Emit it */\n\temit_bytes (acfg, buf, code - buf);\n\temit_symbol_diff (acfg, acfg->got_symbol, \".\", (offset * sizeof (gpointer)) - 4 + 8);\n\temit_symbol_diff (acfg, acfg->got_symbol, \".\", ((offset + 1) * sizeof (gpointer)) - 4 + 4);\n#elif defined(TARGET_ARM64)\n\tarm64_emit_static_rgctx_trampoline (acfg, offset, tramp_size);\n#elif defined(TARGET_POWERPC)\n\tguint8 buf [128];\n\tguint8 *code;\n\n\t*tramp_size = 4;\n\tcode = buf;\n\n\t/*\n\t * PPC has no ip relative addressing, so we need to compute the address\n\t * of the mscorlib got. That is slow and complex, so instead, we store it\n\t * in the second got slot of every aot image. The caller already computed\n\t * the address of its got and placed it into r30.\n\t */\n\temit_unset_mode (acfg);\n\t/* Load mscorlib got address */\n\tfprintf (acfg->fp, \"%s 0, %d(30)\\n\", PPC_LD_OP, (int)sizeof (gpointer));\n\t/* Load rgctx */\n\tfprintf (acfg->fp, \"lis 11, %d@h\\n\", (int)(offset * sizeof (gpointer)));\n\tfprintf (acfg->fp, \"ori 11, 11, %d@l\\n\", (int)(offset * sizeof (gpointer)));\n\tfprintf (acfg->fp, \"%s %d, 11, 0\\n\", PPC_LDX_OP, MONO_ARCH_RGCTX_REG);\n\t/* Load target address */\n\tfprintf (acfg->fp, \"lis 11, %d@h\\n\", (int)((offset + 1) * sizeof (gpointer)));\n\tfprintf (acfg->fp, \"ori 11, 11, %d@l\\n\", (int)((offset + 1) * sizeof (gpointer)));\n\tfprintf (acfg->fp, \"%s 11, 11, 0\\n\", PPC_LDX_OP);\n#ifdef PPC_USES_FUNCTION_DESCRIPTOR\n\tfprintf (acfg->fp, \"%s 2, %d(11)\\n\", PPC_LD_OP, (int)sizeof (gpointer));\n\tfprintf (acfg->fp, \"%s 11, 0(11)\\n\", PPC_LD_OP);\n#endif\n\tfprintf (acfg->fp, \"mtctr 11\\n\");\n\t/* Branch to the target address */\n\tfprintf (acfg->fp, \"bctr\\n\");\n\n#ifdef PPC_USES_FUNCTION_DESCRIPTOR\n\t*tramp_size = 11 * 4;\n#else\n\t*tramp_size = 9 * 4;\n#endif\n\n#elif defined(TARGET_X86)\n\tguint8 buf [128];\n\tguint8 *code;\n\n\t/* Similar to the PPC code above */\n\n\tg_assert (MONO_ARCH_RGCTX_REG != X86_ECX);\n\n\tcode = buf;\n\t/* Load mscorlib got address */\n\tx86_mov_reg_membase (code, X86_ECX, MONO_ARCH_GOT_REG, sizeof (gpointer), 4);\n\t/* Load arg */\n\tx86_mov_reg_membase (code, MONO_ARCH_RGCTX_REG, X86_ECX, offset * sizeof (gpointer), 4);\n\t/* Branch to the target address */\n\tx86_jump_membase (code, X86_ECX, (offset + 1) * sizeof (gpointer));\n\n\temit_bytes (acfg, buf, code - buf);\n\n\t*tramp_size = 15;\n\tg_assert (code - buf == *tramp_size);\n#else\n\tg_assert_not_reached ();\n#endif\n}\t\n\n/*\n * arch_emit_imt_trampoline:\n *\n *   Emit an IMT trampoline usable in full-aot mode. The trampoline uses 1 got slot which\n * points to an array of pointer pairs. The pairs of the form [key, ptr], where\n * key is the IMT key, and ptr holds the address of a memory location holding\n * the address to branch to if the IMT arg matches the key. The array is \n * terminated by a pair whose key is NULL, and whose ptr is the address of the \n * fail_tramp.\n * TRAMP_SIZE is set to the size of the emitted trampoline.\n */\nstatic void\narch_emit_imt_trampoline (MonoAotCompile *acfg, int offset, int *tramp_size)\n{\n#if defined(TARGET_AMD64)\n\tguint8 *buf, *code;\n\tguint8 *labels [16];\n\tguint8 mov_buf[3];\n\tguint8 *mov_buf_ptr = mov_buf;\n\n\tconst int kSizeOfMove = 7;\n\n\tcode = buf = (guint8 *)g_malloc (256);\n\n\t/* FIXME: Optimize this, i.e. use binary search etc. */\n\t/* Maybe move the body into a separate function (slower, but much smaller) */\n\n\t/* MONO_ARCH_IMT_SCRATCH_REG is a free register */\n\n\tif (acfg->llvm) {\n\t\temit_unset_mode (acfg);\n\t\tfprintf (acfg->fp, \"mov %s+%d(%%rip), %s\\n\", acfg->got_symbol, (int)(offset * sizeof (gpointer)), mono_arch_regname (MONO_ARCH_IMT_SCRATCH_REG));\n\t}\n\n\tlabels [0] = code;\n\tamd64_alu_membase_imm (code, X86_CMP, MONO_ARCH_IMT_SCRATCH_REG, 0, 0);\n\tlabels [1] = code;\n\tamd64_branch8 (code, X86_CC_Z, 0, FALSE);\n\n\t/* Check key */\n\tamd64_alu_membase_reg_size (code, X86_CMP, MONO_ARCH_IMT_SCRATCH_REG, 0, MONO_ARCH_IMT_REG, sizeof (gpointer));\n\tlabels [2] = code;\n\tamd64_branch8 (code, X86_CC_Z, 0, FALSE);\n\n\t/* Loop footer */\n\tamd64_alu_reg_imm (code, X86_ADD, MONO_ARCH_IMT_SCRATCH_REG, 2 * sizeof (gpointer));\n\tamd64_jump_code (code, labels [0]);\n\n\t/* Match */\n\tmono_amd64_patch (labels [2], code);\n\tamd64_mov_reg_membase (code, MONO_ARCH_IMT_SCRATCH_REG, MONO_ARCH_IMT_SCRATCH_REG, sizeof (gpointer), sizeof (gpointer));\n\tamd64_jump_membase (code, MONO_ARCH_IMT_SCRATCH_REG, 0);\n\n\t/* No match */\n\tmono_amd64_patch (labels [1], code);\n\t/* Load fail tramp */\n\tamd64_alu_reg_imm (code, X86_ADD, MONO_ARCH_IMT_SCRATCH_REG, sizeof (gpointer));\n\t/* Check if there is a fail tramp */\n\tamd64_alu_membase_imm (code, X86_CMP, MONO_ARCH_IMT_SCRATCH_REG, 0, 0);\n\tlabels [3] = code;\n\tamd64_branch8 (code, X86_CC_Z, 0, FALSE);\n\t/* Jump to fail tramp */\n\tamd64_jump_membase (code, MONO_ARCH_IMT_SCRATCH_REG, 0);\n\n\t/* Fail */\n\tmono_amd64_patch (labels [3], code);\n\tx86_breakpoint (code);\n\n\tif (!acfg->llvm) {\n\t\t/* mov <OFFSET>(%rip), MONO_ARCH_IMT_SCRATCH_REG */\n\t\tamd64_emit_rex (mov_buf_ptr, sizeof(gpointer), MONO_ARCH_IMT_SCRATCH_REG, 0, AMD64_RIP);\n\t\t*(mov_buf_ptr)++ = (unsigned char)0x8b; /* mov opcode */\n\t\tx86_address_byte (mov_buf_ptr, 0, MONO_ARCH_IMT_SCRATCH_REG & 0x7, 5);\n\t\temit_bytes (acfg, mov_buf, mov_buf_ptr - mov_buf);\n\t\temit_symbol_diff (acfg, acfg->got_symbol, \".\", (offset * sizeof (gpointer)) - 4);\n\t}\n\temit_bytes (acfg, buf, code - buf);\n\n\t*tramp_size = code - buf + kSizeOfMove;\n\n\tg_free (buf);\n\n#elif defined(TARGET_X86)\n\tguint8 *buf, *code;\n\tguint8 *labels [16];\n\n\tcode = buf = g_malloc (256);\n\n\t/* Allocate a temporary stack slot */\n\tx86_push_reg (code, X86_EAX);\n\t/* Save EAX */\n\tx86_push_reg (code, X86_EAX);\n\n\t/* Load mscorlib got address */\n\tx86_mov_reg_membase (code, X86_EAX, MONO_ARCH_GOT_REG, sizeof (gpointer), 4);\n\t/* Load arg */\n\tx86_mov_reg_membase (code, X86_EAX, X86_EAX, offset * sizeof (gpointer), 4);\n\n\tlabels [0] = code;\n\tx86_alu_membase_imm (code, X86_CMP, X86_EAX, 0, 0);\n\tlabels [1] = code;\n\tx86_branch8 (code, X86_CC_Z, FALSE, 0);\n\n\t/* Check key */\n\tx86_alu_membase_reg (code, X86_CMP, X86_EAX, 0, MONO_ARCH_IMT_REG);\n\tlabels [2] = code;\n\tx86_branch8 (code, X86_CC_Z, FALSE, 0);\n\n\t/* Loop footer */\n\tx86_alu_reg_imm (code, X86_ADD, X86_EAX, 2 * sizeof (gpointer));\n\tx86_jump_code (code, labels [0]);\n\n\t/* Match */\n\tmono_x86_patch (labels [2], code);\n\tx86_mov_reg_membase (code, X86_EAX, X86_EAX, sizeof (gpointer), 4);\n\tx86_mov_reg_membase (code, X86_EAX, X86_EAX, 0, 4);\n\t/* Save the target address to the temporary stack location */\n\tx86_mov_membase_reg (code, X86_ESP, 4, X86_EAX, 4);\n\t/* Restore EAX */\n\tx86_pop_reg (code, X86_EAX);\n\t/* Jump to the target address */\n\tx86_ret (code);\n\n\t/* No match */\n\tmono_x86_patch (labels [1], code);\n\t/* Load fail tramp */\n\tx86_mov_reg_membase (code, X86_EAX, X86_EAX, sizeof (gpointer), 4);\n\tx86_alu_membase_imm (code, X86_CMP, X86_EAX, 0, 0);\n\tlabels [3] = code;\n\tx86_branch8 (code, X86_CC_Z, FALSE, 0);\n\t/* Jump to fail tramp */\n\tx86_mov_membase_reg (code, X86_ESP, 4, X86_EAX, 4);\n\tx86_pop_reg (code, X86_EAX);\n\tx86_ret (code);\n\n\t/* Fail */\n\tmono_x86_patch (labels [3], code);\n\tx86_breakpoint (code);\n\n\temit_bytes (acfg, buf, code - buf);\n\t\n\t*tramp_size = code - buf;\n\n\tg_free (buf);\n\n#elif defined(TARGET_ARM)\n\tguint8 buf [128];\n\tguint8 *code, *code2, *labels [16];\n\n\tcode = buf;\n\n\t/* The IMT method is in v5 */\n\n\t/* Need at least two free registers, plus a slot for storing the pc */\n\tARM_PUSH (code, (1 << ARMREG_R0)|(1 << ARMREG_R1)|(1 << ARMREG_R2));\n\tlabels [0] = code;\n\t/* Load the parameter from the GOT */\n\tARM_LDR_IMM (code, ARMREG_R0, ARMREG_PC, 0);\n\tARM_LDR_REG_REG (code, ARMREG_R0, ARMREG_PC, ARMREG_R0);\n\n\tlabels [1] = code;\n\tARM_LDR_IMM (code, ARMREG_R1, ARMREG_R0, 0);\n\tARM_CMP_REG_REG (code, ARMREG_R1, ARMREG_V5);\n\tlabels [2] = code;\n\tARM_B_COND (code, ARMCOND_EQ, 0);\n\n\t/* End-of-loop check */\n\tARM_CMP_REG_IMM (code, ARMREG_R1, 0, 0);\n\tlabels [3] = code;\n\tARM_B_COND (code, ARMCOND_EQ, 0);\n\n\t/* Loop footer */\n\tARM_ADD_REG_IMM8 (code, ARMREG_R0, ARMREG_R0, sizeof (gpointer) * 2);\n\tlabels [4] = code;\n\tARM_B (code, 0);\n\tarm_patch (labels [4], labels [1]);\n\n\t/* Match */\n\tarm_patch (labels [2], code);\n\tARM_LDR_IMM (code, ARMREG_R0, ARMREG_R0, 4);\n\tARM_LDR_IMM (code, ARMREG_R0, ARMREG_R0, 0);\n\t/* Save it to the third stack slot */\n\tARM_STR_IMM (code, ARMREG_R0, ARMREG_SP, 8);\n\t/* Restore the registers and branch */\n\tARM_POP (code, (1 << ARMREG_R0)|(1 << ARMREG_R1)|(1 << ARMREG_PC));\n\n\t/* No match */\n\tarm_patch (labels [3], code);\n\tARM_LDR_IMM (code, ARMREG_R0, ARMREG_R0, 4);\n\tARM_STR_IMM (code, ARMREG_R0, ARMREG_SP, 8);\n\tARM_POP (code, (1 << ARMREG_R0)|(1 << ARMREG_R1)|(1 << ARMREG_PC));\n\n\t/* Fixup offset */\n\tcode2 = labels [0];\n\tARM_LDR_IMM (code2, ARMREG_R0, ARMREG_PC, (code - (labels [0] + 8)));\n\n\temit_bytes (acfg, buf, code - buf);\n\temit_symbol_diff (acfg, acfg->got_symbol, \".\", (offset * sizeof (gpointer)) + (code - (labels [0] + 8)) - 4);\n\n\t*tramp_size = code - buf + 4;\n#elif defined(TARGET_ARM64)\n\tarm64_emit_imt_trampoline (acfg, offset, tramp_size);\n#elif defined(TARGET_POWERPC)\n\tguint8 buf [128];\n\tguint8 *code, *labels [16];\n\n\tcode = buf;\n\n\t/* Load the mscorlib got address */\n\tppc_ldptr (code, ppc_r12, sizeof (gpointer), ppc_r30);\n\t/* Load the parameter from the GOT */\n\tppc_load (code, ppc_r0, offset * sizeof (gpointer));\n\tppc_ldptr_indexed (code, ppc_r12, ppc_r12, ppc_r0);\n\n\t/* Load and check key */\n\tlabels [1] = code;\n\tppc_ldptr (code, ppc_r0, 0, ppc_r12);\n\tppc_cmp (code, 0, sizeof (gpointer) == 8 ? 1 : 0, ppc_r0, MONO_ARCH_IMT_REG);\n\tlabels [2] = code;\n\tppc_bc (code, PPC_BR_TRUE, PPC_BR_EQ, 0);\n\n\t/* End-of-loop check */\n\tppc_cmpi (code, 0, sizeof (gpointer) == 8 ? 1 : 0, ppc_r0, 0);\n\tlabels [3] = code;\n\tppc_bc (code, PPC_BR_TRUE, PPC_BR_EQ, 0);\n\n\t/* Loop footer */\n\tppc_addi (code, ppc_r12, ppc_r12, 2 * sizeof (gpointer));\n\tlabels [4] = code;\n\tppc_b (code, 0);\n\tmono_ppc_patch (labels [4], labels [1]);\n\n\t/* Match */\n\tmono_ppc_patch (labels [2], code);\n\tppc_ldptr (code, ppc_r12, sizeof (gpointer), ppc_r12);\n\t/* r12 now contains the value of the vtable slot */\n\t/* this is not a function descriptor on ppc64 */\n\tppc_ldptr (code, ppc_r12, 0, ppc_r12);\n\tppc_mtctr (code, ppc_r12);\n\tppc_bcctr (code, PPC_BR_ALWAYS, 0);\n\n\t/* Fail */\n\tmono_ppc_patch (labels [3], code);\n\t/* FIXME: */\n\tppc_break (code);\n\n\t*tramp_size = code - buf;\n\n\temit_bytes (acfg, buf, code - buf);\n#else\n\tg_assert_not_reached ();\n#endif\n}\n\n\n#if defined (TARGET_AMD64)\n\nstatic void\namd64_emit_load_got_slot (MonoAotCompile *acfg, int dreg, int got_slot)\n{\n\n\tg_assert (acfg->fp);\n\temit_unset_mode (acfg);\n\n\tfprintf (acfg->fp, \"mov %s+%d(%%rip), %s\\n\", acfg->got_symbol, (unsigned int) ((got_slot * sizeof (gpointer))), mono_arch_regname (dreg));\n}\n\n#endif\n\n\n/*\n * arch_emit_gsharedvt_arg_trampoline:\n *\n *   Emit code for a gsharedvt arg trampoline. OFFSET is the offset of the first of\n * two GOT slots which contain the argument, and the code to jump to.\n * TRAMP_SIZE is set to the size of the emitted trampoline.\n * These kinds of trampolines cannot be enumerated statically, since there could\n * be one trampoline per method instantiation, so we emit the same code for all\n * trampolines, and parameterize them using two GOT slots.\n */\nstatic void\narch_emit_gsharedvt_arg_trampoline (MonoAotCompile *acfg, int offset, int *tramp_size)\n{\n#if defined(TARGET_X86)\n\tguint8 buf [128];\n\tguint8 *code;\n\n\t/* Similar to the PPC code above */\n\n\tg_assert (MONO_ARCH_RGCTX_REG != X86_ECX);\n\n\tcode = buf;\n\t/* Load mscorlib got address */\n\tx86_mov_reg_membase (code, X86_ECX, MONO_ARCH_GOT_REG, sizeof (gpointer), 4);\n\t/* Load arg */\n\tx86_mov_reg_membase (code, X86_EAX, X86_ECX, offset * sizeof (gpointer), 4);\n\t/* Branch to the target address */\n\tx86_jump_membase (code, X86_ECX, (offset + 1) * sizeof (gpointer));\n\n\temit_bytes (acfg, buf, code - buf);\n\n\t*tramp_size = 15;\n\tg_assert (code - buf == *tramp_size);\n#elif defined(TARGET_ARM)\n\tguint8 buf [128];\n\tguint8 *code;\n\n\t/* The same as mono_arch_get_gsharedvt_arg_trampoline (), but for AOT */\n\t/* Similar to arch_emit_specific_trampoline () */\n\t*tramp_size = 24;\n\tcode = buf;\n\tARM_PUSH (code, (1 << ARMREG_R0) | (1 << ARMREG_R1) | (1 << ARMREG_R2) | (1 << ARMREG_R3));\n\tARM_LDR_IMM (code, ARMREG_R1, ARMREG_PC, 8);\n\t/* Load the arg value from the GOT */\n\tARM_LDR_REG_REG (code, ARMREG_R0, ARMREG_PC, ARMREG_R1);\n\t/* Load the addr from the GOT */\n\tARM_LDR_REG_REG (code, ARMREG_R1, ARMREG_PC, ARMREG_R1);\n\t/* Branch to it */\n\tARM_BX (code, ARMREG_R1);\n\n\tg_assert (code - buf == 20);\n\n\t/* Emit it */\n\temit_bytes (acfg, buf, code - buf);\n\temit_symbol_diff (acfg, acfg->got_symbol, \".\", (offset * sizeof (gpointer)) + 4);\n#elif defined(TARGET_ARM64)\n\tarm64_emit_gsharedvt_arg_trampoline (acfg, offset, tramp_size);\n#elif defined (TARGET_AMD64)\n\n\tamd64_emit_load_got_slot (acfg, AMD64_RAX, offset);\n\tamd64_emit_load_got_slot (acfg, MONO_ARCH_IMT_SCRATCH_REG, offset + 1);\n\tg_assert (AMD64_R11 == MONO_ARCH_IMT_SCRATCH_REG);\n\tfprintf (acfg->fp, \"jmp *%%r11\\n\");\n\n\t*tramp_size = 0x11;\n#else\n\tg_assert_not_reached ();\n#endif\n}\t\n\n/* END OF ARCH SPECIFIC CODE */\n\nstatic guint32\nmono_get_field_token (MonoClassField *field) \n{\n\tMonoClass *klass = field->parent;\n\tint i;\n\n\tint fcount = mono_class_get_field_count (klass);\n\tfor (i = 0; i < fcount; ++i) {\n\t\tif (field == &klass->fields [i])\n\t\t\treturn MONO_TOKEN_FIELD_DEF | (mono_class_get_first_field_idx (klass) + 1 + i);\n\t}\n\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nstatic inline void\nencode_value (gint32 value, guint8 *buf, guint8 **endbuf)\n{\n\tguint8 *p = buf;\n\n\t//printf (\"ENCODE: %d 0x%x.\\n\", value, value);\n\n\t/* \n\t * Same encoding as the one used in the metadata, extended to handle values\n\t * greater than 0x1fffffff.\n\t */\n\tif ((value >= 0) && (value <= 127))\n\t\t*p++ = value;\n\telse if ((value >= 0) && (value <= 16383)) {\n\t\tp [0] = 0x80 | (value >> 8);\n\t\tp [1] = value & 0xff;\n\t\tp += 2;\n\t} else if ((value >= 0) && (value <= 0x1fffffff)) {\n\t\tp [0] = (value >> 24) | 0xc0;\n\t\tp [1] = (value >> 16) & 0xff;\n\t\tp [2] = (value >> 8) & 0xff;\n\t\tp [3] = value & 0xff;\n\t\tp += 4;\n\t}\n\telse {\n\t\tp [0] = 0xff;\n\t\tp [1] = (value >> 24) & 0xff;\n\t\tp [2] = (value >> 16) & 0xff;\n\t\tp [3] = (value >> 8) & 0xff;\n\t\tp [4] = value & 0xff;\n\t\tp += 5;\n\t}\n\tif (endbuf)\n\t\t*endbuf = p;\n}\n\nstatic void\nstream_init (MonoDynamicStream *sh)\n{\n\tsh->index = 0;\n\tsh->alloc_size = 4096;\n\tsh->data = (char *)g_malloc (4096);\n\n\t/* So offsets are > 0 */\n\tsh->data [0] = 0;\n\tsh->index ++;\n}\n\nstatic void\nmake_room_in_stream (MonoDynamicStream *stream, int size)\n{\n\tif (size <= stream->alloc_size)\n\t\treturn;\n\t\n\twhile (stream->alloc_size <= size) {\n\t\tif (stream->alloc_size < 4096)\n\t\t\tstream->alloc_size = 4096;\n\t\telse\n\t\t\tstream->alloc_size *= 2;\n\t}\n\t\n\tstream->data = (char *)g_realloc (stream->data, stream->alloc_size);\n}\n\nstatic guint32\nadd_stream_data (MonoDynamicStream *stream, const char *data, guint32 len)\n{\n\tguint32 idx;\n\t\n\tmake_room_in_stream (stream, stream->index + len);\n\tmemcpy (stream->data + stream->index, data, len);\n\tidx = stream->index;\n\tstream->index += len;\n\treturn idx;\n}\n\n/*\n * add_to_blob:\n *\n *   Add data to the binary blob inside the aot image. Returns the offset inside the\n * blob where the data was stored.\n */\nstatic guint32\nadd_to_blob (MonoAotCompile *acfg, const guint8 *data, guint32 data_len)\n{\n\tg_assert (!acfg->blob_closed);\n\n\tif (acfg->blob.alloc_size == 0)\n\t\tstream_init (&acfg->blob);\n\n\treturn add_stream_data (&acfg->blob, (char*)data, data_len);\n}\n\nstatic guint32\nadd_to_blob_aligned (MonoAotCompile *acfg, const guint8 *data, guint32 data_len, guint32 align)\n{\n\tchar buf [4] = {0};\n\tguint32 count;\n\n\tif (acfg->blob.alloc_size == 0)\n\t\tstream_init (&acfg->blob);\n\n\tcount = acfg->blob.index % align;\n\n\t/* we assume the stream data will be aligned */\n\tif (count)\n\t\tadd_stream_data (&acfg->blob, buf, 4 - count);\n\n\treturn add_stream_data (&acfg->blob, (char*)data, data_len);\n}\n\n/* Emit a table of data into the aot image */\nstatic void\nemit_aot_data (MonoAotCompile *acfg, MonoAotFileTable table, const char *symbol, guint8 *data, int size)\n{\n\tif (acfg->data_outfile) {\n\t\tacfg->table_offsets [(int)table] = acfg->datafile_offset;\n\t\tfwrite (data,1, size, acfg->data_outfile);\n\t\tacfg->datafile_offset += size;\n\t\t// align the data to 8 bytes. Put zeros in the file (so that every build results in consistent output).\n\t\tint align = 8 - size % 8;\n\t\tacfg->datafile_offset += align;\n\t\tguint8 align_buf [16];\n\t\tmemset (&align_buf, 0, sizeof (align_buf));\n\t\tfwrite (align_buf, align, 1, acfg->data_outfile);\n\t} else if (acfg->llvm) {\n\t\tmono_llvm_emit_aot_data (symbol, data, size);\n\t} else {\n\t\temit_section_change (acfg, RODATA_SECT, 0);\n\t\temit_alignment (acfg, 8);\n\t\temit_label (acfg, symbol);\n\t\temit_bytes (acfg, data, size);\n\t}\n}\n\n/*\n * emit_offset_table:\n *\n *   Emit a table of increasing offsets in a compact form using differential encoding.\n * There is an index entry for each GROUP_SIZE number of entries. The greater the\n * group size, the more compact the table becomes, but the slower it becomes to compute\n * a given entry. Returns the size of the table.\n */\nstatic guint32\nemit_offset_table (MonoAotCompile *acfg, const char *symbol, MonoAotFileTable table, int noffsets, int group_size, gint32 *offsets)\n{\n\tgint32 current_offset;\n\tint i, buf_size, ngroups, index_entry_size;\n\tguint8 *p, *buf;\n\tguint8 *data_p, *data_buf;\n\tguint32 *index_offsets;\n\n\tngroups = (noffsets + (group_size - 1)) / group_size;\n\n\tindex_offsets = g_new0 (guint32, ngroups);\n\n\tbuf_size = noffsets * 4;\n\tp = buf = (guint8 *)g_malloc0 (buf_size);\n\n\tcurrent_offset = 0;\n\tfor (i = 0; i < noffsets; ++i) {\n\t\t//printf (\"D: %d -> %d\\n\", i, offsets [i]);\n\t\tif ((i % group_size) == 0) {\n\t\t\tindex_offsets [i / group_size] = p - buf;\n\t\t\t/* Emit the full value for these entries */\n\t\t\tencode_value (offsets [i], p, &p);\n\t\t} else {\n\t\t\t/* The offsets are allowed to be non-increasing */\n\t\t\t//g_assert (offsets [i] >= current_offset);\n\t\t\tencode_value (offsets [i] - current_offset, p, &p);\n\t\t}\n\t\tcurrent_offset = offsets [i];\n\t}\n\tdata_buf = buf;\n\tdata_p = p;\n\n\tif (ngroups && index_offsets [ngroups - 1] < 65000)\n\t\tindex_entry_size = 2;\n\telse\n\t\tindex_entry_size = 4;\n\n\tbuf_size = (data_p - data_buf) + (ngroups * 4) + 16;\n\tp = buf = (guint8 *)g_malloc0 (buf_size);\n\n\t/* Emit the header */\n\tencode_int (noffsets, p, &p);\n\tencode_int (group_size, p, &p);\n\tencode_int (ngroups, p, &p);\n\tencode_int (index_entry_size, p, &p);\n\n\t/* Emit the index */\n\tfor (i = 0; i < ngroups; ++i) {\n\t\tif (index_entry_size == 2)\n\t\t\tencode_int16 (index_offsets [i], p, &p);\n\t\telse\n\t\t\tencode_int (index_offsets [i], p, &p);\n\t}\n\t/* Emit the data */\n\tmemcpy (p, data_buf, data_p - data_buf);\n\tp += data_p - data_buf;\n\n\tg_assert (p - buf <= buf_size);\n\n\temit_aot_data (acfg, table, symbol, buf, p - buf);\n\n\tg_free (buf);\n\tg_free (data_buf);\n\n    return (int)(p - buf);\n}\n\nstatic guint32\nget_image_index (MonoAotCompile *cfg, MonoImage *image)\n{\n\tguint32 index;\n\n\tindex = GPOINTER_TO_UINT (g_hash_table_lookup (cfg->image_hash, image));\n\tif (index)\n\t\treturn index - 1;\n\telse {\n\t\tindex = g_hash_table_size (cfg->image_hash);\n\t\tg_hash_table_insert (cfg->image_hash, image, GUINT_TO_POINTER (index + 1));\n\t\tg_ptr_array_add (cfg->image_table, image);\n\t\treturn index;\n\t}\n}\n\nstatic guint32\nfind_typespec_for_class (MonoAotCompile *acfg, MonoClass *klass)\n{\n\tint i;\n\tint len = acfg->image->tables [MONO_TABLE_TYPESPEC].rows;\n\n\t/* FIXME: Search referenced images as well */\n\tif (!acfg->typespec_classes) {\n\t\tacfg->typespec_classes = g_hash_table_new (NULL, NULL);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tMonoError error;\n\t\t\tint typespec = MONO_TOKEN_TYPE_SPEC | (i + 1);\n\t\t\tMonoClass *klass_key = mono_class_get_and_inflate_typespec_checked (acfg->image, typespec, NULL, &error);\n\t\t\tif (!is_ok (&error)) {\n\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tg_hash_table_insert (acfg->typespec_classes, klass_key, GINT_TO_POINTER (typespec));\n\t\t}\n\t}\n\treturn GPOINTER_TO_INT (g_hash_table_lookup (acfg->typespec_classes, klass));\n}\n\nstatic void\nencode_method_ref (MonoAotCompile *acfg, MonoMethod *method, guint8 *buf, guint8 **endbuf);\n\nstatic void\nencode_klass_ref (MonoAotCompile *acfg, MonoClass *klass, guint8 *buf, guint8 **endbuf);\n\nstatic void\nencode_ginst (MonoAotCompile *acfg, MonoGenericInst *inst, guint8 *buf, guint8 **endbuf);\n\nstatic void\nencode_type (MonoAotCompile *acfg, MonoType *t, guint8 *buf, guint8 **endbuf);\n\nstatic void\nencode_klass_ref_inner (MonoAotCompile *acfg, MonoClass *klass, guint8 *buf, guint8 **endbuf)\n{\n\tguint8 *p = buf;\n\n\t/*\n\t * The encoding begins with one of the MONO_AOT_TYPEREF values, followed by additional\n\t * information.\n\t */\n\n\tif (mono_class_is_ginst (klass)) {\n\t\tguint32 token;\n\t\tg_assert (klass->type_token);\n\n\t\t/* Find a typespec for a class if possible */\n\t\ttoken = find_typespec_for_class (acfg, klass);\n\t\tif (token) {\n\t\t\tencode_value (MONO_AOT_TYPEREF_TYPESPEC_TOKEN, p, &p);\n\t\t\tencode_value (token, p, &p);\n\t\t} else {\n\t\t\tMonoClass *gclass = mono_class_get_generic_class (klass)->container_class;\n\t\t\tMonoGenericInst *inst = mono_class_get_generic_class (klass)->context.class_inst;\n\t\t\tstatic int count = 0;\n\t\t\tguint8 *p1 = p;\n\n\t\t\tencode_value (MONO_AOT_TYPEREF_GINST, p, &p);\n\t\t\tencode_klass_ref (acfg, gclass, p, &p);\n\t\t\tencode_ginst (acfg, inst, p, &p);\n\n\t\t\tcount += p - p1;\n\t\t}\n\t} else if (klass->type_token) {\n\t\tint iindex = get_image_index (acfg, klass->image);\n\n\t\tg_assert (mono_metadata_token_code (klass->type_token) == MONO_TOKEN_TYPE_DEF);\n\t\tif (iindex == 0) {\n\t\t\tencode_value (MONO_AOT_TYPEREF_TYPEDEF_INDEX, p, &p);\n\t\t\tencode_value (klass->type_token - MONO_TOKEN_TYPE_DEF, p, &p);\n\t\t} else {\n\t\t\tencode_value (MONO_AOT_TYPEREF_TYPEDEF_INDEX_IMAGE, p, &p);\n\t\t\tencode_value (klass->type_token - MONO_TOKEN_TYPE_DEF, p, &p);\n\t\t\tencode_value (get_image_index (acfg, klass->image), p, &p);\n\t\t}\n\t} else if ((klass->byval_arg.type == MONO_TYPE_VAR) || (klass->byval_arg.type == MONO_TYPE_MVAR)) {\n\t\tMonoGenericContainer *container = mono_type_get_generic_param_owner (&klass->byval_arg);\n\t\tMonoGenericParam *par = klass->byval_arg.data.generic_param;\n\n\t\tencode_value (MONO_AOT_TYPEREF_VAR, p, &p);\n\n\t\tencode_value (par->gshared_constraint ? 1 : 0, p, &p);\n\t\tif (par->gshared_constraint) {\n\t\t\tMonoGSharedGenericParam *gpar = (MonoGSharedGenericParam*)par;\n\t\t\tencode_type (acfg, par->gshared_constraint, p, &p);\n\t\t\tencode_klass_ref (acfg, mono_class_from_generic_parameter_internal (gpar->parent), p, &p);\n\t\t} else {\n\t\t\tencode_value (klass->byval_arg.type, p, &p);\n\t\t\tencode_value (mono_type_get_generic_param_num (&klass->byval_arg), p, &p);\n\n\t\t\tencode_value (container->is_anonymous ? 0 : 1, p, &p);\n\n\t\t\tif (!container->is_anonymous) {\n\t\t\t\tencode_value (container->is_method, p, &p);\n\t\t\t\tif (container->is_method)\n\t\t\t\t\tencode_method_ref (acfg, container->owner.method, p, &p);\n\t\t\t\telse\n\t\t\t\t\tencode_klass_ref (acfg, container->owner.klass, p, &p);\n\t\t\t}\n\t\t}\n\t} else if (klass->byval_arg.type == MONO_TYPE_PTR) {\n\t\tencode_value (MONO_AOT_TYPEREF_PTR, p, &p);\n\t\tencode_type (acfg, &klass->byval_arg, p, &p);\n\t} else {\n\t\t/* Array class */\n\t\tg_assert (klass->rank > 0);\n\t\tencode_value (MONO_AOT_TYPEREF_ARRAY, p, &p);\n\t\tencode_value (klass->rank, p, &p);\n\t\tencode_klass_ref (acfg, klass->element_class, p, &p);\n\t}\n\t*endbuf = p;\n}\n\n/*\n * encode_klass_ref:\n *\n *   Encode a reference to KLASS. We use our home-grown encoding instead of the\n * standard metadata encoding.\n */\nstatic void\nencode_klass_ref (MonoAotCompile *acfg, MonoClass *klass, guint8 *buf, guint8 **endbuf)\n{\n\tgboolean shared = FALSE;\n\n\t/* \n\t * The encoding of generic instances is large so emit them only once.\n\t */\n\tif (mono_class_is_ginst (klass)) {\n\t\tguint32 token;\n\t\tg_assert (klass->type_token);\n\n\t\t/* Find a typespec for a class if possible */\n\t\ttoken = find_typespec_for_class (acfg, klass);\n\t\tif (!token)\n\t\t\tshared = TRUE;\n\t} else if ((klass->byval_arg.type == MONO_TYPE_VAR) || (klass->byval_arg.type == MONO_TYPE_MVAR)) {\n\t\tshared = TRUE;\n\t}\n\n\tif (shared) {\n\t\tguint offset = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->klass_blob_hash, klass));\n\t\tguint8 *buf2, *p;\n\n\t\tif (!offset) {\n\t\t\tbuf2 = (guint8 *)g_malloc (1024);\n\t\t\tp = buf2;\n\n\t\t\tencode_klass_ref_inner (acfg, klass, p, &p);\n\t\t\tg_assert (p - buf2 < 1024);\n\n\t\t\toffset = add_to_blob (acfg, buf2, p - buf2);\n\t\t\tg_free (buf2);\n\n\t\t\tg_hash_table_insert (acfg->klass_blob_hash, klass, GUINT_TO_POINTER (offset + 1));\n\t\t} else {\n\t\t\toffset --;\n\t\t}\n\n\t\tp = buf;\n\t\tencode_value (MONO_AOT_TYPEREF_BLOB_INDEX, p, &p);\n\t\tencode_value (offset, p, &p);\n\t\t*endbuf = p;\n\t\treturn;\n\t}\n\n\tencode_klass_ref_inner (acfg, klass, buf, endbuf);\n}\n\nstatic void\nencode_field_info (MonoAotCompile *cfg, MonoClassField *field, guint8 *buf, guint8 **endbuf)\n{\n\tguint32 token = mono_get_field_token (field);\n\tguint8 *p = buf;\n\n\tencode_klass_ref (cfg, field->parent, p, &p);\n\tg_assert (mono_metadata_token_code (token) == MONO_TOKEN_FIELD_DEF);\n\tencode_value (token - MONO_TOKEN_FIELD_DEF, p, &p);\n\t*endbuf = p;\n}\n\nstatic void\nencode_ginst (MonoAotCompile *acfg, MonoGenericInst *inst, guint8 *buf, guint8 **endbuf)\n{\n\tguint8 *p = buf;\n\tint i;\n\n\tencode_value (inst->type_argc, p, &p);\n\tfor (i = 0; i < inst->type_argc; ++i)\n\t\tencode_klass_ref (acfg, mono_class_from_mono_type (inst->type_argv [i]), p, &p);\n\t*endbuf = p;\n}\n\nstatic void\nencode_generic_context (MonoAotCompile *acfg, MonoGenericContext *context, guint8 *buf, guint8 **endbuf)\n{\n\tguint8 *p = buf;\n\tMonoGenericInst *inst;\n\n\tinst = context->class_inst;\n\tif (inst) {\n\t\tg_assert (inst->type_argc);\n\t\tencode_ginst (acfg, inst, p, &p);\n\t} else {\n\t\tencode_value (0, p, &p);\n\t}\n\tinst = context->method_inst;\n\tif (inst) {\n\t\tg_assert (inst->type_argc);\n\t\tencode_ginst (acfg, inst, p, &p);\n\t} else {\n\t\tencode_value (0, p, &p);\n\t}\n\t*endbuf = p;\n}\n\nstatic void\nencode_type (MonoAotCompile *acfg, MonoType *t, guint8 *buf, guint8 **endbuf)\n{\n\tguint8 *p = buf;\n\n\tg_assert (t->num_mods == 0);\n\t/* t->attrs can be ignored */\n\t//g_assert (t->attrs == 0);\n\n\tif (t->pinned) {\n\t\t*p = MONO_TYPE_PINNED;\n\t\t++p;\n\t}\n\tif (t->byref) {\n\t\t*p = MONO_TYPE_BYREF;\n\t\t++p;\n\t}\n\n\t*p = t->type;\n\tp ++;\n\n\tswitch (t->type) {\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS:\n\t\tencode_klass_ref (acfg, mono_class_from_mono_type (t), p, &p);\n\t\tbreak;\n\tcase MONO_TYPE_SZARRAY:\n\t\tencode_klass_ref (acfg, t->data.klass, p, &p);\n\t\tbreak;\n\tcase MONO_TYPE_PTR:\n\t\tencode_type (acfg, t->data.type, p, &p);\n\t\tbreak;\n\tcase MONO_TYPE_GENERICINST: {\n\t\tMonoClass *gclass = t->data.generic_class->container_class;\n\t\tMonoGenericInst *inst = t->data.generic_class->context.class_inst;\n\n\t\tencode_klass_ref (acfg, gclass, p, &p);\n\t\tencode_ginst (acfg, inst, p, &p);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_ARRAY: {\n\t\tMonoArrayType *array = t->data.array;\n\t\tint i;\n\n\t\tencode_klass_ref (acfg, array->eklass, p, &p);\n\t\tencode_value (array->rank, p, &p);\n\t\tencode_value (array->numsizes, p, &p);\n\t\tfor (i = 0; i < array->numsizes; ++i)\n\t\t\tencode_value (array->sizes [i], p, &p);\n\t\tencode_value (array->numlobounds, p, &p);\n\t\tfor (i = 0; i < array->numlobounds; ++i)\n\t\t\tencode_value (array->lobounds [i], p, &p);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\tencode_klass_ref (acfg, mono_class_from_mono_type (t), p, &p);\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\t*endbuf = p;\n}\n\nstatic void\nencode_signature (MonoAotCompile *acfg, MonoMethodSignature *sig, guint8 *buf, guint8 **endbuf)\n{\n\tguint8 *p = buf;\n\tguint32 flags = 0;\n\tint i;\n\n\t/* Similar to the metadata encoding */\n\tif (sig->generic_param_count)\n\t\tflags |= 0x10;\n\tif (sig->hasthis)\n\t\tflags |= 0x20;\n\tif (sig->explicit_this)\n\t\tflags |= 0x40;\n\tflags |= (sig->call_convention & 0x0F);\n\n\t*p = flags;\n\t++p;\n\tif (sig->generic_param_count)\n\t\tencode_value (sig->generic_param_count, p, &p);\n\tencode_value (sig->param_count, p, &p);\n\n\tencode_type (acfg, sig->ret, p, &p);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tif (sig->sentinelpos == i) {\n\t\t\t*p = MONO_TYPE_SENTINEL;\n\t\t\t++p;\n\t\t}\n\t\tencode_type (acfg, sig->params [i], p, &p);\n\t}\n\n\t*endbuf = p;\n}\n\n#define MAX_IMAGE_INDEX 250\n\nstatic void\nencode_method_ref (MonoAotCompile *acfg, MonoMethod *method, guint8 *buf, guint8 **endbuf)\n{\n\tguint32 image_index = get_image_index (acfg, method->klass->image);\n\tguint32 token = method->token;\n\tMonoJumpInfoToken *ji;\n\tguint8 *p = buf;\n\n\t/*\n\t * The encoding for most methods is as follows:\n\t * - image index encoded as a leb128\n\t * - token index encoded as a leb128\n\t * Values of image index >= MONO_AOT_METHODREF_MIN are used to mark additional\n\t * types of method encodings.\n\t */\n\n\t/* Mark methods which can't use aot trampolines because they need the further \n\t * processing in mono_magic_trampoline () which requires a MonoMethod*.\n\t */\n\tif ((method->is_generic && (method->flags & METHOD_ATTRIBUTE_VIRTUAL)) ||\n\t\t(method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED))\n\t\tencode_value ((MONO_AOT_METHODREF_NO_AOT_TRAMPOLINE << 24), p, &p);\n\n\tif (method->wrapper_type) {\n\t\tWrapperInfo *info = mono_marshal_get_wrapper_info (method);\n\n\t\tencode_value ((MONO_AOT_METHODREF_WRAPPER << 24), p, &p);\n\n\t\tencode_value (method->wrapper_type, p, &p);\n\n\t\tswitch (method->wrapper_type) {\n\t\tcase MONO_WRAPPER_REMOTING_INVOKE:\n\t\tcase MONO_WRAPPER_REMOTING_INVOKE_WITH_CHECK:\n\t\tcase MONO_WRAPPER_XDOMAIN_INVOKE: {\n\t\t\tMonoMethod *m;\n\n\t\t\tm = mono_marshal_method_from_wrapper (method);\n\t\t\tg_assert (m);\n\t\t\tencode_method_ref (acfg, m, p, &p);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_PROXY_ISINST:\n\t\tcase MONO_WRAPPER_LDFLD:\n\t\tcase MONO_WRAPPER_LDFLDA:\n\t\tcase MONO_WRAPPER_STFLD: {\n\t\t\tg_assert (info);\n\t\t\tencode_klass_ref (acfg, info->d.proxy.klass, p, &p);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_ALLOC: {\n\t\t\t/* The GC name is saved once in MonoAotFileInfo */\n\t\t\tg_assert (info->d.alloc.alloc_type != -1);\n\t\t\tencode_value (info->d.alloc.alloc_type, p, &p);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_WRITE_BARRIER: {\n\t\t\tg_assert (info);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_STELEMREF: {\n\t\t\tg_assert (info);\n\t\t\tencode_value (info->subtype, p, &p);\n\t\t\tif (info->subtype == WRAPPER_SUBTYPE_VIRTUAL_STELEMREF)\n\t\t\t\tencode_value (info->d.virtual_stelemref.kind, p, &p);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_UNKNOWN: {\n\t\t\tg_assert (info);\n\t\t\tencode_value (info->subtype, p, &p);\n\t\t\tif (info->subtype == WRAPPER_SUBTYPE_PTR_TO_STRUCTURE ||\n\t\t\t\tinfo->subtype == WRAPPER_SUBTYPE_STRUCTURE_TO_PTR)\n\t\t\t\tencode_klass_ref (acfg, method->klass, p, &p);\n\t\t\telse if (info->subtype == WRAPPER_SUBTYPE_SYNCHRONIZED_INNER)\n\t\t\t\tencode_method_ref (acfg, info->d.synchronized_inner.method, p, &p);\n\t\t\telse if (info->subtype == WRAPPER_SUBTYPE_ARRAY_ACCESSOR)\n\t\t\t\tencode_method_ref (acfg, info->d.array_accessor.method, p, &p);\n\t\t\telse if (info->subtype == WRAPPER_SUBTYPE_INTERP_IN)\n\t\t\t\tencode_signature (acfg, info->d.interp_in.sig, p, &p);\n\t\t\telse if (info->subtype == WRAPPER_SUBTYPE_GSHAREDVT_IN_SIG)\n\t\t\t\tencode_signature (acfg, info->d.gsharedvt.sig, p, &p);\n\t\t\telse if (info->subtype == WRAPPER_SUBTYPE_GSHAREDVT_OUT_SIG)\n\t\t\t\tencode_signature (acfg, info->d.gsharedvt.sig, p, &p);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_MANAGED_TO_NATIVE: {\n\t\t\tg_assert (info);\n\t\t\tencode_value (info->subtype, p, &p);\n\t\t\tif (info->subtype == WRAPPER_SUBTYPE_ICALL_WRAPPER) {\n\t\t\t\tstrcpy ((char*)p, method->name);\n\t\t\t\tp += strlen (method->name) + 1;\n\t\t\t} else if (info->subtype == WRAPPER_SUBTYPE_NATIVE_FUNC_AOT) {\n\t\t\t\tencode_method_ref (acfg, info->d.managed_to_native.method, p, &p);\n\t\t\t} else {\n\t\t\t\tg_assert (info->subtype == WRAPPER_SUBTYPE_NONE || info->subtype == WRAPPER_SUBTYPE_PINVOKE);\n\t\t\t\tencode_method_ref (acfg, info->d.managed_to_native.method, p, &p);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_SYNCHRONIZED: {\n\t\t\tMonoMethod *m;\n\n\t\t\tm = mono_marshal_method_from_wrapper (method);\n\t\t\tg_assert (m);\n\t\t\tg_assert (m != method);\n\t\t\tencode_method_ref (acfg, m, p, &p);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_MANAGED_TO_MANAGED: {\n\t\t\tg_assert (info);\n\t\t\tencode_value (info->subtype, p, &p);\n\n\t\t\tif (info->subtype == WRAPPER_SUBTYPE_ELEMENT_ADDR) {\n\t\t\t\tencode_value (info->d.element_addr.rank, p, &p);\n\t\t\t\tencode_value (info->d.element_addr.elem_size, p, &p);\n\t\t\t} else if (info->subtype == WRAPPER_SUBTYPE_STRING_CTOR) {\n\t\t\t\tencode_method_ref (acfg, info->d.string_ctor.method, p, &p);\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_CASTCLASS: {\n\t\t\tg_assert (info);\n\t\t\tencode_value (info->subtype, p, &p);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_RUNTIME_INVOKE: {\n\t\t\tg_assert (info);\n\t\t\tencode_value (info->subtype, p, &p);\n\t\t\tif (info->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_DIRECT || info->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_VIRTUAL)\n\t\t\t\tencode_method_ref (acfg, info->d.runtime_invoke.method, p, &p);\n\t\t\telse if (info->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_NORMAL)\n\t\t\t\tencode_signature (acfg, info->d.runtime_invoke.sig, p, &p);\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_DELEGATE_INVOKE:\n\t\tcase MONO_WRAPPER_DELEGATE_BEGIN_INVOKE:\n\t\tcase MONO_WRAPPER_DELEGATE_END_INVOKE: {\n\t\t\tif (method->is_inflated) {\n\t\t\t\t/* These wrappers are identified by their class */\n\t\t\t\tencode_value (1, p, &p);\n\t\t\t\tencode_klass_ref (acfg, method->klass, p, &p);\n\t\t\t} else {\n\t\t\t\tMonoMethodSignature *sig = mono_method_signature (method);\n\t\t\t\tWrapperInfo *info = mono_marshal_get_wrapper_info (method);\n\n\t\t\t\tencode_value (0, p, &p);\n\t\t\t\tif (method->wrapper_type == MONO_WRAPPER_DELEGATE_INVOKE)\n\t\t\t\t\tencode_value (info ? info->subtype : 0, p, &p);\n\t\t\t\tencode_signature (acfg, sig, p, &p);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_WRAPPER_NATIVE_TO_MANAGED: {\n\t\t\tg_assert (info);\n\t\t\tencode_method_ref (acfg, info->d.native_to_managed.method, p, &p);\n\t\t\tencode_klass_ref (acfg, info->d.native_to_managed.klass, p, &p);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t} else if (mono_method_signature (method)->is_inflated) {\n\t\t/* \n\t\t * This is a generic method, find the original token which referenced it and\n\t\t * encode that.\n\t\t * Obtain the token from information recorded by the JIT.\n\t\t */\n\t\tji = (MonoJumpInfoToken *)g_hash_table_lookup (acfg->token_info_hash, method);\n\t\tif (ji) {\n\t\t\timage_index = get_image_index (acfg, ji->image);\n\t\t\tg_assert (image_index < MAX_IMAGE_INDEX);\n\t\t\ttoken = ji->token;\n\n\t\t\tencode_value ((MONO_AOT_METHODREF_METHODSPEC << 24), p, &p);\n\t\t\tencode_value (image_index, p, &p);\n\t\t\tencode_value (token, p, &p);\n\t\t} else {\n\t\t\tMonoMethod *declaring;\n\t\t\tMonoGenericContext *context = mono_method_get_context (method);\n\n\t\t\tg_assert (method->is_inflated);\n\t\t\tdeclaring = ((MonoMethodInflated*)method)->declaring;\n\n\t\t\t/*\n\t\t\t * This might be a non-generic method of a generic instance, which \n\t\t\t * doesn't have a token since the reference is generated by the JIT \n\t\t\t * like Nullable:Box/Unbox, or by generic sharing.\n\t\t\t */\n\t\t\tencode_value ((MONO_AOT_METHODREF_GINST << 24), p, &p);\n\t\t\t/* Encode the klass */\n\t\t\tencode_klass_ref (acfg, method->klass, p, &p);\n\t\t\t/* Encode the method */\n\t\t\timage_index = get_image_index (acfg, method->klass->image);\n\t\t\tg_assert (image_index < MAX_IMAGE_INDEX);\n\t\t\tg_assert (declaring->token);\n\t\t\ttoken = declaring->token;\n\t\t\tg_assert (mono_metadata_token_table (token) == MONO_TABLE_METHOD);\n\t\t\tencode_value (image_index, p, &p);\n\t\t\tencode_value (token, p, &p);\n\t\t\tencode_generic_context (acfg, context, p, &p);\n\t\t}\n\t} else if (token == 0) {\n\t\t/* This might be a method of a constructed type like int[,].Set */\n\t\t/* Obtain the token from information recorded by the JIT */\n\t\tji = (MonoJumpInfoToken *)g_hash_table_lookup (acfg->token_info_hash, method);\n\t\tif (ji) {\n\t\t\timage_index = get_image_index (acfg, ji->image);\n\t\t\tg_assert (image_index < MAX_IMAGE_INDEX);\n\t\t\ttoken = ji->token;\n\n\t\t\tencode_value ((MONO_AOT_METHODREF_METHODSPEC << 24), p, &p);\n\t\t\tencode_value (image_index, p, &p);\n\t\t\tencode_value (token, p, &p);\n\t\t} else {\n\t\t\t/* Array methods */\n\t\t\tg_assert (method->klass->rank);\n\n\t\t\t/* Encode directly */\n\t\t\tencode_value ((MONO_AOT_METHODREF_ARRAY << 24), p, &p);\n\t\t\tencode_klass_ref (acfg, method->klass, p, &p);\n\t\t\tif (!strcmp (method->name, \".ctor\") && mono_method_signature (method)->param_count == method->klass->rank)\n\t\t\t\tencode_value (0, p, &p);\n\t\t\telse if (!strcmp (method->name, \".ctor\") && mono_method_signature (method)->param_count == method->klass->rank * 2)\n\t\t\t\tencode_value (1, p, &p);\n\t\t\telse if (!strcmp (method->name, \"Get\"))\n\t\t\t\tencode_value (2, p, &p);\n\t\t\telse if (!strcmp (method->name, \"Address\"))\n\t\t\t\tencode_value (3, p, &p);\n\t\t\telse if (!strcmp (method->name, \"Set\"))\n\t\t\t\tencode_value (4, p, &p);\n\t\t\telse\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\t} else {\n\t\tg_assert (mono_metadata_token_table (token) == MONO_TABLE_METHOD);\n\n\t\tif (image_index >= MONO_AOT_METHODREF_MIN) {\n\t\t\tencode_value ((MONO_AOT_METHODREF_LARGE_IMAGE_INDEX << 24), p, &p);\n\t\t\tencode_value (image_index, p, &p);\n\t\t\tencode_value (mono_metadata_token_index (token), p, &p);\n\t\t} else {\n\t\t\tencode_value ((image_index << 24) | mono_metadata_token_index (token), p, &p);\n\t\t}\n\t}\n\t*endbuf = p;\n}\n\nstatic gint\ncompare_patches (gconstpointer a, gconstpointer b)\n{\n\tint i, j;\n\n\ti = (*(MonoJumpInfo**)a)->ip.i;\n\tj = (*(MonoJumpInfo**)b)->ip.i;\n\n\tif (i < j)\n\t\treturn -1;\n\telse\n\t\tif (i > j)\n\t\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic G_GNUC_UNUSED char*\npatch_to_string (MonoJumpInfo *patch_info)\n{\n\tGString *str;\n\n\tstr = g_string_new (\"\");\n\n\tg_string_append_printf (str, \"%s(\", get_patch_name (patch_info->type));\n\n\tswitch (patch_info->type) {\n\tcase MONO_PATCH_INFO_VTABLE:\n\t\tmono_type_get_desc (str, &patch_info->data.klass->byval_arg, TRUE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tg_string_append_printf (str, \")\");\n\treturn g_string_free (str, FALSE);\n}\n\n/*\n * is_plt_patch:\n *\n *   Return whenever PATCH_INFO refers to a direct call, and thus requires a\n * PLT entry.\n */\nstatic inline gboolean\nis_plt_patch (MonoJumpInfo *patch_info)\n{\n\tswitch (patch_info->type) {\n\tcase MONO_PATCH_INFO_METHOD:\n\tcase MONO_PATCH_INFO_INTERNAL_METHOD:\n\tcase MONO_PATCH_INFO_JIT_ICALL_ADDR:\n\tcase MONO_PATCH_INFO_ICALL_ADDR_CALL:\n\tcase MONO_PATCH_INFO_RGCTX_FETCH:\n\t\treturn TRUE;\n\tdefault:\n\t\treturn FALSE;\n\t}\n}\n\n/*\n * get_plt_symbol:\n *\n *   Return the symbol identifying the plt entry PLT_OFFSET.\n */\nstatic char*\nget_plt_symbol (MonoAotCompile *acfg, int plt_offset, MonoJumpInfo *patch_info)\n{\n#ifdef TARGET_MACH\n\t/* \n\t * The Apple linker reorganizes object files, so it doesn't like branches to local\n\t * labels, since those have no relocations.\n\t */\n\treturn g_strdup_printf (\"%sp_%d\", acfg->llvm_label_prefix, plt_offset);\n#else\n\treturn g_strdup_printf (\"%sp_%d\", acfg->temp_prefix, plt_offset);\n#endif\n}\n\n/*\n * get_plt_entry:\n *\n *   Return a PLT entry which belongs to the method identified by PATCH_INFO.\n */\nstatic MonoPltEntry*\nget_plt_entry (MonoAotCompile *acfg, MonoJumpInfo *patch_info)\n{\n\tMonoPltEntry *res;\n\tgboolean synchronized = FALSE;\n\tstatic int synchronized_symbol_idx;\n\n\tif (!is_plt_patch (patch_info))\n\t\treturn NULL;\n\n\tif (!acfg->patch_to_plt_entry [patch_info->type])\n\t\tacfg->patch_to_plt_entry [patch_info->type] = g_hash_table_new (mono_patch_info_hash, mono_patch_info_equal);\n\tres = (MonoPltEntry *)g_hash_table_lookup (acfg->patch_to_plt_entry [patch_info->type], patch_info);\n\n\tif (!acfg->llvm && patch_info->type == MONO_PATCH_INFO_METHOD && (patch_info->data.method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED)) {\n\t\t/* \n\t\t * Allocate a separate PLT slot for each such patch, since some plt\n\t\t * entries will refer to the method itself, and some will refer to the\n\t\t * wrapper.\n\t\t */\n\t\tres = NULL;\n\t\tsynchronized = TRUE;\n\t}\n\n\tif (!res) {\n\t\tMonoJumpInfo *new_ji;\n\n\t\tnew_ji = mono_patch_info_dup_mp (acfg->mempool, patch_info);\n\n\t\tres = (MonoPltEntry *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoPltEntry));\n\t\tres->plt_offset = acfg->plt_offset;\n\t\tres->ji = new_ji;\n\t\tres->symbol = get_plt_symbol (acfg, res->plt_offset, patch_info);\n\t\tif (acfg->aot_opts.write_symbols)\n\t\t\tres->debug_sym = get_plt_entry_debug_sym (acfg, res->ji, acfg->plt_entry_debug_sym_cache);\n\t\tif (synchronized) {\n\t\t\t/* Avoid duplicate symbols because we don't cache */\n\t\t\tres->symbol = g_strdup_printf (\"%s_%d\", res->symbol, synchronized_symbol_idx);\n\t\t\tif (res->debug_sym)\n\t\t\t\tres->debug_sym = g_strdup_printf (\"%s_%d\", res->debug_sym, synchronized_symbol_idx);\n\t\t\tsynchronized_symbol_idx ++;\n\t\t}\n\t\tif (res->debug_sym)\n\t\t\tres->llvm_symbol = g_strdup_printf (\"%s_%s_llvm\", res->symbol, res->debug_sym);\n\t\telse\n\t\t\tres->llvm_symbol = g_strdup_printf (\"%s_llvm\", res->symbol);\n\n\t\tg_hash_table_insert (acfg->patch_to_plt_entry [new_ji->type], new_ji, res);\n\n\t\tg_hash_table_insert (acfg->plt_offset_to_entry, GUINT_TO_POINTER (res->plt_offset), res);\n\n\t\t//g_assert (mono_patch_info_equal (patch_info, new_ji));\n\t\t//mono_print_ji (patch_info); printf (\"\\n\");\n\t\t//g_hash_table_print_stats (acfg->patch_to_plt_entry);\n\n\t\tacfg->plt_offset ++;\n\t}\n\n\treturn res;\n}\n\n/**\n * get_got_offset:\n *\n *   Returns the offset of the GOT slot where the runtime object resulting from resolving\n * JI could be found if it exists, otherwise allocates a new one.\n */\nstatic guint32\nget_got_offset (MonoAotCompile *acfg, gboolean llvm, MonoJumpInfo *ji)\n{\n\tguint32 got_offset;\n\tGotInfo *info = llvm ? &acfg->llvm_got_info : &acfg->got_info;\n\n\tgot_offset = GPOINTER_TO_UINT (g_hash_table_lookup (info->patch_to_got_offset_by_type [ji->type], ji));\n\tif (got_offset)\n\t\treturn got_offset - 1;\n\n\tif (llvm) {\n\t\tgot_offset = acfg->llvm_got_offset;\n\t\tacfg->llvm_got_offset ++;\n\t} else {\n\t\tgot_offset = acfg->got_offset;\n\t\tacfg->got_offset ++;\n\t}\n\n\tacfg->stats.got_slots ++;\n\tacfg->stats.got_slot_types [ji->type] ++;\n\n\tg_hash_table_insert (info->patch_to_got_offset, ji, GUINT_TO_POINTER (got_offset + 1));\n\tg_hash_table_insert (info->patch_to_got_offset_by_type [ji->type], ji, GUINT_TO_POINTER (got_offset + 1));\n\tg_ptr_array_add (info->got_patches, ji);\n\n\treturn got_offset;\n}\n\n/* Add a method to the list of methods which need to be emitted */\nstatic void\nadd_method_with_index (MonoAotCompile *acfg, MonoMethod *method, int index, gboolean extra)\n{\n\tg_assert (method);\n\tif (!g_hash_table_lookup (acfg->method_indexes, method)) {\n\t\tg_ptr_array_add (acfg->methods, method);\n\t\tg_hash_table_insert (acfg->method_indexes, method, GUINT_TO_POINTER (index + 1));\n\t\tacfg->nmethods = acfg->methods->len + 1;\n\t}\n\n\tif (method->wrapper_type || extra)\n\t\tg_ptr_array_add (acfg->extra_methods, method);\n}\n\nstatic gboolean\nprefer_gsharedvt_method (MonoAotCompile *acfg, MonoMethod *method)\n{\n\t/* One instantiation with valuetypes is generated for each async method */\n\tif (method->klass->image == mono_defaults.corlib && (!strcmp (method->klass->name, \"AsyncMethodBuilderCore\") || !strcmp (method->klass->name, \"AsyncVoidMethodBuilder\")))\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}\n\nstatic guint32\nget_method_index (MonoAotCompile *acfg, MonoMethod *method)\n{\n\tint index = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->method_indexes, method));\n\t\n\tg_assert (index);\n\n\treturn index - 1;\n}\n\nstatic int\nadd_method_full (MonoAotCompile *acfg, MonoMethod *method, gboolean extra, int depth)\n{\n\tint index;\n\n\tindex = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->method_indexes, method));\n\tif (index)\n\t\treturn index - 1;\n\n\tindex = acfg->method_index;\n\tadd_method_with_index (acfg, method, index, extra);\n\n\tg_ptr_array_add (acfg->method_order, GUINT_TO_POINTER (index));\n\n\tg_hash_table_insert (acfg->method_depth, method, GUINT_TO_POINTER (depth));\n\n\tacfg->method_index ++;\n\n\treturn index;\n}\n\nstatic int\nadd_method (MonoAotCompile *acfg, MonoMethod *method)\n{\n\treturn add_method_full (acfg, method, FALSE, 0);\n}\n\nstatic void\nmono_dedup_cache_method (MonoAotCompile *acfg, MonoMethod *method)\n{\n\tg_assert (acfg->dedup_stats);\n\n\tchar *name = mono_aot_get_mangled_method_name (method);\n\tg_assert (name);\n\n\t// For stats\n\tchar *stats_name = g_strdup (name);\n\n\tg_assert (acfg->dedup_cache);\n\n\tif (!g_hash_table_lookup (acfg->dedup_cache, name)) {\n\t\t// This AOTCompile owns this method\n\t\t// We do this to decide whether to write it to disk\n\t\t// during a dedup run (first phase, where we skip).\n\t\t//\n\t\t// If never changed, then maybe can avoid a recompile\n\t\t// of the cache.\n\t\t//\n\t\t// Files not read in during last phase.\n\t\tacfg->dedup_cache_changed = TRUE;\n\n\t\t// owns name\n\t\tg_hash_table_insert (acfg->dedup_cache, name, method);\n\t} else {\n\t\t// owns name\n\t\tg_free (name);\n\t}\n\n\tguint count = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->dedup_stats, stats_name));\n\tcount++;\n\tg_hash_table_insert (acfg->dedup_stats, stats_name, GUINT_TO_POINTER (count));\n}\n\nstatic void\nadd_extra_method_with_depth (MonoAotCompile *acfg, MonoMethod *method, int depth)\n{\n\tif (mono_method_is_generic_sharable_full (method, TRUE, TRUE, FALSE))\n\t\tmethod = mini_get_shared_method (method);\n\telse if ((acfg->opts & MONO_OPT_GSHAREDVT) && prefer_gsharedvt_method (acfg, method) && mono_method_is_generic_sharable_full (method, FALSE, FALSE, TRUE))\n\t\t/* Use the gsharedvt version */\n\t\tmethod = mini_get_shared_method_full (method, TRUE, TRUE);\n\n\tif ((acfg->aot_opts.dedup || acfg->aot_opts.dedup_include) && mono_aot_can_dedup (method)) {\n\t\tmono_dedup_cache_method (acfg, method);\n\n\t\tif (!acfg->dedup_emit_mode)\n\t\t\treturn;\n\t}\n\n\tif (acfg->aot_opts.log_generics)\n\t\taot_printf (acfg, \"%*sAdding method %s.\\n\", depth, \"\", mono_method_get_full_name (method));\n\n\tadd_method_full (acfg, method, TRUE, depth);\n}\n\nstatic void\nadd_extra_method (MonoAotCompile *acfg, MonoMethod *method)\n{\n\tadd_extra_method_with_depth (acfg, method, 0);\n}\n\nstatic void\nadd_jit_icall_wrapper (gpointer key, gpointer value, gpointer user_data)\n{\n\tMonoAotCompile *acfg = (MonoAotCompile *)user_data;\n\tMonoJitICallInfo *callinfo = (MonoJitICallInfo *)value;\n\tMonoMethod *wrapper;\n\tchar *name;\n\n\tif (!callinfo->sig)\n\t\treturn;\n\n\tname = g_strdup_printf (\"__icall_wrapper_%s\", callinfo->name);\n\twrapper = mono_marshal_get_icall_wrapper (callinfo->sig, name, callinfo->func, TRUE);\n\tg_free (name);\n\n\tadd_method (acfg, wrapper);\n}\n\nstatic MonoMethod*\nget_runtime_invoke_sig (MonoMethodSignature *sig)\n{\n\tMonoMethodBuilder *mb;\n\tMonoMethod *m;\n\n\tmb = mono_mb_new (mono_defaults.object_class, \"FOO\", MONO_WRAPPER_NONE);\n\tm = mono_mb_create_method (mb, sig, 16);\n\tMonoMethod *invoke = mono_marshal_get_runtime_invoke (m, FALSE);\n\tmono_mb_free (mb);\n\treturn invoke;\n}\n\nstatic MonoMethod*\nget_runtime_invoke (MonoAotCompile *acfg, MonoMethod *method, gboolean virtual_)\n{\n\treturn mono_marshal_get_runtime_invoke (method, virtual_);\n}\n\nstatic gboolean\ncan_marshal_struct (MonoClass *klass)\n{\n\tMonoClassField *field;\n\tgboolean can_marshal = TRUE;\n\tgpointer iter = NULL;\n\tMonoMarshalType *info;\n\tint i;\n\n\tif (mono_class_is_auto_layout (klass))\n\t\treturn FALSE;\n\n\tinfo = mono_marshal_load_type_info (klass);\n\n\t/* Only allow a few field types to avoid asserts in the marshalling code */\n\twhile ((field = mono_class_get_fields (klass, &iter))) {\n\t\tif ((field->type->attrs & FIELD_ATTRIBUTE_STATIC))\n\t\t\tcontinue;\n\n\t\tswitch (field->type->type) {\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_U1:\n\t\tcase MONO_TYPE_BOOLEAN:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_U8:\n\t\tcase MONO_TYPE_I:\n\t\tcase MONO_TYPE_U:\n\t\tcase MONO_TYPE_PTR:\n\t\tcase MONO_TYPE_R4:\n\t\tcase MONO_TYPE_R8:\n\t\tcase MONO_TYPE_STRING:\n\t\t\tbreak;\n\t\tcase MONO_TYPE_VALUETYPE:\n\t\t\tif (!mono_class_from_mono_type (field->type)->enumtype && !can_marshal_struct (mono_class_from_mono_type (field->type)))\n\t\t\t\tcan_marshal = FALSE;\n\t\t\tbreak;\n\t\tcase MONO_TYPE_SZARRAY: {\n\t\t\tgboolean has_mspec = FALSE;\n\n\t\t\tif (info) {\n\t\t\t\tfor (i = 0; i < info->num_fields; ++i) {\n\t\t\t\t\tif (info->fields [i].field == field && info->fields [i].mspec)\n\t\t\t\t\t\thas_mspec = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!has_mspec)\n\t\t\t\tcan_marshal = FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tcan_marshal = FALSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Special cases */\n\t/* Its hard to compute whenever these can be marshalled or not */\n\tif (!strcmp (klass->name_space, \"System.Net.NetworkInformation.MacOsStructs\") && strcmp (klass->name, \"sockaddr_dl\"))\n\t\treturn TRUE;\n\n\treturn can_marshal;\n}\n\nstatic void\ncreate_gsharedvt_inst (MonoAotCompile *acfg, MonoMethod *method, MonoGenericContext *ctx)\n{\n\t/* Create a vtype instantiation */\n\tMonoGenericContext shared_context;\n\tMonoType **args;\n\tMonoGenericInst *inst;\n\tMonoGenericContainer *container;\n\tMonoClass **constraints;\n\tint i;\n\n\tmemset (ctx, 0, sizeof (MonoGenericContext));\n\n\tif (mono_class_is_gtd (method->klass)) {\n\t\tshared_context = mono_class_get_generic_container (method->klass)->context;\n\t\tinst = shared_context.class_inst;\n\n\t\targs = g_new0 (MonoType*, inst->type_argc);\n\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\targs [i] = &mono_defaults.int_class->byval_arg;\n\t\t}\n\t\tctx->class_inst = mono_metadata_get_generic_inst (inst->type_argc, args);\n\t}\n\tif (method->is_generic) {\n\t\tcontainer = mono_method_get_generic_container (method);\n\t\tshared_context = container->context;\n\t\tinst = shared_context.method_inst;\n\n\t\targs = g_new0 (MonoType*, inst->type_argc);\n\t\tfor (i = 0; i < container->type_argc; ++i) {\n\t\t\tMonoGenericParamInfo *info = &container->type_params [i].info;\n\t\t\tgboolean ref_only = FALSE;\n\n\t\t\tif (info && info->constraints) {\n\t\t\t\tconstraints = info->constraints;\n\n\t\t\t\twhile (*constraints) {\n\t\t\t\t\tMonoClass *cklass = *constraints;\n\t\t\t\t\tif (!(cklass == mono_defaults.object_class || (cklass->image == mono_defaults.corlib && !strcmp (cklass->name, \"ValueType\"))))\n\t\t\t\t\t\t/* Inflaring the method with our vtype would not be valid */\n\t\t\t\t\t\tref_only = TRUE;\n\t\t\t\t\tconstraints ++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ref_only)\n\t\t\t\targs [i] = &mono_defaults.object_class->byval_arg;\n\t\t\telse\n\t\t\t\targs [i] = &mono_defaults.int_class->byval_arg;\n\t\t}\n\t\tctx->method_inst = mono_metadata_get_generic_inst (inst->type_argc, args);\n\t}\n}\n\nstatic void\nadd_wrappers (MonoAotCompile *acfg)\n{\n\tMonoMethod *method, *m;\n\tint i, j;\n\tMonoMethodSignature *sig, *csig;\n\tguint32 token;\n\n\t/* \n\t * FIXME: Instead of AOTing all the wrappers, it might be better to redesign them\n\t * so there is only one wrapper of a given type, or inlining their contents into their\n\t * callers.\n\t */\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_METHOD].rows; ++i) {\n\t\tMonoError error;\n\t\tMonoMethod *method;\n\t\tguint32 token = MONO_TOKEN_METHOD_DEF | (i + 1);\n\t\tgboolean skip = FALSE;\n\n\t\tmethod = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);\n\t\treport_loader_error (acfg, &error, TRUE, \"Failed to load method token 0x%x due to %s\\n\", i, mono_error_get_message (&error));\n\n\t\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t\t(method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) ||\n\t\t\t(method->flags & METHOD_ATTRIBUTE_ABSTRACT))\n\t\t\tskip = TRUE;\n\n\t\t/* Skip methods which can not be handled by get_runtime_invoke () */\n\t\tsig = mono_method_signature (method);\n\t\tif (!sig)\n\t\t\tcontinue;\n\t\tif ((sig->ret->type == MONO_TYPE_PTR) ||\n\t\t\t(sig->ret->type == MONO_TYPE_TYPEDBYREF))\n\t\t\tskip = TRUE;\n\t\tif (mono_class_is_open_constructed_type (sig->ret))\n\t\t\tskip = TRUE;\n\n\t\tfor (j = 0; j < sig->param_count; j++) {\n\t\t\tif (sig->params [j]->type == MONO_TYPE_TYPEDBYREF)\n\t\t\t\tskip = TRUE;\n\t\t\tif (mono_class_is_open_constructed_type (sig->params [j]))\n\t\t\t\tskip = TRUE;\n\t\t}\n\n#ifdef MONO_ARCH_DYN_CALL_SUPPORTED\n\t\tif (!mono_class_is_contextbound (method->klass)) {\n\t\t\tMonoDynCallInfo *info = mono_arch_dyn_call_prepare (sig);\n\t\t\tgboolean has_nullable = FALSE;\n\n\t\t\tfor (j = 0; j < sig->param_count; j++) {\n\t\t\t\tif (sig->params [j]->type == MONO_TYPE_GENERICINST && mono_class_is_nullable (mono_class_from_mono_type (sig->params [j])))\n\t\t\t\t\thas_nullable = TRUE;\n\t\t\t}\n\n\t\t\tif (info && !has_nullable && !acfg->aot_opts.llvm_only) {\n\t\t\t\t/* Supported by the dynamic runtime-invoke wrapper */\n\t\t\t\tskip = TRUE;\n\t\t\t}\n\t\t\tif (info)\n\t\t\t\tmono_arch_dyn_call_free (info);\n\t\t}\n#endif\n\n\t\tif (acfg->aot_opts.llvm_only)\n\t\t\t/* Supported by the gsharedvt based runtime-invoke wrapper */\n\t\t\tskip = TRUE;\n\n\t\tif (!skip) {\n\t\t\t//printf (\"%s\\n\", mono_method_full_name (method, TRUE));\n\t\t\tadd_method (acfg, get_runtime_invoke (acfg, method, FALSE));\n\t\t}\n \t}\n\n\tif (strcmp (acfg->image->assembly->aname.name, \"mscorlib\") == 0) {\n\t\tint nallocators;\n\n\t\t/* Runtime invoke wrappers */\n\n\t\t/* void runtime-invoke () [.cctor] */\n\t\tcsig = mono_metadata_signature_alloc (mono_defaults.corlib, 0);\n\t\tcsig->ret = &mono_defaults.void_class->byval_arg;\n\t\tadd_method (acfg, get_runtime_invoke_sig (csig));\n\n\t\t/* void runtime-invoke () [Finalize] */\n\t\tcsig = mono_metadata_signature_alloc (mono_defaults.corlib, 0);\n\t\tcsig->hasthis = 1;\n\t\tcsig->ret = &mono_defaults.void_class->byval_arg;\n\t\tadd_method (acfg, get_runtime_invoke_sig (csig));\n\n\t\t/* void runtime-invoke (string) [exception ctor] */\n\t\tcsig = mono_metadata_signature_alloc (mono_defaults.corlib, 1);\n\t\tcsig->hasthis = 1;\n\t\tcsig->ret = &mono_defaults.void_class->byval_arg;\n\t\tcsig->params [0] = &mono_defaults.string_class->byval_arg;\n\t\tadd_method (acfg, get_runtime_invoke_sig (csig));\n\n\t\t/* void runtime-invoke (string, string) [exception ctor] */\n\t\tcsig = mono_metadata_signature_alloc (mono_defaults.corlib, 2);\n\t\tcsig->hasthis = 1;\n\t\tcsig->ret = &mono_defaults.void_class->byval_arg;\n\t\tcsig->params [0] = &mono_defaults.string_class->byval_arg;\n\t\tcsig->params [1] = &mono_defaults.string_class->byval_arg;\n\t\tadd_method (acfg, get_runtime_invoke_sig (csig));\n\n\t\t/* string runtime-invoke () [Exception.ToString ()] */\n\t\tcsig = mono_metadata_signature_alloc (mono_defaults.corlib, 0);\n\t\tcsig->hasthis = 1;\n\t\tcsig->ret = &mono_defaults.string_class->byval_arg;\n\t\tadd_method (acfg, get_runtime_invoke_sig (csig));\n\n\t\t/* void runtime-invoke (string, Exception) [exception ctor] */\n\t\tcsig = mono_metadata_signature_alloc (mono_defaults.corlib, 2);\n\t\tcsig->hasthis = 1;\n\t\tcsig->ret = &mono_defaults.void_class->byval_arg;\n\t\tcsig->params [0] = &mono_defaults.string_class->byval_arg;\n\t\tcsig->params [1] = &mono_defaults.exception_class->byval_arg;\n\t\tadd_method (acfg, get_runtime_invoke_sig (csig));\n\n\t\t/* Assembly runtime-invoke (string, Assembly, bool) [DoAssemblyResolve] */\n\t\tcsig = mono_metadata_signature_alloc (mono_defaults.corlib, 3);\n\t\tcsig->hasthis = 1;\n\t\tcsig->ret = &(mono_class_load_from_name (\n\t\t\t\t\t\t\t\t\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Assembly\"))->byval_arg;\n\t\tcsig->params [0] = &mono_defaults.string_class->byval_arg;\n\t\tcsig->params [1] = &(mono_class_load_from_name (mono_defaults.corlib, \"System.Reflection\", \"Assembly\"))->byval_arg;\n\t\tcsig->params [2] = &mono_defaults.boolean_class->byval_arg;\n\t\tadd_method (acfg, get_runtime_invoke_sig (csig));\n\n\t\t/* runtime-invoke used by finalizers */\n\t\tadd_method (acfg, get_runtime_invoke (acfg, mono_class_get_method_from_name_flags (mono_defaults.object_class, \"Finalize\", 0, 0), TRUE));\n\n\t\t/* This is used by mono_runtime_capture_context () */\n\t\tmethod = mono_get_context_capture_method ();\n\t\tif (method)\n\t\t\tadd_method (acfg, get_runtime_invoke (acfg, method, FALSE));\n\n#ifdef MONO_ARCH_DYN_CALL_SUPPORTED\n\t\tif (!acfg->aot_opts.llvm_only)\n\t\t\tadd_method (acfg, mono_marshal_get_runtime_invoke_dynamic ());\n#endif\n\n\t\t/* These are used by mono_jit_runtime_invoke () to calls gsharedvt out wrappers */\n\t\tif (acfg->aot_opts.llvm_only) {\n\t\t\tint variants;\n\n\t\t\t/* Create simplified signatures which match the signature used by the gsharedvt out wrappers */\n\t\t\tfor (variants = 0; variants < 4; ++variants) {\n\t\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\t\tsig = mini_get_gsharedvt_out_sig_wrapper_signature ((variants & 1) > 0, (variants & 2) > 0, i);\n\t\t\t\t\tadd_extra_method (acfg, mono_marshal_get_runtime_invoke_for_sig (sig));\n\n\t\t\t\t\tg_free (sig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* stelemref */\n\t\tadd_method (acfg, mono_marshal_get_stelemref ());\n\n\t\t/* Managed Allocators */\n\t\tnallocators = mono_gc_get_managed_allocator_types ();\n\t\tfor (i = 0; i < nallocators; ++i) {\n\t\t\tif ((m = mono_gc_get_managed_allocator_by_type (i, MANAGED_ALLOCATOR_REGULAR)))\n\t\t\t\tadd_method (acfg, m);\n\t\t\tif ((m = mono_gc_get_managed_allocator_by_type (i, MANAGED_ALLOCATOR_SLOW_PATH)))\n\t\t\t\tadd_method (acfg, m);\n\t\t\tif ((m = mono_gc_get_managed_allocator_by_type (i, MANAGED_ALLOCATOR_PROFILER)))\n\t\t\t\tadd_method (acfg, m);\n\t\t}\n\n\t\t/* write barriers */\n\t\tif (mono_gc_is_moving ()) {\n\t\t\tadd_method (acfg, mono_gc_get_specific_write_barrier (FALSE));\n\t\t\tadd_method (acfg, mono_gc_get_specific_write_barrier (TRUE));\n\t\t}\n\n\t\t/* Stelemref wrappers */\n\t\t{\n\t\t\tMonoMethod **wrappers;\n\t\t\tint nwrappers;\n\n\t\t\twrappers = mono_marshal_get_virtual_stelemref_wrappers (&nwrappers);\n\t\t\tfor (i = 0; i < nwrappers; ++i)\n\t\t\t\tadd_method (acfg, wrappers [i]);\n\t\t\tg_free (wrappers);\n\t\t}\n\n\t\t/* castclass_with_check wrapper */\n\t\tadd_method (acfg, mono_marshal_get_castclass_with_cache ());\n\t\t/* isinst_with_check wrapper */\n\t\tadd_method (acfg, mono_marshal_get_isinst_with_cache ());\n\n\t\t/* JIT icall wrappers */\n\t\t/* FIXME: locking - this is \"safe\" as full-AOT threads don't mutate the icall hash*/\n\t\tg_hash_table_foreach (mono_get_jit_icall_info (), add_jit_icall_wrapper, acfg);\n\t}\n\n\t/* \n\t * remoting-invoke-with-check wrappers are very frequent, so avoid emitting them,\n\t * we use the original method instead at runtime.\n\t * Since full-aot doesn't support remoting, this is not a problem.\n\t */\n#if 0\n\t/* remoting-invoke wrappers */\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_METHOD].rows; ++i) {\n\t\tMonoError error;\n\t\tMonoMethodSignature *sig;\n\t\t\n\t\ttoken = MONO_TOKEN_METHOD_DEF | (i + 1);\n\t\tmethod = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);\n\t\tg_assert (mono_error_ok (&error)); /* FIXME don't swallow the error */\n\n\t\tsig = mono_method_signature (method);\n\n\t\tif (sig->hasthis && (method->klass->marshalbyref || method->klass == mono_defaults.object_class)) {\n\t\t\tm = mono_marshal_get_remoting_invoke_with_check (method);\n\n\t\t\tadd_method (acfg, m);\n\t\t}\n\t}\n#endif\n\n\t/* delegate-invoke wrappers */\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_TYPEDEF].rows; ++i) {\n\t\tMonoError error;\n\t\tMonoClass *klass;\n\t\tMonoCustomAttrInfo *cattr;\n\t\t\n\t\ttoken = MONO_TOKEN_TYPE_DEF | (i + 1);\n\t\tklass = mono_class_get_checked (acfg->image, token, &error);\n\n\t\tif (!klass) {\n\t\t\tmono_error_cleanup (&error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!klass->delegate || klass == mono_defaults.delegate_class || klass == mono_defaults.multicastdelegate_class)\n\t\t\tcontinue;\n\n\t\tif (!mono_class_is_gtd (klass)) {\n\t\t\tmethod = mono_get_delegate_invoke (klass);\n\n\t\t\tm = mono_marshal_get_delegate_invoke (method, NULL);\n\n\t\t\tadd_method (acfg, m);\n\n\t\t\tmethod = mono_class_get_method_from_name_flags (klass, \"BeginInvoke\", -1, 0);\n\t\t\tif (method)\n\t\t\t\tadd_method (acfg, mono_marshal_get_delegate_begin_invoke (method));\n\n\t\t\tmethod = mono_class_get_method_from_name_flags (klass, \"EndInvoke\", -1, 0);\n\t\t\tif (method)\n\t\t\t\tadd_method (acfg, mono_marshal_get_delegate_end_invoke (method));\n\n\t\t\tcattr = mono_custom_attrs_from_class_checked (klass, &error);\n\t\t\tif (!is_ok (&error)) {\n\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cattr) {\n\t\t\t\tint j;\n\n\t\t\t\tfor (j = 0; j < cattr->num_attrs; ++j)\n\t\t\t\t\tif (cattr->attrs [j].ctor && (!strcmp (cattr->attrs [j].ctor->klass->name, \"MonoNativeFunctionWrapperAttribute\") || !strcmp (cattr->attrs [j].ctor->klass->name, \"UnmanagedFunctionPointerAttribute\")))\n\t\t\t\t\t\tbreak;\n\t\t\t\tif (j < cattr->num_attrs) {\n\t\t\t\t\tMonoMethod *invoke;\n\t\t\t\t\tMonoMethod *wrapper;\n\t\t\t\t\tMonoMethod *del_invoke;\n\n\t\t\t\t\t/* Add wrappers needed by mono_ftnptr_to_delegate () */\n\t\t\t\t\tinvoke = mono_get_delegate_invoke (klass);\n\t\t\t\t\twrapper = mono_marshal_get_native_func_wrapper_aot (klass);\n\t\t\t\t\tdel_invoke = mono_marshal_get_delegate_invoke_internal (invoke, FALSE, TRUE, wrapper);\n\t\t\t\t\tadd_method (acfg, wrapper);\n\t\t\t\t\tadd_method (acfg, del_invoke);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ((acfg->opts & MONO_OPT_GSHAREDVT) && mono_class_is_gtd (klass)) {\n\t\t\tMonoError error;\n\t\t\tMonoGenericContext ctx;\n\t\t\tMonoMethod *inst, *gshared;\n\n\t\t\t/*\n\t\t\t * Emit gsharedvt versions of the generic delegate-invoke wrappers\n\t\t\t */\n\t\t\t/* Invoke */\n\t\t\tmethod = mono_get_delegate_invoke (klass);\n\t\t\tcreate_gsharedvt_inst (acfg, method, &ctx);\n\n\t\t\tinst = mono_class_inflate_generic_method_checked (method, &ctx, &error);\n\t\t\tg_assert (mono_error_ok (&error)); /* FIXME don't swallow the error */\n\n\t\t\tm = mono_marshal_get_delegate_invoke (inst, NULL);\n\t\t\tg_assert (m->is_inflated);\n\n\t\t\tgshared = mini_get_shared_method_full (m, FALSE, TRUE);\n\t\t\tadd_extra_method (acfg, gshared);\n\n\t\t\t/* begin-invoke */\n\t\t\tmethod = mono_get_delegate_begin_invoke (klass);\n\t\t\tif (method) {\n\t\t\t\tcreate_gsharedvt_inst (acfg, method, &ctx);\n\n\t\t\t\tinst = mono_class_inflate_generic_method_checked (method, &ctx, &error);\n\t\t\t\tg_assert (mono_error_ok (&error)); /* FIXME don't swallow the error */\n\n\t\t\t\tm = mono_marshal_get_delegate_begin_invoke (inst);\n\t\t\t\tg_assert (m->is_inflated);\n\n\t\t\t\tgshared = mini_get_shared_method_full (m, FALSE, TRUE);\n\t\t\t\tadd_extra_method (acfg, gshared);\n\t\t\t}\n\n\t\t\t/* end-invoke */\n\t\t\tmethod = mono_get_delegate_end_invoke (klass);\n\t\t\tif (method) {\n\t\t\t\tcreate_gsharedvt_inst (acfg, method, &ctx);\n\n\t\t\t\tinst = mono_class_inflate_generic_method_checked (method, &ctx, &error);\n\t\t\t\tg_assert (mono_error_ok (&error)); /* FIXME don't swallow the error */\n\n\t\t\t\tm = mono_marshal_get_delegate_end_invoke (inst);\n\t\t\t\tg_assert (m->is_inflated);\n\n\t\t\t\tgshared = mini_get_shared_method_full (m, FALSE, TRUE);\n\t\t\t\tadd_extra_method (acfg, gshared);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* array access wrappers */\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_TYPESPEC].rows; ++i) {\n\t\tMonoError error;\n\t\tMonoClass *klass;\n\t\t\n\t\ttoken = MONO_TOKEN_TYPE_SPEC | (i + 1);\n\t\tklass = mono_class_get_checked (acfg->image, token, &error);\n\n\t\tif (!klass) {\n\t\t\tmono_error_cleanup (&error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (klass->rank && MONO_TYPE_IS_PRIMITIVE (&klass->element_class->byval_arg)) {\n\t\t\tMonoMethod *m, *wrapper;\n\n\t\t\t/* Add runtime-invoke wrappers too */\n\n\t\t\tm = mono_class_get_method_from_name (klass, \"Get\", -1);\n\t\t\tg_assert (m);\n\t\t\twrapper = mono_marshal_get_array_accessor_wrapper (m);\n\t\t\tadd_extra_method (acfg, wrapper);\n\t\t\tif (!acfg->aot_opts.llvm_only)\n\t\t\t\tadd_extra_method (acfg, get_runtime_invoke (acfg, wrapper, FALSE));\n\n\t\t\tm = mono_class_get_method_from_name (klass, \"Set\", -1);\n\t\t\tg_assert (m);\n\t\t\twrapper = mono_marshal_get_array_accessor_wrapper (m);\n\t\t\tadd_extra_method (acfg, wrapper);\n\t\t\tif (!acfg->aot_opts.llvm_only)\n\t\t\t\tadd_extra_method (acfg, get_runtime_invoke (acfg, wrapper, FALSE));\n\t\t}\n\t}\n\n\t/* Synchronized wrappers */\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_METHOD].rows; ++i) {\n\t\tMonoError error;\n\t\ttoken = MONO_TOKEN_METHOD_DEF | (i + 1);\n\t\tmethod = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);\n\t\treport_loader_error (acfg, &error, TRUE, \"Failed to load method token 0x%x due to %s\\n\", i, mono_error_get_message (&error));\n\n\t\tif (method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED) {\n\t\t\tif (method->is_generic) {\n\t\t\t\t// FIXME:\n\t\t\t} else if ((acfg->opts & MONO_OPT_GSHAREDVT) && mono_class_is_gtd (method->klass)) {\n\t\t\t\tMonoError error;\n\t\t\t\tMonoGenericContext ctx;\n\t\t\t\tMonoMethod *inst, *gshared, *m;\n\n\t\t\t\t/*\n\t\t\t\t * Create a generic wrapper for a generic instance, and AOT that.\n\t\t\t\t */\n\t\t\t\tcreate_gsharedvt_inst (acfg, method, &ctx);\n\t\t\t\tinst = mono_class_inflate_generic_method_checked (method, &ctx, &error);\n\t\t\t\tg_assert (mono_error_ok (&error)); /* FIXME don't swallow the error */\n\t\t\t\tm = mono_marshal_get_synchronized_wrapper (inst);\n\t\t\t\tg_assert (m->is_inflated);\n\t\t\t\tgshared = mini_get_shared_method_full (m, FALSE, TRUE);\n\t\t\t\tadd_method (acfg, gshared);\n\t\t\t} else {\n\t\t\t\tadd_method (acfg, mono_marshal_get_synchronized_wrapper (method));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* pinvoke wrappers */\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_METHOD].rows; ++i) {\n\t\tMonoError error;\n\t\tMonoMethod *method;\n\t\tguint32 token = MONO_TOKEN_METHOD_DEF | (i + 1);\n\n\t\tmethod = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);\n\t\treport_loader_error (acfg, &error, TRUE, \"Failed to load method token 0x%x due to %s\\n\", i, mono_error_get_message (&error));\n\n\t\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t\t(method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL)) {\n\t\t\tadd_method (acfg, mono_marshal_get_native_wrapper (method, TRUE, TRUE));\n\t\t}\n\n\t\tif (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\t\tif (acfg->aot_opts.llvm_only) {\n\t\t\t\t/* The wrappers have a different signature (hasthis is not set) so need to add this too */\n\t\t\t\tadd_gsharedvt_wrappers (acfg, mono_method_signature (method), FALSE, TRUE);\n\t\t\t}\n\t\t}\n\t}\n \n\t/* native-to-managed wrappers */\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_METHOD].rows; ++i) {\n\t\tMonoError error;\n\t\tMonoMethod *method;\n\t\tguint32 token = MONO_TOKEN_METHOD_DEF | (i + 1);\n\t\tMonoCustomAttrInfo *cattr;\n\t\tint j;\n\n\t\tmethod = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);\n\t\treport_loader_error (acfg, &error, TRUE, \"Failed to load method token 0x%x due to %s\\n\", i, mono_error_get_message (&error));\n\n\t\t/* \n\t\t * Only generate native-to-managed wrappers for methods which have an\n\t\t * attribute named MonoPInvokeCallbackAttribute. We search for the attribute by\n\t\t * name to avoid defining a new assembly to contain it.\n\t\t */\n\t\tcattr = mono_custom_attrs_from_method_checked (method, &error);\n\t\tif (!is_ok (&error)) {\n\t\t\tchar *name = mono_method_get_full_name (method);\n\t\t\treport_loader_error (acfg, &error, TRUE, \"Failed to load custom attributes from method %s due to %s\\n\", name, mono_error_get_message (&error));\n\t\t\tg_free (name);\n\t\t}\n\n\t\tif (cattr) {\n\t\t\tfor (j = 0; j < cattr->num_attrs; ++j)\n\t\t\t\tif (cattr->attrs [j].ctor && !strcmp (cattr->attrs [j].ctor->klass->name, \"MonoPInvokeCallbackAttribute\"))\n\t\t\t\t\tbreak;\n\t\t\tif (j < cattr->num_attrs) {\n\t\t\t\tMonoCustomAttrEntry *e = &cattr->attrs [j];\n\t\t\t\tMonoMethodSignature *sig = mono_method_signature (e->ctor);\n\t\t\t\tconst char *p = (const char*)e->data;\n\t\t\t\tconst char *named;\n\t\t\t\tint slen, num_named, named_type;\n\t\t\t\tchar *n;\n\t\t\t\tMonoType *t;\n\t\t\t\tMonoClass *klass;\n\t\t\t\tchar *export_name = NULL;\n\t\t\t\tMonoMethod *wrapper;\n\n\t\t\t\t/* this cannot be enforced by the C# compiler so we must give the user some warning before aborting */\n\t\t\t\tif (!(method->flags & METHOD_ATTRIBUTE_STATIC)) {\n\t\t\t\t\tg_warning (\"AOT restriction: Method '%s' must be static since it is decorated with [MonoPInvokeCallback]. See http://ios.xamarin.com/Documentation/Limitations#Reverse_Callbacks\", \n\t\t\t\t\t\tmono_method_full_name (method, TRUE));\n\t\t\t\t\texit (1);\n\t\t\t\t}\n\n\t\t\t\tg_assert (sig->param_count == 1);\n\t\t\t\tg_assert (sig->params [0]->type == MONO_TYPE_CLASS && !strcmp (mono_class_from_mono_type (sig->params [0])->name, \"Type\"));\n\n\t\t\t\t/* \n\t\t\t\t * Decode the cattr manually since we can't create objects\n\t\t\t\t * during aot compilation.\n\t\t\t\t */\n\t\t\t\t\t\n\t\t\t\t/* Skip prolog */\n\t\t\t\tp += 2;\n\n\t\t\t\t/* From load_cattr_value () in reflection.c */\n\t\t\t\tslen = mono_metadata_decode_value (p, &p);\n\t\t\t\tn = (char *)g_memdup (p, slen + 1);\n\t\t\t\tn [slen] = 0;\n\t\t\t\tt = mono_reflection_type_from_name_checked (n, acfg->image, &error);\n\t\t\t\tg_assert (t);\n\t\t\t\tmono_error_assert_ok (&error);\n\t\t\t\tg_free (n);\n\n\t\t\t\tklass = mono_class_from_mono_type (t);\n\t\t\t\tg_assert (klass->parent == mono_defaults.multicastdelegate_class);\n\n\t\t\t\tp += slen;\n\n\t\t\t\tnum_named = read16 (p);\n\t\t\t\tp += 2;\n\n\t\t\t\tg_assert (num_named < 2);\n\t\t\t\tif (num_named == 1) {\n\t\t\t\t\tint name_len;\n\t\t\t\t\tchar *name;\n\n\t\t\t\t\t/* parse ExportSymbol attribute */\n\t\t\t\t\tnamed = p;\n\t\t\t\t\tnamed_type = *named;\n\t\t\t\t\tnamed += 1;\n\t\t\t\t\t/* data_type = *named; */\n\t\t\t\t\tnamed += 1;\n\n\t\t\t\t\tname_len = mono_metadata_decode_blob_size (named, &named);\n\t\t\t\t\tname = (char *)g_malloc (name_len + 1);\n\t\t\t\t\tmemcpy (name, named, name_len);\n\t\t\t\t\tname [name_len] = 0;\n\t\t\t\t\tnamed += name_len;\n\n\t\t\t\t\tg_assert (named_type == 0x54);\n\t\t\t\t\tg_assert (!strcmp (name, \"ExportSymbol\"));\n\n\t\t\t\t\t/* load_cattr_value (), string case */\n\t\t\t\t\tg_assert (*named != (char)0xff);\n\t\t\t\t\tslen = mono_metadata_decode_value (named, &named);\n\t\t\t\t\texport_name = (char *)g_malloc (slen + 1);\n\t\t\t\t\tmemcpy (export_name, named, slen);\n\t\t\t\t\texport_name [slen] = 0;\n\t\t\t\t\tnamed += slen;\n\t\t\t\t}\n\n\t\t\t\twrapper = mono_marshal_get_managed_wrapper (method, klass, 0, &error);\n\t\t\t\tmono_error_assert_ok (&error);\n\n\t\t\t\tadd_method (acfg, wrapper);\n\t\t\t\tif (export_name)\n\t\t\t\t\tg_hash_table_insert (acfg->export_names, wrapper, export_name);\n\t\t\t}\n\t\t\tg_free (cattr);\n\t\t}\n\n\t\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t\t(method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL)) {\n\t\t\tadd_method (acfg, mono_marshal_get_native_wrapper (method, TRUE, TRUE));\n\t\t}\n\t}\n\n\t/* StructureToPtr/PtrToStructure wrappers */\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_TYPEDEF].rows; ++i) {\n\t\tMonoError error;\n\t\tMonoClass *klass;\n\t\t\n\t\ttoken = MONO_TOKEN_TYPE_DEF | (i + 1);\n\t\tklass = mono_class_get_checked (acfg->image, token, &error);\n\n\t\tif (!klass) {\n\t\t\tmono_error_cleanup (&error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (klass->valuetype && !mono_class_is_gtd (klass) && can_marshal_struct (klass) &&\n\t\t\t!(klass->nested_in && strstr (klass->nested_in->name, \"<PrivateImplementationDetails>\") == klass->nested_in->name)) {\n\t\t\tadd_method (acfg, mono_marshal_get_struct_to_ptr (klass));\n\t\t\tadd_method (acfg, mono_marshal_get_ptr_to_struct (klass));\n\t\t}\n\t}\n}\n\nstatic gboolean\nhas_type_vars (MonoClass *klass)\n{\n\tif ((klass->byval_arg.type == MONO_TYPE_VAR) || (klass->byval_arg.type == MONO_TYPE_MVAR))\n\t\treturn TRUE;\n\tif (klass->rank)\n\t\treturn has_type_vars (klass->element_class);\n\tif (mono_class_is_ginst (klass)) {\n\t\tMonoGenericContext *context = &mono_class_get_generic_class (klass)->context;\n\t\tif (context->class_inst) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < context->class_inst->type_argc; ++i)\n\t\t\t\tif (has_type_vars (mono_class_from_mono_type (context->class_inst->type_argv [i])))\n\t\t\t\t\treturn TRUE;\n\t\t}\n\t}\n\tif (mono_class_is_gtd (klass))\n\t\treturn TRUE;\n\treturn FALSE;\n}\n\nstatic gboolean\nis_vt_inst (MonoGenericInst *inst)\n{\n\tint i;\n\n\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\tMonoType *t = inst->type_argv [i];\n\t\tif (MONO_TYPE_ISSTRUCT (t) || t->type == MONO_TYPE_VALUETYPE)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nmethod_has_type_vars (MonoMethod *method)\n{\n\tif (has_type_vars (method->klass))\n\t\treturn TRUE;\n\n\tif (method->is_inflated) {\n\t\tMonoGenericContext *context = mono_method_get_context (method);\n\t\tif (context->method_inst) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < context->method_inst->type_argc; ++i)\n\t\t\t\tif (has_type_vars (mono_class_from_mono_type (context->method_inst->type_argv [i])))\n\t\t\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\nstatic\ngboolean mono_aot_mode_is_full (MonoAotOptions *opts)\n{\n\treturn opts->mode == MONO_AOT_MODE_FULL || opts->mode == MONO_AOT_MODE_INTERP;\n}\n\nstatic\ngboolean mono_aot_mode_is_interp (MonoAotOptions *opts)\n{\n\treturn opts->mode == MONO_AOT_MODE_INTERP;\n}\n\nstatic\ngboolean mono_aot_mode_is_hybrid (MonoAotOptions *opts)\n{\n\treturn opts->mode == MONO_AOT_MODE_HYBRID;\n}\n\nstatic void add_generic_class_with_depth (MonoAotCompile *acfg, MonoClass *klass, int depth, const char *ref);\n\nstatic void\nadd_generic_class (MonoAotCompile *acfg, MonoClass *klass, gboolean force, const char *ref)\n{\n\t/* This might lead to a huge code blowup so only do it if neccesary */\n\tif (!mono_aot_mode_is_full (&acfg->aot_opts) && !mono_aot_mode_is_hybrid (&acfg->aot_opts) && !force)\n\t\treturn;\n\n\tadd_generic_class_with_depth (acfg, klass, 0, ref);\n}\n\nstatic gboolean\ncheck_type_depth (MonoType *t, int depth)\n{\n\tint i;\n\n\tif (depth > 8)\n\t\treturn TRUE;\n\n\tswitch (t->type) {\n\tcase MONO_TYPE_GENERICINST: {\n\t\tMonoGenericClass *gklass = t->data.generic_class;\n\t\tMonoGenericInst *ginst = gklass->context.class_inst;\n\n\t\tif (ginst) {\n\t\t\tfor (i = 0; i < ginst->type_argc; ++i) {\n\t\t\t\tif (check_type_depth (ginst->type_argv [i], depth + 1))\n\t\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn FALSE;\n}\n\nstatic void\nadd_types_from_method_header (MonoAotCompile *acfg, MonoMethod *method);\n\n/*\n * add_generic_class:\n *\n *   Add all methods of a generic class.\n */\nstatic void\nadd_generic_class_with_depth (MonoAotCompile *acfg, MonoClass *klass, int depth, const char *ref)\n{\n\tMonoMethod *method;\n\tMonoClassField *field;\n\tgpointer iter;\n\tgboolean use_gsharedvt = FALSE;\n\n\tif (!acfg->ginst_hash)\n\t\tacfg->ginst_hash = g_hash_table_new (NULL, NULL);\n\n\tmono_class_init (klass);\n\n\tif (mono_class_is_ginst (klass) && mono_class_get_generic_class (klass)->context.class_inst->is_open)\n\t\treturn;\n\n\tif (has_type_vars (klass))\n\t\treturn;\n\n\tif (!mono_class_is_ginst (klass) && !klass->rank)\n\t\treturn;\n\n\tif (mono_class_has_failure (klass))\n\t\treturn;\n\n\tif (!acfg->ginst_hash)\n\t\tacfg->ginst_hash = g_hash_table_new (NULL, NULL);\n\n\tif (g_hash_table_lookup (acfg->ginst_hash, klass))\n\t\treturn;\n\n\tif (check_type_depth (&klass->byval_arg, 0))\n\t\treturn;\n\n\tif (acfg->aot_opts.log_generics)\n\t\taot_printf (acfg, \"%*sAdding generic instance %s [%s].\\n\", depth, \"\", mono_type_full_name (&klass->byval_arg), ref);\n\n\tg_hash_table_insert (acfg->ginst_hash, klass, klass);\n\n\t/*\n\t * Use gsharedvt for generic collections with vtype arguments to avoid code blowup.\n\t * Enable this only for some classes since gsharedvt might not support all methods.\n\t */\n\tif ((acfg->opts & MONO_OPT_GSHAREDVT) && klass->image == mono_defaults.corlib && mono_class_is_ginst (klass) && mono_class_get_generic_class (klass)->context.class_inst && is_vt_inst (mono_class_get_generic_class (klass)->context.class_inst) &&\n\t\t(!strcmp (klass->name, \"Dictionary`2\") || !strcmp (klass->name, \"List`1\") || !strcmp (klass->name, \"ReadOnlyCollection`1\")))\n\t\tuse_gsharedvt = TRUE;\n\n\titer = NULL;\n\twhile ((method = mono_class_get_methods (klass, &iter))) {\n\t\tif ((acfg->opts & MONO_OPT_GSHAREDVT) && method->is_inflated && mono_method_get_context (method)->method_inst) {\n\t\t\t/*\n\t\t\t * This is partial sharing, and we can't handle it yet\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (mono_method_is_generic_sharable_full (method, FALSE, FALSE, use_gsharedvt)) {\n\t\t\t/* Already added */\n\t\t\tadd_types_from_method_header (acfg, method);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (method->is_generic)\n\t\t\t/* FIXME: */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FIXME: Instances which are referenced by these methods are not added,\n\t\t * for example Array.Resize<int> for List<int>.Add ().\n\t\t */\n\t\tadd_extra_method_with_depth (acfg, method, depth + 1);\n\t}\n\n\titer = NULL;\n\twhile ((field = mono_class_get_fields (klass, &iter))) {\n\t\tif (field->type->type == MONO_TYPE_GENERICINST)\n\t\t\tadd_generic_class_with_depth (acfg, mono_class_from_mono_type (field->type), depth + 1, \"field\");\n\t}\n\n\tif (klass->delegate) {\n\t\tmethod = mono_get_delegate_invoke (klass);\n\n\t\tmethod = mono_marshal_get_delegate_invoke (method, NULL);\n\n\t\tif (acfg->aot_opts.log_generics)\n\t\t\taot_printf (acfg, \"%*sAdding method %s.\\n\", depth, \"\", mono_method_get_full_name (method));\n\n\t\tadd_method (acfg, method);\n\t}\n\n\t/* Add superclasses */\n\tif (klass->parent)\n\t\tadd_generic_class_with_depth (acfg, klass->parent, depth, \"parent\");\n\n\t/* \n\t * For ICollection<T>, add instances of the helper methods\n\t * in Array, since a T[] could be cast to ICollection<T>.\n\t */\n\tif (klass->image == mono_defaults.corlib && !strcmp (klass->name_space, \"System.Collections.Generic\") &&\n\t\t(!strcmp(klass->name, \"ICollection`1\") || !strcmp (klass->name, \"IEnumerable`1\") || !strcmp (klass->name, \"IList`1\") || !strcmp (klass->name, \"IEnumerator`1\") || !strcmp (klass->name, \"IReadOnlyList`1\"))) {\n\t\tMonoClass *tclass = mono_class_from_mono_type (mono_class_get_generic_class (klass)->context.class_inst->type_argv [0]);\n\t\tMonoClass *array_class = mono_bounded_array_class_get (tclass, 1, FALSE);\n\t\tgpointer iter;\n\t\tchar *name_prefix;\n\n\t\tif (!strcmp (klass->name, \"IEnumerator`1\"))\n\t\t\tname_prefix = g_strdup_printf (\"%s.%s\", klass->name_space, \"IEnumerable`1\");\n\t\telse\n\t\t\tname_prefix = g_strdup_printf (\"%s.%s\", klass->name_space, klass->name);\n\n\t\t/* Add the T[]/InternalEnumerator class */\n\t\tif (!strcmp (klass->name, \"IEnumerable`1\") || !strcmp (klass->name, \"IEnumerator`1\")) {\n\t\t\tMonoError error;\n\t\t\tMonoClass *nclass;\n\n\t\t\titer = NULL;\n\t\t\twhile ((nclass = mono_class_get_nested_types (array_class->parent, &iter))) {\n\t\t\t\tif (!strcmp (nclass->name, \"InternalEnumerator`1\"))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg_assert (nclass);\n\t\t\tnclass = mono_class_inflate_generic_class_checked (nclass, mono_generic_class_get_context (mono_class_get_generic_class (klass)), &error);\n\t\t\tmono_error_assert_ok (&error); /* FIXME don't swallow the error */\n\t\t\tadd_generic_class (acfg, nclass, FALSE, \"ICollection<T>\");\n\t\t}\n\n\t\titer = NULL;\n\t\twhile ((method = mono_class_get_methods (array_class, &iter))) {\n\t\t\tif (strstr (method->name, name_prefix)) {\n\t\t\t\tMonoMethod *m = mono_aot_get_array_helper_from_wrapper (method);\n\n\t\t\t\tadd_extra_method_with_depth (acfg, m, depth);\n\t\t\t}\n\t\t}\n\n\t\tg_free (name_prefix);\n\t}\n\n\t/* Add an instance of GenericComparer<T> which is created dynamically by Comparer<T> */\n\tif (klass->image == mono_defaults.corlib && !strcmp (klass->name_space, \"System.Collections.Generic\") && !strcmp (klass->name, \"Comparer`1\")) {\n\t\tMonoError error;\n\t\tMonoClass *tclass = mono_class_from_mono_type (mono_class_get_generic_class (klass)->context.class_inst->type_argv [0]);\n\t\tMonoClass *icomparable, *gcomparer, *icomparable_inst;\n\t\tMonoGenericContext ctx;\n\t\tMonoType *args [16];\n\n\t\tmemset (&ctx, 0, sizeof (ctx));\n\n\t\ticomparable = mono_class_load_from_name (mono_defaults.corlib, \"System\", \"IComparable`1\");\n\n\t\targs [0] = &tclass->byval_arg;\n\t\tctx.class_inst = mono_metadata_get_generic_inst (1, args);\n\n\t\ticomparable_inst = mono_class_inflate_generic_class_checked (icomparable, &ctx, &error);\n\t\tmono_error_assert_ok (&error); /* FIXME don't swallow the error */\n\n\t\tif (mono_class_is_assignable_from (icomparable_inst, tclass)) {\n\t\t\tMonoClass *gcomparer_inst;\n\t\t\tgcomparer = mono_class_load_from_name (mono_defaults.corlib, \"System.Collections.Generic\", \"GenericComparer`1\");\n\t\t\tgcomparer_inst = mono_class_inflate_generic_class_checked (gcomparer, &ctx, &error);\n\t\t\tmono_error_assert_ok (&error); /* FIXME don't swallow the error */\n\n\t\t\tadd_generic_class (acfg, gcomparer_inst, FALSE, \"Comparer<T>\");\n\t\t}\n\t}\n\n\t/* Add an instance of GenericEqualityComparer<T> which is created dynamically by EqualityComparer<T> */\n\tif (klass->image == mono_defaults.corlib && !strcmp (klass->name_space, \"System.Collections.Generic\") && !strcmp (klass->name, \"EqualityComparer`1\")) {\n\t\tMonoError error;\n\t\tMonoClass *tclass = mono_class_from_mono_type (mono_class_get_generic_class (klass)->context.class_inst->type_argv [0]);\n\t\tMonoClass *iface, *gcomparer, *iface_inst;\n\t\tMonoGenericContext ctx;\n\t\tMonoType *args [16];\n\n\t\tmemset (&ctx, 0, sizeof (ctx));\n\n\t\tiface = mono_class_load_from_name (mono_defaults.corlib, \"System\", \"IEquatable`1\");\n\t\tg_assert (iface);\n\t\targs [0] = &tclass->byval_arg;\n\t\tctx.class_inst = mono_metadata_get_generic_inst (1, args);\n\n\t\tiface_inst = mono_class_inflate_generic_class_checked (iface, &ctx, &error);\n\t\tmono_error_assert_ok (&error); /* FIXME don't swallow the error */\n\n\t\tif (mono_class_is_assignable_from (iface_inst, tclass)) {\n\t\t\tMonoClass *gcomparer_inst;\n\t\t\tMonoError error;\n\n\t\t\tgcomparer = mono_class_load_from_name (mono_defaults.corlib, \"System.Collections.Generic\", \"GenericEqualityComparer`1\");\n\t\t\tgcomparer_inst = mono_class_inflate_generic_class_checked (gcomparer, &ctx, &error);\n\t\t\tmono_error_assert_ok (&error); /* FIXME don't swallow the error */\n\t\t\tadd_generic_class (acfg, gcomparer_inst, FALSE, \"EqualityComparer<T>\");\n\t\t}\n\t}\n\n\t/* Add an instance of EnumComparer<T> which is created dynamically by EqualityComparer<T> for enums */\n\tif (klass->image == mono_defaults.corlib && !strcmp (klass->name_space, \"System.Collections.Generic\") && !strcmp (klass->name, \"EqualityComparer`1\")) {\n\t\tMonoClass *enum_comparer;\n\t\tMonoClass *tclass = mono_class_from_mono_type (mono_class_get_generic_class (klass)->context.class_inst->type_argv [0]);\n\t\tMonoGenericContext ctx;\n\t\tMonoType *args [16];\n\n\t\tif (mono_class_is_enum (tclass)) {\n\t\t\tMonoClass *enum_comparer_inst;\n\t\t\tMonoError error;\n\n\t\t\tmemset (&ctx, 0, sizeof (ctx));\n\t\t\targs [0] = &tclass->byval_arg;\n\t\t\tctx.class_inst = mono_metadata_get_generic_inst (1, args);\n\n\t\t\tenum_comparer = mono_class_load_from_name (mono_defaults.corlib, \"System.Collections.Generic\", \"EnumEqualityComparer`1\");\n\t\t\tenum_comparer_inst = mono_class_inflate_generic_class_checked (enum_comparer, &ctx, &error);\n\t\t\tmono_error_assert_ok (&error); /* FIXME don't swallow the error */\n\t\t\tadd_generic_class (acfg, enum_comparer_inst, FALSE, \"EqualityComparer<T>\");\n\t\t}\n\t}\n\n\t/* Add an instance of ObjectComparer<T> which is created dynamically by Comparer<T> for enums */\n\tif (klass->image == mono_defaults.corlib && !strcmp (klass->name_space, \"System.Collections.Generic\") && !strcmp (klass->name, \"Comparer`1\")) {\n\t\tMonoClass *comparer;\n\t\tMonoClass *tclass = mono_class_from_mono_type (mono_class_get_generic_class (klass)->context.class_inst->type_argv [0]);\n\t\tMonoGenericContext ctx;\n\t\tMonoType *args [16];\n\n\t\tif (mono_class_is_enum (tclass)) {\n\t\t\tMonoClass *comparer_inst;\n\t\t\tMonoError error;\n\n\t\t\tmemset (&ctx, 0, sizeof (ctx));\n\t\t\targs [0] = &tclass->byval_arg;\n\t\t\tctx.class_inst = mono_metadata_get_generic_inst (1, args);\n\n\t\t\tcomparer = mono_class_load_from_name (mono_defaults.corlib, \"System.Collections.Generic\", \"ObjectComparer`1\");\n\t\t\tcomparer_inst = mono_class_inflate_generic_class_checked (comparer, &ctx, &error);\n\t\t\tmono_error_assert_ok (&error); /* FIXME don't swallow the error */\n\t\t\tadd_generic_class (acfg, comparer_inst, FALSE, \"Comparer<T>\");\n\t\t}\n\t}\n}\n\nstatic void\nadd_instances_of (MonoAotCompile *acfg, MonoClass *klass, MonoType **insts, int ninsts, gboolean force)\n{\n\tint i;\n\tMonoGenericContext ctx;\n\tMonoType *args [16];\n\n\tif (acfg->aot_opts.no_instances)\n\t\treturn;\n\n\tmemset (&ctx, 0, sizeof (ctx));\n\n\tfor (i = 0; i < ninsts; ++i) {\n\t\tMonoError error;\n\t\tMonoClass *generic_inst;\n\t\targs [0] = insts [i];\n\t\tctx.class_inst = mono_metadata_get_generic_inst (1, args);\n\t\tgeneric_inst = mono_class_inflate_generic_class_checked (klass, &ctx, &error);\n\t\tmono_error_assert_ok (&error); /* FIXME don't swallow the error */\n\t\tadd_generic_class (acfg, generic_inst, force, \"\");\n\t}\n}\n\nstatic void\nadd_types_from_method_header (MonoAotCompile *acfg, MonoMethod *method)\n{\n\tMonoError error;\n\tMonoMethodHeader *header;\n\tMonoMethodSignature *sig;\n\tint j, depth;\n\n\tdepth = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->method_depth, method));\n\n\tsig = mono_method_signature (method);\n\n\tif (sig) {\n\t\tfor (j = 0; j < sig->param_count; ++j)\n\t\t\tif (sig->params [j]->type == MONO_TYPE_GENERICINST)\n\t\t\t\tadd_generic_class_with_depth (acfg, mono_class_from_mono_type (sig->params [j]), depth + 1, \"arg\");\n\t}\n\n\theader = mono_method_get_header_checked (method, &error);\n\n\tif (header) {\n\t\tfor (j = 0; j < header->num_locals; ++j)\n\t\t\tif (header->locals [j]->type == MONO_TYPE_GENERICINST)\n\t\t\t\tadd_generic_class_with_depth (acfg, mono_class_from_mono_type (header->locals [j]), depth + 1, \"local\");\n\t\tmono_metadata_free_mh (header);\n\t} else {\n\t\tmono_error_cleanup (&error); /* FIXME report the error */\n\t}\n\n}\n\n/*\n * add_generic_instances:\n *\n *   Add instances referenced by the METHODSPEC/TYPESPEC table.\n */\nstatic void\nadd_generic_instances (MonoAotCompile *acfg)\n{\n\tint i;\n\tguint32 token;\n\tMonoMethod *method;\n\tMonoGenericContext *context;\n\n\tif (acfg->aot_opts.no_instances)\n\t\treturn;\n\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_METHODSPEC].rows; ++i) {\n\t\tMonoError error;\n\t\ttoken = MONO_TOKEN_METHOD_SPEC | (i + 1);\n\t\tmethod = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);\n\n\t\tif (!method) {\n\t\t\taot_printerrf (acfg, \"Failed to load methodspec 0x%x due to %s.\\n\", token, mono_error_get_message (&error));\n\t\t\taot_printerrf (acfg, \"Run with MONO_LOG_LEVEL=debug for more information.\\n\");\n\t\t\tmono_error_cleanup (&error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (method->klass->image != acfg->image)\n\t\t\tcontinue;\n\n\t\tcontext = mono_method_get_context (method);\n\n\t\tif (context && ((context->class_inst && context->class_inst->is_open)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * For open methods, create an instantiation which can be passed to the JIT.\n\t\t * FIXME: Handle class_inst as well.\n\t\t */\n\t\tif (context && context->method_inst && context->method_inst->is_open) {\n\t\t\tMonoError error;\n\t\t\tMonoGenericContext shared_context;\n\t\t\tMonoGenericInst *inst;\n\t\t\tMonoType **type_argv;\n\t\t\tint i;\n\t\t\tMonoMethod *declaring_method;\n\t\t\tgboolean supported = TRUE;\n\n\t\t\t/* Check that the context doesn't contain open constructed types */\n\t\t\tif (context->class_inst) {\n\t\t\t\tinst = context->class_inst;\n\t\t\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\t\t\tif (MONO_TYPE_IS_REFERENCE (inst->type_argv [i]) || inst->type_argv [i]->type == MONO_TYPE_VAR || inst->type_argv [i]->type == MONO_TYPE_MVAR)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (mono_class_is_open_constructed_type (inst->type_argv [i]))\n\t\t\t\t\t\tsupported = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (context->method_inst) {\n\t\t\t\tinst = context->method_inst;\n\t\t\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\t\t\tif (MONO_TYPE_IS_REFERENCE (inst->type_argv [i]) || inst->type_argv [i]->type == MONO_TYPE_VAR || inst->type_argv [i]->type == MONO_TYPE_MVAR)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (mono_class_is_open_constructed_type (inst->type_argv [i]))\n\t\t\t\t\t\tsupported = FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!supported)\n\t\t\t\tcontinue;\n\n\t\t\tmemset (&shared_context, 0, sizeof (MonoGenericContext));\n\n\t\t\tinst = context->class_inst;\n\t\t\tif (inst) {\n\t\t\t\ttype_argv = g_new0 (MonoType*, inst->type_argc);\n\t\t\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\t\t\tif (MONO_TYPE_IS_REFERENCE (inst->type_argv [i]) || inst->type_argv [i]->type == MONO_TYPE_VAR || inst->type_argv [i]->type == MONO_TYPE_MVAR)\n\t\t\t\t\t\ttype_argv [i] = &mono_defaults.object_class->byval_arg;\n\t\t\t\t\telse\n\t\t\t\t\t\ttype_argv [i] = inst->type_argv [i];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tshared_context.class_inst = mono_metadata_get_generic_inst (inst->type_argc, type_argv);\n\t\t\t\tg_free (type_argv);\n\t\t\t}\n\n\t\t\tinst = context->method_inst;\n\t\t\tif (inst) {\n\t\t\t\ttype_argv = g_new0 (MonoType*, inst->type_argc);\n\t\t\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\t\t\tif (MONO_TYPE_IS_REFERENCE (inst->type_argv [i]) || inst->type_argv [i]->type == MONO_TYPE_VAR || inst->type_argv [i]->type == MONO_TYPE_MVAR)\n\t\t\t\t\t\ttype_argv [i] = &mono_defaults.object_class->byval_arg;\n\t\t\t\t\telse\n\t\t\t\t\t\ttype_argv [i] = inst->type_argv [i];\n\t\t\t\t}\n\n\t\t\t\tshared_context.method_inst = mono_metadata_get_generic_inst (inst->type_argc, type_argv);\n\t\t\t\tg_free (type_argv);\n\t\t\t}\n\n\t\t\tif (method->is_generic || mono_class_is_gtd (method->klass))\n\t\t\t\tdeclaring_method = method;\n\t\t\telse\n\t\t\t\tdeclaring_method = mono_method_get_declaring_generic_method (method);\n\n\t\t\tmethod = mono_class_inflate_generic_method_checked (declaring_method, &shared_context, &error);\n\t\t\tg_assert (mono_error_ok (&error)); /* FIXME don't swallow the error */\n\t\t}\n\n\t\t/* \n\t\t * If the method is fully sharable, it was already added in place of its\n\t\t * generic definition.\n\t\t */\n\t\tif (mono_method_is_generic_sharable_full (method, FALSE, FALSE, FALSE))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FIXME: Partially shared methods are not shared here, so we end up with\n\t\t * many identical methods.\n\t\t */\n\t\tadd_extra_method (acfg, method);\n\t}\n\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_TYPESPEC].rows; ++i) {\n\t\tMonoError error;\n\t\tMonoClass *klass;\n\n\t\ttoken = MONO_TOKEN_TYPE_SPEC | (i + 1);\n\n\t\tklass = mono_class_get_checked (acfg->image, token, &error);\n\t\tif (!klass || klass->rank) {\n\t\t\tmono_error_cleanup (&error);\n\t\t\tcontinue;\n\t\t}\n\n\t\tadd_generic_class (acfg, klass, FALSE, \"typespec\");\n\t}\n\n\t/* Add types of args/locals */\n\tfor (i = 0; i < acfg->methods->len; ++i) {\n\t\tmethod = (MonoMethod *)g_ptr_array_index (acfg->methods, i);\n\t\tadd_types_from_method_header (acfg, method);\n\t}\n\n\tif (acfg->image == mono_defaults.corlib) {\n\t\tMonoClass *klass;\n\t\tMonoType *insts [256];\n\t\tint ninsts = 0;\n\n\t\tinsts [ninsts ++] = &mono_defaults.byte_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.sbyte_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.int16_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.uint16_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.int32_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.uint32_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.int64_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.uint64_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.single_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.double_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.char_class->byval_arg;\n\t\tinsts [ninsts ++] = &mono_defaults.boolean_class->byval_arg;\n\n\t\t/* Add GenericComparer<T> instances for primitive types for Enum.ToString () */\n\t\tklass = mono_class_try_load_from_name (acfg->image, \"System.Collections.Generic\", \"GenericComparer`1\");\n\t\tif (klass)\n\t\t\tadd_instances_of (acfg, klass, insts, ninsts, TRUE);\n\t\tklass = mono_class_try_load_from_name (acfg->image, \"System.Collections.Generic\", \"GenericEqualityComparer`1\");\n\t\tif (klass)\n\t\t\tadd_instances_of (acfg, klass, insts, ninsts, TRUE);\n\n\t\t/* Add instances of EnumEqualityComparer which are created by EqualityComparer<T> for enums */\n\t\t{\n\t\t\tMonoClass *enum_comparer;\n\t\t\tMonoType *insts [16];\n\t\t\tint ninsts;\n\n\t\t\tninsts = 0;\n\t\t\tinsts [ninsts ++] = &mono_defaults.int32_class->byval_arg;\n\t\t\tinsts [ninsts ++] = &mono_defaults.uint32_class->byval_arg;\n\t\t\tinsts [ninsts ++] = &mono_defaults.uint16_class->byval_arg;\n\t\t\tinsts [ninsts ++] = &mono_defaults.byte_class->byval_arg;\n\t\t\tenum_comparer = mono_class_load_from_name (mono_defaults.corlib, \"System.Collections.Generic\", \"EnumEqualityComparer`1\");\n\t\t\tadd_instances_of (acfg, enum_comparer, insts, ninsts, FALSE);\n\n\t\t\tninsts = 0;\n\t\t\tinsts [ninsts ++] = &mono_defaults.int16_class->byval_arg;\n\t\t\tenum_comparer = mono_class_load_from_name (mono_defaults.corlib, \"System.Collections.Generic\", \"ShortEnumEqualityComparer`1\");\n\t\t\tadd_instances_of (acfg, enum_comparer, insts, ninsts, FALSE);\n\n\t\t\tninsts = 0;\n\t\t\tinsts [ninsts ++] = &mono_defaults.sbyte_class->byval_arg;\n\t\t\tenum_comparer = mono_class_load_from_name (mono_defaults.corlib, \"System.Collections.Generic\", \"SByteEnumEqualityComparer`1\");\n\t\t\tadd_instances_of (acfg, enum_comparer, insts, ninsts, FALSE);\n\n\t\t\tenum_comparer = mono_class_load_from_name (mono_defaults.corlib, \"System.Collections.Generic\", \"LongEnumEqualityComparer`1\");\n\t\t\tninsts = 0;\n\t\t\tinsts [ninsts ++] = &mono_defaults.int64_class->byval_arg;\n\t\t\tinsts [ninsts ++] = &mono_defaults.uint64_class->byval_arg;\n\t\t\tadd_instances_of (acfg, enum_comparer, insts, ninsts, FALSE);\n\t\t}\n\n\t\t/* Add instances of the array generic interfaces for primitive types */\n\t\t/* This will add instances of the InternalArray_ helper methods in Array too */\n\t\tklass = mono_class_try_load_from_name (acfg->image, \"System.Collections.Generic\", \"ICollection`1\");\n\t\tif (klass)\n\t\t\tadd_instances_of (acfg, klass, insts, ninsts, TRUE);\n\n\t\tklass = mono_class_try_load_from_name (acfg->image, \"System.Collections.Generic\", \"IList`1\");\n\t\tif (klass)\n\t\t\tadd_instances_of (acfg, klass, insts, ninsts, TRUE);\n\n\t\tklass = mono_class_try_load_from_name (acfg->image, \"System.Collections.Generic\", \"IEnumerable`1\");\n\t\tif (klass)\n\t\t\tadd_instances_of (acfg, klass, insts, ninsts, TRUE);\n\n\t\t/* \n\t\t * Add a managed-to-native wrapper of Array.GetGenericValueImpl<object>, which is\n\t\t * used for all instances of GetGenericValueImpl by the AOT runtime.\n\t\t */\n\t\t{\n\t\t\tMonoGenericContext ctx;\n\t\t\tMonoType *args [16];\n\t\t\tMonoMethod *get_method;\n\t\t\tMonoClass *array_klass = mono_array_class_get (mono_defaults.object_class, 1)->parent;\n\n\t\t\tget_method = mono_class_get_method_from_name (array_klass, \"GetGenericValueImpl\", 2);\n\n\t\t\tif (get_method) {\n\t\t\t\tMonoError error;\n\t\t\t\tmemset (&ctx, 0, sizeof (ctx));\n\t\t\t\targs [0] = &mono_defaults.object_class->byval_arg;\n\t\t\t\tctx.method_inst = mono_metadata_get_generic_inst (1, args);\n\t\t\t\tadd_extra_method (acfg, mono_marshal_get_native_wrapper (mono_class_inflate_generic_method_checked (get_method, &ctx, &error), TRUE, TRUE));\n\t\t\t\tg_assert (mono_error_ok (&error)); /* FIXME don't swallow the error */\n\t\t\t}\n\t\t}\n\n\t\t/* Same for CompareExchange<T>/Exchange<T> */\n\t\t{\n\t\t\tMonoGenericContext ctx;\n\t\t\tMonoType *args [16];\n\t\t\tMonoMethod *m;\n\t\t\tMonoClass *interlocked_klass = mono_class_load_from_name (mono_defaults.corlib, \"System.Threading\", \"Interlocked\");\n\t\t\tgpointer iter = NULL;\n\n\t\t\twhile ((m = mono_class_get_methods (interlocked_klass, &iter))) {\n\t\t\t\tif ((!strcmp (m->name, \"CompareExchange\") || !strcmp (m->name, \"Exchange\")) && m->is_generic) {\n\t\t\t\t\tMonoError error;\n\t\t\t\t\tmemset (&ctx, 0, sizeof (ctx));\n\t\t\t\t\targs [0] = &mono_defaults.object_class->byval_arg;\n\t\t\t\t\tctx.method_inst = mono_metadata_get_generic_inst (1, args);\n\t\t\t\t\tadd_extra_method (acfg, mono_marshal_get_native_wrapper (mono_class_inflate_generic_method_checked (m, &ctx, &error), TRUE, TRUE));\n\t\t\t\t\tg_assert (mono_error_ok (&error)); /* FIXME don't swallow the error */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Same for Volatile.Read/Write<T> */\n\t\t{\n\t\t\tMonoGenericContext ctx;\n\t\t\tMonoType *args [16];\n\t\t\tMonoMethod *m;\n\t\t\tMonoClass *volatile_klass = mono_class_try_load_from_name (mono_defaults.corlib, \"System.Threading\", \"Volatile\");\n\t\t\tgpointer iter = NULL;\n\n\t\t\tif (volatile_klass) {\n\t\t\t\twhile ((m = mono_class_get_methods (volatile_klass, &iter))) {\n\t\t\t\t\tif ((!strcmp (m->name, \"Read\") || !strcmp (m->name, \"Write\")) && m->is_generic) {\n\t\t\t\t\t\tMonoError error;\n\t\t\t\t\t\tmemset (&ctx, 0, sizeof (ctx));\n\t\t\t\t\t\targs [0] = &mono_defaults.object_class->byval_arg;\n\t\t\t\t\t\tctx.method_inst = mono_metadata_get_generic_inst (1, args);\n\t\t\t\t\t\tadd_extra_method (acfg, mono_marshal_get_native_wrapper (mono_class_inflate_generic_method_checked (m, &ctx, &error), TRUE, TRUE));\n\t\t\t\t\t\tg_assert (mono_error_ok (&error)); /* FIXME don't swallow the error */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* object[] accessor wrappers. */\n\t\tfor (i = 1; i < 4; ++i) {\n\t\t\tMonoClass *obj_array_class = mono_array_class_get (mono_defaults.object_class, i);\n\t\t\tMonoMethod *m;\n\n\t\t\tm = mono_class_get_method_from_name (obj_array_class, \"Get\", i);\n\t\t\tg_assert (m);\n\n\t\t\tm = mono_marshal_get_array_accessor_wrapper (m);\n\t\t\tadd_extra_method (acfg, m);\n\n\t\t\tm = mono_class_get_method_from_name (obj_array_class, \"Address\", i);\n\t\t\tg_assert (m);\n\n\t\t\tm = mono_marshal_get_array_accessor_wrapper (m);\n\t\t\tadd_extra_method (acfg, m);\n\n\t\t\tm = mono_class_get_method_from_name (obj_array_class, \"Set\", i + 1);\n\t\t\tg_assert (m);\n\n\t\t\tm = mono_marshal_get_array_accessor_wrapper (m);\n\t\t\tadd_extra_method (acfg, m);\n\t\t}\n\t}\n}\n\n/*\n * is_direct_callable:\n *\n *   Return whenever the method identified by JI is directly callable without \n * going through the PLT.\n */\nstatic gboolean\nis_direct_callable (MonoAotCompile *acfg, MonoMethod *method, MonoJumpInfo *patch_info)\n{\n\tif ((patch_info->type == MONO_PATCH_INFO_METHOD) && (patch_info->data.method->klass->image == acfg->image)) {\n\t\tMonoCompile *callee_cfg = (MonoCompile *)g_hash_table_lookup (acfg->method_to_cfg, patch_info->data.method);\n\t\tif (callee_cfg) {\n\t\t\tgboolean direct_callable = TRUE;\n\n\t\t\tif (direct_callable && (acfg->aot_opts.dedup || acfg->aot_opts.dedup_include) && mono_aot_can_dedup (patch_info->data.method))\n\t\t\t\tdirect_callable = FALSE;\n\n\t\t\tif (direct_callable && !(!callee_cfg->has_got_slots && mono_class_is_before_field_init (callee_cfg->method->klass)))\n\t\t\t\tdirect_callable = FALSE;\n\t\t\tif ((callee_cfg->method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED) && (!method || method->wrapper_type != MONO_WRAPPER_SYNCHRONIZED))\n\t\t\t\t// FIXME: Maybe call the wrapper directly ?\n\t\t\t\tdirect_callable = FALSE;\n\n\t\t\tif (acfg->aot_opts.soft_debug || acfg->aot_opts.no_direct_calls) {\n\t\t\t\t/* Disable this so all calls go through load_method (), see the\n\t\t\t\t * mini_get_debug_options ()->load_aot_jit_info_eagerly = TRUE; line in\n\t\t\t\t * mono_debugger_agent_init ().\n\t\t\t\t */\n\t\t\t\tdirect_callable = FALSE;\n\t\t\t}\n\n\t\t\tif (callee_cfg->method->wrapper_type == MONO_WRAPPER_ALLOC)\n\t\t\t\t/* sgen does some initialization when the allocator method is created */\n\t\t\t\tdirect_callable = FALSE;\n\t\t\tif (callee_cfg->method->wrapper_type == MONO_WRAPPER_WRITE_BARRIER)\n\t\t\t\t/* we don't know at compile time whether sgen is concurrent or not */\n\t\t\t\tdirect_callable = FALSE;\n\n\t\t\tif (direct_callable)\n\t\t\t\treturn TRUE;\n\t\t}\n\t} else if ((patch_info->type == MONO_PATCH_INFO_ICALL_ADDR_CALL && patch_info->data.method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL)) {\n\t\tif (acfg->aot_opts.direct_pinvoke)\n\t\t\treturn TRUE;\n\t} else if (patch_info->type == MONO_PATCH_INFO_ICALL_ADDR_CALL) {\n\t\tif (acfg->aot_opts.direct_icalls)\n\t\t\treturn TRUE;\n\t\treturn FALSE;\n\t}\n\n\treturn FALSE;\n}\n\n#ifdef MONO_ARCH_AOT_SUPPORTED\nstatic const char *\nget_pinvoke_import (MonoAotCompile *acfg, MonoMethod *method)\n{\n\tMonoImage *image = method->klass->image;\n\tMonoMethodPInvoke *piinfo = (MonoMethodPInvoke *) method;\n\tMonoTableInfo *tables = image->tables;\n\tMonoTableInfo *im = &tables [MONO_TABLE_IMPLMAP];\n\tMonoTableInfo *mr = &tables [MONO_TABLE_MODULEREF];\n\tguint32 im_cols [MONO_IMPLMAP_SIZE];\n\tchar *import;\n\n\timport = (char *)g_hash_table_lookup (acfg->method_to_pinvoke_import, method);\n\tif (import != NULL)\n\t\treturn import;\n\n\tif (!piinfo->implmap_idx || piinfo->implmap_idx > im->rows)\n\t\treturn NULL;\n\n\tmono_metadata_decode_row (im, piinfo->implmap_idx - 1, im_cols, MONO_IMPLMAP_SIZE);\n\n\tif (!im_cols [MONO_IMPLMAP_SCOPE] || im_cols [MONO_IMPLMAP_SCOPE] > mr->rows)\n\t\treturn NULL;\n\n\timport = g_strdup_printf (\"%s\", mono_metadata_string_heap (image, im_cols [MONO_IMPLMAP_NAME]));\n\n\tg_hash_table_insert (acfg->method_to_pinvoke_import, method, import);\n\t\n\treturn import;\n}\n#else\nstatic const char *\nget_pinvoke_import (MonoAotCompile *acfg, MonoMethod *method)\n{\n\treturn NULL;\n}\n#endif\n\nstatic gint\ncompare_lne (MonoDebugLineNumberEntry *a, MonoDebugLineNumberEntry *b)\n{\n\tif (a->native_offset == b->native_offset)\n\t\treturn a->il_offset - b->il_offset;\n\telse\n\t\treturn a->native_offset - b->native_offset;\n}\n\n/*\n * compute_line_numbers:\n *\n * Returns a sparse array of size CODE_SIZE containing MonoDebugSourceLocation* entries for the native offsets which have a corresponding line number\n * entry.\n */\nstatic MonoDebugSourceLocation**\ncompute_line_numbers (MonoMethod *method, int code_size, MonoDebugMethodJitInfo *debug_info)\n{\n\tMonoDebugMethodInfo *minfo;\n\tMonoDebugLineNumberEntry *ln_array;\n\tMonoDebugSourceLocation *loc;\n\tint i, prev_line, prev_il_offset;\n\tint *native_to_il_offset = NULL;\n\tMonoDebugSourceLocation **res;\n\tgboolean first;\n\n\tminfo = mono_debug_lookup_method (method);\n\tif (!minfo)\n\t\treturn NULL;\n\t// FIXME: This seems to happen when two methods have the same cfg->method_to_register\n\tif (debug_info->code_size != code_size)\n\t\treturn NULL;\n\n\tg_assert (code_size);\n\n\t/* Compute the native->IL offset mapping */\n\n\tln_array = g_new0 (MonoDebugLineNumberEntry, debug_info->num_line_numbers);\n\tmemcpy (ln_array, debug_info->line_numbers, debug_info->num_line_numbers * sizeof (MonoDebugLineNumberEntry));\n\n\tqsort (ln_array, debug_info->num_line_numbers, sizeof (MonoDebugLineNumberEntry), (int (*)(const void *, const void *))compare_lne);\n\n\tnative_to_il_offset = g_new0 (int, code_size + 1);\n\n\tfor (i = 0; i < debug_info->num_line_numbers; ++i) {\n\t\tint j;\n\t\tMonoDebugLineNumberEntry *lne = &ln_array [i];\n\n\t\tif (i == 0) {\n\t\t\tfor (j = 0; j < lne->native_offset; ++j)\n\t\t\t\tnative_to_il_offset [j] = -1;\n\t\t}\n\n\t\tif (i < debug_info->num_line_numbers - 1) {\n\t\t\tMonoDebugLineNumberEntry *lne_next = &ln_array [i + 1];\n\n\t\t\tfor (j = lne->native_offset; j < lne_next->native_offset; ++j)\n\t\t\t\tnative_to_il_offset [j] = lne->il_offset;\n\t\t} else {\n\t\t\tfor (j = lne->native_offset; j < code_size; ++j)\n\t\t\t\tnative_to_il_offset [j] = lne->il_offset;\n\t\t}\n\t}\n\tg_free (ln_array);\n\n\t/* Compute the native->line number mapping */\n\tres = g_new0 (MonoDebugSourceLocation*, code_size);\n\tprev_il_offset = -1;\n\tprev_line = -1;\n\tfirst = TRUE;\n\tfor (i = 0; i < code_size; ++i) {\n\t\tint il_offset = native_to_il_offset [i];\n\n\t\tif (il_offset == -1 || il_offset == prev_il_offset)\n\t\t\tcontinue;\n\t\tprev_il_offset = il_offset;\n\t\tloc = mono_debug_method_lookup_location (minfo, il_offset);\n\t\tif (!(loc && loc->source_file))\n\t\t\tcontinue;\n\t\tif (loc->row == prev_line) {\n\t\t\tmono_debug_free_source_location (loc);\n\t\t\tcontinue;\n\t\t}\n\t\tprev_line = loc->row;\n\t\t//printf (\"D: %s:%d il=%x native=%x\\n\", loc->source_file, loc->row, il_offset, i);\n\t\tif (first)\n\t\t\t/* This will cover the prolog too */\n\t\t\tres [0] = loc;\n\t\telse\n\t\t\tres [i] = loc;\n\t\tfirst = FALSE;\n\t}\n\treturn res;\n}\n\nstatic int\nget_file_index (MonoAotCompile *acfg, const char *source_file)\n{\n\tint findex;\n\n\t// FIXME: Free these\n\tif (!acfg->dwarf_ln_filenames)\n\t\tacfg->dwarf_ln_filenames = g_hash_table_new (g_str_hash, g_str_equal);\n\tfindex = GPOINTER_TO_INT (g_hash_table_lookup (acfg->dwarf_ln_filenames, source_file));\n\tif (!findex) {\n\t\tfindex = g_hash_table_size (acfg->dwarf_ln_filenames) + 1;\n\t\tg_hash_table_insert (acfg->dwarf_ln_filenames, g_strdup (source_file), GINT_TO_POINTER (findex));\n\t\temit_unset_mode (acfg);\n\t\tfprintf (acfg->fp, \".file %d \\\"%s\\\"\\n\", findex, mono_dwarf_escape_path (source_file));\n\t}\n\treturn findex;\n}\n\n#ifdef TARGET_ARM64\n#define INST_LEN 4\n#else\n#define INST_LEN 1\n#endif\n\n/*\n * emit_and_reloc_code:\n *\n *   Emit the native code in CODE, handling relocations along the way. If GOT_ONLY\n * is true, calls are made through the GOT too. This is used for emitting trampolines\n * in full-aot mode, since calls made from trampolines couldn't go through the PLT,\n * since trampolines are needed to make PTL work.\n */\nstatic void\nemit_and_reloc_code (MonoAotCompile *acfg, MonoMethod *method, guint8 *code, guint32 code_len, MonoJumpInfo *relocs, gboolean got_only, MonoDebugMethodJitInfo *debug_info)\n{\n\tint i, pindex, start_index;\n\tGPtrArray *patches;\n\tMonoJumpInfo *patch_info;\n\tMonoDebugSourceLocation **locs = NULL;\n\tgboolean skip, prologue_end = FALSE;\n#ifdef MONO_ARCH_AOT_SUPPORTED\n\tgboolean direct_call, external_call;\n\tguint32 got_slot;\n\tconst char *direct_call_target = 0;\n\tconst char *direct_pinvoke;\n#endif\n\n\tif (acfg->gas_line_numbers && method && debug_info) {\n\t\tlocs = compute_line_numbers (method, code_len, debug_info);\n\t\tif (!locs) {\n\t\t\tint findex = get_file_index (acfg, \"<unknown>\");\n\t\t\temit_unset_mode (acfg);\n\t\t\tfprintf (acfg->fp, \".loc %d %d 0\\n\", findex, 1);\n\t\t}\n\t}\n\n\t/* Collect and sort relocations */\n\tpatches = g_ptr_array_new ();\n\tfor (patch_info = relocs; patch_info; patch_info = patch_info->next)\n\t\tg_ptr_array_add (patches, patch_info);\n\tg_ptr_array_sort (patches, compare_patches);\n\n\tstart_index = 0;\n\tfor (i = 0; i < code_len; i += INST_LEN) {\n\t\tpatch_info = NULL;\n\t\tfor (pindex = start_index; pindex < patches->len; ++pindex) {\n\t\t\tpatch_info = (MonoJumpInfo *)g_ptr_array_index (patches, pindex);\n\t\t\tif (patch_info->ip.i >= i)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (locs && locs [i]) {\n\t\t\tMonoDebugSourceLocation *loc = locs [i];\n\t\t\tint findex;\n\t\t\tconst char *options;\n\n\t\t\tfindex = get_file_index (acfg, loc->source_file);\n\t\t\temit_unset_mode (acfg);\n\t\t\tif (!prologue_end)\n\t\t\t\toptions = \" prologue_end\";\n\t\t\telse\n\t\t\t\toptions = \"\";\n\t\t\tprologue_end = TRUE;\n\t\t\tfprintf (acfg->fp, \".loc %d %d 0%s\\n\", findex, loc->row, options);\n\t\t\tmono_debug_free_source_location (loc);\n\t\t}\n\n\t\tskip = FALSE;\n#ifdef MONO_ARCH_AOT_SUPPORTED\n\t\tif (patch_info && (patch_info->ip.i == i) && (pindex < patches->len)) {\n\t\t\tstart_index = pindex;\n\n\t\t\tswitch (patch_info->type) {\n\t\t\tcase MONO_PATCH_INFO_NONE:\n\t\t\t\tbreak;\n\t\t\tcase MONO_PATCH_INFO_GOT_OFFSET: {\n\t\t\t\tint code_size;\n \n\t\t\t\tarch_emit_got_offset (acfg, code + i, &code_size);\n\t\t\t\ti += code_size - INST_LEN;\n\t\t\t\tskip = TRUE;\n\t\t\t\tpatch_info->type = MONO_PATCH_INFO_NONE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MONO_PATCH_INFO_OBJC_SELECTOR_REF: {\n\t\t\t\tint code_size, index;\n\t\t\t\tchar *selector = (char *)patch_info->data.target;\n\n\t\t\t\tif (!acfg->objc_selector_to_index)\n\t\t\t\t\tacfg->objc_selector_to_index = g_hash_table_new (g_str_hash, g_str_equal);\n\t\t\t\tif (!acfg->objc_selectors)\n\t\t\t\t\tacfg->objc_selectors = g_ptr_array_new ();\n\t\t\t\tindex = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->objc_selector_to_index, selector));\n\t\t\t\tif (index)\n\t\t\t\t\tindex --;\n\t\t\t\telse {\n\t\t\t\t\tindex = acfg->objc_selector_index;\n\t\t\t\t\tg_ptr_array_add (acfg->objc_selectors, (void*)patch_info->data.target);\n\t\t\t\t\tg_hash_table_insert (acfg->objc_selector_to_index, selector, GUINT_TO_POINTER (index + 1));\n\t\t\t\t\tacfg->objc_selector_index ++;\n\t\t\t\t}\n\n\t\t\t\tarch_emit_objc_selector_ref (acfg, code + i, index, &code_size);\n\t\t\t\ti += code_size - INST_LEN;\n\t\t\t\tskip = TRUE;\n\t\t\t\tpatch_info->type = MONO_PATCH_INFO_NONE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t/*\n\t\t\t\t * If this patch is a call, try emitting a direct call instead of\n\t\t\t\t * through a PLT entry. This is possible if the called method is in\n\t\t\t\t * the same assembly and requires no initialization.\n\t\t\t\t */\n\t\t\t\tdirect_call = FALSE;\n\t\t\t\texternal_call = FALSE;\n\t\t\t\tif ((patch_info->type == MONO_PATCH_INFO_METHOD) && (patch_info->data.method->klass->image == acfg->image)) {\n\t\t\t\t\tif (!got_only && is_direct_callable (acfg, method, patch_info)) {\n\t\t\t\t\t\tMonoCompile *callee_cfg = (MonoCompile *)g_hash_table_lookup (acfg->method_to_cfg, patch_info->data.method);\n\n\t\t\t\t\t\t// Don't compile inflated methods if we're doing dedup\n\t\t\t\t\t\tif (acfg->aot_opts.dedup && !mono_aot_can_dedup (patch_info->data.method)) {\n\t\t\t\t\t\t\tchar *name = mono_aot_get_mangled_method_name (patch_info->data.method);\n\t\t\t\t\t\t\tmono_trace (G_LOG_LEVEL_DEBUG, MONO_TRACE_AOT, \"DIRECT CALL: %s by %s\", name, method ? mono_method_full_name (method, TRUE) : \"\");\n\t\t\t\t\t\t\tg_free (name);\n\n\t\t\t\t\t\t\tdirect_call = TRUE;\n\t\t\t\t\t\t\tdirect_call_target = callee_cfg->asm_symbol;\n\t\t\t\t\t\t\tpatch_info->type = MONO_PATCH_INFO_NONE;\n\t\t\t\t\t\t\tacfg->stats.direct_calls ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tacfg->stats.all_calls ++;\n\t\t\t\t} else if (patch_info->type == MONO_PATCH_INFO_ICALL_ADDR_CALL) {\n\t\t\t\t\tif (!got_only && is_direct_callable (acfg, method, patch_info)) {\n\t\t\t\t\t\tif (!(patch_info->data.method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))\n\t\t\t\t\t\t\tdirect_pinvoke = mono_lookup_icall_symbol (patch_info->data.method);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdirect_pinvoke = get_pinvoke_import (acfg, patch_info->data.method);\n\t\t\t\t\t\tif (direct_pinvoke) {\n\t\t\t\t\t\t\tdirect_call = TRUE;\n\t\t\t\t\t\t\tg_assert (strlen (direct_pinvoke) < 1000);\n\t\t\t\t\t\t\tdirect_call_target = g_strdup_printf (\"%s%s\", acfg->user_symbol_prefix, direct_pinvoke);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (patch_info->type == MONO_PATCH_INFO_JIT_ICALL_ADDR) {\n\t\t\t\t\tconst char *sym = mono_lookup_jit_icall_symbol (patch_info->data.name);\n\t\t\t\t\tif (!got_only && sym && acfg->aot_opts.direct_icalls) {\n\t\t\t\t\t\t/* Call to a C function implementing a jit icall */\n\t\t\t\t\t\tdirect_call = TRUE;\n\t\t\t\t\t\texternal_call = TRUE;\n\t\t\t\t\t\tg_assert (strlen (sym) < 1000);\n\t\t\t\t\t\tdirect_call_target = g_strdup_printf (\"%s%s\", acfg->user_symbol_prefix, sym);\n\t\t\t\t\t}\n\t\t\t\t} else if (patch_info->type == MONO_PATCH_INFO_INTERNAL_METHOD) {\n\t\t\t\t\tMonoJitICallInfo *info = mono_find_jit_icall_by_name (patch_info->data.name);\n\t\t\t\t\tconst char *sym = mono_lookup_jit_icall_symbol (patch_info->data.name);\n\t\t\t\t\tif (!got_only && sym && acfg->aot_opts.direct_icalls && info->func == info->wrapper) {\n\t\t\t\t\t\t/* Call to a jit icall without a wrapper */\n\t\t\t\t\t\tdirect_call = TRUE;\n\t\t\t\t\t\texternal_call = TRUE;\n\t\t\t\t\t\tg_assert (strlen (sym) < 1000);\n\t\t\t\t\t\tdirect_call_target = g_strdup_printf (\"%s%s\", acfg->user_symbol_prefix, sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (direct_call) {\n\t\t\t\t\tpatch_info->type = MONO_PATCH_INFO_NONE;\n\t\t\t\t\tacfg->stats.direct_calls ++;\n\t\t\t\t}\n\n\t\t\t\tif (!got_only && !direct_call) {\n\t\t\t\t\tMonoPltEntry *plt_entry = get_plt_entry (acfg, patch_info);\n\t\t\t\t\tif (plt_entry) {\n\t\t\t\t\t\t/* This patch has a PLT entry, so we must emit a call to the PLT entry */\n\t\t\t\t\t\tdirect_call = TRUE;\n\t\t\t\t\t\tdirect_call_target = plt_entry->symbol;\n\t\t\n\t\t\t\t\t\t/* Nullify the patch */\n\t\t\t\t\t\tpatch_info->type = MONO_PATCH_INFO_NONE;\n\t\t\t\t\t\tplt_entry->jit_used = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (direct_call) {\n\t\t\t\t\tint call_size;\n\n\t\t\t\t\tarch_emit_direct_call (acfg, direct_call_target, external_call, FALSE, patch_info, &call_size);\n\t\t\t\t\ti += call_size - INST_LEN;\n\t\t\t\t} else {\n\t\t\t\t\tint code_size;\n\n\t\t\t\t\tgot_slot = get_got_offset (acfg, FALSE, patch_info);\n\n\t\t\t\t\tarch_emit_got_access (acfg, acfg->got_symbol, code + i, got_slot, &code_size);\n\t\t\t\t\ti += code_size - INST_LEN;\n\t\t\t\t}\n\t\t\t\tskip = TRUE;\n\t\t\t}\n\t\t\t}\n\t\t}\n#endif /* MONO_ARCH_AOT_SUPPORTED */\n\n\t\tif (!skip) {\n\t\t\t/* Find next patch */\n\t\t\tpatch_info = NULL;\n\t\t\tfor (pindex = start_index; pindex < patches->len; ++pindex) {\n\t\t\t\tpatch_info = (MonoJumpInfo *)g_ptr_array_index (patches, pindex);\n\t\t\t\tif (patch_info->ip.i >= i)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Try to emit multiple bytes at once */\n\t\t\tif (pindex < patches->len && patch_info->ip.i > i) {\n\t\t\t\tint limit;\n\n\t\t\t\tfor (limit = i + INST_LEN; limit < patch_info->ip.i; limit += INST_LEN) {\n\t\t\t\t\tif (locs && locs [limit])\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\temit_code_bytes (acfg, code + i, limit - i);\n\t\t\t\ti = limit - INST_LEN;\n\t\t\t} else {\n\t\t\t\temit_code_bytes (acfg, code + i, INST_LEN);\n\t\t\t}\n\t\t}\n\t}\n\n\tg_ptr_array_free (patches, TRUE);\n\tg_free (locs);\n}\n\n/*\n * sanitize_symbol:\n *\n *   Return a modified version of S which only includes characters permissible in symbols.\n */\nstatic char*\nsanitize_symbol (MonoAotCompile *acfg, char *s)\n{\n\tgboolean process = FALSE;\n\tint i, len;\n\tGString *gs;\n\tchar *res;\n\n\tif (!s)\n\t\treturn s;\n\n\tlen = strlen (s);\n\tfor (i = 0; i < len; ++i)\n\t\tif (!(s [i] <= 0x7f && (isalnum (s [i]) || s [i] == '_')))\n\t\t\tprocess = TRUE;\n\tif (!process)\n\t\treturn s;\n\n\tgs = g_string_sized_new (len);\n\tfor (i = 0; i < len; ++i) {\n\t\tguint8 c = s [i];\n\t\tif (c <= 0x7f && (isalnum (c) || c == '_')) {\n\t\t\tg_string_append_c (gs, c);\n\t\t} else if (c > 0x7f) {\n\t\t\t/* multi-byte utf8 */\n\t\t\tg_string_append_printf (gs, \"_0x%x\", c);\n\t\t\ti ++;\n\t\t\tc = s [i];\n\t\t\twhile (c >> 6 == 0x2) {\n\t\t\t\tg_string_append_printf (gs, \"%x\", c);\n\t\t\t\ti ++;\n\t\t\t\tc = s [i];\n\t\t\t}\n\t\t\tg_string_append_printf (gs, \"_\");\n\t\t\ti --;\n\t\t} else {\n\t\t\tg_string_append_c (gs, '_');\n\t\t}\n\t}\n\n\tres = mono_mempool_strdup (acfg->mempool, gs->str);\n\tg_string_free (gs, TRUE);\n\treturn res;\n}\n\nstatic char*\nget_debug_sym (MonoMethod *method, const char *prefix, GHashTable *cache)\n{\n\tchar *name1, *name2, *cached;\n\tint i, j, len, count;\n\tMonoMethod *cached_method;\n\n\tname1 = mono_method_full_name (method, TRUE);\n\n#ifdef TARGET_MACH\n\t// This is so that we don't accidentally create a local symbol (which starts with 'L')\n\tif ((!prefix || !*prefix) && name1 [0] == 'L')\n\t\tprefix = \"_\";\n#endif\n\n#if defined(TARGET_WIN32) && defined(TARGET_X86)\n\tchar adjustedPrefix [MAX_SYMBOL_SIZE];\n\tprefix = mangle_symbol (prefix, adjustedPrefix, G_N_ELEMENTS (adjustedPrefix));\n#endif\n\n\tlen = strlen (name1);\n\tname2 = (char *)malloc (strlen (prefix) + len + 16);\n\tmemcpy (name2, prefix, strlen (prefix));\n\tj = strlen (prefix);\n\tfor (i = 0; i < len; ++i) {\n\t\tif (i == 0 && name1 [0] >= '0' && name1 [0] <= '9') {\n\t\t\tname2 [j ++] = '_';\n\t\t} else if (isalnum (name1 [i])) {\n\t\t\tname2 [j ++] = name1 [i];\n\t\t} else if (name1 [i] == ' ' && name1 [i + 1] == '(' && name1 [i + 2] == ')') {\n\t\t\ti += 2;\n\t\t} else if (name1 [i] == ',' && name1 [i + 1] == ' ') {\n\t\t\tname2 [j ++] = '_';\n\t\t\ti++;\n\t\t} else if (name1 [i] == '(' || name1 [i] == ')' || name1 [i] == '>') {\n\t\t} else\n\t\t\tname2 [j ++] = '_';\n\t}\n\tname2 [j] = '\\0';\n\n\tg_free (name1);\n\n\tcount = 0;\n\twhile (TRUE) {\n\t\tcached_method = (MonoMethod *)g_hash_table_lookup (cache, name2);\n\t\tif (!(cached_method && cached_method != method))\n\t\t\tbreak;\n\t\tsprintf (name2 + j, \"_%d\", count);\n\t\tcount ++;\n\t}\n\n\tcached = g_strdup (name2);\n\tg_hash_table_insert (cache, cached, method);\n\n\treturn name2;\n}\n\nstatic void\nemit_method_code (MonoAotCompile *acfg, MonoCompile *cfg)\n{\n\tMonoMethod *method;\n\tint method_index;\n\tguint8 *code;\n\tchar *debug_sym = NULL;\n\tchar *symbol = NULL;\n\tint func_alignment = AOT_FUNC_ALIGNMENT;\n\tchar *export_name;\n\n\tg_assert (!ignore_cfg (cfg));\n\n\tmethod = cfg->orig_method;\n\tcode = cfg->native_code;\n\n\tmethod_index = get_method_index (acfg, method);\n\tsymbol = g_strdup_printf (\"%sme_%x\", acfg->temp_prefix, method_index);\n\n\t/* Make the labels local */\n\temit_section_change (acfg, \".text\", 0);\n\temit_alignment_code (acfg, func_alignment);\n\t\n\tif (acfg->global_symbols && acfg->need_no_dead_strip)\n\t\tfprintf (acfg->fp, \"\t.no_dead_strip %s\\n\", cfg->asm_symbol);\n\t\n\temit_label (acfg, cfg->asm_symbol);\n\n\tif (acfg->aot_opts.write_symbols && !acfg->global_symbols && !acfg->llvm) {\n\t\t/* \n\t\t * Write a C style symbol for every method, this has two uses:\n\t\t * - it works on platforms where the dwarf debugging info is not\n\t\t *   yet supported.\n\t\t * - it allows the setting of breakpoints of aot-ed methods.\n\t\t */\n\n\t\t// Comment out to force dedup to link these symbols and forbid compiling\n\t\t// in duplicated code. This is an \"assert when linking if broken\" trick.\n\t\t/*if (mono_aot_can_dedup (method) && (acfg->aot_opts.dedup || acfg->aot_opts.dedup_include))*/\n\t\t\t/*debug_sym = mono_aot_get_mangled_method_name (method);*/\n\t\t/*else*/\n\t\t\tdebug_sym = get_debug_sym (method, \"\", acfg->method_label_hash);\n\n\t\tcfg->asm_debug_symbol = g_strdup (debug_sym);\n\n\t\tif (acfg->need_no_dead_strip)\n\t\t\tfprintf (acfg->fp, \"\t.no_dead_strip %s\\n\", debug_sym);\n\n\t\t// Comment out to force dedup to link these symbols and forbid compiling\n\t\t// in duplicated code. This is an \"assert when linking if broken\" trick.\n\t\t/*if (mono_aot_can_dedup (method) && (acfg->aot_opts.dedup || acfg->aot_opts.dedup_include))*/\n\t\t\t/*emit_global_inner (acfg, debug_sym, TRUE);*/\n\t\t/*else*/\n\t\t\temit_local_symbol (acfg, debug_sym, symbol, TRUE);\n\n\t\temit_label (acfg, debug_sym);\n\t}\n\n\texport_name = (char *)g_hash_table_lookup (acfg->export_names, method);\n\tif (export_name) {\n\t\t/* Emit a global symbol for the method */\n\t\temit_global_inner (acfg, export_name, TRUE);\n\t\temit_label (acfg, export_name);\n\t}\n\n\tif (cfg->verbose_level > 0 && !ignore_cfg (cfg))\n\t\tg_print (\"Method %s emitted as %s\\n\", mono_method_get_full_name (method), cfg->asm_symbol);\n\n\tacfg->stats.code_size += cfg->code_len;\n\n\tacfg->cfgs [method_index]->got_offset = acfg->got_offset;\n\n\temit_and_reloc_code (acfg, method, code, cfg->code_len, cfg->patch_info, FALSE, mono_debug_find_method (cfg->jit_info->d.method, mono_domain_get ()));\n\n\temit_line (acfg);\n\n\tif (acfg->aot_opts.write_symbols) {\n\t\tif (debug_sym)\n\t\t\temit_symbol_size (acfg, debug_sym, \".\");\n\t\telse\n\t\t\temit_symbol_size (acfg, cfg->asm_symbol, \".\");\n\t\tg_free (debug_sym);\n\t}\n\n\temit_label (acfg, symbol);\n\n\tarch_emit_unwind_info_sections (acfg, cfg->asm_symbol, symbol, cfg->unwind_ops);\n\n\tg_free (symbol);\n}\n\n/**\n * encode_patch:\n *\n *  Encode PATCH_INFO into its disk representation.\n */\nstatic void\nencode_patch (MonoAotCompile *acfg, MonoJumpInfo *patch_info, guint8 *buf, guint8 **endbuf)\n{\n\tguint8 *p = buf;\n\n\tswitch (patch_info->type) {\n\tcase MONO_PATCH_INFO_NONE:\n\t\tbreak;\n\tcase MONO_PATCH_INFO_IMAGE:\n\t\tencode_value (get_image_index (acfg, patch_info->data.image), p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_MSCORLIB_GOT_ADDR:\n\tcase MONO_PATCH_INFO_GC_CARD_TABLE_ADDR:\n\tcase MONO_PATCH_INFO_GC_NURSERY_START:\n\tcase MONO_PATCH_INFO_GC_NURSERY_BITS:\n\t\tbreak;\n\tcase MONO_PATCH_INFO_CASTCLASS_CACHE:\n\t\tencode_value (patch_info->data.index, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_METHOD_REL:\n\t\tencode_value ((gint)patch_info->data.offset, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_SWITCH: {\n\t\tgpointer *table = (gpointer *)patch_info->data.table->table;\n\t\tint k;\n\n\t\tencode_value (patch_info->data.table->table_size, p, &p);\n\t\tfor (k = 0; k < patch_info->data.table->table_size; k++)\n\t\t\tencode_value ((int)(gssize)table [k], p, &p);\n\t\tbreak;\n\t}\n\tcase MONO_PATCH_INFO_METHODCONST:\n\tcase MONO_PATCH_INFO_METHOD:\n\tcase MONO_PATCH_INFO_METHOD_JUMP:\n\tcase MONO_PATCH_INFO_ICALL_ADDR:\n\tcase MONO_PATCH_INFO_ICALL_ADDR_CALL:\n\tcase MONO_PATCH_INFO_METHOD_RGCTX:\n\tcase MONO_PATCH_INFO_METHOD_CODE_SLOT:\n\t\tencode_method_ref (acfg, patch_info->data.method, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_AOT_JIT_INFO:\n\tcase MONO_PATCH_INFO_GET_TLS_TRAMP:\n\tcase MONO_PATCH_INFO_SET_TLS_TRAMP:\n\t\tencode_value (patch_info->data.index, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_INTERNAL_METHOD:\n\tcase MONO_PATCH_INFO_JIT_ICALL_ADDR:\n\tcase MONO_PATCH_INFO_JIT_ICALL_ADDR_NOCALL: {\n\t\tguint32 len = strlen (patch_info->data.name);\n\n\t\tencode_value (len, p, &p);\n\n\t\tmemcpy (p, patch_info->data.name, len);\n\t\tp += len;\n\t\t*p++ = '\\0';\n\t\tbreak;\n\t}\n\tcase MONO_PATCH_INFO_LDSTR: {\n\t\tguint32 image_index = get_image_index (acfg, patch_info->data.token->image);\n\t\tguint32 token = patch_info->data.token->token;\n\t\tg_assert (mono_metadata_token_code (token) == MONO_TOKEN_STRING);\n\t\tencode_value (image_index, p, &p);\n\t\tencode_value (patch_info->data.token->token - MONO_TOKEN_STRING, p, &p);\n\t\tbreak;\n\t}\n\tcase MONO_PATCH_INFO_RVA:\n\tcase MONO_PATCH_INFO_DECLSEC:\n\tcase MONO_PATCH_INFO_LDTOKEN:\n\tcase MONO_PATCH_INFO_TYPE_FROM_HANDLE:\n\t\tencode_value (get_image_index (acfg, patch_info->data.token->image), p, &p);\n\t\tencode_value (patch_info->data.token->token, p, &p);\n\t\tencode_value (patch_info->data.token->has_context, p, &p);\n\t\tif (patch_info->data.token->has_context)\n\t\t\tencode_generic_context (acfg, &patch_info->data.token->context, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_EXC_NAME: {\n\t\tMonoClass *ex_class;\n\n\t\tex_class =\n\t\t\tmono_class_load_from_name (mono_defaults.exception_class->image,\n\t\t\t\t\t\t\t\t  \"System\", (const char *)patch_info->data.target);\n\t\tencode_klass_ref (acfg, ex_class, p, &p);\n\t\tbreak;\n\t}\n\tcase MONO_PATCH_INFO_R4:\n\t\tencode_value (*((guint32 *)patch_info->data.target), p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_R8:\n\t\tencode_value (((guint32 *)patch_info->data.target) [MINI_LS_WORD_IDX], p, &p);\n\t\tencode_value (((guint32 *)patch_info->data.target) [MINI_MS_WORD_IDX], p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_VTABLE:\n\tcase MONO_PATCH_INFO_CLASS:\n\tcase MONO_PATCH_INFO_IID:\n\tcase MONO_PATCH_INFO_ADJUSTED_IID:\n\t\tencode_klass_ref (acfg, patch_info->data.klass, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_DELEGATE_TRAMPOLINE:\n\t\tencode_klass_ref (acfg, patch_info->data.del_tramp->klass, p, &p);\n\t\tif (patch_info->data.del_tramp->method) {\n\t\t\tencode_value (1, p, &p);\n\t\t\tencode_method_ref (acfg, patch_info->data.del_tramp->method, p, &p);\n\t\t} else {\n\t\t\tencode_value (0, p, &p);\n\t\t}\n\t\tencode_value (patch_info->data.del_tramp->is_virtual, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_FIELD:\n\tcase MONO_PATCH_INFO_SFLDA:\n\t\tencode_field_info (acfg, patch_info->data.field, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_INTERRUPTION_REQUEST_FLAG:\n\t\tbreak;\n\tcase MONO_PATCH_INFO_PROFILER_ALLOCATION_COUNT:\n\t\tbreak;\n\tcase MONO_PATCH_INFO_RGCTX_FETCH:\n\tcase MONO_PATCH_INFO_RGCTX_SLOT_INDEX: {\n\t\tMonoJumpInfoRgctxEntry *entry = patch_info->data.rgctx_entry;\n\t\tguint32 offset;\n\t\tguint8 *buf2, *p2;\n\n\t\t/* \n\t\t * entry->method has a lenghtly encoding and multiple rgctx_fetch entries\n\t\t * reference the same method, so encode the method only once.\n\t\t */\n\t\toffset = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->method_blob_hash, entry->method));\n\t\tif (!offset) {\n\t\t\tbuf2 = (guint8 *)g_malloc (1024);\n\t\t\tp2 = buf2;\n\n\t\t\tencode_method_ref (acfg, entry->method, p2, &p2);\n\t\t\tg_assert (p2 - buf2 < 1024);\n\n\t\t\toffset = add_to_blob (acfg, buf2, p2 - buf2);\n\t\t\tg_free (buf2);\n\n\t\t\tg_hash_table_insert (acfg->method_blob_hash, entry->method, GUINT_TO_POINTER (offset + 1));\n\t\t} else {\n\t\t\toffset --;\n\t\t}\n\n\t\tencode_value (offset, p, &p);\n\t\tg_assert ((int)entry->info_type < 256);\n\t\tg_assert (entry->data->type < 256);\n\t\tencode_value ((entry->in_mrgctx ? 1 : 0) | (entry->info_type << 1) | (entry->data->type << 9), p, &p);\n\t\tencode_patch (acfg, entry->data, p, &p);\n\t\tbreak;\n\t}\n\tcase MONO_PATCH_INFO_SEQ_POINT_INFO:\n\tcase MONO_PATCH_INFO_AOT_MODULE:\n\t\tbreak;\n\tcase MONO_PATCH_INFO_SIGNATURE:\n\tcase MONO_PATCH_INFO_GSHAREDVT_IN_WRAPPER:\n\t\tencode_signature (acfg, (MonoMethodSignature*)patch_info->data.target, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_GSHAREDVT_CALL:\n\t\tencode_signature (acfg, (MonoMethodSignature*)patch_info->data.gsharedvt->sig, p, &p);\n\t\tencode_method_ref (acfg, patch_info->data.gsharedvt->method, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_GSHAREDVT_METHOD: {\n\t\tMonoGSharedVtMethodInfo *info = patch_info->data.gsharedvt_method;\n\t\tint i;\n\n\t\tencode_method_ref (acfg, info->method, p, &p);\n\t\tencode_value (info->num_entries, p, &p);\n\t\tfor (i = 0; i < info->num_entries; ++i) {\n\t\t\tMonoRuntimeGenericContextInfoTemplate *template_ = &info->entries [i];\n\n\t\t\tencode_value (template_->info_type, p, &p);\n\t\t\tswitch (mini_rgctx_info_type_to_patch_info_type (template_->info_type)) {\n\t\t\tcase MONO_PATCH_INFO_CLASS:\n\t\t\t\tencode_klass_ref (acfg, mono_class_from_mono_type ((MonoType *)template_->data), p, &p);\n\t\t\t\tbreak;\n\t\t\tcase MONO_PATCH_INFO_FIELD:\n\t\t\t\tencode_field_info (acfg, (MonoClassField *)template_->data, p, &p);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_PATCH_INFO_LDSTR_LIT: {\n\t\tconst char *s = (const char *)patch_info->data.target;\n\t\tint len = strlen (s);\n\n\t\tencode_value (len, p, &p);\n\t\tmemcpy (p, s, len + 1);\n\t\tp += len + 1;\n\t\tbreak;\n\t}\n\tcase MONO_PATCH_INFO_VIRT_METHOD:\n\t\tencode_klass_ref (acfg, patch_info->data.virt_method->klass, p, &p);\n\t\tencode_method_ref (acfg, patch_info->data.virt_method->method, p, &p);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_GC_SAFE_POINT_FLAG:\n\tcase MONO_PATCH_INFO_JIT_THREAD_ATTACH:\n\t\tbreak;\n\tdefault:\n\t\tg_warning (\"unable to handle jump info %d\", patch_info->type);\n\t\tg_assert_not_reached ();\n\t}\n\n\t*endbuf = p;\n}\n\nstatic void\nencode_patch_list (MonoAotCompile *acfg, GPtrArray *patches, int n_patches, gboolean llvm, int first_got_offset, guint8 *buf, guint8 **endbuf)\n{\n\tguint8 *p = buf;\n\tguint32 pindex, offset;\n\tMonoJumpInfo *patch_info;\n\n\tencode_value (n_patches, p, &p);\n\n\tfor (pindex = 0; pindex < patches->len; ++pindex) {\n\t\tpatch_info = (MonoJumpInfo *)g_ptr_array_index (patches, pindex);\n\n\t\tif (patch_info->type == MONO_PATCH_INFO_NONE || patch_info->type == MONO_PATCH_INFO_BB)\n\t\t\t/* Nothing to do */\n\t\t\tcontinue;\n\n\t\toffset = get_got_offset (acfg, llvm, patch_info);\n\t\tencode_value (offset, p, &p);\n\t}\n\n\t*endbuf = p;\n}\n\nstatic void\nemit_method_info (MonoAotCompile *acfg, MonoCompile *cfg)\n{\n\tMonoMethod *method;\n\tint pindex, buf_size, n_patches;\n\tGPtrArray *patches;\n\tMonoJumpInfo *patch_info;\n\tguint32 method_index;\n\tguint8 *p, *buf;\n\tguint32 first_got_offset;\n\n\tmethod = cfg->orig_method;\n\n\tmethod_index = get_method_index (acfg, method);\n\n\t/* Sort relocations */\n\tpatches = g_ptr_array_new ();\n\tfor (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next)\n\t\tg_ptr_array_add (patches, patch_info);\n\tg_ptr_array_sort (patches, compare_patches);\n\n\tfirst_got_offset = acfg->cfgs [method_index]->got_offset;\n\n\t/**********************/\n\t/* Encode method info */\n\t/**********************/\n\n\tbuf_size = (patches->len < 1000) ? 40960 : 40960 + (patches->len * 64);\n\tp = buf = (guint8 *)g_malloc (buf_size);\n\n\tif (mono_class_get_cctor (method->klass)) {\n\t\tencode_value (1, p, &p);\n\t\tencode_klass_ref (acfg, method->klass, p, &p);\n\t} else {\n\t\t/* Not needed when loading the method */\n\t\tencode_value (0, p, &p);\n\t}\n\n\tg_assert (!(cfg->opt & MONO_OPT_SHARED));\n\n\tn_patches = 0;\n\tfor (pindex = 0; pindex < patches->len; ++pindex) {\n\t\tpatch_info = (MonoJumpInfo *)g_ptr_array_index (patches, pindex);\n\t\t\n\t\tif ((patch_info->type == MONO_PATCH_INFO_GOT_OFFSET) ||\n\t\t\t(patch_info->type == MONO_PATCH_INFO_NONE)) {\n\t\t\tpatch_info->type = MONO_PATCH_INFO_NONE;\n\t\t\t/* Nothing to do */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((patch_info->type == MONO_PATCH_INFO_IMAGE) && (patch_info->data.image == acfg->image)) {\n\t\t\t/* Stored in a GOT slot initialized at module load time */\n\t\t\tpatch_info->type = MONO_PATCH_INFO_NONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (patch_info->type == MONO_PATCH_INFO_GC_CARD_TABLE_ADDR ||\n\t\t\tpatch_info->type == MONO_PATCH_INFO_GC_NURSERY_START ||\n\t\t\tpatch_info->type == MONO_PATCH_INFO_GC_NURSERY_BITS ||\n\t\t\tpatch_info->type == MONO_PATCH_INFO_AOT_MODULE) {\n\t\t\t/* Stored in a GOT slot initialized at module load time */\n\t\t\tpatch_info->type = MONO_PATCH_INFO_NONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_plt_patch (patch_info) && !(cfg->compile_llvm && acfg->aot_opts.llvm_only)) {\n\t\t\t/* Calls are made through the PLT */\n\t\t\tpatch_info->type = MONO_PATCH_INFO_NONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tn_patches ++;\n\t}\n\n\tif (n_patches)\n\t\tg_assert (cfg->has_got_slots);\n\n\tencode_patch_list (acfg, patches, n_patches, cfg->compile_llvm, first_got_offset, p, &p);\n\n\tg_ptr_array_free (patches, TRUE);\n\n\tacfg->stats.info_size += p - buf;\n\n\tg_assert (p - buf < buf_size);\n\n\tcfg->method_info_offset = add_to_blob (acfg, buf, p - buf);\n\tg_free (buf);\n}\n\nstatic guint32\nget_unwind_info_offset (MonoAotCompile *acfg, guint8 *encoded, guint32 encoded_len)\n{\n\tguint32 cache_index;\n\tguint32 offset;\n\n\t/* Reuse the unwind module to canonize and store unwind info entries */\n\tcache_index = mono_cache_unwind_info (encoded, encoded_len);\n\n\t/* Use +/- 1 to distinguish 0s from missing entries */\n\toffset = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->unwind_info_offsets, GUINT_TO_POINTER (cache_index + 1)));\n\tif (offset)\n\t\treturn offset - 1;\n\telse {\n\t\tguint8 buf [16];\n\t\tguint8 *p;\n\n\t\t/* \n\t\t * It would be easier to use assembler symbols, but the caller needs an\n\t\t * offset now.\n\t\t */\n\t\toffset = acfg->unwind_info_offset;\n\t\tg_hash_table_insert (acfg->unwind_info_offsets, GUINT_TO_POINTER (cache_index + 1), GUINT_TO_POINTER (offset + 1));\n\t\tg_ptr_array_add (acfg->unwind_ops, GUINT_TO_POINTER (cache_index));\n\n\t\tp = buf;\n\t\tencode_value (encoded_len, p, &p);\n\n\t\tacfg->unwind_info_offset += encoded_len + (p - buf);\n\t\treturn offset;\n\t}\n}\n\nstatic void\nemit_exception_debug_info (MonoAotCompile *acfg, MonoCompile *cfg, gboolean store_seq_points)\n{\n\tint i, k, buf_size;\n\tguint32 debug_info_size, seq_points_size;\n\tguint8 *code;\n\tMonoMethodHeader *header;\n\tguint8 *p, *buf, *debug_info;\n\tMonoJitInfo *jinfo = cfg->jit_info;\n\tguint32 flags;\n\tgboolean use_unwind_ops = FALSE;\n\tMonoSeqPointInfo *seq_points;\n\n\tcode = cfg->native_code;\n\theader = cfg->header;\n\n\tif (!acfg->aot_opts.nodebug) {\n\t\tmono_debug_serialize_debug_info (cfg, &debug_info, &debug_info_size);\n\t} else {\n\t\tdebug_info = NULL;\n\t\tdebug_info_size = 0;\n\t}\n\n\tseq_points = cfg->seq_point_info;\n\tseq_points_size = (store_seq_points)? mono_seq_point_info_get_write_size (seq_points) : 0;\n\n\tbuf_size = header->num_clauses * 256 + debug_info_size + 2048 + seq_points_size + cfg->gc_map_size;\n\tif (jinfo->has_try_block_holes) {\n\t\tMonoTryBlockHoleTableJitInfo *table = mono_jit_info_get_try_block_hole_table_info (jinfo);\n\t\tbuf_size += table->num_holes * 16;\n\t}\n\n\tp = buf = (guint8 *)g_malloc (buf_size);\n\n\tuse_unwind_ops = cfg->unwind_ops != NULL;\n\n\tflags = (jinfo->has_generic_jit_info ? 1 : 0) | (use_unwind_ops ? 2 : 0) | (header->num_clauses ? 4 : 0) | (seq_points_size ? 8 : 0) | (cfg->compile_llvm ? 16 : 0) | (jinfo->has_try_block_holes ? 32 : 0) | (cfg->gc_map ? 64 : 0) | (jinfo->has_arch_eh_info ? 128 : 0);\n\n\tencode_value (flags, p, &p);\n\n\tif (use_unwind_ops) {\n\t\tguint32 encoded_len;\n\t\tguint8 *encoded;\n\t\tguint32 unwind_desc;\n\n\t\tencoded = mono_unwind_ops_encode (cfg->unwind_ops, &encoded_len);\n\n\t\tunwind_desc = get_unwind_info_offset (acfg, encoded, encoded_len);\n\t\tencode_value (unwind_desc, p, &p);\n\n\t\tg_free (encoded);\n\t} else {\n\t\tencode_value (jinfo->unwind_info, p, &p);\n\t}\n\n\t/*Encode the number of holes before the number of clauses to make decoding easier*/\n\tif (jinfo->has_try_block_holes) {\n\t\tMonoTryBlockHoleTableJitInfo *table = mono_jit_info_get_try_block_hole_table_info (jinfo);\n\t\tencode_value (table->num_holes, p, &p);\n\t}\n\n\tif (jinfo->has_arch_eh_info) {\n\t\t/*\n\t\t * In AOT mode, the code length is calculated from the address of the previous method,\n\t\t * which could include alignment padding, so calculating the start of the epilog as\n\t\t * code_len - epilog_size is correct any more. Save the real code len as a workaround.\n\t\t */\n\t\tencode_value (jinfo->code_size, p, &p);\n\t}\n\n\t/* Exception table */\n\tif (cfg->compile_llvm) {\n\t\t/*\n\t\t * When using LLVM, we can't emit some data, like pc offsets, this reg/offset etc.,\n\t\t * since the information is only available to llc. Instead, we let llc save the data\n\t\t * into the LSDA, and read it from there at runtime.\n\t\t */\n\t\t/* The assembly might be CIL stripped so emit the data ourselves */\n\t\tif (header->num_clauses)\n\t\t\tencode_value (header->num_clauses, p, &p);\n\n\t\tfor (k = 0; k < header->num_clauses; ++k) {\n\t\t\tMonoExceptionClause *clause;\n\n\t\t\tclause = &header->clauses [k];\n\n\t\t\tencode_value (clause->flags, p, &p);\n\t\t\tif (!(clause->flags == MONO_EXCEPTION_CLAUSE_FILTER || clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY)) {\n\t\t\t\tif (clause->data.catch_class) {\n\t\t\t\t\tguint8 *buf2, *p2;\n\t\t\t\t\tint len;\n\n\t\t\t\t\tbuf2 = (guint8 *)g_malloc (4096);\n\t\t\t\t\tp2 = buf2;\n\t\t\t\t\tencode_klass_ref (acfg, clause->data.catch_class, p2, &p2);\n\t\t\t\t\tlen = p2 - buf2;\n\t\t\t\t\tg_assert (len < 4096);\n\t\t\t\t\tencode_value (len, p, &p);\n\t\t\t\t\tmemcpy (p, buf2, len);\n\t\t\t\t\tp += p2 - buf2;\n\t\t\t\t\tg_free (buf2);\n\t\t\t\t} else {\n\t\t\t\t\tencode_value (0, p, &p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Emit the IL ranges too, since they might not be available at runtime */\n\t\t\tencode_value (clause->try_offset, p, &p);\n\t\t\tencode_value (clause->try_len, p, &p);\n\t\t\tencode_value (clause->handler_offset, p, &p);\n\t\t\tencode_value (clause->handler_len, p, &p);\n\n\t\t\t/* Emit a list of nesting clauses */\n\t\t\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\t\t\tgint32 cindex1 = k;\n\t\t\t\tMonoExceptionClause *clause1 = &header->clauses [cindex1];\n\t\t\t\tgint32 cindex2 = i;\n\t\t\t\tMonoExceptionClause *clause2 = &header->clauses [cindex2];\n\n\t\t\t\tif (cindex1 != cindex2 && clause1->try_offset >= clause2->try_offset && clause1->handler_offset <= clause2->handler_offset)\n\t\t\t\t\tencode_value (i, p, &p);\n\t\t\t}\n\t\t\tencode_value (-1, p, &p);\n\t\t}\n\t} else {\n\t\tif (jinfo->num_clauses)\n\t\t\tencode_value (jinfo->num_clauses, p, &p);\n\n\t\tfor (k = 0; k < jinfo->num_clauses; ++k) {\n\t\t\tMonoJitExceptionInfo *ei = &jinfo->clauses [k];\n\n\t\t\tencode_value (ei->flags, p, &p);\n#ifdef MONO_CONTEXT_SET_LLVM_EXC_REG\n\t\t\t/* Not used for catch clauses */\n\t\t\tif (ei->flags != MONO_EXCEPTION_CLAUSE_NONE)\n\t\t\t\tencode_value (ei->exvar_offset, p, &p);\n#else\n\t\t\tencode_value (ei->exvar_offset, p, &p);\n#endif\n\n\t\t\tif (ei->flags == MONO_EXCEPTION_CLAUSE_FILTER || ei->flags == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\tencode_value ((gint)((guint8*)ei->data.filter - code), p, &p);\n\t\t\telse {\n\t\t\t\tif (ei->data.catch_class) {\n\t\t\t\t\tguint8 *buf2, *p2;\n\t\t\t\t\tint len;\n\n\t\t\t\t\tbuf2 = (guint8 *)g_malloc (4096);\n\t\t\t\t\tp2 = buf2;\n\t\t\t\t\tencode_klass_ref (acfg, ei->data.catch_class, p2, &p2);\n\t\t\t\t\tlen = p2 - buf2;\n\t\t\t\t\tg_assert (len < 4096);\n\t\t\t\t\tencode_value (len, p, &p);\n\t\t\t\t\tmemcpy (p, buf2, len);\n\t\t\t\t\tp += p2 - buf2;\n\t\t\t\t\tg_free (buf2);\n\t\t\t\t} else {\n\t\t\t\t\tencode_value (0, p, &p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tencode_value ((gint)((guint8*)ei->try_start - code), p, &p);\n\t\t\tencode_value ((gint)((guint8*)ei->try_end - code), p, &p);\n\t\t\tencode_value ((gint)((guint8*)ei->handler_start - code), p, &p);\n\t\t}\n\t}\n\n\tif (jinfo->has_try_block_holes) {\n\t\tMonoTryBlockHoleTableJitInfo *table = mono_jit_info_get_try_block_hole_table_info (jinfo);\n\t\tfor (i = 0; i < table->num_holes; ++i) {\n\t\t\tMonoTryBlockHoleJitInfo *hole = &table->holes [i];\n\t\t\tencode_value (hole->clause, p, &p);\n\t\t\tencode_value (hole->length, p, &p);\n\t\t\tencode_value (hole->offset, p, &p);\n\t\t}\n\t}\n\n\tif (jinfo->has_arch_eh_info) {\n\t\tMonoArchEHJitInfo *eh_info;\n\n\t\teh_info = mono_jit_info_get_arch_eh_info (jinfo);\n\t\tencode_value (eh_info->stack_size, p, &p);\n\t\tencode_value (eh_info->epilog_size, p, &p);\n\t}\n\n\tif (jinfo->has_generic_jit_info) {\n\t\tMonoGenericJitInfo *gi = mono_jit_info_get_generic_jit_info (jinfo);\n\t\tMonoGenericSharingContext* gsctx = gi->generic_sharing_context;\n\t\tguint8 *buf2, *p2;\n\t\tint len;\n\n\t\tencode_value (gi->nlocs, p, &p);\n\t\tif (gi->nlocs) {\n\t\t\tfor (i = 0; i < gi->nlocs; ++i) {\n\t\t\t\tMonoDwarfLocListEntry *entry = &gi->locations [i];\n\n\t\t\t\tencode_value (entry->is_reg ? 1 : 0, p, &p);\n\t\t\t\tencode_value (entry->reg, p, &p);\n\t\t\t\tif (!entry->is_reg)\n\t\t\t\t\tencode_value (entry->offset, p, &p);\n\t\t\t\tif (i == 0)\n\t\t\t\t\tg_assert (entry->from == 0);\n\t\t\t\telse\n\t\t\t\t\tencode_value (entry->from, p, &p);\n\t\t\t\tencode_value (entry->to, p, &p);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!cfg->compile_llvm) {\n\t\t\t\tencode_value (gi->has_this ? 1 : 0, p, &p);\n\t\t\t\tencode_value (gi->this_reg, p, &p);\n\t\t\t\tencode_value (gi->this_offset, p, &p);\n\t\t\t}\n\t\t}\n\n\t\t/* \n\t\t * Need to encode jinfo->method too, since it is not equal to 'method'\n\t\t * when using generic sharing.\n\t\t */\n\t\tbuf2 = (guint8 *)g_malloc (4096);\n\t\tp2 = buf2;\n\t\tencode_method_ref (acfg, jinfo->d.method, p2, &p2);\n\t\tlen = p2 - buf2;\n\t\tg_assert (len < 4096);\n\t\tencode_value (len, p, &p);\n\t\tmemcpy (p, buf2, len);\n\t\tp += p2 - buf2;\n\t\tg_free (buf2);\n\n\t\tif (gsctx && gsctx->is_gsharedvt) {\n\t\t\tencode_value (1, p, &p);\n\t\t} else {\n\t\t\tencode_value (0, p, &p);\n\t\t}\n\t}\n\n\tif (seq_points_size)\n\t\tp += mono_seq_point_info_write (seq_points, p);\n\n\tg_assert (debug_info_size < buf_size);\n\n\tencode_value (debug_info_size, p, &p);\n\tif (debug_info_size) {\n\t\tmemcpy (p, debug_info, debug_info_size);\n\t\tp += debug_info_size;\n\t\tg_free (debug_info);\n\t}\n\n\t/* GC Map */\n\tif (cfg->gc_map) {\n\t\tencode_value (cfg->gc_map_size, p, &p);\n\t\t/* The GC map requires 4 bytes of alignment */\n\t\twhile ((gsize)p % 4)\n\t\t\tp ++;\n\t\tmemcpy (p, cfg->gc_map, cfg->gc_map_size);\n\t\tp += cfg->gc_map_size;\n\t}\n\n\tacfg->stats.ex_info_size += p - buf;\n\n\tg_assert (p - buf < buf_size);\n\n\t/* Emit info */\n\t/* The GC Map requires 4 byte alignment */\n\tcfg->ex_info_offset = add_to_blob_aligned (acfg, buf, p - buf, cfg->gc_map ? 4 : 1);\n\tg_free (buf);\n}\n\nstatic guint32\nemit_klass_info (MonoAotCompile *acfg, guint32 token)\n{\n\tMonoError error;\n\tMonoClass *klass = mono_class_get_checked (acfg->image, token, &error);\n\tguint8 *p, *buf;\n\tint i, buf_size, res;\n\tgboolean no_special_static, cant_encode;\n\tgpointer iter = NULL;\n\n\tif (!klass) {\n\t\tmono_error_cleanup (&error);\n\n\t\tbuf_size = 16;\n\n\t\tp = buf = (guint8 *)g_malloc (buf_size);\n\n\t\t/* Mark as unusable */\n\t\tencode_value (-1, p, &p);\n\n\t\tres = add_to_blob (acfg, buf, p - buf);\n\t\tg_free (buf);\n\n\t\treturn res;\n\t}\n\t\t\n\tbuf_size = 10240 + (klass->vtable_size * 16);\n\tp = buf = (guint8 *)g_malloc (buf_size);\n\n\tg_assert (klass);\n\n\tmono_class_init (klass);\n\n\tmono_class_get_nested_types (klass, &iter);\n\tg_assert (klass->nested_classes_inited);\n\n\tmono_class_setup_vtable (klass);\n\n\t/* \n\t * Emit all the information which is required for creating vtables so\n\t * the runtime does not need to create the MonoMethod structures which\n\t * take up a lot of space.\n\t */\n\n\tno_special_static = !mono_class_has_special_static_fields (klass);\n\n\t/* Check whenever we have enough info to encode the vtable */\n\tcant_encode = FALSE;\n\tfor (i = 0; i < klass->vtable_size; ++i) {\n\t\tMonoMethod *cm = klass->vtable [i];\n\n\t\tif (cm && mono_method_signature (cm)->is_inflated && !g_hash_table_lookup (acfg->token_info_hash, cm))\n\t\t\tcant_encode = TRUE;\n\t}\n\n\tmono_class_has_finalizer (klass);\n\tif (mono_class_has_failure (klass))\n\t\tcant_encode = TRUE;\n\n\tif (mono_class_is_gtd (klass) || cant_encode) {\n\t\tencode_value (-1, p, &p);\n\t} else {\n\t\tgboolean has_nested = mono_class_get_nested_classes_property (klass) != NULL;\n\t\tencode_value (klass->vtable_size, p, &p);\n\t\tencode_value ((klass->has_weak_fields << 9) | (mono_class_is_gtd (klass) ? (1 << 8) : 0) | (no_special_static << 7) | (klass->has_static_refs << 6) | (klass->has_references << 5) | ((klass->blittable << 4) | (has_nested ? 1 : 0) << 3) | (klass->has_cctor << 2) | (klass->has_finalize << 1) | klass->ghcimpl, p, &p);\n\t\tif (klass->has_cctor)\n\t\t\tencode_method_ref (acfg, mono_class_get_cctor (klass), p, &p);\n\t\tif (klass->has_finalize)\n\t\t\tencode_method_ref (acfg, mono_class_get_finalizer (klass), p, &p);\n \n\t\tencode_value (klass->instance_size, p, &p);\n\t\tencode_value (mono_class_data_size (klass), p, &p);\n\t\tencode_value (klass->packing_size, p, &p);\n\t\tencode_value (klass->min_align, p, &p);\n\n\t\tfor (i = 0; i < klass->vtable_size; ++i) {\n\t\t\tMonoMethod *cm = klass->vtable [i];\n\n\t\t\tif (cm)\n\t\t\t\tencode_method_ref (acfg, cm, p, &p);\n\t\t\telse\n\t\t\t\tencode_value (0, p, &p);\n\t\t}\n\t}\n\n\tacfg->stats.class_info_size += p - buf;\n\n\tg_assert (p - buf < buf_size);\n\tres = add_to_blob (acfg, buf, p - buf);\n\tg_free (buf);\n\n\treturn res;\n}\n\nstatic char*\nget_plt_entry_debug_sym (MonoAotCompile *acfg, MonoJumpInfo *ji, GHashTable *cache)\n{\n\tchar *debug_sym = NULL;\n\tchar *prefix;\n\n\tif (acfg->llvm && llvm_acfg->aot_opts.static_link) {\n\t\t/* Need to add a prefix to create unique symbols */\n\t\tprefix = g_strdup_printf (\"plt_%s_\", acfg->assembly_name_sym);\n\t} else {\n#if defined(TARGET_WIN32) && defined(TARGET_X86)\n\t\tprefix = mangle_symbol_alloc (\"plt_\");\n#else\n\t\tprefix = g_strdup (\"plt_\");\n#endif\n\t}\n\n\tswitch (ji->type) {\n\tcase MONO_PATCH_INFO_METHOD:\n\t\tdebug_sym = get_debug_sym (ji->data.method, prefix, cache);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_INTERNAL_METHOD:\n\t\tdebug_sym = g_strdup_printf (\"%s_jit_icall_%s\", prefix, ji->data.name);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_RGCTX_FETCH:\n\t\tdebug_sym = g_strdup_printf (\"%s_rgctx_fetch_%d\", prefix, acfg->label_generator ++);\n\t\tbreak;\n\tcase MONO_PATCH_INFO_ICALL_ADDR:\n\tcase MONO_PATCH_INFO_ICALL_ADDR_CALL: {\n\t\tchar *s = get_debug_sym (ji->data.method, \"\", cache);\n\t\t\n\t\tdebug_sym = g_strdup_printf (\"%s_icall_native_%s\", prefix, s);\n\t\tg_free (s);\n\t\tbreak;\n\t}\n\tcase MONO_PATCH_INFO_JIT_ICALL_ADDR:\n\t\tdebug_sym = g_strdup_printf (\"%s_jit_icall_native_%s\", prefix, ji->data.name);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tg_free (prefix);\n\n\treturn sanitize_symbol (acfg, debug_sym);\n}\n\n/*\n * Calls made from AOTed code are routed through a table of jumps similar to the\n * ELF PLT (Program Linkage Table). Initially the PLT entries jump to code which transfers\n * control to the AOT runtime through a trampoline.\n */\nstatic void\nemit_plt (MonoAotCompile *acfg)\n{\n\tint i;\n\n\tif (acfg->aot_opts.llvm_only) {\n\t\tg_assert (acfg->plt_offset == 1);\n\t\treturn;\n\t}\n\n\temit_line (acfg);\n\n\temit_section_change (acfg, \".text\", 0);\n\temit_alignment_code (acfg, 16);\n\temit_info_symbol (acfg, \"plt\");\n\temit_label (acfg, acfg->plt_symbol);\n\n\tfor (i = 0; i < acfg->plt_offset; ++i) {\n\t\tchar *debug_sym = NULL;\n\t\tMonoPltEntry *plt_entry = NULL;\n\n\t\tif (i == 0)\n\t\t\t/* \n\t\t\t * The first plt entry is unused.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tplt_entry = (MonoPltEntry *)g_hash_table_lookup (acfg->plt_offset_to_entry, GUINT_TO_POINTER (i));\n\n\t\tdebug_sym = plt_entry->debug_sym;\n\n\t\tif (acfg->thumb_mixed && !plt_entry->jit_used)\n\t\t\t/* Emit only a thumb version */\n\t\t\tcontinue;\n\n\t\t/* Skip plt entries not actually called */\n\t\tif (!plt_entry->jit_used && !plt_entry->llvm_used)\n\t\t\tcontinue;\n\n\t\tif (acfg->llvm && !acfg->thumb_mixed) {\n\t\t\temit_label (acfg, plt_entry->llvm_symbol);\n\t\t\tif (acfg->llvm) {\n\t\t\t\temit_global_inner (acfg, plt_entry->llvm_symbol, TRUE);\n#if defined(TARGET_MACH)\n\t\t\t\tfprintf (acfg->fp, \".private_extern %s\\n\", plt_entry->llvm_symbol);\n#endif\n\t\t\t}\n\t\t}\n\n\t\tif (debug_sym) {\n\t\t\tif (acfg->need_no_dead_strip) {\n\t\t\t\temit_unset_mode (acfg);\n\t\t\t\tfprintf (acfg->fp, \"\t.no_dead_strip %s\\n\", debug_sym);\n\t\t\t}\n\t\t\temit_local_symbol (acfg, debug_sym, NULL, TRUE);\n\t\t\temit_label (acfg, debug_sym);\n\t\t}\n\n\t\temit_label (acfg, plt_entry->symbol);\n\n\t\tarch_emit_plt_entry (acfg, acfg->got_symbol, (acfg->plt_got_offset_base + i) * sizeof (gpointer), acfg->plt_got_info_offsets [i]);\n\n\t\tif (debug_sym)\n\t\t\temit_symbol_size (acfg, debug_sym, \".\");\n\t}\n\n\tif (acfg->thumb_mixed) {\n\t\t/* Make sure the ARM symbols don't alias the thumb ones */\n\t\temit_zero_bytes (acfg, 16);\n\n\t\t/* \n\t\t * Emit a separate set of PLT entries using thumb2 which is called by LLVM generated\n\t\t * code.\n\t\t */\n\t\tfor (i = 0; i < acfg->plt_offset; ++i) {\n\t\t\tchar *debug_sym = NULL;\n\t\t\tMonoPltEntry *plt_entry = NULL;\n\n\t\t\tif (i == 0)\n\t\t\t\tcontinue;\n\n\t\t\tplt_entry = (MonoPltEntry *)g_hash_table_lookup (acfg->plt_offset_to_entry, GUINT_TO_POINTER (i));\n\n\t\t\t/* Skip plt entries not actually called by LLVM code */\n\t\t\tif (!plt_entry->llvm_used)\n\t\t\t\tcontinue;\n\n\t\t\tif (acfg->aot_opts.write_symbols) {\n\t\t\t\tif (plt_entry->debug_sym)\n\t\t\t\t\tdebug_sym = g_strdup_printf (\"%s_thumb\", plt_entry->debug_sym);\n\t\t\t}\n\n\t\t\tif (debug_sym) {\n#if defined(TARGET_MACH)\n\t\t\t\tfprintf (acfg->fp, \"\t.thumb_func %s\\n\", debug_sym);\n\t\t\t\tfprintf (acfg->fp, \"\t.no_dead_strip %s\\n\", debug_sym);\n#endif\n\t\t\t\temit_local_symbol (acfg, debug_sym, NULL, TRUE);\n\t\t\t\temit_label (acfg, debug_sym);\n\t\t\t}\n\t\t\tfprintf (acfg->fp, \"\\n.thumb_func\\n\");\n\n\t\t\temit_label (acfg, plt_entry->llvm_symbol);\n\n\t\t\tif (acfg->llvm)\n\t\t\t\temit_global_inner (acfg, plt_entry->llvm_symbol, TRUE);\n\n\t\t\tarch_emit_llvm_plt_entry (acfg, acfg->got_symbol, (acfg->plt_got_offset_base + i) * sizeof (gpointer), acfg->plt_got_info_offsets [i]);\n\n\t\t\tif (debug_sym) {\n\t\t\t\temit_symbol_size (acfg, debug_sym, \".\");\n\t\t\t\tg_free (debug_sym);\n\t\t\t}\n\t\t}\n\t}\n\n\temit_symbol_size (acfg, acfg->plt_symbol, \".\");\n\n\temit_info_symbol (acfg, \"plt_end\");\n\n\tarch_emit_unwind_info_sections (acfg, \"plt\", \"plt_end\", NULL);\n}\n\n/*\n * emit_trampoline_full:\n *\n *   If EMIT_TINFO is TRUE, emit additional information which can be used to create a MonoJitInfo for this trampoline by\n * create_jit_info_for_trampoline ().\n */\nstatic G_GNUC_UNUSED void\nemit_trampoline_full (MonoAotCompile *acfg, int got_offset, MonoTrampInfo *info, gboolean emit_tinfo)\n{\n\tchar start_symbol [MAX_SYMBOL_SIZE];\n\tchar end_symbol [MAX_SYMBOL_SIZE];\n\tchar symbol [MAX_SYMBOL_SIZE];\n\tguint32 buf_size, info_offset;\n\tMonoJumpInfo *patch_info;\n\tguint8 *buf, *p;\n\tGPtrArray *patches;\n\tchar *name;\n\tguint8 *code;\n\tguint32 code_size;\n\tMonoJumpInfo *ji;\n\tGSList *unwind_ops;\n\n\tg_assert (info);\n\n\tname = info->name;\n\tcode = info->code;\n\tcode_size = info->code_size;\n\tji = info->ji;\n\tunwind_ops = info->unwind_ops;\n\n\t/* Emit code */\n\n\tsprintf (start_symbol, \"%s%s\", acfg->user_symbol_prefix, name);\n\n\temit_section_change (acfg, \".text\", 0);\n\temit_global (acfg, start_symbol, TRUE);\n\temit_alignment_code (acfg, AOT_FUNC_ALIGNMENT);\n\temit_label (acfg, start_symbol);\n\n\tsprintf (symbol, \"%snamed_%s\", acfg->temp_prefix, name);\n\temit_label (acfg, symbol);\n\n\t/* \n\t * The code should access everything through the GOT, so we pass\n\t * TRUE here.\n\t */\n\temit_and_reloc_code (acfg, NULL, code, code_size, ji, TRUE, NULL);\n\n\temit_symbol_size (acfg, start_symbol, \".\");\n\n\tif (emit_tinfo) {\n\t\tsprintf (end_symbol, \"%snamede_%s\", acfg->temp_prefix, name);\n\t\temit_label (acfg, end_symbol);\n\t}\n\n\t/* Emit info */\n\n\t/* Sort relocations */\n\tpatches = g_ptr_array_new ();\n\tfor (patch_info = ji; patch_info; patch_info = patch_info->next)\n\t\tif (patch_info->type != MONO_PATCH_INFO_NONE)\n\t\t\tg_ptr_array_add (patches, patch_info);\n\tg_ptr_array_sort (patches, compare_patches);\n\n\tbuf_size = patches->len * 128 + 128;\n\tbuf = (guint8 *)g_malloc (buf_size);\n\tp = buf;\n\n\tencode_patch_list (acfg, patches, patches->len, FALSE, got_offset, p, &p);\n\tg_assert (p - buf < buf_size);\n\tg_ptr_array_free (patches, TRUE);\n\n\tsprintf (symbol, \"%s%s_p\", acfg->user_symbol_prefix, name);\n\n\tinfo_offset = add_to_blob (acfg, buf, p - buf);\n\n\temit_section_change (acfg, RODATA_SECT, 0);\n\temit_global (acfg, symbol, FALSE);\n\temit_label (acfg, symbol);\n\n\temit_int32 (acfg, info_offset);\n\n\tif (emit_tinfo) {\n\t\tguint8 *encoded;\n\t\tguint32 encoded_len;\n\t\tguint32 uw_offset;\n\n\t\t/*\n\t\t * Emit additional information which can be used to reconstruct a partial MonoTrampInfo.\n\t\t */\n\t\tencoded = mono_unwind_ops_encode (info->unwind_ops, &encoded_len);\n\t\tuw_offset = get_unwind_info_offset (acfg, encoded, encoded_len);\n\t\tg_free (encoded);\n\n\t\temit_symbol_diff (acfg, end_symbol, start_symbol, 0);\n\t\temit_int32 (acfg, uw_offset);\n\t}\n\n\t/* Emit debug info */\n\tif (unwind_ops) {\n\t\tchar symbol2 [MAX_SYMBOL_SIZE];\n\n\t\tsprintf (symbol, \"%s\", name);\n\t\tsprintf (symbol2, \"%snamed_%s\", acfg->temp_prefix, name);\n\n\t\tarch_emit_unwind_info_sections (acfg, start_symbol, end_symbol, unwind_ops);\n\n\t\tif (acfg->dwarf)\n\t\t\tmono_dwarf_writer_emit_trampoline (acfg->dwarf, symbol, symbol2, NULL, NULL, code_size, unwind_ops);\n\t}\n\n\tg_free (buf);\n}\n\nstatic G_GNUC_UNUSED void\nemit_trampoline (MonoAotCompile *acfg, int got_offset, MonoTrampInfo *info)\n{\n\temit_trampoline_full (acfg, got_offset, info, TRUE);\n}\n\nstatic void\nemit_trampolines (MonoAotCompile *acfg)\n{\n\tchar symbol [MAX_SYMBOL_SIZE];\n\tchar end_symbol [MAX_SYMBOL_SIZE];\n\tint i, tramp_got_offset;\n\tint ntype;\n#ifdef MONO_ARCH_HAVE_FULL_AOT_TRAMPOLINES\n\tint tramp_type;\n#endif\n\n\tif (!mono_aot_mode_is_full (&acfg->aot_opts) || acfg->aot_opts.llvm_only)\n\t\treturn;\n\t\n\tg_assert (acfg->image->assembly);\n\n\t/* Currently, we emit most trampolines into the mscorlib AOT image. */\n\tif (strcmp (acfg->image->assembly->aname.name, \"mscorlib\") == 0) {\n#ifdef MONO_ARCH_HAVE_FULL_AOT_TRAMPOLINES\n\t\tMonoTrampInfo *info;\n\n\t\t/*\n\t\t * Emit the generic trampolines.\n\t\t *\n\t\t * We could save some code by treating the generic trampolines as a wrapper\n\t\t * method, but that approach has its own complexities, so we choose the simpler\n\t\t * method.\n\t\t */\n\t\tfor (tramp_type = 0; tramp_type < MONO_TRAMPOLINE_NUM; ++tramp_type) {\n\t\t\t/* we overload the boolean here to indicate the slightly different trampoline needed, see mono_arch_create_generic_trampoline() */\n#ifdef DISABLE_REMOTING\n\t\t\tif (tramp_type == MONO_TRAMPOLINE_GENERIC_VIRTUAL_REMOTING)\n\t\t\t\tcontinue;\n#endif\n\t\t\tmono_arch_create_generic_trampoline ((MonoTrampolineType)tramp_type, &info, acfg->aot_opts.use_trampolines_page? 2: TRUE);\n\t\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\t\tmono_tramp_info_free (info);\n\t\t}\n\n\t\t/* Emit the exception related code pieces */\n\t\tmono_arch_get_restore_context (&info, TRUE);\n\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\tmono_tramp_info_free (info);\n\n\t\tmono_arch_get_call_filter (&info, TRUE);\n\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\tmono_tramp_info_free (info);\n\n\t\tmono_arch_get_throw_exception (&info, TRUE);\n\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\tmono_tramp_info_free (info);\n\n\t\tmono_arch_get_rethrow_exception (&info, TRUE);\n\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\tmono_tramp_info_free (info);\n\n\t\tmono_arch_get_throw_corlib_exception (&info, TRUE);\n\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\tmono_tramp_info_free (info);\n\n#ifdef MONO_ARCH_HAVE_SDB_TRAMPOLINES\n\t\tmono_arch_create_sdb_trampoline (TRUE, &info, TRUE);\n\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\tmono_tramp_info_free (info);\n\n\t\tmono_arch_create_sdb_trampoline (FALSE, &info, TRUE);\n\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\tmono_tramp_info_free (info);\n#endif\n\n#ifdef MONO_ARCH_GSHAREDVT_SUPPORTED\n\t\tmono_arch_get_gsharedvt_trampoline (&info, TRUE);\n\t\tif (info) {\n\t\t\temit_trampoline_full (acfg, acfg->got_offset, info, TRUE);\n\n\t\t\t/* Create a separate out trampoline for more information in stack traces */\n\t\t\tinfo->name = g_strdup (\"gsharedvt_out_trampoline\");\n\t\t\temit_trampoline_full (acfg, acfg->got_offset, info, TRUE);\n\t\t\tmono_tramp_info_free (info);\n\t\t}\n#endif\n\n#if defined(MONO_ARCH_HAVE_GET_TRAMPOLINES)\n\t\t{\n\t\t\tGSList *l = mono_arch_get_trampolines (TRUE);\n\n\t\t\twhile (l) {\n\t\t\t\tMonoTrampInfo *info = (MonoTrampInfo *)l->data;\n\n\t\t\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\t\t\tl = l->next;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < acfg->aot_opts.nrgctx_fetch_trampolines; ++i) {\n\t\t\tint offset;\n\n\t\t\toffset = MONO_RGCTX_SLOT_MAKE_RGCTX (i);\n\t\t\tmono_arch_create_rgctx_lazy_fetch_trampoline (offset, &info, TRUE);\n\t\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\t\tmono_tramp_info_free (info);\n\n\t\t\toffset = MONO_RGCTX_SLOT_MAKE_MRGCTX (i);\n\t\t\tmono_arch_create_rgctx_lazy_fetch_trampoline (offset, &info, TRUE);\n\t\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\t\tmono_tramp_info_free (info);\n\t\t}\n\n#ifdef MONO_ARCH_HAVE_GENERAL_RGCTX_LAZY_FETCH_TRAMPOLINE\n\t\tmono_arch_create_general_rgctx_lazy_fetch_trampoline (&info, TRUE);\n\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\tmono_tramp_info_free (info);\n#endif\n\n\t\t{\n\t\t\tGSList *l;\n\n\t\t\t/* delegate_invoke_impl trampolines */\n\t\t\tl = mono_arch_get_delegate_invoke_impls ();\n\t\t\twhile (l) {\n\t\t\t\tMonoTrampInfo *info = (MonoTrampInfo *)l->data;\n\n\t\t\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\t\t\tl = l->next;\n\t\t\t}\n\t\t}\n\n\t\tif (mono_aot_mode_is_interp (&acfg->aot_opts)) {\n\t\t\tmono_arch_get_enter_icall_trampoline (&info);\n\t\t\temit_trampoline (acfg, acfg->got_offset, info);\n\t\t}\n\n#endif /* #ifdef MONO_ARCH_HAVE_FULL_AOT_TRAMPOLINES */\n\n\t\t/* Emit trampolines which are numerous */\n\n\t\t/*\n\t\t * These include the following:\n\t\t * - specific trampolines\n\t\t * - static rgctx invoke trampolines\n\t\t * - imt trampolines\n\t\t * These trampolines have the same code, they are parameterized by GOT \n\t\t * slots. \n\t\t * They are defined in this file, in the arch_... routines instead of\n\t\t * in tramp-<ARCH>.c, since it is easier to do it this way.\n\t\t */\n\n\t\t/*\n\t\t * When running in aot-only mode, we can't create specific trampolines at \n\t\t * runtime, so we create a few, and save them in the AOT file. \n\t\t * Normal trampolines embed their argument as a literal inside the \n\t\t * trampoline code, we can't do that here, so instead we embed an offset\n\t\t * which needs to be added to the trampoline address to get the address of\n\t\t * the GOT slot which contains the argument value.\n\t\t * The generated trampolines jump to the generic trampolines using another\n\t\t * GOT slot, which will be setup by the AOT loader to point to the \n\t\t * generic trampoline code of the given type.\n\t\t */\n\n\t\t/*\n\t\t * FIXME: Maybe we should use more specific trampolines (i.e. one class init for\n\t\t * each class).\n\t\t */\n\n\t\temit_section_change (acfg, \".text\", 0);\n\n\t\ttramp_got_offset = acfg->got_offset;\n\n\t\tfor (ntype = 0; ntype < MONO_AOT_TRAMP_NUM; ++ntype) {\n\t\t\tswitch (ntype) {\n\t\t\tcase MONO_AOT_TRAMP_SPECIFIC:\n\t\t\t\tsprintf (symbol, \"specific_trampolines\");\n\t\t\t\tbreak;\n\t\t\tcase MONO_AOT_TRAMP_STATIC_RGCTX:\n\t\t\t\tsprintf (symbol, \"static_rgctx_trampolines\");\n\t\t\t\tbreak;\n\t\t\tcase MONO_AOT_TRAMP_IMT:\n\t\t\t\tsprintf (symbol, \"imt_trampolines\");\n\t\t\t\tbreak;\n\t\t\tcase MONO_AOT_TRAMP_GSHAREDVT_ARG:\n\t\t\t\tsprintf (symbol, \"gsharedvt_arg_trampolines\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\n\t\t\tsprintf (end_symbol, \"%s_e\", symbol);\n\n\t\t\tif (acfg->aot_opts.write_symbols)\n\t\t\t\temit_local_symbol (acfg, symbol, end_symbol, TRUE);\n\n\t\t\temit_alignment_code (acfg, AOT_FUNC_ALIGNMENT);\n\t\t\temit_info_symbol (acfg, symbol);\n\n\t\t\tacfg->trampoline_got_offset_base [ntype] = tramp_got_offset;\n\n\t\t\tfor (i = 0; i < acfg->num_trampolines [ntype]; ++i) {\n\t\t\t\tint tramp_size = 0;\n\n\t\t\t\tswitch (ntype) {\n\t\t\t\tcase MONO_AOT_TRAMP_SPECIFIC:\n\t\t\t\t\tarch_emit_specific_trampoline (acfg, tramp_got_offset, &tramp_size);\n\t\t\t\t\ttramp_got_offset += 2;\n\t\t\t\tbreak;\n\t\t\t\tcase MONO_AOT_TRAMP_STATIC_RGCTX:\n\t\t\t\t\tarch_emit_static_rgctx_trampoline (acfg, tramp_got_offset, &tramp_size);\t\t\t\t\n\t\t\t\t\ttramp_got_offset += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MONO_AOT_TRAMP_IMT:\n\t\t\t\t\tarch_emit_imt_trampoline (acfg, tramp_got_offset, &tramp_size);\n\t\t\t\t\ttramp_got_offset += 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MONO_AOT_TRAMP_GSHAREDVT_ARG:\n\t\t\t\t\tarch_emit_gsharedvt_arg_trampoline (acfg, tramp_got_offset, &tramp_size);\t\t\t\t\n\t\t\t\t\ttramp_got_offset += 2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t\tif (!acfg->trampoline_size [ntype]) {\n\t\t\t\t\tg_assert (tramp_size);\n\t\t\t\t\tacfg->trampoline_size [ntype] = tramp_size;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\temit_label (acfg, end_symbol);\n\t\t\temit_int32 (acfg, 0);\n\t\t}\n\n\t\tarch_emit_specific_trampoline_pages (acfg);\n\n\t\t/* Reserve some entries at the end of the GOT for our use */\n\t\tacfg->num_trampoline_got_entries = tramp_got_offset - acfg->got_offset;\n\t}\n\n\tacfg->got_offset += acfg->num_trampoline_got_entries;\n}\n\nstatic gboolean\nstr_begins_with (const char *str1, const char *str2)\n{\n\tint len = strlen (str2);\n\treturn strncmp (str1, str2, len) == 0;\n}\n\nvoid*\nmono_aot_readonly_field_override (MonoClassField *field)\n{\n\tReadOnlyValue *rdv;\n\tfor (rdv = readonly_values; rdv; rdv = rdv->next) {\n\t\tchar *p = rdv->name;\n\t\tint len;\n\t\tlen = strlen (field->parent->name_space);\n\t\tif (strncmp (p, field->parent->name_space, len))\n\t\t\tcontinue;\n\t\tp += len;\n\t\tif (*p++ != '.')\n\t\t\tcontinue;\n\t\tlen = strlen (field->parent->name);\n\t\tif (strncmp (p, field->parent->name, len))\n\t\t\tcontinue;\n\t\tp += len;\n\t\tif (*p++ != '.')\n\t\t\tcontinue;\n\t\tif (strcmp (p, field->name))\n\t\t\tcontinue;\n\t\tswitch (rdv->type) {\n\t\tcase MONO_TYPE_I1:\n\t\t\treturn &rdv->value.i1;\n\t\tcase MONO_TYPE_I2:\n\t\t\treturn &rdv->value.i2;\n\t\tcase MONO_TYPE_I4:\n\t\t\treturn &rdv->value.i4;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void\nadd_readonly_value (MonoAotOptions *opts, const char *val)\n{\n\tReadOnlyValue *rdv;\n\tconst char *fval;\n\tconst char *tval;\n\t/* the format of val is:\n\t * namespace.typename.fieldname=type/value\n\t * type can be i1 for uint8/int8/boolean, i2 for uint16/int16/char, i4 for uint32/int32\n\t */\n\tfval = strrchr (val, '/');\n\tif (!fval) {\n\t\tfprintf (stderr, \"AOT : invalid format for readonly field '%s', missing /.\\n\", val);\n\t\texit (1);\n\t}\n\ttval = strrchr (val, '=');\n\tif (!tval) {\n\t\tfprintf (stderr, \"AOT : invalid format for readonly field '%s', missing =.\\n\", val);\n\t\texit (1);\n\t}\n\trdv = g_new0 (ReadOnlyValue, 1);\n\trdv->name = (char *)g_malloc0 (tval - val + 1);\n\tmemcpy (rdv->name, val, tval - val);\n\ttval++;\n\tfval++;\n\tif (strncmp (tval, \"i1\", 2) == 0) {\n\t\trdv->value.i1 = atoi (fval);\n\t\trdv->type = MONO_TYPE_I1;\n\t} else if (strncmp (tval, \"i2\", 2) == 0) {\n\t\trdv->value.i2 = atoi (fval);\n\t\trdv->type = MONO_TYPE_I2;\n\t} else if (strncmp (tval, \"i4\", 2) == 0) {\n\t\trdv->value.i4 = atoi (fval);\n\t\trdv->type = MONO_TYPE_I4;\n\t} else {\n\t\tfprintf (stderr, \"AOT : unsupported type for readonly field '%s'.\\n\", tval);\n\t\texit (1);\n\t}\n\trdv->next = readonly_values;\n\treadonly_values = rdv;\n}\n\nstatic gchar *\nclean_path (gchar * path)\n{\n\tif (!path)\n\t\treturn NULL;\n\n\tif (g_str_has_suffix (path, G_DIR_SEPARATOR_S))\n\t\treturn path;\n\n\tgchar *clean = g_strconcat (path, G_DIR_SEPARATOR_S, NULL);\n\tg_free (path);\n\n\treturn clean;\n}\n\nstatic gchar *\nwrap_path (gchar * path)\n{\n\tint len;\n\tif (!path)\n\t\treturn NULL;\n\n\t// If the string contains no spaces, just return the original string.\n\tif (strstr (path, \" \") == NULL)\n\t\treturn path;\n\n\t// If the string is already wrapped in quotes, return it.\n\tlen = strlen (path);\n\tif (len >= 2 && path[0] == '\\\"' && path[len-1] == '\\\"')\n\t\treturn path;\n\n\t// If the string contains spaces, then wrap it in quotes.\n\tgchar *clean = g_strdup_printf (\"\\\"%s\\\"\", path);\n\n\treturn clean;\n}\n\n// Duplicate a char range and add it to a ptrarray, but only if it is nonempty\nstatic void\nptr_array_add_range_if_nonempty(GPtrArray *args, gchar const *start, gchar const *end)\n{\n\tptrdiff_t len = end-start;\n\tif (len > 0)\n\t\tg_ptr_array_add (args, g_strndup (start, len));\n}\n\nstatic GPtrArray *\nmono_aot_split_options (const char *aot_options)\n{\n\tenum MonoAotOptionState {\n\t\tMONO_AOT_OPTION_STATE_DEFAULT,\n\t\tMONO_AOT_OPTION_STATE_STRING,\n\t\tMONO_AOT_OPTION_STATE_ESCAPE,\n\t};\n\n\tGPtrArray *args = g_ptr_array_new ();\n\tenum MonoAotOptionState state = MONO_AOT_OPTION_STATE_DEFAULT;\n\tgchar const *opt_start = aot_options;\n\tgboolean end_of_string = FALSE;\n\tgchar cur;\n\n\tg_return_val_if_fail (aot_options != NULL, NULL);\n\n\twhile ((cur = *aot_options) != '\\0') {\n\t\tif (state == MONO_AOT_OPTION_STATE_ESCAPE)\n\t\t\tgoto next;\n\n\t\tswitch (cur) {\n\t\tcase '\"':\n\t\t\t// If we find a quote, then if we're in the default case then\n\t\t\t// it means we've found the start of a string, if not then it\n\t\t\t// means we've found the end of the string and should switch\n\t\t\t// back to the default case.\t\t\n\t\t\tswitch (state) {\n\t\t\tcase MONO_AOT_OPTION_STATE_DEFAULT:\n\t\t\t\tstate = MONO_AOT_OPTION_STATE_STRING;\n\t\t\t\tbreak;\n\t\t\tcase MONO_AOT_OPTION_STATE_STRING:\n\t\t\t\tstate = MONO_AOT_OPTION_STATE_DEFAULT;\n\t\t\t\tbreak;\n\t\t\tcase MONO_AOT_OPTION_STATE_ESCAPE:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\t// If we've found an escaping operator, then this means we\n\t\t\t// should not process the next character if inside a string.\t\t\n\t\t\tif (state == MONO_AOT_OPTION_STATE_STRING) \n\t\t\t\tstate = MONO_AOT_OPTION_STATE_ESCAPE;\n\t\t\tbreak;\n\t\tcase ',':\n\t\t\t// If we're in the default state then this means we've found\n\t\t\t// an option, store it for later processing.\n\t\t\tif (state == MONO_AOT_OPTION_STATE_DEFAULT)\n\t\t\t\tgoto new_opt;\n\t\t\tbreak;\n\t\t}\n\n\tnext:\n\t\taot_options++;\n\trestart:\n\t\t// If the next character is end of string, then process the last option.\n\t\tif (*(aot_options) == '\\0') {\n\t\t\tend_of_string = TRUE;\n\t\t\tgoto new_opt;\n\t\t}\n\t\tcontinue;\n\n\tnew_opt:\n\t\tptr_array_add_range_if_nonempty (args, opt_start, aot_options);\n\t\topt_start = ++aot_options;\n\t\tif (end_of_string)\n\t\t\tbreak;\n\t\tgoto restart; // Check for null and continue loop\n\t}\n\n\treturn args;\n}\n\nstatic void\nmono_aot_parse_options (const char *aot_options, MonoAotOptions *opts)\n{\n\tGPtrArray* args;\n\n\targs = mono_aot_split_options (aot_options ? aot_options : \"\");\n\tfor (int i = 0; i < args->len; ++i) {\n\t\tconst char *arg = (const char *)g_ptr_array_index (args, i);\n\n\t\tif (str_begins_with (arg, \"outfile=\")) {\n\t\t\topts->outfile = g_strdup (arg + strlen (\"outfile=\"));\n\t\t} else if (str_begins_with (arg, \"llvm-outfile=\")) {\n\t\t\topts->llvm_outfile = g_strdup (arg + strlen (\"llvm-outfile=\"));\n\t\t} else if (str_begins_with (arg, \"temp-path=\")) {\n\t\t\topts->temp_path = clean_path (g_strdup (arg + strlen (\"temp-path=\")));\n\t\t} else if (str_begins_with (arg, \"save-temps\")) {\n\t\t\topts->save_temps = TRUE;\n\t\t} else if (str_begins_with (arg, \"keep-temps\")) {\n\t\t\topts->save_temps = TRUE;\n\t\t} else if (str_begins_with (arg, \"write-symbols\")) {\n\t\t\topts->write_symbols = TRUE;\n\t\t} else if (str_begins_with (arg, \"no-write-symbols\")) {\n\t\t\topts->write_symbols = FALSE;\n\t\t// Intentionally undocumented -- one-off experiment\n\t\t} else if (str_begins_with (arg, \"metadata-only\")) {\n\t\t\topts->metadata_only = TRUE;\n\t\t} else if (str_begins_with (arg, \"bind-to-runtime-version\")) {\n\t\t\topts->bind_to_runtime_version = TRUE;\n\t\t} else if (str_begins_with (arg, \"full\")) {\n\t\t\topts->mode = MONO_AOT_MODE_FULL;\n\t\t} else if (str_begins_with (arg, \"hybrid\")) {\n\t\t\topts->mode = MONO_AOT_MODE_HYBRID;\t\t\t\n\t\t} else if (str_begins_with (arg, \"interp\")) {\n\t\t\topts->mode = MONO_AOT_MODE_INTERP;\n\t\t} else if (str_begins_with (arg, \"threads=\")) {\n\t\t\topts->nthreads = atoi (arg + strlen (\"threads=\"));\n\t\t} else if (str_begins_with (arg, \"static\")) {\n\t\t\topts->static_link = TRUE;\n\t\t\topts->no_dlsym = TRUE;\n\t\t} else if (str_begins_with (arg, \"asmonly\")) {\n\t\t\topts->asm_only = TRUE;\n\t\t} else if (str_begins_with (arg, \"asmwriter\")) {\n\t\t\topts->asm_writer = TRUE;\n\t\t} else if (str_begins_with (arg, \"nodebug\")) {\n\t\t\topts->nodebug = TRUE;\n\t\t} else if (str_begins_with (arg, \"dwarfdebug\")) {\n\t\t\topts->dwarf_debug = TRUE;\n\t\t// Intentionally undocumented -- No one remembers what this does. It appears to be ARM-only\n\t\t} else if (str_begins_with (arg, \"nopagetrampolines\")) {\n\t\t\topts->use_trampolines_page = FALSE;\n\t\t} else if (str_begins_with (arg, \"ntrampolines=\")) {\n\t\t\topts->ntrampolines = atoi (arg + strlen (\"ntrampolines=\"));\n\t\t} else if (str_begins_with (arg, \"nrgctx-trampolines=\")) {\n\t\t\topts->nrgctx_trampolines = atoi (arg + strlen (\"nrgctx-trampolines=\"));\n\t\t} else if (str_begins_with (arg, \"nrgctx-fetch-trampolines=\")) {\n\t\t\topts->nrgctx_fetch_trampolines = atoi (arg + strlen (\"nrgctx-fetch-trampolines=\"));\n\t\t} else if (str_begins_with (arg, \"nimt-trampolines=\")) {\n\t\t\topts->nimt_trampolines = atoi (arg + strlen (\"nimt-trampolines=\"));\n\t\t} else if (str_begins_with (arg, \"ngsharedvt-trampolines=\")) {\n\t\t\topts->ngsharedvt_arg_trampolines = atoi (arg + strlen (\"ngsharedvt-trampolines=\"));\n\t\t} else if (str_begins_with (arg, \"tool-prefix=\")) {\n\t\t\topts->tool_prefix = g_strdup (arg + strlen (\"tool-prefix=\"));\n\t\t} else if (str_begins_with (arg, \"ld-flags=\")) {\n\t\t\topts->ld_flags = g_strdup (arg + strlen (\"ld-flags=\"));\t\t\t\n\t\t} else if (str_begins_with (arg, \"soft-debug\")) {\n\t\t\topts->soft_debug = TRUE;\n\t\t// Intentionally undocumented x2-- deprecated\n\t\t} else if (str_begins_with (arg, \"gen-seq-points-file=\")) {\n\t\t\tfprintf (stderr, \"Mono Warning: aot option gen-seq-points-file= is deprecated.\\n\");\n\t\t} else if (str_begins_with (arg, \"gen-seq-points-file\")) {\n\t\t\tfprintf (stderr, \"Mono Warning: aot option gen-seq-points-file is deprecated.\\n\");\n\t\t} else if (str_begins_with (arg, \"msym-dir=\")) {\n\t\t\tdebug_options.no_seq_points_compact_data = FALSE;\n\t\t\topts->gen_msym_dir = TRUE;\n\t\t\topts->gen_msym_dir_path = g_strdup (arg + strlen (\"msym_dir=\"));;\n\t\t} else if (str_begins_with (arg, \"direct-pinvoke\")) {\n\t\t\topts->direct_pinvoke = TRUE;\n\t\t} else if (str_begins_with (arg, \"direct-icalls\")) {\n\t\t\topts->direct_icalls = TRUE;\n\t\t} else if (str_begins_with (arg, \"no-direct-calls\")) {\n\t\t\topts->no_direct_calls = TRUE;\n\t\t} else if (str_begins_with (arg, \"print-skipped\")) {\n\t\t\topts->print_skipped_methods = TRUE;\n\t\t} else if (str_begins_with (arg, \"stats\")) {\n\t\t\topts->stats = TRUE;\n\t\t// Intentionally undocumented-- has no known function other than to debug the compiler\n\t\t} else if (str_begins_with (arg, \"no-instances\")) {\n\t\t\topts->no_instances = TRUE;\n\t\t// Intentionally undocumented x4-- Used for internal debugging of compiler\n\t\t} else if (str_begins_with (arg, \"log-generics\")) {\n\t\t\topts->log_generics = TRUE;\n\t\t} else if (str_begins_with (arg, \"log-instances=\")) {\n\t\t\topts->log_instances = TRUE;\n\t\t\topts->instances_logfile_path = g_strdup (arg + strlen (\"log-instances=\"));\n\t\t} else if (str_begins_with (arg, \"log-instances\")) {\n\t\t\topts->log_instances = TRUE;\n\t\t} else if (str_begins_with (arg, \"internal-logfile=\")) {\n\t\t\topts->logfile = g_strdup (arg + strlen (\"internal-logfile=\"));\n\t\t} else if (str_begins_with (arg, \"dedup-skip\")) {\n\t\t\topts->dedup = TRUE;\n\t\t} else if (str_begins_with (arg, \"dedup-include=\")) {\n\t\t\topts->dedup_include = g_strdup (arg + strlen (\"dedup-include=\"));\n\t\t} else if (str_begins_with (arg, \"mtriple=\")) {\n\t\t\topts->mtriple = g_strdup (arg + strlen (\"mtriple=\"));\n\t\t} else if (str_begins_with (arg, \"llvm-path=\")) {\n\t\t\topts->llvm_path = clean_path (g_strdup (arg + strlen (\"llvm-path=\")));\n\t\t} else if (!strcmp (arg, \"llvm\")) {\n\t\t\topts->llvm = TRUE;\n\t\t} else if (str_begins_with (arg, \"readonly-value=\")) {\n\t\t\tadd_readonly_value (opts, arg + strlen (\"readonly-value=\"));\n\t\t} else if (str_begins_with (arg, \"info\")) {\n\t\t\tprintf (\"AOT target setup: %s.\\n\", AOT_TARGET_STR);\n\t\t\texit (0);\n\t\t// Intentionally undocumented: Used for precise stack maps, which are not available yet\n\t\t} else if (str_begins_with (arg, \"gc-maps\")) {\n\t\t\tmini_gc_enable_gc_maps_for_aot ();\n\t\t// Intentionally undocumented: Used for internal debugging\n\t\t} else if (str_begins_with (arg, \"dump\")) {\n\t\t\topts->dump_json = TRUE;\n\t\t} else if (str_begins_with (arg, \"llvmonly\")) {\n\t\t\topts->mode = MONO_AOT_MODE_FULL;\n\t\t\topts->llvm = TRUE;\n\t\t\topts->llvm_only = TRUE;\n\t\t} else if (str_begins_with (arg, \"data-outfile=\")) {\n\t\t\topts->data_outfile = g_strdup (arg + strlen (\"data-outfile=\"));\n\t\t} else if (str_begins_with (arg, \"profile=\")) {\n\t\t\topts->profile_files = g_list_append (opts->profile_files, g_strdup (arg + strlen (\"profile=\")));\n\t\t} else if (!strcmp (arg, \"profile-only\")) {\n\t\t\topts->profile_only = TRUE;\n\t\t} else if (!strcmp (arg, \"verbose\")) {\n\t\t\topts->verbose = TRUE;\n\t\t} else if (str_begins_with (arg, \"help\") || str_begins_with (arg, \"?\")) {\n\t\t\tprintf (\"Supported options for --aot:\\n\");\n\t\t\tprintf (\"    asmonly\\n\");\n\t\t\tprintf (\"    bind-to-runtime-version\\n\");\n\t\t\tprintf (\"    bitcode\\n\");\n\t\t\tprintf (\"    data-outfile=\\n\");\n\t\t\tprintf (\"    direct-icalls\\n\");\n\t\t\tprintf (\"    direct-pinvoke\\n\");\n\t\t\tprintf (\"    dwarfdebug\\n\");\n\t\t\tprintf (\"    full\\n\");\n\t\t\tprintf (\"    hybrid\\n\");\n\t\t\tprintf (\"    info\\n\");\n\t\t\tprintf (\"    keep-temps\\n\");\n\t\t\tprintf (\"    llvm\\n\");\n\t\t\tprintf (\"    llvmonly\\n\");\n\t\t\tprintf (\"    llvm-outfile=\\n\");\n\t\t\tprintf (\"    llvm-path=\\n\");\n\t\t\tprintf (\"    msym-dir=\\n\");\n\t\t\tprintf (\"    mtriple\\n\");\n\t\t\tprintf (\"    nimt-trampolines=\\n\");\n\t\t\tprintf (\"    nodebug\\n\");\n\t\t\tprintf (\"    no-direct-calls\\n\");\n\t\t\tprintf (\"    no-write-symbols\\n\");\n\t\t\tprintf (\"    nrgctx-trampolines=\\n\");\n\t\t\tprintf (\"    nrgctx-fetch-trampolines=\\n\");\n\t\t\tprintf (\"    ngsharedvt-trampolines=\\n\");\n\t\t\tprintf (\"    ntrampolines=\\n\");\n\t\t\tprintf (\"    outfile=\\n\");\n\t\t\tprintf (\"    profile=\\n\");\n\t\t\tprintf (\"    profile-only\\n\");\n\t\t\tprintf (\"    print-skipped-methods\\n\");\n\t\t\tprintf (\"    readonly-value=\\n\");\n\t\t\tprintf (\"    save-temps\\n\");\n\t\t\tprintf (\"    soft-debug\\n\");\n\t\t\tprintf (\"    static\\n\");\n\t\t\tprintf (\"    stats\\n\");\n\t\t\tprintf (\"    temp-path=\\n\");\n\t\t\tprintf (\"    tool-prefix=\\n\");\n\t\t\tprintf (\"    threads=\\n\");\n\t\t\tprintf (\"    write-symbols\\n\");\n\t\t\tprintf (\"    verbose\\n\");\n\t\t\tprintf (\"    help/?\\n\");\n\t\t\texit (0);\n\t\t} else {\n\t\t\tfprintf (stderr, \"AOT : Unknown argument '%s'.\\n\", arg);\n\t\t\texit (1);\n\t\t}\n\n\t\tg_free ((gpointer) arg);\n\t}\n\n\tif (opts->use_trampolines_page) {\n\t\topts->ntrampolines = 0;\n\t\topts->nrgctx_trampolines = 0;\n\t\topts->nimt_trampolines = 0;\n\t\topts->ngsharedvt_arg_trampolines = 0;\n\t}\n\n\tg_ptr_array_free (args, /*free_seg=*/TRUE);\n}\n\nstatic void\nadd_token_info_hash (gpointer key, gpointer value, gpointer user_data)\n{\n\tMonoMethod *method = (MonoMethod*)key;\n\tMonoJumpInfoToken *ji = (MonoJumpInfoToken*)value;\n\tMonoAotCompile *acfg = (MonoAotCompile *)user_data;\n\tMonoJumpInfoToken *new_ji;\n\n\tnew_ji = (MonoJumpInfoToken *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfoToken));\n\tnew_ji->image = ji->image;\n\tnew_ji->token = ji->token;\n\tg_hash_table_insert (acfg->token_info_hash, method, new_ji);\n}\n\nstatic gboolean\ncan_encode_class (MonoAotCompile *acfg, MonoClass *klass)\n{\n\tif (klass->type_token)\n\t\treturn TRUE;\n\tif ((klass->byval_arg.type == MONO_TYPE_VAR) || (klass->byval_arg.type == MONO_TYPE_MVAR) || (klass->byval_arg.type == MONO_TYPE_PTR))\n\t\treturn TRUE;\n\tif (klass->rank)\n\t\treturn can_encode_class (acfg, klass->element_class);\n\treturn FALSE;\n}\n\nstatic gboolean\ncan_encode_method (MonoAotCompile *acfg, MonoMethod *method)\n{\n\t\tif (method->wrapper_type) {\n\t\t\tswitch (method->wrapper_type) {\n\t\t\tcase MONO_WRAPPER_NONE:\n\t\t\tcase MONO_WRAPPER_REMOTING_INVOKE_WITH_CHECK:\n\t\t\tcase MONO_WRAPPER_XDOMAIN_INVOKE:\n\t\t\tcase MONO_WRAPPER_STFLD:\n\t\t\tcase MONO_WRAPPER_LDFLD:\n\t\t\tcase MONO_WRAPPER_LDFLDA:\n\t\t\tcase MONO_WRAPPER_STELEMREF:\n\t\t\tcase MONO_WRAPPER_PROXY_ISINST:\n\t\t\tcase MONO_WRAPPER_ALLOC:\n\t\t\tcase MONO_WRAPPER_REMOTING_INVOKE:\n\t\t\tcase MONO_WRAPPER_UNKNOWN:\n\t\t\tcase MONO_WRAPPER_WRITE_BARRIER:\n\t\t\tcase MONO_WRAPPER_DELEGATE_INVOKE:\n\t\t\tcase MONO_WRAPPER_DELEGATE_BEGIN_INVOKE:\n\t\t\tcase MONO_WRAPPER_DELEGATE_END_INVOKE:\n\t\t\tcase MONO_WRAPPER_SYNCHRONIZED:\n\t\t\t\tbreak;\n\t\t\tcase MONO_WRAPPER_MANAGED_TO_MANAGED:\n\t\t\tcase MONO_WRAPPER_CASTCLASS: {\n\t\t\t\tWrapperInfo *info = mono_marshal_get_wrapper_info (method);\n\n\t\t\t\tif (info)\n\t\t\t\t\treturn TRUE;\n\t\t\t\telse\n\t\t\t\t\treturn FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\t//printf (\"Skip (wrapper call): %d -> %s\\n\", patch_info->type, mono_method_full_name (patch_info->data.method, TRUE));\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!method->token) {\n\t\t\t\t/* The method is part of a constructed type like Int[,].Set (). */\n\t\t\t\tif (!g_hash_table_lookup (acfg->token_info_hash, method)) {\n\t\t\t\t\tif (method->klass->rank)\n\t\t\t\t\t\treturn TRUE;\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn TRUE;\n}\n\nstatic gboolean\ncan_encode_patch (MonoAotCompile *acfg, MonoJumpInfo *patch_info)\n{\n\tswitch (patch_info->type) {\n\tcase MONO_PATCH_INFO_METHOD:\n\tcase MONO_PATCH_INFO_METHODCONST:\n\tcase MONO_PATCH_INFO_METHOD_CODE_SLOT: {\n\t\tMonoMethod *method = patch_info->data.method;\n\n\t\treturn can_encode_method (acfg, method);\n\t}\n\tcase MONO_PATCH_INFO_VTABLE:\n\tcase MONO_PATCH_INFO_CLASS:\n\tcase MONO_PATCH_INFO_IID:\n\tcase MONO_PATCH_INFO_ADJUSTED_IID:\n\t\tif (!can_encode_class (acfg, patch_info->data.klass)) {\n\t\t\t//printf (\"Skip: %s\\n\", mono_type_full_name (&patch_info->data.klass->byval_arg));\n\t\t\treturn FALSE;\n\t\t}\n\t\tbreak;\n\tcase MONO_PATCH_INFO_DELEGATE_TRAMPOLINE: {\n\t\tif (!can_encode_class (acfg, patch_info->data.del_tramp->klass)) {\n\t\t\t//printf (\"Skip: %s\\n\", mono_type_full_name (&patch_info->data.klass->byval_arg));\n\t\t\treturn FALSE;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_PATCH_INFO_RGCTX_FETCH:\n\tcase MONO_PATCH_INFO_RGCTX_SLOT_INDEX: {\n\t\tMonoJumpInfoRgctxEntry *entry = patch_info->data.rgctx_entry;\n\n\t\tif (!can_encode_method (acfg, entry->method))\n\t\t\treturn FALSE;\n\t\tif (!can_encode_patch (acfg, entry->data))\n\t\t\treturn FALSE;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n\nstatic gboolean\nis_concrete_type (MonoType *t)\n{\n\tMonoClass *klass;\n\tint i;\n\n\tif (t->type == MONO_TYPE_VAR || t->type == MONO_TYPE_MVAR)\n\t\treturn FALSE;\n\tif (t->type == MONO_TYPE_GENERICINST) {\n\t\tMonoGenericContext *orig_ctx;\n\t\tMonoGenericInst *inst;\n\t\tMonoType *arg;\n\n\t\tif (!MONO_TYPE_ISSTRUCT (t))\n\t\t\treturn TRUE;\n\t\tklass = mono_class_from_mono_type (t);\n\t\torig_ctx = &mono_class_get_generic_class (klass)->context;\n\n\t\tinst = orig_ctx->class_inst;\n\t\tif (inst) {\n\t\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\t\targ = mini_get_underlying_type (inst->type_argv [i]);\n\t\t\t\tif (!is_concrete_type (arg))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\tinst = orig_ctx->method_inst;\n\t\tif (inst) {\n\t\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\t\targ = mini_get_underlying_type (inst->type_argv [i]);\n\t\t\t\tif (!is_concrete_type (arg))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/* LOCKING: Assumes the loader lock is held */\nstatic void\nadd_gsharedvt_wrappers (MonoAotCompile *acfg, MonoMethodSignature *sig, gboolean gsharedvt_in, gboolean gsharedvt_out)\n{\n\tMonoMethod *wrapper;\n\tgboolean concrete = TRUE;\n\tgboolean add_in = gsharedvt_in;\n\tgboolean add_out = gsharedvt_out;\n\n\tif (gsharedvt_in && g_hash_table_lookup (acfg->gsharedvt_in_signatures, sig))\n\t\tadd_in = FALSE;\n\tif (gsharedvt_out && g_hash_table_lookup (acfg->gsharedvt_out_signatures, sig))\n\t\tadd_out = FALSE;\n\n\tif (!add_in && !add_out)\n\t\treturn;\n\n\tif (mini_is_gsharedvt_variable_signature (sig))\n\t\treturn;\n\n\tif (add_in)\n\t\tg_hash_table_insert (acfg->gsharedvt_in_signatures, sig, sig);\n\tif (add_out)\n\t\tg_hash_table_insert (acfg->gsharedvt_out_signatures, sig, sig);\n\n\tif (!sig->has_type_parameters) {\n\t\t//printf (\"%s\\n\", mono_signature_full_name (sig));\n\n\t\tif (gsharedvt_in) {\n\t\t\twrapper = mini_get_gsharedvt_in_sig_wrapper (sig);\n\t\t\tadd_extra_method (acfg, wrapper);\n\t\t}\n\t\tif (gsharedvt_out) {\n\t\t\twrapper = mini_get_gsharedvt_out_sig_wrapper (sig);\n\t\t\tadd_extra_method (acfg, wrapper);\n\t\t}\n\t} else {\n\t\t/* For signatures creared during generic sharing, convert them to a concrete signature if possible */\n\t\tMonoMethodSignature *copy = mono_metadata_signature_dup (sig);\n\t\tint i;\n\n\t\t//printf (\"%s\\n\", mono_signature_full_name (sig));\n\n\t\tcopy->ret = mini_get_underlying_type (sig->ret);\n\t\tif (!is_concrete_type (copy->ret))\n\t\t\tconcrete = FALSE;\n\t\tfor (i = 0; i < sig->param_count; ++i) {\n\t\t\tcopy->params [i] = mini_get_underlying_type (sig->params [i]);\n\t\t\tif (!is_concrete_type (copy->params [i]))\n\t\t\t\tconcrete = FALSE;\n\t\t}\n\t\tif (concrete) {\n\t\t\tcopy->has_type_parameters = 0;\n\n\t\t\tif (gsharedvt_in) {\n\t\t\t\twrapper = mini_get_gsharedvt_in_sig_wrapper (copy);\n\t\t\t\tadd_extra_method (acfg, wrapper);\n\t\t\t}\n\n\t\t\tif (gsharedvt_out) {\n\t\t\t\twrapper = mini_get_gsharedvt_out_sig_wrapper (copy);\n\t\t\t\tadd_extra_method (acfg, wrapper);\n\t\t\t}\n\n\t\t\t//printf (\"%s\\n\", mono_method_full_name (wrapper, 1));\n\t\t}\n\t}\n}\n\n/*\n * compile_method:\n *\n *   AOT compile a given method.\n * This function might be called by multiple threads, so it must be thread-safe.\n */\nstatic void\ncompile_method (MonoAotCompile *acfg, MonoMethod *method)\n{\n\tMonoCompile *cfg;\n\tMonoJumpInfo *patch_info;\n\tgboolean skip;\n\tint index, depth;\n\tMonoMethod *wrapped;\n\tGTimer *jit_timer;\n\tJitFlags flags;\n\n\tif (acfg->aot_opts.metadata_only)\n\t\treturn;\n\n\tmono_acfg_lock (acfg);\n\tindex = get_method_index (acfg, method);\n\tmono_acfg_unlock (acfg);\n\n\t/* fixme: maybe we can also precompile wrapper methods */\n\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t(method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) ||\n\t\t(method->flags & METHOD_ATTRIBUTE_ABSTRACT)) {\n\t\t//printf (\"Skip (impossible): %s\\n\", mono_method_full_name (method, TRUE));\n\t\treturn;\n\t}\n\n\tif (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL)\n\t\treturn;\n\n\twrapped = mono_marshal_method_from_wrapper (method);\n\tif (wrapped && (wrapped->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) && wrapped->is_generic)\n\t\t// FIXME: The wrapper should be generic too, but it is not\n\t\treturn;\n\n\tif (method->wrapper_type == MONO_WRAPPER_COMINTEROP)\n\t\treturn;\n\n\tif (acfg->aot_opts.profile_only && !method->is_inflated && !g_hash_table_lookup (acfg->profile_methods, method))\n\t\treturn;\n\n\tmono_atomic_inc_i32 (&acfg->stats.mcount);\n\n#if 0\n\tif (method->is_generic || mono_class_is_gtd (method->klass)) {\n\t\tmono_atomic_inc_i32 (&acfg->stats.genericcount);\n\t\treturn;\n\t}\n#endif\n\n\t//acfg->aot_opts.print_skipped_methods = TRUE;\n\n\t/*\n\t * Since these methods are the only ones which are compiled with\n\t * AOT support, and they are not used by runtime startup/shutdown code,\n\t * the runtime will not see AOT methods during AOT compilation,so it\n\t * does not need to support them by creating a fake GOT etc.\n\t */\n\tflags = JIT_FLAG_AOT;\n\tif (mono_aot_mode_is_full (&acfg->aot_opts))\n\t\tflags = (JitFlags)(flags | JIT_FLAG_FULL_AOT);\n\tif (acfg->llvm)\n\t\tflags = (JitFlags)(flags | JIT_FLAG_LLVM);\n\tif (acfg->aot_opts.llvm_only)\n\t\tflags = (JitFlags)(flags | JIT_FLAG_LLVM_ONLY | JIT_FLAG_EXPLICIT_NULL_CHECKS);\n\tif (acfg->aot_opts.no_direct_calls)\n\t\tflags = (JitFlags)(flags | JIT_FLAG_NO_DIRECT_ICALLS);\n\tif (acfg->aot_opts.direct_pinvoke)\n\t\tflags = (JitFlags)(flags | JIT_FLAG_DIRECT_PINVOKE);\n\n\tjit_timer = mono_time_track_start ();\n\tcfg = mini_method_compile (method, acfg->opts, mono_get_root_domain (), flags, 0, index);\n\tmono_time_track_end (&mono_jit_stats.jit_time, jit_timer);\n\n\tif (cfg->exception_type == MONO_EXCEPTION_GENERIC_SHARING_FAILED) {\n\t\tif (acfg->aot_opts.print_skipped_methods)\n\t\t\tprintf (\"Skip (gshared failure): %s (%s)\\n\", mono_method_get_full_name (method), cfg->exception_message);\n\t\tmono_atomic_inc_i32 (&acfg->stats.genericcount);\n\t\treturn;\n\t}\n\tif (cfg->exception_type != MONO_EXCEPTION_NONE) {\n\t\t/* Some instances cannot be JITted due to constraints etc. */\n\t\tif (!method->is_inflated)\n\t\t\treport_loader_error (acfg, &cfg->error, FALSE, \"Unable to compile method '%s' due to: '%s'.\\n\", mono_method_get_full_name (method), mono_error_get_message (&cfg->error));\n\t\t/* Let the exception happen at runtime */\n\t\treturn;\n\t}\n\n\tif (cfg->disable_aot) {\n\t\tif (acfg->aot_opts.print_skipped_methods)\n\t\t\tprintf (\"Skip (disabled): %s\\n\", mono_method_get_full_name (method));\n\t\tmono_atomic_inc_i32 (&acfg->stats.ocount);\n\t\treturn;\n\t}\n\tcfg->method_index = index;\n\n\t/* Nullify patches which need no aot processing */\n\tfor (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {\n\t\tswitch (patch_info->type) {\n\t\tcase MONO_PATCH_INFO_LABEL:\n\t\tcase MONO_PATCH_INFO_BB:\n\t\t\tpatch_info->type = MONO_PATCH_INFO_NONE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Collect method->token associations from the cfg */\n\tmono_acfg_lock (acfg);\n\tg_hash_table_foreach (cfg->token_info_hash, add_token_info_hash, acfg);\n\tmono_acfg_unlock (acfg);\n\tg_hash_table_destroy (cfg->token_info_hash);\n\tcfg->token_info_hash = NULL;\n\n\t/*\n\t * Check for absolute addresses.\n\t */\n\tskip = FALSE;\n\tfor (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {\n\t\tswitch (patch_info->type) {\n\t\tcase MONO_PATCH_INFO_ABS:\n\t\t\t/* unable to handle this */\n\t\t\tskip = TRUE;\t\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skip) {\n\t\tif (acfg->aot_opts.print_skipped_methods)\n\t\t\tprintf (\"Skip (abs call): %s\\n\", mono_method_get_full_name (method));\n\t\tmono_atomic_inc_i32 (&acfg->stats.abscount);\n\t\treturn;\n\t}\n\n\t/* Lock for the rest of the code */\n\tmono_acfg_lock (acfg);\n\n\tif (cfg->gsharedvt)\n\t\tacfg->stats.method_categories [METHOD_CAT_GSHAREDVT] ++;\n\telse if (cfg->gshared)\n\t\tacfg->stats.method_categories [METHOD_CAT_INST] ++;\n\telse if (cfg->method->wrapper_type)\n\t\tacfg->stats.method_categories [METHOD_CAT_WRAPPER] ++;\n\telse\n\t\tacfg->stats.method_categories [METHOD_CAT_NORMAL] ++;\n\n\t/*\n\t * Check for methods/klasses we can't encode.\n\t */\n\tskip = FALSE;\n\tfor (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {\n\t\tif (!can_encode_patch (acfg, patch_info))\n\t\t\tskip = TRUE;\n\t}\n\n\tif (skip) {\n\t\tif (acfg->aot_opts.print_skipped_methods)\n\t\t\tprintf (\"Skip (patches): %s\\n\", mono_method_get_full_name (method));\n\t\tacfg->stats.ocount++;\n\t\tmono_acfg_unlock (acfg);\n\t\treturn;\n\t}\n\n\tif (!cfg->compile_llvm)\n\t\tacfg->has_jitted_code = TRUE;\n\n\tif (method->is_inflated && acfg->aot_opts.log_instances) {\n\t\tif (acfg->instances_logfile)\n\t\t\tfprintf (acfg->instances_logfile, \"%s ### %d\\n\", mono_method_get_full_name (method), cfg->code_size);\n\t\telse\n\t\t\tprintf (\"%s ### %d\\n\", mono_method_get_full_name (method), cfg->code_size);\n\t}\n\n\t/* Adds generic instances referenced by this method */\n\t/* \n\t * The depth is used to avoid infinite loops when generic virtual recursion is \n\t * encountered.\n\t */\n\tdepth = GPOINTER_TO_UINT (g_hash_table_lookup (acfg->method_depth, method));\n\tif (!acfg->aot_opts.no_instances && depth < 32 && (mono_aot_mode_is_full (&acfg->aot_opts) || mono_aot_mode_is_hybrid (&acfg->aot_opts))) {\n\t\tfor (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {\n\t\t\tswitch (patch_info->type) {\n\t\t\tcase MONO_PATCH_INFO_RGCTX_FETCH:\n\t\t\tcase MONO_PATCH_INFO_RGCTX_SLOT_INDEX:\n\t\t\tcase MONO_PATCH_INFO_METHOD:\n\t\t\tcase MONO_PATCH_INFO_METHOD_RGCTX: {\n\t\t\t\tMonoMethod *m = NULL;\n\n\t\t\t\tif (patch_info->type == MONO_PATCH_INFO_RGCTX_FETCH || patch_info->type == MONO_PATCH_INFO_RGCTX_SLOT_INDEX) {\n\t\t\t\t\tMonoJumpInfoRgctxEntry *e = patch_info->data.rgctx_entry;\n\n\t\t\t\t\tif (e->info_type == MONO_RGCTX_INFO_GENERIC_METHOD_CODE)\n\t\t\t\t\t\tm = e->data->data.method;\n\t\t\t\t} else {\n\t\t\t\t\tm = patch_info->data.method;\n\t\t\t\t}\n\n\t\t\t\tif (!m)\n\t\t\t\t\tbreak;\n\t\t\t\tif (m->is_inflated && (mono_aot_mode_is_full (&acfg->aot_opts) || mono_aot_mode_is_hybrid (&acfg->aot_opts))) {\n\t\t\t\t\tif (!(mono_class_generic_sharing_enabled (m->klass) &&\n\t\t\t\t\t\t  mono_method_is_generic_sharable_full (m, FALSE, FALSE, FALSE)) &&\n\t\t\t\t\t\t(!method_has_type_vars (m) || mono_method_is_generic_sharable_full (m, TRUE, TRUE, FALSE))) {\n\t\t\t\t\t\tif (m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\t\t\t\t\t\tif (mono_aot_mode_is_full (&acfg->aot_opts) && !method_has_type_vars (m))\n\t\t\t\t\t\t\t\tadd_extra_method_with_depth (acfg, mono_marshal_get_native_wrapper (m, TRUE, TRUE), depth + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadd_extra_method_with_depth (acfg, m, depth + 1);\n\t\t\t\t\t\t\tadd_types_from_method_header (acfg, m);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tadd_generic_class_with_depth (acfg, m->klass, depth + 5, \"method\");\n\t\t\t\t}\n\t\t\t\tif (m->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\t\t\t\tWrapperInfo *info = mono_marshal_get_wrapper_info (m);\n\n\t\t\t\t\tif (info && info->subtype == WRAPPER_SUBTYPE_ELEMENT_ADDR)\n\t\t\t\t\t\tadd_extra_method_with_depth (acfg, m, depth + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MONO_PATCH_INFO_VTABLE: {\n\t\t\t\tMonoClass *klass = patch_info->data.klass;\n\n\t\t\t\tif (mono_class_is_ginst (klass) && !mini_class_is_generic_sharable (klass))\n\t\t\t\t\tadd_generic_class_with_depth (acfg, klass, depth + 5, \"vtable\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MONO_PATCH_INFO_SFLDA: {\n\t\t\t\tMonoClass *klass = patch_info->data.field->parent;\n\n\t\t\t\t/* The .cctor needs to run at runtime. */\n\t\t\t\tif (mono_class_is_ginst (klass) && !mono_generic_context_is_sharable_full (&mono_class_get_generic_class (klass)->context, FALSE, FALSE) && mono_class_get_cctor (klass))\n\t\t\t\t\tadd_extra_method_with_depth (acfg, mono_class_get_cctor (klass), depth + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Determine whenever the method has GOT slots */\n\tfor (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {\n\t\tswitch (patch_info->type) {\n\t\tcase MONO_PATCH_INFO_GOT_OFFSET:\n\t\tcase MONO_PATCH_INFO_NONE:\n\t\tcase MONO_PATCH_INFO_GC_CARD_TABLE_ADDR:\n\t\tcase MONO_PATCH_INFO_GC_NURSERY_START:\n\t\tcase MONO_PATCH_INFO_GC_NURSERY_BITS:\n\t\t\tbreak;\n\t\tcase MONO_PATCH_INFO_IMAGE:\n\t\t\t/* The assembly is stored in GOT slot 0 */\n\t\t\tif (patch_info->data.image != acfg->image)\n\t\t\t\tcfg->has_got_slots = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!is_plt_patch (patch_info) || (cfg->compile_llvm && acfg->aot_opts.llvm_only))\n\t\t\t\tcfg->has_got_slots = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!cfg->has_got_slots)\n\t\tmono_atomic_inc_i32 (&acfg->stats.methods_without_got_slots);\n\n\t/* Add gsharedvt wrappers for signatures used by the method */\n\tif (acfg->aot_opts.llvm_only) {\n\t\tGSList *l;\n\n\t\tif (!cfg->method->wrapper_type || cfg->method->wrapper_type == MONO_WRAPPER_DELEGATE_INVOKE)\n\t\t\t/* These only need out wrappers */\n\t\t\tadd_gsharedvt_wrappers (acfg, mono_method_signature (cfg->method), FALSE, TRUE);\n\n\t\tfor (l = cfg->signatures; l; l = l->next) {\n\t\t\tMonoMethodSignature *sig = mono_metadata_signature_dup ((MonoMethodSignature*)l->data);\n\n\t\t\t/* These only need in wrappers */\n\t\t\tadd_gsharedvt_wrappers (acfg, sig, TRUE, FALSE);\n\t\t}\n\t}\n\n\t/* \n\t * FIXME: Instead of this mess, allocate the patches from the aot mempool.\n\t */\n\t/* Make a copy of the patch info which is in the mempool */\n\t{\n\t\tMonoJumpInfo *patches = NULL, *patches_end = NULL;\n\n\t\tfor (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {\n\t\t\tMonoJumpInfo *new_patch_info = mono_patch_info_dup_mp (acfg->mempool, patch_info);\n\n\t\t\tif (!patches)\n\t\t\t\tpatches = new_patch_info;\n\t\t\telse\n\t\t\t\tpatches_end->next = new_patch_info;\n\t\t\tpatches_end = new_patch_info;\n\t\t}\n\t\tcfg->patch_info = patches;\n\t}\n\t/* Make a copy of the unwind info */\n\t{\n\t\tGSList *l, *unwind_ops;\n\t\tMonoUnwindOp *op;\n\n\t\tunwind_ops = NULL;\n\t\tfor (l = cfg->unwind_ops; l; l = l->next) {\n\t\t\top = (MonoUnwindOp *)mono_mempool_alloc (acfg->mempool, sizeof (MonoUnwindOp));\n\t\t\tmemcpy (op, l->data, sizeof (MonoUnwindOp));\n\t\t\tunwind_ops = g_slist_prepend_mempool (acfg->mempool, unwind_ops, op);\n\t\t}\n\t\tcfg->unwind_ops = g_slist_reverse (unwind_ops);\n\t}\n\t/* Make a copy of the argument/local info */\n\t{\n\t\tMonoError error;\n\t\tMonoInst **args, **locals;\n\t\tMonoMethodSignature *sig;\n\t\tMonoMethodHeader *header;\n\t\tint i;\n\t\t\n\t\tsig = mono_method_signature (method);\n\t\targs = (MonoInst **)mono_mempool_alloc (acfg->mempool, sizeof (MonoInst*) * (sig->param_count + sig->hasthis));\n\t\tfor (i = 0; i < sig->param_count + sig->hasthis; ++i) {\n\t\t\targs [i] = (MonoInst *)mono_mempool_alloc (acfg->mempool, sizeof (MonoInst));\n\t\t\tmemcpy (args [i], cfg->args [i], sizeof (MonoInst));\n\t\t}\n\t\tcfg->args = args;\n\n\t\theader = mono_method_get_header_checked (method, &error);\n\t\tmono_error_assert_ok (&error); /* FIXME don't swallow the error */\n\t\tlocals = (MonoInst **)mono_mempool_alloc (acfg->mempool, sizeof (MonoInst*) * header->num_locals);\n\t\tfor (i = 0; i < header->num_locals; ++i) {\n\t\t\tlocals [i] = (MonoInst *)mono_mempool_alloc (acfg->mempool, sizeof (MonoInst));\n\t\t\tmemcpy (locals [i], cfg->locals [i], sizeof (MonoInst));\n\t\t}\n\t\tmono_metadata_free_mh (header);\n\t\tcfg->locals = locals;\n\t}\n\n\t/* Free some fields used by cfg to conserve memory */\n\tmono_empty_compile (cfg);\n\n\t//printf (\"Compile:           %s\\n\", mono_method_full_name (method, TRUE));\n\n\twhile (index >= acfg->cfgs_size) {\n\t\tMonoCompile **new_cfgs;\n\t\tint new_size;\n\n\t\tnew_size = acfg->cfgs_size * 2;\n\t\tnew_cfgs = g_new0 (MonoCompile*, new_size);\n\t\tmemcpy (new_cfgs, acfg->cfgs, sizeof (MonoCompile*) * acfg->cfgs_size);\n\t\tg_free (acfg->cfgs);\n\t\tacfg->cfgs = new_cfgs;\n\t\tacfg->cfgs_size = new_size;\n\t}\n\tacfg->cfgs [index] = cfg;\n\n\tg_hash_table_insert (acfg->method_to_cfg, cfg->orig_method, cfg);\n\n\t/* Update global stats while holding a lock. */\n\tmono_update_jit_stats (cfg);\n\n\t/*\n\tif (cfg->orig_method->wrapper_type)\n\t\tg_ptr_array_add (acfg->extra_methods, cfg->orig_method);\n\t*/\n\n\tmono_acfg_unlock (acfg);\n\n\tmono_atomic_inc_i32 (&acfg->stats.ccount);\n}\n \nstatic mono_thread_start_return_t WINAPI\ncompile_thread_main (gpointer user_data)\n{\n\tMonoAotCompile *acfg = ((MonoAotCompile **)user_data) [0];\n\tGPtrArray *methods = ((GPtrArray **)user_data) [1];\n\tint i;\n\n\tMonoError error;\n\tMonoInternalThread *internal = mono_thread_internal_current ();\n\tMonoString *str = mono_string_new_checked (mono_domain_get (), \"AOT compiler\", &error);\n\tmono_error_assert_ok (&error);\n\tmono_thread_set_name_internal (internal, str, TRUE, FALSE, &error);\n\tmono_error_assert_ok (&error);\n\n\tfor (i = 0; i < methods->len; ++i)\n\t\tcompile_method (acfg, (MonoMethod *)g_ptr_array_index (methods, i));\n\n\treturn 0;\n}\n \n/* Used by the LLVM backend */\nguint32\nmono_aot_get_got_offset (MonoJumpInfo *ji)\n{\n\treturn get_got_offset (llvm_acfg, TRUE, ji);\n}\n\n/*\n * mono_aot_is_shared_got_offset:\n *\n *   Return whenever OFFSET refers to a GOT slot which is preinitialized\n * when the AOT image is loaded.\n */\ngboolean\nmono_aot_is_shared_got_offset (int offset)\n{\n\treturn offset < llvm_acfg->nshared_got_entries;\n}\n\nchar*\nmono_aot_get_method_name (MonoCompile *cfg)\n{\n\tif (llvm_acfg->aot_opts.static_link)\n\t\t/* Include the assembly name too to avoid duplicate symbol errors */\n\t\treturn g_strdup_printf (\"%s_%s\", llvm_acfg->assembly_name_sym, get_debug_sym (cfg->orig_method, \"\", llvm_acfg->method_label_hash));\n\telse\n\t\treturn get_debug_sym (cfg->orig_method, \"\", llvm_acfg->method_label_hash);\n}\n\n/*\n * mono_aot_is_linkonce_method:\n *\n *   Return whenever METHOD should be emitted with linkonce linkage,\n * eliminating duplicate copies when compiling in static mode.\n */\ngboolean\nmono_aot_is_linkonce_method (MonoMethod *method)\n{\n\treturn FALSE;\n#if 0\n\tWrapperInfo *info;\n\n\t// FIXME: Add more cases\n\tif (method->wrapper_type != MONO_WRAPPER_UNKNOWN)\n\t\treturn FALSE;\n\tinfo = mono_marshal_get_wrapper_info (method);\n\tif ((info && (info->subtype == WRAPPER_SUBTYPE_GSHAREDVT_IN_SIG || info->subtype == WRAPPER_SUBTYPE_GSHAREDVT_OUT_SIG)))\n\t\treturn TRUE;\n\treturn FALSE;\n#endif\n}\n\nstatic gboolean\nappend_mangled_type (GString *s, MonoType *t)\n{\n\tif (t->byref)\n\t\tg_string_append_printf (s, \"b\");\n\tswitch (t->type) {\n\tcase MONO_TYPE_VOID:\n\t\tg_string_append_printf (s, \"void_\");\n\t\tbreak;\n\tcase MONO_TYPE_I1:\n\t\tg_string_append_printf (s, \"i1\");\n\t\tbreak;\n\tcase MONO_TYPE_U1:\n\t\tg_string_append_printf (s, \"u1\");\n\t\tbreak;\n\tcase MONO_TYPE_I2:\n\t\tg_string_append_printf (s, \"i2\");\n\t\tbreak;\n\tcase MONO_TYPE_U2:\n\t\tg_string_append_printf (s, \"u2\");\n\t\tbreak;\n\tcase MONO_TYPE_I4:\n\t\tg_string_append_printf (s, \"i4\");\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\t\tg_string_append_printf (s, \"u4\");\n\t\tbreak;\n\tcase MONO_TYPE_I8:\n\t\tg_string_append_printf (s, \"i8\");\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\t\tg_string_append_printf (s, \"u8\");\n\t\tbreak;\n\tcase MONO_TYPE_I:\n\t\tg_string_append_printf (s, \"ii\");\n\t\tbreak;\n\tcase MONO_TYPE_U:\n\t\tg_string_append_printf (s, \"ui\");\n\t\tbreak;\n\tcase MONO_TYPE_R4:\n\t\tg_string_append_printf (s, \"fl\");\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n\t\tg_string_append_printf (s, \"do\");\n\t\tbreak;\n\tdefault: {\n\t\tchar *fullname = mono_type_full_name (t);\n\t\tGString *temp;\n\t\tchar *temps;\n\t\tint i, len;\n\n\t\t/*\n\t\t * Have to create a mangled name which is:\n\t\t * - a valid symbol\n\t\t * - unique\n\t\t */\n\t\ttemp = g_string_new (\"\");\n\t\tlen = strlen (fullname);\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tchar c = fullname [i];\n\t\t\tif (isalnum (c)) {\n\t\t\t\tg_string_append_c (temp, c);\n\t\t\t} else if (c == '_') {\n\t\t\t\tg_string_append_c (temp, '_');\n\t\t\t\tg_string_append_c (temp, '_');\n\t\t\t} else {\n\t\t\t\tg_string_append_c (temp, '_');\n\t\t\t\tg_string_append_printf (temp, \"%x\", (int)c);\n\t\t\t}\n\t\t}\n\t\ttemps = g_string_free (temp, FALSE);\n\t\t/* Include the length to avoid different length type names aliasing each other */\n\t\tg_string_append_printf (s, \"cl%x_%s_\", strlen (temps), temps);\n\t\tg_free (temps);\n\t}\n\t}\n\tif (t->attrs)\n\t\tg_string_append_printf (s, \"_attrs_%d\", t->attrs);\n\treturn TRUE;\n}\n\nstatic gboolean\nappend_mangled_signature (GString *s, MonoMethodSignature *sig)\n{\n\tint i;\n\tgboolean supported;\n\n\tsupported = append_mangled_type (s, sig->ret);\n\tif (!supported)\n\t\treturn FALSE;\n\tif (sig->hasthis)\n\t\tg_string_append_printf (s, \"this_\");\n\tif (sig->pinvoke)\n\t\tg_string_append_printf (s, \"pinvoke_\");\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tsupported = append_mangled_type (s, sig->params [i]);\n\t\tif (!supported)\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic void\nappend_mangled_wrapper_type (GString *s, guint32 wrapper_type) \n{\n\tconst char *label;\n\n\tswitch (wrapper_type) {\n\tcase MONO_WRAPPER_REMOTING_INVOKE:\n\t\tlabel = \"remoting_invoke\";\n\t\tbreak;\n\tcase MONO_WRAPPER_REMOTING_INVOKE_WITH_CHECK:\n\t\tlabel = \"remoting_invoke_check\";\n\t\tbreak;\n\tcase MONO_WRAPPER_XDOMAIN_INVOKE:\n\t\tlabel = \"remoting_invoke_xdomain\";\n\t\tbreak;\n\tcase MONO_WRAPPER_PROXY_ISINST:\n\t\tlabel = \"proxy_isinst\";\n\t\tbreak;\n\tcase MONO_WRAPPER_LDFLD:\n\t\tlabel = \"ldfld\";\n\t\tbreak;\n\tcase MONO_WRAPPER_LDFLDA:\n\t\tlabel = \"ldflda\";\n\t\tbreak;\n\tcase MONO_WRAPPER_STFLD: \n\t\tlabel = \"stfld\";\n\t\tbreak;\n\tcase MONO_WRAPPER_ALLOC:\n\t\tlabel = \"alloc\";\n\t\tbreak;\n\tcase MONO_WRAPPER_WRITE_BARRIER:\n\t\tlabel = \"write_barrier\";\n\t\tbreak;\n\tcase MONO_WRAPPER_STELEMREF:\n\t\tlabel = \"stelemref\";\n\t\tbreak;\n\tcase MONO_WRAPPER_UNKNOWN:\n\t\tlabel = \"unknown\";\n\t\tbreak;\n\tcase MONO_WRAPPER_MANAGED_TO_NATIVE:\n\t\tlabel = \"man2native\";\n\t\tbreak;\n\tcase MONO_WRAPPER_SYNCHRONIZED:\n\t\tlabel = \"synch\";\n\t\tbreak;\n\tcase MONO_WRAPPER_MANAGED_TO_MANAGED:\n\t\tlabel = \"man2man\";\n\t\tbreak;\n\tcase MONO_WRAPPER_CASTCLASS:\n\t\tlabel = \"castclass\";\n\t\tbreak;\n\tcase MONO_WRAPPER_RUNTIME_INVOKE:\n\t\tlabel = \"run_invoke\";\n\t\tbreak;\n\tcase MONO_WRAPPER_DELEGATE_INVOKE:\n\t\tlabel = \"del_inv\";\n\t\tbreak;\n\tcase MONO_WRAPPER_DELEGATE_BEGIN_INVOKE:\n\t\tlabel = \"del_beg_inv\";\n\t\tbreak;\n\tcase MONO_WRAPPER_DELEGATE_END_INVOKE:\n\t\tlabel = \"del_end_inv\";\n\t\tbreak;\n\tcase MONO_WRAPPER_NATIVE_TO_MANAGED:\n\t\tlabel = \"native2man\";\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\tg_string_append_printf (s, \"%s_\", label);\n}\n\nstatic void\nappend_mangled_wrapper_subtype (GString *s, WrapperSubtype subtype) \n{\n\tconst char *label;\n\n\tswitch (subtype) \n\t{\n\tcase WRAPPER_SUBTYPE_NONE:\n\t\treturn;\n\tcase WRAPPER_SUBTYPE_ELEMENT_ADDR:\n\t\tlabel = \"elem_addr\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_STRING_CTOR:\n\t\tlabel = \"str_ctor\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_VIRTUAL_STELEMREF:\n\t\tlabel = \"virt_stelem\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_FAST_MONITOR_ENTER:\n\t\tlabel = \"fast_mon_enter\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_FAST_MONITOR_ENTER_V4:\n\t\tlabel = \"fast_mon_enter_4\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_FAST_MONITOR_EXIT:\n\t\tlabel = \"fast_monitor_exit\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_PTR_TO_STRUCTURE:\n\t\tlabel = \"ptr2struct\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_STRUCTURE_TO_PTR:\n\t\tlabel = \"struct2ptr\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_CASTCLASS_WITH_CACHE:\n\t\tlabel = \"castclass_w_cache\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_ISINST_WITH_CACHE:\n\t\tlabel = \"isinst_w_cache\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_RUNTIME_INVOKE_NORMAL:\n\t\tlabel = \"run_inv_norm\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_RUNTIME_INVOKE_DYNAMIC:\n\t\tlabel = \"run_inv_dyn\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_RUNTIME_INVOKE_DIRECT:\n\t\tlabel = \"run_inv_dir\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_RUNTIME_INVOKE_VIRTUAL:\n\t\tlabel = \"run_inv_vir\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_ICALL_WRAPPER:\n\t\tlabel = \"icall\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_NATIVE_FUNC_AOT:\n\t\tlabel = \"native_func_aot\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_PINVOKE:\n\t\tlabel = \"pinvoke\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_SYNCHRONIZED_INNER:\n\t\tlabel = \"synch_inner\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_GSHAREDVT_IN:\n\t\tlabel = \"gshared_in\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_GSHAREDVT_OUT:\n\t\tlabel = \"gshared_out\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_ARRAY_ACCESSOR:\n\t\tlabel = \"array_acc\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_GENERIC_ARRAY_HELPER:\n\t\tlabel = \"generic_arry_help\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_DELEGATE_INVOKE_VIRTUAL:\n\t\tlabel = \"del_inv_virt\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_DELEGATE_INVOKE_BOUND:\n\t\tlabel = \"del_inv_bound\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_INTERP_IN:\n\t\tlabel = \"interp_in\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_GSHAREDVT_IN_SIG:\n\t\tlabel = \"gsharedvt_in_sig\";\n\t\tbreak;\n\tcase WRAPPER_SUBTYPE_GSHAREDVT_OUT_SIG:\n\t\tlabel = \"gsharedvt_out_sig\";\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\tg_string_append_printf (s, \"%s_\", label);\n}\n\nstatic char *\nsanitize_mangled_string (const char *input)\n{\n\tGString *s = g_string_new (\"\");\n\n\tfor (int i=0; input [i] != '\\0'; i++) {\n\t\tchar c = input [i];\n\t\tswitch (c) {\n\t\tcase '.':\n\t\t\tg_string_append (s, \"_dot_\");\n\t\t\tbreak;\n\t\tcase ' ':\n\t\t\tg_string_append (s, \"_\");\n\t\t\tbreak;\n\t\tcase '`':\n\t\t\tg_string_append (s, \"_bt_\");\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tg_string_append (s, \"_le_\");\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tg_string_append (s, \"_gt_\");\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tg_string_append (s, \"_sl_\");\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tg_string_append (s, \"_lbrack_\");\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tg_string_append (s, \"_rbrack_\");\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tg_string_append (s, \"_lparen_\");\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tg_string_append (s, \"_dash_\");\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\tg_string_append (s, \"_rparen_\");\n\t\t\tbreak;\n\t\tcase ',':\n\t\t\tg_string_append (s, \"_comma_\");\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tg_string_append (s, \"_colon_\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_string_append_c (s, c);\n\t\t}\n\t}\n\n\treturn g_string_free (s, FALSE);\n}\n\nstatic gboolean\nappend_mangled_klass (GString *s, MonoClass *klass)\n{\n\tchar *klass_desc = mono_class_full_name (klass);\n\tg_string_append_printf (s, \"_%s_%s_\", klass->name_space, klass_desc);\n\tg_free (klass_desc);\n\n\t// Success\n\treturn TRUE;\n}\n\nstatic gboolean\nappend_mangled_method (GString *s, MonoMethod *method);\n\nstatic gboolean\nappend_mangled_wrapper (GString *s, MonoMethod *method) \n{\n\tgboolean success = TRUE;\n\tWrapperInfo *info = mono_marshal_get_wrapper_info (method);\n\tg_string_append_printf (s, \"wrapper_\");\n\tg_string_append_printf (s, \"%s_\", method->klass->image->assembly->aname.name);\n\n\tappend_mangled_wrapper_type (s, method->wrapper_type);\n\n\tswitch (method->wrapper_type) {\n\tcase MONO_WRAPPER_REMOTING_INVOKE:\n\tcase MONO_WRAPPER_REMOTING_INVOKE_WITH_CHECK:\n\tcase MONO_WRAPPER_XDOMAIN_INVOKE: {\n\t\tMonoMethod *m = mono_marshal_method_from_wrapper (method);\n\t\tg_assert (m);\n\t\tsuccess = success && append_mangled_method (s, m);\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_PROXY_ISINST:\n\tcase MONO_WRAPPER_LDFLD:\n\tcase MONO_WRAPPER_LDFLDA:\n\tcase MONO_WRAPPER_STFLD: {\n\t\tg_assert (info);\n\t\tsuccess = success && append_mangled_klass (s, info->d.proxy.klass);\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_ALLOC: {\n\t\t/* The GC name is saved once in MonoAotFileInfo */\n\t\tg_assert (info->d.alloc.alloc_type != -1);\n\t\tg_string_append_printf (s, \"%d_\", info->d.alloc.alloc_type);\n\t\t// SlowAlloc, etc\n\t\tg_string_append_printf (s, \"%s_\", method->name);\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_WRITE_BARRIER: {\n\t\tg_string_append_printf (s, \"%s_\", method->name);\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_STELEMREF: {\n\t\tappend_mangled_wrapper_subtype (s, info->subtype);\n\t\tif (info->subtype == WRAPPER_SUBTYPE_VIRTUAL_STELEMREF)\n\t\t\tg_string_append_printf (s, \"%d\", info->d.virtual_stelemref.kind);\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_UNKNOWN: {\n\t\tappend_mangled_wrapper_subtype (s, info->subtype);\n\t\tif (info->subtype == WRAPPER_SUBTYPE_PTR_TO_STRUCTURE ||\n\t\t\tinfo->subtype == WRAPPER_SUBTYPE_STRUCTURE_TO_PTR)\n\t\t\tsuccess = success && append_mangled_klass (s, method->klass);\n\t\telse if (info->subtype == WRAPPER_SUBTYPE_SYNCHRONIZED_INNER)\n\t\t\tsuccess = success && append_mangled_method (s, info->d.synchronized_inner.method);\n\t\telse if (info->subtype == WRAPPER_SUBTYPE_ARRAY_ACCESSOR)\n\t\t\tsuccess = success && append_mangled_method (s, info->d.array_accessor.method);\n\t\telse if (info->subtype == WRAPPER_SUBTYPE_INTERP_IN)\n\t\t\tappend_mangled_signature (s, info->d.interp_in.sig);\n\t\telse if (info->subtype == WRAPPER_SUBTYPE_GSHAREDVT_IN_SIG)\n\t\t\tappend_mangled_signature (s, info->d.gsharedvt.sig);\n\t\telse if (info->subtype == WRAPPER_SUBTYPE_GSHAREDVT_OUT_SIG)\n\t\t\tappend_mangled_signature (s, info->d.gsharedvt.sig);\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_MANAGED_TO_NATIVE: {\n\t\tappend_mangled_wrapper_subtype (s, info->subtype);\n\t\tif (info->subtype == WRAPPER_SUBTYPE_ICALL_WRAPPER) {\n\t\t\tg_string_append_printf (s, \"%s\", method->name);\n\t\t} else if (info->subtype == WRAPPER_SUBTYPE_NATIVE_FUNC_AOT) {\n\t\t\tsuccess = success && append_mangled_method (s, info->d.managed_to_native.method);\n\t\t} else {\n\t\t\tg_assert (info->subtype == WRAPPER_SUBTYPE_NONE || info->subtype == WRAPPER_SUBTYPE_PINVOKE);\n\t\t\tsuccess = success && append_mangled_method (s, info->d.managed_to_native.method);\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_SYNCHRONIZED: {\n\t\tMonoMethod *m;\n\n\t\tm = mono_marshal_method_from_wrapper (method);\n\t\tg_assert (m);\n\t\tg_assert (m != method);\n\t\tsuccess = success && append_mangled_method (s, m);\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_MANAGED_TO_MANAGED: {\n\t\tappend_mangled_wrapper_subtype (s, info->subtype);\n\n\t\tif (info->subtype == WRAPPER_SUBTYPE_ELEMENT_ADDR) {\n\t\t\tg_string_append_printf (s, \"%d_\", info->d.element_addr.rank);\n\t\t\tg_string_append_printf (s, \"%d_\", info->d.element_addr.elem_size);\n\t\t} else if (info->subtype == WRAPPER_SUBTYPE_STRING_CTOR) {\n\t\t\tsuccess = success && append_mangled_method (s, info->d.string_ctor.method);\n\t\t} else if (info->subtype == WRAPPER_SUBTYPE_GENERIC_ARRAY_HELPER) {\n\t\t\tsuccess = success && append_mangled_method (s, info->d.generic_array_helper.method);\n\t\t} else {\n\t\t\tsuccess = FALSE;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_CASTCLASS: {\n\t\tappend_mangled_wrapper_subtype (s, info->subtype);\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_RUNTIME_INVOKE: {\n\t\tappend_mangled_wrapper_subtype (s, info->subtype);\n\t\tif (info->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_DIRECT || info->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_VIRTUAL)\n\t\t\tsuccess = success && append_mangled_method (s, info->d.runtime_invoke.method);\n\t\telse if (info->subtype == WRAPPER_SUBTYPE_RUNTIME_INVOKE_NORMAL)\n\t\t\tsuccess = success && append_mangled_signature (s, info->d.runtime_invoke.sig);\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_DELEGATE_INVOKE:\n\tcase MONO_WRAPPER_DELEGATE_BEGIN_INVOKE:\n\tcase MONO_WRAPPER_DELEGATE_END_INVOKE: {\n\t\tif (method->is_inflated) {\n\t\t\t/* These wrappers are identified by their class */\n\t\t\tg_string_append_printf (s, \"i_\");\n\t\t\tsuccess = success && append_mangled_klass (s, method->klass);\n\t\t} else {\n\t\t\tWrapperInfo *info = mono_marshal_get_wrapper_info (method);\n\n\t\t\tg_string_append_printf (s, \"u_\");\n\t\t\tif (method->wrapper_type == MONO_WRAPPER_DELEGATE_INVOKE)\n\t\t\t\tappend_mangled_wrapper_subtype (s, info->subtype);\n\t\t\tg_string_append_printf (s, \"u_sigstart\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_WRAPPER_NATIVE_TO_MANAGED: {\n\t\tg_assert (info);\n\t\tsuccess = success && append_mangled_method (s, info->d.native_to_managed.method);\n\t\tsuccess = success && append_mangled_klass (s, method->klass);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn success && append_mangled_signature (s, mono_method_signature (method));\n}\n\nstatic void\nappend_mangled_ginst (GString *str, MonoGenericInst *ginst)\n{\n\tint i;\n\n\tfor (i = 0; i < ginst->type_argc; ++i) {\n\t\tif (i > 0)\n\t\t\tg_string_append (str, \", \");\n\t\tMonoType *type = ginst->type_argv [i];\n\t\tswitch (type->type) {\n\t\tcase MONO_TYPE_VAR:\n\t\tcase MONO_TYPE_MVAR: {\n\t\t\tMonoType *constraint = NULL;\n\t\t\tif (type->data.generic_param)\n\t\t\t\tconstraint = type->data.generic_param->gshared_constraint;\n\t\t\tif (constraint) {\n\t\t\t\tg_assert (constraint->type != MONO_TYPE_VAR && constraint->type != MONO_TYPE_MVAR);\n\t\t\t\tg_string_append (str, \"gshared:\");\n\t\t\t\tmono_type_get_desc (str, constraint, TRUE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Else falls through to common case\n\t\t}\n\t\tdefault:\n\t\t\tmono_type_get_desc (str, type, TRUE);\n\t\t}\n\t}\n}\n\nstatic void\nappend_mangled_context (GString *str, MonoGenericContext *context)\n{\n\tGString *res = g_string_new (\"\");\n\n\tg_string_append_printf (res, \"gens_\");\n\tg_string_append (res, \"00\");\n\n\tgboolean good = context->class_inst && context->class_inst->type_argc > 0;\n\tgood = good || (context->method_inst && context->method_inst->type_argc > 0);\n\tg_assert (good);\n\n\tif (context->class_inst)\n\t\tappend_mangled_ginst (res, context->class_inst);\n\tif (context->method_inst) {\n\t\tif (context->class_inst)\n\t\t\tg_string_append (res, \"11\");\n\t\tappend_mangled_ginst (res, context->method_inst);\n\t}\n\tg_string_append_printf (str, \"gens_%s\", res->str);\n\tg_free (res);\n}\n\nstatic gboolean\nappend_mangled_method (GString *s, MonoMethod *method)\n{\n\tif (method->wrapper_type)\n\t\treturn append_mangled_wrapper (s, method);\n\n\tif (method->is_inflated) {\n\t\tg_string_append_printf (s, \"inflated_\");\n\t\tMonoMethodInflated *imethod = (MonoMethodInflated*) method;\n\t\tg_assert (imethod->context.class_inst != NULL || imethod->context.method_inst != NULL);\n\n\t\tappend_mangled_context (s, &imethod->context);\n\t\tg_string_append_printf (s, \"_declared_by_\");\n\t\tappend_mangled_method (s, imethod->declaring);\n\t} else if (method->is_generic) {\n\t\tg_string_append_printf (s, \"%s_\", method->klass->image->assembly->aname.name);\n\n\t\tg_string_append_printf (s, \"generic_\");\n\t\tappend_mangled_klass (s, method->klass);\n\t\tg_string_append_printf (s, \"_%s_\", method->name);\n\n\t\tMonoGenericContainer *container = mono_method_get_generic_container (method);\n\t\tg_string_append_printf (s, \"_%s\");\n\t\tappend_mangled_context (s, &container->context);\n\n\t\treturn append_mangled_signature (s, mono_method_signature (method));\n\t} else {\n\t\tg_string_append_printf (s, \"_\");\n\t\tappend_mangled_klass (s, method->klass);\n\t\tg_string_append_printf (s, \"_%s_\", method->name);\n\t\tif (!append_mangled_signature (s, mono_method_signature (method))) {\n\t\t\tg_string_free (s, TRUE);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * mono_aot_get_mangled_method_name:\n *\n *   Return a unique mangled name for METHOD, or NULL.\n */\nchar*\nmono_aot_get_mangled_method_name (MonoMethod *method)\n{\n\t// FIXME: use static cache (mempool?)\n\t// We call this a *lot*\n\n\tGString *s = g_string_new (\"aot_\");\n\tif (!append_mangled_method (s, method)) {\n\t\tg_string_free (s, TRUE);\n\t\treturn NULL;\n\t} else {\n\t\tchar *out = g_string_free (s, FALSE);\n\t\t// Scrub method and class names\n\t\tchar *cleaned = sanitize_mangled_string (out);\n\t\tg_free (out);\n\t\treturn cleaned;\n\t}\n}\n\ngboolean\nmono_aot_is_direct_callable (MonoJumpInfo *patch_info)\n{\n\treturn is_direct_callable (llvm_acfg, NULL, patch_info);\n}\n\nvoid\nmono_aot_mark_unused_llvm_plt_entry (MonoJumpInfo *patch_info)\n{\n\tMonoPltEntry *plt_entry;\n\n\tplt_entry = get_plt_entry (llvm_acfg, patch_info);\n\tplt_entry->llvm_used = FALSE;\n}\n\nchar*\nmono_aot_get_direct_call_symbol (MonoJumpInfoType type, gconstpointer data)\n{\n\tconst char *sym = NULL;\n\n\tif (llvm_acfg->aot_opts.direct_icalls) {\n\t\tif (type == MONO_PATCH_INFO_JIT_ICALL_ADDR) {\n\t\t\t/* Call to a C function implementing a jit icall */\n\t\t\tsym = mono_lookup_jit_icall_symbol ((const char *)data);\n\t\t} else if (type == MONO_PATCH_INFO_ICALL_ADDR_CALL) {\n\t\t\tMonoMethod *method = (MonoMethod *)data;\n\t\t\tif (!(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))\n\t\t\t\tsym = mono_lookup_icall_symbol (method);\n\t\t\telse if (llvm_acfg->aot_opts.direct_pinvoke)\n\t\t\t\tsym = get_pinvoke_import (llvm_acfg, method);\n\t\t}\n\t\tif (sym)\n\t\t\treturn g_strdup (sym);\n\t}\n\treturn NULL;\n}\n\nchar*\nmono_aot_get_plt_symbol (MonoJumpInfoType type, gconstpointer data)\n{\n\tMonoJumpInfo *ji = (MonoJumpInfo *)mono_mempool_alloc (llvm_acfg->mempool, sizeof (MonoJumpInfo));\n\tMonoPltEntry *plt_entry;\n\tconst char *sym = NULL;\n\n\tji->type = type;\n\tji->data.target = data;\n\n\tif (!can_encode_patch (llvm_acfg, ji))\n\t\treturn NULL;\n\n\tif (llvm_acfg->aot_opts.direct_icalls) {\n\t\tif (type == MONO_PATCH_INFO_JIT_ICALL_ADDR) {\n\t\t\t/* Call to a C function implementing a jit icall */\n\t\t\tsym = mono_lookup_jit_icall_symbol ((const char *)data);\n\t\t} else if (type == MONO_PATCH_INFO_ICALL_ADDR_CALL) {\n\t\t\tMonoMethod *method = (MonoMethod *)data;\n\t\t\tif (!(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))\n\t\t\t\tsym = mono_lookup_icall_symbol (method);\n\t\t}\n\t\tif (sym)\n\t\t\treturn g_strdup (sym);\n\t}\n\n\tplt_entry = get_plt_entry (llvm_acfg, ji);\n\tplt_entry->llvm_used = TRUE;\n\n#if defined(TARGET_MACH)\n\treturn g_strdup_printf (plt_entry->llvm_symbol + strlen (llvm_acfg->llvm_label_prefix));\n#else\n\treturn g_strdup_printf (plt_entry->llvm_symbol);\n#endif\n}\n\nint\nmono_aot_get_method_index (MonoMethod *method)\n{\n\tg_assert (llvm_acfg);\n\treturn get_method_index (llvm_acfg, method);\n}\n\nMonoJumpInfo*\nmono_aot_patch_info_dup (MonoJumpInfo* ji)\n{\n\tMonoJumpInfo *res;\n\n\tmono_acfg_lock (llvm_acfg);\n\tres = mono_patch_info_dup_mp (llvm_acfg->mempool, ji);\n\tmono_acfg_unlock (llvm_acfg);\n\n\treturn res;\n}\n\nstatic int\nexecute_system (const char * command)\n{\n\tint status = 0;\n\n#if G_HAVE_API_SUPPORT(HAVE_CLASSIC_WINAPI_SUPPORT) && defined(HOST_WIN32)\n\t// We need an extra set of quotes around the whole command to properly handle commands \n\t// with spaces since internally the command is called through \"cmd /c.\n\tchar * quoted_command = g_strdup_printf (\"\\\"%s\\\"\", command);\n\n\tint size =  MultiByteToWideChar (CP_UTF8, 0 , quoted_command , -1, NULL , 0);\n\twchar_t* wstr = g_malloc (sizeof (wchar_t) * size);\n\tMultiByteToWideChar (CP_UTF8, 0, quoted_command, -1, wstr , size);\n\tstatus = _wsystem (wstr);\n\tg_free (wstr);\n\n\tg_free (quoted_command);\n#elif defined (HAVE_SYSTEM)\n\tstatus = system (command);\n#else\n\tg_assert_not_reached ();\n#endif\n\n\treturn status;\n}\n\n#ifdef ENABLE_LLVM\n\n/*\n * emit_llvm_file:\n *\n *   Emit the LLVM code into an LLVM bytecode file, and compile it using the LLVM\n * tools.\n */\nstatic gboolean\nemit_llvm_file (MonoAotCompile *acfg)\n{\n\tchar *command, *opts, *tempbc, *optbc, *output_fname;\n\n\tif (acfg->aot_opts.llvm_only && acfg->aot_opts.asm_only) {\n\t\ttempbc = g_strdup_printf (\"%s.bc\", acfg->tmpbasename);\n\t\toptbc = g_strdup (acfg->aot_opts.llvm_outfile);\n\t} else {\n\t\ttempbc = g_strdup_printf (\"%s.bc\", acfg->tmpbasename);\n\t\toptbc = g_strdup_printf (\"%s.opt.bc\", acfg->tmpbasename);\n\t}\n\n\tmono_llvm_emit_aot_module (tempbc, g_path_get_basename (acfg->image->name));\n\n\t/*\n\t * FIXME: Experiment with adding optimizations, the -std-compile-opts set takes\n\t * a lot of time, and doesn't seem to save much space.\n\t * The following optimizations cannot be enabled:\n\t * - 'tailcallelim'\n\t * - 'jump-threading' changes our blockaddress references to int constants.\n\t * - 'basiccg' fails because it contains:\n\t * if (CS && !isa<IntrinsicInst>(II)) {\n\t * and isa<IntrinsicInst> is false for invokes to intrinsics (iltests.exe).\n\t * - 'prune-eh' and 'functionattrs' depend on 'basiccg'.\n\t * The opt list below was produced by taking the output of:\n\t * llvm-as < /dev/null | opt -O2 -disable-output -debug-pass=Arguments\n\t * then removing tailcallelim + the global opts.\n\t * strip-dead-prototypes deletes unused intrinsics definitions.\n\t */\n\t/* The dse pass is disabled because of #13734 and #17616 */\n\t/*\n\t * The dse bug is in DeadStoreElimination.cpp:isOverwrite ():\n\t * // If we have no DataLayout information around, then the size of the store\n\t *  // is inferrable from the pointee type.  If they are the same type, then\n\t * // we know that the store is safe.\n\t * if (AA.getDataLayout() == 0 &&\n\t * Later.Ptr->getType() == Earlier.Ptr->getType()) {\n\t * return OverwriteComplete;\n\t * Here, if 'Earlier' refers to a memset, and Later has no size info, it mistakenly thinks the memset is redundant.\n\t */\n\tif (acfg->aot_opts.llvm_only)\n\t\t// FIXME: This doesn't work yet\n\t\topts = g_strdup (\"\");\n\telse\n#if LLVM_API_VERSION > 100\n\t\topts = g_strdup (\"-O2 -disable-tail-calls\");\n#else\n\t\topts = g_strdup (\"-targetlibinfo -no-aa -basicaa -notti -instcombine -simplifycfg -inline-cost -inline -sroa -domtree -early-cse -lazy-value-info -correlated-propagation -simplifycfg -instcombine -simplifycfg -reassociate -domtree -loops -loop-simplify -lcssa -loop-rotate -licm -lcssa -loop-unswitch -instcombine -scalar-evolution -loop-simplify -lcssa -indvars -loop-idiom -loop-deletion -loop-unroll -memdep -gvn -memdep -memcpyopt -sccp -instcombine -lazy-value-info -correlated-propagation -domtree -memdep -adce -simplifycfg -instcombine -strip-dead-prototypes -domtree -verify\");\n#endif\n\tcommand = g_strdup_printf (\"\\\"%sopt\\\" -f %s -o \\\"%s\\\" \\\"%s\\\"\", acfg->aot_opts.llvm_path, opts, optbc, tempbc);\n\taot_printf (acfg, \"Executing opt: %s\\n\", command);\n\tif (execute_system (command) != 0)\n\t\treturn FALSE;\n\tg_free (opts);\n\n\tif (acfg->aot_opts.llvm_only && acfg->aot_opts.asm_only)\n\t\t/* Nothing else to do */\n\t\treturn TRUE;\n\n\tif (acfg->aot_opts.llvm_only) {\n\t\t/* Use the stock clang from xcode */\n\t\t// FIXME: arch\n\t\tcommand = g_strdup_printf (\"clang++ -fexceptions -march=x86-64 -fpic -msse -msse2 -msse3 -msse4 -O2 -fno-optimize-sibling-calls -Wno-override-module -c -o \\\"%s\\\" \\\"%s.opt.bc\\\"\", acfg->llvm_ofile, acfg->tmpbasename);\n\n\t\taot_printf (acfg, \"Executing clang: %s\\n\", command);\n\t\tif (execute_system (command) != 0)\n\t\t\treturn FALSE;\n\t\treturn TRUE;\n\t}\n\n\tif (!acfg->llc_args)\n\t\tacfg->llc_args = g_string_new (\"\");\n\n\t/* Verbose asm slows down llc greatly */\n\tg_string_append (acfg->llc_args, \" -asm-verbose=false\");\n\n\tif (acfg->aot_opts.mtriple)\n\t\tg_string_append_printf (acfg->llc_args, \" -mtriple=%s\", acfg->aot_opts.mtriple);\n\n\tg_string_append (acfg->llc_args, \" -disable-gnu-eh-frame -enable-mono-eh-frame\");\n\n\tg_string_append_printf (acfg->llc_args, \" -mono-eh-frame-symbol=%s%s\", acfg->user_symbol_prefix, acfg->llvm_eh_frame_symbol);\n\n#if LLVM_API_VERSION > 100\n\tg_string_append_printf (acfg->llc_args, \" -disable-tail-calls\");\n#endif\n\n#if ( defined(TARGET_MACH) && defined(TARGET_ARM) ) || defined(TARGET_ORBIS)\n\t/* ios requires PIC code now */\n\tg_string_append_printf (acfg->llc_args, \" -relocation-model=pic\");\n#else\n\tif (llvm_acfg->aot_opts.static_link)\n\t\tg_string_append_printf (acfg->llc_args, \" -relocation-model=static\");\n\telse\n\t\tg_string_append_printf (acfg->llc_args, \" -relocation-model=pic\");\n#endif\n\n\tif (acfg->llvm_owriter) {\n\t\t/* Emit an object file directly */\n\t\toutput_fname = g_strdup_printf (\"%s\", acfg->llvm_ofile);\n\t\tg_string_append_printf (acfg->llc_args, \" -filetype=obj\");\n\t} else {\n\t\toutput_fname = g_strdup_printf (\"%s\", acfg->llvm_sfile);\n\t}\n\tcommand = g_strdup_printf (\"\\\"%sllc\\\" %s -o \\\"%s\\\" \\\"%s.opt.bc\\\"\", acfg->aot_opts.llvm_path, acfg->llc_args->str, output_fname, acfg->tmpbasename);\n\tg_free (output_fname);\n\n\taot_printf (acfg, \"Executing llc: %s\\n\", command);\n\n\tif (execute_system (command) != 0)\n\t\treturn FALSE;\n\treturn TRUE;\n}\n#endif\n\nstatic void\nemit_code (MonoAotCompile *acfg)\n{\n\tint oindex, i, prev_index;\n\tgboolean saved_unbox_info = FALSE;\n\tchar symbol [MAX_SYMBOL_SIZE];\n\n\tif (acfg->aot_opts.llvm_only)\n\t\treturn;\n\n#if defined(TARGET_POWERPC64)\n\tsprintf (symbol, \".Lgot_addr\");\n\temit_section_change (acfg, \".text\", 0);\n\temit_alignment (acfg, 8);\n\temit_label (acfg, symbol);\n\temit_pointer (acfg, acfg->got_symbol);\n#endif\n\n\t/* \n\t * This global symbol is used to compute the address of each method using the\n\t * code_offsets array. It is also used to compute the memory ranges occupied by\n\t * AOT code, so it must be equal to the address of the first emitted method.\n\t */\n\temit_section_change (acfg, \".text\", 0);\n\temit_alignment_code (acfg, 8);\n\temit_info_symbol (acfg, \"jit_code_start\");\n\n\t/* \n\t * Emit some padding so the local symbol for the first method doesn't have the\n\t * same address as 'methods'.\n\t */\n\temit_padding (acfg, 16);\n\n\tfor (oindex = 0; oindex < acfg->method_order->len; ++oindex) {\n\t\tMonoCompile *cfg;\n\t\tMonoMethod *method;\n\n\t\ti = GPOINTER_TO_UINT (g_ptr_array_index (acfg->method_order, oindex));\n\n\t\tcfg = acfg->cfgs [i];\n\n\t\tif (!cfg)\n\t\t\tcontinue;\n\n\t\tmethod = cfg->orig_method;\n\n\t\tgboolean dedup_collect = acfg->aot_opts.dedup || (acfg->aot_opts.dedup_include && !acfg->dedup_emit_mode);\n\t\tgboolean dedupable = mono_aot_can_dedup (method);\n\n\t\t// cfg->skip is vital for LLVM to work, can't just continue in this loop\n\t\tif (dedupable && strcmp (method->name, \"wbarrier_conc\") && dedup_collect) {\n\t\t\tmono_dedup_cache_method (acfg, method);\n\n\t\t\t// Don't compile inflated methods if we're in first phase of\n\t\t\t// dedup\n\t\t\t//\n\t\t\t// In second phase, we emit methods that\n\t\t\t// are dedupable. We also emit later methods\n\t\t\t// which are referenced by them and added later. \n\t\t\t// For this reason, when in the dedup_include mode,\n\t\t\t// we never set skip.\n\t\t\tif (acfg->aot_opts.dedup)\n\t\t\t\tcfg->skip = TRUE;\n\t\t}\n\n\t\t// Don't compile anything in this mode\n\t\tif (acfg->aot_opts.dedup_include && !acfg->dedup_emit_mode)\n\t\t\tcfg->skip = TRUE;\n\n\t\t// Compile everything in this mode\n\t\tif (acfg->aot_opts.dedup_include && acfg->dedup_emit_mode)\n\t\t\tcfg->skip = FALSE;\n\n\t\t/*if (dedup_collect) {*/\n\t\t\t/*char *name = mono_aot_get_mangled_method_name (method);*/\n\n\t\t\t/*if (ignore_cfg (cfg))*/\n\t\t\t\t/*aot_printf (acfg, \"Dedup Skipping %s\\n\", acfg->image->name, name);*/\n\t\t\t/*else*/\n\t\t\t\t/*aot_printf (acfg, \"Dedup Keeping %s\\n\", acfg->image->name, name);*/\n\n\t\t\t/*g_free (name);*/\n\t\t/*}*/\n\n\t\tif (ignore_cfg (cfg))\n\t\t\tcontinue;\n\n\t\t/* Emit unbox trampoline */\n\t\tif (mono_aot_mode_is_full (&acfg->aot_opts) && cfg->orig_method->klass->valuetype) {\n\t\t\tsprintf (symbol, \"ut_%d\", get_method_index (acfg, method));\n\n\t\t\temit_section_change (acfg, \".text\", 0);\n\n\t\t\tif (acfg->thumb_mixed && cfg->compile_llvm) {\n\t\t\t\temit_set_thumb_mode (acfg);\n\t\t\t\tfprintf (acfg->fp, \"\\n.thumb_func\\n\");\n\t\t\t}\n\n\t\t\temit_label (acfg, symbol);\n\n\t\t\tarch_emit_unbox_trampoline (acfg, cfg, cfg->orig_method, cfg->asm_symbol);\n\n\t\t\tif (acfg->thumb_mixed && cfg->compile_llvm)\n\t\t\t\temit_set_arm_mode (acfg);\n\n\t\t\tif (!saved_unbox_info) {\n\t\t\t\tchar user_symbol [128];\n\t\t\t\tGSList *unwind_ops;\n\t\t\t\tsprintf (user_symbol, \"%sunbox_trampoline_p\", acfg->user_symbol_prefix);\n\n\t\t\t\temit_label (acfg, \"ut_end\");\n\n\t\t\t\tunwind_ops = mono_unwind_get_cie_program ();\n\t\t\t\tsave_unwind_info (acfg, user_symbol, unwind_ops);\n\t\t\t\tmono_free_unwind_info (unwind_ops);\n\n\t\t\t\t/* Save the unbox trampoline size */\n\t\t\t\temit_symbol_diff (acfg, \"ut_end\", symbol, 0);\n\n\t\t\t\tsaved_unbox_info = TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (cfg->compile_llvm) {\n\t\t\tacfg->stats.llvm_count ++;\n\t\t} else {\n\t\t\temit_method_code (acfg, cfg);\n\t\t}\n\t}\n\n\temit_section_change (acfg, \".text\", 0);\n\temit_alignment_code (acfg, 8);\n\temit_info_symbol (acfg, \"jit_code_end\");\n\n\t/* To distinguish it from the next symbol */\n\temit_padding (acfg, 4);\n\n\t/* \n\t * Add .no_dead_strip directives for all LLVM methods to prevent the OSX linker\n\t * from optimizing them away, since it doesn't see that code_offsets references them.\n\t * JITted methods don't need this since they are referenced using assembler local\n\t * symbols.\n\t * FIXME: This is why write-symbols doesn't work on OSX ?\n\t */\n\tif (acfg->llvm && acfg->need_no_dead_strip) {\n\t\tfprintf (acfg->fp, \"\\n\");\n\t\tfor (i = 0; i < acfg->nmethods; ++i) {\n\t\t\tif (acfg->cfgs [i] && acfg->cfgs [i]->compile_llvm)\n\t\t\t\tfprintf (acfg->fp, \".no_dead_strip %s\\n\", acfg->cfgs [i]->asm_symbol);\n\t\t}\n\t}\n\n\t/*\n\t * To work around linker issues, we emit a table of branches, and disassemble them at runtime.\n\t * This is PIE code, and the linker can update it if needed.\n\t */\n\t\n\tsprintf (symbol, \"method_addresses\");\n\temit_section_change (acfg, \".text\", 1);\n\temit_alignment_code (acfg, 8);\n\temit_info_symbol (acfg, symbol);\n\tif (acfg->aot_opts.write_symbols)\n\t\temit_local_symbol (acfg, symbol, \"method_addresses_end\", TRUE);\n\temit_unset_mode (acfg);\n\tif (acfg->need_no_dead_strip)\n\t\tfprintf (acfg->fp, \"\t.no_dead_strip %s\\n\", symbol);\n\n\tfor (i = 0; i < acfg->nmethods; ++i) {\n#ifdef MONO_ARCH_AOT_SUPPORTED\n\t\tint call_size;\n\n\t\tif (!ignore_cfg (acfg->cfgs [i])) {\n\t\t\tarch_emit_direct_call (acfg, acfg->cfgs [i]->asm_symbol, FALSE, acfg->thumb_mixed && acfg->cfgs [i]->compile_llvm, NULL, &call_size);\n\t\t} else {\n\t\t\tarch_emit_direct_call (acfg, symbol, FALSE, FALSE, NULL, &call_size);\n\t\t}\n#endif\n\t}\n\n\tsprintf (symbol, \"method_addresses_end\");\n\temit_label (acfg, symbol);\n\temit_line (acfg);\n\n\t/* Emit a sorted table mapping methods to the index of their unbox trampolines */\n\tsprintf (symbol, \"unbox_trampolines\");\n\temit_section_change (acfg, RODATA_SECT, 0);\n\temit_alignment (acfg, 8);\n\temit_info_symbol (acfg, symbol);\n\n\tprev_index = -1;\n\tfor (i = 0; i < acfg->nmethods; ++i) {\n\t\tMonoCompile *cfg;\n\t\tMonoMethod *method;\n\t\tint index;\n\n\t\tcfg = acfg->cfgs [i];\n\t\tif (ignore_cfg (cfg))\n\t\t\tcontinue;\n\n\t\tmethod = cfg->orig_method;\n\n\t\tif (mono_aot_mode_is_full (&acfg->aot_opts) && cfg->orig_method->klass->valuetype) {\n\t\t\tindex = get_method_index (acfg, method);\n\n\t\t\temit_int32 (acfg, index);\n\t\t\t/* Make sure the table is sorted by index */\n\t\t\tg_assert (index > prev_index);\n\t\t\tprev_index = index;\n\t\t}\n\t}\n\tsprintf (symbol, \"unbox_trampolines_end\");\n\temit_info_symbol (acfg, symbol);\n\temit_int32 (acfg, 0);\n\n\t/* Emit a separate table with the trampoline addresses/offsets */\n\tsprintf (symbol, \"unbox_trampoline_addresses\");\n\temit_section_change (acfg, \".text\", 0);\n\temit_alignment_code (acfg, 8);\n\temit_info_symbol (acfg, symbol);\n\n\tfor (i = 0; i < acfg->nmethods; ++i) {\n\t\tMonoCompile *cfg;\n\t\tMonoMethod *method;\n\t\tint index;\n\n\t\tcfg = acfg->cfgs [i];\n\t\tif (ignore_cfg (cfg))\n\t\t\tcontinue;\n\n\t\tmethod = cfg->orig_method;\n\n\t\tif (mono_aot_mode_is_full (&acfg->aot_opts) && cfg->orig_method->klass->valuetype) {\n#ifdef MONO_ARCH_AOT_SUPPORTED\n\t\t\tint call_size;\n\n\t\t\tindex = get_method_index (acfg, method);\n\t\t\tsprintf (symbol, \"ut_%d\", index);\n\n\t\t\tarch_emit_direct_call (acfg, symbol, FALSE, acfg->thumb_mixed && cfg->compile_llvm, NULL, &call_size);\n#endif\n\t\t}\n\t}\n\temit_int32 (acfg, 0);\n}\n\nstatic void\nemit_info (MonoAotCompile *acfg)\n{\n\tint oindex, i;\n\tgint32 *offsets;\n\n\toffsets = g_new0 (gint32, acfg->nmethods);\n\n\tfor (oindex = 0; oindex < acfg->method_order->len; ++oindex) {\n\t\ti = GPOINTER_TO_UINT (g_ptr_array_index (acfg->method_order, oindex));\n\n\t\tif (acfg->cfgs [i]) {\n\t\t\temit_method_info (acfg, acfg->cfgs [i]);\n\t\t\toffsets [i] = acfg->cfgs [i]->method_info_offset;\n\t\t} else {\n\t\t\toffsets [i] = 0;\n\t\t}\n\t}\n\n\tacfg->stats.offsets_size += emit_offset_table (acfg, \"method_info_offsets\", MONO_AOT_TABLE_METHOD_INFO_OFFSETS, acfg->nmethods, 10, offsets);\n\n\tg_free (offsets);\n}\n\n#endif /* #if !defined(DISABLE_AOT) && !defined(DISABLE_JIT) */\n\n#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n#define mix(a,b,c) { \\\n\ta -= c;  a ^= rot(c, 4);  c += b; \\\n\tb -= a;  b ^= rot(a, 6);  a += c; \\\n\tc -= b;  c ^= rot(b, 8);  b += a; \\\n\ta -= c;  a ^= rot(c,16);  c += b; \\\n\tb -= a;  b ^= rot(a,19);  a += c; \\\n\tc -= b;  c ^= rot(b, 4);  b += a; \\\n}\n#define final(a,b,c) { \\\n\tc ^= b; c -= rot(b,14); \\\n\ta ^= c; a -= rot(c,11); \\\n\tb ^= a; b -= rot(a,25); \\\n\tc ^= b; c -= rot(b,16); \\\n\ta ^= c; a -= rot(c,4);  \\\n\tb ^= a; b -= rot(a,14); \\\n\tc ^= b; c -= rot(b,24); \\\n}\n\nstatic guint\nmono_aot_type_hash (MonoType *t1)\n{\n\tguint hash = t1->type;\n\n\thash |= t1->byref << 6; /* do not collide with t1->type values */\n\tswitch (t1->type) {\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_SZARRAY:\n\t\t/* check if the distribution is good enough */\n\t\treturn ((hash << 5) - hash) ^ mono_metadata_str_hash (t1->data.klass->name);\n\tcase MONO_TYPE_PTR:\n\t\treturn ((hash << 5) - hash) ^ mono_metadata_type_hash (t1->data.type);\n\tcase MONO_TYPE_ARRAY:\n\t\treturn ((hash << 5) - hash) ^ mono_metadata_type_hash (&t1->data.array->eklass->byval_arg);\n\tcase MONO_TYPE_GENERICINST:\n\t\treturn ((hash << 5) - hash) ^ 0;\n\tdefault:\n\t\treturn hash;\n\t}\n}\n\n/*\n * mono_aot_method_hash:\n *\n *   Return a hash code for methods which only depends on metadata.\n */\nguint32\nmono_aot_method_hash (MonoMethod *method)\n{\n\tMonoMethodSignature *sig;\n\tMonoClass *klass;\n\tint i, hindex;\n\tint hashes_count;\n\tguint32 *hashes_start, *hashes;\n\tguint32 a, b, c;\n\tMonoGenericInst *class_ginst = NULL;\n\tMonoGenericInst *ginst = NULL;\n\n\t/* Similar to the hash in mono_method_get_imt_slot () */\n\n\tsig = mono_method_signature (method);\n\n\tif (mono_class_is_ginst (method->klass))\n\t\tclass_ginst = mono_class_get_generic_class (method->klass)->context.class_inst;\n\tif (method->is_inflated)\n\t\tginst = ((MonoMethodInflated*)method)->context.method_inst;\n\n\thashes_count = sig->param_count + 5 + (class_ginst ? class_ginst->type_argc : 0) + (ginst ? ginst->type_argc : 0);\n\thashes_start = (guint32 *)g_malloc0 (hashes_count * sizeof (guint32));\n\thashes = hashes_start;\n\n\t/* Some wrappers are assigned to random classes */\n\tif (!method->wrapper_type || method->wrapper_type == MONO_WRAPPER_REMOTING_INVOKE_WITH_CHECK)\n\t\tklass = method->klass;\n\telse\n\t\tklass = mono_defaults.object_class;\n\n\tif (!method->wrapper_type) {\n\t\tchar *full_name;\n\n\t\tif (mono_class_is_ginst (klass))\n\t\t\tfull_name = mono_type_full_name (&mono_class_get_generic_class (klass)->container_class->byval_arg);\n\t\telse\n\t\t\tfull_name = mono_type_full_name (&klass->byval_arg);\n\n\t\thashes [0] = mono_metadata_str_hash (full_name);\n\t\thashes [1] = 0;\n\t\tg_free (full_name);\n\t} else {\n\t\thashes [0] = mono_metadata_str_hash (klass->name);\n\t\thashes [1] = mono_metadata_str_hash (klass->name_space);\n\t}\n\tif (method->wrapper_type == MONO_WRAPPER_STFLD || method->wrapper_type == MONO_WRAPPER_LDFLD || method->wrapper_type == MONO_WRAPPER_LDFLDA)\n\t\t/* The method name includes a stringified pointer */\n\t\thashes [2] = 0;\n\telse\n\t\thashes [2] = mono_metadata_str_hash (method->name);\n\thashes [3] = method->wrapper_type;\n\thashes [4] = mono_aot_type_hash (sig->ret);\n\thindex = 5;\n\tfor (i = 0; i < sig->param_count; i++) {\n\t\thashes [hindex ++] = mono_aot_type_hash (sig->params [i]);\n\t}\n\tif (class_ginst) {\n\t\tfor (i = 0; i < class_ginst->type_argc; ++i)\n\t\t\thashes [hindex ++] = mono_aot_type_hash (class_ginst->type_argv [i]);\n\t}\n\tif (ginst) {\n\t\tfor (i = 0; i < ginst->type_argc; ++i)\n\t\t\thashes [hindex ++] = mono_aot_type_hash (ginst->type_argv [i]);\n\t}\t\t\n\tg_assert (hindex == hashes_count);\n\n\t/* Setup internal state */\n\ta = b = c = 0xdeadbeef + (((guint32)hashes_count)<<2);\n\n\t/* Handle most of the hashes */\n\twhile (hashes_count > 3) {\n\t\ta += hashes [0];\n\t\tb += hashes [1];\n\t\tc += hashes [2];\n\t\tmix (a,b,c);\n\t\thashes_count -= 3;\n\t\thashes += 3;\n\t}\n\n\t/* Handle the last 3 hashes (all the case statements fall through) */\n\tswitch (hashes_count) { \n\tcase 3 : c += hashes [2];\n\tcase 2 : b += hashes [1];\n\tcase 1 : a += hashes [0];\n\t\tfinal (a,b,c);\n\tcase 0: /* nothing left to add */\n\t\tbreak;\n\t}\n\t\n\tg_free (hashes_start);\n\t\n\treturn c;\n}\n#undef rot\n#undef mix\n#undef final\n\n/*\n * mono_aot_get_array_helper_from_wrapper;\n *\n * Get the helper method in Array called by an array wrapper method.\n */\nMonoMethod*\nmono_aot_get_array_helper_from_wrapper (MonoMethod *method)\n{\n\tMonoMethod *m;\n\tconst char *prefix;\n\tMonoGenericContext ctx;\n\tMonoType *args [16];\n\tchar *mname, *iname, *s, *s2, *helper_name = NULL;\n\n\tprefix = \"System.Collections.Generic\";\n\ts = g_strdup_printf (\"%s\", method->name + strlen (prefix) + 1);\n\ts2 = strstr (s, \"`1.\");\n\tg_assert (s2);\n\ts2 [0] = '\\0';\n\tiname = s;\n\tmname = s2 + 3;\n\n\t//printf (\"X: %s %s\\n\", iname, mname);\n\n\tif (!strcmp (iname, \"IList\"))\n\t\thelper_name = g_strdup_printf (\"InternalArray__%s\", mname);\n\telse\n\t\thelper_name = g_strdup_printf (\"InternalArray__%s_%s\", iname, mname);\n\tm = mono_class_get_method_from_name (mono_defaults.array_class, helper_name, mono_method_signature (method)->param_count);\n\tg_assert (m);\n\tg_free (helper_name);\n\tg_free (s);\n\n\tif (m->is_generic) {\n\t\tMonoError error;\n\t\tmemset (&ctx, 0, sizeof (ctx));\n\t\targs [0] = &method->klass->element_class->byval_arg;\n\t\tctx.method_inst = mono_metadata_get_generic_inst (1, args);\n\t\tm = mono_class_inflate_generic_method_checked (m, &ctx, &error);\n\t\tg_assert (mono_error_ok (&error)); /* FIXME don't swallow the error */\n\t}\n\n\treturn m;\n}\n\n#if !defined(DISABLE_AOT) && !defined(DISABLE_JIT)\n\ntypedef struct HashEntry {\n    guint32 key, value, index;\n\tstruct HashEntry *next;\n} HashEntry;\n\n/*\n * emit_extra_methods:\n *\n * Emit methods which are not in the METHOD table, like wrappers.\n */\nstatic void\nemit_extra_methods (MonoAotCompile *acfg)\n{\n\tint i, table_size, buf_size;\n\tguint8 *p, *buf;\n\tguint32 *info_offsets;\n\tguint32 hash;\n\tGPtrArray *table;\n\tHashEntry *entry, *new_entry;\n\tint nmethods, max_chain_length;\n\tint *chain_lengths;\n\n\tinfo_offsets = g_new0 (guint32, acfg->extra_methods->len);\n\n\t/* Emit method info */\n\tnmethods = 0;\n\tfor (i = 0; i < acfg->extra_methods->len; ++i) {\n\t\tMonoMethod *method = (MonoMethod *)g_ptr_array_index (acfg->extra_methods, i);\n\t\tMonoCompile *cfg = (MonoCompile *)g_hash_table_lookup (acfg->method_to_cfg, method);\n\n\t\tif (ignore_cfg (cfg))\n\t\t\tcontinue;\n\n\t\tbuf_size = 10240;\n\t\tp = buf = (guint8 *)g_malloc (buf_size);\n\n\t\tnmethods ++;\n\n\t\tmethod = cfg->method_to_register;\n\n\t\tencode_method_ref (acfg, method, p, &p);\n\n\t\tg_assert ((p - buf) < buf_size);\n\n\t\tinfo_offsets [i] = add_to_blob (acfg, buf, p - buf);\n\t\tg_free (buf);\n\t}\n\n\t/*\n\t * Construct a chained hash table for mapping indexes in extra_method_info to\n\t * method indexes.\n\t */\n\ttable_size = g_spaced_primes_closest ((int)(nmethods * 1.5));\n\ttable = g_ptr_array_sized_new (table_size);\n\tfor (i = 0; i < table_size; ++i)\n\t\tg_ptr_array_add (table, NULL);\n\tchain_lengths = g_new0 (int, table_size);\n\tmax_chain_length = 0;\n\tfor (i = 0; i < acfg->extra_methods->len; ++i) {\n\t\tMonoMethod *method = (MonoMethod *)g_ptr_array_index (acfg->extra_methods, i);\n\t\tMonoCompile *cfg = (MonoCompile *)g_hash_table_lookup (acfg->method_to_cfg, method);\n\t\tguint32 key, value;\n\n\t\tif (ignore_cfg (cfg))\n\t\t\tcontinue;\n\n\t\tkey = info_offsets [i];\n\t\tvalue = get_method_index (acfg, method);\n\n\t\thash = mono_aot_method_hash (method) % table_size;\n\t\t//printf (\"X: %s %x\\n\", mono_method_get_full_name (method), mono_aot_method_hash (method));\n\n\t\tchain_lengths [hash] ++;\n\t\tmax_chain_length = MAX (max_chain_length, chain_lengths [hash]);\n\n\t\tnew_entry = (HashEntry *)mono_mempool_alloc0 (acfg->mempool, sizeof (HashEntry));\n\t\tnew_entry->key = key;\n\t\tnew_entry->value = value;\n\n\t\tentry = (HashEntry *)g_ptr_array_index (table, hash);\n\t\tif (entry == NULL) {\n\t\t\tnew_entry->index = hash;\n\t\t\tg_ptr_array_index (table, hash) = new_entry;\n\t\t} else {\n\t\t\twhile (entry->next)\n\t\t\t\tentry = entry->next;\n\t\t\t\n\t\t\tentry->next = new_entry;\n\t\t\tnew_entry->index = table->len;\n\t\t\tg_ptr_array_add (table, new_entry);\n\t\t}\n\t}\n\tg_free (chain_lengths);\n\n\t//printf (\"MAX: %d\\n\", max_chain_length);\n\n\tbuf_size = table->len * 12 + 4;\n\tp = buf = (guint8 *)g_malloc (buf_size);\n\tencode_int (table_size, p, &p);\n\n\tfor (i = 0; i < table->len; ++i) {\n\t\tHashEntry *entry = (HashEntry *)g_ptr_array_index (table, i);\n\n\t\tif (entry == NULL) {\n\t\t\tencode_int (0, p, &p);\n\t\t\tencode_int (0, p, &p);\n\t\t\tencode_int (0, p, &p);\n\t\t} else {\n\t\t\t//g_assert (entry->key > 0);\n\t\t\tencode_int (entry->key, p, &p);\n\t\t\tencode_int (entry->value, p, &p);\n\t\t\tif (entry->next)\n\t\t\t\tencode_int (entry->next->index, p, &p);\n\t\t\telse\n\t\t\t\tencode_int (0, p, &p);\n\t\t}\n\t}\n\tg_assert (p - buf <= buf_size);\n\n\t/* Emit the table */\n\temit_aot_data (acfg, MONO_AOT_TABLE_EXTRA_METHOD_TABLE, \"extra_method_table\", buf, p - buf);\n\n\tg_free (buf);\n\n\t/* \n\t * Emit a table reverse mapping method indexes to their index in extra_method_info.\n\t * This is used by mono_aot_find_jit_info ().\n\t */\n\tbuf_size = acfg->extra_methods->len * 8 + 4;\n\tp = buf = (guint8 *)g_malloc (buf_size);\n\tencode_int (acfg->extra_methods->len, p, &p);\n\tfor (i = 0; i < acfg->extra_methods->len; ++i) {\n\t\tMonoMethod *method = (MonoMethod *)g_ptr_array_index (acfg->extra_methods, i);\n\n\t\tencode_int (get_method_index (acfg, method), p, &p);\n\t\tencode_int (info_offsets [i], p, &p);\n\t}\n\temit_aot_data (acfg, MONO_AOT_TABLE_EXTRA_METHOD_INFO_OFFSETS, \"extra_method_info_offsets\", buf, p - buf);\n\n\tg_free (buf);\n\tg_free (info_offsets);\n\tg_ptr_array_free (table, TRUE);\n}\t\n\nstatic void\ngenerate_aotid (guint8* aotid)\n{\n\tgpointer rand_handle;\n\tMonoError error;\n\n\tmono_rand_open ();\n\trand_handle = mono_rand_init (NULL, 0);\n\n\tmono_rand_try_get_bytes (&rand_handle, aotid, 16, &error);\n\tmono_error_assert_ok (&error);\n\n\tmono_rand_close (rand_handle);\n}\n\nstatic void\nemit_exception_info (MonoAotCompile *acfg)\n{\n\tint i;\n\tgint32 *offsets;\n\tSeqPointData sp_data;\n\tgboolean seq_points_to_file = FALSE;\n\n\toffsets = g_new0 (gint32, acfg->nmethods);\n\tfor (i = 0; i < acfg->nmethods; ++i) {\n\t\tif (acfg->cfgs [i]) {\n\t\t\tMonoCompile *cfg = acfg->cfgs [i];\n\n\t\t\t// By design aot-runtime decode_exception_debug_info is not able to load sequence point debug data from a file.\n\t\t\t// As it is not possible to load debug data from a file its is also not possible to store it in a file.\n\t\t\tgboolean method_seq_points_to_file = acfg->aot_opts.gen_msym_dir &&\n\t\t\t\tcfg->gen_seq_points && !cfg->gen_sdb_seq_points;\n\t\t\tgboolean method_seq_points_to_binary = cfg->gen_seq_points && !method_seq_points_to_file;\n\t\t\t\n\t\t\temit_exception_debug_info (acfg, cfg, method_seq_points_to_binary);\n\t\t\toffsets [i] = cfg->ex_info_offset;\n\n\t\t\tif (method_seq_points_to_file) {\n\t\t\t\tif (!seq_points_to_file) {\n\t\t\t\t\tmono_seq_point_data_init (&sp_data, acfg->nmethods);\n\t\t\t\t\tseq_points_to_file = TRUE;\n\t\t\t\t}\n\t\t\t\tmono_seq_point_data_add (&sp_data, cfg->method->token, cfg->method_index, cfg->seq_point_info);\n\t\t\t}\n\t\t} else {\n\t\t\toffsets [i] = 0;\n\t\t}\n\t}\n\n\tif (seq_points_to_file) {\n\t\tchar *aotid = mono_guid_to_string_minimal (acfg->image->aotid);\n\t\tchar *dir = g_build_filename (acfg->aot_opts.gen_msym_dir_path, aotid, NULL);\n\t\tchar *image_basename = g_path_get_basename (acfg->image->name);\n\t\tchar *aot_file = g_strdup_printf(\"%s%s\", image_basename, SEQ_POINT_AOT_EXT);\n\t\tchar *aot_file_path = g_build_filename (dir, aot_file, NULL);\n\n\t\tif (g_ensure_directory_exists (aot_file_path) == FALSE) {\n\t\t\tfprintf (stderr, \"AOT : failed to create msym directory: %s\\n\", aot_file_path);\n\t\t\texit (1);\n\t\t}\n\n\t\tmono_seq_point_data_write (&sp_data, aot_file_path);\n\t\tmono_seq_point_data_free (&sp_data);\n\n\t\tg_free (aotid);\n\t\tg_free (dir);\n\t\tg_free (image_basename);\n\t\tg_free (aot_file);\n\t\tg_free (aot_file_path);\n\t}\n\n\tacfg->stats.offsets_size += emit_offset_table (acfg, \"ex_info_offsets\", MONO_AOT_TABLE_EX_INFO_OFFSETS, acfg->nmethods, 10, offsets);\n\tg_free (offsets);\n}\n\nstatic void\nemit_unwind_info (MonoAotCompile *acfg)\n{\n\tint i;\n\tchar symbol [128];\n\n\tif (acfg->aot_opts.llvm_only) {\n\t\tg_assert (acfg->unwind_ops->len == 0);\n\t\treturn;\n\t}\n\n\t/* \n\t * The unwind info contains a lot of duplicates so we emit each unique\n\t * entry once, and only store the offset from the start of the table in the\n\t * exception info.\n\t */\n\n\tsprintf (symbol, \"unwind_info\");\n\temit_section_change (acfg, RODATA_SECT, 1);\n\temit_alignment (acfg, 8);\n\temit_info_symbol (acfg, symbol);\n\n\tfor (i = 0; i < acfg->unwind_ops->len; ++i) {\n\t\tguint32 index = GPOINTER_TO_UINT (g_ptr_array_index (acfg->unwind_ops, i));\n\t\tguint8 *unwind_info;\n\t\tguint32 unwind_info_len;\n\t\tguint8 buf [16];\n\t\tguint8 *p;\n\n\t\tunwind_info = mono_get_cached_unwind_info (index, &unwind_info_len);\n\n\t\tp = buf;\n\t\tencode_value (unwind_info_len, p, &p);\n\t\temit_bytes (acfg, buf, p - buf);\n\t\temit_bytes (acfg, unwind_info, unwind_info_len);\n\n\t\tacfg->stats.unwind_info_size += (p - buf) + unwind_info_len;\n\t}\n}\n\nstatic void\nemit_class_info (MonoAotCompile *acfg)\n{\n\tint i;\n\tgint32 *offsets;\n\n\toffsets = g_new0 (gint32, acfg->image->tables [MONO_TABLE_TYPEDEF].rows);\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_TYPEDEF].rows; ++i)\n\t\toffsets [i] = emit_klass_info (acfg, MONO_TOKEN_TYPE_DEF | (i + 1));\n\n\tacfg->stats.offsets_size += emit_offset_table (acfg, \"class_info_offsets\", MONO_AOT_TABLE_CLASS_INFO_OFFSETS, acfg->image->tables [MONO_TABLE_TYPEDEF].rows, 10, offsets);\n\tg_free (offsets);\n}\n\ntypedef struct ClassNameTableEntry {\n\tguint32 token, index;\n\tstruct ClassNameTableEntry *next;\n} ClassNameTableEntry;\n\nstatic void\nemit_class_name_table (MonoAotCompile *acfg)\n{\n\tint i, table_size, buf_size;\n\tguint32 token, hash;\n\tMonoClass *klass;\n\tGPtrArray *table;\n\tchar *full_name;\n\tguint8 *buf, *p;\n\tClassNameTableEntry *entry, *new_entry;\n\n\t/*\n\t * Construct a chained hash table for mapping class names to typedef tokens.\n\t */\n\ttable_size = g_spaced_primes_closest ((int)(acfg->image->tables [MONO_TABLE_TYPEDEF].rows * 1.5));\n\ttable = g_ptr_array_sized_new (table_size);\n\tfor (i = 0; i < table_size; ++i)\n\t\tg_ptr_array_add (table, NULL);\n\tfor (i = 0; i < acfg->image->tables [MONO_TABLE_TYPEDEF].rows; ++i) {\n\t\tMonoError error;\n\t\ttoken = MONO_TOKEN_TYPE_DEF | (i + 1);\n\t\tklass = mono_class_get_checked (acfg->image, token, &error);\n\t\tif (!klass) {\n\t\t\tmono_error_cleanup (&error);\n\t\t\tcontinue;\n\t\t}\n\t\tfull_name = mono_type_get_name_full (mono_class_get_type (klass), MONO_TYPE_NAME_FORMAT_FULL_NAME);\n\t\thash = mono_metadata_str_hash (full_name) % table_size;\n\t\tg_free (full_name);\n\n\t\t/* FIXME: Allocate from the mempool */\n\t\tnew_entry = g_new0 (ClassNameTableEntry, 1);\n\t\tnew_entry->token = token;\n\n\t\tentry = (ClassNameTableEntry *)g_ptr_array_index (table, hash);\n\t\tif (entry == NULL) {\n\t\t\tnew_entry->index = hash;\n\t\t\tg_ptr_array_index (table, hash) = new_entry;\n\t\t} else {\n\t\t\twhile (entry->next)\n\t\t\t\tentry = entry->next;\n\t\t\t\n\t\t\tentry->next = new_entry;\n\t\t\tnew_entry->index = table->len;\n\t\t\tg_ptr_array_add (table, new_entry);\n\t\t}\n\t}\n\n\t/* Emit the table */\n\tbuf_size = table->len * 4 + 4;\n\tp = buf = (guint8 *)g_malloc0 (buf_size);\n\n\t/* FIXME: Optimize memory usage */\n\tg_assert (table_size < 65000);\n\tencode_int16 (table_size, p, &p);\n\tg_assert (table->len < 65000);\n\tfor (i = 0; i < table->len; ++i) {\n\t\tClassNameTableEntry *entry = (ClassNameTableEntry *)g_ptr_array_index (table, i);\n\n\t\tif (entry == NULL) {\n\t\t\tencode_int16 (0, p, &p);\n\t\t\tencode_int16 (0, p, &p);\n\t\t} else {\n\t\t\tencode_int16 (mono_metadata_token_index (entry->token), p, &p);\n\t\t\tif (entry->next)\n\t\t\t\tencode_int16 (entry->next->index, p, &p);\n\t\t\telse\n\t\t\t\tencode_int16 (0, p, &p);\n\t\t}\n\t\tg_free (entry);\n\t}\n\tg_assert (p - buf <= buf_size);\n\tg_ptr_array_free (table, TRUE);\n\n\temit_aot_data (acfg, MONO_AOT_TABLE_CLASS_NAME, \"class_name_table\", buf, p - buf);\n\n\tg_free (buf);\n}\n\nstatic void\nemit_image_table (MonoAotCompile *acfg)\n{\n\tint i, buf_size;\n\tguint8 *buf, *p;\n\n\t/*\n\t * The image table is small but referenced in a lot of places.\n\t * So we emit it at once, and reference its elements by an index.\n\t */\n\tbuf_size = acfg->image_table->len * 28 + 4;\n\tfor (i = 0; i < acfg->image_table->len; i++) {\n\t\tMonoImage *image = (MonoImage*)g_ptr_array_index (acfg->image_table, i);\n\t\tMonoAssemblyName *aname = &image->assembly->aname;\n\n\t\tbuf_size += strlen (image->assembly_name) + strlen (image->guid) + (aname->culture ? strlen (aname->culture) : 1) + strlen ((char*)aname->public_key_token) + 4;\n\t}\n\n\tbuf = p = (guint8 *)g_malloc0 (buf_size);\n\tencode_int (acfg->image_table->len, p, &p);\n\tfor (i = 0; i < acfg->image_table->len; i++) {\n\t\tMonoImage *image = (MonoImage*)g_ptr_array_index (acfg->image_table, i);\n\t\tMonoAssemblyName *aname = &image->assembly->aname;\n\n\t\t/* FIXME: Support multi-module assemblies */\n\t\tg_assert (image->assembly->image == image);\n\n\t\tencode_string (image->assembly_name, p, &p);\n\t\tencode_string (image->guid, p, &p);\n\t\tencode_string (aname->culture ? aname->culture : \"\", p, &p);\n\t\tencode_string ((const char*)aname->public_key_token, p, &p);\n\n\t\twhile (GPOINTER_TO_UINT (p) % 8 != 0)\n\t\t\tp ++;\n\n\t\tencode_int (aname->flags, p, &p);\n\t\tencode_int (aname->major, p, &p);\n\t\tencode_int (aname->minor, p, &p);\n\t\tencode_int (aname->build, p, &p);\n\t\tencode_int (aname->revision, p, &p);\n\t}\n\tg_assert (p - buf <= buf_size);\n\n\temit_aot_data (acfg, MONO_AOT_TABLE_IMAGE_TABLE, \"image_table\", buf, p - buf);\n\n\tg_free (buf);\n}\n\nstatic void\nemit_weak_field_indexes (MonoAotCompile *acfg)\n{\n\tGHashTable *indexes;\n\tGHashTableIter iter;\n\tgpointer key, value;\n\tint buf_size;\n\tguint8 *buf, *p;\n\n\t/* Emit a table of weak field indexes, since computing these at runtime is expensive */\n\tmono_assembly_init_weak_fields (acfg->image);\n\tindexes = acfg->image->weak_field_indexes;\n\tg_assert (indexes);\n\n\tbuf_size = (g_hash_table_size (indexes) + 1) * 4;\n\tbuf = p = (guint8 *)g_malloc0 (buf_size);\n\n\tencode_int (g_hash_table_size (indexes), p, &p);\n\tg_hash_table_iter_init (&iter, indexes);\n\twhile (g_hash_table_iter_next (&iter, &key, &value)) {\n\t\tguint32 index = GPOINTER_TO_UINT (key);\n\t\tencode_int (index, p, &p);\n\t}\n\tg_assert (p - buf <= buf_size);\n\n\temit_aot_data (acfg, MONO_AOT_TABLE_WEAK_FIELD_INDEXES, \"weak_field_indexes\", buf, p - buf);\n\n\tg_free (buf);\n}\n\nstatic void\nemit_got_info (MonoAotCompile *acfg, gboolean llvm)\n{\n\tint i, first_plt_got_patch = 0, buf_size;\n\tguint8 *p, *buf;\n\tguint32 *got_info_offsets;\n\tGotInfo *info = llvm ? &acfg->llvm_got_info : &acfg->got_info;\n\n\t/* Add the patches needed by the PLT to the GOT */\n\tif (!llvm) {\n\t\tacfg->plt_got_offset_base = acfg->got_offset;\n\t\tfirst_plt_got_patch = info->got_patches->len;\n\t\tfor (i = 1; i < acfg->plt_offset; ++i) {\n\t\t\tMonoPltEntry *plt_entry = (MonoPltEntry *)g_hash_table_lookup (acfg->plt_offset_to_entry, GUINT_TO_POINTER (i));\n\n\t\t\tg_ptr_array_add (info->got_patches, plt_entry->ji);\n\n\t\t\tacfg->stats.got_slot_types [plt_entry->ji->type] ++;\n\t\t}\n\n\t\tacfg->got_offset += acfg->plt_offset;\n\t}\n\n\t/**\n\t * FIXME: \n\t * - optimize offsets table.\n\t * - reduce number of exported symbols.\n\t * - emit info for a klass only once.\n\t * - determine when a method uses a GOT slot which is guaranteed to be already \n\t *   initialized.\n\t * - clean up and document the code.\n\t * - use String.Empty in class libs.\n\t */\n\n\t/* Encode info required to decode shared GOT entries */\n\tbuf_size = info->got_patches->len * 128;\n\tp = buf = (guint8 *)mono_mempool_alloc (acfg->mempool, buf_size);\n\tgot_info_offsets = (guint32 *)mono_mempool_alloc (acfg->mempool, info->got_patches->len * sizeof (guint32));\n\tif (!llvm) {\n\t\tacfg->plt_got_info_offsets = (guint32 *)mono_mempool_alloc (acfg->mempool, acfg->plt_offset * sizeof (guint32));\n\t\t/* Unused */\n\t\tif (acfg->plt_offset)\n\t\t\tacfg->plt_got_info_offsets [0] = 0;\n\t}\n\tfor (i = 0; i < info->got_patches->len; ++i) {\n\t\tMonoJumpInfo *ji = (MonoJumpInfo *)g_ptr_array_index (info->got_patches, i);\n\t\tguint8 *p2;\n\n\t\tp = buf;\n\n\t\tencode_value (ji->type, p, &p);\n\t\tp2 = p;\n\t\tencode_patch (acfg, ji, p, &p);\n\t\tacfg->stats.got_slot_info_sizes [ji->type] += p - p2;\n\t\tg_assert (p - buf <= buf_size);\n\t\tgot_info_offsets [i] = add_to_blob (acfg, buf, p - buf);\n\n\t\tif (!llvm && i >= first_plt_got_patch)\n\t\t\tacfg->plt_got_info_offsets [i - first_plt_got_patch + 1] = got_info_offsets [i];\n\t\tacfg->stats.got_info_size += p - buf;\n\t}\n\n\t/* Emit got_info_offsets table */\n\n\t/* No need to emit offsets for the got plt entries, the plt embeds them directly */\n\tacfg->stats.offsets_size += emit_offset_table (acfg, llvm ? \"llvm_got_info_offsets\" : \"got_info_offsets\", llvm ? MONO_AOT_TABLE_LLVM_GOT_INFO_OFFSETS : MONO_AOT_TABLE_GOT_INFO_OFFSETS, llvm ? acfg->llvm_got_offset : first_plt_got_patch, 10, (gint32*)got_info_offsets);\n}\n\nstatic void\nemit_got (MonoAotCompile *acfg)\n{\n\tchar symbol [MAX_SYMBOL_SIZE];\n\n\tif (acfg->aot_opts.llvm_only)\n\t\treturn;\n\n\t/* Don't make GOT global so accesses to it don't need relocations */\n\tsprintf (symbol, \"%s\", acfg->got_symbol);\n\n#ifdef TARGET_MACH\n\temit_unset_mode (acfg);\n\tfprintf (acfg->fp, \".section __DATA, __bss\\n\");\n\temit_alignment (acfg, 8);\n\tif (acfg->llvm)\n\t\temit_info_symbol (acfg, \"jit_got\");\n\tfprintf (acfg->fp, \".lcomm %s, %d\\n\", acfg->got_symbol, (int)(acfg->got_offset * sizeof (gpointer)));\n#else\n\temit_section_change (acfg, \".bss\", 0);\n\temit_alignment (acfg, 8);\n\tif (acfg->aot_opts.write_symbols)\n\t\temit_local_symbol (acfg, symbol, \"got_end\", FALSE);\n\temit_label (acfg, symbol);\n\tif (acfg->llvm)\n\t\temit_info_symbol (acfg, \"jit_got\");\n\tif (acfg->got_offset > 0)\n\t\temit_zero_bytes (acfg, (int)(acfg->got_offset * sizeof (gpointer)));\n#endif\n\n\tsprintf (symbol, \"got_end\");\n\temit_label (acfg, symbol);\n}\n\ntypedef struct GlobalsTableEntry {\n\tguint32 value, index;\n\tstruct GlobalsTableEntry *next;\n} GlobalsTableEntry;\n\n#ifdef TARGET_WIN32_MSVC\n#define DLL_ENTRY_POINT \"DllMain\"\n\nstatic void\nemit_library_info (MonoAotCompile *acfg)\n{\n\t// Only include for shared libraries linked directly from generated object.\n\tif (link_shared_library (acfg)) {\n\t\tchar\t*name = NULL;\n\t\tchar\tsymbol [MAX_SYMBOL_SIZE];\n\n\t\t// Ask linker to export all global symbols.\n\t\temit_section_change (acfg, \".drectve\", 0);\n\t\tfor (guint i = 0; i < acfg->globals->len; ++i) {\n\t\t\tname = (char *)g_ptr_array_index (acfg->globals, i);\n\t\t\tg_assert (name != NULL);\n\t\t\tsprintf_s (symbol, MAX_SYMBOL_SIZE, \" /EXPORT:%s\", name);\n\t\t\temit_string (acfg, symbol);\n\t\t}\n\n\t\t// Emit DLLMain function, needed by MSVC linker for DLL's.\n\t\t// NOTE, DllMain should not go into exports above.\n\t\temit_section_change (acfg, \".text\", 0);\n\t\temit_global (acfg, DLL_ENTRY_POINT, TRUE);\n\t\temit_label (acfg, DLL_ENTRY_POINT);\n\n\t\t// Simple implementation of DLLMain, just returning TRUE.\n\t\t// For more information about DLLMain: https://msdn.microsoft.com/en-us/library/windows/desktop/ms682583(v=vs.85).aspx\n\t\tfprintf (acfg->fp, \"movl $1, %%eax\\n\");\n\t\tfprintf (acfg->fp, \"ret\\n\");\n\n\t\t// Inform linker about our dll entry function.\n\t\temit_section_change (acfg, \".drectve\", 0);\n\t\temit_string (acfg, \"/ENTRY:\" DLL_ENTRY_POINT);\n\t\treturn;\n\t}\n}\n\n#else\n\nstatic inline void\nemit_library_info (MonoAotCompile *acfg)\n{\n\treturn;\n}\n#endif\n\nstatic void\nemit_globals (MonoAotCompile *acfg)\n{\n\tint i, table_size;\n\tguint32 hash;\n\tGPtrArray *table;\n\tchar symbol [1024];\n\tGlobalsTableEntry *entry, *new_entry;\n\n\tif (!acfg->aot_opts.static_link)\n\t\treturn;\n\n\tif (acfg->aot_opts.llvm_only) {\n\t\tg_assert (acfg->globals->len == 0);\n\t\treturn;\n\t}\n\n\t/* \n\t * When static linking, we emit a table containing our globals.\n\t */\n\n\t/*\n\t * Construct a chained hash table for mapping global names to their index in\n\t * the globals table.\n\t */\n\ttable_size = g_spaced_primes_closest ((int)(acfg->globals->len * 1.5));\n\ttable = g_ptr_array_sized_new (table_size);\n\tfor (i = 0; i < table_size; ++i)\n\t\tg_ptr_array_add (table, NULL);\n\tfor (i = 0; i < acfg->globals->len; ++i) {\n\t\tchar *name = (char *)g_ptr_array_index (acfg->globals, i);\n\n\t\thash = mono_metadata_str_hash (name) % table_size;\n\n\t\t/* FIXME: Allocate from the mempool */\n\t\tnew_entry = g_new0 (GlobalsTableEntry, 1);\n\t\tnew_entry->value = i;\n\n\t\tentry = (GlobalsTableEntry *)g_ptr_array_index (table, hash);\n\t\tif (entry == NULL) {\n\t\t\tnew_entry->index = hash;\n\t\t\tg_ptr_array_index (table, hash) = new_entry;\n\t\t} else {\n\t\t\twhile (entry->next)\n\t\t\t\tentry = entry->next;\n\t\t\t\n\t\t\tentry->next = new_entry;\n\t\t\tnew_entry->index = table->len;\n\t\t\tg_ptr_array_add (table, new_entry);\n\t\t}\n\t}\n\n\t/* Emit the table */\n\tsprintf (symbol, \".Lglobals_hash\");\n\temit_section_change (acfg, RODATA_SECT, 0);\n\temit_alignment (acfg, 8);\n\temit_label (acfg, symbol);\n\n\t/* FIXME: Optimize memory usage */\n\tg_assert (table_size < 65000);\n\temit_int16 (acfg, table_size);\n\tfor (i = 0; i < table->len; ++i) {\n\t\tGlobalsTableEntry *entry = (GlobalsTableEntry *)g_ptr_array_index (table, i);\n\n\t\tif (entry == NULL) {\n\t\t\temit_int16 (acfg, 0);\n\t\t\temit_int16 (acfg, 0);\n\t\t} else {\n\t\t\temit_int16 (acfg, entry->value + 1);\n\t\t\tif (entry->next)\n\t\t\t\temit_int16 (acfg, entry->next->index);\n\t\t\telse\n\t\t\t\temit_int16 (acfg, 0);\n\t\t}\n\t}\n\n\t/* Emit the names */\n\tfor (i = 0; i < acfg->globals->len; ++i) {\n\t\tchar *name = (char *)g_ptr_array_index (acfg->globals, i);\n\n\t\tsprintf (symbol, \"name_%d\", i);\n\t\temit_section_change (acfg, RODATA_SECT, 1);\n#ifdef TARGET_MACH\n\t\temit_alignment (acfg, 4);\n#endif\n\t\temit_label (acfg, symbol);\n\t\temit_string (acfg, name);\n\t}\n\n\t/* Emit the globals table */\n\tsprintf (symbol, \"globals\");\n\temit_section_change (acfg, \".data\", 0);\n\t/* This is not a global, since it is accessed by the init function */\n\temit_alignment (acfg, 8);\n\temit_info_symbol (acfg, symbol);\n\n\tsprintf (symbol, \"%sglobals_hash\", acfg->temp_prefix);\n\temit_pointer (acfg, symbol);\n\n\tfor (i = 0; i < acfg->globals->len; ++i) {\n\t\tchar *name = (char *)g_ptr_array_index (acfg->globals, i);\n\n\t\tsprintf (symbol, \"name_%d\", i);\n\t\temit_pointer (acfg, symbol);\n\n\t\tg_assert (strlen (name) < sizeof (symbol));\n\t\tsprintf (symbol, \"%s\", name);\n\t\temit_pointer (acfg, symbol);\n\t}\n\t/* Null terminate the table */\n\temit_int32 (acfg, 0);\n\temit_int32 (acfg, 0);\n}\n\nstatic void\nemit_mem_end (MonoAotCompile *acfg)\n{\n\tchar symbol [128];\n\n\tif (acfg->aot_opts.llvm_only)\n\t\treturn;\n\n\tsprintf (symbol, \"mem_end\");\n\temit_section_change (acfg, \".text\", 1);\n\temit_alignment_code (acfg, 8);\n\temit_label (acfg, symbol);\n}\n\nstatic void\ninit_aot_file_info (MonoAotCompile *acfg, MonoAotFileInfo *info)\n{\n\tint i;\n\n\tinfo->version = MONO_AOT_FILE_VERSION;\n\tinfo->plt_got_offset_base = acfg->plt_got_offset_base;\n\tinfo->got_size = acfg->got_offset * sizeof (gpointer);\n\tinfo->plt_size = acfg->plt_offset;\n\tinfo->nmethods = acfg->nmethods;\n\tinfo->flags = acfg->flags;\n\tinfo->opts = acfg->opts;\n\tinfo->simd_opts = acfg->simd_opts;\n\tinfo->gc_name_index = acfg->gc_name_offset;\n\tinfo->datafile_size = acfg->datafile_offset;\n\tfor (i = 0; i < MONO_AOT_TABLE_NUM; ++i)\n\t\tinfo->table_offsets [i] = acfg->table_offsets [i];\n\tfor (i = 0; i < MONO_AOT_TRAMP_NUM; ++i)\n\t\tinfo->num_trampolines [i] = acfg->num_trampolines [i];\n\tfor (i = 0; i < MONO_AOT_TRAMP_NUM; ++i)\n\t\tinfo->trampoline_got_offset_base [i] = acfg->trampoline_got_offset_base [i];\n\tfor (i = 0; i < MONO_AOT_TRAMP_NUM; ++i)\n\t\tinfo->trampoline_size [i] = acfg->trampoline_size [i];\n\tinfo->num_rgctx_fetch_trampolines = acfg->aot_opts.nrgctx_fetch_trampolines;\n\n\tinfo->double_align = MONO_ABI_ALIGNOF (double);\n\tinfo->long_align = MONO_ABI_ALIGNOF (gint64);\n\tinfo->generic_tramp_num = MONO_TRAMPOLINE_NUM;\n\tinfo->tramp_page_size = acfg->tramp_page_size;\n\tinfo->nshared_got_entries = acfg->nshared_got_entries;\n\tfor (i = 0; i < MONO_AOT_TRAMP_NUM; ++i)\n\t\tinfo->tramp_page_code_offsets [i] = acfg->tramp_page_code_offsets [i];\n\n\tmemcpy(&info->aotid, acfg->image->aotid, 16);\n}\n\nstatic void\nemit_aot_file_info (MonoAotCompile *acfg, MonoAotFileInfo *info)\n{\n\tchar symbol [MAX_SYMBOL_SIZE];\n\tint i, sindex;\n\tconst char **symbols;\n\n\tsymbols = g_new0 (const char *, MONO_AOT_FILE_INFO_NUM_SYMBOLS);\n\tsindex = 0;\n\tsymbols [sindex ++] = acfg->got_symbol;\n\tif (acfg->llvm) {\n\t\tsymbols [sindex ++] = g_strdup_printf (\"%s%s\", acfg->user_symbol_prefix, acfg->llvm_got_symbol);\n\t\tsymbols [sindex ++] = acfg->llvm_eh_frame_symbol;\n\t} else {\n\t\tsymbols [sindex ++] = NULL;\n\t\tsymbols [sindex ++] = NULL;\n\t}\n\t/* llvm_get_method */\n\tsymbols [sindex ++] = NULL;\n\t/* llvm_get_unbox_tramp */\n\tsymbols [sindex ++] = NULL;\n\tif (!acfg->aot_opts.llvm_only) {\n\t\tsymbols [sindex ++] = \"jit_code_start\";\n\t\tsymbols [sindex ++] = \"jit_code_end\";\n\t\tsymbols [sindex ++] = \"method_addresses\";\n\t} else {\n\t\tsymbols [sindex ++] = NULL;\n\t\tsymbols [sindex ++] = NULL;\n\t\tsymbols [sindex ++] = NULL;\n\t}\n\n\tif (acfg->data_outfile) {\n\t\tfor (i = 0; i < MONO_AOT_TABLE_NUM; ++i)\n\t\t\tsymbols [sindex ++] = NULL;\n\t} else {\n\t\tsymbols [sindex ++] = \"blob\";\n\t\tsymbols [sindex ++] = \"class_name_table\";\n\t\tsymbols [sindex ++] = \"class_info_offsets\";\n\t\tsymbols [sindex ++] = \"method_info_offsets\";\n\t\tsymbols [sindex ++] = \"ex_info_offsets\";\n\t\tsymbols [sindex ++] = \"extra_method_info_offsets\";\n\t\tsymbols [sindex ++] = \"extra_method_table\";\n\t\tsymbols [sindex ++] = \"got_info_offsets\";\n\t\tif (acfg->llvm)\n\t\t\tsymbols [sindex ++] = \"llvm_got_info_offsets\";\n\t\telse\n\t\t\tsymbols [sindex ++] = NULL;\n\t\tsymbols [sindex ++] = \"image_table\";\n\t\tsymbols [sindex ++] = \"weak_field_indexes\";\n\t}\n\n\tsymbols [sindex ++] = \"mem_end\";\n\tsymbols [sindex ++] = \"assembly_guid\";\n\tsymbols [sindex ++] = \"runtime_version\";\n\tif (acfg->num_trampoline_got_entries) {\n\t\tsymbols [sindex ++] = \"specific_trampolines\";\n\t\tsymbols [sindex ++] = \"static_rgctx_trampolines\";\n\t\tsymbols [sindex ++] = \"imt_trampolines\";\n\t\tsymbols [sindex ++] = \"gsharedvt_arg_trampolines\";\n\t} else {\n\t\tsymbols [sindex ++] = NULL;\n\t\tsymbols [sindex ++] = NULL;\n\t\tsymbols [sindex ++] = NULL;\n\t\tsymbols [sindex ++] = NULL;\n\t}\n\tif (acfg->aot_opts.static_link) {\n\t\tsymbols [sindex ++] = \"globals\";\n\t} else {\n\t\tsymbols [sindex ++] = NULL;\n\t}\n\tsymbols [sindex ++] = \"assembly_name\";\n\tsymbols [sindex ++] = \"plt\";\n\tsymbols [sindex ++] = \"plt_end\";\n\tsymbols [sindex ++] = \"unwind_info\";\n\tif (!acfg->aot_opts.llvm_only) {\n\t\tsymbols [sindex ++] = \"unbox_trampolines\";\n\t\tsymbols [sindex ++] = \"unbox_trampolines_end\";\n\t\tsymbols [sindex ++] = \"unbox_trampoline_addresses\";\n\t} else {\n\t\tsymbols [sindex ++] = NULL;\n\t\tsymbols [sindex ++] = NULL;\n\t\tsymbols [sindex ++] = NULL;\n\t}\n\n\tg_assert (sindex == MONO_AOT_FILE_INFO_NUM_SYMBOLS);\n\n\tsprintf (symbol, \"%smono_aot_file_info\", acfg->user_symbol_prefix);\n\temit_section_change (acfg, \".data\", 0);\n\temit_alignment (acfg, 8);\n\temit_label (acfg, symbol);\n\tif (!acfg->aot_opts.static_link)\n\t\temit_global (acfg, symbol, FALSE);\n\n\t/* The data emitted here must match MonoAotFileInfo. */\n\n\temit_int32 (acfg, info->version);\n\temit_int32 (acfg, info->dummy);\n\n\t/* \n\t * We emit pointers to our data structures instead of emitting global symbols which\n\t * point to them, to reduce the number of globals, and because using globals leads to\n\t * various problems (i.e. arm/thumb).\n\t */\n\tfor (i = 0; i < MONO_AOT_FILE_INFO_NUM_SYMBOLS; ++i)\n\t\temit_pointer (acfg, symbols [i]);\n\n\temit_int32 (acfg, info->plt_got_offset_base);\n\temit_int32 (acfg, info->got_size);\n\temit_int32 (acfg, info->plt_size);\n\temit_int32 (acfg, info->nmethods);\n\temit_int32 (acfg, info->flags);\n\temit_int32 (acfg, info->opts);\n\temit_int32 (acfg, info->simd_opts);\n\temit_int32 (acfg, info->gc_name_index);\n\temit_int32 (acfg, info->num_rgctx_fetch_trampolines);\n\temit_int32 (acfg, info->double_align);\n\temit_int32 (acfg, info->long_align);\n\temit_int32 (acfg, info->generic_tramp_num);\n\temit_int32 (acfg, info->tramp_page_size);\n\temit_int32 (acfg, info->nshared_got_entries);\n\temit_int32 (acfg, info->datafile_size);\n\n\tfor (i = 0; i < MONO_AOT_TABLE_NUM; ++i)\n\t\temit_int32 (acfg, info->table_offsets [i]);\n\tfor (i = 0; i < MONO_AOT_TRAMP_NUM; ++i)\n\t\temit_int32 (acfg, info->num_trampolines [i]);\n\tfor (i = 0; i < MONO_AOT_TRAMP_NUM; ++i)\n\t\temit_int32 (acfg, info->trampoline_got_offset_base [i]);\n\tfor (i = 0; i < MONO_AOT_TRAMP_NUM; ++i)\n\t\temit_int32 (acfg, info->trampoline_size [i]);\n\tfor (i = 0; i < MONO_AOT_TRAMP_NUM; ++i)\n\t\temit_int32 (acfg, info->tramp_page_code_offsets [i]);\n\n\temit_bytes (acfg, info->aotid, 16);\n\n\tif (acfg->aot_opts.static_link) {\n\t\temit_global_inner (acfg, acfg->static_linking_symbol, FALSE);\n\t\temit_alignment (acfg, sizeof (gpointer));\n\t\temit_label (acfg, acfg->static_linking_symbol);\n\t\temit_pointer_2 (acfg, acfg->user_symbol_prefix, \"mono_aot_file_info\");\n\t}\n}\n\n/*\n * Emit a structure containing all the information not stored elsewhere.\n */\nstatic void\nemit_file_info (MonoAotCompile *acfg)\n{\n\tchar *build_info;\n\tMonoAotFileInfo *info;\n\n\tif (acfg->aot_opts.bind_to_runtime_version) {\n\t\tbuild_info = mono_get_runtime_build_info ();\n\t\temit_string_symbol (acfg, \"runtime_version\", build_info);\n\t\tg_free (build_info);\n\t} else {\n\t\temit_string_symbol (acfg, \"runtime_version\", \"\");\n\t}\n\n\temit_string_symbol (acfg, \"assembly_guid\" , acfg->image->guid);\n\n\t/* Emit a string holding the assembly name */\n\temit_string_symbol (acfg, \"assembly_name\", acfg->image->assembly->aname.name);\n\n\tinfo = g_new0 (MonoAotFileInfo, 1);\n\tinit_aot_file_info (acfg, info);\n\n\tif (acfg->aot_opts.static_link) {\n\t\tchar symbol [MAX_SYMBOL_SIZE];\n\t\tchar *p;\n\n\t\t/*\n\t\t * Emit a global symbol which can be passed by an embedding app to\n\t\t * mono_aot_register_module (). The symbol points to a pointer to the the file info\n\t\t * structure.\n\t\t */\n\t\tsprintf (symbol, \"%smono_aot_module_%s_info\", acfg->user_symbol_prefix, acfg->image->assembly->aname.name);\n\n\t\t/* Get rid of characters which cannot occur in symbols */\n\t\tp = symbol;\n\t\tfor (p = symbol; *p; ++p) {\n\t\t\tif (!(isalnum (*p) || *p == '_'))\n\t\t\t\t*p = '_';\n\t\t}\n\t\tacfg->static_linking_symbol = g_strdup (symbol);\n\t}\n\n\tif (acfg->llvm)\n\t\tmono_llvm_emit_aot_file_info (info, acfg->has_jitted_code);\n\telse\n\t\temit_aot_file_info (acfg, info);\n}\n\nstatic void\nemit_blob (MonoAotCompile *acfg)\n{\n\tacfg->blob_closed = TRUE;\n\n\temit_aot_data (acfg, MONO_AOT_TABLE_BLOB, \"blob\", (guint8*)acfg->blob.data, acfg->blob.index);\n}\n\nstatic void\nemit_objc_selectors (MonoAotCompile *acfg)\n{\n\tint i;\n\tchar symbol [128];\n\n\tif (!acfg->objc_selectors || acfg->objc_selectors->len == 0)\n\t\treturn;\n\n\t/*\n\t * From\n\t * cat > foo.m << EOF\n\t * void *ret ()\n\t * {\n\t * return @selector(print:);\n\t * }\n\t * EOF\n\t */\n\n\tmono_img_writer_emit_unset_mode (acfg->w);\n\tg_assert (acfg->fp);\n\tfprintf (acfg->fp, \".section\t__DATA,__objc_selrefs,literal_pointers,no_dead_strip\\n\");\n\tfprintf (acfg->fp, \".align\t3\\n\");\n\tfor (i = 0; i < acfg->objc_selectors->len; ++i) {\n\t\tsprintf (symbol, \"L_OBJC_SELECTOR_REFERENCES_%d\", i);\n\t\temit_label (acfg, symbol);\n\t\tsprintf (symbol, \"L_OBJC_METH_VAR_NAME_%d\", i);\n\t\temit_pointer (acfg, symbol);\n\n\t}\n\tfprintf (acfg->fp, \".section\t__TEXT,__cstring,cstring_literals\\n\");\n\tfor (i = 0; i < acfg->objc_selectors->len; ++i) {\n\t\tfprintf (acfg->fp, \"L_OBJC_METH_VAR_NAME_%d:\\n\", i);\n\t\tfprintf (acfg->fp, \".asciz \\\"%s\\\"\\n\", (char*)g_ptr_array_index (acfg->objc_selectors, i));\n\t}\n\n\tfprintf (acfg->fp, \".section\t__DATA,__objc_imageinfo,regular,no_dead_strip\\n\");\n\tfprintf (acfg->fp, \".align\t3\\n\");\n\tfprintf (acfg->fp, \"L_OBJC_IMAGE_INFO:\\n\");\n\tfprintf (acfg->fp, \".long\t0\\n\");\n\tfprintf (acfg->fp, \".long\t16\\n\");\n}\n\nstatic void\nemit_dwarf_info (MonoAotCompile *acfg)\n{\n#ifdef EMIT_DWARF_INFO\n\tint i;\n\tchar symbol2 [128];\n\n\t/* DIEs for methods */\n\tfor (i = 0; i < acfg->nmethods; ++i) {\n\t\tMonoCompile *cfg = acfg->cfgs [i];\n\n\t\tif (ignore_cfg (cfg))\n\t\t\tcontinue;\n\n\t\t// FIXME: LLVM doesn't define .Lme_...\n\t\tif (cfg->compile_llvm)\n\t\t\tcontinue;\n\n\t\tsprintf (symbol2, \"%sme_%x\", acfg->temp_prefix, i);\n\n\t\tmono_dwarf_writer_emit_method (acfg->dwarf, cfg, cfg->method, cfg->asm_symbol, symbol2, cfg->asm_debug_symbol, (guint8 *)cfg->jit_info->code_start, cfg->jit_info->code_size, cfg->args, cfg->locals, cfg->unwind_ops, mono_debug_find_method (cfg->jit_info->d.method, mono_domain_get ()));\n\t}\n#endif\n}\n\n#ifdef EMIT_WIN32_CODEVIEW_INFO\ntypedef struct _CodeViewSubSectionData\n{\n\tgchar *start_section;\n\tgchar *end_section;\n\tgchar *start_section_record;\n\tgchar *end_section_record;\n\tint section_type;\n\tint section_record_type;\n\tint section_id;\n} CodeViewSubsectionData;\n\ntypedef struct _CodeViewCompilerVersion\n{\n\tgint major;\n\tgint minor;\n\tgint revision;\n\tgint patch;\n} CodeViewCompilerVersion;\n\n#define CODEVIEW_SUBSECTION_SYMBOL_TYPE 0xF1\n#define CODEVIEW_SUBSECTION_RECORD_COMPILER_TYPE 0x113c\n#define CODEVIEW_SUBSECTION_RECORD_FUNCTION_START_TYPE 0x1147\n#define CODEVIEW_SUBSECTION_RECORD_FUNCTION_END_TYPE 0x114F\n#define CODEVIEW_CSHARP_LANGUAGE_TYPE 0x0A\n#define CODEVIEW_CPU_TYPE 0x0\n#define CODEVIEW_MAGIC_HEADER 0x4\n\nstatic void\ncodeview_clear_subsection_data (CodeViewSubsectionData *section_data)\n{\n\tg_free (section_data->start_section);\n\tg_free (section_data->end_section);\n\tg_free (section_data->start_section_record);\n\tg_free (section_data->end_section_record);\n\n\tmemset (section_data, 0, sizeof (CodeViewSubsectionData));\n}\n\nstatic void\ncodeview_parse_compiler_version (gchar *version, CodeViewCompilerVersion *data)\n{\n\tgint values[4] = { 0 };\n\tgint *value = values;\n\n\twhile (*version && (value < values + G_N_ELEMENTS (values))) {\n\t\tif (isdigit (*version)) {\n\t\t\t*value *= 10;\n\t\t\t*value += *version - '0';\n\t\t}\n\t\telse if (*version == '.') {\n\t\t\tvalue++;\n\t\t}\n\n\t\tversion++;\n\t}\n\n\tdata->major = values[0];\n\tdata->minor = values[1];\n\tdata->revision = values[2];\n\tdata->patch = values[3];\n}\n\nstatic void\nemit_codeview_start_subsection (MonoAotCompile *acfg, int section_id, int section_type, int section_record_type, CodeViewSubsectionData *section_data)\n{\n\t// Starting a new subsection, clear old data.\n\tcodeview_clear_subsection_data (section_data);\n\n\t// Keep subsection data.\n\tsection_data->section_id = section_id;\n\tsection_data->section_type = section_type;\n\tsection_data->section_record_type = section_record_type;\n\n\t// Allocate all labels used in subsection.\n\tsection_data->start_section = g_strdup_printf (\"%scvs_%d\", acfg->temp_prefix, section_data->section_id);\n\tsection_data->end_section = g_strdup_printf (\"%scvse_%d\", acfg->temp_prefix, section_data->section_id);\n\tsection_data->start_section_record = g_strdup_printf (\"%scvsr_%d\", acfg->temp_prefix, section_data->section_id);\n\tsection_data->end_section_record = g_strdup_printf (\"%scvsre_%d\", acfg->temp_prefix, section_data->section_id);\n\n\t// Subsection type, function symbol.\n\temit_int32 (acfg, section_data->section_type);\n\n\t// Subsection size.\n\temit_symbol_diff (acfg, section_data->end_section, section_data->start_section, 0);\n\temit_label (acfg, section_data->start_section);\n\n\t// Subsection record size.\n\tfprintf (acfg->fp, \"\\t.word %s - %s\\n\", section_data->end_section_record, section_data->start_section_record);\n\temit_label (acfg, section_data->start_section_record);\n\n\t// Subsection record type.\n\temit_int16 (acfg, section_record_type);\n}\n\nstatic void\nemit_codeview_end_subsection (MonoAotCompile *acfg, CodeViewSubsectionData *section_data, int *section_id)\n{\n\tg_assert (section_data->start_section);\n\tg_assert (section_data->end_section);\n\tg_assert (section_data->start_section_record);\n\tg_assert (section_data->end_section_record);\n\n\temit_label (acfg, section_data->end_section_record);\n\n\tif (section_data->section_record_type == CODEVIEW_SUBSECTION_RECORD_FUNCTION_START_TYPE) {\n\t\t// Emit record length.\n\t\temit_int16 (acfg, 2);\n\n\t\t// Emit specific record type end.\n\t\temit_int16 (acfg, CODEVIEW_SUBSECTION_RECORD_FUNCTION_END_TYPE);\n\t}\n\n\temit_label (acfg, section_data->end_section);\n\n\t// Next subsection needs to be 4 byte aligned.\n\temit_alignment (acfg, 4);\n\n\t*section_id = section_data->section_id + 1;\n\tcodeview_clear_subsection_data (section_data);\n}\n\ninline static void\nemit_codeview_start_symbol_subsection (MonoAotCompile *acfg, int section_id, int section_record_type, CodeViewSubsectionData *section_data)\n{\n\temit_codeview_start_subsection (acfg, section_id, CODEVIEW_SUBSECTION_SYMBOL_TYPE, section_record_type, section_data);\n}\n\ninline static void\nemit_codeview_end_symbol_subsection (MonoAotCompile *acfg, CodeViewSubsectionData *section_data, int *section_id)\n{\n\temit_codeview_end_subsection (acfg, section_data, section_id);\n}\n\nstatic void\nemit_codeview_compiler_info (MonoAotCompile *acfg, int *section_id)\n{\n\tCodeViewSubsectionData section_data = { 0 };\n\tCodeViewCompilerVersion compiler_version = { 0 };\n\n\t// Start new compiler record subsection.\n\temit_codeview_start_symbol_subsection (acfg, *section_id, CODEVIEW_SUBSECTION_RECORD_COMPILER_TYPE, &section_data);\n\n\temit_int32 (acfg, CODEVIEW_CSHARP_LANGUAGE_TYPE);\n\temit_int16 (acfg, CODEVIEW_CPU_TYPE);\n\n\t// Get compiler version information.\n\tcodeview_parse_compiler_version (VERSION, &compiler_version);\n\n\t// Compiler frontend version, 4 digits.\n\temit_int16 (acfg, compiler_version.major);\n\temit_int16 (acfg, compiler_version.minor);\n\temit_int16 (acfg, compiler_version.revision);\n\temit_int16 (acfg, compiler_version.patch);\n\n\t// Compiler backend version, 4 digits (currently same as frontend).\n\temit_int16 (acfg, compiler_version.major);\n\temit_int16 (acfg, compiler_version.minor);\n\temit_int16 (acfg, compiler_version.revision);\n\temit_int16 (acfg, compiler_version.patch);\n\n\t// Compiler string.\n\temit_string (acfg, \"Mono AOT compiler\");\n\n\t// Done with section.\n\temit_codeview_end_symbol_subsection (acfg, &section_data, section_id);\n}\n\nstatic void\nemit_codeview_function_info (MonoAotCompile *acfg, MonoMethod *method, int *section_id, gchar *symbol, gchar *symbol_start, gchar *symbol_end)\n{\n\tCodeViewSubsectionData section_data = { 0 };\n\tgchar *full_method_name = NULL;\n\n\t// Start new function record subsection.\n\temit_codeview_start_symbol_subsection (acfg, *section_id, CODEVIEW_SUBSECTION_RECORD_FUNCTION_START_TYPE, &section_data);\n\n\t// Emit 3 int 0 byte padding, currently not used.\n\temit_zero_bytes (acfg, sizeof (int) * 3);\n\n\t// Emit size of function.\n\temit_symbol_diff (acfg, symbol_end, symbol_start, 0);\n\n\t// Emit 3 int 0 byte padding, currently not used.\n\temit_zero_bytes (acfg, sizeof (int) * 3);\n\n\t// Emit reallocation info.\n\tfprintf (acfg->fp, \"\\t.secrel32 %s\\n\", symbol);\n\tfprintf (acfg->fp, \"\\t.secidx %s\\n\", symbol);\n\n\t// Emit flag, currently not used.\n\temit_zero_bytes (acfg, 1);\n\n\t// Emit function name, exclude signature since it should be described by own metadata.\n\tfull_method_name = mono_method_full_name (method, FALSE);\n\temit_string (acfg, full_method_name ? full_method_name : \"\");\n\tg_free (full_method_name);\n\n\t// Done with section.\n\temit_codeview_end_symbol_subsection (acfg, &section_data, section_id);\n}\n\nstatic void\nemit_codeview_info (MonoAotCompile *acfg)\n{\n\tint i;\n\tint section_id = 0;\n\tgchar symbol_buffer[MAX_SYMBOL_SIZE];\n\n\t// Emit codeview debug info section\n\temit_section_change (acfg, \".debug$S\", 0);\n\n\t// Emit magic header.\n\temit_int32 (acfg, CODEVIEW_MAGIC_HEADER);\n\n\temit_codeview_compiler_info (acfg, &section_id);\n\n\tfor (i = 0; i < acfg->nmethods; ++i) {\n\t\tMonoCompile *cfg = acfg->cfgs[i];\n\n\t\tif (!cfg)\n\t\t\tcontinue;\n\n\t\tint ret = g_snprintf (symbol_buffer, G_N_ELEMENTS (symbol_buffer), \"%sme_%x\", acfg->temp_prefix, i);\n\t\tif (ret > 0 && ret < G_N_ELEMENTS (symbol_buffer))\n\t\t\temit_codeview_function_info (acfg, cfg->method, &section_id, cfg->asm_debug_symbol, cfg->asm_symbol, symbol_buffer);\n\t}\n}\n#else\nstatic void\nemit_codeview_info (MonoAotCompile *acfg)\n{\n}\n#endif /* EMIT_WIN32_CODEVIEW_INFO */\n\n#ifdef EMIT_WIN32_UNWIND_INFO\nstatic UnwindInfoSectionCacheItem *\nget_cached_unwind_info_section_item_win32 (MonoAotCompile *acfg, const char *function_start, const char *function_end, GSList *unwind_ops)\n{\n\tUnwindInfoSectionCacheItem *item = NULL;\n\n\tif (!acfg->unwind_info_section_cache)\n\t\tacfg->unwind_info_section_cache = g_list_alloc ();\n\n\tPUNWIND_INFO unwind_info = mono_arch_unwindinfo_alloc_unwind_info (unwind_ops);\n\n\t// Search for unwind info in cache.\n\tGList *list = acfg->unwind_info_section_cache;\n\tint list_size = 0;\n\twhile (list && list->data) {\n\t\titem = (UnwindInfoSectionCacheItem*)list->data;\n\t\tif (!memcmp (unwind_info, item->unwind_info, sizeof (UNWIND_INFO))) {\n\t\t\t// Cache hit, return cached item.\n\t\t\treturn item;\n\t\t}\n\t\tlist = list->next;\n\t\tlist_size++;\n\t}\n\n\t// Add to cache.\n\tif (acfg->unwind_info_section_cache) {\n\t\titem = g_new0 (UnwindInfoSectionCacheItem, 1);\n\t\tif (item) {\n\t\t\t// Format .xdata section label for function, used to get unwind info address RVA.\n\t\t\t// Since the unwind info is similar for most functions, the symbol will be reused.\n\t\t\titem->xdata_section_label = g_strdup_printf (\"%sunwind_%d\", acfg->temp_prefix, list_size);\n\n\t\t\t// Cache unwind info data, used when checking cache for matching unwind info. NOTE, cache takes\n\t\t\t//over ownership of unwind info.\n\t\t\titem->unwind_info = unwind_info;\n\n\t\t\t// Needs to be emitted once.\n\t\t\titem->xdata_section_emitted = FALSE;\n\n\t\t\t// Prepend to beginning of list to speed up inserts.\n\t\t\tacfg->unwind_info_section_cache = g_list_prepend (acfg->unwind_info_section_cache, (gpointer)item);\n\t\t}\n\t}\n\n\treturn item;\n}\n\nstatic void\nfree_unwind_info_section_cache_win32 (MonoAotCompile *acfg)\n{\n\tGList *list = acfg->unwind_info_section_cache;\n\n\twhile (list) {\n\t\tUnwindInfoSectionCacheItem *item = (UnwindInfoSectionCacheItem *)list->data;\n\t\tif (item) {\n\t\t\tg_free (item->xdata_section_label);\n\t\t\tmono_arch_unwindinfo_free_unwind_info (item->unwind_info);\n\n\t\t\tg_free (item);\n\t\t\tlist->data = NULL;\n\t\t}\n\n\t\tlist = list->next;\n\t}\n\n\tg_list_free (acfg->unwind_info_section_cache);\n\tacfg->unwind_info_section_cache = NULL;\n}\n\nstatic void\nemit_unwind_info_data_win32 (MonoAotCompile *acfg, PUNWIND_INFO unwind_info)\n{\n\t// Emit the unwind info struct.\n\temit_bytes (acfg, (guint8*)unwind_info, sizeof (UNWIND_INFO) - (sizeof (UNWIND_CODE) * MONO_MAX_UNWIND_CODES));\n\n\t// Emit all unwind codes encoded in unwind info struct.\n\tPUNWIND_CODE current_unwind_node = &unwind_info->UnwindCode[MONO_MAX_UNWIND_CODES - unwind_info->CountOfCodes];\n\tPUNWIND_CODE last_unwind_node = &unwind_info->UnwindCode[MONO_MAX_UNWIND_CODES];\n\n\twhile (current_unwind_node < last_unwind_node) {\n\t\tguint8 node_count = 0;\n\t\tswitch (current_unwind_node->UnwindOp) {\n\t\tcase UWOP_PUSH_NONVOL:\n\t\tcase UWOP_ALLOC_SMALL:\n\t\tcase UWOP_SET_FPREG:\n\t\tcase UWOP_PUSH_MACHFRAME:\n\t\t\tnode_count = 1;\n\t\t\tbreak;\n\t\tcase UWOP_SAVE_NONVOL:\n\t\tcase UWOP_SAVE_XMM128:\n\t\t\tnode_count = 2;\n\t\t\tbreak;\n\t\tcase UWOP_SAVE_NONVOL_FAR:\n\t\tcase UWOP_SAVE_XMM128_FAR:\n\t\t\tnode_count = 3;\n\t\t\tbreak;\n\t\tcase UWOP_ALLOC_LARGE:\n\t\t\tif (current_unwind_node->OpInfo == 0)\n\t\t\t\tnode_count = 2;\n\t\t\telse\n\t\t\t\tnode_count = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert (!\"Unknown unwind opcode.\");\n\t\t}\n\n\t\twhile (node_count > 0) {\n\t\t\tg_assert (current_unwind_node < last_unwind_node);\n\n\t\t\t//Emit current node.\n\t\t\temit_bytes (acfg, (guint8*)current_unwind_node, sizeof (UNWIND_CODE));\n\n\t\t\tnode_count--;\n\t\t\tcurrent_unwind_node++;\n\t\t}\n\t}\n}\n\n// Emit unwind info sections for each function. Unwind info on Windows x64 is emitted into two different sections.\n// .pdata includes the serialized DWORD aligned RVA's of function start, end and address of serialized\n// UNWIND_INFO struct emitted into .xdata, see https://msdn.microsoft.com/en-us/library/ft9x1kdx.aspx.\n// .xdata section includes DWORD aligned serialized version of UNWIND_INFO struct, https://msdn.microsoft.com/en-us/library/ddssxxy8.aspx.\nstatic void\nemit_unwind_info_sections_win32 (MonoAotCompile *acfg, const char *function_start, const char *function_end, GSList *unwind_ops)\n{\n\tchar *pdata_section_label = NULL;\n\n\tint temp_prefix_len = (acfg->temp_prefix != NULL) ? strlen (acfg->temp_prefix) : 0;\n\tif (strncmp (function_start, acfg->temp_prefix, temp_prefix_len)) {\n\t\ttemp_prefix_len = 0;\n\t}\n\n\t// Format .pdata section label for function.\n\tpdata_section_label = g_strdup_printf (\"%spdata_%s\", acfg->temp_prefix, function_start + temp_prefix_len);\n\n\tUnwindInfoSectionCacheItem *cache_item = get_cached_unwind_info_section_item_win32 (acfg, function_start, function_end, unwind_ops);\n\tg_assert (cache_item && cache_item->xdata_section_label && cache_item->unwind_info);\n\n\t// Emit .pdata section.\n\temit_section_change (acfg, \".pdata\", 0);\n\temit_alignment (acfg, sizeof (DWORD));\n\temit_label (acfg, pdata_section_label);\n\n\t// Emit function start address RVA.\n\tfprintf (acfg->fp, \"\\t.long %s@IMGREL\\n\", function_start);\n\n\t// Emit function end address RVA.\n\tfprintf (acfg->fp, \"\\t.long %s@IMGREL\\n\", function_end);\n\n\t// Emit unwind info address RVA.\n\tfprintf (acfg->fp, \"\\t.long %s@IMGREL\\n\", cache_item->xdata_section_label);\n\n\tif (!cache_item->xdata_section_emitted) {\n\t\t// Emit .xdata section.\n\t\temit_section_change (acfg, \".xdata\", 0);\n\t\temit_alignment (acfg, sizeof (DWORD));\n\t\temit_label (acfg, cache_item->xdata_section_label);\n\n\t\t// Emit unwind info into .xdata section.\n\t\temit_unwind_info_data_win32 (acfg, cache_item->unwind_info);\n\t\tcache_item->xdata_section_emitted = TRUE;\n\t}\n\n\tg_free (pdata_section_label);\n}\n#endif\n\nstatic gboolean\ncollect_methods (MonoAotCompile *acfg)\n{\n\tint mindex, i;\n\tMonoImage *image = acfg->image;\n\n\t/* Collect methods */\n\tfor (i = 0; i < image->tables [MONO_TABLE_METHOD].rows; ++i) {\n\t\tMonoError error;\n\t\tMonoMethod *method;\n\t\tguint32 token = MONO_TOKEN_METHOD_DEF | (i + 1);\n\n\t\tmethod = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);\n\n\t\tif (!method) {\n\t\t\taot_printerrf (acfg, \"Failed to load method 0x%x from '%s' due to %s.\\n\", token, image->name, mono_error_get_message (&error));\n\t\t\taot_printerrf (acfg, \"Run with MONO_LOG_LEVEL=debug for more information.\\n\");\n\t\t\tmono_error_cleanup (&error);\n\t\t\treturn FALSE;\n\t\t}\n\t\t\t\n\t\t/* Load all methods eagerly to skip the slower lazy loading code */\n\t\tmono_class_setup_methods (method->klass);\n\n\t\tif (mono_aot_mode_is_full (&acfg->aot_opts) && method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\t\t/* Compile the wrapper instead */\n\t\t\t/* We do this here instead of add_wrappers () because it is easy to do it here */\n\t\t\tMonoMethod *wrapper = mono_marshal_get_native_wrapper (method, TRUE, TRUE);\n\t\t\tmethod = wrapper;\n\t\t}\n\n\t\t/* FIXME: Some mscorlib methods don't have debug info */\n\t\t/*\n\t\tif (acfg->aot_opts.soft_debug && !method->wrapper_type) {\n\t\t\tif (!((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t\t\t  (method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) ||\n\t\t\t\t  (method->flags & METHOD_ATTRIBUTE_ABSTRACT) ||\n\t\t\t\t  (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL))) {\n\t\t\t\tif (!mono_debug_lookup_method (method)) {\n\t\t\t\t\tfprintf (stderr, \"Method %s has no debug info, probably the .mdb file for the assembly is missing.\\n\", mono_method_get_full_name (method));\n\t\t\t\t\texit (1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\n\t\tif (method->is_generic || mono_class_is_gtd (method->klass))\n\t\t\t/* Compile the ref shared version instead */\n\t\t\tmethod = mini_get_shared_method (method);\n\n\t\t/* Since we add the normal methods first, their index will be equal to their zero based token index */\n\t\tadd_method_with_index (acfg, method, i, FALSE);\n\t\tacfg->method_index ++;\n\t}\n\n\t/* gsharedvt methods */\n\tfor (mindex = 0; mindex < image->tables [MONO_TABLE_METHOD].rows; ++mindex) {\n\t\tMonoError error;\n\t\tMonoMethod *method;\n\t\tguint32 token = MONO_TOKEN_METHOD_DEF | (mindex + 1);\n\n\t\tif (!(acfg->opts & MONO_OPT_GSHAREDVT))\n\t\t\tcontinue;\n\n\t\tmethod = mono_get_method_checked (acfg->image, token, NULL, NULL, &error);\n\t\treport_loader_error (acfg, &error, TRUE, \"Failed to load method token 0x%x due to %s\\n\", i, mono_error_get_message (&error));\n\n\t\tif (method->is_generic || mono_class_is_gtd (method->klass)) {\n\t\t\tMonoMethod *gshared;\n\n\t\t\tgshared = mini_get_shared_method_full (method, TRUE, TRUE);\n\t\t\tadd_extra_method (acfg, gshared);\n\t\t}\n\t}\n\n\tif (mono_aot_mode_is_full (&acfg->aot_opts) || mono_aot_mode_is_hybrid (&acfg->aot_opts))\n\t\tadd_generic_instances (acfg);\n\n\tif (mono_aot_mode_is_full (&acfg->aot_opts))\n\t\tadd_wrappers (acfg);\n\treturn TRUE;\n}\n\nstatic void\ncompile_methods (MonoAotCompile *acfg)\n{\n\tint i, methods_len;\n\n\tif (acfg->aot_opts.nthreads > 0) {\n\t\tGPtrArray *frag;\n\t\tint len, j;\n\t\tGPtrArray *threads;\n\t\tMonoThreadHandle *thread_handle;\n\t\tgpointer *user_data;\n\t\tMonoMethod **methods;\n\n\t\tmethods_len = acfg->methods->len;\n\n\t\tlen = acfg->methods->len / acfg->aot_opts.nthreads;\n\t\tg_assert (len > 0);\n\t\t/* \n\t\t * Partition the list of methods into fragments, and hand it to threads to\n\t\t * process.\n\t\t */\n\t\tthreads = g_ptr_array_new ();\n\t\t/* Make a copy since acfg->methods is modified by compile_method () */\n\t\tmethods = g_new0 (MonoMethod*, methods_len);\n\t\t//memcpy (methods, g_ptr_array_index (acfg->methods, 0), sizeof (MonoMethod*) * methods_len);\n\t\tfor (i = 0; i < methods_len; ++i)\n\t\t\tmethods [i] = (MonoMethod *)g_ptr_array_index (acfg->methods, i);\n\t\ti = 0;\n\t\twhile (i < methods_len) {\n\t\t\tMonoError error;\n\t\t\tMonoInternalThread *thread;\n\n\t\t\tfrag = g_ptr_array_new ();\n\t\t\tfor (j = 0; j < len; ++j) {\n\t\t\t\tif (i < methods_len) {\n\t\t\t\t\tg_ptr_array_add (frag, methods [i]);\n\t\t\t\t\ti ++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tuser_data = g_new0 (gpointer, 3);\n\t\t\tuser_data [0] = acfg;\n\t\t\tuser_data [1] = frag;\n\t\t\t\n\t\t\tthread = mono_thread_create_internal (mono_domain_get (), compile_thread_main, (gpointer) user_data, MONO_THREAD_CREATE_FLAGS_NONE, &error);\n\t\t\tmono_error_assert_ok (&error);\n\n\t\t\tthread_handle = mono_threads_open_thread_handle (thread->handle);\n\t\t\tg_ptr_array_add (threads, thread_handle);\n\t\t}\n\t\tg_free (methods);\n\n\t\tfor (i = 0; i < threads->len; ++i) {\n\t\t\tmono_thread_info_wait_one_handle (g_ptr_array_index (threads, i), MONO_INFINITE_WAIT, FALSE);\n\t\t\tmono_threads_close_thread_handle (g_ptr_array_index (threads, i));\n\t\t}\n\t} else {\n\t\tmethods_len = 0;\n\t}\n\n\t/* Compile methods added by compile_method () or all methods if nthreads == 0 */\n\tfor (i = methods_len; i < acfg->methods->len; ++i) {\n\t\t/* This can add new methods to acfg->methods */\n\t\tcompile_method (acfg, (MonoMethod *)g_ptr_array_index (acfg->methods, i));\n\t}\n}\n\nstatic int\ncompile_asm (MonoAotCompile *acfg)\n{\n\tchar *command, *objfile;\n\tchar *outfile_name, *tmp_outfile_name, *llvm_ofile;\n\tconst char *tool_prefix = acfg->aot_opts.tool_prefix ? acfg->aot_opts.tool_prefix : \"\";\n\tchar *ld_flags = acfg->aot_opts.ld_flags ? acfg->aot_opts.ld_flags : g_strdup(\"\");\n\n#ifdef TARGET_WIN32_MSVC\n#define AS_OPTIONS \"-c -x assembler\"\n#elif defined(TARGET_AMD64) && !defined(TARGET_MACH)\n#define AS_OPTIONS \"--64\"\n#elif defined(TARGET_POWERPC64)\n#define AS_OPTIONS \"-a64 -mppc64\"\n#elif defined(sparc) && SIZEOF_VOID_P == 8\n#define AS_OPTIONS \"-xarch=v9\"\n#elif defined(TARGET_X86) && defined(TARGET_MACH)\n#define AS_OPTIONS \"-arch i386\"\n#else\n#define AS_OPTIONS \"\"\n#endif\n\n#if defined(TARGET_OSX)\n#define AS_NAME \"clang\"\n#elif defined(TARGET_WIN32_MSVC)\n#define AS_NAME \"clang.exe\"\n#else\n#define AS_NAME \"as\"\n#endif\n\n#ifdef TARGET_WIN32_MSVC\n#define AS_OBJECT_FILE_SUFFIX \"obj\"\n#else\n#define AS_OBJECT_FILE_SUFFIX \"o\"\n#endif\n\n#if defined(sparc)\n#define LD_NAME \"ld\"\n#define LD_OPTIONS \"-shared -G\"\n#elif defined(__ppc__) && defined(TARGET_MACH)\n#define LD_NAME \"gcc\"\n#define LD_OPTIONS \"-dynamiclib\"\n#elif defined(TARGET_AMD64) && defined(TARGET_MACH)\n#define LD_NAME \"clang\"\n#define LD_OPTIONS \"--shared\"\n#elif defined(TARGET_WIN32_MSVC)\n#define LD_NAME \"link.exe\"\n#define LD_OPTIONS \"/DLL /MACHINE:X64 /NOLOGO /INCREMENTAL:NO\"\n#define LD_DEBUG_OPTIONS LD_OPTIONS \" /DEBUG\"\n#elif defined(TARGET_WIN32) && !defined(TARGET_ANDROID)\n#define LD_NAME \"gcc\"\n#define LD_OPTIONS \"-shared\"\n#elif defined(TARGET_X86) && defined(TARGET_MACH)\n#define LD_NAME \"clang\"\n#define LD_OPTIONS \"-m32 -dynamiclib\"\n#elif defined(TARGET_ARM) && !defined(TARGET_ANDROID)\n#define LD_NAME \"gcc\"\n#define LD_OPTIONS \"--shared\"\n#elif defined(TARGET_POWERPC64)\n#define LD_OPTIONS \"-m elf64ppc\"\n#endif\n\n#ifndef LD_OPTIONS\n#define LD_OPTIONS \"\"\n#endif\n\n\tif (acfg->aot_opts.asm_only) {\n\t\taot_printf (acfg, \"Output file: '%s'.\\n\", acfg->tmpfname);\n\t\tif (acfg->aot_opts.static_link)\n\t\t\taot_printf (acfg, \"Linking symbol: '%s'.\\n\", acfg->static_linking_symbol);\n\t\tif (acfg->llvm)\n\t\t\taot_printf (acfg, \"LLVM output file: '%s'.\\n\", acfg->llvm_sfile);\n\t\treturn 0;\n\t}\n\n\tif (acfg->aot_opts.static_link) {\n\t\tif (acfg->aot_opts.outfile)\n\t\t\tobjfile = g_strdup_printf (\"%s\", acfg->aot_opts.outfile);\n\t\telse\n\t\t\tobjfile = g_strdup_printf (\"%s.\" AS_OBJECT_FILE_SUFFIX, acfg->image->name);\n\t} else {\n\t\tobjfile = g_strdup_printf (\"%s.\" AS_OBJECT_FILE_SUFFIX, acfg->tmpfname);\n\t}\n\n#ifdef TARGET_OSX\n\tg_string_append (acfg->as_args, \"-c -x assembler\");\n#endif\n\n\tcommand = g_strdup_printf (\"\\\"%s%s\\\" %s %s -o %s %s\", tool_prefix, AS_NAME, AS_OPTIONS,\n\t\t\tacfg->as_args ? acfg->as_args->str : \"\", \n\t\t\twrap_path (objfile), wrap_path (acfg->tmpfname));\n\taot_printf (acfg, \"Executing the native assembler: %s\\n\", command);\n\tif (execute_system (command) != 0) {\n\t\tg_free (command);\n\t\tg_free (objfile);\n\t\treturn 1;\n\t}\n\n\tif (acfg->llvm && !acfg->llvm_owriter) {\n\t\tcommand = g_strdup_printf (\"\\\"%s%s\\\" %s %s -o %s %s\", tool_prefix, AS_NAME, AS_OPTIONS,\n\t\t\tacfg->as_args ? acfg->as_args->str : \"\",\n\t\t\twrap_path (acfg->llvm_ofile), wrap_path (acfg->llvm_sfile));\n\t\taot_printf (acfg, \"Executing the native assembler: %s\\n\", command);\n\t\tif (execute_system (command) != 0) {\n\t\t\tg_free (command);\n\t\t\tg_free (objfile);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tg_free (command);\n\n\tif (acfg->aot_opts.static_link) {\n\t\taot_printf (acfg, \"Output file: '%s'.\\n\", objfile);\n\t\taot_printf (acfg, \"Linking symbol: '%s'.\\n\", acfg->static_linking_symbol);\n\t\tg_free (objfile);\n\t\treturn 0;\n\t}\n\n\tif (acfg->aot_opts.outfile)\n\t\toutfile_name = g_strdup_printf (\"%s\", acfg->aot_opts.outfile);\n\telse\n\t\toutfile_name = g_strdup_printf (\"%s%s\", acfg->image->name, MONO_SOLIB_EXT);\n\n\ttmp_outfile_name = g_strdup_printf (\"%s.tmp\", outfile_name);\n\n\tif (acfg->llvm) {\n\t\tllvm_ofile = g_strdup_printf (\"\\\"%s\\\"\", acfg->llvm_ofile);\n\t} else {\n\t\tllvm_ofile = g_strdup (\"\");\n\t}\n\n\t/* replace the ; flags separators with spaces */\n\tg_strdelimit (ld_flags, \";\", ' ');\n\n\tif (acfg->aot_opts.llvm_only)\n\t\tld_flags = g_strdup_printf (\"%s %s\", ld_flags, \"-lstdc++\");\n\n#ifdef TARGET_WIN32_MSVC\n\tg_assert (tmp_outfile_name != NULL);\n\tg_assert (objfile != NULL);\n\tcommand = g_strdup_printf (\"\\\"%s%s\\\" %s %s /OUT:\\\"%s\\\" \\\"%s\\\"\", tool_prefix, LD_NAME,\n\t\t\tacfg->aot_opts.nodebug ? LD_OPTIONS : LD_DEBUG_OPTIONS, ld_flags, tmp_outfile_name, objfile);\n#elif defined(LD_NAME)\n\tcommand = g_strdup_printf (\"%s%s %s -o %s %s %s %s\", tool_prefix, LD_NAME, LD_OPTIONS,\n\t\twrap_path (tmp_outfile_name), wrap_path (llvm_ofile),\n\t\twrap_path (g_strdup_printf (\"%s.\" AS_OBJECT_FILE_SUFFIX, acfg->tmpfname)), ld_flags);\n#else\n\t// Default (linux)\n\tif (acfg->aot_opts.tool_prefix) {\n\t\t/* Cross compiling */\n\t\tcommand = g_strdup_printf (\"\\\"%sld\\\" %s -shared -o %s %s %s %s\", tool_prefix, LD_OPTIONS,\n\t\t\t\t\t\t\t\t   wrap_path (tmp_outfile_name), wrap_path (llvm_ofile),\n\t\t\t\t\t\t\t\t   wrap_path (g_strdup_printf (\"%s.\" AS_OBJECT_FILE_SUFFIX, acfg->tmpfname)), ld_flags);\n\t} else {\n\t\tchar *args = g_strdup_printf (\"%s -shared -o %s %s %s %s\", LD_OPTIONS,\n\t\t\t\t\t\t\t\t\t  wrap_path (tmp_outfile_name), wrap_path (llvm_ofile),\n\t\t\t\t\t\t\t\t\t  wrap_path (g_strdup_printf (\"%s.\" AS_OBJECT_FILE_SUFFIX, acfg->tmpfname)), ld_flags);\n\n\t\tif (acfg->aot_opts.llvm_only) {\n\t\t\tcommand = g_strdup_printf (\"clang++ %s\", args);\n\t\t} else {\n\t\t\tcommand = g_strdup_printf (\"\\\"%sld\\\" %s\", tool_prefix, args);\n\t\t}\n\t\tg_free (args);\n\t}\n#endif\n\taot_printf (acfg, \"Executing the native linker: %s\\n\", command);\n\tif (execute_system (command) != 0) {\n\t\tg_free (tmp_outfile_name);\n\t\tg_free (outfile_name);\n\t\tg_free (command);\n\t\tg_free (objfile);\n\t\tg_free (ld_flags);\n\t\treturn 1;\n\t}\n\n\tg_free (command);\n\n\t/*com = g_strdup_printf (\"strip --strip-unneeded %s%s\", acfg->image->name, MONO_SOLIB_EXT);\n\tprintf (\"Stripping the binary: %s\\n\", com);\n\texecute_system (com);\n\tg_free (com);*/\n\n#if defined(TARGET_ARM) && !defined(TARGET_MACH)\n\t/* \n\t * gas generates 'mapping symbols' each time code and data is mixed, which \n\t * happens a lot in emit_and_reloc_code (), so we need to get rid of them.\n\t */\n\tcommand = g_strdup_printf (\"\\\"%sstrip\\\" --strip-symbol=\\\\$a --strip-symbol=\\\\$d %s\", wrap_path(tool_prefix), wrap_path(tmp_outfile_name));\n\taot_printf (acfg, \"Stripping the binary: %s\\n\", command);\n\tif (execute_system (command) != 0) {\n\t\tg_free (tmp_outfile_name);\n\t\tg_free (outfile_name);\n\t\tg_free (command);\n\t\tg_free (objfile);\n\t\treturn 1;\n\t}\n#endif\n\n\tif (0 != rename (tmp_outfile_name, outfile_name)) {\n\t\tif (G_FILE_ERROR_EXIST == g_file_error_from_errno (errno)) {\n\t\t\t/* Since we are rebuilding the module we need to be able to replace any old copies. Remove old file and retry rename operation. */\n\t\t\tunlink (outfile_name);\n\t\t\trename (tmp_outfile_name, outfile_name);\n\t\t}\n\t}\n\n#if defined(TARGET_MACH)\n\tcommand = g_strdup_printf (\"dsymutil \\\"%s\\\"\", outfile_name);\n\taot_printf (acfg, \"Executing dsymutil: %s\\n\", command);\n\tif (execute_system (command) != 0) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!acfg->aot_opts.save_temps)\n\t\tunlink (objfile);\n\n\tg_free (tmp_outfile_name);\n\tg_free (outfile_name);\n\tg_free (objfile);\n\n\tif (acfg->aot_opts.save_temps)\n\t\taot_printf (acfg, \"Retained input file.\\n\");\n\telse\n\t\tunlink (acfg->tmpfname);\n\n\treturn 0;\n}\n\nstatic guint8\nprofread_byte (FILE *infile)\n{\n\tguint8 i;\n\tint res;\n\n\tres = fread (&i, 1, 1, infile);\n\tg_assert (res == 1);\n\treturn i;\n}\n\nstatic int\nprofread_int (FILE *infile)\n{\n\tint i, res;\n\n\tres = fread (&i, 4, 1, infile);\n\tg_assert (res == 1);\n\treturn i;\n}\n\nstatic char*\nprofread_string (FILE *infile)\n{\n\tint len, res;\n\tchar buf [1024];\n\tchar *pbuf;\n\n\tlen = profread_int (infile);\n\tif (len + 1 > 1024)\n\t\tpbuf = g_malloc (len + 1);\n\telse\n\t\tpbuf = buf;\n\tres = fread (pbuf, 1, len, infile);\n\tg_assert (res == len);\n\tpbuf [len] = '\\0';\n\tif (pbuf == buf)\n\t\treturn g_strdup (buf);\n\telse\n\t\treturn pbuf;\n}\n\nstatic void\nload_profile_file (MonoAotCompile *acfg, char *filename)\n{\n\tFILE *infile;\n\tchar buf [1024];\n\tint res, len, version;\n\tchar magic [32];\n\n\tinfile = fopen (filename, \"r\");\n\tif (!infile) {\n\t\tfprintf (stderr, \"Unable to open file '%s': %s.\\n\", filename, strerror (errno));\n\t\texit (1);\n\t}\n\n\tprintf (\"Using profile data file '%s'\\n\", filename);\n\n\tsprintf (magic, AOT_PROFILER_MAGIC);\n\tlen = strlen (magic);\n\tres = fread (buf, 1, len, infile);\n\tmagic [len] = '\\0';\n\tbuf [len] = '\\0';\n\tif ((res != len) || strcmp (buf, magic) != 0) {\n\t\tprintf (\"Profile file has wrong header: '%s'.\\n\", buf);\n\t\tfclose (infile);\n\t\texit (1);\n\t}\n\tguint32 expected_version = (AOT_PROFILER_MAJOR_VERSION << 16) | AOT_PROFILER_MINOR_VERSION;\n\tversion = profread_int (infile);\n\tif (version != expected_version) {\n\t\tprintf (\"Profile file has wrong version 0x%4x, expected 0x%4x.\\n\", version, expected_version);\n\t\tfclose (infile);\n\t\texit (1);\n\t}\n\n\tProfileData *data = g_new0 (ProfileData, 1);\n\tdata->images = g_hash_table_new (NULL, NULL);\n\tdata->classes = g_hash_table_new (NULL, NULL);\n\tdata->ginsts = g_hash_table_new (NULL, NULL);\n\tdata->methods = g_hash_table_new (NULL, NULL);\n\n\twhile (TRUE) {\n\t\tint type = profread_byte (infile);\n\t\tint id = profread_int (infile);\n\n\t\tif (type == AOTPROF_RECORD_NONE)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase AOTPROF_RECORD_IMAGE: {\n\t\t\tImageProfileData *idata = g_new0 (ImageProfileData, 1);\n\t\t\tidata->name = profread_string (infile);\n\t\t\tchar *mvid = profread_string (infile);\n\t\t\tg_free (mvid);\n\t\t\tg_hash_table_insert (data->images, GINT_TO_POINTER (id), idata);\n\t\t\tbreak;\n\t\t}\n\t\tcase AOTPROF_RECORD_GINST: {\n\t\t\tint i;\n\t\t\tint len = profread_int (infile);\n\n\t\t\tGInstProfileData *gdata = g_new0 (GInstProfileData, 1);\n\t\t\tgdata->argc = len;\n\t\t\tgdata->argv = g_new0 (ClassProfileData*, len);\n\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tint class_id = profread_int (infile);\n\n\t\t\t\tgdata->argv [i] = g_hash_table_lookup (data->classes, GINT_TO_POINTER (class_id));\n\t\t\t\tg_assert (gdata->argv [i]);\n\t\t\t}\n\t\t\tg_hash_table_insert (data->ginsts, GINT_TO_POINTER (id), gdata);\n\t\t\tbreak;\n\t\t}\n\t\tcase AOTPROF_RECORD_TYPE: {\n\t\t\tint type = profread_byte (infile);\n\n\t\t\tswitch (type) {\n\t\t\tcase MONO_TYPE_CLASS: {\n\t\t\t\tint image_id = profread_int (infile);\n\t\t\t\tint ginst_id = profread_int (infile);\n\t\t\t\tchar *class_name = profread_string (infile);\n\n\t\t\t\tImageProfileData *image = g_hash_table_lookup (data->images, GINT_TO_POINTER (image_id));\n\t\t\t\tg_assert (image);\n\n\t\t\t\tchar *p = strrchr (class_name, '.');\n\t\t\t\tg_assert (p);\n\t\t\t\t*p = '\\0';\n\n\t\t\t\tClassProfileData *cdata = g_new0 (ClassProfileData, 1);\n\t\t\t\tcdata->image = image;\n\t\t\t\tcdata->ns = g_strdup (class_name);\n\t\t\t\tcdata->name = g_strdup (p + 1);\n\n\t\t\t\tif (ginst_id != -1) {\n\t\t\t\t\tcdata->inst = g_hash_table_lookup (data->ginsts, GINT_TO_POINTER (ginst_id));\n\t\t\t\t\tg_assert (cdata->inst);\n\t\t\t\t}\n\t\t\t\tg_free (class_name);\n\n\t\t\t\tg_hash_table_insert (data->classes, GINT_TO_POINTER (id), cdata);\n\t\t\t\tbreak;\n\t\t\t}\n#if 0\n\t\t\tcase MONO_TYPE_SZARRAY: {\n\t\t\t\tint elem_id = profread_int (infile);\n\t\t\t\t// FIXME:\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase AOTPROF_RECORD_METHOD: {\n\t\t\tint class_id = profread_int (infile);\n\t\t\tint ginst_id = profread_int (infile);\n\t\t\tint param_count = profread_int (infile);\n\t\t\tchar *method_name = profread_string (infile);\n\t\t\tchar *sig = profread_string (infile);\n\n\t\t\tClassProfileData *klass = g_hash_table_lookup (data->classes, GINT_TO_POINTER (class_id));\n\t\t\tg_assert (klass);\n\n\t\t\tMethodProfileData *mdata = g_new0 (MethodProfileData, 1);\n\t\t\tmdata->id = id;\n\t\t\tmdata->klass = klass;\n\t\t\tmdata->name = method_name;\n\t\t\tmdata->signature = sig;\n\t\t\tmdata->param_count = param_count;\n\n\t\t\tif (ginst_id != -1) {\n\t\t\t\tmdata->inst = g_hash_table_lookup (data->ginsts, GINT_TO_POINTER (ginst_id));\n\t\t\t\tg_assert (mdata->inst);\n\t\t\t}\n\t\t\tg_hash_table_insert (data->methods, GINT_TO_POINTER (id), mdata);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tprintf (\"%d\\n\", type);\n\t\t\tg_assert_not_reached ();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose (infile);\n\tacfg->profile_data = g_list_append (acfg->profile_data, data);\n}\n\nstatic void\nresolve_class (ClassProfileData *cdata);\n\nstatic void\nresolve_ginst (GInstProfileData *inst_data)\n{\n\tint i;\n\n\tif (inst_data->inst)\n\t\treturn;\n\n\tfor (i = 0; i < inst_data->argc; ++i) {\n\t\tresolve_class (inst_data->argv [i]);\n\t\tif (!inst_data->argv [i]->klass)\n\t\t\treturn;\n\t}\n\tMonoType **args = g_new0 (MonoType*, inst_data->argc);\n\tfor (i = 0; i < inst_data->argc; ++i)\n\t\targs [i] = &inst_data->argv [i]->klass->byval_arg;\n\n\tinst_data->inst = mono_metadata_get_generic_inst (inst_data->argc, args);\n}\n\nstatic void\nresolve_class (ClassProfileData *cdata)\n{\n\tMonoError error;\n\tMonoClass *klass;\n\n\tif (!cdata->image->image)\n\t\treturn;\n\n\tklass = mono_class_from_name_checked (cdata->image->image, cdata->ns, cdata->name, &error);\n\tif (!klass) {\n\t\t//printf (\"[%s] %s.%s\\n\", cdata->image->name, cdata->ns, cdata->name);\n\t\treturn;\n\t}\n\tif (cdata->inst) {\n\t\tresolve_ginst (cdata->inst);\n\t\tif (!cdata->inst->inst)\n\t\t\treturn;\n\t\tMonoGenericContext ctx;\n\n\t\tmemset (&ctx, 0, sizeof (ctx));\n\t\tctx.class_inst = cdata->inst->inst;\n\t\tcdata->klass = mono_class_inflate_generic_class_checked (klass, &ctx, &error);\n\t} else {\n\t\tcdata->klass = klass;\n\t}\n}\n\n/*\n * Resolve the profile data to the corresponding loaded classes/methods etc. if possible.\n */\nstatic void\nresolve_profile_data (MonoAotCompile *acfg, ProfileData *data)\n{\n\tGHashTableIter iter;\n\tgpointer key, value;\n\tint i;\n\n\tif (!data)\n\t\treturn;\n\n\t/* Images */\n\tGPtrArray *assemblies = mono_domain_get_assemblies (mono_get_root_domain (), FALSE);\n\tg_hash_table_iter_init (&iter, data->images);\n\twhile (g_hash_table_iter_next (&iter, &key, &value)) {\n\t\tImageProfileData *idata = (ImageProfileData*)value;\n\n\t\tfor (i = 0; i < assemblies->len; ++i) {\n\t\t\tMonoAssembly *ass = g_ptr_array_index (assemblies, i);\n\n\t\t\tif (!strcmp (ass->aname.name, idata->name)) {\n\t\t\t\tidata->image = ass->image;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tg_ptr_array_free (assemblies, TRUE);\n\n\t/* Classes */\n\tg_hash_table_iter_init (&iter, data->classes);\n\twhile (g_hash_table_iter_next (&iter, &key, &value)) {\n\t\tClassProfileData *cdata = (ClassProfileData*)value;\n\n\t\tif (!cdata->image->image) {\n\t\t\tif (acfg->aot_opts.verbose)\n\t\t\t\tprintf (\"Unable to load class '%s.%s' because its image '%s' is not loaded.\\n\", cdata->ns, cdata->name, cdata->image->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tresolve_class (cdata);\n\t\t/*\n\t\tif (cdata->klass)\n\t\t\tprintf (\"%s %s %s\\n\", cdata->ns, cdata->name, mono_class_full_name (cdata->klass));\n\t\t*/\n\t}\n\n\t/* Methods */\n\tg_hash_table_iter_init (&iter, data->methods);\n\twhile (g_hash_table_iter_next (&iter, &key, &value)) {\n\t\tMethodProfileData *mdata = (MethodProfileData*)value;\n\t\tMonoClass *klass;\n\t\tMonoMethod *m;\n\t\tgpointer miter;\n\n\t\tresolve_class (mdata->klass);\n\t\tklass = mdata->klass->klass;\n\t\tif (!klass) {\n\t\t\tif (acfg->aot_opts.verbose)\n\t\t\t\tprintf (\"Unable to load method '%s' because its class '%s.%s' is not loaded.\\n\", mdata->name, mdata->klass->ns, mdata->klass->name);\n\t\t\tcontinue;\n\t\t}\n\t\tmiter = NULL;\n\t\twhile ((m = mono_class_get_methods (klass, &miter))) {\n\t\t\tMonoError error;\n\n\t\t\tif (strcmp (m->name, mdata->name))\n\t\t\t\tcontinue;\n\t\t\tMonoMethodSignature *sig = mono_method_signature (m);\n\t\t\tif (!sig)\n\t\t\t\tcontinue;\n\t\t\tif (sig->param_count != mdata->param_count)\n\t\t\t\tcontinue;\n\t\t\tif (mdata->inst) {\n\t\t\t\tresolve_ginst (mdata->inst);\n\t\t\t\tif (!mdata->inst->inst)\n\t\t\t\t\tcontinue;\n\t\t\t\tMonoGenericContext ctx;\n\n\t\t\t\tmemset (&ctx, 0, sizeof (ctx));\n\t\t\t\tctx.method_inst = mdata->inst->inst;\n\n\t\t\t\tm = mono_class_inflate_generic_method_checked (m, &ctx, &error);\n\t\t\t\tif (!m)\n\t\t\t\t\tcontinue;\n\t\t\t\tsig = mono_method_signature_checked (m, &error);\n\t\t\t\tif (!is_ok (&error)) {\n\t\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *sig_str = mono_signature_full_name (sig);\n\t\t\tgboolean match = !strcmp (sig_str, mdata->signature);\n\t\t\tg_free (sig_str);\n\t\t\tif (!match)\n\n\t\t\t\tcontinue;\n\t\t\t//printf (\"%s\\n\", mono_method_full_name (m, 1));\n\t\t\tmdata->method = m;\n\t\t\tbreak;\n\t\t}\n\t\tif (!mdata->method) {\n\t\t\tif (acfg->aot_opts.verbose)\n\t\t\t\tprintf (\"Unable to load method '%s' from class '%s', not found.\\n\", mdata->name, mono_class_full_name (klass));\n\t\t}\n\t}\n}\n\nstatic gboolean\ninst_references_image (MonoGenericInst *inst, MonoImage *image)\n{\n\tint i;\n\n\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\tMonoClass *k = mono_class_from_mono_type (inst->type_argv [i]);\n\t\tif (k->image == image)\n\t\t\treturn TRUE;\n\t\tif (mono_class_is_ginst (k)) {\n\t\t\tMonoGenericInst *kinst = mono_class_get_context (k)->class_inst;\n\t\t\tif (inst_references_image (kinst, image))\n\t\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nis_local_inst (MonoGenericInst *inst, MonoImage *image)\n{\n\tint i;\n\n\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\tMonoClass *k = mono_class_from_mono_type (inst->type_argv [i]);\n\t\tif (!MONO_TYPE_IS_PRIMITIVE (inst->type_argv [i]) && k->image != image)\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic void\nadd_profile_instances (MonoAotCompile *acfg, ProfileData *data)\n{\n\tGHashTableIter iter;\n\tgpointer key, value;\n\tint count = 0;\n\n\tif (!data)\n\t\treturn;\n\n\tif (acfg->aot_opts.profile_only) {\n\t\t/* Add methods referenced by the profile */\n\t\tg_hash_table_iter_init (&iter, data->methods);\n\t\twhile (g_hash_table_iter_next (&iter, &key, &value)) {\n\t\t\tMethodProfileData *mdata = (MethodProfileData*)value;\n\t\t\tMonoMethod *m = mdata->method;\n\n\t\t\tif (!m)\n\t\t\t\tcontinue;\n\t\t\tif (m->is_inflated)\n\t\t\t\tcontinue;\n\t\t\tadd_extra_method (acfg, m);\n\t\t\tg_hash_table_insert (acfg->profile_methods, m, m);\n\t\t\tcount ++;\n\t\t}\n\t}\n\n\t/*\n\t * Add method instances 'related' to this assembly to the AOT image.\n\t */\n\tg_hash_table_iter_init (&iter, data->methods);\n\twhile (g_hash_table_iter_next (&iter, &key, &value)) {\n\t\tMethodProfileData *mdata = (MethodProfileData*)value;\n\t\tMonoMethod *m = mdata->method;\n\t\tMonoGenericContext *ctx;\n\n\t\tif (!m)\n\t\t\tcontinue;\n\t\tif (!m->is_inflated)\n\t\t\tcontinue;\n\n\t\tctx = mono_method_get_context (m);\n\t\t/* For simplicity, add instances which reference the assembly we are compiling */\n\t\tif (((ctx->class_inst && inst_references_image (ctx->class_inst, acfg->image)) ||\n\t\t\t (ctx->method_inst && inst_references_image (ctx->method_inst, acfg->image))) &&\n\t\t\t!mono_method_is_generic_sharable_full (m, FALSE, FALSE, FALSE)) {\n\t\t\t//printf (\"%s\\n\", mono_method_full_name (m, TRUE));\n\t\t\tadd_extra_method (acfg, m);\n\t\t\tcount ++;\n\t\t} else if (m->klass->image == acfg->image &&\n\t\t\t((ctx->class_inst && is_local_inst (ctx->class_inst, acfg->image)) ||\n\t\t\t (ctx->method_inst && is_local_inst (ctx->method_inst, acfg->image))) &&\n\t\t\t!mono_method_is_generic_sharable_full (m, FALSE, FALSE, FALSE))  {\n\t\t\t/* Add instances where the gtd is in the assembly and its inflated with types from this assembly or corlib */\n\t\t\t//printf (\"%s\\n\", mono_method_full_name (m, TRUE));\n\t\t\tadd_extra_method (acfg, m);\n\t\t\tcount ++;\n\t\t}\n\t\t/*\n\t\t * FIXME: We might skip some instances, for example:\n\t\t * Foo<Bar> won't be compiled when compiling Foo's assembly since it doesn't match the first case,\n\t\t * and it won't be compiled when compiling Bar's assembly if Foo's assembly is not loaded.\n\t\t */\n\t}\n\n\tprintf (\"Added %d methods from profile.\\n\", count);\n}\n\nstatic void\ninit_got_info (GotInfo *info)\n{\n\tint i;\n\n\tinfo->patch_to_got_offset = g_hash_table_new (mono_patch_info_hash, mono_patch_info_equal);\n\tinfo->patch_to_got_offset_by_type = g_new0 (GHashTable*, MONO_PATCH_INFO_NUM);\n\tfor (i = 0; i < MONO_PATCH_INFO_NUM; ++i)\n\t\tinfo->patch_to_got_offset_by_type [i] = g_hash_table_new (mono_patch_info_hash, mono_patch_info_equal);\n\tinfo->got_patches = g_ptr_array_new ();\n}\n\nstatic MonoAotCompile*\nacfg_create (MonoAssembly *ass, guint32 opts)\n{\n\tMonoImage *image = ass->image;\n\tMonoAotCompile *acfg;\n\n\tacfg = g_new0 (MonoAotCompile, 1);\n\tacfg->methods = g_ptr_array_new ();\n\tacfg->method_indexes = g_hash_table_new (NULL, NULL);\n\tacfg->method_depth = g_hash_table_new (NULL, NULL);\n\tacfg->plt_offset_to_entry = g_hash_table_new (NULL, NULL);\n\tacfg->patch_to_plt_entry = g_new0 (GHashTable*, MONO_PATCH_INFO_NUM);\n\tacfg->method_to_cfg = g_hash_table_new (NULL, NULL);\n\tacfg->token_info_hash = g_hash_table_new_full (NULL, NULL, NULL, NULL);\n\tacfg->method_to_pinvoke_import = g_hash_table_new_full (NULL, NULL, NULL, g_free);\n\tacfg->image_hash = g_hash_table_new (NULL, NULL);\n\tacfg->image_table = g_ptr_array_new ();\n\tacfg->globals = g_ptr_array_new ();\n\tacfg->image = image;\n\tacfg->opts = opts;\n\t/* TODO: Write out set of SIMD instructions used, rather than just those available */\n\tacfg->simd_opts = mono_arch_cpu_enumerate_simd_versions ();\n\tacfg->mempool = mono_mempool_new ();\n\tacfg->extra_methods = g_ptr_array_new ();\n\tacfg->unwind_info_offsets = g_hash_table_new (NULL, NULL);\n\tacfg->unwind_ops = g_ptr_array_new ();\n\tacfg->method_label_hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n\tacfg->method_order = g_ptr_array_new ();\n\tacfg->export_names = g_hash_table_new (NULL, NULL);\n\tacfg->klass_blob_hash = g_hash_table_new (NULL, NULL);\n\tacfg->method_blob_hash = g_hash_table_new (NULL, NULL);\n\tacfg->plt_entry_debug_sym_cache = g_hash_table_new (g_str_hash, g_str_equal);\n\tacfg->gsharedvt_in_signatures = g_hash_table_new ((GHashFunc)mono_signature_hash, (GEqualFunc)mono_metadata_signature_equal);\n\tacfg->gsharedvt_out_signatures = g_hash_table_new ((GHashFunc)mono_signature_hash, (GEqualFunc)mono_metadata_signature_equal);\n\tacfg->profile_methods = g_hash_table_new (NULL, NULL);\n\tmono_os_mutex_init_recursive (&acfg->mutex);\n\n\tinit_got_info (&acfg->got_info);\n\tinit_got_info (&acfg->llvm_got_info);\n\n\treturn acfg;\n}\n\nstatic void\ngot_info_free (GotInfo *info)\n{\n\tint i;\n\n\tfor (i = 0; i < MONO_PATCH_INFO_NUM; ++i)\n\t\tg_hash_table_destroy (info->patch_to_got_offset_by_type [i]);\n\tg_free (info->patch_to_got_offset_by_type);\n\tg_hash_table_destroy (info->patch_to_got_offset);\n\tg_ptr_array_free (info->got_patches, TRUE);\n}\n\nstatic void\nacfg_free (MonoAotCompile *acfg)\n{\n\tint i;\n\n\tmono_img_writer_destroy (acfg->w);\n\tfor (i = 0; i < acfg->nmethods; ++i)\n\t\tif (acfg->cfgs [i])\n\t\t\tmono_destroy_compile (acfg->cfgs [i]);\n\n\tg_free (acfg->cfgs);\n\n\tg_free (acfg->static_linking_symbol);\n\tg_free (acfg->got_symbol);\n\tg_free (acfg->plt_symbol);\n\tg_ptr_array_free (acfg->methods, TRUE);\n\tg_ptr_array_free (acfg->image_table, TRUE);\n\tg_ptr_array_free (acfg->globals, TRUE);\n\tg_ptr_array_free (acfg->unwind_ops, TRUE);\n\tg_hash_table_destroy (acfg->method_indexes);\n\tg_hash_table_destroy (acfg->method_depth);\n\tg_hash_table_destroy (acfg->plt_offset_to_entry);\n\tfor (i = 0; i < MONO_PATCH_INFO_NUM; ++i) {\n\t\tif (acfg->patch_to_plt_entry [i])\n\t\t\tg_hash_table_destroy (acfg->patch_to_plt_entry [i]);\n\t}\n\tg_free (acfg->patch_to_plt_entry);\n\tg_hash_table_destroy (acfg->method_to_cfg);\n\tg_hash_table_destroy (acfg->token_info_hash);\n\tg_hash_table_destroy (acfg->method_to_pinvoke_import);\n\tg_hash_table_destroy (acfg->image_hash);\n\tg_hash_table_destroy (acfg->unwind_info_offsets);\n\tg_hash_table_destroy (acfg->method_label_hash);\n\tif (acfg->typespec_classes)\n\t\tg_hash_table_destroy (acfg->typespec_classes);\n\tg_hash_table_destroy (acfg->export_names);\n\tg_hash_table_destroy (acfg->plt_entry_debug_sym_cache);\n\tg_hash_table_destroy (acfg->klass_blob_hash);\n\tg_hash_table_destroy (acfg->method_blob_hash);\n\tgot_info_free (&acfg->got_info);\n\tgot_info_free (&acfg->llvm_got_info);\n\tarch_free_unwind_info_section_cache (acfg);\n\tmono_mempool_destroy (acfg->mempool);\n\tg_free (acfg);\n}\n\n#define WRAPPER(e,n) n,\nstatic const char* const\nwrapper_type_names [MONO_WRAPPER_NUM + 1] = {\n#include \"mono/metadata/wrapper-types.h\"\n\tNULL\n};\n\nstatic G_GNUC_UNUSED const char*\nget_wrapper_type_name (int type)\n{\n\treturn wrapper_type_names [type];\n}\n\n//#define DUMP_PLT\n//#define DUMP_GOT\n\nstatic void aot_dump (MonoAotCompile *acfg)\n{\n\tFILE *dumpfile;\n\tchar * dumpname;\n\n\tJsonWriter writer;\n\tmono_json_writer_init (&writer);\n\n\tmono_json_writer_object_begin(&writer);\n\n\t// Methods\n\tmono_json_writer_indent (&writer);\n\tmono_json_writer_object_key(&writer, \"methods\");\n\tmono_json_writer_array_begin (&writer);\n\n\tint i;\n\tfor (i = 0; i < acfg->nmethods; ++i) {\n\t\tMonoCompile *cfg;\n\t\tMonoMethod *method;\n\t\tMonoClass *klass;\n\n\t\tcfg = acfg->cfgs [i];\n\t\tif (ignore_cfg (cfg))\n\t\t\tcontinue;\n\n\t\tmethod = cfg->orig_method;\n\n\t\tmono_json_writer_indent (&writer);\n\t\tmono_json_writer_object_begin(&writer);\n\n\t\tmono_json_writer_indent (&writer);\n\t\tmono_json_writer_object_key(&writer, \"name\");\n\t\tmono_json_writer_printf (&writer, \"\\\"%s\\\",\\n\", method->name);\n\n\t\tmono_json_writer_indent (&writer);\n\t\tmono_json_writer_object_key(&writer, \"signature\");\n\t\tmono_json_writer_printf (&writer, \"\\\"%s\\\",\\n\", mono_method_get_full_name (method));\n\n\t\tmono_json_writer_indent (&writer);\n\t\tmono_json_writer_object_key(&writer, \"code_size\");\n\t\tmono_json_writer_printf (&writer, \"\\\"%d\\\",\\n\", cfg->code_size);\n\n\t\tklass = method->klass;\n\n\t\tmono_json_writer_indent (&writer);\n\t\tmono_json_writer_object_key(&writer, \"class\");\n\t\tmono_json_writer_printf (&writer, \"\\\"%s\\\",\\n\", klass->name);\n\n\t\tmono_json_writer_indent (&writer);\n\t\tmono_json_writer_object_key(&writer, \"namespace\");\n\t\tmono_json_writer_printf (&writer, \"\\\"%s\\\",\\n\", klass->name_space);\n\n\t\tmono_json_writer_indent (&writer);\n\t\tmono_json_writer_object_key(&writer, \"wrapper_type\");\n\t\tmono_json_writer_printf (&writer, \"\\\"%s\\\",\\n\", get_wrapper_type_name(method->wrapper_type));\n\n\t\tmono_json_writer_indent_pop (&writer);\n\t\tmono_json_writer_indent (&writer);\n\t\tmono_json_writer_object_end (&writer);\n\t\tmono_json_writer_printf (&writer, \",\\n\");\n\t}\n\n\tmono_json_writer_indent_pop (&writer);\n\tmono_json_writer_indent (&writer);\n\tmono_json_writer_array_end (&writer);\n\tmono_json_writer_printf (&writer, \",\\n\");\n\n\t// PLT entries\n#ifdef DUMP_PLT\n\tmono_json_writer_indent_push (&writer);\n\tmono_json_writer_indent (&writer);\n\tmono_json_writer_object_key(&writer, \"plt\");\n\tmono_json_writer_array_begin (&writer);\n\n\tfor (i = 0; i < acfg->plt_offset; ++i) {\n\t\tMonoPltEntry *plt_entry = NULL;\n\t\tMonoJumpInfo *ji;\n\n\t\tif (i == 0)\n\t\t\t/* \n\t\t\t * The first plt entry is unused.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tplt_entry = g_hash_table_lookup (acfg->plt_offset_to_entry, GUINT_TO_POINTER (i));\n\t\tji = plt_entry->ji;\n\n\t\tmono_json_writer_indent (&writer);\n\t\tmono_json_writer_printf (&writer, \"{ \");\n\t\tmono_json_writer_object_key(&writer, \"symbol\");\n\t\tmono_json_writer_printf (&writer, \"\\\"%s\\\" },\\n\", plt_entry->symbol);\n\t}\n\n\tmono_json_writer_indent_pop (&writer);\n\tmono_json_writer_indent (&writer);\n\tmono_json_writer_array_end (&writer);\n\tmono_json_writer_printf (&writer, \",\\n\");\n#endif\n\n\t// GOT entries\n#ifdef DUMP_GOT\n\tmono_json_writer_indent_push (&writer);\n\tmono_json_writer_indent (&writer);\n\tmono_json_writer_object_key(&writer, \"got\");\n\tmono_json_writer_array_begin (&writer);\n\n\tmono_json_writer_indent_push (&writer);\n\tfor (i = 0; i < acfg->got_info.got_patches->len; ++i) {\n\t\tMonoJumpInfo *ji = g_ptr_array_index (acfg->got_info.got_patches, i);\n\n\t\tmono_json_writer_indent (&writer);\n\t\tmono_json_writer_printf (&writer, \"{ \");\n\t\tmono_json_writer_object_key(&writer, \"patch_name\");\n\t\tmono_json_writer_printf (&writer, \"\\\"%s\\\" },\\n\", get_patch_name (ji->type));\n\t}\n\n\tmono_json_writer_indent_pop (&writer);\n\tmono_json_writer_indent (&writer);\n\tmono_json_writer_array_end (&writer);\n\tmono_json_writer_printf (&writer, \",\\n\");\n#endif\n\n\tmono_json_writer_indent_pop (&writer);\n\tmono_json_writer_indent (&writer);\n\tmono_json_writer_object_end (&writer);\n\n\tdumpname = g_strdup_printf (\"%s.json\", g_path_get_basename (acfg->image->name));\n\tdumpfile = fopen (dumpname, \"w+\");\n\tg_free (dumpname);\n\n\tfprintf (dumpfile, \"%s\", writer.text->str);\n\tfclose (dumpfile);\n\n\tmono_json_writer_destroy (&writer);\n}\n\nstatic const char *preinited_jit_icalls[] = {\n\t\"mono_aot_init_llvm_method\",\n\t\"mono_aot_init_gshared_method_this\",\n\t\"mono_aot_init_gshared_method_mrgctx\",\n\t\"mono_aot_init_gshared_method_vtable\",\n\t\"mono_llvm_throw_corlib_exception\",\n\t\"mono_init_vtable_slot\",\n\t\"mono_helper_ldstr_mscorlib\"\n};\n\nstatic void\nadd_preinit_got_slots (MonoAotCompile *acfg)\n{\n\tMonoJumpInfo *ji;\n\tint i;\n\n\t/*\n\t * Allocate the first few GOT entries to information which is needed frequently, or it is needed\n\t * during method initialization etc.\n\t */\n\n\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));\n\tji->type = MONO_PATCH_INFO_IMAGE;\n\tji->data.image = acfg->image;\n\tget_got_offset (acfg, FALSE, ji);\n\tget_got_offset (acfg, TRUE, ji);\n\n\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));\n\tji->type = MONO_PATCH_INFO_MSCORLIB_GOT_ADDR;\n\tget_got_offset (acfg, FALSE, ji);\n\tget_got_offset (acfg, TRUE, ji);\n\n\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));\n\tji->type = MONO_PATCH_INFO_GC_CARD_TABLE_ADDR;\n\tget_got_offset (acfg, FALSE, ji);\n\tget_got_offset (acfg, TRUE, ji);\n\n\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));\n\tji->type = MONO_PATCH_INFO_GC_NURSERY_START;\n\tget_got_offset (acfg, FALSE, ji);\n\tget_got_offset (acfg, TRUE, ji);\n\n\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));\n\tji->type = MONO_PATCH_INFO_AOT_MODULE;\n\tget_got_offset (acfg, FALSE, ji);\n\tget_got_offset (acfg, TRUE, ji);\n\n\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));\n\tji->type = MONO_PATCH_INFO_GC_NURSERY_BITS;\n\tget_got_offset (acfg, FALSE, ji);\n\tget_got_offset (acfg, TRUE, ji);\n\n\tfor (i = 0; i < TLS_KEY_NUM; i++) {\n\t\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));\n\t\tji->type = MONO_PATCH_INFO_GET_TLS_TRAMP;\n\t\tji->data.index = i;\n\t\tget_got_offset (acfg, FALSE, ji);\n\t\tget_got_offset (acfg, TRUE, ji);\n\n\t\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));\n\t\tji->type = MONO_PATCH_INFO_SET_TLS_TRAMP;\n\t\tji->data.index = i;\n\t\tget_got_offset (acfg, FALSE, ji);\n\t\tget_got_offset (acfg, TRUE, ji);\n\t}\n\n\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));\n\tji->type = MONO_PATCH_INFO_JIT_THREAD_ATTACH;\n\tget_got_offset (acfg, FALSE, ji);\n\tget_got_offset (acfg, TRUE, ji);\n\n\t/* Called by native-to-managed wrappers on possibly unattached threads */\n\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoJumpInfo));\n\tji->type = MONO_PATCH_INFO_JIT_ICALL_ADDR_NOCALL;\n\tji->data.name = \"mono_threads_attach_coop\";\n\tget_got_offset (acfg, FALSE, ji);\n\tget_got_offset (acfg, TRUE, ji);\n\n\tfor (i = 0; i < sizeof (preinited_jit_icalls) / sizeof (char*); ++i) {\n\t\tji = (MonoJumpInfo *)mono_mempool_alloc0 (acfg->mempool, sizeof (MonoAotCompile));\n\t\tji->type = MONO_PATCH_INFO_INTERNAL_METHOD;\n\t\tji->data.name = preinited_jit_icalls [i];\n\t\tget_got_offset (acfg, FALSE, ji);\n\t\tget_got_offset (acfg, TRUE, ji);\n\t}\n\n\tacfg->nshared_got_entries = acfg->got_offset;\n}\n\nstatic void\nmono_dedup_log_stats (MonoAotCompile *acfg)\n{\n\tGHashTableIter iter;\n\tg_assert (acfg->dedup_stats);\n\n\t// If dedup_emit_mode, acfg is the dummy dedup module that consolidates\n\t// deduped modules\n\tg_hash_table_iter_init (&iter, acfg->method_to_cfg);\n\tMonoCompile *dcfg = NULL;\n\tMonoMethod *method = NULL;\n\n\tsize_t wrappers_size_saved = 0;\n\tsize_t inflated_size_saved = 0;\n\tsize_t copied_singles = 0;\n\n\twhile (g_hash_table_iter_next (&iter, (gpointer *) &method, (gpointer *)&dcfg)) {\n\t\tgchar *dedup_name = mono_aot_get_mangled_method_name (method);\n\t\tguint count = GPOINTER_TO_UINT(g_hash_table_lookup (acfg->dedup_stats, dedup_name));\n\n\t\tif (count == 0)\n\t\t\tcontinue;\n\n\t\tif (acfg->dedup_emit_mode) {\n\t\t\t// Size *saved* is the size due to things not emitted.\n\t\t\tif (count < 2) {\n\t\t\t\t// Just moved, didn't save space / dedup\n\t\t\t\tcopied_singles += dcfg->code_len;\n\t\t\t} else if (method->wrapper_type != MONO_WRAPPER_NONE) {\n\t\t\t\twrappers_size_saved += dcfg->code_len * (count - 1);\n\t\t\t} else {\n\t\t\t\tinflated_size_saved += dcfg->code_len * (count - 1);\n\t\t\t}\n\t\t}\n\t  if (acfg->aot_opts.dedup) {\n\t\t\tif (method->wrapper_type != MONO_WRAPPER_NONE) {\n\t\t\t\twrappers_size_saved += dcfg->code_len * count;\n\t\t\t} else {\n\t\t\t\tinflated_size_saved += dcfg->code_len * count;\n\t\t\t}\n\t\t}\n\t}\n\n\taot_printf (acfg, \"Dedup Pass: Size Saved From Deduped Wrappers:\\t%zu bytes\\n\", wrappers_size_saved);\n\taot_printf (acfg, \"Dedup Pass: Size Saved From Inflated Methods:\\t%zu bytes\\n\", inflated_size_saved);\n\tif (acfg->dedup_emit_mode)\n\t\taot_printf (acfg, \"Dedup Pass: Size of Moved But Not Deduped (only 1 copy) Methods:\\t%zu bytes\\n\", copied_singles);\n\n\tg_hash_table_destroy (acfg->dedup_stats);\n\tacfg->dedup_stats = NULL;\n}\n\n// Flush the cache to tell future calls what to skip\nstatic void\nmono_flush_method_cache (MonoAotCompile *acfg)\n{\n\tGHashTable *method_cache = acfg->dedup_cache;\n\tchar *filename = g_strdup_printf (\"%s.dedup\", acfg->image->name);\n\tif (!acfg->dedup_cache_changed || !acfg->aot_opts.dedup) {\n\t\tg_free (filename);\n\t\treturn;\n\t}\n\n\tacfg->dedup_cache = NULL;\n\n\tFILE *cache = fopen (filename, \"w\");\n\n\tif (!cache)\n\t\tg_error (\"Could not create cache at %s because of error: %s\\n\", filename, strerror (errno));\n\t\n\tGHashTableIter iter;\n\tgchar *name = NULL;\n\tg_hash_table_iter_init (&iter, method_cache);\n\tgboolean cont = TRUE;\n\twhile (cont && g_hash_table_iter_next (&iter, (gpointer *) &name, NULL)) {\n\t\tint res = fprintf (cache, \"%s\\n\", name);\n\t\tcont = res >= 0;\n\t}\n\t// FIXME: don't assert if error when flushing\n\tg_assert (cont);\n\n\tfclose (cache);\n\tg_free (filename);\n\n\t// The keys are all in the imageset, nothing to free\n\t// Values are just pointers to memory owned elsewhere, or sentinels\n\tg_hash_table_destroy (method_cache);\n}\n\n// Read in what has been emitted by previous invocations,\n// what can be skipped\nstatic void\nmono_read_method_cache (MonoAotCompile *acfg)\n{\n\tchar *filename = g_strdup_printf (\"%s.dedup\", acfg->image->name);\n\t// Only do once, when dedup_cache is null\n\tif (acfg->dedup_cache)\n\t\tgoto early_exit;\n\n\tif (acfg->aot_opts.dedup_include || acfg->aot_opts.dedup)\n\t\tg_assert (acfg->dedup_stats);\n\t\n\t// only in skip mode\n\tif (!acfg->aot_opts.dedup)\n\t\tgoto early_exit;\n\n\tg_assert (acfg->dedup_cache);\n\n\tFILE *cache = fopen (filename, \"r\");\n\tif (!cache)\n\t\tgoto early_exit;\n\n\t// Since we do pointer comparisons, and it can't be allocated at\n\t// the address 0x1 due to alignment, we use this as a sentinel\n\tgpointer other_acfg_sentinel = GINT_TO_POINTER (0x1);\n\n\tif (fseek (cache, 0L, SEEK_END))\n\t\tgoto cleanup;\n\n\tsize_t fileLength = ftell (cache);\n\tg_assert (fileLength > 0);\n\n\tif (fseek (cache, 0L, SEEK_SET))\n\t\tgoto cleanup;\n\n\t// Avoid thousands of new malloc entries\n\t// FIXME: allocate into imageset, so we don't need to free.\n\t// put the other mangled names there too.\n\tchar *bulk = g_malloc0 (fileLength * sizeof (char));\n\tsize_t offset = 0;\n\n\twhile (fgets (&bulk [offset], fileLength - offset, cache)) {\n\t\t// strip newline\n\t\tchar *line = &bulk [offset];\n\t\tsize_t len = strlen (line);\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\tif (len >= 0 && line [len] == '\\n')\n\t\t\tline [len] = '\\0';\n\t\toffset += strlen (line) + 1;\n\t\tg_assert (fileLength >= offset);\n\n\t\tg_hash_table_insert (acfg->dedup_cache, line, other_acfg_sentinel);\n\t}\n\ncleanup:\n\tfclose (cache);\n\nearly_exit:\n\tg_free (filename);\n\treturn;\n}\n\ntypedef struct {\n\tGHashTable *cache;\n\tGHashTable *stats;\n\tgboolean emit_inflated_methods;\n\tMonoAssembly *inflated_assembly;\n} MonoAotState;\n\nstatic MonoAotState *\nalloc_aot_state (void) \n{\n\tMonoAotState *state = g_malloc (sizeof (MonoAotState));\n\t// FIXME: Should this own the memory?\n\tstate->cache = g_hash_table_new (g_str_hash, g_str_equal);\n\tstate->stats = g_hash_table_new (g_str_hash, g_str_equal);\n\t// Start in \"collect mode\"\n\tstate->emit_inflated_methods = FALSE;\n\tstate->inflated_assembly = NULL;\n\treturn state;\n}\n\nstatic void\nfree_aot_state (MonoAotState *astate) \n{\n\tg_hash_table_destroy (astate->cache);\n\tg_free (astate);\n}\n\nstatic void\nmono_add_deferred_extra_methods (MonoAotCompile *acfg, MonoAotState *astate)\n{\n\tGHashTableIter iter;\n\tgchar *name = NULL;\n\tMonoMethod *method = NULL;\n\n\tacfg->dedup_emit_mode = TRUE;\n\n\tg_hash_table_iter_init (&iter, astate->cache);\n\twhile (g_hash_table_iter_next (&iter, (gpointer *) &name, (gpointer *) &method)) {\n\t\tadd_method_full (acfg, method, TRUE, 0);\n\t}\n\treturn;\n}\n\nstatic void\nmono_setup_dedup_state (MonoAotCompile *acfg, MonoAotState **global_aot_state, MonoAssembly *ass, MonoAotState **astate, gboolean *is_dedup_dummy) \n{\n\tif (!acfg->aot_opts.dedup_include && !acfg->aot_opts.dedup)\n\t\treturn;\n\n\tif (global_aot_state && *global_aot_state && acfg->aot_opts.dedup_include) {\n\t// Thread the state through when making the inflate pass\n\t\t*astate = *global_aot_state;\n\t}\n\n\tif (!*astate) {\n\t\t*astate = alloc_aot_state ();\n\t\t*global_aot_state = *astate;\n\t}\n\n\tacfg->dedup_cache = (*astate)->cache;\n\tacfg->dedup_stats = (*astate)->stats;\n\n\t// fills out acfg->dedup_cache\n\tif (acfg->aot_opts.dedup)\n\t\tmono_read_method_cache (acfg);\n\n\tif (!(*astate)->inflated_assembly && acfg->aot_opts.dedup_include) {\n\t\tgchar **asm_path = g_strsplit (ass->image->name, G_DIR_SEPARATOR_S, 0);\n\t\tgchar *asm_file = NULL;\n\n\t\t// Get the last part of the path, the filename\n\t\tfor (int i=0; asm_path [i] != NULL; i++)\n\t\t\tasm_file = asm_path [i];\n\n\t\tif (!strcmp (acfg->aot_opts.dedup_include, asm_file)) {\n\t\t\t// Save\n\t\t\t*is_dedup_dummy = TRUE;\n\t\t\t(*astate)->inflated_assembly = ass;\n\t\t}\n\t\tg_strfreev (asm_path);\n\t} else if ((*astate)->inflated_assembly) {\n\t\t*is_dedup_dummy = (ass == (*astate)->inflated_assembly);\n\t}\n}\n\nint \nmono_compile_deferred_assemblies (guint32 opts, const char *aot_options, gpointer **aot_state)\n{\n\t// create assembly, loop and add extra_methods\n\t// in add_generic_instances , rip out what's in that for loop\n\t// and apply that to this aot_state inside of mono_compile_assembly\n\tMonoAotState *astate;\n\tastate = *(MonoAotState **)aot_state;\n\tg_assert (astate);\n\n\t// FIXME: allow suffixes?\n\tif (!astate->inflated_assembly) {\n\t\tchar *inflate = strstr (aot_options, \"dedup-inflate\");\n\t\tif (!inflate)\n\t\t\treturn 0;\n\t\telse \n\t\t\tg_error (\"Error: mono was not given an assembly with the provided inflate name\\n\");\n\t}\n\n\t// Switch modes\n\tastate->emit_inflated_methods = TRUE;\n\n\tint res = mono_compile_assembly (astate->inflated_assembly, opts, aot_options, aot_state);\n\n\t*aot_state = NULL;\n\tfree_aot_state (astate);\n\n\treturn res;\n}\n\nstatic const char* interp_in_static_sigs[] = {\n\t\"bool ptr int32 ptr&\",\n\t\"bool ptr ptr&\",\n\t\"int32 int32 ptr&\",\n\t\"int32 int32 ptr ptr&\",\n\t\"int32 ptr int32 ptr\",\n\t\"int32 ptr int32 ptr&\",\n\t\"int32 ptr ptr&\",\n\t\"object object ptr ptr ptr\",\n\t\"ptr int32 ptr&\",\n\t\"ptr ptr int32 ptr ptr ptr&\",\n\t\"ptr ptr int32 ptr ptr&\",\n\t\"ptr ptr int32 ptr&\",\n\t\"ptr ptr ptr int32 ptr&\",\n\t\"ptr ptr ptr ptr& ptr&\",\n\t\"ptr ptr ptr ptr&\",\n\t\"ptr ptr ptr&\",\n\t\"ptr ptr uint32 ptr&\",\n\t\"ptr uint32 ptr&\",\n\t\"void object ptr ptr ptr\",\n\t\"void ptr ptr int32 ptr ptr& ptr ptr&\",\n\t\"void ptr ptr int32 ptr ptr&\",\n\t\"void ptr ptr ptr&\",\n\t\"void ptr ptr&\",\n\t\"void ptr\",\n\t\"void int32 ptr&\",\n\t\"void uint32 ptr&\",\n};\n\nint\nmono_compile_assembly (MonoAssembly *ass, guint32 opts, const char *aot_options, gpointer **global_aot_state)\n{\n\tMonoImage *image = ass->image;\n\tint i, res;\n\tgint64 all_sizes;\n\tMonoAotCompile *acfg;\n\tchar *outfile_name, *tmp_outfile_name, *p;\n\tchar llvm_stats_msg [256];\n\tTV_DECLARE (atv);\n\tTV_DECLARE (btv);\n\n\tacfg = acfg_create (ass, opts);\n\n\tmemset (&acfg->aot_opts, 0, sizeof (acfg->aot_opts));\n\tacfg->aot_opts.write_symbols = TRUE;\n\tacfg->aot_opts.ntrampolines = 4096;\n\tacfg->aot_opts.nrgctx_trampolines = 4096;\n\tacfg->aot_opts.nimt_trampolines = 512;\n\tacfg->aot_opts.nrgctx_fetch_trampolines = 128;\n\tacfg->aot_opts.ngsharedvt_arg_trampolines = 512;\n\tacfg->aot_opts.llvm_path = g_strdup (\"\");\n\tacfg->aot_opts.temp_path = g_strdup (\"\");\n#ifdef MONOTOUCH\n\tacfg->aot_opts.use_trampolines_page = TRUE;\n#endif\n\n\tmono_aot_parse_options (aot_options, &acfg->aot_opts);\n\n\t// start dedup\n\tMonoAotState *astate = NULL;\n\tgboolean is_dedup_dummy = FALSE;\n\tmono_setup_dedup_state (acfg, (MonoAotState **) global_aot_state, ass, &astate, &is_dedup_dummy);\n\n\t// Process later\n\tif (is_dedup_dummy && astate && !astate->emit_inflated_methods)\n\t\treturn 0; \n\n\t// end dedup\n\n\tif (acfg->aot_opts.logfile) {\n\t\tacfg->logfile = fopen (acfg->aot_opts.logfile, \"a+\");\n\t}\n\n\tif (acfg->aot_opts.data_outfile) {\n\t\tacfg->data_outfile = fopen (acfg->aot_opts.data_outfile, \"w+\");\n\t\tif (!acfg->data_outfile) {\n\t\t\taot_printerrf (acfg, \"Unable to create file '%s': %s\\n\", acfg->aot_opts.data_outfile, strerror (errno));\n\t\t\treturn 1;\n\t\t}\n\t\tacfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_SEPARATE_DATA);\n\t}\n\n\t//acfg->aot_opts.print_skipped_methods = TRUE;\n\n#if !defined(MONO_ARCH_GSHAREDVT_SUPPORTED)\n\tif (acfg->opts & MONO_OPT_GSHAREDVT) {\n\t\taot_printerrf (acfg, \"-O=gsharedvt not supported on this platform.\\n\");\n\t\treturn 1;\n\t}\n\tif (acfg->aot_opts.llvm_only) {\n\t\taot_printerrf (acfg, \"--aot=llvmonly requires a runtime that supports gsharedvt.\\n\");\n\t\treturn 1;\n\t}\n#else\n\tif (acfg->aot_opts.llvm_only || mono_aot_mode_is_full (&acfg->aot_opts) || mono_aot_mode_is_hybrid (&acfg->aot_opts))\n\t\tacfg->opts |= MONO_OPT_GSHAREDVT;\n#endif\n\n#if !defined(ENABLE_LLVM)\n\tif (acfg->aot_opts.llvm_only) {\n\t\taot_printerrf (acfg, \"--aot=llvmonly requires a runtime compiled with llvm support.\\n\");\n\t\treturn 1;\n\t}\n#endif\n\n\tif (acfg->opts & MONO_OPT_GSHAREDVT)\n\t\tmono_set_generic_sharing_vt_supported (TRUE);\n\n\taot_printf (acfg, \"Mono Ahead of Time compiler - compiling assembly %s\\n\", image->name);\n\n\tgenerate_aotid ((guint8*) &acfg->image->aotid);\n\n\tchar *aotid = mono_guid_to_string (acfg->image->aotid);\n\taot_printf (acfg, \"AOTID %s\\n\", aotid);\n\tg_free (aotid);\n\n#ifndef MONO_ARCH_HAVE_FULL_AOT_TRAMPOLINES\n\tif (mono_aot_mode_is_full (&acfg->aot_opts)) {\n\t\taot_printerrf (acfg, \"--aot=full is not supported on this platform.\\n\");\n\t\treturn 1;\n\t}\n#endif\n\n\tif (acfg->aot_opts.direct_pinvoke && !acfg->aot_opts.static_link) {\n\t\taot_printerrf (acfg, \"The 'direct-pinvoke' AOT option also requires the 'static' AOT option.\\n\");\n\t\treturn 1;\n\t}\n\n\tif (acfg->aot_opts.static_link)\n\t\tacfg->aot_opts.asm_writer = TRUE;\n\n\tif (acfg->aot_opts.soft_debug) {\n\t\tMonoDebugOptions *opt = mini_get_debug_options ();\n\n\t\topt->mdb_optimizations = TRUE;\n\t\topt->gen_sdb_seq_points = TRUE;\n\n\t\tif (!mono_debug_enabled ()) {\n\t\t\taot_printerrf (acfg, \"The soft-debug AOT option requires the --debug option.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tacfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_DEBUG);\n\t}\n\n\tif (mono_use_llvm || acfg->aot_opts.llvm) {\n\t\tacfg->llvm = TRUE;\n\t\tacfg->aot_opts.asm_writer = TRUE;\n\t\tacfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_WITH_LLVM);\n\n\t\tif (acfg->aot_opts.soft_debug) {\n\t\t\taot_printerrf (acfg, \"The 'soft-debug' option is not supported when compiling with LLVM.\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tmini_llvm_init ();\n\n\t\tif (acfg->aot_opts.asm_only && !acfg->aot_opts.llvm_outfile) {\n\t\t\taot_printerrf (acfg, \"Compiling with LLVM and the asm-only option requires the llvm-outfile= option.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (mono_aot_mode_is_full (&acfg->aot_opts)) {\n\t\tacfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_FULL_AOT);\n\t\tacfg->is_full_aot = TRUE;\n\t}\n\n\tif (mono_threads_is_coop_enabled ())\n\t\tacfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_SAFEPOINTS);\n\n\t// The methods in dedup-emit amodules must be available on runtime startup\n\t// Note: Only one such amodule can have this attribute\n\tif (astate && astate->emit_inflated_methods)\n\t\tacfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_EAGER_LOAD);\n\n\n\tif (acfg->aot_opts.instances_logfile_path) {\n\t\tacfg->instances_logfile = fopen (acfg->aot_opts.instances_logfile_path, \"w\");\n\t\tif (!acfg->instances_logfile) {\n\t\t\taot_printerrf (acfg, \"Unable to create logfile: '%s'.\\n\", acfg->aot_opts.instances_logfile_path);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (acfg->aot_opts.profile_files) {\n\t\tGList *l;\n\n\t\tfor (l = acfg->aot_opts.profile_files; l; l = l->next) {\n\t\t\tload_profile_file (acfg, (char*)l->data);\n\t\t}\n\t}\n\n\tif (!mono_aot_mode_is_interp (&acfg->aot_opts)) {\n\t\tint method_index;\n\n       for (method_index = 0; method_index < acfg->image->tables [MONO_TABLE_METHOD].rows; ++method_index) {\n\t\t   g_ptr_array_add (acfg->method_order,GUINT_TO_POINTER (method_index));\n       }\n\t}\n\n\tacfg->num_trampolines [MONO_AOT_TRAMP_SPECIFIC] = mono_aot_mode_is_full (&acfg->aot_opts) ? acfg->aot_opts.ntrampolines : 0;\n#ifdef MONO_ARCH_GSHARED_SUPPORTED\n\tacfg->num_trampolines [MONO_AOT_TRAMP_STATIC_RGCTX] = mono_aot_mode_is_full (&acfg->aot_opts) ? acfg->aot_opts.nrgctx_trampolines : 0;\n#endif\n\tacfg->num_trampolines [MONO_AOT_TRAMP_IMT] = mono_aot_mode_is_full (&acfg->aot_opts) ? acfg->aot_opts.nimt_trampolines : 0;\n#ifdef MONO_ARCH_GSHAREDVT_SUPPORTED\n\tif (acfg->opts & MONO_OPT_GSHAREDVT)\n\t\tacfg->num_trampolines [MONO_AOT_TRAMP_GSHAREDVT_ARG] = mono_aot_mode_is_full (&acfg->aot_opts) ? acfg->aot_opts.ngsharedvt_arg_trampolines : 0;\n#endif\n\n\tacfg->temp_prefix = mono_img_writer_get_temp_label_prefix (NULL);\n\n\tarch_init (acfg);\n\n\tif (mono_use_llvm || acfg->aot_opts.llvm) {\n\n\t\t/*\n\t\t * Emit all LLVM code into a separate assembly/object file and link with it\n\t\t * normally.\n\t\t */\n\t\tif (!acfg->aot_opts.asm_only && acfg->llvm_owriter_supported) {\n\t\t\tacfg->llvm_owriter = TRUE;\n\t\t} else if (acfg->aot_opts.llvm_outfile) {\n\t\t\tint len = strlen (acfg->aot_opts.llvm_outfile);\n\n\t\t\tif (len >= 2 && acfg->aot_opts.llvm_outfile [len - 2] == '.' && acfg->aot_opts.llvm_outfile [len - 1] == 'o')\n\t\t\t\tacfg->llvm_owriter = TRUE;\n\t\t}\n\t}\n\n\tif (acfg->llvm && acfg->thumb_mixed)\n\t\tacfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_LLVM_THUMB);\n\tif (acfg->aot_opts.llvm_only)\n\t\tacfg->flags = (MonoAotFileFlags)(acfg->flags | MONO_AOT_FILE_FLAG_LLVM_ONLY);\n\n\tacfg->assembly_name_sym = g_strdup (acfg->image->assembly->aname.name);\n\t/* Get rid of characters which cannot occur in symbols */\n\tfor (p = acfg->assembly_name_sym; *p; ++p) {\n\t\tif (!(isalnum (*p) || *p == '_'))\n\t\t\t*p = '_';\n\t}\n\n\tacfg->global_prefix = g_strdup_printf (\"mono_aot_%s\", acfg->assembly_name_sym);\n\tacfg->plt_symbol = g_strdup_printf (\"%s_plt\", acfg->global_prefix);\n\tacfg->got_symbol = g_strdup_printf (\"%s_got\", acfg->global_prefix);\n \tif (acfg->llvm) {\n\t\tacfg->llvm_got_symbol = g_strdup_printf (\"%s_llvm_got\", acfg->global_prefix);\n\t\tacfg->llvm_eh_frame_symbol = g_strdup_printf (\"%s_eh_frame\", acfg->global_prefix);\n\t}\n\n\tacfg->method_index = 1;\n\n\tif (mono_aot_mode_is_full (&acfg->aot_opts) || mono_aot_mode_is_hybrid (&acfg->aot_opts))\n\t\tmono_set_partial_sharing_supported (TRUE);\n\n\tif (!mono_aot_mode_is_interp (&acfg->aot_opts)) {\n\t\tres = collect_methods (acfg);\n\n\t\tif (!res)\n\t\t\treturn 1;\n\t}\n\n\t// If we're emitting all of the inflated methods into a dummy\n\t// Assembly, then after extra_methods is set up, we're done\n\t// in this function.\n\tif (astate && astate->emit_inflated_methods)\n\t\tmono_add_deferred_extra_methods (acfg, astate);\n\n\t{\n\t\tGList *l;\n\n\t\tfor (l = acfg->profile_data; l; l = l->next)\n\t\t\tresolve_profile_data (acfg, (ProfileData*)l->data);\n\t\tfor (l = acfg->profile_data; l; l = l->next)\n\t\t\tadd_profile_instances (acfg, (ProfileData*)l->data);\n\t}\n\n\tacfg->cfgs_size = acfg->methods->len + 32;\n\tacfg->cfgs = g_new0 (MonoCompile*, acfg->cfgs_size);\n\n\t/* PLT offset 0 is reserved for the PLT trampoline */\n\tacfg->plt_offset = 1;\n\tadd_preinit_got_slots (acfg);\n\n#ifdef ENABLE_LLVM\n\tif (acfg->llvm) {\n\t\tllvm_acfg = acfg;\n\t\tmono_llvm_create_aot_module (acfg->image->assembly, acfg->global_prefix, acfg->nshared_got_entries, TRUE, acfg->aot_opts.static_link, acfg->aot_opts.llvm_only);\n\t}\n#endif\n\n\tif (mono_aot_mode_is_interp (&acfg->aot_opts)) {\n\t\tfor (int i = 0; i < sizeof (interp_in_static_sigs) / sizeof (const char *); i++) {\n\t\t\tMonoMethodSignature *sig = mono_create_icall_signature (interp_in_static_sigs [i]);\n\t\t\tMonoMethod *wrapper = mini_get_interp_in_wrapper (sig);\n\t\t\tadd_method (acfg, wrapper);\n\t\t}\n\t}\n\n\tTV_GETTIME (atv);\n\n\tcompile_methods (acfg);\n\n\tTV_GETTIME (btv);\n\n\tacfg->stats.jit_time = TV_ELAPSED (atv, btv);\n\n\tTV_GETTIME (atv);\n\n#ifdef ENABLE_LLVM\n\tif (acfg->llvm) {\n\t\tif (acfg->aot_opts.asm_only) {\n\t\t\tif (acfg->aot_opts.outfile) {\n\t\t\t\tacfg->tmpfname = g_strdup_printf (\"%s\", acfg->aot_opts.outfile);\n\t\t\t\tacfg->tmpbasename = g_strdup (acfg->tmpfname);\n\t\t\t} else {\n\t\t\t\tacfg->tmpbasename = g_strdup_printf (\"%s\", acfg->image->name);\n\t\t\t\tacfg->tmpfname = g_strdup_printf (\"%s.s\", acfg->tmpbasename);\n\t\t\t}\n\t\t\tg_assert (acfg->aot_opts.llvm_outfile);\n\t\t\tacfg->llvm_sfile = g_strdup (acfg->aot_opts.llvm_outfile);\n\t\t\tif (acfg->llvm_owriter)\n\t\t\t\tacfg->llvm_ofile = g_strdup (acfg->aot_opts.llvm_outfile);\n\t\t\telse\n\t\t\t\tacfg->llvm_sfile = g_strdup (acfg->aot_opts.llvm_outfile);\n\t\t} else {\n\t\t\tacfg->tmpbasename = (strcmp (acfg->aot_opts.temp_path, \"\") == 0) ?\n\t\t\t\tg_strdup_printf (\"%s\", \"temp\") :\n\t\t\t\tg_build_filename (acfg->aot_opts.temp_path, \"temp\", NULL);\n\t\t\t\t\n\t\t\tacfg->tmpfname = g_strdup_printf (\"%s.s\", acfg->tmpbasename);\n\t\t\tacfg->llvm_sfile = g_strdup_printf (\"%s-llvm.s\", acfg->tmpbasename);\n\t\t\tacfg->llvm_ofile = g_strdup_printf (\"%s-llvm.o\", acfg->tmpbasename);\n\t\t}\n\t}\n#endif\n\n\tif (acfg->aot_opts.asm_only && !acfg->aot_opts.llvm_only) {\n\t\tif (acfg->aot_opts.outfile)\n\t\t\tacfg->tmpfname = g_strdup_printf (\"%s\", acfg->aot_opts.outfile);\n\t\telse\n\t\t\tacfg->tmpfname = g_strdup_printf (\"%s.s\", acfg->image->name);\n\t\tacfg->fp = fopen (acfg->tmpfname, \"w+\");\n\t} else {\n\t\tif (strcmp (acfg->aot_opts.temp_path, \"\") == 0) {\n\t\t\tint i = g_file_open_tmp (\"mono_aot_XXXXXX\", &acfg->tmpfname, NULL);\n\t\t\tacfg->fp = fdopen (i, \"w+\");\n\t\t} else {\n\t\t\tacfg->tmpbasename = g_build_filename (acfg->aot_opts.temp_path, \"temp\", NULL);\n\t\t\tacfg->tmpfname = g_strdup_printf (\"%s.s\", acfg->tmpbasename);\n\t\t\tacfg->fp = fopen (acfg->tmpfname, \"w+\");\n\t\t}\n\t}\n\tif (acfg->fp == 0 && !acfg->aot_opts.llvm_only) {\n\t\taot_printerrf (acfg, \"Unable to open file '%s': %s\\n\", acfg->tmpfname, strerror (errno));\n\t\treturn 1;\n\t}\n\tif (acfg->fp)\n\t\tacfg->w = mono_img_writer_create (acfg->fp, FALSE);\n\n\ttmp_outfile_name = NULL;\n\toutfile_name = NULL;\n\n\t/* Compute symbols for methods */\n\tfor (i = 0; i < acfg->nmethods; ++i) {\n\t\tif (acfg->cfgs [i]) {\n\t\t\tMonoCompile *cfg = acfg->cfgs [i];\n\t\t\tint method_index = get_method_index (acfg, cfg->orig_method);\n\n\t\t\tif (COMPILE_LLVM (cfg))\n\t\t\t\tcfg->asm_symbol = g_strdup_printf (\"%s%s\", acfg->llvm_label_prefix, cfg->llvm_method_name);\n\t\t\telse if (acfg->global_symbols || acfg->llvm)\n\t\t\t\tcfg->asm_symbol = get_debug_sym (cfg->orig_method, \"\", acfg->method_label_hash);\n\t\t\telse\n\t\t\t\tcfg->asm_symbol = g_strdup_printf (\"%s%sm_%x\", acfg->temp_prefix, acfg->llvm_label_prefix, method_index);\n\t\t\tcfg->asm_debug_symbol = cfg->asm_symbol;\n\t\t}\n\t}\n\n\tif (acfg->aot_opts.dwarf_debug && acfg->aot_opts.gnu_asm) {\n\t\t/*\n\t\t * CLANG supports GAS .file/.loc directives, so emit line number information this way\n\t\t */\n\t\tacfg->gas_line_numbers = TRUE;\n\t}\n\n#ifdef EMIT_DWARF_INFO\n\tif ((!acfg->aot_opts.nodebug || acfg->aot_opts.dwarf_debug) && acfg->has_jitted_code) {\n\t\tif (acfg->aot_opts.dwarf_debug && !mono_debug_enabled ()) {\n\t\t\taot_printerrf (acfg, \"The dwarf AOT option requires the --debug option.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tacfg->dwarf = mono_dwarf_writer_create (acfg->w, NULL, 0, !acfg->gas_line_numbers);\n\t}\n#endif /* EMIT_DWARF_INFO */\n\n\tif (acfg->w)\n\t\tmono_img_writer_emit_start (acfg->w);\n\n\tif (acfg->dwarf)\n\t\tmono_dwarf_writer_emit_base_info (acfg->dwarf, g_path_get_basename (acfg->image->name), mono_unwind_get_cie_program ());\n\n\temit_code (acfg);\n\tif (acfg->aot_opts.dedup)\n\t\tmono_flush_method_cache (acfg);\n\tif (acfg->aot_opts.dedup || acfg->dedup_emit_mode)\n\t\tmono_dedup_log_stats (acfg);\n\n\temit_info (acfg);\n\n\temit_extra_methods (acfg);\n\n\tif (acfg->aot_opts.dedup_include && !is_dedup_dummy)\n\t\treturn 0;\n\n\temit_trampolines (acfg);\n\n\temit_class_name_table (acfg);\n\n\temit_got_info (acfg, FALSE);\n\tif (acfg->llvm)\n\t\temit_got_info (acfg, TRUE);\n\n\temit_exception_info (acfg);\n\n\temit_unwind_info (acfg);\n\n\temit_class_info (acfg);\n\n\temit_plt (acfg);\n\n\temit_image_table (acfg);\n\n\temit_weak_field_indexes (acfg);\n\n\temit_got (acfg);\n\n\t{\n\t\t/*\n\t\t * The managed allocators are GC specific, so can't use an AOT image created by one GC\n\t\t * in another.\n\t\t */\n\t\tconst char *gc_name = mono_gc_get_gc_name ();\n\t\tacfg->gc_name_offset = add_to_blob (acfg, (guint8*)gc_name, strlen (gc_name) + 1);\n\t}\n\n\temit_blob (acfg);\n\n\temit_objc_selectors (acfg);\n\n\temit_globals (acfg);\n\n\temit_file_info (acfg);\n\n\temit_library_info (acfg);\n\n\tif (acfg->dwarf) {\n\t\temit_dwarf_info (acfg);\n\t\tmono_dwarf_writer_close (acfg->dwarf);\n\t} else {\n\t\tif (!acfg->aot_opts.nodebug)\n\t\t\temit_codeview_info (acfg);\n\t}\n\n\temit_mem_end (acfg);\n\n\tif (acfg->need_pt_gnu_stack) {\n\t\t/* This is required so the .so doesn't have an executable stack */\n\t\t/* The bin writer already emits this */\n\t\tfprintf (acfg->fp, \"\\n.section\t.note.GNU-stack,\\\"\\\",@progbits\\n\");\n\t}\n\n\tif (acfg->aot_opts.data_outfile)\n\t\tfclose (acfg->data_outfile);\n\n#ifdef ENABLE_LLVM\n\tif (acfg->llvm) {\n\t\tgboolean res;\n\n\t\tres = emit_llvm_file (acfg);\n\t\tif (!res)\n\t\t\treturn 1;\n\t}\n#endif\n\n\tTV_GETTIME (btv);\n\n\tacfg->stats.gen_time = TV_ELAPSED (atv, btv);\n\n\tif (acfg->llvm)\n\t\tsprintf (llvm_stats_msg, \", LLVM: %d (%d%%)\", acfg->stats.llvm_count, acfg->stats.mcount ? (acfg->stats.llvm_count * 100) / acfg->stats.mcount : 100);\n\telse\n\t\tstrcpy (llvm_stats_msg, \"\");\n\n\tall_sizes = acfg->stats.code_size + acfg->stats.info_size + acfg->stats.ex_info_size + acfg->stats.unwind_info_size + acfg->stats.class_info_size + acfg->stats.got_info_size + acfg->stats.offsets_size + acfg->stats.plt_size;\n\n\taot_printf (acfg, \"Code: %d(%d%%) Info: %d(%d%%) Ex Info: %d(%d%%) Unwind Info: %d(%d%%) Class Info: %d(%d%%) PLT: %d(%d%%) GOT Info: %d(%d%%) Offsets: %d(%d%%) GOT: %d\\n\",\n\t\t\t\t(int)acfg->stats.code_size, (int)(acfg->stats.code_size * 100 / all_sizes),\n\t\t\t\t(int)acfg->stats.info_size, (int)(acfg->stats.info_size * 100 / all_sizes),\n\t\t\t\t(int)acfg->stats.ex_info_size, (int)(acfg->stats.ex_info_size * 100 / all_sizes),\n\t\t\t\t(int)acfg->stats.unwind_info_size, (int)(acfg->stats.unwind_info_size * 100 / all_sizes),\n\t\t\t\t(int)acfg->stats.class_info_size, (int)(acfg->stats.class_info_size * 100 / all_sizes),\n\t\t\t\tacfg->stats.plt_size ? (int)acfg->stats.plt_size : (int)acfg->plt_offset, acfg->stats.plt_size ? (int)(acfg->stats.plt_size * 100 / all_sizes) : 0,\n\t\t\t\t(int)acfg->stats.got_info_size, (int)(acfg->stats.got_info_size * 100 / all_sizes),\n\t\t\t\t(int)acfg->stats.offsets_size, (int)(acfg->stats.offsets_size * 100 / all_sizes),\n\t\t\t(int)(acfg->got_offset * sizeof (gpointer)));\n\taot_printf (acfg, \"Compiled: %d/%d (%d%%)%s, No GOT slots: %d (%d%%), Direct calls: %d (%d%%)\\n\", \n\t\t\tacfg->stats.ccount, acfg->stats.mcount, acfg->stats.mcount ? (acfg->stats.ccount * 100) / acfg->stats.mcount : 100,\n\t\t\tllvm_stats_msg,\n\t\t\tacfg->stats.methods_without_got_slots, acfg->stats.mcount ? (acfg->stats.methods_without_got_slots * 100) / acfg->stats.mcount : 100,\n\t\t\tacfg->stats.direct_calls, acfg->stats.all_calls ? (acfg->stats.direct_calls * 100) / acfg->stats.all_calls : 100);\n\tif (acfg->stats.genericcount)\n\t\taot_printf (acfg, \"%d methods are generic (%d%%)\\n\", acfg->stats.genericcount, acfg->stats.mcount ? (acfg->stats.genericcount * 100) / acfg->stats.mcount : 100);\n\tif (acfg->stats.abscount)\n\t\taot_printf (acfg, \"%d methods contain absolute addresses (%d%%)\\n\", acfg->stats.abscount, acfg->stats.mcount ? (acfg->stats.abscount * 100) / acfg->stats.mcount : 100);\n\tif (acfg->stats.lmfcount)\n\t\taot_printf (acfg, \"%d methods contain lmf pointers (%d%%)\\n\", acfg->stats.lmfcount, acfg->stats.mcount ? (acfg->stats.lmfcount * 100) / acfg->stats.mcount : 100);\n\tif (acfg->stats.ocount)\n\t\taot_printf (acfg, \"%d methods have other problems (%d%%)\\n\", acfg->stats.ocount, acfg->stats.mcount ? (acfg->stats.ocount * 100) / acfg->stats.mcount : 100);\n\n\tTV_GETTIME (atv);\n\tif (acfg->w) {\n\t\tres = mono_img_writer_emit_writeout (acfg->w);\n\t\tif (res != 0) {\n\t\t\tacfg_free (acfg);\n\t\t\treturn res;\n\t\t}\n\t\tres = compile_asm (acfg);\n\t\tif (res != 0) {\n\t\t\tacfg_free (acfg);\n\t\t\treturn res;\n\t\t}\n\t}\n\tTV_GETTIME (btv);\n\tacfg->stats.link_time = TV_ELAPSED (atv, btv);\n\n\tif (acfg->aot_opts.stats) {\n\t\tint i;\n\n\t\taot_printf (acfg, \"GOT slot distribution:\\n\");\n\t\tfor (i = 0; i < MONO_PATCH_INFO_NUM; ++i)\n\t\t\tif (acfg->stats.got_slot_types [i])\n\t\t\t\taot_printf (acfg, \"\\t%s: %d (%d)\\n\", get_patch_name (i), acfg->stats.got_slot_types [i], acfg->stats.got_slot_info_sizes [i]);\n\t\taot_printf (acfg, \"\\nMethod stats:\\n\");\n\t\taot_printf (acfg, \"\\tNormal:    %d\\n\", acfg->stats.method_categories [METHOD_CAT_NORMAL]);\n\t\taot_printf (acfg, \"\\tInstance:  %d\\n\", acfg->stats.method_categories [METHOD_CAT_INST]);\n\t\taot_printf (acfg, \"\\tGSharedvt: %d\\n\", acfg->stats.method_categories [METHOD_CAT_GSHAREDVT]);\n\t\taot_printf (acfg, \"\\tWrapper:   %d\\n\", acfg->stats.method_categories [METHOD_CAT_WRAPPER]);\n\t}\n\n\taot_printf (acfg, \"JIT time: %d ms, Generation time: %d ms, Assembly+Link time: %d ms.\\n\", acfg->stats.jit_time / 1000, acfg->stats.gen_time / 1000, acfg->stats.link_time / 1000);\n\n\tif (acfg->aot_opts.dump_json)\n\t\taot_dump (acfg);\n\n\tacfg_free (acfg);\n\t\n\treturn 0;\n}\n\n#else\n\n/* AOT disabled */\n\nvoid*\nmono_aot_readonly_field_override (MonoClassField *field)\n{\n\treturn NULL;\n}\n\nint\nmono_compile_assembly (MonoAssembly *ass, guint32 opts, const char *aot_options, gpointer **aot_state)\n{\n\treturn 0;\n}\n\ngboolean\nmono_aot_is_shared_got_offset (int offset)\n{\n\treturn FALSE;\n}\n\nint\nmono_compile_deferred_assemblies (guint32 opts, const char *aot_options, gpointer **aot_state)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mono/mini/llvm-jit.cpp": "//\n// jit-llvm.cpp: Support code for using LLVM as a JIT backend\n//\n// (C) 2009-2011 Novell, Inc.\n// Copyright 2011-2015 Xamarin, Inc (http://www.xamarin.com)\n//\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n//\n// Mono's internal header files are not C++ clean, so avoid including them if \n// possible\n//\n\n#include \"config.h\"\n\n#include <llvm-c/Core.h>\n#include <llvm-c/ExecutionEngine.h>\n\n#include \"mini-llvm-cpp.h\"\n#include \"llvm-jit.h\"\n\n#if !defined(MONO_CROSS_COMPILE) && LLVM_API_VERSION > 100\n\n/*\n * LLVM 3.9 uses the OrcJIT APIs\n */\n\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Support/Host.h>\n#include <llvm/Support/TargetSelect.h>\n#include <llvm/IR/Mangler.h>\n#include <llvm/ExecutionEngine/ExecutionEngine.h>\n#include \"llvm/ExecutionEngine/Orc/CompileUtils.h\"\n#include \"llvm/ExecutionEngine/Orc/IRCompileLayer.h\"\n#include \"llvm/ExecutionEngine/Orc/LambdaResolver.h\"\n#if LLVM_API_VERSION >= 500\n#include \"llvm/ExecutionEngine/RTDyldMemoryManager.h\"\n#include \"llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h\"\n#include \"llvm/ExecutionEngine/JITSymbol.h\"\n#else\n#include \"llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h\"\n#endif\n\n#include <cstdlib>\n\nextern \"C\" {\n#include <mono/utils/mono-dl.h>\n}\n\nusing namespace llvm;\nusing namespace llvm::orc;\n\nextern cl::opt<bool> EnableMonoEH;\nextern cl::opt<std::string> MonoEHFrameSymbol;\n\nvoid\nmono_llvm_set_unhandled_exception_handler (void)\n{\n}\n\ntemplate <typename T>\nstatic std::vector<T> singletonSet(T t) {\n  std::vector<T> Vec;\n  Vec.push_back(std::move(t));\n  return Vec;\n}\n\n#ifdef __MINGW32__\n\n#include <stddef.h>\nextern void *memset(void *, int, size_t);\nvoid bzero (void *to, size_t count) { memset (to, 0, count); }\n\n#endif\n\nstatic AllocCodeMemoryCb *alloc_code_mem_cb;\n\nclass MonoJitMemoryManager : public RTDyldMemoryManager\n{\npublic:\n\t~MonoJitMemoryManager() override;\n\n\tuint8_t *allocateDataSection(uintptr_t Size,\n\t\t\t\t\t\t\t\t unsigned Alignment,\n\t\t\t\t\t\t\t\t unsigned SectionID,\n\t\t\t\t\t\t\t\t StringRef SectionName,\n\t\t\t\t\t\t\t\t bool IsReadOnly) override;\n\n\tuint8_t *allocateCodeSection(uintptr_t Size,\n\t\t\t\t\t\t\t\t unsigned Alignment,\n\t\t\t\t\t\t\t\t unsigned SectionID,\n\t\t\t\t\t\t\t\t StringRef SectionName) override;\n\n\tbool finalizeMemory(std::string *ErrMsg = nullptr) override;\n};\n\nMonoJitMemoryManager::~MonoJitMemoryManager()\n{\n}\n\nuint8_t *\nMonoJitMemoryManager::allocateDataSection(uintptr_t Size,\n\t\t\t\t\t\t\t\t\t\t  unsigned Alignment,\n\t\t\t\t\t\t\t\t\t\t  unsigned SectionID,\n\t\t\t\t\t\t\t\t\t\t  StringRef SectionName,\n\t\t\t\t\t\t\t\t\t\t  bool IsReadOnly) {\n\tuint8_t *res = (uint8_t*)malloc (Size);\n\tassert (res);\n\tmemset (res, 0, Size);\n\treturn res;\n}\n\nuint8_t *\nMonoJitMemoryManager::allocateCodeSection(uintptr_t Size,\n\t\t\t\t\t\t\t\t\t\t  unsigned Alignment,\n\t\t\t\t\t\t\t\t\t\t  unsigned SectionID,\n\t\t\t\t\t\t\t\t\t\t  StringRef SectionName)\n{\n\treturn alloc_code_mem_cb (NULL, Size);\n}\n\nbool\nMonoJitMemoryManager::finalizeMemory(std::string *ErrMsg)\n{\n\treturn false;\n}\n\nclass MonoLLVMJIT {\npublic:\n\t/* We use our own trampoline infrastructure instead of the Orc one */\n#if LLVM_API_VERSION >= 500\n\ttypedef RTDyldObjectLinkingLayer ObjLayerT;\n\ttypedef IRCompileLayer<ObjLayerT, SimpleCompiler> CompileLayerT;\n\ttypedef CompileLayerT::ModuleHandleT ModuleHandleT;\n#else\n\ttypedef ObjectLinkingLayer<> ObjLayerT;\n\ttypedef IRCompileLayer<ObjLayerT> CompileLayerT;\n\ttypedef CompileLayerT::ModuleSetHandleT ModuleHandleT;\n#endif\n\n\tMonoLLVMJIT (TargetMachine *TM, MonoJitMemoryManager *mm)\n#if LLVM_API_VERSION >= 500\n\t\t: TM(TM), ObjectLayer([=] { return std::shared_ptr<RuntimeDyld::MemoryManager> (mm); }),\n#else\n\t\t: TM(TM),\n#endif\n\t\t  CompileLayer (ObjectLayer, SimpleCompiler (*TM)),\n\t\t  modules() {\n\t}\n\n#if LLVM_API_VERSION >= 500\n\tModuleHandleT addModule(Function *F, std::shared_ptr<Module> M) {\n#else\n\tModuleHandleT addModule(Function *F, Module *M) {\n#endif\n\t\tauto Resolver = createLambdaResolver(\n                      [&](const std::string &Name) {\n\t\t\t\t\t\t  const char *name = Name.c_str ();\n#if LLVM_API_VERSION >= 500\n\t\t\t\t\t\t  JITSymbolFlags flags = JITSymbolFlags ();\n#else\n\t\t\t\t\t\t  JITSymbolFlags flags = (JITSymbolFlags)0;\n#endif\n\t\t\t\t\t\t  if (!strcmp (name, \"___bzero\")) {\n#if LLVM_API_VERSION >= 500\n\t\t\t\t\t\t\t  return JITSymbol((uint64_t)(gssize)(void*)bzero, flags);\n#else\n\t\t\t\t\t\t\t  return RuntimeDyld::SymbolInfo((uint64_t)(gssize)(void*)bzero, flags);\n#endif\n\t\t\t\t\t\t  }\n\n\t\t\t\t\t\t  MonoDl *current;\n\t\t\t\t\t\t  char *err;\n\t\t\t\t\t\t  void *symbol;\n\t\t\t\t\t\t  current = mono_dl_open (NULL, 0, NULL);\n\t\t\t\t\t\t  g_assert (current);\n\t\t\t\t\t\t  if (name [0] == '_')\n\t\t\t\t\t\t\t  err = mono_dl_symbol (current, name + 1, &symbol);\n\t\t\t\t\t\t  else\n\t\t\t\t\t\t\t  err = mono_dl_symbol (current, name, &symbol);\n\t\t\t\t\t\t  mono_dl_close (current);\n\t\t\t\t\t\t  if (!symbol)\n\t\t\t\t\t\t\t  outs () << \"R: \" << Name << \"\\n\";\n\t\t\t\t\t\t  assert (symbol);\n#if LLVM_API_VERSION >= 500\n\t\t\t\t\t\t  return JITSymbol((uint64_t)(gssize)symbol, flags);\n#else\n\t\t\t\t\t\t  return RuntimeDyld::SymbolInfo((uint64_t)(gssize)symbol, flags);\n#endif\n                      },\n                      [](const std::string &S) {\n\t\t\t\t\t\t  outs () << \"R2: \" << S << \"\\n\";\n\t\t\t\t\t\t  assert (0);\n\t\t\t\t\t\t  return nullptr;\n\t\t\t\t\t  } );\n\n#if LLVM_API_VERSION >= 500\n\t\tModuleHandleT m = CompileLayer.addModule(M,\n\t\t\t\t\t\t\t\t\t\t\t\t std::move(Resolver)).get ();\n\t\treturn m;\n#else\n\t\treturn CompileLayer.addModuleSet(singletonSet(M),\n\t\t\t\t\t\t\t\t\t\t  make_unique<MonoJitMemoryManager>(),\n\t\t\t\t\t\t\t\t\t\t  std::move(Resolver));\n#endif\n\t}\n\n\tstd::string mangle(const std::string &Name) {\n\t\tstd::string MangledName;\n\t\t{\n\t\t\traw_string_ostream MangledNameStream(MangledName);\n\t\t\tMangler::getNameWithPrefix(MangledNameStream, Name,\n\t\t\t\t\t\t\t\t\t   TM->createDataLayout());\n\t\t}\n\t\treturn MangledName;\n\t}\n\n\tstd::string mangle(const GlobalValue *GV) {\n\t\tstd::string MangledName;\n\t\t{\n\t\t\tMangler Mang;\n\n\t\t\traw_string_ostream MangledNameStream(MangledName);\n\t\t\tMang.getNameWithPrefix(MangledNameStream, GV, false);\n\t\t}\n\t\treturn MangledName;\n\t}\n\n\tgpointer compile (Function *F, int nvars, LLVMValueRef *callee_vars, gpointer *callee_addrs, gpointer *eh_frame) {\n\t\tF->getParent ()->setDataLayout (TM->createDataLayout ());\n#if LLVM_API_VERSION >= 500\n\t\t// Orc uses a shared_ptr to refer to modules so we have to save them ourselves to keep a ref\n\t\tstd::shared_ptr<Module> m (F->getParent ());\n\t\tmodules.push_back (m);\n\t\tauto ModuleHandle = addModule (F, m);\n#else\n\t\tauto ModuleHandle = addModule (F, F->getParent ());\n#endif\n\t\tauto BodySym = CompileLayer.findSymbolIn(ModuleHandle, mangle (F), false);\n\t\tauto BodyAddr = BodySym.getAddress();\n\t\tassert (BodyAddr);\n\n\t\tfor (int i = 0; i < nvars; ++i) {\n\t\t\tGlobalVariable *var = unwrap<GlobalVariable>(callee_vars [i]);\n\n\t\t\tauto sym = CompileLayer.findSymbolIn (ModuleHandle, mangle (var->getName ()), true);\n\t\t\tauto addr = sym.getAddress ();\n\t\t\tg_assert (addr);\n#if LLVM_API_VERSION >= 500\n\t\t\tcallee_addrs [i] = (gpointer)addr.get ();\n#else\n\t\t\tcallee_addrs [i] = (gpointer)addr;\n#endif\n\t\t}\n\n\t\tauto ehsym = CompileLayer.findSymbolIn(ModuleHandle, \"mono_eh_frame\", false);\n\t\tauto ehaddr = ehsym.getAddress ();\n\t\tg_assert (ehaddr);\n#if LLVM_API_VERSION >= 500\n\t\t*eh_frame = (gpointer)ehaddr.get ();\n\t\treturn (gpointer)BodyAddr.get ();\n#else\n\t\t*eh_frame = (gpointer)ehaddr;\n\t\treturn (gpointer)BodyAddr;\n#endif\n\t}\n\nprivate:\n\tTargetMachine *TM;\n\tObjLayerT ObjectLayer;\n\tCompileLayerT CompileLayer;\n\tstd::vector<std::shared_ptr<Module>> modules;\n};\n\nstatic MonoLLVMJIT *jit;\nstatic MonoJitMemoryManager *mono_mm;\n\nMonoEERef\nmono_llvm_create_ee (LLVMModuleProviderRef MP, AllocCodeMemoryCb *alloc_cb, FunctionEmittedCb *emitted_cb, ExceptionTableCb *exception_cb, DlSymCb *dlsym_cb, LLVMExecutionEngineRef *ee)\n{\n\talloc_code_mem_cb = alloc_cb;\n\n\tInitializeNativeTarget ();\n\tInitializeNativeTargetAsmPrinter();\n\n\tEnableMonoEH = true;\n\tMonoEHFrameSymbol = \"mono_eh_frame\";\n\n\tEngineBuilder EB;\n#if defined(TARGET_AMD64) || defined(TARGET_X86)\n\tstd::vector<std::string> attrs;\n\t// FIXME: Autodetect this\n\tattrs.push_back(\"sse3\");\n\tattrs.push_back(\"sse4.1\");\n\tEB.setMAttrs (attrs);\n#endif\n\tauto TM = EB.selectTarget ();\n\tassert (TM);\n\n\tmono_mm = new MonoJitMemoryManager ();\n\tjit = new MonoLLVMJIT (TM, mono_mm);\n\n\treturn NULL;\n}\n\n/*\n * mono_llvm_compile_method:\n *\n *   Compile METHOD to native code. Compute the addresses of the variables in CALLEE_VARS and store them into\n * CALLEE_ADDRS. Return the EH frame address in EH_FRAME.\n */\ngpointer\nmono_llvm_compile_method (MonoEERef mono_ee, LLVMValueRef method, int nvars, LLVMValueRef *callee_vars, gpointer *callee_addrs, gpointer *eh_frame)\n{\n\treturn jit->compile (unwrap<Function> (method), nvars, callee_vars, callee_addrs, eh_frame);\n}\n\nvoid\nmono_llvm_dispose_ee (MonoEERef *eeref)\n{\n}\n\nvoid\nLLVMAddGlobalMapping(LLVMExecutionEngineRef EE, LLVMValueRef Global,\n\t\t\t\t\t void* Addr)\n{\n\tg_assert_not_reached ();\n}\n\nvoid*\nLLVMGetPointerToGlobal(LLVMExecutionEngineRef EE, LLVMValueRef Global)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\n#elif !defined(MONO_CROSS_COMPILE) && LLVM_API_VERSION < 100\n\n#include <stdint.h>\n\n#include <llvm/Support/raw_ostream.h>\n#include <llvm/Support/Host.h>\n#include <llvm/PassManager.h>\n#include <llvm/ExecutionEngine/ExecutionEngine.h>\n#include <llvm/ExecutionEngine/JITMemoryManager.h>\n#include <llvm/ExecutionEngine/JITEventListener.h>\n#include <llvm/Target/TargetOptions.h>\n#include <llvm/Target/TargetRegisterInfo.h>\n#include <llvm/IR/Verifier.h>\n#include <llvm/Analysis/Passes.h>\n#include <llvm/Transforms/Scalar.h>\n#include <llvm/Support/CommandLine.h>\n#include <llvm/IR/LegacyPassNameParser.h>\n#include <llvm/Support/PrettyStackTrace.h>\n#include <llvm/CodeGen/Passes.h>\n#include <llvm/CodeGen/MachineFunctionPass.h>\n#include <llvm/CodeGen/MachineFunction.h>\n#include <llvm/CodeGen/MachineFrameInfo.h>\n#include <llvm/IR/Function.h>\n#include <llvm/IR/IRBuilder.h>\n#include <llvm/IR/Module.h>\n\nusing namespace llvm;\n\nstatic void (*unhandled_exception)() = default_mono_llvm_unhandled_exception;\n\nvoid\nmono_llvm_set_unhandled_exception_handler (void)\n{\n\tstd::set_terminate (unhandled_exception);\n}\n\nclass MonoJITMemoryManager : public JITMemoryManager\n{\nprivate:\n\tJITMemoryManager *mm;\n\npublic:\n\t/* Callbacks installed by mono */\n\tAllocCodeMemoryCb *alloc_cb;\n\tDlSymCb *dlsym_cb;\n\tExceptionTableCb *exception_cb;\n\n\tMonoJITMemoryManager ();\n\t~MonoJITMemoryManager ();\n\n\tvoid setMemoryWritable (void);\n\n\tvoid setMemoryExecutable (void);\n\n\tvoid AllocateGOT();\n\n    unsigned char *getGOTBase() const {\n\t\treturn mm->getGOTBase ();\n    }\n\n\tvoid setPoisonMemory(bool) {\n\t}\n\n\tunsigned char *startFunctionBody(const Function *F, \n\t\t\t\t\t\t\t\t\t uintptr_t &ActualSize);\n  \n\tunsigned char *allocateStub(const GlobalValue* F, unsigned StubSize,\n\t\t\t\t\t\t\t\t unsigned Alignment);\n  \n\tvoid endFunctionBody(const Function *F, unsigned char *FunctionStart,\n\t\t\t\t\t\t unsigned char *FunctionEnd);\n\n\tunsigned char *allocateSpace(intptr_t Size, unsigned Alignment);\n\n\tuint8_t *allocateGlobal(uintptr_t Size, unsigned Alignment);\n  \n\tvoid deallocateMemForFunction(const Function *F);\n  \n\tunsigned char*startExceptionTable(const Function* F,\n\t\t\t\t\t\t\t\t\t  uintptr_t &ActualSize);\n  \n\tvoid endExceptionTable(const Function *F, unsigned char *TableStart,\n\t\t\t\t\t\t   unsigned char *TableEnd, \n\t\t\t\t\t\t   unsigned char* FrameRegister);\n\n\tvirtual void deallocateFunctionBody(void*) {\n\t}\n\n\tvirtual void deallocateExceptionTable(void*) {\n\t}\n\n\tvirtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment, unsigned SectionID,\n\t\t\t\t\t\t\t\t\t\t StringRef SectionName) {\n\t\t// FIXME:\n\t\tassert(0);\n\t\treturn NULL;\n\t}\n\n\tvirtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment, unsigned SectionID,\n\t\t\t\t\t\t\t\t\t\t StringRef SectionName, bool IsReadOnly) {\n\t\t// FIXME:\n\t\tassert(0);\n\t\treturn NULL;\n\t}\n\n\tvirtual bool applyPermissions(std::string*) {\n\t\t// FIXME:\n\t\tassert(0);\n\t\treturn false;\n\t}\n\n\tvirtual bool finalizeMemory(std::string *ErrMsg = 0) {\n\t\t// FIXME:\n\t\tassert(0);\n\t\treturn false;\n\t}\n\n\tvirtual void* getPointerToNamedFunction(const std::string &Name, bool AbortOnFailure) {\n\t\tvoid *res;\n\t\tchar *err;\n\n\t\terr = dlsym_cb (Name.c_str (), &res);\n\t\tif (err) {\n\t\t\touts () << \"Unable to resolve: \" << Name << \": \" << err << \"\\n\";\n\t\t\tassert(0);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nMonoJITMemoryManager::MonoJITMemoryManager ()\n{\n\tmm = JITMemoryManager::CreateDefaultMemManager ();\n}\n\nMonoJITMemoryManager::~MonoJITMemoryManager ()\n{\n\tdelete mm;\n}\n\nvoid\nMonoJITMemoryManager::setMemoryWritable (void)\n{\n}\n\nvoid\nMonoJITMemoryManager::setMemoryExecutable (void)\n{\n}\n\nvoid\nMonoJITMemoryManager::AllocateGOT()\n{\n\tmm->AllocateGOT ();\n}\n\nunsigned char *\nMonoJITMemoryManager::startFunctionBody(const Function *F, \n\t\t\t\t\tuintptr_t &ActualSize)\n{\n\t// FIXME: This leaks memory\n\tif (ActualSize == 0)\n\t\tActualSize = 128;\n\treturn alloc_cb (wrap (F), ActualSize);\n}\n  \nunsigned char *\nMonoJITMemoryManager::allocateStub(const GlobalValue* F, unsigned StubSize,\n\t\t\t   unsigned Alignment)\n{\n\treturn alloc_cb (wrap (F), StubSize);\n}\n  \nvoid\nMonoJITMemoryManager::endFunctionBody(const Function *F, unsigned char *FunctionStart,\n\t\t\t\t  unsigned char *FunctionEnd)\n{\n}\n\nunsigned char *\nMonoJITMemoryManager::allocateSpace(intptr_t Size, unsigned Alignment)\n{\n\treturn new unsigned char [Size];\n}\n\nuint8_t *\nMonoJITMemoryManager::allocateGlobal(uintptr_t Size, unsigned Alignment)\n{\n\treturn new unsigned char [Size];\n}\n\nvoid\nMonoJITMemoryManager::deallocateMemForFunction(const Function *F)\n{\n}\n  \nunsigned char*\nMonoJITMemoryManager::startExceptionTable(const Function* F,\n\t\t\t\t\t  uintptr_t &ActualSize)\n{\n\treturn startFunctionBody(F, ActualSize);\n}\n  \nvoid\nMonoJITMemoryManager::endExceptionTable(const Function *F, unsigned char *TableStart,\n\t\t\t\t\tunsigned char *TableEnd, \n\t\t\t\t\tunsigned char* FrameRegister)\n{\n\texception_cb (FrameRegister);\n}\n\nclass MonoJITEventListener : public JITEventListener {\n\npublic:\n\tFunctionEmittedCb *emitted_cb;\n\n\tMonoJITEventListener (FunctionEmittedCb *cb) {\n\t\temitted_cb = cb;\n\t}\n\n\tvirtual void NotifyFunctionEmitted(const Function &F,\n\t\t\t\t\t\t\t\t\t   void *Code, size_t Size,\n\t\t\t\t\t\t\t\t\t   const EmittedFunctionDetails &Details) {\n\t\temitted_cb (wrap (&F), Code, (char*)Code + Size);\n\t}\n};\n\nclass MonoEE {\npublic:\n\tExecutionEngine *EE;\n\tMonoJITMemoryManager *mm;\n\tMonoJITEventListener *listener;\n\tFunctionPassManager *fpm;\n};\n\nvoid\nmono_llvm_optimize_method (MonoEERef eeref, LLVMValueRef method)\n{\n\tMonoEE *mono_ee = (MonoEE*)eeref;\n\n\t/*\n\t * The verifier does some checks on the whole module, leading to quadratic behavior.\n\t */\n\t//verifyFunction (*(unwrap<Function> (method)));\n\tmono_ee->fpm->run (*unwrap<Function> (method));\n}\n\nstatic cl::list<const PassInfo*, bool, PassNameParser>\nPassList(cl::desc(\"Optimizations available:\"));\n\nstatic void\nforce_pass_linking (void)\n{\n\t// Make sure the rest is linked in, but never executed\n\tchar *foo = g_getenv (\"FOO\");\n\tgboolean ret = (foo != (char*)-1);\n\tg_free (foo);\n\n\tif (ret) \n\t\treturn;\n\n\t// This is a subset of the passes in LinkAllPasses.h\n\t// The utility passes and the interprocedural passes are commented out\n\n      (void) llvm::createAAEvalPass();\n      (void) llvm::createAggressiveDCEPass();\n      (void) llvm::createAliasAnalysisCounterPass();\n      (void) llvm::createAliasDebugger();\n\t  /*\n      (void) llvm::createArgumentPromotionPass();\n      (void) llvm::createStructRetPromotionPass();\n\t  */\n      (void) llvm::createBasicAliasAnalysisPass();\n      (void) llvm::createLibCallAliasAnalysisPass(0);\n      (void) llvm::createScalarEvolutionAliasAnalysisPass();\n      //(void) llvm::createBlockPlacementPass();\n      (void) llvm::createBreakCriticalEdgesPass();\n      (void) llvm::createCFGSimplificationPass();\n\t  /*\n      (void) llvm::createConstantMergePass();\n      (void) llvm::createConstantPropagationPass();\n\t  */\n\t  /*\n      (void) llvm::createDeadArgEliminationPass();\n\t  */\n      (void) llvm::createDeadCodeEliminationPass();\n      (void) llvm::createDeadInstEliminationPass();\n      (void) llvm::createDeadStoreEliminationPass();\n\t  /*\n      (void) llvm::createDeadTypeEliminationPass();\n      (void) llvm::createDomOnlyPrinterPass();\n      (void) llvm::createDomPrinterPass();\n      (void) llvm::createDomOnlyViewerPass();\n      (void) llvm::createDomViewerPass();\n      (void) llvm::createEdgeProfilerPass();\n      (void) llvm::createOptimalEdgeProfilerPass();\n      (void) llvm::createFunctionInliningPass();\n      (void) llvm::createAlwaysInlinerPass();\n      (void) llvm::createGlobalDCEPass();\n      (void) llvm::createGlobalOptimizerPass();\n      (void) llvm::createGlobalsModRefPass();\n      (void) llvm::createIPConstantPropagationPass();\n      (void) llvm::createIPSCCPPass();\n\t  */\n      (void) llvm::createIndVarSimplifyPass();\n      (void) llvm::createInstructionCombiningPass();\n\t  /*\n      (void) llvm::createInternalizePass(false);\n\t  */\n      (void) llvm::createLCSSAPass();\n      (void) llvm::createLICMPass();\n      (void) llvm::createLazyValueInfoPass();\n      //(void) llvm::createLoopDependenceAnalysisPass();\n\t  /*\n      (void) llvm::createLoopExtractorPass();\n\t  */\n      (void) llvm::createLoopSimplifyPass();\n      (void) llvm::createLoopStrengthReducePass();\n      (void) llvm::createLoopUnrollPass();\n      (void) llvm::createLoopUnswitchPass();\n      (void) llvm::createLoopRotatePass();\n      (void) llvm::createLowerInvokePass();\n\t  /*\n      (void) llvm::createLowerSetJmpPass();\n\t  */\n      (void) llvm::createLowerSwitchPass();\n      (void) llvm::createNoAAPass();\n\t  /*\n      (void) llvm::createNoProfileInfoPass();\n      (void) llvm::createProfileEstimatorPass();\n      (void) llvm::createProfileVerifierPass();\n      (void) llvm::createProfileLoaderPass();\n\t  */\n      (void) llvm::createPromoteMemoryToRegisterPass();\n      (void) llvm::createDemoteRegisterToMemoryPass();\n\t  /*\n      (void) llvm::createPruneEHPass();\n      (void) llvm::createPostDomOnlyPrinterPass();\n      (void) llvm::createPostDomPrinterPass();\n      (void) llvm::createPostDomOnlyViewerPass();\n      (void) llvm::createPostDomViewerPass();\n\t  */\n      (void) llvm::createReassociatePass();\n      (void) llvm::createSCCPPass();\n      (void) llvm::createScalarReplAggregatesPass();\n      //(void) llvm::createSimplifyLibCallsPass();\n\t  /*\n      (void) llvm::createSingleLoopExtractorPass();\n      (void) llvm::createStripSymbolsPass();\n      (void) llvm::createStripNonDebugSymbolsPass();\n      (void) llvm::createStripDeadDebugInfoPass();\n      (void) llvm::createStripDeadPrototypesPass();\n      (void) llvm::createTailCallEliminationPass();\n      (void) llvm::createTailDuplicationPass();\n      (void) llvm::createJumpThreadingPass();\n\t  */\n\t  /*\n      (void) llvm::createUnifyFunctionExitNodesPass();\n\t  */\n      (void) llvm::createInstCountPass();\n      (void) llvm::createCodeGenPreparePass();\n      (void) llvm::createGVNPass();\n      (void) llvm::createMemCpyOptPass();\n      (void) llvm::createLoopDeletionPass();\n\t  /*\n      (void) llvm::createPostDomTree();\n      (void) llvm::createPostDomFrontier();\n      (void) llvm::createInstructionNamerPass();\n      (void) llvm::createPartialSpecializationPass();\n      (void) llvm::createFunctionAttrsPass();\n      (void) llvm::createMergeFunctionsPass();\n      (void) llvm::createPrintModulePass(0);\n      (void) llvm::createPrintFunctionPass(\"\", 0);\n      (void) llvm::createDbgInfoPrinterPass();\n      (void) llvm::createModuleDebugInfoPrinterPass();\n      (void) llvm::createPartialInliningPass();\n      (void) llvm::createGEPSplitterPass();\n      (void) llvm::createLintPass();\n\t  */\n      (void) llvm::createSinkingPass();\n}\n\nstatic gboolean inited;\n\nstatic void\ninit_llvm (void)\n{\n\tif (inited)\n\t\treturn;\n\n  force_pass_linking ();\n\n#ifdef TARGET_ARM\n  LLVMInitializeARMTarget ();\n  LLVMInitializeARMTargetInfo ();\n  LLVMInitializeARMTargetMC ();\n#elif defined(TARGET_X86) || defined(TARGET_AMD64)\n  LLVMInitializeX86Target ();\n  LLVMInitializeX86TargetInfo ();\n  LLVMInitializeX86TargetMC ();\n#elif defined(TARGET_POWERPC)\n  LLVMInitializePowerPCTarget ();\n  LLVMInitializePowerPCTargetInfo ();\n  LLVMInitializePowerPCTargetMC ();\n#else\n  #error Unsupported mono-llvm target\n#endif\n\n  PassRegistry &Registry = *PassRegistry::getPassRegistry();\n  initializeCore(Registry);\n  initializeScalarOpts(Registry);\n  initializeAnalysis(Registry);\n  initializeIPA(Registry);\n  initializeTransformUtils(Registry);\n  initializeInstCombine(Registry);\n  initializeTarget(Registry);\n\n  llvm::cl::ParseEnvironmentOptions(\"mono\", \"MONO_LLVM\", \"\");\n\n  inited = true;\n}\n\nMonoEERef\nmono_llvm_create_ee (LLVMModuleProviderRef MP, AllocCodeMemoryCb *alloc_cb, FunctionEmittedCb *emitted_cb, ExceptionTableCb *exception_cb, DlSymCb *dlsym_cb, LLVMExecutionEngineRef *ee)\n{\n  std::string Error;\n  MonoEE *mono_ee;\n\n  init_llvm ();\n\n  mono_ee = new MonoEE ();\n\n  MonoJITMemoryManager *mono_mm = new MonoJITMemoryManager ();\n  mono_mm->alloc_cb = alloc_cb;\n  mono_mm->dlsym_cb = dlsym_cb;\n  mono_mm->exception_cb = exception_cb;\n  mono_ee->mm = mono_mm;\n\n  /*\n   * The Default code model doesn't seem to work on amd64,\n   * test_0_fields_with_big_offsets (among others) crashes, because LLVM tries to call\n   * memset using a normal pcrel code which is in 32bit memory, while memset isn't.\n   */\n\n  TargetOptions opts;\n  opts.JITExceptionHandling = 1;\n\n  StringRef cpu_name = sys::getHostCPUName ();\n\n  // EngineBuilder no longer has a copy assignment operator (?)\n  std::unique_ptr<Module> Owner(unwrap(MP));\n  EngineBuilder b (std::move(Owner));\n  ExecutionEngine *EE = b.setJITMemoryManager (mono_mm).setTargetOptions (opts).setAllocateGVsWithCode (true).setMCPU (cpu_name).create ();\n\n  g_assert (EE);\n  mono_ee->EE = EE;\n\n  MonoJITEventListener *listener = new MonoJITEventListener (emitted_cb);\n  EE->RegisterJITEventListener (listener);\n  mono_ee->listener = listener;\n\n  FunctionPassManager *fpm = new FunctionPassManager (unwrap (MP));\n  mono_ee->fpm = fpm;\n\n  fpm->add(new DataLayoutPass(*EE->getDataLayout()));\n\n  if (PassList.size() > 0) {\n\t  /* Use the passes specified by the env variable */\n\t  /* Only the passes in force_pass_linking () can be used */\n\t  for (unsigned i = 0; i < PassList.size(); ++i) {\n\t\t  const PassInfo *PassInf = PassList[i];\n\t\t  Pass *P = 0;\n\n\t\t  if (PassInf->getNormalCtor())\n\t\t\t  P = PassInf->getNormalCtor()();\n\t\t  fpm->add (P);\n\t  }\n  } else {\n\t  /* Use the same passes used by 'opt' by default, without the ipo passes */\n\t  const char *opts = \"-simplifycfg -domtree -domfrontier -scalarrepl -instcombine -simplifycfg -domtree -domfrontier -scalarrepl -instcombine -simplifycfg -instcombine -simplifycfg -reassociate -domtree -loops -loop-simplify -domfrontier -loop-simplify -lcssa -loop-rotate -licm -lcssa -loop-unswitch -instcombine -scalar-evolution -loop-simplify -lcssa -iv-users -indvars -loop-deletion -loop-simplify -lcssa -loop-unroll -instcombine -memdep -gvn -memdep -memcpyopt -sccp -instcombine -domtree -memdep -dse -adce -gvn -simplifycfg\";\n\t  char **args;\n\t  int i;\n\n\t  args = g_strsplit (opts, \" \", 1000);\n\t  for (i = 0; args [i]; i++)\n\t\t  ;\n\t  llvm::cl::ParseCommandLineOptions (i, args, \"\");\n\t  g_strfreev (args);\n\n\t  for (unsigned i = 0; i < PassList.size(); ++i) {\n\t\t  const PassInfo *PassInf = PassList[i];\n\t\t  Pass *P = 0;\n\n\t\t  if (PassInf->getNormalCtor())\n\t\t\t  P = PassInf->getNormalCtor()();\n\t\t  g_assert (P->getPassKind () == llvm::PT_Function || P->getPassKind () == llvm::PT_Loop);\n\t\t  fpm->add (P);\n\t  }\n\n\t  /*\n\t  fpm->add(createInstructionCombiningPass());\n\t  fpm->add(createReassociatePass());\n\t  fpm->add(createGVNPass());\n\t  fpm->add(createCFGSimplificationPass());\n\t  */\n  }\n\n  *ee = wrap (EE);\n\n  return mono_ee;\n}\n\nvoid\nmono_llvm_dispose_ee (MonoEERef *eeref)\n{\n\tMonoEE *mono_ee = (MonoEE*)eeref;\n\n\tdelete mono_ee->EE;\n\tdelete mono_ee->fpm;\n\t//delete mono_ee->mm;\n\tdelete mono_ee->listener;\n\tdelete mono_ee;\n}\n\n#else /* MONO_CROSS_COMPILE */\n\nvoid\nmono_llvm_set_unhandled_exception_handler (void)\n{\n}\n\nMonoEERef\nmono_llvm_create_ee (LLVMModuleProviderRef MP, AllocCodeMemoryCb *alloc_cb, FunctionEmittedCb *emitted_cb, ExceptionTableCb *exception_cb, DlSymCb *dlsym_cb, LLVMExecutionEngineRef *ee)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid\nmono_llvm_optimize_method (MonoEERef eeref, LLVMValueRef method)\n{\n\tg_assert_not_reached ();\n}\n\ngpointer\nmono_llvm_compile_method (MonoEERef mono_ee, LLVMValueRef method, int nvars, LLVMValueRef *callee_vars, gpointer *callee_addrs, gpointer *eh_frame)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid\nmono_llvm_dispose_ee (MonoEERef *eeref)\n{\n\tg_assert_not_reached ();\n}\n\n/* Not linked in */\nvoid\nLLVMAddGlobalMapping(LLVMExecutionEngineRef EE, LLVMValueRef Global,\n\t\t\t\t\t void* Addr)\n{\n\tg_assert_not_reached ();\n}\n\nvoid*\nLLVMGetPointerToGlobal(LLVMExecutionEngineRef EE, LLVMValueRef Global)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\n#endif /* !MONO_CROSS_COMPILE */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mono/eglib/gmodule-unix.c": "/*\n * gmodule.c: dl* functions, glib style\n *\n * Author:\n *   Gonzalo Paniagua Javier (gonzalo@novell.com)\n *   Jonathan Chambers (joncham@gmail.com)\n *   Robert Jordan (robertj@gmx.net)\n *\n * (C) 2006 Novell, Inc.\n * (C) 2006 Jonathan Chambers\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n#include <config.h>\n\n#include <glib.h>\n#include <gmodule.h>\n\n#if defined(G_OS_UNIX) && defined(HAVE_DLFCN_H)\n#include <dlfcn.h>\n\n/* For Linux and Solaris, need to add others as we port this */\n#define LIBPREFIX \"lib\"\n#define LIBSUFFIX \".so\"\n\nstruct _GModule {\n\tvoid *handle;\n};\n\nGModule *\ng_module_open (const gchar *file, GModuleFlags flags)\n{\n\tint f = 0;\n\tGModule *module;\n\tvoid *handle;\n\t\n\tflags &= G_MODULE_BIND_MASK;\n\tif ((flags & G_MODULE_BIND_LAZY) != 0)\n\t\tf |= RTLD_LAZY;\n\tif ((flags & G_MODULE_BIND_LOCAL) != 0)\n\t\tf |= RTLD_LOCAL;\n\n\thandle = dlopen (file, f);\n\tif (handle == NULL)\n\t\treturn NULL;\n\t\n\tmodule = g_new (GModule,1);\n\tmodule->handle = handle;\n\t\n\treturn module;\n}\n\ngboolean\ng_module_symbol (GModule *module, const gchar *symbol_name, gpointer *symbol)\n{\n\tif (symbol_name == NULL || symbol == NULL)\n\t\treturn FALSE;\n\n\tif (module == NULL || module->handle == NULL)\n\t\treturn FALSE;\n\n\t*symbol = dlsym (module->handle, symbol_name);\n\treturn (*symbol != NULL);\n}\n\nconst gchar *\ng_module_error (void)\n{\n\treturn dlerror ();\n}\n\ngboolean\ng_module_close (GModule *module)\n{\n\tvoid *handle;\n\tif (module == NULL || module->handle == NULL)\n\t\treturn FALSE;\n\n\thandle = module->handle;\n\tmodule->handle = NULL;\n\tg_free (module);\n\treturn (0 == dlclose (handle));\n}\n\n#elif defined (G_OS_WIN32)\n#include <windows.h>\n#include <psapi.h>\n\n#define LIBSUFFIX \".dll\"\n#define LIBPREFIX \"\"\n\nstruct _GModule {\n\tHMODULE handle;\n\tint main_module;\n};\n\nGModule *\ng_module_open (const gchar *file, GModuleFlags flags)\n{\n\tGModule *module;\n\tmodule = g_malloc (sizeof (GModule));\n\tif (module == NULL)\n\t\treturn NULL;\n\n\tif (file != NULL) {\n\t\tgunichar2 *file16;\n\t\tfile16 = u8to16(file); \n\t\tmodule->main_module = FALSE;\n\t\tmodule->handle = LoadLibrary (file16);\n\t\tg_free(file16);\n\t\tif (!module->handle) {\n\t\t\tg_free (module);\n\t\t\treturn NULL;\n\t\t}\n\t\t\t\n\t} else {\n\t\tmodule->main_module = TRUE;\n\t\tmodule->handle = GetModuleHandle (NULL);\n\t}\n\n\treturn module;\n}\n\nstatic gpointer\nw32_find_symbol (const gchar *symbol_name)\n{\n\tHMODULE *modules;\n\tDWORD buffer_size = sizeof (HMODULE) * 1024;\n\tDWORD needed, i;\n\n\tmodules = (HMODULE *) g_malloc (buffer_size);\n\n\tif (modules == NULL)\n\t\treturn NULL;\n\n\tif (!EnumProcessModules (GetCurrentProcess (), modules,\n\t\t\t\t buffer_size, &needed)) {\n\t\tg_free (modules);\n\t\treturn NULL;\n\t}\n\n\t/* check whether the supplied buffer was too small, realloc, retry */\n\tif (needed > buffer_size) {\n\t\tg_free (modules);\n\n\t\tbuffer_size = needed;\n\t\tmodules = (HMODULE *) g_malloc (buffer_size);\n\n\t\tif (modules == NULL)\n\t\t\treturn NULL;\n\n\t\tif (!EnumProcessModules (GetCurrentProcess (), modules,\n\t\t\t\t\t buffer_size, &needed)) {\n\t\t\tg_free (modules);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < needed / sizeof (HANDLE); i++) {\n\t\tgpointer proc = (gpointer)(intptr_t)GetProcAddress (modules [i], symbol_name);\n\t\tif (proc != NULL) {\n\t\t\tg_free (modules);\n\t\t\treturn proc;\n\t\t}\n\t}\n\n\tg_free (modules);\n\treturn NULL;\n}\n\ngboolean\ng_module_symbol (GModule *module, const gchar *symbol_name, gpointer *symbol)\n{\n\tif (module == NULL || symbol_name == NULL || symbol == NULL)\n\t\treturn FALSE;\n\n\tif (module->main_module) {\n\t\t*symbol = (gpointer)(intptr_t)GetProcAddress (module->handle, symbol_name);\n\t\tif (*symbol != NULL)\n\t\t\treturn TRUE;\n\n\t\t*symbol = w32_find_symbol (symbol_name);\n\t\treturn *symbol != NULL;\n\t} else {\n\t\t*symbol = (gpointer)(intptr_t)GetProcAddress (module->handle, symbol_name);\n\t\treturn *symbol != NULL;\n\t}\n}\n\nconst gchar *\ng_module_error (void)\n{\n\tgchar* ret = NULL;\n\tTCHAR* buf = NULL;\n\tDWORD code = GetLastError ();\n\n\tFormatMessage (FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, NULL, \n\t\tcode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), buf, 0, NULL);\n\n\tret = u16to8 (buf);\n\tLocalFree(buf);\n\n\treturn ret;\n}\n\ngboolean\ng_module_close (GModule *module)\n{\n\tHMODULE handle;\n\tint main_module;\n\n\tif (module == NULL || module->handle == NULL)\n\t\treturn FALSE;\n\n\thandle = module->handle;\n\tmain_module = module->main_module;\n\tmodule->handle = NULL;\n\tg_free (module);\n\treturn (main_module ? 1 : (0 == FreeLibrary (handle)));\n}\n\n#else\n\n#define LIBSUFFIX \"\"\n#define LIBPREFIX \"\"\n\nGModule *\ng_module_open (const gchar *file, GModuleFlags flags)\n{\n\tg_error (\"%s\", \"g_module_open not implemented on this platform\");\n\treturn NULL;\n}\n\ngboolean\ng_module_symbol (GModule *module, const gchar *symbol_name, gpointer *symbol)\n{\n\tg_error (\"%s\", \"g_module_open not implemented on this platform\");\n\treturn FALSE;\n}\n\nconst gchar *\ng_module_error (void)\n{\n\tg_error (\"%s\", \"g_module_open not implemented on this platform\");\n\treturn NULL;\n}\n\ngboolean\ng_module_close (GModule *module)\n{\n\tg_error (\"%s\", \"g_module_open not implemented on this platform\");\n\treturn FALSE;\n}\n#endif\n\ngchar *\ng_module_build_path (const gchar *directory, const gchar *module_name)\n{\n\tconst char *lib_prefix = \"\";\n\t\n\tif (module_name == NULL)\n\t\treturn NULL;\n\n\tif (strncmp (module_name, \"lib\", 3) != 0)\n\t\tlib_prefix = LIBPREFIX;\n\t\n\tif (directory && *directory)\n\t\treturn g_strdup_printf (\"%s/%s%s\" LIBSUFFIX, directory, lib_prefix, module_name);\n\treturn g_strdup_printf (\"%s%s\" LIBSUFFIX, lib_prefix, module_name); \n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/libgc/ltmain.sh": "\n# libtool (GNU libtool) 2.4.2\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006,\n# 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html,\n# or obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\n# Usage: $progname [OPTION]... [MODE-ARG]...\n#\n# Provide generalized library-building support services.\n#\n#       --config             show all configuration variables\n#       --debug              enable verbose shell tracing\n#   -n, --dry-run            display commands without modifying any files\n#       --features           display basic configuration information and exit\n#       --mode=MODE          use operation mode MODE\n#       --preserve-dup-deps  don't remove duplicate dependency libraries\n#       --quiet, --silent    don't print informational messages\n#       --no-quiet, --no-silent\n#                            print informational messages (default)\n#       --no-warn            don't display warning messages\n#       --tag=TAG            use configuration variables from tag TAG\n#   -v, --verbose            print more informational messages than default\n#       --no-verbose         don't print the extra informational messages\n#       --version            print version information\n#   -h, --help, --help-all   print short, long, or detailed help message\n#\n# MODE must be one of the following:\n#\n#         clean              remove files from the build directory\n#         compile            compile a source file into a libtool object\n#         execute            automatically set library path, then run a program\n#         finish             complete the installation of libtool libraries\n#         install            install libraries or executables\n#         link               create a library or an executable\n#         uninstall          remove libraries from an installed directory\n#\n# MODE-ARGS vary depending on the MODE.  When passed as first option,\n# `--mode=MODE' may be abbreviated as `MODE' or a unique abbreviation of that.\n# Try `$progname --help --mode=MODE' for a more detailed description of MODE.\n#\n# When reporting a bug, please describe a test case to reproduce it and\n# include the following information:\n#\n#         host-triplet:\t$host\n#         shell:\t\t$SHELL\n#         compiler:\t\t$LTCC\n#         compiler flags:\t\t$LTCFLAGS\n#         linker:\t\t$LD (gnu? $with_gnu_ld)\n#         $progname:\t(GNU libtool) 2.4.2 Debian-2.4.2-1.7ubuntu1\n#         automake:\t$automake_version\n#         autoconf:\t$autoconf_version\n#\n# Report bugs to <bug-libtool@gnu.org>.\n# GNU libtool home page: <http://www.gnu.org/software/libtool/>.\n# General help using GNU software: <http://www.gnu.org/gethelp/>.\n\nPROGRAM=libtool\nPACKAGE=libtool\nVERSION=\"2.4.2 Debian-2.4.2-1.7ubuntu1\"\nTIMESTAMP=\"\"\npackage_revision=1.3337\n\n# Be Bourne compatible\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n$1\n_LTECHO_EOF'\n}\n\n# NLS nuisances: We save the old values to restore during execute mode.\nlt_user_locale=\nlt_safe_locale=\nfor lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test \\\"\\${$lt_var+set}\\\" = set; then\n          save_$lt_var=\\$$lt_var\n          $lt_var=C\n\t  export $lt_var\n\t  lt_user_locale=\\\"$lt_var=\\\\\\$save_\\$lt_var; \\$lt_user_locale\\\"\n\t  lt_safe_locale=\\\"$lt_var=C; \\$lt_safe_locale\\\"\n\tfi\"\ndone\nLC_ALL=C\nLANGUAGE=C\nexport LANGUAGE LC_ALL\n\n$lt_unset CDPATH\n\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=\"$0\"\n\n\n\n: ${CP=\"cp -f\"}\ntest \"${ECHO+set}\" = set || ECHO=${as_echo-'printf %s\\n'}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n: ${Xsed=\"$SED -e 1s/^X//\"}\n\n# Global variables:\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\nexit_status=$EXIT_SUCCESS\n\n# Make sure IFS has a sensible default\nlt_nl='\n'\nIFS=\" \t$lt_nl\"\n\ndirname=\"s,/[^/]*$,,\"\nbasename=\"s,^.*/,,\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n    func_dirname_result=`$ECHO \"${1}\" | $SED \"$dirname\"`\n    if test \"X$func_dirname_result\" = \"X${1}\"; then\n      func_dirname_result=\"${3}\"\n    else\n      func_dirname_result=\"$func_dirname_result${2}\"\n    fi\n} # func_dirname may be replaced by extended shell implementation\n\n\n# func_basename file\nfunc_basename ()\n{\n    func_basename_result=`$ECHO \"${1}\" | $SED \"$basename\"`\n} # func_basename may be replaced by extended shell implementation\n\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n    # Extract subdirectory from the argument.\n    func_dirname_result=`$ECHO \"${1}\" | $SED -e \"$dirname\"`\n    if test \"X$func_dirname_result\" = \"X${1}\"; then\n      func_dirname_result=\"${3}\"\n    else\n      func_dirname_result=\"$func_dirname_result${2}\"\n    fi\n    func_basename_result=`$ECHO \"${1}\" | $SED -e \"$basename\"`\n} # func_dirname_and_basename may be replaced by extended shell implementation\n\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n# func_strip_suffix prefix name\nfunc_stripname ()\n{\n    case ${2} in\n      .*) func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%\\\\\\\\${2}\\$%%\"`;;\n      *)  func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%${2}\\$%%\"`;;\n    esac\n} # func_stripname may be replaced by extended shell implementation\n\n\n# These SED scripts presuppose an absolute path with a trailing slash.\npathcar='s,^/\\([^/]*\\).*$,\\1,'\npathcdr='s,^/[^/]*,,'\nremovedotparts=':dotsl\n\t\ts@/\\./@/@g\n\t\tt dotsl\n\t\ts,/\\.$,/,'\ncollapseslashes='s@/\\{1,\\}@/@g'\nfinalslash='s,/*$,/,'\n\n# func_normal_abspath PATH\n# Remove doubled-up and trailing slashes, \".\" path components,\n# and cancel out any \"..\" path components in PATH after making\n# it an absolute path.\n#             value returned in \"$func_normal_abspath_result\"\nfunc_normal_abspath ()\n{\n  # Start from root dir and reassemble the path.\n  func_normal_abspath_result=\n  func_normal_abspath_tpath=$1\n  func_normal_abspath_altnamespace=\n  case $func_normal_abspath_tpath in\n    \"\")\n      # Empty path, that just means $cwd.\n      func_stripname '' '/' \"`pwd`\"\n      func_normal_abspath_result=$func_stripname_result\n      return\n    ;;\n    # The next three entries are used to spot a run of precisely\n    # two leading slashes without using negated character classes;\n    # we take advantage of case's first-match behaviour.\n    ///*)\n      # Unusual form of absolute path, do nothing.\n    ;;\n    //*)\n      # Not necessarily an ordinary path; POSIX reserves leading '//'\n      # and for example Cygwin uses it to access remote file shares\n      # over CIFS/SMB, so we conserve a leading double slash if found.\n      func_normal_abspath_altnamespace=/\n    ;;\n    /*)\n      # Absolute path, do nothing.\n    ;;\n    *)\n      # Relative path, prepend $cwd.\n      func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath\n    ;;\n  esac\n  # Cancel out all the simple stuff to save iterations.  We also want\n  # the path to end with a slash for ease of parsing, so make sure\n  # there is one (and only one) here.\n  func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$removedotparts\" -e \"$collapseslashes\" -e \"$finalslash\"`\n  while :; do\n    # Processed it all yet?\n    if test \"$func_normal_abspath_tpath\" = / ; then\n      # If we ascended to the root using \"..\" the result may be empty now.\n      if test -z \"$func_normal_abspath_result\" ; then\n        func_normal_abspath_result=/\n      fi\n      break\n    fi\n    func_normal_abspath_tcomponent=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcar\"`\n    func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcdr\"`\n    # Figure out what to do with it\n    case $func_normal_abspath_tcomponent in\n      \"\")\n        # Trailing empty path component, ignore it.\n      ;;\n      ..)\n        # Parent dir; strip last assembled component from result.\n        func_dirname \"$func_normal_abspath_result\"\n        func_normal_abspath_result=$func_dirname_result\n      ;;\n      *)\n        # Actual path component, append it.\n        func_normal_abspath_result=$func_normal_abspath_result/$func_normal_abspath_tcomponent\n      ;;\n    esac\n  done\n  # Restore leading double-slash if one was found on entry.\n  func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result\n}\n\n# func_relative_path SRCDIR DSTDIR\n# generates a relative path from SRCDIR to DSTDIR, with a trailing\n# slash if non-empty, suitable for immediately appending a filename\n# without needing to append a separator.\n#             value returned in \"$func_relative_path_result\"\nfunc_relative_path ()\n{\n  func_relative_path_result=\n  func_normal_abspath \"$1\"\n  func_relative_path_tlibdir=$func_normal_abspath_result\n  func_normal_abspath \"$2\"\n  func_relative_path_tbindir=$func_normal_abspath_result\n\n  # Ascend the tree starting from libdir\n  while :; do\n    # check if we have found a prefix of bindir\n    case $func_relative_path_tbindir in\n      $func_relative_path_tlibdir)\n        # found an exact match\n        func_relative_path_tcancelled=\n        break\n        ;;\n      $func_relative_path_tlibdir*)\n        # found a matching prefix\n        func_stripname \"$func_relative_path_tlibdir\" '' \"$func_relative_path_tbindir\"\n        func_relative_path_tcancelled=$func_stripname_result\n        if test -z \"$func_relative_path_result\"; then\n          func_relative_path_result=.\n        fi\n        break\n        ;;\n      *)\n        func_dirname $func_relative_path_tlibdir\n        func_relative_path_tlibdir=${func_dirname_result}\n        if test \"x$func_relative_path_tlibdir\" = x ; then\n          # Have to descend all the way to the root!\n          func_relative_path_result=../$func_relative_path_result\n          func_relative_path_tcancelled=$func_relative_path_tbindir\n          break\n        fi\n        func_relative_path_result=../$func_relative_path_result\n        ;;\n    esac\n  done\n\n  # Now calculate path; take care to avoid doubling-up slashes.\n  func_stripname '' '/' \"$func_relative_path_result\"\n  func_relative_path_result=$func_stripname_result\n  func_stripname '/' '/' \"$func_relative_path_tcancelled\"\n  if test \"x$func_stripname_result\" != x ; then\n    func_relative_path_result=${func_relative_path_result}/${func_stripname_result}\n  fi\n\n  # Normalisation. If bindir is libdir, return empty string,\n  # else relative path ending with a slash; either way, target\n  # file name can be directly appended.\n  if test ! -z \"$func_relative_path_result\"; then\n    func_stripname './' '' \"$func_relative_path_result/\"\n    func_relative_path_result=$func_stripname_result\n  fi\n}\n\n# The name of this program:\nfunc_dirname_and_basename \"$progpath\"\nprogname=$func_basename_result\n\n# Make sure we have an absolute path for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=$func_dirname_result\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\n  *)\n     save_IFS=\"$IFS\"\n     IFS=${PATH_SEPARATOR-:}\n     for progdir in $PATH; do\n       IFS=\"$save_IFS\"\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=\"$save_IFS\"\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed=\"${SED}\"' -e 1s/^X//'\nsed_quote_subst='s/\\([`\"$\\\\]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Sed substitution that turns a string into a regex matching for the\n# string literally.\nsed_make_literal_regex='s,[].[^$\\\\*\\/],\\\\&,g'\n\n# Sed substitution that converts a w32 file name or path\n# which contains forward slashes, into one that contains\n# (escaped) backslashes.  A very naive implementation.\nlt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n\n# Re-`\\' parameter expansions in output of double_quote_subst that were\n# `\\'-ed in input to the same.  If an odd number of `\\' preceded a '$'\n# in input to double_quote_subst, that '$' was protected from expansion.\n# Since each input `\\' is now two `\\'s, look for any number of runs of\n# four `\\'s followed by two `\\'s and then a '$'.  `\\' that '$'.\nbs='\\\\'\nbs2='\\\\\\\\'\nbs4='\\\\\\\\\\\\\\\\'\ndollar='\\$'\nsed_double_backslash=\"\\\n  s/$bs4/&\\\\\n/g\n  s/^$bs2$dollar/$bs&/\n  s/\\\\([^$bs]\\\\)$bs2$dollar/\\\\1$bs2$bs$dollar/g\n  s/\\n//g\"\n\n# Standard options:\nopt_dry_run=false\nopt_help=false\nopt_quiet=false\nopt_verbose=false\nopt_warning=:\n\n# func_echo arg...\n# Echo program name prefixed message, along with the current mode\n# name if it has been set yet.\nfunc_echo ()\n{\n    $ECHO \"$progname: ${opt_mode+$opt_mode: }$*\"\n}\n\n# func_verbose arg...\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $opt_verbose && func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\n# func_error arg...\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $ECHO \"$progname: ${opt_mode+$opt_mode: }\"${1+\"$@\"} 1>&2\n}\n\n# func_warning arg...\n# Echo program name prefixed warning message to standard error.\nfunc_warning ()\n{\n    $opt_warning && $ECHO \"$progname: ${opt_mode+$opt_mode: }warning: \"${1+\"$@\"} 1>&2\n\n    # bash bug again:\n    :\n}\n\n# func_fatal_error arg...\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n# func_fatal_help arg...\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    func_error ${1+\"$@\"}\n    func_fatal_error \"$help\"\n}\nhelp=\"Try \\`$progname --help' for more information.\"  ## default\n\n\n# func_grep expression filename\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_mkdir_p directory-path\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    my_directory_path=\"$1\"\n    my_dir_list=\n\n    if test -n \"$my_directory_path\" && test \"$opt_dry_run\" != \":\"; then\n\n      # Protect directory names starting with `-'\n      case $my_directory_path in\n        -*) my_directory_path=\"./$my_directory_path\" ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$my_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        my_dir_list=\"$my_directory_path:$my_dir_list\"\n\n        # If the last portion added has no slash in it, the list is done\n        case $my_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        my_directory_path=`$ECHO \"$my_directory_path\" | $SED -e \"$dirname\"`\n      done\n      my_dir_list=`$ECHO \"$my_dir_list\" | $SED 's,:*$,,'`\n\n      save_mkdir_p_IFS=\"$IFS\"; IFS=':'\n      for my_dir in $my_dir_list; do\n\tIFS=\"$save_mkdir_p_IFS\"\n        # mkdir can fail with a `File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$my_dir\" 2>/dev/null || :\n      done\n      IFS=\"$save_mkdir_p_IFS\"\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$my_directory_path\" || \\\n        func_fatal_error \"Failed to create \\`$1'\"\n    fi\n}\n\n\n# func_mktempdir [string]\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, STRING is the basename for that directory.\nfunc_mktempdir ()\n{\n    my_template=\"${TMPDIR-/tmp}/${1-$progname}\"\n\n    if test \"$opt_dry_run\" = \":\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      my_tmpdir=\"${my_template}-$$\"\n    else\n\n      # If mktemp works, use that first and foremost\n      my_tmpdir=`mktemp -d \"${my_template}-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$my_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        my_tmpdir=\"${my_template}-${RANDOM-0}$$\"\n\n        save_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$my_tmpdir\"\n        umask $save_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$my_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory \\`$my_tmpdir'\"\n    fi\n\n    $ECHO \"$my_tmpdir\"\n}\n\n\n# func_quote_for_eval arg\n# Aesthetically quote ARG to be evaled later.\n# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT\n# is double-quoted, suitable for a subsequent eval, whereas\n# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters\n# which are still active within double quotes backslashified.\nfunc_quote_for_eval ()\n{\n    case $1 in\n      *[\\\\\\`\\\"\\$]*)\n\tfunc_quote_for_eval_unquoted_result=`$ECHO \"$1\" | $SED \"$sed_quote_subst\"` ;;\n      *)\n        func_quote_for_eval_unquoted_result=\"$1\" ;;\n    esac\n\n    case $func_quote_for_eval_unquoted_result in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting, command substitution and and variable\n      # expansion for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        func_quote_for_eval_result=\"\\\"$func_quote_for_eval_unquoted_result\\\"\"\n        ;;\n      *)\n        func_quote_for_eval_result=\"$func_quote_for_eval_unquoted_result\"\n    esac\n}\n\n\n# func_quote_for_expand arg\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\tmy_arg=`$ECHO \"$1\" | $SED \\\n\t    -e \"$double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        my_arg=\"$1\" ;;\n    esac\n\n    case $my_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        my_arg=\"\\\"$my_arg\\\"\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=\"$my_arg\"\n}\n\n\n# func_show_eval cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$my_cmd\"\n      my_status=$?\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n# func_show_eval_locale cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$lt_user_locale\n\t    $my_cmd\"\n      my_status=$?\n      eval \"$lt_safe_locale\"\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n# func_tr_sh\n# Turn $1 into a string suitable for a shell variable name.\n# Result is stored in $func_tr_sh_result.  All characters\n# not in the set a-zA-Z0-9_ are replaced with '_'. Further,\n# if $1 begins with a digit, a '_' is prepended as well.\nfunc_tr_sh ()\n{\n  case $1 in\n  [0-9]* | *[!a-zA-Z0-9_]*)\n    func_tr_sh_result=`$ECHO \"$1\" | $SED 's/^\\([0-9]\\)/_\\1/; s/[^a-zA-Z0-9_]/_/g'`\n    ;;\n  * )\n    func_tr_sh_result=$1\n    ;;\n  esac\n}\n\n\n# func_version\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $opt_debug\n\n    $SED -n '/(C)/!b go\n\t:more\n\t/\\./!{\n\t  N\n\t  s/\\n# / /\n\t  b more\n\t}\n\t:go\n\t/^# '$PROGRAM' (GNU /,/# warranty; / {\n        s/^# //\n\ts/^# *$//\n        s/\\((C)\\)[ 0-9,-]*\\( [1-9][0-9]*\\)/\\1\\2/\n        p\n     }' < \"$progpath\"\n     exit $?\n}\n\n# func_usage\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $opt_debug\n\n    $SED -n '/^# Usage:/,/^#  *.*--help/ {\n        s/^# //\n\ts/^# *$//\n\ts/\\$progname/'$progname'/\n\tp\n    }' < \"$progpath\"\n    echo\n    $ECHO \"run \\`$progname --help | more' for full usage\"\n    exit $?\n}\n\n# func_help [NOEXIT]\n# Echo long help message to standard output and exit,\n# unless 'noexit' is passed as argument.\nfunc_help ()\n{\n    $opt_debug\n\n    $SED -n '/^# Usage:/,/# Report bugs to/ {\n\t:print\n        s/^# //\n\ts/^# *$//\n\ts*\\$progname*'$progname'*\n\ts*\\$host*'\"$host\"'*\n\ts*\\$SHELL*'\"$SHELL\"'*\n\ts*\\$LTCC*'\"$LTCC\"'*\n\ts*\\$LTCFLAGS*'\"$LTCFLAGS\"'*\n\ts*\\$LD*'\"$LD\"'*\n\ts/\\$with_gnu_ld/'\"$with_gnu_ld\"'/\n\ts/\\$automake_version/'\"`(${AUTOMAKE-automake} --version) 2>/dev/null |$SED 1q`\"'/\n\ts/\\$autoconf_version/'\"`(${AUTOCONF-autoconf} --version) 2>/dev/null |$SED 1q`\"'/\n\tp\n\td\n     }\n     /^# .* home page:/b print\n     /^# General help using/b print\n     ' < \"$progpath\"\n    ret=$?\n    if test -z \"$1\"; then\n      exit $ret\n    fi\n}\n\n# func_missing_arg argname\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    $opt_debug\n\n    func_error \"missing argument for $1.\"\n    exit_cmd=exit\n}\n\n\n# func_split_short_opt shortopt\n# Set func_split_short_opt_name and func_split_short_opt_arg shell\n# variables after splitting SHORTOPT after the 2nd character.\nfunc_split_short_opt ()\n{\n    my_sed_short_opt='1s/^\\(..\\).*$/\\1/;q'\n    my_sed_short_rest='1s/^..\\(.*\\)$/\\1/;q'\n\n    func_split_short_opt_name=`$ECHO \"$1\" | $SED \"$my_sed_short_opt\"`\n    func_split_short_opt_arg=`$ECHO \"$1\" | $SED \"$my_sed_short_rest\"`\n} # func_split_short_opt may be replaced by extended shell implementation\n\n\n# func_split_long_opt longopt\n# Set func_split_long_opt_name and func_split_long_opt_arg shell\n# variables after splitting LONGOPT at the `=' sign.\nfunc_split_long_opt ()\n{\n    my_sed_long_opt='1s/^\\(--[^=]*\\)=.*/\\1/;q'\n    my_sed_long_arg='1s/^--[^=]*=//'\n\n    func_split_long_opt_name=`$ECHO \"$1\" | $SED \"$my_sed_long_opt\"`\n    func_split_long_opt_arg=`$ECHO \"$1\" | $SED \"$my_sed_long_arg\"`\n} # func_split_long_opt may be replaced by extended shell implementation\n\nexit_cmd=:\n\n\n\n\n\nmagic=\"%%%MAGIC variable%%%\"\nmagic_exe=\"%%%MAGIC EXE variable%%%\"\n\n# Global variables.\nnonopt=\npreserve_args=\nlo2o=\"s/\\\\.lo\\$/.${objext}/\"\no2lo=\"s/\\\\.${objext}\\$/.lo/\"\nextracted_archives=\nextracted_serial=0\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n    eval \"${1}=\\$${1}\\${2}\"\n} # func_append may be replaced by extended shell implementation\n\n# func_append_quoted var value\n# Quote VALUE and append to the end of shell variable VAR, separated\n# by a space.\nfunc_append_quoted ()\n{\n    func_quote_for_eval \"${2}\"\n    eval \"${1}=\\$${1}\\\\ \\$func_quote_for_eval_result\"\n} # func_append_quoted may be replaced by extended shell implementation\n\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n    func_arith_result=`expr \"${@}\"`\n} # func_arith may be replaced by extended shell implementation\n\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n    func_len_result=`expr \"${1}\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n} # func_len may be replaced by extended shell implementation\n\n\n# func_lo2o object\nfunc_lo2o ()\n{\n    func_lo2o_result=`$ECHO \"${1}\" | $SED \"$lo2o\"`\n} # func_lo2o may be replaced by extended shell implementation\n\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n    func_xform_result=`$ECHO \"${1}\" | $SED 's/\\.[^.]*$/.lo/'`\n} # func_xform may be replaced by extended shell implementation\n\n\n# func_fatal_configuration arg...\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func_error ${1+\"$@\"}\n    func_error \"See the $PACKAGE documentation for more information.\"\n    func_fatal_error \"Fatal configuration error.\"\n}\n\n\n# func_config\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n# func_features\n# Display the features supported by this script.\nfunc_features ()\n{\n    echo \"host: $host\"\n    if test \"$build_libtool_libs\" = yes; then\n      echo \"enable shared libraries\"\n    else\n      echo \"disable shared libraries\"\n    fi\n    if test \"$build_old_libs\" = yes; then\n      echo \"enable static libraries\"\n    else\n      echo \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n# func_enable_tag tagname\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n  # Global variable:\n  tagname=\"$1\"\n\n  re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n  re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n  sed_extractcf=\"/$re_begincf/,/$re_endcf/p\"\n\n  # Validate tagname.\n  case $tagname in\n    *[!-_A-Za-z0-9,/]*)\n      func_fatal_error \"invalid tag name: $tagname\"\n      ;;\n  esac\n\n  # Don't test for the \"default\" C tag, as we know it's\n  # there but not specially marked.\n  case $tagname in\n    CC) ;;\n    *)\n      if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\ttaglist=\"$taglist $tagname\"\n\n\t# Evaluate the configuration.  Be careful to quote the path\n\t# and the sed script, to avoid splitting on whitespace, but\n\t# also don't use non-portable quotes within backquotes within\n\t# quotes we have to do it in 2 steps:\n\textractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\teval \"$extractedcf\"\n      else\n\tfunc_error \"ignoring unknown tag $tagname\"\n      fi\n      ;;\n  esac\n}\n\n# func_check_version_match\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n  if test \"$package_revision\" != \"$macro_revision\"; then\n    if test \"$VERSION\" != \"$macro_version\"; then\n      if test -z \"$macro_version\"; then\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      fi\n    else\n      cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n    fi\n\n    exit $EXIT_MISMATCH\n  fi\n}\n\n\n# Shorthand for --mode=foo, only valid as the first argument\ncase $1 in\nclean|clea|cle|cl)\n  shift; set dummy --mode clean ${1+\"$@\"}; shift\n  ;;\ncompile|compil|compi|comp|com|co|c)\n  shift; set dummy --mode compile ${1+\"$@\"}; shift\n  ;;\nexecute|execut|execu|exec|exe|ex|e)\n  shift; set dummy --mode execute ${1+\"$@\"}; shift\n  ;;\nfinish|finis|fini|fin|fi|f)\n  shift; set dummy --mode finish ${1+\"$@\"}; shift\n  ;;\ninstall|instal|insta|inst|ins|in|i)\n  shift; set dummy --mode install ${1+\"$@\"}; shift\n  ;;\nlink|lin|li|l)\n  shift; set dummy --mode link ${1+\"$@\"}; shift\n  ;;\nuninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n  shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n  ;;\nesac\n\n\n\n# Option defaults:\nopt_debug=:\nopt_dry_run=false\nopt_config=false\nopt_preserve_dup_deps=false\nopt_features=false\nopt_finish=false\nopt_help=false\nopt_help_all=false\nopt_silent=:\nopt_warning=:\nopt_verbose=:\nopt_silent=false\nopt_verbose=false\n\n\n# Parse options once, thoroughly.  This comes as soon as possible in the\n# script to make things like `--version' happen as quickly as we can.\n{\n  # this just eases exit handling\n  while test $# -gt 0; do\n    opt=\"$1\"\n    shift\n    case $opt in\n      --debug|-x)\topt_debug='set -x'\n\t\t\tfunc_echo \"enabling shell trace mode\"\n\t\t\t$opt_debug\n\t\t\t;;\n      --dry-run|--dryrun|-n)\n\t\t\topt_dry_run=:\n\t\t\t;;\n      --config)\n\t\t\topt_config=:\nfunc_config\n\t\t\t;;\n      --dlopen|-dlopen)\n\t\t\toptarg=\"$1\"\n\t\t\topt_dlopen=\"${opt_dlopen+$opt_dlopen\n}$optarg\"\n\t\t\tshift\n\t\t\t;;\n      --preserve-dup-deps)\n\t\t\topt_preserve_dup_deps=:\n\t\t\t;;\n      --features)\n\t\t\topt_features=:\nfunc_features\n\t\t\t;;\n      --finish)\n\t\t\topt_finish=:\nset dummy --mode finish ${1+\"$@\"}; shift\n\t\t\t;;\n      --help)\n\t\t\topt_help=:\n\t\t\t;;\n      --help-all)\n\t\t\topt_help_all=:\nopt_help=': help-all'\n\t\t\t;;\n      --mode)\n\t\t\ttest $# = 0 && func_missing_arg $opt && break\n\t\t\toptarg=\"$1\"\n\t\t\topt_mode=\"$optarg\"\ncase $optarg in\n  # Valid mode arguments:\n  clean|compile|execute|finish|install|link|relink|uninstall) ;;\n\n  # Catch anything else as an error\n  *) func_error \"invalid argument for $opt\"\n     exit_cmd=exit\n     break\n     ;;\nesac\n\t\t\tshift\n\t\t\t;;\n      --no-silent|--no-quiet)\n\t\t\topt_silent=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --no-warning|--no-warn)\n\t\t\topt_warning=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --no-verbose)\n\t\t\topt_verbose=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --silent|--quiet)\n\t\t\topt_silent=:\nfunc_append preserve_args \" $opt\"\n        opt_verbose=false\n\t\t\t;;\n      --verbose|-v)\n\t\t\topt_verbose=:\nfunc_append preserve_args \" $opt\"\nopt_silent=false\n\t\t\t;;\n      --tag)\n\t\t\ttest $# = 0 && func_missing_arg $opt && break\n\t\t\toptarg=\"$1\"\n\t\t\topt_tag=\"$optarg\"\nfunc_append preserve_args \" $opt $optarg\"\nfunc_enable_tag \"$optarg\"\n\t\t\tshift\n\t\t\t;;\n\n      -\\?|-h)\t\tfunc_usage\t\t\t\t;;\n      --help)\t\tfunc_help\t\t\t\t;;\n      --version)\tfunc_version\t\t\t\t;;\n\n      # Separate optargs to long options:\n      --*=*)\n\t\t\tfunc_split_long_opt \"$opt\"\n\t\t\tset dummy \"$func_split_long_opt_name\" \"$func_split_long_opt_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      # Separate non-argument short options:\n      -\\?*|-h*|-n*|-v*)\n\t\t\tfunc_split_short_opt \"$opt\"\n\t\t\tset dummy \"$func_split_short_opt_name\" \"-$func_split_short_opt_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      --)\t\tbreak\t\t\t\t\t;;\n      -*)\t\tfunc_fatal_help \"unrecognized option \\`$opt'\" ;;\n      *)\t\tset dummy \"$opt\" ${1+\"$@\"};\tshift; break  ;;\n    esac\n  done\n\n  # Validate options:\n\n  # save first non-option argument\n  if test \"$#\" -gt 0; then\n    nonopt=\"$opt\"\n    shift\n  fi\n\n  # preserve --debug\n  test \"$opt_debug\" = : || func_append preserve_args \" --debug\"\n\n  case $host in\n    *cygwin* | *mingw* | *pw32* | *cegcc*)\n      # don't eliminate duplications in $postdeps and $predeps\n      opt_duplicate_compiler_generated_deps=:\n      ;;\n    *)\n      opt_duplicate_compiler_generated_deps=$opt_preserve_dup_deps\n      ;;\n  esac\n\n  $opt_help || {\n    # Sanity checks first:\n    func_check_version_match\n\n    if test \"$build_libtool_libs\" != yes && test \"$build_old_libs\" != yes; then\n      func_fatal_configuration \"not configured to build any kind of library\"\n    fi\n\n    # Darwin sucks\n    eval std_shrext=\\\"$shrext_cmds\\\"\n\n    # Only execute mode is allowed to have -dlopen flags.\n    if test -n \"$opt_dlopen\" && test \"$opt_mode\" != execute; then\n      func_error \"unrecognized option \\`-dlopen'\"\n      $ECHO \"$help\" 1>&2\n      exit $EXIT_FAILURE\n    fi\n\n    # Change the help message to a mode-specific one.\n    generic_help=\"$help\"\n    help=\"Try \\`$progname --help --mode=$opt_mode' for more information.\"\n  }\n\n\n  # Bail if the options were screwed\n  $exit_cmd $EXIT_FAILURE\n}\n\n\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\n# func_lalib_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null \\\n        | $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if `file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case \"$lalib_p_line\" in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test \"$lalib_p\" = yes\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    func_lalib_p \"$1\"\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_dirname_and_basename \"$1\" \"\" \".\"\n    func_stripname '' '.exe' \"$func_basename_result\"\n    func_ltwrapper_scriptname_result=\"$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\"\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $opt_debug\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$save_ifs\n      eval cmd=\\\"$cmd\\\"\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# `FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $opt_debug\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_resolve_sysroot PATH\n# Replace a leading = in PATH with a sysroot.  Store the result into\n# func_resolve_sysroot_result\nfunc_resolve_sysroot ()\n{\n  func_resolve_sysroot_result=$1\n  case $func_resolve_sysroot_result in\n  =*)\n    func_stripname '=' '' \"$func_resolve_sysroot_result\"\n    func_resolve_sysroot_result=$lt_sysroot$func_stripname_result\n    ;;\n  esac\n}\n\n# func_replace_sysroot PATH\n# If PATH begins with the sysroot, replace it with = and\n# store the result into func_replace_sysroot_result.\nfunc_replace_sysroot ()\n{\n  case \"$lt_sysroot:$1\" in\n  ?*:\"$lt_sysroot\"*)\n    func_stripname \"$lt_sysroot\" '' \"$1\"\n    func_replace_sysroot_result=\"=$func_stripname_result\"\n    ;;\n  *)\n    # Including no sysroot.\n    func_replace_sysroot_result=$1\n    ;;\n  esac\n}\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $opt_debug\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n\tfunc_append_quoted CC_quoted \"$arg\"\n      done\n      CC_expanded=`func_echo_all $CC`\n      CC_quoted_expanded=`func_echo_all $CC_quoted`\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n      \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_append_quoted CC_quoted \"$arg\"\n\t    done\n\t    CC_expanded=`func_echo_all $CC`\n\t    CC_quoted_expanded=`func_echo_all $CC_quoted`\n\t    case \"$@ \" in\n\t    \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n\t    \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with \\`--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=${1}\n    if test \"$build_libtool_libs\" = yes; then\n      write_lobj=\\'${2}\\'\n    else\n      write_lobj=none\n    fi\n\n    if test \"$build_old_libs\" = yes; then\n      write_oldobj=\\'${3}\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"${write_libobj}\"\n    }\n}\n\n\n##################################################\n# FILE NAME AND PATH CONVERSION HELPER FUNCTIONS #\n##################################################\n\n# func_convert_core_file_wine_to_w32 ARG\n# Helper function used by file name conversion functions when $build is *nix,\n# and $host is mingw, cygwin, or some other w32 environment. Relies on a\n# correctly configured wine environment available, with the winepath program\n# in $build's $PATH.\n#\n# ARG is the $build file name to be converted to w32 format.\n# Result is available in $func_convert_core_file_wine_to_w32_result, and will\n# be empty on error (or when ARG is empty)\nfunc_convert_core_file_wine_to_w32 ()\n{\n  $opt_debug\n  func_convert_core_file_wine_to_w32_result=\"$1\"\n  if test -n \"$1\"; then\n    # Unfortunately, winepath does not exit with a non-zero error code, so we\n    # are forced to check the contents of stdout. On the other hand, if the\n    # command is not found, the shell will set an exit code of 127 and print\n    # *an error message* to stdout. So we must check for both error code of\n    # zero AND non-empty stdout, which explains the odd construction:\n    func_convert_core_file_wine_to_w32_tmp=`winepath -w \"$1\" 2>/dev/null`\n    if test \"$?\" -eq 0 && test -n \"${func_convert_core_file_wine_to_w32_tmp}\"; then\n      func_convert_core_file_wine_to_w32_result=`$ECHO \"$func_convert_core_file_wine_to_w32_tmp\" |\n        $SED -e \"$lt_sed_naive_backslashify\"`\n    else\n      func_convert_core_file_wine_to_w32_result=\n    fi\n  fi\n}\n# end: func_convert_core_file_wine_to_w32\n\n\n# func_convert_core_path_wine_to_w32 ARG\n# Helper function used by path conversion functions when $build is *nix, and\n# $host is mingw, cygwin, or some other w32 environment. Relies on a correctly\n# configured wine environment available, with the winepath program in $build's\n# $PATH. Assumes ARG has no leading or trailing path separator characters.\n#\n# ARG is path to be converted from $build format to win32.\n# Result is available in $func_convert_core_path_wine_to_w32_result.\n# Unconvertible file (directory) names in ARG are skipped; if no directory names\n# are convertible, then the result may be empty.\nfunc_convert_core_path_wine_to_w32 ()\n{\n  $opt_debug\n  # unfortunately, winepath doesn't convert paths, only file names\n  func_convert_core_path_wine_to_w32_result=\"\"\n  if test -n \"$1\"; then\n    oldIFS=$IFS\n    IFS=:\n    for func_convert_core_path_wine_to_w32_f in $1; do\n      IFS=$oldIFS\n      func_convert_core_file_wine_to_w32 \"$func_convert_core_path_wine_to_w32_f\"\n      if test -n \"$func_convert_core_file_wine_to_w32_result\" ; then\n        if test -z \"$func_convert_core_path_wine_to_w32_result\"; then\n          func_convert_core_path_wine_to_w32_result=\"$func_convert_core_file_wine_to_w32_result\"\n        else\n          func_append func_convert_core_path_wine_to_w32_result \";$func_convert_core_file_wine_to_w32_result\"\n        fi\n      fi\n    done\n    IFS=$oldIFS\n  fi\n}\n# end: func_convert_core_path_wine_to_w32\n\n\n# func_cygpath ARGS...\n# Wrapper around calling the cygpath program via LT_CYGPATH. This is used when\n# when (1) $build is *nix and Cygwin is hosted via a wine environment; or (2)\n# $build is MSYS and $host is Cygwin, or (3) $build is Cygwin. In case (1) or\n# (2), returns the Cygwin file name or path in func_cygpath_result (input\n# file name or path is assumed to be in w32 format, as previously converted\n# from $build's *nix or MSYS format). In case (3), returns the w32 file name\n# or path in func_cygpath_result (input file name or path is assumed to be in\n# Cygwin format). Returns an empty string on error.\n#\n# ARGS are passed to cygpath, with the last one being the file name or path to\n# be converted.\n#\n# Specify the absolute *nix (or w32) name to cygpath in the LT_CYGPATH\n# environment variable; do not put it in $PATH.\nfunc_cygpath ()\n{\n  $opt_debug\n  if test -n \"$LT_CYGPATH\" && test -f \"$LT_CYGPATH\"; then\n    func_cygpath_result=`$LT_CYGPATH \"$@\" 2>/dev/null`\n    if test \"$?\" -ne 0; then\n      # on failure, ensure result is empty\n      func_cygpath_result=\n    fi\n  else\n    func_cygpath_result=\n    func_error \"LT_CYGPATH is empty or specifies non-existent file: \\`$LT_CYGPATH'\"\n  fi\n}\n#end: func_cygpath\n\n\n# func_convert_core_msys_to_w32 ARG\n# Convert file name or path ARG from MSYS format to w32 format.  Return\n# result in func_convert_core_msys_to_w32_result.\nfunc_convert_core_msys_to_w32 ()\n{\n  $opt_debug\n  # awkward: cmd appends spaces to result\n  func_convert_core_msys_to_w32_result=`( cmd //c echo \"$1\" ) 2>/dev/null |\n    $SED -e 's/[ ]*$//' -e \"$lt_sed_naive_backslashify\"`\n}\n#end: func_convert_core_msys_to_w32\n\n\n# func_convert_file_check ARG1 ARG2\n# Verify that ARG1 (a file name in $build format) was converted to $host\n# format in ARG2. Otherwise, emit an error message, but continue (resetting\n# func_to_host_file_result to ARG1).\nfunc_convert_file_check ()\n{\n  $opt_debug\n  if test -z \"$2\" && test -n \"$1\" ; then\n    func_error \"Could not determine host file name corresponding to\"\n    func_error \"  \\`$1'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback:\n    func_to_host_file_result=\"$1\"\n  fi\n}\n# end func_convert_file_check\n\n\n# func_convert_path_check FROM_PATHSEP TO_PATHSEP FROM_PATH TO_PATH\n# Verify that FROM_PATH (a path in $build format) was converted to $host\n# format in TO_PATH. Otherwise, emit an error message, but continue, resetting\n# func_to_host_file_result to a simplistic fallback value (see below).\nfunc_convert_path_check ()\n{\n  $opt_debug\n  if test -z \"$4\" && test -n \"$3\"; then\n    func_error \"Could not determine the host path corresponding to\"\n    func_error \"  \\`$3'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback.  This is a deliberately simplistic \"conversion\" and\n    # should not be \"improved\".  See libtool.info.\n    if test \"x$1\" != \"x$2\"; then\n      lt_replace_pathsep_chars=\"s|$1|$2|g\"\n      func_to_host_path_result=`echo \"$3\" |\n        $SED -e \"$lt_replace_pathsep_chars\"`\n    else\n      func_to_host_path_result=\"$3\"\n    fi\n  fi\n}\n# end func_convert_path_check\n\n\n# func_convert_path_front_back_pathsep FRONTPAT BACKPAT REPL ORIG\n# Modifies func_to_host_path_result by prepending REPL if ORIG matches FRONTPAT\n# and appending REPL if ORIG matches BACKPAT.\nfunc_convert_path_front_back_pathsep ()\n{\n  $opt_debug\n  case $4 in\n  $1 ) func_to_host_path_result=\"$3$func_to_host_path_result\"\n    ;;\n  esac\n  case $4 in\n  $2 ) func_append func_to_host_path_result \"$3\"\n    ;;\n  esac\n}\n# end func_convert_path_front_back_pathsep\n\n\n##################################################\n# $build to $host FILE NAME CONVERSION FUNCTIONS #\n##################################################\n# invoked via `$to_host_file_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# Result will be available in $func_to_host_file_result.\n\n\n# func_to_host_file ARG\n# Converts the file name ARG from $build format to $host format. Return result\n# in func_to_host_file_result.\nfunc_to_host_file ()\n{\n  $opt_debug\n  $to_host_file_cmd \"$1\"\n}\n# end func_to_host_file\n\n\n# func_to_tool_file ARG LAZY\n# converts the file name ARG from $build format to toolchain format. Return\n# result in func_to_tool_file_result.  If the conversion in use is listed\n# in (the comma separated) LAZY, no conversion takes place.\nfunc_to_tool_file ()\n{\n  $opt_debug\n  case ,$2, in\n    *,\"$to_tool_file_cmd\",*)\n      func_to_tool_file_result=$1\n      ;;\n    *)\n      $to_tool_file_cmd \"$1\"\n      func_to_tool_file_result=$func_to_host_file_result\n      ;;\n  esac\n}\n# end func_to_tool_file\n\n\n# func_convert_file_noop ARG\n# Copy ARG to func_to_host_file_result.\nfunc_convert_file_noop ()\n{\n  func_to_host_file_result=\"$1\"\n}\n# end func_convert_file_noop\n\n\n# func_convert_file_msys_to_w32 ARG\n# Convert file name ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_msys_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_to_host_file_result=\"$func_convert_core_msys_to_w32_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_w32\n\n\n# func_convert_file_cygwin_to_w32 ARG\n# Convert file name ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_cygwin_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    # because $build is cygwin, we call \"the\" cygpath in $PATH; no need to use\n    # LT_CYGPATH in this case.\n    func_to_host_file_result=`cygpath -m \"$1\"`\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_cygwin_to_w32\n\n\n# func_convert_file_nix_to_w32 ARG\n# Convert file name ARG from *nix to w32 format.  Requires a wine environment\n# and a working winepath. Returns result in func_to_host_file_result.\nfunc_convert_file_nix_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_to_host_file_result=\"$func_convert_core_file_wine_to_w32_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_w32\n\n\n# func_convert_file_msys_to_cygwin ARG\n# Convert file name ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_file_msys_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_file_result=\"$func_cygpath_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_cygwin\n\n\n# func_convert_file_nix_to_cygwin ARG\n# Convert file name ARG from *nix to Cygwin format.  Requires Cygwin installed\n# in a wine environment, working winepath, and LT_CYGPATH set.  Returns result\n# in func_to_host_file_result.\nfunc_convert_file_nix_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_file_wine_to_w32_result\"\n    func_to_host_file_result=\"$func_cygpath_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_cygwin\n\n\n#############################################\n# $build to $host PATH CONVERSION FUNCTIONS #\n#############################################\n# invoked via `$to_host_path_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# The result will be available in $func_to_host_path_result.\n#\n# Path separators are also converted from $build format to $host format.  If\n# ARG begins or ends with a path separator character, it is preserved (but\n# converted to $host format) on output.\n#\n# All path conversion functions are named using the following convention:\n#   file name conversion function    : func_convert_file_X_to_Y ()\n#   path conversion function         : func_convert_path_X_to_Y ()\n# where, for any given $build/$host combination the 'X_to_Y' value is the\n# same.  If conversion functions are added for new $build/$host combinations,\n# the two new functions must follow this pattern, or func_init_to_host_path_cmd\n# will break.\n\n\n# func_init_to_host_path_cmd\n# Ensures that function \"pointer\" variable $to_host_path_cmd is set to the\n# appropriate value, based on the value of $to_host_file_cmd.\nto_host_path_cmd=\nfunc_init_to_host_path_cmd ()\n{\n  $opt_debug\n  if test -z \"$to_host_path_cmd\"; then\n    func_stripname 'func_convert_file_' '' \"$to_host_file_cmd\"\n    to_host_path_cmd=\"func_convert_path_${func_stripname_result}\"\n  fi\n}\n\n\n# func_to_host_path ARG\n# Converts the path ARG from $build format to $host format. Return result\n# in func_to_host_path_result.\nfunc_to_host_path ()\n{\n  $opt_debug\n  func_init_to_host_path_cmd\n  $to_host_path_cmd \"$1\"\n}\n# end func_to_host_path\n\n\n# func_convert_path_noop ARG\n# Copy ARG to func_to_host_path_result.\nfunc_convert_path_noop ()\n{\n  func_to_host_path_result=\"$1\"\n}\n# end func_convert_path_noop\n\n\n# func_convert_path_msys_to_w32 ARG\n# Convert path ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_path_result.\nfunc_convert_path_msys_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from ARG.  MSYS\n    # behavior is inconsistent here; cygpath turns them into '.;' and ';.';\n    # and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=\"$func_convert_core_msys_to_w32_result\"\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_w32\n\n\n# func_convert_path_cygwin_to_w32 ARG\n# Convert path ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_cygwin_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_to_host_path_result=`cygpath -m -p \"$func_to_host_path_tmp1\"`\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_cygwin_to_w32\n\n\n# func_convert_path_nix_to_w32 ARG\n# Convert path ARG from *nix to w32 format.  Requires a wine environment and\n# a working winepath.  Returns result in func_to_host_file_result.\nfunc_convert_path_nix_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=\"$func_convert_core_path_wine_to_w32_result\"\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_w32\n\n\n# func_convert_path_msys_to_cygwin ARG\n# Convert path ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_path_msys_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_path_result=\"$func_cygpath_result\"\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_cygwin\n\n\n# func_convert_path_nix_to_cygwin ARG\n# Convert path ARG from *nix to Cygwin format.  Requires Cygwin installed in a\n# a wine environment, working winepath, and LT_CYGPATH set.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_nix_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from\n    # ARG. msys behavior is inconsistent here, cygpath turns them\n    # into '.;' and ';.', and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_path_wine_to_w32_result\"\n    func_to_host_path_result=\"$func_cygpath_result\"\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_cygwin\n\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $opt_debug\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=\"$nonopt\"  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=\"$arg\"\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=\"$arg\"\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify \\`-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          func_append pie_flag \" $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  func_append later \" $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=\"$IFS\"; IFS=','\n\t  for arg in $args; do\n\t    IFS=\"$save_ifs\"\n\t    func_append_quoted lastarg \"$arg\"\n\t  done\n\t  IFS=\"$save_ifs\"\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  func_append base_compile \" $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=\"$srcfile\"\n\t  srcfile=\"$arg\"\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_append_quoted base_compile \"$lastarg\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with \\`-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=\"$func_basename_result\"\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from \\`$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name \\`$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=\"$func_basename_result\"\n    xdir=\"$func_dirname_result\"\n    lobj=${xdir}$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test \"$build_old_libs\" = yes; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test \"$pic_mode\" = no && test \"$deplibs_check_method\" != pass_all; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test \"$compiler_c_o\" = no; then\n      output_obj=`$ECHO \"$srcfile\" | $SED 's%^.*/%%; s%\\.[^.]*$%%'`.${objext}\n      lockfile=\"$output_obj.lock\"\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test \"$need_locks\" = yes; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test \"$need_locks\" = warn; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      func_append removelist \" $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    func_append removelist \" $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    func_to_tool_file \"$srcfile\" func_convert_file_msys_to_w32\n    srcfile=$func_to_tool_file_result\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test \"$build_libtool_libs\" = yes; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test \"$pic_mode\" != no; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tfunc_append command \" -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test \"$suppress_opt\" = yes; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test \"$build_old_libs\" = yes; then\n      if test \"$pic_mode\" != yes; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test \"$compiler_c_o\" = yes; then\n\tfunc_append command \" -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      func_append command \"$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test \"$need_locks\" != no; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\n  test \"$opt_mode\" = compile && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $opt_mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to build PIC objects only\n  -prefer-non-pic   try to build non-PIC objects only\n  -shared           do not build a \\`.o' file suitable for static linking\n  -static           only build a \\`.o' file suitable for static linking\n  -Wc,FLAG          pass FLAG directly to the compiler\n\nCOMPILE-COMMAND is a command to be used in creating a \\`standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix \\`.c' with the\nlibrary object suffix, \\`.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to \\`-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe \\`--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the \\`install' or \\`cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -bindir BINDIR    specify path to binaries directory (for systems where\n                    libraries must be found in the PATH setting at runtime)\n  -dlopen FILE      \\`-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  Use a list of object files found in FILE to specify objects\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n  -Wc,FLAG\n  -Xcompiler FLAG   pass linker-specific FLAG directly to the compiler\n  -Wl,FLAG\n  -Xlinker FLAG     pass linker-specific FLAG directly to the linker\n  -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)\n\nAll other options (arguments beginning with \\`-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in \\`.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in \\`.la', then a libtool library is created,\nonly library objects (\\`.lo' files) may be specified, and \\`-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in \\`.a' or \\`.lib', then a standard library is created\nusing \\`ar' and \\`ranlib', or on Windows using \\`lib'.\n\nIf OUTPUT-FILE ends in \\`.lo' or \\`.${objext}', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode \\`$opt_mode'\"\n        ;;\n    esac\n\n    echo\n    $ECHO \"Try \\`$progname --help' for more information about other modes.\"\n}\n\n# Now that we've collected a possible --mode arg, show help if necessary\nif $opt_help; then\n  if test \"$opt_help\" = :; then\n    func_mode_help\n  else\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\tfunc_mode_help\n      done\n    } | sed -n '1p; 2,$s/^Usage:/  or: /p'\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\techo\n\tfunc_mode_help\n      done\n    } |\n    sed '1d\n      /^When reporting/,/^Report/{\n\tH\n\td\n      }\n      $x\n      /information about other modes/d\n      /more detailed .*MODE/d\n      s/^Usage:.*--mode=\\([^ ]*\\) .*/Description of \\1 mode:/'\n  fi\n  exit $?\nfi\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $opt_debug\n    # The first argument is the command name.\n    cmd=\"$nonopt\"\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $opt_dlopen; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"\\`$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"\\`$file' was not linked with \\`-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  func_append dir \"/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find \\`$dlname' in \\`$dir' or \\`$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\t;;\n\n      *)\n\tfunc_warning \"\\`-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=\"$absdir\"\n\n      # Now add the directory to shlibpath_var.\n      if eval \"test -z \\\"\\$$shlibpath_var\\\"\"; then\n\teval \"$shlibpath_var=\\\"\\$dir\\\"\"\n      else\n\teval \"$shlibpath_var=\\\"\\$dir:\\$$shlibpath_var\\\"\"\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=\"$magic\"\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -* | *.la | *.lo ) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_append_quoted args \"$file\"\n    done\n\n    if test \"X$opt_dry_run\" = Xfalse; then\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\"\\$cmd$args\"\n    else\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\techo \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$opt_mode\" = execute && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $opt_debug\n    libs=\n    libdirs=\n    admincmds=\n\n    for opt in \"$nonopt\" ${1+\"$@\"}\n    do\n      if test -d \"$opt\"; then\n\tfunc_append libdirs \" $opt\"\n\n      elif test -f \"$opt\"; then\n\tif func_lalib_unsafe_p \"$opt\"; then\n\t  func_append libs \" $opt\"\n\telse\n\t  func_warning \"\\`$opt' is not a valid libtool archive\"\n\tfi\n\n      else\n\tfunc_fatal_error \"invalid argument \\`$opt'\"\n      fi\n    done\n\n    if test -n \"$libs\"; then\n      if test -n \"$lt_sysroot\"; then\n        sysroot_regex=`$ECHO \"$lt_sysroot\" | $SED \"$sed_make_literal_regex\"`\n        sysroot_cmd=\"s/\\([ ']\\)$sysroot_regex/\\1/g;\"\n      else\n        sysroot_cmd=\n      fi\n\n      # Remove sysroot references\n      if $opt_dry_run; then\n        for lib in $libs; do\n          echo \"removing references to $lt_sysroot and \\`=' prefixes from $lib\"\n        done\n      else\n        tmpdir=`func_mktempdir`\n        for lib in $libs; do\n\t  sed -e \"${sysroot_cmd} s/\\([ ']-[LR]\\)=/\\1/g; s/\\([ ']\\)=/\\1/g\" $lib \\\n\t    > $tmpdir/tmp-la\n\t  mv -f $tmpdir/tmp-la $lib\n\tdone\n        ${RM}r \"$tmpdir\"\n      fi\n    fi\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || func_append admincmds \"\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_silent && exit $EXIT_SUCCESS\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      echo \"----------------------------------------------------------------------\"\n      echo \"Libraries have been installed in:\"\n      for libdir in $libdirs; do\n\t$ECHO \"   $libdir\"\n      done\n      echo\n      echo \"If you ever happen to want to link against installed libraries\"\n      echo \"in a given directory, LIBDIR, you must either use libtool, and\"\n      echo \"specify the full pathname of the library, or use the \\`-LLIBDIR'\"\n      echo \"flag during linking and do at least one of the following:\"\n      if test -n \"$shlibpath_var\"; then\n\techo \"   - add LIBDIR to the \\`$shlibpath_var' environment variable\"\n\techo \"     during execution\"\n      fi\n      if test -n \"$runpath_var\"; then\n\techo \"   - add LIBDIR to the \\`$runpath_var' environment variable\"\n\techo \"     during linking\"\n      fi\n      if test -n \"$hardcode_libdir_flag_spec\"; then\n\tlibdir=LIBDIR\n\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\n\t$ECHO \"   - use the \\`$flag' linker flag\"\n      fi\n      if test -n \"$admincmds\"; then\n\t$ECHO \"   - have your system administrator run these commands:$admincmds\"\n      fi\n      if test -f /etc/ld.so.conf; then\n\techo \"   - have your system administrator add LIBDIR to \\`/etc/ld.so.conf'\"\n      fi\n      echo\n\n      echo \"See any operating system documentation about shared libraries for\"\n      case $host in\n\tsolaris2.[6789]|solaris2.1[0-9])\n\t  echo \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\t  echo \"pages.\"\n\t  ;;\n\t*)\n\t  echo \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n\t  ;;\n      esac\n      echo \"----------------------------------------------------------------------\"\n    fi\n    exit $EXIT_SUCCESS\n}\n\ntest \"$opt_mode\" = finish && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $opt_debug\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$nonopt\" = \"$SHELL\" || test \"$nonopt\" = /bin/sh ||\n       # Allow the use of GNU shtool's install command.\n       case $nonopt in *shtool*) :;; *) false;; esac; then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    func_append install_prog \"$func_quote_for_eval_result\"\n    install_shared_prog=$install_prog\n    case \" $install_prog \" in\n      *[\\\\\\ /]cp\\ *) install_cp=: ;;\n      *) install_cp=false ;;\n    esac\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=no\n    stripme=\n    no_mode=:\n    for arg\n    do\n      arg2=\n      if test -n \"$dest\"; then\n\tfunc_append files \" $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=yes ;;\n      -f)\n\tif $install_cp; then :; else\n\t  prev=$arg\n\tfi\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  if test \"x$prev\" = x-m && test -n \"$install_override_mode\"; then\n\t    arg2=$install_override_mode\n\t    no_mode=false\n\t  fi\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      func_append install_prog \" $func_quote_for_eval_result\"\n      if test -n \"$arg2\"; then\n\tfunc_quote_for_eval \"$arg2\"\n      fi\n      func_append install_shared_prog \" $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prev' option requires an argument\"\n\n    if test -n \"$install_override_mode\" && $no_mode; then\n      if $install_cp; then :; else\n\tfunc_quote_for_eval \"$install_override_mode\"\n\tfunc_append install_shared_prog \" -m $func_quote_for_eval_result\"\n      fi\n    fi\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=yes\n    if test \"$isdir\" = yes; then\n      destdir=\"$dest\"\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=\"$func_dirname_result\"\n      destname=\"$func_basename_result\"\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"\\`$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"\\`$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tfunc_append staticlibs \" $file\"\n\t;;\n\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append current_libdirs \" $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append future_libdirs \" $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=\"$func_dirname_result\"\n\tfunc_append dir \"$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"$destdir\" | $SED -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install \\`$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking \\`$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink \\`$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=\"$1\"\n\t  shift\n\n\t  srcname=\"$realname\"\n\t  test -n \"$relink_command\" && srcname=\"$realname\"T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_shared_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=\"$stripme\"\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\"\"\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try `ln -sf' first, because the `ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=\"$destdir/$realname\"\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=\"$func_basename_result\"\n\tinstname=\"$dir/$name\"i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && func_append staticlibs \" $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=\"$destfile\"\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to \\`$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test \"$build_old_libs\" = yes; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\"\"\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=\".exe\"\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script \\`$wrapper'\"\n\n\t  finalize=yes\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=\"$libdir/\"`$ECHO \"$lib\" | $SED 's%^.*/%%g'` ### testsuite: skip nested quoting test\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"\\`$lib' has not been installed in \\`$libdir'\"\n\t      finalize=no\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test \"$fast_install\" = no && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if test \"$finalize\" = yes; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=\"$func_basename_result\"\n\t        outputname=\"$tmpdir/$file\"\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"$relink_command\" | $SED 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_silent || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink \\`$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=\"$outputname\"\n\t      else\n\t        func_warning \"cannot relink \\`$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"$file$stripped_ext\" | $SED \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n\n      # Set up the ranlib parameters.\n      oldlib=\"$destdir/$name\"\n      func_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n      tool_oldlib=$func_to_tool_file_result\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $tool_oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run \\`$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\"; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$opt_mode\" = install && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $opt_debug\n    my_outputname=\"$1\"\n    my_originator=\"$2\"\n    my_pic_p=\"${3-no}\"\n    my_prefix=`$ECHO \"$my_originator\" | sed 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=\"${my_outputname}S.c\"\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=\"$output_objdir/${my_outputname}.nm\"\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for \\`$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))\n#pragma GCC diagnostic ignored \\\"-Wstrict-prototypes\\\"\n#endif\n\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)\n/* DATA imports from DLLs on WIN32 con't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT_DLSYM_CONST\n#elif defined(__osf__)\n/* This system does not cope well with relocations in const data.  */\n# define LT_DLSYM_CONST\n#else\n# define LT_DLSYM_CONST const\n#endif\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test \"$dlself\" = yes; then\n\t  func_verbose \"generating symbol list for \\`$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"$objs$old_deplibs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_to_tool_file \"$progfile\" func_convert_file_msys_to_w32\n\t    func_verbose \"extracting global C symbols from \\`$func_to_tool_file_result'\"\n\t    $opt_dry_run || eval \"$NM $func_to_tool_file_result | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=\"$output_objdir/$outputname.exp\"\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      eval \"${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' \"'< \"$nlist\" > \"$export_symbols\"'\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n                eval 'cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"'\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      eval \"${SED} -e 's/\\([].[*^$]\\)/\\\\\\\\\\1/g' -e 's/^/ /' -e 's/$/$/'\"' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"'\n\t      eval '$GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t      case $host in\n\t        *cygwin* | *mingw* | *cegcc* )\n\t          eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n\t          eval 'cat \"$nlist\" >> \"$output_objdir/$outputname.def\"'\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from \\`$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=\"$func_basename_result\"\n          case $host in\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # if an import library, we need to obtain dlname\n\t      if func_win32_import_lib_p \"$dlprefile\"; then\n\t        func_tr_sh \"$dlprefile\"\n\t        eval \"curr_lafile=\\$libfile_$func_tr_sh_result\"\n\t        dlprefile_dlbasename=\"\"\n\t        if test -n \"$curr_lafile\" && func_lalib_p \"$curr_lafile\"; then\n\t          # Use subshell, to avoid clobbering current variable values\n\t          dlprefile_dlname=`source \"$curr_lafile\" && echo \"$dlname\"`\n\t          if test -n \"$dlprefile_dlname\" ; then\n\t            func_basename \"$dlprefile_dlname\"\n\t            dlprefile_dlbasename=\"$func_basename_result\"\n\t          else\n\t            # no lafile. user explicitly requested -dlpreopen <import library>.\n\t            $sharedlib_from_linklib_cmd \"$dlprefile\"\n\t            dlprefile_dlbasename=$sharedlib_from_linklib_result\n\t          fi\n\t        fi\n\t        $opt_dry_run || {\n\t          if test -n \"$dlprefile_dlbasename\" ; then\n\t            eval '$ECHO \": $dlprefile_dlbasename\" >> \"$nlist\"'\n\t          else\n\t            func_warning \"Could not compute DLL name from $name\"\n\t            eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          fi\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe |\n\t            $SED -e '/I __imp/d' -e 's/I __nm_/D /;s/_nm__//' >> '$nlist'\"\n\t        }\n\t      else # not an import lib\n\t        $opt_dry_run || {\n\t          eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t        }\n\t      fi\n\t    ;;\n\t    *)\n\t      $opt_dry_run || {\n\t        eval '$ECHO \": $name \" >> \"$nlist\"'\n\t        func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t        eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t      }\n\t    ;;\n          esac\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    echo '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\nextern LT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\nLT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{\\\n  { \\\"$my_originator\\\", (void *) 0 },\"\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2.*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    if test \"X$my_pic_p\" != Xno; then\n\t      pic_flag_for_symtable=\" $pic_flag\"\n\t    fi\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) func_append symtab_cflags \" $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=\"$output_objdir/${my_outputname}S.$objext\"\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for \\`$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"$compile_command\" | $SED \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"$finalize_command\" | $SED \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\n# Despite the name, also deal with 64 bit binaries.\nfunc_win32_libid ()\n{\n  $opt_debug\n  win32_libid_type=\"unknown\"\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    # Keep the egrep pattern in sync with the one in _LT_CHECK_MAGIC_METHOD.\n    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then\n      func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n      win32_nmres=`eval $NM -f posix -A \\\"$func_to_tool_file_result\\\" |\n\t$SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s,.*,import,\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n# func_cygming_dll_for_implib ARG\n#\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib ()\n{\n  $opt_debug\n  sharedlib_from_linklib_result=`$DLLTOOL --identify-strict --identify \"$1\"`\n}\n\n# func_cygming_dll_for_implib_fallback_core SECTION_NAME LIBNAMEs\n#\n# The is the core of a fallback implementation of a\n# platform-specific function to extract the name of the\n# DLL associated with the specified import library LIBNAME.\n#\n# SECTION_NAME is either .idata$6 or .idata$7, depending\n# on the platform and compiler that created the implib.\n#\n# Echos the name of the DLL associated with the\n# specified import library.\nfunc_cygming_dll_for_implib_fallback_core ()\n{\n  $opt_debug\n  match_literal=`$ECHO \"$1\" | $SED \"$sed_make_literal_regex\"`\n  $OBJDUMP -s --section \"$1\" \"$2\" 2>/dev/null |\n    $SED '/^Contents of section '\"$match_literal\"':/{\n      # Place marker at beginning of archive member dllname section\n      s/.*/====MARK====/\n      p\n      d\n    }\n    # These lines can sometimes be longer than 43 characters, but\n    # are always uninteresting\n    /:[\t ]*file format pe[i]\\{,1\\}-/d\n    /^In archive [^:]*:/d\n    # Ensure marker is printed\n    /^====MARK====/p\n    # Remove all lines with less than 43 characters\n    /^.\\{43\\}/!d\n    # From remaining lines, remove first 43 characters\n    s/^.\\{43\\}//' |\n    $SED -n '\n      # Join marker and all lines until next marker into a single line\n      /^====MARK====/ b para\n      H\n      $ b para\n      b\n      :para\n      x\n      s/\\n//g\n      # Remove the marker\n      s/^====MARK====//\n      # Remove trailing dots and whitespace\n      s/[\\. \\t]*$//\n      # Print\n      /./p' |\n    # we now have a list, one entry per line, of the stringified\n    # contents of the appropriate section of all members of the\n    # archive which possess that section. Heuristic: eliminate\n    # all those which have a first or second character that is\n    # a '.' (that is, objdump's representation of an unprintable\n    # character.) This should work for all archives with less than\n    # 0x302f exports -- but will fail for DLLs whose name actually\n    # begins with a literal '.' or a single character followed by\n    # a '.'.\n    #\n    # Of those that remain, print the first one.\n    $SED -e '/^\\./d;/^.\\./d;q'\n}\n\n# func_cygming_gnu_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is a GNU/binutils-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_gnu_implib_p ()\n{\n  $opt_debug\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_gnu_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $EGREP ' (_head_[A-Za-z0-9_]+_[ad]l*|[A-Za-z0-9_]+_[ad]l*_iname)$'`\n  test -n \"$func_cygming_gnu_implib_tmp\"\n}\n\n# func_cygming_ms_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is an MS-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_ms_implib_p ()\n{\n  $opt_debug\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_ms_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $GREP '_NULL_IMPORT_DESCRIPTOR'`\n  test -n \"$func_cygming_ms_implib_tmp\"\n}\n\n# func_cygming_dll_for_implib_fallback ARG\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n#\n# This fallback implementation is for use when $DLLTOOL\n# does not support the --identify-strict option.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib_fallback ()\n{\n  $opt_debug\n  if func_cygming_gnu_implib_p \"$1\" ; then\n    # binutils import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$7' \"$1\"`\n  elif func_cygming_ms_implib_p \"$1\" ; then\n    # ms-generated import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$6' \"$1\"`\n  else\n    # unknown\n    sharedlib_from_linklib_result=\"\"\n  fi\n}\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $opt_debug\n    f_ex_an_ar_dir=\"$1\"; shift\n    f_ex_an_ar_oldlib=\"$1\"\n    if test \"$lock_old_archive_extraction\" = yes; then\n      lockfile=$f_ex_an_ar_oldlib.lock\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    fi\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" \\\n\t\t   'stat=$?; rm -f \"$lockfile\"; exit $stat'\n    if test \"$lock_old_archive_extraction\" = yes; then\n      $opt_dry_run || rm -f \"$lockfile\"\n    fi\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $opt_debug\n    my_gentop=\"$1\"; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\"\"\n    my_xlib=\"\"\n    my_xabs=\"\"\n    my_xdir=\"\"\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=\"$my_xlib\" ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=\"$func_basename_result\"\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=\"$my_gentop/$my_xlib_u\"\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  darwin_base_archive=`basename \"$darwin_archive\"`\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches ; do\n\t      func_mkdir_p \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\" \"${darwin_archive}\"\n\t      cd \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      func_extract_an_archive \"`pwd`\" \"${darwin_base_archive}\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | sort | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | sort | $NL2SP`\n    done\n\n    func_extract_archives_result=\"$my_oldobjs\"\n}\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory in which it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=${1-no}\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    file=\\\"\\$0\\\"\"\n\n    qECHO=`$ECHO \"$ECHO\" | $SED \"$sed_quote_subst\"`\n    $ECHO \"\\\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$1\n_LTECHO_EOF'\n}\n    ECHO=\\\"$qECHO\\\"\n  fi\n\n# Very basic option parsing. These options are (a) specific to\n# the libtool wrapper, (b) are identical between the wrapper\n# /script/ and the wrapper /executable/ which is used only on\n# windows platforms, and (c) all begin with the string \"--lt-\"\n# (application programs are unlikely to have options which match\n# this pattern).\n#\n# There are only two supported options: --lt-debug and\n# --lt-dump-script. There is, deliberately, no --lt-help.\n#\n# The first argument to this parsing function should be the\n# script's $0 value, followed by \"$@\".\nlt_option_debug=\nfunc_parse_lt_options ()\n{\n  lt_script_arg0=\\$0\n  shift\n  for lt_opt\n  do\n    case \\\"\\$lt_opt\\\" in\n    --lt-debug) lt_option_debug=1 ;;\n    --lt-dump-script)\n        lt_dump_D=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%/[^/]*$%%'\\`\n        test \\\"X\\$lt_dump_D\\\" = \\\"X\\$lt_script_arg0\\\" && lt_dump_D=.\n        lt_dump_F=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%^.*/%%'\\`\n        cat \\\"\\$lt_dump_D/\\$lt_dump_F\\\"\n        exit 0\n      ;;\n    --lt-*)\n        \\$ECHO \\\"Unrecognized --lt- option: '\\$lt_opt'\\\" 1>&2\n        exit 1\n      ;;\n    esac\n  done\n\n  # Print the debug banner immediately:\n  if test -n \\\"\\$lt_option_debug\\\"; then\n    echo \\\"${outputname}:${output}:\\${LINENO}: libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\\\" 1>&2\n  fi\n}\n\n# Used when --lt-debug. Prints its arguments to stdout\n# (redirection is the responsibility of the caller)\nfunc_lt_dump_args ()\n{\n  lt_dump_args_N=1;\n  for lt_arg\n  do\n    \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[\\$lt_dump_args_N]: \\$lt_arg\\\"\n    lt_dump_args_N=\\`expr \\$lt_dump_args_N + 1\\`\n  done\n}\n\n# Core function for launching the target application\nfunc_exec_program_core ()\n{\n\"\n  case $host in\n  # Backslashes separate directories on plain windows\n  *-*-mingw | *-*-os2* | *-cegcc*)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[0]: \\$progdir\\\\\\\\\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n\n  *)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[0]: \\$progdir/\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n  esac\n  $ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n}\n\n# A function to encapsulate launching the target application\n# Strips options in the --lt-* namespace from \\$@ and\n# launches target application with the remaining arguments.\nfunc_exec_program ()\n{\n  case \\\" \\$* \\\" in\n  *\\\\ --lt-*)\n    for lt_wr_arg\n    do\n      case \\$lt_wr_arg in\n      --lt-*) ;;\n      *) set x \\\"\\$@\\\" \\\"\\$lt_wr_arg\\\"; shift;;\n      esac\n      shift\n    done ;;\n  esac\n  func_exec_program_core \\${1+\\\"\\$@\\\"}\n}\n\n  # Parse options\n  func_parse_lt_options \\\"\\$0\\\" \\${1+\\\"\\$@\\\"}\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  done\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"\\$thisdir\\\" | $SED 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test \"$fast_install\" = yes; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | ${SED} 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\$relink_command 2>&1\\`; then :\n      else\n\t$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# fixup the dll searchpath if we need to.\n\t#\n\t# Fix the DLL searchpath if we need to.  Do this before prepending\n\t# to shlibpath, because on Windows, both are PATH and uninstalled\n\t# libraries must come first.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t# Export our shlibpath_var if we have one.\n\tif test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" | $SED 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n      func_exec_program \\${1+\\\"\\$@\\\"}\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: \\\\\\`\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    \\$ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#ifdef _MSC_VER\n# define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n/* declarations of non-ANSI functions */\n#if defined(__MINGW32__)\n# ifdef __STRICT_ANSI__\nint _putenv (const char *);\n# endif\n#elif defined(__CYGWIN__)\n# ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n# endif\n/* #elif defined (other platforms) ... */\n#endif\n\n/* portability defines, excluding path handling macros */\n#if defined(_MSC_VER)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n# define S_IXUSR _S_IEXEC\n# ifndef _INTPTR_T_DEFINED\n#  define _INTPTR_T_DEFINED\n#  define intptr_t int\n# endif\n#elif defined(__MINGW32__)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n#elif defined(__CYGWIN__)\n# define HAVE_SETENV\n# define FOPEN_WB \"wb\"\n/* #elif defined (other platforms) ... */\n#endif\n\n#if defined(PATH_MAX)\n# define LT_PATHMAX PATH_MAX\n#elif defined(MAXPATHLEN)\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n/* path handling portability macros */\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \\\n  defined (__OS2__)\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free ((void *) stale); stale = 0; } \\\n} while (0)\n\n#if defined(LT_DEBUGWRAPPER)\nstatic int lt_debug = 1;\n#else\nstatic int lt_debug = 0;\n#endif\n\nconst char *program_name = \"libtool-wrapper\"; /* in case xstrdup fails */\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_debugprintf (const char *file, int line, const char *fmt, ...);\nvoid lt_fatal (const char *file, int line, const char *message, ...);\nstatic const char *nonnull (const char *s);\nstatic const char *nonempty (const char *s);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\nchar **prepare_spawn (char **argv);\nvoid lt_dump_script (FILE *f);\nEOF\n\n\t    cat <<EOF\nvolatile const char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_path \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_path \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test \"$fast_install\" = yes; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\nstatic const char *debug_opt            = LTWRAPPER_OPTION_PREFIX \"debug\";\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  intptr_t rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  newargz = XMALLOC (char *, argc + 1);\n\n  /* very simple arg parsing; don't want to rely on getopt\n   * also, copy all non cwrapper options to newargz, except\n   * argz[0], which is handled differently\n   */\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], dumpscript_opt) == 0)\n\t{\nEOF\n\t    case \"$host\" in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  lt_dump_script (stdout);\n\t  return 0;\n\t}\n      if (strcmp (argv[i], debug_opt) == 0)\n\t{\n          lt_debug = 1;\n          continue;\n\t}\n      if (strcmp (argv[i], ltwrapper_option_prefix) == 0)\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (__FILE__, __LINE__,\n\t\t    \"unrecognized %s option: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\nEOF\n\t    cat <<EOF\n  /* The GNU banner must be the first non-error debug message */\n  lt_debugprintf (__FILE__, __LINE__, \"libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\\n\");\nEOF\n\t    cat <<\"EOF\"\n  lt_debugprintf (__FILE__, __LINE__, \"(main) argv[0]: %s\\n\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__, \"(main) program_name: %s\\n\", program_name);\n\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (__FILE__, __LINE__, \"couldn't find %s\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (before symlink chase) at: %s\\n\",\n\t\t  tmp_pathspec);\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (after symlink chase) at: %s\\n\",\n\t\t  actual_cwrapper_path);\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup (base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(main) libtool target name: %s\\n\",\n\t\t  target_name);\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  /* Update the DLL searchpath.  EXE_PATH_VALUE ($dllsearchpath) must\n     be prepended before (that is, appear after) LIB_PATH_VALUE ($temp_rpath)\n     because on Windows, both *_VARNAMEs are PATH but uninstalled\n     libraries must come first. */\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n\n  lt_debugprintf (__FILE__, __LINE__, \"(main) lt_argv_zero: %s\\n\",\n\t\t  nonnull (lt_argv_zero));\n  for (i = 0; i < newargc; i++)\n    {\n      lt_debugprintf (__FILE__, __LINE__, \"(main) newargz[%d]: %s\\n\",\n\t\t      i, nonnull (newargz[i]));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  newargz = prepare_spawn (newargz);\n  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"(main) failed to launch target \\\"%s\\\": %s\\n\",\n\t\t      lt_argv_zero, nonnull (strerror (errno)));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (__FILE__, __LINE__, \"memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(check_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(make_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  int tmp_len;\n  char *concat_name;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(find_executable): %s\\n\",\n                  nonempty (wrapper));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = q - p;\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n                              nonnull (strerror (errno)));\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n              nonnull (strerror (errno)));\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"checking path component for symlinks: %s\\n\",\n\t\t      tmp_pathspec);\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  lt_fatal (__FILE__, __LINE__,\n\t\t    \"error accessing file \\\"%s\\\": %s\",\n\t\t    tmp_pathspec, nonnull (strerror (errno)));\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (__FILE__, __LINE__,\n\t\t\"could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (strcmp (str, pat) == 0)\n\t*str = '\\0';\n    }\n  return str;\n}\n\nvoid\nlt_debugprintf (const char *file, int line, const char *fmt, ...)\n{\n  va_list args;\n  if (lt_debug)\n    {\n      (void) fprintf (stderr, \"%s:%s:%d: \", program_name, file, line);\n      va_start (args, fmt);\n      (void) vfprintf (stderr, fmt, args);\n      va_end (args);\n    }\n}\n\nstatic void\nlt_error_core (int exit_status, const char *file,\n\t       int line, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s:%s:%d: %s: \", program_name, file, line, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *file, int line, const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, file, line, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nstatic const char *\nnonnull (const char *s)\n{\n  return s ? s : \"(null)\";\n}\n\nstatic const char *\nnonempty (const char *s)\n{\n  return (s && !*s) ? \"(empty)\" : nonnull (s);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_setenv) setting '%s' to '%s'\\n\",\n                  nonnull (name), nonnull (value));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    int len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      int orig_value_len = strlen (orig_value);\n      int add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      int len = strlen (new_value);\n      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[len-1] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nEOF\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n\n/* Prepares an argument vector before calling spawn().\n   Note that spawn() does not by itself call the command interpreter\n     (getenv (\"COMSPEC\") != NULL ? getenv (\"COMSPEC\") :\n      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n         GetVersionEx(&v);\n         v.dwPlatformId == VER_PLATFORM_WIN32_NT;\n      }) ? \"cmd.exe\" : \"command.com\").\n   Instead it simply concatenates the arguments, separated by ' ', and calls\n   CreateProcess().  We must quote the arguments since Win32 CreateProcess()\n   interprets characters like ' ', '\\t', '\\\\', '\"' (but not '<' and '>') in a\n   special way:\n   - Space and tab are interpreted as delimiters. They are not treated as\n     delimiters if they are surrounded by double quotes: \"...\".\n   - Unescaped double quotes are removed from the input. Their only effect is\n     that within double quotes, space and tab are treated like normal\n     characters.\n   - Backslashes not followed by double quotes are not special.\n   - But 2*n+1 backslashes followed by a double quote become\n     n backslashes followed by a double quote (n >= 0):\n       \\\" -> \"\n       \\\\\\\" -> \\\"\n       \\\\\\\\\\\" -> \\\\\"\n */\n#define SHELL_SPECIAL_CHARS \"\\\"\\\\ \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\n#define SHELL_SPACE_CHARS \" \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\nchar **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XMALLOC (char *, argc + 1);\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n\tnew_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n\t{\n\t  int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n\t  size_t length;\n\t  unsigned int backslashes;\n\t  const char *s;\n\t  char *quoted_string;\n\t  char *p;\n\n\t  length = 0;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    length++;\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\tlength += backslashes + 1;\n\t      length++;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    length += backslashes + 1;\n\n\t  quoted_string = XMALLOC (char, length + 1);\n\n\t  p = quoted_string;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    *p++ = '\"';\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\t{\n\t\t  unsigned int j;\n\t\t  for (j = backslashes + 1; j > 0; j--)\n\t\t    *p++ = '\\\\';\n\t\t}\n\t      *p++ = c;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    {\n\t      unsigned int j;\n\t      for (j = backslashes; j > 0; j--)\n\t\t*p++ = '\\\\';\n\t      *p++ = '\"';\n\t    }\n\t  *p = '\\0';\n\n\t  new_argv[i] = quoted_string;\n\t}\n      else\n\tnew_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}\nEOF\n\t\t;;\n\t    esac\n\n            cat <<\"EOF\"\nvoid lt_dump_script (FILE* f)\n{\nEOF\n\t    func_emit_wrapper yes |\n\t      $SED -n -e '\ns/^\\(.\\{79\\}\\)\\(..*\\)/\\1\\\n\\2/\nh\ns/\\([\\\\\"]\\)/\\\\\\1/g\ns/$/\\\\n/\ns/\\([^\\n]*\\).*/  fputs (\"\\1\", f);/p\ng\nD'\n            cat <<\"EOF\"\n}\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_win32_import_lib_p ARG\n# True if ARG is an import lib, as indicated by $file_magic_cmd\nfunc_win32_import_lib_p ()\n{\n    $opt_debug\n    case `eval $file_magic_cmd \\\"\\$1\\\" 2>/dev/null | $SED -e 10q` in\n    *import*) : ;;\n    *) false ;;\n    esac\n}\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $opt_debug\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # which system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll which has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    bindir=\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=no\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=\"${wl}-single_module\"\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test \"$build_libtool_libs\" = yes && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=\"$1\"\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tbindir)\n\t  bindir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tdlfiles|dlprefiles)\n\t  if test \"$preload\" = no; then\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=yes\n\t  fi\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test \"$dlself\" = no; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test \"$prev\" = dlprefiles; then\n\t      dlself=yes\n\t    elif test \"$prev\" = dlfiles && test \"$dlopen_self\" != yes; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test \"$prev\" = dlfiles; then\n\t      func_append dlfiles \" $arg\"\n\t    else\n\t      func_append dlprefiles \" $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=\"$arg\"\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file \\`$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) func_append deplibs \" $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      func_append moreargs \" $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test \"$pic_object\" = none &&\n\t\t   test \"$non_pic_object\" = none; then\n\t\t  func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=\"$func_dirname_result\"\n\n\t\tif test \"$pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=\"$xdir$pic_object\"\n\n\t\t  if test \"$prev\" = dlfiles; then\n\t\t    if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\t      func_append dlfiles \" $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test \"$prev\" = dlprefiles; then\n\t\t    # Preload the old-style object.\n\t\t    func_append dlprefiles \" $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=\"$pic_object\"\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test \"$non_pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=\"$xdir$non_pic_object\"\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t\t    arg=\"$non_pic_object\"\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=\"$pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=\"$func_dirname_result\"\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file \\`$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=\"-$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test \"$prev\" = rpath; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append rpath \" $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append xrpath \" $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  func_append weak_libs \" $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=\"$arg\"\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"\\`-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -bindir)\n\tprev=bindir\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test \"X$arg\" = \"X-export-symbols\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname \"-L\" '' \"$arg\"\n\tif test -z \"$func_stripname_result\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between \\`-L' and \\`$1'\"\n\t  else\n\t    func_fatal_error \"need path for \\`-L' option\"\n\t  fi\n\tfi\n\tfunc_resolve_sysroot \"$func_stripname_result\"\n\tdir=$func_resolve_sysroot_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of \\`$dir'\"\n\t  dir=\"$absdir\"\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"* | *\" $arg \"*)\n\t  # Will only happen for absolute or sysroot arguments\n\t  ;;\n\t*)\n\t  # Preserve sysroot, but never include relative directories\n\t  case $dir in\n\t    [\\\\/]* | [A-Za-z]:[\\\\/]* | =*) func_append deplibs \" $arg\" ;;\n\t    *) func_append deplibs \" -L$dir\" ;;\n\t  esac\n\t  func_append lib_search_path \" $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$dir\" | $SED 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) func_append dllsearchpath \":$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test \"X$arg\" = \"X-lc\" || test \"X$arg\" = \"X-lm\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  esac\n\telif test \"X$arg\" = \"X-lc_r\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tfunc_append deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot|--sysroot)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n      |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) func_append new_inherited_linker_flags \" $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=\"${wl}-multi_module\"\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"\\`-no-install' is ignored for $host\"\n\t  func_warning \"assuming \\`-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t=*)\n\t  func_stripname '=' '' \"$dir\"\n\t  dir=$lt_sysroot$func_stripname_result\n\t  ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) func_append xrpath \" $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $wl$func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $wl$func_quote_for_eval_result\"\n\t  func_append linker_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      # Flags to be passed through unchanged, with rationale:\n      # -64, -mips[0-9]      enable 64-bit mode for the SGI compiler\n      # -r[0-9][0-9]*        specify processor for the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode for the Sun compiler\n      # +DA*, +DD*           enable 64-bit mode for the HP compiler\n      # -q*                  compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* architecture-specific flags for GCC\n      # -F/path              path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-*  profiling flags for GCC\n      # @file                GCC response files\n      # -tp=*                Portland pgcc target processor selection\n      # --sysroot=*          for sysroot support\n      # -O*, -flto*, -fwhopr*, -fuse-linker-plugin GCC link-time optimization\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \\\n      -O*|-flto*|-fwhopr*|-fuse-linker-plugin)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        func_append compiler_flags \" $arg\"\n        continue\n        ;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tfunc_append objs \" $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test \"$pic_object\" = none &&\n\t     test \"$non_pic_object\" = none; then\n\t    func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=\"$func_dirname_result\"\n\n\t  if test \"$pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=\"$xdir$pic_object\"\n\n\t    if test \"$prev\" = dlfiles; then\n\t      if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\tfunc_append dlfiles \" $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test \"$prev\" = dlprefiles; then\n\t      # Preload the old-style object.\n\t      func_append dlprefiles \" $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=\"$pic_object\"\n\t  fi\n\n\t  # Non-PIC object.\n\t  if test \"$non_pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=\"$xdir$non_pic_object\"\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t      arg=\"$non_pic_object\"\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=\"$pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=\"$func_dirname_result\"\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tfunc_append deplibs \" $arg\"\n\tfunc_append old_deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tfunc_resolve_sysroot \"$arg\"\n\tif test \"$prev\" = dlfiles; then\n\t  # This library was specified with -dlopen.\n\t  func_append dlfiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telif test \"$prev\" = dlprefiles; then\n\t  # The library was specified with -dlpreopen.\n\t  func_append dlprefiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telse\n\t  func_append deplibs \" $func_resolve_sysroot_result\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prevarg' option requires an argument\"\n\n    if test \"$export_dynamic\" = yes && test -n \"$export_dynamic_flag_spec\"; then\n      eval arg=\\\"$export_dynamic_flag_spec\\\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=\"$func_basename_result\"\n    libobjs_save=\"$libobjs\"\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"\\${$shlibpath_var}\\\" \\| \\$SED \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\n    eval sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=\"$func_dirname_result$objdir\"\n    func_to_tool_file \"$output_objdir/\"\n    tool_output_objdir=$func_to_tool_file_result\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_preserve_dup_deps ; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\tesac\n      fi\n      func_append libs \" $deplib\"\n    done\n\n    if test \"$linkmode\" = lib; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) func_append specialdeplibs \" $pre_post_deps\" ;;\n\t  esac\n\t  func_append pre_post_deps \" $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can \\`-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=no\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test \"$linkmode,$pass\" = \"lib,link\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n      fi\n\n      if test \"$linkmode,$pass\" = \"lib,link\" ||\n\t test \"$linkmode,$pass\" = \"prog,scan\"; then\n\tlibs=\"$deplibs\"\n\tdeplibs=\n      fi\n      if test \"$linkmode\" = prog; then\n\tcase $pass in\n\tdlopen) libs=\"$dlfiles\" ;;\n\tdlpreopen) libs=\"$dlprefiles\" ;;\n\tlink)\n\t  libs=\"$deplibs %DEPLIBS%\"\n\t  test \"X$link_all_deplibs\" != Xno && libs=\"$libs $dependency_libs\"\n\t  ;;\n\tesac\n      fi\n      if test \"$linkmode,$pass\" = \"lib,dlpreopen\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  func_resolve_sysroot \"$lib\"\n\t  case $lib in\n\t  *.la)\tfunc_source \"$func_resolve_sysroot_result\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n\t    func_basename \"$deplib\"\n            deplib_base=$func_basename_result\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) func_append deplibs \" $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=\"$dlprefiles\"\n      fi\n      if test \"$pass\" = dlopen; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=\"$deplibs\"\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=no\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n        |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    func_append compiler_flags \" $deplib\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test \"$linkmode\" != lib && test \"$linkmode\" != prog; then\n\t    func_warning \"\\`-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test \"$linkmode\" = lib; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=\"$searchdir/lib${name}${search_ext}\"\n\t      if test -f \"$lib\"; then\n\t\tif test \"$search_ext\" = \".la\"; then\n\t\t  found=yes\n\t\telse\n\t\t  found=no\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if test \"$found\" != yes; then\n\t    # deplib doesn't seem to be a libtool library\n\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  else # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=\"$l\"\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\" ; then # only static version available\n\t\t    found=no\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=\"$func_dirname_result\"\n\t\t    lib=$ladir/$old_library\n\t\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test \"$pass\" = conv && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" = conv; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test \"$pass\" = scan; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"\\`-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test \"$pass\" = link; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    dir=$func_resolve_sysroot_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append xrpath \" $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la)\n\t  func_resolve_sysroot \"$deplib\"\n\t  lib=$func_resolve_sysroot_result\n\t  ;;\n\t*.$libext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=no\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"$deplib\\\"\" 2>/dev/null | $SED 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=yes\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=yes\n\t\t;;\n\t      esac\n\t      if test \"$valid_a_lib\" != yes; then\n\t\techo\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\techo \"*** that it is just a static archive that I should not use here.\"\n\t      else\n\t\techo\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" != link; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test \"$linkmode\" = prog; then\n\t    if test \"$pass\" = dlpreopen || test \"$dlopen_support\" != yes || test \"$build_libtool_libs\" = no; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      func_append newdlprefiles \" $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      func_append newdlfiles \" $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=yes\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\tif test \"$found\" = yes || test -f \"$lib\"; then :\n\telse\n\t  func_fatal_error \"cannot find the library \\`$lib' or unhandled argument \\`$deplib'\"\n\tfi\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=\"$func_dirname_result\"\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"$inherited_linker_flags\" | $SED 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) func_append new_inherited_linker_flags \" $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \" $dependency_libs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test \"$linkmode,$pass\" = \"lib,link\" ||\n\t   test \"$linkmode,$pass\" = \"prog,scan\" ||\n\t   { test \"$linkmode\" != prog && test \"$linkmode\" != lib; }; then\n\t  test -n \"$dlopen\" && func_append dlfiles \" $dlopen\"\n\t  test -n \"$dlpreopen\" && func_append dlprefiles \" $dlpreopen\"\n\tfi\n\n\tif test \"$pass\" = conv; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    func_append convenience \" $ladir/$objdir/$old_library\"\n\t    func_append old_convenience \" $ladir/$objdir/$old_library\"\n\t    tmp_libs=\n\t    for deplib in $dependency_libs; do\n\t      deplibs=\"$deplib $deplibs\"\n\t      if $opt_preserve_dup_deps ; then\n\t\tcase \"$tmp_libs \" in\n\t\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t\tesac\n\t      fi\n\t      func_append tmp_libs \" $deplib\"\n\t    done\n\t  elif test \"$linkmode\" != prog && test \"$linkmode\" != lib; then\n\t    func_fatal_error \"\\`$lib' is not a convenience library\"\n\t  fi\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tif test -n \"$old_library\" &&\n\t   { test \"$prefer_static_libs\" = yes ||\n\t     test \"$prefer_static_libs,$installed\" = \"built,no\"; }; then\n\t  linklib=$old_library\n\telse\n\t  for l in $old_library $library_names; do\n\t    linklib=\"$l\"\n\t  done\n\tfi\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test \"$pass\" = dlopen; then\n\t  if test -z \"$libdir\"; then\n\t    func_fatal_error \"cannot -dlopen a convenience library: \\`$lib'\"\n\t  fi\n\t  if test -z \"$dlname\" ||\n\t     test \"$dlopen_support\" != yes ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    func_append dlprefiles \" $lib $dependency_libs\"\n\t  else\n\t    func_append newdlfiles \" $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=\"$ladir\" ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of \\`$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=\"$ladir\"\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=\"$func_basename_result\"\n\n\t# Find the relevant object directory and library name.\n\tif test \"X$installed\" = Xyes; then\n\t  if test ! -f \"$lt_sysroot$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library \\`$lib' was moved.\"\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    libdir=\"$abs_ladir\"\n\t  else\n\t    dir=\"$lt_sysroot$libdir\"\n\t    absdir=\"$lt_sysroot$libdir\"\n\t  fi\n\t  test \"X$hardcode_automatic\" = Xyes && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  else\n\t    dir=\"$ladir/$objdir\"\n\t    absdir=\"$abs_ladir/$objdir\"\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test \"$pass\" = dlpreopen; then\n\t  if test -z \"$libdir\" && test \"$linkmode\" = prog; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: \\`$lib'\"\n\t  fi\n\t  case \"$host\" in\n\t    # special handling for platforms with PE-DLLs.\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # Linker will automatically link against shared library if both\n\t      # static and shared are present.  Therefore, ensure we extract\n\t      # symbols from the import library if a shared library is present\n\t      # (otherwise, the dlopen module name will be incorrect).  We do\n\t      # this by putting the import library name into $newdlprefiles.\n\t      # We recover the dlopen module name by 'saving' the la file\n\t      # name in a special purpose variable, and (later) extracting the\n\t      # dlname from the la file.\n\t      if test -n \"$dlname\"; then\n\t        func_tr_sh \"$dir/$linklib\"\n\t        eval \"libfile_$func_tr_sh_result=\\$abs_ladir/\\$laname\"\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      fi\n\t    ;;\n\t    * )\n\t      # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t      # are required to link).\n\t      if test -n \"$old_library\"; then\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t      elif test -n \"$dlname\"; then\n\t        func_append newdlprefiles \" $dir/$dlname\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      fi\n\t    ;;\n\t  esac\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test \"$linkmode\" = lib; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test \"$linkmode\" = prog && test \"$pass\" != link; then\n\t  func_append newlib_search_path \" $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=no\n\t  if test \"$link_all_deplibs\" != no || test -z \"$library_names\" ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    linkalldeplibs=yes\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         func_resolve_sysroot \"$func_stripname_result\"\n\t         func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if test \"$linkalldeplibs\" = yes; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_preserve_dup_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test \"$prefer_static_libs\" = no ||\n\t         test \"$prefer_static_libs,$installed\" = \"built,yes\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\" ; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case \"$temp_rpath:\" in\n\t      *\"$absdir:\"*) ;;\n\t      *) func_append temp_rpath \"$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if test \"$alldeplibs\" = yes &&\n\t     { test \"$deplibs_check_method\" = pass_all ||\n\t       { test \"$build_libtool_libs\" = yes &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test \"$use_static_libs\" = built && test \"$installed\" = yes; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test \"$use_static_libs\" = no || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test \"$installed\" = no; then\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\"\"\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=\"$dlpremoduletest\"\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test \"$shouldnotlink\" = yes && test \"$pass\" = link; then\n\t    echo\n\t    if test \"$linkmode\" = prog; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test \"$linkmode\" = lib &&\n\t     test \"$hardcode_into_libs\" = yes; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=\"$1\"\n\t    shift\n\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=\"$dlname\"\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=\"-$major\"\n\t\t;;\n\t      esac\n\t      eval soname=\\\"$soname_spec\\\"\n\t    else\n\t      soname=\"$realname\"\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=\"$soname\"\n\t    func_basename \"$soroot\"\n\t    soname=\"$func_basename_result\"\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from \\`$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for \\`$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test \"$linkmode\" = prog || test \"$opt_mode\" != relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test \"$hardcode_direct\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv4*uw2*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we can not\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null ; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\" ; then\n\t\t\t  echo\n\t\t\t  echo \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  echo \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=\"$dir/$old_library\"\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=\"$dir/$old_library\"\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test \"$hardcode_minus_L\" = no; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=\"$dir\" ;;\n\t\tesac\n\t\tadd_dir=\"-L$dir\"\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = no; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test \"$hardcode_direct\" = yes &&\n\t         test \"$hardcode_direct_absolute\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t      elif test \"$hardcode_minus_L\" = yes; then\n\t\tadd_dir=\"-L$absdir\"\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = yes; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test \"$lib_linked\" != yes; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) func_append compile_shlibpath \"$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test \"$hardcode_direct\" != yes &&\n\t\t test \"$hardcode_minus_L\" != yes &&\n\t\t test \"$hardcode_shlibpath_var\" = yes; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) func_append finalize_shlibpath \"$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test \"$linkmode\" = prog || test \"$opt_mode\" = relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test \"$hardcode_direct\" = yes &&\n\t       test \"$hardcode_direct_absolute\" = no; then\n\t      add=\"$libdir/$linklib\"\n\t    elif test \"$hardcode_minus_L\" = yes; then\n\t      add_dir=\"-L$libdir\"\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_shlibpath_var\" = yes; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) func_append finalize_shlibpath \"$libdir:\" ;;\n\t      esac\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_automatic\" = yes; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\" ; then\n\t\tadd=\"$inst_prefix_dir$libdir/$linklib\"\n\t      else\n\t\tadd=\"$libdir/$linklib\"\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=\"-L$libdir\"\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=\"-l$name\"\n\t    fi\n\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test \"$linkmode\" = prog; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test \"$hardcode_direct\" != unsupported; then\n\t    test -n \"$old_library\" && linklib=\"$old_library\"\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test \"$build_libtool_libs\" = yes; then\n\t  # Not a shared library\n\t  if test \"$deplibs_check_method\" != pass_all; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    echo\n\t    $ECHO \"*** Warning: This system can not link to static lib archive $lib.\"\n\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t    echo \"*** shared version of the library, which you do not appear to have.\"\n\t    if test \"$module\" = yes; then\n\t      echo \"*** But as you try to build a module library, libtool will still create \"\n\t      echo \"*** a static module, that should work as long as the dlopening application\"\n\t      echo \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\techo\n\t\techo \"*** However, this would only work if libtool was able to extract symbol\"\n\t\techo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t\techo \"*** not find such a program.  So, this module is probably useless.\"\n\t\techo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test \"$build_old_libs\" = no; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test \"$linkmode\" = lib; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test \"$hardcode_into_libs\" != yes ||\n\t       test \"$build_old_libs\" = yes ||\n\t       test \"$link_static\" = yes; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) func_append xrpath \" $temp_xrpath\";;\n\t\t   esac;;\n\t      *) func_append temp_deplibs \" $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=\"$temp_deplibs\"\n\t  fi\n\n\t  func_append newlib_search_path \" $absdir\"\n\t  # Link against this library\n\t  test \"$link_static\" = no && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    case $deplib in\n              -L*) func_stripname '-L' '' \"$deplib\"\n                   func_resolve_sysroot \"$func_stripname_result\";;\n              *) func_resolve_sysroot \"$deplib\" ;;\n            esac\n\t    if $opt_preserve_dup_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $func_resolve_sysroot_result \"*)\n                func_append specialdeplibs \" $func_resolve_sysroot_result\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $func_resolve_sysroot_result\"\n\t  done\n\n\t  if test \"$link_all_deplibs\" != no; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      path=\n\t      case $deplib in\n\t      -L*) path=\"$deplib\" ;;\n\t      *.la)\n\t        func_resolve_sysroot \"$deplib\"\n\t        deplib=$func_resolve_sysroot_result\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=$func_dirname_result\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=\"$dir\" ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of \\`$dir'\"\n\t\t    absdir=\"$dir\"\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  eval deplibrary_names=`${SED} -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\" ; then\n\t\t    for tmp in $deplibrary_names ; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\" ; then\n\t\t      depdepl=\"$absdir/$objdir/$depdepl\"\n\t\t      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      func_append compiler_flags \" ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}\"\n\t\t      func_append linker_flags \" -dylib_file ${darwin_install_name}:${depdepl}\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=\"-L$absdir/$objdir\"\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  eval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"\\`$deplib' seems to be moved\"\n\n\t\t  path=\"-L$absdir\"\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test \"$pass\" = link; then\n\tif test \"$linkmode\" = \"prog\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=\"$newdependency_libs\"\n      if test \"$pass\" = dlpreopen; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test \"$pass\" != dlopen; then\n\tif test \"$pass\" != conv; then\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append lib_search_path \" $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\tfi\n\n\tif test \"$linkmode,$pass\" != \"prog,link\"; then\n\t  vars=\"deplibs\"\n\telse\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\\"\\$$var\\\"\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) func_append tmp_libs \" $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) func_append tmp_libs \" $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\\"$tmp_libs\\\"\n\tdone # for var\n      fi\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs ; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\"\"\n\t  ;;\n\tesac\n\tif test -n \"$i\" ; then\n\t  func_append tmp_libs \" $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test \"$linkmode\" = prog; then\n      dlfiles=\"$newdlfiles\"\n    fi\n    if test \"$linkmode\" = prog || test \"$linkmode\" = lib; then\n      dlprefiles=\"$newdlprefiles\"\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"\\`-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=\"$output\"\n      func_append objs \"$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form `libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval libname=\\\"$libname_spec\\\"\n\t;;\n      *)\n\ttest \"$module\" = no && \\\n\t  func_fatal_help \"libtool library \\`$output' must begin with \\`lib'\"\n\n\tif test \"$need_lib_prefix\" != no; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval shared_ext=\\\"$shrext_cmds\\\"\n\t  eval libname=\\\"$libname_spec\\\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test \"$deplibs_check_method\" != pass_all; then\n\t  func_fatal_error \"cannot build libtool library \\`$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  echo\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  func_append libobjs \" $objs\"\n\tfi\n      fi\n\n      test \"$dlself\" != no && \\\n\tfunc_warning \"\\`-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test \"$#\" -gt 1 && \\\n\tfunc_warning \"ignoring multiple \\`-rpath's for a libtool library\"\n\n      install_libdir=\"$1\"\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test \"$build_libtool_libs\" = yes; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a `.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"\\`-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"\\`-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=\"$IFS\"; IFS=':'\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=\"$save_ifs\"\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to \\`-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=\"$1\"\n\t  number_minor=\"$2\"\n\t  number_revision=\"$3\"\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # which has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  # correct linux to gnu/linux during the next big refactor\n\t  darwin|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_revision\"\n\t    ;;\n\t  freebsd-aout|freebsd-elf|qnx|sunos)\n\t    current=\"$number_major\"\n\t    revision=\"$number_minor\"\n\t    age=\"0\"\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_minor\"\n\t    lt_irix_increment=no\n\t    ;;\n\t  *)\n\t    func_fatal_configuration \"$modename: unknown library version type \\`$version_type'\"\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=\"$1\"\n\t  revision=\"$2\"\n\t  age=\"$3\"\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT \\`$current' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION \\`$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE \\`$age' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE \\`$age' is greater than the current interface number \\`$current'\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\";\n\t  ;;\n\n\tfreebsd-elf)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test \"X$lt_irix_increment\" = \"Xno\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=\"$verstring_prefix$major.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring_prefix$major.$iface:$verstring\"\n\t  done\n\n\t  # Before this point, $major must not contain `.'.\n\t  major=.$major\n\t  versuffix=\"$major.$revision\"\n\t  ;;\n\n\tlinux) # correct to gnu/linux during the next big refactor\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\".$current.$age.$revision\"\n\t  verstring=\"$current.$age.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring:${iface}.0\"\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  func_append verstring \":${current}.0\"\n\t  ;;\n\n\tqnx)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tsunos)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\"\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 filesystems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=\"-$major\"\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type \\`$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=\"0.0\"\n\t    ;;\n\t  esac\n\t  if test \"$need_version\" = no; then\n\t    versuffix=\n\t  else\n\t    versuffix=\".0.0\"\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test \"$avoid_version\" = yes && test \"$need_version\" = no; then\n\t  major=\n\t  versuffix=\n\t  verstring=\"\"\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test \"$allow_undefined\" = yes; then\n\t  if test \"$allow_undefined_flag\" = unsupported; then\n\t    func_warning \"undefined symbols not allowed in $host shared libraries\"\n\t    build_libtool_libs=no\n\t    build_old_libs=yes\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=\"$no_undefined_flag\"\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" \"yes\"\n      func_append libobjs \" $symfileobj\"\n      test \"X$libobjs\" = \"X \" && libobjs=\n\n      if test \"$opt_mode\" != relink; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)\n\t       if test \"X$precious_files_regex\" != \"X\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       func_append removelist \" $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test \"$build_old_libs\" = yes && test \"$build_libtool_libs\" != convenience ; then\n\tfunc_append oldlibs \" $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; $lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"$lib_search_path \" | $SED \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"$deplibs \" | $SED \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"$dependency_libs \" | $SED \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  func_replace_sysroot \"$libdir\"\n\t  func_append temp_xrpath \" -R$func_replace_sysroot_result\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n\tif test \"$hardcode_into_libs\" != yes || test \"$build_old_libs\" = yes; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=\"$dlfiles\"\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlfiles \" $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=\"$dlprefiles\"\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlprefiles \" $lib\" ;;\n\tesac\n      done\n\n      if test \"$build_libtool_libs\" = yes; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test \"$build_libtool_need_lc\" = \"yes\"; then\n\t      func_append deplibs \" -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\"\"\n\tversuffix=\"\"\n\tmajor=\"\"\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    func_append newdeplibs \" $i\"\n\t\t    i=\"\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\" ; then\n\t\t  libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t  deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t    func_append newdeplibs \" $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    echo\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    echo \"*** shared version of the library, which I believe you do not have\"\n\t\t    echo \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    echo \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      func_append newdeplibs \" $i\"\n\t\t      i=\"\"\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\" ; then\n\t\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t    deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t      func_append newdeplibs \" $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      echo\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      echo \"*** I have the capability to make that library automatically link in when\"\n\t\t      echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      echo \"*** shared version of the library, which you do not appear to have\"\n\t\t      echo \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      echo \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  echo\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  echo \"*** make it link in!  You will probably need to install it or some\"\n\t\t  echo \"*** library that it depends on before this library will be fully\"\n\t\t  echo \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tif test -n \"$file_magic_glob\"; then\n\t\t  libnameglob=`func_echo_all \"$libname\" | $SED -e $file_magic_glob`\n\t\telse\n\t\t  libnameglob=$libname\n\t\tfi\n\t\ttest \"$want_nocaseglob\" = yes && nocaseglob=`shopt -p nocaseglob`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  if test \"$want_nocaseglob\" = yes; then\n\t\t    shopt -s nocaseglob\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t    $nocaseglob\n\t\t  else\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t  fi\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=\"$potent_lib\"\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=\"$potliblink\";;\n\t\t\t*) potlib=`$ECHO \"$potlib\" | $SED 's,[^/]*$,,'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval $file_magic_cmd \\\"\\$potlib\\\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tfunc_append newdeplibs \" $a_deplib\"\n\t\t\ta_deplib=\"\"\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=\"$potent_lib\" # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"$potent_lib\\\"\" 2>/dev/null | $SED 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      func_append newdeplibs \" $a_deplib\"\n\t\t      a_deplib=\"\"\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\"\"\n\t  tmp_deplibs=`$ECHO \" $deplibs\" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`\n\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t    for i in $predeps $postdeps ; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \" $tmp_deplibs\" | $SED \"s,$i,,\"`\n\t    done\n\t  fi\n\t  case $tmp_deplibs in\n\t  *[!\\\t\\ ]*)\n\t    echo\n\t    if test \"X$deplibs_check_method\" = \"Xnone\"; then\n\t      echo \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      echo \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    echo \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test \"$droppeddeps\" = yes; then\n\t  if test \"$module\" = yes; then\n\t    echo\n\t    echo \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    echo \"*** a static module, that should work as long as the dlopening\"\n\t    echo \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      echo\n\t      echo \"*** However, this would only work if libtool was able to extract symbol\"\n\t      echo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t      echo \"*** not find such a program.  So, this module is probably useless.\"\n\t      echo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test \"$build_old_libs\" = no; then\n\t      oldlibs=\"$output_objdir/$libname.$libext\"\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    echo \"*** The inter-library dependencies that have been dropped here will be\"\n\t    echo \"*** automatically added whenever a program is linked with this library\"\n\t    echo \"*** or is declared to -dlopen it.\"\n\n\t    if test \"$allow_undefined\" = no; then\n\t      echo\n\t      echo \"*** Since this library must not contain undefined symbols,\"\n\t      echo \"*** because either the platform does not support them or\"\n\t      echo \"*** it was explicitly requested with -no-undefined,\"\n\t      echo \"*** libtool will only create a static version of it.\"\n\t      if test \"$build_old_libs\" = no; then\n\t\toldlibs=\"$output_objdir/$libname.$libext\"\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \" $deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      deplibs=\"$new_libs\"\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test \"$build_libtool_libs\" = yes; then\n\t# Remove ${wl} instances when linking with ld.\n\t# FIXME: should test the right _cmds variable.\n\tcase $archive_cmds in\n\t  *\\$LD\\ *) wl= ;;\n        esac\n\tif test \"$hardcode_into_libs\" = yes; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=\"$finalize_rpath\"\n\t  test \"$opt_mode\" != relink && rpath=\"$compile_rpath$rpath\"\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tfunc_replace_sysroot \"$libdir\"\n\t\tlibdir=$func_replace_sysroot_result\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=\"$libdir\"\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    func_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t\tfunc_append dep_rpath \" $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append perm_rpath \" $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=\"$hardcode_libdirs\"\n\t    eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      func_append rpath \"$dir:\"\n\t    done\n\t    eval \"$runpath_var='$rpath\\$$runpath_var'; export $runpath_var\"\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=\"$finalize_shlibpath\"\n\ttest \"$opt_mode\" != relink && shlibpath=\"$compile_shlibpath$shlibpath\"\n\tif test -n \"$shlibpath\"; then\n\t  eval \"$shlibpath_var='$shlibpath\\$$shlibpath_var'; export $shlibpath_var\"\n\tfi\n\n\t# Get the real and link names of the library.\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval library_names=\\\"$library_names_spec\\\"\n\tset dummy $library_names\n\tshift\n\trealname=\"$1\"\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval soname=\\\"$soname_spec\\\"\n\telse\n\t  soname=\"$realname\"\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=\"$output_objdir/$realname\"\n\tlinknames=\n\tfor link\n\tdo\n\t  func_append linknames \" $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"$libobjs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=\"$output_objdir/$libname.uexp\"\n\t  func_append delfiles \" $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    if test \"x`$SED 1q $export_symbols`\" != xEXPORTS; then\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=\"$export_symbols\"\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    fi\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test \"$always_export_symbols\" = yes || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for \\`$libname.la'\"\n\t    export_symbols=\"$output_objdir/$libname.exp\"\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd1 in $cmds; do\n\t      IFS=\"$save_ifs\"\n\t      # Take the normal branch if the nm_file_list_spec branch\n\t      # doesn't work or if tool conversion is not needed.\n\t      case $nm_file_list_spec~$to_tool_file_cmd in\n\t\t*~func_convert_file_noop | *~func_convert_file_msys_to_w32 | ~*)\n\t\t  try_normal_branch=yes\n\t\t  eval cmd=\\\"$cmd1\\\"\n\t\t  func_len \" $cmd\"\n\t\t  len=$func_len_result\n\t\t  ;;\n\t\t*)\n\t\t  try_normal_branch=no\n\t\t  ;;\n\t      esac\n\t      if test \"$try_normal_branch\" = yes \\\n\t\t && { test \"$len\" -lt \"$max_cmd_len\" \\\n\t\t      || test \"$max_cmd_len\" -le -1; }\n\t      then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      elif test -n \"$nm_file_list_spec\"; then\n\t\tfunc_basename \"$output\"\n\t\toutput_la=$func_basename_result\n\t\tsave_libobjs=$libobjs\n\t\tsave_output=$output\n\t\toutput=${output_objdir}/${output_la}.nm\n\t\tfunc_to_tool_file \"$output\"\n\t\tlibobjs=$nm_file_list_spec$func_to_tool_file_result\n\t\tfunc_append delfiles \" $output\"\n\t\tfunc_verbose \"creating $NM input file list: $output\"\n\t\tfor obj in $save_libobjs; do\n\t\t  func_to_tool_file \"$obj\"\n\t\t  $ECHO \"$func_to_tool_file_result\"\n\t\tdone > \"$output\"\n\t\teval cmd=\\\"$cmd1\\\"\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\toutput=$save_output\n\t\tlibobjs=$save_libobjs\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=\"$save_ifs\"\n\t    if test -n \"$export_symbols_regex\" && test \"X$skipped_export\" != \"X:\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=\"$export_symbols\"\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t  $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    func_append tmp_deplibs \" $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test \"$compiler_needs_object\" = yes &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=\"$output_objdir/${outputname}x\"\n\t    func_append generated \" $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    func_append libobjs \" $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test \"$thread_safe\" = yes && test -n \"$thread_safe_flag_spec\"; then\n\t  eval flag=\\\"$thread_safe_flag_spec\\\"\n\t  func_append linker_flags \" $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test \"$opt_mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$module_expsym_cmds\\\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$module_cmds\\\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$archive_expsym_cmds\\\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$archive_cmds\\\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  func_basename \"$output\"\n\t  output_la=$func_basename_result\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"$with_gnu_ld\" = yes; then\n\t    output=${output_objdir}/${output_la}.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    echo 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    echo ')' >> $output\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$func_to_tool_file_result\n\t  elif test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"X$file_list_spec\" != X; then\n\t    output=${output_objdir}/${output_la}.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test \"$compiler_needs_object\" = yes; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$firstobj\\\"$file_list_spec$func_to_tool_file_result\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-${k}.$objext\n\t      eval test_cmds=\\\"$reload_cmds\\\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test \"X$objlist\" = X ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test \"$k\" -eq 1 ; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    reload_objs=$objlist\n\t\t    eval concat_cmds=\\\"$reload_cmds\\\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    reload_objs=\"$objlist $last_robj\"\n\t\t    eval concat_cmds=\\\"\\$concat_cmds~$reload_cmds~\\$RM $last_robj\\\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-${k}.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-${k}.$objext\n\t\t  objlist=\" $obj\"\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      reload_objs=\"$objlist $last_robj\"\n\t      eval concat_cmds=\\\"\\${concat_cmds}$reload_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t        eval concat_cmds=\\\"\\${concat_cmds}~\\$RM $last_robj\\\"\n\t      fi\n\t      func_append delfiles \" $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    if ${skipped_export-false}; then\n\t      func_verbose \"generating symbol list for \\`$libname.la'\"\n\t      export_symbols=\"$output_objdir/$libname.exp\"\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t\teval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t    fi\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=\"$save_ifs\"\n\t      $opt_silent || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test \"$opt_mode\" = relink; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=\"$save_ifs\"\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          if ${skipped_export-false}; then\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=\"$export_symbols\"\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t      $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  fi\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append libobjs \" $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=\"$IFS\"; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=\"$save_ifs\"\n\t  eval cmd=\\\"$cmd\\\"\n\t  $opt_silent || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test \"$opt_mode\" = relink; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=\"$save_ifs\"\n\n\t# Restore the uninstalled library and exit\n\tif test \"$opt_mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test \"$module\" = yes || test \"$export_dynamic\" = yes; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=\"$soname\"\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object \\`$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=\"$output\"\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # reload_cmds runs $LD directly, so let us get rid of\n      # -Wl from whole_archive_flag_spec and hope we can get by with\n      # turning comma into space..\n      wl=\n\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\n\t  reload_conv_objs=$reload_objs\\ `$ECHO \"$tmp_whole_archive_flags\" | $SED 's|,| |g'`\n\telse\n\t  gentop=\"$output_objdir/${obj}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # If we're not building shared, we need to use non_pic_objs\n      test \"$build_libtool_libs\" != yes && libobjs=\"$non_pic_objects\"\n\n      # Create the old-style object.\n      reload_objs=\"$objs$old_deplibs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; /\\.lib$/d; $lo2o\" | $NL2SP`\" $reload_conv_objs\" ### testsuite: skip nested quoting test\n\n      output=\"$obj\"\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$build_libtool_libs\" != yes; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || eval \"echo timestamp > $libobj\" || exit $?\n\texit $EXIT_SUCCESS\n      fi\n\n      if test -n \"$pic_flag\" || test \"$pic_mode\" != default; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=\"$libobj\"\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for programs\"\n\n      test \"$preload\" = yes \\\n        && test \"$dlopen_support\" = unknown \\\n\t&& test \"$dlopen_self\" = unknown \\\n\t&& test \"$dlopen_self_static\" = unknown && \\\n\t  func_warning \"\\`LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test \"$tagname\" = CXX ; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      func_append compile_command \" ${wl}-bind_at_load\"\n\t      func_append finalize_command \" ${wl}-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=\"$new_libs\"\n\n\n      func_append compile_command \" $compile_deplibs\"\n      func_append finalize_command \" $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`${ECHO} \"$libdir\" | ${SED} -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) func_append dllsearchpath \":$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      compile_rpath=\"$rpath\"\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      finalize_rpath=\"$rpath\"\n\n      if test -n \"$libobjs\" && test \"$build_old_libs\" = yes; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"$compile_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"$finalize_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" \"no\"\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=yes\n      case $host in\n      *cegcc* | *mingw32ce*)\n        # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.\n        wrappers_required=no\n        ;;\n      *cygwin* | *mingw* )\n        if test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      *)\n        if test \"$need_relink\" = no || test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      esac\n      if test \"$wrappers_required\" = no; then\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"$compile_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=\"$compile_command$compile_rpath\"\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.${objext}\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.${objext}\"'\n\tfi\n\n\texit $exit_status\n      fi\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test \"$no_install\" = yes; then\n\t# We don't need to create a wrapper script.\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$hardcode_action\" = relink; then\n\t# Fast installation is not supported\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\trelink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\n\tfunc_warning \"this platform does not like uninstalled shared libraries\"\n\tfunc_warning \"\\`$output' will be relinked during installation\"\n      else\n\tif test \"$fast_install\" != no; then\n\t  link_command=\"$finalize_var$compile_command$finalize_rpath\"\n\t  if test \"$fast_install\" = yes; then\n\t    relink_command=`$ECHO \"$compile_var$compile_command$compile_rpath\" | $SED 's%@OUTPUT@%\\$progdir/\\$file%g'`\n\t  else\n\t    # fast_install is set to needless\n\t    relink_command=\n\t  fi\n\telse\n\t  link_command=\"$compile_var$compile_command$compile_rpath\"\n\t  relink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\tfi\n      fi\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      if test -n \"$postlink_cmds\"; then\n\tfunc_to_tool_file \"$output_objdir/$outputname\"\n\tpostlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\tfunc_execute_cmds \"$postlink_cmds\" 'exit $?'\n      fi\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=\"$output_path/$objdir/lt-$output_name.c\"\n\t    cwrapper=\"$output_path/$output_name.exe\"\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\" ; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      if test \"$build_libtool_libs\" = convenience; then\n\toldobjs=\"$libobjs_save $symfileobj\"\n\taddlibs=\"$convenience\"\n\tbuild_libtool_libs=no\n      else\n\tif test \"$build_libtool_libs\" = module; then\n\t  oldobjs=\"$libobjs_save\"\n\t  build_libtool_libs=no\n\telse\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  if test \"$preload\" = yes && test -f \"$symfileobj\"; then\n\t    func_append oldobjs \" $symfileobj\"\n\t  fi\n\tfi\n\taddlibs=\"$old_convenience\"\n      fi\n\n      if test -n \"$addlibs\"; then\n\tgentop=\"$output_objdir/${outputname}x\"\n\tfunc_append generated \" $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\tfunc_append oldobjs \" $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test \"$build_libtool_libs\" = yes; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append oldobjs \" $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  echo \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=\"$func_basename_result\"\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      func_append oldobjs \" $gentop/$newobj\"\n\t      ;;\n\t    *) func_append oldobjs \" $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\tfunc_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n\ttool_oldlib=$func_to_tool_file_result\n\teval cmds=\\\"$old_archive_cmds\\\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telif test -n \"$archiver_list_spec\"; then\n\t  func_verbose \"using command file archive linking...\"\n\t  for obj in $oldobjs\n\t  do\n\t    func_to_tool_file \"$obj\"\n\t    $ECHO \"$func_to_tool_file_result\"\n\t  done > $output_objdir/$libname.libcmd\n\t  func_to_tool_file \"$output_objdir/$libname.libcmd\"\n\t  oldobjs=\" $archiver_list_spec$func_to_tool_file_result\"\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval test_cmds=\\\"$old_archive_cmds\\\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\" ; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\${concat_cmds}$old_archive_cmds\\\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test \"X$oldobjs\" = \"X\" ; then\n\t    eval cmds=\\\"\\$concat_cmds\\\"\n\t  else\n\t    eval cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test \"$build_old_libs\" = yes && old_library=\"$libname.$libext\"\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      if test \"$hardcode_automatic\" = yes ; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test \"$installed\" = yes; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=\"$output_objdir/$outputname\"i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=\"$func_basename_result\"\n\t\tfunc_resolve_sysroot \"$deplib\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $func_resolve_sysroot_result`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\tfunc_append newdependency_libs \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      -L*)\n\t\tfunc_stripname -L '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -L$func_replace_sysroot_result\"\n\t\t;;\n\t      -R*)\n\t\tfunc_stripname -R '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -R$func_replace_sysroot_result\"\n\t\t;;\n\t      *) func_append newdependency_libs \" $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=\"$newdependency_libs\"\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlfiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      *) func_append newdlfiles \" $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlprefiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlfiles \" $abs\"\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlprefiles \" $abs\"\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  # In fact, it would be nice if we could use this code for all target\n\t  # systems that can't hard-code library paths into their executables\n\t  # and that have no shared library path variable independent of PATH,\n\t  # but it turns out we can't easily determine that from inspecting\n\t  # libtool variables, so we have to hard-code the OSs to which it\n\t  # applies here; at the moment, that means platforms that use the PE\n\t  # object format with DLL files.  See the long comment at the top of\n\t  # tests/bindir.at for full details.\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)\n\t      # If a -bindir argument was supplied, place the dll there.\n\t      if test \"x$bindir\" != x ;\n\t      then\n\t\tfunc_relative_path \"$install_libdir\" \"$bindir\"\n\t\ttdlname=$func_relative_path_result$dlname\n\t      else\n\t\t# Otherwise fall back on heuristic.\n\t\ttdlname=../bin/$dlname\n\t      fi\n\t      ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that can not go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test \"$installed\" = no && test \"$need_relink\" = yes; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\n{ test \"$opt_mode\" = link || test \"$opt_mode\" = relink; } &&\n    func_mode_link ${1+\"$@\"}\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $opt_debug\n    RM=\"$nonopt\"\n    files=\n    rmforce=\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    for arg\n    do\n      case $arg in\n      -f) func_append RM \" $arg\"; rmforce=yes ;;\n      -*) func_append RM \" $arg\" ;;\n      *) func_append files \" $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=\"$func_dirname_result\"\n      if test \"X$dir\" = X.; then\n\todir=\"$objdir\"\n      else\n\todir=\"$dir/$objdir\"\n      fi\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n      test \"$opt_mode\" = uninstall && odir=\"$dir\"\n\n      # Remember odir for removal later, being careful to avoid duplicates\n      if test \"$opt_mode\" = clean; then\n\tcase \" $rmdirs \" in\n\t  *\" $odir \"*) ;;\n\t  *) func_append rmdirs \" $odir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif test \"$rmforce\" = yes; then\n\tcontinue\n      fi\n\n      rmfiles=\"$file\"\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    func_append rmfiles \" $odir/$n\"\n\t  done\n\t  test -n \"$old_library\" && func_append rmfiles \" $odir/$old_library\"\n\n\t  case \"$opt_mode\" in\n\t  clean)\n\t    case \" $library_names \" in\n\t    *\" $dlname \"*) ;;\n\t    *) test -n \"$dlname\" && func_append rmfiles \" $odir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && func_append rmfiles \" $odir/$name $odir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" &&\n\t     test \"$pic_object\" != none; then\n\t    func_append rmfiles \" $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" &&\n\t     test \"$non_pic_object\" != none; then\n\t    func_append rmfiles \" $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test \"$opt_mode\" = clean ; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    func_append rmfiles \" $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      func_append rmfiles \" $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    func_append rmfiles \" $odir/$name $odir/${name}S.${objext}\"\n\t    if test \"$fast_install\" = yes && test -n \"$relink_command\"; then\n\t      func_append rmfiles \" $odir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\" ; then\n\t      func_append rmfiles \" $odir/lt-${noexename}.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n\n    # Try to remove the ${objdir}s in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\n{ test \"$opt_mode\" = uninstall || test \"$opt_mode\" = clean; } &&\n    func_mode_uninstall ${1+\"$@\"}\n\ntest -z \"$opt_mode\" && {\n  help=\"$generic_help\"\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode \\`$opt_mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# in which we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n# vi:sw=2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/libgc/dyn_load.c": "/*\n * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n *\n * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n *\n * Permission is hereby granted to use or copy this program\n * for any purpose,  provided the above notices are retained on all copies.\n * Permission to modify the code and to distribute modified code is granted,\n * provided the above notices are retained, and a notice that the code was\n * modified is included with the above copyright notice.\n *\n * Original author: Bill Janssen\n * Heavily modified by Hans Boehm and others\n */\n\n/*\n * This is incredibly OS specific code for tracking down data sections in\n * dynamic libraries.  There appears to be no way of doing this quickly\n * without groveling through undocumented data structures.  We would argue\n * that this is a bug in the design of the dlopen interface.  THIS CODE\n * MAY BREAK IN FUTURE OS RELEASES.  If this matters to you, don't hesitate\n * to let your vendor know ...\n *\n * None of this is safe with dlclose and incremental collection.\n * But then not much of anything is safe in the presence of dlclose.\n */\n#if (defined(__linux__) || defined(__GLIBC__) || defined(__native_client__)) && !defined(_GNU_SOURCE)\n    /* Can't test LINUX, since this must be define before other includes */\n#   define _GNU_SOURCE\n#endif\n#if !defined(MACOS) && !defined(_WIN32_WCE)\n#  include <sys/types.h>\n#endif\n#include \"private/gc_priv.h\"\n\n/* BTL: avoid circular redefinition of dlopen if GC_SOLARIS_THREADS defined */\n# if (defined(GC_PTHREADS) || defined(GC_SOLARIS_THREADS)) \\\n      && defined(dlopen) && !defined(GC_USE_LD_WRAP)\n    /* To support threads in Solaris, gc.h interposes on dlopen by       */\n    /* defining \"dlopen\" to be \"GC_dlopen\", which is implemented below.  */\n    /* However, both GC_FirstDLOpenedLinkMap() and GC_dlopen() use the   */\n    /* real system dlopen() in their implementation. We first remove     */\n    /* gc.h's dlopen definition and restore it later, after GC_dlopen(). */\n#   undef dlopen\n#   define GC_must_restore_redefined_dlopen\n# else\n#   undef GC_must_restore_redefined_dlopen\n# endif\n\n#if (defined(DYNAMIC_LOADING) || defined(MSWIN32) || defined(MSWINCE)) \\\n    && !defined(PCR)\n#if !defined(SUNOS4) && !defined(SUNOS5DL) && !defined(IRIX5) && \\\n    !defined(MSWIN32) && !defined(MSWINCE) && \\\n    !(defined(ALPHA) && defined(OSF1)) && \\\n    !defined(HPUX) && !((defined(LINUX) || defined(NACL)) && defined(__ELF__)) && \\\n    !defined(RS6000) && !defined(SCO_ELF) && !defined(DGUX) && \\\n    !(defined(FREEBSD) && defined(__ELF__)) && \\\n    !(defined(OPENBSD) && (defined(__ELF__) || defined(M68K))) && \\\n    !(defined(NETBSD) && defined(__ELF__)) && !defined(HURD) && \\\n    !defined(DARWIN)\n --> We only know how to find data segments of dynamic libraries for the\n --> above.  Additional SVR4 variants might not be too\n --> hard to add.\n#endif\n\n#include <stdio.h>\n#ifdef SUNOS5DL\n/* Avoid  #error \"large files are not supported by libelf\" errors */\n#if defined(_ILP32) && (_FILE_OFFSET_BITS != 32)\n#undef _FILE_OFFSET_BITS\n#define _FILE_OFFSET_BITS 32\n#endif\n#   include <sys/elf.h>\n#   include <dlfcn.h>\n#   include <link.h>\n#endif\n#ifdef SUNOS4\n#   include <dlfcn.h>\n#   include <link.h>\n#   include <a.out.h>\n  /* struct link_map field overrides */\n#   define l_next\tlm_next\n#   define l_addr\tlm_addr\n#   define l_name\tlm_name\n#endif\n\n#if defined(NETBSD)\n#   include <machine/elf_machdep.h>\n#   define ELFSIZE ARCH_ELFSIZE\n#endif\n\n#if (defined(LINUX) || defined(NACL)) && defined(__ELF__) || defined(SCO_ELF) || \\\n    (defined(FREEBSD) && defined(__ELF__)) || defined(DGUX) || \\\n    (defined(OPENBSD) && defined(__ELF__)) || \\\n    (defined(NETBSD) && defined(__ELF__)) || defined(HURD)\n#   include <stddef.h>\n# if !defined(OPENBSD)\n#   include <elf.h>\n# endif\n#   include <link.h>\n#endif\n\n/* Newer versions of GNU/Linux define this macro.  We\n * define it similarly for any ELF systems that don't.  */\n#  ifndef ElfW\n#    if defined(FREEBSD)\n#      if __ELF_WORD_SIZE == 32\n#        define ElfW(type) Elf32_##type\n#      else\n#        define ElfW(type) Elf64_##type\n#      endif\n#    else\n#      ifdef NETBSD\n#        if ELFSIZE == 32\n#          define ElfW(type) Elf32_##type\n#        else\n#          define ElfW(type) Elf64_##type\n#        endif\n#      else\n#        if !defined(ELF_CLASS) || ELF_CLASS == ELFCLASS32\n#          define ElfW(type) Elf32_##type\n#        else\n#          define ElfW(type) Elf64_##type\n#\t endif\n#      endif\n#    endif\n#  endif \n\n#if defined(SUNOS5DL) && !defined(USE_PROC_FOR_LIBRARIES)\n\n#ifdef LINT\n    Elf32_Dyn _DYNAMIC;\n#endif\n\nstatic struct link_map *\nGC_FirstDLOpenedLinkMap()\n{\n    extern ElfW(Dyn) _DYNAMIC;\n    ElfW(Dyn) *dp;\n    struct r_debug *r;\n    static struct link_map * cachedResult = 0;\n    static ElfW(Dyn) *dynStructureAddr = 0;\n    \t\t\t/* BTL: added to avoid Solaris 5.3 ld.so _DYNAMIC bug */\n\n#   ifdef SUNOS53_SHARED_LIB\n\t/* BTL: Avoid the Solaris 5.3 bug that _DYNAMIC isn't being set\t*/\n\t/* up properly in dynamically linked .so's. This means we have\t*/\n\t/* to use its value in the set of original object files loaded\t*/\n\t/* at program startup.\t\t\t\t\t\t*/\n\tif( dynStructureAddr == 0 ) {\n\t  void* startupSyms = dlopen(0, RTLD_LAZY);\n\t  dynStructureAddr = (ElfW(Dyn)*)dlsym(startupSyms, \"_DYNAMIC\");\n\t\t}\n#   else\n\tdynStructureAddr = &_DYNAMIC;\n#   endif\n\n    if( dynStructureAddr == 0) {\n        return(0);\n    }\n    if( cachedResult == 0 ) {\n        int tag;\n        for( dp = ((ElfW(Dyn) *)(&_DYNAMIC)); (tag = dp->d_tag) != 0; dp++ ) {\n            if( tag == DT_DEBUG ) {\n                struct link_map *lm\n                        = ((struct r_debug *)(dp->d_un.d_ptr))->r_map;\n                if( lm != 0 ) cachedResult = lm->l_next; /* might be NIL */\n                break;\n            }\n        }\n    }\n    return cachedResult;\n}\n\n#endif /* SUNOS5DL ... */\n\n/* BTL: added to fix circular dlopen definition if GC_SOLARIS_THREADS defined */\n# if defined(GC_must_restore_redefined_dlopen)\n#   define dlopen GC_dlopen\n# endif\n\n#if defined(SUNOS4) && !defined(USE_PROC_FOR_LIBRARIES)\n\n#ifdef LINT\n    struct link_dynamic _DYNAMIC;\n#endif\n\nstatic struct link_map *\nGC_FirstDLOpenedLinkMap()\n{\n    extern struct link_dynamic _DYNAMIC;\n\n    if( &_DYNAMIC == 0) {\n        return(0);\n    }\n    return(_DYNAMIC.ld_un.ld_1->ld_loaded);\n}\n\n/* Return the address of the ld.so allocated common symbol\t*/\n/* with the least address, or 0 if none.\t\t\t*/\nstatic ptr_t GC_first_common()\n{\n    ptr_t result = 0;\n    extern struct link_dynamic _DYNAMIC;\n    struct rtc_symb * curr_symbol;\n    \n    if( &_DYNAMIC == 0) {\n        return(0);\n    }\n    curr_symbol = _DYNAMIC.ldd -> ldd_cp;\n    for (; curr_symbol != 0; curr_symbol = curr_symbol -> rtc_next) {\n        if (result == 0\n            || (ptr_t)(curr_symbol -> rtc_sp -> n_value) < result) {\n            result = (ptr_t)(curr_symbol -> rtc_sp -> n_value);\n        }\n    }\n    return(result);\n}\n\n#endif  /* SUNOS4 ... */\n\n# if defined(SUNOS4) || defined(SUNOS5DL)\n/* Add dynamic library data sections to the root set.\t\t*/\n# if !defined(PCR) && !defined(GC_SOLARIS_THREADS) && defined(THREADS)\n#   ifndef SRC_M3\n\t--> fix mutual exclusion with dlopen\n#   endif  /* We assume M3 programs don't call dlopen for now */\n# endif\n\n# ifndef USE_PROC_FOR_LIBRARIES\nvoid GC_register_dynamic_libraries()\n{\n  struct link_map *lm = GC_FirstDLOpenedLinkMap();\n  \n\n  for (lm = GC_FirstDLOpenedLinkMap();\n       lm != (struct link_map *) 0;  lm = lm->l_next)\n    {\n#     ifdef SUNOS4\n\tstruct exec *e;\n\t \n        e = (struct exec *) lm->lm_addr;\n        GC_add_roots_inner(\n      \t\t    ((char *) (N_DATOFF(*e) + lm->lm_addr)),\n\t\t    ((char *) (N_BSSADDR(*e) + e->a_bss + lm->lm_addr)),\n\t\t    TRUE);\n#     endif\n#     ifdef SUNOS5DL\n\tElfW(Ehdr) * e;\n        ElfW(Phdr) * p;\n        unsigned long offset;\n        char * start;\n        register int i;\n        \n        e = (ElfW(Ehdr) *) lm->l_addr;\n        if (e == NULL)\n          continue;\n\n        p = ((ElfW(Phdr) *)(((char *)(e)) + e->e_phoff));\n        offset = ((unsigned long)(lm->l_addr));\n        for( i = 0; i < (int)(e->e_phnum); ((i++),(p++)) ) {\n          switch( p->p_type ) {\n            case PT_LOAD:\n              {\n                if( !(p->p_flags & PF_W) ) break;\n                start = ((char *)(p->p_vaddr)) + offset;\n                GC_add_roots_inner(\n                  start,\n                  start + p->p_memsz,\n                  TRUE\n                );\n              }\n              break;\n            default:\n              break;\n          }\n\t}\n#     endif\n    }\n#   ifdef SUNOS4\n      {\n      \tstatic ptr_t common_start = 0;\n      \tptr_t common_end;\n      \textern ptr_t GC_find_limit();\n      \t\n      \tif (common_start == 0) common_start = GC_first_common();\n      \tif (common_start != 0) {\n      \t    common_end = GC_find_limit(common_start, TRUE);\n      \t    GC_add_roots_inner((char *)common_start, (char *)common_end, TRUE);\n      \t}\n      }\n#   endif\n}\n\n# endif /* !USE_PROC ... */\n# endif /* SUNOS */\n\n#if (defined(LINUX) || defined(NACL)) && defined(__ELF__) || defined(SCO_ELF) || \\\n    (defined(FREEBSD) && defined(__ELF__)) || defined(DGUX) || \\\n    (defined(OPENBSD) && defined(__ELF__)) || \\\n    (defined(NETBSD) && defined(__ELF__)) || defined(HURD)\n\n\n#ifdef USE_PROC_FOR_LIBRARIES\n\n#include <string.h>\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#define MAPS_BUF_SIZE (32*1024)\n\nextern ssize_t GC_repeat_read(int fd, char *buf, size_t count);\n\t/* Repeatedly read until buffer is filled, or EOF is encountered */\n\t/* Defined in os_dep.c.  \t\t\t\t\t */\n\nchar *GC_parse_map_entry(char *buf_ptr, word *start, word *end,\n                         char *prot_buf, unsigned int *maj_dev);\nword GC_apply_to_maps(word (*fn)(char *));\n\t/* From os_dep.c\t*/\n\nword GC_register_map_entries(char *maps)\n{\n    char prot_buf[5];\n    char *buf_ptr = maps;\n    int count;\n    word start, end;\n    unsigned int maj_dev;\n    word least_ha, greatest_ha;\n    unsigned i;\n    word datastart = (word)(DATASTART);\n\n    /* Compute heap bounds. FIXME: Should be done by add_to_heap?\t*/\n\tleast_ha = (word)(-1);\n\tgreatest_ha = 0;\n\tfor (i = 0; i < GC_n_heap_sects; ++i) {\n\t    word sect_start = (word)GC_heap_sects[i].hs_start;\n\t    word sect_end = sect_start + GC_heap_sects[i].hs_bytes;\n\t    if (sect_start < least_ha) least_ha = sect_start;\n\t    if (sect_end > greatest_ha) greatest_ha = sect_end;\n        }\n    \tif (greatest_ha < (word)GC_scratch_last_end_ptr)\n\t    greatest_ha = (word)GC_scratch_last_end_ptr; \n\n    for (;;) {\n        buf_ptr = GC_parse_map_entry(buf_ptr, &start, &end, prot_buf, &maj_dev);\n\tif (buf_ptr == NULL) return 1;\n\tif (prot_buf[1] == 'w') {\n\t    /* This is a writable mapping.  Add it to\t\t*/\n\t    /* the root set unless it is already otherwise\t*/\n\t    /* accounted for.\t\t\t\t\t*/\n\t    if (start <= (word)GC_stackbottom && end >= (word)GC_stackbottom) {\n\t\t/* Stack mapping; discard\t*/\n\t\tcontinue;\n\t    }\n#\t    ifdef THREADS\n\t      if (GC_segment_is_thread_stack(start, end)) continue;\n#\t    endif\n\t    /* We no longer exclude the main data segment.\t\t*/\n\t    if (start < least_ha && end > least_ha) {\n\t\tend = least_ha;\n\t    }\n\t    if (start < greatest_ha && end > greatest_ha) {\n\t\tstart = greatest_ha;\n\t    }\n\t    if (start >= least_ha && end <= greatest_ha) continue;\n\t    GC_add_roots_inner((char *)start, (char *)end, TRUE);\n\t}\n    }\n    return 1;\n}\n\nvoid GC_register_dynamic_libraries()\n{\n   if (!GC_apply_to_maps(GC_register_map_entries))\n       ABORT(\"Failed to read /proc for library registration.\");\n}\n\n/* We now take care of the main data segment ourselves: */\nGC_bool GC_register_main_static_data()\n{\n  return FALSE;\n}\n  \n# define HAVE_REGISTER_MAIN_STATIC_DATA\n\n#endif /* USE_PROC_FOR_LIBRARIES */\n\n#if !defined(USE_PROC_FOR_LIBRARIES)\n/* The following is the preferred way to walk dynamic libraries\t*/\n/* For glibc 2.2.4+.  Unfortunately, it doesn't work for older\t*/\n/* versions.  Thanks to Jakub Jelinek for most of the code.\t*/\n\n# if (defined(LINUX) || defined (__GLIBC__) || defined(NACL)) /* Are others OK here, too? */ \\\n     && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \\\n         || (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && defined(DT_CONFIG))) \n\n/* We have the header files for a glibc that includes dl_iterate_phdr.\t*/\n/* It may still not be available in the library on the target system.   */\n/* Thus we also treat it as a weak symbol.\t\t\t\t*/\n#define HAVE_DL_ITERATE_PHDR\n\nstatic int GC_register_dynlib_callback(info, size, ptr)\n     struct dl_phdr_info * info;\n     size_t size;\n     void * ptr;\n{\n  const ElfW(Phdr) * p;\n  char * start;\n  register int i;\n\n  /* Make sure struct dl_phdr_info is at least as big as we need.  */\n  if (size < offsetof (struct dl_phdr_info, dlpi_phnum)\n      + sizeof (info->dlpi_phnum))\n    return -1;\n\n  p = info->dlpi_phdr;\n  for( i = 0; i < (int)(info->dlpi_phnum); ((i++),(p++)) ) {\n    switch( p->p_type ) {\n      case PT_LOAD:\n\t{\n\t  if( !(p->p_flags & PF_W) ) break;\n\t  start = ((char *)(p->p_vaddr)) + info->dlpi_addr;\n\t  GC_add_roots_inner(start, start + p->p_memsz, TRUE);\n\t}\n      break;\n      default:\n\tbreak;\n    }\n  }\n\n  * (int *)ptr = 1;\t/* Signal that we were called */\n  return 0;\n}     \n\n/* Return TRUE if we succeed, FALSE if dl_iterate_phdr wasn't there. */\n\n#pragma weak dl_iterate_phdr\n\nGC_bool GC_register_dynamic_libraries_dl_iterate_phdr()\n{\n  if (dl_iterate_phdr) {\n    int did_something = 0;\n    dl_iterate_phdr(GC_register_dynlib_callback, &did_something);\n    if (!did_something) {\n\t/* dl_iterate_phdr may forget the static data segment in\t*/\n\t/* statically linked executables.\t\t\t\t*/\n\tGC_add_roots_inner(DATASTART, (char *)(DATAEND), TRUE);\n#       if defined(DATASTART2)\n          GC_add_roots_inner(DATASTART2, (char *)(DATAEND2), TRUE);\n#       endif\n    }\n\n    return TRUE;\n  } else {\n    return FALSE;\n  }\n}\n\n/* Do we need to separately register the main static data segment? */\nGC_bool GC_register_main_static_data()\n{\n  return (dl_iterate_phdr == 0);\n}\n\n#define HAVE_REGISTER_MAIN_STATIC_DATA\n\n# else /* !LINUX || version(glibc) < 2.2.4 */\n\n/* Dynamic loading code for Linux running ELF. Somewhat tested on\n * Linux/x86, untested but hopefully should work on Linux/Alpha. \n * This code was derived from the Solaris/ELF support. Thanks to\n * whatever kind soul wrote that.  - Patrick Bridges */\n\n/* This doesn't necessarily work in all cases, e.g. with preloaded\n * dynamic libraries.\t\t\t\t\t\t*/\n\n#if defined(NETBSD) || defined(OPENBSD)\n# if !defined(OPENBSD)\n#  include <sys/exec_elf.h>\n# endif\n/* for compatibility with 1.4.x */\n#  ifndef DT_DEBUG\n#  define DT_DEBUG     21\n#  endif\n#  ifndef PT_LOAD\n#  define PT_LOAD      1\n#  endif\n#  ifndef PF_W\n#  define PF_W         2\n#  endif\n#else\n#  include <elf.h>\n#endif\n#include <link.h>\n\n# endif\n\n#ifdef __GNUC__\n# pragma weak _DYNAMIC\n#endif\nextern ElfW(Dyn) _DYNAMIC[];\n\nstatic struct link_map *\nGC_FirstDLOpenedLinkMap()\n{\n    ElfW(Dyn) *dp;\n    static struct link_map *cachedResult = 0;\n\n    if( _DYNAMIC == 0) {\n        return(0);\n    }\n    if( cachedResult == 0 ) {\n        int tag;\n        for( dp = _DYNAMIC; (tag = dp->d_tag) != 0; dp++ ) {\n\t    /* FIXME: The DT_DEBUG header is not mandated by the\t*/\n\t    /* ELF spec.  This code appears to be dependent on\t\t*/\n\t    /* idiosynchracies of older GNU tool chains.  If this code\t*/\n\t    /* fails for you, the real problem is probably that it is\t*/\n\t    /* being used at all.  You should be getting the \t\t*/\n\t    /* dl_iterate_phdr version.\t\t\t\t\t*/\n            if( tag == DT_DEBUG ) {\n                struct link_map *lm\n                        = ((struct r_debug *)(dp->d_un.d_ptr))->r_map;\n                if( lm != 0 ) cachedResult = lm->l_next; /* might be NIL */\n                break;\n            }\n        }\n    }\n    return cachedResult;\n}\n\n\nvoid GC_register_dynamic_libraries()\n{\n  struct link_map *lm;\n  \n\n# ifdef HAVE_DL_ITERATE_PHDR\n    if (GC_register_dynamic_libraries_dl_iterate_phdr()) {\n\treturn;\n    }\n# endif\n  lm = GC_FirstDLOpenedLinkMap();\n  for (lm = GC_FirstDLOpenedLinkMap();\n       lm != (struct link_map *) 0;  lm = lm->l_next)\n    {\n\tElfW(Ehdr) * e;\n        ElfW(Phdr) * p;\n        unsigned long offset;\n        char * start;\n        register int i;\n        \n        e = (ElfW(Ehdr) *) lm->l_addr;\n        if (e == NULL)\n          continue;\n\n        p = ((ElfW(Phdr) *)(((char *)(e)) + e->e_phoff));\n        offset = ((unsigned long)(lm->l_addr));\n        for( i = 0; i < (int)(e->e_phnum); ((i++),(p++)) ) {\n          switch( p->p_type ) {\n            case PT_LOAD:\n              {\n                if( !(p->p_flags & PF_W) ) break;\n                start = ((char *)(p->p_vaddr)) + offset;\n                GC_add_roots_inner(start, start + p->p_memsz, TRUE);\n              }\n              break;\n            default:\n              break;\n          }\n\t}\n    }\n}\n\n#endif /* !USE_PROC_FOR_LIBRARIES */\n\n#endif /* LINUX */\n\n#if defined(IRIX5) || (defined(USE_PROC_FOR_LIBRARIES) && !defined(LINUX))\n\n#include <sys/procfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <elf.h>\n#include <errno.h>\n#include <signal.h>  /* Only for the following test. */\n#ifndef _sigargs\n# define IRIX6\n#endif\n\nextern void * GC_roots_present();\n\t/* The type is a lie, since the real type doesn't make sense here, */\n\t/* and we only test for NULL.\t\t\t\t\t   */\n\n\n/* We use /proc to track down all parts of the address space that are\t*/\n/* mapped by the process, and throw out regions we know we shouldn't\t*/\n/* worry about.  This may also work under other SVR4 variants.\t\t*/\nvoid GC_register_dynamic_libraries()\n{\n    static int fd = -1;\n    char buf[30];\n    static prmap_t * addr_map = 0;\n    static int current_sz = 0;\t/* Number of records currently in addr_map */\n    static int needed_sz;\t/* Required size of addr_map\t\t*/\n    register int i;\n    register long flags;\n    register ptr_t start;\n    register ptr_t limit;\n    ptr_t heap_start = (ptr_t)HEAP_START;\n    ptr_t heap_end = heap_start;\n\n#   ifdef SUNOS5DL\n#     define MA_PHYS 0\n#   endif /* SUNOS5DL */\n\n    if (fd < 0) {\n      sprintf(buf, \"/proc/%d\", getpid());\n\t/* The above generates a lint complaint, since pid_t varies.\t*/\n\t/* It's unclear how to improve this.\t\t\t\t*/\n      fd = open(buf, O_RDONLY);\n      if (fd < 0) {\n    \tABORT(\"/proc open failed\");\n      }\n    }\n    if (ioctl(fd, PIOCNMAP, &needed_sz) < 0) {\n\tGC_err_printf2(\"fd = %d, errno = %d\\n\", fd, errno);\n    \tABORT(\"/proc PIOCNMAP ioctl failed\");\n    }\n    if (needed_sz >= current_sz) {\n        current_sz = needed_sz * 2 + 1;\n        \t\t/* Expansion, plus room for 0 record */\n        addr_map = (prmap_t *)GC_scratch_alloc((word)\n\t\t\t\t\t\t(current_sz * sizeof(prmap_t)));\n    }\n    if (ioctl(fd, PIOCMAP, addr_map) < 0) {\n        GC_err_printf4(\"fd = %d, errno = %d, needed_sz = %d, addr_map = 0x%X\\n\",\n                        fd, errno, needed_sz, addr_map);\n    \tABORT(\"/proc PIOCMAP ioctl failed\");\n    };\n    if (GC_n_heap_sects > 0) {\n    \theap_end = GC_heap_sects[GC_n_heap_sects-1].hs_start\n    \t\t\t+ GC_heap_sects[GC_n_heap_sects-1].hs_bytes;\n    \tif (heap_end < GC_scratch_last_end_ptr) heap_end = GC_scratch_last_end_ptr; \n    }\n    for (i = 0; i < needed_sz; i++) {\n        flags = addr_map[i].pr_mflags;\n        if ((flags & (MA_BREAK | MA_STACK | MA_PHYS\n\t\t      | MA_FETCHOP | MA_NOTCACHED)) != 0) goto irrelevant;\n        if ((flags & (MA_READ | MA_WRITE)) != (MA_READ | MA_WRITE))\n            goto irrelevant;\n          /* The latter test is empirically useless in very old Irix\t*/\n\t  /* versions.  Other than the\t\t\t\t\t*/\n          /* main data and stack segments, everything appears to be\t*/\n          /* mapped readable, writable, executable, and shared(!!).\t*/\n          /* This makes no sense to me.\t- HB\t\t\t\t*/\n        start = (ptr_t)(addr_map[i].pr_vaddr);\n        if (GC_roots_present(start)) goto irrelevant;\n        if (start < heap_end && start >= heap_start)\n        \tgoto irrelevant;\n#\tifdef MMAP_STACKS\n\t  if (GC_is_thread_stack(start)) goto irrelevant;\n#\tendif /* MMAP_STACKS */\n\n        limit = start + addr_map[i].pr_size;\n\t/* The following seemed to be necessary for very old versions \t*/\n\t/* of Irix, but it has been reported to discard relevant\t*/\n\t/* segments under Irix 6.5.  \t\t\t\t\t*/\n#\tifndef IRIX6\n\t  if (addr_map[i].pr_off == 0 && strncmp(start, ELFMAG, 4) == 0) {\n\t    /* Discard text segments, i.e. 0-offset mappings against\t*/\n\t    /* executable files which appear to have ELF headers.\t*/\n\t    caddr_t arg;\n\t    int obj;\n#\t    define MAP_IRR_SZ 10\n\t    static ptr_t map_irr[MAP_IRR_SZ];\n\t    \t\t\t\t/* Known irrelevant map entries\t*/\n\t    static int n_irr = 0;\n\t    struct stat buf;\n\t    register int i;\n\t    \n\t    for (i = 0; i < n_irr; i++) {\n\t        if (map_irr[i] == start) goto irrelevant;\n\t    }\n\t    arg = (caddr_t)start;\n\t    obj = ioctl(fd, PIOCOPENM, &arg);\n\t    if (obj >= 0) {\n\t        fstat(obj, &buf);\n\t        close(obj);\n\t        if ((buf.st_mode & 0111) != 0) {\n\t            if (n_irr < MAP_IRR_SZ) {\n\t                map_irr[n_irr++] = start;\n\t            }\n\t            goto irrelevant;\n\t        }\n\t    }\n\t  }\n#\tendif /* !IRIX6 */\n        GC_add_roots_inner(start, limit, TRUE);\n      irrelevant: ;\n    }\n    /* Dont keep cached descriptor, for now.  Some kernels don't like us */\n    /* to keep a /proc file descriptor around during kill -9.\t\t */\n    \tif (close(fd) < 0) ABORT(\"Couldnt close /proc file\");\n\tfd = -1;\n}\n\n# endif /* USE_PROC || IRIX5 */\n\n# if defined(MSWIN32) || defined(MSWINCE)\n\n# define WIN32_LEAN_AND_MEAN\n# define NOSERVICE\n# include <windows.h>\n# include <stdlib.h>\n\n  /* We traverse the entire address space and register all segments \t*/\n  /* that could possibly have been written to.\t\t\t\t*/\n  \n  extern GC_bool GC_is_heap_base (ptr_t p);\n\n# ifdef GC_WIN32_THREADS\n    extern void GC_get_next_stack(char *start, char **lo, char **hi);\n    void GC_cond_add_roots(char *base, char * limit)\n    {\n      char * curr_base = base;\n      char * next_stack_lo;\n      char * next_stack_hi;\n   \n      if (base == limit) return;\n      for(;;) {\n\t  GC_get_next_stack(curr_base, &next_stack_lo, &next_stack_hi);\n\t  if (next_stack_lo >= limit) break;\n\t  GC_add_roots_inner(curr_base, next_stack_lo, TRUE);\n\t  curr_base = next_stack_hi;\n      }\n      if (curr_base < limit) GC_add_roots_inner(curr_base, limit, TRUE);\n    }\n# else\n    void GC_cond_add_roots(char *base, char * limit)\n    {\n      char dummy;\n      char * stack_top\n\t = (char *) ((word)(&dummy) & ~(GC_sysinfo.dwAllocationGranularity-1));\n      if (base == limit) return;\n      if (limit > stack_top && base < GC_stackbottom) {\n    \t  /* Part of the stack; ignore it. */\n    \t  return;\n      }\n      GC_add_roots_inner(base, limit, TRUE);\n    }\n# endif\n\n# ifdef MSWINCE\n  /* Do we need to separately register the main static data segment? */\n  GC_bool GC_register_main_static_data()\n  {\n    return FALSE;\n  }\n# else /* win32 */\n  extern GC_bool GC_no_win32_dlls;\n\n  GC_bool GC_register_main_static_data()\n  {\n    return GC_no_win32_dlls;\n  }\n# endif /* win32 */\n  \n# define HAVE_REGISTER_MAIN_STATIC_DATA\n\n  /* The frame buffer testing code is dead in this version.\t*/\n  /* We leave it here temporarily in case the switch to just \t*/\n  /* testing for MEM_IMAGE sections causes un expected \t\t*/\n  /* problems.\t\t\t\t\t\t\t*/\n  GC_bool GC_warn_fb = TRUE;\t/* Warn about traced likely \t*/\n  \t\t\t\t/* graphics memory.\t\t*/\n  GC_bool GC_disallow_ignore_fb = FALSE;\n  int GC_ignore_fb_mb;\t/* Ignore mappings bigger than the \t*/\n  \t\t\t/* specified number of MB.\t\t*/\n  GC_bool GC_ignore_fb = FALSE; /* Enable frame buffer \t*/\n  \t\t\t\t/* checking.\t\t*/\n  \n  /* Issue warning if tracing apparent framebuffer. \t\t*/\n  /* This limits us to one warning, and it's a back door to\t*/\n  /* disable that.\t\t\t\t\t\t*/\n \n  /* Should [start, start+len) be treated as a frame buffer\t*/\n  /* and ignored?\t\t\t\t\t\t*/\n  /* Unfortunately, we currently are not quite sure how to tell\t*/\n  /* this automatically, and rely largely on user input.\t*/\n  /* We expect that any mapping with type MEM_MAPPED (which \t*/\n  /* apparently excludes library data sections) can be safely\t*/\n  /* ignored.  But we're too chicken to do that in this \t*/\n  /* version.\t\t\t\t\t\t\t*/\n  /* Based on a very limited sample, it appears that:\t\t*/\n  /* \t- Frame buffer mappings appear as mappings of large\t*/\n  /*\t  length, usually a bit less than a power of two.\t*/\n  /*\t- The definition of \"a bit less\" in the above cannot\t*/\n  /*\t  be made more precise.\t\t\t\t\t*/\n  /*\t- Have a starting address at best 64K aligned.\t\t*/\n  /*\t- Have type == MEM_MAPPED.\t\t\t\t*/\n  static GC_bool is_frame_buffer(ptr_t start, size_t len, DWORD tp)\n  {\n    static GC_bool initialized = FALSE;\n#   define MB (1024*1024)\n#   define DEFAULT_FB_MB 15\n#   define MIN_FB_MB 3\n\n    if (GC_disallow_ignore_fb || tp != MEM_MAPPED) return FALSE;\n    if (!initialized) {\n      char * ignore_fb_string =  GETENV(\"GC_IGNORE_FB\");\n\n      if (0 != ignore_fb_string) {\n\twhile (*ignore_fb_string == ' ' || *ignore_fb_string == '\\t')\n\t  ++ignore_fb_string;\n\tif (*ignore_fb_string == '\\0') {\n\t  GC_ignore_fb_mb = DEFAULT_FB_MB;\n\t} else {\n\t  GC_ignore_fb_mb = atoi(ignore_fb_string);\n\t  if (GC_ignore_fb_mb < MIN_FB_MB) {\n\t    WARN(\"Bad GC_IGNORE_FB value.  Using %ld\\n\", DEFAULT_FB_MB);\n\t    GC_ignore_fb_mb = DEFAULT_FB_MB;\n\t  }\n\t}\n\tGC_ignore_fb = TRUE;\n      } else {\n\tGC_ignore_fb_mb = DEFAULT_FB_MB;  /* For warning */\n      }\n      initialized = TRUE;\n    }\n    if (len >= ((size_t)GC_ignore_fb_mb << 20)) {\n      if (GC_ignore_fb) {\n\treturn TRUE;\n      } else {\n\tif (GC_warn_fb) {\n\t  WARN(\"Possible frame buffer mapping at 0x%lx: \\n\"\n\t       \"\\tConsider setting GC_IGNORE_FB to improve performance.\\n\",\n\t       start);\n\t  GC_warn_fb = FALSE;\n\t}\n\treturn FALSE;\n      }\n    } else {\n      return FALSE;\n    }\n  }\n\n# ifdef DEBUG_VIRTUALQUERY\n  void GC_dump_meminfo(MEMORY_BASIC_INFORMATION *buf)\n  {\n    GC_printf4(\"BaseAddress = %lx, AllocationBase = %lx, RegionSize = %lx(%lu)\\n\",\n\t       buf -> BaseAddress, buf -> AllocationBase, buf -> RegionSize,\n\t       buf -> RegionSize);\n    GC_printf4(\"\\tAllocationProtect = %lx, State = %lx, Protect = %lx, \"\n\t       \"Type = %lx\\n\",\n\t       buf -> AllocationProtect, buf -> State, buf -> Protect,\n\t       buf -> Type);\n  }\n# endif /* DEBUG_VIRTUALQUERY */\n\n  void GC_register_dynamic_libraries()\n  {\n    MEMORY_BASIC_INFORMATION buf;\n    DWORD result;\n    DWORD protect;\n    LPVOID p;\n    char * base;\n    char * limit, * new_limit;\n\n#   ifdef MSWIN32\n      if (GC_no_win32_dlls) return;\n#   endif\n    base = limit = p = GC_sysinfo.lpMinimumApplicationAddress;\n#   if defined(MSWINCE) && !defined(_WIN32_WCE_EMULATION)\n    /* Only the first 32 MB of address space belongs to the current process */\n    while (p < (LPVOID)0x02000000) {\n        result = VirtualQuery(p, &buf, sizeof(buf));\n\tif (result == 0) {\n\t    /* Page is free; advance to the next possible allocation base */\n\t    new_limit = (char *)\n\t\t(((DWORD) p + GC_sysinfo.dwAllocationGranularity)\n\t\t & ~(GC_sysinfo.dwAllocationGranularity-1));\n\t} else\n#   else\n    while (p < GC_sysinfo.lpMaximumApplicationAddress) {\n        result = VirtualQuery(p, &buf, sizeof(buf));\n#   endif\n\t{\n\t    if (result != sizeof(buf)) {\n\t\tABORT(\"Weird VirtualQuery result\");\n\t    }\n\t    new_limit = (char *)p + buf.RegionSize;\n\t    protect = buf.Protect;\n\t    if (buf.State == MEM_COMMIT\n\t\t&& (protect == PAGE_EXECUTE_READWRITE\n\t\t    || protect == PAGE_READWRITE)\n\t\t&& !GC_is_heap_base(buf.AllocationBase)\n\t\t/* This used to check for\n\t\t * !is_frame_buffer(p, buf.RegionSize, buf.Type)\n\t\t * instead of just checking for MEM_IMAGE.\n\t\t * If something breaks, change it back. */\n\t\t&& buf.Type == MEM_IMAGE) {  \n#\t        ifdef DEBUG_VIRTUALQUERY\n\t          GC_dump_meminfo(&buf);\n#\t        endif\n\t\tif ((char *)p != limit) {\n\t\t    GC_cond_add_roots(base, limit);\n\t\t    base = p;\n\t\t}\n\t\tlimit = new_limit;\n\t    }\n\t}\n        if (p > (LPVOID)new_limit /* overflow */) break;\n        p = (LPVOID)new_limit;\n    }\n    GC_cond_add_roots(base, limit);\n  }\n\n#endif /* MSWIN32 || MSWINCE */\n  \n#if defined(ALPHA) && defined(OSF1)\n\n#include <loader.h>\n\nvoid GC_register_dynamic_libraries()\n{\n  int status;\n  ldr_process_t mypid;\n\n  /* module */\n    ldr_module_t moduleid = LDR_NULL_MODULE;\n    ldr_module_info_t moduleinfo;\n    size_t moduleinfosize = sizeof(moduleinfo);\n    size_t modulereturnsize;    \n\n  /* region */\n    ldr_region_t region; \n    ldr_region_info_t regioninfo;\n    size_t regioninfosize = sizeof(regioninfo);\n    size_t regionreturnsize;\n\n  /* Obtain id of this process */\n    mypid = ldr_my_process();\n  \n  /* For each module */\n    while (TRUE) {\n\n      /* Get the next (first) module */\n        status = ldr_next_module(mypid, &moduleid);\n\n      /* Any more modules? */\n        if (moduleid == LDR_NULL_MODULE)\n            break;    /* No more modules */\n\n      /* Check status AFTER checking moduleid because */\n      /* of a bug in the non-shared ldr_next_module stub */\n        if (status != 0 ) {\n            GC_printf1(\"dynamic_load: status = %ld\\n\", (long)status);\n            {\n                extern char *sys_errlist[];\n                extern int sys_nerr;\n                extern int errno;\n                if (errno <= sys_nerr) {\n                    GC_printf1(\"dynamic_load: %s\\n\", (long)sys_errlist[errno]);\n               } else {\n                    GC_printf1(\"dynamic_load: %d\\n\", (long)errno);\n                }\n        }\n            ABORT(\"ldr_next_module failed\");\n         }\n\n      /* Get the module information */\n        status = ldr_inq_module(mypid, moduleid, &moduleinfo,\n                                moduleinfosize, &modulereturnsize); \n        if (status != 0 )\n            ABORT(\"ldr_inq_module failed\");\n\n      /* is module for the main program (i.e. nonshared portion)? */\n          if (moduleinfo.lmi_flags & LDR_MAIN)\n              continue;    /* skip the main module */\n\n#     ifdef VERBOSE\n          GC_printf(\"---Module---\\n\");\n          GC_printf(\"Module ID            = %16ld\\n\", moduleinfo.lmi_modid);\n          GC_printf(\"Count of regions     = %16d\\n\", moduleinfo.lmi_nregion);\n          GC_printf(\"flags for module     = %16lx\\n\", moduleinfo.lmi_flags); \n          GC_printf(\"pathname of module   = \\\"%s\\\"\\n\", moduleinfo.lmi_name);\n#     endif\n\n      /* For each region in this module */\n        for (region = 0; region < moduleinfo.lmi_nregion; region++) {\n\n          /* Get the region information */\n            status = ldr_inq_region(mypid, moduleid, region, &regioninfo,\n                                    regioninfosize, &regionreturnsize);\n            if (status != 0 )\n                ABORT(\"ldr_inq_region failed\");\n\n          /* only process writable (data) regions */\n            if (! (regioninfo.lri_prot & LDR_W))\n                continue;\n\n#         ifdef VERBOSE\n              GC_printf(\"--- Region ---\\n\");\n              GC_printf(\"Region number    = %16ld\\n\",\n              \t        regioninfo.lri_region_no);\n              GC_printf(\"Protection flags = %016x\\n\",  regioninfo.lri_prot);\n              GC_printf(\"Virtual address  = %16p\\n\",   regioninfo.lri_vaddr);\n              GC_printf(\"Mapped address   = %16p\\n\",   regioninfo.lri_mapaddr);\n              GC_printf(\"Region size      = %16ld\\n\",  regioninfo.lri_size);\n              GC_printf(\"Region name      = \\\"%s\\\"\\n\", regioninfo.lri_name);\n#         endif\n\n          /* register region as a garbage collection root */\n            GC_add_roots_inner (\n                (char *)regioninfo.lri_mapaddr,\n                (char *)regioninfo.lri_mapaddr + regioninfo.lri_size,\n                TRUE);\n\n        }\n    }\n}\n#endif\n\n#if defined(HPUX)\n\n#include <errno.h>\n#include <dl.h>\n\nextern int errno;\nextern char *sys_errlist[];\nextern int sys_nerr;\n\nvoid GC_register_dynamic_libraries()\n{\n  int status;\n  int index = 1; /* Ordinal position in shared library search list */\n  struct shl_descriptor *shl_desc; /* Shared library info, see dl.h */\n\n  /* For each dynamic library loaded */\n    while (TRUE) {\n\n      /* Get info about next shared library */\n        status = shl_get(index, &shl_desc);\n\n      /* Check if this is the end of the list or if some error occured */\n        if (status != 0) {\n#\t ifdef GC_HPUX_THREADS\n\t   /* I've seen errno values of 0.  The man page is not clear\t*/\n\t   /* as to whether errno should get set on a -1 return.\t*/\n\t   break;\n#\t else\n          if (errno == EINVAL) {\n              break; /* Moved past end of shared library list --> finished */\n          } else {\n              if (errno <= sys_nerr) {\n                    GC_printf1(\"dynamic_load: %s\\n\", (long) sys_errlist[errno]);\n              } else {\n                    GC_printf1(\"dynamic_load: %d\\n\", (long) errno);\n\t      }\n              ABORT(\"shl_get failed\");\n          }\n#\t endif\n        }\n\n#     ifdef VERBOSE\n          GC_printf0(\"---Shared library---\\n\");\n          GC_printf1(\"\\tfilename        = \\\"%s\\\"\\n\", shl_desc->filename);\n          GC_printf1(\"\\tindex           = %d\\n\", index);\n          GC_printf1(\"\\thandle          = %08x\\n\",\n\t\t\t\t\t(unsigned long) shl_desc->handle);\n          GC_printf1(\"\\ttext seg. start = %08x\\n\", shl_desc->tstart);\n          GC_printf1(\"\\ttext seg. end   = %08x\\n\", shl_desc->tend);\n          GC_printf1(\"\\tdata seg. start = %08x\\n\", shl_desc->dstart);\n          GC_printf1(\"\\tdata seg. end   = %08x\\n\", shl_desc->dend);\n          GC_printf1(\"\\tref. count      = %lu\\n\", shl_desc->ref_count);\n#     endif\n\n      /* register shared library's data segment as a garbage collection root */\n        GC_add_roots_inner((char *) shl_desc->dstart,\n\t\t\t   (char *) shl_desc->dend, TRUE);\n\n        index++;\n    }\n}\n#endif /* HPUX */\n\n#ifdef RS6000\n#pragma alloca\n#include <sys/ldr.h>\n#include <sys/errno.h>\nvoid GC_register_dynamic_libraries()\n{\n\tint len;\n\tchar *ldibuf;\n\tint ldibuflen;\n\tstruct ld_info *ldi;\n\n\tldibuf = alloca(ldibuflen = 8192);\n\n\twhile ( (len = loadquery(L_GETINFO,ldibuf,ldibuflen)) < 0) {\n\t\tif (errno != ENOMEM) {\n\t\t\tABORT(\"loadquery failed\");\n\t\t}\n\t\tldibuf = alloca(ldibuflen *= 2);\n\t}\n\n\tldi = (struct ld_info *)ldibuf;\n\twhile (ldi) {\n\t\tlen = ldi->ldinfo_next;\n\t\tGC_add_roots_inner(\n\t\t\t\tldi->ldinfo_dataorg,\n\t\t\t\t(ptr_t)(unsigned long)ldi->ldinfo_dataorg\n\t\t\t        + ldi->ldinfo_datasize,\n\t\t\t\tTRUE);\n\t\tldi = len ? (struct ld_info *)((char *)ldi + len) : 0;\n\t}\n}\n#endif /* RS6000 */\n\n#ifdef DARWIN\n\n/* __private_extern__ hack required for pre-3.4 gcc versions.\t*/\n#ifndef __private_extern__\n# define __private_extern__ extern\n# include <mach-o/dyld.h>\n# undef __private_extern__\n#else\n# include <mach-o/dyld.h>\n#endif\n#include <mach-o/getsect.h>\n\n/*#define DARWIN_DEBUG*/\n\nconst static struct { \n        const char *seg;\n        const char *sect;\n} GC_dyld_sections[] = {\n        { SEG_DATA, SECT_DATA },\n        { SEG_DATA, SECT_BSS },\n        { SEG_DATA, SECT_COMMON }\n};\n    \n#ifdef DARWIN_DEBUG\nstatic const char *GC_dyld_name_for_hdr(struct mach_header *hdr) {\n    unsigned long i,c;\n    c = _dyld_image_count();\n    for(i=0;i<c;i++) if(_dyld_get_image_header(i) == hdr)\n        return _dyld_get_image_name(i);\n    return NULL;\n}\n#endif\n        \n/* This should never be called by a thread holding the lock */\nstatic void GC_dyld_image_add(struct mach_header* hdr, unsigned long slide) {\n    unsigned long start,end,i;\n    const struct section *sec;\n    if (GC_no_dls) return;\n    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n        sec = getsectbynamefromheader(\n            hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n        if(sec == NULL || sec->size == 0) continue;\n        start = slide + sec->addr;\n        end = start + sec->size;\n#\tifdef DARWIN_DEBUG\n            GC_printf4(\"Adding section at %p-%p (%lu bytes) from image %s\\n\",\n                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n#       endif\n        GC_add_roots((char*)start,(char*)end);\n    }\n#   ifdef DARWIN_DEBUG\n        GC_print_static_roots();\n#   endif\n}\n\n/* This should never be called by a thread holding the lock */\nstatic void GC_dyld_image_remove(struct mach_header* hdr, unsigned long slide) {\n    unsigned long start,end,i;\n    const struct section *sec;\n    for(i=0;i<sizeof(GC_dyld_sections)/sizeof(GC_dyld_sections[0]);i++) {\n        sec = getsectbynamefromheader(\n            hdr,GC_dyld_sections[i].seg,GC_dyld_sections[i].sect);\n        if(sec == NULL || sec->size == 0) continue;\n        start = slide + sec->addr;\n        end = start + sec->size;\n#\tifdef DARWIN_DEBUG\n            GC_printf4(\"Removing section at %p-%p (%lu bytes) from image %s\\n\",\n                start,end,sec->size,GC_dyld_name_for_hdr(hdr));\n#\t\tendif\n        GC_remove_roots((char*)start,(char*)end);\n    }\n#   ifdef DARWIN_DEBUG\n        GC_print_static_roots();\n#   endif\n}\n\nvoid GC_register_dynamic_libraries() {\n    /* Currently does nothing. The callbacks are setup by GC_init_dyld() \n    The dyld library takes it from there. */\n}\n\n/* The _dyld_* functions have an internal lock so no _dyld functions\n   can be called while the world is stopped without the risk of a deadlock.\n   Because of this we MUST setup callbacks BEFORE we ever stop the world.\n   This should be called BEFORE any thread in created and WITHOUT the\n   allocation lock held. */\n   \nvoid GC_init_dyld() {\n  static GC_bool initialized = FALSE;\n  char *bind_fully_env = NULL;\n  \n  if(initialized) return;\n  \n#   ifdef DARWIN_DEBUG\n  GC_printf0(\"Registering dyld callbacks...\\n\");\n#   endif\n  \n  /* Apple's Documentation:\n     When you call _dyld_register_func_for_add_image, the dynamic linker runtime\n     calls the specified callback (func) once for each of the images that is\n     currently loaded into the program. When a new image is added to the program,\n     your callback is called again with the mach_header for the new image, and the \t\n     virtual memory slide amount of the new image. \n     \n     This WILL properly register already linked libraries and libraries \n     linked in the future\n  */\n  \n    _dyld_register_func_for_add_image(GC_dyld_image_add);\n    _dyld_register_func_for_remove_image(GC_dyld_image_remove);\n\n    /* Set this early to avoid reentrancy issues. */\n    initialized = TRUE;\n\n    bind_fully_env = getenv(\"DYLD_BIND_AT_LAUNCH\");\n    \n    if (bind_fully_env == NULL) {\n#   ifdef DARWIN_DEBUG\n      GC_printf0(\"Forcing full bind of GC code...\\n\");\n#   endif\n      \n      if(!_dyld_bind_fully_image_containing_address((unsigned long*)GC_malloc))\n        GC_abort(\"_dyld_bind_fully_image_containing_address failed\");\n    }\n\n}\n\n#define HAVE_REGISTER_MAIN_STATIC_DATA\nGC_bool GC_register_main_static_data()\n{\n  /* Already done through dyld callbacks */\n  return FALSE;\n}\n\n#endif /* DARWIN */\n\n#else /* !DYNAMIC_LOADING */\n\n#ifdef PCR\n\n#   include \"il/PCR_IL.h\"\n#   include \"th/PCR_ThCtl.h\"\n#   include \"mm/PCR_MM.h\"\n\nvoid GC_register_dynamic_libraries()\n{\n    /* Add new static data areas of dynamically loaded modules.\t*/\n        {\n          PCR_IL_LoadedFile * p = PCR_IL_GetLastLoadedFile();\n          PCR_IL_LoadedSegment * q;\n          \n          /* Skip uncommited files */\n          while (p != NIL && !(p -> lf_commitPoint)) {\n              /* The loading of this file has not yet been committed\t*/\n              /* Hence its description could be inconsistent.  \t\t*/\n              /* Furthermore, it hasn't yet been run.  Hence its data\t*/\n              /* segments can't possibly reference heap allocated\t*/\n              /* objects.\t\t\t\t\t\t*/\n              p = p -> lf_prev;\n          }\n          for (; p != NIL; p = p -> lf_prev) {\n            for (q = p -> lf_ls; q != NIL; q = q -> ls_next) {\n              if ((q -> ls_flags & PCR_IL_SegFlags_Traced_MASK)\n                  == PCR_IL_SegFlags_Traced_on) {\n                GC_add_roots_inner\n                \t((char *)(q -> ls_addr), \n                \t (char *)(q -> ls_addr) + q -> ls_bytes,\n                \t TRUE);\n              }\n            }\n          }\n        }\n}\n\n\n#else /* !PCR */\n\nvoid GC_register_dynamic_libraries(){}\n\nint GC_no_dynamic_loading;\n\n#endif /* !PCR */\n\n#endif /* !DYNAMIC_LOADING */\n\n#ifndef HAVE_REGISTER_MAIN_STATIC_DATA\n\n/* Do we need to separately register the main static data segment? */\nGC_bool GC_register_main_static_data()\n{\n  return TRUE;\n}\n#endif /* HAVE_REGISTER_MAIN_STATIC_DATA */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/libgc/m4/libtool.m4": "# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n#                 Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n#                 Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n#   This file is part of GNU Libtool.\n#\n# GNU Libtool is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 2 of\n# the License, or (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html, or\n# obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n])\n\n# serial 57 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT\nAC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\n_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=\"$ltmain\"\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nm4_defun([_LT_CC_BASENAME],\n[for cc_temp in $1\"\"; do\n  case $cc_temp in\n    compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n    distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n    \\-*) ;;\n    *) break;;\n  esac\ndone\ncc_basename=`$ECHO \"$cc_temp\" | $SED \"s%.*/%%; s%^$host_alias-%%\"`\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\n\n_LT_DECL([], [PATH_SEPARATOR], [1], [The PATH separator for the build system])dnl\ndnl\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_PATH_CONVERSION_FUNCTIONS])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CHECK_SHAREDLIB_FROM_LINKLIB])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_WITH_SYSROOT])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options which allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test \"X${COLLECT_NAMES+set}\" != Xset; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a `.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=\"$lt_cv_prog_gnu_ld\"\n\nold_CC=\"$CC\"\nold_CFLAGS=\"$CFLAGS\"\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PREPARE_SED_QUOTE_VARS\n# --------------------------\n# Define a few sed substitution that help us do robust quoting.\nm4_defun([_LT_PREPARE_SED_QUOTE_VARS],\n[# Backslashify metacharacters that are still active within\n# double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n])\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from `configure', and `config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# `config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=\"$ac_aux_dir/ltmain.sh\"\n])# _LT_PROG_LTMAIN\n\n\n## ------------------------------------- ##\n## Accumulate code for creating libtool. ##\n## ------------------------------------- ##\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the `libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n## ------------------------ ##\n## FIXME: Eliminate VARNAME ##\n## ------------------------ ##\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to `config.status' so that its\n# declaration there will have the same value as in `configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"$][$1\" | $SED \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"$<var>\" | $SED \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags=\"_LT_TAGS\"dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into `config.status', and then the shell code to quote escape them in\n# for loops in `config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$[]1\n_LTECHO_EOF'\n}\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])\n# ------------------------------------\n# Generate a child script FILE with all initialization necessary to\n# reuse the environment learned by the parent script, and make the\n# file executable.  If COMMENT is supplied, it is inserted after the\n# `#!' sequence but before initialization text begins.  After this\n# macro, additional text can be appended to FILE to form the body of\n# the child script.  The macro ends with non-zero status if the\n# file could not be fully written (such as if the disk is full).\nm4_ifdef([AS_INIT_GENERATED],\n[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],\n[m4_defun([_LT_GENERATED_FILE_INIT],\n[m4_require([AS_PREPARE])]dnl\n[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl\n[lt_write_fail=0\ncat >$1 <<_ASEOF || lt_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n$2\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$1 <<\\_ASEOF || lt_write_fail=1\nAS_SHELL_SANITIZE\n_AS_PREPARE\nexec AS_MESSAGE_FD>&1\n_ASEOF\ntest $lt_write_fail = 0 && chmod +x $1[]dnl\nm4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\n_LT_GENERATED_FILE_INIT([\"$CONFIG_LT\"],\n[# Run this file to recreate a libtool stub with the current configuration.])\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nlt_cl_silent=false\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n\\`$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test $[#] != 0\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nlt_cl_success=:\ntest \"$silent\" = yes &&\n  lt_config_lt_args=\"$lt_config_lt_args --quiet\"\nexec AS_MESSAGE_LOG_FD>/dev/null\n$SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\nexec AS_MESSAGE_LOG_FD>>config.log\n$lt_cl_success || AS_EXIT(1)\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options which allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\" ; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=\"${ofile}T\"\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n\n# `$ECHO \"$ofile\" | sed 's%^.*/%%'` - Provide generalized library-building support services.\n# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n#\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test \"X${COLLECT_NAMES+set}\" != Xset; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '$q' \"$ltmain\" >> \"$cfgfile\" \\\n     || (rm -f \"$cfgfile\"; exit 1)\n\n  _LT_PROG_REPLACE_SHELLFNS\n\n   mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    TIMESTAMP='$TIMESTAMP'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Go],\t\t\t[_LT_LANG(GO)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\nm4_ifndef([AC_PROG_GO], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_GO.  When it is available in    #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\nm4_defun([AC_PROG_GO],\n[AC_LANG_PUSH(Go)dnl\nAC_ARG_VAR([GOC],     [Go compiler command])dnl\nAC_ARG_VAR([GOFLAGS], [Go compiler flags])dnl\n_AC_ARG_VAR_LDFLAGS()dnl\nAC_CHECK_TOOL(GOC, gccgo)\nif test -z \"$GOC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    AC_CHECK_PROG(GOC, [${ac_tool_prefix}gccgo], [${ac_tool_prefix}gccgo])\n  fi\nfi\nif test -z \"$GOC\"; then\n  AC_CHECK_PROG(GOC, gccgo, gccgo, false)\nfi\n])#m4_defun\n])#m4_ifndef\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([AC_PROG_GO],\n  [LT_LANG(GO)],\n  [m4_define([AC_PROG_GO], defn([AC_PROG_GO])[LT_LANG(GO)])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\nAU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\ndnl AC_DEFUN([AC_LIBTOOL_RC], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"${LT_MULTI_MODULE}\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\t# If there is a non-empty error log, and \"single_module\"\n\t# appears in it, assume the flag caused a linker warning\n        if test -s conftest.err && $GREP single_module conftest.err; then\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\t# Otherwise, if the output was created with a 0 exit code from\n\t# the compiler, it worked.\n\telif test -f libconftest.dylib && test $_lt_result -eq 0; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=\"$save_LDFLAGS\"\n    ])\n\n    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],\n      [lt_cv_ld_force_load=no\n      cat > conftest.c << _LT_EOF\nint forced_loaded() { return 2;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS -c -o conftest.o conftest.c\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD\n      echo \"$AR cru libconftest.a conftest.o\" >&AS_MESSAGE_LOG_FD\n      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD\n      echo \"$RANLIB libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $RANLIB libconftest.a 2>&AS_MESSAGE_LOG_FD\n      cat > conftest.c << _LT_EOF\nint main() { return 0;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err\n      _lt_result=$?\n      if test -s conftest.err && $GREP force_load conftest.err; then\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      elif test -f conftest && test $_lt_result -eq 0 && $GREP forced_load conftest >/dev/null 2>&1 ; then\n\tlt_cv_ld_force_load=yes\n      else\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      fi\n        rm -f conftest.err libconftest.a conftest conftest.c\n        rm -rf conftest.dSYM\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]]*)\n\t  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test \"$lt_cv_apple_cc_single_mod\" = \"yes\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test \"$lt_cv_ld_exported_symbols_list\" = \"yes\"; then\n      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'\n    fi\n    if test \"$DSYMUTIL\" != \":\" && test \"$lt_cv_ld_force_load\" = \"no\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES([TAG])\n# ---------------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  if test \"$lt_cv_ld_force_load\" = \"yes\"; then\n    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience ${wl}-force_load,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"`'\n    m4_case([$1], [F77], [_LT_TAGVAR(compiler_needs_object, $1)=yes],\n                  [FC],  [_LT_TAGVAR(compiler_needs_object, $1)=yes])\n  else\n    _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  fi\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=\"$_lt_dar_allow_undefined\"\n  case $cc_basename in\n     ifort*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test \"$_lt_dar_can_shared\" = \"yes\"; then\n    output_verbose_link_cmd=func_echo_all\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod${_lt_dsymutil}\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dsymutil}\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}\"\n    m4_if([$1], [CXX],\n[   if test \"$lt_cv_apple_cc_single_mod\" != \"yes\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dsymutil}\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dar_export_syms}${_lt_dsymutil}\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX([TAGNAME])\n# ----------------------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\n# Store the results from the different compilers for each TAGNAME.\n# Allow to override them for all tags through lt_cv_aix_libpath.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nif test \"${lt_cv_aix_libpath+set}\" = set; then\n  aix_libpath=$lt_cv_aix_libpath\nelse\n  AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM],[\n  lt_aix_libpath_sed='[\n      /Import File Strings/,/^$/ {\n\t  /^0/ {\n\t      s/^0  *\\([^ ]*\\) *$/\\1/\n\t      p\n\t  }\n      }]'\n  _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  # Check for a 64-bit object if we didn't find anything.\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  fi],[])\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=\"/usr/lib:/lib\"\n  fi\n  ])\n  aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\nfi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[m4_divert_text([M4SH-INIT], [$1\n])])# _LT_SHELL_INIT\n\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Find how we can fake an echo command that does not interpret backslash.\n# In particular, with Autoconf 2.60 or later we add some code to the start\n# of the generated configure script which will find a shell with a builtin\n# printf (which we can use as an echo command).\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n\nAC_MSG_CHECKING([how to print strings])\n# Test print first, because it will be a builtin if present.\nif test \"X`( print -r -- -n ) 2>/dev/null`\" = X-n && \\\n   test \"X`print -r -- $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='print -r --'\nelif test \"X`printf %s $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='printf %s\\n'\nelse\n  # Use this function as a fallback that always works.\n  func_fallback_echo ()\n  {\n    eval 'cat <<_LTECHO_EOF\n$[]1\n_LTECHO_EOF'\n  }\n  ECHO='func_fallback_echo'\nfi\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\" \n}\n\ncase \"$ECHO\" in\n  printf*) AC_MSG_RESULT([printf]) ;;\n  print*) AC_MSG_RESULT([print -r]) ;;\n  *) AC_MSG_RESULT([cat]) ;;\nesac\n\nm4_ifdef([_AS_DETECT_SUGGESTED],\n[_AS_DETECT_SUGGESTED([\n  test -n \"${ZSH_VERSION+set}${BASH_VERSION+set}\" || (\n    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n    PATH=/empty FPATH=/empty; export PATH FPATH\n    test \"X`printf %s $ECHO`\" = \"X$ECHO\" \\\n      || test \"X`print -r -- $ECHO`\" = \"X$ECHO\" )])])\n\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_WITH_SYSROOT\n# ----------------\nAC_DEFUN([_LT_WITH_SYSROOT],\n[AC_MSG_CHECKING([for sysroot])\nAC_ARG_WITH([sysroot],\n[  --with-sysroot[=DIR] Search for dependent libraries within DIR\n                        (or the compiler's sysroot if not specified).],\n[], [with_sysroot=no])\n\ndnl lt_sysroot will always be passed unquoted.  We quote it here\ndnl in case the user passed a directory name.\nlt_sysroot=\ncase ${with_sysroot} in #(\n yes)\n   if test \"$GCC\" = yes; then\n     lt_sysroot=`$CC --print-sysroot 2>/dev/null`\n   fi\n   ;; #(\n /*)\n   lt_sysroot=`echo \"$with_sysroot\" | sed -e \"$sed_quote_subst\"`\n   ;; #(\n no|'')\n   ;; #(\n *)\n   AC_MSG_RESULT([${with_sysroot}])\n   AC_MSG_ERROR([The sysroot must be an absolute path.])\n   ;;\nesac\n\n AC_MSG_RESULT([${lt_sysroot:-no}])\n_LT_DECL([], [lt_sysroot], [0], [The root where to search for ]dnl\n[dependent libraries, and in which our libraries should be installed.])])\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=\"32\"\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=\"64\"\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out which ABI we are using.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    case `/usr/bin/file conftest.o` in\n\t      *x86-64*)\n\t\tLD=\"${LD-ld} -m elf32_x86_64\"\n\t\t;;\n\t      *)\n\t\tLD=\"${LD-ld} -m elf_i386\"\n\t\t;;\n\t    esac\n\t    ;;\n\t  powerpc64le-*)\n\t    LD=\"${LD-ld} -m elf32lppclinux\"\n\t    ;;\n\t  powerpc64-*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  powerpcle-*)\n\t    LD=\"${LD-ld} -m elf64lppc\"\n\t    ;;\n\t  powerpc-*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\n  ;;\n*-*solaris*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*)\n        case $host in\n        i?86-*-solaris*)\n          LD=\"${LD-ld} -m elf_x86_64\"\n          ;;\n        sparc*-*-solaris*)\n          LD=\"${LD-ld} -m elf64_sparc\"\n          ;;\n        esac\n        # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.\n        if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then\n          LD=\"${LD-ld}_sol2\"\n        fi\n        ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=\"$enable_libtool_lock\"\n])# _LT_ENABLE_LOCK\n\n\n# _LT_PROG_AR\n# -----------\nm4_defun([_LT_PROG_AR],\n[AC_CHECK_TOOLS(AR, [ar], false)\n: ${AR=ar}\n: ${AR_FLAGS=cru}\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1], [Flags to create an archive])\n\nAC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],\n  [lt_cv_ar_at_file=no\n   AC_COMPILE_IFELSE([AC_LANG_PROGRAM],\n     [echo conftest.$ac_objext > conftest.lst\n      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&AS_MESSAGE_LOG_FD'\n      AC_TRY_EVAL([lt_ar_try])\n      if test \"$ac_status\" -eq 0; then\n\t# Ensure the archiver fails upon bogus file names.\n\trm -f conftest.$ac_objext libconftest.a\n\tAC_TRY_EVAL([lt_ar_try])\n\tif test \"$ac_status\" -ne 0; then\n          lt_cv_ar_at_file=@\n        fi\n      fi\n      rm -f conftest.* libconftest.a\n     ])\n  ])\n\nif test \"x$lt_cv_ar_at_file\" = xno; then\n  archiver_list_spec=\nelse\n  archiver_list_spec=$lt_cv_ar_at_file\nfi\n_LT_DECL([], [archiver_list_spec], [1],\n  [How to feed a file listing to the archiver])\n])# _LT_PROG_AR\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[_LT_PROG_AR\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$tool_oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$tool_oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$tool_oldlib\"\nfi\n\ncase $host_os in\n  darwin*)\n    lock_old_archive_extraction=yes ;;\n  *)\n    lock_old_archive_extraction=no ;;\nesac\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n_LT_DECL([], [lock_old_archive_extraction], [0],\n    [Whether to use a lock for old archive extraction])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"$_lt_linker_boilerplate\" | $SED '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=\"$save_LDFLAGS\"\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=\"ABCD\"\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  mint*)\n    # On MiNT this can take a long time and run out of memory.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  os2*)\n    # The test takes a long time on OS/2.\n    lt_cv_sys_max_cmd_len=8192\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\" && \\\n\ttest undefined != \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8 ; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test \"X\"`env echo \"$teststring$teststring\" 2>/dev/null` \\\n\t         = \"X$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test $i != 17 # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n $lt_cv_sys_max_cmd_len ; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"$cross_compiling\" = yes; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line $LINENO \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n/* When -fvisbility=hidden is used, assume the code has been annotated\n   correspondingly for the symbols needed.  */\n#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))\nint fnord () __attribute__((visibility(\"default\")));\n#endif\n\nint fnord () { return 42; }\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else\n        {\n\t  if (dlsym( self,\"_fnord\"))  status = $lt_dlneed_uscore;\n          else puts (dlerror ());\n\t}\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"x$enable_dlopen\" != xyes; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-ldld\"],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=\"dlopen\"],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-ldld\"])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test \"x$lt_cv_dlopen\" != xno; then\n    enable_dlopen=yes\n  else\n    enable_dlopen=no\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    test \"x$ac_cv_header_dlfcn_h\" = xyes && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=\"$LDFLAGS\"\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test \"x$lt_cv_dlopen_self\" = xyes; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=\"nottested\"\nif test \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" = no && test \"$need_locks\" != no; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test \"$hard_links\" = no; then\n    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED(LT_OBJDIR, \"$lt_cv_objdir/\",\n  [Define to the sub-directory in which libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test \"X$_LT_TAGVAR(hardcode_automatic, $1)\" = \"Xyes\" ; then\n\n  # We can hardcode non-existent directories.\n  if test \"$_LT_TAGVAR(hardcode_direct, $1)\" != no &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" != no &&\n     test \"$_LT_TAGVAR(hardcode_minus_L, $1)\" != no; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test \"$_LT_TAGVAR(hardcode_action, $1)\" = relink ||\n   test \"$_LT_TAGVAR(inherit_rpath, $1)\" = yes; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test \"$shlibpath_overrides_runpath\" = yes ||\n     test \"$enable_shared\" = no; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\" ; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test \"$GCC\" = yes; then\n  case $host_os in\n    darwin*) lt_awk_arg=\"/^libraries:/,/LR/\" ;;\n    *) lt_awk_arg=\"/^libraries:/\" ;;\n  esac\n  case $host_os in\n    mingw* | cegcc*) lt_sed_strip_eq=\"s,=\\([[A-Za-z]]:\\),\\1,g\" ;;\n    *) lt_sed_strip_eq=\"s,=/,/,g\" ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e $lt_sed_strip_eq`\n  case $lt_search_path_spec in\n  *\\;*)\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED 's/;/ /g'`\n    ;;\n  *)\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED \"s/$PATH_SEPARATOR/ /g\"`\n    ;;\n  esac\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary.\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path/$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir\"\n    else\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO \"$lt_tmp_lt_search_path_spec\" | awk '\nBEGIN {RS=\" \"; FS=\"/|\\n\";} {\n  lt_foo=\"\";\n  lt_count=0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo=\"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  # AWK program above erroneously prepends '/' to C:/dos/paths\n  # for these hosts.\n  case $host_os in\n    mingw* | cegcc*) lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" |\\\n      $SED 's,/\\([[A-Za-z]]:\\),\\1,g'` ;;\n  esac\n  sys_lib_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $lt_NL2SP`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=\".so\"\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\ncase $host_os in\naix3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='${libname}${release}${shared_ext}$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test \"$host_cpu\" = ia64; then\n    # AIX 5 supports IA64\n    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line `#! .'.  This would cause the generated library to\n    # depend on `.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    else\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='${libname}${release}.a $libname.a'\n      soname_spec='${libname}${release}${shared_ext}$major'\n    fi\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all \"$lib\" | $SED '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='${libname}${shared_ext}'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=\".dll\"\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$cc_basename in\n  yes,*)\n    # gcc\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\nm4_if([$1], [],[\n      sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/lib/w32api\"])\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    esac\n    dynamic_linker='Win32 ld.exe'\n    ;;\n\n  *,cl*)\n    # Native MSVC\n    libname_spec='$name'\n    soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n    library_names_spec='${libname}.dll.lib'\n\n    case $build_os in\n    mingw*)\n      sys_lib_search_path_spec=\n      lt_save_ifs=$IFS\n      IFS=';'\n      for lt_path in $LIB\n      do\n        IFS=$lt_save_ifs\n        # Let DOS variable expansion print the short 8.3 style file name.\n        lt_path=`cd \"$lt_path\" 2>/dev/null && cmd //C \"for %i in (\".\") do @echo %~si\"`\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec $lt_path\"\n      done\n      IFS=$lt_save_ifs\n      # Convert to MSYS style.\n      sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | sed -e 's|\\\\\\\\|/|g' -e 's| \\\\([[a-zA-Z]]\\\\):| /\\\\1|g' -e 's|^ ||'`\n      ;;\n    cygwin*)\n      # Convert to unix form, then to dos form, then back to unix form\n      # but this time dos style (no spaces!) so that the unix form looks\n      # like /cygdrive/c/PROGRA~1:/cygdr...\n      sys_lib_search_path_spec=`cygpath --path --unix \"$LIB\"`\n      sys_lib_search_path_spec=`cygpath --path --dos \"$sys_lib_search_path_spec\" 2>/dev/null`\n      sys_lib_search_path_spec=`cygpath --path --unix \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      ;;\n    *)\n      sys_lib_search_path_spec=\"$LIB\"\n      if $ECHO \"$sys_lib_search_path_spec\" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH.\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      # FIXME: find the short name or the path components, as spaces are\n      # common. (e.g. \"Program Files\" -> \"PROGRA~1\")\n      ;;\n    esac\n\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n    dynamic_linker='Win32 link.exe'\n    ;;\n\n  *)\n    # Assume MSVC wrapper\n    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'\n    dynamic_linker='Win32 ld.exe'\n    ;;\n  esac\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'\n  soname_spec='${libname}${release}${major}$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[23]].*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2.*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\nhaiku*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  dynamic_linker=\"$host_os runtime_loader\"\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    if test \"X$HPUX_IA64_MODE\" = X32; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n    fi\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...\n  postinstall_cmds='chmod 555 $lib'\n  # or fails outright, so override atomically:\n  install_override_mode=555\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test \"$lt_cv_prog_gnu_ld\" = yes; then\n\t\tversion_type=linux # correct to gnu/linux during the next big refactor\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n\n  # Some binutils ld are patched to set DT_RUNPATH\n  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],\n    [lt_cv_shlibpath_overrides_runpath=no\n    save_LDFLAGS=$LDFLAGS\n    save_libdir=$libdir\n    eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n\t LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n\t [lt_cv_shlibpath_overrides_runpath=yes])])\n    LDFLAGS=$save_LDFLAGS\n    libdir=$save_libdir\n    ])\n  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Append ld.so.conf contents to the search path\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/\"//g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsdelf*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='NetBSD ld.elf_so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=\"/usr/lib\"\n  need_lib_prefix=no\n  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.\n  case $host_os in\n    openbsd3.3 | openbsd3.3.*)\tneed_version=yes ;;\n    *)\t\t\t\tneed_version=no  ;;\n  esac\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    case $host_os in\n      openbsd2.[[89]] | openbsd2.[[89]].*)\n\tshlibpath_overrides_runpath=no\n\t;;\n      *)\n\tshlibpath_overrides_runpath=yes\n\t;;\n      esac\n  else\n    shlibpath_overrides_runpath=yes\n  fi\n  ;;\n\nos2*)\n  libname_spec='$name'\n  shrext_cmds=\".dll\"\n  need_lib_prefix=no\n  library_names_spec='$libname${shared_ext} $libname.a'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=LIBPATH\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=\"$sys_lib_search_path_spec\"\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test \"$with_gnu_ld\" = yes; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec ;then\n    version_type=linux # correct to gnu/linux during the next big refactor\n    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'\n    soname_spec='$libname${shared_ext}.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=freebsd-elf\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test \"$with_gnu_ld\" = yes; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest \"$dynamic_linker\" = no && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test \"$GCC\" = yes; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test \"${lt_cv_sys_lib_search_path_spec+set}\" = set; then\n  sys_lib_search_path_spec=\"$lt_cv_sys_lib_search_path_spec\"\nfi\nif test \"${lt_cv_sys_lib_dlsearch_path_spec+set}\" = set; then\n  sys_lib_dlsearch_path_spec=\"$lt_cv_sys_lib_dlsearch_path_spec\"\nfi\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [install_override_mode], [1],\n    [Permission mode override for installation of shared libraries])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],\n    [Run-time system search path for libraries])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program which can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=\"$MAGIC_CMD\" # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=\"$MAGIC_CMD\"\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f $ac_dir/$1; then\n      lt_cv_path_MAGIC_CMD=\"$ac_dir/$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n  MAGIC_CMD=\"$lt_save_MAGIC_CMD\"\n  ;;\nesac])\nMAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program which can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PROG_ECHO_BACKSLASH])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break\n\t;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break\n\t;;\n      esac\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\nelse\n  lt_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$lt_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    if test \"$GCC\" != yes; then\n      reload_cmds=false\n    fi\n    ;;\n  darwin*)\n    if test \"$GCC\" = yes; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_TAGDECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# `unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# which responds to the $file_magic_cmd with a given extended regex.\n# If you have `file' or equivalent on your system and you're not sure\n# whether `pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.\n  if ( test \"$lt_cv_nm_interface\" = \"BSD nm\" && file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    # Keep this pattern in sync with the one in func_win32_libid.\n    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc*)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\nhaiku*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\\.[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\\.[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd* | netbsdelf*-gnu)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\n\nfile_magic_glob=\nwant_nocaseglob=no\nif test \"$build\" = \"$host\"; then\n  case $host_os in\n  mingw* | pw32*)\n    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then\n      want_nocaseglob=yes\n    else\n      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e \"s/\\(..\\)/s\\/[[\\1]]\\/[[\\1]]\\/g;/g\"`\n    fi\n    ;;\n  esac\nfi\n\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [file_magic_glob], [1],\n    [How to find potential files when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [want_nocaseglob], [1],\n    [Find potential files using nocaseglob when deplibs_check_method = \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=\"$NM\"\nelse\n  lt_nm_to_check=\"${ac_tool_prefix}nm\"\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=\"$lt_save_ifs\"\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=\"$ac_dir/$lt_tmp_nm\"\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\" ; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the `sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\tcase `\"$tmp_nm\" -B /dev/null 2>&1 | sed '1q'` in\n\t*/dev/null* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test \"$lt_cv_path_NM\" != \"no\"; then\n  NM=\"$lt_cv_path_NM\"\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  if test -n \"$DUMPBIN\"; then :\n    # Let the user override the test.\n  else\n    AC_CHECK_TOOLS(DUMPBIN, [dumpbin \"link -dump\"], :)\n    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in\n    *COFF*)\n      DUMPBIN=\"$DUMPBIN -symbols\"\n      ;;\n    *)\n      DUMPBIN=:\n      ;;\n    esac\n  fi\n  AC_SUBST([DUMPBIN])\n  if test \"$DUMPBIN\" != \":\"; then\n    NM=\"$DUMPBIN\"\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:$LINENO: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n# --------------------------------\n# how to determine the name of the shared library\n# associated with a specific link library.\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_SHAREDLIB_FROM_LINKLIB],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nm4_require([_LT_DECL_DLLTOOL])\nAC_CACHE_CHECK([how to associate runtime and link libraries],\nlt_cv_sharedlib_from_linklib_cmd,\n[lt_cv_sharedlib_from_linklib_cmd='unknown'\n\ncase $host_os in\ncygwin* | mingw* | pw32* | cegcc*)\n  # two different shell functions defined in ltmain.sh\n  # decide which to use based on capabilities of $DLLTOOL\n  case `$DLLTOOL --help 2>&1` in\n  *--identify-strict*)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib\n    ;;\n  *)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback\n    ;;\n  esac\n  ;;\n*)\n  # fallback: assume linklib IS sharedlib\n  lt_cv_sharedlib_from_linklib_cmd=\"$ECHO\"\n  ;;\nesac\n])\nsharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd\ntest -z \"$sharedlib_from_linklib_cmd\" && sharedlib_from_linklib_cmd=$ECHO\n\n_LT_DECL([], [sharedlib_from_linklib_cmd], [1],\n    [Command to associate shared and link libraries])\n])# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n\n\n# _LT_PATH_MANIFEST_TOOL\n# ----------------------\n# locate the manifest tool\nm4_defun([_LT_PATH_MANIFEST_TOOL],\n[AC_CHECK_TOOL(MANIFEST_TOOL, mt, :)\ntest -z \"$MANIFEST_TOOL\" && MANIFEST_TOOL=mt\nAC_CACHE_CHECK([if $MANIFEST_TOOL is a manifest tool], [lt_cv_path_mainfest_tool],\n  [lt_cv_path_mainfest_tool=no\n  echo \"$as_me:$LINENO: $MANIFEST_TOOL '-?'\" >&AS_MESSAGE_LOG_FD\n  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  if $GREP 'Manifest Tool' conftest.out > /dev/null; then\n    lt_cv_path_mainfest_tool=yes\n  fi\n  rm -f conftest*])\nif test \"x$lt_cv_path_mainfest_tool\" != xyes; then\n  MANIFEST_TOOL=:\nfi\n_LT_DECL([], [MANIFEST_TOOL], [1], [Manifest tool])dnl\n])# _LT_PATH_MANIFEST_TOOL\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=\"-lm\")\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test \"$GCC\" = yes; then\n  case $cc_basename in\n  nvcc*)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;\n  esac\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\)[[ ]]*$/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p'\"\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n -e 's/^: \\([[^ ]]*\\)[[ ]]*$/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\(lib[[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"lib\\2\\\", (void *) \\&\\2},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function\n    # and D for any global variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=0}; \\$ 0~/\\(\\).*\\|/{f=1}; {printf f ? \\\"T \\\" : \\\"D \\\"};\"\\\n\"     {split(\\$ 0, a, /\\||\\r/); split(a[2], s)};\"\\\n\"     s[1]~/^[@?]/{print s[1], s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print t[1], substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n  lt_cv_sys_global_symbol_pipe=\"$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'\"\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| \"$lt_cv_sys_global_symbol_pipe\" \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)\n/* DATA imports from DLLs on WIN32 con't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT@&t@_DLSYM_CONST\n#elif defined(__osf__)\n/* This system does not cope well with relocations in const data.  */\n# define LT@&t@_DLSYM_CONST\n#else\n# define LT@&t@_DLSYM_CONST const\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nLT@&t@_DLSYM_CONST struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* \\(.*\\) \\(.*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_globsym_save_LIBS=$LIBS\n\t  lt_globsym_save_CFLAGS=$CFLAGS\n\t  LIBS=\"conftstm.$ac_objext\"\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=$lt_globsym_save_LIBS\n\t  CFLAGS=$lt_globsym_save_CFLAGS\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test \"$pipe_works\" = yes; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n# Response file support.\nif test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n  nm_file_list_spec='@'\nelif $NM --help 2>/dev/null | grep '[[@]]FILE' >/dev/null; then\n  nm_file_list_spec='@'\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n_LT_DECL([], [nm_file_list_spec], [1],\n    [Specify filename containing input files for $NM])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test \"$GXX\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test \"$host_cpu\" = ia64; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      mingw* | cygwin* | os2* | pw32* | cegcc*)\n\t# This hack is so that the source file can tell whether it is being\n\t# built for inclusion in a dll (and should export symbols for example).\n\tm4_if([$1], [GCJ], [],\n\t  [_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    if test \"$host_cpu\" != ia64; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64 which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)\n\t    # IBM XL 8.0, 9.0 on PPC and BlueGene\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd* | netbsdelf*-gnu)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test \"$GCC\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n\n    case $cc_basename in\n    nvcc*) # Cuda Compiler Driver 2.2\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '\n      if test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"-Xcompiler $_LT_TAGVAR(lt_prog_compiler_pic, $1)\"\n      fi\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n      case $cc_basename in\n      # old Intel for x86_64 which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      nagfor*)\n\t# NAG Fortran compiler\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl* | bgxl* | bgf* | mpixl*)\n\t# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ Ceres\\ Fortran* | *Sun*Fortran*\\ [[1-7]].* | *Sun*Fortran*\\ 8.[[0-3]]*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\t*Sun\\ F* | *Sun*Fortran*)\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t  ;;\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n        *Intel*\\ [[CF]]*Compiler*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t  ;;\n\t*Portland\\ Group*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec ;then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms which do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\n\nAC_CACHE_CHECK([for $compiler option to produce PIC],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to AIX nm, but means don't demangle with GNU nm\n    # Also, AIX nm treats weak defined symbols like other global defined\n    # symbols, whereas GNU nm marks them as \"W\".\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=\"$ltdll_cmds\"\n    ;;\n  cygwin* | mingw* | cegcc*)\n    case $cc_basename in\n    cl*)\n      _LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n      ;;\n    *)\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n      ;;\n    esac\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n    ;;\n  esac\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ` (' and `)$', so one must not match beginning or\n  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',\n  # as well as any symbol that contains `d'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test \"$GCC\" != yes; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd*)\n    with_gnu_ld=no\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n\n  # On some targets, GNU ld is compatible enough with the native linker\n  # that we're better off using the native interface for both.\n  lt_use_gnu_ld_interface=no\n  if test \"$with_gnu_ld\" = yes; then\n    case $host_os in\n      aix*)\n\t# The AIX port of GNU ld has always aspired to compatibility\n\t# with the native linker.  However, as the warning in the GNU ld\n\t# block says, versions before 2.19.5* couldn't really create working\n\t# shared libraries, regardless of the interface used.\n\tcase `$LD -v 2>&1` in\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.19.5*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.[[2-9]]*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ [[3-9]]*) ;;\n\t  *)\n\t    lt_use_gnu_ld_interface=yes\n\t    ;;\n\tesac\n\t;;\n      *)\n\tlt_use_gnu_ld_interface=yes\n\t;;\n    esac\n  fi\n\n  if test \"$lt_use_gnu_ld_interface\" = yes; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='${wl}'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v 2>&1` in\n      *GNU\\ gold*) supports_anon_versioning=yes ;;\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test \"$host_cpu\" != ia64; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.19, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to install binutils\n*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.\n*** You will then need to restart the configuration process.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file (1st line\n\t# is EXPORTS), use it as is; otherwise, prepend...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t  cp $export_symbols $output_objdir/$soname.def;\n\telse\n\t  echo EXPORTS > $output_objdir/$soname.def;\n\t  cat $export_symbols >> $output_objdir/$soname.def;\n\tfi~\n\t$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    haiku*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)\n      tmp_diet=no\n      if test \"$host_os\" = linux-dietlibc; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test \"$tmp_diet\" = no\n      then\n\ttmp_addflag=' $pic_flag'\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95* | pgfortran*)\n\t\t\t\t\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n\txl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tnvcc*)\t# Cuda Compiler Driver 2.2\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\n        if test \"x$supports_anon_versioning\" = xyes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t    cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t    echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t    $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\txlf* | bgf* | bgxlf* | mpixlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'\n\t  if test \"x$supports_anon_versioning\" = xyes; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t      cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t      echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test \"$GCC\" = yes && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test \"$host_cpu\" = ia64; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\"\"\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to AIX nm, but means don't demangle with GNU nm\n\t# Also, AIX nm treats weak defined symbols like other global\n\t# defined symbols, whereas GNU nm marks them as \"W\".\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# need to do runtime linking.\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n      if test \"$GCC\" = yes; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag=\"$shared_flag \"'${wl}-G'\n\tfi\n\t_LT_TAGVAR(link_all_deplibs, $1)=no\n      else\n\t# not using gcc\n\tif test \"$host_cpu\" = ia64; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag='${wl}-G'\n\t  else\n\t    shared_flag='${wl}-bM:SRE'\n\t  fi\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test \"$aix_use_runtimelinking\" = yes; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX([$1])\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n      else\n\tif test \"$host_cpu\" = ia64; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX([$1])\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t  if test \"$with_gnu_ld\" = yes; then\n\t    # We only use this code for GNU lds that support --whole-archive.\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t  else\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  fi\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  # This is similar to how AIX traditionally builds its shared libraries.\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      case $cc_basename in\n      cl*)\n\t# Native MSVC\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t_LT_TAGVAR(always_export_symbols, $1)=yes\n\t_LT_TAGVAR(file_list_spec, $1)='@'\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=\".dll\"\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t    sed -n -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' -e '1\\\\\\!p' < $export_symbols > $output_objdir/$soname.exp;\n\t  else\n\t    sed -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;\n\t  fi~\n\t  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n\t  linknames='\n\t# The linker will not automatically build a static lib if we build a DLL.\n\t# _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t_LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n\t_LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1,DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\t# Don't use ranlib\n\t_LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t_LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n\t  lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n\t  case $lt_outputfile in\n\t    *.exe|*.EXE) ;;\n\t    *)\n\t      lt_outputfile=\"$lt_outputfile.exe\"\n\t      lt_tool_outputfile=\"$lt_tool_outputfile.exe\"\n\t      ;;\n\t  esac~\n\t  if test \"$MANIFEST_TOOL\" != \":\" && test -f \"$lt_outputfile.manifest\"; then\n\t    $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n\t    $RM \"$lt_outputfile.manifest\";\n\t  fi'\n\t;;\n      *)\n\t# Assume MSVC wrapper\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=\".dll\"\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all \"$deplibs\" | $SED '\\''s/ -lc$//'\\''` -link -dll~linknames='\n\t# The linker will automatically build a .lib file if we build a DLL.\n\t_LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t# FIXME: Should let the user specify the lib program.\n\t_LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t;;\n      esac\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2.*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      ;;\n\n    hpux10*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\tm4_if($1, [], [\n\t  # Older versions of the 11.00 compiler do not understand -b yet\n\t  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)\n\t  _LT_LINKER_OPTION([if $CC understands -b],\n\t    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],\n\t  [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])\n\t  ;;\n\tesac\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n\t# This should be the same for all languages, so no per-tag cache variable.\n\tAC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],\n\t  [lt_cv_irix_exported_symbol],\n\t  [save_LDFLAGS=\"$LDFLAGS\"\n\t   LDFLAGS=\"$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null\"\n\t   AC_LINK_IFELSE(\n\t     [AC_LANG_SOURCE(\n\t        [AC_LANG_CASE([C], [[int foo (void) { return 0; }]],\n\t\t\t      [C++], [[int foo (void) { return 0; }]],\n\t\t\t      [Fortran 77], [[\n      subroutine foo\n      end]],\n\t\t\t      [Fortran], [[\n      subroutine foo\n      end]])])],\n\t      [lt_cv_irix_exported_symbol=yes],\n\t      [lt_cv_irix_exported_symbol=no])\n           LDFLAGS=\"$save_LDFLAGS\"])\n\tif test \"$lt_cv_irix_exported_symbol\" = yes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'\n\tfi\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\telse\n\t  case $host_os in\n\t   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)\n\t     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t     ;;\n\t   *)\n\t     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t     ;;\n\t  esac\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY $libname INITINSTANCE\" > $output_objdir/$libname.def~$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo \" SINGLE NONSHARED\" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'\n      ;;\n\n    osf3*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $pic_flag $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n\t$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test \"$GCC\" = yes; then\n\twlarc='${wl}'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='${wl}'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands `-z linker_flag'.  GCC discards it without `$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test \"$GCC\" = yes; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test \"x$host_vendor\" = xsequent; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We can NOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test x$host_vendor = xsni; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test \"$enable_shared\" = yes && test \"$GCC\" = yes; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_CACHE_CHECK([whether -lc should be explicitly linked in],\n\t[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),\n\t[$RM conftest*\n\techo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n\tif AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n\t  soname=conftest\n\t  lib=conftest\n\t  libobjs=conftest.$ac_objext\n\t  deplibs=\n\t  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\t  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n\t  compiler_flags=-v\n\t  linker_flags=-v\n\t  verstring=\n\t  output_objdir=.\n\t  libname=conftest\n\t  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\n\t  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n\t  then\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t  else\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  fi\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n\telse\n\t  cat conftest.err 1>&5\n\tfi\n\t$RM conftest*\n\t])\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting ${shlibpath_var} if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [postlink_cmds], [2],\n    [Commands necessary for finishing linking programs])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=\"$CC\"\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report which library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test \"$enable_shared\" = yes && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n      test \"$enable_shared\" = yes && enable_static=no\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test \"$enable_shared\" = yes || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test \"X$CXX\" != \"Xg++\"))) ; then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_caught_CXX_error\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_CFLAGS=$CFLAGS\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  CFLAGS=$CXXFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test \"$GXX\" = yes; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test \"$GXX\" = yes; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test \"$with_gnu_ld\" = yes; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='${wl}'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test \"$host_cpu\" = ia64; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\"\"\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # need to do runtime linking.\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n        if test \"$GXX\" = yes; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag=\"$shared_flag \"'${wl}-G'\n\t  fi\n        else\n          # not using gcc\n          if test \"$host_cpu\" = ia64; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test \"$aix_use_runtimelinking\" = yes; then\n\t      shared_flag='${wl}-G'\n\t    else\n\t      shared_flag='${wl}-bM:SRE'\n\t    fi\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n        if test \"$aix_use_runtimelinking\" = yes; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX([$1])\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n        else\n          if test \"$host_cpu\" = ia64; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX([$1])\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t    if test \"$with_gnu_ld\" = yes; then\n\t      # We only use this code for GNU lds that support --whole-archive.\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    else\n\t      # Exported symbols can be pulled into shared objects from archives\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    fi\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    # This is similar to how AIX traditionally builds its shared\n\t    # libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n\tcase $GXX,$cc_basename in\n\t,cl* | no,cl*)\n\t  # Native MSVC\n\t  # hardcode_libdir_flag_spec is actually meaningless, as there is\n\t  # no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=yes\n\t  _LT_TAGVAR(file_list_spec, $1)='@'\n\t  # Tell ltmain to make .lib files, not .a files.\n\t  libext=lib\n\t  # Tell ltmain to make .dll files, not .so files.\n\t  shrext_cmds=\".dll\"\n\t  # FIXME: Setting linknames here is a bad hack.\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t      $SED -n -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' -e '1\\\\\\!p' < $export_symbols > $output_objdir/$soname.exp;\n\t    else\n\t      $SED -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;\n\t    fi~\n\t    $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n\t    linknames='\n\t  # The linker will not automatically build a static lib if we build a DLL.\n\t  # _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t  # Don't use ranlib\n\t  _LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t  _LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n\t    lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n\t    case $lt_outputfile in\n\t      *.exe|*.EXE) ;;\n\t      *)\n\t\tlt_outputfile=\"$lt_outputfile.exe\"\n\t\tlt_tool_outputfile=\"$lt_tool_outputfile.exe\"\n\t\t;;\n\t    esac~\n\t    func_to_tool_file \"$lt_outputfile\"~\n\t    if test \"$MANIFEST_TOOL\" != \":\" && test -f \"$lt_outputfile.manifest\"; then\n\t      $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n\t      $RM \"$lt_outputfile.manifest\";\n\t    fi'\n\t  ;;\n\t*)\n\t  # g++\n\t  # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n\t  # as there is no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=no\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n\t  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t    # If the export-symbols file already is a .def file (1st line\n\t    # is EXPORTS), use it as is; otherwise, prepend...\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t      cp $export_symbols $output_objdir/$soname.def;\n\t    else\n\t      echo EXPORTS > $output_objdir/$soname.def;\n\t      cat $export_symbols >> $output_objdir/$soname.def;\n\t    fi~\n\t    $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t  ;;\n\tesac\n\t;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd2.*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      haiku*)\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n            ;;\n          *)\n            if test \"$GXX\" = yes; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test $with_gnu_ld = no; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test $with_gnu_ld = no; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test \"$with_gnu_ld\" = no; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib ${wl}-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]].* | *pgcpp\\ [[1-5]].*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n\t\tcompile_command=\"$compile_command `find $tpldir -name \\*.o | sort | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n\t\t$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | sort | $NL2SP`~\n\t\t$RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 and above use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"X$list\" | $Xsed'\n\t    ;;\n\t  xl* | mpixl* | bgxl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    if test \"x$supports_anon_versioning\" = xyes; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t\tcat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t\techo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t\t$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='func_echo_all'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd2*)\n        # C++ shared libraries are fairly broken\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      openbsd*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=func_echo_all\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n\t          echo \"-hidden\">> $lib.exp~\n\t          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~\n\t          $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n\t  *)\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands `-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='func_echo_all'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -shared $pic_flag -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require `-G' NOT `-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We can NOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~\n\t      '\"$_LT_TAGVAR(old_archive_cmds, $1)\"\n\t    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~\n\t      '\"$_LT_TAGVAR(reload_cmds, $1)\"\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=\"$GXX\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test \"$_lt_caught_CXX_error\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_FUNC_STRIPNAME_CNF\n# ----------------------\n# func_stripname_cnf prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n#\n# This function is identical to the (non-XSI) version of func_stripname,\n# except this one can be used by m4 code that may be executed by configure,\n# rather than the libtool script.\nm4_defun([_LT_FUNC_STRIPNAME_CNF],[dnl\nAC_REQUIRE([_LT_DECL_SED])\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])\nfunc_stripname_cnf ()\n{\n  case ${2} in\n  .*) func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%\\\\\\\\${2}\\$%%\"`;;\n  *)  func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%${2}\\$%%\"`;;\n  esac\n} # func_stripname_cnf\n])# _LT_FUNC_STRIPNAME_CNF\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nAC_REQUIRE([_LT_FUNC_STRIPNAME_CNF])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF\npackage foo\nfunc foo() {\n}\n_LT_EOF\n])\n\n_lt_libdeps_save_CFLAGS=$CFLAGS\ncase \"$CC $CFLAGS \" in #(\n*\\ -flto*\\ *) CFLAGS=\"$CFLAGS -fno-lto\" ;;\n*\\ -fwhopr*\\ *) CFLAGS=\"$CFLAGS -fno-whopr\" ;;\n*\\ -fuse-linker-plugin*\\ *) CFLAGS=\"$CFLAGS -fno-use-linker-plugin\" ;;\nesac\n\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case ${prev}${p} in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test $p = \"-L\" ||\n          test $p = \"-R\"; then\n\t prev=$p\n\t continue\n       fi\n\n       # Expand the sysroot to ease extracting the directories later.\n       if test -z \"$prev\"; then\n         case $p in\n         -L*) func_stripname_cnf '-L' '' \"$p\"; prev=-L; p=$func_stripname_result ;;\n         -R*) func_stripname_cnf '-R' '' \"$p\"; prev=-R; p=$func_stripname_result ;;\n         -l*) func_stripname_cnf '-l' '' \"$p\"; prev=-l; p=$func_stripname_result ;;\n         esac\n       fi\n       case $p in\n       =*) func_stripname_cnf '=' '' \"$p\"; p=$lt_sysroot$func_stripname_result ;;\n       esac\n       if test \"$pre_test_object_deps_done\" = no; then\n\t case ${prev} in\n\t -L | -R)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${prev}${p}\"\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=\"${prev}${p}\"\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} ${prev}${p}\"\n\t fi\n       fi\n       prev=\n       ;;\n\n    *.lto.$objext) ;; # Ignore GCC LTO objects\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\nCFLAGS=$_lt_libdeps_save_CFLAGS\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\n\nlinux*)\n  case `$CC -V 2>&1 | sed 5q` in\n  *Sun\\ C*)\n    # Sun C++ 5.9\n\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\n\nsolaris*)\n  case $cc_basename in\n  CC* | sunCC*)\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    # Adding this requires a known-good setup of shared libraries for\n    # Sun compiler versions before 5.6, else PIC objects from an old\n    # archive will be linked into the output, leading to subtle bugs.\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | ${SED} -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_LANG_PUSH(Fortran 77)\nif test -z \"$F77\" || test \"X$F77\" = \"Xno\"; then\n  _lt_disable_F77=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_F77\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${F77-\"f77\"}\n  CFLAGS=$FFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$G77\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\n  CFLAGS=\"$lt_save_CFLAGS\"\nfi # test \"$_lt_disable_F77\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_LANG_PUSH(Fortran)\n\nif test -z \"$FC\" || test \"X$FC\" = \"Xno\"; then\n  _lt_disable_FC=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_FC\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${FC-\"f95\"}\n  CFLAGS=$FCFLAGS\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$ac_cv_fc_compiler_gnu\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\nfi # test \"$_lt_disable_FC\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\nCFLAGS=$GCJFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_GO_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Go compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GO_CONFIG],\n[AC_REQUIRE([LT_PROG_GO])dnl\nAC_LANG_SAVE\n\n# Source file extension for Go test sources.\nac_ext=go\n\n# Object file extension for compiled Go test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"package main; func main() { }\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='package main; func main() { }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GOC-\"gccgo\"}\nCFLAGS=$GOFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# Go did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GO_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"$lt_simple_compile_test_code\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\nCFLAGS=\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test \"x${GCJFLAGS+set}\" = xset || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_GO\n# ----------\nAC_DEFUN([LT_PROG_GO],\n[AC_CHECK_TOOL(GOC, gccgo,)\n])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n# _LT_DECL_DLLTOOL\n# ----------------\n# Ensure DLLTOOL variable is set.\nm4_defun([_LT_DECL_DLLTOOL],\n[AC_CHECK_TOOL(DLLTOOL, dlltool, false)\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])\nAC_SUBST([DLLTOOL])\n])\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f $lt_ac_sed && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test $lt_ac_count -gt 10 && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test $lt_ac_count -gt $lt_ac_max; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[AC_MSG_CHECKING([whether the shell understands some XSI constructs])\n# Try some XSI features\nxsi_shell=no\n( _lt_dummy=\"a/b/c\"\n  test \"${_lt_dummy##*/},${_lt_dummy%/*},${_lt_dummy#??}\"${_lt_dummy%\"$_lt_dummy\"}, \\\n      = c,a/b,b/c, \\\n    && eval 'test $(( 1 + 1 )) -eq 2 \\\n    && test \"${#_lt_dummy}\" -eq 5' ) >/dev/null 2>&1 \\\n  && xsi_shell=yes\nAC_MSG_RESULT([$xsi_shell])\n_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])\n\nAC_MSG_CHECKING([whether the shell understands \"+=\"])\nlt_shell_append=no\n( foo=bar; set foo baz; eval \"$[1]+=\\$[2]\" && test \"$foo\" = barbaz ) \\\n    >/dev/null 2>&1 \\\n  && lt_shell_append=yes\nAC_MSG_RESULT([$lt_shell_append])\n_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])\n\nif ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PROG_FUNCTION_REPLACE (FUNCNAME, REPLACEMENT-BODY)\n# ------------------------------------------------------\n# In `$cfgfile', look for function FUNCNAME delimited by `^FUNCNAME ()$' and\n# '^} FUNCNAME ', and replace its body with REPLACEMENT-BODY.\nm4_defun([_LT_PROG_FUNCTION_REPLACE],\n[dnl {\nsed -e '/^$1 ()$/,/^} # $1 /c\\\n$1 ()\\\n{\\\nm4_bpatsubsts([$2], [$], [\\\\], [^\\([\t ]\\)], [\\\\\\1])\n} # Extended-shell $1 implementation' \"$cfgfile\" > $cfgfile.tmp \\\n  && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\ntest 0 -eq $? || _lt_function_replace_fail=:\n])\n\n\n# _LT_PROG_REPLACE_SHELLFNS\n# -------------------------\n# Replace existing portable implementations of several shell functions with\n# equivalent extended shell implementations where those features are available..\nm4_defun([_LT_PROG_REPLACE_SHELLFNS],\n[if test x\"$xsi_shell\" = xyes; then\n  _LT_PROG_FUNCTION_REPLACE([func_dirname], [dnl\n    case ${1} in\n      */*) func_dirname_result=\"${1%/*}${2}\" ;;\n      *  ) func_dirname_result=\"${3}\" ;;\n    esac])\n\n  _LT_PROG_FUNCTION_REPLACE([func_basename], [dnl\n    func_basename_result=\"${1##*/}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_dirname_and_basename], [dnl\n    case ${1} in\n      */*) func_dirname_result=\"${1%/*}${2}\" ;;\n      *  ) func_dirname_result=\"${3}\" ;;\n    esac\n    func_basename_result=\"${1##*/}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_stripname], [dnl\n    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n    # positional parameters, so assign one to ordinary parameter first.\n    func_stripname_result=${3}\n    func_stripname_result=${func_stripname_result#\"${1}\"}\n    func_stripname_result=${func_stripname_result%\"${2}\"}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_split_long_opt], [dnl\n    func_split_long_opt_name=${1%%=*}\n    func_split_long_opt_arg=${1#*=}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_split_short_opt], [dnl\n    func_split_short_opt_arg=${1#??}\n    func_split_short_opt_name=${1%\"$func_split_short_opt_arg\"}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_lo2o], [dnl\n    case ${1} in\n      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\n      *)    func_lo2o_result=${1} ;;\n    esac])\n\n  _LT_PROG_FUNCTION_REPLACE([func_xform], [    func_xform_result=${1%.*}.lo])\n\n  _LT_PROG_FUNCTION_REPLACE([func_arith], [    func_arith_result=$(( $[*] ))])\n\n  _LT_PROG_FUNCTION_REPLACE([func_len], [    func_len_result=${#1}])\nfi\n\nif test x\"$lt_shell_append\" = xyes; then\n  _LT_PROG_FUNCTION_REPLACE([func_append], [    eval \"${1}+=\\\\${2}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_append_quoted], [dnl\n    func_quote_for_eval \"${2}\"\ndnl m4 expansion turns \\\\\\\\ into \\\\, and then the shell eval turns that into \\\n    eval \"${1}+=\\\\\\\\ \\\\$func_quote_for_eval_result\"])\n\n  # Save a `func_append' function call where possible by direct use of '+='\n  sed -e 's%func_append \\([[a-zA-Z_]]\\{1,\\}\\) \"%\\1+=\"%g' $cfgfile > $cfgfile.tmp \\\n    && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n      || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\n  test 0 -eq $? || _lt_function_replace_fail=:\nelse\n  # Save a `func_append' function call even when '+=' is not available\n  sed -e 's%func_append \\([[a-zA-Z_]]\\{1,\\}\\) \"%\\1=\"$\\1%g' $cfgfile > $cfgfile.tmp \\\n    && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n      || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\n  test 0 -eq $? || _lt_function_replace_fail=:\nfi\n\nif test x\"$_lt_function_replace_fail\" = x\":\"; then\n  AC_MSG_WARN([Unable to substitute extended shell functions in $ofile])\nfi\n])\n\n# _LT_PATH_CONVERSION_FUNCTIONS\n# -----------------------------\n# Determine which file name conversion functions should be used by\n# func_to_host_file (and, implicitly, by func_to_host_path).  These are needed\n# for certain cross-compile configurations and native mingw.\nm4_defun([_LT_PATH_CONVERSION_FUNCTIONS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_MSG_CHECKING([how to convert $build file names to $host format])\nAC_CACHE_VAL(lt_cv_to_host_file_cmd,\n[case $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32\n        ;;\n    esac\n    ;;\n  *-*-cygwin* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_noop\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin\n        ;;\n    esac\n    ;;\n  * ) # unhandled hosts (and \"normal\" native builds)\n    lt_cv_to_host_file_cmd=func_convert_file_noop\n    ;;\nesac\n])\nto_host_file_cmd=$lt_cv_to_host_file_cmd\nAC_MSG_RESULT([$lt_cv_to_host_file_cmd])\n_LT_DECL([to_host_file_cmd], [lt_cv_to_host_file_cmd],\n         [0], [convert $build file names to $host format])dnl\n\nAC_MSG_CHECKING([how to convert $build file names to toolchain format])\nAC_CACHE_VAL(lt_cv_to_tool_file_cmd,\n[#assume ordinary cross tools, or native build.\nlt_cv_to_tool_file_cmd=func_convert_file_noop\ncase $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32\n        ;;\n    esac\n    ;;\nesac\n])\nto_tool_file_cmd=$lt_cv_to_tool_file_cmd\nAC_MSG_RESULT([$lt_cv_to_tool_file_cmd])\n_LT_DECL([to_tool_file_cmd], [lt_cv_to_tool_file_cmd],\n         [0], [convert $build files to toolchain format])dnl\n])# _LT_PATH_CONVERSION_FUNCTIONS\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/m4/libtool.m4": "# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n#                 Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n#                 Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n#   This file is part of GNU Libtool.\n#\n# GNU Libtool is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 2 of\n# the License, or (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html, or\n# obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n])\n\n# serial 57 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT\nAC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\n_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=\"$ltmain\"\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nm4_defun([_LT_CC_BASENAME],\n[for cc_temp in $1\"\"; do\n  case $cc_temp in\n    compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n    distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n    \\-*) ;;\n    *) break;;\n  esac\ndone\ncc_basename=`$ECHO \"$cc_temp\" | $SED \"s%.*/%%; s%^$host_alias-%%\"`\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\n\n_LT_DECL([], [PATH_SEPARATOR], [1], [The PATH separator for the build system])dnl\ndnl\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_PATH_CONVERSION_FUNCTIONS])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CHECK_SHAREDLIB_FROM_LINKLIB])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_WITH_SYSROOT])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options which allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test \"X${COLLECT_NAMES+set}\" != Xset; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a `.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=\"$lt_cv_prog_gnu_ld\"\n\nold_CC=\"$CC\"\nold_CFLAGS=\"$CFLAGS\"\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PREPARE_SED_QUOTE_VARS\n# --------------------------\n# Define a few sed substitution that help us do robust quoting.\nm4_defun([_LT_PREPARE_SED_QUOTE_VARS],\n[# Backslashify metacharacters that are still active within\n# double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n])\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from `configure', and `config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# `config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=\"$ac_aux_dir/ltmain.sh\"\n])# _LT_PROG_LTMAIN\n\n\n## ------------------------------------- ##\n## Accumulate code for creating libtool. ##\n## ------------------------------------- ##\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the `libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n## ------------------------ ##\n## FIXME: Eliminate VARNAME ##\n## ------------------------ ##\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to `config.status' so that its\n# declaration there will have the same value as in `configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"$][$1\" | $SED \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"$<var>\" | $SED \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags=\"_LT_TAGS\"dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into `config.status', and then the shell code to quote escape them in\n# for loops in `config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$[]1\n_LTECHO_EOF'\n}\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])\n# ------------------------------------\n# Generate a child script FILE with all initialization necessary to\n# reuse the environment learned by the parent script, and make the\n# file executable.  If COMMENT is supplied, it is inserted after the\n# `#!' sequence but before initialization text begins.  After this\n# macro, additional text can be appended to FILE to form the body of\n# the child script.  The macro ends with non-zero status if the\n# file could not be fully written (such as if the disk is full).\nm4_ifdef([AS_INIT_GENERATED],\n[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],\n[m4_defun([_LT_GENERATED_FILE_INIT],\n[m4_require([AS_PREPARE])]dnl\n[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl\n[lt_write_fail=0\ncat >$1 <<_ASEOF || lt_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n$2\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$1 <<\\_ASEOF || lt_write_fail=1\nAS_SHELL_SANITIZE\n_AS_PREPARE\nexec AS_MESSAGE_FD>&1\n_ASEOF\ntest $lt_write_fail = 0 && chmod +x $1[]dnl\nm4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\n_LT_GENERATED_FILE_INIT([\"$CONFIG_LT\"],\n[# Run this file to recreate a libtool stub with the current configuration.])\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nlt_cl_silent=false\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n\\`$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test $[#] != 0\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nlt_cl_success=:\ntest \"$silent\" = yes &&\n  lt_config_lt_args=\"$lt_config_lt_args --quiet\"\nexec AS_MESSAGE_LOG_FD>/dev/null\n$SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\nexec AS_MESSAGE_LOG_FD>>config.log\n$lt_cl_success || AS_EXIT(1)\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options which allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\" ; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=\"${ofile}T\"\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n\n# `$ECHO \"$ofile\" | sed 's%^.*/%%'` - Provide generalized library-building support services.\n# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n#\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test \"X${COLLECT_NAMES+set}\" != Xset; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '$q' \"$ltmain\" >> \"$cfgfile\" \\\n     || (rm -f \"$cfgfile\"; exit 1)\n\n  _LT_PROG_REPLACE_SHELLFNS\n\n   mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    TIMESTAMP='$TIMESTAMP'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Go],\t\t\t[_LT_LANG(GO)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\nm4_ifndef([AC_PROG_GO], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_GO.  When it is available in    #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\nm4_defun([AC_PROG_GO],\n[AC_LANG_PUSH(Go)dnl\nAC_ARG_VAR([GOC],     [Go compiler command])dnl\nAC_ARG_VAR([GOFLAGS], [Go compiler flags])dnl\n_AC_ARG_VAR_LDFLAGS()dnl\nAC_CHECK_TOOL(GOC, gccgo)\nif test -z \"$GOC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    AC_CHECK_PROG(GOC, [${ac_tool_prefix}gccgo], [${ac_tool_prefix}gccgo])\n  fi\nfi\nif test -z \"$GOC\"; then\n  AC_CHECK_PROG(GOC, gccgo, gccgo, false)\nfi\n])#m4_defun\n])#m4_ifndef\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([AC_PROG_GO],\n  [LT_LANG(GO)],\n  [m4_define([AC_PROG_GO], defn([AC_PROG_GO])[LT_LANG(GO)])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\nAU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\ndnl AC_DEFUN([AC_LIBTOOL_RC], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"${LT_MULTI_MODULE}\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\t# If there is a non-empty error log, and \"single_module\"\n\t# appears in it, assume the flag caused a linker warning\n        if test -s conftest.err && $GREP single_module conftest.err; then\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\t# Otherwise, if the output was created with a 0 exit code from\n\t# the compiler, it worked.\n\telif test -f libconftest.dylib && test $_lt_result -eq 0; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=\"$save_LDFLAGS\"\n    ])\n\n    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],\n      [lt_cv_ld_force_load=no\n      cat > conftest.c << _LT_EOF\nint forced_loaded() { return 2;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS -c -o conftest.o conftest.c\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD\n      echo \"$AR cru libconftest.a conftest.o\" >&AS_MESSAGE_LOG_FD\n      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD\n      echo \"$RANLIB libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $RANLIB libconftest.a 2>&AS_MESSAGE_LOG_FD\n      cat > conftest.c << _LT_EOF\nint main() { return 0;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err\n      _lt_result=$?\n      if test -s conftest.err && $GREP force_load conftest.err; then\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      elif test -f conftest && test $_lt_result -eq 0 && $GREP forced_load conftest >/dev/null 2>&1 ; then\n\tlt_cv_ld_force_load=yes\n      else\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      fi\n        rm -f conftest.err libconftest.a conftest conftest.c\n        rm -rf conftest.dSYM\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]]*)\n\t  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test \"$lt_cv_apple_cc_single_mod\" = \"yes\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test \"$lt_cv_ld_exported_symbols_list\" = \"yes\"; then\n      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'\n    fi\n    if test \"$DSYMUTIL\" != \":\" && test \"$lt_cv_ld_force_load\" = \"no\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES([TAG])\n# ---------------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  if test \"$lt_cv_ld_force_load\" = \"yes\"; then\n    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience ${wl}-force_load,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"`'\n    m4_case([$1], [F77], [_LT_TAGVAR(compiler_needs_object, $1)=yes],\n                  [FC],  [_LT_TAGVAR(compiler_needs_object, $1)=yes])\n  else\n    _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  fi\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=\"$_lt_dar_allow_undefined\"\n  case $cc_basename in\n     ifort*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test \"$_lt_dar_can_shared\" = \"yes\"; then\n    output_verbose_link_cmd=func_echo_all\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod${_lt_dsymutil}\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dsymutil}\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}\"\n    m4_if([$1], [CXX],\n[   if test \"$lt_cv_apple_cc_single_mod\" != \"yes\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dsymutil}\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dar_export_syms}${_lt_dsymutil}\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX([TAGNAME])\n# ----------------------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\n# Store the results from the different compilers for each TAGNAME.\n# Allow to override them for all tags through lt_cv_aix_libpath.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nif test \"${lt_cv_aix_libpath+set}\" = set; then\n  aix_libpath=$lt_cv_aix_libpath\nelse\n  AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM],[\n  lt_aix_libpath_sed='[\n      /Import File Strings/,/^$/ {\n\t  /^0/ {\n\t      s/^0  *\\([^ ]*\\) *$/\\1/\n\t      p\n\t  }\n      }]'\n  _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  # Check for a 64-bit object if we didn't find anything.\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  fi],[])\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=\"/usr/lib:/lib\"\n  fi\n  ])\n  aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\nfi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[m4_divert_text([M4SH-INIT], [$1\n])])# _LT_SHELL_INIT\n\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Find how we can fake an echo command that does not interpret backslash.\n# In particular, with Autoconf 2.60 or later we add some code to the start\n# of the generated configure script which will find a shell with a builtin\n# printf (which we can use as an echo command).\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n\nAC_MSG_CHECKING([how to print strings])\n# Test print first, because it will be a builtin if present.\nif test \"X`( print -r -- -n ) 2>/dev/null`\" = X-n && \\\n   test \"X`print -r -- $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='print -r --'\nelif test \"X`printf %s $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='printf %s\\n'\nelse\n  # Use this function as a fallback that always works.\n  func_fallback_echo ()\n  {\n    eval 'cat <<_LTECHO_EOF\n$[]1\n_LTECHO_EOF'\n  }\n  ECHO='func_fallback_echo'\nfi\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\" \n}\n\ncase \"$ECHO\" in\n  printf*) AC_MSG_RESULT([printf]) ;;\n  print*) AC_MSG_RESULT([print -r]) ;;\n  *) AC_MSG_RESULT([cat]) ;;\nesac\n\nm4_ifdef([_AS_DETECT_SUGGESTED],\n[_AS_DETECT_SUGGESTED([\n  test -n \"${ZSH_VERSION+set}${BASH_VERSION+set}\" || (\n    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n    PATH=/empty FPATH=/empty; export PATH FPATH\n    test \"X`printf %s $ECHO`\" = \"X$ECHO\" \\\n      || test \"X`print -r -- $ECHO`\" = \"X$ECHO\" )])])\n\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_WITH_SYSROOT\n# ----------------\nAC_DEFUN([_LT_WITH_SYSROOT],\n[AC_MSG_CHECKING([for sysroot])\nAC_ARG_WITH([sysroot],\n[  --with-sysroot[=DIR] Search for dependent libraries within DIR\n                        (or the compiler's sysroot if not specified).],\n[], [with_sysroot=no])\n\ndnl lt_sysroot will always be passed unquoted.  We quote it here\ndnl in case the user passed a directory name.\nlt_sysroot=\ncase ${with_sysroot} in #(\n yes)\n   if test \"$GCC\" = yes; then\n     lt_sysroot=`$CC --print-sysroot 2>/dev/null`\n   fi\n   ;; #(\n /*)\n   lt_sysroot=`echo \"$with_sysroot\" | sed -e \"$sed_quote_subst\"`\n   ;; #(\n no|'')\n   ;; #(\n *)\n   AC_MSG_RESULT([${with_sysroot}])\n   AC_MSG_ERROR([The sysroot must be an absolute path.])\n   ;;\nesac\n\n AC_MSG_RESULT([${lt_sysroot:-no}])\n_LT_DECL([], [lt_sysroot], [0], [The root where to search for ]dnl\n[dependent libraries, and in which our libraries should be installed.])])\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=\"32\"\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=\"64\"\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out which ABI we are using.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    case `/usr/bin/file conftest.o` in\n\t      *x86-64*)\n\t\tLD=\"${LD-ld} -m elf32_x86_64\"\n\t\t;;\n\t      *)\n\t\tLD=\"${LD-ld} -m elf_i386\"\n\t\t;;\n\t    esac\n\t    ;;\n\t  powerpc64le-*)\n\t    LD=\"${LD-ld} -m elf32lppclinux\"\n\t    ;;\n\t  powerpc64-*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  powerpcle-*)\n\t    LD=\"${LD-ld} -m elf64lppc\"\n\t    ;;\n\t  powerpc-*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\n  ;;\n*-*solaris*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*)\n        case $host in\n        i?86-*-solaris*)\n          LD=\"${LD-ld} -m elf_x86_64\"\n          ;;\n        sparc*-*-solaris*)\n          LD=\"${LD-ld} -m elf64_sparc\"\n          ;;\n        esac\n        # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.\n        if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then\n          LD=\"${LD-ld}_sol2\"\n        fi\n        ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=\"$enable_libtool_lock\"\n])# _LT_ENABLE_LOCK\n\n\n# _LT_PROG_AR\n# -----------\nm4_defun([_LT_PROG_AR],\n[AC_CHECK_TOOLS(AR, [ar], false)\n: ${AR=ar}\n: ${AR_FLAGS=cru}\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1], [Flags to create an archive])\n\nAC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],\n  [lt_cv_ar_at_file=no\n   AC_COMPILE_IFELSE([AC_LANG_PROGRAM],\n     [echo conftest.$ac_objext > conftest.lst\n      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&AS_MESSAGE_LOG_FD'\n      AC_TRY_EVAL([lt_ar_try])\n      if test \"$ac_status\" -eq 0; then\n\t# Ensure the archiver fails upon bogus file names.\n\trm -f conftest.$ac_objext libconftest.a\n\tAC_TRY_EVAL([lt_ar_try])\n\tif test \"$ac_status\" -ne 0; then\n          lt_cv_ar_at_file=@\n        fi\n      fi\n      rm -f conftest.* libconftest.a\n     ])\n  ])\n\nif test \"x$lt_cv_ar_at_file\" = xno; then\n  archiver_list_spec=\nelse\n  archiver_list_spec=$lt_cv_ar_at_file\nfi\n_LT_DECL([], [archiver_list_spec], [1],\n  [How to feed a file listing to the archiver])\n])# _LT_PROG_AR\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[_LT_PROG_AR\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$tool_oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$tool_oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$tool_oldlib\"\nfi\n\ncase $host_os in\n  darwin*)\n    lock_old_archive_extraction=yes ;;\n  *)\n    lock_old_archive_extraction=no ;;\nesac\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n_LT_DECL([], [lock_old_archive_extraction], [0],\n    [Whether to use a lock for old archive extraction])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"$_lt_linker_boilerplate\" | $SED '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=\"$save_LDFLAGS\"\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=\"ABCD\"\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  mint*)\n    # On MiNT this can take a long time and run out of memory.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  os2*)\n    # The test takes a long time on OS/2.\n    lt_cv_sys_max_cmd_len=8192\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\" && \\\n\ttest undefined != \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8 ; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test \"X\"`env echo \"$teststring$teststring\" 2>/dev/null` \\\n\t         = \"X$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test $i != 17 # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n $lt_cv_sys_max_cmd_len ; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"$cross_compiling\" = yes; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line $LINENO \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n/* When -fvisbility=hidden is used, assume the code has been annotated\n   correspondingly for the symbols needed.  */\n#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))\nint fnord () __attribute__((visibility(\"default\")));\n#endif\n\nint fnord () { return 42; }\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else\n        {\n\t  if (dlsym( self,\"_fnord\"))  status = $lt_dlneed_uscore;\n          else puts (dlerror ());\n\t}\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"x$enable_dlopen\" != xyes; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-ldld\"],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=\"dlopen\"],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-ldld\"])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test \"x$lt_cv_dlopen\" != xno; then\n    enable_dlopen=yes\n  else\n    enable_dlopen=no\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    test \"x$ac_cv_header_dlfcn_h\" = xyes && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=\"$LDFLAGS\"\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test \"x$lt_cv_dlopen_self\" = xyes; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=\"nottested\"\nif test \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" = no && test \"$need_locks\" != no; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test \"$hard_links\" = no; then\n    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED(LT_OBJDIR, \"$lt_cv_objdir/\",\n  [Define to the sub-directory in which libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test \"X$_LT_TAGVAR(hardcode_automatic, $1)\" = \"Xyes\" ; then\n\n  # We can hardcode non-existent directories.\n  if test \"$_LT_TAGVAR(hardcode_direct, $1)\" != no &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" != no &&\n     test \"$_LT_TAGVAR(hardcode_minus_L, $1)\" != no; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test \"$_LT_TAGVAR(hardcode_action, $1)\" = relink ||\n   test \"$_LT_TAGVAR(inherit_rpath, $1)\" = yes; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test \"$shlibpath_overrides_runpath\" = yes ||\n     test \"$enable_shared\" = no; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\" ; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test \"$GCC\" = yes; then\n  case $host_os in\n    darwin*) lt_awk_arg=\"/^libraries:/,/LR/\" ;;\n    *) lt_awk_arg=\"/^libraries:/\" ;;\n  esac\n  case $host_os in\n    mingw* | cegcc*) lt_sed_strip_eq=\"s,=\\([[A-Za-z]]:\\),\\1,g\" ;;\n    *) lt_sed_strip_eq=\"s,=/,/,g\" ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e $lt_sed_strip_eq`\n  case $lt_search_path_spec in\n  *\\;*)\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED 's/;/ /g'`\n    ;;\n  *)\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED \"s/$PATH_SEPARATOR/ /g\"`\n    ;;\n  esac\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary.\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path/$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir\"\n    else\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO \"$lt_tmp_lt_search_path_spec\" | awk '\nBEGIN {RS=\" \"; FS=\"/|\\n\";} {\n  lt_foo=\"\";\n  lt_count=0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo=\"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  # AWK program above erroneously prepends '/' to C:/dos/paths\n  # for these hosts.\n  case $host_os in\n    mingw* | cegcc*) lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" |\\\n      $SED 's,/\\([[A-Za-z]]:\\),\\1,g'` ;;\n  esac\n  sys_lib_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $lt_NL2SP`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=\".so\"\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\ncase $host_os in\naix3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='${libname}${release}${shared_ext}$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test \"$host_cpu\" = ia64; then\n    # AIX 5 supports IA64\n    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line `#! .'.  This would cause the generated library to\n    # depend on `.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    else\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='${libname}${release}.a $libname.a'\n      soname_spec='${libname}${release}${shared_ext}$major'\n    fi\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all \"$lib\" | $SED '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='${libname}${shared_ext}'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=\".dll\"\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$cc_basename in\n  yes,*)\n    # gcc\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\nm4_if([$1], [],[\n      sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/lib/w32api\"])\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    esac\n    dynamic_linker='Win32 ld.exe'\n    ;;\n\n  *,cl*)\n    # Native MSVC\n    libname_spec='$name'\n    soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n    library_names_spec='${libname}.dll.lib'\n\n    case $build_os in\n    mingw*)\n      sys_lib_search_path_spec=\n      lt_save_ifs=$IFS\n      IFS=';'\n      for lt_path in $LIB\n      do\n        IFS=$lt_save_ifs\n        # Let DOS variable expansion print the short 8.3 style file name.\n        lt_path=`cd \"$lt_path\" 2>/dev/null && cmd //C \"for %i in (\".\") do @echo %~si\"`\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec $lt_path\"\n      done\n      IFS=$lt_save_ifs\n      # Convert to MSYS style.\n      sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | sed -e 's|\\\\\\\\|/|g' -e 's| \\\\([[a-zA-Z]]\\\\):| /\\\\1|g' -e 's|^ ||'`\n      ;;\n    cygwin*)\n      # Convert to unix form, then to dos form, then back to unix form\n      # but this time dos style (no spaces!) so that the unix form looks\n      # like /cygdrive/c/PROGRA~1:/cygdr...\n      sys_lib_search_path_spec=`cygpath --path --unix \"$LIB\"`\n      sys_lib_search_path_spec=`cygpath --path --dos \"$sys_lib_search_path_spec\" 2>/dev/null`\n      sys_lib_search_path_spec=`cygpath --path --unix \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      ;;\n    *)\n      sys_lib_search_path_spec=\"$LIB\"\n      if $ECHO \"$sys_lib_search_path_spec\" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH.\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      # FIXME: find the short name or the path components, as spaces are\n      # common. (e.g. \"Program Files\" -> \"PROGRA~1\")\n      ;;\n    esac\n\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n    dynamic_linker='Win32 link.exe'\n    ;;\n\n  *)\n    # Assume MSVC wrapper\n    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'\n    dynamic_linker='Win32 ld.exe'\n    ;;\n  esac\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'\n  soname_spec='${libname}${release}${major}$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[23]].*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2.*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\nhaiku*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  dynamic_linker=\"$host_os runtime_loader\"\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    if test \"X$HPUX_IA64_MODE\" = X32; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n    fi\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...\n  postinstall_cmds='chmod 555 $lib'\n  # or fails outright, so override atomically:\n  install_override_mode=555\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test \"$lt_cv_prog_gnu_ld\" = yes; then\n\t\tversion_type=linux # correct to gnu/linux during the next big refactor\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n\n  # Some binutils ld are patched to set DT_RUNPATH\n  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],\n    [lt_cv_shlibpath_overrides_runpath=no\n    save_LDFLAGS=$LDFLAGS\n    save_libdir=$libdir\n    eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n\t LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n\t [lt_cv_shlibpath_overrides_runpath=yes])])\n    LDFLAGS=$save_LDFLAGS\n    libdir=$save_libdir\n    ])\n  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Append ld.so.conf contents to the search path\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/\"//g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsdelf*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='NetBSD ld.elf_so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=\"/usr/lib\"\n  need_lib_prefix=no\n  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.\n  case $host_os in\n    openbsd3.3 | openbsd3.3.*)\tneed_version=yes ;;\n    *)\t\t\t\tneed_version=no  ;;\n  esac\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    case $host_os in\n      openbsd2.[[89]] | openbsd2.[[89]].*)\n\tshlibpath_overrides_runpath=no\n\t;;\n      *)\n\tshlibpath_overrides_runpath=yes\n\t;;\n      esac\n  else\n    shlibpath_overrides_runpath=yes\n  fi\n  ;;\n\nos2*)\n  libname_spec='$name'\n  shrext_cmds=\".dll\"\n  need_lib_prefix=no\n  library_names_spec='$libname${shared_ext} $libname.a'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=LIBPATH\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=\"$sys_lib_search_path_spec\"\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test \"$with_gnu_ld\" = yes; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec ;then\n    version_type=linux # correct to gnu/linux during the next big refactor\n    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'\n    soname_spec='$libname${shared_ext}.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=freebsd-elf\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test \"$with_gnu_ld\" = yes; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest \"$dynamic_linker\" = no && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test \"$GCC\" = yes; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test \"${lt_cv_sys_lib_search_path_spec+set}\" = set; then\n  sys_lib_search_path_spec=\"$lt_cv_sys_lib_search_path_spec\"\nfi\nif test \"${lt_cv_sys_lib_dlsearch_path_spec+set}\" = set; then\n  sys_lib_dlsearch_path_spec=\"$lt_cv_sys_lib_dlsearch_path_spec\"\nfi\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [install_override_mode], [1],\n    [Permission mode override for installation of shared libraries])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],\n    [Run-time system search path for libraries])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program which can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=\"$MAGIC_CMD\" # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=\"$MAGIC_CMD\"\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f $ac_dir/$1; then\n      lt_cv_path_MAGIC_CMD=\"$ac_dir/$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n  MAGIC_CMD=\"$lt_save_MAGIC_CMD\"\n  ;;\nesac])\nMAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program which can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PROG_ECHO_BACKSLASH])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break\n\t;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break\n\t;;\n      esac\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\nelse\n  lt_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$lt_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    if test \"$GCC\" != yes; then\n      reload_cmds=false\n    fi\n    ;;\n  darwin*)\n    if test \"$GCC\" = yes; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_TAGDECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# `unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# which responds to the $file_magic_cmd with a given extended regex.\n# If you have `file' or equivalent on your system and you're not sure\n# whether `pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.\n  if ( test \"$lt_cv_nm_interface\" = \"BSD nm\" && file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    # Keep this pattern in sync with the one in func_win32_libid.\n    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc*)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\nhaiku*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\\.[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\\.[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd* | netbsdelf*-gnu)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\n\nfile_magic_glob=\nwant_nocaseglob=no\nif test \"$build\" = \"$host\"; then\n  case $host_os in\n  mingw* | pw32*)\n    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then\n      want_nocaseglob=yes\n    else\n      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e \"s/\\(..\\)/s\\/[[\\1]]\\/[[\\1]]\\/g;/g\"`\n    fi\n    ;;\n  esac\nfi\n\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [file_magic_glob], [1],\n    [How to find potential files when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [want_nocaseglob], [1],\n    [Find potential files using nocaseglob when deplibs_check_method = \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=\"$NM\"\nelse\n  lt_nm_to_check=\"${ac_tool_prefix}nm\"\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=\"$lt_save_ifs\"\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=\"$ac_dir/$lt_tmp_nm\"\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\" ; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the `sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\tcase `\"$tmp_nm\" -B /dev/null 2>&1 | sed '1q'` in\n\t*/dev/null* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test \"$lt_cv_path_NM\" != \"no\"; then\n  NM=\"$lt_cv_path_NM\"\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  if test -n \"$DUMPBIN\"; then :\n    # Let the user override the test.\n  else\n    AC_CHECK_TOOLS(DUMPBIN, [dumpbin \"link -dump\"], :)\n    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in\n    *COFF*)\n      DUMPBIN=\"$DUMPBIN -symbols\"\n      ;;\n    *)\n      DUMPBIN=:\n      ;;\n    esac\n  fi\n  AC_SUBST([DUMPBIN])\n  if test \"$DUMPBIN\" != \":\"; then\n    NM=\"$DUMPBIN\"\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:$LINENO: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n# --------------------------------\n# how to determine the name of the shared library\n# associated with a specific link library.\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_SHAREDLIB_FROM_LINKLIB],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nm4_require([_LT_DECL_DLLTOOL])\nAC_CACHE_CHECK([how to associate runtime and link libraries],\nlt_cv_sharedlib_from_linklib_cmd,\n[lt_cv_sharedlib_from_linklib_cmd='unknown'\n\ncase $host_os in\ncygwin* | mingw* | pw32* | cegcc*)\n  # two different shell functions defined in ltmain.sh\n  # decide which to use based on capabilities of $DLLTOOL\n  case `$DLLTOOL --help 2>&1` in\n  *--identify-strict*)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib\n    ;;\n  *)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback\n    ;;\n  esac\n  ;;\n*)\n  # fallback: assume linklib IS sharedlib\n  lt_cv_sharedlib_from_linklib_cmd=\"$ECHO\"\n  ;;\nesac\n])\nsharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd\ntest -z \"$sharedlib_from_linklib_cmd\" && sharedlib_from_linklib_cmd=$ECHO\n\n_LT_DECL([], [sharedlib_from_linklib_cmd], [1],\n    [Command to associate shared and link libraries])\n])# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n\n\n# _LT_PATH_MANIFEST_TOOL\n# ----------------------\n# locate the manifest tool\nm4_defun([_LT_PATH_MANIFEST_TOOL],\n[AC_CHECK_TOOL(MANIFEST_TOOL, mt, :)\ntest -z \"$MANIFEST_TOOL\" && MANIFEST_TOOL=mt\nAC_CACHE_CHECK([if $MANIFEST_TOOL is a manifest tool], [lt_cv_path_mainfest_tool],\n  [lt_cv_path_mainfest_tool=no\n  echo \"$as_me:$LINENO: $MANIFEST_TOOL '-?'\" >&AS_MESSAGE_LOG_FD\n  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  if $GREP 'Manifest Tool' conftest.out > /dev/null; then\n    lt_cv_path_mainfest_tool=yes\n  fi\n  rm -f conftest*])\nif test \"x$lt_cv_path_mainfest_tool\" != xyes; then\n  MANIFEST_TOOL=:\nfi\n_LT_DECL([], [MANIFEST_TOOL], [1], [Manifest tool])dnl\n])# _LT_PATH_MANIFEST_TOOL\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=\"-lm\")\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test \"$GCC\" = yes; then\n  case $cc_basename in\n  nvcc*)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;\n  esac\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\)[[ ]]*$/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p'\"\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n -e 's/^: \\([[^ ]]*\\)[[ ]]*$/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\(lib[[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"lib\\2\\\", (void *) \\&\\2},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function\n    # and D for any global variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=0}; \\$ 0~/\\(\\).*\\|/{f=1}; {printf f ? \\\"T \\\" : \\\"D \\\"};\"\\\n\"     {split(\\$ 0, a, /\\||\\r/); split(a[2], s)};\"\\\n\"     s[1]~/^[@?]/{print s[1], s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print t[1], substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n  lt_cv_sys_global_symbol_pipe=\"$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'\"\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| \"$lt_cv_sys_global_symbol_pipe\" \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)\n/* DATA imports from DLLs on WIN32 con't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT@&t@_DLSYM_CONST\n#elif defined(__osf__)\n/* This system does not cope well with relocations in const data.  */\n# define LT@&t@_DLSYM_CONST\n#else\n# define LT@&t@_DLSYM_CONST const\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nLT@&t@_DLSYM_CONST struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* \\(.*\\) \\(.*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_globsym_save_LIBS=$LIBS\n\t  lt_globsym_save_CFLAGS=$CFLAGS\n\t  LIBS=\"conftstm.$ac_objext\"\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=$lt_globsym_save_LIBS\n\t  CFLAGS=$lt_globsym_save_CFLAGS\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test \"$pipe_works\" = yes; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n# Response file support.\nif test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n  nm_file_list_spec='@'\nelif $NM --help 2>/dev/null | grep '[[@]]FILE' >/dev/null; then\n  nm_file_list_spec='@'\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n_LT_DECL([], [nm_file_list_spec], [1],\n    [Specify filename containing input files for $NM])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test \"$GXX\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test \"$host_cpu\" = ia64; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      mingw* | cygwin* | os2* | pw32* | cegcc*)\n\t# This hack is so that the source file can tell whether it is being\n\t# built for inclusion in a dll (and should export symbols for example).\n\tm4_if([$1], [GCJ], [],\n\t  [_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    if test \"$host_cpu\" != ia64; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64 which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)\n\t    # IBM XL 8.0, 9.0 on PPC and BlueGene\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd* | netbsdelf*-gnu)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test \"$GCC\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n\n    case $cc_basename in\n    nvcc*) # Cuda Compiler Driver 2.2\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '\n      if test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"-Xcompiler $_LT_TAGVAR(lt_prog_compiler_pic, $1)\"\n      fi\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n      case $cc_basename in\n      # old Intel for x86_64 which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      nagfor*)\n\t# NAG Fortran compiler\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl* | bgxl* | bgf* | mpixl*)\n\t# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ Ceres\\ Fortran* | *Sun*Fortran*\\ [[1-7]].* | *Sun*Fortran*\\ 8.[[0-3]]*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\t*Sun\\ F* | *Sun*Fortran*)\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t  ;;\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n        *Intel*\\ [[CF]]*Compiler*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t  ;;\n\t*Portland\\ Group*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec ;then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms which do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\n\nAC_CACHE_CHECK([for $compiler option to produce PIC],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to AIX nm, but means don't demangle with GNU nm\n    # Also, AIX nm treats weak defined symbols like other global defined\n    # symbols, whereas GNU nm marks them as \"W\".\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=\"$ltdll_cmds\"\n    ;;\n  cygwin* | mingw* | cegcc*)\n    case $cc_basename in\n    cl*)\n      _LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n      ;;\n    *)\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n      ;;\n    esac\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n    ;;\n  esac\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ` (' and `)$', so one must not match beginning or\n  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',\n  # as well as any symbol that contains `d'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test \"$GCC\" != yes; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd*)\n    with_gnu_ld=no\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n\n  # On some targets, GNU ld is compatible enough with the native linker\n  # that we're better off using the native interface for both.\n  lt_use_gnu_ld_interface=no\n  if test \"$with_gnu_ld\" = yes; then\n    case $host_os in\n      aix*)\n\t# The AIX port of GNU ld has always aspired to compatibility\n\t# with the native linker.  However, as the warning in the GNU ld\n\t# block says, versions before 2.19.5* couldn't really create working\n\t# shared libraries, regardless of the interface used.\n\tcase `$LD -v 2>&1` in\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.19.5*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.[[2-9]]*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ [[3-9]]*) ;;\n\t  *)\n\t    lt_use_gnu_ld_interface=yes\n\t    ;;\n\tesac\n\t;;\n      *)\n\tlt_use_gnu_ld_interface=yes\n\t;;\n    esac\n  fi\n\n  if test \"$lt_use_gnu_ld_interface\" = yes; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='${wl}'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v 2>&1` in\n      *GNU\\ gold*) supports_anon_versioning=yes ;;\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test \"$host_cpu\" != ia64; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.19, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to install binutils\n*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.\n*** You will then need to restart the configuration process.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file (1st line\n\t# is EXPORTS), use it as is; otherwise, prepend...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t  cp $export_symbols $output_objdir/$soname.def;\n\telse\n\t  echo EXPORTS > $output_objdir/$soname.def;\n\t  cat $export_symbols >> $output_objdir/$soname.def;\n\tfi~\n\t$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    haiku*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)\n      tmp_diet=no\n      if test \"$host_os\" = linux-dietlibc; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test \"$tmp_diet\" = no\n      then\n\ttmp_addflag=' $pic_flag'\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95* | pgfortran*)\n\t\t\t\t\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n\txl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tnvcc*)\t# Cuda Compiler Driver 2.2\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\n        if test \"x$supports_anon_versioning\" = xyes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t    cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t    echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t    $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\txlf* | bgf* | bgxlf* | mpixlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'\n\t  if test \"x$supports_anon_versioning\" = xyes; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t      cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t      echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test \"$GCC\" = yes && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test \"$host_cpu\" = ia64; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\"\"\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to AIX nm, but means don't demangle with GNU nm\n\t# Also, AIX nm treats weak defined symbols like other global\n\t# defined symbols, whereas GNU nm marks them as \"W\".\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# need to do runtime linking.\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n      if test \"$GCC\" = yes; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag=\"$shared_flag \"'${wl}-G'\n\tfi\n\t_LT_TAGVAR(link_all_deplibs, $1)=no\n      else\n\t# not using gcc\n\tif test \"$host_cpu\" = ia64; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag='${wl}-G'\n\t  else\n\t    shared_flag='${wl}-bM:SRE'\n\t  fi\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test \"$aix_use_runtimelinking\" = yes; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX([$1])\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n      else\n\tif test \"$host_cpu\" = ia64; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX([$1])\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t  if test \"$with_gnu_ld\" = yes; then\n\t    # We only use this code for GNU lds that support --whole-archive.\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t  else\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  fi\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  # This is similar to how AIX traditionally builds its shared libraries.\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      case $cc_basename in\n      cl*)\n\t# Native MSVC\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t_LT_TAGVAR(always_export_symbols, $1)=yes\n\t_LT_TAGVAR(file_list_spec, $1)='@'\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=\".dll\"\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t    sed -n -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' -e '1\\\\\\!p' < $export_symbols > $output_objdir/$soname.exp;\n\t  else\n\t    sed -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;\n\t  fi~\n\t  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n\t  linknames='\n\t# The linker will not automatically build a static lib if we build a DLL.\n\t# _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t_LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n\t_LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1,DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\t# Don't use ranlib\n\t_LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t_LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n\t  lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n\t  case $lt_outputfile in\n\t    *.exe|*.EXE) ;;\n\t    *)\n\t      lt_outputfile=\"$lt_outputfile.exe\"\n\t      lt_tool_outputfile=\"$lt_tool_outputfile.exe\"\n\t      ;;\n\t  esac~\n\t  if test \"$MANIFEST_TOOL\" != \":\" && test -f \"$lt_outputfile.manifest\"; then\n\t    $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n\t    $RM \"$lt_outputfile.manifest\";\n\t  fi'\n\t;;\n      *)\n\t# Assume MSVC wrapper\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=\".dll\"\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all \"$deplibs\" | $SED '\\''s/ -lc$//'\\''` -link -dll~linknames='\n\t# The linker will automatically build a .lib file if we build a DLL.\n\t_LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t# FIXME: Should let the user specify the lib program.\n\t_LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t;;\n      esac\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2.*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      ;;\n\n    hpux10*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\tm4_if($1, [], [\n\t  # Older versions of the 11.00 compiler do not understand -b yet\n\t  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)\n\t  _LT_LINKER_OPTION([if $CC understands -b],\n\t    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],\n\t  [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])\n\t  ;;\n\tesac\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n\t# This should be the same for all languages, so no per-tag cache variable.\n\tAC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],\n\t  [lt_cv_irix_exported_symbol],\n\t  [save_LDFLAGS=\"$LDFLAGS\"\n\t   LDFLAGS=\"$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null\"\n\t   AC_LINK_IFELSE(\n\t     [AC_LANG_SOURCE(\n\t        [AC_LANG_CASE([C], [[int foo (void) { return 0; }]],\n\t\t\t      [C++], [[int foo (void) { return 0; }]],\n\t\t\t      [Fortran 77], [[\n      subroutine foo\n      end]],\n\t\t\t      [Fortran], [[\n      subroutine foo\n      end]])])],\n\t      [lt_cv_irix_exported_symbol=yes],\n\t      [lt_cv_irix_exported_symbol=no])\n           LDFLAGS=\"$save_LDFLAGS\"])\n\tif test \"$lt_cv_irix_exported_symbol\" = yes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'\n\tfi\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\telse\n\t  case $host_os in\n\t   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)\n\t     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t     ;;\n\t   *)\n\t     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t     ;;\n\t  esac\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY $libname INITINSTANCE\" > $output_objdir/$libname.def~$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo \" SINGLE NONSHARED\" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'\n      ;;\n\n    osf3*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $pic_flag $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n\t$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test \"$GCC\" = yes; then\n\twlarc='${wl}'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='${wl}'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands `-z linker_flag'.  GCC discards it without `$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test \"$GCC\" = yes; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test \"x$host_vendor\" = xsequent; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We can NOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test x$host_vendor = xsni; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test \"$enable_shared\" = yes && test \"$GCC\" = yes; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_CACHE_CHECK([whether -lc should be explicitly linked in],\n\t[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),\n\t[$RM conftest*\n\techo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n\tif AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n\t  soname=conftest\n\t  lib=conftest\n\t  libobjs=conftest.$ac_objext\n\t  deplibs=\n\t  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\t  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n\t  compiler_flags=-v\n\t  linker_flags=-v\n\t  verstring=\n\t  output_objdir=.\n\t  libname=conftest\n\t  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\n\t  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n\t  then\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t  else\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  fi\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n\telse\n\t  cat conftest.err 1>&5\n\tfi\n\t$RM conftest*\n\t])\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting ${shlibpath_var} if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [postlink_cmds], [2],\n    [Commands necessary for finishing linking programs])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=\"$CC\"\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report which library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test \"$enable_shared\" = yes && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n      test \"$enable_shared\" = yes && enable_static=no\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test \"$enable_shared\" = yes || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test \"X$CXX\" != \"Xg++\"))) ; then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_caught_CXX_error\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_CFLAGS=$CFLAGS\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  CFLAGS=$CXXFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test \"$GXX\" = yes; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test \"$GXX\" = yes; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test \"$with_gnu_ld\" = yes; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='${wl}'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test \"$host_cpu\" = ia64; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\"\"\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # need to do runtime linking.\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n        if test \"$GXX\" = yes; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag=\"$shared_flag \"'${wl}-G'\n\t  fi\n        else\n          # not using gcc\n          if test \"$host_cpu\" = ia64; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test \"$aix_use_runtimelinking\" = yes; then\n\t      shared_flag='${wl}-G'\n\t    else\n\t      shared_flag='${wl}-bM:SRE'\n\t    fi\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n        if test \"$aix_use_runtimelinking\" = yes; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX([$1])\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n        else\n          if test \"$host_cpu\" = ia64; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX([$1])\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t    if test \"$with_gnu_ld\" = yes; then\n\t      # We only use this code for GNU lds that support --whole-archive.\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    else\n\t      # Exported symbols can be pulled into shared objects from archives\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    fi\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    # This is similar to how AIX traditionally builds its shared\n\t    # libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n\tcase $GXX,$cc_basename in\n\t,cl* | no,cl*)\n\t  # Native MSVC\n\t  # hardcode_libdir_flag_spec is actually meaningless, as there is\n\t  # no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=yes\n\t  _LT_TAGVAR(file_list_spec, $1)='@'\n\t  # Tell ltmain to make .lib files, not .a files.\n\t  libext=lib\n\t  # Tell ltmain to make .dll files, not .so files.\n\t  shrext_cmds=\".dll\"\n\t  # FIXME: Setting linknames here is a bad hack.\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t      $SED -n -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' -e '1\\\\\\!p' < $export_symbols > $output_objdir/$soname.exp;\n\t    else\n\t      $SED -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;\n\t    fi~\n\t    $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n\t    linknames='\n\t  # The linker will not automatically build a static lib if we build a DLL.\n\t  # _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t  # Don't use ranlib\n\t  _LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t  _LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n\t    lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n\t    case $lt_outputfile in\n\t      *.exe|*.EXE) ;;\n\t      *)\n\t\tlt_outputfile=\"$lt_outputfile.exe\"\n\t\tlt_tool_outputfile=\"$lt_tool_outputfile.exe\"\n\t\t;;\n\t    esac~\n\t    func_to_tool_file \"$lt_outputfile\"~\n\t    if test \"$MANIFEST_TOOL\" != \":\" && test -f \"$lt_outputfile.manifest\"; then\n\t      $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n\t      $RM \"$lt_outputfile.manifest\";\n\t    fi'\n\t  ;;\n\t*)\n\t  # g++\n\t  # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n\t  # as there is no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=no\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n\t  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t    # If the export-symbols file already is a .def file (1st line\n\t    # is EXPORTS), use it as is; otherwise, prepend...\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t      cp $export_symbols $output_objdir/$soname.def;\n\t    else\n\t      echo EXPORTS > $output_objdir/$soname.def;\n\t      cat $export_symbols >> $output_objdir/$soname.def;\n\t    fi~\n\t    $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t  ;;\n\tesac\n\t;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd2.*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      haiku*)\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n            ;;\n          *)\n            if test \"$GXX\" = yes; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test $with_gnu_ld = no; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test $with_gnu_ld = no; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test \"$with_gnu_ld\" = no; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib ${wl}-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]].* | *pgcpp\\ [[1-5]].*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n\t\tcompile_command=\"$compile_command `find $tpldir -name \\*.o | sort | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n\t\t$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | sort | $NL2SP`~\n\t\t$RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 and above use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"X$list\" | $Xsed'\n\t    ;;\n\t  xl* | mpixl* | bgxl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    if test \"x$supports_anon_versioning\" = xyes; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t\tcat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t\techo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t\t$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='func_echo_all'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd2*)\n        # C++ shared libraries are fairly broken\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      openbsd*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=func_echo_all\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n\t          echo \"-hidden\">> $lib.exp~\n\t          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~\n\t          $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n\t  *)\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands `-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='func_echo_all'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -shared $pic_flag -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require `-G' NOT `-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We can NOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~\n\t      '\"$_LT_TAGVAR(old_archive_cmds, $1)\"\n\t    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~\n\t      '\"$_LT_TAGVAR(reload_cmds, $1)\"\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=\"$GXX\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test \"$_lt_caught_CXX_error\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_FUNC_STRIPNAME_CNF\n# ----------------------\n# func_stripname_cnf prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n#\n# This function is identical to the (non-XSI) version of func_stripname,\n# except this one can be used by m4 code that may be executed by configure,\n# rather than the libtool script.\nm4_defun([_LT_FUNC_STRIPNAME_CNF],[dnl\nAC_REQUIRE([_LT_DECL_SED])\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])\nfunc_stripname_cnf ()\n{\n  case ${2} in\n  .*) func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%\\\\\\\\${2}\\$%%\"`;;\n  *)  func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%${2}\\$%%\"`;;\n  esac\n} # func_stripname_cnf\n])# _LT_FUNC_STRIPNAME_CNF\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nAC_REQUIRE([_LT_FUNC_STRIPNAME_CNF])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF\npackage foo\nfunc foo() {\n}\n_LT_EOF\n])\n\n_lt_libdeps_save_CFLAGS=$CFLAGS\ncase \"$CC $CFLAGS \" in #(\n*\\ -flto*\\ *) CFLAGS=\"$CFLAGS -fno-lto\" ;;\n*\\ -fwhopr*\\ *) CFLAGS=\"$CFLAGS -fno-whopr\" ;;\n*\\ -fuse-linker-plugin*\\ *) CFLAGS=\"$CFLAGS -fno-use-linker-plugin\" ;;\nesac\n\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case ${prev}${p} in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test $p = \"-L\" ||\n          test $p = \"-R\"; then\n\t prev=$p\n\t continue\n       fi\n\n       # Expand the sysroot to ease extracting the directories later.\n       if test -z \"$prev\"; then\n         case $p in\n         -L*) func_stripname_cnf '-L' '' \"$p\"; prev=-L; p=$func_stripname_result ;;\n         -R*) func_stripname_cnf '-R' '' \"$p\"; prev=-R; p=$func_stripname_result ;;\n         -l*) func_stripname_cnf '-l' '' \"$p\"; prev=-l; p=$func_stripname_result ;;\n         esac\n       fi\n       case $p in\n       =*) func_stripname_cnf '=' '' \"$p\"; p=$lt_sysroot$func_stripname_result ;;\n       esac\n       if test \"$pre_test_object_deps_done\" = no; then\n\t case ${prev} in\n\t -L | -R)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${prev}${p}\"\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=\"${prev}${p}\"\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} ${prev}${p}\"\n\t fi\n       fi\n       prev=\n       ;;\n\n    *.lto.$objext) ;; # Ignore GCC LTO objects\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\nCFLAGS=$_lt_libdeps_save_CFLAGS\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\n\nlinux*)\n  case `$CC -V 2>&1 | sed 5q` in\n  *Sun\\ C*)\n    # Sun C++ 5.9\n\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\n\nsolaris*)\n  case $cc_basename in\n  CC* | sunCC*)\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    # Adding this requires a known-good setup of shared libraries for\n    # Sun compiler versions before 5.6, else PIC objects from an old\n    # archive will be linked into the output, leading to subtle bugs.\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | ${SED} -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_LANG_PUSH(Fortran 77)\nif test -z \"$F77\" || test \"X$F77\" = \"Xno\"; then\n  _lt_disable_F77=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_F77\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${F77-\"f77\"}\n  CFLAGS=$FFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$G77\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\n  CFLAGS=\"$lt_save_CFLAGS\"\nfi # test \"$_lt_disable_F77\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_LANG_PUSH(Fortran)\n\nif test -z \"$FC\" || test \"X$FC\" = \"Xno\"; then\n  _lt_disable_FC=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_FC\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${FC-\"f95\"}\n  CFLAGS=$FCFLAGS\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$ac_cv_fc_compiler_gnu\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\nfi # test \"$_lt_disable_FC\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\nCFLAGS=$GCJFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_GO_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Go compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GO_CONFIG],\n[AC_REQUIRE([LT_PROG_GO])dnl\nAC_LANG_SAVE\n\n# Source file extension for Go test sources.\nac_ext=go\n\n# Object file extension for compiled Go test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"package main; func main() { }\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='package main; func main() { }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GOC-\"gccgo\"}\nCFLAGS=$GOFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# Go did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GO_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"$lt_simple_compile_test_code\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\nCFLAGS=\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test \"x${GCJFLAGS+set}\" = xset || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_GO\n# ----------\nAC_DEFUN([LT_PROG_GO],\n[AC_CHECK_TOOL(GOC, gccgo,)\n])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n# _LT_DECL_DLLTOOL\n# ----------------\n# Ensure DLLTOOL variable is set.\nm4_defun([_LT_DECL_DLLTOOL],\n[AC_CHECK_TOOL(DLLTOOL, dlltool, false)\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])\nAC_SUBST([DLLTOOL])\n])\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f $lt_ac_sed && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test $lt_ac_count -gt 10 && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test $lt_ac_count -gt $lt_ac_max; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[AC_MSG_CHECKING([whether the shell understands some XSI constructs])\n# Try some XSI features\nxsi_shell=no\n( _lt_dummy=\"a/b/c\"\n  test \"${_lt_dummy##*/},${_lt_dummy%/*},${_lt_dummy#??}\"${_lt_dummy%\"$_lt_dummy\"}, \\\n      = c,a/b,b/c, \\\n    && eval 'test $(( 1 + 1 )) -eq 2 \\\n    && test \"${#_lt_dummy}\" -eq 5' ) >/dev/null 2>&1 \\\n  && xsi_shell=yes\nAC_MSG_RESULT([$xsi_shell])\n_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])\n\nAC_MSG_CHECKING([whether the shell understands \"+=\"])\nlt_shell_append=no\n( foo=bar; set foo baz; eval \"$[1]+=\\$[2]\" && test \"$foo\" = barbaz ) \\\n    >/dev/null 2>&1 \\\n  && lt_shell_append=yes\nAC_MSG_RESULT([$lt_shell_append])\n_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])\n\nif ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PROG_FUNCTION_REPLACE (FUNCNAME, REPLACEMENT-BODY)\n# ------------------------------------------------------\n# In `$cfgfile', look for function FUNCNAME delimited by `^FUNCNAME ()$' and\n# '^} FUNCNAME ', and replace its body with REPLACEMENT-BODY.\nm4_defun([_LT_PROG_FUNCTION_REPLACE],\n[dnl {\nsed -e '/^$1 ()$/,/^} # $1 /c\\\n$1 ()\\\n{\\\nm4_bpatsubsts([$2], [$], [\\\\], [^\\([\t ]\\)], [\\\\\\1])\n} # Extended-shell $1 implementation' \"$cfgfile\" > $cfgfile.tmp \\\n  && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\ntest 0 -eq $? || _lt_function_replace_fail=:\n])\n\n\n# _LT_PROG_REPLACE_SHELLFNS\n# -------------------------\n# Replace existing portable implementations of several shell functions with\n# equivalent extended shell implementations where those features are available..\nm4_defun([_LT_PROG_REPLACE_SHELLFNS],\n[if test x\"$xsi_shell\" = xyes; then\n  _LT_PROG_FUNCTION_REPLACE([func_dirname], [dnl\n    case ${1} in\n      */*) func_dirname_result=\"${1%/*}${2}\" ;;\n      *  ) func_dirname_result=\"${3}\" ;;\n    esac])\n\n  _LT_PROG_FUNCTION_REPLACE([func_basename], [dnl\n    func_basename_result=\"${1##*/}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_dirname_and_basename], [dnl\n    case ${1} in\n      */*) func_dirname_result=\"${1%/*}${2}\" ;;\n      *  ) func_dirname_result=\"${3}\" ;;\n    esac\n    func_basename_result=\"${1##*/}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_stripname], [dnl\n    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n    # positional parameters, so assign one to ordinary parameter first.\n    func_stripname_result=${3}\n    func_stripname_result=${func_stripname_result#\"${1}\"}\n    func_stripname_result=${func_stripname_result%\"${2}\"}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_split_long_opt], [dnl\n    func_split_long_opt_name=${1%%=*}\n    func_split_long_opt_arg=${1#*=}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_split_short_opt], [dnl\n    func_split_short_opt_arg=${1#??}\n    func_split_short_opt_name=${1%\"$func_split_short_opt_arg\"}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_lo2o], [dnl\n    case ${1} in\n      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\n      *)    func_lo2o_result=${1} ;;\n    esac])\n\n  _LT_PROG_FUNCTION_REPLACE([func_xform], [    func_xform_result=${1%.*}.lo])\n\n  _LT_PROG_FUNCTION_REPLACE([func_arith], [    func_arith_result=$(( $[*] ))])\n\n  _LT_PROG_FUNCTION_REPLACE([func_len], [    func_len_result=${#1}])\nfi\n\nif test x\"$lt_shell_append\" = xyes; then\n  _LT_PROG_FUNCTION_REPLACE([func_append], [    eval \"${1}+=\\\\${2}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_append_quoted], [dnl\n    func_quote_for_eval \"${2}\"\ndnl m4 expansion turns \\\\\\\\ into \\\\, and then the shell eval turns that into \\\n    eval \"${1}+=\\\\\\\\ \\\\$func_quote_for_eval_result\"])\n\n  # Save a `func_append' function call where possible by direct use of '+='\n  sed -e 's%func_append \\([[a-zA-Z_]]\\{1,\\}\\) \"%\\1+=\"%g' $cfgfile > $cfgfile.tmp \\\n    && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n      || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\n  test 0 -eq $? || _lt_function_replace_fail=:\nelse\n  # Save a `func_append' function call even when '+=' is not available\n  sed -e 's%func_append \\([[a-zA-Z_]]\\{1,\\}\\) \"%\\1=\"$\\1%g' $cfgfile > $cfgfile.tmp \\\n    && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n      || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\n  test 0 -eq $? || _lt_function_replace_fail=:\nfi\n\nif test x\"$_lt_function_replace_fail\" = x\":\"; then\n  AC_MSG_WARN([Unable to substitute extended shell functions in $ofile])\nfi\n])\n\n# _LT_PATH_CONVERSION_FUNCTIONS\n# -----------------------------\n# Determine which file name conversion functions should be used by\n# func_to_host_file (and, implicitly, by func_to_host_path).  These are needed\n# for certain cross-compile configurations and native mingw.\nm4_defun([_LT_PATH_CONVERSION_FUNCTIONS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_MSG_CHECKING([how to convert $build file names to $host format])\nAC_CACHE_VAL(lt_cv_to_host_file_cmd,\n[case $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32\n        ;;\n    esac\n    ;;\n  *-*-cygwin* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_noop\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin\n        ;;\n    esac\n    ;;\n  * ) # unhandled hosts (and \"normal\" native builds)\n    lt_cv_to_host_file_cmd=func_convert_file_noop\n    ;;\nesac\n])\nto_host_file_cmd=$lt_cv_to_host_file_cmd\nAC_MSG_RESULT([$lt_cv_to_host_file_cmd])\n_LT_DECL([to_host_file_cmd], [lt_cv_to_host_file_cmd],\n         [0], [convert $build file names to $host format])dnl\n\nAC_MSG_CHECKING([how to convert $build file names to toolchain format])\nAC_CACHE_VAL(lt_cv_to_tool_file_cmd,\n[#assume ordinary cross tools, or native build.\nlt_cv_to_tool_file_cmd=func_convert_file_noop\ncase $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32\n        ;;\n    esac\n    ;;\nesac\n])\nto_tool_file_cmd=$lt_cv_to_tool_file_cmd\nAC_MSG_RESULT([$lt_cv_to_tool_file_cmd])\n_LT_DECL([to_tool_file_cmd], [lt_cv_to_tool_file_cmd],\n         [0], [convert $build files to toolchain format])dnl\n])# _LT_PATH_CONVERSION_FUNCTIONS\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Native/Unix/System.Security.Cryptography.Native/opensslshim.cpp": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n//\n\n#include <dlfcn.h>\n#include <stdio.h>\n\n#include \"opensslshim.h\"\n\n// Define pointers to all the used ICU functions\n#define PER_FUNCTION_BLOCK(fn, isRequired) decltype(fn) fn##_ptr;\nFOR_ALL_OPENSSL_FUNCTIONS\n#undef PER_FUNCTION_BLOCK\n\nstatic void* libssl = nullptr;\n\nbool OpenLibrary()\n{\n    // First try the default versioned so naming as described in the OpenSSL doc\n    libssl = dlopen(\"libssl.so.1.0.0\", RTLD_LAZY);\n    if (libssl == nullptr)\n    {\n        // Fedora derived distros use different naming for the version 1.0.0\n        libssl = dlopen(\"libssl.so.10\", RTLD_LAZY);\n    }\n\n    if (libssl == nullptr)\n    {\n        // Debian 9 has dropped support for SSLv3 and so they have bumped their soname\n        libssl = dlopen(\"libssl.so.1.0.2\", RTLD_LAZY);\n    }\n\n    return libssl != nullptr;\n}\n\n__attribute__((constructor))\nvoid InitializeOpenSSLShim()\n{\n    if (!OpenLibrary())\n    {\n        fprintf(stderr, \"No usable version of the libssl was found\\n\");\n        abort();\n    }\n\n    // Get pointers to all the ICU functions that are needed\n#define PER_FUNCTION_BLOCK(fn, isRequired) \\\n    fn##_ptr = reinterpret_cast<decltype(fn)>(dlsym(libssl, #fn)); \\\n    if ((fn##_ptr) == NULL && isRequired) { fprintf(stderr, \"Cannot get required symbol \" #fn \" from libssl\\n\"); abort(); }\n\n    FOR_ALL_OPENSSL_FUNCTIONS\n#undef PER_FUNCTION_BLOCK    \n}\n\n__attribute__((destructor))\nvoid ShutdownOpenSSLShim()\n{\n    if (libssl != nullptr)\n    {\n        dlclose(libssl);\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Native/Unix/System.Security.Cryptography.Native/CMakeLists.txt": "\nproject(System.Security.Cryptography.Native)\n\nset(CMAKE_INCLUDE_CURRENT_DIR ON)\n\n# These are happening inside of OpenSSL-defined macros out of our control\nadd_compile_options(-Wno-cast-align)\n\nadd_definitions(-DPIC=1)\n\nif(CMAKE_STATIC_LIB_LINK)\n   set(CMAKE_FIND_LIBRARY_SUFFIXES .a)\nendif(CMAKE_STATIC_LIB_LINK)\n\nfind_package(OpenSSL REQUIRED)\ninclude_directories(SYSTEM ${OPENSSL_INCLUDE_DIR})\n\nset(NATIVECRYPTO_SOURCES\n    openssl.cpp\n    pal_asn1.cpp\n    pal_asn1_print.cpp\n    pal_bignum.cpp\n    pal_bio.cpp\n    pal_dsa.cpp\n    pal_ecdsa.cpp\n    pal_ecc_import_export.cpp\n    pal_eckey.cpp\n    pal_err.cpp\n    pal_evp.cpp\n    pal_evp_pkey.cpp\n    pal_evp_pkey_dsa.cpp\n    pal_evp_pkey_eckey.cpp\n    pal_evp_pkey_rsa.cpp\n    pal_evp_cipher.cpp\n    pal_hmac.cpp\n    pal_pkcs12.cpp\n    pal_pkcs7.cpp\n    pal_rsa.cpp\n    pal_ssl.cpp\n    pal_x509.cpp\n    pal_x509_name.cpp\n    pal_x509_root.cpp\n    pal_x509ext.cpp\n)\n\nif (FEATURE_DISTRO_AGNOSTIC_SSL)\n    if (NOT CMAKE_SYSTEM_NAME STREQUAL Linux)\n        message(FATAL_ERROR \"FEATURE_DISTRO_AGNOSTIC_SSL can only be enabled for Linux\")\n    endif()\n\n    list(APPEND NATIVECRYPTO_SOURCES\n        opensslshim.cpp\n    )\n    add_definitions(-DFEATURE_DISTRO_AGNOSTIC_SSL)\nendif()\n\nadd_library(objlib OBJECT ${NATIVECRYPTO_SOURCES} ${VERSION_FILE_PATH})\n\nadd_library(System.Security.Cryptography.Native.OpenSsl\n    SHARED\n    $<TARGET_OBJECTS:objlib>\n)\n\nadd_library(System.Security.Cryptography.Native.OpenSsl-Static\n    STATIC\n    $<TARGET_OBJECTS:objlib>\n)\n\n# Disable the \"lib\" prefix.\nset_target_properties(System.Security.Cryptography.Native.OpenSsl PROPERTIES PREFIX \"\")\n\n# Disable the \"lib\" prefix and override default name\nset_target_properties(System.Security.Cryptography.Native.OpenSsl-Static PROPERTIES PREFIX \"\")\nset_target_properties(System.Security.Cryptography.Native.OpenSsl-Static PROPERTIES OUTPUT_NAME System.Security.Cryptography.Native.OpenSsl CLEAN_DIRECT_OUTPUT 1)\n\nif (FEATURE_DISTRO_AGNOSTIC_SSL)\n    add_custom_command(TARGET System.Security.Cryptography.Native.OpenSsl POST_BUILD\n        COMMENT \"Verifying System.Security.Cryptography.Native.OpenSsl.so dependencies\"\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/../verify-so.sh \n            $<TARGET_FILE:System.Security.Cryptography.Native.OpenSsl> \n            \"Verification failed. System.Security.Cryptography.Native.OpenSsl.so has undefined dependencies. These are likely OpenSSL APIs that need to be added to opensslshim.h\"\n        VERBATIM\n    )\n\n    # Link with libdl.so to get the dlopen / dlsym / dlclose\n    target_link_libraries(System.Security.Cryptography.Native.OpenSsl\n      dl\n    )\nelse()\n    target_link_libraries(System.Security.Cryptography.Native.OpenSsl\n      ${OPENSSL_CRYPTO_LIBRARY}\n      ${OPENSSL_SSL_LIBRARY}\n    )\n  \n    # On OS X every library emits the manner in which it should be referenced.\n    # All of our libraries are referenced via @rpath, which is similar to how Linux and Windows\n    # libraries are loaded. The homebrew installation of OpenSSL (libcrypto, libssl) uses the\n    # full path to the library installation. This means that this library is not flexible to\n    # users installing newer libcrypto in the working directory, or to systems which do not\n    # install to the same path as homebrew does.\n    #\n    # So, after compiling, rewrite the references to libcrypto to be more flexible.\n    if (APPLE)\n        add_custom_command(TARGET System.Security.Cryptography.Native.OpenSsl POST_BUILD\n            COMMAND ${CMAKE_INSTALL_NAME_TOOL} -change /usr/local/opt/openssl/lib/libcrypto.1.0.0.dylib @rpath/libcrypto.1.0.0.dylib $<TARGET_FILE:System.Security.Cryptography.Native.OpenSsl>\n            COMMAND ${CMAKE_INSTALL_NAME_TOOL} -change /usr/local/opt/openssl/lib/libssl.1.0.0.dylib @rpath/libssl.1.0.0.dylib $<TARGET_FILE:System.Security.Cryptography.Native.OpenSsl>\n            COMMAND ${CMAKE_INSTALL_NAME_TOOL} -add_rpath @loader_path $<TARGET_FILE:System.Security.Cryptography.Native.OpenSsl>\n            )\n    endif()\nendif()\n\ninclude(configure.cmake)\n\ninstall_library_and_symbols (System.Security.Cryptography.Native.OpenSsl)\ninstall (TARGETS System.Security.Cryptography.Native.OpenSsl-Static DESTINATION .)\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/src/Interop/Unix/libdl/Interop.dlsym.cs": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System;\nusing System.Runtime.InteropServices;\n\ninternal partial class Interop\n{\n    internal partial class Libdl\n    {\n        [DllImport(Libraries.Libdl)]\n        public static extern IntPtr dlsym(IntPtr handle, string symbol);\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/src/System/Runtime/InteropServices/FunctionWrapper.Unix.cs": "\ufeff// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nnamespace System.Runtime.InteropServices\n{\n    internal static partial class FunctionWrapper\n    {\n        public static IntPtr LoadFunctionPointer(IntPtr nativeLibraryHandle, string functionName)\n            => Interop.Libdl.dlsym(nativeLibraryHandle, functionName);\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Drawing.Common/src/System.Drawing.Common.csproj": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"14.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <Import Project=\"$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), dir.props))\\dir.props\" />\n  <PropertyGroup>\n    <OutputType>Library</OutputType>\n    <ProjectGuid>{191B3618-FECD-4ABD-9D6B-5AC90DC33621}</ProjectGuid>\n    <DefineConstants>$(DefineConstants);DRAWING_NAMESPACE</DefineConstants>\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n    <!-- TODO: RE-ENABLE THIS -->\n    <EnablePInvokeAnalyzer>false</EnablePInvokeAnalyzer>\n    <WarningsNotAsErrors>CS0618</WarningsNotAsErrors>\n    <DefineConstants Condition=\"'$(TargetsWindows)' == 'true'\">$(DefineConstants);FEATURE_WINDOWS_SYSTEM_COLORS</DefineConstants>\n    <DefineConstants Condition=\"'$(TargetsUnix)' == 'true'\">$(DefineConstants);CORECLR;NETCORE</DefineConstants>\n    <IsPartialFacadeAssembly Condition=\"'$(TargetGroup)' == 'netfx'\">true</IsPartialFacadeAssembly>\n    <GeneratePlatformNotSupportedAssemblyMessage Condition=\"'$(TargetGroup)' == 'netstandard'\">SR.PlatformNotSupported_Drawing</GeneratePlatformNotSupportedAssemblyMessage>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp2.0-Unix-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp2.0-Unix-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp2.0-Windows_NT-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp2.0-Windows_NT-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Windows_NT-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Windows_NT-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Unix-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netcoreapp-Unix-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netfx-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netfx-Release|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netstandard-Debug|AnyCPU'\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)' == 'netstandard-Release|AnyCPU'\" />\n  <ItemGroup Condition=\"$(TargetGroup.StartsWith('netcoreapp'))\">\n    <!-- Shared source code, all configurations -->\n    <Compile Include=\"System\\Drawing\\Bitmap.cs\" />\n    <Compile Include=\"System\\Drawing\\BitmapSuffixInSameAssemblyAttribute.cs\" />\n    <Compile Include=\"System\\Drawing\\BitmapSuffixInSatelliteAssemblyAttribute.cs\" />\n    <Compile Include=\"System\\Drawing\\Brushes.cs\" />\n    <Compile Include=\"System\\Drawing\\CharacterRange.cs\" />\n    <Compile Include=\"System\\Drawing\\ColorTranslator.cs\" />\n    <Compile Include=\"System\\Drawing\\ContentAlignment.cs\" />\n    <Compile Include=\"System\\Drawing\\IDeviceContext.cs\" />\n    <Compile Include=\"System\\Drawing\\Image.cs\" />\n    <Compile Include=\"System\\Drawing\\GdiplusNative.cs\" />\n    <Compile Include=\"System\\Drawing\\Graphics.cs\" />\n    <Compile Include=\"System\\Drawing\\GraphicsUnit.cs\" />\n    <Compile Include=\"System\\Drawing\\ImageType.cs\" />\n    <Compile Include=\"System\\Drawing\\Pen.cs\" />\n    <Compile Include=\"System\\Drawing\\Pens.cs\" />\n    <Compile Include=\"System\\Drawing\\RotateFlipType.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemColors.cs\" />\n    <Compile Include=\"System\\Drawing\\StringFormat.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemFonts.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemPens.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterUnit.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PreviewPageInfo.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintEventHandler.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintingPermissionLevel.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintAction.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintPageEventHandler.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\QueryPageSettingsEventArgs.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\QueryPageSettingsEventHandler.cs\" />\n    <Compile Include=\"System\\Drawing\\Design\\CategoryNameCollection.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\Blend.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\BrushType.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\ColorBlend.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CombineMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CompositingMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CompositingQuality.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CoordinateSpace.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\DashStyle.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\FillMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\FlushIntention.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\GraphicsContainer.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\HatchBrush.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\HatchStyle.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\InterpolationMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\LinearGradientMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\LinearGradientBrush.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\LineCap.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\LineJoin.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\MatrixOrder.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\Matrix.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PathData.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PathGradientBrush.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PathPointType.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PenAlignment.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PenType.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\PixelOffsetMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\QualityMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\RegionData.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\SmoothingMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\WrapMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\WarpMode.cs\" />\n    <Compile Include=\"System\\Drawing\\CopyPixelOperation.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorAdjustType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorChannelFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorMap.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorMapType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorMatrixFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EmfPlusRecordType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EmfType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\Encoder.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EncoderParameterValueType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EncoderValue.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\FrameDimension.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageCodecFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageFormat.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageLockMode.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\PaletteFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\PixelFormat.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\PlayRecordCallback.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\PropertyItem.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\WmfPlaceableFileHeader.cs\" />\n    <Compile Include=\"System\\Drawing\\FontStyle.cs\" />\n    <Compile Include=\"System\\Drawing\\Region.cs\" />\n    <Compile Include=\"System\\Drawing\\StringAlignment.cs\" />\n    <Compile Include=\"System\\Drawing\\StringDigitSubstitute.cs\" />\n    <Compile Include=\"System\\Drawing\\StringFormatFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\StringTrimming.cs\" />\n    <Compile Include=\"System\\Drawing\\StringUnit.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\GenericFontFamilies.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\HotkeyPrefix.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\TextRenderingHint.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\PrivateFontCollection.cs\" />\n    <Compile Include=\"System\\Drawing\\ClientUtils.cs\" />\n    <Compile Include=\"misc\\CompModSwitches.cs\" />\n    <Compile Include=\"misc\\DebugHandleTracker.cs\" />\n    <Compile Include=\"misc\\HandleCollector.cs\" />\n    <Compile Include=\"System\\Drawing\\Gdiplus.cs\" />\n    <Compile Include=\"System\\Drawing\\NativeMethods.cs\" />\n    <Compile Include=\"System\\Drawing\\UnsafeNativeMethods.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\GPPOINT.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\GPPOINTF.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\GPRECT.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\GPRECTF.cs\" />\n    <Compile Include=\"System\\Drawing\\Brush.cs\" />\n    <Compile Include=\"System\\Drawing\\FontFamily.cs\" />\n    <Compile Include=\"System\\Drawing\\SolidBrush.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemBrushes.cs\" />\n    <Compile Include=\"System\\Drawing\\TextureBrush.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CustomLineCapType.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EmfPlusFlags.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileHeaderWmf.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileHeaderEmf.cs\" />\n    <Compile Include=\"System\\Drawing\\PropertyItemInternal.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\Duplex.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\InvalidPrinterException.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\InvalidPrinterException.Core.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\Margins.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PaperKinds.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PaperSize.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PaperSource.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PaperSourceKind.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterResolution.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterResolutionKind.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterUnitConvert.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintRange.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\AdjustableArrowCap.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CustomLineCap.cs\" />\n    <Compile Include=\"System\\Drawing\\DashCap.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\GraphicsPathIterator.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\GraphicsState.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\SafeCustomLineCapHandle.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\FontCollection.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\InstalledFontCollection.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorMatrix.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ColorPalette.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EncoderParameter.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\EncoderParameters.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageAttributes.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageCodecInfo.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\ImageCodecInfoPrivate.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileFrameUnit.cs\" />\n    <Compile Include=\"$(CommonPath)\\System\\Drawing\\ColorConverterCommon.cs\">\n      <Link>System\\Drawing\\ColorConverterCommon.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Drawing\\ColorTable.cs\">\n      <Link>System\\Drawing\\ColorTable.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Drawing\\ColorUtil.netcoreapp20.cs\">\n      <Link>System\\Drawing\\ColorUtil.netcoreapp20.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Drawing\\KnownColorTable.cs\">\n      <Link>System\\Drawing\\KnownColorTable.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Runtime\\InteropServices\\FunctionWrapper.cs\">\n      <Link>Common\\System\\Runtime\\InteropServices\\FunctionWrapper.cs</Link>\n    </Compile>\n    <EmbeddedResource Include=\"Resources\\System\\Drawing\\DefaultComponent.bmp\">\n      <LogicalName>System.Drawing.DefaultComponent.bmp</LogicalName>\n    </EmbeddedResource>\n    <EmbeddedResource Include=\"Resources\\System\\Drawing\\Printing\\PrintDocument.bmp\" />\n    <EmbeddedResource Include=\"Resources\\System\\Drawing\\ShieldIcon.ico\">\n      <LogicalName>System.Drawing.ShieldIcon.ico</LogicalName>\n    </EmbeddedResource>\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetGroup)' == 'netcoreapp2.0'\">\n    <Compile Include=\"misc\\InvalidEnumArgumentException.cs\" />\n    <Compile Include=\"$(CommonPath)\\System\\Drawing\\KnownColor.cs\">\n      <Link>System\\Drawing\\KnownColor.cs</Link>\n    </Compile>\n  </ItemGroup>\n  <ItemGroup Condition=\"$(TargetGroup.StartsWith('netcoreapp')) AND '$(TargetsWindows)' == 'true'\">\n    <!-- Windows-specific -->\n    <Compile Include=\"AssemblyRef.cs\" />\n    <Compile Include=\"SRDescriptionAttribute.cs\" />\n    <Compile Include=\"System\\Drawing\\Bitmap.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\BitmapSelector.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphics.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphicsContext.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphicsManager.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CustomLineCap.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\GraphicsPath.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Font.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Font.NotSerializable.cs\" />\n    <Compile Include=\"System\\Drawing\\GdiplusNative.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Graphics.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\GraphicsContext.cs\" />\n    <Compile Include=\"System\\Drawing\\Icon.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Icon.NotSerializable.cs\" />\n    <Compile Include=\"System\\Drawing\\Image.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Image.NotSerializable.cs\" />\n    <Compile Include=\"System\\Drawing\\ImageAnimator.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\ImageInfo.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\BitmapData.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\Metafile.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileHeader.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetaHeader.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Internal\\GPStream.cs\" />\n    <Compile Include=\"System\\Drawing\\LocalAppContextSwitches.cs\" />\n    <Compile Include=\"System\\Drawing\\Pen.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\DefaultPrintController.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\ModeField.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PageSettings.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PreviewPrintController.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintController.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintDocument.Windows.cs\">\n      <SubType>Component</SubType>\n    </Compile>\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterSettings.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintEventArgs.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintPageEventArgs.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintPreviewGraphics.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\TriState.cs\" />\n    <Compile Include=\"System\\Drawing\\Region.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemFonts.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemIcons.Windows.cs\" />\n    <Compile Include=\"System\\Drawing\\ToolboxBitmapAttribute.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\PrivateFontCollection.Windows.cs\" />\n    <Compile Include=\"misc\\DbgUtil.cs\" />\n    <Compile Include=\"misc\\DpiHelper.cs\" />\n    <Compile Include=\"misc\\ExternDll.cs\" />\n    <Compile Include=\"misc\\GDI\\ApplyGraphicsProperties.cs\" />\n    <Compile Include=\"misc\\GDI\\DeviceContext.cs\" />\n    <Compile Include=\"misc\\GDI\\DeviceContexts.cs\" />\n    <Compile Include=\"misc\\GDI\\DeviceContextType.cs\" />\n    <Compile Include=\"misc\\GDI\\NativeMethods.cs\" />\n    <Compile Include=\"misc\\GDI\\SafeNativeMethods.cs\" />\n    <Compile Include=\"misc\\GDI\\UnsafeNativeMethods.cs\" />\n    <Compile Include=\"misc\\GDI\\WindowsGraphics.cs\" />\n    <Compile Include=\"misc\\GDI\\WindowsRegion.cs\" />\n    <Compile Include=\"misc\\GDI\\WindowsRegionCombineMode.cs\" />\n    <Compile Include=\"$(CommonPath)\\System\\LocalAppContext.cs\" />\n    <Compile Include=\"$(CommonPath)\\System\\Numerics\\Hashing\\HashHelpers.cs\">\n      <Link>Common\\System\\Numerics\\Hashing\\HashHelpers.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\Interop.Libraries.cs\">\n      <Link>Common\\Interop\\Windows\\Interop.Libraries.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\kernel32\\Interop.FreeLibrary.cs\">\n      <Link>Common\\Interop\\Windows\\kernel32\\Interop.FreeLibrary.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\kernel32\\Interop.LoadLibraryEx.cs\">\n      <Link>Common\\Interop\\Windows\\kernel32\\Interop.LoadLibraryEx.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\kernel32\\Interop.GetProcAddress.cs\">\n      <Link>Common\\Interop\\Windows\\kernel32\\Interop.GetProcAddress.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\user32\\Interop.GetSysColor.cs\">\n      <Link>Common\\Interop\\Windows\\user32\\Interop.GetSysColor.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Windows\\user32\\Interop.Win32SystemColors.cs\">\n      <Link>Common\\Interop\\Windows\\user32\\Interop.Win32SystemColors.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Microsoft\\Win32\\SafeHandles\\SafeLibraryHandle.cs\">\n      <Link>Common\\Microsoft\\Win32\\SafeHandles\\SafeLibraryHandle.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Runtime\\InteropServices\\FunctionWrapper.Windows.cs\">\n      <Link>Common\\System\\Runtime\\InteropServices\\FunctionWrapper.Windows.cs</Link>\n    </Compile>\n  </ItemGroup>\n  <ItemGroup Condition=\"$(TargetGroup.StartsWith('netcoreapp')) AND '$(TargetsUnix)' == 'true'\">\n    <!-- Unix-specific -->\n    <Compile Include=\"System\\Drawing\\Graphics.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Icon.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Icon.NotSerializable.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemFonts.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\BitmapData.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\Metafile.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetafileHeader.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Imaging\\MetaHeader.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\LibcupsNative.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintingServices.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PageSettings.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PreviewPrintController.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintController.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintDocument.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrinterSettings.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintEventArgs.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\PrintPageEventArgs.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Printing\\StandardPrintController.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Bitmap.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphics.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphicsManager.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\BufferedGraphicsContext.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\macFunctions.cs\" />\n    <Compile Include=\"System\\Drawing\\Font.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\GdiplusNative.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\GdiPlusStreamHelper.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\LibX11Functions.cs\" />\n    <Compile Include=\"System\\Drawing\\MarshallingHelpers.cs\" />\n    <Compile Include=\"System\\Drawing\\NativeStructs.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\ImageAnimator.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Image.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Pen.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Region.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\SRDescriptionAttribute.cs\" />\n    <Compile Include=\"System\\Drawing\\SystemIcons.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\ToolboxBitmapAttribute.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\AdjustableArrowCap.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\CustomLineCap.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Drawing2D\\GraphicsPath.Unix.cs\" />\n    <Compile Include=\"System\\Drawing\\Text\\PrivateFontCollection.Unix.cs\" />\n    <Compile Include=\"MonoTODOAttribute.cs\" />\n    <Compile Include=\"misc\\ExternDll.Unix.cs\" />\n    <Compile Include=\"$(CommonPath)\\Interop\\Unix\\Interop.Libraries.cs\">\n      <Link>Common\\Interop\\Unix\\Interop.Libraries.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Unix\\libdl\\Interop.dlopen.cs\">\n      <Link>Common\\Interop\\Unix\\libdl\\Interop.dlopen.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\Interop\\Unix\\libdl\\Interop.dlsym.cs\">\n      <Link>Common\\Interop\\Unix\\libdl\\Interop.dlsym.cs</Link>\n    </Compile>\n    <Compile Include=\"$(CommonPath)\\System\\Runtime\\InteropServices\\FunctionWrapper.Unix.cs\">\n      <Link>Common\\System\\Runtime\\InteropServices\\FunctionWrapper.Unix.cs</Link>\n    </Compile>\n    <EmbeddedResource Include=\"Resources\\System\\Drawing\\Error.ico\">\n      <LogicalName>placeholder.ico</LogicalName>\n    </EmbeddedResource>\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetGroup)' != 'netfx'\">\n    <Reference Include=\"Microsoft.Win32.Primitives\" />\n    <Reference Include=\"System.Collections\" />\n    <Reference Include=\"System.Collections.NonGeneric\" />\n    <Reference Include=\"System.Collections.Specialized\" />\n    <Reference Include=\"System.Diagnostics.Debug\" />\n    <Reference Include=\"System.Diagnostics.StackTrace\" />\n    <Reference Include=\"System.Diagnostics.Tools\" />\n    <Reference Include=\"System.Diagnostics.TraceSource\" />\n    <Reference Include=\"System.Drawing.Primitives\" />\n    <Reference Include=\"System.IO.FileSystem\" />\n    <Reference Include=\"System.Resources.ResourceManager\" />\n    <Reference Include=\"System.Runtime\" />\n    <Reference Include=\"System.Runtime.Extensions\" />\n    <Reference Include=\"System.Runtime.InteropServices\" />\n    <Reference Include=\"System.Runtime.InteropServices.RuntimeInformation\" />\n    <Reference Include=\"System.ComponentModel\" />\n    <Reference Include=\"System.ComponentModel.Primitives\" />\n    <Reference Include=\"System.Threading\" />\n    <Reference Include=\"System.Threading.Thread\" />\n    <Reference Include=\"System.Text.Encoding.Extensions\" />\n  </ItemGroup>\n  <ItemGroup Condition=\"'$(TargetGroup)' == 'netfx'\">\n    <Reference Include=\"mscorlib\" />\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.Drawing\" />\n  </ItemGroup>\n  <Import Project=\"$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), dir.targets))\\dir.targets\" />\n</Project>",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Drawing.Common/src/System/Drawing/GdiplusNative.Unix.cs": "\ufeff// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\nusing System.Drawing.Drawing2D;\nusing System.Drawing.Imaging;\nusing System.Drawing.Text;\nusing System.IO;\nusing System.Runtime.InteropServices;\n\nnamespace System.Drawing\n{\n    internal partial class SafeNativeMethods\n    {\n        internal unsafe partial class Gdip\n        {\n            private const string LibraryName = \"libgdiplus\";\n            public static IntPtr Display = IntPtr.Zero;\n\n            // Indicates whether X11 is available. It's available on Linux but not on recent macOS versions\n            // When set to false, where Carbon Drawing is used instead.\n            // macOS users can force X11 by setting the SYSTEM_DRAWING_COMMON_FORCE_X11 flag.\n            public static bool UseX11Drawable { get; } =\n                !RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ||\n                Environment.GetEnvironmentVariable(\"SYSTEM_DRAWING_COMMON_FORCE_X11\") != null;\n\n            private static IntPtr LoadNativeLibrary()\n            {\n                string libraryName;\n\n                IntPtr lib = IntPtr.Zero;\n                if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))\n                {\n                    libraryName = \"libgdiplus.dylib\";\n                    lib = Interop.Libdl.dlopen(libraryName, Interop.Libdl.RTLD_NOW);\n                }\n                else\n                {\n                    // Various Unix package managers have chosen different names for the \"libgdiplus\" shared library.\n                    // The mono project, where libgdiplus originated, allowed both of the names below to be used, via\n                    // a global configuration setting. We prefer the \"unversioned\" shared object name, and fallback to\n                    // the name suffixed with \".0\".\n                    libraryName = \"libgdiplus.so\";\n                    lib = Interop.Libdl.dlopen(libraryName, Interop.Libdl.RTLD_NOW);\n                    if (lib == IntPtr.Zero)\n                    {\n                        lib = Interop.Libdl.dlopen(\"libgdiplus.so.0\", Interop.Libdl.RTLD_NOW);\n                    }\n                }\n\n                // If we couldn't find libgdiplus in the system search path, try to look for libgdiplus in the\n                // NuGet package folders. This matches the DllImport behavior.\n                if (lib == IntPtr.Zero)\n                {\n                    string[] searchDirectories = ((string)AppContext.GetData(\"NATIVE_DLL_SEARCH_DIRECTORIES\")).Split(':');\n\n                    foreach (var searchDirectory in searchDirectories)\n                    {\n                        var searchPath = Path.Combine(searchDirectory, libraryName);\n\n                        lib = Interop.Libdl.dlopen(searchPath, Interop.Libdl.RTLD_NOW);\n\n                        if (lib != IntPtr.Zero)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                // This function may return a null handle. If it does, individual functions loaded from it will throw a DllNotFoundException,\n                // but not until an attempt is made to actually use the function (rather than load it). This matches how PInvokes behave.\n                return lib;\n            }\n\n            private static IntPtr LoadFunctionPointer(IntPtr nativeLibraryHandle, string functionName) => Interop.Libdl.dlsym(nativeLibraryHandle, functionName);\n\n            private static void PlatformInitialize()\n            {\n                LoadFunctionPointers();\n            }\n\n            private static void LoadFunctionPointers()\n            {\n                GdiplusStartup_ptr = FunctionWrapper.Load<GdiplusStartup_delegate>(s_gdipModule, \"GdiplusStartup\", LibraryName);\n                GdiplusShutdown_ptr = FunctionWrapper.Load<GdiplusShutdown_delegate>(s_gdipModule, \"GdiplusShutdown\", LibraryName);\n                GdipAlloc_ptr = FunctionWrapper.Load<GdipAlloc_delegate>(s_gdipModule, \"GdipAlloc\", LibraryName);\n                GdipFree_ptr = FunctionWrapper.Load<GdipFree_delegate>(s_gdipModule, \"GdipFree\", LibraryName);\n                GdipDeleteBrush_ptr = FunctionWrapper.Load<GdipDeleteBrush_delegate>(s_gdipModule, \"GdipDeleteBrush\", LibraryName);\n                GdipGetBrushType_ptr = FunctionWrapper.Load<GdipGetBrushType_delegate>(s_gdipModule, \"GdipGetBrushType\", LibraryName);\n                GdipCreateFromHDC_ptr = FunctionWrapper.Load<GdipCreateFromHDC_delegate>(s_gdipModule, \"GdipCreateFromHDC\", LibraryName);\n                GdipDeleteGraphics_ptr = FunctionWrapper.Load<GdipDeleteGraphics_delegate>(s_gdipModule, \"GdipDeleteGraphics\", LibraryName);\n                GdipRestoreGraphics_ptr = FunctionWrapper.Load<GdipRestoreGraphics_delegate>(s_gdipModule, \"GdipRestoreGraphics\", LibraryName);\n                GdipSaveGraphics_ptr = FunctionWrapper.Load<GdipSaveGraphics_delegate>(s_gdipModule, \"GdipSaveGraphics\", LibraryName);\n                GdipDrawArc_ptr = FunctionWrapper.Load<GdipDrawArc_delegate>(s_gdipModule, \"GdipDrawArc\", LibraryName);\n                GdipDrawArcI_ptr = FunctionWrapper.Load<GdipDrawArcI_delegate>(s_gdipModule, \"GdipDrawArcI\", LibraryName);\n                GdipDrawBezier_ptr = FunctionWrapper.Load<GdipDrawBezier_delegate>(s_gdipModule, \"GdipDrawBezier\", LibraryName);\n                GdipDrawBezierI_ptr = FunctionWrapper.Load<GdipDrawBezierI_delegate>(s_gdipModule, \"GdipDrawBezierI\", LibraryName);\n                GdipDrawEllipseI_ptr = FunctionWrapper.Load<GdipDrawEllipseI_delegate>(s_gdipModule, \"GdipDrawEllipseI\", LibraryName);\n                GdipDrawEllipse_ptr = FunctionWrapper.Load<GdipDrawEllipse_delegate>(s_gdipModule, \"GdipDrawEllipse\", LibraryName);\n                GdipDrawLine_ptr = FunctionWrapper.Load<GdipDrawLine_delegate>(s_gdipModule, \"GdipDrawLine\", LibraryName);\n                GdipDrawLineI_ptr = FunctionWrapper.Load<GdipDrawLineI_delegate>(s_gdipModule, \"GdipDrawLineI\", LibraryName);\n                GdipDrawLines_ptr = FunctionWrapper.Load<GdipDrawLines_delegate>(s_gdipModule, \"GdipDrawLines\", LibraryName);\n                GdipDrawLinesI_ptr = FunctionWrapper.Load<GdipDrawLinesI_delegate>(s_gdipModule, \"GdipDrawLinesI\", LibraryName);\n                GdipDrawPath_ptr = FunctionWrapper.Load<GdipDrawPath_delegate>(s_gdipModule, \"GdipDrawPath\", LibraryName);\n                GdipDrawPie_ptr = FunctionWrapper.Load<GdipDrawPie_delegate>(s_gdipModule, \"GdipDrawPie\", LibraryName);\n                GdipDrawPieI_ptr = FunctionWrapper.Load<GdipDrawPieI_delegate>(s_gdipModule, \"GdipDrawPieI\", LibraryName);\n                GdipDrawPolygon_ptr = FunctionWrapper.Load<GdipDrawPolygon_delegate>(s_gdipModule, \"GdipDrawPolygon\", LibraryName);\n                GdipDrawPolygonI_ptr = FunctionWrapper.Load<GdipDrawPolygonI_delegate>(s_gdipModule, \"GdipDrawPolygonI\", LibraryName);\n                GdipDrawRectangle_ptr = FunctionWrapper.Load<GdipDrawRectangle_delegate>(s_gdipModule, \"GdipDrawRectangle\", LibraryName);\n                GdipDrawRectangleI_ptr = FunctionWrapper.Load<GdipDrawRectangleI_delegate>(s_gdipModule, \"GdipDrawRectangleI\", LibraryName);\n                GdipDrawRectangles_ptr = FunctionWrapper.Load<GdipDrawRectangles_delegate>(s_gdipModule, \"GdipDrawRectangles\", LibraryName);\n                GdipDrawRectanglesI_ptr = FunctionWrapper.Load<GdipDrawRectanglesI_delegate>(s_gdipModule, \"GdipDrawRectanglesI\", LibraryName);\n                GdipFillEllipseI_ptr = FunctionWrapper.Load<GdipFillEllipseI_delegate>(s_gdipModule, \"GdipFillEllipseI\", LibraryName);\n                GdipFillEllipse_ptr = FunctionWrapper.Load<GdipFillEllipse_delegate>(s_gdipModule, \"GdipFillEllipse\", LibraryName);\n                GdipFillPolygon_ptr = FunctionWrapper.Load<GdipFillPolygon_delegate>(s_gdipModule, \"GdipFillPolygon\", LibraryName);\n                GdipFillPolygonI_ptr = FunctionWrapper.Load<GdipFillPolygonI_delegate>(s_gdipModule, \"GdipFillPolygonI\", LibraryName);\n                GdipFillPolygon2_ptr = FunctionWrapper.Load<GdipFillPolygon2_delegate>(s_gdipModule, \"GdipFillPolygon2\", LibraryName);\n                GdipFillPolygon2I_ptr = FunctionWrapper.Load<GdipFillPolygon2I_delegate>(s_gdipModule, \"GdipFillPolygon2I\", LibraryName);\n                GdipFillRectangle_ptr = FunctionWrapper.Load<GdipFillRectangle_delegate>(s_gdipModule, \"GdipFillRectangle\", LibraryName);\n                GdipFillRectangleI_ptr = FunctionWrapper.Load<GdipFillRectangleI_delegate>(s_gdipModule, \"GdipFillRectangleI\", LibraryName);\n                GdipFillRectangles_ptr = FunctionWrapper.Load<GdipFillRectangles_delegate>(s_gdipModule, \"GdipFillRectangles\", LibraryName);\n                GdipFillRectanglesI_ptr = FunctionWrapper.Load<GdipFillRectanglesI_delegate>(s_gdipModule, \"GdipFillRectanglesI\", LibraryName);\n                GdipDrawString_ptr = FunctionWrapper.Load<GdipDrawString_delegate>(s_gdipModule, \"GdipDrawString\", LibraryName);\n                GdipGetDC_ptr = FunctionWrapper.Load<GdipGetDC_delegate>(s_gdipModule, \"GdipGetDC\", LibraryName);\n                GdipReleaseDC_ptr = FunctionWrapper.Load<GdipReleaseDC_delegate>(s_gdipModule, \"GdipReleaseDC\", LibraryName);\n                GdipDrawImageRectI_ptr = FunctionWrapper.Load<GdipDrawImageRectI_delegate>(s_gdipModule, \"GdipDrawImageRectI\", LibraryName);\n                GdipGetRenderingOrigin_ptr = FunctionWrapper.Load<GdipGetRenderingOrigin_delegate>(s_gdipModule, \"GdipGetRenderingOrigin\", LibraryName);\n                GdipSetRenderingOrigin_ptr = FunctionWrapper.Load<GdipSetRenderingOrigin_delegate>(s_gdipModule, \"GdipSetRenderingOrigin\", LibraryName);\n                GdipGraphicsClear_ptr = FunctionWrapper.Load<GdipGraphicsClear_delegate>(s_gdipModule, \"GdipGraphicsClear\", LibraryName);\n                GdipDrawClosedCurve_ptr = FunctionWrapper.Load<GdipDrawClosedCurve_delegate>(s_gdipModule, \"GdipDrawClosedCurve\", LibraryName);\n                GdipDrawClosedCurveI_ptr = FunctionWrapper.Load<GdipDrawClosedCurveI_delegate>(s_gdipModule, \"GdipDrawClosedCurveI\", LibraryName);\n                GdipDrawClosedCurve2_ptr = FunctionWrapper.Load<GdipDrawClosedCurve2_delegate>(s_gdipModule, \"GdipDrawClosedCurve2\", LibraryName);\n                GdipDrawClosedCurve2I_ptr = FunctionWrapper.Load<GdipDrawClosedCurve2I_delegate>(s_gdipModule, \"GdipDrawClosedCurve2I\", LibraryName);\n                GdipDrawCurve_ptr = FunctionWrapper.Load<GdipDrawCurve_delegate>(s_gdipModule, \"GdipDrawCurve\", LibraryName);\n                GdipDrawCurveI_ptr = FunctionWrapper.Load<GdipDrawCurveI_delegate>(s_gdipModule, \"GdipDrawCurveI\", LibraryName);\n                GdipDrawCurve2_ptr = FunctionWrapper.Load<GdipDrawCurve2_delegate>(s_gdipModule, \"GdipDrawCurve2\", LibraryName);\n                GdipDrawCurve2I_ptr = FunctionWrapper.Load<GdipDrawCurve2I_delegate>(s_gdipModule, \"GdipDrawCurve2I\", LibraryName);\n                GdipDrawCurve3_ptr = FunctionWrapper.Load<GdipDrawCurve3_delegate>(s_gdipModule, \"GdipDrawCurve3\", LibraryName);\n                GdipDrawCurve3I_ptr = FunctionWrapper.Load<GdipDrawCurve3I_delegate>(s_gdipModule, \"GdipDrawCurve3I\", LibraryName);\n                GdipFillClosedCurve_ptr = FunctionWrapper.Load<GdipFillClosedCurve_delegate>(s_gdipModule, \"GdipFillClosedCurve\", LibraryName);\n                GdipFillClosedCurveI_ptr = FunctionWrapper.Load<GdipFillClosedCurveI_delegate>(s_gdipModule, \"GdipFillClosedCurveI\", LibraryName);\n                GdipFillClosedCurve2_ptr = FunctionWrapper.Load<GdipFillClosedCurve2_delegate>(s_gdipModule, \"GdipFillClosedCurve2\", LibraryName);\n                GdipFillClosedCurve2I_ptr = FunctionWrapper.Load<GdipFillClosedCurve2I_delegate>(s_gdipModule, \"GdipFillClosedCurve2I\", LibraryName);\n                GdipFillPie_ptr = FunctionWrapper.Load<GdipFillPie_delegate>(s_gdipModule, \"GdipFillPie\", LibraryName);\n                GdipFillPieI_ptr = FunctionWrapper.Load<GdipFillPieI_delegate>(s_gdipModule, \"GdipFillPieI\", LibraryName);\n                GdipFillPath_ptr = FunctionWrapper.Load<GdipFillPath_delegate>(s_gdipModule, \"GdipFillPath\", LibraryName);\n                GdipGetNearestColor_ptr = FunctionWrapper.Load<GdipGetNearestColor_delegate>(s_gdipModule, \"GdipGetNearestColor\", LibraryName);\n                GdipTransformPoints_ptr = FunctionWrapper.Load<GdipTransformPoints_delegate>(s_gdipModule, \"GdipTransformPoints\", LibraryName);\n                GdipTransformPointsI_ptr = FunctionWrapper.Load<GdipTransformPointsI_delegate>(s_gdipModule, \"GdipTransformPointsI\", LibraryName);\n                GdipSetCompositingMode_ptr = FunctionWrapper.Load<GdipSetCompositingMode_delegate>(s_gdipModule, \"GdipSetCompositingMode\", LibraryName);\n                GdipGetCompositingMode_ptr = FunctionWrapper.Load<GdipGetCompositingMode_delegate>(s_gdipModule, \"GdipGetCompositingMode\", LibraryName);\n                GdipSetCompositingQuality_ptr = FunctionWrapper.Load<GdipSetCompositingQuality_delegate>(s_gdipModule, \"GdipSetCompositingQuality\", LibraryName);\n                GdipGetCompositingQuality_ptr = FunctionWrapper.Load<GdipGetCompositingQuality_delegate>(s_gdipModule, \"GdipGetCompositingQuality\", LibraryName);\n                GdipSetInterpolationMode_ptr = FunctionWrapper.Load<GdipSetInterpolationMode_delegate>(s_gdipModule, \"GdipSetInterpolationMode\", LibraryName);\n                GdipGetInterpolationMode_ptr = FunctionWrapper.Load<GdipGetInterpolationMode_delegate>(s_gdipModule, \"GdipGetInterpolationMode\", LibraryName);\n                GdipGetDpiX_ptr = FunctionWrapper.Load<GdipGetDpiX_delegate>(s_gdipModule, \"GdipGetDpiX\", LibraryName);\n                GdipGetDpiY_ptr = FunctionWrapper.Load<GdipGetDpiY_delegate>(s_gdipModule, \"GdipGetDpiY\", LibraryName);\n                GdipGetPageUnit_ptr = FunctionWrapper.Load<GdipGetPageUnit_delegate>(s_gdipModule, \"GdipGetPageUnit\", LibraryName);\n                GdipGetPageScale_ptr = FunctionWrapper.Load<GdipGetPageScale_delegate>(s_gdipModule, \"GdipGetPageScale\", LibraryName);\n                GdipSetPageUnit_ptr = FunctionWrapper.Load<GdipSetPageUnit_delegate>(s_gdipModule, \"GdipSetPageUnit\", LibraryName);\n                GdipSetPageScale_ptr = FunctionWrapper.Load<GdipSetPageScale_delegate>(s_gdipModule, \"GdipSetPageScale\", LibraryName);\n                GdipSetPixelOffsetMode_ptr = FunctionWrapper.Load<GdipSetPixelOffsetMode_delegate>(s_gdipModule, \"GdipSetPixelOffsetMode\", LibraryName);\n                GdipGetPixelOffsetMode_ptr = FunctionWrapper.Load<GdipGetPixelOffsetMode_delegate>(s_gdipModule, \"GdipGetPixelOffsetMode\", LibraryName);\n                GdipSetSmoothingMode_ptr = FunctionWrapper.Load<GdipSetSmoothingMode_delegate>(s_gdipModule, \"GdipSetSmoothingMode\", LibraryName);\n                GdipGetSmoothingMode_ptr = FunctionWrapper.Load<GdipGetSmoothingMode_delegate>(s_gdipModule, \"GdipGetSmoothingMode\", LibraryName);\n                GdipSetTextContrast_ptr = FunctionWrapper.Load<GdipSetTextContrast_delegate>(s_gdipModule, \"GdipSetTextContrast\", LibraryName);\n                GdipGetTextContrast_ptr = FunctionWrapper.Load<GdipGetTextContrast_delegate>(s_gdipModule, \"GdipGetTextContrast\", LibraryName);\n                GdipSetTextRenderingHint_ptr = FunctionWrapper.Load<GdipSetTextRenderingHint_delegate>(s_gdipModule, \"GdipSetTextRenderingHint\", LibraryName);\n                GdipGetTextRenderingHint_ptr = FunctionWrapper.Load<GdipGetTextRenderingHint_delegate>(s_gdipModule, \"GdipGetTextRenderingHint\", LibraryName);\n                GdipFlush_ptr = FunctionWrapper.Load<GdipFlush_delegate>(s_gdipModule, \"GdipFlush\", LibraryName);\n                GdipAddPathString_ptr = FunctionWrapper.Load<GdipAddPathString_delegate>(s_gdipModule, \"GdipAddPathString\", LibraryName);\n                GdipAddPathStringI_ptr = FunctionWrapper.Load<GdipAddPathStringI_delegate>(s_gdipModule, \"GdipAddPathStringI\", LibraryName);\n                GdipCreateFromHWND_ptr = FunctionWrapper.Load<GdipCreateFromHWND_delegate>(s_gdipModule, \"GdipCreateFromHWND\", LibraryName);\n                GdipMeasureString_ptr = FunctionWrapper.Load<GdipMeasureString_delegate>(s_gdipModule, \"GdipMeasureString\", LibraryName);\n                GdipMeasureCharacterRanges_ptr = FunctionWrapper.Load<GdipMeasureCharacterRanges_delegate>(s_gdipModule, \"GdipMeasureCharacterRanges\", LibraryName);\n                GdipLoadImageFromFile_ptr = FunctionWrapper.Load<GdipLoadImageFromFile_delegate>(s_gdipModule, \"GdipLoadImageFromFile\", LibraryName);\n                GdipCloneImage_ptr = FunctionWrapper.Load<GdipCloneImage_delegate>(s_gdipModule, \"GdipCloneImage\", LibraryName);\n                GdipLoadImageFromFileICM_ptr = FunctionWrapper.Load<GdipLoadImageFromFileICM_delegate>(s_gdipModule, \"GdipLoadImageFromFileICM\", LibraryName);\n                GdipCreateBitmapFromHBITMAP_ptr = FunctionWrapper.Load<GdipCreateBitmapFromHBITMAP_delegate>(s_gdipModule, \"GdipCreateBitmapFromHBITMAP\", LibraryName);\n                GdipDisposeImage_ptr = FunctionWrapper.Load<GdipDisposeImage_delegate>(s_gdipModule, \"GdipDisposeImage\", LibraryName);\n                GdipGetImageFlags_ptr = FunctionWrapper.Load<GdipGetImageFlags_delegate>(s_gdipModule, \"GdipGetImageFlags\", LibraryName);\n                GdipGetImageType_ptr = FunctionWrapper.Load<GdipGetImageType_delegate>(s_gdipModule, \"GdipGetImageType\", LibraryName);\n                GdipImageGetFrameDimensionsCount_ptr = FunctionWrapper.Load<GdipImageGetFrameDimensionsCount_delegate>(s_gdipModule, \"GdipImageGetFrameDimensionsCount\", LibraryName);\n                GdipImageGetFrameDimensionsList_ptr = FunctionWrapper.Load<GdipImageGetFrameDimensionsList_delegate>(s_gdipModule, \"GdipImageGetFrameDimensionsList\", LibraryName);\n                GdipGetImageHeight_ptr = FunctionWrapper.Load<GdipGetImageHeight_delegate>(s_gdipModule, \"GdipGetImageHeight\", LibraryName);\n                GdipGetImageHorizontalResolution_ptr = FunctionWrapper.Load<GdipGetImageHorizontalResolution_delegate>(s_gdipModule, \"GdipGetImageHorizontalResolution\", LibraryName);\n                GdipGetImagePaletteSize_ptr = FunctionWrapper.Load<GdipGetImagePaletteSize_delegate>(s_gdipModule, \"GdipGetImagePaletteSize\", LibraryName);\n                GdipGetImagePalette_ptr = FunctionWrapper.Load<GdipGetImagePalette_delegate>(s_gdipModule, \"GdipGetImagePalette\", LibraryName);\n                GdipSetImagePalette_ptr = FunctionWrapper.Load<GdipSetImagePalette_delegate>(s_gdipModule, \"GdipSetImagePalette\", LibraryName);\n                GdipGetImageDimension_ptr = FunctionWrapper.Load<GdipGetImageDimension_delegate>(s_gdipModule, \"GdipGetImageDimension\", LibraryName);\n                GdipGetImagePixelFormat_ptr = FunctionWrapper.Load<GdipGetImagePixelFormat_delegate>(s_gdipModule, \"GdipGetImagePixelFormat\", LibraryName);\n                GdipGetPropertyCount_ptr = FunctionWrapper.Load<GdipGetPropertyCount_delegate>(s_gdipModule, \"GdipGetPropertyCount\", LibraryName);\n                GdipGetPropertyIdList_ptr = FunctionWrapper.Load<GdipGetPropertyIdList_delegate>(s_gdipModule, \"GdipGetPropertyIdList\", LibraryName);\n                GdipGetPropertySize_ptr = FunctionWrapper.Load<GdipGetPropertySize_delegate>(s_gdipModule, \"GdipGetPropertySize\", LibraryName);\n                GdipGetAllPropertyItems_ptr = FunctionWrapper.Load<GdipGetAllPropertyItems_delegate>(s_gdipModule, \"GdipGetAllPropertyItems\", LibraryName);\n                GdipGetImageRawFormat_ptr = FunctionWrapper.Load<GdipGetImageRawFormat_delegate>(s_gdipModule, \"GdipGetImageRawFormat\", LibraryName);\n                GdipGetImageVerticalResolution_ptr = FunctionWrapper.Load<GdipGetImageVerticalResolution_delegate>(s_gdipModule, \"GdipGetImageVerticalResolution\", LibraryName);\n                GdipGetImageWidth_ptr = FunctionWrapper.Load<GdipGetImageWidth_delegate>(s_gdipModule, \"GdipGetImageWidth\", LibraryName);\n                GdipGetImageBounds_ptr = FunctionWrapper.Load<GdipGetImageBounds_delegate>(s_gdipModule, \"GdipGetImageBounds\", LibraryName);\n                GdipGetEncoderParameterListSize_ptr = FunctionWrapper.Load<GdipGetEncoderParameterListSize_delegate>(s_gdipModule, \"GdipGetEncoderParameterListSize\", LibraryName);\n                GdipGetEncoderParameterList_ptr = FunctionWrapper.Load<GdipGetEncoderParameterList_delegate>(s_gdipModule, \"GdipGetEncoderParameterList\", LibraryName);\n                GdipImageGetFrameCount_ptr = FunctionWrapper.Load<GdipImageGetFrameCount_delegate>(s_gdipModule, \"GdipImageGetFrameCount\", LibraryName);\n                GdipImageSelectActiveFrame_ptr = FunctionWrapper.Load<GdipImageSelectActiveFrame_delegate>(s_gdipModule, \"GdipImageSelectActiveFrame\", LibraryName);\n                GdipGetPropertyItemSize_ptr = FunctionWrapper.Load<GdipGetPropertyItemSize_delegate>(s_gdipModule, \"GdipGetPropertyItemSize\", LibraryName);\n                GdipGetPropertyItem_ptr = FunctionWrapper.Load<GdipGetPropertyItem_delegate>(s_gdipModule, \"GdipGetPropertyItem\", LibraryName);\n                GdipRemovePropertyItem_ptr = FunctionWrapper.Load<GdipRemovePropertyItem_delegate>(s_gdipModule, \"GdipRemovePropertyItem\", LibraryName);\n                GdipSetPropertyItem_ptr = FunctionWrapper.Load<GdipSetPropertyItem_delegate>(s_gdipModule, \"GdipSetPropertyItem\", LibraryName);\n                GdipGetImageThumbnail_ptr = FunctionWrapper.Load<GdipGetImageThumbnail_delegate>(s_gdipModule, \"GdipGetImageThumbnail\", LibraryName);\n                GdipImageRotateFlip_ptr = FunctionWrapper.Load<GdipImageRotateFlip_delegate>(s_gdipModule, \"GdipImageRotateFlip\", LibraryName);\n                GdipSaveImageToFile_ptr = FunctionWrapper.Load<GdipSaveImageToFile_delegate>(s_gdipModule, \"GdipSaveImageToFile\", LibraryName);\n                GdipSaveAdd_ptr = FunctionWrapper.Load<GdipSaveAdd_delegate>(s_gdipModule, \"GdipSaveAdd\", LibraryName);\n                GdipSaveAddImage_ptr = FunctionWrapper.Load<GdipSaveAddImage_delegate>(s_gdipModule, \"GdipSaveAddImage\", LibraryName);\n                GdipDrawImageI_ptr = FunctionWrapper.Load<GdipDrawImageI_delegate>(s_gdipModule, \"GdipDrawImageI\", LibraryName);\n                GdipGetImageGraphicsContext_ptr = FunctionWrapper.Load<GdipGetImageGraphicsContext_delegate>(s_gdipModule, \"GdipGetImageGraphicsContext\", LibraryName);\n                GdipDrawImage_ptr = FunctionWrapper.Load<GdipDrawImage_delegate>(s_gdipModule, \"GdipDrawImage\", LibraryName);\n                GdipDrawImagePoints_ptr = FunctionWrapper.Load<GdipDrawImagePoints_delegate>(s_gdipModule, \"GdipDrawImagePoints\", LibraryName);\n                GdipDrawImagePointsI_ptr = FunctionWrapper.Load<GdipDrawImagePointsI_delegate>(s_gdipModule, \"GdipDrawImagePointsI\", LibraryName);\n                GdipDrawImageRectRectI_ptr = FunctionWrapper.Load<GdipDrawImageRectRectI_delegate>(s_gdipModule, \"GdipDrawImageRectRectI\", LibraryName);\n                GdipDrawImageRectRect_ptr = FunctionWrapper.Load<GdipDrawImageRectRect_delegate>(s_gdipModule, \"GdipDrawImageRectRect\", LibraryName);\n                GdipDrawImagePointsRectI_ptr = FunctionWrapper.Load<GdipDrawImagePointsRectI_delegate>(s_gdipModule, \"GdipDrawImagePointsRectI\", LibraryName);\n                GdipDrawImagePointsRect_ptr = FunctionWrapper.Load<GdipDrawImagePointsRect_delegate>(s_gdipModule, \"GdipDrawImagePointsRect\", LibraryName);\n                GdipDrawImageRect_ptr = FunctionWrapper.Load<GdipDrawImageRect_delegate>(s_gdipModule, \"GdipDrawImageRect\", LibraryName);\n                GdipDrawImagePointRect_ptr = FunctionWrapper.Load<GdipDrawImagePointRect_delegate>(s_gdipModule, \"GdipDrawImagePointRect\", LibraryName);\n                GdipDrawImagePointRectI_ptr = FunctionWrapper.Load<GdipDrawImagePointRectI_delegate>(s_gdipModule, \"GdipDrawImagePointRectI\", LibraryName);\n                GdipCreatePath_ptr = FunctionWrapper.Load<GdipCreatePath_delegate>(s_gdipModule, \"GdipCreatePath\", LibraryName);\n                GdipCreatePath2_ptr = FunctionWrapper.Load<GdipCreatePath2_delegate>(s_gdipModule, \"GdipCreatePath2\", LibraryName);\n                GdipCreatePath2I_ptr = FunctionWrapper.Load<GdipCreatePath2I_delegate>(s_gdipModule, \"GdipCreatePath2I\", LibraryName);\n                GdipClonePath_ptr = FunctionWrapper.Load<GdipClonePath_delegate>(s_gdipModule, \"GdipClonePath\", LibraryName);\n                GdipDeletePath_ptr = FunctionWrapper.Load<GdipDeletePath_delegate>(s_gdipModule, \"GdipDeletePath\", LibraryName);\n                GdipResetPath_ptr = FunctionWrapper.Load<GdipResetPath_delegate>(s_gdipModule, \"GdipResetPath\", LibraryName);\n                GdipGetPointCount_ptr = FunctionWrapper.Load<GdipGetPointCount_delegate>(s_gdipModule, \"GdipGetPointCount\", LibraryName);\n                GdipGetPathTypes_ptr = FunctionWrapper.Load<GdipGetPathTypes_delegate>(s_gdipModule, \"GdipGetPathTypes\", LibraryName);\n                GdipGetPathPoints_ptr = FunctionWrapper.Load<GdipGetPathPoints_delegate>(s_gdipModule, \"GdipGetPathPoints\", LibraryName);\n                GdipGetPathPointsI_ptr = FunctionWrapper.Load<GdipGetPathPointsI_delegate>(s_gdipModule, \"GdipGetPathPointsI\", LibraryName);\n                GdipGetPathFillMode_ptr = FunctionWrapper.Load<GdipGetPathFillMode_delegate>(s_gdipModule, \"GdipGetPathFillMode\", LibraryName);\n                GdipSetPathFillMode_ptr = FunctionWrapper.Load<GdipSetPathFillMode_delegate>(s_gdipModule, \"GdipSetPathFillMode\", LibraryName);\n                GdipStartPathFigure_ptr = FunctionWrapper.Load<GdipStartPathFigure_delegate>(s_gdipModule, \"GdipStartPathFigure\", LibraryName);\n                GdipClosePathFigure_ptr = FunctionWrapper.Load<GdipClosePathFigure_delegate>(s_gdipModule, \"GdipClosePathFigure\", LibraryName);\n                GdipClosePathFigures_ptr = FunctionWrapper.Load<GdipClosePathFigures_delegate>(s_gdipModule, \"GdipClosePathFigures\", LibraryName);\n                GdipSetPathMarker_ptr = FunctionWrapper.Load<GdipSetPathMarker_delegate>(s_gdipModule, \"GdipSetPathMarker\", LibraryName);\n                GdipClearPathMarkers_ptr = FunctionWrapper.Load<GdipClearPathMarkers_delegate>(s_gdipModule, \"GdipClearPathMarkers\", LibraryName);\n                GdipReversePath_ptr = FunctionWrapper.Load<GdipReversePath_delegate>(s_gdipModule, \"GdipReversePath\", LibraryName);\n                GdipGetPathLastPoint_ptr = FunctionWrapper.Load<GdipGetPathLastPoint_delegate>(s_gdipModule, \"GdipGetPathLastPoint\", LibraryName);\n                GdipAddPathLine_ptr = FunctionWrapper.Load<GdipAddPathLine_delegate>(s_gdipModule, \"GdipAddPathLine\", LibraryName);\n                GdipAddPathLine2_ptr = FunctionWrapper.Load<GdipAddPathLine2_delegate>(s_gdipModule, \"GdipAddPathLine2\", LibraryName);\n                GdipAddPathLine2I_ptr = FunctionWrapper.Load<GdipAddPathLine2I_delegate>(s_gdipModule, \"GdipAddPathLine2I\", LibraryName);\n                GdipAddPathArc_ptr = FunctionWrapper.Load<GdipAddPathArc_delegate>(s_gdipModule, \"GdipAddPathArc\", LibraryName);\n                GdipAddPathBezier_ptr = FunctionWrapper.Load<GdipAddPathBezier_delegate>(s_gdipModule, \"GdipAddPathBezier\", LibraryName);\n                GdipAddPathBeziers_ptr = FunctionWrapper.Load<GdipAddPathBeziers_delegate>(s_gdipModule, \"GdipAddPathBeziers\", LibraryName);\n                GdipAddPathCurve_ptr = FunctionWrapper.Load<GdipAddPathCurve_delegate>(s_gdipModule, \"GdipAddPathCurve\", LibraryName);\n                GdipAddPathCurveI_ptr = FunctionWrapper.Load<GdipAddPathCurveI_delegate>(s_gdipModule, \"GdipAddPathCurveI\", LibraryName);\n                GdipAddPathCurve2_ptr = FunctionWrapper.Load<GdipAddPathCurve2_delegate>(s_gdipModule, \"GdipAddPathCurve2\", LibraryName);\n                GdipAddPathCurve2I_ptr = FunctionWrapper.Load<GdipAddPathCurve2I_delegate>(s_gdipModule, \"GdipAddPathCurve2I\", LibraryName);\n                GdipAddPathCurve3_ptr = FunctionWrapper.Load<GdipAddPathCurve3_delegate>(s_gdipModule, \"GdipAddPathCurve3\", LibraryName);\n                GdipAddPathCurve3I_ptr = FunctionWrapper.Load<GdipAddPathCurve3I_delegate>(s_gdipModule, \"GdipAddPathCurve3I\", LibraryName);\n                GdipAddPathClosedCurve_ptr = FunctionWrapper.Load<GdipAddPathClosedCurve_delegate>(s_gdipModule, \"GdipAddPathClosedCurve\", LibraryName);\n                GdipAddPathClosedCurveI_ptr = FunctionWrapper.Load<GdipAddPathClosedCurveI_delegate>(s_gdipModule, \"GdipAddPathClosedCurveI\", LibraryName);\n                GdipAddPathClosedCurve2_ptr = FunctionWrapper.Load<GdipAddPathClosedCurve2_delegate>(s_gdipModule, \"GdipAddPathClosedCurve2\", LibraryName);\n                GdipAddPathClosedCurve2I_ptr = FunctionWrapper.Load<GdipAddPathClosedCurve2I_delegate>(s_gdipModule, \"GdipAddPathClosedCurve2I\", LibraryName);\n                GdipAddPathRectangle_ptr = FunctionWrapper.Load<GdipAddPathRectangle_delegate>(s_gdipModule, \"GdipAddPathRectangle\", LibraryName);\n                GdipAddPathRectangles_ptr = FunctionWrapper.Load<GdipAddPathRectangles_delegate>(s_gdipModule, \"GdipAddPathRectangles\", LibraryName);\n                GdipAddPathEllipse_ptr = FunctionWrapper.Load<GdipAddPathEllipse_delegate>(s_gdipModule, \"GdipAddPathEllipse\", LibraryName);\n                GdipAddPathEllipseI_ptr = FunctionWrapper.Load<GdipAddPathEllipseI_delegate>(s_gdipModule, \"GdipAddPathEllipseI\", LibraryName);\n                GdipAddPathPie_ptr = FunctionWrapper.Load<GdipAddPathPie_delegate>(s_gdipModule, \"GdipAddPathPie\", LibraryName);\n                GdipAddPathPieI_ptr = FunctionWrapper.Load<GdipAddPathPieI_delegate>(s_gdipModule, \"GdipAddPathPieI\", LibraryName);\n                GdipAddPathPolygon_ptr = FunctionWrapper.Load<GdipAddPathPolygon_delegate>(s_gdipModule, \"GdipAddPathPolygon\", LibraryName);\n                GdipAddPathPath_ptr = FunctionWrapper.Load<GdipAddPathPath_delegate>(s_gdipModule, \"GdipAddPathPath\", LibraryName);\n                GdipAddPathLineI_ptr = FunctionWrapper.Load<GdipAddPathLineI_delegate>(s_gdipModule, \"GdipAddPathLineI\", LibraryName);\n                GdipAddPathArcI_ptr = FunctionWrapper.Load<GdipAddPathArcI_delegate>(s_gdipModule, \"GdipAddPathArcI\", LibraryName);\n                GdipAddPathBezierI_ptr = FunctionWrapper.Load<GdipAddPathBezierI_delegate>(s_gdipModule, \"GdipAddPathBezierI\", LibraryName);\n                GdipAddPathBeziersI_ptr = FunctionWrapper.Load<GdipAddPathBeziersI_delegate>(s_gdipModule, \"GdipAddPathBeziersI\", LibraryName);\n                GdipAddPathPolygonI_ptr = FunctionWrapper.Load<GdipAddPathPolygonI_delegate>(s_gdipModule, \"GdipAddPathPolygonI\", LibraryName);\n                GdipAddPathRectangleI_ptr = FunctionWrapper.Load<GdipAddPathRectangleI_delegate>(s_gdipModule, \"GdipAddPathRectangleI\", LibraryName);\n                GdipAddPathRectanglesI_ptr = FunctionWrapper.Load<GdipAddPathRectanglesI_delegate>(s_gdipModule, \"GdipAddPathRectanglesI\", LibraryName);\n                GdipFlattenPath_ptr = FunctionWrapper.Load<GdipFlattenPath_delegate>(s_gdipModule, \"GdipFlattenPath\", LibraryName);\n                GdipTransformPath_ptr = FunctionWrapper.Load<GdipTransformPath_delegate>(s_gdipModule, \"GdipTransformPath\", LibraryName);\n                GdipWarpPath_ptr = FunctionWrapper.Load<GdipWarpPath_delegate>(s_gdipModule, \"GdipWarpPath\", LibraryName);\n                GdipWidenPath_ptr = FunctionWrapper.Load<GdipWidenPath_delegate>(s_gdipModule, \"GdipWidenPath\", LibraryName);\n                GdipGetPathWorldBounds_ptr = FunctionWrapper.Load<GdipGetPathWorldBounds_delegate>(s_gdipModule, \"GdipGetPathWorldBounds\", LibraryName);\n                GdipGetPathWorldBoundsI_ptr = FunctionWrapper.Load<GdipGetPathWorldBoundsI_delegate>(s_gdipModule, \"GdipGetPathWorldBoundsI\", LibraryName);\n                GdipIsVisiblePathPoint_ptr = FunctionWrapper.Load<GdipIsVisiblePathPoint_delegate>(s_gdipModule, \"GdipIsVisiblePathPoint\", LibraryName);\n                GdipIsVisiblePathPointI_ptr = FunctionWrapper.Load<GdipIsVisiblePathPointI_delegate>(s_gdipModule, \"GdipIsVisiblePathPointI\", LibraryName);\n                GdipIsOutlineVisiblePathPoint_ptr = FunctionWrapper.Load<GdipIsOutlineVisiblePathPoint_delegate>(s_gdipModule, \"GdipIsOutlineVisiblePathPoint\", LibraryName);\n                GdipIsOutlineVisiblePathPointI_ptr = FunctionWrapper.Load<GdipIsOutlineVisiblePathPointI_delegate>(s_gdipModule, \"GdipIsOutlineVisiblePathPointI\", LibraryName);\n                GdipCreateFont_ptr = FunctionWrapper.Load<GdipCreateFont_delegate>(s_gdipModule, \"GdipCreateFont\", LibraryName);\n                GdipDeleteFont_ptr = FunctionWrapper.Load<GdipDeleteFont_delegate>(s_gdipModule, \"GdipDeleteFont\", LibraryName);\n                GdipGetLogFont_ptr = FunctionWrapper.Load<GdipGetLogFont_delegate>(s_gdipModule, \"GdipGetLogFontW\", LibraryName);\n                GdipCreateFontFromDC_ptr = FunctionWrapper.Load<GdipCreateFontFromDC_delegate>(s_gdipModule, \"GdipCreateFontFromDC\", LibraryName);\n                GdipCreateFontFromLogfont_ptr = FunctionWrapper.Load<GdipCreateFontFromLogfont_delegate>(s_gdipModule, \"GdipCreateFontFromLogfontW\", LibraryName);\n                GdipCreateFontFromHfont_ptr = FunctionWrapper.Load<GdipCreateFontFromHfont_delegate>(s_gdipModule, \"GdipCreateFontFromHfontA\", LibraryName);\n                GdipGetFontSize_ptr = FunctionWrapper.Load<GdipGetFontSize_delegate>(s_gdipModule, \"GdipGetFontSize\", LibraryName);\n                GdipGetFontHeight_ptr = FunctionWrapper.Load<GdipGetFontHeight_delegate>(s_gdipModule, \"GdipGetFontHeight\", LibraryName);\n                GdipGetFontHeightGivenDPI_ptr = FunctionWrapper.Load<GdipGetFontHeightGivenDPI_delegate>(s_gdipModule, \"GdipGetFontHeightGivenDPI\", LibraryName);\n                GdipCreateMetafileFromFile_ptr = FunctionWrapper.Load<GdipCreateMetafileFromFile_delegate>(s_gdipModule, \"GdipCreateMetafileFromFile\", LibraryName);\n                GdipCreateMetafileFromEmf_ptr = FunctionWrapper.Load<GdipCreateMetafileFromEmf_delegate>(s_gdipModule, \"GdipCreateMetafileFromEmf\", LibraryName);\n                GdipCreateMetafileFromWmf_ptr = FunctionWrapper.Load<GdipCreateMetafileFromWmf_delegate>(s_gdipModule, \"GdipCreateMetafileFromWmf\", LibraryName);\n                GdipGetMetafileHeaderFromFile_ptr = FunctionWrapper.Load<GdipGetMetafileHeaderFromFile_delegate>(s_gdipModule, \"GdipGetMetafileHeaderFromFile\", LibraryName);\n                GdipGetMetafileHeaderFromMetafile_ptr = FunctionWrapper.Load<GdipGetMetafileHeaderFromMetafile_delegate>(s_gdipModule, \"GdipGetMetafileHeaderFromMetafile\", LibraryName);\n                GdipGetMetafileHeaderFromEmf_ptr = FunctionWrapper.Load<GdipGetMetafileHeaderFromEmf_delegate>(s_gdipModule, \"GdipGetMetafileHeaderFromEmf\", LibraryName);\n                GdipGetMetafileHeaderFromWmf_ptr = FunctionWrapper.Load<GdipGetMetafileHeaderFromWmf_delegate>(s_gdipModule, \"GdipGetMetafileHeaderFromWmf\", LibraryName);\n                GdipGetHemfFromMetafile_ptr = FunctionWrapper.Load<GdipGetHemfFromMetafile_delegate>(s_gdipModule, \"GdipGetHemfFromMetafile\", LibraryName);\n                GdipGetMetafileDownLevelRasterizationLimit_ptr = FunctionWrapper.Load<GdipGetMetafileDownLevelRasterizationLimit_delegate>(s_gdipModule, \"GdipGetMetafileDownLevelRasterizationLimit\", LibraryName);\n                GdipSetMetafileDownLevelRasterizationLimit_ptr = FunctionWrapper.Load<GdipSetMetafileDownLevelRasterizationLimit_delegate>(s_gdipModule, \"GdipSetMetafileDownLevelRasterizationLimit\", LibraryName);\n                GdipPlayMetafileRecord_ptr = FunctionWrapper.Load<GdipPlayMetafileRecord_delegate>(s_gdipModule, \"GdipPlayMetafileRecord\", LibraryName);\n                GdipRecordMetafile_ptr = FunctionWrapper.Load<GdipRecordMetafile_delegate>(s_gdipModule, \"GdipRecordMetafile\", LibraryName);\n                GdipRecordMetafileI_ptr = FunctionWrapper.Load<GdipRecordMetafileI_delegate>(s_gdipModule, \"GdipRecordMetafileI\", LibraryName);\n                GdipRecordMetafileFileName_ptr = FunctionWrapper.Load<GdipRecordMetafileFileName_delegate>(s_gdipModule, \"GdipRecordMetafileFileName\", LibraryName);\n                GdipRecordMetafileFileNameI_ptr = FunctionWrapper.Load<GdipRecordMetafileFileNameI_delegate>(s_gdipModule, \"GdipRecordMetafileFileNameI\", LibraryName);\n                GdipCreateFromContext_macosx_ptr = FunctionWrapper.Load<GdipCreateFromContext_macosx_delegate>(s_gdipModule, \"GdipCreateFromContext_macosx\", LibraryName);\n                GdipSetVisibleClip_linux_ptr = FunctionWrapper.Load<GdipSetVisibleClip_linux_delegate>(s_gdipModule, \"GdipSetVisibleClip_linux\", LibraryName);\n                GdipCreateFromXDrawable_linux_ptr = FunctionWrapper.Load<GdipCreateFromXDrawable_linux_delegate>(s_gdipModule, \"GdipCreateFromXDrawable_linux\", LibraryName);\n                GdipLoadImageFromDelegate_linux_ptr = FunctionWrapper.Load<GdipLoadImageFromDelegate_linux_delegate>(s_gdipModule, \"GdipLoadImageFromDelegate_linux\", LibraryName);\n                GdipSaveImageToDelegate_linux_ptr = FunctionWrapper.Load<GdipSaveImageToDelegate_linux_delegate>(s_gdipModule, \"GdipSaveImageToDelegate_linux\", LibraryName);\n                GdipCreateMetafileFromDelegate_linux_ptr = FunctionWrapper.Load<GdipCreateMetafileFromDelegate_linux_delegate>(s_gdipModule, \"GdipCreateMetafileFromDelegate_linux\", LibraryName);\n                GdipGetMetafileHeaderFromDelegate_linux_ptr = FunctionWrapper.Load<GdipGetMetafileHeaderFromDelegate_linux_delegate>(s_gdipModule, \"GdipGetMetafileHeaderFromDelegate_linux\", LibraryName);\n                GdipRecordMetafileFromDelegate_linux_ptr = FunctionWrapper.Load<GdipRecordMetafileFromDelegate_linux_delegate>(s_gdipModule, \"GdipRecordMetafileFromDelegate_linux\", LibraryName);\n                GdipRecordMetafileFromDelegateI_linux_ptr = FunctionWrapper.Load<GdipRecordMetafileFromDelegateI_linux_delegate>(s_gdipModule, \"GdipRecordMetafileFromDelegateI_linux\", LibraryName);\n                GdipGetPostScriptSavePage_ptr = FunctionWrapper.Load<GdipGetPostScriptSavePage_delegate>(s_gdipModule, \"GdipGetPostScriptSavePage\", LibraryName);\n                GdipGetPostScriptGraphicsContext_ptr = FunctionWrapper.Load<GdipGetPostScriptGraphicsContext_delegate>(s_gdipModule, \"GdipGetPostScriptGraphicsContext\", LibraryName);\n            }\n\n            // Imported functions\n\n            private delegate int GdiplusStartup_delegate(out IntPtr token, ref StartupInput input, out StartupOutput output);\n            private static FunctionWrapper<GdiplusStartup_delegate> GdiplusStartup_ptr;\n            internal static int GdiplusStartup(out IntPtr token, ref StartupInput input, out StartupOutput output) => (int)GdiplusStartup_ptr.Delegate(out token, ref input, out output);\n\n            private delegate void GdiplusShutdown_delegate(ref ulong token);\n            private static FunctionWrapper<GdiplusShutdown_delegate> GdiplusShutdown_ptr;\n            internal static void GdiplusShutdown(ref ulong token) => GdiplusShutdown_ptr.Delegate(ref token);\n\n            private delegate IntPtr GdipAlloc_delegate(int size);\n            private static FunctionWrapper<GdipAlloc_delegate> GdipAlloc_ptr;\n            internal static IntPtr GdipAlloc(int size) => GdipAlloc_ptr.Delegate(size);\n\n            private delegate void GdipFree_delegate(IntPtr ptr);\n            private static FunctionWrapper<GdipFree_delegate> GdipFree_ptr;\n            internal static void GdipFree(IntPtr ptr) => GdipFree_ptr.Delegate(ptr);\n\n            private delegate int GdipDeleteBrush_delegate(IntPtr brush);\n            private static FunctionWrapper<GdipDeleteBrush_delegate> GdipDeleteBrush_ptr;\n            internal static int GdipDeleteBrush(IntPtr brush) => GdipDeleteBrush_ptr.Delegate(brush);\n            internal static int IntGdipDeleteBrush(HandleRef brush) => (int)GdipDeleteBrush_ptr.Delegate(brush.Handle);\n\n            private delegate int GdipGetBrushType_delegate(IntPtr brush, out BrushType type);\n            private static FunctionWrapper<GdipGetBrushType_delegate> GdipGetBrushType_ptr;\n            internal static int GdipGetBrushType(IntPtr brush, out BrushType type) => GdipGetBrushType_ptr.Delegate(brush, out type);\n\n            private delegate int GdipCreateFromHDC_delegate(IntPtr hDC, out IntPtr graphics);\n            private static FunctionWrapper<GdipCreateFromHDC_delegate> GdipCreateFromHDC_ptr;\n            internal static int GdipCreateFromHDC(IntPtr hDC, out IntPtr graphics) => GdipCreateFromHDC_ptr.Delegate(hDC, out graphics);\n\n            private delegate int GdipDeleteGraphics_delegate(IntPtr graphics);\n            private static FunctionWrapper<GdipDeleteGraphics_delegate> GdipDeleteGraphics_ptr;\n            internal static int GdipDeleteGraphics(IntPtr graphics) => GdipDeleteGraphics_ptr.Delegate(graphics);\n            internal static int IntGdipDeleteGraphics(HandleRef graphics) => (int)GdipDeleteGraphics_ptr.Delegate(graphics.Handle);\n\n            private delegate int GdipRestoreGraphics_delegate(IntPtr graphics, uint graphicsState);\n            private static FunctionWrapper<GdipRestoreGraphics_delegate> GdipRestoreGraphics_ptr;\n            internal static int GdipRestoreGraphics(IntPtr graphics, uint graphicsState) => GdipRestoreGraphics_ptr.Delegate(graphics, graphicsState);\n\n            private delegate int GdipSaveGraphics_delegate(IntPtr graphics, out uint state);\n            private static FunctionWrapper<GdipSaveGraphics_delegate> GdipSaveGraphics_ptr;\n            internal static int GdipSaveGraphics(IntPtr graphics, out uint state) => GdipSaveGraphics_ptr.Delegate(graphics, out state);\n\n            private delegate int GdipDrawArc_delegate(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipDrawArc_delegate> GdipDrawArc_ptr;\n            internal static int GdipDrawArc(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle) => GdipDrawArc_ptr.Delegate(graphics, pen, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipDrawArcI_delegate(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipDrawArcI_delegate> GdipDrawArcI_ptr;\n            internal static int GdipDrawArcI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle) => GdipDrawArcI_ptr.Delegate(graphics, pen, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipDrawBezier_delegate(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);\n            private static FunctionWrapper<GdipDrawBezier_delegate> GdipDrawBezier_ptr;\n            internal static int GdipDrawBezier(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4) => GdipDrawBezier_ptr.Delegate(graphics, pen, x1, y1, x2, y2, x3, y3, x4, y4);\n\n            private delegate int GdipDrawBezierI_delegate(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);\n            private static FunctionWrapper<GdipDrawBezierI_delegate> GdipDrawBezierI_ptr;\n            internal static int GdipDrawBezierI(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) => GdipDrawBezierI_ptr.Delegate(graphics, pen, x1, y1, x2, y2, x3, y3, x4, y4);\n\n            private delegate int GdipDrawEllipseI_delegate(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipDrawEllipseI_delegate> GdipDrawEllipseI_ptr;\n            internal static int GdipDrawEllipseI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height) => GdipDrawEllipseI_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipDrawEllipse_delegate(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipDrawEllipse_delegate> GdipDrawEllipse_ptr;\n            internal static int GdipDrawEllipse(IntPtr graphics, IntPtr pen, float x, float y, float width, float height) => GdipDrawEllipse_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipDrawLine_delegate(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2);\n            private static FunctionWrapper<GdipDrawLine_delegate> GdipDrawLine_ptr;\n            internal static int GdipDrawLine(IntPtr graphics, IntPtr pen, float x1, float y1, float x2, float y2) => GdipDrawLine_ptr.Delegate(graphics, pen, x1, y1, x2, y2);\n\n            private delegate int GdipDrawLineI_delegate(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2);\n            private static FunctionWrapper<GdipDrawLineI_delegate> GdipDrawLineI_ptr;\n            internal static int GdipDrawLineI(IntPtr graphics, IntPtr pen, int x1, int y1, int x2, int y2) => GdipDrawLineI_ptr.Delegate(graphics, pen, x1, y1, x2, y2);\n\n            private delegate int GdipDrawLines_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count);\n            private static FunctionWrapper<GdipDrawLines_delegate> GdipDrawLines_ptr;\n            internal static int GdipDrawLines(IntPtr graphics, IntPtr pen, PointF[] points, int count) => GdipDrawLines_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawLinesI_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count);\n            private static FunctionWrapper<GdipDrawLinesI_delegate> GdipDrawLinesI_ptr;\n            internal static int GdipDrawLinesI(IntPtr graphics, IntPtr pen, Point[] points, int count) => GdipDrawLinesI_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawPath_delegate(IntPtr graphics, IntPtr pen, IntPtr path);\n            private static FunctionWrapper<GdipDrawPath_delegate> GdipDrawPath_ptr;\n            internal static int GdipDrawPath(IntPtr graphics, IntPtr pen, IntPtr path) => GdipDrawPath_ptr.Delegate(graphics, pen, path);\n\n            private delegate int GdipDrawPie_delegate(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipDrawPie_delegate> GdipDrawPie_ptr;\n            internal static int GdipDrawPie(IntPtr graphics, IntPtr pen, float x, float y, float width, float height, float startAngle, float sweepAngle) => GdipDrawPie_ptr.Delegate(graphics, pen, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipDrawPieI_delegate(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipDrawPieI_delegate> GdipDrawPieI_ptr;\n            internal static int GdipDrawPieI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height, float startAngle, float sweepAngle) => GdipDrawPieI_ptr.Delegate(graphics, pen, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipDrawPolygon_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count);\n            private static FunctionWrapper<GdipDrawPolygon_delegate> GdipDrawPolygon_ptr;\n            internal static int GdipDrawPolygon(IntPtr graphics, IntPtr pen, PointF[] points, int count) => GdipDrawPolygon_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawPolygonI_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count);\n            private static FunctionWrapper<GdipDrawPolygonI_delegate> GdipDrawPolygonI_ptr;\n            internal static int GdipDrawPolygonI(IntPtr graphics, IntPtr pen, Point[] points, int count) => GdipDrawPolygonI_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawRectangle_delegate(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipDrawRectangle_delegate> GdipDrawRectangle_ptr;\n            internal static int GdipDrawRectangle(IntPtr graphics, IntPtr pen, float x, float y, float width, float height) => GdipDrawRectangle_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipDrawRectangleI_delegate(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipDrawRectangleI_delegate> GdipDrawRectangleI_ptr;\n            internal static int GdipDrawRectangleI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height) => GdipDrawRectangleI_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipDrawRectangles_delegate(IntPtr graphics, IntPtr pen, RectangleF[] rects, int count);\n            private static FunctionWrapper<GdipDrawRectangles_delegate> GdipDrawRectangles_ptr;\n            internal static int GdipDrawRectangles(IntPtr graphics, IntPtr pen, RectangleF[] rects, int count) => GdipDrawRectangles_ptr.Delegate(graphics, pen, rects, count);\n\n            private delegate int GdipDrawRectanglesI_delegate(IntPtr graphics, IntPtr pen, Rectangle[] rects, int count);\n            private static FunctionWrapper<GdipDrawRectanglesI_delegate> GdipDrawRectanglesI_ptr;\n            internal static int GdipDrawRectanglesI(IntPtr graphics, IntPtr pen, Rectangle[] rects, int count) => GdipDrawRectanglesI_ptr.Delegate(graphics, pen, rects, count);\n\n            private delegate int GdipFillEllipseI_delegate(IntPtr graphics, IntPtr pen, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipFillEllipseI_delegate> GdipFillEllipseI_ptr;\n            internal static int GdipFillEllipseI(IntPtr graphics, IntPtr pen, int x, int y, int width, int height) => GdipFillEllipseI_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipFillEllipse_delegate(IntPtr graphics, IntPtr pen, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipFillEllipse_delegate> GdipFillEllipse_ptr;\n            internal static int GdipFillEllipse(IntPtr graphics, IntPtr pen, float x, float y, float width, float height) => GdipFillEllipse_ptr.Delegate(graphics, pen, x, y, width, height);\n\n            private delegate int GdipFillPolygon_delegate(IntPtr graphics, IntPtr brush, PointF[] points, int count, FillMode fillMode);\n            private static FunctionWrapper<GdipFillPolygon_delegate> GdipFillPolygon_ptr;\n            internal static int GdipFillPolygon(IntPtr graphics, IntPtr brush, PointF[] points, int count, FillMode fillMode) => GdipFillPolygon_ptr.Delegate(graphics, brush, points, count, fillMode);\n\n            private delegate int GdipFillPolygonI_delegate(IntPtr graphics, IntPtr brush, Point[] points, int count, FillMode fillMode);\n            private static FunctionWrapper<GdipFillPolygonI_delegate> GdipFillPolygonI_ptr;\n            internal static int GdipFillPolygonI(IntPtr graphics, IntPtr brush, Point[] points, int count, FillMode fillMode) => GdipFillPolygonI_ptr.Delegate(graphics, brush, points, count, fillMode);\n\n            private delegate int GdipFillPolygon2_delegate(IntPtr graphics, IntPtr brush, PointF[] points, int count);\n            private static FunctionWrapper<GdipFillPolygon2_delegate> GdipFillPolygon2_ptr;\n            internal static int GdipFillPolygon2(IntPtr graphics, IntPtr brush, PointF[] points, int count) => GdipFillPolygon2_ptr.Delegate(graphics, brush, points, count);\n\n            private delegate int GdipFillPolygon2I_delegate(IntPtr graphics, IntPtr brush, Point[] points, int count);\n            private static FunctionWrapper<GdipFillPolygon2I_delegate> GdipFillPolygon2I_ptr;\n            internal static int GdipFillPolygon2I(IntPtr graphics, IntPtr brush, Point[] points, int count) => GdipFillPolygon2I_ptr.Delegate(graphics, brush, points, count);\n\n            private delegate int GdipFillRectangle_delegate(IntPtr graphics, IntPtr brush, float x1, float y1, float x2, float y2);\n            private static FunctionWrapper<GdipFillRectangle_delegate> GdipFillRectangle_ptr;\n            internal static int GdipFillRectangle(IntPtr graphics, IntPtr brush, float x1, float y1, float x2, float y2) => GdipFillRectangle_ptr.Delegate(graphics, brush, x1, y1, x2, y2);\n\n            private delegate int GdipFillRectangleI_delegate(IntPtr graphics, IntPtr brush, int x1, int y1, int x2, int y2);\n            private static FunctionWrapper<GdipFillRectangleI_delegate> GdipFillRectangleI_ptr;\n            internal static int GdipFillRectangleI(IntPtr graphics, IntPtr brush, int x1, int y1, int x2, int y2) => GdipFillRectangleI_ptr.Delegate(graphics, brush, x1, y1, x2, y2);\n\n            private delegate int GdipFillRectangles_delegate(IntPtr graphics, IntPtr brush, RectangleF[] rects, int count);\n            private static FunctionWrapper<GdipFillRectangles_delegate> GdipFillRectangles_ptr;\n            internal static int GdipFillRectangles(IntPtr graphics, IntPtr brush, RectangleF[] rects, int count) => GdipFillRectangles_ptr.Delegate(graphics, brush, rects, count);\n\n            private delegate int GdipFillRectanglesI_delegate(IntPtr graphics, IntPtr brush, Rectangle[] rects, int count);\n            private static FunctionWrapper<GdipFillRectanglesI_delegate> GdipFillRectanglesI_ptr;\n            internal static int GdipFillRectanglesI(IntPtr graphics, IntPtr brush, Rectangle[] rects, int count) => GdipFillRectanglesI_ptr.Delegate(graphics, brush, rects, count);\n\n            private delegate int GdipDrawString_delegate(IntPtr graphics, [MarshalAs(UnmanagedType.LPWStr)]string text, int len, IntPtr font, ref RectangleF rc, IntPtr format, IntPtr brush);\n            private static FunctionWrapper<GdipDrawString_delegate> GdipDrawString_ptr;\n            internal static int GdipDrawString(IntPtr graphics, string text, int len, IntPtr font, ref RectangleF rc, IntPtr format, IntPtr brush) => GdipDrawString_ptr.Delegate(graphics, text, len, font, ref rc, format, brush);\n\n            private delegate int GdipGetDC_delegate(IntPtr graphics, out IntPtr hdc);\n            private static FunctionWrapper<GdipGetDC_delegate> GdipGetDC_ptr;\n            internal static int GdipGetDC(IntPtr graphics, out IntPtr hdc) => GdipGetDC_ptr.Delegate(graphics, out hdc);\n\n            private delegate int GdipReleaseDC_delegate(IntPtr graphics, IntPtr hdc);\n            private static FunctionWrapper<GdipReleaseDC_delegate> GdipReleaseDC_ptr;\n            internal static int GdipReleaseDC(IntPtr graphics, IntPtr hdc) => GdipReleaseDC_ptr.Delegate(graphics, hdc);\n            internal static int IntGdipReleaseDC(HandleRef graphics, HandleRef hdc) => (int)GdipReleaseDC_ptr.Delegate(graphics.Handle, hdc.Handle);\n\n            private delegate int GdipDrawImageRectI_delegate(IntPtr graphics, IntPtr image, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipDrawImageRectI_delegate> GdipDrawImageRectI_ptr;\n            internal static int GdipDrawImageRectI(IntPtr graphics, IntPtr image, int x, int y, int width, int height) => GdipDrawImageRectI_ptr.Delegate(graphics, image, x, y, width, height);\n\n            private delegate int GdipGetRenderingOrigin_delegate(IntPtr graphics, out int x, out int y);\n            private static FunctionWrapper<GdipGetRenderingOrigin_delegate> GdipGetRenderingOrigin_ptr;\n            internal static int GdipGetRenderingOrigin(IntPtr graphics, out int x, out int y) => GdipGetRenderingOrigin_ptr.Delegate(graphics, out x, out y);\n\n            private delegate int GdipSetRenderingOrigin_delegate(IntPtr graphics, int x, int y);\n            private static FunctionWrapper<GdipSetRenderingOrigin_delegate> GdipSetRenderingOrigin_ptr;\n            internal static int GdipSetRenderingOrigin(IntPtr graphics, int x, int y) => GdipSetRenderingOrigin_ptr.Delegate(graphics, x, y);\n\n            private delegate int GdipGraphicsClear_delegate(IntPtr graphics, int argb);\n            private static FunctionWrapper<GdipGraphicsClear_delegate> GdipGraphicsClear_ptr;\n            internal static int GdipGraphicsClear(IntPtr graphics, int argb) => GdipGraphicsClear_ptr.Delegate(graphics, argb);\n\n            private delegate int GdipDrawClosedCurve_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count);\n            private static FunctionWrapper<GdipDrawClosedCurve_delegate> GdipDrawClosedCurve_ptr;\n            internal static int GdipDrawClosedCurve(IntPtr graphics, IntPtr pen, PointF[] points, int count) => GdipDrawClosedCurve_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawClosedCurveI_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count);\n            private static FunctionWrapper<GdipDrawClosedCurveI_delegate> GdipDrawClosedCurveI_ptr;\n            internal static int GdipDrawClosedCurveI(IntPtr graphics, IntPtr pen, Point[] points, int count) => GdipDrawClosedCurveI_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawClosedCurve2_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension);\n            private static FunctionWrapper<GdipDrawClosedCurve2_delegate> GdipDrawClosedCurve2_ptr;\n            internal static int GdipDrawClosedCurve2(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension) => GdipDrawClosedCurve2_ptr.Delegate(graphics, pen, points, count, tension);\n\n            private delegate int GdipDrawClosedCurve2I_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension);\n            private static FunctionWrapper<GdipDrawClosedCurve2I_delegate> GdipDrawClosedCurve2I_ptr;\n            internal static int GdipDrawClosedCurve2I(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension) => GdipDrawClosedCurve2I_ptr.Delegate(graphics, pen, points, count, tension);\n\n            private delegate int GdipDrawCurve_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count);\n            private static FunctionWrapper<GdipDrawCurve_delegate> GdipDrawCurve_ptr;\n            internal static int GdipDrawCurve(IntPtr graphics, IntPtr pen, PointF[] points, int count) => GdipDrawCurve_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawCurveI_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count);\n            private static FunctionWrapper<GdipDrawCurveI_delegate> GdipDrawCurveI_ptr;\n            internal static int GdipDrawCurveI(IntPtr graphics, IntPtr pen, Point[] points, int count) => GdipDrawCurveI_ptr.Delegate(graphics, pen, points, count);\n\n            private delegate int GdipDrawCurve2_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension);\n            private static FunctionWrapper<GdipDrawCurve2_delegate> GdipDrawCurve2_ptr;\n            internal static int GdipDrawCurve2(IntPtr graphics, IntPtr pen, PointF[] points, int count, float tension) => GdipDrawCurve2_ptr.Delegate(graphics, pen, points, count, tension);\n\n            private delegate int GdipDrawCurve2I_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension);\n            private static FunctionWrapper<GdipDrawCurve2I_delegate> GdipDrawCurve2I_ptr;\n            internal static int GdipDrawCurve2I(IntPtr graphics, IntPtr pen, Point[] points, int count, float tension) => GdipDrawCurve2I_ptr.Delegate(graphics, pen, points, count, tension);\n\n            private delegate int GdipDrawCurve3_delegate(IntPtr graphics, IntPtr pen, PointF[] points, int count, int offset, int numberOfSegments, float tension);\n            private static FunctionWrapper<GdipDrawCurve3_delegate> GdipDrawCurve3_ptr;\n            internal static int GdipDrawCurve3(IntPtr graphics, IntPtr pen, PointF[] points, int count, int offset, int numberOfSegments, float tension) => GdipDrawCurve3_ptr.Delegate(graphics, pen, points, count, offset, numberOfSegments, tension);\n\n            private delegate int GdipDrawCurve3I_delegate(IntPtr graphics, IntPtr pen, Point[] points, int count, int offset, int numberOfSegments, float tension);\n            private static FunctionWrapper<GdipDrawCurve3I_delegate> GdipDrawCurve3I_ptr;\n            internal static int GdipDrawCurve3I(IntPtr graphics, IntPtr pen, Point[] points, int count, int offset, int numberOfSegments, float tension) => GdipDrawCurve3I_ptr.Delegate(graphics, pen, points, count, offset, numberOfSegments, tension);\n\n            private delegate int GdipFillClosedCurve_delegate(IntPtr graphics, IntPtr brush, PointF[] points, int count);\n            private static FunctionWrapper<GdipFillClosedCurve_delegate> GdipFillClosedCurve_ptr;\n            internal static int GdipFillClosedCurve(IntPtr graphics, IntPtr brush, PointF[] points, int count) => GdipFillClosedCurve_ptr.Delegate(graphics, brush, points, count);\n\n            private delegate int GdipFillClosedCurveI_delegate(IntPtr graphics, IntPtr brush, Point[] points, int count);\n            private static FunctionWrapper<GdipFillClosedCurveI_delegate> GdipFillClosedCurveI_ptr;\n            internal static int GdipFillClosedCurveI(IntPtr graphics, IntPtr brush, Point[] points, int count) => GdipFillClosedCurveI_ptr.Delegate(graphics, brush, points, count);\n\n            private delegate int GdipFillClosedCurve2_delegate(IntPtr graphics, IntPtr brush, PointF[] points, int count, float tension, FillMode fillMode);\n            private static FunctionWrapper<GdipFillClosedCurve2_delegate> GdipFillClosedCurve2_ptr;\n            internal static int GdipFillClosedCurve2(IntPtr graphics, IntPtr brush, PointF[] points, int count, float tension, FillMode fillMode) => GdipFillClosedCurve2_ptr.Delegate(graphics, brush, points, count, tension, fillMode);\n\n            private delegate int GdipFillClosedCurve2I_delegate(IntPtr graphics, IntPtr brush, Point[] points, int count, float tension, FillMode fillMode);\n            private static FunctionWrapper<GdipFillClosedCurve2I_delegate> GdipFillClosedCurve2I_ptr;\n            internal static int GdipFillClosedCurve2I(IntPtr graphics, IntPtr brush, Point[] points, int count, float tension, FillMode fillMode) => GdipFillClosedCurve2I_ptr.Delegate(graphics, brush, points, count, tension, fillMode);\n\n            private delegate int GdipFillPie_delegate(IntPtr graphics, IntPtr brush, float x, float y, float width, float height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipFillPie_delegate> GdipFillPie_ptr;\n            internal static int GdipFillPie(IntPtr graphics, IntPtr brush, float x, float y, float width, float height, float startAngle, float sweepAngle) => GdipFillPie_ptr.Delegate(graphics, brush, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipFillPieI_delegate(IntPtr graphics, IntPtr brush, int x, int y, int width, int height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipFillPieI_delegate> GdipFillPieI_ptr;\n            internal static int GdipFillPieI(IntPtr graphics, IntPtr brush, int x, int y, int width, int height, float startAngle, float sweepAngle) => GdipFillPieI_ptr.Delegate(graphics, brush, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipFillPath_delegate(IntPtr graphics, IntPtr brush, IntPtr path);\n            private static FunctionWrapper<GdipFillPath_delegate> GdipFillPath_ptr;\n            internal static int GdipFillPath(IntPtr graphics, IntPtr brush, IntPtr path) => GdipFillPath_ptr.Delegate(graphics, brush, path);\n\n            private delegate int GdipGetNearestColor_delegate(IntPtr graphics, out int argb);\n            private static FunctionWrapper<GdipGetNearestColor_delegate> GdipGetNearestColor_ptr;\n            internal static int GdipGetNearestColor(IntPtr graphics, out int argb) => GdipGetNearestColor_ptr.Delegate(graphics, out argb);\n\n            private delegate int GdipTransformPoints_delegate(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count);\n            private static FunctionWrapper<GdipTransformPoints_delegate> GdipTransformPoints_ptr;\n            internal static int GdipTransformPoints(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count) => GdipTransformPoints_ptr.Delegate(graphics, destSpace, srcSpace, points, count);\n\n            private delegate int GdipTransformPointsI_delegate(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count);\n            private static FunctionWrapper<GdipTransformPointsI_delegate> GdipTransformPointsI_ptr;\n            internal static int GdipTransformPointsI(IntPtr graphics, CoordinateSpace destSpace, CoordinateSpace srcSpace, IntPtr points, int count) => GdipTransformPointsI_ptr.Delegate(graphics, destSpace, srcSpace, points, count);\n\n            private delegate int GdipSetCompositingMode_delegate(IntPtr graphics, CompositingMode compositingMode);\n            private static FunctionWrapper<GdipSetCompositingMode_delegate> GdipSetCompositingMode_ptr;\n            internal static int GdipSetCompositingMode(IntPtr graphics, CompositingMode compositingMode) => GdipSetCompositingMode_ptr.Delegate(graphics, compositingMode);\n\n            private delegate int GdipGetCompositingMode_delegate(IntPtr graphics, out CompositingMode compositingMode);\n            private static FunctionWrapper<GdipGetCompositingMode_delegate> GdipGetCompositingMode_ptr;\n            internal static int GdipGetCompositingMode(IntPtr graphics, out CompositingMode compositingMode) => GdipGetCompositingMode_ptr.Delegate(graphics, out compositingMode);\n\n            private delegate int GdipSetCompositingQuality_delegate(IntPtr graphics, CompositingQuality compositingQuality);\n            private static FunctionWrapper<GdipSetCompositingQuality_delegate> GdipSetCompositingQuality_ptr;\n            internal static int GdipSetCompositingQuality(IntPtr graphics, CompositingQuality compositingQuality) => GdipSetCompositingQuality_ptr.Delegate(graphics, compositingQuality);\n\n            private delegate int GdipGetCompositingQuality_delegate(IntPtr graphics, out CompositingQuality compositingQuality);\n            private static FunctionWrapper<GdipGetCompositingQuality_delegate> GdipGetCompositingQuality_ptr;\n            internal static int GdipGetCompositingQuality(IntPtr graphics, out CompositingQuality compositingQuality) => GdipGetCompositingQuality_ptr.Delegate(graphics, out compositingQuality);\n\n            private delegate int GdipSetInterpolationMode_delegate(IntPtr graphics, InterpolationMode interpolationMode);\n            private static FunctionWrapper<GdipSetInterpolationMode_delegate> GdipSetInterpolationMode_ptr;\n            internal static int GdipSetInterpolationMode(IntPtr graphics, InterpolationMode interpolationMode) => GdipSetInterpolationMode_ptr.Delegate(graphics, interpolationMode);\n\n            private delegate int GdipGetInterpolationMode_delegate(IntPtr graphics, out InterpolationMode interpolationMode);\n            private static FunctionWrapper<GdipGetInterpolationMode_delegate> GdipGetInterpolationMode_ptr;\n            internal static int GdipGetInterpolationMode(IntPtr graphics, out InterpolationMode interpolationMode) => GdipGetInterpolationMode_ptr.Delegate(graphics, out interpolationMode);\n\n            private delegate int GdipGetDpiX_delegate(IntPtr graphics, out float dpi);\n            private static FunctionWrapper<GdipGetDpiX_delegate> GdipGetDpiX_ptr;\n            internal static int GdipGetDpiX(IntPtr graphics, out float dpi) => GdipGetDpiX_ptr.Delegate(graphics, out dpi);\n\n            private delegate int GdipGetDpiY_delegate(IntPtr graphics, out float dpi);\n            private static FunctionWrapper<GdipGetDpiY_delegate> GdipGetDpiY_ptr;\n            internal static int GdipGetDpiY(IntPtr graphics, out float dpi) => GdipGetDpiY_ptr.Delegate(graphics, out dpi);\n\n            private delegate int GdipGetPageUnit_delegate(IntPtr graphics, out GraphicsUnit unit);\n            private static FunctionWrapper<GdipGetPageUnit_delegate> GdipGetPageUnit_ptr;\n            internal static int GdipGetPageUnit(IntPtr graphics, out GraphicsUnit unit) => GdipGetPageUnit_ptr.Delegate(graphics, out unit);\n\n            private delegate int GdipGetPageScale_delegate(IntPtr graphics, out float scale);\n            private static FunctionWrapper<GdipGetPageScale_delegate> GdipGetPageScale_ptr;\n            internal static int GdipGetPageScale(IntPtr graphics, out float scale) => GdipGetPageScale_ptr.Delegate(graphics, out scale);\n\n            private delegate int GdipSetPageUnit_delegate(IntPtr graphics, GraphicsUnit unit);\n            private static FunctionWrapper<GdipSetPageUnit_delegate> GdipSetPageUnit_ptr;\n            internal static int GdipSetPageUnit(IntPtr graphics, GraphicsUnit unit) => GdipSetPageUnit_ptr.Delegate(graphics, unit);\n\n            private delegate int GdipSetPageScale_delegate(IntPtr graphics, float scale);\n            private static FunctionWrapper<GdipSetPageScale_delegate> GdipSetPageScale_ptr;\n            internal static int GdipSetPageScale(IntPtr graphics, float scale) => GdipSetPageScale_ptr.Delegate(graphics, scale);\n\n            private delegate int GdipSetPixelOffsetMode_delegate(IntPtr graphics, PixelOffsetMode pixelOffsetMode);\n            private static FunctionWrapper<GdipSetPixelOffsetMode_delegate> GdipSetPixelOffsetMode_ptr;\n            internal static int GdipSetPixelOffsetMode(IntPtr graphics, PixelOffsetMode pixelOffsetMode) => GdipSetPixelOffsetMode_ptr.Delegate(graphics, pixelOffsetMode);\n\n            private delegate int GdipGetPixelOffsetMode_delegate(IntPtr graphics, out PixelOffsetMode pixelOffsetMode);\n            private static FunctionWrapper<GdipGetPixelOffsetMode_delegate> GdipGetPixelOffsetMode_ptr;\n            internal static int GdipGetPixelOffsetMode(IntPtr graphics, out PixelOffsetMode pixelOffsetMode) => GdipGetPixelOffsetMode_ptr.Delegate(graphics, out pixelOffsetMode);\n\n            private delegate int GdipSetSmoothingMode_delegate(IntPtr graphics, SmoothingMode smoothingMode);\n            private static FunctionWrapper<GdipSetSmoothingMode_delegate> GdipSetSmoothingMode_ptr;\n            internal static int GdipSetSmoothingMode(IntPtr graphics, SmoothingMode smoothingMode) => GdipSetSmoothingMode_ptr.Delegate(graphics, smoothingMode);\n\n            private delegate int GdipGetSmoothingMode_delegate(IntPtr graphics, out SmoothingMode smoothingMode);\n            private static FunctionWrapper<GdipGetSmoothingMode_delegate> GdipGetSmoothingMode_ptr;\n            internal static int GdipGetSmoothingMode(IntPtr graphics, out SmoothingMode smoothingMode) => GdipGetSmoothingMode_ptr.Delegate(graphics, out smoothingMode);\n\n            private delegate int GdipSetTextContrast_delegate(IntPtr graphics, int contrast);\n            private static FunctionWrapper<GdipSetTextContrast_delegate> GdipSetTextContrast_ptr;\n            internal static int GdipSetTextContrast(IntPtr graphics, int contrast) => GdipSetTextContrast_ptr.Delegate(graphics, contrast);\n\n            private delegate int GdipGetTextContrast_delegate(IntPtr graphics, out int contrast);\n            private static FunctionWrapper<GdipGetTextContrast_delegate> GdipGetTextContrast_ptr;\n            internal static int GdipGetTextContrast(IntPtr graphics, out int contrast) => GdipGetTextContrast_ptr.Delegate(graphics, out contrast);\n\n            private delegate int GdipSetTextRenderingHint_delegate(IntPtr graphics, TextRenderingHint mode);\n            private static FunctionWrapper<GdipSetTextRenderingHint_delegate> GdipSetTextRenderingHint_ptr;\n            internal static int GdipSetTextRenderingHint(IntPtr graphics, TextRenderingHint mode) => GdipSetTextRenderingHint_ptr.Delegate(graphics, mode);\n\n            private delegate int GdipGetTextRenderingHint_delegate(IntPtr graphics, out TextRenderingHint mode);\n            private static FunctionWrapper<GdipGetTextRenderingHint_delegate> GdipGetTextRenderingHint_ptr;\n            internal static int GdipGetTextRenderingHint(IntPtr graphics, out TextRenderingHint mode) => GdipGetTextRenderingHint_ptr.Delegate(graphics, out mode);\n\n            private delegate int GdipFlush_delegate(IntPtr graphics, FlushIntention intention);\n            private static FunctionWrapper<GdipFlush_delegate> GdipFlush_ptr;\n            internal static int GdipFlush(IntPtr graphics, FlushIntention intention) => GdipFlush_ptr.Delegate(graphics, intention);\n\n            private delegate int GdipAddPathString_delegate(IntPtr path, [MarshalAs(UnmanagedType.LPWStr)]string s, int lenght, IntPtr family, int style, float emSize, ref RectangleF layoutRect, IntPtr format);\n            private static FunctionWrapper<GdipAddPathString_delegate> GdipAddPathString_ptr;\n            internal static int GdipAddPathString(IntPtr path, string s, int lenght, IntPtr family, int style, float emSize, ref RectangleF layoutRect, IntPtr format) => GdipAddPathString_ptr.Delegate(path, s, lenght, family, style, emSize, ref layoutRect, format);\n\n            private delegate int GdipAddPathStringI_delegate(IntPtr path, [MarshalAs(UnmanagedType.LPWStr)]string s, int lenght, IntPtr family, int style, float emSize, ref Rectangle layoutRect, IntPtr format);\n            private static FunctionWrapper<GdipAddPathStringI_delegate> GdipAddPathStringI_ptr;\n            internal static int GdipAddPathStringI(IntPtr path, string s, int lenght, IntPtr family, int style, float emSize, ref Rectangle layoutRect, IntPtr format) => GdipAddPathStringI_ptr.Delegate(path, s, lenght, family, style, emSize, ref layoutRect, format);\n\n            private delegate int GdipCreateFromHWND_delegate(IntPtr hwnd, out IntPtr graphics);\n            private static FunctionWrapper<GdipCreateFromHWND_delegate> GdipCreateFromHWND_ptr;\n            internal static int GdipCreateFromHWND(IntPtr hwnd, out IntPtr graphics) => GdipCreateFromHWND_ptr.Delegate(hwnd, out graphics);\n\n            private delegate int GdipMeasureString_delegate(IntPtr graphics, [MarshalAs(UnmanagedType.LPWStr)]string str, int length, IntPtr font, ref RectangleF layoutRect, IntPtr stringFormat, out RectangleF boundingBox, int* codepointsFitted, int* linesFilled);\n            private static FunctionWrapper<GdipMeasureString_delegate> GdipMeasureString_ptr;\n            internal static int GdipMeasureString(IntPtr graphics, string str, int length, IntPtr font, ref RectangleF layoutRect, IntPtr stringFormat, out RectangleF boundingBox, int* codepointsFitted, int* linesFilled) => GdipMeasureString_ptr.Delegate(graphics, str, length, font, ref layoutRect, stringFormat, out boundingBox, codepointsFitted, linesFilled);\n\n            private delegate int GdipMeasureCharacterRanges_delegate(IntPtr graphics, [MarshalAs(UnmanagedType.LPWStr)]string str, int length, IntPtr font, ref RectangleF layoutRect, IntPtr stringFormat, int regcount, out IntPtr regions);\n            private static FunctionWrapper<GdipMeasureCharacterRanges_delegate> GdipMeasureCharacterRanges_ptr;\n            internal static int GdipMeasureCharacterRanges(IntPtr graphics, string str, int length, IntPtr font, ref RectangleF layoutRect, IntPtr stringFormat, int regcount, out IntPtr regions) => GdipMeasureCharacterRanges_ptr.Delegate(graphics, str, length, font, ref layoutRect, stringFormat, regcount, out regions);\n\n            private delegate int GdipLoadImageFromFile_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, out IntPtr image);\n            private static FunctionWrapper<GdipLoadImageFromFile_delegate> GdipLoadImageFromFile_ptr;\n            internal static int GdipLoadImageFromFile(string filename, out IntPtr image) => GdipLoadImageFromFile_ptr.Delegate(filename, out image);\n\n            private delegate int GdipCloneImage_delegate(IntPtr image, out IntPtr imageclone);\n            private static FunctionWrapper<GdipCloneImage_delegate> GdipCloneImage_ptr;\n            internal static int GdipCloneImage(IntPtr image, out IntPtr imageclone) => GdipCloneImage_ptr.Delegate(image, out imageclone);\n\n            private delegate int GdipLoadImageFromFileICM_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, out IntPtr image);\n            private static FunctionWrapper<GdipLoadImageFromFileICM_delegate> GdipLoadImageFromFileICM_ptr;\n            internal static int GdipLoadImageFromFileICM(string filename, out IntPtr image) => GdipLoadImageFromFileICM_ptr.Delegate(filename, out image);\n\n            private delegate int GdipDisposeImage_delegate(IntPtr image);\n            private static FunctionWrapper<GdipDisposeImage_delegate> GdipDisposeImage_ptr;\n            internal static int GdipDisposeImage(IntPtr image) => GdipDisposeImage_ptr.Delegate(image);\n            internal static int IntGdipDisposeImage(HandleRef image) => (int)GdipDisposeImage_ptr.Delegate(image.Handle);\n\n            private delegate int GdipGetImageFlags_delegate(IntPtr image, out int flag);\n            private static FunctionWrapper<GdipGetImageFlags_delegate> GdipGetImageFlags_ptr;\n            internal static int GdipGetImageFlags(IntPtr image, out int flag) => GdipGetImageFlags_ptr.Delegate(image, out flag);\n\n            private delegate int GdipGetImageType_delegate(IntPtr image, out ImageType type);\n            private static FunctionWrapper<GdipGetImageType_delegate> GdipGetImageType_ptr;\n            internal static int GdipGetImageType(IntPtr image, out ImageType type) => GdipGetImageType_ptr.Delegate(image, out type);\n\n            private delegate int GdipImageGetFrameDimensionsCount_delegate(IntPtr image, out uint count);\n            private static FunctionWrapper<GdipImageGetFrameDimensionsCount_delegate> GdipImageGetFrameDimensionsCount_ptr;\n            internal static int GdipImageGetFrameDimensionsCount(IntPtr image, out uint count) => GdipImageGetFrameDimensionsCount_ptr.Delegate(image, out count);\n\n            private delegate int GdipImageGetFrameDimensionsList_delegate(IntPtr image, [Out] Guid[] dimensionIDs, uint count);\n            private static FunctionWrapper<GdipImageGetFrameDimensionsList_delegate> GdipImageGetFrameDimensionsList_ptr;\n            internal static int GdipImageGetFrameDimensionsList(IntPtr image, [Out] Guid[] dimensionIDs, uint count) => GdipImageGetFrameDimensionsList_ptr.Delegate(image, dimensionIDs, count);\n\n            private delegate int GdipGetImageHeight_delegate(IntPtr image, out uint height);\n            private static FunctionWrapper<GdipGetImageHeight_delegate> GdipGetImageHeight_ptr;\n            internal static int GdipGetImageHeight(IntPtr image, out uint height) => GdipGetImageHeight_ptr.Delegate(image, out height);\n\n            private delegate int GdipGetImageHorizontalResolution_delegate(IntPtr image, out float resolution);\n            private static FunctionWrapper<GdipGetImageHorizontalResolution_delegate> GdipGetImageHorizontalResolution_ptr;\n            internal static int GdipGetImageHorizontalResolution(IntPtr image, out float resolution) => GdipGetImageHorizontalResolution_ptr.Delegate(image, out resolution);\n\n            private delegate int GdipGetImagePaletteSize_delegate(IntPtr image, out int size);\n            private static FunctionWrapper<GdipGetImagePaletteSize_delegate> GdipGetImagePaletteSize_ptr;\n            internal static int GdipGetImagePaletteSize(IntPtr image, out int size) => GdipGetImagePaletteSize_ptr.Delegate(image, out size);\n\n            private delegate int GdipGetImagePalette_delegate(IntPtr image, IntPtr palette, int size);\n            private static FunctionWrapper<GdipGetImagePalette_delegate> GdipGetImagePalette_ptr;\n            internal static int GdipGetImagePalette(IntPtr image, IntPtr palette, int size) => GdipGetImagePalette_ptr.Delegate(image, palette, size);\n\n            private delegate int GdipSetImagePalette_delegate(IntPtr image, IntPtr palette);\n            private static FunctionWrapper<GdipSetImagePalette_delegate> GdipSetImagePalette_ptr;\n            internal static int GdipSetImagePalette(IntPtr image, IntPtr palette) => GdipSetImagePalette_ptr.Delegate(image, palette);\n\n            private delegate int GdipGetImageDimension_delegate(IntPtr image, out float width, out float height);\n            private static FunctionWrapper<GdipGetImageDimension_delegate> GdipGetImageDimension_ptr;\n            internal static int GdipGetImageDimension(IntPtr image, out float width, out float height) => GdipGetImageDimension_ptr.Delegate(image, out width, out height);\n\n            private delegate int GdipGetImagePixelFormat_delegate(IntPtr image, out PixelFormat format);\n            private static FunctionWrapper<GdipGetImagePixelFormat_delegate> GdipGetImagePixelFormat_ptr;\n            internal static int GdipGetImagePixelFormat(IntPtr image, out PixelFormat format) => GdipGetImagePixelFormat_ptr.Delegate(image, out format);\n\n            private delegate int GdipGetPropertyCount_delegate(IntPtr image, out uint propNumbers);\n            private static FunctionWrapper<GdipGetPropertyCount_delegate> GdipGetPropertyCount_ptr;\n            internal static int GdipGetPropertyCount(IntPtr image, out uint propNumbers) => GdipGetPropertyCount_ptr.Delegate(image, out propNumbers);\n\n            private delegate int GdipGetPropertyIdList_delegate(IntPtr image, uint propNumbers, [Out] int[] list);\n            private static FunctionWrapper<GdipGetPropertyIdList_delegate> GdipGetPropertyIdList_ptr;\n            internal static int GdipGetPropertyIdList(IntPtr image, uint propNumbers, [Out] int[] list) => GdipGetPropertyIdList_ptr.Delegate(image, propNumbers, list);\n\n            private delegate int GdipGetPropertySize_delegate(IntPtr image, out int bufferSize, out int propNumbers);\n            private static FunctionWrapper<GdipGetPropertySize_delegate> GdipGetPropertySize_ptr;\n            internal static int GdipGetPropertySize(IntPtr image, out int bufferSize, out int propNumbers) => GdipGetPropertySize_ptr.Delegate(image, out bufferSize, out propNumbers);\n\n            private delegate int GdipGetAllPropertyItems_delegate(IntPtr image, int bufferSize, int propNumbers, IntPtr items);\n            private static FunctionWrapper<GdipGetAllPropertyItems_delegate> GdipGetAllPropertyItems_ptr;\n            internal static int GdipGetAllPropertyItems(IntPtr image, int bufferSize, int propNumbers, IntPtr items) => GdipGetAllPropertyItems_ptr.Delegate(image, bufferSize, propNumbers, items);\n\n            private delegate int GdipGetImageRawFormat_delegate(IntPtr image, out Guid format);\n            private static FunctionWrapper<GdipGetImageRawFormat_delegate> GdipGetImageRawFormat_ptr;\n            internal static int GdipGetImageRawFormat(IntPtr image, out Guid format) => GdipGetImageRawFormat_ptr.Delegate(image, out format);\n\n            private delegate int GdipGetImageVerticalResolution_delegate(IntPtr image, out float resolution);\n            private static FunctionWrapper<GdipGetImageVerticalResolution_delegate> GdipGetImageVerticalResolution_ptr;\n            internal static int GdipGetImageVerticalResolution(IntPtr image, out float resolution) => GdipGetImageVerticalResolution_ptr.Delegate(image, out resolution);\n\n            private delegate int GdipGetImageWidth_delegate(IntPtr image, out uint width);\n            private static FunctionWrapper<GdipGetImageWidth_delegate> GdipGetImageWidth_ptr;\n            internal static int GdipGetImageWidth(IntPtr image, out uint width) => GdipGetImageWidth_ptr.Delegate(image, out width);\n\n            private delegate int GdipGetImageBounds_delegate(IntPtr image, out RectangleF source, ref GraphicsUnit unit);\n            private static FunctionWrapper<GdipGetImageBounds_delegate> GdipGetImageBounds_ptr;\n            internal static int GdipGetImageBounds(IntPtr image, out RectangleF source, ref GraphicsUnit unit) => GdipGetImageBounds_ptr.Delegate(image, out source, ref unit);\n\n            private delegate int GdipGetEncoderParameterListSize_delegate(IntPtr image, ref Guid encoder, out uint size);\n            private static FunctionWrapper<GdipGetEncoderParameterListSize_delegate> GdipGetEncoderParameterListSize_ptr;\n            internal static int GdipGetEncoderParameterListSize(IntPtr image, ref Guid encoder, out uint size) => GdipGetEncoderParameterListSize_ptr.Delegate(image, ref encoder, out size);\n\n            private delegate int GdipGetEncoderParameterList_delegate(IntPtr image, ref Guid encoder, uint size, IntPtr buffer);\n            private static FunctionWrapper<GdipGetEncoderParameterList_delegate> GdipGetEncoderParameterList_ptr;\n            internal static int GdipGetEncoderParameterList(IntPtr image, ref Guid encoder, uint size, IntPtr buffer) => GdipGetEncoderParameterList_ptr.Delegate(image, ref encoder, size, buffer);\n\n            private delegate int GdipImageGetFrameCount_delegate(IntPtr image, ref Guid guidDimension, out uint count);\n            private static FunctionWrapper<GdipImageGetFrameCount_delegate> GdipImageGetFrameCount_ptr;\n            internal static int GdipImageGetFrameCount(IntPtr image, ref Guid guidDimension, out uint count) => GdipImageGetFrameCount_ptr.Delegate(image, ref guidDimension, out count);\n\n            private delegate int GdipImageSelectActiveFrame_delegate(IntPtr image, ref Guid guidDimension, int frameIndex);\n            private static FunctionWrapper<GdipImageSelectActiveFrame_delegate> GdipImageSelectActiveFrame_ptr;\n            internal static int GdipImageSelectActiveFrame(IntPtr image, ref Guid guidDimension, int frameIndex) => GdipImageSelectActiveFrame_ptr.Delegate(image, ref guidDimension, frameIndex);\n\n            private delegate int GdipGetPropertyItemSize_delegate(IntPtr image, int propertyID, out int propertySize);\n            private static FunctionWrapper<GdipGetPropertyItemSize_delegate> GdipGetPropertyItemSize_ptr;\n            internal static int GdipGetPropertyItemSize(IntPtr image, int propertyID, out int propertySize) => GdipGetPropertyItemSize_ptr.Delegate(image, propertyID, out propertySize);\n\n            private delegate int GdipGetPropertyItem_delegate(IntPtr image, int propertyID, int propertySize, IntPtr buffer);\n            private static FunctionWrapper<GdipGetPropertyItem_delegate> GdipGetPropertyItem_ptr;\n            internal static int GdipGetPropertyItem(IntPtr image, int propertyID, int propertySize, IntPtr buffer) => GdipGetPropertyItem_ptr.Delegate(image, propertyID, propertySize, buffer);\n\n            private delegate int GdipRemovePropertyItem_delegate(IntPtr image, int propertyId);\n            private static FunctionWrapper<GdipRemovePropertyItem_delegate> GdipRemovePropertyItem_ptr;\n            internal static int GdipRemovePropertyItem(IntPtr image, int propertyId) => GdipRemovePropertyItem_ptr.Delegate(image, propertyId);\n\n            private delegate int GdipSetPropertyItem_delegate(IntPtr image, GdipPropertyItem* propertyItem);\n            private static FunctionWrapper<GdipSetPropertyItem_delegate> GdipSetPropertyItem_ptr;\n            internal static int GdipSetPropertyItem(IntPtr image, GdipPropertyItem* propertyItem) => GdipSetPropertyItem_ptr.Delegate(image, propertyItem);\n\n            private delegate int GdipGetImageThumbnail_delegate(IntPtr image, uint width, uint height, out IntPtr thumbImage, IntPtr callback, IntPtr callBackData);\n            private static FunctionWrapper<GdipGetImageThumbnail_delegate> GdipGetImageThumbnail_ptr;\n            internal static int GdipGetImageThumbnail(IntPtr image, uint width, uint height, out IntPtr thumbImage, IntPtr callback, IntPtr callBackData) => GdipGetImageThumbnail_ptr.Delegate(image, width, height, out thumbImage, callback, callBackData);\n\n            private delegate int GdipImageRotateFlip_delegate(IntPtr image, RotateFlipType rotateFlipType);\n            private static FunctionWrapper<GdipImageRotateFlip_delegate> GdipImageRotateFlip_ptr;\n            internal static int GdipImageRotateFlip(IntPtr image, RotateFlipType rotateFlipType) => GdipImageRotateFlip_ptr.Delegate(image, rotateFlipType);\n\n            private delegate int GdipSaveImageToFile_delegate(IntPtr image, [MarshalAs(UnmanagedType.LPWStr)]string filename, ref Guid encoderClsID, IntPtr encoderParameters);\n            private static FunctionWrapper<GdipSaveImageToFile_delegate> GdipSaveImageToFile_ptr;\n            internal static int GdipSaveImageToFile(IntPtr image, string filename, ref Guid encoderClsID, IntPtr encoderParameters) => GdipSaveImageToFile_ptr.Delegate(image, filename, ref encoderClsID, encoderParameters);\n\n            private delegate int GdipSaveAdd_delegate(IntPtr image, IntPtr encoderParameters);\n            private static FunctionWrapper<GdipSaveAdd_delegate> GdipSaveAdd_ptr;\n            internal static int GdipSaveAdd(IntPtr image, IntPtr encoderParameters) => GdipSaveAdd_ptr.Delegate(image, encoderParameters);\n\n            private delegate int GdipSaveAddImage_delegate(IntPtr image, IntPtr imagenew, IntPtr encoderParameters);\n            private static FunctionWrapper<GdipSaveAddImage_delegate> GdipSaveAddImage_ptr;\n            internal static int GdipSaveAddImage(IntPtr image, IntPtr imagenew, IntPtr encoderParameters) => GdipSaveAddImage_ptr.Delegate(image, imagenew, encoderParameters);\n\n            private delegate int GdipDrawImageI_delegate(IntPtr graphics, IntPtr image, int x, int y);\n            private static FunctionWrapper<GdipDrawImageI_delegate> GdipDrawImageI_ptr;\n            internal static int GdipDrawImageI(IntPtr graphics, IntPtr image, int x, int y) => GdipDrawImageI_ptr.Delegate(graphics, image, x, y);\n\n            private delegate int GdipGetImageGraphicsContext_delegate(IntPtr image, out IntPtr graphics);\n            private static FunctionWrapper<GdipGetImageGraphicsContext_delegate> GdipGetImageGraphicsContext_ptr;\n            internal static int GdipGetImageGraphicsContext(IntPtr image, out IntPtr graphics) => GdipGetImageGraphicsContext_ptr.Delegate(image, out graphics);\n\n            private delegate int GdipDrawImage_delegate(IntPtr graphics, IntPtr image, float x, float y);\n            private static FunctionWrapper<GdipDrawImage_delegate> GdipDrawImage_ptr;\n            internal static int GdipDrawImage(IntPtr graphics, IntPtr image, float x, float y) => GdipDrawImage_ptr.Delegate(graphics, image, x, y);\n\n            private delegate int GdipDrawImagePoints_delegate(IntPtr graphics, IntPtr image, PointF[] destPoints, int count);\n            private static FunctionWrapper<GdipDrawImagePoints_delegate> GdipDrawImagePoints_ptr;\n            internal static int GdipDrawImagePoints(IntPtr graphics, IntPtr image, PointF[] destPoints, int count) => GdipDrawImagePoints_ptr.Delegate(graphics, image, destPoints, count);\n\n            private delegate int GdipDrawImagePointsI_delegate(IntPtr graphics, IntPtr image, Point[] destPoints, int count);\n            private static FunctionWrapper<GdipDrawImagePointsI_delegate> GdipDrawImagePointsI_ptr;\n            internal static int GdipDrawImagePointsI(IntPtr graphics, IntPtr image, Point[] destPoints, int count) => GdipDrawImagePointsI_ptr.Delegate(graphics, image, destPoints, count);\n\n            private delegate int GdipDrawImageRectRectI_delegate(IntPtr graphics, IntPtr image, int dstx, int dsty, int dstwidth, int dstheight, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);\n            private static FunctionWrapper<GdipDrawImageRectRectI_delegate> GdipDrawImageRectRectI_ptr;\n            internal static int GdipDrawImageRectRectI(IntPtr graphics, IntPtr image, int dstx, int dsty, int dstwidth, int dstheight, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData) => GdipDrawImageRectRectI_ptr.Delegate(graphics, image, dstx, dsty, dstwidth, dstheight, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData);\n\n            private delegate int GdipDrawImageRectRect_delegate(IntPtr graphics, IntPtr image, float dstx, float dsty, float dstwidth, float dstheight, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);\n            private static FunctionWrapper<GdipDrawImageRectRect_delegate> GdipDrawImageRectRect_ptr;\n            internal static int GdipDrawImageRectRect(IntPtr graphics, IntPtr image, float dstx, float dsty, float dstwidth, float dstheight, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData) => GdipDrawImageRectRect_ptr.Delegate(graphics, image, dstx, dsty, dstwidth, dstheight, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData);\n\n            private delegate int GdipDrawImagePointsRectI_delegate(IntPtr graphics, IntPtr image, Point[] destPoints, int count, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);\n            private static FunctionWrapper<GdipDrawImagePointsRectI_delegate> GdipDrawImagePointsRectI_ptr;\n            internal static int GdipDrawImagePointsRectI(IntPtr graphics, IntPtr image, Point[] destPoints, int count, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData) => GdipDrawImagePointsRectI_ptr.Delegate(graphics, image, destPoints, count, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData);\n\n            private delegate int GdipDrawImagePointsRect_delegate(IntPtr graphics, IntPtr image, PointF[] destPoints, int count, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData);\n            private static FunctionWrapper<GdipDrawImagePointsRect_delegate> GdipDrawImagePointsRect_ptr;\n            internal static int GdipDrawImagePointsRect(IntPtr graphics, IntPtr image, PointF[] destPoints, int count, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit, IntPtr imageattr, Graphics.DrawImageAbort callback, IntPtr callbackData) => GdipDrawImagePointsRect_ptr.Delegate(graphics, image, destPoints, count, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData);\n\n            private delegate int GdipDrawImageRect_delegate(IntPtr graphics, IntPtr image, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipDrawImageRect_delegate> GdipDrawImageRect_ptr;\n            internal static int GdipDrawImageRect(IntPtr graphics, IntPtr image, float x, float y, float width, float height) => GdipDrawImageRect_ptr.Delegate(graphics, image, x, y, width, height);\n\n            private delegate int GdipDrawImagePointRect_delegate(IntPtr graphics, IntPtr image, float x, float y, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit);\n            private static FunctionWrapper<GdipDrawImagePointRect_delegate> GdipDrawImagePointRect_ptr;\n            internal static int GdipDrawImagePointRect(IntPtr graphics, IntPtr image, float x, float y, float srcx, float srcy, float srcwidth, float srcheight, GraphicsUnit srcUnit) => GdipDrawImagePointRect_ptr.Delegate(graphics, image, x, y, srcx, srcy, srcwidth, srcheight, srcUnit);\n\n            private delegate int GdipDrawImagePointRectI_delegate(IntPtr graphics, IntPtr image, int x, int y, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit);\n            private static FunctionWrapper<GdipDrawImagePointRectI_delegate> GdipDrawImagePointRectI_ptr;\n            internal static int GdipDrawImagePointRectI(IntPtr graphics, IntPtr image, int x, int y, int srcx, int srcy, int srcwidth, int srcheight, GraphicsUnit srcUnit) => GdipDrawImagePointRectI_ptr.Delegate(graphics, image, x, y, srcx, srcy, srcwidth, srcheight, srcUnit);\n\n            private delegate int GdipCreatePath_delegate(FillMode brushMode, out IntPtr path);\n            private static FunctionWrapper<GdipCreatePath_delegate> GdipCreatePath_ptr;\n            internal static int GdipCreatePath(FillMode brushMode, out IntPtr path) => GdipCreatePath_ptr.Delegate(brushMode, out path);\n\n            private delegate int GdipCreatePath2_delegate(PointF[] points, byte[] types, int count, FillMode brushMode, out IntPtr path);\n            private static FunctionWrapper<GdipCreatePath2_delegate> GdipCreatePath2_ptr;\n            internal static int GdipCreatePath2(PointF[] points, byte[] types, int count, FillMode brushMode, out IntPtr path) => GdipCreatePath2_ptr.Delegate(points, types, count, brushMode, out path);\n\n            private delegate int GdipCreatePath2I_delegate(Point[] points, byte[] types, int count, FillMode brushMode, out IntPtr path);\n            private static FunctionWrapper<GdipCreatePath2I_delegate> GdipCreatePath2I_ptr;\n            internal static int GdipCreatePath2I(Point[] points, byte[] types, int count, FillMode brushMode, out IntPtr path) => GdipCreatePath2I_ptr.Delegate(points, types, count, brushMode, out path);\n\n            private delegate int GdipClonePath_delegate(IntPtr path, out IntPtr clonePath);\n            private static FunctionWrapper<GdipClonePath_delegate> GdipClonePath_ptr;\n            internal static int GdipClonePath(IntPtr path, out IntPtr clonePath) => GdipClonePath_ptr.Delegate(path, out clonePath);\n\n            private delegate int GdipDeletePath_delegate(IntPtr path);\n            private static FunctionWrapper<GdipDeletePath_delegate> GdipDeletePath_ptr;\n            internal static int GdipDeletePath(IntPtr path) => GdipDeletePath_ptr.Delegate(path);\n            internal static int IntGdipDeletePath(HandleRef path) => (int)GdipDeletePath_ptr.Delegate(path.Handle);\n\n            private delegate int GdipResetPath_delegate(IntPtr path);\n            private static FunctionWrapper<GdipResetPath_delegate> GdipResetPath_ptr;\n            internal static int GdipResetPath(IntPtr path) => GdipResetPath_ptr.Delegate(path);\n\n            private delegate int GdipGetPointCount_delegate(IntPtr path, out int count);\n            private static FunctionWrapper<GdipGetPointCount_delegate> GdipGetPointCount_ptr;\n            internal static int GdipGetPointCount(IntPtr path, out int count) => GdipGetPointCount_ptr.Delegate(path, out count);\n\n            private delegate int GdipGetPathTypes_delegate(IntPtr path, [Out] byte[] types, int count);\n            private static FunctionWrapper<GdipGetPathTypes_delegate> GdipGetPathTypes_ptr;\n            internal static int GdipGetPathTypes(IntPtr path, [Out] byte[] types, int count) => GdipGetPathTypes_ptr.Delegate(path, types, count);\n\n            private delegate int GdipGetPathPoints_delegate(IntPtr path, [Out] PointF[] points, int count);\n            private static FunctionWrapper<GdipGetPathPoints_delegate> GdipGetPathPoints_ptr;\n            internal static int GdipGetPathPoints(IntPtr path, [Out] PointF[] points, int count) => GdipGetPathPoints_ptr.Delegate(path, points, count);\n\n            private delegate int GdipGetPathPointsI_delegate(IntPtr path, [Out] Point[] points, int count);\n            private static FunctionWrapper<GdipGetPathPointsI_delegate> GdipGetPathPointsI_ptr;\n            internal static int GdipGetPathPointsI(IntPtr path, [Out] Point[] points, int count) => GdipGetPathPointsI_ptr.Delegate(path, points, count);\n\n            private delegate int GdipGetPathFillMode_delegate(IntPtr path, out FillMode fillMode);\n            private static FunctionWrapper<GdipGetPathFillMode_delegate> GdipGetPathFillMode_ptr;\n            internal static int GdipGetPathFillMode(IntPtr path, out FillMode fillMode) => GdipGetPathFillMode_ptr.Delegate(path, out fillMode);\n\n            private delegate int GdipSetPathFillMode_delegate(IntPtr path, FillMode fillMode);\n            private static FunctionWrapper<GdipSetPathFillMode_delegate> GdipSetPathFillMode_ptr;\n            internal static int GdipSetPathFillMode(IntPtr path, FillMode fillMode) => GdipSetPathFillMode_ptr.Delegate(path, fillMode);\n\n            private delegate int GdipStartPathFigure_delegate(IntPtr path);\n            private static FunctionWrapper<GdipStartPathFigure_delegate> GdipStartPathFigure_ptr;\n            internal static int GdipStartPathFigure(IntPtr path) => GdipStartPathFigure_ptr.Delegate(path);\n\n            private delegate int GdipClosePathFigure_delegate(IntPtr path);\n            private static FunctionWrapper<GdipClosePathFigure_delegate> GdipClosePathFigure_ptr;\n            internal static int GdipClosePathFigure(IntPtr path) => GdipClosePathFigure_ptr.Delegate(path);\n\n            private delegate int GdipClosePathFigures_delegate(IntPtr path);\n            private static FunctionWrapper<GdipClosePathFigures_delegate> GdipClosePathFigures_ptr;\n            internal static int GdipClosePathFigures(IntPtr path) => GdipClosePathFigures_ptr.Delegate(path);\n\n            private delegate int GdipSetPathMarker_delegate(IntPtr path);\n            private static FunctionWrapper<GdipSetPathMarker_delegate> GdipSetPathMarker_ptr;\n            internal static int GdipSetPathMarker(IntPtr path) => GdipSetPathMarker_ptr.Delegate(path);\n\n            private delegate int GdipClearPathMarkers_delegate(IntPtr path);\n            private static FunctionWrapper<GdipClearPathMarkers_delegate> GdipClearPathMarkers_ptr;\n            internal static int GdipClearPathMarkers(IntPtr path) => GdipClearPathMarkers_ptr.Delegate(path);\n\n            private delegate int GdipReversePath_delegate(IntPtr path);\n            private static FunctionWrapper<GdipReversePath_delegate> GdipReversePath_ptr;\n            internal static int GdipReversePath(IntPtr path) => GdipReversePath_ptr.Delegate(path);\n\n            private delegate int GdipGetPathLastPoint_delegate(IntPtr path, out PointF lastPoint);\n            private static FunctionWrapper<GdipGetPathLastPoint_delegate> GdipGetPathLastPoint_ptr;\n            internal static int GdipGetPathLastPoint(IntPtr path, out PointF lastPoint) => GdipGetPathLastPoint_ptr.Delegate(path, out lastPoint);\n\n            private delegate int GdipAddPathLine_delegate(IntPtr path, float x1, float y1, float x2, float y2);\n            private static FunctionWrapper<GdipAddPathLine_delegate> GdipAddPathLine_ptr;\n            internal static int GdipAddPathLine(IntPtr path, float x1, float y1, float x2, float y2) => GdipAddPathLine_ptr.Delegate(path, x1, y1, x2, y2);\n\n            private delegate int GdipAddPathLine2_delegate(IntPtr path, PointF[] points, int count);\n            private static FunctionWrapper<GdipAddPathLine2_delegate> GdipAddPathLine2_ptr;\n            internal static int GdipAddPathLine2(IntPtr path, PointF[] points, int count) => GdipAddPathLine2_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathLine2I_delegate(IntPtr path, Point[] points, int count);\n            private static FunctionWrapper<GdipAddPathLine2I_delegate> GdipAddPathLine2I_ptr;\n            internal static int GdipAddPathLine2I(IntPtr path, Point[] points, int count) => GdipAddPathLine2I_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathArc_delegate(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipAddPathArc_delegate> GdipAddPathArc_ptr;\n            internal static int GdipAddPathArc(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle) => GdipAddPathArc_ptr.Delegate(path, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipAddPathBezier_delegate(IntPtr path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);\n            private static FunctionWrapper<GdipAddPathBezier_delegate> GdipAddPathBezier_ptr;\n            internal static int GdipAddPathBezier(IntPtr path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4) => GdipAddPathBezier_ptr.Delegate(path, x1, y1, x2, y2, x3, y3, x4, y4);\n\n            private delegate int GdipAddPathBeziers_delegate(IntPtr path, PointF[] points, int count);\n            private static FunctionWrapper<GdipAddPathBeziers_delegate> GdipAddPathBeziers_ptr;\n            internal static int GdipAddPathBeziers(IntPtr path, PointF[] points, int count) => GdipAddPathBeziers_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathCurve_delegate(IntPtr path, PointF[] points, int count);\n            private static FunctionWrapper<GdipAddPathCurve_delegate> GdipAddPathCurve_ptr;\n            internal static int GdipAddPathCurve(IntPtr path, PointF[] points, int count) => GdipAddPathCurve_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathCurveI_delegate(IntPtr path, Point[] points, int count);\n            private static FunctionWrapper<GdipAddPathCurveI_delegate> GdipAddPathCurveI_ptr;\n            internal static int GdipAddPathCurveI(IntPtr path, Point[] points, int count) => GdipAddPathCurveI_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathCurve2_delegate(IntPtr path, PointF[] points, int count, float tension);\n            private static FunctionWrapper<GdipAddPathCurve2_delegate> GdipAddPathCurve2_ptr;\n            internal static int GdipAddPathCurve2(IntPtr path, PointF[] points, int count, float tension) => GdipAddPathCurve2_ptr.Delegate(path, points, count, tension);\n\n            private delegate int GdipAddPathCurve2I_delegate(IntPtr path, Point[] points, int count, float tension);\n            private static FunctionWrapper<GdipAddPathCurve2I_delegate> GdipAddPathCurve2I_ptr;\n            internal static int GdipAddPathCurve2I(IntPtr path, Point[] points, int count, float tension) => GdipAddPathCurve2I_ptr.Delegate(path, points, count, tension);\n\n            private delegate int GdipAddPathCurve3_delegate(IntPtr path, PointF[] points, int count, int offset, int numberOfSegments, float tension);\n            private static FunctionWrapper<GdipAddPathCurve3_delegate> GdipAddPathCurve3_ptr;\n            internal static int GdipAddPathCurve3(IntPtr path, PointF[] points, int count, int offset, int numberOfSegments, float tension) => GdipAddPathCurve3_ptr.Delegate(path, points, count, offset, numberOfSegments, tension);\n\n            private delegate int GdipAddPathCurve3I_delegate(IntPtr path, Point[] points, int count, int offset, int numberOfSegments, float tension);\n            private static FunctionWrapper<GdipAddPathCurve3I_delegate> GdipAddPathCurve3I_ptr;\n            internal static int GdipAddPathCurve3I(IntPtr path, Point[] points, int count, int offset, int numberOfSegments, float tension) => GdipAddPathCurve3I_ptr.Delegate(path, points, count, offset, numberOfSegments, tension);\n\n            private delegate int GdipAddPathClosedCurve_delegate(IntPtr path, PointF[] points, int count);\n            private static FunctionWrapper<GdipAddPathClosedCurve_delegate> GdipAddPathClosedCurve_ptr;\n            internal static int GdipAddPathClosedCurve(IntPtr path, PointF[] points, int count) => GdipAddPathClosedCurve_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathClosedCurveI_delegate(IntPtr path, Point[] points, int count);\n            private static FunctionWrapper<GdipAddPathClosedCurveI_delegate> GdipAddPathClosedCurveI_ptr;\n            internal static int GdipAddPathClosedCurveI(IntPtr path, Point[] points, int count) => GdipAddPathClosedCurveI_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathClosedCurve2_delegate(IntPtr path, PointF[] points, int count, float tension);\n            private static FunctionWrapper<GdipAddPathClosedCurve2_delegate> GdipAddPathClosedCurve2_ptr;\n            internal static int GdipAddPathClosedCurve2(IntPtr path, PointF[] points, int count, float tension) => GdipAddPathClosedCurve2_ptr.Delegate(path, points, count, tension);\n\n            private delegate int GdipAddPathClosedCurve2I_delegate(IntPtr path, Point[] points, int count, float tension);\n            private static FunctionWrapper<GdipAddPathClosedCurve2I_delegate> GdipAddPathClosedCurve2I_ptr;\n            internal static int GdipAddPathClosedCurve2I(IntPtr path, Point[] points, int count, float tension) => GdipAddPathClosedCurve2I_ptr.Delegate(path, points, count, tension);\n\n            private delegate int GdipAddPathRectangle_delegate(IntPtr path, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipAddPathRectangle_delegate> GdipAddPathRectangle_ptr;\n            internal static int GdipAddPathRectangle(IntPtr path, float x, float y, float width, float height) => GdipAddPathRectangle_ptr.Delegate(path, x, y, width, height);\n\n            private delegate int GdipAddPathRectangles_delegate(IntPtr path, RectangleF[] rects, int count);\n            private static FunctionWrapper<GdipAddPathRectangles_delegate> GdipAddPathRectangles_ptr;\n            internal static int GdipAddPathRectangles(IntPtr path, RectangleF[] rects, int count) => GdipAddPathRectangles_ptr.Delegate(path, rects, count);\n\n            private delegate int GdipAddPathEllipse_delegate(IntPtr path, float x, float y, float width, float height);\n            private static FunctionWrapper<GdipAddPathEllipse_delegate> GdipAddPathEllipse_ptr;\n            internal static int GdipAddPathEllipse(IntPtr path, float x, float y, float width, float height) => GdipAddPathEllipse_ptr.Delegate(path, x, y, width, height);\n\n            private delegate int GdipAddPathEllipseI_delegate(IntPtr path, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipAddPathEllipseI_delegate> GdipAddPathEllipseI_ptr;\n            internal static int GdipAddPathEllipseI(IntPtr path, int x, int y, int width, int height) => GdipAddPathEllipseI_ptr.Delegate(path, x, y, width, height);\n\n            private delegate int GdipAddPathPie_delegate(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipAddPathPie_delegate> GdipAddPathPie_ptr;\n            internal static int GdipAddPathPie(IntPtr path, float x, float y, float width, float height, float startAngle, float sweepAngle) => GdipAddPathPie_ptr.Delegate(path, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipAddPathPieI_delegate(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipAddPathPieI_delegate> GdipAddPathPieI_ptr;\n            internal static int GdipAddPathPieI(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle) => GdipAddPathPieI_ptr.Delegate(path, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipAddPathPolygon_delegate(IntPtr path, PointF[] points, int count);\n            private static FunctionWrapper<GdipAddPathPolygon_delegate> GdipAddPathPolygon_ptr;\n            internal static int GdipAddPathPolygon(IntPtr path, PointF[] points, int count) => GdipAddPathPolygon_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathPath_delegate(IntPtr path, IntPtr addingPath, bool connect);\n            private static FunctionWrapper<GdipAddPathPath_delegate> GdipAddPathPath_ptr;\n            internal static int GdipAddPathPath(IntPtr path, IntPtr addingPath, bool connect) => GdipAddPathPath_ptr.Delegate(path, addingPath, connect);\n\n            private delegate int GdipAddPathLineI_delegate(IntPtr path, int x1, int y1, int x2, int y2);\n            private static FunctionWrapper<GdipAddPathLineI_delegate> GdipAddPathLineI_ptr;\n            internal static int GdipAddPathLineI(IntPtr path, int x1, int y1, int x2, int y2) => GdipAddPathLineI_ptr.Delegate(path, x1, y1, x2, y2);\n\n            private delegate int GdipAddPathArcI_delegate(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle);\n            private static FunctionWrapper<GdipAddPathArcI_delegate> GdipAddPathArcI_ptr;\n            internal static int GdipAddPathArcI(IntPtr path, int x, int y, int width, int height, float startAngle, float sweepAngle) => GdipAddPathArcI_ptr.Delegate(path, x, y, width, height, startAngle, sweepAngle);\n\n            private delegate int GdipAddPathBezierI_delegate(IntPtr path, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);\n            private static FunctionWrapper<GdipAddPathBezierI_delegate> GdipAddPathBezierI_ptr;\n            internal static int GdipAddPathBezierI(IntPtr path, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) => GdipAddPathBezierI_ptr.Delegate(path, x1, y1, x2, y2, x3, y3, x4, y4);\n\n            private delegate int GdipAddPathBeziersI_delegate(IntPtr path, Point[] points, int count);\n            private static FunctionWrapper<GdipAddPathBeziersI_delegate> GdipAddPathBeziersI_ptr;\n            internal static int GdipAddPathBeziersI(IntPtr path, Point[] points, int count) => GdipAddPathBeziersI_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathPolygonI_delegate(IntPtr path, Point[] points, int count);\n            private static FunctionWrapper<GdipAddPathPolygonI_delegate> GdipAddPathPolygonI_ptr;\n            internal static int GdipAddPathPolygonI(IntPtr path, Point[] points, int count) => GdipAddPathPolygonI_ptr.Delegate(path, points, count);\n\n            private delegate int GdipAddPathRectangleI_delegate(IntPtr path, int x, int y, int width, int height);\n            private static FunctionWrapper<GdipAddPathRectangleI_delegate> GdipAddPathRectangleI_ptr;\n            internal static int GdipAddPathRectangleI(IntPtr path, int x, int y, int width, int height) => GdipAddPathRectangleI_ptr.Delegate(path, x, y, width, height);\n\n            private delegate int GdipAddPathRectanglesI_delegate(IntPtr path, Rectangle[] rects, int count);\n            private static FunctionWrapper<GdipAddPathRectanglesI_delegate> GdipAddPathRectanglesI_ptr;\n            internal static int GdipAddPathRectanglesI(IntPtr path, Rectangle[] rects, int count) => GdipAddPathRectanglesI_ptr.Delegate(path, rects, count);\n\n            private delegate int GdipFlattenPath_delegate(IntPtr path, IntPtr matrix, float floatness);\n            private static FunctionWrapper<GdipFlattenPath_delegate> GdipFlattenPath_ptr;\n            internal static int GdipFlattenPath(IntPtr path, IntPtr matrix, float floatness) => GdipFlattenPath_ptr.Delegate(path, matrix, floatness);\n\n            private delegate int GdipTransformPath_delegate(IntPtr path, IntPtr matrix);\n            private static FunctionWrapper<GdipTransformPath_delegate> GdipTransformPath_ptr;\n            internal static int GdipTransformPath(IntPtr path, IntPtr matrix) => GdipTransformPath_ptr.Delegate(path, matrix);\n\n            private delegate int GdipWarpPath_delegate(IntPtr path, IntPtr matrix, PointF[] points, int count, float srcx, float srcy, float srcwidth, float srcheight, WarpMode mode, float flatness);\n            private static FunctionWrapper<GdipWarpPath_delegate> GdipWarpPath_ptr;\n            internal static int GdipWarpPath(IntPtr path, IntPtr matrix, PointF[] points, int count, float srcx, float srcy, float srcwidth, float srcheight, WarpMode mode, float flatness) => GdipWarpPath_ptr.Delegate(path, matrix, points, count, srcx, srcy, srcwidth, srcheight, mode, flatness);\n\n            private delegate int GdipWidenPath_delegate(IntPtr path, IntPtr pen, IntPtr matrix, float flatness);\n            private static FunctionWrapper<GdipWidenPath_delegate> GdipWidenPath_ptr;\n            internal static int GdipWidenPath(IntPtr path, IntPtr pen, IntPtr matrix, float flatness) => GdipWidenPath_ptr.Delegate(path, pen, matrix, flatness);\n\n            private delegate int GdipGetPathWorldBounds_delegate(IntPtr path, out RectangleF bounds, IntPtr matrix, IntPtr pen);\n            private static FunctionWrapper<GdipGetPathWorldBounds_delegate> GdipGetPathWorldBounds_ptr;\n            internal static int GdipGetPathWorldBounds(IntPtr path, out RectangleF bounds, IntPtr matrix, IntPtr pen) => GdipGetPathWorldBounds_ptr.Delegate(path, out bounds, matrix, pen);\n\n            private delegate int GdipGetPathWorldBoundsI_delegate(IntPtr path, out Rectangle bounds, IntPtr matrix, IntPtr pen);\n            private static FunctionWrapper<GdipGetPathWorldBoundsI_delegate> GdipGetPathWorldBoundsI_ptr;\n            internal static int GdipGetPathWorldBoundsI(IntPtr path, out Rectangle bounds, IntPtr matrix, IntPtr pen) => GdipGetPathWorldBoundsI_ptr.Delegate(path, out bounds, matrix, pen);\n\n            private delegate int GdipIsVisiblePathPoint_delegate(IntPtr path, float x, float y, IntPtr graphics, out bool result);\n            private static FunctionWrapper<GdipIsVisiblePathPoint_delegate> GdipIsVisiblePathPoint_ptr;\n            internal static int GdipIsVisiblePathPoint(IntPtr path, float x, float y, IntPtr graphics, out bool result) => GdipIsVisiblePathPoint_ptr.Delegate(path, x, y, graphics, out result);\n\n            private delegate int GdipIsVisiblePathPointI_delegate(IntPtr path, int x, int y, IntPtr graphics, out bool result);\n            private static FunctionWrapper<GdipIsVisiblePathPointI_delegate> GdipIsVisiblePathPointI_ptr;\n            internal static int GdipIsVisiblePathPointI(IntPtr path, int x, int y, IntPtr graphics, out bool result) => GdipIsVisiblePathPointI_ptr.Delegate(path, x, y, graphics, out result);\n\n            private delegate int GdipIsOutlineVisiblePathPoint_delegate(IntPtr path, float x, float y, IntPtr pen, IntPtr graphics, out bool result);\n            private static FunctionWrapper<GdipIsOutlineVisiblePathPoint_delegate> GdipIsOutlineVisiblePathPoint_ptr;\n            internal static int GdipIsOutlineVisiblePathPoint(IntPtr path, float x, float y, IntPtr pen, IntPtr graphics, out bool result) => GdipIsOutlineVisiblePathPoint_ptr.Delegate(path, x, y, pen, graphics, out result);\n\n            private delegate int GdipIsOutlineVisiblePathPointI_delegate(IntPtr path, int x, int y, IntPtr pen, IntPtr graphics, out bool result);\n            private static FunctionWrapper<GdipIsOutlineVisiblePathPointI_delegate> GdipIsOutlineVisiblePathPointI_ptr;\n            internal static int GdipIsOutlineVisiblePathPointI(IntPtr path, int x, int y, IntPtr pen, IntPtr graphics, out bool result) => GdipIsOutlineVisiblePathPointI_ptr.Delegate(path, x, y, pen, graphics, out result);\n\n            private delegate int GdipCreateFont_delegate(IntPtr fontFamily, float emSize, FontStyle style, GraphicsUnit unit, out IntPtr font);\n            private static FunctionWrapper<GdipCreateFont_delegate> GdipCreateFont_ptr;\n            internal static int GdipCreateFont(IntPtr fontFamily, float emSize, FontStyle style, GraphicsUnit unit, out IntPtr font) => GdipCreateFont_ptr.Delegate(fontFamily, emSize, style, unit, out font);\n\n            private delegate int GdipDeleteFont_delegate(IntPtr font);\n            private static FunctionWrapper<GdipDeleteFont_delegate> GdipDeleteFont_ptr;\n            internal static int GdipDeleteFont(IntPtr font) => GdipDeleteFont_ptr.Delegate(font);\n            internal static int IntGdipDeleteFont(HandleRef font) => (int)GdipDeleteFont_ptr.Delegate(font.Handle);\n\n#pragma warning disable CS0618 // Legacy code: We don't care about using obsolete API's.\n            private delegate int GdipGetLogFont_delegate(IntPtr font, IntPtr graphics, [MarshalAs(UnmanagedType.AsAny), Out] object logfontA);\n#pragma warning restore CS0618\n            private static FunctionWrapper<GdipGetLogFont_delegate> GdipGetLogFont_ptr;\n            internal static int GdipGetLogFont(IntPtr font, IntPtr graphics, [Out] object logfontA) => GdipGetLogFont_ptr.Delegate(font, graphics, logfontA);\n\n            private delegate int GdipCreateFontFromDC_delegate(IntPtr hdc, out IntPtr font);\n            private static FunctionWrapper<GdipCreateFontFromDC_delegate> GdipCreateFontFromDC_ptr;\n            internal static int GdipCreateFontFromDC(IntPtr hdc, out IntPtr font) => GdipCreateFontFromDC_ptr.Delegate(hdc, out font);\n\n            private delegate int GdipCreateFontFromLogfont_delegate(IntPtr hdc, ref LOGFONT lf, out IntPtr ptr);\n            private static FunctionWrapper<GdipCreateFontFromLogfont_delegate> GdipCreateFontFromLogfont_ptr;\n            internal static int GdipCreateFontFromLogfont(IntPtr hdc, ref LOGFONT lf, out IntPtr ptr) => GdipCreateFontFromLogfont_ptr.Delegate(hdc, ref lf, out ptr);\n\n            private delegate int GdipCreateFontFromHfont_delegate(IntPtr hdc, out IntPtr font, ref LOGFONT lf);\n            private static FunctionWrapper<GdipCreateFontFromHfont_delegate> GdipCreateFontFromHfont_ptr;\n            internal static int GdipCreateFontFromHfont(IntPtr hdc, out IntPtr font, ref LOGFONT lf) => GdipCreateFontFromHfont_ptr.Delegate(hdc, out font, ref lf);\n\n            private delegate int GdipGetFontSize_delegate(IntPtr font, out float size);\n            private static FunctionWrapper<GdipGetFontSize_delegate> GdipGetFontSize_ptr;\n            internal static int GdipGetFontSize(IntPtr font, out float size) => GdipGetFontSize_ptr.Delegate(font, out size);\n\n            private delegate int GdipGetFontHeight_delegate(IntPtr font, IntPtr graphics, out float height);\n            private static FunctionWrapper<GdipGetFontHeight_delegate> GdipGetFontHeight_ptr;\n            internal static int GdipGetFontHeight(IntPtr font, IntPtr graphics, out float height) => GdipGetFontHeight_ptr.Delegate(font, graphics, out height);\n\n            private delegate int GdipGetFontHeightGivenDPI_delegate(IntPtr font, float dpi, out float height);\n            private static FunctionWrapper<GdipGetFontHeightGivenDPI_delegate> GdipGetFontHeightGivenDPI_ptr;\n            internal static int GdipGetFontHeightGivenDPI(IntPtr font, float dpi, out float height) => GdipGetFontHeightGivenDPI_ptr.Delegate(font, dpi, out height);\n\n            private delegate int GdipCreateMetafileFromFile_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, out IntPtr metafile);\n            private static FunctionWrapper<GdipCreateMetafileFromFile_delegate> GdipCreateMetafileFromFile_ptr;\n            internal static int GdipCreateMetafileFromFile(string filename, out IntPtr metafile) => GdipCreateMetafileFromFile_ptr.Delegate(filename, out metafile);\n\n            private delegate int GdipCreateMetafileFromEmf_delegate(IntPtr hEmf, bool deleteEmf, out IntPtr metafile);\n            private static FunctionWrapper<GdipCreateMetafileFromEmf_delegate> GdipCreateMetafileFromEmf_ptr;\n            internal static int GdipCreateMetafileFromEmf(IntPtr hEmf, bool deleteEmf, out IntPtr metafile) => GdipCreateMetafileFromEmf_ptr.Delegate(hEmf, deleteEmf, out metafile);\n\n            private delegate int GdipCreateMetafileFromWmf_delegate(IntPtr hWmf, bool deleteWmf, WmfPlaceableFileHeader wmfPlaceableFileHeader, out IntPtr metafile);\n            private static FunctionWrapper<GdipCreateMetafileFromWmf_delegate> GdipCreateMetafileFromWmf_ptr;\n            internal static int GdipCreateMetafileFromWmf(IntPtr hWmf, bool deleteWmf, WmfPlaceableFileHeader wmfPlaceableFileHeader, out IntPtr metafile) => GdipCreateMetafileFromWmf_ptr.Delegate(hWmf, deleteWmf, wmfPlaceableFileHeader, out metafile);\n\n            private delegate int GdipGetMetafileHeaderFromFile_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, IntPtr header);\n            private static FunctionWrapper<GdipGetMetafileHeaderFromFile_delegate> GdipGetMetafileHeaderFromFile_ptr;\n            internal static int GdipGetMetafileHeaderFromFile(string filename, IntPtr header) => GdipGetMetafileHeaderFromFile_ptr.Delegate(filename, header);\n\n            private delegate int GdipGetMetafileHeaderFromMetafile_delegate(IntPtr metafile, IntPtr header);\n            private static FunctionWrapper<GdipGetMetafileHeaderFromMetafile_delegate> GdipGetMetafileHeaderFromMetafile_ptr;\n            internal static int GdipGetMetafileHeaderFromMetafile(IntPtr metafile, IntPtr header) => GdipGetMetafileHeaderFromMetafile_ptr.Delegate(metafile, header);\n\n            private delegate int GdipGetMetafileHeaderFromEmf_delegate(IntPtr hEmf, IntPtr header);\n            private static FunctionWrapper<GdipGetMetafileHeaderFromEmf_delegate> GdipGetMetafileHeaderFromEmf_ptr;\n            internal static int GdipGetMetafileHeaderFromEmf(IntPtr hEmf, IntPtr header) => GdipGetMetafileHeaderFromEmf_ptr.Delegate(hEmf, header);\n\n            private delegate int GdipGetMetafileHeaderFromWmf_delegate(IntPtr hWmf, IntPtr wmfPlaceableFileHeader, IntPtr header);\n            private static FunctionWrapper<GdipGetMetafileHeaderFromWmf_delegate> GdipGetMetafileHeaderFromWmf_ptr;\n            internal static int GdipGetMetafileHeaderFromWmf(IntPtr hWmf, IntPtr wmfPlaceableFileHeader, IntPtr header) => GdipGetMetafileHeaderFromWmf_ptr.Delegate(hWmf, wmfPlaceableFileHeader, header);\n\n            private delegate int GdipGetHemfFromMetafile_delegate(IntPtr metafile, out IntPtr hEmf);\n            private static FunctionWrapper<GdipGetHemfFromMetafile_delegate> GdipGetHemfFromMetafile_ptr;\n            internal static int GdipGetHemfFromMetafile(IntPtr metafile, out IntPtr hEmf) => GdipGetHemfFromMetafile_ptr.Delegate(metafile, out hEmf);\n\n            private delegate int GdipGetMetafileDownLevelRasterizationLimit_delegate(IntPtr metafile, ref uint metafileRasterizationLimitDpi);\n            private static FunctionWrapper<GdipGetMetafileDownLevelRasterizationLimit_delegate> GdipGetMetafileDownLevelRasterizationLimit_ptr;\n            internal static int GdipGetMetafileDownLevelRasterizationLimit(IntPtr metafile, ref uint metafileRasterizationLimitDpi) => GdipGetMetafileDownLevelRasterizationLimit_ptr.Delegate(metafile, ref metafileRasterizationLimitDpi);\n\n            private delegate int GdipSetMetafileDownLevelRasterizationLimit_delegate(IntPtr metafile, uint metafileRasterizationLimitDpi);\n            private static FunctionWrapper<GdipSetMetafileDownLevelRasterizationLimit_delegate> GdipSetMetafileDownLevelRasterizationLimit_ptr;\n            internal static int GdipSetMetafileDownLevelRasterizationLimit(IntPtr metafile, uint metafileRasterizationLimitDpi) => GdipSetMetafileDownLevelRasterizationLimit_ptr.Delegate(metafile, metafileRasterizationLimitDpi);\n\n            private delegate int GdipPlayMetafileRecord_delegate(IntPtr metafile, EmfPlusRecordType recordType, int flags, int dataSize, byte[] data);\n            private static FunctionWrapper<GdipPlayMetafileRecord_delegate> GdipPlayMetafileRecord_ptr;\n            internal static int GdipPlayMetafileRecord(IntPtr metafile, EmfPlusRecordType recordType, int flags, int dataSize, byte[] data) => GdipPlayMetafileRecord_ptr.Delegate(metafile, recordType, flags, dataSize, data);\n\n            private delegate int GdipRecordMetafile_delegate(IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)]string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafile_delegate> GdipRecordMetafile_ptr;\n            internal static int GdipRecordMetafile(IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, string description, out IntPtr metafile) => GdipRecordMetafile_ptr.Delegate(hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipRecordMetafileI_delegate(IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)]string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafileI_delegate> GdipRecordMetafileI_ptr;\n            internal static int GdipRecordMetafileI(IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, string description, out IntPtr metafile) => GdipRecordMetafileI_ptr.Delegate(hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipRecordMetafileFileName_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)]string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafileFileName_delegate> GdipRecordMetafileFileName_ptr;\n            internal static int GdipRecordMetafileFileName(string filename, IntPtr hdc, EmfType type, ref RectangleF frameRect, MetafileFrameUnit frameUnit, string description, out IntPtr metafile) => GdipRecordMetafileFileName_ptr.Delegate(filename, hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipRecordMetafileFileNameI_delegate([MarshalAs(UnmanagedType.LPWStr)]string filename, IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)]string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafileFileNameI_delegate> GdipRecordMetafileFileNameI_ptr;\n            internal static int GdipRecordMetafileFileNameI(string filename, IntPtr hdc, EmfType type, ref Rectangle frameRect, MetafileFrameUnit frameUnit, string description, out IntPtr metafile) => GdipRecordMetafileFileNameI_ptr.Delegate(filename, hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipCreateFromContext_macosx_delegate(IntPtr cgref, int width, int height, out IntPtr graphics);\n            private static FunctionWrapper<GdipCreateFromContext_macosx_delegate> GdipCreateFromContext_macosx_ptr;\n            internal static int GdipCreateFromContext_macosx(IntPtr cgref, int width, int height, out IntPtr graphics) => GdipCreateFromContext_macosx_ptr.Delegate(cgref, width, height, out graphics);\n\n            private delegate int GdipSetVisibleClip_linux_delegate(IntPtr graphics, ref Rectangle rect);\n            private static FunctionWrapper<GdipSetVisibleClip_linux_delegate> GdipSetVisibleClip_linux_ptr;\n            internal static int GdipSetVisibleClip_linux(IntPtr graphics, ref Rectangle rect) => GdipSetVisibleClip_linux_ptr.Delegate(graphics, ref rect);\n\n            private delegate int GdipCreateFromXDrawable_linux_delegate(IntPtr drawable, IntPtr display, out IntPtr graphics);\n            private static FunctionWrapper<GdipCreateFromXDrawable_linux_delegate> GdipCreateFromXDrawable_linux_ptr;\n            internal static int GdipCreateFromXDrawable_linux(IntPtr drawable, IntPtr display, out IntPtr graphics) => GdipCreateFromXDrawable_linux_ptr.Delegate(drawable, display, out graphics);\n\n            // Stream functions for non-Win32 (libgdiplus specific)\n            private delegate int GdipLoadImageFromDelegate_linux_delegate(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, out IntPtr image);\n            private static FunctionWrapper<GdipLoadImageFromDelegate_linux_delegate> GdipLoadImageFromDelegate_linux_ptr;\n            internal static int GdipLoadImageFromDelegate_linux(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, out IntPtr image)\n                => GdipLoadImageFromDelegate_linux_ptr.Delegate(getHeader, getBytes, putBytes, doSeek, close, size, out image);\n\n            private delegate int GdipSaveImageToDelegate_linux_delegate(IntPtr image, StreamGetBytesDelegate getBytes,\n                StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close,\n                StreamSizeDelegate size, ref Guid encoderClsID, IntPtr encoderParameters);\n            private static FunctionWrapper<GdipSaveImageToDelegate_linux_delegate> GdipSaveImageToDelegate_linux_ptr;\n            internal static int GdipSaveImageToDelegate_linux(IntPtr image, StreamGetBytesDelegate getBytes,\n                StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek, StreamCloseDelegate close,\n                StreamSizeDelegate size, ref Guid encoderClsID, IntPtr encoderParameters)\n                => GdipSaveImageToDelegate_linux_ptr.Delegate(image, getBytes, putBytes, doSeek, close, size, ref encoderClsID, encoderParameters);\n\n            private delegate int GdipCreateMetafileFromDelegate_linux_delegate(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, out IntPtr metafile);\n            private static FunctionWrapper<GdipCreateMetafileFromDelegate_linux_delegate> GdipCreateMetafileFromDelegate_linux_ptr;\n            internal static int GdipCreateMetafileFromDelegate_linux(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, out IntPtr metafile)\n                => GdipCreateMetafileFromDelegate_linux_ptr.Delegate(getHeader, getBytes, putBytes, doSeek, close, size, out metafile);\n\n            private delegate int GdipGetMetafileHeaderFromDelegate_linux_delegate(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr header);\n            private static FunctionWrapper<GdipGetMetafileHeaderFromDelegate_linux_delegate> GdipGetMetafileHeaderFromDelegate_linux_ptr;\n            internal static int GdipGetMetafileHeaderFromDelegate_linux(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr header)\n                => GdipGetMetafileHeaderFromDelegate_linux_ptr.Delegate(getHeader, getBytes, putBytes, doSeek, close, size, header);\n\n            private delegate int GdipRecordMetafileFromDelegate_linux_delegate(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, ref RectangleF frameRect,\n                MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafileFromDelegate_linux_delegate> GdipRecordMetafileFromDelegate_linux_ptr;\n            internal static int GdipRecordMetafileFromDelegate_linux(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, ref RectangleF frameRect,\n                MetafileFrameUnit frameUnit, string description, out IntPtr metafile)\n                => GdipRecordMetafileFromDelegate_linux_ptr.Delegate(getHeader, getBytes, putBytes, doSeek, close, size, hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipRecordMetafileFromDelegateI_linux_delegate(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, ref Rectangle frameRect,\n                MetafileFrameUnit frameUnit, [MarshalAs(UnmanagedType.LPWStr)] string description, out IntPtr metafile);\n            private static FunctionWrapper<GdipRecordMetafileFromDelegateI_linux_delegate> GdipRecordMetafileFromDelegateI_linux_ptr;\n            internal static int GdipRecordMetafileFromDelegateI_linux(StreamGetHeaderDelegate getHeader,\n                StreamGetBytesDelegate getBytes, StreamPutBytesDelegate putBytes, StreamSeekDelegate doSeek,\n                StreamCloseDelegate close, StreamSizeDelegate size, IntPtr hdc, EmfType type, ref Rectangle frameRect,\n                MetafileFrameUnit frameUnit, string description, out IntPtr metafile)\n                => GdipRecordMetafileFromDelegateI_linux_ptr.Delegate(getHeader, getBytes, putBytes, doSeek, close, size, hdc, type, ref frameRect, frameUnit, description, out metafile);\n\n            private delegate int GdipGetPostScriptGraphicsContext_delegate(string filename, int width, int height, double dpix, double dpiy, ref IntPtr graphics);\n            private static FunctionWrapper<GdipGetPostScriptGraphicsContext_delegate> GdipGetPostScriptGraphicsContext_ptr;\n            internal static int GdipGetPostScriptGraphicsContext([MarshalAs(UnmanagedType.LPStr)]string filename, int width, int height, double dpix, double dpiy, ref IntPtr graphics)\n                => GdipGetPostScriptGraphicsContext_ptr.Delegate(filename, width, height, dpix, dpiy, ref graphics);\n\n            private delegate int GdipGetPostScriptSavePage_delegate(IntPtr graphics);\n            private static FunctionWrapper<GdipGetPostScriptSavePage_delegate> GdipGetPostScriptSavePage_ptr;\n            internal static int GdipGetPostScriptSavePage(IntPtr graphics) => GdipGetPostScriptSavePage_ptr.Delegate(graphics);\n        }\n    }\n\n    // These are unix-only\n    internal delegate int StreamGetHeaderDelegate(IntPtr buf, int bufsz);\n    internal delegate int StreamGetBytesDelegate(IntPtr buf, int bufsz, bool peek);\n    internal delegate long StreamSeekDelegate(int offset, int whence);\n    internal delegate int StreamPutBytesDelegate(IntPtr buf, int bufsz);\n    internal delegate void StreamCloseDelegate();\n    internal delegate long StreamSizeDelegate();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/bockbuild/packages/patches/cairo-fix-color-bitmap-fonts.patch": "diff --git a/src/cairo-quartz-font.c b/src/cairo-quartz-font.c\nindex a9bbbdc..48eb071 100644\n--- a/src/cairo-quartz-font.c\n+++ b/src/cairo-quartz-font.c\n@@ -95,6 +95,10 @@ static int (*CGFontGetAscentPtr) (CGFontRef fontRef) = NULL;\n static int (*CGFontGetDescentPtr) (CGFontRef fontRef) = NULL;\n static int (*CGFontGetLeadingPtr) (CGFontRef fontRef) = NULL;\n\n+/* CTFontCreateWithGraphicsFont is not public until 10.5. */\n+typedef const struct __CTFontDescriptor *CTFontDescriptorRef;\n+static CTFontRef (*CTFontCreateWithGraphicsFontPtr) (CGFontRef, CGFloat, const CGAffineTransform *, CTFontDescriptorRef) = NULL;\n+\n /* Not public anymore in 64-bits nor in 10.7 */\n static ATSFontRef (*FMGetATSFontRefFromFontPtr) (FMFont iFont) = NULL;\n\n@@ -137,6 +141,8 @@ quartz_font_ensure_symbols(void)\n     CGContextGetAllowsFontSmoothingPtr = dlsym(RTLD_DEFAULT, \"CGContextGetAllowsFontSmoothing\");\n     CGContextSetAllowsFontSmoothingPtr = dlsym(RTLD_DEFAULT, \"CGContextSetAllowsFontSmoothing\");\n\n+    CTFontCreateWithGraphicsFontPtr = dlsym(RTLD_DEFAULT, \"CTFontCreateWithGraphicsFont\");\n+\n     FMGetATSFontRefFromFontPtr = dlsym(RTLD_DEFAULT, \"FMGetATSFontRefFromFont\");\n\n     if ((CGFontCreateWithFontNamePtr || CGFontCreateWithNamePtr) &&\n@@ -162,6 +168,7 @@ struct _cairo_quartz_font_face {\n     cairo_font_face_t base;\n\n     CGFontRef cgFont;\n+    CTFontRef ctFont;\n };\n\n /*\n@@ -246,6 +253,10 @@ _cairo_quartz_font_face_destroy (void *abstract_face)\n {\n     cairo_quartz_font_face_t *font_face = (cairo_quartz_font_face_t*) abstract_face;\n\n+    if (font_face->ctFont) {\n+        CFRelease (font_face->ctFont);\n+    }\n+\n     CGFontRelease (font_face->cgFont);\n }\n\n@@ -370,6 +381,12 @@ cairo_quartz_font_face_create_for_cgfont (CGFontRef font)\n\n     font_face->cgFont = CGFontRetain (font);\n\n+    if (CTFontCreateWithGraphicsFontPtr) {\n+        font_face->ctFont = CTFontCreateWithGraphicsFontPtr (font, 1.0, NULL, NULL);\n+    } else {\n+        font_face->ctFont = NULL;\n+    }\n+\n     _cairo_font_face_init (&font_face->base, &_cairo_quartz_font_face_backend);\n\n     return &font_face->base;\n@@ -812,6 +829,14 @@ _cairo_quartz_scaled_font_get_cg_font_ref (cairo_scaled_font_t *abstract_font)\n     return ffont->cgFont;\n }\n\n+CTFontRef\n+_cairo_quartz_scaled_font_get_ct_font_ref (cairo_scaled_font_t *abstract_font)\n+{\n+    cairo_quartz_font_face_t *ffont = _cairo_quartz_scaled_to_face(abstract_font);\n+\n+    return ffont->ctFont;\n+}\n+\n /*\n  * compat with old ATSUI backend\n  */\ndiff --git a/src/cairo-quartz-private.h b/src/cairo-quartz-private.h\nindex f841a49..3c1e5aa 100644\n--- a/src/cairo-quartz-private.h\n+++ b/src/cairo-quartz-private.h\n@@ -57,6 +57,9 @@ typedef enum {\n     DO_TILED_IMAGE\n } cairo_quartz_action_t;\n\n+/* define CTFontRef for pre-10.5 SDKs */\n+typedef const struct __CTFont *CTFontRef;\n+\n typedef struct cairo_quartz_surface {\n     cairo_surface_t base;\n\n@@ -97,6 +100,9 @@ CairoQuartzCreateCGImage (cairo_format_t format,\n cairo_private CGFontRef\n _cairo_quartz_scaled_font_get_cg_font_ref (cairo_scaled_font_t *sfont);\n\n+CTFontRef\n+_cairo_quartz_scaled_font_get_ct_font_ref (cairo_scaled_font_t *sfont);\n+\n #else\n\n # error Cairo was not compiled with support for the quartz backend\ndiff --git a/src/cairo-quartz-surface.c b/src/cairo-quartz-surface.c\nindex 1e2bbec..417255c 100644\n--- a/src/cairo-quartz-surface.c\n+++ b/src/cairo-quartz-surface.c\n@@ -123,6 +123,9 @@ static void (*CGContextSetAllowsFontSmoothingPtr) (CGContextRef, bool) = NULL;\n static unsigned int (*CGContextGetTypePtr) (CGContextRef) = NULL;\n static bool (*CGContextGetAllowsFontSmoothingPtr) (CGContextRef) = NULL;\n\n+/* CTFontDrawGlyphs is not available until 10.7 */\n+static void (*CTFontDrawGlyphsPtr) (CTFontRef, const CGGlyph[], const CGPoint[], size_t, CGContextRef) = NULL;\n+\n static cairo_bool_t _cairo_quartz_symbol_lookup_done = FALSE;\n\n /*\n@@ -155,6 +158,8 @@ static void quartz_ensure_symbols (void)\n     CGContextGetAllowsFontSmoothingPtr = dlsym (RTLD_DEFAULT, \"CGContextGetAllowsFontSmoothing\");\n     CGContextSetAllowsFontSmoothingPtr = dlsym (RTLD_DEFAULT, \"CGContextSetAllowsFontSmoothing\");\n\n+    CTFontDrawGlyphsPtr = dlsym(RTLD_DEFAULT, \"CTFontDrawGlyphs\");\n+\n     _cairo_quartz_symbol_lookup_done = TRUE;\n }\n\n@@ -2026,30 +2031,50 @@ _cairo_quartz_cg_glyphs (const cairo_compositor_t *compositor,\n     CGContextSetTextPosition (state.cgMaskContext, 0.0, 0.0);\n     CGContextSetTextMatrix (state.cgMaskContext, CGAffineTransformIdentity);\n\n-    /* Convert our glyph positions to glyph advances.  We need n-1 advances,\n-     * since the advance at index 0 is applied after glyph 0. */\n-    xprev = glyphs[0].x;\n-    yprev = glyphs[0].y;\n-\n-    cg_glyphs[0] = glyphs[0].index;\n-\n-    for (i = 1; i < num_glyphs; i++) {\n-\tcairo_quartz_float_t xf = glyphs[i].x;\n-\tcairo_quartz_float_t yf = glyphs[i].y;\n-\tcg_glyphs[i] = glyphs[i].index;\n-\tcg_advances[i - 1] = CGSizeApplyAffineTransform (CGSizeMake (xf - xprev, yf - yprev), invTextTransform);\n-\txprev = xf;\n-\typrev = yf;\n-    }\n-\n     /* Translate to the first glyph's position before drawing */\n     CGContextTranslateCTM (state.cgMaskContext, glyphs[0].x, glyphs[0].y);\n     CGContextConcatCTM (state.cgMaskContext, textTransform);\n\n-    CGContextShowGlyphsWithAdvances (state.cgMaskContext,\n-\t\t\t\t     cg_glyphs,\n-\t\t\t\t     cg_advances,\n-\t\t\t\t     num_glyphs);\n+    if (CTFontDrawGlyphsPtr) {\n+        /* If CTFontDrawGlyphs is available (i.e. OS X 10.7 or later), we want to use\n+         * that in preference to CGContextShowGlyphsWithAdvances so that colored-bitmap\n+         * fonts like Apple Color Emoji will render properly.\n+         * For this, we need to convert our glyph positions to Core Graphics's CGPoint.\n+         * We borrow the cg_advances array, as CGPoint and CGSize are the same size. */\n+\n+        CGPoint *cg_positions = (CGPoint*) cg_advances;\n+        cairo_quartz_float_t origin_x = glyphs[0].x;\n+        cairo_quartz_float_t origin_y = glyphs[0].y;\n+\n+        for (i = 0; i < num_glyphs; i++) {\n+            CGPoint pt = CGPointMake (glyphs[i].x - origin_x, glyphs[i].y - origin_y);\n+            cg_positions[i] = CGPointApplyAffineTransform (pt, invTextTransform);\n+            cg_glyphs[i] = glyphs[i].index;\n+        }\n+\n+        CTFontDrawGlyphsPtr (_cairo_quartz_scaled_font_get_ct_font_ref (scaled_font),\n+                             cg_glyphs, cg_positions, num_glyphs, state.cgMaskContext);\n+    } else {\n+        /* Convert our glyph positions to glyph advances.  We need n-1 advances,\n+         * since the advance at index 0 is applied after glyph 0. */\n+        xprev = glyphs[0].x;\n+        yprev = glyphs[0].y;\n+\n+        cg_glyphs[0] = glyphs[0].index;\n+\n+        for (i = 1; i < num_glyphs; i++) {\n+            cairo_quartz_float_t xf = glyphs[i].x;\n+            cairo_quartz_float_t yf = glyphs[i].y;\n+            cg_glyphs[i] = glyphs[i].index;\n+            cg_advances[i - 1] = CGSizeApplyAffineTransform (CGSizeMake (xf - xprev, yf - yprev), invTextTransform);\n+            xprev = xf;\n+            yprev = yf;\n+        }\n+        CGContextShowGlyphsWithAdvances (state.cgMaskContext,\n+                                         cg_glyphs,\n+                                         cg_advances,\n+                                         num_glyphs);\n+    }\n\n     CGContextConcatCTM (state.cgMaskContext, invTextTransform);\n     CGContextTranslateCTM (state.cgMaskContext, -glyphs[0].x, -glyphs[0].y);\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/bockbuild/packages/patches/cairo-cglayer.patch": "--- a/src/cairo-quartz-font.c\t2012-11-13 18:20:00.000000000 -0800\n+++ b/src/cairo-quartz-font.c\t2012-11-13 18:06:56.000000000 -0800\n@@ -90,8 +90,9 @@ static int (*CGFontGetAscentPtr) (CGFont\n static int (*CGFontGetDescentPtr) (CGFontRef fontRef) = NULL;\n static int (*CGFontGetLeadingPtr) (CGFontRef fontRef) = NULL;\n\n-/* Not public anymore in 64-bits nor in 10.7 */\n-static ATSFontRef (*FMGetATSFontRefFromFontPtr) (FMFont iFont) = NULL;\n+/* CTFontCreateWithGraphicsFont is not public until 10.5. */\n+typedef const struct __CTFontDescriptor *CTFontDescriptorRef;\n+static CTFontRef (*CTFontCreateWithGraphicsFontPtr) (CGFontRef, CGFloat, const CGAffineTransform *, CTFontDescriptorRef) = NULL;\n\n static cairo_bool_t _cairo_quartz_font_symbol_lookup_done = FALSE;\n static cairo_bool_t _cairo_quartz_font_symbols_present = FALSE;\n@@ -130,7 +131,7 @@ quartz_font_ensure_symbols(void)\n     CGContextGetAllowsFontSmoothingPtr = dlsym(RTLD_DEFAULT, \"CGContextGetAllowsFontSmoothing\");\n     CGContextSetAllowsFontSmoothingPtr = dlsym(RTLD_DEFAULT, \"CGContextSetAllowsFontSmoothing\");\n\n-    FMGetATSFontRefFromFontPtr = dlsym(RTLD_DEFAULT, \"FMGetATSFontRefFromFont\");\n+    CTFontCreateWithGraphicsFontPtr = dlsym(RTLD_DEFAULT, \"CTFontCreateWithGraphicsFont\");\n\n     if ((CGFontCreateWithFontNamePtr || CGFontCreateWithNamePtr) &&\n\tCGFontGetGlyphBBoxesPtr &&\n@@ -155,6 +156,7 @@ struct _cairo_quartz_font_face {\n     cairo_font_face_t base;\n\n     CGFontRef cgFont;\n+    CTFontRef ctFont;\n };\n\n /*\n@@ -239,6 +241,10 @@ _cairo_quartz_font_face_destroy (void *a\n {\n     cairo_quartz_font_face_t *font_face = (cairo_quartz_font_face_t*) abstract_face;\n\n+    if (font_face->ctFont) {\n+        CFRelease (font_face->ctFont);\n+    }\n+\n     CGFontRelease (font_face->cgFont);\n }\n\n@@ -363,6 +369,12 @@ cairo_quartz_font_face_create_for_cgfont\n\n     font_face->cgFont = CGFontRetain (font);\n\n+    if (CTFontCreateWithGraphicsFontPtr) {\n+        font_face->ctFont = CTFontCreateWithGraphicsFontPtr (font, 1.0, NULL, NULL);\n+    } else {\n+        font_face->ctFont = NULL;\n+    }\n+\n     _cairo_font_face_init (&font_face->base, &_cairo_quartz_font_face_backend);\n\n     return &font_face->base;\n@@ -782,49 +794,10 @@ _cairo_quartz_scaled_font_get_cg_font_re\n     return ffont->cgFont;\n }\n\n-/*\n- * compat with old ATSUI backend\n- */\n-\n-/**\n- * cairo_quartz_font_face_create_for_atsu_font_id\n- * @font_id: an ATSUFontID for the font.\n- *\n- * Creates a new font for the Quartz font backend based on an\n- * #ATSUFontID. This font can then be used with\n- * cairo_set_font_face() or cairo_scaled_font_create().\n- *\n- * Return value: a newly created #cairo_font_face_t. Free with\n- *  cairo_font_face_destroy() when you are done using it.\n- *\n- * Since: 1.6\n- **/\n-cairo_font_face_t *\n-cairo_quartz_font_face_create_for_atsu_font_id (ATSUFontID font_id)\n+CTFontRef\n+_cairo_quartz_scaled_font_get_ct_font_ref (cairo_scaled_font_t *abstract_font)\n {\n-    quartz_font_ensure_symbols();\n-\n-    if (FMGetATSFontRefFromFontPtr != NULL) {\n-\tATSFontRef atsFont = FMGetATSFontRefFromFontPtr (font_id);\n-\tCGFontRef cgFont = CGFontCreateWithPlatformFont (&atsFont);\n-\tcairo_font_face_t *ff;\n-\n-\tff = cairo_quartz_font_face_create_for_cgfont (cgFont);\n-\n-\tCGFontRelease (cgFont);\n-\n-\treturn ff;\n-    } else {\n-\t_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);\n-\treturn (cairo_font_face_t *)&_cairo_font_face_nil;\n-    }\n-}\n-\n-/* This is the old name for the above function, exported for compat purposes */\n-cairo_font_face_t *cairo_atsui_font_face_create_for_atsu_font_id (ATSUFontID font_id);\n+    cairo_quartz_font_face_t *ffont = _cairo_quartz_scaled_to_face(abstract_font);\n\n-cairo_font_face_t *\n-cairo_atsui_font_face_create_for_atsu_font_id (ATSUFontID font_id)\n-{\n-    return cairo_quartz_font_face_create_for_atsu_font_id (font_id);\n+    return ffont->ctFont;\n }\n--- a/src/cairo-quartz-image-surface.c\t2010-06-18 04:47:13.000000000 -0700\n+++ b/src/cairo-quartz-image-surface.c\t2012-11-13 18:06:56.000000000 -0800\n@@ -148,6 +148,8 @@ _cairo_quartz_image_surface_flush (void\n     surface->image = newImage;\n     CGImageRelease (oldImage);\n\n+    surface->base.is_clear = surface->imageSurface->base.is_clear;\n+\n     return CAIRO_STATUS_SUCCESS;\n }\n\n@@ -270,6 +272,8 @@ cairo_quartz_image_surface_create (cairo\n     qisurf->image = image;\n     qisurf->imageSurface = image_surface;\n\n+    qisurf->base.is_clear = image_surface->base.is_clear;\n+\n     return &qisurf->base;\n }\n\n--- a/src/cairo-quartz-private.h\t2010-12-25 06:21:34.000000000 -0800\n+++ b/src/cairo-quartz-private.h\t2012-11-13 18:06:56.000000000 -0800\n@@ -50,6 +50,9 @@ typedef CGFloat cairo_quartz_float_t;\n typedef float cairo_quartz_float_t;\n #endif\n\n+/* define CTFontRef for pre-10.5 SDKs */\n+typedef const struct __CTFont *CTFontRef;\n+\n typedef struct cairo_quartz_surface {\n     cairo_surface_t base;\n\n@@ -60,21 +63,22 @@ typedef struct cairo_quartz_surface {\n     cairo_surface_t *imageSurfaceEquiv;\n\n     cairo_surface_clipper_t clipper;\n-    cairo_rectangle_int_t extents;\n\n-    /* These are stored while drawing operations are in place, set up\n-     * by quartz_setup_source() and quartz_finish_source()\n+    /**\n+     * If non-null, this is a CGImage representing the contents of the surface.\n+     * We clear this out before any painting into the surface, so that we\n+     * don't force a copy to be created.\n      */\n-    CGAffineTransform sourceTransform;\n+    CGImageRef bitmapContextImage;\n\n-    CGImageRef sourceImage;\n-    cairo_surface_t *sourceImageSurface;\n-    CGRect sourceImageRect;\n+    /**\n+     * If non-null, this is the CGLayer for the surface.\n+     */\n+    CGLayerRef cgLayer;\n\n-    CGShadingRef sourceShading;\n-    CGPatternRef sourcePattern;\n+    cairo_rectangle_int_t extents;\n\n-    CGInterpolationQuality oldInterpolationQuality;\n+    cairo_bool_t ownsData;\n } cairo_quartz_surface_t;\n\n typedef struct cairo_quartz_image_surface {\n@@ -103,6 +107,9 @@ _cairo_quartz_create_cgimage (cairo_form\n CGFontRef\n _cairo_quartz_scaled_font_get_cg_font_ref (cairo_scaled_font_t *sfont);\n\n+CTFontRef\n+_cairo_quartz_scaled_font_get_ct_font_ref (cairo_scaled_font_t *sfont);\n+\n #else\n\n # error Cairo was not compiled with support for the quartz backend\n--- a/src/cairo-quartz-surface.c\t2012-11-13 18:20:00.000000000 -0800\n+++ b/src/cairo-quartz-surface.c\t2012-11-13 18:06:56.000000000 -0800\n@@ -41,6 +41,8 @@\n\n #include \"cairo-error-private.h\"\n #include \"cairo-surface-clipper-private.h\"\n+#include \"cairo-gstate-private.h\"\n+#include \"cairo-private.h\"\n\n #include <dlfcn.h>\n\n@@ -77,6 +79,11 @@\n  * This macro can be used to conditionally compile backend-specific code.\n  */\n\n+/* Here are some of the differences between cairo and CoreGraphics\n+   - cairo has only a single source active at once vs. CoreGraphics having\n+     separate sources for stroke and fill\n+*/\n+\n /* This method is private, but it exists.  Its params are are exposed\n  * as args to the NS* method, but not as CG.\n  */\n@@ -126,6 +133,12 @@ static void (*CGContextSetShouldAntialia\n static void (*CGContextSetAllowsFontSmoothingPtr) (CGContextRef, bool) = NULL;\n static bool (*CGContextGetAllowsFontSmoothingPtr) (CGContextRef) = NULL;\n static CGPathRef (*CGContextCopyPathPtr) (CGContextRef) = NULL;\n+static CGFloat (*CGContextGetAlphaPtr) (CGContextRef) = NULL;\n+\n+/* CTFontDrawGlyphs is not available until 10.7 */\n+static void (*CTFontDrawGlyphsPtr) (CTFontRef, const CGGlyph[], const CGPoint[], size_t, CGContextRef) = NULL;\n+\n+static SInt32 _cairo_quartz_osx_version = 0x0;\n\n static cairo_bool_t _cairo_quartz_symbol_lookup_done = FALSE;\n\n@@ -160,6 +173,14 @@ static void quartz_ensure_symbols(void)\n     CGContextCopyPathPtr = dlsym(RTLD_DEFAULT, \"CGContextCopyPath\");\n     CGContextGetAllowsFontSmoothingPtr = dlsym(RTLD_DEFAULT, \"CGContextGetAllowsFontSmoothing\");\n     CGContextSetAllowsFontSmoothingPtr = dlsym(RTLD_DEFAULT, \"CGContextSetAllowsFontSmoothing\");\n+    CGContextGetAlphaPtr = dlsym(RTLD_DEFAULT, \"CGContextGetAlpha\");\n+\n+    CTFontDrawGlyphsPtr = dlsym(RTLD_DEFAULT, \"CTFontDrawGlyphs\");\n+\n+    if (Gestalt(gestaltSystemVersion, &_cairo_quartz_osx_version) != noErr) {\n+        // assume 10.5\n+        _cairo_quartz_osx_version = 0x1050;\n+    }\n\n     _cairo_quartz_symbol_lookup_done = TRUE;\n }\n@@ -430,6 +446,7 @@ _cairo_quartz_cairo_operator_to_quartz_c\n\tcase CAIRO_OPERATOR_HSL_LUMINOSITY:\n         default:\n\t    assert (0);\n+\t    return kPrivateCGCompositeClear;\n     }\n }\n\n@@ -598,10 +615,13 @@ _cairo_quartz_cairo_matrix_to_quartz (co\n typedef struct {\n     bool isClipping;\n     CGGlyph *cg_glyphs;\n-    CGSize *cg_advances;\n+    union {\n+      CGSize *cg_advances;\n+      CGPoint *cg_positions;\n+    } u;\n     size_t nglyphs;\n     CGAffineTransform textTransform;\n-    CGFontRef font;\n+    cairo_scaled_font_t *scaled_font;\n     CGPoint origin;\n } unbounded_show_glyphs_t;\n\n@@ -679,12 +699,6 @@ _cairo_quartz_fixup_unbounded_operation\n\telse\n\t    CGContextEOFillPath (cgc);\n     } else if (op->op == UNBOUNDED_SHOW_GLYPHS) {\n-\tCGContextSetFont (cgc, op->u.show_glyphs.font);\n-\tCGContextSetFontSize (cgc, 1.0);\n-\tCGContextSetTextMatrix (cgc, CGAffineTransformIdentity);\n-\tCGContextTranslateCTM (cgc, op->u.show_glyphs.origin.x, op->u.show_glyphs.origin.y);\n-\tCGContextConcatCTM (cgc, op->u.show_glyphs.textTransform);\n-\n\tif (op->u.show_glyphs.isClipping) {\n\t    /* Note that the comment in show_glyphs about kCGTextClip\n\t     * and the text transform still applies here; however, the\n@@ -693,12 +707,25 @@ _cairo_quartz_fixup_unbounded_operation\n\t    CGContextSetTextDrawingMode (cgc, kCGTextClip);\n\t    CGContextSaveGState (cgc);\n\t}\n+        CGContextTranslateCTM (cgc, op->u.show_glyphs.origin.x, op->u.show_glyphs.origin.y);\n+        CGContextConcatCTM (cgc, op->u.show_glyphs.textTransform);\n+        if (CTFontDrawGlyphsPtr) {\n+            CTFontDrawGlyphsPtr (_cairo_quartz_scaled_font_get_ct_font_ref (op->u.show_glyphs.scaled_font),\n+                                 op->u.show_glyphs.cg_glyphs,\n+                                 op->u.show_glyphs.u.cg_positions,\n+                                 op->u.show_glyphs.nglyphs,\n+                                 cgc);\n+        } else {\n+\t    CGContextSetFont (cgc, _cairo_quartz_scaled_font_get_cg_font_ref (op->u.show_glyphs.scaled_font));\n+\t    CGContextSetFontSize (cgc, 1.0);\n+\t    CGContextSetTextMatrix (cgc, CGAffineTransformIdentity);\n+\n+\t    CGContextShowGlyphsWithAdvances (cgc,\n+\t\t\t\t\t     op->u.show_glyphs.cg_glyphs,\n+\t\t\t\t\t     op->u.show_glyphs.u.cg_advances,\n+\t\t\t\t\t     op->u.show_glyphs.nglyphs);\n\n-\tCGContextShowGlyphsWithAdvances (cgc,\n-\t\t\t\t\t op->u.show_glyphs.cg_glyphs,\n-\t\t\t\t\t op->u.show_glyphs.cg_advances,\n-\t\t\t\t\t op->u.show_glyphs.nglyphs);\n-\n+        }\n\tif (op->u.show_glyphs.isClipping) {\n\t    CGContextClearRect (cgc, clipBoxRound);\n\t    CGContextRestoreGState (cgc);\n@@ -1102,12 +1129,12 @@ DataProviderReleaseCallback (void *info,\n {\n     quartz_source_image_t *source_img = info;\n     _cairo_surface_release_source_image (source_img->surface, source_img->image_out, source_img->image_extra);\n+    cairo_surface_destroy (source_img->surface);\n     free (source_img);\n }\n\n static cairo_status_t\n-_cairo_surface_to_cgimage (cairo_surface_t *target,\n-\t\t\t   cairo_surface_t *source,\n+_cairo_surface_to_cgimage (cairo_surface_t *source,\n\t\t\t   CGImageRef *image_out)\n {\n     cairo_status_t status;\n@@ -1127,9 +1154,14 @@ _cairo_surface_to_cgimage (cairo_surface\n\t}\n\n\tif (_cairo_quartz_is_cgcontext_bitmap_context (surface->cgContext)) {\n-\t    *image_out = CGBitmapContextCreateImage (surface->cgContext);\n-\t    if (*image_out)\n-\t\treturn CAIRO_STATUS_SUCCESS;\n+\t    if (!surface->bitmapContextImage) {\n+\t        surface->bitmapContextImage =\n+\t            CGBitmapContextCreateImage (surface->cgContext);\n+\t    }\n+\t    if (surface->bitmapContextImage) {\n+                *image_out = CGImageRetain (surface->bitmapContextImage);\n+                return CAIRO_STATUS_SUCCESS;\n+            }\n\t}\n     }\n\n@@ -1137,10 +1169,11 @@ _cairo_surface_to_cgimage (cairo_surface\n     if (source_img == NULL)\n\treturn _cairo_error (CAIRO_STATUS_NO_MEMORY);\n\n-    source_img->surface = source;\n+    source_img->surface = cairo_surface_reference(source);\n\n     status = _cairo_surface_acquire_source_image (source_img->surface, &source_img->image_out, &source_img->image_extra);\n     if (status) {\n+\tcairo_surface_destroy (source_img->surface);\n\tfree (source_img);\n\treturn status;\n     }\n@@ -1251,7 +1284,7 @@ _cairo_quartz_cairo_repeating_surface_pa\n     is_bounded = _cairo_surface_get_extents (pat_surf, &extents);\n     assert (is_bounded);\n\n-    status = _cairo_surface_to_cgimage ((cairo_surface_t*) dest, pat_surf, &image);\n+    status = _cairo_surface_to_cgimage (pat_surf, &image);\n     if (status)\n\treturn status;\n     if (image == NULL)\n@@ -1322,16 +1355,43 @@ typedef enum {\n     DO_SHADING,\n     DO_PATTERN,\n     DO_IMAGE,\n+    DO_TILED_IMAGE,\n+    DO_LAYER,\n     DO_UNSUPPORTED,\n-    DO_NOTHING,\n-    DO_TILED_IMAGE\n+    DO_NOTHING\n } cairo_quartz_action_t;\n\n-static cairo_quartz_action_t\n+/* State used during a drawing operation. */\n+typedef struct {\n+    CGContextRef context;\n+    cairo_quartz_action_t action;\n+\n+    // Used with DO_SHADING, DO_IMAGE, DO_TILED_IMAGE and DO_LAYER\n+    CGAffineTransform transform;\n+\n+    // Used with DO_IMAGE and DO_TILED_IMAGE\n+    CGImageRef image;\n+    cairo_surface_t *imageSurface;\n+\n+    // Used with DO_IMAGE, DO_TILED_IMAGE and DO_LAYER\n+    CGRect imageRect;\n+\n+    // Used with DO_LAYER\n+    CGLayerRef layer;\n+\n+    // Used with DO_SHADING\n+    CGShadingRef shading;\n+\n+    // Used with DO_PATTERN\n+    CGPatternRef pattern;\n+} cairo_quartz_drawing_state_t;\n+\n+static void\n _cairo_quartz_setup_fallback_source (cairo_quartz_surface_t *surface,\n-\t\t\t\t     const cairo_pattern_t *source)\n+\t\t\t\t     const cairo_pattern_t *source,\n+\t\t\t\t     cairo_quartz_drawing_state_t *state)\n {\n-    CGRect clipBox = CGContextGetClipBoundingBox (surface->cgContext);\n+    CGRect clipBox = CGContextGetClipBoundingBox (state->context);\n     double x0, y0, w, h;\n\n     cairo_surface_t *fallback;\n@@ -1340,8 +1400,10 @@ _cairo_quartz_setup_fallback_source (cai\n     cairo_status_t status;\n\n     if (clipBox.size.width == 0.0f ||\n-\tclipBox.size.height == 0.0f)\n-\treturn DO_NOTHING;\n+\tclipBox.size.height == 0.0f) {\n+\tstate->action = DO_NOTHING;\n+\treturn;\n+    }\n\n     x0 = floor(clipBox.origin.x);\n     y0 = floor(clipBox.origin.y);\n@@ -1384,18 +1446,21 @@ _cairo_quartz_setup_fallback_source (cai\n     }\n #endif\n\n-    status = _cairo_surface_to_cgimage (&surface->base, fallback, &img);\n-    if (status)\n-\treturn DO_UNSUPPORTED;\n-    if (img == NULL)\n-\treturn DO_NOTHING;\n-\n-    surface->sourceImageRect = CGRectMake (0.0, 0.0, w, h);\n-    surface->sourceImage = img;\n-    surface->sourceImageSurface = fallback;\n-    surface->sourceTransform = CGAffineTransformMakeTranslation (x0, y0);\n+    status = _cairo_surface_to_cgimage (fallback, &img);\n+    if (status) {\n+        state->action = DO_UNSUPPORTED;\n+\treturn;\n+    }\n+    if (img == NULL) {\n+        state->action = DO_NOTHING;\n+\treturn;\n+    }\n\n-    return DO_IMAGE;\n+    state->imageRect = CGRectMake (0.0, 0.0, w, h);\n+    state->image = img;\n+    state->imageSurface = fallback;\n+    state->transform = CGAffineTransformMakeTranslation (x0, y0);\n+    state->action = DO_IMAGE;\n }\n\n /*\n@@ -1411,10 +1476,11 @@ based on the extents of the object (the\n we don't want the rasterization of the entire gradient to depend on the\n clip region).\n */\n-static cairo_quartz_action_t\n+static void\n _cairo_quartz_setup_linear_source (cairo_quartz_surface_t *surface,\n\t\t\t\t   const cairo_linear_pattern_t *lpat,\n-\t\t\t\t   cairo_rectangle_int_t *extents)\n+\t\t\t\t   cairo_rectangle_int_t *extents,\n+\t\t\t\t   cairo_quartz_drawing_state_t *state)\n {\n     const cairo_pattern_t *abspat = &lpat->base.base;\n     cairo_matrix_t mat;\n@@ -1424,9 +1490,10 @@ _cairo_quartz_setup_linear_source (cairo\n     bool extend = abspat->extend == CAIRO_EXTEND_PAD;\n\n     if (lpat->base.n_stops == 0) {\n-\tCGContextSetRGBStrokeColor (surface->cgContext, 0., 0., 0., 0.);\n-\tCGContextSetRGBFillColor (surface->cgContext, 0., 0., 0., 0.);\n-\treturn DO_SOLID;\n+\tCGContextSetRGBStrokeColor (state->context, 0., 0., 0., 0.);\n+\tCGContextSetRGBFillColor (state->context, 0., 0., 0., 0.);\n+\tstate->action = DO_SOLID;\n+\treturn;\n     }\n\n     if (lpat->p1.x == lpat->p2.x &&\n@@ -1436,12 +1503,13 @@ _cairo_quartz_setup_linear_source (cairo\n\t * Whatever the correct behaviour is, let's at least have only pixman's\n\t * implementation to worry about.\n\t */\n-\treturn _cairo_quartz_setup_fallback_source (surface, abspat);\n+\t_cairo_quartz_setup_fallback_source (surface, abspat, state);\n+\treturn;\n     }\n\n     mat = abspat->matrix;\n     cairo_matrix_invert (&mat);\n-    _cairo_quartz_cairo_matrix_to_quartz (&mat, &surface->sourceTransform);\n+    _cairo_quartz_cairo_matrix_to_quartz (&mat, &state->transform);\n\n     rgb = CGColorSpaceCreateDeviceRGB();\n\n@@ -1461,21 +1529,22 @@ _cairo_quartz_setup_linear_source (cairo\n\t\t\t\t\t\t          extents);\n     }\n\n-    surface->sourceShading = CGShadingCreateAxial (rgb,\n-\t\t\t\t\t\t   start, end,\n-\t\t\t\t\t\t   gradFunc,\n-\t\t\t\t\t\t   extend, extend);\n+    state->shading = CGShadingCreateAxial (rgb,\n+\t\t\t\t\t   start, end,\n+\t\t\t\t\t   gradFunc,\n+\t\t\t\t\t   extend, extend);\n\n     CGColorSpaceRelease(rgb);\n     CGFunctionRelease(gradFunc);\n\n-    return DO_SHADING;\n+    state->action = DO_SHADING;\n }\n\n-static cairo_quartz_action_t\n+static void\n _cairo_quartz_setup_radial_source (cairo_quartz_surface_t *surface,\n\t\t\t\t   const cairo_radial_pattern_t *rpat,\n-\t\t\t\t   cairo_rectangle_int_t *extents)\n+\t\t\t\t   cairo_rectangle_int_t *extents,\n+\t\t\t\t   cairo_quartz_drawing_state_t *state)\n {\n     const cairo_pattern_t *abspat = &rpat->base.base;\n     cairo_matrix_t mat;\n@@ -1494,9 +1563,10 @@ _cairo_quartz_setup_radial_source (cairo\n     double centerDistance = sqrt (dx*dx + dy*dy);\n\n     if (rpat->base.n_stops == 0) {\n-\tCGContextSetRGBStrokeColor (surface->cgContext, 0., 0., 0., 0.);\n-\tCGContextSetRGBFillColor (surface->cgContext, 0., 0., 0., 0.);\n-\treturn DO_SOLID;\n+\tCGContextSetRGBStrokeColor (state->context, 0., 0., 0., 0.);\n+\tCGContextSetRGBFillColor (state->context, 0., 0., 0., 0.);\n+\tstate->action = DO_SOLID;\n+\treturn;\n     }\n\n     if (r2 <= centerDistance + r1 + 1e-6 && /* circle 2 doesn't contain circle 1 */\n@@ -1507,12 +1577,13 @@ _cairo_quartz_setup_radial_source (cairo\n\t * implementation to worry about.\n\t * Note that this also catches the cases where r1 == r2.\n\t */\n-\treturn _cairo_quartz_setup_fallback_source (surface, abspat);\n+\t_cairo_quartz_setup_fallback_source (surface, abspat, state);\n+\treturn;\n     }\n\n     mat = abspat->matrix;\n     cairo_matrix_invert (&mat);\n-    _cairo_quartz_cairo_matrix_to_quartz (&mat, &surface->sourceTransform);\n+    _cairo_quartz_cairo_matrix_to_quartz (&mat, &state->transform);\n\n     rgb = CGColorSpaceCreateDeviceRGB();\n\n@@ -1531,90 +1602,79 @@ _cairo_quartz_setup_radial_source (cairo\n\t\t\t\t\t\t          extents);\n     }\n\n-    surface->sourceShading = CGShadingCreateRadial (rgb,\n-\t\t\t\t\t\t    start,\n-\t\t\t\t\t\t    r1,\n-\t\t\t\t\t\t    end,\n-\t\t\t\t\t\t    r2,\n-\t\t\t\t\t\t    gradFunc,\n-\t\t\t\t\t\t    extend, extend);\n+    state->shading = CGShadingCreateRadial (rgb,\n+\t\t\t\t\t    start,\n+\t\t\t\t\t    r1,\n+\t\t\t\t\t    end,\n+\t\t\t\t\t    r2,\n+\t\t\t\t\t    gradFunc,\n+\t\t\t\t\t    extend, extend);\n\n     CGColorSpaceRelease(rgb);\n     CGFunctionRelease(gradFunc);\n\n-    return DO_SHADING;\n+    state->action = DO_SHADING;\n }\n\n-static cairo_quartz_action_t\n-_cairo_quartz_setup_source (cairo_quartz_surface_t *surface,\n-\t\t\t    const cairo_pattern_t *source,\n-\t\t\t    cairo_rectangle_int_t *extents)\n+static void\n+_cairo_quartz_setup_surface_source (cairo_quartz_surface_t *surface,\n+\t\t\t\t    const cairo_surface_pattern_t *spat,\n+\t\t\t\t    cairo_rectangle_int_t *extents,\n+\t\t\t\t    cairo_quartz_drawing_state_t *state)\n {\n-    assert (!(surface->sourceImage || surface->sourceShading || surface->sourcePattern));\n-\n-    surface->oldInterpolationQuality = CGContextGetInterpolationQuality (surface->cgContext);\n-    CGContextSetInterpolationQuality (surface->cgContext, _cairo_quartz_filter_to_quartz (source->filter));\n+    const cairo_pattern_t *source = &spat->base;\n+    CGContextRef context = state->context;\n\n-    if (source->type == CAIRO_PATTERN_TYPE_SOLID) {\n-\tcairo_solid_pattern_t *solid = (cairo_solid_pattern_t *) source;\n-\n-\tCGContextSetRGBStrokeColor (surface->cgContext,\n-\t\t\t\t    solid->color.red,\n-\t\t\t\t    solid->color.green,\n-\t\t\t\t    solid->color.blue,\n-\t\t\t\t    solid->color.alpha);\n-\tCGContextSetRGBFillColor (surface->cgContext,\n-\t\t\t\t  solid->color.red,\n-\t\t\t\t  solid->color.green,\n-\t\t\t\t  solid->color.blue,\n-\t\t\t\t  solid->color.alpha);\n-\n-\treturn DO_SOLID;\n-    }\n-\n-    if (source->type == CAIRO_PATTERN_TYPE_LINEAR) {\n-\tconst cairo_linear_pattern_t *lpat = (const cairo_linear_pattern_t *)source;\n-\treturn _cairo_quartz_setup_linear_source (surface, lpat, extents);\n-    }\n-\n-    if (source->type == CAIRO_PATTERN_TYPE_RADIAL) {\n-\tconst cairo_radial_pattern_t *rpat = (const cairo_radial_pattern_t *)source;\n-\treturn _cairo_quartz_setup_radial_source (surface, rpat, extents);\n-    }\n-\n-    if (source->type == CAIRO_PATTERN_TYPE_SURFACE &&\n-\t(source->extend == CAIRO_EXTEND_NONE || (CGContextDrawTiledImagePtr && source->extend == CAIRO_EXTEND_REPEAT)))\n+    if (source->extend == CAIRO_EXTEND_NONE || source->extend == CAIRO_EXTEND_PAD ||\n+        (CGContextDrawTiledImagePtr && source->extend == CAIRO_EXTEND_REPEAT))\n     {\n-\tconst cairo_surface_pattern_t *spat = (const cairo_surface_pattern_t *) source;\n\tcairo_surface_t *pat_surf = spat->surface;\n\tCGImageRef img;\n\tcairo_matrix_t m = spat->base.matrix;\n\tcairo_rectangle_int_t extents;\n-\tcairo_status_t status;\n\tCGAffineTransform xform;\n\tCGRect srcRect;\n\tcairo_fixed_t fw, fh;\n\tcairo_bool_t is_bounded;\n+\tcairo_bool_t repeat = source->extend == CAIRO_EXTEND_REPEAT;\n+        cairo_status_t status;\n\n-\tstatus = _cairo_surface_to_cgimage ((cairo_surface_t *) surface, pat_surf, &img);\n-\tif (status)\n-\t    return DO_UNSUPPORTED;\n-\tif (img == NULL)\n-\t    return DO_NOTHING;\n+        cairo_matrix_invert(&m);\n+        _cairo_quartz_cairo_matrix_to_quartz (&m, &state->transform);\n\n-\tCGContextSetRGBFillColor (surface->cgContext, 0, 0, 0, 1);\n+        /* Draw nonrepeating CGLayer surface using DO_LAYER */\n+        if (!repeat && cairo_surface_get_type (pat_surf) == CAIRO_SURFACE_TYPE_QUARTZ) {\n+            cairo_quartz_surface_t *quartz_surf = (cairo_quartz_surface_t *) pat_surf;\n+            if (quartz_surf->cgLayer) {\n+         \tstate->imageRect = CGRectMake (0, 0, quartz_surf->extents.width, quartz_surf->extents.height);\n+                state->layer = quartz_surf->cgLayer;\n+                state->action = DO_LAYER;\n+                return;\n+            }\n+        }\n+\n+\tstatus = _cairo_surface_to_cgimage (pat_surf, &img);\n+        if (status) {\n+            state->action = DO_UNSUPPORTED;\n+\t    return;\n+        }\n+        if (img == NULL) {\n+            state->action = DO_NOTHING;\n+\t    return;\n+        }\n\n-\tsurface->sourceImage = img;\n+        /* XXXroc what is this for? */\n+\tCGContextSetRGBFillColor (surface->cgContext, 0, 0, 0, 1);\n\n-\tcairo_matrix_invert(&m);\n-\t_cairo_quartz_cairo_matrix_to_quartz (&m, &surface->sourceTransform);\n+\tstate->image = img;\n\n\tis_bounded = _cairo_surface_get_extents (pat_surf, &extents);\n\tassert (is_bounded);\n\n-\tif (source->extend == CAIRO_EXTEND_NONE) {\n-\t    surface->sourceImageRect = CGRectMake (0, 0, extents.width, extents.height);\n-\t    return DO_IMAGE;\n+\tif (!repeat) {\n+\t    state->imageRect = CGRectMake (0, 0, extents.width, extents.height);\n+\t    state->action = DO_IMAGE;\n+\t    return;\n\t}\n\n\t/* Quartz seems to tile images at pixel-aligned regions only -- this\n@@ -1624,8 +1684,8 @@ _cairo_quartz_setup_source (cairo_quartz\n\t * epsilon), and if not, fall back to the CGPattern type.\n\t */\n\n-\txform = CGAffineTransformConcat (CGContextGetCTM (surface->cgContext),\n-\t\t\t\t\t surface->sourceTransform);\n+\txform = CGAffineTransformConcat (CGContextGetCTM (context),\n+\t\t\t\t\t state->transform);\n\n\tsrcRect = CGRectMake (0, 0, extents.width, extents.height);\n\tsrcRect = CGRectApplyAffineTransform (srcRect, xform);\n@@ -1646,101 +1706,218 @@ _cairo_quartz_setup_source (cairo_quartz\n\n\t    srcRect = CGRectApplyAffineTransform (srcRect, xform);\n\n-\t    surface->sourceImageRect = srcRect;\n-\n-\t    return DO_TILED_IMAGE;\n+\t    state->imageRect = srcRect;\n+            state->action = DO_TILED_IMAGE;\n+            return;\n\t}\n\n\t/* Fall through to generic SURFACE case */\n     }\n\n-    if (source->type == CAIRO_PATTERN_TYPE_SURFACE) {\n-\tcairo_quartz_float_t patternAlpha = 1.0f;\n-\tCGColorSpaceRef patternSpace;\n-\tCGPatternRef pattern;\n-\tcairo_int_status_t status;\n-\n-\tstatus = _cairo_quartz_cairo_repeating_surface_pattern_to_quartz (surface, source, &pattern);\n-\tif (status == CAIRO_INT_STATUS_NOTHING_TO_DO)\n-\t    return DO_NOTHING;\n-\tif (status)\n-\t    return DO_UNSUPPORTED;\n-\n-\t// Save before we change the pattern, colorspace, etc. so that\n-\t// we can restore and make sure that quartz releases our\n-\t// pattern (which may be stack allocated)\n-\tCGContextSaveGState(surface->cgContext);\n-\n-\tpatternSpace = CGColorSpaceCreatePattern(NULL);\n-\tCGContextSetFillColorSpace (surface->cgContext, patternSpace);\n-\tCGContextSetFillPattern (surface->cgContext, pattern, &patternAlpha);\n-\tCGContextSetStrokeColorSpace (surface->cgContext, patternSpace);\n-\tCGContextSetStrokePattern (surface->cgContext, pattern, &patternAlpha);\n-\tCGColorSpaceRelease (patternSpace);\n-\n-\t/* Quartz likes to munge the pattern phase (as yet unexplained\n-\t * why); force it to 0,0 as we've already baked in the correct\n-\t * pattern translation into the pattern matrix\n-\t */\n-\tCGContextSetPatternPhase (surface->cgContext, CGSizeMake(0,0));\n-\n-\tsurface->sourcePattern = pattern;\n+    CGFloat patternAlpha = 1.0f;\n+    CGColorSpaceRef patternSpace;\n+    CGPatternRef pattern;\n+    cairo_int_status_t status;\n\n-\treturn DO_PATTERN;\n+    status = _cairo_quartz_cairo_repeating_surface_pattern_to_quartz (surface, source, &pattern);\n+    if (status == CAIRO_INT_STATUS_NOTHING_TO_DO) {\n+        state->action = DO_NOTHING;\n+\treturn;\n+    }\n+    if (status) {\n+\tstate->action = DO_UNSUPPORTED;\n+\treturn;\n     }\n\n-    return DO_UNSUPPORTED;\n+    patternSpace = CGColorSpaceCreatePattern (NULL);\n+    CGContextSetFillColorSpace (context, patternSpace);\n+    CGContextSetFillPattern (context, pattern, &patternAlpha);\n+    CGContextSetStrokeColorSpace (context, patternSpace);\n+    CGContextSetStrokePattern (context, pattern, &patternAlpha);\n+    CGColorSpaceRelease (patternSpace);\n+\n+    /* Quartz likes to munge the pattern phase (as yet unexplained\n+     * why); force it to 0,0 as we've already baked in the correct\n+     * pattern translation into the pattern matrix\n+     */\n+    CGContextSetPatternPhase (context, CGSizeMake(0,0));\n+\n+    state->pattern = pattern;\n+    state->action = DO_PATTERN;\n+    return;\n }\n\n+/**\n+ * Call this before any operation that can modify the contents of a\n+ * cairo_quartz_surface_t.\n+ */\n static void\n-_cairo_quartz_teardown_source (cairo_quartz_surface_t *surface,\n-\t\t\t       const cairo_pattern_t *source)\n+_cairo_quartz_surface_will_change (cairo_quartz_surface_t *surface)\n {\n-    CGContextSetInterpolationQuality (surface->cgContext, surface->oldInterpolationQuality);\n+    if (surface->bitmapContextImage) {\n+        CGImageRelease (surface->bitmapContextImage);\n+        surface->bitmapContextImage = NULL;\n+    }\n+}\n\n-    if (surface->sourceImage) {\n-\tCGImageRelease(surface->sourceImage);\n-\tsurface->sourceImage = NULL;\n+/**\n+ * Sets up internal state to be used to draw the source mask, stored in\n+ * cairo_quartz_state_t. Guarantees to call CGContextSaveGState on\n+ * surface->cgContext.\n+ */\n+static cairo_quartz_drawing_state_t\n+_cairo_quartz_setup_state (cairo_quartz_surface_t *surface,\n+\t\t\t   const cairo_pattern_t *source,\n+\t\t\t   cairo_operator_t op,\n+\t\t\t   cairo_rectangle_int_t *extents)\n+{\n+    CGContextRef context = surface->cgContext;\n+    cairo_quartz_drawing_state_t state;\n+    cairo_status_t status;\n\n-\tcairo_surface_destroy(surface->sourceImageSurface);\n-\tsurface->sourceImageSurface = NULL;\n+    state.context = context;\n+    state.image = NULL;\n+    state.imageSurface = NULL;\n+    state.layer = NULL;\n+    state.shading = NULL;\n+    state.pattern = NULL;\n+\n+    _cairo_quartz_surface_will_change (surface);\n+\n+    // Save before we change the pattern, colorspace, etc. so that\n+    // we can restore and make sure that quartz releases our\n+    // pattern (which may be stack allocated)\n+    CGContextSaveGState(context);\n+\n+    CGContextSetInterpolationQuality (context, _cairo_quartz_filter_to_quartz (source->filter));\n+\n+    status = _cairo_quartz_surface_set_cairo_operator (surface, op);\n+    if (status == CAIRO_INT_STATUS_NOTHING_TO_DO) {\n+        state.action = DO_NOTHING;\n+        return state;\n+    }\n+    if (status) {\n+        state.action = DO_UNSUPPORTED;\n+        return state;\n     }\n\n-    if (surface->sourceShading) {\n-\tCGShadingRelease(surface->sourceShading);\n-\tsurface->sourceShading = NULL;\n+    if (source->type == CAIRO_PATTERN_TYPE_SOLID) {\n+\tcairo_solid_pattern_t *solid = (cairo_solid_pattern_t *) source;\n+\n+\tCGContextSetRGBStrokeColor (context,\n+\t\t\t\t    solid->color.red,\n+\t\t\t\t    solid->color.green,\n+\t\t\t\t    solid->color.blue,\n+\t\t\t\t    solid->color.alpha);\n+\tCGContextSetRGBFillColor (context,\n+\t\t\t\t  solid->color.red,\n+\t\t\t\t  solid->color.green,\n+\t\t\t\t  solid->color.blue,\n+\t\t\t\t  solid->color.alpha);\n+\n+        state.action = DO_SOLID;\n+        return state;\n+    }\n+\n+    if (source->type == CAIRO_PATTERN_TYPE_LINEAR) {\n+\tconst cairo_linear_pattern_t *lpat = (const cairo_linear_pattern_t *)source;\n+\t_cairo_quartz_setup_linear_source (surface, lpat, extents, &state);\n+\treturn state;\n+    }\n+\n+    if (source->type == CAIRO_PATTERN_TYPE_RADIAL) {\n+\tconst cairo_radial_pattern_t *rpat = (const cairo_radial_pattern_t *)source;\n+\t_cairo_quartz_setup_radial_source (surface, rpat, extents, &state);\n+\treturn state;\n     }\n\n-    if (surface->sourcePattern) {\n-\tCGPatternRelease(surface->sourcePattern);\n-\t// To tear down the pattern and colorspace\n-\tCGContextRestoreGState(surface->cgContext);\n+    if (source->type == CAIRO_PATTERN_TYPE_SURFACE) {\n+        if (op == CAIRO_OPERATOR_OVER && _cairo_pattern_is_opaque (source, NULL) &&\n+            CGContextGetAlphaPtr &&\n+            CGContextGetAlphaPtr (surface->cgContext) == 1.0) {\n+            // Quartz won't touch pixels outside the bounds of the\n+            // source surface, so we can just go ahead and use Copy here\n+            // to accelerate things.\n+            // Quartz won't necessarily be able to do this optimization internally;\n+            // for CGLayer surfaces, we can know all the pixels are opaque\n+            // (because it's CONTENT_COLOR), but Quartz won't know.\n+            CGContextSetCompositeOperation (context, kPrivateCGCompositeCopy);\n+        }\n\n-\tsurface->sourcePattern = NULL;\n+\tconst cairo_surface_pattern_t *spat = (const cairo_surface_pattern_t *) source;\n+        _cairo_quartz_setup_surface_source (surface, spat, extents, &state);\n+        return state;\n     }\n-}\n\n+    state.action = DO_UNSUPPORTED;\n+    return state;\n+}\n\n+/**\n+ * 1) Tears down internal state used to draw the source\n+ * 2) Does CGContextRestoreGState(state->context)\n+ */\n static void\n-_cairo_quartz_draw_image (cairo_quartz_surface_t *surface, cairo_operator_t op,  cairo_quartz_action_t action)\n+_cairo_quartz_teardown_state (cairo_quartz_drawing_state_t *state)\n {\n-    assert (surface && surface->sourceImage && (action == DO_IMAGE || action == DO_TILED_IMAGE));\n+    if (state->image) {\n+\tCGImageRelease(state->image);\n+    }\n\n-    CGContextConcatCTM (surface->cgContext, surface->sourceTransform);\n-    CGContextTranslateCTM (surface->cgContext, 0, surface->sourceImageRect.size.height);\n-    CGContextScaleCTM (surface->cgContext, 1, -1);\n-\n-    if (action == DO_IMAGE) {\n-\tCGContextDrawImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);\n-\tif (!_cairo_operator_bounded_by_source(op)) {\n-\t    CGContextBeginPath (surface->cgContext);\n-\t    CGContextAddRect (surface->cgContext, surface->sourceImageRect);\n-\t    CGContextAddRect (surface->cgContext, CGContextGetClipBoundingBox (surface->cgContext));\n-\t    CGContextSetRGBFillColor (surface->cgContext, 0, 0, 0, 0);\n-\t    CGContextEOFillPath (surface->cgContext);\n+    if (state->imageSurface) {\n+\tcairo_surface_destroy(state->imageSurface);\n+    }\n+\n+    if (state->shading) {\n+\tCGShadingRelease(state->shading);\n+    }\n+\n+    if (state->pattern) {\n+\tCGPatternRelease(state->pattern);\n+    }\n+\n+    CGContextRestoreGState(state->context);\n+}\n+\n+\n+static void\n+_cairo_quartz_draw_image (cairo_quartz_drawing_state_t *state, cairo_operator_t op)\n+{\n+    assert (state &&\n+            ((state->image && (state->action == DO_IMAGE || state->action == DO_TILED_IMAGE)) ||\n+             (state->layer && state->action == DO_LAYER)));\n+\n+    CGContextConcatCTM (state->context, state->transform);\n+    CGContextTranslateCTM (state->context, 0, state->imageRect.size.height);\n+    CGContextScaleCTM (state->context, 1, -1);\n+\n+    if (state->action == DO_TILED_IMAGE) {\n+\tCGContextDrawTiledImagePtr (state->context, state->imageRect, state->image);\n+\t/* no need to worry about unbounded operators, since tiled images\n+\t   fill the entire clip region */\n+    } else {\n+        if (state->action == DO_LAYER) {\n+            /* Note that according to Apple docs it's completely legal\n+             * to draw a CGLayer to any CGContext, even one it wasn't\n+             * created for.\n+             */\n+            CGContextSetInterpolationQuality (state->context, kCGInterpolationNone);\n+            CGContextDrawLayerAtPoint (state->context, state->imageRect.origin,\n+                                       state->layer);\n+        } else {\n+            CGContextDrawImage (state->context, state->imageRect, state->image);\n+        }\n+\n+\t/* disable this EXTEND_NONE correctness code because we use this path\n+\t * for both EXTEND_NONE and EXTEND_PAD */\n+\tif (0 && !_cairo_operator_bounded_by_source (op)) {\n+\t    CGContextBeginPath (state->context);\n+\t    CGContextAddRect (state->context, state->imageRect);\n+\t    CGContextAddRect (state->context, CGContextGetClipBoundingBox (state->context));\n+\t    CGContextSetRGBFillColor (state->context, 0, 0, 0, 0);\n+\t    CGContextEOFillPath (state->context);\n\t}\n-    } else\n-\tCGContextDrawTiledImagePtr (surface->cgContext, surface->sourceImageRect, surface->sourceImage);\n+    }\n }\n\n\n@@ -1762,6 +1939,7 @@ _cairo_quartz_get_image (cairo_quartz_su\n     }\n\n     if (surface->imageSurfaceEquiv) {\n+\tCGContextFlush(surface->cgContext);\n\t*image_out = (cairo_image_surface_t*) cairo_surface_reference(surface->imageSurfaceEquiv);\n\treturn CAIRO_STATUS_SUCCESS;\n     }\n@@ -1773,6 +1951,7 @@ _cairo_quartz_get_image (cairo_quartz_su\n\tCGColorSpaceRef colorspace;\n\tunsigned int color_comps;\n\n+\tCGContextFlush(surface->cgContext);\n\timageData = (unsigned char *) CGBitmapContextGetData(surface->cgContext);\n\n #ifdef USE_10_3_WORKAROUNDS\n@@ -1860,53 +2039,79 @@ _cairo_quartz_surface_finish (void *abst\n\n     surface->cgContext = NULL;\n\n+    if (surface->bitmapContextImage) {\n+        CGImageRelease (surface->bitmapContextImage);\n+        surface->bitmapContextImage = NULL;\n+    }\n+\n     if (surface->imageSurfaceEquiv) {\n+        if (surface->ownsData)\n+            _cairo_image_surface_assume_ownership_of_data (surface->imageSurfaceEquiv);\n\tcairo_surface_destroy (surface->imageSurfaceEquiv);\n\tsurface->imageSurfaceEquiv = NULL;\n+    } else if (surface->imageData && surface->ownsData) {\n+        free (surface->imageData);\n     }\n\n-    if (surface->imageData) {\n-\tfree (surface->imageData);\n-\tsurface->imageData = NULL;\n+    surface->imageData = NULL;\n+\n+    if (surface->cgLayer) {\n+        CGLayerRelease (surface->cgLayer);\n     }\n\n     return CAIRO_STATUS_SUCCESS;\n }\n\n static cairo_status_t\n-_cairo_quartz_surface_acquire_source_image (void *abstract_surface,\n-\t\t\t\t\t     cairo_image_surface_t **image_out,\n-\t\t\t\t\t     void **image_extra)\n+_cairo_quartz_surface_acquire_image (void *abstract_surface,\n+                                     cairo_image_surface_t **image_out,\n+                                     void **image_extra)\n {\n     cairo_int_status_t status;\n     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;\n\n-    //ND((stderr, \"%p _cairo_quartz_surface_acquire_source_image\\n\", surface));\n-\n-    status = _cairo_quartz_get_image (surface, image_out);\n-    if (status)\n-\treturn _cairo_error (CAIRO_STATUS_NO_MEMORY);\n-\n     *image_extra = NULL;\n\n-    return CAIRO_STATUS_SUCCESS;\n-}\n+    /* ND((stderr, \"%p _cairo_quartz_surface_acquire_image\\n\", surface)); */\n\n-static cairo_surface_t *\n-_cairo_quartz_surface_snapshot (void *abstract_surface)\n-{\n-    cairo_int_status_t status;\n-    cairo_quartz_surface_t *surface = abstract_surface;\n-    cairo_image_surface_t *image;\n+    status = _cairo_quartz_get_image (surface, image_out);\n\n-    if (surface->imageSurfaceEquiv)\n-\treturn NULL;\n+    if (status == CAIRO_INT_STATUS_UNSUPPORTED && surface->cgLayer) {\n+        /* copy the layer into a Quartz bitmap context so we can get the data */\n+        cairo_surface_t *tmp =\n+            cairo_quartz_surface_create (CAIRO_FORMAT_ARGB32,\n+                                         surface->extents.width,\n+                                         surface->extents.height);\n+        cairo_quartz_surface_t *tmp_surface = (cairo_quartz_surface_t *) tmp;\n+\n+        /* if surface creation failed, we won't have a Quartz surface here */\n+        if (cairo_surface_get_type (tmp) == CAIRO_SURFACE_TYPE_QUARTZ &&\n+            tmp_surface->imageSurfaceEquiv) {\n+            CGContextSaveGState (tmp_surface->cgContext);\n+            CGContextTranslateCTM (tmp_surface->cgContext, 0, surface->extents.height);\n+            CGContextScaleCTM (tmp_surface->cgContext, 1, -1);\n+            /* Note that according to Apple docs it's completely legal\n+             * to draw a CGLayer to any CGContext, even one it wasn't\n+             * created for.\n+             */\n+            CGContextDrawLayerAtPoint (tmp_surface->cgContext,\n+                                       CGPointMake (0.0, 0.0),\n+                                       surface->cgLayer);\n+            CGContextRestoreGState (tmp_surface->cgContext);\n+\n+            *image_out = (cairo_image_surface_t*)\n+                cairo_surface_reference(tmp_surface->imageSurfaceEquiv);\n+            *image_extra = tmp;\n+            status = CAIRO_STATUS_SUCCESS;\n+        } else {\n+            cairo_surface_destroy (tmp);\n+        }\n+    }\n\n-    status = _cairo_quartz_get_image (surface, &image);\n-    if (unlikely (status))\n-        return _cairo_surface_create_in_error (CAIRO_STATUS_NO_MEMORY);\n+    if (status)\n+\treturn _cairo_error (CAIRO_STATUS_NO_MEMORY);\n\n-    return &image->base;\n+    return CAIRO_STATUS_SUCCESS;\n }\n\n static void\n@@ -1915,6 +2120,10 @@ _cairo_quartz_surface_release_source_ima\n\t\t\t\t\t     void *image_extra)\n {\n     cairo_surface_destroy ((cairo_surface_t *) image);\n+\n+    if (image_extra) {\n+        cairo_surface_destroy ((cairo_surface_t *) image_extra);\n+    }\n }\n\n\n@@ -1926,18 +2135,16 @@ _cairo_quartz_surface_acquire_dest_image\n\t\t\t\t\t  void **image_extra)\n {\n     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;\n-    cairo_int_status_t status;\n\n     ND((stderr, \"%p _cairo_quartz_surface_acquire_dest_image\\n\", surface));\n\n-    status = _cairo_quartz_get_image (surface, image_out);\n-    if (status)\n-\treturn _cairo_error (CAIRO_STATUS_NO_MEMORY);\n-\n     *image_rect = surface->extents;\n     *image_extra = NULL;\n\n-    return CAIRO_STATUS_SUCCESS;\n+    _cairo_quartz_surface_will_change (surface);\n+\n+    return _cairo_quartz_surface_acquire_image (abstract_surface,\n+        image_out, image_extra);\n }\n\n static void\n@@ -1947,11 +2154,31 @@ _cairo_quartz_surface_release_dest_image\n\t\t\t\t\t  cairo_rectangle_int_t *image_rect,\n\t\t\t\t\t  void *image_extra)\n {\n-    //cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;\n-\n-    //ND((stderr, \"%p _cairo_quartz_surface_release_dest_image\\n\", surface));\n+    /* ND((stderr, \"%p _cairo_quartz_surface_release_dest_image\\n\", surface)); */\n\n     cairo_surface_destroy ((cairo_surface_t *) image);\n+\n+    if (image_extra) {\n+        /* we need to write the data from the temp surface back to the layer */\n+        cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;\n+        cairo_quartz_surface_t *tmp_surface = (cairo_quartz_surface_t *) image_extra;\n+        CGImageRef img;\n+        cairo_status_t status = _cairo_surface_to_cgimage (&tmp_surface->base, &img);\n+        if (status) {\n+            cairo_surface_destroy (&tmp_surface->base);\n+            return;\n+        }\n+\n+        CGContextSaveGState (surface->cgContext);\n+        CGContextTranslateCTM (surface->cgContext, 0, surface->extents.height);\n+        CGContextScaleCTM (surface->cgContext, 1, -1);\n+        CGContextDrawImage (surface->cgContext,\n+                            CGRectMake (0.0, 0.0, surface->extents.width, surface->extents.height),\n+                            img);\n+        CGContextRestoreGState (surface->cgContext);\n+\n+        cairo_surface_destroy (&tmp_surface->base);\n+    }\n }\n\n static cairo_surface_t *\n@@ -1960,10 +2187,13 @@ _cairo_quartz_surface_create_similar (vo\n\t\t\t\t       int width,\n\t\t\t\t       int height)\n {\n-    /*cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;*/\n-\n+    cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;\n     cairo_format_t format;\n\n+    if (surface->cgLayer)\n+        return cairo_quartz_surface_create_cg_layer (abstract_surface, content,\n+                                                     width, height);\n+\n     if (content == CAIRO_CONTENT_COLOR_ALPHA)\n\tformat = CAIRO_FORMAT_ARGB32;\n     else if (content == CAIRO_CONTENT_COLOR)\n@@ -2027,7 +2257,7 @@ _cairo_quartz_surface_clone_similar (voi\n\t}\n     }\n\n-    status = _cairo_surface_to_cgimage ((cairo_surface_t*) abstract_surface, src, &quartz_image);\n+    status = _cairo_surface_to_cgimage (src, &quartz_image);\n     if (status)\n\treturn CAIRO_INT_STATUS_UNSUPPORTED;\n\n@@ -2087,7 +2317,7 @@ _cairo_quartz_surface_paint_cg (void *ab\n {\n     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;\n     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;\n-    cairo_quartz_action_t action;\n+    cairo_quartz_drawing_state_t state;\n\n     ND((stderr, \"%p _cairo_quartz_surface_paint op %d source->type %d\\n\", surface, op, source->type));\n\n@@ -2098,31 +2328,24 @@ _cairo_quartz_surface_paint_cg (void *ab\n     if (unlikely (rv))\n\treturn rv;\n\n-    rv = _cairo_quartz_surface_set_cairo_operator (surface, op);\n-    if (unlikely (rv))\n-\treturn rv == CAIRO_INT_STATUS_NOTHING_TO_DO ? CAIRO_STATUS_SUCCESS : rv;\n+    state = _cairo_quartz_setup_state (surface, source, op, NULL);\n\n-    action = _cairo_quartz_setup_source (surface, source, NULL);\n-\n-    if (action == DO_SOLID || action == DO_PATTERN) {\n-\tCGContextFillRect (surface->cgContext, CGRectMake(surface->extents.x,\n-\t\t\t\t\t\t\t  surface->extents.y,\n-\t\t\t\t\t\t\t  surface->extents.width,\n-\t\t\t\t\t\t\t  surface->extents.height));\n-    } else if (action == DO_SHADING) {\n-\tCGContextSaveGState (surface->cgContext);\n-\tCGContextConcatCTM (surface->cgContext, surface->sourceTransform);\n-\tCGContextDrawShading (surface->cgContext, surface->sourceShading);\n-\tCGContextRestoreGState (surface->cgContext);\n-    } else if (action == DO_IMAGE || action == DO_TILED_IMAGE) {\n-\tCGContextSaveGState (surface->cgContext);\n-\t_cairo_quartz_draw_image (surface, op, action);\n-\tCGContextRestoreGState (surface->cgContext);\n-    } else if (action != DO_NOTHING) {\n+    if (state.action == DO_SOLID || state.action == DO_PATTERN) {\n+\tCGContextFillRect (state.context, CGRectMake(surface->extents.x,\n+\t\t\t\t\t\t     surface->extents.y,\n+\t\t\t\t\t\t     surface->extents.width,\n+\t\t\t\t\t\t     surface->extents.height));\n+    } else if (state.action == DO_SHADING) {\n+\tCGContextConcatCTM (state.context, state.transform);\n+\tCGContextDrawShading (state.context, state.shading);\n+    } else if (state.action == DO_IMAGE || state.action == DO_TILED_IMAGE ||\n+               state.action == DO_LAYER) {\n+\t_cairo_quartz_draw_image (&state, op);\n+    } else if (state.action != DO_NOTHING) {\n\trv = CAIRO_INT_STATUS_UNSUPPORTED;\n     }\n\n-    _cairo_quartz_teardown_source (surface, source);\n+    _cairo_quartz_teardown_state (&state);\n\n     ND((stderr, \"-- paint\\n\"));\n     return rv;\n@@ -2186,7 +2409,7 @@ _cairo_quartz_surface_fill_cg (void *abs\n {\n     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;\n     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;\n-    cairo_quartz_action_t action;\n+    cairo_quartz_drawing_state_t state;\n     CGPathRef path_for_unbounded = NULL;\n\n     ND((stderr, \"%p _cairo_quartz_surface_fill op %d source->type %d\\n\", surface, op, source->type));\n@@ -2198,14 +2421,6 @@ _cairo_quartz_surface_fill_cg (void *abs\n     if (unlikely (rv))\n\treturn rv;\n\n-    rv = _cairo_quartz_surface_set_cairo_operator (surface, op);\n-    if (unlikely (rv))\n-\treturn rv == CAIRO_INT_STATUS_NOTHING_TO_DO ? CAIRO_STATUS_SUCCESS : rv;\n-\n-    CGContextSaveGState (surface->cgContext);\n-\n-    CGContextSetShouldAntialias (surface->cgContext, (antialias != CAIRO_ANTIALIAS_NONE));\n-\n     if (_cairo_quartz_source_needs_extents (source))\n     {\n         /* We don't need precise extents since these are only used to\n@@ -2213,46 +2428,47 @@ _cairo_quartz_surface_fill_cg (void *abs\n            object. */\n         cairo_rectangle_int_t path_extents;\n         _cairo_path_fixed_approximate_fill_extents (path, &path_extents);\n-        action = _cairo_quartz_setup_source (surface, source, &path_extents);\n+        state = _cairo_quartz_setup_state (surface, source, op, &path_extents);\n     } else {\n-        action = _cairo_quartz_setup_source (surface, source, NULL);\n+        state = _cairo_quartz_setup_state (surface, source, op, NULL);\n     }\n\n-    _cairo_quartz_cairo_path_to_quartz_context (path, surface->cgContext);\n+    CGContextSetShouldAntialias (state.context, (antialias != CAIRO_ANTIALIAS_NONE));\n+\n+    _cairo_quartz_cairo_path_to_quartz_context (path, state.context);\n\n     if (!_cairo_operator_bounded_by_mask(op) && CGContextCopyPathPtr)\n-\tpath_for_unbounded = CGContextCopyPathPtr (surface->cgContext);\n+\tpath_for_unbounded = CGContextCopyPathPtr (state.context);\n\n-    if (action == DO_SOLID || action == DO_PATTERN) {\n+    if (state.action == DO_SOLID || state.action == DO_PATTERN) {\n\tif (fill_rule == CAIRO_FILL_RULE_WINDING)\n-\t    CGContextFillPath (surface->cgContext);\n+\t    CGContextFillPath (state.context);\n\telse\n-\t    CGContextEOFillPath (surface->cgContext);\n-    } else if (action == DO_SHADING) {\n+\t    CGContextEOFillPath (state.context);\n+    } else if (state.action == DO_SHADING) {\n\n\t// we have to clip and then paint the shading; we can't fill\n\t// with the shading\n\tif (fill_rule == CAIRO_FILL_RULE_WINDING)\n-\t    CGContextClip (surface->cgContext);\n+\t    CGContextClip (state.context);\n\telse\n-\t    CGContextEOClip (surface->cgContext);\n+            CGContextEOClip (state.context);\n\n-\tCGContextConcatCTM (surface->cgContext, surface->sourceTransform);\n-\tCGContextDrawShading (surface->cgContext, surface->sourceShading);\n-    } else if (action == DO_IMAGE || action == DO_TILED_IMAGE) {\n+\tCGContextConcatCTM (state.context, state.transform);\n+\tCGContextDrawShading (state.context, state.shading);\n+    } else if (state.action == DO_IMAGE || state.action == DO_TILED_IMAGE ||\n+               state.action == DO_LAYER) {\n\tif (fill_rule == CAIRO_FILL_RULE_WINDING)\n-\t    CGContextClip (surface->cgContext);\n+\t    CGContextClip (state.context);\n\telse\n-\t    CGContextEOClip (surface->cgContext);\n+\t    CGContextEOClip (state.context);\n\n-\t_cairo_quartz_draw_image (surface, op, action);\n-    } else if (action != DO_NOTHING) {\n+\t_cairo_quartz_draw_image (&state, op);\n+    } else if (state.action != DO_NOTHING) {\n\trv = CAIRO_INT_STATUS_UNSUPPORTED;\n     }\n\n-    _cairo_quartz_teardown_source (surface, source);\n-\n-    CGContextRestoreGState (surface->cgContext);\n+    _cairo_quartz_teardown_state (&state);\n\n     if (path_for_unbounded) {\n\tunbounded_op_data_t ub;\n@@ -2319,7 +2535,7 @@ _cairo_quartz_surface_stroke_cg (void *a\n {\n     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;\n     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;\n-    cairo_quartz_action_t action;\n+    cairo_quartz_drawing_state_t state;\n     CGAffineTransform origCTM, strokeTransform;\n     CGPathRef path_for_unbounded = NULL;\n\n@@ -2336,16 +2552,25 @@ _cairo_quartz_surface_stroke_cg (void *a\n     if (unlikely (rv))\n\treturn rv == CAIRO_INT_STATUS_NOTHING_TO_DO ? CAIRO_STATUS_SUCCESS : rv;\n\n+    if (_cairo_quartz_source_needs_extents (source))\n+    {\n+\tcairo_rectangle_int_t path_extents;\n+\t_cairo_path_fixed_approximate_stroke_extents (path, style, ctm, &path_extents);\n+\tstate = _cairo_quartz_setup_state (surface, source, op, &path_extents);\n+    } else {\n+\tstate = _cairo_quartz_setup_state (surface, source, op, NULL);\n+    }\n+\n     // Turning antialiasing off used to cause misrendering with\n     // single-pixel lines (e.g. 20,10.5 -> 21,10.5 end up being rendered as 2 pixels).\n     // That's been since fixed in at least 10.5, and in the latest 10.4 dot releases.\n-    CGContextSetShouldAntialias (surface->cgContext, (antialias != CAIRO_ANTIALIAS_NONE));\n-    CGContextSetLineWidth (surface->cgContext, style->line_width);\n-    CGContextSetLineCap (surface->cgContext, _cairo_quartz_cairo_line_cap_to_quartz (style->line_cap));\n-    CGContextSetLineJoin (surface->cgContext, _cairo_quartz_cairo_line_join_to_quartz (style->line_join));\n-    CGContextSetMiterLimit (surface->cgContext, style->miter_limit);\n+    CGContextSetShouldAntialias (state.context, (antialias != CAIRO_ANTIALIAS_NONE));\n+    CGContextSetLineWidth (state.context, style->line_width);\n+    CGContextSetLineCap (state.context, _cairo_quartz_cairo_line_cap_to_quartz (style->line_cap));\n+    CGContextSetLineJoin (state.context, _cairo_quartz_cairo_line_join_to_quartz (style->line_join));\n+    CGContextSetMiterLimit (state.context, style->miter_limit);\n\n-    origCTM = CGContextGetCTM (surface->cgContext);\n+    origCTM = CGContextGetCTM (state.context);\n\n     if (style->dash && style->num_dashes) {\n #define STATIC_DASH 32\n@@ -2368,72 +2593,62 @@ _cairo_quartz_surface_stroke_cg (void *a\n\tif (fdash != sdash)\n\t    free (fdash);\n     } else\n-\tCGContextSetLineDash (surface->cgContext, 0, NULL, 0);\n+\tCGContextSetLineDash (state.context, 0, NULL, 0);\n\n-    CGContextSaveGState (surface->cgContext);\n\n+    _cairo_quartz_cairo_path_to_quartz_context (path, state.context);\n\n-    if (_cairo_quartz_source_needs_extents (source))\n-    {\n-        cairo_rectangle_int_t path_extents;\n-        _cairo_path_fixed_approximate_stroke_extents (path, style, ctm, &path_extents);\n-        action = _cairo_quartz_setup_source (surface, source, &path_extents);\n-    } else {\n-        action = _cairo_quartz_setup_source (surface, source, NULL);\n-    }\n-\n-    _cairo_quartz_cairo_path_to_quartz_context (path, surface->cgContext);\n+    _cairo_quartz_cairo_matrix_to_quartz (ctm, &strokeTransform);\n+    CGContextConcatCTM (state.context, strokeTransform);\n\n     if (!_cairo_operator_bounded_by_mask (op) && CGContextCopyPathPtr)\n-\tpath_for_unbounded = CGContextCopyPathPtr (surface->cgContext);\n-\n-    _cairo_quartz_cairo_matrix_to_quartz (ctm, &strokeTransform);\n-    CGContextConcatCTM (surface->cgContext, strokeTransform);\n+\tpath_for_unbounded = CGContextCopyPathPtr (state.context);\n\n-    if (action == DO_SOLID || action == DO_PATTERN) {\n-\tCGContextStrokePath (surface->cgContext);\n-    } else if (action == DO_IMAGE || action == DO_TILED_IMAGE) {\n-\tCGContextReplacePathWithStrokedPath (surface->cgContext);\n-\tCGContextClip (surface->cgContext);\n-\n-\tCGContextSetCTM (surface->cgContext, origCTM);\n-\t_cairo_quartz_draw_image (surface, op, action);\n-    } else if (action == DO_SHADING) {\n-\tCGContextReplacePathWithStrokedPath (surface->cgContext);\n-\tCGContextClip (surface->cgContext);\n-\n-\tCGContextSetCTM (surface->cgContext, origCTM);\n-\n-\tCGContextConcatCTM (surface->cgContext, surface->sourceTransform);\n-\tCGContextDrawShading (surface->cgContext, surface->sourceShading);\n-    } else if (action != DO_NOTHING) {\n+    if (state.action == DO_SOLID || state.action == DO_PATTERN) {\n+\tCGContextStrokePath (state.context);\n+    } else if (state.action == DO_IMAGE || state.action == DO_TILED_IMAGE ||\n+               state.action == DO_LAYER) {\n+\tCGContextReplacePathWithStrokedPath (state.context);\n+\tCGContextClip (state.context);\n+\n+\tCGContextSetCTM (state.context, origCTM);\n+\t_cairo_quartz_draw_image (&state, op);\n+    } else if (state.action == DO_SHADING) {\n+\tCGContextReplacePathWithStrokedPath (state.context);\n+\tCGContextClip (state.context);\n+\n+\tCGContextSetCTM (state.context, origCTM);\n+\n+\tCGContextConcatCTM (state.context, state.transform);\n+\tCGContextDrawShading (state.context, state.shading);\n+    } else if (state.action != DO_NOTHING) {\n\trv = CAIRO_INT_STATUS_UNSUPPORTED;\n+\tgoto BAIL;\n     }\n\n-    _cairo_quartz_teardown_source (surface, source);\n-\n-    CGContextRestoreGState (surface->cgContext);\n-\n     if (path_for_unbounded) {\n\tunbounded_op_data_t ub;\n\tub.op = UNBOUNDED_STROKE_FILL;\n\tub.u.stroke_fill.fill_rule = CAIRO_FILL_RULE_WINDING;\n\n-\tCGContextBeginPath (surface->cgContext);\n-\tCGContextAddPath (surface->cgContext, path_for_unbounded);\n+\tCGContextBeginPath (state.context);\n+\tCGContextAddPath (state.context, path_for_unbounded);\n\tCGPathRelease (path_for_unbounded);\n\n-\tCGContextSaveGState (surface->cgContext);\n-\tCGContextConcatCTM (surface->cgContext, strokeTransform);\n-\tCGContextReplacePathWithStrokedPath (surface->cgContext);\n-\tCGContextRestoreGState (surface->cgContext);\n+\tCGContextSaveGState (state.context);\n+\tCGContextConcatCTM (state.context, strokeTransform);\n+\tCGContextReplacePathWithStrokedPath (state.context);\n+\tCGContextRestoreGState (state.context);\n\n-\tub.u.stroke_fill.cgPath = CGContextCopyPathPtr (surface->cgContext);\n+\tub.u.stroke_fill.cgPath = CGContextCopyPathPtr (state.context);\n\n\t_cairo_quartz_fixup_unbounded_operation (surface, &ub, antialias);\n\tCGPathRelease (ub.u.stroke_fill.cgPath);\n     }\n\n+  BAIL:\n+    _cairo_quartz_teardown_state (&state);\n+\n     ND((stderr, \"-- stroke\\n\"));\n     return rv;\n }\n@@ -2490,18 +2705,22 @@ _cairo_quartz_surface_show_glyphs_cg (vo\n     CGGlyph glyphs_static[STATIC_BUF_SIZE];\n     CGSize cg_advances_static[STATIC_BUF_SIZE];\n     CGGlyph *cg_glyphs = &glyphs_static[0];\n+    /* We'll use the cg_advances array for either advances or positions,\n+       depending which API we're using to actually draw. The types involved\n+       have the same size, so this is safe. */\n     CGSize *cg_advances = &cg_advances_static[0];\n\n     cairo_rectangle_int_t glyph_extents;\n     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;\n     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;\n-    cairo_quartz_action_t action;\n+    cairo_quartz_drawing_state_t state;\n     cairo_quartz_float_t xprev, yprev;\n     int i;\n     CGFontRef cgfref = NULL;\n\n     cairo_bool_t isClipping = FALSE;\n     cairo_bool_t didForceFontSmoothing = FALSE;\n+    cairo_antialias_t effective_antialiasing;\n\n     if (IS_EMPTY(surface))\n\treturn CAIRO_STATUS_SUCCESS;\n@@ -2516,54 +2735,51 @@ _cairo_quartz_surface_show_glyphs_cg (vo\n     if (unlikely (rv))\n\treturn rv;\n\n-    rv = _cairo_quartz_surface_set_cairo_operator (surface, op);\n-    if (unlikely (rv))\n-\treturn rv == CAIRO_INT_STATUS_NOTHING_TO_DO ? CAIRO_STATUS_SUCCESS : rv;\n-\n-    CGContextSaveGState (surface->cgContext);\n-\n     if (_cairo_quartz_source_needs_extents (source) &&\n\t!_cairo_scaled_font_glyph_device_extents (scaled_font, glyphs, num_glyphs,\n\t\t\t\t\t\t  &glyph_extents, NULL))\n     {\n-        action = _cairo_quartz_setup_source (surface, source, &glyph_extents);\n+        state = _cairo_quartz_setup_state (surface, source, op, &glyph_extents);\n     } else {\n-        action = _cairo_quartz_setup_source (surface, source, NULL);\n+        state = _cairo_quartz_setup_state (surface, source, op, NULL);\n     }\n\n-    if (action == DO_SOLID || action == DO_PATTERN) {\n-\tCGContextSetTextDrawingMode (surface->cgContext, kCGTextFill);\n-    } else if (action == DO_IMAGE || action == DO_TILED_IMAGE || action == DO_SHADING) {\n-\tCGContextSetTextDrawingMode (surface->cgContext, kCGTextClip);\n+    if (state.action == DO_SOLID || state.action == DO_PATTERN) {\n+\tCGContextSetTextDrawingMode (state.context, kCGTextFill);\n+    } else if (state.action == DO_IMAGE || state.action == DO_TILED_IMAGE ||\n+               state.action == DO_SHADING || state.action == DO_LAYER) {\n+\tCGContextSetTextDrawingMode (state.context, kCGTextClip);\n\tisClipping = TRUE;\n     } else {\n-\tif (action != DO_NOTHING)\n+\tif (state.action != DO_NOTHING)\n\t    rv = CAIRO_INT_STATUS_UNSUPPORTED;\n\tgoto BAIL;\n     }\n\n     /* this doesn't addref */\n     cgfref = _cairo_quartz_scaled_font_get_cg_font_ref (scaled_font);\n-    CGContextSetFont (surface->cgContext, cgfref);\n-    CGContextSetFontSize (surface->cgContext, 1.0);\n+    CGContextSetFont (state.context, cgfref);\n+    CGContextSetFontSize (state.context, 1.0);\n+\n+    effective_antialiasing = scaled_font->options.antialias;\n\n     switch (scaled_font->options.antialias) {\n\tcase CAIRO_ANTIALIAS_SUBPIXEL:\n-\t    CGContextSetShouldAntialias (surface->cgContext, TRUE);\n-\t    CGContextSetShouldSmoothFonts (surface->cgContext, TRUE);\n+\t    CGContextSetShouldAntialias (state.context, TRUE);\n+\t    CGContextSetShouldSmoothFonts (state.context, TRUE);\n\t    if (CGContextSetAllowsFontSmoothingPtr &&\n-\t\t!CGContextGetAllowsFontSmoothingPtr (surface->cgContext))\n+\t\t!CGContextGetAllowsFontSmoothingPtr (state.context))\n\t    {\n\t\tdidForceFontSmoothing = TRUE;\n-\t\tCGContextSetAllowsFontSmoothingPtr (surface->cgContext, TRUE);\n+\t\tCGContextSetAllowsFontSmoothingPtr (state.context, TRUE);\n\t    }\n\t    break;\n\tcase CAIRO_ANTIALIAS_NONE:\n-\t    CGContextSetShouldAntialias (surface->cgContext, FALSE);\n+\t    CGContextSetShouldAntialias (state.context, FALSE);\n\t    break;\n\tcase CAIRO_ANTIALIAS_GRAY:\n-\t    CGContextSetShouldAntialias (surface->cgContext, TRUE);\n-\t    CGContextSetShouldSmoothFonts (surface->cgContext, FALSE);\n+\t    CGContextSetShouldAntialias (state.context, TRUE);\n+\t    CGContextSetShouldSmoothFonts (state.context, FALSE);\n\t    break;\n\tcase CAIRO_ANTIALIAS_DEFAULT:\n\t    /* Don't do anything */\n@@ -2584,57 +2800,84 @@ _cairo_quartz_surface_show_glyphs_cg (vo\n\t}\n     }\n\n+    /* scale(1,-1) * scaled_font->scale */\n     textTransform = CGAffineTransformMake (scaled_font->scale.xx,\n\t\t\t\t\t   scaled_font->scale.yx,\n\t\t\t\t\t   -scaled_font->scale.xy,\n\t\t\t\t\t   -scaled_font->scale.yy,\n\t\t\t\t\t   0, 0);\n-    _cairo_quartz_cairo_matrix_to_quartz (&scaled_font->scale_inverse, &invTextTransform);\n\n-    CGContextSetTextMatrix (surface->cgContext, CGAffineTransformIdentity);\n+    /* scaled_font->scale_inverse * scale(1,-1) */\n+    invTextTransform = CGAffineTransformMake (scaled_font->scale_inverse.xx,\n+\t\t\t\t\t      -scaled_font->scale_inverse.yx,\n+\t\t\t\t\t      scaled_font->scale_inverse.xy,\n+\t\t\t\t\t      -scaled_font->scale_inverse.yy,\n+\t\t\t\t\t      0.0, 0.0);\n\n-    /* Convert our glyph positions to glyph advances.  We need n-1 advances,\n-     * since the advance at index 0 is applied after glyph 0. */\n-    xprev = glyphs[0].x;\n-    yprev = glyphs[0].y;\n-\n-    cg_glyphs[0] = glyphs[0].index;\n-\n-    for (i = 1; i < num_glyphs; i++) {\n-\tcairo_quartz_float_t xf = glyphs[i].x;\n-\tcairo_quartz_float_t yf = glyphs[i].y;\n-\tcg_glyphs[i] = glyphs[i].index;\n-\tcg_advances[i - 1] = CGSizeApplyAffineTransform(CGSizeMake (xf - xprev, yf - yprev), invTextTransform);\n-\txprev = xf;\n-\typrev = yf;\n-    }\n+    CGContextSetTextMatrix (state.context, CGAffineTransformIdentity);\n\n     /* Translate to the first glyph's position before drawing */\n-    ctm = CGContextGetCTM (surface->cgContext);\n-    CGContextTranslateCTM (surface->cgContext, glyphs[0].x, glyphs[0].y);\n-    CGContextConcatCTM (surface->cgContext, textTransform);\n-\n-    CGContextShowGlyphsWithAdvances (surface->cgContext,\n-\t\t\t\t     cg_glyphs,\n-\t\t\t\t     cg_advances,\n-\t\t\t\t     num_glyphs);\n-\n-    CGContextSetCTM (surface->cgContext, ctm);\n+    ctm = CGContextGetCTM (state.context);\n+    CGContextTranslateCTM (state.context, glyphs[0].x, glyphs[0].y);\n+    CGContextConcatCTM (state.context, textTransform);\n+\n+    if (CTFontDrawGlyphsPtr) {\n+        /* If CTFontDrawGlyphs is available (i.e. OS X 10.7 or later), we want to use\n+         * that in preference to CGContextShowGlyphsWithAdvances so that colored-bitmap\n+         * fonts like Apple Color Emoji will render properly.\n+         * For this, we need to convert our glyph positions to Core Graphics's CGPoint.\n+         * We borrow the cg_advances array, as CGPoint and CGSize are the same size. */\n+\n+        CGPoint *cg_positions = (CGPoint*) cg_advances;\n+        cairo_quartz_float_t origin_x = glyphs[0].x;\n+        cairo_quartz_float_t origin_y = glyphs[0].y;\n+\n+        for (i = 0; i < num_glyphs; i++) {\n+            CGPoint pt = CGPointMake (glyphs[i].x - origin_x, glyphs[i].y - origin_y);\n+            cg_positions[i] = CGPointApplyAffineTransform (pt, invTextTransform);\n+            cg_glyphs[i] = glyphs[i].index;\n+        }\n\n-    if (action == DO_IMAGE || action == DO_TILED_IMAGE) {\n-\t_cairo_quartz_draw_image (surface, op, action);\n-    } else if (action == DO_SHADING) {\n-\tCGContextConcatCTM (surface->cgContext, surface->sourceTransform);\n-\tCGContextDrawShading (surface->cgContext, surface->sourceShading);\n+        CTFontDrawGlyphsPtr (_cairo_quartz_scaled_font_get_ct_font_ref (scaled_font),\n+                             cg_glyphs, cg_positions, num_glyphs, state.context);\n+    } else {\n+        /* Convert our glyph positions to glyph advances.  We need n-1 advances,\n+         * since the advance at index 0 is applied after glyph 0. */\n+        xprev = glyphs[0].x;\n+        yprev = glyphs[0].y;\n+\n+        cg_glyphs[0] = glyphs[0].index;\n+\n+        for (i = 1; i < num_glyphs; i++) {\n+\t    cairo_quartz_float_t xf = glyphs[i].x;\n+\t    cairo_quartz_float_t yf = glyphs[i].y;\n+\t    cg_glyphs[i] = glyphs[i].index;\n+\t    cg_advances[i - 1] = CGSizeApplyAffineTransform(CGSizeMake (xf - xprev, yf - yprev), invTextTransform);\n+\t    xprev = xf;\n+\t    yprev = yf;\n+        }\n+\n+        CGContextShowGlyphsWithAdvances (state.context,\n+\t\t\t\t         cg_glyphs,\n+\t\t\t\t         cg_advances,\n+\t\t\t\t         num_glyphs);\n+    }\n+\n+    CGContextSetCTM (state.context, ctm);\n+\n+    if (state.action == DO_IMAGE || state.action == DO_TILED_IMAGE ||\n+        state.action == DO_LAYER) {\n+\t_cairo_quartz_draw_image (&state, op);\n+    } else if (state.action == DO_SHADING) {\n+\tCGContextConcatCTM (state.context, state.transform);\n+\tCGContextDrawShading (state.context, state.shading);\n     }\n\n BAIL:\n-    _cairo_quartz_teardown_source (surface, source);\n-\n     if (didForceFontSmoothing)\n-\tCGContextSetAllowsFontSmoothingPtr (surface->cgContext, FALSE);\n+        CGContextSetAllowsFontSmoothingPtr (state.context, FALSE);\n\n-    CGContextRestoreGState (surface->cgContext);\n+    _cairo_quartz_teardown_state (&state);\n\n     if (rv == CAIRO_STATUS_SUCCESS &&\n\tcgfref &&\n@@ -2645,10 +2888,17 @@ BAIL:\n\n\tub.u.show_glyphs.isClipping = isClipping;\n\tub.u.show_glyphs.cg_glyphs = cg_glyphs;\n-\tub.u.show_glyphs.cg_advances = cg_advances;\n+\tif (CTFontDrawGlyphsPtr) {\n+\t    /* we're using Core Text API: the cg_advances array was\n+\t       reused (above) for glyph positions */\n+            CGPoint *cg_positions = (CGPoint*) cg_advances;\n+\t    ub.u.show_glyphs.u.cg_positions = cg_positions;\n+\t} else {\n+\t    ub.u.show_glyphs.u.cg_advances = cg_advances;\n+\t}\n\tub.u.show_glyphs.nglyphs = num_glyphs;\n\tub.u.show_glyphs.textTransform = textTransform;\n-\tub.u.show_glyphs.font = cgfref;\n+\tub.u.show_glyphs.scaled_font = scaled_font;\n\tub.u.show_glyphs.origin = CGPointMake (glyphs[0].x, glyphs[0].y);\n\n\t_cairo_quartz_fixup_unbounded_operation (surface, &ub, scaled_font->options.antialias);\n@@ -2717,7 +2967,7 @@ _cairo_quartz_surface_mask_with_surface\n     cairo_status_t status = CAIRO_STATUS_SUCCESS;\n     CGAffineTransform ctm, mask_matrix;\n\n-    status = _cairo_surface_to_cgimage ((cairo_surface_t *) surface, pat_surf, &img);\n+    status = _cairo_surface_to_cgimage (pat_surf, &img);\n     if (status)\n\treturn status;\n     if (img == NULL) {\n@@ -2820,7 +3070,9 @@ _cairo_quartz_surface_mask_cg (void *abs\n     if (unlikely (rv))\n\treturn rv;\n\n-    if (mask->type == CAIRO_PATTERN_TYPE_SOLID) {\n+    /* Using CGContextSetAlpha to implement mask alpha doesn't work for all operators. */\n+    if (mask->type == CAIRO_PATTERN_TYPE_SOLID &&\n+        op == CAIRO_OPERATOR_OVER) {\n\t/* This is easy; we just need to paint with the alpha. */\n\tcairo_solid_pattern_t *solid_mask = (cairo_solid_pattern_t *) mask;\n\n@@ -2834,8 +3086,11 @@ _cairo_quartz_surface_mask_cg (void *abs\n     /* If we have CGContextClipToMask, we can do more complex masks */\n     if (CGContextClipToMaskPtr) {\n\t/* For these, we can skip creating a temporary surface, since we already have one */\n-\tif (mask->type == CAIRO_PATTERN_TYPE_SURFACE && mask->extend == CAIRO_EXTEND_NONE)\n+\t/* For some reason this doesn't work reliably on OS X 10.5.  See bug 721663. */\n+\tif (_cairo_quartz_osx_version >= 0x1060 && mask->type == CAIRO_PATTERN_TYPE_SURFACE &&\n+\t    mask->extend == CAIRO_EXTEND_NONE) {\n\t    return _cairo_quartz_surface_mask_with_surface (surface, op, source, (cairo_surface_pattern_t *) mask, clip);\n+\t}\n\n\treturn _cairo_quartz_surface_mask_with_generic (surface, op, source, mask, clip);\n     }\n@@ -2920,13 +3175,24 @@ _cairo_quartz_surface_clipper_intersect_\n     return CAIRO_STATUS_SUCCESS;\n }\n\n+static cairo_status_t\n+_cairo_quartz_surface_mark_dirty_rectangle (void *abstract_surface,\n+\t\t\t\t\t    int x, int y,\n+\t\t\t\t\t    int width, int height)\n+{\n+    cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;\n+    _cairo_quartz_surface_will_change (surface);\n+    return CAIRO_STATUS_SUCCESS;\n+}\n+\n+\n // XXXtodo implement show_page; need to figure out how to handle begin/end\n\n static const struct _cairo_surface_backend cairo_quartz_surface_backend = {\n     CAIRO_SURFACE_TYPE_QUARTZ,\n     _cairo_quartz_surface_create_similar,\n     _cairo_quartz_surface_finish,\n-    _cairo_quartz_surface_acquire_source_image,\n+    _cairo_quartz_surface_acquire_image,\n     _cairo_quartz_surface_release_source_image,\n     _cairo_quartz_surface_acquire_dest_image,\n     _cairo_quartz_surface_release_dest_image,\n@@ -2942,7 +3208,7 @@ static const struct _cairo_surface_backe\n     NULL, /* old_show_glyphs */\n     NULL, /* get_font_options */\n     NULL, /* flush */\n-    NULL, /* mark_dirty_rectangle */\n+    _cairo_quartz_surface_mark_dirty_rectangle,\n     NULL, /* scaled_font_fini */\n     NULL, /* scaled_glyph_fini */\n\n@@ -2952,7 +3218,7 @@ static const struct _cairo_surface_backe\n     _cairo_quartz_surface_fill,\n     _cairo_quartz_surface_show_glyphs,\n\n-    _cairo_quartz_surface_snapshot,\n+    NULL, /* snapshot */\n     NULL, /* is_similar */\n     NULL  /* fill_stroke */\n };\n@@ -3004,6 +3270,9 @@ _cairo_quartz_surface_create_internal (C\n\n     surface->imageData = NULL;\n     surface->imageSurfaceEquiv = NULL;\n+    surface->bitmapContextImage = NULL;\n+    surface->cgLayer = NULL;\n+    surface->ownsData = TRUE;\n\n     return surface;\n }\n@@ -3056,6 +3325,81 @@ cairo_quartz_surface_create_for_cg_conte\n }\n\n /**\n+ * cairo_quartz_cglayer_surface_create_similar\n+ * @surface: The returned surface can be efficiently drawn into this\n+ * destination surface (if tiling is not used).\"\n+ * @content: the content type of the surface\n+ * @width: width of the surface, in pixels\n+ * @height: height of the surface, in pixels\n+ *\n+ * Creates a Quartz surface backed by a CGLayer, if the given surface\n+ * is a Quartz surface; the CGLayer is created to match the surface's\n+ * Quartz context. Otherwise just calls cairo_surface_create_similar.\n+ * The returned surface can be efficiently blitted to the given surface,\n+ * but tiling and 'extend' modes other than NONE are not so efficient.\n+ *\n+ * Return value: the newly created surface.\n+ *\n+ * Since: 1.10\n+ **/\n+cairo_surface_t *\n+cairo_quartz_surface_create_cg_layer (cairo_surface_t *surface,\n+                                      cairo_content_t content,\n+                                      unsigned int width,\n+                                      unsigned int height)\n+{\n+    cairo_quartz_surface_t *surf;\n+    CGLayerRef layer;\n+    CGContextRef ctx;\n+    CGContextRef cgContext;\n+\n+    cgContext = cairo_quartz_surface_get_cg_context (surface);\n+    if (!cgContext)\n+    \treturn cairo_surface_create_similar (surface, content,\n+                                             width, height);\n+\n+\n+    if (!_cairo_quartz_verify_surface_size(width, height))\n+        return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_SIZE));\n+\n+    /* If we pass zero width or height into CGLayerCreateWithContext below,\n+     * it will fail.\n+     */\n+    if (width == 0 || height == 0) {\n+        return (cairo_surface_t*)\n+            _cairo_quartz_surface_create_internal (NULL, content,\n+                                                   width, height);\n+    }\n+\n+    layer = CGLayerCreateWithContext (cgContext,\n+                                      CGSizeMake (width, height),\n+                                      NULL);\n+    if (!layer)\n+      return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));\n+\n+    ctx = CGLayerGetContext (layer);\n+    CGContextSetInterpolationQuality (ctx, kCGInterpolationNone);\n+    /* Flip it when we draw into it, so that when we finally composite it\n+     * to a flipped target, the directions match and Quartz will optimize\n+     * the composition properly\n+     */\n+    CGContextTranslateCTM (ctx, 0, height);\n+    CGContextScaleCTM (ctx, 1, -1);\n+\n+    CGContextRetain (ctx);\n+    surf = _cairo_quartz_surface_create_internal (ctx, content,\n+                                                  width, height);\n+    if (surf->base.status) {\n+        CGLayerRelease (layer);\n+        // create_internal will have set an error\n+        return (cairo_surface_t*) surf;\n+    }\n+    surf->cgLayer = layer;\n+\n+    return (cairo_surface_t *) surf;\n+}\n+\n+/**\n  * cairo_quartz_surface_create\n  * @format: format of pixels in the surface to create\n  * @width: width of the surface, in pixels\n@@ -3075,13 +3419,93 @@ cairo_quartz_surface_create (cairo_forma\n\t\t\t     unsigned int width,\n\t\t\t     unsigned int height)\n {\n+    int stride;\n+    unsigned char *data;\n+\n+    if (!_cairo_quartz_verify_surface_size(width, height))\n+\treturn _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_SIZE));\n+\n+    if (width == 0 || height == 0) {\n+\treturn (cairo_surface_t*) _cairo_quartz_surface_create_internal (NULL, _cairo_content_from_format (format),\n+\t\t\t\t\t\t\t\t\t width, height);\n+    }\n+\n+    if (format == CAIRO_FORMAT_ARGB32 ||\n+\tformat == CAIRO_FORMAT_RGB24)\n+    {\n+\tstride = width * 4;\n+    } else if (format == CAIRO_FORMAT_A8) {\n+\tstride = width;\n+    } else if (format == CAIRO_FORMAT_A1) {\n+\t/* I don't think we can usefully support this, as defined by\n+\t * cairo_format_t -- these are 1-bit pixels stored in 32-bit\n+\t * quantities.\n+\t */\n+\treturn _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_FORMAT));\n+    } else {\n+\treturn _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_FORMAT));\n+    }\n+\n+    /* The Apple docs say that for best performance, the stride and the data\n+     * pointer should be 16-byte aligned.  malloc already aligns to 16-bytes,\n+     * so we don't have to anything special on allocation.\n+     */\n+    stride = (stride + 15) & ~15;\n+\n+    data = _cairo_malloc_ab (height, stride);\n+    if (!data) {\n+\treturn _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));\n+    }\n+\n+    /* zero the memory to match the image surface behaviour */\n+    memset (data, 0, height * stride);\n+\n+    cairo_quartz_surface_t *surf;\n+    surf = (cairo_quartz_surface_t *) cairo_quartz_surface_create_for_data\n+                                           (data, format, width, height, stride);\n+    if (surf->base.status) {\n+        free (data);\n+        return (cairo_surface_t *) surf;\n+    }\n+\n+    // We created this data, so we can delete it.\n+    surf->ownsData = TRUE;\n+\n+    return (cairo_surface_t *) surf;\n+}\n+\n+/**\n+ * cairo_quartz_surface_create_for_data\n+ * @data: a pointer to a buffer supplied by the application in which\n+ *     to write contents. This pointer must be suitably aligned for any\n+ *     kind of variable, (for example, a pointer returned by malloc).\n+ * @format: format of pixels in the surface to create\n+ * @width: width of the surface, in pixels\n+ * @height: height of the surface, in pixels\n+ *\n+ * Creates a Quartz surface backed by a CGBitmap.  The surface is\n+ * created using the Device RGB (or Device Gray, for A8) color space.\n+ * All Cairo operations, including those that require software\n+ * rendering, will succeed on this surface.\n+ *\n+ * Return value: the newly created surface.\n+ *\n+ * Since: 1.12\n+ **/\n+cairo_surface_t *\n+cairo_quartz_surface_create_for_data (unsigned char *data,\n+\t\t\t\t      cairo_format_t format,\n+\t\t\t\t      unsigned int width,\n+\t\t\t\t      unsigned int height,\n+\t\t\t\t      unsigned int stride)\n+{\n     cairo_quartz_surface_t *surf;\n     CGContextRef cgc;\n     CGColorSpaceRef cgColorspace;\n     CGBitmapInfo bitinfo;\n-    void *imageData;\n-    int stride;\n+    void *imageData = data;\n     int bitsPerComponent;\n+    unsigned int i;\n\n     // verify width and height of surface\n     if (!_cairo_quartz_verify_surface_size(width, height))\n@@ -3102,10 +3526,8 @@ cairo_quartz_surface_create (cairo_forma\n\telse\n\t    bitinfo |= kCGImageAlphaNoneSkipFirst;\n\tbitsPerComponent = 8;\n-\tstride = width * 4;\n     } else if (format == CAIRO_FORMAT_A8) {\n\tcgColorspace = NULL;\n-\tstride = width;\n\tbitinfo = kCGImageAlphaOnly;\n\tbitsPerComponent = 8;\n     } else if (format == CAIRO_FORMAT_A1) {\n@@ -3118,21 +3540,6 @@ cairo_quartz_surface_create (cairo_forma\n\treturn _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_FORMAT));\n     }\n\n-    /* The Apple docs say that for best performance, the stride and the data\n-     * pointer should be 16-byte aligned.  malloc already aligns to 16-bytes,\n-     * so we don't have to anything special on allocation.\n-     */\n-    stride = (stride + 15) & ~15;\n-\n-    imageData = _cairo_malloc_ab (height, stride);\n-    if (!imageData) {\n-\tCGColorSpaceRelease (cgColorspace);\n-\treturn _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));\n-    }\n-\n-    /* zero the memory to match the image surface behaviour */\n-    memset (imageData, 0, height * stride);\n-\n     cgc = CGBitmapContextCreate (imageData,\n\t\t\t\t width,\n\t\t\t\t height,\n@@ -3161,7 +3568,19 @@ cairo_quartz_surface_create (cairo_forma\n     }\n\n     surf->imageData = imageData;\n-    surf->imageSurfaceEquiv = cairo_image_surface_create_for_data (imageData, format, width, height, stride);\n+\n+    cairo_surface_t* tmpImageSurfaceEquiv =\n+      cairo_image_surface_create_for_data (imageData, format,\n+                                           width, height, stride);\n+\n+    if (cairo_surface_status (tmpImageSurfaceEquiv)) {\n+        // Tried & failed to create an imageSurfaceEquiv!\n+        cairo_surface_destroy (tmpImageSurfaceEquiv);\n+        surf->imageSurfaceEquiv = NULL;\n+    } else {\n+        surf->imageSurfaceEquiv = tmpImageSurfaceEquiv;\n+        surf->ownsData = FALSE;\n+    }\n\n     return (cairo_surface_t *) surf;\n }\n@@ -3193,6 +3612,74 @@ _cairo_surface_is_quartz (const cairo_su\n     return surface->backend == &cairo_quartz_surface_backend;\n }\n\n+CGContextRef\n+cairo_quartz_get_cg_context_with_clip (cairo_t *cr)\n+{\n+\n+    cairo_surface_t *surface = cr->gstate->target;\n+    cairo_clip_t *clip = &cr->gstate->clip;\n+    cairo_status_t status;\n+\n+    cairo_quartz_surface_t *quartz = (cairo_quartz_surface_t*)surface;\n+\n+    if (cairo_surface_get_type(surface) != CAIRO_SURFACE_TYPE_QUARTZ)\n+\treturn NULL;\n+\n+    if (!clip->path) {\n+\tif (clip->all_clipped) {\n+\t    /* Save the state before we set an empty clip rect so that\n+\t     * our previous clip will be restored */\n+\n+\t    /* _cairo_surface_clipper_set_clip doesn't deal with\n+\t     * clip->all_clipped because drawing is normally discarded earlier */\n+\t    CGRect empty = {{0,0}, {0,0}};\n+\t    CGContextClipToRect (quartz->cgContext, empty);\n+\t    CGContextSaveGState (quartz->cgContext);\n+\n+\t    return quartz->cgContext;\n+\t}\n+\n+\t/* an empty clip is represented by NULL */\n+\tclip = NULL;\n+    }\n+\n+    status = _cairo_surface_clipper_set_clip (&quartz->clipper, clip);\n+\n+    /* Save the state after we set the clip so that it persists\n+     * after we restore */\n+    CGContextSaveGState (quartz->cgContext);\n+\n+    if (unlikely (status))\n+\treturn NULL;\n+\n+    return quartz->cgContext;\n+}\n+\n+void\n+cairo_quartz_finish_cg_context_with_clip (cairo_t *cr)\n+{\n+    cairo_surface_t *surface = cr->gstate->target;\n+\n+    cairo_quartz_surface_t *quartz = (cairo_quartz_surface_t*)surface;\n+\n+    if (cairo_surface_get_type(surface) != CAIRO_SURFACE_TYPE_QUARTZ)\n+\treturn;\n+\n+    CGContextRestoreGState (quartz->cgContext);\n+}\n+\n+cairo_surface_t *\n+cairo_quartz_surface_get_image (cairo_surface_t *surface)\n+{\n+    cairo_quartz_surface_t *quartz = (cairo_quartz_surface_t *)surface;\n+    cairo_image_surface_t *image;\n+\n+    if (_cairo_quartz_get_image(quartz, &image))\n+        return NULL;\n+\n+    return (cairo_surface_t *)image;\n+}\n+\n /* Debug stuff */\n\n #ifdef QUARTZ_DEBUG\n--- a/src/cairo-quartz.h\t2012-11-13 18:20:00.000000000 -0800\n+++ b/src/cairo-quartz.h\t2012-11-13 18:06:56.000000000 -0800\n@@ -50,6 +50,19 @@ cairo_quartz_surface_create (cairo_forma\n                              unsigned int height);\n\n cairo_public cairo_surface_t *\n+cairo_quartz_surface_create_for_data (unsigned char *data,\n+\t\t\t\t      cairo_format_t format,\n+\t\t\t\t      unsigned int width,\n+\t\t\t\t      unsigned int height,\n+\t\t\t\t      unsigned int stride);\n+\n+cairo_public cairo_surface_t *\n+cairo_quartz_surface_create_cg_layer (cairo_surface_t *surface,\n+                                      cairo_content_t content,\n+                                      unsigned int width,\n+                                      unsigned int height);\n+\n+cairo_public cairo_surface_t *\n cairo_quartz_surface_create_for_cg_context (CGContextRef cgContext,\n                                             unsigned int width,\n                                             unsigned int height);\n@@ -57,6 +70,15 @@ cairo_quartz_surface_create_for_cg_conte\n cairo_public CGContextRef\n cairo_quartz_surface_get_cg_context (cairo_surface_t *surface);\n\n+cairo_public CGContextRef\n+cairo_quartz_get_cg_context_with_clip (cairo_t *cr);\n+\n+cairo_public void\n+cairo_quartz_finish_cg_context_with_clip (cairo_t *cr);\n+\n+cairo_public cairo_surface_t *\n+cairo_quartz_surface_get_image (cairo_surface_t *surface);\n+\n #if CAIRO_HAS_QUARTZ_FONT\n\n /*\n@@ -66,8 +88,10 @@ cairo_quartz_surface_get_cg_context (cai\n cairo_public cairo_font_face_t *\n cairo_quartz_font_face_create_for_cgfont (CGFontRef font);\n\n+#ifndef __LP64__\n cairo_public cairo_font_face_t *\n cairo_quartz_font_face_create_for_atsu_font_id (ATSUFontID font_id);\n+#endif\n\n #endif /* CAIRO_HAS_QUARTZ_FONT */",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/bockbuild/packages/patches/cairo-fix-CGFontGetGlyphPath-deprecation.patch": "From 9d460070fca2c0a61aac60ba7cad6f9a6af82309 Mon Sep 17 00:00:00 2001\nFrom: Andrea Canciani <ranma42@gmail.com>\nDate: Tue, 9 Dec 2014 16:13:00 +0100\nSubject: [PATCH] quartz: Remove call to obsolete CGFontGetGlyphPath\n\nCGFontGetGlyphPath was not public and is not available anymore on\nmodern OSX/iOS systems. The same functionality is available through\nthe CoreText API since OSX 10.5.\n\nBased on a patch by Simon Cozens.\n\nFixes https://bugs.freedesktop.org/show_bug.cgi?id=84324\n---\n src/cairo-quartz-font.c | 10 ++++------\n 1 file changed, 4 insertions(+), 6 deletions(-)\n\ndiff --git a/src/cairo-quartz-font.c b/src/cairo-quartz-font.c\nindex e6a379a..02f3426 100644\n--- a/src/cairo-quartz-font.c\n+++ b/src/cairo-quartz-font.c\n@@ -81,9 +81,6 @@ static void (*CGFontGetGlyphsForUnicharsPtr) (CGFontRef, const UniChar[], const\n static void (*CGContextSetAllowsFontSmoothingPtr) (CGContextRef, bool) = NULL;\n static bool (*CGContextGetAllowsFontSmoothingPtr) (CGContextRef) = NULL;\n\n-/* Not public in the least bit */\n-static CGPathRef (*CGFontGetGlyphPathPtr) (CGFontRef fontRef, CGAffineTransform *textTransform, int unknown, CGGlyph glyph) = NULL;\n-\n /* CGFontGetHMetrics isn't public, but the other functions are public/present in 10.5 */\n typedef struct {\n     int ascent;\n@@ -127,7 +124,6 @@ quartz_font_ensure_symbols(void)\n     /* These have the same name in 10.4 and 10.5 */\n     CGFontGetUnitsPerEmPtr = dlsym(RTLD_DEFAULT, \"CGFontGetUnitsPerEm\");\n     CGFontGetGlyphAdvancesPtr = dlsym(RTLD_DEFAULT, \"CGFontGetGlyphAdvances\");\n-    CGFontGetGlyphPathPtr = dlsym(RTLD_DEFAULT, \"CGFontGetGlyphPath\");\n\n     CGFontGetHMetricsPtr = dlsym(RTLD_DEFAULT, \"CGFontGetHMetrics\");\n     CGFontGetAscentPtr = dlsym(RTLD_DEFAULT, \"CGFontGetAscent\");\n@@ -144,7 +140,6 @@ quartz_font_ensure_symbols(void)\n\tCGFontGetGlyphsForUnicharsPtr &&\n\tCGFontGetUnitsPerEmPtr &&\n\tCGFontGetGlyphAdvancesPtr &&\n-\tCGFontGetGlyphPathPtr &&\n\t(CGFontGetHMetricsPtr || (CGFontGetAscentPtr && CGFontGetDescentPtr && CGFontGetLeadingPtr)))\n\t_cairo_quartz_font_symbols_present = TRUE;\n\n@@ -550,6 +545,7 @@ _cairo_quartz_init_glyph_path (cairo_quartz_scaled_font_t *font,\n     CGGlyph glyph = _cairo_quartz_scaled_glyph_index (scaled_glyph);\n     CGAffineTransform textMatrix;\n     CGPathRef glyphPath;\n+    CTFontRef ctFont;\n     cairo_path_fixed_t *path;\n\n     if (glyph == INVALID_GLYPH) {\n@@ -564,7 +560,9 @@ _cairo_quartz_init_glyph_path (cairo_quartz_scaled_font_t *font,\n\t\t\t\t\t-font->base.scale.yy,\n\t\t\t\t\t0, 0);\n\n-    glyphPath = CGFontGetGlyphPathPtr (font_face->cgFont, &textMatrix, 0, glyph);\n+    ctFont = CTFontCreateWithGraphicsFont (font_face->cgFont, 1.0, NULL, NULL);\n+    glyphPath = CTFontCreatePathForGlyph (ctFont, glyph, &textMatrix);\n+    CFRelease (ctFont);\n     if (!glyphPath)\n\treturn CAIRO_INT_STATUS_UNSUPPORTED;\n\n--\n1.9.3 (Apple Git-50)\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corert/src/Native/System.Private.CoreLib.Native/pal_dynamicload.cpp": "// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\n#include <dlfcn.h>\n\nextern \"C\" void* CoreLibNative_LoadLibrary(const char* filename)\n{\n    return dlopen(filename, RTLD_LAZY);\n}\n\nextern \"C\" void* CoreLibNative_GetProcAddress(void* handle, const char* symbol)\n{\n    // We're not trying to disambiguate between \"symbol was not found\" and \"symbol found, but\n    // the value is null\". .NET does not define a behavior for DllImports of null entrypoints,\n    // so we might as well take the \"not found\" path on the managed side.\n    return dlsym(handle, symbol);\n}\n\nextern \"C\" void CoreLibNative_FreeLibrary(void* handle)\n{\n    dlclose(handle);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System/System.Net/MacProxy.cs": "// \n// MacProxy.cs\n//  \n// Author: Jeffrey Stedfast <jeff@xamarin.com>\n// \n// Copyright (c) 2012-2014 Xamarin Inc.\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// \n\nusing System;\nusing System.Net;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing ObjCRuntimeInternal;\n\nnamespace Mono.Net\n{\n\tinternal class CFType {\n\t\t[DllImport (CFObject.CoreFoundationLibrary, EntryPoint=\"CFGetTypeID\")]\n\t\tpublic static extern IntPtr GetTypeID (IntPtr typeRef);\n\t}\n\n\tinternal class CFObject : IDisposable, INativeObject\n\t{\n\t\tpublic const string CoreFoundationLibrary = \"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\";\n\t\tconst string SystemLibrary = \"/usr/lib/libSystem.dylib\";\n\n\t\t[DllImport (SystemLibrary)]\n\t\tpublic static extern IntPtr dlopen (string path, int mode);\n\n\t\t[DllImport (SystemLibrary)]\n\t\tstatic extern IntPtr dlsym (IntPtr handle, string symbol);\n\n\t\t[DllImport (SystemLibrary)]\n\t\tpublic static extern void dlclose (IntPtr handle);\n\n\t\tpublic static IntPtr GetIndirect (IntPtr handle, string symbol)\n\t\t{\n\t\t\treturn dlsym (handle, symbol);\n\t\t}\n\n\t\tpublic static CFString GetStringConstant (IntPtr handle, string symbol)\n\t\t{\n\t\t\tvar indirect = dlsym (handle, symbol);\n\t\t\tif (indirect == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\tvar actual = Marshal.ReadIntPtr (indirect);\n\t\t\tif (actual == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\treturn new CFString (actual, false);\n\t\t}\n\n\t\tpublic static IntPtr GetIntPtr (IntPtr handle, string symbol)\n\t\t{\n\t\t\tvar indirect = dlsym (handle, symbol);\n\t\t\tif (indirect == IntPtr.Zero)\n\t\t\t\treturn IntPtr.Zero;\n\t\t\treturn Marshal.ReadIntPtr (indirect);\n\t\t}\n\n\t\tpublic static IntPtr GetCFObjectHandle (IntPtr handle, string symbol)\n\t\t{\n\t\t\tvar indirect = dlsym (handle, symbol);\n\t\t\tif (indirect == IntPtr.Zero)\n\t\t\t\treturn IntPtr.Zero;\n\n\t\t\treturn Marshal.ReadIntPtr (indirect);\n\t\t}\n\n\t\tpublic CFObject (IntPtr handle, bool own)\n\t\t{\n\t\t\tHandle = handle;\n\n\t\t\tif (!own)\n\t\t\t\tRetain ();\n\t\t}\n\n\t\t~CFObject ()\n\t\t{\n\t\t\tDispose (false);\n\t\t}\n\n\t\tpublic IntPtr Handle { get; private set; }\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\tinternal extern static IntPtr CFRetain (IntPtr handle);\n\n\t\tvoid Retain ()\n\t\t{\n\t\t\tCFRetain (Handle);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\tinternal extern static void CFRelease (IntPtr handle);\n\n\t\tvoid Release ()\n\t\t{\n\t\t\tCFRelease (Handle);\n\t\t}\n\n\t\tprotected virtual void Dispose (bool disposing)\n\t\t{\n\t\t\tif (Handle != IntPtr.Zero) {\n\t\t\t\tRelease ();\n\t\t\t\tHandle = IntPtr.Zero;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Dispose ()\n\t\t{\n\t\t\tDispose (true);\n\t\t\tGC.SuppressFinalize (this);\n\t\t}\n\t}\n\n\tinternal class CFArray : CFObject\n\t{\n\t\tpublic CFArray (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFArrayCreate (IntPtr allocator, IntPtr values, /* CFIndex */ IntPtr numValues, IntPtr callbacks);\n\t\tstatic readonly IntPtr kCFTypeArrayCallbacks;\n\n\t\tstatic CFArray ()\n\t\t{\n\t\t\tvar handle = dlopen (CoreFoundationLibrary, 0);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tkCFTypeArrayCallbacks = GetIndirect (handle, \"kCFTypeArrayCallBacks\");\n\t\t\t} finally {\n\t\t\t\tdlclose (handle);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static CFArray FromNativeObjects (params INativeObject[] values)\n\t\t{\n\t\t\treturn new CFArray (Create (values), true);\n\t\t}\n\n\t\tpublic static unsafe IntPtr Create (params IntPtr[] values)\n\t\t{\n\t\t\tif (values == null)\n\t\t\t\tthrow new ArgumentNullException (\"values\");\n\t\t\tfixed (IntPtr* pv = values) {\n\t\t\t\treturn CFArrayCreate (IntPtr.Zero, (IntPtr) pv, (IntPtr)values.Length, kCFTypeArrayCallbacks);\n\t\t\t}\n\t\t}\n\n\t\tinternal static unsafe CFArray CreateArray (params IntPtr[] values)\n\t\t{\n\t\t\tif (values == null)\n\t\t\t\tthrow new ArgumentNullException (\"values\");\n\n\t\t\tfixed (IntPtr *pv = values) {\n\t\t\t\tIntPtr handle = CFArrayCreate (IntPtr.Zero, (IntPtr) pv, (IntPtr) values.Length, kCFTypeArrayCallbacks);\n\n\t\t\t\treturn new CFArray (handle, false);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static CFArray CreateArray (params INativeObject[] values)\n\t\t{\n\t\t\treturn new CFArray (Create (values), true);\n\t\t}\n\n\t\tpublic static IntPtr Create (params INativeObject[] values)\n\t\t{\n\t\t\tif (values == null)\n\t\t\t\tthrow new ArgumentNullException (\"values\");\n\t\t\tIntPtr[] _values = new IntPtr [values.Length];\n\t\t\tfor (int i = 0; i < _values.Length; ++i)\n\t\t\t\t_values [i] = values [i].Handle;\n\t\t\treturn Create (_values);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static /* CFIndex */ IntPtr CFArrayGetCount (IntPtr handle);\n\n\t\tpublic int Count {\n\t\t\tget { return (int) CFArrayGetCount (Handle); }\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFArrayGetValueAtIndex (IntPtr handle, /* CFIndex */ IntPtr index);\n\n\t\tpublic IntPtr this[int index] {\n\t\t\tget {\n\t\t\t\treturn CFArrayGetValueAtIndex (Handle, (IntPtr) index);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic public T [] ArrayFromHandle<T> (IntPtr handle, Func<IntPtr, T> creation) where T : class, INativeObject\n\t\t{\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn null;\n\n\t\t\tvar c = CFArrayGetCount (handle);\n\t\t\tT [] ret = new T [(int)c];\n\n\t\t\tfor (uint i = 0; i < (uint)c; i++) {\n\t\t\t\tret [i] = creation (CFArrayGetValueAtIndex (handle, (IntPtr)i));\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tinternal class CFNumber : CFObject\n\t{\n\t\tpublic CFNumber (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\t[return: MarshalAs (UnmanagedType.I1)]\n\t\textern static bool CFNumberGetValue (IntPtr handle, /* CFNumberType */ IntPtr type, [MarshalAs (UnmanagedType.I1)] out bool value);\n\n\t\tpublic static bool AsBool (IntPtr handle)\n\t\t{\n\t\t\tbool value;\n\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn false;\n\n\t\t\tCFNumberGetValue (handle, (IntPtr) 1, out value);\n\n\t\t\treturn value;\n\t\t}\n\n\t\tpublic static implicit operator bool (CFNumber number)\n\t\t{\n\t\t\treturn AsBool (number.Handle);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\t[return: MarshalAs (UnmanagedType.I1)]\n\t\textern static bool CFNumberGetValue (IntPtr handle, /* CFNumberType */ IntPtr type, out int value);\n\n\t\tpublic static int AsInt32 (IntPtr handle)\n\t\t{\n\t\t\tint value;\n\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn 0;\n\n\t\t\t// 9 == kCFNumberIntType == C int\n\t\t\tCFNumberGetValue (handle, (IntPtr) 9, out value);\n\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFNumberCreate (IntPtr allocator, IntPtr theType, IntPtr valuePtr);\t\n\n\t\tpublic static CFNumber FromInt32 (int number)\n\t\t{\n\t\t\t// 9 == kCFNumberIntType == C int\n\t\t\treturn new CFNumber (CFNumberCreate (IntPtr.Zero, (IntPtr)9, (IntPtr)number), true);\n\t\t}\n\n\t\tpublic static implicit operator int (CFNumber number)\n\t\t{\n\t\t\treturn AsInt32 (number.Handle);\n\t\t}\n\t}\n\n\tinternal struct CFRange {\n\t\tpublic IntPtr Location, Length;\n\t\t\n\t\tpublic CFRange (int loc, int len)\n\t\t{\n\t\t\tLocation = (IntPtr) loc;\n\t\t\tLength = (IntPtr) len;\n\t\t}\n\t}\n\n\tinternal struct CFStreamClientContext {\n\t\tpublic IntPtr Version;\n\t\tpublic IntPtr Info;\n\t\tpublic IntPtr Retain;\n\t\tpublic IntPtr Release;\n\t\tpublic IntPtr CopyDescription;\n\t}\n\n\tinternal class CFString : CFObject\n\t{\n\t\tstring str;\n\n\t\tpublic CFString (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFStringCreateWithCharacters (IntPtr alloc, IntPtr chars, /* CFIndex */ IntPtr length);\n\n\t\tpublic static CFString Create (string value)\n\t\t{\n\t\t\tIntPtr handle;\n\n\t\t\tunsafe {\n\t\t\t\tfixed (char *ptr = value) {\n\t\t\t\t\thandle = CFStringCreateWithCharacters (IntPtr.Zero, (IntPtr) ptr, (IntPtr) value.Length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn null;\n\n\t\t\treturn new CFString (handle, true);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static /* CFIndex */ IntPtr CFStringGetLength (IntPtr handle);\n\n\t\tpublic int Length {\n\t\t\tget {\n\t\t\t\tif (str != null)\n\t\t\t\t\treturn str.Length;\n\n\t\t\t\treturn (int) CFStringGetLength (Handle);\n\t\t\t}\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFStringGetCharactersPtr (IntPtr handle);\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFStringGetCharacters (IntPtr handle, CFRange range, IntPtr buffer);\n\n\t\tpublic static string AsString (IntPtr handle)\n\t\t{\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tint len = (int) CFStringGetLength (handle);\n\t\t\t\n\t\t\tif (len == 0)\n\t\t\t\treturn string.Empty;\n\t\t\t\n\t\t\tIntPtr chars = CFStringGetCharactersPtr (handle);\n\t\t\tIntPtr buffer = IntPtr.Zero;\n\t\t\t\n\t\t\tif (chars == IntPtr.Zero) {\n\t\t\t\tCFRange range = new CFRange (0, len);\n\t\t\t\tbuffer = Marshal.AllocHGlobal (len * 2);\n\t\t\t\tCFStringGetCharacters (handle, range, buffer);\n\t\t\t\tchars = buffer;\n\t\t\t}\n\n\t\t\tstring str;\n\n\t\t\tunsafe {\n\t\t\t\tstr = new string ((char *) chars, 0, len);\n\t\t\t}\n\t\t\t\n\t\t\tif (buffer != IntPtr.Zero)\n\t\t\t\tMarshal.FreeHGlobal (buffer);\n\n\t\t\treturn str;\n\t\t}\n\n\t\tpublic override string ToString ()\n\t\t{\n\t\t\tif (str == null)\n\t\t\t\tstr = AsString (Handle);\n\n\t\t\treturn str;\n\t\t}\n\n\t\tpublic static implicit operator string (CFString str)\n\t\t{\n\t\t\treturn str.ToString ();\n\t\t}\n\n\t\tpublic static implicit operator CFString (string str)\n\t\t{\n\t\t\treturn Create (str);\n\t\t}\n\t}\n\n\t\n\tinternal class CFData : CFObject\n\t{\n\t\tpublic CFData (IntPtr handle, bool own) : base (handle, own) { }\n\t\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static /* CFDataRef */ IntPtr CFDataCreate (/* CFAllocatorRef */ IntPtr allocator, /* UInt8* */ IntPtr bytes, /* CFIndex */ IntPtr length);\n\t\tpublic unsafe static CFData FromData (byte [] buffer)\n\t\t{\n\t\t\tfixed (byte* p = buffer)\n\t\t\t{\n\t\t\t\treturn FromData ((IntPtr)p, (IntPtr)buffer.Length);\n\t\t\t}\n\t\t}\n\n\t\tpublic static CFData FromData (IntPtr buffer, IntPtr length)\n\t\t{\n\t\t\treturn new CFData (CFDataCreate (IntPtr.Zero, buffer, length), true);\n\t\t}\n\t\t\n\t\tpublic IntPtr Length {\n\t\t\tget { return CFDataGetLength (Handle); }\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static /* CFIndex */ IntPtr CFDataGetLength (/* CFDataRef */ IntPtr theData);\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static /* UInt8* */ IntPtr CFDataGetBytePtr (/* CFDataRef */ IntPtr theData);\n\n\t\t/*\n\t\t * Exposes a read-only pointer to the underlying storage.\n\t\t */\n\t\tpublic IntPtr Bytes {\n\t\t\tget { return CFDataGetBytePtr (Handle); }\n\t\t}\n\n\t\tpublic byte this [long idx] {\n\t\t\tget {\n\t\t\t\tif (idx < 0 || (ulong) idx > (ulong) Length)\n\t\t\t\t\tthrow new ArgumentException (\"idx\");\n\t\t\t\treturn Marshal.ReadByte (new IntPtr (Bytes.ToInt64 () + idx));\n\t\t\t}\n\n\t\t\tset {\n\t\t\t\tthrow new NotImplementedException (\"NSData arrays can not be modified, use an NSMutableData instead\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\tinternal class CFDictionary : CFObject\n\t{\n\t\tstatic readonly IntPtr KeyCallbacks;\n\t\tstatic readonly IntPtr ValueCallbacks;\n\t\t\n\t\tstatic CFDictionary ()\n\t\t{\n\t\t\tvar handle = dlopen (CoreFoundationLibrary, 0);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn;\n\n\t\t\ttry {\t\t\n\t\t\t\tKeyCallbacks = GetIndirect (handle, \"kCFTypeDictionaryKeyCallBacks\");\n\t\t\t\tValueCallbacks = GetIndirect (handle, \"kCFTypeDictionaryValueCallBacks\");\n\t\t\t} finally {\n\t\t\t\tdlclose (handle);\n\t\t\t}\n\t\t}\n\n\t\tpublic CFDictionary (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\tpublic static CFDictionary FromObjectAndKey (IntPtr obj, IntPtr key)\n\t\t{\n\t\t\treturn new CFDictionary (CFDictionaryCreate (IntPtr.Zero, new IntPtr[] { key }, new IntPtr [] { obj }, (IntPtr)1, KeyCallbacks, ValueCallbacks), true);\n\t\t}\n\n\t\tpublic static CFDictionary FromKeysAndObjects (IList<Tuple<IntPtr,IntPtr>> items)\n\t\t{\n\t\t\tvar keys = new IntPtr [items.Count];\n\t\t\tvar values = new IntPtr [items.Count];\n\t\t\tfor (int i = 0; i < items.Count; i++) {\n\t\t\t\tkeys [i] = items [i].Item1;\n\t\t\t\tvalues [i] = items [i].Item2;\n\t\t\t}\n\t\t\treturn new CFDictionary (CFDictionaryCreate (IntPtr.Zero, keys, values, (IntPtr)items.Count, KeyCallbacks, ValueCallbacks), true);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFDictionaryCreate (IntPtr allocator, IntPtr[] keys, IntPtr[] vals, IntPtr len, IntPtr keyCallbacks, IntPtr valCallbacks);\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFDictionaryGetValue (IntPtr handle, IntPtr key);\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFDictionaryCreateCopy (IntPtr allocator, IntPtr handle);\n\n\t\tpublic CFDictionary Copy ()\n\t\t{\n\t\t\treturn new CFDictionary (CFDictionaryCreateCopy (IntPtr.Zero, Handle), true);\n\t\t}\n\t\t\n\t\tpublic CFMutableDictionary MutableCopy ()\n\t\t{\n\t\t\treturn new CFMutableDictionary (CFDictionaryCreateMutableCopy (IntPtr.Zero, IntPtr.Zero, Handle), true);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFDictionaryCreateMutableCopy (IntPtr allocator, IntPtr capacity, IntPtr theDict);\n\n\t\tpublic IntPtr GetValue (IntPtr key)\n\t\t{\n\t\t\treturn CFDictionaryGetValue (Handle, key);\n\t\t}\n\n\t\tpublic IntPtr this[IntPtr key] {\n\t\t\tget {\n\t\t\t\treturn GetValue (key);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinternal class CFMutableDictionary : CFDictionary\n\t{\n\t\tpublic CFMutableDictionary (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\tpublic void SetValue (IntPtr key, IntPtr val)\n\t\t{\n\t\t\tCFDictionarySetValue (Handle, key, val);\n\t\t}\n\n\t\tpublic static CFMutableDictionary Create ()\n\t\t{\n\t\t\tvar handle = CFDictionaryCreateMutable (IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\tthrow new InvalidOperationException ();\n\t\t\treturn new CFMutableDictionary (handle, true);\n\t\t}\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static void CFDictionarySetValue (IntPtr handle, IntPtr key, IntPtr val);\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFDictionaryCreateMutable (IntPtr allocator, IntPtr capacity, IntPtr keyCallback, IntPtr valueCallbacks);\n\n\t}\n\n\tinternal class CFUrl : CFObject\n\t{\n\t\tpublic CFUrl (IntPtr handle, bool own) : base (handle, own) { }\n\n\t\t[DllImport (CoreFoundationLibrary)]\n\t\textern static IntPtr CFURLCreateWithString (IntPtr allocator, IntPtr str, IntPtr baseURL);\n\n\t\tpublic static CFUrl Create (string absolute)\n\t\t{\n\t\t\tif (string.IsNullOrEmpty (absolute))\n\t\t\t\treturn null;\n\n\t\t\tCFString str = CFString.Create (absolute);\n\t\t\tIntPtr handle = CFURLCreateWithString (IntPtr.Zero, str.Handle, IntPtr.Zero);\n\t\t\tstr.Dispose ();\n\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn null;\n\n\t\t\treturn new CFUrl (handle, true);\n\t\t}\n\t}\n\n\tinternal class CFRunLoop : CFObject\n\t{\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\tstatic extern void CFRunLoopAddSource (IntPtr rl, IntPtr source, IntPtr mode);\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\tstatic extern void CFRunLoopRemoveSource (IntPtr rl, IntPtr source, IntPtr mode);\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\tstatic extern int CFRunLoopRunInMode (IntPtr mode, double seconds, bool returnAfterSourceHandled);\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\tstatic extern IntPtr CFRunLoopGetCurrent ();\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\tstatic extern void CFRunLoopStop (IntPtr rl);\n\n\t\tpublic CFRunLoop (IntPtr handle, bool own): base (handle, own)\n\t\t{\n\t\t}\n\n\t\tpublic static CFRunLoop CurrentRunLoop {\n\t\t\tget { return new CFRunLoop (CFRunLoopGetCurrent (), false); }\n\t\t}\n\n\t\tpublic void AddSource (IntPtr source, CFString mode)\n\t\t{\n\t\t\tCFRunLoopAddSource (Handle, source, mode.Handle);\n\t\t}\n\n\t\tpublic void RemoveSource (IntPtr source, CFString mode)\n\t\t{\n\t\t\tCFRunLoopRemoveSource (Handle, source, mode.Handle);\n\t\t}\n\n\t\tpublic int RunInMode (CFString mode, double seconds, bool returnAfterSourceHandled)\n\t\t{\n\t\t\treturn CFRunLoopRunInMode (mode.Handle, seconds, returnAfterSourceHandled);\n\t\t}\n\n\t\tpublic void Stop ()\n\t\t{\n\t\t\tCFRunLoopStop (Handle);\n\t\t}\n\t}\n\n\tinternal enum CFProxyType {\n\t\tNone,\n\t\tAutoConfigurationUrl,\n\t\tAutoConfigurationJavaScript,\n\t\tFTP,\n\t\tHTTP,\n\t\tHTTPS,\n\t\tSOCKS\n\t}\n\t\n\tinternal class CFProxy {\n\t\t//static IntPtr kCFProxyAutoConfigurationHTTPResponseKey;\n\t\tstatic IntPtr kCFProxyAutoConfigurationJavaScriptKey;\n\t\tstatic IntPtr kCFProxyAutoConfigurationURLKey;\n\t\tstatic IntPtr kCFProxyHostNameKey;\n\t\tstatic IntPtr kCFProxyPasswordKey;\n\t\tstatic IntPtr kCFProxyPortNumberKey;\n\t\tstatic IntPtr kCFProxyTypeKey;\n\t\tstatic IntPtr kCFProxyUsernameKey;\n\n\t\t//static IntPtr kCFProxyTypeNone;\n\t\tstatic IntPtr kCFProxyTypeAutoConfigurationURL;\n\t\tstatic IntPtr kCFProxyTypeAutoConfigurationJavaScript;\n\t\tstatic IntPtr kCFProxyTypeFTP;\n\t\tstatic IntPtr kCFProxyTypeHTTP;\n\t\tstatic IntPtr kCFProxyTypeHTTPS;\n\t\tstatic IntPtr kCFProxyTypeSOCKS;\n\n\t\tstatic CFProxy ()\n\t\t{\n\t\t\tIntPtr handle = CFObject.dlopen (CFNetwork.CFNetworkLibrary, 0);\n\n\t\t\t//kCFProxyAutoConfigurationHTTPResponseKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyAutoConfigurationHTTPResponseKey\");\n\t\t\tkCFProxyAutoConfigurationJavaScriptKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyAutoConfigurationJavaScriptKey\");\n\t\t\tkCFProxyAutoConfigurationURLKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyAutoConfigurationURLKey\");\n\t\t\tkCFProxyHostNameKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyHostNameKey\");\n\t\t\tkCFProxyPasswordKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyPasswordKey\");\n\t\t\tkCFProxyPortNumberKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyPortNumberKey\");\n\t\t\tkCFProxyTypeKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeKey\");\n\t\t\tkCFProxyUsernameKey = CFObject.GetCFObjectHandle (handle, \"kCFProxyUsernameKey\");\n\n\t\t\t//kCFProxyTypeNone = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeNone\");\n\t\t\tkCFProxyTypeAutoConfigurationURL = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeAutoConfigurationURL\");\n\t\t\tkCFProxyTypeAutoConfigurationJavaScript = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeAutoConfigurationJavaScript\");\n\t\t\tkCFProxyTypeFTP = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeFTP\");\n\t\t\tkCFProxyTypeHTTP = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeHTTP\");\n\t\t\tkCFProxyTypeHTTPS = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeHTTPS\");\n\t\t\tkCFProxyTypeSOCKS = CFObject.GetCFObjectHandle (handle, \"kCFProxyTypeSOCKS\");\n\n\t\t\tCFObject.dlclose (handle);\n\t\t}\n\n\t\tCFDictionary settings;\n\t\t\n\t\tinternal CFProxy (CFDictionary settings)\n\t\t{\n\t\t\tthis.settings = settings;\n\t\t}\n\t\t\n\t\tstatic CFProxyType CFProxyTypeToEnum (IntPtr type)\n\t\t{\n\t\t\tif (type == kCFProxyTypeAutoConfigurationJavaScript)\n\t\t\t\treturn CFProxyType.AutoConfigurationJavaScript;\n\n\t\t\tif (type == kCFProxyTypeAutoConfigurationURL)\n\t\t\t\treturn CFProxyType.AutoConfigurationUrl;\n\n\t\t\tif (type == kCFProxyTypeFTP)\n\t\t\t\treturn CFProxyType.FTP;\n\n\t\t\tif (type == kCFProxyTypeHTTP)\n\t\t\t\treturn CFProxyType.HTTP;\n\n\t\t\tif (type == kCFProxyTypeHTTPS)\n\t\t\t\treturn CFProxyType.HTTPS;\n\n\t\t\tif (type == kCFProxyTypeSOCKS)\n\t\t\t\treturn CFProxyType.SOCKS;\n\t\t\t\n\t\t\treturn CFProxyType.None;\n\t\t}\n\t\t\n#if false\n\t\t// AFAICT these get used with CFNetworkExecuteProxyAutoConfiguration*()\n\t\t\n\t\t// TODO: bind CFHTTPMessage so we can return the proper type here.\n\t\tpublic IntPtr AutoConfigurationHTTPResponse {\n\t\t\tget { return settings[kCFProxyAutoConfigurationHTTPResponseKey]; }\n\t\t}\n#endif\n\n\t\tpublic IntPtr AutoConfigurationJavaScript {\n\t\t\tget {\n\t\t\t\tif (kCFProxyAutoConfigurationJavaScriptKey == IntPtr.Zero)\n\t\t\t\t\treturn IntPtr.Zero;\n\t\t\t\t\n\t\t\t\treturn settings[kCFProxyAutoConfigurationJavaScriptKey];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic IntPtr AutoConfigurationUrl {\n\t\t\tget {\n\t\t\t\tif (kCFProxyAutoConfigurationURLKey == IntPtr.Zero)\n\t\t\t\t\treturn IntPtr.Zero;\n\t\t\t\t\n\t\t\t\treturn settings[kCFProxyAutoConfigurationURLKey];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string HostName {\n\t\t\tget {\n\t\t\t\tif (kCFProxyHostNameKey == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\treturn CFString.AsString (settings[kCFProxyHostNameKey]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string Password {\n\t\t\tget {\n\t\t\t\tif (kCFProxyPasswordKey == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\n\t\t\t\treturn CFString.AsString (settings[kCFProxyPasswordKey]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int Port {\n\t\t\tget {\n\t\t\t\tif (kCFProxyPortNumberKey == IntPtr.Zero)\n\t\t\t\t\treturn 0;\n\t\t\t\t\n\t\t\t\treturn CFNumber.AsInt32 (settings[kCFProxyPortNumberKey]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic CFProxyType ProxyType {\n\t\t\tget {\n\t\t\t\tif (kCFProxyTypeKey == IntPtr.Zero)\n\t\t\t\t\treturn CFProxyType.None;\n\t\t\t\t\n\t\t\t\treturn CFProxyTypeToEnum (settings[kCFProxyTypeKey]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string Username {\n\t\t\tget {\n\t\t\t\tif (kCFProxyUsernameKey == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\n\t\t\t\treturn CFString.AsString (settings[kCFProxyUsernameKey]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinternal class CFProxySettings {\n\t\tstatic IntPtr kCFNetworkProxiesHTTPEnable;\n\t\tstatic IntPtr kCFNetworkProxiesHTTPPort;\n\t\tstatic IntPtr kCFNetworkProxiesHTTPProxy;\n\t\tstatic IntPtr kCFNetworkProxiesProxyAutoConfigEnable;\n\t\tstatic IntPtr kCFNetworkProxiesProxyAutoConfigJavaScript;\n\t\tstatic IntPtr kCFNetworkProxiesProxyAutoConfigURLString;\n\n\t\tstatic CFProxySettings ()\n\t\t{\n\t\t\tIntPtr handle = CFObject.dlopen (CFNetwork.CFNetworkLibrary, 0);\n\n\t\t\tkCFNetworkProxiesHTTPEnable = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesHTTPEnable\");\n\t\t\tkCFNetworkProxiesHTTPPort = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesHTTPPort\");\n\t\t\tkCFNetworkProxiesHTTPProxy = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesHTTPProxy\");\n\t\t\tkCFNetworkProxiesProxyAutoConfigEnable = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesProxyAutoConfigEnable\");\n\t\t\tkCFNetworkProxiesProxyAutoConfigJavaScript = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesProxyAutoConfigJavaScript\");\n\t\t\tkCFNetworkProxiesProxyAutoConfigURLString = CFObject.GetCFObjectHandle (handle, \"kCFNetworkProxiesProxyAutoConfigURLString\");\n\n\t\t\tCFObject.dlclose (handle);\n\t\t}\n\n\t\tCFDictionary settings;\n\t\t\n\t\tpublic CFProxySettings (CFDictionary settings)\n\t\t{\n\t\t\tthis.settings = settings;\n\t\t}\n\t\t\n\t\tpublic CFDictionary Dictionary {\n\t\t\tget { return settings; }\n\t\t}\n\t\t\n\t\tpublic bool HTTPEnable {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesHTTPEnable == IntPtr.Zero)\n\t\t\t\t\treturn false;\n\n\t\t\t\treturn CFNumber.AsBool (settings[kCFNetworkProxiesHTTPEnable]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int HTTPPort {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesHTTPPort == IntPtr.Zero)\n\t\t\t\t\treturn 0;\n\t\t\t\t\n\t\t\t\treturn CFNumber.AsInt32 (settings[kCFNetworkProxiesHTTPPort]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string HTTPProxy {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesHTTPProxy == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\treturn CFString.AsString (settings[kCFNetworkProxiesHTTPProxy]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic bool ProxyAutoConfigEnable {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesProxyAutoConfigEnable == IntPtr.Zero)\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\treturn CFNumber.AsBool (settings[kCFNetworkProxiesProxyAutoConfigEnable]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string ProxyAutoConfigJavaScript {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesProxyAutoConfigJavaScript == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\treturn CFString.AsString (settings[kCFNetworkProxiesProxyAutoConfigJavaScript]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic string ProxyAutoConfigURLString {\n\t\t\tget {\n\t\t\t\tif (kCFNetworkProxiesProxyAutoConfigURLString == IntPtr.Zero)\n\t\t\t\t\treturn null;\n\t\t\t\t\n\t\t\t\treturn CFString.AsString (settings[kCFNetworkProxiesProxyAutoConfigURLString]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinternal static class CFNetwork {\n#if !MONOTOUCH\n\t\tpublic const string CFNetworkLibrary = \"/System/Library/Frameworks/CoreServices.framework/Frameworks/CFNetwork.framework/CFNetwork\";\n#else\n\t\tpublic const string CFNetworkLibrary = \"/System/Library/Frameworks/CFNetwork.framework/CFNetwork\";\n#endif\n\t\t\n\t\t[DllImport (CFNetworkLibrary, EntryPoint = \"CFNetworkCopyProxiesForAutoConfigurationScript\")]\n\t\t// CFArrayRef CFNetworkCopyProxiesForAutoConfigurationScript (CFStringRef proxyAutoConfigurationScript, CFURLRef targetURL, CFErrorRef* error);\n\t\textern static IntPtr CFNetworkCopyProxiesForAutoConfigurationScriptSequential (IntPtr proxyAutoConfigurationScript, IntPtr targetURL, out IntPtr error);\n\n\t\t[DllImport (CFNetworkLibrary)]\n\t\textern static IntPtr CFNetworkExecuteProxyAutoConfigurationURL (IntPtr proxyAutoConfigURL, IntPtr targetURL, CFProxyAutoConfigurationResultCallback cb, ref CFStreamClientContext clientContext);\n\n\n\t\tclass GetProxyData : IDisposable {\n\t\t\tpublic IntPtr script;\n\t\t\tpublic IntPtr targetUri;\n\t\t\tpublic IntPtr error;\n\t\t\tpublic IntPtr result;\n\t\t\tpublic ManualResetEvent evt = new ManualResetEvent (false);\n\n\t\t\tpublic void Dispose ()\n\t\t\t{\n\t\t\t\tevt.Close ();\n\t\t\t}\n\t\t}\n\n\t\tstatic object lock_obj = new object ();\n\t\tstatic Queue<GetProxyData> get_proxy_queue;\n\t\tstatic AutoResetEvent proxy_event;\n\n\t\tstatic void CFNetworkCopyProxiesForAutoConfigurationScriptThread ()\n\t\t{\n\t\t\tGetProxyData data;\n\t\t\tvar data_left = true;\n\n\t\t\twhile (true) {\n\t\t\t\tproxy_event.WaitOne ();\n\n\t\t\t\tdo {\n\t\t\t\t\tlock (lock_obj) {\n\t\t\t\t\t\tif (get_proxy_queue.Count == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdata = get_proxy_queue.Dequeue ();\n\t\t\t\t\t\tdata_left = get_proxy_queue.Count > 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.result = CFNetworkCopyProxiesForAutoConfigurationScriptSequential (data.script, data.targetUri, out data.error);\n\t\t\t\t\tdata.evt.Set ();\n\t\t\t\t} while (data_left);\n\t\t\t}\n\t\t}\n\n\t\tstatic IntPtr CFNetworkCopyProxiesForAutoConfigurationScript (IntPtr proxyAutoConfigurationScript, IntPtr targetURL, out IntPtr error)\n\t\t{\n\t\t\t// This method must only be called on only one thread during an application's life time.\n\t\t\t// Note that it's not enough to use a lock to make calls sequential across different threads,\n\t\t\t// it has to be one thread. Also note that that thread can't be the main thread, because the\n\t\t\t// main thread might be blocking waiting for this network request to finish.\n\t\t\t// Another possibility would be to use JavaScriptCore to execute this piece of\n\t\t\t// javascript ourselves, but unfortunately it's not available before iOS7.\n\t\t\t// See bug #7923 comment #21+.\n\n\t\t\tusing (var data = new GetProxyData ()) {\n\t\t\t\tdata.script = proxyAutoConfigurationScript;\n\t\t\t\tdata.targetUri = targetURL;\n\n\t\t\t\tlock (lock_obj) {\n\t\t\t\t\tif (get_proxy_queue == null) {\n\t\t\t\t\t\tget_proxy_queue = new Queue<GetProxyData> ();\n\t\t\t\t\t\tproxy_event = new AutoResetEvent (false);\n\t\t\t\t\t\tnew Thread (CFNetworkCopyProxiesForAutoConfigurationScriptThread) {\n\t\t\t\t\t\t\tIsBackground = true,\n\t\t\t\t\t\t}.Start ();\n\t\t\t\t\t}\n\t\t\t\t\tget_proxy_queue.Enqueue (data);\n\t\t\t\t\tproxy_event.Set ();\n\t\t\t\t}\n\n\t\t\t\tdata.evt.WaitOne ();\n\n\t\t\t\terror = data.error;\n\n\t\t\t\treturn data.result;\n\t\t\t}\n\t\t}\n\n\t\tstatic CFArray CopyProxiesForAutoConfigurationScript (IntPtr proxyAutoConfigurationScript, CFUrl targetURL)\n\t\t{\n\t\t\tIntPtr err = IntPtr.Zero;\n\t\t\tIntPtr native = CFNetworkCopyProxiesForAutoConfigurationScript (proxyAutoConfigurationScript, targetURL.Handle, out err);\n\t\t\t\n\t\t\tif (native == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn new CFArray (native, true);\n\t\t}\n\t\t\n\t\tpublic static CFProxy[] GetProxiesForAutoConfigurationScript (IntPtr proxyAutoConfigurationScript, CFUrl targetURL)\n\t\t{\n\t\t\tif (proxyAutoConfigurationScript == IntPtr.Zero)\n\t\t\t\tthrow new ArgumentNullException (\"proxyAutoConfigurationScript\");\n\t\t\t\n\t\t\tif (targetURL == null)\n\t\t\t\tthrow new ArgumentNullException (\"targetURL\");\n\t\t\t\n\t\t\tCFArray array = CopyProxiesForAutoConfigurationScript (proxyAutoConfigurationScript, targetURL);\n\t\t\t\n\t\t\tif (array == null)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tCFProxy[] proxies = new CFProxy [array.Count];\n\t\t\tfor (int i = 0; i < proxies.Length; i++) {\n\t\t\t\tCFDictionary dict = new CFDictionary (array[i], false);\n\t\t\t\tproxies[i] = new CFProxy (dict);\n\t\t\t}\n\n\t\t\tarray.Dispose ();\n\t\t\t\n\t\t\treturn proxies;\n\t\t}\n\t\t\n\t\tpublic static CFProxy[] GetProxiesForAutoConfigurationScript (IntPtr proxyAutoConfigurationScript, Uri targetUri)\n\t\t{\n\t\t\tif (proxyAutoConfigurationScript == IntPtr.Zero)\n\t\t\t\tthrow new ArgumentNullException (\"proxyAutoConfigurationScript\");\n\t\t\t\n\t\t\tif (targetUri == null)\n\t\t\t\tthrow new ArgumentNullException (\"targetUri\");\n\t\t\t\n\t\t\tCFUrl targetURL = CFUrl.Create (targetUri.AbsoluteUri);\n\t\t\tCFProxy[] proxies = GetProxiesForAutoConfigurationScript (proxyAutoConfigurationScript, targetURL);\n\t\t\ttargetURL.Dispose ();\n\t\t\t\n\t\t\treturn proxies;\n\t\t}\n\n\t\tdelegate void CFProxyAutoConfigurationResultCallback (IntPtr client, IntPtr proxyList, IntPtr error);\n\n\t\tpublic static CFProxy[] ExecuteProxyAutoConfigurationURL (IntPtr proxyAutoConfigURL, Uri targetURL)\n\t\t{\n\t\t\tCFUrl url = CFUrl.Create (targetURL.AbsoluteUri);\n\t\t\tif (url == null)\n\t\t\t\treturn null;\n\n\t\t\tCFProxy[] proxies = null;\n\n\t\t\tvar runLoop = CFRunLoop.CurrentRunLoop;\n\n\t\t\t// Callback that will be called after executing the configuration script\n\t\t\tCFProxyAutoConfigurationResultCallback cb = delegate (IntPtr client, IntPtr proxyList, IntPtr error) {\n\t\t\t\tif (proxyList != IntPtr.Zero) {\n\t\t\t\t\tvar array = new CFArray (proxyList, false);\n\t\t\t\t\tproxies = new CFProxy [array.Count];\n\t\t\t\t\tfor (int i = 0; i < proxies.Length; i++) {\n\t\t\t\t\t\tCFDictionary dict = new CFDictionary (array[i], false);\n\t\t\t\t\t\tproxies[i] = new CFProxy (dict);\n\t\t\t\t\t}\n\t\t\t\t\tarray.Dispose ();\n\t\t\t\t}\n\t\t\t\trunLoop.Stop ();\n\t\t\t};\n\n\t\t\tvar clientContext = new CFStreamClientContext ();\n\t\t\tvar loopSource = CFNetworkExecuteProxyAutoConfigurationURL (proxyAutoConfigURL, url.Handle, cb, ref clientContext);\n\n\t\t\t// Create a private mode\n\t\t\tvar mode = CFString.Create (\"Mono.MacProxy\");\n\n\t\t\trunLoop.AddSource (loopSource, mode);\n\t\t\trunLoop.RunInMode (mode, double.MaxValue, false);\n\t\t\trunLoop.RemoveSource (loopSource, mode);\n\n\t\t\treturn proxies;\n\t\t}\n\t\t\n\t\t[DllImport (CFNetworkLibrary)]\n\t\t// CFArrayRef CFNetworkCopyProxiesForURL (CFURLRef url, CFDictionaryRef proxySettings);\n\t\textern static IntPtr CFNetworkCopyProxiesForURL (IntPtr url, IntPtr proxySettings);\n\t\t\n\t\tstatic CFArray CopyProxiesForURL (CFUrl url, CFDictionary proxySettings)\n\t\t{\n\t\t\tIntPtr native = CFNetworkCopyProxiesForURL (url.Handle, proxySettings != null ? proxySettings.Handle : IntPtr.Zero);\n\t\t\t\n\t\t\tif (native == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn new CFArray (native, true);\n\t\t}\n\t\t\n\t\tpublic static CFProxy[] GetProxiesForURL (CFUrl url, CFProxySettings proxySettings)\n\t\t{\n\t\t\tif (url == null || url.Handle == IntPtr.Zero)\n\t\t\t\tthrow new ArgumentNullException (\"url\");\n\t\t\t\n\t\t\tif (proxySettings == null)\n\t\t\t\tproxySettings = GetSystemProxySettings ();\n\t\t\t\n\t\t\tCFArray array = CopyProxiesForURL (url, proxySettings.Dictionary);\n\t\t\t\n\t\t\tif (array == null)\n\t\t\t\treturn null;\n\n\t\t\tCFProxy[] proxies = new CFProxy [array.Count];\n\t\t\tfor (int i = 0; i < proxies.Length; i++) {\n\t\t\t\tCFDictionary dict = new CFDictionary (array[i], false);\n\t\t\t\tproxies[i] = new CFProxy (dict);\n\t\t\t}\n\n\t\t\tarray.Dispose ();\n\t\t\t\n\t\t\treturn proxies;\n\t\t}\n\t\t\n\t\tpublic static CFProxy[] GetProxiesForUri (Uri uri, CFProxySettings proxySettings)\n\t\t{\n\t\t\tif (uri == null)\n\t\t\t\tthrow new ArgumentNullException (\"uri\");\n\t\t\t\n\t\t\tCFUrl url = CFUrl.Create (uri.AbsoluteUri);\n\t\t\tif (url == null)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tCFProxy[] proxies = GetProxiesForURL (url, proxySettings);\n\t\t\turl.Dispose ();\n\t\t\t\n\t\t\treturn proxies;\n\t\t}\n\t\t\n\t\t[DllImport (CFNetworkLibrary)]\n\t\t// CFDictionaryRef CFNetworkCopySystemProxySettings (void);\n\t\textern static IntPtr CFNetworkCopySystemProxySettings ();\n\t\t\n\t\tpublic static CFProxySettings GetSystemProxySettings ()\n\t\t{\n\t\t\tIntPtr native = CFNetworkCopySystemProxySettings ();\n\t\t\t\n\t\t\tif (native == IntPtr.Zero)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tvar dict = new CFDictionary (native, true);\n\n\t\t\treturn new CFProxySettings (dict);\n\t\t}\n\t\t\n\t\tclass CFWebProxy : IWebProxy {\n\t\t\tICredentials credentials;\n\t\t\tbool userSpecified;\n\t\t\t\n\t\t\tpublic CFWebProxy ()\n\t\t\t{\n\t\t\t}\n\t\t\t\n\t\t\tpublic ICredentials Credentials {\n\t\t\t\tget { return credentials; }\n\t\t\t\tset {\n\t\t\t\t\tuserSpecified = true;\n\t\t\t\t\tcredentials = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstatic Uri GetProxyUri (CFProxy proxy, out NetworkCredential credentials)\n\t\t\t{\n\t\t\t\tstring protocol;\n\t\t\t\t\n\t\t\t\tswitch (proxy.ProxyType) {\n\t\t\t\tcase CFProxyType.FTP:\n\t\t\t\t\tprotocol = \"ftp://\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFProxyType.HTTP:\n\t\t\t\tcase CFProxyType.HTTPS:\n\t\t\t\t\tprotocol = \"http://\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcredentials = null;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstring username = proxy.Username;\n\t\t\t\tstring password = proxy.Password;\n\t\t\t\tstring hostname = proxy.HostName;\n\t\t\t\tint port = proxy.Port;\n\t\t\t\tstring uri;\n\t\t\t\t\n\t\t\t\tif (username != null)\n\t\t\t\t\tcredentials = new NetworkCredential (username, password);\n\t\t\t\telse\n\t\t\t\t\tcredentials = null;\n\t\t\t\t\n\t\t\t\turi = protocol + hostname + (port != 0 ? ':' + port.ToString () : string.Empty);\n\t\t\t\t\n\t\t\t\treturn new Uri (uri, UriKind.Absolute);\n\t\t\t}\n\t\t\t\n\t\t\tstatic Uri GetProxyUriFromScript (IntPtr script, Uri targetUri, out NetworkCredential credentials)\n\t\t\t{\n\t\t\t\tCFProxy[] proxies = CFNetwork.GetProxiesForAutoConfigurationScript (script, targetUri);\n\t\t\t\treturn SelectProxy (proxies, targetUri, out credentials);\n\t\t\t}\n\n\t\t\tstatic Uri ExecuteProxyAutoConfigurationURL (IntPtr proxyAutoConfigURL, Uri targetUri, out NetworkCredential credentials)\n\t\t\t{\n\t\t\t\tCFProxy[] proxies = CFNetwork.ExecuteProxyAutoConfigurationURL (proxyAutoConfigURL, targetUri);\n\t\t\t\treturn SelectProxy (proxies, targetUri, out credentials);\n\t\t\t}\n\n\n\t\t\tstatic Uri SelectProxy (CFProxy[] proxies, Uri targetUri, out NetworkCredential credentials)\n\t\t\t{\n\t\t\t\tif (proxies == null) {\n\t\t\t\t\tcredentials = null;\n\t\t\t\t\treturn targetUri;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < proxies.Length; i++) {\n\t\t\t\t\tswitch (proxies[i].ProxyType) {\n\t\t\t\t\tcase CFProxyType.HTTPS:\n\t\t\t\t\tcase CFProxyType.HTTP:\n\t\t\t\t\tcase CFProxyType.FTP:\n\t\t\t\t\t\t// create a Uri based on the hostname/port/etc info\n\t\t\t\t\t\treturn GetProxyUri (proxies[i], out credentials);\n\t\t\t\t\tcase CFProxyType.SOCKS:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// unsupported proxy type, try the next one\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CFProxyType.None:\n\t\t\t\t\t\t// no proxy should be used\n\t\t\t\t\t\tcredentials = null;\n\t\t\t\t\t\treturn targetUri;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcredentials = null;\n\t\t\t\t\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tpublic Uri GetProxy (Uri targetUri)\n\t\t\t{\n\t\t\t\tNetworkCredential credentials = null;\n\t\t\t\tUri proxy = null;\n\t\t\t\t\n\t\t\t\tif (targetUri == null)\n\t\t\t\t\tthrow new ArgumentNullException (\"targetUri\");\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tCFProxySettings settings = CFNetwork.GetSystemProxySettings ();\n\t\t\t\t\tCFProxy[] proxies = CFNetwork.GetProxiesForUri (targetUri, settings);\n\t\t\t\t\t\n\t\t\t\t\tif (proxies != null) {\n\t\t\t\t\t\tfor (int i = 0; i < proxies.Length && proxy == null; i++) {\n\t\t\t\t\t\t\tswitch (proxies[i].ProxyType) {\n\t\t\t\t\t\t\tcase CFProxyType.AutoConfigurationJavaScript:\n\t\t\t\t\t\t\t\tproxy = GetProxyUriFromScript (proxies[i].AutoConfigurationJavaScript, targetUri, out credentials);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CFProxyType.AutoConfigurationUrl:\n\t\t\t\t\t\t\t\tproxy = ExecuteProxyAutoConfigurationURL (proxies[i].AutoConfigurationUrl, targetUri, out credentials);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CFProxyType.HTTPS:\n\t\t\t\t\t\t\tcase CFProxyType.HTTP:\n\t\t\t\t\t\t\tcase CFProxyType.FTP:\n\t\t\t\t\t\t\t\t// create a Uri based on the hostname/port/etc info\n\t\t\t\t\t\t\t\tproxy = GetProxyUri (proxies[i], out credentials);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CFProxyType.SOCKS:\n\t\t\t\t\t\t\t\t// unsupported proxy type, try the next one\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CFProxyType.None:\n\t\t\t\t\t\t\t\t// no proxy should be used\n\t\t\t\t\t\t\t\tproxy = targetUri;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (proxy == null) {\n\t\t\t\t\t\t\t// no supported proxies for this Uri, fall back to trying to connect to targetUri directly\n\t\t\t\t\t\t\tproxy = targetUri;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tproxy = targetUri;\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// ignore errors while retrieving proxy data\n\t\t\t\t\tproxy = targetUri;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!userSpecified)\n\t\t\t\t\tthis.credentials = credentials;\n\t\t\t\t\n\t\t\t\treturn proxy;\n\t\t\t}\n\t\t\t\n\t\t\tpublic bool IsBypassed (Uri targetUri)\n\t\t\t{\n\t\t\t\tif (targetUri == null)\n\t\t\t\t\tthrow new ArgumentNullException (\"targetUri\");\n\t\t\t\t\n\t\t\t\treturn GetProxy (targetUri) == targetUri;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static IWebProxy GetDefaultProxy ()\n\t\t{\n\t\t\treturn new CFWebProxy ();\n\t\t}\n\t}\n\n\tclass CFBoolean : INativeObject, IDisposable {\n\t\tIntPtr handle;\n\n\t\tpublic static readonly CFBoolean True;\n\t\tpublic static readonly CFBoolean False;\n\n\t\tstatic CFBoolean ()\n\t\t{\n\t\t\tvar handle = CFObject.dlopen (CFObject.CoreFoundationLibrary, 0);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\treturn;\n\t\t\ttry {\n\t\t\t\tTrue  = new CFBoolean (CFObject.GetCFObjectHandle (handle, \"kCFBooleanTrue\"), false);\n\t\t\t\tFalse = new CFBoolean (CFObject.GetCFObjectHandle (handle, \"kCFBooleanFalse\"), false);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tCFObject.dlclose (handle);\n\t\t\t}\n\t\t}\n\n\t\tinternal CFBoolean (IntPtr handle, bool owns)\n\t\t{\n\t\t\tthis.handle = handle;\n\t\t\tif (!owns)\n\t\t\t\tCFObject.CFRetain (handle);\n\t\t}\n\n\t\t~CFBoolean ()\n\t\t{\n\t\t\tDispose (false);\n\t\t}\n\n\t\tpublic IntPtr Handle {\n\t\t\tget {\n\t\t\t\treturn handle;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Dispose ()\n\t\t{\n\t\t\tDispose (true);\n\t\t\tGC.SuppressFinalize (this);\n\t\t}\n\n\t\tprotected virtual void Dispose (bool disposing)\n\t\t{\n\t\t\tif (handle != IntPtr.Zero){\n\t\t\t\tCFObject.CFRelease (handle);\n\t\t\t\thandle = IntPtr.Zero;\n\t\t\t}\n\t\t}\n\n\t\tpublic static implicit operator bool (CFBoolean value)\n\t\t{\n\t\t\treturn value.Value;\n\t\t}\n\n\t\tpublic static explicit operator CFBoolean (bool value)\n\t\t{\n\t\t\treturn FromBoolean (value);\n\t\t}\n\n\t\tpublic static CFBoolean FromBoolean (bool value)\n\t\t{\n\t\t\treturn value ? True : False;\n\t\t}\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\t[return: MarshalAs (UnmanagedType.I1)]\n\t\textern static /* Boolean */ bool CFBooleanGetValue (/* CFBooleanRef */ IntPtr boolean);\n\n\t\tpublic bool Value {\n\t\t\tget {return CFBooleanGetValue (handle);}\n\t\t}\n\n\t\tpublic static bool GetValue (IntPtr boolean)\n\t\t{\n\t\t\treturn CFBooleanGetValue (boolean);\n\t\t}\n\t}\n\n\tinternal class CFDate : INativeObject, IDisposable {\n\t\tIntPtr handle;\n\n\t\tinternal CFDate (IntPtr handle, bool owns)\n\t\t{\n\t\t\tthis.handle = handle;\n\t\t\tif (!owns)\n\t\t\t\tCFObject.CFRetain (handle);\n\t\t}\n\n\t\t~CFDate ()\n\t\t{\n\t\t\tDispose (false);\n\t\t}\n\n\t\t[DllImport (CFObject.CoreFoundationLibrary)]\n\t\textern static IntPtr CFDateCreate (IntPtr allocator, /* CFAbsoluteTime */ double at);\n\n\t\tpublic static CFDate Create (DateTime date)\n\t\t{\n\t\t\tvar referenceTime = new DateTime (2001, 1, 1);\n\t\t\tvar difference = (date - referenceTime).TotalSeconds;\n\t\t\tvar handle = CFDateCreate (IntPtr.Zero, difference);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\tthrow new NotSupportedException ();\n\t\t\treturn new CFDate (handle, true);\n\t\t}\n\n\t\tpublic IntPtr Handle {\n\t\t\tget {\n\t\t\t\treturn handle;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Dispose ()\n\t\t{\n\t\t\tDispose (true);\n\t\t\tGC.SuppressFinalize (this);\n\t\t}\n\n\t\tprotected virtual void Dispose (bool disposing)\n\t\t{\n\t\t\tif (handle != IntPtr.Zero) {\n\t\t\t\tCFObject.CFRelease (handle);\n\t\t\t\thandle = IntPtr.Zero;\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System/System.Net.NetworkInformation/NetworkChange.cs": "//\n// System.Net.NetworkInformation.NetworkChange\n//\n// Authors:\n//   Gonzalo Paniagua Javier (LinuxNetworkChange) (gonzalo@novell.com)\n//   Aaron Bockover (MacNetworkChange) (abock@xamarin.com)\n//\n// Copyright (c) 2006,2011 Novell, Inc. (http://www.novell.com)\n// Copyright (c) 2013 Xamarin, Inc. (http://www.xamarin.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nusing System;\nusing System.Net.Sockets;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\n#if NETWORK_CHANGE_STANDALONE\nnamespace NetworkInformation {\n\n\tpublic class NetworkAvailabilityEventArgs : EventArgs\n\t{\n\t\tpublic bool IsAvailable { get; set; }\n\n\t\tpublic NetworkAvailabilityEventArgs (bool available)\n\t\t{\n\t\t\tIsAvailable = available;\n\t\t}\n\t}\n\n\tpublic delegate void NetworkAddressChangedEventHandler (object sender, EventArgs args);\n\tpublic delegate void NetworkAvailabilityChangedEventHandler (object sender, NetworkAvailabilityEventArgs args);\n#else\nnamespace System.Net.NetworkInformation {\n#endif\n\n\tinternal interface INetworkChange : IDisposable {\n\t\tevent NetworkAddressChangedEventHandler NetworkAddressChanged;\n\t\tevent NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged;\n\t\tbool HasRegisteredEvents { get; }\n\t}\n\n\tpublic sealed class NetworkChange {\n\t\tstatic INetworkChange networkChange;\n\n\t\tpublic static event NetworkAddressChangedEventHandler NetworkAddressChanged {\n\t\t\tadd {\n\t\t\t\tlock (typeof (INetworkChange)) {\n\t\t\t\t\tMaybeCreate ();\n\t\t\t\t\tif (networkChange != null)\n\t\t\t\t\t\tnetworkChange.NetworkAddressChanged += value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremove {\n\t\t\t\tlock (typeof (INetworkChange)) {\n\t\t\t\t\tif (networkChange != null) {\n\t\t\t\t\t\tnetworkChange.NetworkAddressChanged -= value;\n\t\t\t\t\t\tMaybeDispose ();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static event NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged {\n\t\t\tadd {\n\t\t\t\tlock (typeof (INetworkChange)) {\n\t\t\t\t\tMaybeCreate ();\n\t\t\t\t\tif (networkChange != null)\n\t\t\t\t\t\tnetworkChange.NetworkAvailabilityChanged += value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremove {\n\t\t\t\tlock (typeof (INetworkChange)) {\n\t\t\t\t\tif (networkChange != null) {\n\t\t\t\t\t\tnetworkChange.NetworkAvailabilityChanged -= value;\n\t\t\t\t\t\tMaybeDispose ();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic void MaybeCreate ()\n\t\t{\n#if MONOTOUCH_WATCH || ORBIS\n\t\t\tthrow new PlatformNotSupportedException (\"NetworkInformation.NetworkChange is not supported on the current platform.\");\n#else\n\t\t\tif (networkChange != null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tnetworkChange = new MacNetworkChange ();\n\t\t\t} catch {\n#if !NETWORK_CHANGE_STANDALONE && !MONOTOUCH\n\t\t\t\tnetworkChange = new LinuxNetworkChange ();\n#endif\n\t\t\t}\n#endif // MONOTOUCH_WATCH\n\t\t}\n\n\t\tstatic void MaybeDispose ()\n\t\t{\n\t\t\tif (networkChange != null && networkChange.HasRegisteredEvents) {\n\t\t\t\tnetworkChange.Dispose ();\n\t\t\t\tnetworkChange = null;\n\t\t\t}\n\t\t}\n\t}\n\n#if !MONOTOUCH_WATCH && !ORBIS\n\tinternal sealed class MacNetworkChange : INetworkChange\n\t{\n\t\tconst string DL_LIB = \"/usr/lib/libSystem.dylib\";\n\t\tconst string CORE_SERVICES_LIB = \"/System/Library/Frameworks/SystemConfiguration.framework/SystemConfiguration\";\n\t\tconst string CORE_FOUNDATION_LIB = \"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\";\n\n\t\t[UnmanagedFunctionPointerAttribute (CallingConvention.Cdecl)]\n\t\tdelegate void SCNetworkReachabilityCallback (IntPtr target, NetworkReachabilityFlags flags, IntPtr info);\n\n\t\t[DllImport (DL_LIB)]\n\t\tstatic extern IntPtr dlopen (string path, int mode);\n\n\t\t[DllImport (DL_LIB)]\n\t\tstatic extern IntPtr dlsym (IntPtr handle, string symbol);\n\n\t\t[DllImport (DL_LIB)]\n\t\tstatic extern int dlclose (IntPtr handle);\n\n\t\t[DllImport (CORE_FOUNDATION_LIB)]\n\t\tstatic extern void CFRelease (IntPtr handle);\n\n\t\t[DllImport (CORE_FOUNDATION_LIB)]\n\t\tstatic extern IntPtr CFRunLoopGetMain ();\n\n\t\t[DllImport (CORE_SERVICES_LIB)]\n\t\tstatic extern IntPtr SCNetworkReachabilityCreateWithAddress (IntPtr allocator, ref sockaddr_in sockaddr);\n\n\t\t[DllImport (CORE_SERVICES_LIB)]\n\t\tstatic extern bool SCNetworkReachabilityGetFlags (IntPtr reachability, out NetworkReachabilityFlags flags);\n\n\t\t[DllImport (CORE_SERVICES_LIB)]\n\t\tstatic extern bool SCNetworkReachabilitySetCallback (IntPtr reachability, SCNetworkReachabilityCallback callback, ref SCNetworkReachabilityContext context);\n\n\t\t[DllImport (CORE_SERVICES_LIB)]\n\t\tstatic extern bool SCNetworkReachabilityScheduleWithRunLoop (IntPtr reachability, IntPtr runLoop, IntPtr runLoopMode);\n\n\t\t[DllImport (CORE_SERVICES_LIB)]\n\t\tstatic extern bool SCNetworkReachabilityUnscheduleFromRunLoop (IntPtr reachability, IntPtr runLoop, IntPtr runLoopMode);\n\n\t\t[StructLayout (LayoutKind.Explicit, Size = 28)]\n\t\tstruct sockaddr_in {\n\t\t\t[FieldOffset (0)] public byte sin_len;\n\t\t\t[FieldOffset (1)] public byte sin_family;\n\n\t\t\tpublic static sockaddr_in Create ()\n\t\t\t{\n\t\t\t\treturn new sockaddr_in {\n\t\t\t\t\tsin_len = 28,\n\t\t\t\t\tsin_family = 2 // AF_INET\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t[StructLayout (LayoutKind.Sequential)]\n\t\tstruct SCNetworkReachabilityContext {\n\t\t\tpublic IntPtr version;\n\t\t\tpublic IntPtr info;\n\t\t\tpublic IntPtr retain;\n\t\t\tpublic IntPtr release;\n\t\t\tpublic IntPtr copyDescription;\n\t\t}\n\n\t\t[Flags]\n\t\tenum NetworkReachabilityFlags {\n\t\t\tNone = 0,\n\t\t\tTransientConnection = 1 << 0,\n\t\t\tReachable = 1 << 1,\n\t\t\tConnectionRequired = 1 << 2,\n\t\t\tConnectionOnTraffic = 1 << 3,\n\t\t\tInterventionRequired = 1 << 4,\n\t\t\tConnectionOnDemand = 1 << 5,\n\t\t\tIsLocalAddress = 1 << 16,\n\t\t\tIsDirect = 1 << 17,\n\t\t\tIsWWAN = 1 << 18,\n\t\t\tConnectionAutomatic = ConnectionOnTraffic\n\t\t}\n\n\t\tIntPtr handle;\n\t\tIntPtr runLoopMode;\n\t\tSCNetworkReachabilityCallback callback;\n\t\tbool scheduledWithRunLoop;\n\t\tNetworkReachabilityFlags flags;\n\n\t\tevent NetworkAddressChangedEventHandler networkAddressChanged;\n\t\tevent NetworkAvailabilityChangedEventHandler networkAvailabilityChanged;\n\n\t\tpublic event NetworkAddressChangedEventHandler NetworkAddressChanged {\n\t\t\tadd {\n\t\t\t\tvalue (null, EventArgs.Empty);\n\t\t\t\tnetworkAddressChanged += value;\n\t\t\t}\n\n\t\t\tremove { networkAddressChanged -= value; }\n\t\t}\n\n\t\tpublic event NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged {\n\t\t\tadd {\n\t\t\t\tvalue (null, new NetworkAvailabilityEventArgs (IsAvailable));\n\t\t\t\tnetworkAvailabilityChanged += value;\n\t\t\t}\n\n\t\t\tremove { networkAvailabilityChanged -= value; }\n\t\t}\n\n\t\tbool IsAvailable {\n\t\t\tget {\n\t\t\t\treturn (flags & NetworkReachabilityFlags.Reachable) != 0 &&\n\t\t\t\t\t(flags & NetworkReachabilityFlags.ConnectionRequired) == 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic bool HasRegisteredEvents {\n\t\t\tget { return networkAddressChanged != null || networkAvailabilityChanged != null; }\n\t\t}\n\n\t\tpublic MacNetworkChange ()\n\t\t{\n\t\t\tvar sockaddr = sockaddr_in.Create ();\n\t\t\thandle = SCNetworkReachabilityCreateWithAddress (IntPtr.Zero, ref sockaddr);\n\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\tthrow new Exception (\"SCNetworkReachabilityCreateWithAddress returned NULL\");\n\n\t\t\tcallback = new SCNetworkReachabilityCallback (HandleCallback);\n\t\t\tvar info = new SCNetworkReachabilityContext {\n\t\t\t\tinfo = GCHandle.ToIntPtr (GCHandle.Alloc (this))\n\t\t\t};\n\n\t\t\tSCNetworkReachabilitySetCallback (handle, callback, ref info);\n\n\t\t\tscheduledWithRunLoop =\n\t\t\tLoadRunLoopMode () &&\n\t\t\t\tSCNetworkReachabilityScheduleWithRunLoop (handle, CFRunLoopGetMain (), runLoopMode);\n\n\t\t\tSCNetworkReachabilityGetFlags (handle, out flags);\n\t\t}\n\n\t\tbool LoadRunLoopMode ()\n\t\t{\n\t\t\tvar cfLibHandle = dlopen (CORE_FOUNDATION_LIB, 0);\n\t\t\tif (cfLibHandle == IntPtr.Zero)\n\t\t\t\treturn false;\n\n\t\t\ttry {\n\t\t\t\trunLoopMode = dlsym (cfLibHandle, \"kCFRunLoopDefaultMode\");\n\t\t\t\tif (runLoopMode != IntPtr.Zero) {\n\t\t\t\t\trunLoopMode = Marshal.ReadIntPtr (runLoopMode);\n\t\t\t\t\treturn runLoopMode != IntPtr.Zero;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tdlclose (cfLibHandle);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic void Dispose ()\n\t\t{\n\t\t\tlock (this) {\n\t\t\t\tif (handle == IntPtr.Zero)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (scheduledWithRunLoop)\n\t\t\t\t\tSCNetworkReachabilityUnscheduleFromRunLoop (handle, CFRunLoopGetMain (), runLoopMode);\n\n\t\t\t\tCFRelease (handle);\n\t\t\t\thandle = IntPtr.Zero;\n\t\t\t\tcallback = null;\n\t\t\t\tflags = NetworkReachabilityFlags.None;\n\t\t\t\tscheduledWithRunLoop = false;\n\t\t\t}\n\t\t}\n\n\t\t[Mono.Util.MonoPInvokeCallback (typeof (SCNetworkReachabilityCallback))]\n\t\tstatic void HandleCallback (IntPtr reachability, NetworkReachabilityFlags flags, IntPtr info)\n\t\t{\n\t\t\tif (info == IntPtr.Zero)\n\t\t\t\treturn;\n\n\t\t\tvar instance = GCHandle.FromIntPtr (info).Target as MacNetworkChange;\n\t\t\tif (instance == null || instance.flags == flags)\n\t\t\t\treturn;\n\n\t\t\tinstance.flags = flags;\n\n\t\t\tvar addressChanged = instance.networkAddressChanged;\n\t\t\tif (addressChanged != null)\n\t\t\t\taddressChanged (null, EventArgs.Empty);\n\n\t\t\tvar availabilityChanged = instance.networkAvailabilityChanged;\n\t\t\tif (availabilityChanged != null)\n\t\t\t\tavailabilityChanged (null, new NetworkAvailabilityEventArgs (instance.IsAvailable));\n\t\t}\n\t}\n#endif // !MONOTOUCH_WATCH\n\n#if !NETWORK_CHANGE_STANDALONE && !MONOTOUCH && !ORBIS\n\n\tinternal sealed class LinuxNetworkChange : INetworkChange {\n\t\t[Flags]\n\t\tenum EventType {\n\t\t\tAvailability = 1 << 0,\n\t\t\tAddress = 1 << 1,\n\t\t}\n\n\t\tobject _lock = new object ();\n\t\tSocket nl_sock;\n\t\tSocketAsyncEventArgs nl_args;\n\t\tEventType pending_events;\n\t\tTimer timer;\n\n\t\tNetworkAddressChangedEventHandler AddressChanged;\n\t\tNetworkAvailabilityChangedEventHandler AvailabilityChanged;\n\n\t\tpublic event NetworkAddressChangedEventHandler NetworkAddressChanged {\n\t\t\tadd { Register (value); }\n\t\t\tremove { Unregister (value); }\n\t\t}\n\n\t\tpublic event NetworkAvailabilityChangedEventHandler NetworkAvailabilityChanged {\n\t\t\tadd { Register (value); }\n\t\t\tremove { Unregister (value); }\n\t\t}\n\n\t\tpublic bool HasRegisteredEvents {\n\t\t\tget { return AddressChanged != null || AvailabilityChanged != null; }\n\t\t}\n\n\t\tpublic void Dispose ()\n\t\t{\n\t\t}\n\n\t\t//internal Socket (AddressFamily family, SocketType type, ProtocolType proto, IntPtr sock)\n\n\t\tbool EnsureSocket ()\n\t\t{\n\t\t\tlock (_lock) {\n\t\t\t\tif (nl_sock != null)\n\t\t\t\t\treturn true;\n\t\t\t\tIntPtr fd = CreateNLSocket ();\n\t\t\t\tif (fd.ToInt64 () == -1)\n\t\t\t\t\treturn false;\n\n\t\t\t\tvar safeHandle = new SafeSocketHandle (fd, true);\n\n\t\t\t\tnl_sock = new Socket (0, SocketType.Raw, ProtocolType.Udp, safeHandle);\n\t\t\t\tnl_args = new SocketAsyncEventArgs ();\n\t\t\t\tnl_args.SetBuffer (new byte [8192], 0, 8192);\n\t\t\t\tnl_args.Completed += OnDataAvailable;\n\t\t\t\tnl_sock.ReceiveAsync (nl_args);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t// _lock is held by the caller\n\t\tvoid MaybeCloseSocket ()\n\t\t{\n\t\t\tif (nl_sock == null || AvailabilityChanged != null || AddressChanged != null)\n\t\t\t\treturn;\n\n\t\t\tCloseNLSocket (nl_sock.Handle);\n\t\t\tGC.SuppressFinalize (nl_sock);\n\t\t\tnl_sock = null;\n\t\t\tnl_args = null;\n\t\t}\n\n\t\tbool GetAvailability ()\n\t\t{\n\t\t\tNetworkInterface [] adapters = NetworkInterface.GetAllNetworkInterfaces ();\n\t\t\tforeach (NetworkInterface n in adapters) {\n\t\t\t\t// TODO: also check for a default route present?\n\t\t\t\tif (n.NetworkInterfaceType == NetworkInterfaceType.Loopback)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (n.OperationalStatus == OperationalStatus.Up)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvoid OnAvailabilityChanged (object unused)\n\t\t{\n\t\t\tNetworkAvailabilityChangedEventHandler d = AvailabilityChanged;\n\t\t\tif (d != null)\n\t\t\t\td (null, new NetworkAvailabilityEventArgs (GetAvailability ()));\n\t\t}\n\n\t\tvoid OnAddressChanged (object unused)\n\t\t{\n\t\t\tNetworkAddressChangedEventHandler d = AddressChanged;\n\t\t\tif (d != null)\n\t\t\t\td (null, EventArgs.Empty);\n\t\t}\n\n\t\tvoid OnEventDue (object unused)\n\t\t{\n\t\t\tEventType evts;\n\t\t\tlock (_lock) {\n\t\t\t\tevts = pending_events;\n\t\t\t\tpending_events = 0;\n\t\t\t\ttimer.Change (-1, -1);\n\t\t\t}\n\t\t\tif ((evts & EventType.Availability) != 0)\n\t\t\t\tThreadPool.QueueUserWorkItem (OnAvailabilityChanged);\n\t\t\tif ((evts & EventType.Address) != 0)\n\t\t\t\tThreadPool.QueueUserWorkItem (OnAddressChanged);\n\t\t}\n\n\t\tvoid QueueEvent (EventType type)\n\t\t{\n\t\t\tlock (_lock) {\n\t\t\t\tif (timer == null)\n\t\t\t\t\ttimer = new Timer (OnEventDue);\n\t\t\t\tif (pending_events == 0)\n\t\t\t\t\ttimer.Change (150, -1);\n\t\t\t\tpending_events |= type;\n\t\t\t}\n\t\t}\n\n\t\tunsafe void OnDataAvailable (object sender, SocketAsyncEventArgs args)\n\t\t{\n\t\t\tif (nl_sock == null) // Recent changes in Mono cause MaybeCloseSocket to be called before OnDataAvailable\n\t\t\t\treturn;\n\t\t\tEventType type;\n\t\t\tfixed (byte *ptr = args.Buffer) {\n\t\t\t\ttype = ReadEvents (nl_sock.Handle, new IntPtr (ptr), args.BytesTransferred, 8192);\n\t\t\t}\n\t\t\tnl_sock.ReceiveAsync (nl_args);\n\t\t\tif (type != 0)\n\t\t\t\tQueueEvent (type);\n\t\t}\n\n\t\tvoid Register (NetworkAddressChangedEventHandler d)\n\t\t{\n\t\t\tEnsureSocket ();\n\t\t\tAddressChanged += d;\n\t\t}\n\n\t\tvoid Register (NetworkAvailabilityChangedEventHandler d)\n\t\t{\n\t\t\tEnsureSocket ();\n\t\t\tAvailabilityChanged += d;\n\t\t}\n\n\t\tvoid Unregister (NetworkAddressChangedEventHandler d)\n\t\t{\n\t\t\tlock (_lock) {\n\t\t\t\tAddressChanged -= d;\n\t\t\t\tMaybeCloseSocket ();\n\t\t\t}\n\t\t}\n\n\t\tvoid Unregister (NetworkAvailabilityChangedEventHandler d)\n\t\t{\n\t\t\tlock (_lock) {\n\t\t\t\tAvailabilityChanged -= d;\n\t\t\t\tMaybeCloseSocket ();\n\t\t\t}\n\t\t}\n\n#if MONOTOUCH || MONODROID\n\t\tconst string LIBNAME = \"__Internal\";\n#else\n\t\tconst string LIBNAME = \"MonoPosixHelper\";\n#endif\n\n\t\t[DllImport (LIBNAME, CallingConvention=CallingConvention.Cdecl)]\n\t\tstatic extern IntPtr CreateNLSocket ();\n\n\t\t[DllImport (LIBNAME, CallingConvention=CallingConvention.Cdecl)]\n\t\tstatic extern EventType ReadEvents (IntPtr sock, IntPtr buffer, int count, int size);\n\n\t\t[DllImport (LIBNAME, CallingConvention=CallingConvention.Cdecl)]\n\t\tstatic extern IntPtr CloseNLSocket (IntPtr sock);\n\t}\n\n#endif\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/Test/System.Reflection/MethodInfoTest.cs": "//\n// System.Reflection.MethodInfo Test Cases\n//\n// Authors:\n//  Zoltan Varga (vargaz@gmail.com)\n//  Aleksey Kliger (aleksey@xamarin.com)\n//\n// (c) 2003 Ximian, Inc. (http://www.ximian.com)\n// Copyright (C) 2004 Novell, Inc (http://www.novell.com)\n// Copyright (C) 2015 Xamarin, Inc. (http://www.xamarin.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// \n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\nusing NUnit.Framework;\nusing System;\nusing System.Threading;\nusing System.Reflection;\n#if !MONOTOUCH && !FULL_AOT_RUNTIME\nusing System.Reflection.Emit;\n#endif\nusing System.Runtime.InteropServices;\nusing System.Runtime.CompilerServices;\n\nusing System.Collections.Generic;\n\nnamespace A.B.C {\n\t// Disable expected warning\n#pragma warning disable 169\n\tpublic struct MethodInfoTestStruct {\n\t\tint p;\n\t}\n#pragma warning restore 169\n}\nnamespace MonoTests.System.Reflection\n{\n\t[TestFixture]\n\tpublic class MethodInfoTest\n\t{\n#if MONOTOUCH || FULL_AOT_RUNTIME\n\t\t// use an existing symbol - so we can build without dlsym. It does not matter that the signature does not match for the test\n\t\t[DllImport (\"libc\", EntryPoint=\"readlink\", CharSet=CharSet.Unicode, ExactSpelling=false, PreserveSig=true, SetLastError=true, BestFitMapping=true, ThrowOnUnmappableChar=true)]\n#else\n\t\t[DllImport (\"libfoo\", EntryPoint=\"foo\", CharSet=CharSet.Unicode, ExactSpelling=false, PreserveSig=true, SetLastError=true, BestFitMapping=true, ThrowOnUnmappableChar=true)]\n#endif\n\t\tpublic static extern void dllImportMethod ();\n\t\t[MethodImplAttribute(MethodImplOptions.PreserveSig)]\n\t\tpublic void preserveSigMethod ()\n\t\t{\n\t\t}\n\n\t\t[MethodImplAttribute(MethodImplOptions.Synchronized)]\n\t\tpublic void synchronizedMethod ()\n\t\t{\n\t\t}\n\n\t\tpublic interface InterfaceTest\n\t\t{\n\t\t\tvoid Clone ();\n\t\t}\n\n\t\t[Test]\n\t\tpublic void IsDefined_AttributeType_Null ()\n\t\t{\n\t\t\tMethodInfo mi = typeof (MethodInfoTest).GetMethod (\"foo\");\n\n\t\t\ttry {\n\t\t\t\tmi.IsDefined ((Type) null, false);\n\t\t\t\tAssert.Fail (\"#1\");\n\t\t\t} catch (ArgumentNullException ex) {\n\t\t\t\tAssert.AreEqual (typeof (ArgumentNullException), ex.GetType (), \"#2\");\n\t\t\t\tAssert.IsNull (ex.InnerException, \"#3\");\n\t\t\t\tAssert.IsNotNull (ex.Message, \"#4\");\n\t\t\t\tAssert.IsNotNull (ex.ParamName, \"#5\");\n\t\t\t\tAssert.AreEqual (\"attributeType\", ex.ParamName, \"#6\");\n\t\t\t}\n\t\t}\n\n\t\t[Test]\n\t\tpublic void TestInvokeByRefReturnMethod ()\n\t\t{\n\t\t\ttry {\n\t\t\t\tMethodInfo m = typeof (int[]).GetMethod (\"Address\");\n\t\t\t\tm.Invoke (new int[1], new object[] { 0 });\n\t\t\t\tAssert.Fail (\"#1\");\n\t\t\t} catch (NotSupportedException e) {\n\t\t\t\tAssert.AreEqual (typeof (NotSupportedException), e.GetType (), \"#2\");\n\t\t\t\tAssert.IsNull (e.InnerException, \"#3\");\n\t\t\t\tAssert.IsNotNull (e.Message, \"#4\");\n\t\t\t}\n\t\t}\n\n\t\t[Test]\n\t\tpublic void PseudoCustomAttributes ()\n\t\t{\n\t\t\tType t = typeof (MethodInfoTest);\n\n\t\t\tDllImportAttribute attr = (DllImportAttribute)((t.GetMethod (\"dllImportMethod\").GetCustomAttributes (typeof (DllImportAttribute), true)) [0]);\n\n\t\t\tAssert.AreEqual (CallingConvention.Winapi, attr.CallingConvention, \"#1\");\n#if MONOTOUCH || FULL_AOT_RUNTIME\n\t\t\tAssert.AreEqual (\"readlink\", attr.EntryPoint, \"#2\");\n\t\t\tAssert.AreEqual (\"libc\", attr.Value, \"#3\");\n#else\n\t\t\tAssert.AreEqual (\"foo\", attr.EntryPoint, \"#2\");\n\t\t\tAssert.AreEqual (\"libfoo\", attr.Value, \"#3\");\n#endif\n\t\t\tAssert.AreEqual (CharSet.Unicode, attr.CharSet, \"#4\");\n\t\t\tAssert.AreEqual (false, attr.ExactSpelling, \"#5\");\n\t\t\tAssert.AreEqual (true, attr.PreserveSig, \"#6\");\n\t\t\tAssert.AreEqual (true, attr.SetLastError, \"#7\");\n\t\t\tAssert.AreEqual (true, attr.BestFitMapping, \"#8\");\n\t\t\tAssert.AreEqual (true, attr.ThrowOnUnmappableChar, \"#9\");\n\n\t\t\tPreserveSigAttribute attr2 = (PreserveSigAttribute)((t.GetMethod (\"preserveSigMethod\").GetCustomAttributes (true)) [0]);\n\n\t\t\t// This doesn't work under MS.NET\n\t\t\t/*\n\t\t\t  MethodImplAttribute attr3 = (MethodImplAttribute)((t.GetMethod (\"synchronizedMethod\").GetCustomAttributes (true)) [0]);\n\t\t\t*/\n\t\t}\n\n\t\t[return: MarshalAs (UnmanagedType.Interface)]\n\t\tpublic void ReturnTypeMarshalAs ()\n\t\t{\n\t\t}\n\n\t\t[Test]\n\t\tpublic void ReturnTypePseudoCustomAttributes ()\n\t\t{\n\t\t\tMethodInfo mi = typeof (MethodInfoTest).GetMethod (\"ReturnTypeMarshalAs\");\n\n\t\t\tAssert.IsTrue (mi.ReturnTypeCustomAttributes.GetCustomAttributes (typeof (MarshalAsAttribute), true).Length == 1);\n\t\t}\n\n\t\tpublic static int foo (int i, int j)\n\t\t{\n\t\t\treturn i + j;\n\t\t}\n\n\t\t[Test]\n\t\tpublic void StaticInvokeWithObject ()\n\t\t{\n\t\t\tMethodInfo mi = typeof (MethodInfoTest).GetMethod (\"foo\");\n\t\t\t\n\t\t\tmi.Invoke (new Object (), new object [] { 1, 2 });\n\t\t}\n\n\t\t[Test]\n\t\tpublic void ByRefInvoke ()\n\t\t{\n\t\t\tMethodInfo met = typeof(MethodInfoTest).GetMethod (\"ByRefTest\");\n\t\t\tobject[] parms = new object[] {1};\n\t\t\tmet.Invoke (null, parms);\n\t\t\tAssert.AreEqual (2, parms[0]);\n\t\t}\n\n\t\tpublic static void ByRefTest (ref int a1)\n\t\t{\n\t\t\tif (a1 == 1)\n\t\t\t\ta1 = 2;\n\t\t}\n\n\t\tstatic int byref_arg;\n\n\t\tpublic static void ByrefVtype (ref int i) {\n\t\t\tbyref_arg = i;\n\t\t\ti = 5;\n\t\t}\n\n\t\t[Test]\n\t\tpublic void ByrefVtypeInvoke ()\n\t\t{\n\t\t\tMethodInfo mi = typeof (MethodInfoTest).GetMethod (\"ByrefVtype\");\n\n\t\t\tobject o = 1;\n\t\t\tobject[] args = new object [] { o };\n\t\t\tmi.Invoke (null, args);\n\t\t\tAssert.AreEqual (1, byref_arg, \"#A1\");\n\t\t\tAssert.AreEqual (1, o, \"#A2\");\n\t\t\tAssert.AreEqual (5, args[0], \"#A3\");\n\n\t\t\targs [0] = null;\n\t\t\tmi.Invoke (null, args);\n\t\t\tAssert.AreEqual (0, byref_arg, \"#B1\");\n\t\t\tAssert.AreEqual (5, args[0], \"#B2\");\n\t\t}\n\n\t\tpublic void HeyHey (out string out1, ref DateTime ref1)\n\t\t{\n\t\t\tout1 = null;\n\t\t}\n\n\t\tpublic void SignatureTest (__arglist)\n\t\t{\n\t\t}\n\t\t\n\t\tpublic static unsafe int* PtrFunc (int* a)\n\t\t{\n\t\t\treturn (int*) 0;\n\t\t}\n\n#if MONO_FEATURE_THREAD_ABORT\n\t\t[Test] // bug #81538\n\t\tpublic void InvokeThreadAbort ()\n\t\t{\n\t\t\tMethodInfo method = typeof (MethodInfoTest).GetMethod (\"AbortIt\");\n\t\t\ttry {\n\t\t\t\tmethod.Invoke (null, new object [0]);\n\t\t\t\tAssert.Fail (\"#1\");\n\t\t\t}\n\t\t\tcatch (ThreadAbortException ex) {\n\t\t\t\tThread.ResetAbort ();\n\t\t\t\tAssert.IsNull (ex.InnerException, \"#2\");\n\t\t\t}\n\t\t}\n\n\t\tpublic static void AbortIt ()\n\t\t{\n\t\t\tThread.CurrentThread.Abort ();\n\t\t}\n#endif\n\n\t\t[Test] // bug #76541\n\t\tpublic void ToStringByRef ()\n\t\t{\n\t\t\tAssert.AreEqual (\"Void HeyHey(System.String ByRef, System.DateTime ByRef)\",\n\t\t\t\tthis.GetType ().GetMethod (\"HeyHey\").ToString ());\n\t\t}\n\t\t\n\t\t[Test]\n\t\tpublic void ToStringArgList ()\n\t\t{\n\t\t\tAssert.AreEqual (\"Void SignatureTest(...)\",\n\t\t\t\tthis.GetType ().GetMethod (\"SignatureTest\").ToString ());\n\t\t}\n\n\t\t[Test]\n\t\tpublic void ToStringWithPointerSignatures () //bug #409583\n\t\t{\n\t\t\tAssert.AreEqual (\"Int32* PtrFunc(Int32*)\", this.GetType ().GetMethod (\"PtrFunc\").ToString ());\n\t\t}\n\n\t\tpublic struct SimpleStruct\n\t\t{\n\t\t\tpublic int a;\n\t\t}\n\n\t\tpublic static unsafe SimpleStruct* PtrFunc2 (SimpleStruct* a, A.B.C.MethodInfoTestStruct *b)\n\t\t{\n\t\t\treturn (SimpleStruct*) 0;\n\t\t}\n\n\t\t[Test]\n\t\tpublic void ToStringWithPointerSignaturesToNonPrimitiveType ()\n\t\t{\n\t\t\tAssert.AreEqual (\"SimpleStruct* PtrFunc2(SimpleStruct*, A.B.C.MethodInfoTestStruct*)\", \n\t\t\t\tthis.GetType ().GetMethod (\"PtrFunc2\").ToString ());\n\t\t}\t\n\t\t[Test]\n\t\tpublic void ToStringGenericMethod ()\n\t\t{\n\t\t\tAssert.AreEqual (\"System.Collections.ObjectModel.ReadOnlyCollection`1[T] AsReadOnly[T](T[])\",\n\t\t\t\ttypeof (Array).GetMethod (\"AsReadOnly\").ToString ());\n\t\t}\n\n\t\tclass GBD_A         { public virtual     void f () {} }\n\t\tclass GBD_B : GBD_A { public override    void f () {} }\n\t\tclass GBD_C : GBD_B { public override    void f () {} }\n\t\tclass GBD_D : GBD_C { public new virtual void f () {} }\n\t\tclass GBD_E : GBD_D { public override    void f () {} }\n\n\t\tclass GBD_E2 : GBD_D { }\n\t\tclass GBD_F : GBD_E { }\n\n\n\t\t[Test]\n\t\tpublic void GetBaseDefinition ()\n\t\t{\n\t\t\tAssert.AreEqual (typeof (GBD_A), typeof (GBD_C).GetMethod (\"f\").GetBaseDefinition ().DeclaringType);\n\t\t\tAssert.AreEqual (typeof (GBD_A), typeof (GBD_C).GetMethod (\"f\").GetBaseDefinition ().ReflectedType, \"#1r\");\n\n\t\t\tAssert.AreEqual (typeof (GBD_D), typeof (GBD_D).GetMethod (\"f\").GetBaseDefinition ().DeclaringType);\n\t\t\tAssert.AreEqual (typeof (GBD_D), typeof (GBD_D).GetMethod (\"f\").GetBaseDefinition ().ReflectedType, \"#2r\");\n\n\t\t\tAssert.AreEqual (typeof (GBD_D), typeof (GBD_E).GetMethod (\"f\").GetBaseDefinition ().DeclaringType);\n\t\t\tAssert.AreEqual (typeof (GBD_D), typeof (GBD_E).GetMethod (\"f\").GetBaseDefinition ().ReflectedType, \"#3r\");\n\n\t\t\tAssert.AreEqual (typeof (GBD_D), typeof (GBD_E2).GetMethod (\"f\").GetBaseDefinition ().DeclaringType, \"#4\");\n\t\t\tAssert.AreEqual (typeof (GBD_D), typeof (GBD_E2).GetMethod (\"f\").GetBaseDefinition ().ReflectedType, \"#4r\");\n\n\t\t\tAssert.AreEqual (typeof (GBD_D), typeof (GBD_F).GetMethod (\"f\").GetBaseDefinition ().DeclaringType, \"#5\");\n\t\t\tAssert.AreEqual (typeof (GBD_D), typeof (GBD_F).GetMethod (\"f\").GetBaseDefinition ().ReflectedType, \"#5r\");\n\n\t\t}\n\n\t\tclass GenericBase<T,H> {\n\t\t\tpublic virtual void f2 () { }\n\t\t}\n\n\t\tclass GenericMid<T, U> : GenericBase<T, Action<U>> {\n\t\t\tpublic virtual T f1 () { return default (T); }\n\t\t}\n\n\t\tclass GenericChild<T> : GenericMid<T, int> {\n\t\t\tpublic override T f1 () { return default (T); }\n\t\t\tpublic override void f2 () { }\n\t\t}\n\n\t\tclass DerivedFromGenericBase : GenericBase<int, int> {\n\t\t}\n\n\t\t[Test]\n\t\tpublic void GetBaseDefinition_OpenConstructedBaseType () // 36305\n\t\t{\n\t\t\tvar t = typeof (GenericChild<string>);\n\n\t\t\tvar mi1 = t.GetMethod (\"f1\");\n\t\t\tvar mi1_base = mi1.GetBaseDefinition ();\n\n\t\t\tAssert.AreEqual (typeof (GenericMid<string, int>), mi1_base.DeclaringType, \"#1\");\n\n\t\t\tvar mi2 = t.GetMethod (\"f2\");\n\t\t\tvar mi2_base = mi2.GetBaseDefinition ();\n\n\t\t\tAssert.AreEqual (typeof (GenericBase<string, Action<int>>), mi2_base.DeclaringType, \"#2\");\n\t\t}\n\n\t\tclass TestInheritedMethodA {\n\t\t\tprivate void TestMethod ()\n\t\t\t{\n\t\t\t}\n\n\t\t\tpublic void TestMethod2 ()\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\tclass TestInheritedMethodB : TestInheritedMethodA {\n\t\t}\n\n\t\t[Test]\n\t\tpublic void InheritanceTestGetMethodTest ()\n\t\t{\n\t\t\tMethodInfo inheritedMethod = typeof(TestInheritedMethodB).GetMethod(\"TestMethod\", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);\n\t\t\tMethodInfo baseMethod = typeof(TestInheritedMethodB).GetMethod(\"TestMethod\", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);\n\t\t\tAssert.AreSame (inheritedMethod, baseMethod);\n\n\t\t\tMethodInfo inheritedMethod2 = typeof(TestInheritedMethodB).GetMethod(\"TestMethod2\", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);\n\t\t\tMethodInfo baseMethod2 = typeof(TestInheritedMethodB).GetMethod(\"TestMethod2\", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);\n\t\t\tAssert.AreSame (inheritedMethod, baseMethod);\n\t\t}\n\n\t\t[Test]\n\t\tpublic void GetMethodBody_Abstract ()\n\t\t{\n\t\t\tMethodBody mb = typeof (InterfaceTest).GetMethod (\"Clone\").GetMethodBody ();\n\t\t\tAssert.IsNull (mb);\n\t\t}\n\n\t\t[Test]\n\t\tpublic void GetMethodBody_Runtime ()\n\t\t{\n\t\t\tMethodBody mb = typeof (AsyncCallback).GetMethod (\"Invoke\").GetMethodBody ();\n\t\t\tAssert.IsNull (mb);\n\t\t}\n\n\t\t[Test]\n\t\tpublic void GetMethodBody_Pinvoke ()\n\t\t{\n\t\t\tMethodBody mb = typeof (MethodInfoTest).GetMethod (\"dllImportMethod\").GetMethodBody ();\n\t\t\tAssert.IsNull (mb);\n\t\t}\n\n\t\t[Test]\n\t\tpublic void GetMethodBody_Icall ()\n\t\t{\n\t\t\tforeach (MethodInfo mi in typeof (object).GetMethods (BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Instance))\n\t\t\t\tif ((mi.GetMethodImplementationFlags () & MethodImplAttributes.InternalCall) != 0) {\n\t\t\t\t\tMethodBody mb = mi.GetMethodBody ();\n\t\t\t\t\tAssert.IsNull (mb);\n\t\t\t\t}\n\t\t}\n\n\t\tpublic static void locals_method ()\n\t\t{\n\t\t\tbyte[] b = new byte [10];\n\n\t\t\tunsafe {\n\t\t\t\t/* This generates a pinned local */\n\t\t\t\tfixed (byte *p = &b [0]) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Test]\n\t\tpublic void GetMethodBody ()\n\t\t{\n#if (MONOTOUCH || FULL_AOT_RUNTIME) && !DEBUG\n\t\t\tAssert.Ignore (\"Release app (on devices) are stripped of (managed) IL so this test would fail\");\n#endif\n\t\t\tMethodBody mb = typeof (MethodInfoTest).GetMethod (\"locals_method\").GetMethodBody ();\n\n\t\t\tAssert.IsTrue (mb.InitLocals, \"#1\");\n\t\t\tAssert.IsTrue (mb.LocalSignatureMetadataToken > 0, \"#2\");\n\n\t\t\tIList<LocalVariableInfo> locals = mb.LocalVariables;\n\n\t\t\tbool foundPinnedBytePointer = false;\n\t\t\tunsafe {\n\t\t\t\tforeach (LocalVariableInfo lvi in locals) {\n\t\t\t\t\tif (lvi.LocalType == typeof (byte[]))\n\t\t\t\t\t\t// This is optimized out by CSC in .NET 4.6\n\t\t\t\t\t\tAssert.IsFalse (lvi.IsPinned, \"#3-1\");\n\n\t\t\t\t\tif (/* mcs */ lvi.LocalType == typeof (byte*) || /* csc */ lvi.LocalType == typeof (byte).MakeByRefType ()) {\n\t\t\t\t\t\t// We have three locals. There's b the byte[], there's a byte* and there's a byte&.\n\t\t\t\t\t\t// mcs emits a byte* for the latter type.\n\t\t\t\t\t\t// We need to find one such pinned byte pointer. Therefore we're folding with logical or\n\t\t\t\t\t\tfoundPinnedBytePointer = foundPinnedBytePointer || lvi.IsPinned;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tAssert.IsTrue (foundPinnedBytePointer, \"#4\");\n\t\t}\n\n\t\tpublic int return_parameter_test ()\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\t[Test]\n\t\tpublic void GetMethodFromHandle_Generic ()\n\t\t{\n\t\t\tMethodHandleTest<int> test = new MethodHandleTest<int> ();\n\t\t\tRuntimeMethodHandle mh = test.GetType ().GetProperty (\"MyList\")\n\t\t\t\t.GetGetMethod ().MethodHandle;\n\t\t\tMethodBase mb = MethodInfo.GetMethodFromHandle (mh,\n\t\t\t\ttypeof (MethodHandleTest<int>).TypeHandle);\n\t\t\tAssert.IsNotNull (mb, \"#1\");\n\t\t\tList<int> list = (List<int>) mb.Invoke (test, null);\n\t\t\tAssert.IsNotNull (list, \"#2\");\n\t\t\tAssert.AreEqual (1, list.Count, \"#3\");\n\t\t}\n\n\t\t[Test]\n\t\tpublic void ReturnParameter ()\n\t\t{\n\t\t\tParameterInfo pi = typeof (MethodInfoTest).GetMethod (\"return_parameter_test\").ReturnParameter;\n\t\t\tAssert.AreEqual (typeof (int), pi.ParameterType, \"#1\");\n\t\t\tAssert.AreEqual (-1, pi.Position, \"#2\");\n\t\t\t// MS always return false here\n\t\t\t//Assert.IsTrue (pi.IsRetval, \"#3\");\n\t\t}\n\n\t\t[Test]\n\t\tpublic void MethodInfoModule ()\n\t\t{\n\t\t\tType type = typeof (MethodInfoTest);\n\t\t\tMethodInfo me = type.GetMethod (\"return_parameter_test\");\n\n\t\t\tAssert.AreEqual (type.Module, me.Module);\n\t\t}\n\n\t\t[Test]\n\t\t\tpublic void InvokeOnRefOnlyAssembly ()\n\t\t{\n\t\t\tAssembly a = Assembly.ReflectionOnlyLoad (typeof (MethodInfoTest).Assembly.FullName);\n\t\t\tType t = a.GetType (typeof (RefOnlyMethodClass).FullName);\n\t\t\tMethodInfo m = t.GetMethod (\"RefOnlyMethod\", BindingFlags.Static | BindingFlags.NonPublic);\n\t\t\ttry {\n\t\t\t\tm.Invoke (null, new object [0]);\n\t\t\t\tAssert.Fail (\"#1\");\n\t\t\t} catch (InvalidOperationException ex) {\n\t\t\t\t// The requested operation is invalid in the\n\t\t\t\t// ReflectionOnly context\n\t\t\t\tAssert.AreEqual (typeof (InvalidOperationException), ex.GetType (), \"#2\");\n\t\t\t\tAssert.IsNull (ex.InnerException, \"#3\");\n\t\t\t\tAssert.IsNotNull (ex.Message, \"#4\");\n\t\t\t}\n\t\t}\n\n\t\t[Test]\n\t\t[ExpectedException (typeof (TargetInvocationException))]\n\t\tpublic void InvokeInvalidOpExceptionThrow () {\n\t\t\tMethodInfo mi = typeof (MethodInfoTest).GetMethod (\"ThrowMethod\");\n\t\t\tmi.Invoke(null, null);\n\t\t}\n\n\t\tpublic static void ThrowMethod () {\n\t\t\tthrow new InvalidOperationException ();\n\t\t}\n\n\t\t[Test]\n\t\tpublic void InvokeGenericVtype ()\n\t\t{\n\t\t\tKeyValuePair<string, uint> kvp = new KeyValuePair<string, uint> (\"a\", 21);\n\t\t\tType type = kvp.GetType ();\n\t\t\tType [] arguments = type.GetGenericArguments ();\n\t\t\tMethodInfo method = typeof (MethodInfoTest).GetMethod (\"Go\");\n\t\t\tMethodInfo generic_method = method.MakeGenericMethod (arguments);\n\t\t\tkvp = (KeyValuePair<string, uint>)generic_method.Invoke (null, new object [] { kvp });\n\n\t\t\tAssert.AreEqual (\"a\", kvp.Key, \"#1\");\n\t\t\tAssert.AreEqual (21, kvp.Value, \"#2\");\n\t\t}\n\n\t\tpublic static KeyValuePair<T1, T2> Go <T1, T2> (KeyValuePair <T1, T2> kvp)\n\t\t{\n\t\t\treturn kvp;\n\t\t}\n\n\t\t[Test] // bug #81997\n\t\tpublic void InvokeGenericInst ()\n\t\t{\n\t\t\tList<string> str = null;\n\n\t\t\tobject [] methodArgs = new object [] { str };\n\t\t\tMethodInfo mi = typeof (MethodInfoTest).GetMethod (\"GenericRefMethod\");\n\t\t\tmi.Invoke (null, methodArgs);\n\t\t\tAssert.IsNotNull (methodArgs [0], \"#A1\");\n\t\t\tAssert.IsNull (str, \"#A2\");\n\t\t\tAssert.IsTrue (methodArgs [0] is List<string>, \"#A3\");\n\n\t\t\tList<string> refStr = methodArgs [0] as List<string>;\n\t\t\tAssert.IsNotNull (refStr, \"#B1\");\n\t\t\tAssert.AreEqual (1, refStr.Count, \"#B2\");\n\t\t\tAssert.AreEqual (\"test\", refStr [0], \"#B3\");\n\t\t}\n\n\t\tpublic static void GenericRefMethod (ref List<string> strArg)\n\t\t{\n\t\t\tstrArg = new List<string> ();\n\t\t\tstrArg.Add (\"test\");\n\t\t}\n\n\t\tpublic void MakeGenericMethodArgsMismatchFoo<T> ()\n\t\t{\n\t\t}\n\n\t\t[Test]\n\t\tpublic void MakeGenericMethodArgsMismatch ()\n\t\t{\n\t\t\tMethodInfo gmi = this.GetType ().GetMethod (\n\t\t\t\t\"MakeGenericMethodArgsMismatchFoo\");\n\t\t\ttry {\n\t\t\t\tgmi.MakeGenericMethod ();\n\t\t\t\tAssert.Fail (\"#1\");\n\t\t\t} catch (ArgumentException ex) {\n\t\t\t\t// The type or method has 1 generic parameter(s),\n\t\t\t\t// but 0 generic argument(s) were provided. A\n\t\t\t\t// generic argument must be provided for each\n\t\t\t\t// generic parameter\n\t\t\t\tAssert.AreEqual (typeof (ArgumentException), ex.GetType (), \"#2\");\n\t\t\t\tAssert.IsNull (ex.InnerException, \"#3\");\n\t\t\t\tAssert.IsNotNull (ex.Message, \"#4\");\n\t\t\t\tAssert.IsNull (ex.ParamName, \"#5\");\n\t\t\t}\n\t\t}\n\n\t\tpublic void SimpleGenericMethod<TFoo, TBar> () {}\n\n\t\t[Test]\n\t\tpublic void MakeGenericMethodWithNullArray ()\n\t\t{\n\t\t\tMethodInfo gmi = this.GetType ().GetMethod (\"SimpleGenericMethod\");\n\t\t\ttry {\n\t\t\t\tgmi.MakeGenericMethod ((Type []) null);\n\t\t\t\tAssert.Fail (\"#1\");\n\t\t\t} catch (ArgumentNullException ex) {\n\t\t\t\tAssert.AreEqual (typeof (ArgumentNullException), ex.GetType (), \"#2\");\n\t\t\t\tAssert.IsNull (ex.InnerException, \"#3\");\n\t\t\t\tAssert.IsNotNull (ex.Message, \"#4\");\n\t\t\t\tAssert.AreEqual (\"methodInstantiation\", ex.ParamName, \"#5\");\n\t\t\t}\n\t\t}\n\n\t\t[Test]\n\t\tpublic void MakeGenericMethodWithNullValueInTypesArray ()\n\t\t{\n\t\t\tMethodInfo gmi = this.GetType ().GetMethod (\"SimpleGenericMethod\");\n\t\t\ttry {\n\t\t\t\tgmi.MakeGenericMethod (new Type [] { typeof (int), null });\n\t\t\t\tAssert.Fail (\"#1\");\n\t\t\t} catch (ArgumentNullException ex) {\n\t\t\t\tAssert.AreEqual (typeof (ArgumentNullException), ex.GetType (), \"#2\");\n\t\t\t\tAssert.IsNull (ex.InnerException, \"#3\");\n\t\t\t\tAssert.IsNotNull (ex.Message, \"#4\");\n\t\t\t\tAssert.IsNull (ex.ParamName, \"#5\");\n\t\t\t}\n\t\t}\n\n\t\t[Test]\n\t\tpublic void MakeGenericMethodWithNonGenericMethodDefinitionMethod ()\n\t\t{\n\t\t\tMethodInfo gmi = this.GetType ().GetMethod (\"SimpleGenericMethod\");\n\t\t\tMethodInfo inst = gmi.MakeGenericMethod (typeof (int), typeof (double));\n\t\t\ttry {\n\t\t\t\tinst.MakeGenericMethod (typeof (int), typeof (double));\n\t\t\t\tAssert.Fail (\"#1\");\n\t\t\t} catch (InvalidOperationException ex) {\n\t\t\t}\n\t\t}\n#if !MONOTOUCH && !FULL_AOT_RUNTIME\n\t\tpublic TFoo SimpleGenericMethod2<TFoo, TBar> () { return default (TFoo); }\n\t\t/*Test for the uggly broken behavior of SRE.*/\n\t\t[Test]\n\t\tpublic void MakeGenericMethodWithSreTypeResultsInStupidMethodInfo ()\n\t\t{\n\t\t\tAssemblyName assemblyName = new AssemblyName ();\n\t\t\tassemblyName.Name = \"MonoTests.System.Reflection.Emit.MethodInfoTest\";\n\t\t\tAssemblyBuilder assembly = Thread.GetDomain ().DefineDynamicAssembly (assemblyName, AssemblyBuilderAccess.RunAndSave, \".\");\n\t\t\tModuleBuilder module = assembly.DefineDynamicModule (\"module1\", \"tst.dll\");\n\t\t\tTypeBuilder tb = module.DefineType (\"Test\", TypeAttributes.Public);\n\n\t\t\tMethodInfo gmi = this.GetType ().GetMethod (\"SimpleGenericMethod2\");\n\t\t\tMethodInfo ins = gmi.MakeGenericMethod (typeof (int), tb);\n\n\t\t\tAssert.AreSame (tb, ins.GetGenericArguments () [1], \"#1\");\n\t\t\t/*broken ReturnType*/\n\t\t\tAssert.AreSame (gmi.GetGenericArguments () [0], ins.ReturnType, \"#2\");\n\t\t}\n#endif\n\t\tpublic static int? pass_nullable (int? i)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\n\t\t[Test]\n\t\tpublic void NullableTests ()\n\t\t{\n\t\t\tMethodInfo mi = typeof (MethodInfoTest).GetMethod (\"pass_nullable\");\n\t\t\tAssert.AreEqual (102, mi.Invoke (null, new object [] { 102 }), \"#1\");\n\t\t\tAssert.AreEqual (null, mi.Invoke (null, new object [] { null }), \"#2\");\n\n\t\t\t// Test conversion of vtype to a nullable type for the this argument\n\t\t\tPropertyInfo pi = typeof (Nullable <int>).GetProperty (\"HasValue\");\n\t\t\tAssert.AreEqual (true, pi.GetGetMethod ().Invoke (10, null));\n\t\t\tPropertyInfo pi2 = typeof (Nullable <int>).GetProperty (\"Value\");\n\t\t\tAssert.AreEqual (10, pi2.GetGetMethod ().Invoke (10, null));\n\t\t}\n\n\t\tpublic static void foo_generic<T> ()\n\t\t{\n\t\t}\n\n\t\t[Test]\n\t\tpublic void IsGenericMethod ()\n\t\t{\n\t\t\tMethodInfo mi = typeof (MethodInfoTest).GetMethod (\"foo_generic\");\n\t\t\tAssert.AreEqual (true, mi.IsGenericMethod, \"#1\");\n\t\t\tMethodInfo mi2 = mi.MakeGenericMethod (new Type[] { typeof (int) });\n\t\t\tAssert.AreEqual (true, mi2.IsGenericMethod, \"#2\");\n\t\t\tMethodInfo mi3 = typeof (GenericHelper<int>).GetMethod (\"Test\");\n\t\t\tAssert.AreEqual (false, mi3.IsGenericMethod, \"#3\");\n\t\t}\n\n\t\tclass A<T>\n\t\t{\n\t\t\tpublic static void Foo<T2> (T2 i)\n\t\t\t{\n\t\t\t}\n\n\t\t\tpublic static void Bar ()\n\t\t\t{\n\t\t\t}\n\n\t\t\tpublic class B\n\t\t\t{\n\t\t\t\tpublic static void Baz ()\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Test]\n\t\tpublic void ContainsGenericParameters ()\n\t\t{\n\t\t\t// Non-generic method in open generic type\n\t\t\tAssert.IsTrue (typeof (A<int>).GetGenericTypeDefinition ().GetMethod (\"Bar\").ContainsGenericParameters);\n\t\t\t// open generic method in closed generic type\n\t\t\tAssert.IsTrue (typeof (A<int>).GetMethod (\"Foo\").ContainsGenericParameters);\n\t\t\t// non-generic method in closed generic type\n\t\t\tAssert.IsFalse (typeof (A<int>).GetMethod (\"Bar\").ContainsGenericParameters);\n\t\t\t// closed generic method in closed generic type\n\t\t\tAssert.IsFalse (typeof (A<int>).GetMethod (\"Foo\").MakeGenericMethod (new Type [] { typeof (int) }).ContainsGenericParameters);\n\t\t\t// non-generic method in non-generic nested type of closed generic type\n\t\t\tAssert.IsFalse (typeof (A<int>.B).GetMethod (\"Baz\").ContainsGenericParameters);\n\t\t\t// non-generic method in non-generic nested type of open generic type\n\t\t\tAssert.IsTrue (typeof (A<int>.B).GetGenericTypeDefinition ().GetMethod (\"Baz\").ContainsGenericParameters);\n\t\t}\n\n\t\t[Test]\n\t\tpublic void IsGenericMethodDefinition ()\n\t\t{\n\t\t\tMethodInfo m1 = typeof (A<>).GetMethod (\"Foo\");\n\t\t\tAssert.IsTrue (m1.IsGenericMethod, \"#A1\");\n\t\t\tAssert.IsTrue (m1.IsGenericMethodDefinition, \"#A2\");\n\n\t\t\tMethodInfo m2 = typeof (A<int>).GetMethod (\"Foo\");\n\t\t\tAssert.IsTrue (m2.IsGenericMethod, \"#B1\");\n\t\t\tAssert.IsTrue (m2.IsGenericMethodDefinition, \"#B2\");\n\n\t\t\tMethodInfo m3 = m2.MakeGenericMethod (typeof (int));\n\t\t\tAssert.IsTrue (m3.IsGenericMethod, \"#C1\");\n\t\t\tAssert.IsFalse (m3.IsGenericMethodDefinition, \"#C2\");\n\t\t}\n\n\t\t[Test]\n\t\tpublic void GetGenericMethodDefinition ()\n\t\t{\n\t\t\tMethodInfo mi1 = typeof (MyList<>).GetMethod (\"ConvertAll\");\n\t\t\tMethodInfo mi2 = typeof (MyList<int>).GetMethod (\"ConvertAll\");\n\n\t\t\tAssert.AreEqual (\"MonoTests.System.Reflection.MethodInfoTest+Foo`2[T,TOutput]\",\n\t\t\t\t\t mi1.GetParameters () [0].ParameterType.ToString (), \"#A1\");\n\t\t\tAssert.AreEqual (\"MonoTests.System.Reflection.MethodInfoTest+Foo`2[System.Int32,TOutput]\",\n\t\t\t\t\t mi2.GetParameters () [0].ParameterType.ToString (), \"#A2\");\n\t\t\tAssert.IsTrue (mi1.IsGenericMethod, \"#A3\");\n\t\t\tAssert.IsTrue (mi1.IsGenericMethodDefinition, \"#A4\");\n\t\t\tAssert.IsTrue (mi2.IsGenericMethod, \"#A5\");\n\t\t\tAssert.IsTrue (mi2.IsGenericMethodDefinition, \"#A6\");\n\n\t\t\tMethodInfo mi3 = mi2.GetGenericMethodDefinition ();\n\n\t\t\tAssert.IsTrue (mi3.IsGenericMethod, \"#B1\");\n\t\t\tAssert.IsTrue (mi3.IsGenericMethodDefinition, \"#B2\");\n\t\t\tAssert.AreSame (mi2, mi3, \"#B3\");\n\n\t\t\tMethodInfo mi4 = mi2.MakeGenericMethod (typeof (short));\n\t\t\tAssert.IsTrue (mi4.IsGenericMethod, \"#C1\");\n\t\t\tAssert.IsFalse (mi4.IsGenericMethodDefinition, \"#C2\");\n\t\t\tAssert.AreSame (mi2, mi4.GetGenericMethodDefinition (), \"#C3\");\n\t\t}\n\n\t\tpublic void TestMethod123(int a, int b) {}\n\n\t\t[Test]\n\t\tpublic void GetParametersDontReturnInternedArray ()\n\t\t{\n\t\t\tvar method = typeof (MethodInfoTest).GetMethod (\"TestMethod123\");\n\t\t\tvar parms = method.GetParameters ();\n\t\t\tAssert.AreNotSame (parms, method.GetParameters (), \"#1\");\n\n\t\t\tparms [0] = null;\n\t\t\tAssert.IsNotNull (method.GetParameters () [0], \"#2\");\n\t\t}\n\n\t\t[Test]\n\t\tpublic void Bug354757 ()\n\t\t{\n\t\t\tMethodInfo gmd = (typeof (MyList <int>)).GetMethod (\"ConvertAll\");\n\t\t\tMethodInfo oi = gmd.MakeGenericMethod (gmd.GetGenericArguments ());\n\t\t\tAssert.AreSame (gmd, oi);\n\t\t}\n\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n#if MOBILE\n\t\t[Category (\"NotWorking\")] // #10552\n#endif\n\t\tpublic void MakeGenericMethodRespectConstraints ()\n\t\t{\n\t\t\tvar m = typeof (MethodInfoTest).GetMethod (\"TestMethod\");\n\t\t\tm.MakeGenericMethod (typeof (Type));\n\t\t}\n\n\t\tpublic void TestMethod <T> () where T : Exception\n\t\t{\n\t\t}\n\n\t\tpublic class MyList<T>\n\t\t{\n\t\t\tpublic TOutput ConvertAll<TOutput> (Foo<T,TOutput> arg)\n\t\t\t{\n\t\t\t\treturn default (TOutput);\n\t\t\t}\n\t\t\tpublic T ConvertAll2 (MyList<T> arg)\n\t\t\t{\n\t\t\t\treturn default (T);\n\t\t\t}\n\t\t}\n\n\t\tpublic class Foo<T,TOutput>\n\t\t{\n\t\t}\n\n\t\tclass GenericHelper<T>\n\t\t{\n\t\t\tpublic void Test (T t)\n\t\t\t{\n\t\t\t}\n\t\t}\n\t\tinterface IMethodInvoke<out T>\n\t\t{\n\t\t    T Test ();\n\t\t}\n\n\t\tclass MethodInvoke : IMethodInvoke<string>\n\t\t{\n\t\t    public string Test ()\n\t\t    {\n\t\t        return \"MethodInvoke\";\n\t\t    }\n\t\t}\n\n\t\t[Test]\n\t\tpublic void GetInterfaceMapWorksWithVariantIfaces ()\n\t\t{\n\t\t\tvar m0 = typeof (IMethodInvoke<object>).GetMethod (\"Test\");\n\t\t\tvar m1 = typeof (IMethodInvoke<string>).GetMethod (\"Test\");\n\t\t\tvar obj = new MethodInvoke ();\n\n\t\t\tAssert.AreEqual (\"MethodInvoke\", m0.Invoke (obj, new Object [0]));\n\t\t\tAssert.AreEqual (\"MethodInvoke\", m1.Invoke (obj, new Object [0]));\n\t\t}\n\n\n\t\tpublic int? Bug12856 ()\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\t[Test] //Bug #12856\n\t\tpublic void MethodToStringShouldPrintFullNameOfGenericStructs ()\n\t\t{\n\t\t\tvar m = GetType ().GetMethod (\"Bug12856\");\n\t\t\tAssert.AreEqual (\"System.Nullable`1[System.Int32] Bug12856()\", m.ToString (), \"#1\");\n\t\t}\n\n\t\t[Test]\n\t\tpublic void GetReflectedType () // #12205\n\t\t{\n\t\t\t// public method declared in base type, queried from a derived type\n\t\t\tMethodInfo mi = typeof (TestInheritedMethodB).GetMethod (\"TestMethod2\");\n\t\t\tAssert.AreEqual (mi.ReflectedType, typeof (TestInheritedMethodB), \"#1\");\n\n\t\t\t// public method declared in a generic class,\n\t\t\t// queried from a non-generic class derived\n\t\t\t// from an instantiation of the generic class.\n\t\t\tmi = typeof (DerivedFromGenericBase).GetMethod (\"f2\");\n\t\t\tAssert.AreEqual (mi.ReflectedType, typeof (DerivedFromGenericBase), \"#2\");\n\n\t\t\t// public method declared in a generic class,\n\t\t\t// queried from the generic type defintion of\n\t\t\t// a generic derived class.\n\t\t\tmi = typeof (GenericMid<,>).GetMethod (\"f2\");\n\t\t\tAssert.AreEqual (mi.ReflectedType, typeof (GenericMid<,>), \"#3\");\n\n\t\t\t// public method declared in a generic class,\n\t\t\t// queried from an instantiation of a generic\n\t\t\t// derived class.\n\t\t\tmi = typeof (GenericMid<int,int>).GetMethod (\"f2\");\n\t\t\tAssert.AreEqual (mi.ReflectedType, typeof (GenericMid<int,int>), \"#4\");\n\n\t\t}\n\n#if !MONOTOUCH && !FULL_AOT_RUNTIME\n\t\tclass GenericClass<T>\n\t\t{\n\t\t\tpublic void Method ()\n\t\t\t{\n\t\t\t\tT lv = default(T);\n\t\t\t\tConsole.WriteLine(lv);\n\t\t\t}\n\n\t\t\tpublic void Method2<K> (T a0, K a1)\n\t\t\t{\n\t\t\t\tT var0 = a0;\n\t\t\t\tK var1 = a1;\n\t\t\t\tConsole.WriteLine (var0);\n\t\t\t\tConsole.WriteLine (var1);\n\t\t\t}\n\t\t}\n\n\t\t[Test]\n\t\tpublic void TestLocalVariableTypes ()\n\t\t{\n\t\t\tvar typeofT = typeof (GenericClass<>).GetGenericArguments () [0];\n\t\t\tvar typeofK = typeof (GenericClass<>).GetMethod (\"Method2\").GetGenericArguments () [0];\n\n\t\t\tvar type = typeof (GenericClass<>).GetMethod(\"Method\").GetMethodBody().LocalVariables[0].LocalType;\n\t\t\tAssert.AreEqual (typeofT, type);\n\t\t\tAssert.AreEqual (typeof (GenericClass<>), type.DeclaringType);\n\t\t\n\t\t\tbool foundTypeOfK = false;\n\t\t\tbool foundExpectedType = false;\n\t    \n\t\t\tMethodBody mb = typeof (GenericClass<>).GetMethod(\"Method2\").GetMethodBody();\n\t\t\tforeach (LocalVariableInfo lvi in mb.LocalVariables) {\n\t\t\t\tif (lvi.LocalType == typeofK) {\n\t\t\t\t\tfoundTypeOfK = true;\n\t\t\t\t\tAssert.AreEqual (typeof (GenericClass<>), lvi.LocalType.DeclaringType, \"#1-1\");\n\t\t\t\t} else if (lvi.LocalType == typeofT) {\n\t\t\t\t\tfoundExpectedType = true;\n\t\t\t\t\tAssert.AreEqual (typeof (GenericClass<>), lvi.LocalType.DeclaringType, \"#1-2\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAssert.IsTrue (foundTypeOfK, \"#1-3\");\n\t\t\tif (mb.LocalVariables.Count < 2)\n\t\t\t\tAssert.Ignore (\"Code built in release mode - 'T var0' optmized out\");\n\t\t\telse\n\t\t\t\tAssert.IsTrue (foundExpectedType, \"#1-4\");\n\t    \n\t\t\tfoundTypeOfK = false;\n\t\t\tfoundExpectedType = false;\n\t\t\tmb = typeof (GenericClass<int>).GetMethod(\"Method2\").GetMethodBody();\n\t\t\tforeach (LocalVariableInfo lvi in mb.LocalVariables) {\n\t\t\t\tif (lvi.LocalType == typeofK) {\n\t\t\t\t\tfoundTypeOfK = true;\n\t\t\t\t\tAssert.AreEqual (typeof (GenericClass<>), lvi.LocalType.DeclaringType, \"#2-1\");\n\t\t\t\t} else if (lvi.LocalType == typeof (int)) {\n\t\t\t\t\tfoundExpectedType = true;\n\t\t\t\t}\n\t\t\t}\n\t    \n\t\t\tAssert.IsTrue (foundTypeOfK, \"#2-3\");\n\t\t\tif (mb.LocalVariables.Count < 2)\n\t\t\t\tAssert.Ignore (\"Code built in release mode - 'int var0' optmized out\");\n\t\t\telse\n\t\t\t\tAssert.IsTrue (foundExpectedType, \"#2-4\");\n\t\t}\n#endif\n\t}\n\t\n\t// Helper class\n\tclass RefOnlyMethodClass \n\t{\n\t\t// Helper static method\n\t\tstatic void RefOnlyMethod ()\n\t\t{\n\t\t}\n\t}\n\n\tpublic class MethodHandleTest<T>\n\t{\n\t\tprivate List<T> _myList = new List<T> ();\n\n\t\tpublic MethodHandleTest ()\n\t\t{\n\t\t\t_myList.Add (default (T));\n\t\t}\n\n\t\tpublic List<T> MyList {\n\t\t\tget { return _myList; }\n\t\t\tset { _myList = value; }\n\t\t}\n\t}\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mono/tests/testing_gac/testkey.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/libgc/cord/de_win.ICO",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/libgc/doc/README.Mac",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/data/browscap.ini",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/po/mcs/pt_BR.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/po/mcs/ja.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/po/mcs/de.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/po/mcs/es.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/ICSharpCode.SharpZipLib.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/SharpZipLib.mshc",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/SharpZipLib.chm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch80.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch20.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch60.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch0.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch30.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_sortactive_asc.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch70.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_collapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch90.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_sortactive_desc.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_pin_unpinned.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_pin_pinned.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_expanded.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch50.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch40.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch100.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_sortinactive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/opencover/pic_branch10.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/specification/bzip2-manual-1.0.5.html",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/Documentation/future/FILEFMTS.LST",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/ICSharpCode.SharpZipLib.Samples/vb/viewzipfile/MainForm.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/ICSharpCode.SharpZipLib.Samples/vb/minibzip2/MainForm.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/ICSharpCode.SharpZipLib.Samples/vb/CreateZipFile/CreateZipFile.MainForm.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/external/SharpZipLib/ICSharpCode.SharpZipLib.Samples/vb/CreateZipFile/MainForm.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Test/monodoc_test/trees/tree-from-3-0.tree",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Test/monodoc_test/trees/tree-from-3-0-old.tree",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Test/monodoc_test/sources/netdocs.zip",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Test/monodoc_test/sources/netdocs.tree",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/creativecommons.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/Lminus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/Lplus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/help.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/privevent.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/bc_separator.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/privdelegate.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/protmethod.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/error.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/protclass.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/house.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/namespace.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/privenumeration.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/headerbg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/members.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/protenumeration.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/pubenumeration.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/protinterface.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/pubmethod.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/privmethod.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/pubextension.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/protstructure.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/pubevent.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/pubproperty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/pubfield.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/protproperty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/pubclass.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/protfield.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/treebg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/protextension.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/pubinterface.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/bc_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/pubstructure.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/pubdelegate.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/privfield.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/privstructure.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/protdelegate.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/privinterface.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/protevent.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/privextension.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/hatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/privclass.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/privproperty.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-doc-tools/monodoc/Resources/images/reference.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/ikvm/ikvm-fork.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/src/System/Xml/XmlCharType.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/Xslt/TestFiles/TestData/xsltc/baseline/infft16---.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/Xslt/TestFiles/TestData/xsltc/baseline/infft2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/Xslt/TestFiles/TestData/xsltc/precompiled/Scripting28.xsl",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/bug382035a.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/bug382035a1.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v4-2.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v5-2.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v6-1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v6-1.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v6-2.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v5-2.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v5-1.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/b.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/a.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v5-1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v6-2.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Private.Xml/tests/XmlSchema/TestFiles/TestData/EnableUpaCheck/v4-1.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.DirectoryServices/src/Resources/System/DirectoryServices/DirectoryEntry.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.DirectoryServices/src/Resources/System/DirectoryServices/DirectorySearcher.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Text.Encodings.Web/src/Resources/unicode8definedcharacters.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Native/Windows/clrcompression/zlib/zlib.3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Native/AnyOS/brotli/common/dictionary.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Reflection/tests/Resources/EmbeddedImage.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/WinRT/Lib.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/PortablePdbs/Documents.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/Misc/KeyPair.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/Misc/CPPClassLibrary2.obj",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/NetModule/ModuleCS00.mod",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/NetModule/ModuleCS01.mod",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Reflection.Metadata/tests/Resources/NetModule/ModuleVB01.mod",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Runtime/tests/System/Reflection/EmbeddedImage.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/KOR_problem_chars_b.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/Thai_risky_chars.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/Surrogates_1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/Russian_problem_chars.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/JPN_problem_chars_2.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/JPN_problem_chars_1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/test63682.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/xql_orders-flat-200a.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/turkish.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/XQL_Orders_j3.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/Common/tests/System/Xml/XPath/TestData/XQL_Orders_j1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Runtime.Serialization.Xml/tests/Canonicalization/baselines/ReaderWriter_C14N_BaselineXML.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Runtime.Serialization.Xml/tests/Canonicalization/baselines/ReaderWriter_C14N_BaselineXML_NoCRLF.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Runtime.Serialization.Xml/tests/Canonicalization/baselines/ReaderWriter_C14N_BaselineXML_Binary.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Runtime.Serialization.Xml/tests/Canonicalization/baselines/ReaderWriter_C14N_BaselineXML_OnlyLF.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Data.SqlClient/tests/ManualTests/SQL/TransactionTest/TransactionTest.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Data.SqlClient/tests/Tools/TDS/TDS.Servers/TdsServerCertificate.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Text.Encoding.CodePages/src/Data/codepages.nlp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Diagnostics.Tracing/documentation/PerfViewCapture_Events.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Diagnostics.Tracing/documentation/PerfViewCapture_Counters.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Net.Sockets/tests/Scripts/SetReuseUnicastPort.ps1",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Net.Sockets/tests/Scripts/ClearReuseUnicastPort.ps1",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Drawing.Common/src/Resources/System/Drawing/ShieldIcon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Drawing.Common/src/Resources/System/Drawing/DefaultComponent.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Drawing.Common/src/Resources/System/Drawing/Error.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Drawing.Common/src/Resources/System/Drawing/Printing/PrintDocument.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/src/System.Drawing.Common/src/misc/GDI/WindowsGraphics.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/Documentation/images/portability_report.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/Documentation/images/portability_solution_explorer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/Documentation/images/api-review-process.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/Documentation/images/portability_screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/Documentation/project-docs/pcl-targets-dialog-net46-aspnetcore10.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corefx/Documentation/debugging/perfview_example.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.2/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.1/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.1.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.0.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/Microsoft.Net.Compilers.1.3.2.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.Diagnostics.StackTrace.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.AppContext.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.DiaSymReader.Native.x86.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.DiaSymReader.Native.amd64.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.1.3.2/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.3.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/ValueTuple/bin/Xamarin.Android/ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/ValueTuple/bin/Xamarin.iOS/ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/ValueTuple/bin/Net45/ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/roslyn-binaries/ValueTuple/bin/Xamarin.Mac/ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/mono.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/symbols/pdb/Test/Resources/assemblies/test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/symbols/pdb/Test/Resources/assemblies/VBConsApp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/symbols/pdb/Test/Resources/assemblies/fsapp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/symbols/pdb/Microsoft.Cci.Pdb/IntHashTable.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/symbols/pdb/Mono.Cecil.Pdb/AssemblyInfo.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/symbols/mdb/Test/Resources/assemblies/hello.exe.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/symbols/mdb/Mono.Cecil.Mdb/AssemblyInfo.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/Test/libs/nunit-2.6.2/license.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/Test/Resources/assemblies/moda.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil-legacy/Test/Resources/assemblies/modb.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-snapshot/profiles/msfinal.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/api-snapshot/profiles/silverlight.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/nuget-buildtasks/build/PublicKey.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/cecil.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/AVbTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/empty-iterator.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/EmptyRootNamespace.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/CecilTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/VBConsApp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/fsapp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/ComplexPdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/pdb/Test/Resources/assemblies/PdbTarget.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/pdb/Microsoft.Cci.Pdb/IntHashTable.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/mdb/Test/Resources/assemblies/hello.exe.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/mdb/Test/Resources/assemblies/mscorlib.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/symbols/mdb/Test/Resources/assemblies/BreakpointTest.Portable.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/libs/nunit-2.6.2/license.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/moda.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/ExternalPdbDeterministic.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/xattr.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/TargetLib.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/embedcs.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/SQLite-net.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/libmdb.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/ManagedWinmd.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/mylib.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/cecil.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/line.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/Mono.Android.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/winrtcomp.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/modb.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/EmptyPdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/PdbTarget.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/libpdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/cecil/Test/Resources/assemblies/NativeWinmd.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/nunit-lite/NUnitLite-1.0.0/.DS_Store",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/nunit-lite/NUnitLite-1.0.0/src/.DS_Store",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/nunit-lite/NUnitLite-1.0.0/src/framework/nunit.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/cecil.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/pdb/Test/Resources/assemblies/AVbTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/pdb/Test/Resources/assemblies/empty-iterator.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/pdb/Test/Resources/assemblies/EmptyRootNamespace.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/pdb/Test/Resources/assemblies/test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/pdb/Test/Resources/assemblies/CecilTest.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/pdb/Test/Resources/assemblies/VBConsApp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/pdb/Test/Resources/assemblies/fsapp.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/pdb/Test/Resources/assemblies/ComplexPdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/pdb/Test/Resources/assemblies/PdbTarget.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/pdb/Microsoft.Cci.Pdb/IntHashTable.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/mdb/Test/Resources/assemblies/hello.exe.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/mdb/Test/Resources/assemblies/mscorlib.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/symbols/mdb/Test/Resources/assemblies/BreakpointTest.Portable.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/libs/nunit-2.6.2/license.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/moda.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/ExternalPdbDeterministic.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/xattr.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/TargetLib.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/embedcs.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/SQLite-net.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/libmdb.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/ManagedWinmd.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/mylib.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/cecil.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/line.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/Mono.Android.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/winrtcomp.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/modb.netmodule",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/EmptyPdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/PdbTarget.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/libpdb.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/linker/cecil/Test/Resources/assemblies/NativeWinmd.winmd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.0/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monotouch/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monotouch/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monotouch/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monotouch/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monotouch/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monotouch/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monodroid/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monodroid/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monodroid/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monodroid/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monodroid/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/build/monodroid/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Drawing.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ComponentModel.TypeConverter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Globalization.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.UnmanagedMemoryStream.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Cryptography.X509Certificates.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Sockets.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.Compression.ZipFile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.TraceSource.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Console.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ComponentModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/Microsoft.Win32.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.XPath.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Resources.Reader.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.FileSystem.Watcher.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Collections.Specialized.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.Process.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.XmlDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.FileSystem.DriveInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Globalization.Calendars.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Claims.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Serialization.Formatters.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.TextWriterTraceListener.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.WebSockets.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.IsolatedStorage.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.MemoryMappedFiles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.Pipes.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.WebSockets.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.NameResolution.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Xml.XPath.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Diagnostics.StackTrace.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.ThreadPool.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.AppContext.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Cryptography.Csp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.Thread.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Threading.Overlapped.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Data.Common.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Ping.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/netstandard.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Cryptography.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Http.Rtc.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.CompilerServices.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Resources.Writer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Security.SecureString.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Collections.NonGeneric.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7.1/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/I18N.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/I18N.Other.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Experimental.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/cscompmgd.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/RabbitMQ.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Web.WebPages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Web.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Posix.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Commons.Xml.Relaxng.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/ICSharpCode.SharpZipLib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Numerics.Vectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Debugger.Soft.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Web.Http.SelfHost.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Web.Http.WebHost.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Messaging.RabbitMQ.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/IBM.Data.DB2.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Microsoft.Web.Infrastructure.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/SMDiagnostics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/I18N.West.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Threading.Tasks.Dataflow.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/PEAPI.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Simd.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Cairo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.CompilerServices.SymbolWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Security.Win32.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.WebBrowser.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/I18N.Rare.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Json.Microsoft.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Web.WebPages.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Windows.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Observable.Aliases.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/WebMatrix.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Debugger.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.C5.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/I18N.MidEast.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Net.Http.Formatting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.CodeContracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Web.WebPages.Razor.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Data.Sqlite.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Tasklets.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/I18N.CJK.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Web.Mvc.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Data.Tds.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Options.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Novell.Directory.Ldap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Web.Razor.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.PlatformServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/Mono.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Providers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/mono/System.Reactive.Interfaces.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.2/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.2/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5.1/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.5/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.7/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Workflow.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.Internals.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.Entity.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Workflow.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Net.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Reflection.Context.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.Build.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Xaml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.Build.Utilities.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Workflow.Activities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.Discovery.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.IO.Compression.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Net.Http.WebRequest.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.Caching.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.ComponentModel.Composition.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.ApplicationServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Windows.Forms.DataVisualization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.IO.Compression.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.DurableInstancing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceModel.Activation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Runtime.InteropServices.RuntimeInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Dynamic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Xml.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Deployment.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Web.Mobile.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Microsoft.Build.Tasks.v4.0.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/System.Windows.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Xml.XmlSerializer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Net.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ComponentModel.Annotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ServiceModel.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ServiceModel.Duplex.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ServiceModel.Http.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.Emit.Lightweight.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Threading.Timer.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Diagnostics.Contracts.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Linq.Queryable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Net.WebHeaderCollection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Linq.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.Emit.ILGeneration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ServiceModel.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ServiceModel.NetTcp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Serialization.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Handles.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Diagnostics.Tracing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Text.RegularExpressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ObjectModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Net.NetworkInformation.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.InteropServices.WindowsRuntime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Serialization.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Security.Principal.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ComponentModel.EventBasedAsync.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.Serialization.Json.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.ComponentModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Net.Requests.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Reflection.Emit.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v4.6.1/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v3.5/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v3.5/Microsoft.Build.Utilities.v3.5.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v3.5/Microsoft.Build.Tasks.v3.5.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v3.5/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Web.DynamicData.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Data.Services.Client.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.Build.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.IdentityModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Data.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/Accessibility.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.ComponentModel.DataAnnotations.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.DirectoryServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Data.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Data.OracleClient.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.EnterpriseServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Net.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.Build.Engine.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.ServiceModel.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Data.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.ServiceModel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.Build.Utilities.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Messaging.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Web.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Transactions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Runtime.Remoting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/WindowsBase.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Data.DataSetExtensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Web.Abstractions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Web.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Web.Services.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.VisualC.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.IdentityModel.Selectors.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/Microsoft.Build.Framework.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Web.Routing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.DirectoryServices.Protocols.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Runtime.Serialization.Formatters.Soap.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Management.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Web.Extensions.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Drawing.Design.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Runtime.Serialization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Windows.Forms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Drawing.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Configuration.Install.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.ServiceProcess.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/CustomMarshalers.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/binary-reference-assemblies/v2.0/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corert/src/System.Private.TypeLoader/src/Internal/Runtime/TypeLoader/ReferenceSource/callhelpers.h",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/corert/Documentation/images/typesystem-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Ix/NET/35MSSharedLib1024.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Test/Rx/WindowsStoreApp8_NuGet/WindowsStoreApp8_NuGet_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Test/Rx/WindowsStoreApp8_NuGet/Assets/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Test/Rx/WindowsStoreApp8_NuGet/Assets/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Test/Rx/WindowsStoreApp8_NuGet/Assets/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Test/Rx/WindowsStoreApp8_NuGet/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Test/Rx/WpfXbapApp45_NuGet/WpfXbapApp45_NuGet_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo_Color.design",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo_Color.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo_Color_300x300.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo_Color_2010x2000.psd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo_Zip.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Resources/Artwork/Logo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Samples/HOL/Rx HOL .NET C#.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Samples/HOL/Rx HOL .NET VB.docx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Samples/HOL/Rx HOL .NET C#.docx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Samples/HOL/Rx HOL JavaScript.docx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/35MSSharedLib1024.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/reactive.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/ReactiveTestApplication/Resources/drawable/Icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/GithubApiClientSample/Resources/drawable-ldpi/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/GithubApiClientSample/Resources/drawable-mdpi/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/GithubApiClientSample/Resources/drawable-hdpi/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/GithubApiClientSample/Resources/drawable-xhdpi/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/GithubApiClientSample/Resources/drawable-xxhdpi/icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/android/samples/ReactiveAndroidSample/ReactiveAndroidSample/Resources/drawable/Icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.Experimental.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.Linq.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.Core.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.Debugger.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.Interfaces.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/Rx_Xamarin/iOS/libs/System.Reactive.PlatformServices.dll.mdb",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/packages/Microsoft.Bcl.Build.1.0.4/Microsoft.Bcl.Build.1.0.4.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/packages/Microsoft.Bcl.Build.1.0.10/Microsoft.Bcl.Build.1.0.10.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/packages/Microsoft.Bcl.Async.1.0.16/Microsoft.Bcl.Async.1.0.16.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/Rx/NET/Source/packages/Microsoft.Bcl.1.0.19/Microsoft.Bcl.1.0.19.nupkg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/xpkg/RxForXamarin_128x128.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/xpkg/ProjectReferences.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/rx/component/rx_128x128.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/bunny_pancake.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Newtonsoft.Json.Tests.Metro_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/TestObjects/Store.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Properties/AssemblyInfo.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Images/UnitTestLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Images/UnitTestSmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Images/UnitTestSplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json.Tests/Images/UnitTestStoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json/Dynamic.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json/Properties/AssemblyInfo.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Src/Newtonsoft.Json/Utilities/CollectionUtils.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Tools/NUnit/lib/failure.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Tools/NUnit/lib/skipped.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Tools/NUnit/lib/inconclusive.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Tools/NUnit/lib/ignored.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Tools/NUnit/lib/success.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Tools/7-zip/7-zip.chm",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Doc/donate.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/Newtonsoft.Json/Doc/ReducingSerializedJSONSize.html",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/images/package.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/images/error.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/images/aspLogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/images/ok.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/images/tabon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/packages/images/package.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/src/System.Web.WebPages.Administration/packages/images/error.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/test/System.Web.Helpers.Test/TestFiles/logo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/test/System.Web.Helpers.Test/TestFiles/LambdaFinal.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/test/System.Web.Helpers.Test/TestFiles/NETLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/test/System.Web.Helpers.Test/TestFiles/HiRes.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/external/aspnetwebstack/tools/35MSSharedLib1024.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/MonoIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/nunit24/nunit.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/nunit24/ConsoleRunner/nunit-console-exe/App.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tests/InternalsVisibleTest2.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tests/test-715.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tests/key.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/errors/cs1577.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/errors/CS1616.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/errors/cs1548.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/errors/key.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/winfx.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/mono.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/mono.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/msfinal.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/reactive.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Open.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/winfx3.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/silverlight.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System/Test/System.Text.RegularExpressions/RegexMatchTests.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System/resources/Asterisk.wav",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System/resources/Beep.wav",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System/resources/Exclamation.wav",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System/resources/Hand.wav",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System/resources/Question.wav",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.Options/Documentation/en/examples/locale/es/LC_MESSAGES/localization.mo",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.Data.Sqlite/resources/SQLiteConnection.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.Data.Sqlite/resources/SQLiteCommand.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.Data.Sqlite/resources/SQLiteDataAdapter.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.Data.Sqlite/resources/SR.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.IdentityModel/Test/Resources/test.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.IdentityModel/Test/Resources/test_neg_serial.cer",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.IdentityModel/Test/Resources/test2.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.IdentityModel/Test/Resources/test.cer",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data.Services.Client/Client/System/Data/Services/Client/DataServiceContext.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/System.Web.Security/SqliteMembershipProvider.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/System.Web.Security/SqliteRoleProvider.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/System.Web.Util/SerializationHelper.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/NunitWebResources/Bluehills.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableHeaderCell_TableHeaderCell_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_UpdateText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_ctor_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_MaxLength.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Parent.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Item_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_ProcessShutdownReason_ProcessShutdownReason_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_CssClass.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_DataTextFormatString.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_IsReadOnly.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SelectedItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableItemStyle_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_GetKey_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_HeaderTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DropDownList_DropDownList_SelectedIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_DataTextField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_BeginEventHandler_BeginEventHandler_ctor_OI.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Enabled.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlControl_HtmlControl_TagName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ItemDataBound.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_Visible.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_FromString_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeatLayout_RepeatLayout_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Item_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DropDownList_DropDownList_BorderColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_FooterText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_Count.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_BackColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_SelectedIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SeparatorTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_AlternatingItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_InitializeCell_TIL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageHyperLink.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_Src.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_HeaderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_DataBind_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlGenericControl_HtmlGenericControl_TagName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_UnderLine.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_FooterStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_Items.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_RemoveAll_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_AccessKey.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Item_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_RemoveAll_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_UpdateCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_ButtonType.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Count.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableStyle_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Page.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_AllowSorting.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_Cols.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_PageCount.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SelectedItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_Items.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_RemoveAt_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DayNameFormat_DayNameFormat_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWControl2.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_PagerStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BoundColumn_BoundColumn_InitializeCell_TIL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_BeginEventHandler_BeginEventHandler_BeginInvoke_OEAOAO.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_SortExpression.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_TextAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Image_Image_AlternateText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_CancelCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_PageButtonCount.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_MergeStyle_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_IsReadOnly.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_EditItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_RemoveAt_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_Value.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableItemStyle_VerticalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlAnchor_HtmlAnchor_Target.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Label_Label_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_Target.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_AutoPostBack.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Clear_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_IsSynchronized.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_VerticalAlign_VerticalAlign_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Panel_Panel_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_InitializeCell_TIL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Init.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlAnchor_HtmlAnchor_Title.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_CopyTo_AI.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_Add_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_GetEnumerator_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_DataKeyField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Keys.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_EditItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_ColumnSpan.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_IsReadOnly2.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlControl_HtmlControl_Disabled.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_SelectCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_IsSynchronized.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_NextPageText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_EditCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButton_RadioButton_GroupName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_HeaderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLink_HyperLink_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DropDownList_DropDownList_ToolTip.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_BeginEventHandler_BeginEventHandler_Invoke_OEAO.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_Wrap.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_ClearSelection_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ShowHeader.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Load_wo_CodeBehind.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_EditItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_Reset_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ImageAlign_ImageAlign_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBox_CheckBox_AutoPostBack.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_DataMember.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_DataTextField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataListItem_DataListItem_DataItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeaterItem_RepeaterItem_ItemType.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SeparatorStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_UniqueID.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_ctor_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ValidationCompareOperator_ValidationCompareOperator_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ApplyStyle_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_GridLines.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_Items.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_Rows.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWControl4.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_FontSize_FontSize_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BoundColumn_BoundColumn_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_AddAt_IT.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_ctor_2.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlGenericControl_HtmlGenericControl_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_ReadOnly.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Add_Nothing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_Bold.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlControl_HtmlControl_Attributes.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Attributes.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_GridLines.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_RenderEndTag_H.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ImageButton_ImageButton_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_CopyFrom_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_EditItemIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_CopyTo_AI.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBox_CheckBox_Enabled.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_CssClass.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_FooterStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlGenericControl_HtmlGenericControl_ctor_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Button_Button_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Contents.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_ButtonType.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_VerticalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_ToolTip.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Add_SO.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_Attributes.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_RepeatLayout.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_Clear_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_ToString_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_FooterTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Page_Page_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlContainerControl_HtmlContainerControl_InnerHtml.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_Item.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Visible.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_IsCookieless.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextAlign_TextAlign_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeatDirection_RepeatDirection_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BoundColumn_BoundColumn_ReadOnly.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_Columns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Timeout.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_BorderColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_BorderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_ForeColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_BackImageUrl.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Clear_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_IsBindableType_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_Rows.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_BorderWidth.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_UnitType_UnitType_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_Wrap.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ControlStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_Reset_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_Name.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_DataValueField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_Item.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_CopyTo_AI.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_SelectedItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableStyle_GridLines.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_GridLines_GridLines_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_HeaderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_MergeWith_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_Items.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_VerticalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_UpdateCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Image_Image_Enabled.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_GridLines.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_RepeatColumns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_MergeWith_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_DataSource.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputButton_HtmlInputButton_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_AddRange_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_CopyBaseAttributes_W.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_Rows.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_CancelText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListSelectionMode_ListSelectionMode_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Remove_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_DeleteCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlAnchor_HtmlAnchor_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridItem_DataGridItem_DataItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableStyle_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_MergeWith_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_EditCommandColumn_EditCommandColumn_EditText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlTextWriterAttribute_HtmlTextWriterAttribute_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpRequest_HttpRequest_ContentEncoding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ControlStyleCreated.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_AutoPostBack.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_ProcessStatus_ProcessStatus_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Remove_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_GetRowIndex_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_AddRange_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridItem_DataGridItem_ItemType.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_Cells.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItemType_ListItemType_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWMaster.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_Value.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableItemStyle_Wrap.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_AlternatingItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_Controls.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_DataKeys.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_Reset_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_TraceMode_TraceMode_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_CreateControlStyle_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_SeparatorTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TitleFormat_TitleFormat_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWOMaster.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CalendarSelectionMode_CalendarSelectionMode_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_Visible.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_Align.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_LinkButton_LinkButton_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeaterItem_RepeaterItem_ItemIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpRequest_HttpRequest_AcceptTypes.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_NextPageCommandArgument.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_ShowHeader.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_RepeatColumns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ToolTip.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataListItem_DataListItem_ItemIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataListItem_DataListItem_ctor_IL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Contents.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Button_Button_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SelectedIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_SelectionMode.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_RowSpan.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_VerticalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_InitializeCell_TIL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HorizontalAlign_HorizontalAlign_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_EditCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ctor_H.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Add_SO.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_RemoveAt_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataListItem_DataListItem_ItemType.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_HeaderText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DropDownList_DropDownList_BorderWidth.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_CurrentPageIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_BorderColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_ItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_FirstDayOfWeek_FirstDayOfWeek_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_ViewState.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_ItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_InitializeCell_TIL.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_DataMember.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_SelectedIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_FooterStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeaterItem_RepeaterItem_ItemType_Manual.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_DataTextFormatString.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Label_Label_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListBox_ListBox_BorderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_OverLine.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBox_CheckBox_Checked.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlTextWriterTag_HtmlTextWriterTag_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_NextPrevFormat_NextPrevFormat_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_Mode.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_LinkButton_LinkButton_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlButton_HtmlButton_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_DeleteCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TableStyle_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_PrevPageText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlTextWriterStyle_HtmlTextWriterStyle_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpCacheRevalidation_HttpCacheRevalidation_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_VirtualItemCount.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_SelectedValue.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BorderStyle_BorderStyle_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Image_Image_Font.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_Wrap.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_ItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_DataSource.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_ShowFooter.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Image_Image_ImageAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_Item.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlControl_HtmlControl_Style.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_ItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ValidationSummaryDisplayMode_ValidationSummaryDisplayMode_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_Clear_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputHidden_HtmlInputHidden_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_SyncRoot.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_Position.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_CellPadding.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridItem_DataGridItem_ItemIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Width.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_ExtractTemplateRows.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_SelectedItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_Alt.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWControl3.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_RemoveAt_I.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_TextAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_PrevPageCommandArgument.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_AlternatingItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridItem_DataGridItem_DataSetIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpRequest_HttpRequest_Browser.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_DataTextFormatString.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridPagerStyle_DataGridPagerStyle_CopyFrom_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_SortCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_RepeatDirection.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ItemCreated.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLink_HyperLink_Target.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SelectCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBox_TextBox_TextMode.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_DataTextField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_RepeatColumns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableItemStyle_TableItemStyle_CopyFrom_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_PageSize.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlButton_HtmlButton_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_ctor_3.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ValidationDataType_ValidationDataType_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ShowFooter.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlAnchor_HtmlAnchor_Name.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_ForeColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_ItemDataBound.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Font.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpValidationStatus_HttpValidationStatus_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_Name.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_PageCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_LCID.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_ClientID.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_AutoGenerateColumns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_BackColor.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_Italic.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_BorderWidth.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_Equals_O.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRow_TableRow_CreateControlCollection_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_Remove_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_CodePage.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BoundColumn_BoundColumn_DataFormatString.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_HeaderImageUrl.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Border.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_GridLines.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_PlaceHolder_PlaceHolder_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_UserPage.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCell_TableCell_HorizontalAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_Count.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBox_CheckBox_TextAlign.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_Columns.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_CommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RadioButtonList_RadioButtonList_RepeatDirection.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGridColumn_DataGridColumn_ToString_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_RenderBeginTag_H.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Count.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_CausesValidation.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_DataSource.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_HeaderTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_GetEnumerator_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TextBoxMode_TextBoxMode_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlContainerControl_HtmlContainerControl_InnerText.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_ItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_PageDirectories_Pages_PageWControl1.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BoundColumn_BoundColumn_DataField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_BaseDataList_BaseDataList_CellSpacing.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_Dispose_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_AllowCustomPaging.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlInputImage_HtmlInputImage_Border.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_RepeaterItem_RepeaterItem_DataItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_DataNavigateUrlField.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_SyncRoot.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBox_CheckBox_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_AllowPaging.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_CancelCommandName.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_ctor_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Height.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_ID.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_Size.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_GetEnumerator_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_SessionID.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpRequest_HttpRequest_ServerVariables.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_DataBind_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ButtonColumn_ButtonColumn_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_HyperLinkColumn_HyperLinkColumn_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListControl_ListControl_DataMember.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_Add_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_IsReadOnly.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Literal_Literal_Text.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_HtmlControls_HtmlTextArea_HtmlTextArea_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_ctor_.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TemplateColumn_TemplateColumn_FooterTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpRequest_HttpRequest_ClientCertificate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Panel_Panel_Wrap.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_SessionState_HttpSessionState_HttpSessionState_Item.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Table_Table_Rows.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_EditItemIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_HeaderTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpCacheability_HttpCacheability_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_ItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_CheckBoxList_CheckBoxList_RepeatLayout.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DropDownList_DropDownList_BorderStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_Selected.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_TabIndex.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ValidatorDisplay_ValidatorDisplay_Enum.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataGrid_DataGrid_SelectedItem.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableStyle_TableStyle_BackImageUrl.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_StrikeOut.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_SelectedItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_Repeater_Repeater_FooterTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableCellCollection_TableCellCollection_GetCellIndex_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_EditItemStyle.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_ValidationPropertyAttribute_ValidationPropertyAttribute_ctor_S.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_TableRowCollection_TableRowCollection_Remove_T.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_WebControl_WebControl_Style_Font_Names.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_Control_Control_NamingContainer.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_ListItem_ListItem_ctor_SS.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_AlternatingItemTemplate.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_HttpApplicationState_HttpApplicationState_AllKeys.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/mainsoft/MainsoftWebTest/reference20/_System_Web_UI_WebControls_DataList_DataList_RepeatDirection.aspx.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/standalone/theme/PageLinks/App_Themes/Black/Images/button-login.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/tools/CachePQTestGenerator/Sequences/cache_pq_sequence_2011-04-07_02-03-02_25377827.seq.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/Test/tools/CachePQTestGenerator/Sequences/cache_pq_sequence_2010-11-18_01-38-13.seq.gz",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/box_noexpand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/box_minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_lplus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/box_plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_rplus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_dash.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_t.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/box_empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/contact.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_dashplus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/folder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/star_full.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_i.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/transparent.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_lminus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/box_full.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/computer.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/file.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/dot_full.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_dashminus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/dots.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/arrow_down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/inbox.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/arrow_minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/warning.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/star_empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_tminus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_rminus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/arrow_up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/dot_empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/arrow_noexpand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/arrow_plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_tplus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/resources/TreeView_noexpand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web/System.Web.Profile/SqliteProfileProvider.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/mcs.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Mono.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-win32/1051000004/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/mcs.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Mono.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-darwin/1051000004/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/System.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/System.Xml.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/mcs.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Mono.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/mscorlib.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/System.Core.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/System.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/System.Xml.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/System.Configuration.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/System.Security.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Threading.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Threading.Tasks.Parallel.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Resources.ResourceManager.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Globalization.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.ValueTuple.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Xml.ReaderWriter.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Collections.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Reflection.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Text.Encoding.CodePages.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Diagnostics.Debug.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Runtime.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Runtime.Numerics.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Diagnostics.FileVersionInfo.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Linq.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Text.Encoding.Extensions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Reflection.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Collections.Concurrent.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Dynamic.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Text.Encoding.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Reflection.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Diagnostics.Tools.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Threading.Tasks.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Xml.XDocument.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Runtime.InteropServices.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Security.Cryptography.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.IO.FileSystem.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.IO.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.IO.FileSystem.Primitives.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Security.Cryptography.Algorithms.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Runtime.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/lib/monolite-linux/1051000004/Facades/System.Linq.Expressions.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Net.Http/Test/System.Net.Http/StringContentTest.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Commons.Xml.Relaxng/Test/XmlFiles/team.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System/compmod/system/componentmodel/CultureInfoConverter.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System/services/monitoring/system/diagnosticts/EventLogInternal.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System/InternalApis/NDP_FX/inc/ZLibNative.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System/net/System/Net/HttpListenerRequestUriBuilder.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System/net/System/Net/cookiecontainer.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System/net/System/Net/Configuration/DefaultProxySection.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web/HttpResponse.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.ServiceModel.Activation/System/ServiceModel/Activities/Activation/WorkflowServiceHostFactory.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.Services/System/Web/Services/Protocols/ServerProtocol.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/WebForm/ChartWebControl.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/WebForm/General/ChartHttpHandler.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/WebForm/Converters/MapAreaCoordinatesConverter.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/GroupAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/ArrowAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/RectangleAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/AnnotationBase.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/LineAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/TextAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/PolygonAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/ImageAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/AnnotationCollection.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Annotation/CalloutAnnotation.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Constants.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Label.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisScrollBar.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Matrix3D.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/DataManipulator.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/GdiGraphics.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisScale.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Statistics.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisScaleSegments.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/IChartRenderingEngine.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartArea.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartElement.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartAreaCollection.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Legend.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Chart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartAreaCircular.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartGraphics.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ImageMap.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/GridTickMarks.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/LegendColumns.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisScrollZoom.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/NamedImageCollection.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisLabels.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/CommonElements.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartAreaCursor.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Title.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartRenderingEngine.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/SubAxis.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartAreaAxes.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/StripLine.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Selection.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/Axis.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/FormulaData.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/AxisScaleBreaks.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartGraphics3D.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/SmartLabels.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/General/ChartSerializer.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/RenkoChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/DoughnutChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/PointChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/PieChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/ErrorBarChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/LineChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/BubbleChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/FastPointChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/RadarChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/BarChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/StepLineChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/StockChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/StackedAreaChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/PolarChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/ColumnChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/FastLineChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/ChartTypeRegistry.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/BoxPlotChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/AreaChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/StackedBarChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/StackedColumnChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/FunnelChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/PointAndFigureChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/ThreeLineBreakChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/KagiChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/ChartTypes/RangeChart.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/LegendConverters.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/AnnotationConverters.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/DataManagerConverters.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/ElementPositionConverter.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/AxisConverters.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/AxesArrayConverter.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Converters/CustomAttributesConverters.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/ElementPosition.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/KeywordsRegistry.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/ColorPalette.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/ValueConverter.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/CustomAttributesRegistry.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/ImageLoader.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Utilities/XmlSerializer.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/DataManager/DataPoint.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/DataManager/DataSeries.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/DataManager/DataManager.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/PriceIndicators.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/FormulaRegistry.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/VolumeIndicator.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/GeneralFormulas.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/StatisticalAnalysis.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/TechGeneralIndicators.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/TimeSeriesAndForecasting.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Formulas/Oscillator.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Borders3D/EmbossBorder.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Web.DataVisualization/Common/Borders3D/Borders3D.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.ServiceModel/System/ServiceModel/Dispatcher/SecurityValidationBehavior.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.ServiceModel/System/ServiceModel/Channels/TransportDefaults.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Core/System/IO/Pipes/PipeStream.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Core/System/Linq/Parallel/QueryOperators/Unary/TakeOrSkipQueryOperator.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/Common/CommandTrees/ExpressionBuilder/Spatial/SpatialEdmFunctions.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/Query/PlanCompiler/NestPullup.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/Query/PlanCompiler/JoinGraph.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/Query/PlanCompiler/TransformationRules.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/Query/PlanCompiler/KeyPullup.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Data.Entity/System/Data/EntityModel/SchemaObjectModel/EntityContainerRelationshipSetEnd.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Data.DataSetExtensions/System/Data/DataRowExtensions.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Xml/System.Xml.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Xml/System/Xml/XmlConvert.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Runtime.Serialization/System/Xml/XmlUTF8TextReader.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.ServiceModel.Activities/System/ServiceModel/Activities/InternalSendMessage.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.ServiceModel.Activities/System/ServiceModel/Activities/InternalReceiveMessage.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/System.Data/System/Data/SqlClient/TdsEnums.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/mscorlib/system/convert.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/mscorlib/system/timezoneinfo.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/mscorlib/system/version.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/mscorlib/system/io/streamreader.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/mscorlib/system/text/encoding.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/mscorlib/system/threading/SpinWait.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/mscorlib/system/threading/threadpool.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/mscorlib/system/resources/resourcefallbackmanager.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/mscorlib/system/collections/hashtable.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/referencesource/mscorlib/system/collections/generic/equalitycomparer.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Reactive.Windows.Threading/Strings_WindowsThreading.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.ServiceModel/Test/System.ServiceModel.Channels/binary-message.raw",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.ServiceModel/Test/Resources/test.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.ServiceModel/Test/Resources/test2.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.ServiceModel/Test/Resources/test.cer",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/nordic-865.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/icelandic-10079.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/italian-28593.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/latin-28605.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/polish-1250.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/portguese-860.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/greek-28597.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/hungarian-28592.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/french2-863.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/french-10000.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/latin-850.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/greek-1253.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/box-437.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/icelandic2-861.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/West/Test/texts/norwegian-1252.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/Common/ByteSafeEncoding.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/Common/MonoSafeEncoding.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/ks.table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/big5.table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/jis.table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/gb2312.table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/gb18030.table",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/Test/texts/japanese-51932.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/Test/texts/chinese4-950.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/Test/texts/japanese-932.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/Test/texts/korean-949.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/Test/texts/chinese3-936.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/Test/texts/chinese-936.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/Test/texts/chinese-54936.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/CJK/Test/texts/chinese2-950.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/MidEast/Test/texts/encoder-handlefallback-generic-utf8.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/I18N/MidEast/Test/texts/turkish-1254.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Reactive.Core/Strings_Core.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Reactive.Providers/Strings_Providers.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/PgLast.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/Back.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/PgPrev.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/PgNext.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/PgFirst.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Web.DynamicData/Test/WebPages/DynamicData/Content/Images/header_back.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Novell.Directory.Ldap/Novell.Directory.Ldap.Extensions/LdapBackupResponse.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Security/Test/System.Security.Cryptography.Pkcs/detached.data",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Security/Test/System.Security.Cryptography.Pkcs/detached.p7",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Security/Test/System.Security.Cryptography.Xml/sample.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data.Linq/src/DbLinq.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data.Linq/src/DbMetal/Language/EnglishWords.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data.Linq/src/DbMetal/Language/GermanWords.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data.Linq/src/DbLinq/Schema/Dbml/DbmlSchema.xsd",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data.Linq/src/DbLinq/Data/Linq/EntityRef.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.Cairo/Samples/x11/data/e.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.Cairo/Samples/png/data/e.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.Cairo/Samples/gtk/data/e.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/IBM.Data.DB2/ibm.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Reactive.PlatformServices/Strings_PlatformServices.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/M.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/Test/resources/32x32.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/Test/resources/a.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/Test/System.Windows.Forms/bitmaps/a.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/errorProvider.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/SplitterWE.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/image-missing.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/document-open.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/16_user-home.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/16_dialog-warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/folder.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/nav_previous.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/image-x-generic.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/DnDNo.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/DnDLink.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/folder-remote.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/32_document-open.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/16_dialog-information.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/22_page-magnifier.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/nav_first.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/32_user-desktop.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/32_printer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/NESW.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/16_computer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/preferences-system-windows.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/nav_plus.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/3-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/DnDMove.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/NWSE.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/mono.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/System.Windows.Forms.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/folder-new.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/propertygrid-categorized.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/16_dialog-error.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/user-desktop.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/4-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/go-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/go-previous.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/16_user-desktop.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/nav_end.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/6-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/32_user-home.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/16_printer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/keyboards.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/16_document-open.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/nav_next.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/computer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/EventsTab.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/text-x-generic.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/propertygrid-alphabetical.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/user-home.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/nav_delete.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/32_folder-remote.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/16_folder-remote.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/1-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/PropertiesTab.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/16_folder.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/DnDCopy.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/propertygrid-propertypages.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/2-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/SplitterNS.cur",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/resources/32_computer.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Windows.Forms/System.Windows.Forms/PageSetupDialog.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/Test/System.Security/SecurityElementTest.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/Test/resources/MyResources.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/Test/resources/MyResources.de.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/Test/resources/Fergie.GED",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/Test/resources/bug81759.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/Test/resources/StreamTest.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/Test/resources/415628.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/Test/resources/StreamTest.ja.resources",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/resources/charinfo.nlp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/resources/collation.cjkJA.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/resources/collation.cjkCHS.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/resources/collation.core.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/resources/collation.cjkCHT.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/resources/collation.cjkKOlv2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/resources/collation.tailoring.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/corlib/resources/collation.cjkKO.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing.Imaging/TiffCodecTest.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing.Imaging/IconCodecTest.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/resources/indexed.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/nature24bits.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/64x64x256.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/96x96x256.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/323511.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver32bits.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/4bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/nature24bits.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver1bit.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/32x32x16.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver24bits.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver32bits.tif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/milkmateya01.emf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/48x48x1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver8bits.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/81674-2bpp.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/telescope_01.wmf",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver24bits1.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/32bpp.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/non-inverted.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/maketransparent.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/1bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/415581.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/nature24bits87.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/81773-interlaced.gif",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/almogaver-os2.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/16x16x16.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/VisualPng1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/smiley.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/80509.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/VisualPng.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Test/System.Drawing/bitmaps/nature-greyscale.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/Exclamation.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/Warning.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/Information.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/Asterisk.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/Application.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/Shield.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/Error.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/WinLogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/Question.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/Mono.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Drawing/Assembly/Hand.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data/SqliteTest.db",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data/Test/ProviderTests/sql/sqlserver7.sql",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data/Test/System.Data/binserialize/BS-tb1.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data/Test/System.Data/binserialize/BS-tb3.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data/Test/System.Data/binserialize/BS-tb2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data/Test/System.Data/binserialize/BS-tb5.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Data/Test/System.Data/binserialize/BS-tb4.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.C5/c5.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.C5/c5.snk",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/Mono.C5/Test/BasesTest.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/System.Reactive.Linq/Strings_Linq.resources.prebuilt",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/ICSharpCode.SharpZipLib/SharpZipLib.pub",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/class/ICSharpCode.SharpZipLib/SharpZipLib.key",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/System.Collections.Immutable.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/vbc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.Build.Tasks.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.CSharp.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/System.Reflection.Metadata.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/VBCSCompiler.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.CSharp.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/csc.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.VisualBasic.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/csi.exe",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/packages/mnt/jenkins/workspace/release-tarball-mono/external/roslyn-binaries/Microsoft.Net.Compilers/Microsoft.Net.Compilers.2.6.0/tools/Microsoft.CodeAnalysis.Scripting.dll",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/nunitreport/Media/backbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/nunitreport/Media/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/nunitreport/Media/fail.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/nunitreport/Media/bullet.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/nunitreport/Media/pass.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/nunitreport/Media/rupert.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/security/certview/v3.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/security/certview/mono.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/security/certview/v3critical.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/security/certview/v1.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/security/certview/wax-seal.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/security/certview/v2.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/security/certview/mono.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/security/certview/wax-seal-broken.png",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/tools/pdb2mdb/IntHashTable.cs",
        "/tmp/vanessa/spack-stage/spack-stage-mono-5.10.1.57-iqvygpwgutbjcjcn2a3wvuvlimkmj25s/spack-src/mcs/mcs/visit.cs"
    ],
    "total_files": 82201
}