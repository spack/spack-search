{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/src/OSspecific/POSIX/POSIX.C": "/*---------------------------------------------------------------------------*\\\n  =========                 |\n  \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox\n   \\\\    /   O peration     | Website:  https://openfoam.org\n    \\\\  /    A nd           | Copyright (C) 2011-2019 OpenFOAM Foundation\n     \\\\/     M anipulation  |\n-------------------------------------------------------------------------------\nLicense\n    This file is part of OpenFOAM.\n\n    OpenFOAM is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n    for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.\n\nDescription\n    POSIX versions of the functions declared in OSspecific.H\n\n\\*---------------------------------------------------------------------------*/\n\n#ifdef solarisGcc\n    #define _SYS_VNODE_H\n#endif\n\n#include \"OSspecific.H\"\n#include \"POSIX.H\"\n#include \"foamVersion.H\"\n#include \"fileName.H\"\n#include \"fileStat.H\"\n#include \"timer.H\"\n#include \"IFstream.H\"\n#include \"DynamicList.H\"\n#include \"HashSet.H\"\n#include \"IOstreams.H\"\n#include \"Pstream.H\"\n\n#include <fstream>\n#include <cstdlib>\n#include <cctype>\n\n#include <stdio.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <dlfcn.h>\n#include <link.h>\n\n#include <netinet/in.h>\n\n// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //\n\nnamespace Foam\n{\n    defineTypeNameAndDebug(POSIX, 0);\n}\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\npid_t Foam::pid()\n{\n    return ::getpid();\n}\n\n\npid_t Foam::ppid()\n{\n    return ::getppid();\n}\n\n\npid_t Foam::pgid()\n{\n    return ::getpgrp();\n}\n\n\nbool Foam::env(const word& envName)\n{\n    return ::getenv(envName.c_str()) != nullptr;\n}\n\n\nFoam::string Foam::getEnv(const word& envName)\n{\n    char* env = ::getenv(envName.c_str());\n\n    if (env)\n    {\n        return string(env);\n    }\n    else\n    {\n        // Return null-constructed string rather than string::null\n        // to avoid cyclic dependencies in the construction of globals\n        return string();\n    }\n}\n\n\nbool Foam::setEnv\n(\n    const word& envName,\n    const std::string& value,\n    const bool overwrite\n)\n{\n    return setenv(envName.c_str(), value.c_str(), overwrite) == 0;\n}\n\n\nFoam::string Foam::hostName(bool full)\n{\n    char buf[128];\n    ::gethostname(buf, sizeof(buf));\n\n    // Implementation as per hostname from net-tools\n    if (full)\n    {\n        struct hostent *hp = ::gethostbyname(buf);\n        if (hp)\n        {\n            return hp->h_name;\n        }\n    }\n\n    return buf;\n}\n\n\nFoam::string Foam::domainName()\n{\n    char buf[128];\n    ::gethostname(buf, sizeof(buf));\n\n    // Implementation as per hostname from net-tools\n    struct hostent *hp = ::gethostbyname(buf);\n    if (hp)\n    {\n        char *p = ::strchr(hp->h_name, '.');\n        if (p)\n        {\n            ++p;\n            return p;\n        }\n    }\n\n    return string::null;\n}\n\n\nFoam::string Foam::userName()\n{\n    struct passwd* pw = ::getpwuid(::getuid());\n\n    if (pw != nullptr)\n    {\n        return pw->pw_name;\n    }\n    else\n    {\n        return string::null;\n    }\n}\n\n\nbool Foam::isAdministrator()\n{\n    return (::geteuid() == 0);\n}\n\n\nFoam::fileName Foam::home()\n{\n    char* env = ::getenv(\"HOME\");\n\n    if (env != nullptr)\n    {\n        return fileName(env);\n    }\n    else\n    {\n        struct passwd* pw = ::getpwuid(getuid());\n\n        if (pw != nullptr)\n        {\n            return pw->pw_dir;\n        }\n        else\n        {\n            return fileName::null;\n        }\n    }\n}\n\n\nFoam::fileName Foam::home(const string& userName)\n{\n    struct passwd* pw;\n\n    if (userName.size())\n    {\n        pw = ::getpwnam(userName.c_str());\n    }\n    else\n    {\n        char* env = ::getenv(\"HOME\");\n\n        if (env != nullptr)\n        {\n            return fileName(env);\n        }\n\n        pw = ::getpwuid(::getuid());\n    }\n\n    if (pw != nullptr)\n    {\n        return pw->pw_dir;\n    }\n    else\n    {\n        return fileName::null;\n    }\n}\n\n\nFoam::fileName Foam::cwd()\n{\n    label pathLengthLimit = POSIX::pathLengthChunk;\n    List<char> path(pathLengthLimit);\n\n    // Resize path if getcwd fails with an ERANGE error\n    while(pathLengthLimit == path.size())\n    {\n        if (::getcwd(path.data(), path.size()))\n        {\n            return path.data();\n        }\n        else if(errno == ERANGE)\n        {\n            // Increment path length up to the pathLengthMax limit\n            if\n            (\n                (pathLengthLimit += POSIX::pathLengthChunk)\n             >= POSIX::pathLengthMax\n            )\n            {\n                FatalErrorInFunction\n                    << \"Attempt to increase path length beyond limit of \"\n                    << POSIX::pathLengthMax\n                    << exit(FatalError);\n            }\n\n            path.setSize(pathLengthLimit);\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    FatalErrorInFunction\n        << \"Couldn't get the current working directory\"\n        << exit(FatalError);\n\n    return fileName::null;\n}\n\n\nbool Foam::chDir(const fileName& dir)\n{\n    return ::chdir(dir.c_str()) == 0;\n}\n\n\nbool Foam::mkDir(const fileName& pathName, mode_t mode)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : pathName:\" << pathName << \" mode:\" << mode\n            << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Empty names are meaningless\n    if (pathName.empty())\n    {\n        return false;\n    }\n\n    // Construct instance path directory if does not exist\n    if (::mkdir(pathName.c_str(), mode) == 0)\n    {\n        // Directory made OK so return true\n        return true;\n    }\n    else\n    {\n        switch (errno)\n        {\n            case EPERM:\n            {\n                FatalErrorInFunction\n                    << \"The filesystem containing \" << pathName\n                    << \" does not support the creation of directories.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case EEXIST:\n            {\n                // Directory already exists so simply return true\n                return true;\n            }\n\n            case EFAULT:\n            {\n                FatalErrorInFunction\n                    << \"\" << pathName\n                    << \" points outside your accessible address space.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case EACCES:\n            {\n                FatalErrorInFunction\n                    << \"The parent directory does not allow write \"\n                       \"permission to the process,\"<< nl\n                    << \"or one of the directories in \" << pathName\n                    << \" did not allow search (execute) permission.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case ENAMETOOLONG:\n            {\n                FatalErrorInFunction\n                    << \"\" << pathName << \" is too long.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case ENOENT:\n            {\n                // Part of the path does not exist so try to create it\n                if (pathName.path().size() && mkDir(pathName.path(), mode))\n                {\n                    return mkDir(pathName, mode);\n                }\n                else\n                {\n                    FatalErrorInFunction\n                        << \"Couldn't create directory \" << pathName\n                        << exit(FatalError);\n\n                    return false;\n                }\n            }\n\n            case ENOTDIR:\n            {\n                FatalErrorInFunction\n                    << \"A component used as a directory in \" << pathName\n                    << \" is not, in fact, a directory.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case ENOMEM:\n            {\n                FatalErrorInFunction\n                    << \"Insufficient kernel memory was available to make \"\n                       \"directory \" << pathName << '.'\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case EROFS:\n            {\n                FatalErrorInFunction\n                    << \"\" << pathName\n                    << \" refers to a file on a read-only filesystem.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case ELOOP:\n            {\n                FatalErrorInFunction\n                    << \"Too many symbolic links were encountered in resolving \"\n                    << pathName << '.'\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case ENOSPC:\n            {\n                FatalErrorInFunction\n                    << \"The device containing \" << pathName\n                    << \" has no room for the new directory or \"\n                    << \"the user's disk quota is exhausted.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            default:\n            {\n                FatalErrorInFunction\n                    << \"Couldn't create directory \" << pathName\n                    << exit(FatalError);\n\n                return false;\n            }\n        }\n    }\n}\n\n\nbool Foam::chMod(const fileName& name, const mode_t m)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n    return ::chmod(name.c_str(), m) == 0;\n}\n\n\nmode_t Foam::mode\n(\n    const fileName& name,\n    const bool checkVariants,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n    fileStat fileStatus(name, checkVariants, followLink);\n    if (fileStatus.isValid())\n    {\n        return fileStatus.status().st_mode;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n\nFoam::fileType Foam::type\n(\n    const fileName& name,\n    const bool checkVariants,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n    }\n    mode_t m = mode(name, checkVariants, followLink);\n\n    if (S_ISREG(m))\n    {\n        return fileType::file;\n    }\n    else if (S_ISLNK(m))\n    {\n        return fileType::link;\n    }\n    else if (S_ISDIR(m))\n    {\n        return fileType::directory;\n    }\n    else\n    {\n        return fileType::undefined;\n    }\n}\n\n\nbool Foam::exists\n(\n    const fileName& name,\n    const bool checkVariants,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << \" checkVariants:\"\n            << bool(checkVariants) << \" followLink:\" << followLink << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n    return mode(name, checkVariants, followLink);\n}\n\n\nbool Foam::isDir(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << \" followLink:\"\n            << followLink << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n    return S_ISDIR(mode(name, false, followLink));\n}\n\n\nbool Foam::isFile\n(\n    const fileName& name,\n    const bool checkVariants,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << \" checkVariants:\"\n            << bool(checkVariants) << \" followLink:\" << followLink << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    return S_ISREG(mode(name, checkVariants, followLink));\n}\n\n\noff_t Foam::fileSize\n(\n    const fileName& name,\n    const bool checkVariants,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << \" checkVariants:\"\n            << bool(checkVariants) << \" followLink:\" << followLink << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n    fileStat fileStatus(name, checkVariants, followLink);\n    if (fileStatus.isValid())\n    {\n        return fileStatus.status().st_size;\n    }\n    else\n    {\n        return -1;\n    }\n}\n\n\ntime_t Foam::lastModified\n(\n    const fileName& name,\n    const bool checkVariants,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << \" checkVariants:\"\n            << bool(checkVariants) << \" followLink:\" << followLink << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n    fileStat fileStatus(name, checkVariants, followLink);\n    if (fileStatus.isValid())\n    {\n        return fileStatus.status().st_mtime;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n\ndouble Foam::highResLastModified\n(\n    const fileName& name,\n    const bool checkVariants,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << \" checkVariants:\"\n            << bool(checkVariants) << \" followLink:\" << followLink << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n    fileStat fileStatus(name, checkVariants, followLink);\n    if (fileStatus.isValid())\n    {\n        return\n            fileStatus.status().st_mtime\n          + 1e-9*fileStatus.status().st_atim.tv_nsec;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n\nFoam::fileNameList Foam::readDir\n(\n    const fileName& directory,\n    const fileType type,\n    const bool filterVariants,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : reading directory \" << directory << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Create empty set of file names\n    HashSet<fileName> dirEntries;\n\n    // Pointers to the directory entries\n    DIR *source;\n    struct dirent *list;\n\n    // Attempt to open directory and set the structure pointer\n    if ((source = ::opendir(directory.c_str())) == nullptr)\n    {\n        if (POSIX::debug)\n        {\n            InfoInFunction\n                << \"cannot open directory \" << directory << endl;\n        }\n    }\n    else\n    {\n        // Read and parse all the entries in the directory\n        while ((list = ::readdir(source)) != nullptr)\n        {\n            fileName fName(list->d_name);\n\n            // Ignore files beginning with ., i.e. '.', '..' and '.*'\n            if (fName.size() && fName[0] != '.')\n            {\n                word fExt = fName.ext();\n\n                if\n                (\n                    (type == fileType::directory)\n                 ||\n                    (\n                        type == fileType::file\n                     && fName[fName.size()-1] != '~'\n                     && fExt != \"bak\"\n                     && fExt != \"BAK\"\n                     && fExt != \"old\"\n                     && fExt != \"save\"\n                    )\n                )\n                {\n                    if ((directory/fName).type(false, followLink) == type)\n                    {\n                        bool filtered = false;\n\n                        if (filterVariants)\n                        {\n                            for (label i = 0; i < fileStat::nVariants_; ++ i)\n                            {\n                                if (fExt == fileStat::variantExts_[i])\n                                {\n                                    dirEntries.insert(fName.lessExt());\n                                    filtered = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (!filtered)\n                        {\n                            dirEntries.insert(fName);\n                        }\n                    }\n                }\n            }\n        }\n\n        ::closedir(source);\n    }\n\n    return dirEntries.toc();\n}\n\n\nbool Foam::cp(const fileName& src, const fileName& dest, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : src:\" << src << \" dest:\" << dest << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n    // Make sure source exists.\n    if (!exists(src))\n    {\n        return false;\n    }\n\n    const fileType srcType = src.type(false, followLink);\n\n    fileName destFile(dest);\n\n    // Check type of source file.\n    if (srcType == fileType::file)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileType::directory)\n        {\n            destFile = destFile/src.name();\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile.path()) && !mkDir(destFile.path()))\n        {\n            return false;\n        }\n\n        // Open and check streams.\n        std::ifstream srcStream(src.c_str());\n        if (!srcStream)\n        {\n            return false;\n        }\n\n        std::ofstream destStream(destFile.c_str());\n        if (!destStream)\n        {\n            return false;\n        }\n\n        // Copy character data.\n        char ch;\n        while (srcStream.get(ch))\n        {\n            destStream.put(ch);\n        }\n\n        // Final check.\n        if (!srcStream.eof() || !destStream)\n        {\n            return false;\n        }\n    }\n    else if (srcType == fileType::link)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileType::directory)\n        {\n            destFile = destFile/src.name();\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile.path()) && !mkDir(destFile.path()))\n        {\n            return false;\n        }\n\n        ln(src, destFile);\n    }\n    else if (srcType == fileType::directory)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileType::directory)\n        {\n            destFile = destFile/src.component(src.components().size() -1);\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile) && !mkDir(destFile))\n        {\n            return false;\n        }\n\n        char* realSrcPath = realpath(src.c_str(), nullptr);\n        char* realDestPath = realpath(destFile.c_str(), nullptr);\n        const bool samePath = strcmp(realSrcPath, realDestPath) == 0;\n\n        if (POSIX::debug && samePath)\n        {\n            InfoInFunction\n                << \"Attempt to copy \" << realSrcPath << \" to itself\" << endl;\n        }\n\n        if (realSrcPath)\n        {\n            free(realSrcPath);\n        }\n\n        if (realDestPath)\n        {\n            free(realDestPath);\n        }\n\n        // Do not copy over self when src is actually a link to dest\n        if (samePath)\n        {\n            return false;\n        }\n\n        // Copy files\n        fileNameList contents = readDir(src, fileType::file, false, followLink);\n        forAll(contents, i)\n        {\n            if (POSIX::debug)\n            {\n                InfoInFunction\n                    << \"Copying : \" << src/contents[i]\n                    << \" to \" << destFile/contents[i] << endl;\n            }\n\n            // File to file.\n            cp(src/contents[i], destFile/contents[i], followLink);\n        }\n\n        // Copy sub directories.\n        fileNameList subdirs = readDir\n        (\n            src,\n            fileType::directory,\n            false,\n            followLink\n        );\n\n        forAll(subdirs, i)\n        {\n            if (POSIX::debug)\n            {\n                InfoInFunction\n                    << \"Copying : \" << src/subdirs[i]\n                    << \" to \" << destFile << endl;\n            }\n\n            // Dir to Dir.\n            cp(src/subdirs[i], destFile, followLink);\n        }\n    }\n\n    return true;\n}\n\n\nbool Foam::ln(const fileName& src, const fileName& dst)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME\n            << \" : Create softlink from : \" << src << \" to \" << dst << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    if (exists(dst))\n    {\n        WarningInFunction\n            << \"destination \" << dst << \" already exists. Not linking.\"\n            << endl;\n        return false;\n    }\n\n    if (src.isAbsolute() && !exists(src))\n    {\n        WarningInFunction\n            << \"source \" << src << \" does not exist.\" << endl;\n        return false;\n    }\n\n    if (::symlink(src.c_str(), dst.c_str()) == 0)\n    {\n        return true;\n    }\n    else\n    {\n        WarningInFunction\n            << \"symlink from \" << src << \" to \" << dst << \" failed.\" << endl;\n        return false;\n    }\n}\n\n\nbool Foam::mv(const fileName& src, const fileName& dst, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : Move : \" << src << \" to \" << dst << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    if\n    (\n        dst.type() == fileType::directory\n     && src.type(false, followLink) != fileType::directory\n    )\n    {\n        const fileName dstName(dst/src.name());\n\n        return ::rename(src.c_str(), dstName.c_str()) == 0;\n    }\n    else\n    {\n        return ::rename(src.c_str(), dst.c_str()) == 0;\n    }\n}\n\n\nbool Foam::mvBak(const fileName& src, const std::string& ext)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME\n            << \" : moving : \" << src << \" to extension \" << ext << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    if (exists(src, false, false))\n    {\n        const int maxIndex = 99;\n        char index[3];\n\n        for (int n = 0; n <= maxIndex; n++)\n        {\n            fileName dstName(src + \".\" + ext);\n            if (n)\n            {\n                sprintf(index, \"%02d\", n);\n                dstName += index;\n            }\n\n            // Avoid overwriting existing files, except for the last\n            // possible index where we have no choice\n            if (!exists(dstName, false, false) || n == maxIndex)\n            {\n                return ::rename(src.c_str(), dstName.c_str()) == 0;\n            }\n\n        }\n    }\n\n    // Fall-through: nothing to do\n    return false;\n}\n\n\nbool Foam::rm(const fileName& file)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : Removing : \" << file << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Try returning plain file name; if not there, try variants\n    if (remove(file.c_str()) == 0)\n    {\n        return true;\n    }\n\n    for (label i = 0; i < fileStat::nVariants_; ++ i)\n    {\n        const fileName fileVar = file + \".\" + fileStat::variantExts_[i];\n        if (::remove(string(fileVar).c_str()) == 0)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\nbool Foam::rmDir(const fileName& directory)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : removing directory \" << directory << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Pointers to the directory entries\n    DIR *source;\n    struct dirent *list;\n\n    // Attempt to open directory and set the structure pointer\n    if ((source = ::opendir(directory.c_str())) == nullptr)\n    {\n        WarningInFunction\n            << \"cannot open directory \" << directory << endl;\n\n        return false;\n    }\n    else\n    {\n        // Read and parse all the entries in the directory\n        while ((list = ::readdir(source)) != nullptr)\n        {\n            fileName fName(list->d_name);\n\n            if (fName != \".\" && fName != \"..\")\n            {\n                fileName path = directory/fName;\n\n                if (path.type(false, false) == fileType::directory)\n                {\n                    if (!rmDir(path))\n                    {\n                        WarningInFunction\n                            << \"failed to remove directory \" << fName\n                            << \" while removing directory \" << directory\n                            << endl;\n\n                        ::closedir(source);\n\n                        return false;\n                    }\n                }\n                else\n                {\n                    if (!rm(path))\n                    {\n                        WarningInFunction\n                            << \"failed to remove file \" << fName\n                            << \" while removing directory \" << directory\n                            << endl;\n\n                        ::closedir(source);\n\n                        return false;\n                    }\n                }\n            }\n\n        }\n\n        if (!rm(directory))\n        {\n            WarningInFunction\n                << \"failed to remove directory \" << directory << endl;\n\n            ::closedir(source);\n\n            return false;\n        }\n\n        ::closedir(source);\n\n        return true;\n    }\n}\n\n\nunsigned int Foam::sleep(const unsigned int s)\n{\n    return ::sleep(s);\n}\n\n\nvoid Foam::fdClose(const int fd)\n{\n    if (close(fd) != 0)\n    {\n        FatalErrorInFunction\n            << \"close error on \" << fd << endl\n            << abort(FatalError);\n    }\n}\n\n\nbool Foam::ping\n(\n    const string& destName,\n    const label destPort,\n    const label timeOut\n)\n{\n    struct hostent *hostPtr;\n    volatile int sockfd;\n    struct sockaddr_in destAddr;      // Will hold the destination addr\n    u_int addr;\n\n    if ((hostPtr = ::gethostbyname(destName.c_str())) == nullptr)\n    {\n        FatalErrorInFunction\n            << \"gethostbyname error \" << h_errno << \" for host \" << destName\n            << abort(FatalError);\n    }\n\n    // Get first of the SLL of addresses\n    addr = (reinterpret_cast<struct in_addr*>(*(hostPtr->h_addr_list)))->s_addr;\n\n    // Allocate socket\n    sockfd = ::socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0)\n    {\n        FatalErrorInFunction\n            << \"socket error\"\n            << abort(FatalError);\n    }\n\n    // Fill sockaddr_in structure with dest address and port\n    memset(reinterpret_cast<char *>(&destAddr), '\\0', sizeof(destAddr));\n    destAddr.sin_family = AF_INET;\n    destAddr.sin_port = htons(ushort(destPort));\n    destAddr.sin_addr.s_addr = addr;\n\n\n    timer myTimer(timeOut);\n\n    if (timedOut(myTimer))\n    {\n        // Setjmp from timer jumps back to here\n        fdClose(sockfd);\n        return false;\n    }\n\n    if\n    (\n        ::connect\n        (\n            sockfd,\n            reinterpret_cast<struct sockaddr*>(&destAddr),\n            sizeof(struct sockaddr)\n        ) != 0\n    )\n    {\n        // Connection refused. Check if network was actually used or not.\n\n        int connectErr = errno;\n\n        fdClose(sockfd);\n\n        if (connectErr == ECONNREFUSED)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    fdClose(sockfd);\n\n    return true;\n}\n\n\nbool Foam::ping(const string& hostname, const label timeOut)\n{\n    return ping(hostname, 222, timeOut) || ping(hostname, 22, timeOut);\n}\n\n\nint Foam::system(const std::string& command)\n{\n    return ::system(command.c_str());\n}\n\n\nvoid* Foam::dlOpen(const fileName& lib, const bool check)\n{\n    if (POSIX::debug)\n    {\n        std::cout<< \"dlOpen(const fileName&)\"\n            << \" : dlopen of \" << lib << std::endl;\n    }\n    void* handle = ::dlopen(lib.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n\n    if (!handle && check)\n    {\n        WarningInFunction\n            << \"dlopen error : \" << ::dlerror()\n            << endl;\n    }\n\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlOpen(const fileName&)\"\n            << \" : dlopen of \" << lib\n            << \" handle \" << handle << std::endl;\n    }\n\n    return handle;\n}\n\n\nbool Foam::dlClose(void* handle)\n{\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlClose(void*)\"\n            << \" : dlclose of handle \" << handle << std::endl;\n    }\n    return ::dlclose(handle) == 0;\n}\n\n\nvoid* Foam::dlSym(void* handle, const std::string& symbol)\n{\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlSym(void*, const std::string&)\"\n            << \" : dlsym of \" << symbol << std::endl;\n    }\n\n    // Clear any old errors - see manpage dlopen\n    (void) ::dlerror();\n\n    // Get address of symbol\n    void* fun = ::dlsym(handle, symbol.c_str());\n\n    // Find error (if any)\n    char *error = ::dlerror();\n\n    if (error)\n    {\n        WarningInFunction\n            << \"Cannot lookup symbol \" << symbol << \" : \" << error\n            << endl;\n    }\n\n    return fun;\n}\n\n\nbool Foam::dlSymFound(void* handle, const std::string& symbol)\n{\n    if (handle && !symbol.empty())\n    {\n        if (POSIX::debug)\n        {\n            std::cout\n                << \"dlSymFound(void*, const std::string&)\"\n                << \" : dlsym of \" << symbol << std::endl;\n        }\n\n        // Clear any old errors - see manpage dlopen\n        (void) ::dlerror();\n\n        // Get address of symbol\n        (void) ::dlsym(handle, symbol.c_str());\n\n        // Symbol can be found if there was no error\n        return !::dlerror();\n    }\n    else\n    {\n        return false;\n    }\n}\n\n\nstatic int collectLibsCallback\n(\n    struct dl_phdr_info *info,\n    size_t size,\n    void *data\n)\n{\n    Foam::DynamicList<Foam::fileName>* ptr =\n        reinterpret_cast<Foam::DynamicList<Foam::fileName>*>(data);\n    ptr->append(info->dlpi_name);\n    return 0;\n}\n\n\nFoam::fileNameList Foam::dlLoaded()\n{\n    DynamicList<fileName> libs;\n    dl_iterate_phdr(collectLibsCallback, &libs);\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlLoaded()\"\n            << \" : determined loaded libraries :\" << libs.size() << std::endl;\n    }\n\n    return move(libs);\n}\n\n\n// ************************************************************************* //\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/applications/utilities/mesh/conversion/kivaToFoam/kiva3v-valves.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/src/meshTools/momentOfInertia/volInt.ps.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/lagrangian/MPPICFoam/cyclone/constant/triSurface/cyclone.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/combustion/reactingFoam/RAS/membrane/constant/triSurface/boundaries.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/combustion/reactingFoam/RAS/membrane/constant/triSurface/membrane.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/p.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/B.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/nuTilda.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/U.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/nut.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/k.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/incompressible/simpleFoam/windAroundBuildings/constant/triSurface/buildings.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/heatTransfer/chtMultiRegionFoam/shellAndTubeHeatExchanger/constant/triSurface/tube.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/heatTransfer/chtMultiRegionFoam/shellAndTubeHeatExchanger/constant/triSurface/tube_to_solid.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/heatTransfer/chtMultiRegionFoam/shellAndTubeHeatExchanger/constant/triSurface/solid.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/heatTransfer/chtMultiRegionFoam/shellAndTubeHeatExchanger/constant/triSurface/shell_to_solid.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/heatTransfer/chtMultiRegionFoam/shellAndTubeHeatExchanger/constant/triSurface/shell.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh/cells.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/multiphase/interPhaseChangeFoam/cavitatingBullet/constant/triSurface/bullet.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/propeller-middleCylinder.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/mixerVessel-sparger.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/mixerVessel-shaft.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/propeller-outerCylinder.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/pipeWall.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/propeller-innerCylinder.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/pipe.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/mixerVessel-oilInlet.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/DTC-scaled.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/mixerVessel-outlet.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/mixerVessel-baffles.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/propeller.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/mixerVessel-stirrer.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/flange.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/motorBike.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/NACA0012.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/mixerVessel-vessel.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/resources/geometry/mixerVessel-shaftRotating.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/mesh/moveDynamicMesh/SnakeRiverCanyon/constant/triSurface/AcrossRiver.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/mesh/moveDynamicMesh/SnakeRiverCanyon/constant/triSurface/ACROSSCYN.JPG",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/mesh/foamyHexMesh/blob/constant/triSurface/blob.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/compressible/rhoPimpleFoam/RAS/nacaAirfoil/prostar/nacaAirfoil.vrt.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/compressible/rhoPimpleFoam/RAS/nacaAirfoil/prostar/nacaAirfoil.bnd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/tutorials/compressible/rhoPimpleFoam/RAS/nacaAirfoil/prostar/nacaAirfoil.cel.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/doc/Doxygen/CFDFoundation55x55.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/doc/Guides/OpenFOAMUserGuide-USletter.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-org-8-kkx7oilp2ygkchc4vs2xs2gppozrcymp/spack-src/doc/Guides/OpenFOAMUserGuide-A4.pdf"
    ],
    "total_files": 9532
}