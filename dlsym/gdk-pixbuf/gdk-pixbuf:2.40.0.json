{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/gdk-pixbuf/pixops/pixops.c": "/*\n * Copyright (C) 2000 Red Hat, Inc\n * mediaLib integration Copyright (c) 2001-2007 Sun Microsystems, Inc.\n * All rights reserved.  (Brian Cameron, Dmitriy Demin, James Cheng,\n * Padraig O'Briain)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#include \"config.h\"\n#include <math.h>\n#include <glib.h>\n\n#include \"../fallback-c89.c\"\n#include \"pixops.h\"\n\n#define SUBSAMPLE_BITS 4\n#define SUBSAMPLE (1 << SUBSAMPLE_BITS)\n#define SUBSAMPLE_MASK ((1 << SUBSAMPLE_BITS)-1)\n#define SCALE_SHIFT 16\n\nstatic void\n_pixops_scale_real (guchar        *dest_buf,\n                    int            render_x0,\n                    int            render_y0,\n                    int            render_x1,\n                    int            render_y1,\n                    int            dest_rowstride,\n                    int            dest_channels,\n                    gboolean       dest_has_alpha,\n                    const guchar  *src_buf,\n                    int            src_width,\n                    int            src_height,\n                    int            src_rowstride,\n                    int            src_channels,\n                    gboolean       src_has_alpha,\n                    double         scale_x,\n                    double         scale_y,\n                    PixopsInterpType  interp_type);\n\ntypedef struct _PixopsFilter PixopsFilter;\ntypedef struct _PixopsFilterDimension PixopsFilterDimension;\n\nstruct _PixopsFilterDimension\n{\n  int n;\n  double offset;\n  double *weights;\n};\n\nstruct _PixopsFilter\n{\n  PixopsFilterDimension x;\n  PixopsFilterDimension y;\n  double overall_alpha;\n}; \n\ntypedef guchar *(*PixopsLineFunc) (int *weights, int n_x, int n_y,\n\t\t\t\t   guchar *dest, int dest_x, guchar *dest_end,\n\t\t\t\t   int dest_channels, int dest_has_alpha,\n\t\t\t\t   guchar **src, int src_channels,\n\t\t\t\t   gboolean src_has_alpha, int x_init,\n\t\t\t\t   int x_step, int src_width, int check_size,\n\t\t\t\t   guint32 color1, guint32 color2);\ntypedef void (*PixopsPixelFunc)   (guchar *dest, int dest_x, int dest_channels,\n\t\t\t\t   int dest_has_alpha, int src_has_alpha,\n\t\t\t\t   int check_size, guint32 color1,\n\t\t\t\t   guint32 color2,\n\t\t\t\t   guint r, guint g, guint b, guint a);\n\n#ifdef USE_MEDIALIB\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <mlib_image.h>\n\n#ifdef HAVE_STRINGS_H\n#include <strings.h>\n#endif\n\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n\n#if defined(HAVE_SYS_SYSTEMINFO_H)\n#include <sys/systeminfo.h>\n#elif defined(HAVE_SYS_SYSINFO_H)\n#include <sys/sysinfo.h>\n#endif\n\nstatic void pixops_medialib_composite    (guchar          *dest_buf,\n                                          int              dest_width,\n                                          int              dest_height,\n                                          int              dest_rowstride,\n                                          int              dest_channels,\n                                          int              dest_has_alpha,\n                                          const guchar    *src_buf,\n                                          int              src_width,\n                                          int              src_height,\n                                          int              src_rowstride,\n                                          int              src_channels,\n                                          int              src_has_alpha,\n                                          int              dest_x,\n                                          int              dest_y,\n                                          int              dest_region_width,\n                                          int              dest_region_height,\n                                          double           offset_x,\n                                          double           offset_y,\n                                          double           scale_x,\n                                          double           scale_y,\n                                          PixopsInterpType interp_type,\n                                          int              overall_alpha);\n\nstatic void pixops_medialib_scale        (guchar          *dest_buf,\n                                          int              dest_width,\n                                          int              dest_height,\n                                          int              dest_rowstride,\n                                          int              dest_channels,\n                                          int              dest_has_alpha,\n                                          const guchar    *src_buf,\n                                          int              src_width,\n                                          int              src_height,\n                                          int              src_rowstride,\n                                          int              src_channels,\n                                          int              src_has_alpha,\n                                          int              dest_x,\n                                          int              dest_y,\n                                          int              dest_region_width,\n                                          int              dest_region_height,\n                                          double           offset_x,\n                                          double           offset_y,\n                                          double           scale_x,\n                                          double           scale_y,\n                                          PixopsInterpType interp_type);\n\ntypedef struct _mlInterp mlInterp;\n\nstruct _mlInterp\n{\n  double       tx;\n  double       ty;\n  PixopsFilter po_filter;\n  void         *interp_table;\n};\n\nstatic gboolean medialib_initialized = FALSE;\nstatic gboolean use_medialib         = TRUE;\n\n/*\n * Sun mediaLib(tm) support.\n *\n *   http://www.sun.com/processors/vis/mlib.html\n *\n */\nstatic void\n_pixops_use_medialib ()\n{\n  char *mlib_version_string;\n  char  sys_info[257];\n  long  count;\n\n  medialib_initialized = TRUE; \n\n  if (getenv (\"GDK_DISABLE_MEDIALIB\"))\n    {\n      use_medialib = FALSE;\n      return;\n    }\n\n  /*\n   * The imaging functions we want to use were added in mediaLib version 2.\n   * So turn off mediaLib support if the user has an older version.\n   * mlib_version returns a string in this format:\n   *\n   * mediaLib:0210:20011101:v8plusa\n   * ^^^^^^^^ ^^^^ ^^^^^^^^ ^^^^^^^\n   * libname  vers  build   ISALIST identifier\n   *                date    (in this case sparcv8plus+vis)\n   * \n   * The first 2 digits of the version are the major version.  The 3rd digit\n   * is the minor version, and the 4th digit is the micro version.  So the\n   * above string corresponds to version 2.1.0.  In the following test we only\n   * care about the major version.\n   */\n  mlib_version_string = mlib_version ();\n\n  count = sysinfo (SI_ARCHITECTURE, &sys_info[0], 257);\n\n  if (count != -1)\n    {\n      if (strcmp (sys_info, \"i386\") == 0)\n        {\n          char *mlib_target_isa = &mlib_version_string[23];\n\n          /*\n           * For x86 processors mediaLib generic C implementation\n           * does not give any performance advantage so disable it\n           */\n          if (strncmp (mlib_target_isa, \"sse\", 3) != 0)\n            {\n              use_medialib = FALSE;\n              return;\n            }\n\n          /*\n           * For x86 processors use of libumem conflicts with\n           * mediaLib, so avoid using it.\n           */\n          if (dlsym (RTLD_PROBE,   \"umem_alloc\") != NULL)\n            {\n              use_medialib = FALSE;\n              return;\n            }\n        }\n    }\n  else\n    {\n      /* Failed to get system architecture, disable mediaLib anyway */\n      use_medialib = FALSE;\n      return;\n    }\n}\n#endif\n\nstatic int\nget_check_shift (int check_size)\n{\n  int check_shift = 0;\n  g_return_val_if_fail (check_size >= 0, 4);\n\n  while (!(check_size & 1))\n    {\n      check_shift++;\n      check_size >>= 1;\n    }\n\n  return check_shift;\n}\n\nstatic void\npixops_scale_nearest (guchar        *dest_buf,\n\t\t      int            render_x0,\n\t\t      int            render_y0,\n\t\t      int            render_x1,\n\t\t      int            render_y1,\n\t\t      int            dest_rowstride,\n\t\t      int            dest_channels,\n\t\t      gboolean       dest_has_alpha,\n\t\t      const guchar  *src_buf,\n\t\t      int            src_width,\n\t\t      int            src_height,\n\t\t      int            src_rowstride,\n\t\t      int            src_channels,\n\t\t      gboolean       src_has_alpha,\n\t\t      double         scale_x,\n\t\t      double         scale_y)\n{\n  gint64 i;\n  gint64 x;\n  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;\n  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;\n  gint64 xmax, xstart, xstop, x_pos, y_pos;\n  const guchar *p;\n\n#define INNER_LOOP(SRC_CHANNELS,DEST_CHANNELS,ASSIGN_PIXEL)     \\\n      xmax = x + (render_x1 - render_x0) * x_step;              \\\n      xstart = MIN (0, xmax);                                   \\\n      xstop = MIN (src_width << SCALE_SHIFT, xmax);             \\\n      p = src + (CLAMP (x, xstart, xstop) >> SCALE_SHIFT) * SRC_CHANNELS; \\\n      while (x < xstart)                                        \\\n        {                                                       \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x += x_step;                                          \\\n        }                                                       \\\n      while (x < xstop)                                         \\\n        {                                                       \\\n          p = src + (x >> SCALE_SHIFT) * SRC_CHANNELS;          \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x += x_step;                                          \\\n        }                                                       \\\n      x_pos = x >> SCALE_SHIFT;                                 \\\n      p = src + CLAMP (x_pos, 0, src_width - 1) * SRC_CHANNELS; \\\n      while (x < xmax)                                          \\\n        {                                                       \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x += x_step;                                          \\\n        }\n\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      const guchar *src;\n      guchar       *dest;\n      y_pos = ((i + render_y0) * y_step + y_step / 2) >> SCALE_SHIFT;\n      y_pos = CLAMP (y_pos, 0, src_height - 1);\n      src  = src_buf + (gsize)y_pos * src_rowstride;\n      dest = dest_buf + (gsize)i * dest_rowstride;\n\n      x = render_x0 * x_step + x_step / 2;\n\n      if (src_channels == 3)\n\t{\n\t  if (dest_channels == 3)\n\t    {\n\t      INNER_LOOP (3, 3, dest[0]=p[0];dest[1]=p[1];dest[2]=p[2]);\n\t    }\n\t  else\n\t    {\n\t      INNER_LOOP (3, 4, dest[0]=p[0];dest[1]=p[1];dest[2]=p[2];dest[3]=0xff);\n\t    }\n\t}\n      else if (src_channels == 4)\n\t{\n\t  if (dest_channels == 3)\n\t    {\n\t      INNER_LOOP (4, 3, dest[0]=p[0];dest[1]=p[1];dest[2]=p[2]);\n\t    }\n\t  else\n\t    {\n\t      guint32 *p32;\n\t      INNER_LOOP(4, 4, p32=(guint32*)dest;*p32=*((guint32*)p));\n\t    }\n\t}\n    }\n}\n\nstatic void\npixops_composite_nearest (guchar        *dest_buf,\n\t\t\t  int            render_x0,\n\t\t\t  int            render_y0,\n\t\t\t  int            render_x1,\n\t\t\t  int            render_y1,\n\t\t\t  int            dest_rowstride,\n\t\t\t  int            dest_channels,\n\t\t\t  gboolean       dest_has_alpha,\n\t\t\t  const guchar  *src_buf,\n\t\t\t  int            src_width,\n\t\t\t  int            src_height,\n\t\t\t  int            src_rowstride,\n\t\t\t  int            src_channels,\n\t\t\t  gboolean       src_has_alpha,\n\t\t\t  double         scale_x,\n\t\t\t  double         scale_y,\n\t\t\t  int            overall_alpha)\n{\n  gint64 i;\n  gint64 x;\n  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;\n  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;\n  gint64 xmax, xstart, xstop, x_pos, y_pos;\n  const guchar *p;\n  unsigned int  a0;\n\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      const guchar *src;\n      guchar       *dest;\n      y_pos = ((i + render_y0) * y_step + y_step / 2) >> SCALE_SHIFT;\n      y_pos = CLAMP (y_pos, 0, src_height - 1);\n      src  = src_buf + (gsize)y_pos * src_rowstride;\n      dest = dest_buf + (gsize)i * dest_rowstride;\n\n      x = render_x0 * x_step + x_step / 2;\n      \n      INNER_LOOP(src_channels, dest_channels,\n\t  if (src_has_alpha)\n\t    a0 = (p[3] * overall_alpha) / 0xff;\n\t  else\n\t    a0 = overall_alpha;\n\n          switch (a0)\n            {\n            case 0:\n              break;\n            case 255:\n              dest[0] = p[0];\n              dest[1] = p[1];\n              dest[2] = p[2];\n              if (dest_has_alpha)\n                dest[3] = 0xff;\n              break;\n            default:\n              if (dest_has_alpha)\n                {\n                  unsigned int w0 = 0xff * a0;\n                  unsigned int w1 = (0xff - a0) * dest[3];\n                  unsigned int w = w0 + w1;\n\n\t\t  dest[0] = (w0 * p[0] + w1 * dest[0]) / w;\n\t\t  dest[1] = (w0 * p[1] + w1 * dest[1]) / w;\n\t\t  dest[2] = (w0 * p[2] + w1 * dest[2]) / w;\n\t\t  dest[3] = w / 0xff;\n                }\n              else\n                {\n                  unsigned int a1 = 0xff - a0;\n\t\t  unsigned int tmp;\n\n\t\t  tmp = a0 * p[0] + a1 * dest[0] + 0x80;\n                  dest[0] = (tmp + (tmp >> 8)) >> 8;\n\t\t  tmp = a0 * p[1] + a1 * dest[1] + 0x80;\n                  dest[1] = (tmp + (tmp >> 8)) >> 8;\n\t\t  tmp = a0 * p[2] + a1 * dest[2] + 0x80;\n                  dest[2] = (tmp + (tmp >> 8)) >> 8;\n                }\n              break;\n            }\n\t);\n    }\n}\n\nstatic void\npixops_composite_nearest_noscale (guchar        *dest_buf,\n\t\t\t\t  int            render_x0,\n\t\t\t\t  int            render_y0,\n\t\t\t\t  int            render_x1,\n\t\t\t\t  int            render_y1,\n\t\t\t\t  int            dest_rowstride,\n\t\t\t\t  int            dest_channels,\n\t\t\t\t  gboolean       dest_has_alpha,\n\t\t\t\t  const guchar  *src_buf,\n\t\t\t\t  int            src_width,\n\t\t\t\t  int            src_height,\n\t\t\t\t  int            src_rowstride,\n\t\t\t\t  int            src_channels,\n\t\t\t\t  gboolean       src_has_alpha,\n\t\t\t\t  int            overall_alpha)\n{\n  gint64 i;\n  gint64 x;\n  gint64 xmax, xstart, xstop, y_pos;\n  const guchar *p;\n  unsigned int  a0;\n\n#define INNER_LOOP_NOSCALE(SRC_CHANNELS,DEST_CHANNELS,ASSIGN_PIXEL) \\\n      xmax = x + (render_x1 - render_x0);                       \\\n      xstart = MIN (0, xmax);                                   \\\n      xstop = MIN (src_width, xmax);                            \\\n      p = src + CLAMP (x, xstart, xstop) * SRC_CHANNELS;        \\\n      while (x < xstart)                                        \\\n        {                                                       \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x++;                                                  \\\n        }                                                       \\\n      p = src + x * SRC_CHANNELS;                               \\\n      while (x < xstop)                                         \\\n        {                                                       \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x++;                                                  \\\n          p += SRC_CHANNELS;                                    \\\n        }                                                       \\\n      p = src + CLAMP (x, 0, src_width - 1) * SRC_CHANNELS;     \\\n      while (x < xmax)                                          \\\n        {                                                       \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x++;                                                  \\\n        }\n\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      const guchar *src;\n      guchar       *dest;\n      y_pos = i + render_y0;\n      y_pos = CLAMP (y_pos, 0, src_height - 1);\n      src  = src_buf + (gsize)y_pos * src_rowstride;\n      dest = dest_buf + (gsize)i * dest_rowstride;\n\n      x = render_x0;\n\n      INNER_LOOP_NOSCALE(src_channels, dest_channels,\n\t  if (src_has_alpha)\n\t    a0 = (p[3] * overall_alpha) / 0xff;\n\t  else\n\t    a0 = overall_alpha;\n\n\t  switch (a0)\n\t    {\n\t    case 0:\n\t      break;\n\t    case 255:\n\t      dest[0] = p[0];\n\t      dest[1] = p[1];\n\t      dest[2] = p[2];\n\t      if (dest_has_alpha)\n\t\tdest[3] = 0xff;\n\t      break;\n\t    default:\n\t      if (dest_has_alpha)\n\t        {\n\t\t  unsigned int w0 = 0xff * a0;\n\t\t  unsigned int w1 = (0xff - a0) * dest[3];\n\t\t  unsigned int w = w0 + w1;\n\n\t\t  dest[0] = (w0 * p[0] + w1 * dest[0]) / w;\n\t\t  dest[1] = (w0 * p[1] + w1 * dest[1]) / w;\n\t\t  dest[2] = (w0 * p[2] + w1 * dest[2]) / w;\n\t\t  dest[3] = w / 0xff;\n\t        }\n\t      else\n\t        {\n\t\t  unsigned int a1 = 0xff - a0;\n\t\t  unsigned int tmp;\n\n\t\t  tmp = a0 * p[0] + a1 * dest[0] + 0x80;\n\t\t  dest[0] = (tmp + (tmp >> 8)) >> 8;\n\t\t  tmp = a0 * p[1] + a1 * dest[1] + 0x80;\n\t\t  dest[1] = (tmp + (tmp >> 8)) >> 8;\n\t\t  tmp = a0 * p[2] + a1 * dest[2] + 0x80;\n\t\t  dest[2] = (tmp + (tmp >> 8)) >> 8;\n\t        }\n\t      break;\n\t    }\n\t);\n    }\n}\n#undef INNER_LOOP_NOSCALE\n\nstatic void\npixops_composite_color_nearest (guchar        *dest_buf,\n\t\t\t\tint            render_x0,\n\t\t\t\tint            render_y0,\n\t\t\t\tint            render_x1,\n\t\t\t\tint            render_y1,\n\t\t\t\tint            dest_rowstride,\n\t\t\t\tint            dest_channels,\n\t\t\t\tgboolean       dest_has_alpha,\n\t\t\t\tconst guchar  *src_buf,\n\t\t\t\tint            src_width,\n\t\t\t\tint            src_height,\n\t\t\t\tint            src_rowstride,\n\t\t\t\tint            src_channels,\n\t\t\t\tgboolean       src_has_alpha,\n\t\t\t\tdouble         scale_x,\n\t\t\t\tdouble         scale_y,\n\t\t\t\tint            overall_alpha,\n\t\t\t\tint            check_x,\n\t\t\t\tint            check_y,\n\t\t\t\tint            check_size,\n\t\t\t\tguint32        color1,\n\t\t\t\tguint32        color2)\n{\n  gint64 i, j;\n  gint64 x;\n  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;\n  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;\n  int r1, g1, b1, r2, g2, b2;\n  int check_shift = get_check_shift (check_size);\n  gint64 xmax, xstart, xstop, x_pos, y_pos;\n  const guchar *p;\n  unsigned int  a0;\n\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      const guchar *src;\n      guchar       *dest;\n      y_pos = ((i + render_y0) * y_step + y_step / 2) >> SCALE_SHIFT;\n      y_pos = CLAMP (y_pos, 0, src_height - 1);\n      src  = src_buf + (gsize)y_pos * src_rowstride;\n      dest = dest_buf + (gsize)i * dest_rowstride;\n\n      x = render_x0 * x_step + x_step / 2;\n      \n      \n      if (((i + check_y) >> check_shift) & 1)\n\t{\n\t  r1 = (color2 & 0xff0000) >> 16;\n\t  g1 = (color2 & 0xff00) >> 8;\n\t  b1 = color2 & 0xff;\n\n\t  r2 = (color1 & 0xff0000) >> 16;\n\t  g2 = (color1 & 0xff00) >> 8;\n\t  b2 = color1 & 0xff;\n\t}\n      else\n\t{\n\t  r1 = (color1 & 0xff0000) >> 16;\n\t  g1 = (color1 & 0xff00) >> 8;\n\t  b1 = color1 & 0xff;\n\n\t  r2 = (color2 & 0xff0000) >> 16;\n\t  g2 = (color2 & 0xff00) >> 8;\n\t  b2 = color2 & 0xff;\n\t}\n\n      j = 0;\n      INNER_LOOP(src_channels, dest_channels,\n\t  if (src_has_alpha)\n\t    a0 = (p[3] * overall_alpha + 0xff) >> 8;\n\t  else\n\t    a0 = overall_alpha;\n\n          switch (a0)\n            {\n            case 0:\n              if (((j + check_x) >> check_shift) & 1)\n                {\n                  dest[0] = r2; \n                  dest[1] = g2; \n                  dest[2] = b2;\n                }\n              else\n                {\n                  dest[0] = r1; \n                  dest[1] = g1; \n                  dest[2] = b1;\n                }\n            break;\n            case 255:\n\t      dest[0] = p[0];\n\t      dest[1] = p[1];\n\t      dest[2] = p[2];\n              break;\n            default:\n\t\t     {\n\t\t       unsigned int tmp;\n              if (((j + check_x) >> check_shift) & 1)\n                {\n                  tmp = ((int) p[0] - r2) * a0;\n                  dest[0] = r2 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[1] - g2) * a0;\n                  dest[1] = g2 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[2] - b2) * a0;\n                  dest[2] = b2 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                }\n              else\n                {\n                  tmp = ((int) p[0] - r1) * a0;\n                  dest[0] = r1 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[1] - g1) * a0;\n                  dest[1] = g1 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[2] - b1) * a0;\n                  dest[2] = b1 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                }\n\t\t     }\n              break;\n            }\n\t  \n\t  if (dest_channels == 4)\n\t    dest[3] = 0xff;\n\n\t\t j++;\n\t);\n    }\n}\n#undef INNER_LOOP\n\nstatic void\ncomposite_pixel (guchar *dest, int dest_x, int dest_channels, int dest_has_alpha,\n\t\t int src_has_alpha, int check_size, guint32 color1, guint32 color2,\n\t\t guint r, guint g, guint b, guint a)\n{\n  if (dest_has_alpha)\n    {\n      unsigned int w0 = a - (a >> 8);\n      unsigned int w1 = ((0xff0000 - a) >> 8) * dest[3];\n      unsigned int w = w0 + w1;\n      \n      if (w != 0)\n\t{\n\t  dest[0] = (r - (r >> 8) + w1 * dest[0]) / w;\n\t  dest[1] = (g - (g >> 8) + w1 * dest[1]) / w;\n\t  dest[2] = (b - (b >> 8) + w1 * dest[2]) / w;\n\t  dest[3] = w / 0xff00;\n\t}\n      else\n\t{\n\t  dest[0] = 0;\n\t  dest[1] = 0;\n\t  dest[2] = 0;\n\t  dest[3] = 0;\n\t}\n    }\n  else\n    {\n      dest[0] = (r + (0xff0000 - a) * dest[0]) / 0xff0000;\n      dest[1] = (g + (0xff0000 - a) * dest[1]) / 0xff0000;\n      dest[2] = (b + (0xff0000 - a) * dest[2]) / 0xff0000;\n    }\n}\n\nstatic guchar *\ncomposite_line (int *weights, int n_x, int n_y,\n\t\tguchar *dest, int dest_x, guchar *dest_end, int dest_channels, int dest_has_alpha,\n\t\tguchar **src, int src_channels, gboolean src_has_alpha,\n\t\tint x_init, int x_step, int src_width,\n\t\tint check_size, guint32 color1, guint32 color2)\n{\n  int x = x_init;\n  int i, j;\n\n  while (dest < dest_end)\n    {\n      int x_scaled = x >> SCALE_SHIFT;\n      unsigned int r = 0, g = 0, b = 0, a = 0;\n      int *pixel_weights;\n      \n      pixel_weights = weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * n_x * n_y;\n      \n      for (i=0; i<n_y; i++)\n\t{\n\t  guchar *q = src[i] + x_scaled * src_channels;\n\t  int *line_weights = pixel_weights + n_x * i;\n\t  \n\t  for (j=0; j<n_x; j++)\n\t    {\n\t      unsigned int ta;\n\n\t      if (src_has_alpha)\n\t\tta = q[3] * line_weights[j];\n\t      else\n\t\tta = 0xff * line_weights[j];\n\t      \n\t      r += ta * q[0];\n\t      g += ta * q[1];\n\t      b += ta * q[2];\n\t      a += ta;\n\n\t      q += src_channels;\n\t    }\n\t}\n\n      if (dest_has_alpha)\n\t{\n\t  unsigned int w0 = a - (a >> 8);\n\t  unsigned int w1 = ((0xff0000 - a) >> 8) * dest[3];\n\t  unsigned int w = w0 + w1;\n\n\t  if (w != 0)\n\t    {\n\t      dest[0] = (r - (r >> 8) + w1 * dest[0]) / w;\n\t      dest[1] = (g - (g >> 8) + w1 * dest[1]) / w;\n\t      dest[2] = (b - (b >> 8) + w1 * dest[2]) / w;\n\t      dest[3] = w / 0xff00;\n\t    }\n\t  else\n\t    {\n\t      dest[0] = 0;\n\t      dest[1] = 0;\n\t      dest[2] = 0;\n\t      dest[3] = 0;\n\t    }\n\t}\n      else\n\t{\n\t  dest[0] = (r + (0xff0000 - a) * dest[0]) / 0xff0000;\n\t  dest[1] = (g + (0xff0000 - a) * dest[1]) / 0xff0000;\n\t  dest[2] = (b + (0xff0000 - a) * dest[2]) / 0xff0000;\n\t}\n      \n      dest += dest_channels;\n      x += x_step;\n    }\n\n  return dest;\n}\n\nstatic guchar *\ncomposite_line_22_4a4 (int *weights, int n_x, int n_y,\n\t\t       guchar *dest, int dest_x, guchar *dest_end, int dest_channels, int dest_has_alpha,\n\t\t       guchar **src, int src_channels, gboolean src_has_alpha,\n\t\t       int x_init, int x_step, int src_width,\n\t\t       int check_size, guint32 color1, guint32 color2)\n{\n  int x = x_init;\n  guchar *src0 = src[0];\n  guchar *src1 = src[1];\n\n  g_return_val_if_fail (src_channels != 3, dest);\n  g_return_val_if_fail (src_has_alpha, dest);\n  \n  while (dest < dest_end)\n    {\n      int x_scaled = x >> SCALE_SHIFT;\n      unsigned int r, g, b, a, ta;\n      int *pixel_weights;\n      guchar *q0, *q1;\n      int w1, w2, w3, w4;\n      \n      q0 = src0 + x_scaled * 4;\n      q1 = src1 + x_scaled * 4;\n      \n      pixel_weights = (int *)((char *)weights +\n\t((x >> (SCALE_SHIFT - SUBSAMPLE_BITS - 4)) & (SUBSAMPLE_MASK << 4)));\n      \n      w1 = pixel_weights[0];\n      w2 = pixel_weights[1];\n      w3 = pixel_weights[2];\n      w4 = pixel_weights[3];\n\n      a = w1 * q0[3];\n      r = a * q0[0];\n      g = a * q0[1];\n      b = a * q0[2];\n\n      ta = w2 * q0[7];\n      r += ta * q0[4];\n      g += ta * q0[5];\n      b += ta * q0[6];\n      a += ta;\n\n      ta = w3 * q1[3];\n      r += ta * q1[0];\n      g += ta * q1[1];\n      b += ta * q1[2];\n      a += ta;\n\n      ta = w4 * q1[7];\n      r += ta * q1[4];\n      g += ta * q1[5];\n      b += ta * q1[6];\n      a += ta;\n\n      dest[0] = ((0xff0000 - a) * dest[0] + r) >> 24;\n      dest[1] = ((0xff0000 - a) * dest[1] + g) >> 24;\n      dest[2] = ((0xff0000 - a) * dest[2] + b) >> 24;\n      dest[3] = a >> 16;\n      \n      dest += 4;\n      x += x_step;\n    }\n\n  return dest;\n}\n\nstatic void\ncomposite_pixel_color (guchar *dest, int dest_x, int dest_channels,\n\t\t       int dest_has_alpha, int src_has_alpha, int check_size,\n\t\t       guint32 color1, guint32 color2, guint r, guint g,\n\t\t       guint b, guint a)\n{\n  int dest_r, dest_g, dest_b;\n  int check_shift = get_check_shift (check_size);\n\n  if ((dest_x >> check_shift) & 1)\n    {\n      dest_r = (color2 & 0xff0000) >> 16;\n      dest_g = (color2 & 0xff00) >> 8;\n      dest_b = color2 & 0xff;\n    }\n  else\n    {\n      dest_r = (color1 & 0xff0000) >> 16;\n      dest_g = (color1 & 0xff00) >> 8;\n      dest_b = color1 & 0xff;\n    }\n\n  dest[0] = ((0xff0000 - a) * dest_r + r) >> 24;\n  dest[1] = ((0xff0000 - a) * dest_g + g) >> 24;\n  dest[2] = ((0xff0000 - a) * dest_b + b) >> 24;\n\n  if (dest_has_alpha)\n    dest[3] = 0xff;\n  else if (dest_channels == 4)\n    dest[3] = a >> 16;\n}\n\nstatic guchar *\ncomposite_line_color (int *weights, int n_x, int n_y, guchar *dest,\n\t\t      int dest_x, guchar *dest_end, int dest_channels,\n\t\t      int dest_has_alpha, guchar **src, int src_channels,\n\t\t      gboolean src_has_alpha, int x_init, int x_step,\n\t\t      int src_width, int check_size, guint32 color1,\n\t\t      guint32 color2)\n{\n  int x = x_init;\n  int i, j;\n  int check_shift = get_check_shift (check_size);\n  int dest_r1, dest_g1, dest_b1;\n  int dest_r2, dest_g2, dest_b2;\n\n  g_return_val_if_fail (check_size != 0, dest);\n\n  dest_r1 = (color1 & 0xff0000) >> 16;\n  dest_g1 = (color1 & 0xff00) >> 8;\n  dest_b1 = color1 & 0xff;\n\n  dest_r2 = (color2 & 0xff0000) >> 16;\n  dest_g2 = (color2 & 0xff00) >> 8;\n  dest_b2 = color2 & 0xff;\n\n  while (dest < dest_end)\n    {\n      int x_scaled = x >> SCALE_SHIFT;\n      unsigned int r = 0, g = 0, b = 0, a = 0;\n      int *pixel_weights;\n      \n      pixel_weights = weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * n_x * n_y;\n\n      for (i=0; i<n_y; i++)\n\t{\n\t  guchar *q = src[i] + x_scaled * src_channels;\n\t  int *line_weights = pixel_weights + n_x * i;\n\t  \n\t  for (j=0; j<n_x; j++)\n\t    {\n\t      unsigned int ta;\n\t      \n\t      if (src_has_alpha)\n\t\tta = q[3] * line_weights[j];\n\t      else\n\t\tta = 0xff * line_weights[j];\n\t\t  \n\t      r += ta * q[0];\n\t      g += ta * q[1];\n\t      b += ta * q[2];\n\t      a += ta;\n\n\t      q += src_channels;\n\t    }\n\t}\n\n      if ((dest_x >> check_shift) & 1)\n\t{\n\t  dest[0] = ((0xff0000 - a) * dest_r2 + r) >> 24;\n\t  dest[1] = ((0xff0000 - a) * dest_g2 + g) >> 24;\n\t  dest[2] = ((0xff0000 - a) * dest_b2 + b) >> 24;\n\t}\n      else\n\t{\n\t  dest[0] = ((0xff0000 - a) * dest_r1 + r) >> 24;\n\t  dest[1] = ((0xff0000 - a) * dest_g1 + g) >> 24;\n\t  dest[2] = ((0xff0000 - a) * dest_b1 + b) >> 24;\n\t}\n\n      if (dest_has_alpha)\n\tdest[3] = 0xff;\n      else if (dest_channels == 4)\n\tdest[3] = a >> 16;\n\t\n      dest += dest_channels;\n      x += x_step;\n      dest_x++;\n    }\n\n  return dest;\n}\n\nstatic void\nscale_pixel (guchar *dest, int dest_x, int dest_channels, int dest_has_alpha,\n\t     int src_has_alpha, int check_size, guint32 color1, guint32 color2,\n\t     guint r, guint g, guint b, guint a)\n{\n  if (src_has_alpha)\n    {\n      if (a)\n\t{\n\t  dest[0] = r / a;\n\t  dest[1] = g / a;\n\t  dest[2] = b / a;\n\t  dest[3] = a >> 16;\n\t}\n      else\n\t{\n\t  dest[0] = 0;\n\t  dest[1] = 0;\n\t  dest[2] = 0;\n\t  dest[3] = 0;\n\t}\n    }\n  else\n    {\n      dest[0] = (r + 0xffffff) >> 24;\n      dest[1] = (g + 0xffffff) >> 24;\n      dest[2] = (b + 0xffffff) >> 24;\n      \n      if (dest_has_alpha)\n\tdest[3] = 0xff;\n    }\n}\n\nstatic guchar *\nscale_line (int *weights, int n_x, int n_y, guchar *dest, int dest_x,\n\t    guchar *dest_end, int dest_channels, int dest_has_alpha,\n\t    guchar **src, int src_channels, gboolean src_has_alpha, int x_init,\n\t    int x_step, int src_width, int check_size, guint32 color1,\n\t    guint32 color2)\n{\n  int x = x_init;\n  int i, j;\n\n  while (dest < dest_end)\n    {\n      int x_scaled = x >> SCALE_SHIFT;\n      int *pixel_weights;\n\n      pixel_weights = weights +\n        ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * n_x * n_y;\n\n      if (src_has_alpha)\n\t{\n\t  unsigned int r = 0, g = 0, b = 0, a = 0;\n\t  for (i=0; i<n_y; i++)\n\t    {\n\t      guchar *q = src[i] + x_scaled * src_channels;\n\t      int *line_weights  = pixel_weights + n_x * i;\n\t      \n\t      for (j=0; j<n_x; j++)\n\t\t{\n\t\t  unsigned int ta;\n\t\t  \n\t\t  ta = q[3] * line_weights[j];\n\t\t  r += ta * q[0];\n\t\t  g += ta * q[1];\n\t\t  b += ta * q[2];\n\t\t  a += ta;\n\t\t  \n\t\t  q += src_channels;\n\t\t}\n\t    }\n\n\t  if (a)\n\t    {\n\t      dest[0] = r / a;\n\t      dest[1] = g / a;\n\t      dest[2] = b / a;\n\t      dest[3] = a >> 16;\n\t    }\n\t  else\n\t    {\n\t      dest[0] = 0;\n\t      dest[1] = 0;\n\t      dest[2] = 0;\n\t      dest[3] = 0;\n\t    }\n\t}\n      else\n\t{\n\t  unsigned int r = 0, g = 0, b = 0;\n\t  for (i=0; i<n_y; i++)\n\t    {\n\t      guchar *q = src[i] + x_scaled * src_channels;\n\t      int *line_weights  = pixel_weights + n_x * i;\n\t      \n\t      for (j=0; j<n_x; j++)\n\t\t{\n\t\t  unsigned int ta = line_weights[j];\n\t\t  \n\t\t  r += ta * q[0];\n\t\t  g += ta * q[1];\n\t\t  b += ta * q[2];\n\n\t\t  q += src_channels;\n\t\t}\n\t    }\n\n\t  dest[0] = (r + 0xffff) >> 16;\n\t  dest[1] = (g + 0xffff) >> 16;\n\t  dest[2] = (b + 0xffff) >> 16;\n\t  \n\t  if (dest_has_alpha)\n\t    dest[3] = 0xff;\n\t}\n\n      dest += dest_channels;\n      \n      x += x_step;\n    }\n\n  return dest;\n}\n\n\nstatic guchar *\nscale_line_22_33 (int *weights, int n_x, int n_y, guchar *dest, int dest_x,\n\t\t  guchar *dest_end, int dest_channels, int dest_has_alpha,\n\t\t  guchar **src, int src_channels, gboolean src_has_alpha,\n\t\t  int x_init, int x_step, int src_width,\n\t\t  int check_size, guint32 color1, guint32 color2)\n{\n  int x = x_init;\n  guchar *src0 = src[0];\n  guchar *src1 = src[1];\n  \n  while (dest < dest_end)\n    {\n      unsigned int r, g, b;\n      int x_scaled = x >> SCALE_SHIFT;\n      int *pixel_weights;\n      guchar *q0, *q1;\n      int w1, w2, w3, w4;\n\n      q0 = src0 + x_scaled * 3;\n      q1 = src1 + x_scaled * 3;\n      \n      pixel_weights = weights +\n        ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * 4;\n\n      w1 = pixel_weights[0];\n      w2 = pixel_weights[1];\n      w3 = pixel_weights[2];\n      w4 = pixel_weights[3];\n\n      r = w1 * q0[0];\n      g = w1 * q0[1];\n      b = w1 * q0[2];\n\n      r += w2 * q0[3];\n      g += w2 * q0[4];\n      b += w2 * q0[5];\n\n      r += w3 * q1[0];\n      g += w3 * q1[1];\n      b += w3 * q1[2];\n\n      r += w4 * q1[3];\n      g += w4 * q1[4];\n      b += w4 * q1[5];\n\n      dest[0] = (r + 0x8000) >> 16;\n      dest[1] = (g + 0x8000) >> 16;\n      dest[2] = (b + 0x8000) >> 16;\n      \n      dest += 3;\n      x += x_step;\n    }\n  \n  return dest;\n}\n\nstatic void\nprocess_pixel (int *weights, int n_x, int n_y, guchar *dest, int dest_x,\n\t       int dest_channels, int dest_has_alpha, guchar **src,\n\t       int src_channels, gboolean src_has_alpha, int x_start,\n\t       int src_width, int check_size, guint32 color1, guint32 color2,\n\t       PixopsPixelFunc pixel_func)\n{\n  unsigned int r = 0, g = 0, b = 0, a = 0;\n  int i, j;\n  \n  for (i=0; i<n_y; i++)\n    {\n      int *line_weights  = weights + n_x * i;\n\n      for (j=0; j<n_x; j++)\n\t{\n\t  unsigned int ta;\n\t  guchar *q;\n\n\t  if (x_start + j < 0)\n\t    q = src[i];\n\t  else if (x_start + j < src_width)\n\t    q = src[i] + (x_start + j) * src_channels;\n\t  else\n\t    q = src[i] + (src_width - 1) * src_channels;\n\n\t  if (src_has_alpha)\n\t    ta = q[3] * line_weights[j];\n\t  else\n\t    ta = 0xff * line_weights[j];\n\n\t  r += ta * q[0];\n\t  g += ta * q[1];\n\t  b += ta * q[2];\n\t  a += ta;\n\t}\n    }\n\n  (*pixel_func) (dest, dest_x, dest_channels, dest_has_alpha, src_has_alpha,\n    check_size, color1, color2, r, g, b, a);\n}\n\nstatic void \ncorrect_total (int    *weights, \n               int    n_x, \n               int    n_y,\n               int    total, \n               double overall_alpha)\n{\n  int correction = (int)(0.5 + 65536 * overall_alpha) - total;\n  int remaining, c, d, i;\n  \n  if (correction != 0)\n    {\n      remaining = correction;\n      for (d = 1, c = correction; c != 0 && remaining != 0; d++, c = correction / d) \n\tfor (i = n_x * n_y - 1; i >= 0 && c != 0 && remaining != 0; i--) \n\t  if (*(weights + i) + c >= 0) \n\t    {\n\t      *(weights + i) += c;\n\t      remaining -= c;\n\t      if ((0 < remaining && remaining < c) ||\n\t\t  (0 > remaining && remaining > c))\n\t\tc = remaining;\n\t    }\n    }\n}\n\nstatic int *\nmake_filter_table (PixopsFilter *filter)\n{\n  int i_offset, j_offset;\n  int n_x = filter->x.n;\n  int n_y = filter->y.n;\n  int *weights;\n\n  /* check n_x doesn't overflow */\n  if (G_MAXINT / (SUBSAMPLE * SUBSAMPLE) < n_x)\n    return NULL;\n\n  /* check n_y doesn't overflow */\n  if (G_MAXINT / (SUBSAMPLE * SUBSAMPLE * n_x) < n_y)\n    return NULL;\n\n  weights = g_try_new (int, SUBSAMPLE * SUBSAMPLE * n_x * n_y);\n  if (!weights)\n    return NULL; /* overflow, bail */\n\n  for (i_offset=0; i_offset < SUBSAMPLE; i_offset++)\n    for (j_offset=0; j_offset < SUBSAMPLE; j_offset++)\n      {\n        double weight;\n        int *pixel_weights = weights + ((i_offset*SUBSAMPLE) + j_offset) * n_x * n_y;\n        int total = 0;\n        int i, j;\n\n        for (i=0; i < n_y; i++)\n          for (j=0; j < n_x; j++)\n            {\n              weight = filter->x.weights[(j_offset * n_x) + j] *\n                       filter->y.weights[(i_offset * n_y) + i] *\n                       filter->overall_alpha * 65536 + 0.5;\n\n              total += (int)weight;\n\n              *(pixel_weights + n_x * i + j) = weight;\n            }\n\n        correct_total (pixel_weights, n_x, n_y, total, filter->overall_alpha);\n      }\n\n  return weights;\n}\n\nstatic void\npixops_process (guchar         *dest_buf,\n\t\tint             render_x0,\n\t\tint             render_y0,\n\t\tint             render_x1,\n\t\tint             render_y1,\n\t\tint             dest_rowstride,\n\t\tint             dest_channels,\n\t\tgboolean        dest_has_alpha,\n\t\tconst guchar   *src_buf,\n\t\tint             src_width,\n\t\tint             src_height,\n\t\tint             src_rowstride,\n\t\tint             src_channels,\n\t\tgboolean        src_has_alpha,\n\t\tdouble          scale_x,\n\t\tdouble          scale_y,\n\t\tint             check_x,\n\t\tint             check_y,\n\t\tint             check_size,\n\t\tguint32         color1,\n\t\tguint32         color2,\n\t\tPixopsFilter   *filter,\n\t\tPixopsLineFunc  line_func,\n\t\tPixopsPixelFunc pixel_func)\n{\n  gint64 i, j;\n  gint64 x, y;\t\t\t/* X and Y position in source (fixed_point) */\n\n  guchar **line_bufs;\n  int *filter_weights;\n\n  gint64 x_step;\n  gint64 y_step;\n\n  int check_shift;\n  gint64 scaled_x_offset;\n\n  gint64 run_end_x;\n  gint64 run_end_index;\n\n  x_step = (1 << SCALE_SHIFT) / scale_x; /* X step in source (fixed point) */\n  y_step = (1 << SCALE_SHIFT) / scale_y; /* Y step in source (fixed point) */\n\n  if (x_step == 0 || y_step == 0)\n    return; /* overflow, bail out */\n\n  filter_weights = make_filter_table (filter);\n  if (!filter_weights)\n    return; /* overflow, bail out */\n\n  line_bufs = g_new (guchar *, filter->y.n);\n\n  check_shift = check_size ? get_check_shift (check_size) : 0;\n\n  scaled_x_offset = floor (filter->x.offset * (1 << SCALE_SHIFT));\n\n  /* Compute the index where we run off the end of the source buffer. The\n   * furthest source pixel we access at index i is:\n   *\n   *  ((render_x0 + i) * x_step + scaled_x_offset) >> SCALE_SHIFT + filter->x.n - 1\n   *\n   * So, run_end_index is the smallest i for which this pixel is src_width,\n   * i.e, for which:\n   *\n   *  (i + render_x0) * x_step >= ((src_width - filter->x.n + 1) << SCALE_SHIFT) - scaled_x_offset\n   *\n   */\n#define MYDIV(a,b) ((a) > 0 ? (a) / (b) : ((a) - (b) + 1) / (b))    /* Division so that -1/5 = -1 */\n\n  run_end_x = (((src_width - filter->x.n + 1) << SCALE_SHIFT) - scaled_x_offset);\n  run_end_index = MYDIV (run_end_x + x_step - 1, x_step) - render_x0;\n  run_end_index = MIN (run_end_index, render_x1 - render_x0);\n\n  y = render_y0 * y_step + floor (filter->y.offset * (1 << SCALE_SHIFT));\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      int dest_x;\n      int y_start = y >> SCALE_SHIFT;\n      int x_start;\n      int *run_weights = filter_weights +\n                         ((y >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) *\n                         filter->x.n * filter->y.n * SUBSAMPLE;\n      guchar *new_outbuf;\n      guint32 tcolor1, tcolor2;\n\n      guchar *outbuf = dest_buf + (gsize)dest_rowstride * i;\n      guchar *outbuf_end = outbuf + dest_channels * (render_x1 - render_x0);\n\n      if (((i + check_y) >> check_shift) & 1)\n\t{\n\t  tcolor1 = color2;\n\t  tcolor2 = color1;\n\t}\n      else\n\t{\n\t  tcolor1 = color1;\n\t  tcolor2 = color2;\n\t}\n\n      for (j=0; j<filter->y.n; j++)\n\t{\n\t  if (y_start <  0)\n\t    line_bufs[j] = (guchar *)src_buf;\n\t  else if (y_start < src_height)\n\t    line_bufs[j] = (guchar *)src_buf + (gsize)src_rowstride * y_start;\n\t  else\n\t    line_bufs[j] = (guchar *)src_buf + (gsize)src_rowstride * (src_height - 1);\n\n\t  y_start++;\n\t}\n\n      dest_x = check_x;\n      x = render_x0 * x_step + scaled_x_offset;\n      x_start = x >> SCALE_SHIFT;\n\n      while (x_start < 0 && outbuf < outbuf_end)\n\t{\n\t  process_pixel (run_weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * (filter->x.n * filter->y.n), filter->x.n, filter->y.n,\n\t\t\t outbuf, dest_x, dest_channels, dest_has_alpha,\n\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t x >> SCALE_SHIFT, src_width,\n\t\t\t check_size, tcolor1, tcolor2, pixel_func);\n\n\t  x += x_step;\n\t  x_start = x >> SCALE_SHIFT;\n\t  dest_x++;\n\t  outbuf += dest_channels;\n\t}\n\n      new_outbuf = (*line_func) (run_weights, filter->x.n, filter->y.n,\n\t\t\t\t outbuf, dest_x, dest_buf + (gsize)dest_rowstride *\n\t\t\t\t i + run_end_index * dest_channels,\n\t\t\t\t dest_channels, dest_has_alpha,\n\t\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t\t x, x_step, src_width, check_size, tcolor1,\n\t\t\t\t tcolor2);\n\n      dest_x += (new_outbuf - outbuf) / dest_channels;\n\n      x = (dest_x - check_x + render_x0) * x_step + scaled_x_offset;\n      outbuf = new_outbuf;\n\n      while (outbuf < outbuf_end)\n\t{\n\t  process_pixel (run_weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * (filter->x.n * filter->y.n), filter->x.n, filter->y.n,\n\t\t\t outbuf, dest_x, dest_channels, dest_has_alpha,\n\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t x >> SCALE_SHIFT, src_width,\n\t\t\t check_size, tcolor1, tcolor2, pixel_func);\n\n\t  x += x_step;\n\t  dest_x++;\n\t  outbuf += dest_channels;\n\t}\n\n      y += y_step;\n    }\n\n  g_free (line_bufs);\n  g_free (filter_weights);\n}\n\n/* Compute weights for reconstruction by replication followed by\n * sampling with a box filter\n */\nstatic gboolean\ntile_make_weights (PixopsFilterDimension *dim,\n\t\t   double                 scale)\n{\n  int n = ceil (1 / scale + 1);\n  double *pixel_weights;\n  int offset;\n  int i;\n\n  pixel_weights = g_try_malloc_n (sizeof (double) * SUBSAMPLE, n);\n  if (pixel_weights == NULL)\n    return FALSE;\n\n  dim->n = n;\n  dim->offset = 0;\n  dim->weights = pixel_weights;\n\n  for (offset = 0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset / SUBSAMPLE;\n      double a = x + 1 / scale;\n\n      for (i = 0; i < n; i++)\n        {\n          if (i < x)\n            {\n              if (i + 1 > x)\n                *(pixel_weights++)  = (MIN (i + 1, a) - x) * scale;\n              else\n                *(pixel_weights++) = 0;\n            }\n          else\n            {\n              if (a > i)\n                *(pixel_weights++)  = (MIN (i + 1, a) - i) * scale;\n              else\n                *(pixel_weights++) = 0;\n            }\n       }\n    }\n\n  return TRUE;\n}\n\n/* Compute weights for a filter that, for minification\n * is the same as 'tiles', and for magnification, is bilinear\n * reconstruction followed by a sampling with a delta function.\n */\nstatic gboolean\nbilinear_magnify_make_weights (PixopsFilterDimension *dim,\n\t\t\t       double                 scale)\n{\n  double *pixel_weights;\n  int n;\n  int offset;\n  int i;\n\n  if (scale > 1.0)            /* Linear */\n    {\n      n = 2;\n      dim->offset = 0.5 * (1 / scale - 1);\n    }\n  else                          /* Tile */\n    {\n      n = ceil (1.0 + 1.0 / scale);\n      dim->offset = 0.0;\n    }\n\n  dim->n = n;\n  dim->weights = g_try_malloc_n (sizeof (double) * SUBSAMPLE, n);\n  if (dim->weights == NULL)\n    return FALSE;\n\n  pixel_weights = dim->weights;\n\n  for (offset=0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset / SUBSAMPLE;\n\n      if (scale > 1.0)      /* Linear */\n        {\n          for (i = 0; i < n; i++)\n            *(pixel_weights++) = (((i == 0) ? (1 - x) : x) / scale) * scale;\n        }\n      else                  /* Tile */\n        {\n          double a = x + 1 / scale;\n\n          /*           x\n           * ---------|--.-|----|--.-|-------  SRC\n           * ------------|---------|---------  DEST\n           */\n          for (i = 0; i < n; i++)\n            {\n              if (i < x)\n                {\n                  if (i + 1 > x)\n                    *(pixel_weights++) = (MIN (i + 1, a) - x) * scale;\n                  else\n                    *(pixel_weights++) = 0;\n                }\n              else\n                {\n                  if (a > i)\n                    *(pixel_weights++) = (MIN (i + 1, a) - i) * scale;\n                  else\n                    *(pixel_weights++) = 0;\n                }\n            }\n        }\n    }\n\n  return TRUE;\n}\n\n/* Computes the integral from b0 to b1 of\n *\n * f(x) = x; 0 <= x < 1\n * f(x) = 0; otherwise\n *\n * We combine two of these to compute the convolution of\n * a box filter with a triangular spike.\n */\nstatic double\nlinear_box_half (double b0, double b1)\n{\n  double a0, a1;\n  double x0, x1;\n\n  a0 = 0.;\n  a1 = 1.;\n\n  if (a0 < b0)\n    {\n      if (a1 > b0)\n        {\n          x0 = b0;\n          x1 = MIN (a1, b1);\n        }\n      else\n        return 0;\n    }\n  else\n    {\n      if (b1 > a0)\n        {\n          x0 = a0;\n          x1 = MIN (a1, b1);\n        }\n      else\n        return 0;\n    }\n\n  return 0.5 * (x1*x1 - x0*x0);\n}\n\n/* Compute weights for reconstructing with bilinear\n * interpolation, then sampling with a box filter\n */\nstatic gboolean\nbilinear_box_make_weights (PixopsFilterDimension *dim,\n\t\t\t   double                 scale)\n{\n  int n = ceil (1/scale + 3.0);\n  double *pixel_weights;\n  double w;\n  int offset, i;\n\n  pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n  if (pixel_weights == NULL)\n    return FALSE;\n\n  dim->offset = -1.0;\n  dim->n = n;\n  dim->weights = pixel_weights;\n\n  for (offset = 0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset / SUBSAMPLE;\n      double a = x + 1 / scale;\n\n      for (i = 0; i < n; i++)\n        {\n          w  = linear_box_half (0.5 + i - a, 0.5 + i - x);\n          w += linear_box_half (1.5 + x - i, 1.5 + a - i);\n      \n          *(pixel_weights++) = w * scale;\n        }\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nmake_weights (PixopsFilter     *filter,\n\t      PixopsInterpType  interp_type,\t      \n\t      double            scale_x,\n\t      double            scale_y)\n{\n  switch (interp_type)\n    {\n    case PIXOPS_INTERP_NEAREST:\n    default:\n      g_assert_not_reached ();\n      return FALSE;\n\n    case PIXOPS_INTERP_TILES:\n      if (!tile_make_weights (&filter->x, scale_x))\n        return FALSE;\n      if (!tile_make_weights (&filter->y, scale_y))\n        {\n          g_free (filter->x.weights);\n          return FALSE;\n        }\n      return TRUE;\n      \n    case PIXOPS_INTERP_BILINEAR:\n      if (!bilinear_magnify_make_weights (&filter->x, scale_x))\n        return FALSE;\n      if (!bilinear_magnify_make_weights (&filter->y, scale_y))\n        {\n          g_free (filter->x.weights);\n          return FALSE;\n        }\n      return TRUE;\n      \n    case PIXOPS_INTERP_HYPER:\n      if (!bilinear_box_make_weights (&filter->x, scale_x))\n        return FALSE;\n      if (!bilinear_box_make_weights (&filter->y, scale_y))\n        {\n          g_free (filter->x.weights);\n          return FALSE;\n        }\n      return TRUE;\n    }\n}\n\n/* Two-step scaler begins */\n\n/* make_filter_table() bloats out in VM usage and consumes 100% CPU for\n * tens of seconds when downscaling by a large factor.\n * https://bugzilla.gnome.org/show_bug.cgi?id=80925\n * We work round this by doing extreme reductions in two steps.\n *\n * The excessive CPU usage is accompanied by an excessive RAM usage because\n * make_weights() allocates two arrays of weights proportional in size to\n * n_x = (1 / scale_x + 3) and n_y = (1 / scale_y + 3),  then make_filter_table()\n * allocates and fills an array of SUBSAMPLE * SUBSAMPLE * n_x * n_y doubles.\n * Empirically, on machines with plenty of RAM, the execution time slopes upward\n * when n_filters > 1000.\n * SUBSAMPLE is 16 so each filter takes 16 x 16 doubles (8 bytes) = 2kb RAM.\n * Limiting it to 1000 filters limits the scaler's RAM consumption to about 2MB\n * which should be OK on machines with relatively little memory.\n *\n * GDK_INTER_BILINEAR, GDK_INTERP_TILES and GDK_INTER_HYPER all have\n * similar symptoms; only GDK_INTERP_NEAREST does not need this trick.\n **/\n#define MAX_FILTERS 1000\n\n/* Check whether prescaling is necessary to avoid the bug */\nstatic gboolean\nneed_to_prescale (double           scale_x,\n\t\t  double           scale_y,\n\t\t  PixopsInterpType interp_type)\n{\n  int n_x, n_y; /* See make_weights() */\n\n  /* The testsuite sets this to compare the results with and without it. */\n  if (g_getenv (\"GDK_PIXBUF_DISABLE_TWO_STEP_SCALER\"))\n    return FALSE;\n\n  /* Calculate the number of weights created in make_weights() */\n  switch (interp_type) {\n  case PIXOPS_INTERP_HYPER:\n    n_x = ceil (1 / scale_x + 3);\n    n_y = ceil (1 / scale_y + 3);\n    break;\n  case PIXOPS_INTERP_TILES:\n  case PIXOPS_INTERP_BILINEAR:\n    n_x = ceil (1 / scale_x + 1);\n    n_y = ceil (1 / scale_y + 1);\n    break;\n  case PIXOPS_INTERP_NEAREST:\n    /* Doesn't need the optimization */\n    return FALSE;\n  default:\n    g_assert_not_reached ();\n  }\n\n  /* Limit the number of filters created by make_filter_table(). */\n  return (n_x * n_y > MAX_FILTERS);\n}\n\n/* Prescale the source image.\n * If successful, it changes the source buffer's parameters to reflect the\n * half-scaled image and the scaling factors to reflect the scaling left to do.\n * It returns a pointer to the new image data or NULL, so that the caller knows\n * whether they have to free the temporary buffer or not.\n */\nstatic guchar *\nprescale (const guchar     **src_bufp,\n\t  int               *src_widthp,\n\t  int               *src_heightp,\n\t  int               *src_rowstridep,\n\t  int                src_channels,\n\t  gboolean           src_has_alpha,\n\t  double            *scale_xp,\n\t  double            *scale_yp,\n\t  PixopsInterpType   interp_type)\n{\n  /* Give local names to parameters that may be modified */\n  const guchar *src_buf = *src_bufp;\n  int           src_width = *src_widthp;\n  int           src_height = *src_heightp;\n  int           src_rowstride = *src_rowstridep;\n  double        scale_x = *scale_xp;\n  double        scale_y = *scale_yp;\n\n  /* How much we prescale each axis by */\n  double prescale_x, prescale_y;\n\n  /* The prescaled image */\n  int tmp_width, tmp_height;\n  int tmp_rowstride;\n  int tmp_channels;\n  gboolean tmp_has_alpha;\n  guchar *tmp_buf;\n\n  /* The time taken by make_filter_table() is roughly proportional to\n   * 1/scale_x * 1/scale_y, i.e. to the area reduction factor, so we\n   * reduce the image in two steps, each of which reduces the total area\n   * by the same factor. */\n  prescale_x = sqrt (scale_x);\n  prescale_y = sqrt (scale_y);\n\n  /* Scale the whole source image into a top-left-aligned temporary pixbuf.\n   * render_[xy][01] are done in the final scaling, not here, as they are\n   * measured in the coordinate system of the scaled image. */\n  tmp_width = lrint (src_width * prescale_x);\n  tmp_height = lrint (src_height * prescale_y);\n\n  /* We are below the gdk_ interface, so create the temp image manually.\n   * Code copied from gdk_pixbuf_new() */\n  tmp_channels = src_channels;\n  tmp_has_alpha = src_has_alpha;\n  tmp_rowstride = ((tmp_width * tmp_channels) + 3) & ~3;\n  tmp_buf = g_try_malloc_n (tmp_height, tmp_rowstride);\n  if (!tmp_buf)\n    return NULL; /* Skip the prescaling */\n\n  /* Prescale to an intermediate size */\n  _pixops_scale (tmp_buf, tmp_width, tmp_height, tmp_rowstride,\n\t\t tmp_channels, tmp_has_alpha, src_buf, src_width,\n\t\t src_height, src_rowstride, src_channels, src_has_alpha,\n\t\t 0, 0, tmp_width, tmp_height, 0.0, 0.0,\n\t\t prescale_x, prescale_y,\n\t\t interp_type);\n\n  /* The second call to the scaler reads from the prescaled image */\n  *src_bufp = tmp_buf;\n  *src_widthp = tmp_width;\n  *src_heightp = tmp_height;\n  *src_rowstridep = tmp_rowstride;\n\n  /* Calculate how much scaling is left to do */\n  *scale_xp /= prescale_x;\n  *scale_yp /= prescale_y;\n\n  return tmp_buf;\n}\n/* End of two-step scaler */\n\nstatic void\n_pixops_composite_color_real (guchar          *dest_buf,\n\t\t\t      int              render_x0,\n\t\t\t      int              render_y0,\n\t\t\t      int              render_x1,\n\t\t\t      int              render_y1,\n\t\t\t      int              dest_rowstride,\n\t\t\t      int              dest_channels,\n\t\t\t      gboolean         dest_has_alpha,\n\t\t\t      const guchar    *src_buf,\n\t\t\t      int              src_width,\n\t\t\t      int              src_height,\n\t\t\t      int              src_rowstride,\n\t\t\t      int              src_channels,\n\t\t\t      gboolean         src_has_alpha,\n\t\t\t      double           scale_x,\n\t\t\t      double           scale_y,\n\t\t\t      PixopsInterpType interp_type,\n\t\t\t      int              overall_alpha,\n\t\t\t      int              check_x,\n\t\t\t      int              check_y,\n\t\t\t      int              check_size,\n\t\t\t      guint32          color1,\n\t\t\t      guint32          color2)\n{\n  PixopsFilter filter;\n  PixopsLineFunc line_func;\n  guchar *tmp_buf = NULL;\n  \n  g_return_if_fail (!(dest_channels == 3 && dest_has_alpha));\n  g_return_if_fail (!(src_channels == 3 && src_has_alpha));\n\n  if (scale_x == 0 || scale_y == 0)\n    return;\n\n  if (interp_type == PIXOPS_INTERP_NEAREST)\n    {\n      pixops_composite_color_nearest (dest_buf, render_x0, render_y0,\n\t\t\t\t      render_x1, render_y1, dest_rowstride,\n\t\t\t\t      dest_channels, dest_has_alpha, src_buf,\n\t\t\t\t      src_width, src_height, src_rowstride,\n\t\t\t\t      src_channels, src_has_alpha, scale_x,\n\t\t\t\t      scale_y, overall_alpha, check_x, check_y,\n\t\t\t\t      check_size, color1, color2);\n      return;\n    }\n\n  if (need_to_prescale (scale_x, scale_y, interp_type))\n    tmp_buf = prescale (&src_buf, &src_width, &src_height, &src_rowstride,\n\t\t\tsrc_channels, src_has_alpha,\n\t\t\t&scale_x, &scale_y, interp_type);\n  \n  filter.overall_alpha = overall_alpha / 255.;\n  if (!make_weights (&filter, interp_type, scale_x, scale_y))\n    return;\n\n  line_func = composite_line_color;\n  \n  pixops_process (dest_buf, render_x0, render_y0, render_x1, render_y1,\n\t\t  dest_rowstride, dest_channels, dest_has_alpha,\n\t\t  src_buf, src_width, src_height, src_rowstride, src_channels,\n\t\t  src_has_alpha, scale_x, scale_y, check_x, check_y, check_size, color1, color2,\n\t\t  &filter, line_func, composite_pixel_color);\n\n  g_free (filter.x.weights);\n  g_free (filter.y.weights);\n  if (tmp_buf)\n    g_free (tmp_buf);\n}\n\nvoid\n_pixops_composite_color (guchar          *dest_buf,\n\t\t\t int              dest_width,\n\t\t\t int              dest_height,\n\t\t\t int              dest_rowstride,\n\t\t\t int              dest_channels,\n\t\t\t gboolean         dest_has_alpha,\n\t\t\t const guchar    *src_buf,\n\t\t\t int              src_width,\n\t\t\t int              src_height,\n\t\t\t int              src_rowstride,\n\t\t\t int              src_channels,\n\t\t\t gboolean         src_has_alpha,\n\t\t\t int              dest_x,\n\t\t\t int              dest_y,\n\t\t\t int              dest_region_width,\n\t\t\t int              dest_region_height,\n\t\t\t double           offset_x,\n\t\t\t double           offset_y,\n\t\t\t double           scale_x,\n\t\t\t double           scale_y,\n\t\t\t PixopsInterpType interp_type,\n\t\t\t int              overall_alpha,\n\t\t\t int              check_x,\n\t\t\t int              check_y,\n\t\t\t int              check_size,\n\t\t\t guint32          color1,\n\t\t\t guint32          color2)\n{\n  guchar *new_dest_buf;\n  int render_x0;\n  int render_y0;\n  int render_x1;\n  int render_y1;\n\n  if (!src_has_alpha && overall_alpha == 255)\n    {\n      _pixops_scale (dest_buf, dest_width, dest_height, dest_rowstride,\n\t\t     dest_channels, dest_has_alpha, src_buf, src_width,\n\t\t     src_height, src_rowstride, src_channels, src_has_alpha,\n\t\t     dest_x, dest_y, dest_region_width, dest_region_height,\n\t\t     offset_x, offset_y, scale_x, scale_y, interp_type);\n      return;\n    }\n\n  new_dest_buf = dest_buf + dest_y * dest_rowstride + dest_x *\n                 dest_channels;\n  render_x0 = dest_x - offset_x;\n  render_y0 = dest_y - offset_y;\n  render_x1 = dest_x + dest_region_width  - offset_x;\n  render_y1 = dest_y + dest_region_height - offset_y;\n\n  _pixops_composite_color_real (new_dest_buf, render_x0, render_y0, render_x1,\n\t\t\t\trender_y1, dest_rowstride, dest_channels,\n\t\t\t\tdest_has_alpha, src_buf, src_width,\n\t\t\t\tsrc_height, src_rowstride, src_channels,\n\t\t\t\tsrc_has_alpha, scale_x, scale_y,\n\t\t\t\t(PixopsInterpType)interp_type, overall_alpha,\n\t\t\t\tcheck_x, check_y, check_size, color1, color2);\n}\n\n/**\n * _pixops_composite_real:\n * @dest_buf: pointer to location to store result\n * @render_x0: x0 of region of scaled source to store into @dest_buf\n * @render_y0: y0 of region of scaled source to store into @dest_buf\n * @render_x1: x1 of region of scaled source to store into @dest_buf\n * @render_y1: y1 of region of scaled source to store into @dest_buf\n * @dest_rowstride: rowstride of @dest_buf\n * @dest_channels: number of channels in @dest_buf\n * @dest_has_alpha: whether @dest_buf has alpha\n * @src_buf: pointer to source pixels\n * @src_width: width of source (used for clipping)\n * @src_height: height of source (used for clipping)\n * @src_rowstride: rowstride of source\n * @src_channels: number of channels in @src_buf\n * @src_has_alpha: whether @src_buf has alpha\n * @scale_x: amount to scale source by in X direction\n * @scale_y: amount to scale source by in Y direction\n * @interp_type: type of enumeration\n * @overall_alpha: overall alpha factor to multiply source by\n * \n * Scale source buffer by scale_x / scale_y, then composite a given rectangle\n * of the result into the destination buffer.\n **/\nstatic void\n_pixops_composite_real (guchar          *dest_buf,\n\t\t\tint              render_x0,\n\t\t\tint              render_y0,\n\t\t\tint              render_x1,\n\t\t\tint              render_y1,\n\t\t\tint              dest_rowstride,\n\t\t\tint              dest_channels,\n\t\t\tgboolean         dest_has_alpha,\n\t\t\tconst guchar    *src_buf,\n\t\t\tint              src_width,\n\t\t\tint              src_height,\n\t\t\tint              src_rowstride,\n\t\t\tint              src_channels,\n\t\t\tgboolean         src_has_alpha,\n\t\t\tdouble           scale_x,\n\t\t\tdouble           scale_y,\n\t\t\tPixopsInterpType interp_type,\n\t\t\tint              overall_alpha)\n{\n  PixopsFilter filter;\n  PixopsLineFunc line_func;\n  guchar *tmp_buf = NULL;\n  \n  g_return_if_fail (!(dest_channels == 3 && dest_has_alpha));\n  g_return_if_fail (!(src_channels == 3 && src_has_alpha));\n\n  if (scale_x == 0 || scale_y == 0)\n    return;\n\n  if (interp_type == PIXOPS_INTERP_NEAREST)\n    {\n      if (scale_x == 1.0 && scale_y == 1.0)\n\tpixops_composite_nearest_noscale (dest_buf, render_x0, render_y0, render_x1, render_y1,\n\t\t\t\t\t  dest_rowstride, dest_channels, dest_has_alpha,\n\t\t\t\t\t  src_buf, src_width, src_height, src_rowstride, src_channels,\n\t\t\t\t\t  src_has_alpha, overall_alpha);\n      else\n\tpixops_composite_nearest (dest_buf, render_x0, render_y0, render_x1, render_y1,\n\t\t\t\t  dest_rowstride, dest_channels, dest_has_alpha,\n\t\t\t\t  src_buf, src_width, src_height, src_rowstride, src_channels,\n\t\t\t\t  src_has_alpha, scale_x, scale_y, overall_alpha);\n      return;\n    }\n\n  if (need_to_prescale (scale_x, scale_y, interp_type))\n    tmp_buf = prescale (&src_buf, &src_width, &src_height, &src_rowstride,\n\t\t\tsrc_channels, src_has_alpha,\n\t\t\t&scale_x, &scale_y, interp_type);\n  \n  filter.overall_alpha = overall_alpha / 255.;\n  if (!make_weights (&filter, interp_type, scale_x, scale_y))\n    return;\n\n  if (filter.x.n == 2 && filter.y.n == 2 && dest_channels == 4 &&\n      src_channels == 4 && src_has_alpha && !dest_has_alpha)\n    line_func = composite_line_22_4a4;\n  else\n    line_func = composite_line;\n  \n  pixops_process (dest_buf, render_x0, render_y0, render_x1, render_y1,\n\t\t  dest_rowstride, dest_channels, dest_has_alpha,\n\t\t  src_buf, src_width, src_height, src_rowstride, src_channels,\n\t\t  src_has_alpha, scale_x, scale_y, 0, 0, 0, 0, 0, \n\t\t  &filter, line_func, composite_pixel);\n\n  g_free (filter.x.weights);\n  g_free (filter.y.weights);\n  if (tmp_buf)\n    g_free (tmp_buf);\n}\n\nvoid\n_pixops_composite (guchar          *dest_buf,\n                   int              dest_width,\n                   int              dest_height,\n                   int              dest_rowstride,\n                   int              dest_channels,\n                   int              dest_has_alpha,\n                   const guchar    *src_buf,\n                   int              src_width,\n                   int              src_height,\n                   int              src_rowstride,\n                   int              src_channels,\n                   int              src_has_alpha,\n                   int              dest_x,\n                   int              dest_y,\n                   int              dest_region_width,\n                   int              dest_region_height,\n                   double           offset_x,\n                   double           offset_y,\n                   double           scale_x,\n                   double           scale_y,\n                   PixopsInterpType interp_type,\n                   int              overall_alpha)\n{\n  guchar *new_dest_buf;\n  int render_x0;\n  int render_y0;\n  int render_x1;\n  int render_y1;\n\n  if (!src_has_alpha && overall_alpha == 255)\n    {\n      _pixops_scale (dest_buf, dest_width, dest_height, dest_rowstride,\n\t\t     dest_channels, dest_has_alpha, src_buf, src_width,\n\t\t     src_height, src_rowstride, src_channels, src_has_alpha,\n\t\t     dest_x, dest_y, dest_region_width, dest_region_height,\n\t\t     offset_x, offset_y, scale_x, scale_y, interp_type);\n      return;\n    }\n\n#ifdef USE_MEDIALIB\n  pixops_medialib_composite (dest_buf, dest_width, dest_height, dest_rowstride,\n                             dest_channels, dest_has_alpha, src_buf,\n                             src_width, src_height, src_rowstride,\n                             src_channels, src_has_alpha, dest_x, dest_y,\n                             dest_region_width, dest_region_height, offset_x,\n\t\t\t     offset_y, scale_x, scale_y,\n                             (PixopsInterpType)interp_type, overall_alpha);\n  return;\n#endif\n\n  new_dest_buf = dest_buf + (gsize)dest_y * dest_rowstride + (gsize)dest_x * dest_channels;\n  render_x0 = dest_x - offset_x;\n  render_y0 = dest_y - offset_y;\n  render_x1 = dest_x + dest_region_width  - offset_x;\n  render_y1 = dest_y + dest_region_height - offset_y;\n\n  _pixops_composite_real (new_dest_buf, render_x0, render_y0, render_x1,\n\t\t\t  render_y1, dest_rowstride, dest_channels,\n\t\t\t  dest_has_alpha, src_buf, src_width, src_height,\n\t\t\t  src_rowstride, src_channels, src_has_alpha, scale_x,\n\t\t\t  scale_y, (PixopsInterpType)interp_type,\n\t\t\t  overall_alpha);\n}\n\n#ifdef USE_MEDIALIB\nstatic void\nmedialib_get_interpolation (mlInterp * ml_interp,\n                            PixopsInterpType interp_type,\n                            double scale_x,\n                            double scale_y,\n                            double overall_alpha)\n{\n  mlib_s32 leftPadding, topPadding;\n  ml_interp->interp_table = NULL;\n\n /*\n  * medialib 2.1 and later supports scaling with user-defined interpolation\n  * tables, so this logic is used.  \n  *\n  * bilinear_magnify_make_weights builds an interpolation table of size 2x2 if\n  * the scale factor >= 1.0 and \"ceil (1.0 + 1.0/scale)\" otherwise.  These map\n  * most closely to MLIB_BILINEAR, which uses an interpolation table of size\n  * 2x2.\n  *\n  * tile_make_weights builds an interpolation table of size 2x2 if the scale\n  * factor >= 1.0 and \"ceil (1.0 + 1.0/scale)\" otherwise.  These map most\n  * closely to MLIB_BILINEAR, which uses an interpolation table of size 2x2.\n  *\n  * bilinear_box_make_weights builds an interpolation table of size 4x4 if the\n  * scale factor >= 1.0 and \"ceil (1.0 + 1.0/scale)\" otherwise.  These map most\n  * closely to MLIB_BICUBIC, which uses an interpolation table of size 4x4.\n  *\n  * PIXOPS_INTERP_NEAREST calls pixops_scale_nearest which does not use an\n  * interpolation table.  This maps to MLIB_NEAREST.\n  */\n  switch (interp_type)\n    {\n    case PIXOPS_INTERP_BILINEAR:\n      bilinear_magnify_make_weights (&(ml_interp->po_filter.x), scale_x);\n      bilinear_magnify_make_weights (&(ml_interp->po_filter.y), scale_y);\n      leftPadding = 0;\n      topPadding  = 0;\n\n      if (scale_x <= 1.0)\n          ml_interp->tx = 0.5 * (1 - scale_x);\n      else\n          ml_interp->tx = 0.0;\n\n      if (scale_y <= 1.0)\n          ml_interp->ty = 0.5 * (1 - scale_y);\n      else\n          ml_interp->ty = 0.0;\n\n      break;\n\n    case PIXOPS_INTERP_TILES:\n      tile_make_weights (&(ml_interp->po_filter.x), scale_x);\n      tile_make_weights (&(ml_interp->po_filter.y), scale_y);\n      leftPadding   = 0;\n      topPadding    = 0;\n      ml_interp->tx = 0.5 * (1 - scale_x);\n      ml_interp->ty = 0.5 * (1 - scale_y);\n      break;\n\n    case PIXOPS_INTERP_HYPER:\n      bilinear_box_make_weights (&(ml_interp->po_filter.x), scale_x);\n      bilinear_box_make_weights (&(ml_interp->po_filter.y), scale_y);\n      leftPadding   = 1;\n      topPadding    = 1;\n      ml_interp->tx = 0.5 * (1 - scale_x);\n      ml_interp->ty = 0.5 * (1 - scale_y);\n      break;\n\n    case PIXOPS_INTERP_NEAREST:\n    default:\n      /*\n       * Note that this function should not be called in the\n       * PIXOPS_INTERP_NEAREST case since it does not use an interpolation\n       * table.\n       */\n      g_assert_not_reached ();\n      break;\n    }\n\n /* \n  * If overall_alpha is not 1.0, then multiply the vectors built by the\n  * sqrt (overall_alpha).  This will cause overall_alpha to get evenly\n  * blended across both axis.\n  *\n  * Note there is no need to multiply the vectors built by the various\n  * make-weight functions by sqrt (overall_alpha) since the make-weight\n  * functions are called with overall_alpha hardcoded to 1.0.\n  */\n  if (overall_alpha != 1.0)\n    {\n      double sqrt_alpha = sqrt (overall_alpha);\n      int i;\n\n      for (i=0; i < SUBSAMPLE * ml_interp->po_filter.x.n; i++)\n         ml_interp->po_filter.x.weights[i] *= sqrt_alpha;\n      for (i=0; i < SUBSAMPLE * ml_interp->po_filter.y.n; i++)\n         ml_interp->po_filter.y.weights[i] *= sqrt_alpha;\n    }\n    \n  ml_interp->interp_table = (void *) mlib_ImageInterpTableCreate (MLIB_DOUBLE,\n    ml_interp->po_filter.x.n, ml_interp->po_filter.y.n, leftPadding,\n    topPadding, SUBSAMPLE_BITS, SUBSAMPLE_BITS, 8,\n    ml_interp->po_filter.x.weights, ml_interp->po_filter.y.weights);\n\n  g_free (ml_interp->po_filter.x.weights);\n  g_free (ml_interp->po_filter.y.weights);  \n}\n\nstatic void\npixops_medialib_composite (guchar          *dest_buf,\n                           int              dest_width,\n                           int              dest_height,\n                           int              dest_rowstride,\n                           int              dest_channels,\n                           int              dest_has_alpha,\n                           const guchar    *src_buf,\n                           int              src_width,\n                           int              src_height,\n                           int              src_rowstride,\n                           int              src_channels,\n                           int              src_has_alpha,\n                           int              dest_x,\n                           int              dest_y,\n                           int              dest_region_width,\n                           int              dest_region_height,\n                           double           offset_x,\n                           double           offset_y,\n                           double           scale_x,\n                           double           scale_y,\n                           PixopsInterpType interp_type,\n                           int              overall_alpha)\n{\n  mlib_blend blend;\n  g_return_if_fail (!(dest_channels == 3 && dest_has_alpha));\n  g_return_if_fail (!(src_channels == 3 && src_has_alpha));\n\n  if (scale_x == 0 || scale_y == 0)\n    return;\n\n  if (!medialib_initialized)\n    _pixops_use_medialib ();\n\n  if (!use_medialib)\n    {\n      /* Use non-mediaLib version */\n      _pixops_composite_real (dest_buf + (gsize)dest_y * dest_rowstride + (gsize)dest_x *\n\t\t\t      dest_channels, dest_x - offset_x, dest_y -\n\t\t\t      offset_y, dest_x + dest_region_width - offset_x,\n\t\t\t      dest_y + dest_region_height - offset_y,\n\t\t\t      dest_rowstride, dest_channels, dest_has_alpha,\n\t\t\t      src_buf, src_width, src_height, src_rowstride,\n\t\t\t      src_channels, src_has_alpha, scale_x, scale_y,\n\t\t\t      interp_type, overall_alpha);\n    }\n  else\n    {\n      mlInterp ml_interp;\n      mlib_image img_src, img_dest;\n      double ml_offset_x, ml_offset_y;\n\n      if (!src_has_alpha && overall_alpha == 255 &&\n\t  dest_channels <= src_channels) \n        {\n          pixops_medialib_scale (dest_buf, dest_region_width,\n\t\t\t\t dest_region_height, dest_rowstride,\n\t\t\t\t dest_channels, dest_has_alpha, src_buf,\n\t\t\t\t src_width, src_height, src_rowstride,\n\t\t\t\t src_channels, src_has_alpha, dest_x, dest_y,\n\t\t\t\t dest_region_width, dest_region_height,\n\t\t\t\t offset_x, offset_y, scale_x, scale_y,\n\t\t\t\t interp_type);\n          return;\n        }\n\n      mlib_ImageSetStruct (&img_src, MLIB_BYTE, src_channels,\n\t\t\t   src_width, src_height, src_rowstride, src_buf);\n\n      if (dest_x == 0 && dest_y == 0 &&\n          dest_width  == dest_region_width &&\n          dest_height == dest_region_height)\n        {\n          mlib_ImageSetStruct (&img_dest, MLIB_BYTE, dest_channels,\n\t\t\t       dest_width, dest_height, dest_rowstride,\n\t\t\t       dest_buf);\n        }\n      else\n        {\n\t  mlib_u8 *data = dest_buf + (gsize)dest_y * dest_rowstride +\n\t\t\t\t     (gsize)dest_x * dest_channels;\n\n          mlib_ImageSetStruct (&img_dest, MLIB_BYTE, dest_channels,\n\t\t\t       dest_region_width, dest_region_height,\n\t\t\t       dest_rowstride, data);\n        }\n\n      ml_offset_x = floor (offset_x) - dest_x;\n      ml_offset_y = floor (offset_y) - dest_y;\n\n      if (interp_type == PIXOPS_INTERP_NEAREST)\n        {\n          blend = src_has_alpha ? MLIB_BLEND_GTK_SRC_OVER2 : MLIB_BLEND_GTK_SRC;\n\n          mlib_ImageZoomTranslateBlend (&img_dest,\n                                        &img_src,\n                                        scale_x,\n                                        scale_y,\n                                        ml_offset_x,\n                                        ml_offset_y,\n                                        MLIB_NEAREST,\n                                        MLIB_EDGE_SRC_EXTEND_INDEF,\n                                        blend,\n                                        overall_alpha,\n                                        1);\n        }\n      else\n        {\n          blend = src_has_alpha ? MLIB_BLEND_GTK_SRC_OVER : MLIB_BLEND_GTK_SRC;\n\n          if (interp_type == PIXOPS_INTERP_BILINEAR &&\n\t      scale_x > 1.0 && scale_y > 1.0)\n            {\n              mlib_ImageZoomTranslateBlend (&img_dest,\n                                            &img_src,\n                                            scale_x,\n                                            scale_y,\n                                            ml_offset_x,\n                                            ml_offset_y,\n                                            MLIB_BILINEAR,\n                                            MLIB_EDGE_SRC_EXTEND_INDEF,\n                                            blend,\n                                            overall_alpha,\n                                            1);\n            }\n          else\n            {\n              medialib_get_interpolation (&ml_interp, interp_type, scale_x,\n\t\t\t\t\t  scale_y, overall_alpha/255.0);\n\n              if (ml_interp.interp_table != NULL)\n                {\n                  mlib_ImageZoomTranslateTableBlend (&img_dest,\n                                                     &img_src,\n                                                     scale_x,\n                                                     scale_y,\n                                                     ml_offset_x + ml_interp.tx,\n                                                     ml_offset_y + ml_interp.ty,\n                                                     ml_interp.interp_table,\n                                                     MLIB_EDGE_SRC_EXTEND_INDEF,\n                                                     blend,\n                                                     1);\n                  mlib_ImageInterpTableDelete (ml_interp.interp_table);\n                }\n              else\n                {\n                  /* Should not happen - Use non-mediaLib version */\n                  _pixops_composite_real (dest_buf + (gsize)dest_y * dest_rowstride +\n                                          (gsize)dest_x * dest_channels,\n                                          dest_x - offset_x, dest_y - offset_y,\n                                          dest_x + dest_region_width - offset_x,\n                                          dest_y + dest_region_height - offset_y,\n                                          dest_rowstride, dest_channels,\n                                          dest_has_alpha, src_buf, src_width,\n                                          src_height, src_rowstride,\n                                          src_channels, src_has_alpha, scale_x,\n                                          scale_y, interp_type, overall_alpha);\n                }\n            }\n        }\n    }\n}\n#endif\n\nstatic void\n_pixops_scale_real (guchar        *dest_buf,\n\t\t    int            render_x0,\n\t\t    int            render_y0,\n\t\t    int            render_x1,\n\t\t    int            render_y1,\n\t\t    int            dest_rowstride,\n\t\t    int            dest_channels,\n\t\t    gboolean       dest_has_alpha,\n\t\t    const guchar  *src_buf,\n\t\t    int            src_width,\n\t\t    int            src_height,\n\t\t    int            src_rowstride,\n\t\t    int            src_channels,\n\t\t    gboolean       src_has_alpha,\n\t\t    double         scale_x,\n\t\t    double         scale_y,\n\t\t    PixopsInterpType  interp_type)\n{\n  PixopsFilter filter;\n  PixopsLineFunc line_func;\n  guchar *tmp_buf = NULL;\t/* Temporary image for two-step scaling */\n\n  g_return_if_fail (!(dest_channels == 3 && dest_has_alpha));\n  g_return_if_fail (!(src_channels == 3 && src_has_alpha));\n  g_return_if_fail (!(src_has_alpha && !dest_has_alpha));\n\n  if (scale_x == 0 || scale_y == 0)\n    return;\n\n  if (interp_type == PIXOPS_INTERP_NEAREST)\n    {\n      pixops_scale_nearest (dest_buf, render_x0, render_y0, render_x1,\n\t\t\t    render_y1, dest_rowstride, dest_channels,\n\t\t\t    dest_has_alpha, src_buf, src_width, src_height,\n\t\t\t    src_rowstride, src_channels, src_has_alpha,\n\t\t\t    scale_x, scale_y);\n      return;\n    }\n\n  if (need_to_prescale (scale_x, scale_y, interp_type))\n    tmp_buf = prescale (&src_buf, &src_width, &src_height, &src_rowstride,\n\t\t\tsrc_channels, src_has_alpha,\n\t\t\t&scale_x, &scale_y, interp_type);\n  \n  filter.overall_alpha = 1.0;\n  if (!make_weights (&filter, interp_type, scale_x, scale_y))\n    return;\n\n  if (filter.x.n == 2 && filter.y.n == 2 && dest_channels == 3 && src_channels == 3)\n    line_func = scale_line_22_33;\n  else\n    line_func = scale_line;\n  \n  pixops_process (dest_buf, render_x0, render_y0, render_x1, render_y1,\n\t\t  dest_rowstride, dest_channels, dest_has_alpha,\n\t\t  src_buf, src_width, src_height, src_rowstride, src_channels,\n\t\t  src_has_alpha, scale_x, scale_y, 0, 0, 0, 0, 0,\n\t\t  &filter, line_func, scale_pixel);\n\n  g_free (filter.x.weights);\n  g_free (filter.y.weights);\n  g_clear_pointer (&tmp_buf, g_free);\n}\n\nvoid\n_pixops_scale (guchar          *dest_buf,\n               int              dest_width,\n               int              dest_height,\n               int              dest_rowstride,\n               int              dest_channels,\n               int              dest_has_alpha,\n               const guchar    *src_buf,\n               int              src_width,\n               int              src_height,\n               int              src_rowstride,\n               int              src_channels,\n               int              src_has_alpha,\n               int              dest_x,\n               int              dest_y,\n               int              dest_region_width,\n               int              dest_region_height,\n               double           offset_x,\n               double           offset_y,\n               double           scale_x,\n               double           scale_y,\n               PixopsInterpType interp_type)\n{\n  guchar *new_dest_buf;\n  int render_x0;\n  int render_y0;\n  int render_x1;\n  int render_y1;\n\n#ifdef USE_MEDIALIB\n  pixops_medialib_scale (dest_buf, dest_width, dest_height, dest_rowstride,\n                         dest_channels, dest_has_alpha, src_buf, src_width,\n                         src_height, src_rowstride, src_channels,\n                         src_has_alpha, dest_x, dest_y, dest_region_width,\n\t\t\t dest_region_height, offset_x, offset_y, scale_x,\n\t\t\t scale_y, (PixopsInterpType)interp_type);\n  return;\n#endif\n\n  new_dest_buf = dest_buf + (gsize)dest_y * dest_rowstride + (gsize)dest_x * dest_channels;\n  render_x0    = dest_x - offset_x;\n  render_y0    = dest_y - offset_y;\n  render_x1    = dest_x + dest_region_width  - offset_x;\n  render_y1    = dest_y + dest_region_height - offset_y;\n\n  _pixops_scale_real (new_dest_buf, render_x0, render_y0, render_x1,\n                      render_y1, dest_rowstride, dest_channels,\n                      dest_has_alpha, src_buf, src_width, src_height,\n                      src_rowstride, src_channels, src_has_alpha,\n                      scale_x, scale_y, (PixopsInterpType)interp_type);\n}\n\n#ifdef USE_MEDIALIB\nstatic void\npixops_medialib_scale     (guchar          *dest_buf,\n                           int              dest_width,\n                           int              dest_height,\n                           int              dest_rowstride,\n                           int              dest_channels,\n                           int              dest_has_alpha,\n                           const guchar    *src_buf,\n                           int              src_width,\n                           int              src_height,\n                           int              src_rowstride,\n                           int              src_channels,\n                           int              src_has_alpha,\n                           int              dest_x,\n                           int              dest_y,\n                           int              dest_region_width,\n                           int              dest_region_height,\n                           double           offset_x,\n                           double           offset_y,\n                           double           scale_x,\n                           double           scale_y,\n                           PixopsInterpType interp_type)\n{\n  if (scale_x == 0 || scale_y == 0)\n    return;\n\n  if (!medialib_initialized)\n    _pixops_use_medialib ();\n \n  /*\n   * We no longer support mediaLib 2.1 because it has a core dumping problem\n   * in the mlib_ImageZoomTranslateTable function that has been corrected in\n   * 2.2.  Although the mediaLib_zoom function could be used, it does not\n   * work properly if the source and destination images have different \n   * values for \"has_alpha\" or \"num_channels\".  The complicated if-logic\n   * required to support both versions is not worth supporting\n   * mediaLib 2.1 moving forward.\n   */\n  if (!use_medialib)\n    {\n      _pixops_scale_real (dest_buf + (gsize)dest_y * dest_rowstride + (gsize)dest_x *\n\t\t\t  dest_channels, dest_x - offset_x, dest_y - offset_y,\n\t\t\t  dest_x + dest_region_width - offset_x,\n\t\t\t  dest_y + dest_region_height - offset_y,\n\t\t\t  dest_rowstride, dest_channels, dest_has_alpha,\n\t\t\t  src_buf, src_width, src_height, src_rowstride,\n\t\t\t  src_channels, src_has_alpha, scale_x, scale_y,\n\t\t\t  interp_type);\n    }\n  else \n    {\n      mlInterp ml_interp;\n      mlib_image img_orig_src, img_src, img_dest;\n      double ml_offset_x, ml_offset_y;\n      guchar *tmp_buf = NULL;\n\n      mlib_ImageSetStruct (&img_orig_src, MLIB_BYTE, src_channels, src_width, \n\t\t\t   src_height, src_rowstride, src_buf);\n\n      if (dest_x == 0 && dest_y == 0 &&\n          dest_width == dest_region_width &&\n          dest_height == dest_region_height)\n        {\n          mlib_ImageSetStruct (&img_dest, MLIB_BYTE, dest_channels,\n\t\t\t       dest_width, dest_height, dest_rowstride,\n\t\t\t       dest_buf);\n        }\n      else\n        {\n\t  mlib_u8 *data = dest_buf + (gsize)dest_y * dest_rowstride +\n\t\t\t\t     (gsize)dest_x * dest_channels;\n\n          mlib_ImageSetStruct (&img_dest, MLIB_BYTE, dest_channels,\n\t\t\t       dest_region_width, dest_region_height,\n\t\t\t       dest_rowstride, data);\n        }\n\n      ml_offset_x = floor (offset_x) - dest_x;\n      ml_offset_y = floor (offset_y) - dest_y;\n\n     /*\n      * Note that zoomTranslate and zoomTranslateTable are faster\n      * than zoomTranslateBlend and zoomTranslateTableBlend.  However\n      * the faster functions only work in the following case:\n      *\n      *   if (src_channels == dest_channels &&\n      *       (!src_alpha && interp_table != PIXOPS_INTERP_NEAREST))\n      *\n      * We use the faster versions if we can.\n      *\n      * Note when the interp_type is BILINEAR and the interpolation\n      * table will be size 2x2 (when both x/y scale factors > 1.0),\n      * then we do not bother building the interpolation table.   In\n      * this case we can just use MLIB_BILINEAR, which is faster than\n      * using a specified interpolation table.\n      */\n      img_src = img_orig_src;\n\n      if (!src_has_alpha)\n        {\n          if (src_channels > dest_channels)\n            {\n              int channels  = 3;\n              int rowstride = (channels * src_width + 3) & ~3;\n        \n              tmp_buf = g_malloc_n (src_rowstride, src_height);\n\n              if (src_buf != NULL)\n                {\n                  src_channels  = channels;\n                  src_rowstride = rowstride;\n          \n                  mlib_ImageSetStruct (&img_src, MLIB_BYTE, src_channels,\n\t\t\t\t       src_width, src_height, src_rowstride,\n\t\t\t\t       tmp_buf);\n                  mlib_ImageChannelExtract (&img_src, &img_orig_src, 0xE);  \n                }\n            }\n        }\n    \n      if (interp_type == PIXOPS_INTERP_NEAREST)\n        {\n          if (src_channels == dest_channels)\n            {\n              mlib_ImageZoomTranslate (&img_dest,\n                                       &img_src,\n                                       scale_x,\n                                       scale_y,\n                                       ml_offset_x,\n                                       ml_offset_y,\n                                       MLIB_NEAREST,\n                                       MLIB_EDGE_SRC_EXTEND_INDEF);\n            }\n          else\n            {\n              mlib_ImageZoomTranslateBlend (&img_dest,\n                                            &img_src,\n                                            scale_x,\n                                            scale_y,\n                                            ml_offset_x,\n                                            ml_offset_y,\n                                            MLIB_NEAREST,\n                                            MLIB_EDGE_SRC_EXTEND_INDEF,\n                                            MLIB_BLEND_GTK_SRC,\n                                            1.0,\n                                            1);\n            }\n        }\n      else if (src_channels == dest_channels && !src_has_alpha)\n        {\n          if (interp_type == PIXOPS_INTERP_BILINEAR &&\n              scale_x > 1.0 && scale_y > 1.0)\n            {\n               mlib_ImageZoomTranslate (&img_dest,\n                                        &img_src,\n                                        scale_x,\n                                        scale_y,\n                                        ml_offset_x,\n                                        ml_offset_y,\n                                        MLIB_BILINEAR,\n                                        MLIB_EDGE_SRC_EXTEND_INDEF);\n            }\n          else\n            {\n              medialib_get_interpolation (&ml_interp, interp_type,\n                                          scale_x, scale_y, 1.0);\n\n              if (ml_interp.interp_table != NULL)\n                {\n                  mlib_ImageZoomTranslateTable (&img_dest, \n                                                &img_src,\n                                                scale_x,\n                                                scale_y,\n                                                ml_offset_x + ml_interp.tx,\n                                                ml_offset_y + ml_interp.ty,\n                                                ml_interp.interp_table,\n                                                MLIB_EDGE_SRC_EXTEND_INDEF);\n\n\t          mlib_ImageInterpTableDelete (ml_interp.interp_table);\n                }\n              else\n                {\n                  /* Should not happen. */\n                  mlib_filter  ml_filter;\n\n                  switch (interp_type)\n                    {\n                    case PIXOPS_INTERP_BILINEAR:\n                      ml_filter = MLIB_BILINEAR;\n                      break;\n\n                    case PIXOPS_INTERP_TILES:\n                      ml_filter = MLIB_BILINEAR;\n                      break;\n\n                    case PIXOPS_INTERP_HYPER:\n                      ml_filter = MLIB_BICUBIC;\n                      break;\n                    }\n\n                  mlib_ImageZoomTranslate (&img_dest,\n                                           &img_src,\n                                           scale_x,\n                                           scale_y,\n                                           ml_offset_x,\n                                           ml_offset_y,\n                                           ml_filter,\n                                           MLIB_EDGE_SRC_EXTEND_INDEF);\n                }\n            }\n        }\n\n      /* Deal with case where src_channels != dest_channels || src_has_alpha */\n      else if (interp_type == PIXOPS_INTERP_BILINEAR &&\n               scale_x > 1.0 && scale_y > 1.0)\n        {\n          mlib_ImageZoomTranslateBlend (&img_dest,\n                                        &img_src,\n                                        scale_x,\n                                        scale_y,\n                                        ml_offset_x,\n                                        ml_offset_y,\n                                        MLIB_BILINEAR,\n                                        MLIB_EDGE_SRC_EXTEND_INDEF,\n                                        MLIB_BLEND_GTK_SRC,\n                                        1.0,\n                                        1);\n        }\n      else\n        {\n          medialib_get_interpolation (&ml_interp, interp_type,\n                                      scale_x, scale_y, 1.0);\n\n          if (ml_interp.interp_table != NULL)\n            {\n              mlib_ImageZoomTranslateTableBlend (&img_dest,\n                                                 &img_src,\n                                                 scale_x,\n                                                 scale_y,\n                                                 ml_offset_x + ml_interp.tx,\n                                                 ml_offset_y + ml_interp.ty,\n                                                 ml_interp.interp_table,\n                                                 MLIB_EDGE_SRC_EXTEND_INDEF,\n                                                 MLIB_BLEND_GTK_SRC,\n                                                 1);\n              mlib_ImageInterpTableDelete (ml_interp.interp_table);\n            }\n          else\n            {\n              mlib_filter  ml_filter;\n\n              switch (interp_type)\n                {\n                case PIXOPS_INTERP_BILINEAR:\n                  ml_filter = MLIB_BILINEAR;\n                  break;\n            \n                case PIXOPS_INTERP_TILES:\n                  ml_filter = MLIB_BILINEAR;\n                  break;\n\n                case PIXOPS_INTERP_HYPER:\n                  ml_filter = MLIB_BICUBIC;\n                  break;\n                }\n\n              mlib_ImageZoomTranslate (&img_dest,\n                                       &img_src,\n                                       scale_x,\n                                       scale_y,\n                                       ml_offset_x,\n                                       ml_offset_y,\n                                       ml_filter,\n                                       MLIB_EDGE_SRC_EXTEND_INDEF);\n            }\n        }\n\n      if (tmp_buf != NULL)\n        g_free (tmp_buf);\n    }\n}\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/pixbuf-randomly-modified.c",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/icc-profile.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/bug143608-comment.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/dpi.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/cve-2015-4491.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/aero.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/circular-table.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/pixbuf-random.c",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/pixbuf-read.c",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-image-rle.pixdata",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/premature-end.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/icc-profile.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/dpi.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/premature-end.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/large.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/dpi.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/bug725582-testrotate.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/large.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-animation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/bug775218.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-image.pixdata",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/bug775693.pixdata",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/pixbuf-lowmem.c",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/1_partyanimsm2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-animation.ani",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-image.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/bug753605-atsize.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/pixbuf-save-ref.c",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/bug775229.pixdata",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/bug725582-testrotate.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/decodecolormap.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/bug776040.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/bug775697.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/valid.1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/valid.1.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/valid.1.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/valid.2.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/bmp-line-overflow.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/valid.1.jp2",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/bug775242.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/valid.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/invalid.2.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/valid.2.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/bug775648.qtif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/bug775232.pnm",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/valid.1.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/randomly-modified/valid.1.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/rle-too-many-pixels-2.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/colormap-too-small.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/bug785447.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/rle-too-many-pixels-2.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/rle-too-many-pixels.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/squares.ico.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/bug785447.ico.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/mandatory-bitmasks.bmp.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/bug696331.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/colormap-too-small.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/mandatory-bitmasks.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/bug696331.png.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/rle-too-many-pixels.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/cat.jpg.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/cat.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/squares.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-opaque.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-8bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-opaque.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-16bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-32bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-8bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-16bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-top-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-cmap-rle-8bpp-bottom-right.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-bottom-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-24bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-bottom-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-16bpp-bottom-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-24bpp-top-left.tga.ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-gray-rle-8bpp-top-left.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/reftests/tga/gtk-logo-rle-32bpp-top-right.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/max-height.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/missing-pixels.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/extra-data.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-speed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/disabled-transparent.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/loop-buffer.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/dispose-keep.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-erase.3.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/depth7.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/large-codes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/all-greens.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-fill.1.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/all-reds.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/no-clear.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/xmp-data.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/depth2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-inside-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/invalid-utf8-comment.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-overlap-bg.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/nul-comment.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-no-delays.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/no-data.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-erase.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/unknown-extension.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/all-reds.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/white-dot.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/icc-color-profile.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/images-combine.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/missing-pixels.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-erase.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/depth6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/double-clears.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/max-height.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/nul-application-extension.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-inside-bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/loop-max.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-overlap-bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/depth8.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-fill.0.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/dispose-none.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/high-color.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/large-comment.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/random-image.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/checkerboard.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/dispose-restore-previous.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/many-clears.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/max-size.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/loop-animexts.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/max-width.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/invalid-transparent.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/four-colors.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/loop-once.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/sRGB.icc",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-outside-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/max-width.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/comment.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/transparent.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/invalid-ascii-comment.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-outside-bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/depth5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/transparent-dot.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/four-colors.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/max-codes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-erase.0.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-fill.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/loop-buffer_max.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/plain-text.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/gif87a.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-zero-height.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/255-codes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation.1.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-zero-delays.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/dispose-restore-background.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-fill.0.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/no-eoi.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/xmp-data-empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/icc-color-profile-empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-erase.0.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/no-global-color-table.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/unknown-application-extension.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/white-dot.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/depth1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/all-greens.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/four-colors.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/no-clear-and-eoi.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/max-height.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/four-colors-transparent.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-inside-bg.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/local-color-table.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/4095-codes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-multi-image-explicit-zero-delay.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation.0.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/checkerboard.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/depth4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/all-greens.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-fill.2.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-overlap-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/missing-pixels.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/white-hline2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/zero-size.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/zero-width.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-erase.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-zero-width.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-fill.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/invalid-colors.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/all-reds.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-erase.2.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/invalid-background.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/four-colors-transparent.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/images-overlap.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/high-color.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/gif87a-animation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-fill.3.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/4095-codes-clear.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/all-blues.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/extra-pixels.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/random_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/zero-height.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/high-color.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/white-hline2.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/max-width.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/all-blues.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/random-image.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation.2.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/all-blues.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation.3.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/interlace.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/loop-infinite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-multi-image.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-fill.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation-erase.1.rgba",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/image-zero-size.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/depth3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/gif-test-suite/animation.0.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/bug784903-overflow-dimensions.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/bug776694.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/bug779012.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/bug779016-infinite.icns",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/file3.jp2",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.1.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/CVE-2017-2862.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/bug785973.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.3.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/bug778584.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.4.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/overflow.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/invalid.1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/colormap-image-without-colormap.tga",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/bug780269.tif",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/bug793470-crasher.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/tests/test-images/fail/bug777315.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/docs/apple-red-1a.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/docs/gnome-gmush-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/docs/apple-red-2c.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/docs/composite.png",
        "/tmp/vanessa/spack-stage/spack-stage-gdk-pixbuf-2.40.0-y4cggjwndzd343add4me6nbvbqq2gui2/spack-src/docs/composite.dia"
    ],
    "total_files": 690
}