{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/override_getaddrinfo.c": "// we need this for dlsym(): #include <dlfcn.h>\n#include \"config.h\"\n#include <stdio.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\nint getaddrinfo(const char *node __attribute__((unused)),\n\tconst char *service __attribute__((unused)),\n\tconst struct addrinfo *hints __attribute__((unused)),\n\tstruct addrinfo **res __attribute__((unused)))\n{\n\treturn EAI_MEMORY;\n}\n\nstatic void __attribute__((constructor))\nmy_init(void)\n{\n\t/* we currently do not need this entry point, but keep it as\n\t * a \"template\". It can be used, e.g. to emit some diagnostic\n\t * information:\n\tprintf(\"loaded\\n\");\n\t * or - more importantly - obtain a pointer to the overriden\n\t * API:\n\torig_etry = dlsym(RTLD_NEXT, \"original_entry_point\");\n\t*/\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/override_gethostname.c": "// we need this for dlsym(): #include <dlfcn.h>\n#include <stdio.h>\n\n\nint gethostname(char *name, size_t __attribute__((unused)) len)\n{\n\t*name = '\\0';\n\treturn 0;\n}\n\nstatic void __attribute__((constructor))\nmy_init(void)\n{\n\t/* we currently do not need this entry point, but keep it as\n\t * a \"template\". It can be used, e.g. to emit some diagnostic\n\t * information:\n\tprintf(\"loaded\\n\");\n\t * or - more importantly - obtain a pointer to the overriden\n\t * API:\n\torig_etry = dlsym(RTLD_NEXT, \"original_entry_point\");\n\t*/\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/runtime/modules.c": "/* modules.c\n * This is the implementation of syslogd modules object.\n * This object handles plug-ins and build-in modules of all kind.\n *\n * Modules are reference-counted. Anyone who access a module must call\n * Use() before any function is accessed and Release() when he is done.\n * When the reference count reaches 0, rsyslog unloads the module (that\n * may be changed in the future to cache modules). Rsyslog does NOT\n * unload modules with a reference count > 0, even if the unload\n * method is called!\n *\n * File begun on 2007-07-22 by RGerhards\n *\n * Copyright 2007-2018 Rainer Gerhards and Adiscon GmbH.\n *\n * This file is part of the rsyslog runtime library.\n *\n * The rsyslog runtime library is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The rsyslog runtime library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with the rsyslog runtime library.  If not, see <http://www.gnu.org/licenses/>.\n *\n * A copy of the GPL can be found in the file \"COPYING\" in this distribution.\n * A copy of the LGPL can be found in the file \"COPYING.LESSER\" in this distribution.\n */\n#include \"config.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <errno.h>\n#include <pthread.h>\n#ifdef\tOS_BSD\n#\tinclude \"libgen.h\"\n#endif\n\n#include <dlfcn.h> /* TODO: replace this with the libtools equivalent! */\n\n#include <unistd.h>\n#include <sys/file.h>\n\n#ifndef PATH_MAX\n#\tdefine PATH_MAX MAXPATHLEN\n#endif\n\n#include \"rsyslog.h\"\n#include \"rainerscript.h\"\n#include \"cfsysline.h\"\n#include \"rsconf.h\"\n#include \"modules.h\"\n#include \"errmsg.h\"\n#include \"parser.h\"\n#include \"strgen.h\"\n\n/* static data */\nDEFobjStaticHelpers\nDEFobjCurrIf(strgen)\n\nstatic modInfo_t *pLoadedModules = NULL;\t/* list of currently-loaded modules */\nstatic modInfo_t *pLoadedModulesLast = NULL;\t/* tail-pointer */\n\n/* already dlopen()-ed libs */\nstatic struct dlhandle_s *pHandles = NULL;\n\nstatic uchar *pModDir;\t\t/* directory where loadable modules are found */\n\n/* tables for interfacing with the v6 config system */\n/* action (instance) parameters */\nstatic struct cnfparamdescr actpdescr[] = {\n\t{ \"load\", eCmdHdlrGetWord, 1 }\n};\nstatic struct cnfparamblk pblk =\n\t{ CNFPARAMBLK_VERSION,\n\t  sizeof(actpdescr)/sizeof(struct cnfparamdescr),\n\t  actpdescr\n\t};\n\n\ntypedef rsRetVal (*pModInit_t)(int,int*, rsRetVal(**)(), rsRetVal(*)(), modInfo_t*);\n\n/* we provide a set of dummy functions for modules that do not support the\n * some interfaces.\n * On the commit feature: As the modules do not support it, they commit each message they\n * receive, and as such the dummies can always return RS_RET_OK without causing\n * harm. This simplifies things as in action processing we do not need to check\n * if the transactional entry points exist.\n */\nstatic rsRetVal\ndummyBeginTransaction(__attribute__((unused)) void * dummy)\n{\n\treturn RS_RET_OK;\n}\nstatic rsRetVal\ndummyEndTransaction(__attribute__((unused)) void * dummy)\n{\n\treturn RS_RET_OK;\n}\nstatic rsRetVal\ndummyIsCompatibleWithFeature(__attribute__((unused)) syslogFeature eFeat)\n{\n\treturn RS_RET_INCOMPATIBLE;\n}\nstatic rsRetVal\ndummynewActInst(uchar *modName, struct nvlst __attribute__((unused)) *dummy1,\n\t\tvoid __attribute__((unused)) **dummy2, omodStringRequest_t __attribute__((unused)) **dummy3)\n{\n\tLogError(0, RS_RET_CONFOBJ_UNSUPPORTED, \"config objects are not \"\n\t\t\t\"supported by module '%s' -- legacy config options \"\n\t\t\t\"MUST be used instead\", modName);\n\treturn RS_RET_CONFOBJ_UNSUPPORTED;\n}\n\n#ifdef DEBUG\n/* we add some home-grown support to track our users (and detect who does not free us). In\n * the long term, this should probably be migrated into debug.c (TODO). -- rgerhards, 2008-03-11\n */\n\n/* add a user to the current list of users (always at the root) */\nstatic void\nmodUsrAdd(modInfo_t *pThis, const char *pszUsr)\n{\n\tmodUsr_t *pUsr;\n\n\tif((pUsr = calloc(1, sizeof(modUsr_t))) == NULL)\n\t\tgoto finalize_it;\n\n\tif((pUsr->pszFile = strdup(pszUsr)) == NULL) {\n\t\tfree(pUsr);\n\t\tgoto finalize_it;\n\t}\n\n\tif(pThis->pModUsrRoot != NULL) {\n\t\tpUsr->pNext = pThis->pModUsrRoot;\n\t}\n\tpThis->pModUsrRoot = pUsr;\n\nfinalize_it:\n\treturn;\n}\n\n\n/* remove a user from the current user list\n * rgerhards, 2008-03-11\n */\nstatic void\nmodUsrDel(modInfo_t *pThis, const char *pszUsr)\n{\n\tmodUsr_t *pUsr;\n\tmodUsr_t *pPrev = NULL;\n\n\tfor(pUsr = pThis->pModUsrRoot ; pUsr != NULL ; pUsr = pUsr->pNext) {\n\t\tif(!strcmp(pUsr->pszFile, pszUsr))\n\t\t\tbreak;\n\t\telse\n\t\t\tpPrev = pUsr;\n\t}\n\n\tif(pUsr == NULL) {\n\t\tdbgprintf(\"oops - tried to delete user %s from module %s and it wasn't registered as one...\\n\",\n\t\t\t  pszUsr, pThis->pszName);\n\t} else {\n\t\tif(pPrev == NULL) {\n\t\t\t/* This was at the root! */\n\t\t\tpThis->pModUsrRoot = pUsr->pNext;\n\t\t} else {\n\t\t\tpPrev->pNext = pUsr->pNext;\n\t\t}\n\t\t/* free ressources */\n\t\tfree(pUsr->pszFile);\n\t\tfree(pUsr);\n\t\tpUsr = NULL; /* just to make sure... */\n\t}\n}\n\n\n/* print a short list all all source files using the module in question\n * rgerhards, 2008-03-11\n */\nstatic void\nmodUsrPrint(modInfo_t *pThis)\n{\n\tmodUsr_t *pUsr;\n\n\tfor(pUsr = pThis->pModUsrRoot ; pUsr != NULL ; pUsr = pUsr->pNext) {\n\t\tdbgprintf(\"\\tmodule %s is currently in use by file %s\\n\",\n\t\t\t  pThis->pszName, pUsr->pszFile);\n\t}\n}\n\n\n/* print all loaded modules and who is accessing them. This is primarily intended\n * to be called at end of run to detect \"module leaks\" and who is causing them.\n * rgerhards, 2008-03-11\n */\nstatic void\nmodUsrPrintAll(void)\n{\n\tmodInfo_t *pMod;\n\n\tfor(pMod = pLoadedModules ; pMod != NULL ; pMod = pMod->pNext) {\n\t\tdbgprintf(\"printing users of loadable module %s, refcount %u, ptr %p, type %d\\n\",\n\t\tpMod->pszName, pMod->uRefCnt, pMod, pMod->eType);\n\t\tmodUsrPrint(pMod);\n\t}\n}\n\n#endif /* #ifdef DEBUG */\n\n\n/* Construct a new module object\n */\nstatic rsRetVal moduleConstruct(modInfo_t **pThis)\n{\n\tmodInfo_t *pNew;\n\n\tif((pNew = calloc(1, sizeof(modInfo_t))) == NULL)\n\t\treturn RS_RET_OUT_OF_MEMORY;\n\n\t/* OK, we got the element, now initialize members that should\n\t * not be zero-filled.\n\t */\n\n\t*pThis = pNew;\n\treturn RS_RET_OK;\n}\n\n\n/* Destructs a module object. The object must not be linked to the\n * linked list of modules. Please note that all other dependencies on this\n * modules must have been removed before (e.g. CfSysLineHandlers!)\n */\nstatic void moduleDestruct(modInfo_t *pThis)\n{\n\tassert(pThis != NULL);\n\tfree(pThis->pszName);\n\tfree(pThis->cnfName);\n\tif(pThis->pModHdlr != NULL) {\n#\tifdef\tVALGRIND\n\t\tDBGPRINTF(\"moduleDestruct: compiled with valgrind, do \"\n\t\t\t\"not unload module\\n\");\n#\telse\n\t\tif(glblUnloadModules) {\n\t\t\tif(pThis->eKeepType == eMOD_NOKEEP) {\n\t\t\t\tdlclose(pThis->pModHdlr);\n\t\t\t}\n\t\t} else {\n\t\t\tDBGPRINTF(\"moduleDestruct: not unloading module \"\n\t\t\t\t\"due to user configuration\\n\");\n\t\t}\n#\tendif\n\t}\n\n\tfree(pThis);\n}\n\n\n/* This enables a module to query the core for specific features.\n * rgerhards, 2009-04-22\n */\nstatic rsRetVal queryCoreFeatureSupport(int *pBool, unsigned uFeat)\n{\n\tDEFiRet;\n\n\tif(pBool == NULL)\n\t\tABORT_FINALIZE(RS_RET_PARAM_ERROR);\n\n\t*pBool = (uFeat & CORE_FEATURE_BATCHING) ? 1 : 0;\n\nfinalize_it:\n\tRETiRet;\n}\n\n\n/* The following function is the queryEntryPoint for host-based entry points.\n * Modules may call it to get access to core interface functions. Please note\n * that utility functions can be accessed via shared libraries - at least this\n * is my current shool of thinking.\n * Please note that the implementation as a query interface allows to take\n * care of plug-in interface version differences. -- rgerhards, 2007-07-31\n * ... but often it better not to use a new interface. So we now add core\n * functions here that a plugin may request. -- rgerhards, 2009-04-22\n */\nstatic rsRetVal queryHostEtryPt(uchar *name, rsRetVal (**pEtryPoint)())\n{\n\tDEFiRet;\n\n\tif((name == NULL) || (pEtryPoint == NULL))\n\t\tABORT_FINALIZE(RS_RET_PARAM_ERROR);\n\n\tif(!strcmp((char*) name, \"regCfSysLineHdlr\")) {\n\t\t*pEtryPoint = regCfSysLineHdlr;\n\t} else if(!strcmp((char*) name, \"objGetObjInterface\")) {\n\t\t*pEtryPoint = objGetObjInterface;\n\t} else if(!strcmp((char*) name, \"OMSRgetSupportedTplOpts\")) {\n\t\t*pEtryPoint = OMSRgetSupportedTplOpts;\n\t} else if(!strcmp((char*) name, \"queryCoreFeatureSupport\")) {\n\t\t*pEtryPoint = queryCoreFeatureSupport;\n\t} else {\n\t\t*pEtryPoint = NULL; /* to  be on the safe side */\n\t\tABORT_FINALIZE(RS_RET_ENTRY_POINT_NOT_FOUND);\n\t}\n\nfinalize_it:\n\tRETiRet;\n}\n\n\n/* get the name of a module\n */\nuchar *\nmodGetName(modInfo_t *pThis)\n{\n\treturn((pThis->pszName == NULL) ? (uchar*) \"\" : pThis->pszName);\n}\n\n\n/* get the state-name of a module. The state name is its name\n * together with a short description of the module state (which\n * is pulled from the module itself.\n * rgerhards, 2007-07-24\n * TODO: the actual state name is not yet pulled\n */\nstatic uchar *modGetStateName(modInfo_t *pThis)\n{\n\treturn(modGetName(pThis));\n}\n\n\n/* Add a module to the loaded module linked list\n */\nstatic void ATTR_NONNULL()\naddModToGlblList(modInfo_t *const pThis)\n{\n\tassert(pThis != NULL);\n\n\tif(pLoadedModules == NULL) {\n\t\tpLoadedModules = pLoadedModulesLast = pThis;\n\t} else {\n\t\t/* there already exist entries */\n\t\tpThis->pPrev = pLoadedModulesLast;\n\t\tpLoadedModulesLast->pNext = pThis;\n\t\tpLoadedModulesLast = pThis;\n\t}\n}\n\n\n/* ready module for config processing. this includes checking if the module\n * is already in the config, so this function may return errors. Returns a\n * pointer to the last module inthe current config. That pointer needs to\n * be passed to addModToCnfLst() when it is called later in the process.\n */\nrsRetVal\nreadyModForCnf(modInfo_t *pThis, cfgmodules_etry_t **ppNew, cfgmodules_etry_t **ppLast)\n{\n\tcfgmodules_etry_t *pNew = NULL;\n\tcfgmodules_etry_t *pLast;\n\tDEFiRet;\n\tassert(pThis != NULL);\n\n\tif(loadConf == NULL) {\n\t\tFINALIZE; /* we are in an early init state */\n\t}\n\n\t/* check for duplicates and, as a side-activity, identify last node */\n\tpLast = loadConf->modules.root;\n\tif(pLast != NULL) {\n\t\twhile(1) { /* loop broken inside */\n\t\t\tif(pLast->pMod == pThis) {\n\t\t\t\tDBGPRINTF(\"module '%s' already in this config\\n\", modGetName(pThis));\n\t\t\t\tif(strncmp((char*)modGetName(pThis), \"builtin:\", sizeof(\"builtin:\")-1)) {\n\t\t\t\t\tLogError(0, RS_RET_MODULE_ALREADY_IN_CONF,\n\t\t\t\t\t   \"module '%s' already in this config, cannot be added\\n\", modGetName(pThis));\n\t\t\t\t\tABORT_FINALIZE(RS_RET_MODULE_ALREADY_IN_CONF);\n\t\t\t\t}\n\t\t\t\tFINALIZE;\n\t\t\t}\n\t\t\tif(pLast->next == NULL)\n\t\t\t\tbreak;\n\t\t\tpLast = pLast->next;\n\t\t}\n\t}\n\n\t/* if we reach this point, pLast is the tail pointer and this module is new\n\t * inside the currently loaded config. So, iff it is an input module, let's\n\t * pass it a pointer which it can populate with a pointer to its module conf.\n\t */\n\n\tCHKmalloc(pNew = malloc(sizeof(cfgmodules_etry_t)));\n\tpNew->canActivate = 1;\n\tpNew->next = NULL;\n\tpNew->pMod = pThis;\n\n\tif(pThis->beginCnfLoad != NULL) {\n\t\tCHKiRet(pThis->beginCnfLoad(&pNew->modCnf, loadConf));\n\t}\n\n\t*ppLast = pLast;\n\t*ppNew = pNew;\nfinalize_it:\n\tif(iRet != RS_RET_OK) {\n\t\tif(pNew != NULL)\n\t\t\tfree(pNew);\n\t}\n\tRETiRet;\n}\n\n\n/* abort the creation of a module entry without adding it to the\n * module list. Needed to prevent mem leaks.\n */\nstatic inline void\nabortCnfUse(cfgmodules_etry_t **pNew)\n{\n\tif(pNew != NULL) {\n\t\tfree(*pNew);\n\t\t*pNew = NULL;\n\t}\n}\n\n\n/* Add a module to the config module list for current loadConf.\n * Requires last pointer obtained by readyModForCnf().\n * The module pointer is handed over to this function. It is no\n * longer available to caller one we are called.\n */\nrsRetVal ATTR_NONNULL(1)\naddModToCnfList(cfgmodules_etry_t **const pNew, cfgmodules_etry_t *const pLast)\n{\n\tDEFiRet;\n\tassert(*pNew != NULL);\n\n\tif(loadConf == NULL) {\n\t\tabortCnfUse(pNew);\n\t\tFINALIZE; /* we are in an early init state */\n\t}\n\n\tif(pLast == NULL) {\n\t\tloadConf->modules.root = *pNew;\n\t} else {\n\t\t/* there already exist entries */\n\t\tpLast->next = *pNew;\n\t}\n\nfinalize_it:\n\t*pNew = NULL;\n\tRETiRet;\n}\n\n\n/* Get the next module pointer - this is used to traverse the list.\n * The function returns the next pointer or NULL, if there is no next one.\n * The last object must be provided to the function. If NULL is provided,\n * it starts at the root of the list. Even in this case, NULL may be\n * returned - then, the list is empty.\n * rgerhards, 2007-07-23\n */\nstatic modInfo_t *GetNxt(modInfo_t *pThis)\n{\n\tmodInfo_t *pNew;\n\n\tif(pThis == NULL)\n\t\tpNew = pLoadedModules;\n\telse\n\t\tpNew = pThis->pNext;\n\n\treturn(pNew);\n}\n\n\n/* this function is like GetNxt(), but it returns pointers to\n * the configmodules entry, which than can be used to obtain the\n * actual module pointer. Note that it returns those for\n * modules of specific type only. Only modules from the provided\n * config are returned. Note that processing speed could be improved,\n * but this is really not relevant, as config file loading is not really\n * something we are concerned about in regard to runtime.\n */\nstatic cfgmodules_etry_t\n*GetNxtCnfType(rsconf_t *cnf, cfgmodules_etry_t *node, eModType_t rqtdType)\n{\n\tif(node == NULL) { /* start at beginning of module list */\n\t\tnode = cnf->modules.root;\n\t} else {\n\t\tnode = node->next;\n\t}\n\n\tif(rqtdType != eMOD_ANY) { /* if any, we already have the right one! */\n\t\twhile(node != NULL && node->pMod->eType != rqtdType) {\n\t\t\tnode = node->next;\n\t\t}\n\t}\n\n\treturn node;\n}\n\n\n/* Find a module with the given conf name and type. Returns NULL if none\n * can be found, otherwise module found.\n */\nstatic modInfo_t *\nFindWithCnfName(rsconf_t *cnf, uchar *name, eModType_t rqtdType)\n{\n\tcfgmodules_etry_t *node;\n\n\t;\n\tfor(  node = cnf->modules.root\n\t    ; node != NULL\n\t    ; node = node->next) {\n\t\tif(node->pMod->eType != rqtdType || node->pMod->cnfName == NULL)\n\t\t\tcontinue;\n\t\tif(!strcasecmp((char*)node->pMod->cnfName, (char*)name))\n\t\t\tbreak;\n\t}\n\n\treturn node == NULL ? NULL : node->pMod;\n}\n\n\n/* Prepare a module for unloading.\n * This is currently a dummy, to be filled when we have a plug-in\n * interface - rgerhards, 2007-08-09\n * rgerhards, 2007-11-21:\n * When this function is called, all instance-data must already have\n * been destroyed. In the case of output modules, this happens when the\n * rule set is being destroyed. When we implement other module types, we\n * need to think how we handle it there (and if we have any instance data).\n * rgerhards, 2008-03-10: reject unload request if the module has a reference\n * count > 0.\n */\nstatic rsRetVal\nmodPrepareUnload(modInfo_t *pThis)\n{\n\tDEFiRet;\n\tvoid *pModCookie;\n\n\tassert(pThis != NULL);\n\n\tif(pThis->uRefCnt > 0) {\n\t\tdbgprintf(\"rejecting unload of module '%s' because it has a refcount of %d\\n\",\n\t\t\t  pThis->pszName, pThis->uRefCnt);\n\t\tABORT_FINALIZE(RS_RET_MODULE_STILL_REFERENCED);\n\t}\n\n\tCHKiRet(pThis->modGetID(&pModCookie));\n\tpThis->modExit(); /* tell the module to get ready for unload */\n\tCHKiRet(unregCfSysLineHdlrs4Owner(pModCookie));\n\nfinalize_it:\n\tRETiRet;\n}\n\n\n/* Add an already-loaded module to the module linked list. This function does\n * everything needed to fully initialize the module.\n */\nstatic rsRetVal\ndoModInit(pModInit_t modInit, uchar *name, void *pModHdlr, modInfo_t **pNewModule)\n{\n\trsRetVal localRet;\n\tmodInfo_t *pNew = NULL;\n\tuchar *pName;\n\tstrgen_t *pStrgen; /* used for strgen modules */\n\trsRetVal (*GetName)(uchar**);\n\trsRetVal (*modGetType)(eModType_t *pType);\n\trsRetVal (*modGetKeepType)(eModKeepType_t *pKeepType);\n\tstruct dlhandle_s *pHandle = NULL;\n\trsRetVal (*getModCnfName)(uchar **cnfName);\n\tuchar *cnfName;\n\tDEFiRet;\n\n\tassert(modInit != NULL);\n\n\tif((iRet = moduleConstruct(&pNew)) != RS_RET_OK) {\n\t\tpNew = NULL;\n\t\tFINALIZE;\n\t}\n\n\tCHKiRet((*modInit)(CURR_MOD_IF_VERSION, &pNew->iIFVers, &pNew->modQueryEtryPt, queryHostEtryPt, pNew));\n\n\tif(pNew->iIFVers != CURR_MOD_IF_VERSION) {\n\t\tABORT_FINALIZE(RS_RET_MISSING_INTERFACE);\n\t}\n\n\t/* We now poll the module to see what type it is. We do this only once as this\n\t * can never change in the lifetime of an module. -- rgerhards, 2007-12-14\n\t */\n\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"getType\", &modGetType));\n\tCHKiRet((*modGetType)(&pNew->eType));\n\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"getKeepType\", &modGetKeepType));\n\tCHKiRet((*modGetKeepType)(&pNew->eKeepType));\n\tdbgprintf(\"module %s of type %d being loaded (keepType=%d).\\n\", name, pNew->eType, pNew->eKeepType);\n\t\n\t/* OK, we know we can successfully work with the module. So we now fill the\n\t * rest of the data elements. First we load the interfaces common to all\n\t * module types.\n\t */\n\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"modGetID\", &pNew->modGetID));\n\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"modExit\", &pNew->modExit));\n\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"isCompatibleWithFeature\", &pNew->isCompatibleWithFeature);\n\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\tpNew->isCompatibleWithFeature = dummyIsCompatibleWithFeature;\n\telse if(localRet != RS_RET_OK)\n\t\tABORT_FINALIZE(localRet);\n\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"setModCnf\", &pNew->setModCnf);\n\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\tpNew->setModCnf = NULL;\n\telse if(localRet != RS_RET_OK)\n\t\tABORT_FINALIZE(localRet);\n\n\t/* optional calls for new config system */\n\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"getModCnfName\", &getModCnfName);\n\tif(localRet == RS_RET_OK) {\n\t\tif(getModCnfName(&cnfName) == RS_RET_OK)\n\t\t\tpNew->cnfName = (uchar*) strdup((char*)cnfName);\n\t\t\t  /**< we do not care if strdup() fails, we can accept that */\n\t\telse\n\t\t\tpNew->cnfName = NULL;\n\t\tdbgprintf(\"module config name is '%s'\\n\", cnfName);\n\t}\n\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"beginCnfLoad\", &pNew->beginCnfLoad);\n\tif(localRet == RS_RET_OK) {\n\t\tdbgprintf(\"module %s supports rsyslog v6 config interface\\n\", name);\n\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"endCnfLoad\", &pNew->endCnfLoad));\n\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"freeCnf\", &pNew->freeCnf));\n\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"checkCnf\", &pNew->checkCnf));\n\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"activateCnf\", &pNew->activateCnf));\n\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"activateCnfPrePrivDrop\", &pNew->activateCnfPrePrivDrop);\n\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\tpNew->activateCnfPrePrivDrop = NULL;\n\t\t} else {\n\t\t\tCHKiRet(localRet);\n\t\t}\n\t} else if(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\tpNew->beginCnfLoad = NULL; /* flag as non-present */\n\t} else {\n\t\tABORT_FINALIZE(localRet);\n\t}\n\t/* ... and now the module-specific interfaces */\n\tswitch(pNew->eType) {\n\t\tcase eMOD_IN:\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"runInput\", &pNew->mod.im.runInput));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"willRun\", &pNew->mod.im.willRun));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"afterRun\", &pNew->mod.im.afterRun));\n\t\t\tpNew->mod.im.bCanRun = 0;\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"newInpInst\", &pNew->mod.im.newInpInst);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.im.newInpInst = NULL;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"doHUP\", &pNew->doHUP);\n\t\t\tif(localRet != RS_RET_OK && localRet != RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\t\t\tABORT_FINALIZE(localRet);\n\n\t\t\tbreak;\n\t\tcase eMOD_OUT:\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"freeInstance\", &pNew->freeInstance));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"dbgPrintInstInfo\", &pNew->dbgPrintInstInfo));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"parseSelectorAct\", &pNew->mod.om.parseSelectorAct));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"tryResume\", &pNew->tryResume));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"createWrkrInstance\",\n\t\t\t\t&pNew->mod.om.createWrkrInstance));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"freeWrkrInstance\",\n\t\t\t\t&pNew->mod.om.freeWrkrInstance));\n\n\t\t\t/* try load optional interfaces */\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"doHUP\", &pNew->doHUP);\n\t\t\tif(localRet != RS_RET_OK && localRet != RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\t\t\tABORT_FINALIZE(localRet);\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"doHUPWrkr\", &pNew->doHUPWrkr);\n\t\t\tif(localRet != RS_RET_OK && localRet != RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\t\t\tABORT_FINALIZE(localRet);\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"SetShutdownImmdtPtr\",\n\t\t\t\t&pNew->mod.om.SetShutdownImmdtPtr);\n\t\t\tif(localRet != RS_RET_OK && localRet != RS_RET_MODULE_ENTRY_POINT_NOT_FOUND)\n\t\t\t\tABORT_FINALIZE(localRet);\n\n\t\t\tpNew->mod.om.supportsTX = 1;\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"beginTransaction\", &pNew->mod.om.beginTransaction);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.om.beginTransaction = dummyBeginTransaction;\n\t\t\t\tpNew->mod.om.supportsTX = 0;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"doAction\",\n\t\t\t\t   &pNew->mod.om.doAction);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.om.doAction = NULL;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"commitTransaction\",\n\t\t\t\t   &pNew->mod.om.commitTransaction);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.om.commitTransaction = NULL;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\n\t\t\tif(pNew->mod.om.doAction == NULL && pNew->mod.om.commitTransaction == NULL) {\n\t\t\t\tLogError(0, RS_RET_INVLD_OMOD,\n\t\t\t\t\t\"module %s does neither provide doAction() \"\n\t\t\t\t\t\"nor commitTransaction() interface - cannot \"\n\t\t\t\t\t\"load\", name);\n\t\t\t\tABORT_FINALIZE(RS_RET_INVLD_OMOD);\n\t\t\t}\n\n\t\t\tif(pNew->mod.om.commitTransaction != NULL) {\n\t\t\t\tif(pNew->mod.om.doAction != NULL){\n\t\t\t\t\tLogError(0, RS_RET_INVLD_OMOD,\n\t\t\t\t\t\t\"module %s provides both doAction() \"\n\t\t\t\t\t\t\"and commitTransaction() interface, using \"\n\t\t\t\t\t\t\"commitTransaction()\", name);\n\t\t\t\t\tpNew->mod.om.doAction = NULL;\n\t\t\t\t}\n\t\t\t\tif(pNew->mod.om.beginTransaction == NULL){\n\t\t\t\t\tLogError(0, RS_RET_INVLD_OMOD,\n\t\t\t\t\t\t\"module %s provides both commitTransaction() \"\n\t\t\t\t\t\t\"but does not provide beginTransaction() - \"\n\t\t\t\t\t\t\"cannot load\", name);\n\t\t\t\t\tABORT_FINALIZE(RS_RET_INVLD_OMOD);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"endTransaction\",\n\t\t\t\t   &pNew->mod.om.endTransaction);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.om.endTransaction = dummyEndTransaction;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"newActInst\", &pNew->mod.om.newActInst);\n\t\t\tif(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.om.newActInst = dummynewActInst;\n\t\t\t} else if(localRet != RS_RET_OK) {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase eMOD_LIB:\n\t\t\tbreak;\n\t\tcase eMOD_PARSER:\n\t\t\tlocalRet = (*pNew->modQueryEtryPt)((uchar*)\"parse2\",\n\t\t\t\t   &pNew->mod.pm.parse2);\n\t\t\tif(localRet == RS_RET_OK) {\n\t\t\t\tpNew->mod.pm.parse = NULL;\n\t\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"newParserInst\",\n\t\t\t\t\t&pNew->mod.pm.newParserInst));\n\t\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"freeParserInst\",\n\t\t\t\t\t&pNew->mod.pm.freeParserInst));\n\t\t\t} else if(localRet == RS_RET_MODULE_ENTRY_POINT_NOT_FOUND) {\n\t\t\t\tpNew->mod.pm.parse2 = NULL;\n\t\t\t\tpNew->mod.pm.newParserInst = NULL;\n\t\t\t\tpNew->mod.pm.freeParserInst = NULL;\n\t\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"parse\", &pNew->mod.pm.parse));\n\t\t\t} else {\n\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t}\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"GetParserName\", &GetName));\n\t\t\tCHKiRet(GetName(&pName));\n\t\t\tCHKiRet(parserConstructViaModAndName(pNew, pName, NULL));\n\t\t\tbreak;\n\t\tcase eMOD_STRGEN:\n\t\t\t/* first, we need to obtain the strgen object. We could not do that during\n\t\t\t * init as that would have caused class bootstrap issues which are not\n\t\t\t * absolutely necessary. Note that we can call objUse() multiple times, it\n\t\t\t * handles that.\n\t\t\t */\n\t\t\tCHKiRet(objUse(strgen, CORE_COMPONENT));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"strgen\", &pNew->mod.sm.strgen));\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"GetName\", &GetName));\n\t\t\tCHKiRet(GetName(&pName));\n\t\t\tCHKiRet(strgen.Construct(&pStrgen));\n\t\t\tCHKiRet(strgen.SetName(pStrgen, pName));\n\t\t\tCHKiRet(strgen.SetModPtr(pStrgen, pNew));\n\t\t\tCHKiRet(strgen.ConstructFinalize(pStrgen));\n\t\t\tbreak;\n\t\tcase eMOD_FUNCTION:\n\t\t\tCHKiRet((*pNew->modQueryEtryPt)((uchar*)\"getFunctArray\", &pNew->mod.fm.getFunctArray));\n\t\t\tint version;\n\t\t\tstruct scriptFunct *functArray;\n\t\t\tpNew->mod.fm.getFunctArray(&version, &functArray);\n\t\t\tdbgprintf(\"LLL: %s\\n\", functArray[0].fname);\n\t\t\taddMod2List(version, functArray);\n\t\t\tbreak;\n\t\tcase eMOD_ANY: /* this is mostly to keep the compiler happy! */\n\t\t\tDBGPRINTF(\"PROGRAM ERROR: eMOD_ANY set as module type\\n\");\n\t\t\tassert(0);\n\t\t\tbreak;\n\t}\n\n\tpNew->pszName = (uchar*) strdup((char*)name); /* we do not care if strdup() fails, we can accept that */\n\tpNew->pModHdlr = pModHdlr;\n\tif(pModHdlr == NULL) {\n\t\tpNew->eLinkType = eMOD_LINK_STATIC;\n\t} else {\n\t\tpNew->eLinkType = eMOD_LINK_DYNAMIC_LOADED;\n\n\t\t/* if we need to keep the linked module, save it */\n\t\tif (pNew->eKeepType == eMOD_KEEP) {\n\t\t\t/* see if we have this one already */\n\t\t\tfor (pHandle = pHandles; pHandle; pHandle = pHandle->next) {\n\t\t\t\tif (!strcmp((char *)name, (char *)pHandle->pszName))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* not found, create it */\n\t\t\tif (!pHandle) {\n\t\t\t\tif((pHandle = malloc(sizeof (*pHandle))) == NULL) {\n\t\t\t\t\tABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);\n\t\t\t\t}\n\t\t\t\tif((pHandle->pszName = (uchar*) strdup((char*)name)) == NULL) {\n\t\t\t\t\tfree(pHandle);\n\t\t\t\t\tABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);\n\t\t\t\t}\n\t\t\t\tpHandle->pModHdlr = pModHdlr;\n\t\t\t\tpHandle->next = pHandles;\n\n\t\t\t\tpHandles = pHandle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* we initialized the structure, now let's add it to the linked list of modules */\n\taddModToGlblList(pNew);\n\t*pNewModule = pNew;\n\nfinalize_it:\n\tif(iRet != RS_RET_OK) {\n\t\tif(pNew != NULL)\n\t\t\tmoduleDestruct(pNew);\n\t\t*pNewModule = NULL;\n\t}\n\n\tRETiRet;\n}\n\n/* Print loaded modules. This is more or less a\n * debug or test aid, but anyhow I think it's worth it...\n * This only works if the dbgprintf() subsystem is initialized.\n * TODO: update for new input modules!\n */\nstatic void modPrintList(void)\n{\n\tmodInfo_t *pMod;\n\n\tpMod = GetNxt(NULL);\n\twhile(pMod != NULL) {\n\t\tdbgprintf(\"Loaded Module: Name='%s', IFVersion=%d, \",\n\t\t\t(char*) modGetName(pMod), pMod->iIFVers);\n\t\tdbgprintf(\"type=\");\n\t\tswitch(pMod->eType) {\n\t\tcase eMOD_OUT:\n\t\t\tdbgprintf(\"output\");\n\t\t\tbreak;\n\t\tcase eMOD_IN:\n\t\t\tdbgprintf(\"input\");\n\t\t\tbreak;\n\t\tcase eMOD_LIB:\n\t\t\tdbgprintf(\"library\");\n\t\t\tbreak;\n\t\tcase eMOD_PARSER:\n\t\t\tdbgprintf(\"parser\");\n\t\t\tbreak;\n\t\tcase eMOD_STRGEN:\n\t\t\tdbgprintf(\"strgen\");\n\t\t\tbreak;\n\t\tcase eMOD_FUNCTION:\n\t\t\tdbgprintf(\"function\");\n\t\t\tbreak;\n\t\tcase eMOD_ANY: /* this is mostly to keep the compiler happy! */\n\t\t\tDBGPRINTF(\"PROGRAM ERROR: eMOD_ANY set as module type\\n\");\n\t\t\tassert(0);\n\t\t\tbreak;\n\t\t}\n\t\tdbgprintf(\" module.\\n\");\n\t\tdbgprintf(\"Entry points:\\n\");\n\t\tdbgprintf(\"\\tqueryEtryPt:        0x%lx\\n\", (unsigned long) pMod->modQueryEtryPt);\n\t\tdbgprintf(\"\\tdbgPrintInstInfo:   0x%lx\\n\", (unsigned long) pMod->dbgPrintInstInfo);\n\t\tdbgprintf(\"\\tfreeInstance:       0x%lx\\n\", (unsigned long) pMod->freeInstance);\n\t\tdbgprintf(\"\\tbeginCnfLoad:       0x%lx\\n\", (unsigned long) pMod->beginCnfLoad);\n\t\tdbgprintf(\"\\tSetModCnf:          0x%lx\\n\", (unsigned long) pMod->setModCnf);\n\t\tdbgprintf(\"\\tcheckCnf:           0x%lx\\n\", (unsigned long) pMod->checkCnf);\n\t\tdbgprintf(\"\\tactivateCnfPrePrivDrop: 0x%lx\\n\", (unsigned long) pMod->activateCnfPrePrivDrop);\n\t\tdbgprintf(\"\\tactivateCnf:        0x%lx\\n\", (unsigned long) pMod->activateCnf);\n\t\tdbgprintf(\"\\tfreeCnf:            0x%lx\\n\", (unsigned long) pMod->freeCnf);\n\t\tswitch(pMod->eType) {\n\t\tcase eMOD_OUT:\n\t\t\tdbgprintf(\"Output Module Entry Points:\\n\");\n\t\t\tdbgprintf(\"\\tdoAction:           %p\\n\", pMod->mod.om.doAction);\n\t\t\tdbgprintf(\"\\tparseSelectorAct:   %p\\n\", pMod->mod.om.parseSelectorAct);\n\t\t\tdbgprintf(\"\\tnewActInst:         %p\\n\", (pMod->mod.om.newActInst == dummynewActInst) ?\n\t\t\t\t\t\tNULL :  pMod->mod.om.newActInst);\n\t\t\tdbgprintf(\"\\ttryResume:          %p\\n\", pMod->tryResume);\n\t\t\tdbgprintf(\"\\tdoHUP:              %p\\n\", pMod->doHUP);\n\t\t\tdbgprintf(\"\\tBeginTransaction:   %p\\n\", ((pMod->mod.om.beginTransaction ==\n\t\t\t\t\t\tdummyBeginTransaction) ? NULL :  pMod->mod.om.beginTransaction));\n\t\t\tdbgprintf(\"\\tEndTransaction:     %p\\n\", ((pMod->mod.om.endTransaction ==\n\t\t\t\t\t\tdummyEndTransaction) ? NULL :  pMod->mod.om.endTransaction));\n\t\t\tbreak;\n\t\tcase eMOD_IN:\n\t\t\tdbgprintf(\"Input Module Entry Points\\n\");\n\t\t\tdbgprintf(\"\\trunInput:           0x%lx\\n\", (unsigned long) pMod->mod.im.runInput);\n\t\t\tdbgprintf(\"\\twillRun:            0x%lx\\n\", (unsigned long) pMod->mod.im.willRun);\n\t\t\tdbgprintf(\"\\tafterRun:           0x%lx\\n\", (unsigned long) pMod->mod.im.afterRun);\n\t\t\tbreak;\n\t\tcase eMOD_LIB:\n\t\t\tbreak;\n\t\tcase eMOD_PARSER:\n\t\t\tdbgprintf(\"Parser Module Entry Points\\n\");\n\t\t\tdbgprintf(\"\\tparse:              0x%lx\\n\", (unsigned long) pMod->mod.pm.parse);\n\t\t\tbreak;\n\t\tcase eMOD_STRGEN:\n\t\t\tdbgprintf(\"Strgen Module Entry Points\\n\");\n\t\t\tdbgprintf(\"\\tstrgen:            0x%lx\\n\", (unsigned long) pMod->mod.sm.strgen);\n\t\t\tbreak;\n\t\tcase eMOD_FUNCTION:\n\t\t\tdbgprintf(\"Function Module Entry Points\\n\");\n\t\t\tdbgprintf(\"\\tgetFunctArray:     0x%lx\\n\", (unsigned long) pMod->mod.fm.getFunctArray);\n\t\t\tbreak;\n\t\tcase eMOD_ANY: /* this is mostly to keep the compiler happy! */\n\t\t\tbreak;\n\t\t}\n\t\tdbgprintf(\"\\n\");\n\t\tpMod = GetNxt(pMod); /* done, go next */\n\t}\n}\n\n\n/* HUP all modules that support it - except for actions, which\n * need (and have) specialised HUP handling.\n */\nvoid\nmodDoHUP(void)\n{\n\tmodInfo_t *pMod;\n\n\tpthread_mutex_lock(&mutObjGlobalOp);\n\tpMod = GetNxt(NULL);\n\twhile(pMod != NULL) {\n\t\tif(pMod->eType != eMOD_OUT && pMod->doHUP != NULL) {\n\t\t\tDBGPRINTF(\"HUPing module %s\\n\", (char*) modGetName(pMod));\n\t\t\tpMod->doHUP(NULL);\n\t\t}\n\t\tpMod = GetNxt(pMod); /* done, go next */\n\t}\n\tpthread_mutex_unlock(&mutObjGlobalOp);\n}\n\n\n/* unlink and destroy a module. The caller must provide a pointer to the module\n * itself as well as one to its immediate predecessor.\n * rgerhards, 2008-02-26\n */\nstatic rsRetVal\nmodUnlinkAndDestroy(modInfo_t **ppThis)\n{\n\tDEFiRet;\n\tmodInfo_t *pThis;\n\n\tassert(ppThis != NULL);\n\tpThis = *ppThis;\n\tassert(pThis != NULL);\n\n\tpthread_mutex_lock(&mutObjGlobalOp);\n\n\t/* first check if we are permitted to unload */\n\tif(pThis->eType == eMOD_LIB) {\n\t\tif(pThis->uRefCnt > 0) {\n\t\t\tdbgprintf(\"module %s NOT unloaded because it still has a refcount of %u\\n\",\n\t\t\t\t  pThis->pszName, pThis->uRefCnt);\n\t\t\tABORT_FINALIZE(RS_RET_MODULE_STILL_REFERENCED);\n\t\t}\n\t}\n\n\t/* we need to unlink the module before we can destruct it -- rgerhards, 2008-02-26 */\n\tif(pThis->pPrev == NULL) {\n\t\t/* module is root, so we need to set a new root */\n\t\tpLoadedModules = pThis->pNext;\n\t} else {\n\t\tpThis->pPrev->pNext = pThis->pNext;\n\t}\n\n\tif(pThis->pNext == NULL) {\n\t\tpLoadedModulesLast = pThis->pPrev;\n\t} else {\n\t\tpThis->pNext->pPrev = pThis->pPrev;\n\t}\n\n\t/* finally, we are ready for the module to go away... */\n\tdbgprintf(\"Unloading module %s\\n\", modGetName(pThis));\n\tCHKiRet(modPrepareUnload(pThis));\n\t*ppThis = pThis->pNext;\n\n\tmoduleDestruct(pThis);\n\nfinalize_it:\n\tpthread_mutex_unlock(&mutObjGlobalOp);\n\tRETiRet;\n}\n\n\n/* unload all loaded modules of a specific type (use eMOD_ALL if you want to\n * unload all module types). The unload happens only if the module is no longer\n * referenced. So some modules may survive this call.\n * rgerhards, 2008-03-11\n */\nstatic rsRetVal\nmodUnloadAndDestructAll(eModLinkType_t modLinkTypesToUnload)\n{\n\tDEFiRet;\n\tmodInfo_t *pModCurr; /* module currently being processed */\n\n\tpModCurr = GetNxt(NULL);\n\twhile(pModCurr != NULL) {\n\t\tif(modLinkTypesToUnload == eMOD_LINK_ALL || pModCurr->eLinkType == modLinkTypesToUnload) {\n\t\t\tif(modUnlinkAndDestroy(&pModCurr) == RS_RET_MODULE_STILL_REFERENCED) {\n\t\t\t\tpModCurr = GetNxt(pModCurr);\n\t\t\t} else {\n\t\t\t\t/* Note: if the module was successfully unloaded, it has updated the\n\t\t\t\t * pModCurr pointer to the next module. However, the unload process may\n\t\t\t\t * still have indirectly referenced the pointer list in a way that the\n\t\t\t\t * unloaded module is not aware of. So we restart the unload process\n\t\t\t\t * to make sure we do not fall into a trap (what we did ;)). The\n\t\t\t\t * performance toll is minimal. -- rgerhards, 2008-04-28\n\t\t\t\t */\n\t\t\t\tpModCurr = GetNxt(NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tpModCurr = GetNxt(pModCurr);\n\t\t}\n\t}\n\n\tRETiRet;\n}\n\n/* find module with given name in global list */\nstatic rsRetVal\nfindModule(uchar *pModName, int iModNameLen, modInfo_t **pMod)\n{\n\tmodInfo_t *pModInfo;\n\tuchar *pModNameCmp;\n\tDEFiRet;\n\n\tpModInfo = GetNxt(NULL);\n\twhile(pModInfo != NULL) {\n\t\tif(!strncmp((char *) pModName, (char *) (pModNameCmp = modGetName(pModInfo)), iModNameLen) &&\n\t\t   (!*(pModNameCmp + iModNameLen) || !strcmp((char *) pModNameCmp + iModNameLen, \".so\"))) {\n\t\t\tdbgprintf(\"Module '%s' found\\n\", pModName);\n\t\t\tbreak;\n\t\t}\n\t\tpModInfo = GetNxt(pModInfo);\n\t}\n\t*pMod = pModInfo;\n\tRETiRet;\n}\n\n\n/* load a module and initialize it, based on doModLoad() from conf.c\n * rgerhards, 2008-03-05\n * varmojfekoj added support for dynamically loadable modules on 2007-08-13\n * rgerhards, 2007-09-25: please note that the non-threadsafe function dlerror() is\n * called below. This is ok because modules are currently only loaded during\n * configuration file processing, which is executed on a single thread. Should we\n * change that design at any stage (what is unlikely), we need to find a\n * replacement.\n * rgerhards, 2011-04-27:\n * Parameter \"bConfLoad\" tells us if the load was triggered by a config handler, in\n * which case we need to tie the loaded module to the current config. If bConfLoad == 0,\n * the system loads a module for internal reasons, this is not directly tied to a\n * configuration. We could also think if it would be useful to add only certain types\n * of modules, but the current implementation at least looks simpler.\n * Note: pvals = NULL means legacy config system\n */\nstatic rsRetVal ATTR_NONNULL(1)\nLoad(uchar *const pModName, const sbool bConfLoad, struct nvlst *const lst)\n{\n\tsize_t iPathLen, iModNameLen;\n\tint bHasExtension;\n\tvoid *pModHdlr;\n\tpModInit_t pModInit;\n\tmodInfo_t *pModInfo;\n\tcfgmodules_etry_t *pNew = NULL;\n\tcfgmodules_etry_t *pLast = NULL;\n\tuchar *pModDirCurr, *pModDirNext;\n\tint iLoadCnt;\n\tstruct dlhandle_s *pHandle = NULL;\n#\tifdef PATH_MAX\n\tuchar pathBuf[PATH_MAX+1];\n#\telse\n\tuchar pathBuf[4096];\n#\tendif\n\tuchar *pPathBuf = pathBuf;\n\tsize_t lenPathBuf = sizeof(pathBuf);\n\trsRetVal localRet;\n\tcstr_t *load_err_msg = NULL;\n\tDEFiRet;\n\n\tassert(pModName != NULL);\n\tDBGPRINTF(\"Requested to load module '%s'\\n\", pModName);\n\n\tiModNameLen = strlen((char*)pModName);\n\t/* overhead for a full path is potentially 1 byte for a slash,\n\t * three bytes for \".so\" and one byte for '\\0'.\n\t */\n#\tdefine PATHBUF_OVERHEAD 1 + iModNameLen + 3 + 1\n\n\tpthread_mutex_lock(&mutObjGlobalOp);\n\n\tif(iModNameLen > 3 && !strcmp((char *) pModName + iModNameLen - 3, \".so\")) {\n\t\tiModNameLen -= 3;\n\t\tbHasExtension = RSTRUE;\n\t} else\n\t\tbHasExtension = RSFALSE;\n\n\tCHKiRet(findModule(pModName, iModNameLen, &pModInfo));\n\tif(pModInfo != NULL) {\n\t\tDBGPRINTF(\"Module '%s' already loaded\\n\", pModName);\n\t\tif(bConfLoad) {\n\t\t\tlocalRet = readyModForCnf(pModInfo, &pNew, &pLast);\n\t\t\tif(pModInfo->setModCnf != NULL && localRet == RS_RET_OK) {\n\t\t\t\tif(!strncmp((char*)pModName, \"builtin:\", sizeof(\"builtin:\")-1)) {\n\t\t\t\t\tif(pModInfo->bSetModCnfCalled) {\n\t\t\t\t\t\tLogError(0, RS_RET_DUP_PARAM,\n\t\t\t\t\t\t    \"parameters for built-in module %s already set - ignored\\n\",\n\t\t\t\t\t\t    pModName);\n\t\t\t\t\t\tABORT_FINALIZE(RS_RET_DUP_PARAM);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* for built-in moules, we need to call setModConf,\n\t\t\t\t\t\t * because there is no way to set parameters at load\n\t\t\t\t\t\t * time for obvious reasons...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif(lst != NULL)\n\t\t\t\t\t\t\tpModInfo->setModCnf(lst);\n\t\t\t\t\t\tpModInfo->bSetModCnfCalled = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* regular modules need to be added to conf list (for\n\t\t\t\t\t * builtins, this happend during initial load).\n\t\t\t\t\t */\n\t\t\t\t\taddModToCnfList(&pNew, pLast);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFINALIZE;\n\t}\n\n\tpModDirCurr = (uchar *)((pModDir == NULL) ? _PATH_MODDIR : (char *)pModDir);\n\tpModDirNext = NULL;\n\tpModHdlr    = NULL;\n\tiLoadCnt    = 0;\n\tdo {\t/* now build our load module name */\n\t\tif(*pModName == '/' || *pModName == '.') {\n\t\t\tif(lenPathBuf < PATHBUF_OVERHEAD) {\n\t\t\t\tif(pPathBuf != pathBuf) /* already malloc()ed memory? */\n\t\t\t\t\tfree(pPathBuf);\n\t\t\t\t/* we always alloc enough memory for everything we potentiall need to add */\n\t\t\t\tlenPathBuf = PATHBUF_OVERHEAD;\n\t\t\t\tCHKmalloc(pPathBuf = malloc(lenPathBuf));\n\t\t\t}\n\t\t\t*pPathBuf = '\\0';\t/* we do not need to append the path - its already in the module name */\n\t\t\tiPathLen = 0;\n\t\t} else {\n\t\t\t*pPathBuf = '\\0';\n\n\t\t\tiPathLen = strlen((char *)pModDirCurr);\n\t\t\tpModDirNext = (uchar *)strchr((char *)pModDirCurr, ':');\n\t\t\tif(pModDirNext)\n\t\t\t\tiPathLen = (size_t)(pModDirNext - pModDirCurr);\n\n\t\t\tif(iPathLen == 0) {\n\t\t\t\tif(pModDirNext) {\n\t\t\t\t\tpModDirCurr = pModDirNext + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if(iPathLen > lenPathBuf - PATHBUF_OVERHEAD) {\n\t\t\t\tif(pPathBuf != pathBuf) /* already malloc()ed memory? */\n\t\t\t\t\tfree(pPathBuf);\n\t\t\t\t/* we always alloc enough memory for everything we potentiall need to add */\n\t\t\t\tlenPathBuf = iPathLen + PATHBUF_OVERHEAD;\n\t\t\t\tCHKmalloc(pPathBuf = malloc(lenPathBuf));\n\t\t\t}\n\n\t\t\tmemcpy((char *) pPathBuf, (char *)pModDirCurr, iPathLen);\n\t\t\tif((pPathBuf[iPathLen - 1] != '/')) {\n\t\t\t\t/* we have space, made sure in previous check */\n\t\t\t\tpPathBuf[iPathLen++] = '/';\n\t\t\t}\n\t\t\tpPathBuf[iPathLen] = '\\0';\n\n\t\t\tif(pModDirNext)\n\t\t\t\tpModDirCurr = pModDirNext + 1;\n\t\t}\n\n\t\t/* ... add actual name ... */\n\t\tstrncat((char *) pPathBuf, (char *) pModName, lenPathBuf - iPathLen - 1);\n\n\t\t/* now see if we have an extension and, if not, append \".so\" */\n\t\tif(!bHasExtension) {\n\t\t\t/* we do not have an extension and so need to add \".so\"\n\t\t\t * TODO: I guess this is highly importable, so we should change the\n\t\t\t * algo over time... -- rgerhards, 2008-03-05\n\t\t\t */\n\t\t\tstrncat((char *) pPathBuf, \".so\", lenPathBuf - strlen((char*) pPathBuf) - 1);\n\t\t}\n\n\t\t/* complete load path constructed, so ... GO! */\n\t\tdbgprintf(\"loading module '%s'\\n\", pPathBuf);\n\n\t\t/* see if we have this one already */\n\t\tfor (pHandle = pHandles; pHandle; pHandle = pHandle->next) {\n\t\t\tif (!strcmp((char *)pModName, (char *)pHandle->pszName)) {\n\t\t\t\tpModHdlr = pHandle->pModHdlr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* not found, try to dynamically link it */\n\t\tif (!pModHdlr) {\n\t\t\tpModHdlr = dlopen((char *) pPathBuf, RTLD_NOW);\n\t\t}\n\n\t\tif(pModHdlr == NULL) {\n\t\t\tchar errmsg[4096];\n\t\t\tsnprintf(errmsg, sizeof(errmsg), \"%strying to load module %s: %s\",\n\t\t\t\t(load_err_msg == NULL) ? \"\" : \"  ////////  \",\n\t\t\t\tpPathBuf, dlerror());\n\t\t\tif(load_err_msg == NULL) {\n\t\t\t\trsCStrConstructFromszStr(&load_err_msg, (uchar*)errmsg);\n\t\t\t} else {\n\t\t\t\trsCStrAppendStr(load_err_msg, (uchar*)errmsg);\n\t\t\t}\n\t\t}\n\n\t\tiLoadCnt++;\n\t\n\t} while(pModHdlr == NULL && *pModName != '/' && pModDirNext);\n\n\tif(load_err_msg != NULL) {\n\t\tcstrFinalize(load_err_msg);\n\t}\n\n\tif(!pModHdlr) {\n\t\tLogError(0, RS_RET_MODULE_LOAD_ERR_DLOPEN, \"could not load module '%s', errors: %s\", pModName,\n\t\t\t(load_err_msg == NULL) ? \"NONE SEEN???\" : (const char*) cstrGetSzStrNoNULL(load_err_msg));\n\t\tABORT_FINALIZE(RS_RET_MODULE_LOAD_ERR_DLOPEN);\n\t}\n\tif(!(pModInit = (pModInit_t)dlsym(pModHdlr, \"modInit\"))) {\n\t\tLogError(0, RS_RET_MODULE_LOAD_ERR_NO_INIT,\n\t\t\t \t\"could not load module '%s', dlsym: %s\\n\", pPathBuf, dlerror());\n\t\tdlclose(pModHdlr);\n\t\tABORT_FINALIZE(RS_RET_MODULE_LOAD_ERR_NO_INIT);\n\t}\n\tif((iRet = doModInit(pModInit, (uchar*) pModName, pModHdlr, &pModInfo)) != RS_RET_OK) {\n\t\tLogError(0, RS_RET_MODULE_LOAD_ERR_INIT_FAILED,\n\t\t\t\"could not load module '%s', rsyslog error %d\\n\", pPathBuf, iRet);\n\t\tdlclose(pModHdlr);\n\t\tABORT_FINALIZE(RS_RET_MODULE_LOAD_ERR_INIT_FAILED);\n\t}\n\n\tif(bConfLoad) {\n\t\treadyModForCnf(pModInfo, &pNew, &pLast);\n\t\tif(pModInfo->setModCnf != NULL) {\n\t\t\tif(lst != NULL) {\n\t\t\t\tlocalRet = pModInfo->setModCnf(lst);\n\t\t\t\tif(localRet != RS_RET_OK) {\n\t\t\t\t\tLogError(0, localRet,\n\t\t\t\t\t\t\"module '%s', failed processing config parameters\",\n\t\t\t\t\t\tpPathBuf);\n\t\t\t\t\tABORT_FINALIZE(localRet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpModInfo->bSetModCnfCalled = 1;\n\t\t}\n\t\taddModToCnfList(&pNew, pLast);\n\t}\n\nfinalize_it:\n\tif(load_err_msg != NULL) {\n\t\tcstrDestruct(&load_err_msg);\n\t}\n\tif(pPathBuf != pathBuf) /* used malloc()ed memory? */\n\t\tfree(pPathBuf);\n\tif(iRet != RS_RET_OK)\n\t\tabortCnfUse(&pNew);\n\tfree(pNew); /* is NULL again if properly consumed, else clean up */\n\tpthread_mutex_unlock(&mutObjGlobalOp);\n\tRETiRet;\n}\n\n\n/* the v6+ way of loading modules: process a \"module(...)\" directive.\n * rgerhards, 2012-06-20\n */\nrsRetVal\nmodulesProcessCnf(struct cnfobj *o)\n{\n\tstruct cnfparamvals *pvals;\n\tuchar *cnfModName = NULL;\n\tint typeIdx;\n\tDEFiRet;\n\n\tpvals = nvlstGetParams(o->nvlst, &pblk, NULL);\n\tif(pvals == NULL) {\n\t\tABORT_FINALIZE(RS_RET_ERR);\n\t}\n\tDBGPRINTF(\"modulesProcessCnf params:\\n\");\n\tcnfparamsPrint(&pblk, pvals);\n\ttypeIdx = cnfparamGetIdx(&pblk, \"load\");\n\tif(pvals[typeIdx].bUsed == 0) {\n\t\tLogError(0, RS_RET_CONF_RQRD_PARAM_MISSING, \"module type missing\");\n\t\tABORT_FINALIZE(RS_RET_CONF_RQRD_PARAM_MISSING);\n\t}\n\n\tcnfModName = (uchar*)es_str2cstr(pvals[typeIdx].val.d.estr, NULL);\n\tiRet = Load(cnfModName, 1, o->nvlst);\n\t\nfinalize_it:\n\tfree(cnfModName);\n\tcnfparamvalsDestruct(pvals, &pblk);\n\tRETiRet;\n}\n\n\n/* set the default module load directory. A NULL value may be provided, in\n * which case any previous value is deleted but no new one set. The caller-provided\n * string is duplicated. If it needs to be freed, that's the caller's duty.\n * rgerhards, 2008-03-07\n */\nstatic rsRetVal\nSetModDir(uchar *pszModDir)\n{\n\tDEFiRet;\n\n\tdbgprintf(\"setting default module load directory '%s'\\n\", pszModDir);\n\tif(pModDir != NULL) {\n\t\tfree(pModDir);\n\t}\n\n\tpModDir = (uchar*) strdup((char*)pszModDir);\n\n\tRETiRet;\n}\n\n\n/* Reference-Counting object access: add 1 to the current reference count. Must be\n * called by anyone interested in using a module. -- rgerhards, 20080-03-10\n */\nstatic rsRetVal\nUse(const char *srcFile, modInfo_t *pThis)\n{\n\tDEFiRet;\n\n\tassert(pThis != NULL);\n\tpThis->uRefCnt++;\n\tdbgprintf(\"source file %s requested reference for module '%s', reference count now %u\\n\",\n\t\t  srcFile, pThis->pszName, pThis->uRefCnt);\n\n#\tifdef DEBUG\n\tmodUsrAdd(pThis, srcFile);\n#\tendif\n\n\tRETiRet;\n\n}\n\n\n/* Reference-Counting object access: subract one from the current refcount. Must\n * by called by anyone who no longer needs a module. If count reaches 0, the\n * module is unloaded. -- rgerhards, 20080-03-10\n */\nstatic rsRetVal\nRelease(const char *srcFile, modInfo_t **ppThis)\n{\n\tDEFiRet;\n\tmodInfo_t *pThis;\n\n\tassert(ppThis != NULL);\n\tpThis = *ppThis;\n\tassert(pThis != NULL);\n\tif(pThis->uRefCnt == 0) {\n\t\t/* oops, we are already at 0? */\n\t\tdbgprintf(\"internal error: module '%s' already has a refcount of 0 (released by %s)!\\n\",\n\t\t\t  pThis->pszName, srcFile);\n\t} else {\n\t\t--pThis->uRefCnt;\n\t\tdbgprintf(\"file %s released module '%s', reference count now %u\\n\",\n\t\t\t  srcFile, pThis->pszName, pThis->uRefCnt);\n#\t\tifdef DEBUG\n\t\tmodUsrDel(pThis, srcFile);\n\t\tmodUsrPrint(pThis);\n#\t\tendif\n\t}\n\n\tif(pThis->uRefCnt == 0) {\n\t\t/* we have a zero refcount, so we must unload the module */\n\t\tdbgprintf(\"module '%s' has zero reference count, unloading...\\n\", pThis->pszName);\n\t\tmodUnlinkAndDestroy(&pThis);\n\t\t/* we must NOT do a *ppThis = NULL, because ppThis now points into freed memory!\n\t\t * If in doubt, see obj.c::ReleaseObj() for how we are called.\n\t\t */\n\t}\n\n\tRETiRet;\n\n}\n\n\n/* exit our class\n * rgerhards, 2008-03-11\n */\nBEGINObjClassExit(module, OBJ_IS_LOADABLE_MODULE) /* CHANGE class also in END MACRO! */\nCODESTARTObjClassExit(module)\n\t/* release objects we no longer need */\n\tfree(pModDir);\n#\tifdef DEBUG\n\tmodUsrPrintAll(); /* debug aid - TODO: integrate with debug.c, at least the settings! */\n#\tendif\nENDObjClassExit(module)\n\n\n/* queryInterface function\n * rgerhards, 2008-03-05\n */\nBEGINobjQueryInterface(module)\nCODESTARTobjQueryInterface(module)\n\tif(pIf->ifVersion != moduleCURR_IF_VERSION) { /* check for current version, increment on each change */\n\t\tABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);\n\t}\n\n\t/* ok, we have the right interface, so let's fill it\n\t * Please note that we may also do some backwards-compatibility\n\t * work here (if we can support an older interface version - that,\n\t * of course, also affects the \"if\" above).\n\t */\n\tpIf->GetNxt = GetNxt;\n\tpIf->GetNxtCnfType = GetNxtCnfType;\n\tpIf->GetName = modGetName;\n\tpIf->GetStateName = modGetStateName;\n\tpIf->PrintList = modPrintList;\n\tpIf->FindWithCnfName = FindWithCnfName;\n\tpIf->UnloadAndDestructAll = modUnloadAndDestructAll;\n\tpIf->doModInit = doModInit;\n\tpIf->SetModDir = SetModDir;\n\tpIf->Load = Load;\n\tpIf->Use = Use;\n\tpIf->Release = Release;\nfinalize_it:\nENDobjQueryInterface(module)\n\n\n/* Initialize our class. Must be called as the very first method\n * before anything else is called inside this class.\n * rgerhards, 2008-03-05\n */\nBEGINAbstractObjClassInit(module, 1, OBJ_IS_CORE_MODULE) /* class, version - CHANGE class also in END MACRO! */\n\tuchar *pModPath;\n\n\t/* use any module load path specified in the environment */\n\tif((pModPath = (uchar*) getenv(\"RSYSLOG_MODDIR\")) != NULL) {\n\t\tSetModDir(pModPath);\n\t}\n\n\t/* now check if another module path was set via the command line (-M)\n\t * if so, that overrides the environment. Please note that we must use\n\t * a global setting here because the command line parser can NOT call\n\t * into the module object, because it is not initialized at that point. So\n\t * instead a global setting is changed and we pick it up as soon as we\n\t * initialize -- rgerhards, 2008-04-04\n\t */\n\tif(glblModPath != NULL) {\n\t\tSetModDir(glblModPath);\n\t}\n\n\t/* request objects we use */\nENDObjClassInit(module)\n\n/* vi:set ai:\n */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/dns.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/mmutf8fix_no_error.sh",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/test.mmdb",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/with_space.mmdb",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/http.cap",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/testsuites/ksi-sample.log.ksisig",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/resultdata/lmsig_ksi_ls12_async/mockinput.bin",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/resultdata/lmsig_ksi_ls12_async/messages.logsig.parts/blocks.dat",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/tests/resultdata/lmsig_ksi_ls12_async/messages.logsig.parts/block-signatures.dat",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/plugins/omsnmp/mibs/ADISCON-MIB.txt",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/plugins/omsnmp/mibs/ADISCON-MONITORWARE-MIB.txt",
        "/tmp/vanessa/spack-stage/spack-stage-rsyslog-8.2006.0-snqh5glavalavfbyu6fzlsnyo6bcjwlz/spack-src/solaris/cddllicense.txt"
    ],
    "total_files": 1621
}