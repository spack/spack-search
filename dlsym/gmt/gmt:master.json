{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/src/gmt_api.c": "/*--------------------------------------------------------------------\n *\n *\tCopyright (c) 1991-2021 by the GMT Team (https://www.generic-mapping-tools.org/team.html)\n *\tSee LICENSE.TXT file for copying and redistribution conditions.\n *\n *\tThis program is free software; you can redistribute it and/or modify\n *\tit under the terms of the GNU Lesser General Public License as published by\n *\tthe Free Software Foundation; version 3 or any later version.\n *\n *\tThis program is distributed in the hope that it will be useful,\n *\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n *\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *\tGNU Lesser General Public License for more details.\n *\n *\tContact info: www.generic-mapping-tools.org\n *--------------------------------------------------------------------*/\n/*\n * Public functions for the GMT C/C++ API.  The API consist of functions\n * in gmt_api.c, gmt_parse.c, and all the GMT modules; see gmt.h for list.\n *\n * Author: \tPaul Wessel\n * Date:\t1-JUN-2013\n * Version:\t5\n *\n * The API presently consists of 69 documented functions.  For a full\n * description of the API, see the GMT_API documentation.\n * These functions have Fortran bindings as well, provided you add\n * -DFORTRAN_API to the C preprocessor flags [in ConfigUserAdvanced.cmake].\n *\n * There are 2 public functions used for GMT API session handling.\n * This part of the API helps the developer create and delete GMT sessions:\n *\n * GMT_Create_Session\t   : Initialize a new GMT session\n * GMT_Destroy_Session\t   : Destroy a GMT session\n *\n * There is 2 public functions for common error reporting.\n * Errors will be reported to stderr or selected log file:\n *\n * GMT_Message\t\t       : Report an message given a verbosity level\n * GMT_Report\t\t       : Report an error given an error code\n *\n * There are 33 further public functions used for GMT i/o activities:\n *\n * GMT_Alloc_Segment       : Allocate a single DATASET segment\n * GMT_Begin_IO\t           : Allow i/o to take place for rec-by-rec operations\n * GMT_Convert_Data        : Convert between different data sets, if possible\n * GMT_Create_Data         : Return an empty container for a new data set\n * GMT_Destroy_Data        : Destroy a data set and its container\n * GMT_Duplicate_Data      : Make an exact duplicate of a dataset\n * GMT_Duplicate_String    : Allocates a copy of a string to be freed by API\n * GMT_Get_FilePath        : Check existence of file and replace with full path\n * GMT_End_IO              : Disallow further rec-by-rec i/o\n * GMT_Get_Info            : Get meta-data from the object passed\n * GMT_Get_Record          : Get the next single data record from the source(s)\n * GMT_Get_Row             : Read one row from a grid\n * GMT_Get_Status          : Examine current status of record-by-record i/o\n * GMT_Get_Matrix          : Get user matrix from GMT_MATRIX array\n * GMT_Get_Vector          : Get user vector from GMT_VECTOR column\n * GMT_Get_Strings         : Get user strings from GMT_VECTOR or MATRIX container\n * GMT_Init_IO             : Initialize rec-by-rec i/o machinery before program use\n * GMT_Init_VirtualFile    : Reset a virtual file for reuse\n * GMT_Inquire_VirtualFile : Determine family of a virtual file\n * GMT_Open_VirtualFile    : Open a memory location for reading or writing by a module\n * GMT_Put_Levels          : Place an array with 3rd dimension coordinates for a cube\n * GMT_Put_Record          : Send the next output record to its destination\n * GMT_Put_Row             : Write one row to a grid\n * GMT_Put_Matrix          : Hook user matrix to GMT_MATRIX array\n * GMT_Put_Vector          : Hook user vector to GMT_VECTOR column\n * GMT_Put_Strings         : Hook user strings to GMT_VECTOR or MATRIX container\n * GMT_Read_Data           : Load data into program memory from selected source\n * GMT_Read_Group          : Read numerous files into an array of objects\n * GMT_Read_VirtualFile    : Obtain the memory resource that a module wrote to.\n * GMT_Register_IO         : Register a source (or destination) for i/o use\n * GMT_Set_Comment         : Update a comment for a data set\n * GMT_Write_Data          : Place data set from program memory to selected destination\n * GMT_Encode_Options      : Used by external APIs to fill out options from implicit rules\n\n * The above functions deal with registration of input sources (files,\n * streams, file handles, or memory locations) and output destinations\n * (same flavors as input), the setup of the i/o, and generic functions\n * to access the data either in one go (GMT_Get|Put_Data) or on a\n * record-by-record basis (GMT_Get|Put_Record).  Finally, data sets that\n * are allocated can then be destroyed when no longer needed.\n *\n * There are 6 functions that deal with options, defaults and arguments:\n *\n * GMT_Get_Common          : Checks for and returns values for GMT common options\n * GMT_Get_Default         : Return the value of a GMT parameter as a string\n * GMT_Get_Enum            : Return the integer constant of a GMT API enum.\n * GMT_Get_Values          : Convert string to one or more coordinates or dimensions\n * GMT_Set_Default         : Set a GMT parameter via a strings\n * GMT_Option              : Display syntax for one or more GMT common options\n *\n * One function handles the listing of modules and the calling of any GMT module:\n *\n * GMT_Call_Module         : Call the specified GMT module\n *\n * Five functions are used to get grid index from row, col, and to obtain coordinates\n *\n * GMT_Get_Coord           : Return array of coordinates for one dimension\n * GMT_Get_Index           : Return 1-D grid index given row, col\n * GMT_Get_Index3          : Return 1-D cube index given row, col, layer\n * GMT_Get_Pixel           : Return 1-D image index given row, col, layer\n * GMT_Set_Columns         : Specify number of output columns for rec-by-rec writing\n *\n * For FFT operations there are 8 additional API functions:\n *\n * GMT_FFT                 : Call the forward or inverse FFT\n * GMT_FFT_1D              : Lower-level 1-D FFT call\n * GMT_FFT_2D              : Lower-level 2-D FFT call\n * GMT_FFT_Create          : Initialize the FFT machinery for given dimension\n * GMT_FFT_Destroy         : Destroy FFT machinery\n * GMT_FFT_Option          : Display the syntax of the GMT FFT option settings\n * GMT_FFT_Parse           : Parse the GMT FFT option\n * GMT_FFT_Wavenumber      : Return selected wavenumber given its type\n *\n * There are also 13 functions for argument and option parsing.  See gmt_parse.c for these.\n *\n * Finally, three low-level F77-callable functions for grid i/o are given:\n *\n * gmt_f77_readgrdinfo_    : Read the header of a GMT grid\n * gmt_f77_readgrd_        : Read a GMT grid from file\n * gmt_f77_writegrd_       : Write a GMT grid to file\n *\n * --------------------------------------------------------------------------------------------\n * Guru notes on memory management: Paul Wessel, June 2013.\n *\n * GMT maintains control over allocating, reallocating, and freeing of GMT objects created by GMT.\n * Because GMT_modules may be given files, memory locations, streams, etc., as input and output we\n * have to impose some structure as how this will work seamlessly.  Here, \"GMT object\" refers to\n * any of the 5 GMT resources: grids, images, datasets, palettes, and PostScript.\n *\n * 1. When GMT allocates memory for a GMT object it sets its alloc_mode to GMT_ALLOC_INTERNALLY (1)\n *    and its alloc_level to <module level>.  This is 0 for the gmt.c UNIX application as well as\n *    for any external API (MEX, Python, Julia), 1 for any GMT module called, 2 for modules called\n *    by top-level modules, etc., as far down as the thread goes.\n * 2. Memory not allocated by GMT will have an implicit alloc_mode = GMT_ALLOC_EXTERNALLY [0]\n *    and alloc_level = 0 (i.e., gmt executable or API level) but it does not matter since such memory is\n *    only used for reading and we may never free it or reallocate it within GMT. This alloc_mode\n *    only applies to data arrays inside objects (e.g., G->data), not the GMT objects themselves.\n *    The GMT objects (the \"containers\") are freed at the end of their level, if not before.\n * 3. Memory passed into modules as \"input file\" requires no special treatment since its level\n *    will be lower than that of the module it is used in, and when that module tries to free it\n *    (directly with GMT_Destroy_Data or via end-of-module gmtlib_garbage_collection) it will skip\n *    it as its level does not match the current module level.  A module can only free memory that\n *    it allocated; the exception is the top-level gmt application.\n * 4. Passing memory out of a module (i.e., \"writing to memory\") requires that the calling function\n *    first create an output object and use the ID to encode the memory filename (@GMTAPI@-######).\n *    The object stores the level it was called at.  Pass the encoded filename as the output file.\n *    When GMT_Create_Data is called with no dimensions then the direction is set to GMT_OUT and\n *    we set the object's messenger flag to true.  This is used so that when the dataset we wish to\n *    return out of a module is built it replaces the empty initial dataset but inherits that dataset's\n *    alloc_level so it may survive the life of the module process.\n *    Internally, the memory that the module allocates (e.g., grid, dataset, etc.) will initially\n *    have an alloc_level matching the module level (and would be freed if written to a regular\n *    file).  However, when GMT_Write_Data is called and we branch into the GMT_REFERENCE case we\n *    instead take the following steps:\n *\ta) The registered output API->object's resource pointer is set to the GMT object that the\n *         module allocated (this is how we pass the data out of a module).\n *\tb) The GMT object's alloc_level is changed to equal the output API->object's level (this\n *         is how it will survive beyond the end of the module).\n *\tc) The API object originally pointing to the GMT object is flagged by having its variable\n *         no_longer_owner set to true (this is how we avoid freeing something twice).\n *    When the module ends there are two API objects with references to the GMT object: the internal\n *    module object and the output object.  The first is set to NULL by gmtlib_garbage_collection because\n *    the object is no longer the owner of the data. The second is ignored because its level is too low.\n *    After that any empty API objects are removed (so the no_longer_owner one is removed), while\n *    the second survives the life of the module, as we require.\n *\n * Thus, at the session (gmt) level all GMT objects have alloc_level = 0 since anything higher will\n * have been freed by a module.  GMT_Destroy_Session finally calls gmtlib_garbage_collection a final\n * time and he frees any remaining GMT objects.\n *\n * Notes on family vs actual_family:\n * The S->actual_family contains the object type that we allocated.  However, we allow modules\n * that expect a DATASET to instead be passed a GMT_VECTOR or GMT_MATRIX.  If so then S->family\n * will be GMT_IS_DATASET while the actual_family remains GMT_VECTOR|GMT_MATRIX.  The i/o functions\n * GMT_Read_Data, GMT_Put_Record, etc knows how to deal with this.\n */\n\n/*!\n * \\file gmt_api.c\n * \\brief Public functions for the GMT C/C++ API.\n */\n\n#include \"gmt_dev.h\"\n#include \"gmt_internals.h\"\n#include \"gmt_sharedlibs.h\" \t/* Common shared libs structures */\n#include <stdarg.h>\n\n#ifdef HAVE_DIRENT_H_\n#\tinclude <dirent.h>\n#endif\n\n#ifdef HAVE_SYS_DIR_H_\n#\tinclude <sys/dir.h>\n#endif\n\n/* Possibly define missing shared library constants */\n#ifndef DT_DIR\n#\tdefine DT_DIR 4\n#endif\n\n#ifndef RTLD_LAZY\n#\tdefine RTLD_LAZY 1\n#endif\n\n#ifdef WIN32\t/* Special for Windows */\n#\tinclude <process.h>\n#\tdefine getpid _getpid\n#endif\n\n#define GMTAPI_MAX_ID 999999\t/* Largest integer that will fit in the %06d format */\n#define GMTAPI_UNLIMITED\t0\t/* Using 0 to mean we may allow 1 or more data objects of this family */\n\n#ifdef FORTRAN_API\n/* Global structure pointer needed for FORTRAN-77 [PW: not tested yet - is it even needed?] */\nstatic struct GMTAPI_CTRL *GMT_FORTRAN = NULL;\n#endif\n\nstatic int GMTAPI_session_counter = 0;\t/* Keeps track of the ID of new sessions for multi-session programs */\n\n/* Grid node lookup */\nstatic uint64_t (*GMTAPI_index_function) (struct GMT_GRID_HEADER *, uint64_t, uint64_t, uint64_t);\t/* Pointer to index function (for images only) */\n\n/*! Macros that report error, then return a NULL pointer, the error, or a value, respectively */\n#define return_null(API,err) { gmtlib_report_error(API,err); return (NULL);}\n#define return_error(API,err) { gmtlib_report_error(API,err); return (err);}\n#define return_value(API,err,val) { gmtlib_report_error(API,err); return (val);}\n\n/* We asked for subset of grid if the wesn pointer is not NULL and indicates a nonzero region */\n#define full_region(wesn) (!wesn || (wesn[XLO] == wesn[XHI] && wesn[YLO] == wesn[YHI]))\n\n/* DATASET can be given via many individual files. */\n#define multiple_files_ok(family) (family == GMT_IS_DATASET)\n/* GRID and IMAGE can be read it two steps (header, then data). */\n#define a_grid_or_image(family) (family == GMT_IS_GRID || family == GMT_IS_IMAGE)\n/* GRID, IMAGE, and DATACUBE can be read it two steps (header, then data). */\n#define a_grid_or_image_or_cube(family) (family == GMT_IS_GRID || family == GMT_IS_IMAGE || family == GMT_IS_CUBE)\n/* A MATRIX read as a SURFACE will read a grid */\n#define a_matrix_surface(family,geometry) (family == GMT_IS_MATRIX && geometry == GMT_IS_SURFACE)\n\n/* Misc. local text strings needed in this file only, used when debug verbose is on (-Vd).\n * NOTE: The order of these MUST MATCH the order in the enums in gmt_resources.h! */\n\nstatic const char *GMT_method[] = {\"File\", \"Stream\", \"File Descriptor\", \"Memory Copy\", \"Memory Reference\"};\nstatic const char *GMT_family[] = {\"Data Table\", \"Grid\", \"Image\", \"CPT\", \"PostScript\", \"Matrix\", \"Vector\", \"Cube\", \"Coord\"};\nstatic const char *GMT_direction[] = {\"Input\", \"Output\"};\nstatic const char *GMT_stream[] = {\"Standard\", \"User-supplied\"};\nstatic const char *GMT_status[] = {\"Unused\", \"In-use\", \"Used\"};\nstatic const char *GMT_geometry[] = {\"Not Set\", \"Point\", \"Line\", \"Polygon\", \"Point|Line|Poly\", \"Line|Poly\", \"Surface\", \"Volume\", \"Non-Geographical\", \"Text\"};\nstatic const char *GMT_class[] = {\"QUIET\", \"NOTICE\", \"ERROR\", \"WARNING\", \"TIMING\", \"INFORMATION\", \"COMPATIBILITY\", \"DEBUG\"};\nstatic unsigned int GMT_no_pad[4] = {0, 0, 0, 0};\nstatic const char *GMT_family_abbrev[] = {\"D\", \"G\", \"I\", \"C\", \"X\", \"M\", \"V\", \"U\", \"-\"};\n\n/*! Two different i/o mode: GMT_Put|Get_Data vs GMT_Put|Get_Record */\nenum GMT_enum_iomode {\n\tGMTAPI_BY_SET \t= 0,\t/* Default is to read the entire dataset or texset */\n\tGMTAPI_BY_REC\t= 1};\t/* Means we will access the registere files on a record-by-record basis */\n\n/*! Entries into dim[] for matrix or vector */\nenum GMT_dim {\n\tGMTAPI_HDR_POS = 3,\t/* Used with curr_pos to keep track of table headers only */\n\tGMTAPI_DIM_COL\t= 0,\t/* Holds the number of columns for vectors and x-nodes for matrix */\n\tGMTAPI_DIM_ROW = 1};\t/* Holds the number of rows for vectors and y-nodes for matrix */\n\nenum GMTAPI_enum_input {\n\tGMTAPI_OPTION_INPUT \t= 0,\t/* Input resource specified via an option (e.g., -G<file>) */\n\tGMTAPI_MODULE_INPUT \t= 1};\t/* Input resource specified via the module command line */\n\nenum GMTAPI_enum_status {\n\tGMTAPI_GOT_SEGHEADER \t= -1,\t/* Read a segment header */\n\tGMTAPI_GOT_SEGGAP \t= -2};\t/* Detected a gap and insertion of new segment header */\n\n/*==================================================================================================\n *\t\tPRIVATE FUNCTIONS ONLY USED BY THIS LIBRARY FILE\n *==================================================================================================\n *\n * gmtapi_* functions are static and only used in gmt_api.c\n * gmtlib_* functions are exported and may be used in other gmt_*.c files\n */\n\nGMT_LOCAL const char *gmtapi_method (unsigned int M) {\n\tif (M < GMT_IS_DUPLICATE) return (GMT_method[M]);\n\tif (M == GMT_IS_DUPLICATE) return (GMT_method[3]);\n\tif (M == GMT_IS_REFERENCE) return (GMT_method[4]);\n\treturn NULL;\n}\n\nGMT_LOCAL void gmtapi_get_record_init (struct GMTAPI_CTRL *API);\n\nGMT_LOCAL int gmtapi_sort_on_classic (const void *vA, const void *vB) {\n\tconst struct GMT_MODULEINFO *A = vA, *B = vB;\n\tif (A == NULL) return +1;\t/* Get the NULL entry to the end */\n\tif (B == NULL) return -1;\t/* Get the NULL entry to the end */\n\treturn strcmp(A->cname, B->cname);\n}\n\nGMT_LOCAL int gmtapi_sort_on_modern (const void *vA, const void *vB) {\n\tconst struct GMT_MODULEINFO *A = vA, *B = vB;\n\tif (A == NULL) return +1;\t/* Get the NULL entry to the end */\n\tif (B == NULL) return -1;\t/* Get the NULL entry to the end */\n\treturn strcmp(A->mname, B->mname);\n}\n\n\n/* Function to exclude some special core modules from being reported by gmt --help|show-modules */\nGMT_LOCAL int gmtapi_skip_this_module (const char *name) {\n\tif (!strncmp (name, \"gmtread\", 7U)) return 1;\t/* Skip the gmtread module */\n\tif (!strncmp (name, \"gmtwrite\", 8U)) return 1;\t/* Skip the gmtwrite module */\n\treturn 0;\t/* Display this one */\n}\n\n/* Function to exclude modern mode modules from being reported by gmt --show-classic */\nGMT_LOCAL int gmtapi_skip_modern_module (const char *name) {\n\tif (!strncmp (name, \"subplot\", 7U)) return 1;\t/* Skip the subplot module */\n\tif (!strncmp (name, \"figure\", 6U)) return 1;\t/* Skip the figure module */\n\tif (!strncmp (name, \"begin\", 5U)) return 1;\t\t/* Skip the begin module */\n\tif (!strncmp (name, \"clear\", 5U)) return 1;\t\t/* Skip the clear module */\n\tif (!strncmp (name, \"inset\", 5U)) return 1;\t\t/* Skip the inset module */\n\tif (!strncmp (name, \"movie\", 5U)) return 1;\t\t/* Skip the movie module */\n\tif (!strncmp (name, \"docs\", 4U)) return 1;\t\t/* Skip the docs module */\n\tif (!strncmp (name, \"end\", 3U)) return 1;\t\t/* Skip the end module */\n\treturn 0;\t/* Display this one */\n}\n\nEXTERN_MSC int gmt_nc_write_cube (struct GMT_CTRL *GMT, struct GMT_CUBE *C, double wesn[], const char *file);\n\n/* Pretty print all GMT core module names and their purposes for gmt --help */\nvoid gmtlib_module_show_all (void *V_API, struct GMT_MODULEINFO M[], const char *title) {\n\tunsigned int module_id = 0, n;\n\tchar message[GMT_LEN256];\n\tstruct GMTAPI_CTRL *API = gmt_get_api_ptr (V_API);\n\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\n===  %s  ===\\n\", title);\n\twhile (M[module_id].cname != NULL) {\n\t\tif (module_id == 0 || strcmp (M[module_id-1].component, M[module_id].component)) {\n\t\t\t/* Start of new supplemental group */\n\t\t\tsnprintf (message, GMT_LEN256, \"\\nModule name:     Purpose of %s module:\\n\", M[module_id].component);\n\t\t\tGMT_Message (V_API, GMT_TIME_NONE, message);\n\t\t\tGMT_Message (V_API, GMT_TIME_NONE, \"----------------------------------------------------------------\\n\");\n\t\t}\n\t\tn = module_id + 1;\t/* Determine extent of this component lib */\n\t\twhile (M[n].cname != NULL && !strcmp (M[n-1].component, M[n].component)) n++;\n\t\t/* Sort array on modern names */\n\t\tqsort (&M[module_id], n-module_id, sizeof (struct GMT_MODULEINFO), gmtapi_sort_on_modern);\n\n\t\tif (API->external || !gmtapi_skip_this_module (M[module_id].cname)) {\n\t\t\tsnprintf (message, GMT_LEN256, \"%-16s %s\\n\",\n\t\t\t\tM[module_id].mname, M[module_id].purpose);\n\t\t\t\tGMT_Message (V_API, GMT_TIME_NONE, message);\n\t\t}\n\t\t++module_id;\n\t}\n}\n\n/* Produce single list on stdout of all GMT core module names for gmt --show-modules */\nvoid gmtlib_module_list_all (void *V_API, struct GMT_MODULEINFO M[]) {\n\tunsigned int module_id = 0;\n\tsize_t n_modules = 0;\n\tstruct GMTAPI_CTRL *API = gmt_get_api_ptr (V_API);\n\n\twhile (M[n_modules].cname != NULL)\t/* Count the modules */\n\t\t++n_modules;\n\n\t/* Sort array on modern names */\n\tqsort (M, n_modules, sizeof (struct GMT_MODULEINFO), gmtapi_sort_on_modern);\n\n\twhile (M[module_id].cname != NULL) {\n\t\tif (API->external || !gmtapi_skip_this_module (M[module_id].cname))\n\t\t\tprintf (\"%s\\n\", M[module_id].mname);\n\t\t++module_id;\n\t}\n}\n\n/* Produce single list on stdout of all GMT core module names for gmt --show-classic [i.e., classic mode names] */\nvoid gmtlib_module_classic_all (void *V_API, struct GMT_MODULEINFO M[]) {\n\tunsigned int module_id = 0;\n\tsize_t n_modules = 0;\n\tstruct GMTAPI_CTRL *API = gmt_get_api_ptr (V_API);\n\n\twhile (M[n_modules].cname != NULL)\t/* Count the modules */\n\t\t++n_modules;\n\n\t/* Sort array on classic names */\n\tqsort (M, n_modules, sizeof (struct GMT_MODULEINFO), gmtapi_sort_on_classic);\n\n\twhile (M[module_id].cname != NULL) {\n\t\tif (API->external || !(gmtapi_skip_this_module (M[module_id].cname) || gmtapi_skip_modern_module (M[module_id].cname)))\n\t\t\tprintf (\"%s\\n\", M[module_id].cname);\n\t\t++module_id;\n\t}\n}\n\n/* Lookup module id by name, return option keys pointer (for external API developers) */\nconst char *gmtlib_module_keys (void *API, struct GMT_MODULEINFO M[], char *candidate) {\n\tint module_id = 0;\n\tgmt_M_unused(API);\n\n\t/* Match actual_name against g_module[module_id].cname */\n\twhile (M[module_id].cname != NULL &&\n\t       strcmp (candidate, M[module_id].cname))\n\t\t++module_id;\n\n\t/* Return Module keys or NULL */\n\treturn (M[module_id].keys);\n}\n\n/* Lookup module id by name, return group char name (for external API developers) */\nconst char *gmtlib_module_group (void *API, struct GMT_MODULEINFO M[], char *candidate) {\n\tint module_id = 0;\n\tgmt_M_unused(API);\n\n\t/* Match actual_name against g_module[module_id].cname */\n\twhile (M[module_id].cname != NULL &&\n\t       strcmp (candidate, M[module_id].cname))\n\t\t++module_id;\n\n\t/* Return Module keys or NULL */\n\treturn (M[module_id].component);\n}\n\nint GMT_Show_ModuleInfo (void *API, struct GMT_MODULEINFO M[], char *arg, unsigned int mode) {\n\t/* API function to display module information from shared libraries */\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tswitch (mode) {\n\t\tcase GMT_MODULE_HELP:\n\t\t\tif (arg == NULL) return_error (API, GMT_ARG_IS_NULL);\n\t\t\tgmtlib_module_show_all (API, M, arg);\n\t\t\tbreak;\n\t\tcase GMT_MODULE_SHOW_MODERN:\n\t\t\tgmtlib_module_list_all (API, M);\n\t\t\tbreak;\n\t\tcase GMT_MODULE_SHOW_CLASSIC:\n\t\t\tgmtlib_module_classic_all (API, M);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Internal error in GMT_Show_ModuleInfo: Passed bad mode (%d)\\n\", mode);\n\t\t\treturn_error (API, GMT_NOT_A_VALID_MODE);\n\t\t\tbreak;\n\t}\n\treturn (GMT_NOERROR);\n}\n\nconst char * GMT_Get_ModuleInfo (void *API, struct GMT_MODULEINFO M[], char *module, unsigned int mode) {\n\t/* API function to display module information from shared libraries */\n\tconst char *answer = NULL;\n\tif (API == NULL) return_null (NULL, GMT_NOT_A_SESSION);\n\tif (module == NULL) return_null (NULL, GMT_ARG_IS_NULL);\n\tswitch (mode) {\n\t\tcase GMT_MODULE_KEYS:\n\t\t\tanswer = gmtlib_module_keys (API, M, module);\n\t\t\tbreak;\n\t\tcase GMT_MODULE_GROUP:\n\t\t\tanswer = gmtlib_module_group (API, M, module);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Internal error in GMT_Get_ModuleInfo: Passed bad mode (%d)\\n\", mode);\n\t\t\treturn_null (NULL, GMT_NOT_A_VALID_MODE);\n\t\t\tbreak;\n\t}\n\treturn (answer);\n}\n\n/* Series of one-line functions to assign val to a particular union member of array u at position row, rounding if integer output */\nGMT_LOCAL void gmtapi_put_val_double (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->f8[row]  =                  val; }\nGMT_LOCAL void gmtapi_put_val_float  (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->f4[row]  = (float)          val; }\nGMT_LOCAL void gmtapi_put_val_ulong  (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->ui8[row] = (uint64_t)lrint(val); }\nGMT_LOCAL void gmtapi_put_val_long   (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->si8[row] =  (int64_t)lrint(val); }\nGMT_LOCAL void gmtapi_put_val_uint   (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->ui4[row] = (uint32_t)lrint(val); }\nGMT_LOCAL void gmtapi_put_val_int    (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->si4[row] =  (int32_t)lrint(val); }\nGMT_LOCAL void gmtapi_put_val_ushort (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->ui2[row] = (uint16_t)lrint(val); }\nGMT_LOCAL void gmtapi_put_val_short  (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->si2[row] =  (int16_t)lrint(val); }\nGMT_LOCAL void gmtapi_put_val_uchar  (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->uc1[row] =  (uint8_t)lrint(val); }\nGMT_LOCAL void gmtapi_put_val_char   (union GMT_UNIVECTOR *u, uint64_t row, double val) { u->sc1[row] =   (int8_t)lrint(val); }\n\nGMT_LOCAL void gmtapi_get_val_double (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->f8[row]; }\nGMT_LOCAL void gmtapi_get_val_float  (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->f4[row]; }\nGMT_LOCAL void gmtapi_get_val_ulong  (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = (double)u->ui8[row]; }\t/* Must cast/truncate since longs integer range exceed that of double */\nGMT_LOCAL void gmtapi_get_val_long   (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = (double)u->si8[row]; }\t/* Must cast/truncate since longs integer range exceed that of double */\nGMT_LOCAL void gmtapi_get_val_uint   (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->ui4[row]; }\nGMT_LOCAL void gmtapi_get_val_int    (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->si4[row]; }\nGMT_LOCAL void gmtapi_get_val_ushort (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->ui2[row]; }\nGMT_LOCAL void gmtapi_get_val_short  (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->si2[row]; }\nGMT_LOCAL void gmtapi_get_val_uchar  (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->uc1[row]; }\nGMT_LOCAL void gmtapi_get_val_char   (union GMT_UNIVECTOR *u, uint64_t row, double *val) { *val = u->sc1[row]; }\n\nGMT_LOCAL inline GMT_putfunction gmtapi_select_put_function (struct GMTAPI_CTRL *API, unsigned int type) {\n\tswitch (type) {\t/* Use type to select the correct put function with which to place a value in the union */\n\t\tcase GMT_DOUBLE:\treturn (gmtapi_put_val_double);\tbreak;\n\t\tcase GMT_FLOAT:\t\treturn (gmtapi_put_val_float);\tbreak;\n\t\tcase GMT_ULONG:\t\treturn (gmtapi_put_val_ulong);\tbreak;\n\t\tcase GMT_LONG:\t\treturn (gmtapi_put_val_long);\tbreak;\n\t\tcase GMT_UINT:\t\treturn (gmtapi_put_val_uint);\tbreak;\n\t\tcase GMT_INT:\t\treturn (gmtapi_put_val_int);\tbreak;\n\t\tcase GMT_USHORT:\treturn (gmtapi_put_val_ushort);\tbreak;\n\t\tcase GMT_SHORT:\t\treturn (gmtapi_put_val_short);\tbreak;\n\t\tcase GMT_UCHAR:\t\treturn (gmtapi_put_val_uchar);\tbreak;\n\t\tcase GMT_CHAR:\t\treturn (gmtapi_put_val_char);\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Internal error in gmtapi_select_put_function: Passed bad type (%d), Will be unable to place binary data\\n\", type);\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t}\n}\n\nGMT_LOCAL inline GMT_getfunction gmtapi_select_get_function (struct GMTAPI_CTRL *API, unsigned int type) {\n\tswitch (type) {\t/* Use type to select the correct get function with which to extract a value from the union */\n\t\tcase GMT_DOUBLE:\treturn (gmtapi_get_val_double);\tbreak;\n\t\tcase GMT_FLOAT:\t\treturn (gmtapi_get_val_float);\tbreak;\n\t\tcase GMT_ULONG:\t\treturn (gmtapi_get_val_ulong);\tbreak;\n\t\tcase GMT_LONG:\t\treturn (gmtapi_get_val_long);\tbreak;\n\t\tcase GMT_UINT:\t\treturn (gmtapi_get_val_uint);\tbreak;\n\t\tcase GMT_INT:\t\treturn (gmtapi_get_val_int);\tbreak;\n\t\tcase GMT_USHORT:\treturn (gmtapi_get_val_ushort);\tbreak;\n\t\tcase GMT_SHORT:\t\treturn (gmtapi_get_val_short);\tbreak;\n\t\tcase GMT_UCHAR:\t\treturn (gmtapi_get_val_uchar);\tbreak;\n\t\tcase GMT_CHAR:\t\treturn (gmtapi_get_val_char);\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Internal error in gmtapi_select_get_function: Passed bad type (%d), will be unable to convert binary data\\n\", type);\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t}\n}\n\nGMT_LOCAL bool gmtapi_valid_input_family (unsigned int family) {\n\t/* Return true for the main input types */\n\treturn (family == GMT_IS_DATASET || family == GMT_IS_GRID || family == GMT_IS_CUBE \\\n\t       || family == GMT_IS_IMAGE || family == GMT_IS_PALETTE || family == GMT_IS_POSTSCRIPT);\n}\n\nGMT_LOCAL bool gmtapi_valid_actual_family (unsigned int family) {\n\t/* Return true for the main actual family types */\n\treturn (family < GMT_N_FAMILIES);\n}\n\nGMT_LOCAL bool gmtapi_valid_output_family (unsigned int family) {\n\tif (family == GMT_IS_VECTOR || family == GMT_IS_MATRIX || family == GMT_IS_POSTSCRIPT) return true;\n\treturn gmtapi_valid_input_family (family);\n}\n\nGMT_LOCAL bool gmtapi_valid_via_family (unsigned int family) {\n\tif (family == GMT_IS_VECTOR || family == GMT_IS_MATRIX) return true;\n\treturn false;\n}\n\nGMT_LOCAL bool gmtapi_valid_type (int type) {\t/* Check for valid matrix/vector data types */\n\tif (type < GMT_CHAR || type > GMT_DOUBLE) return false;\n\treturn true;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_get_item (struct GMTAPI_CTRL *API, unsigned int family, void *data) {\n\t/* Get the first item of requested family from list of objects, allowing for\n\t * datasets and grids to masquerade as other things (Matrix, vector). */\n\tunsigned int i;\n\tint item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tAPI->error = GMT_NOERROR;\n\tfor (i = 0, item = GMT_NOTSET; item == GMT_NOTSET && i < API->n_objects; i++) {\n\t\tif (!API->object[i]) continue;\t\t\t\t/* Empty object */\n\t\tS_obj = API->object[i];\n\t\tif (!S_obj->resource) continue;\t\t/* No resource */\n\t\tif (S_obj->family != (enum GMT_enum_family)family) {\t\t/* Not the required data type; check for exceptions... */\n\t\t\tif (family == GMT_IS_DATASET && gmtapi_valid_via_family (S_obj->family))\n\t\t\t\tS_obj->family = GMT_IS_DATASET;\t/* Vectors or Matrix masquerading as dataset are valid. Change their family here. */\n\t\t\telse if (family == GMT_IS_GRID && S_obj->family == GMT_IS_MATRIX)\n\t\t\t\tS_obj->family = GMT_IS_GRID;\t/* Matrix masquerading as grid is valid. Change its family here. */\n\t\t\telse\t/* We don't like your kind */\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (S_obj->resource == data) item = i;\t/* Found the requested data */\n\t}\n\tif (item == GMT_NOTSET) { API->error = GMT_NOT_A_VALID_ID; return (GMT_NOTSET); }\t/* No such data found */\n\treturn (item);\n}\n\n/*! . */\nGMT_LOCAL inline uint64_t gmtapi_n_cols_needed_for_gaps (struct GMT_CTRL *GMT, uint64_t n) {\n\t/* Return the actual items needed (which may be more than n if gap testing demands it) */\n\tif (GMT->common.g.active) return (MAX (n, GMT->common.g.n_col));\t/* n or n_col (if larger) */\n\treturn (n);\t/* No gap checking, n it is */\n}\n\n/*! . */\nGMT_LOCAL inline void gmtapi_update_prev_rec (struct GMT_CTRL *GMT, uint64_t n_use) {\n\t/* Update previous record before reading the new record, but only if needed */\n\tif (GMT->current.io.need_previous) gmt_M_memcpy (GMT->current.io.prev_rec, GMT->current.io.curr_rec, n_use, double);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_alloc_grid (struct GMT_CTRL *GMT, struct GMT_GRID *G) {\n\t/* Use information in Grid header to allocate the grid data array.\n\t * We assume gmtapi_init_grdheader has already been called. */\n\tstruct GMT_GRID_HEADER_HIDDEN *GH = NULL;\n\tif (G == NULL) return (GMT_PTR_IS_NULL);\n\tGH = gmt_get_H_hidden (G->header);\n\tif (G->data) return (GMT_PTR_NOT_NULL);\n\tif (G->header->size == 0U) return (GMT_SIZE_IS_ZERO);\n\tif ((G->data = gmt_M_memory_aligned (GMT, NULL, G->header->size, gmt_grdfloat)) == NULL) return (GMT_MEMORY_ERROR);\n\tGH->orig_datatype = (sizeof (gmt_grdfloat) == sizeof (float)) ? GMT_FLOAT : GMT_DOUBLE;\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL double * gmtapi_grid_coord (struct GMTAPI_CTRL *API, int dim, struct GMT_GRID *G) {\n\treturn (gmt_grd_coord (API->GMT, G->header, dim));\n}\n\n/*! . */\nGMT_LOCAL double * gmtapi_cube_coord (struct GMTAPI_CTRL *API, int dim, struct GMT_CUBE *U) {\n\treturn (gmt_grd_coord (API->GMT, U->header, dim));\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_alloc_grid_xy (struct GMTAPI_CTRL *API, struct GMT_GRID *G) {\n\t/* Use information in Grid header to allocate the grid x/y vectors.\n\t * We assume gmtapi_init_grdheader has been called. */\n\tstruct GMT_GRID_HIDDEN *GH = NULL;\n\tif (G == NULL) return (GMT_PTR_IS_NULL);\n\tif (G->x || G->y) return (GMT_PTR_NOT_NULL);\n\tGH = gmt_get_G_hidden (G);\n\tG->x = gmtapi_grid_coord (API, GMT_X, G);\t/* Get array of x coordinates */\n\tG->y = gmtapi_grid_coord (API, GMT_Y, G);\t/* Get array of y coordinates */\n\tGH->xy_alloc_mode[GMT_X] = GH->xy_alloc_mode[GMT_Y] = GMT_ALLOC_INTERNALLY;\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_alloc_image (struct GMT_CTRL *GMT, uint64_t *dim, unsigned int mode, struct GMT_IMAGE *I) {\n\t/* Use information in Image header to allocate the image data.\n\t * We assume gmtapi_init_grdheader has been called.\n\t * If dim given and is 2 or 4 then we have 1 or 3 bands plus alpha channel\n\t * Depending on mode, the alpha layer is part of image or separate array. */\n\tunsigned int n_bands = I->header->n_bands;\n\n\tif (I == NULL) return (GMT_PTR_IS_NULL);\n\tif (I->data) return (GMT_PTR_NOT_NULL);\n\tif (I->header->size == 0U) return (GMT_SIZE_IS_ZERO);\n\tif (dim && (dim[GMT_Z] == 2 || dim[GMT_Z] == 4)) {\t/* Transparency layer is requested */\n\t\tif ((mode & GMT_IMAGE_ALPHA_LAYER) == 0) {\t/* Use a separate alpha array */\n\t\t\tif ((I->alpha = gmt_M_memory_aligned (GMT, NULL, I->header->size, unsigned char)) == NULL) return (GMT_MEMORY_ERROR);\n\t\t\tn_bands--;\t/* One less layer to allocate */\n\t\t}\n\t}\n\tif ((I->data = gmt_M_memory_aligned (GMT, NULL, I->header->size * n_bands, unsigned char)) == NULL) return (GMT_MEMORY_ERROR);\n\tI->header->n_bands = n_bands;\t/* Update as needed */\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL double * gmtapi_image_coord (struct GMTAPI_CTRL *API, int dim, struct GMT_IMAGE *I) {\n\treturn (gmt_grd_coord (API->GMT, I->header, dim));\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_alloc_image_xy (struct GMTAPI_CTRL *API, struct GMT_IMAGE *I) {\n\t/* Use information in Grid header to allocate the image x,y vectors.\n\t * We assume gmtapi_init_grdheader has been called. */\n\tif (I == NULL) return (GMT_PTR_IS_NULL);\n\tif (I->x || I->y) return (GMT_PTR_NOT_NULL);\n\tI->x = gmtapi_image_coord (API, GMT_X, I);\t/* Get array of x coordinates */\n\tI->y = gmtapi_image_coord (API, GMT_Y, I);\t/* Get array of y coordinates */\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_print_func (FILE *fp, const char *message) {\n\t/* Just print this message to fp.  It is being used indirectly via\n\t * API->print_func.  Purpose of this mechanism is to allow external APIs such\n\t * as MATLAB (which cannot use printf) to reset API->print_func to\n\t * mexPrintf or similar functions. Default is gmtapi_print_func. */\n\n\tfprintf (fp, \"%s\", message);\n\treturn 0;\n}\n\n/*! . */\nGMT_LOCAL unsigned int gmtapi_gmtry (unsigned int geometry) {\n\t/* Return index to text representation in the array GMT_geometry[] for debug messages */\n\tif (geometry == GMT_IS_POINT)   return 1;\n\tif (geometry == GMT_IS_LINE)    return 2;\n\tif (geometry == GMT_IS_POLY)    return 3;\n\tif (geometry == GMT_IS_PLP)     return 4;\n\tif ((geometry & GMT_IS_LINE) && (geometry & GMT_IS_POLY)) return 5;\n\tif (geometry == GMT_IS_SURFACE) return 6;\n\tif (geometry == GMT_IS_NONE)    return 7;\n\tif (geometry == GMT_IS_TEXT)    return 8;\n\treturn 0;\n}\n/* We also need to return the pointer to an object given a void * address of that pointer.\n * This needs to be done on a per data-type basis, e.g., to cast that void * to a struct GMT_GRID **\n * so we may return the value at that address: */\n\nGMT_LOCAL inline struct GMTAPI_CTRL    * gmtapi_get_api_ptr      (struct GMTAPI_CTRL *ptr)     {return (ptr);}\nGMT_LOCAL inline struct GMT_PALETTE    * gmtapi_get_cpt_ptr      (struct GMT_PALETTE **ptr)    {return (*ptr);}\nGMT_LOCAL inline struct GMT_DATASET    * gmtapi_get_dataset_ptr  (struct GMT_DATASET **ptr)    {return (*ptr);}\nGMT_LOCAL inline struct GMT_GRID       * gmtapi_get_grid_ptr     (struct GMT_GRID **ptr)       {return (*ptr);}\nGMT_LOCAL inline struct GMT_POSTSCRIPT * gmtapi_get_ps_ptr       (struct GMT_POSTSCRIPT **ptr) {return (*ptr);}\nGMT_LOCAL inline struct GMT_CUBE   * gmtapi_get_cube_ptr (struct GMT_CUBE **ptr)   {return (*ptr);}\nGMT_LOCAL inline struct GMT_MATRIX     * gmtapi_get_matrix_ptr   (struct GMT_MATRIX **ptr)     {return (*ptr);}\nGMT_LOCAL inline struct GMT_VECTOR     * gmtapi_get_vector_ptr   (struct GMT_VECTOR **ptr)     {return (*ptr);}\nGMT_LOCAL inline double      \t       * gmtapi_get_coord_ptr    (double **ptr)                {return (*ptr);}\nGMT_LOCAL inline struct GMT_IMAGE      * gmtapi_get_image_ptr    (struct GMT_IMAGE **ptr)      {return (*ptr);}\n/* Various inline functs to convert void pointer to specific type */\nGMT_LOCAL inline struct GMT_GRID_ROWBYROW * gmtapi_get_rbr_ptr (struct GMT_GRID_ROWBYROW *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_FFT_INFO * gmtapi_get_fftinfo_ptr (struct GMT_FFT_INFO *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_FFT_WAVENUMBER * gmtapi_get_fftwave_ptr (struct GMT_FFT_WAVENUMBER *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_FFT_WAVENUMBER ** gmtapi_get_fftwave_addr (struct GMT_FFT_WAVENUMBER **ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_GRID    * gmtapi_get_grid_data (struct GMT_GRID *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_IMAGE   * gmtapi_get_image_data (struct GMT_IMAGE *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_DATASET * gmtapi_get_dataset_data (struct GMT_DATASET *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_VECTOR  * gmtapi_get_vector_data (struct GMT_VECTOR *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_MATRIX  * gmtapi_get_matrix_data (struct GMT_MATRIX *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_CUBE  * gmtapi_get_cube_data (struct GMT_CUBE *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_POSTSCRIPT  * gmtapi_get_postscript_data (struct GMT_POSTSCRIPT *ptr) {return (ptr);}\nGMT_LOCAL inline struct GMT_PALETTE  * gmtapi_get_palette_data (struct GMT_PALETTE *ptr) {return (ptr);}\nGMT_LOCAL inline char ** gmtapi_get_char_char_ptr     (char **ptr)  {return (ptr);}\n\n/*! gmtapi_return_address is a convenience function that, given type, calls the correct converter */\nGMT_LOCAL void * gmtapi_return_address (void *data, unsigned int type) {\n\tvoid *p = NULL;\n\tswitch (type) {\n\t\tcase GMT_IS_GRID:       p = gmtapi_get_grid_ptr (data);     break;\n\t\tcase GMT_IS_DATASET:    p = gmtapi_get_dataset_ptr (data);  break;\n\t\tcase GMT_IS_PALETTE:    p = gmtapi_get_cpt_ptr (data);      break;\n\t\tcase GMT_IS_POSTSCRIPT: p = gmtapi_get_ps_ptr (data);       break;\n\t\tcase GMT_IS_CUBE:\tp = gmtapi_get_cube_ptr (data); break;\n\t\tcase GMT_IS_MATRIX:     p = gmtapi_get_matrix_ptr (data);   break;\n\t\tcase GMT_IS_VECTOR:     p = gmtapi_get_vector_ptr (data);   break;\n\t\tcase GMT_IS_COORD:      p = gmtapi_get_coord_ptr (data);    break;\n\t\tcase GMT_IS_IMAGE:      p = gmtapi_get_image_ptr (data);    break;\n\t}\n\treturn (p);\n}\n\n/*! . */\nstruct GMTAPI_CTRL * gmt_get_api_ptr (struct GMTAPI_CTRL *ptr) {\n\t/* Clean casting of void to API pointer at start of a module\n \t * If ptr is NULL we are in deep trouble...\n\t */\n\tif (ptr == NULL) return_null (NULL, GMT_NOT_A_SESSION);\n\treturn (ptr);\n}\n\n/*! gmtapi_alloc_object_array is a convenience function that, given type, allocates an array of pointers to the corresponding container */\nGMT_LOCAL void * gmtapi_alloc_object_array (struct GMTAPI_CTRL *API, unsigned int n_items, unsigned int type) {\n\tvoid *p = NULL;\n\tswitch (type) {\n\t\tcase GMT_IS_GRID:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_GRID *);\t\tbreak;\n\t\tcase GMT_IS_DATASET:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_DATASET *);\tbreak;\n\t\tcase GMT_IS_PALETTE:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_PALETTE *);\tbreak;\n\t\tcase GMT_IS_CUBE:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_CUBE *);\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_POSTSCRIPT *);\tbreak;\n\t\tcase GMT_IS_IMAGE:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_IMAGE *);\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_MATRIX *);\tbreak;\n\t\tcase GMT_IS_VECTOR:\tp = gmt_M_memory (API->GMT, NULL, n_items, struct GMT_VECTOR *);\tbreak;\n\t}\n\treturn (p);\n}\n\n#ifdef DEBUG\n/*! Can be used to display API->object info wherever it is called as part of a debug operation */\nGMT_LOCAL void gmtapi_list_objects (struct GMTAPI_CTRL *API, char *txt) {\n\tunsigned int item, ext;\n\tstruct GMTAPI_DATA_OBJECT *S;\n\tchar message[GMT_LEN256] = {\"\"}, O, M;\n\t/* if (API->deep_debug == false) return; */\n\tif (!gmt_M_is_verbose (API->GMT, GMT_MSG_DEBUG)) return;\n\tsnprintf (message, GMT_LEN256, \"==> %d API Objects at end of %s\\n\", API->n_objects, txt);\n\tGMT_Message (API, GMT_TIME_NONE, message);\n\tif (API->n_objects == 0) return;\n\tGMT_Message (API, GMT_TIME_NONE, \"--------------------------------------------------------\\n\");\n\tsnprintf (message, GMT_LEN256,   \"K.. ID RESOURCE.... FAMILY.... ACTUAL.... DIR... S O M L\\n\");\n\tGMT_Message (API, GMT_TIME_NONE, message);\n\tGMT_Message (API, GMT_TIME_NONE, \"--------------------------------------------------------\\n\");\n\tfor (item = 0; item < API->n_objects; item++) {\n\t\tif ((S = API->object[item]) == NULL) continue;\n\t\tO = (S->no_longer_owner) ? 'N' : 'Y';\n\t\tM = (S->messenger) ? 'Y' : 'N';\n\t\text = (S->alloc_mode == GMT_ALLOC_EXTERNALLY) ? '*' : ' ';\n\t\tsnprintf (message, GMT_LEN256, \"%c%2d %2d %12\" PRIxS \" %-10s %-10s %-6s %d %c %c %d\\n\", ext, item, S->ID, (size_t)S->resource,\n\t\t\tGMT_family[S->family], GMT_family[S->actual_family], GMT_direction[S->direction], S->status, O, M, S->alloc_level);\n\t\tGMT_Message (API, GMT_TIME_NONE, message);\n\t}\n\tGMT_Message (API, GMT_TIME_NONE, \"--------------------------------------------------------\\n\");\n}\n\n/*! Mostly for debugging */\nGMT_LOCAL void gmtapi_set_object (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *obj) {\n\t/* This is mostly for debugging and may go away or remain under DEBUG */\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Set_Object for family: %d\\n\", obj->family);\n\tswitch (obj->family) {\n\t\tcase GMT_IS_GRID:\tobj->G = obj->resource; break;\n\t\tcase GMT_IS_DATASET:\tobj->D = obj->resource; break;\n\t\tcase GMT_IS_PALETTE:\tobj->C = obj->resource; break;\n\t\tcase GMT_IS_CUBE:\t\tobj->U = obj->resource; break;\n\t\tcase GMT_IS_POSTSCRIPT:\t\tobj->P = obj->resource; break;\n\t\tcase GMT_IS_MATRIX:\tobj->M = obj->resource; break;\n\t\tcase GMT_IS_VECTOR:\tobj->V = obj->resource; break;\n\t\tcase GMT_IS_COORD:\tbreak;\t/* No worries */\n\t\tcase GMT_IS_IMAGE:\tobj->I = obj->resource; break;\n\t\tcase GMT_N_FAMILIES:\tbreak;\n\t}\n}\n#endif\n\nGMT_LOCAL void gmtapi_check_for_modern_oneliner (struct GMTAPI_CTRL *API, const char *module, int mode, void *args) {\n\t/* Determine if user is attempting a modern mode one-liner plot, and if so, set run mode to GMT_MODERN.\n\t * This is needed since there is not gmt begin | end sequence in this case.\n\t * Also, if a user wants to get the usage message for a modern mode module then it is also a type\n\t * of one-liner and thus we set to GMT_MODERN as well, but only for modern module names. */\n\n\tunsigned modern = 0, pos;\n\tchar format[GMT_LEN128] = {\"\"}, p[GMT_LEN16] = {\"\"}, *c = NULL;\n\tbool usage = false;\n\tsize_t len;\n\tstruct GMT_OPTION *opt = NULL, *head = NULL;\n\n\tif (API->GMT->current.setting.run_mode == GMT_MODERN) {\t/* Just need to check if a classic name was given... */\n\t\tif (!strncmp (module, \"ps\", 2U) && strncmp (module, \"psconvert\", 9U)) {\t/* Gave classic ps* name in modern mode but not psconvert */\n\t\t\tchar not_used[GMT_LEN32] = {\"\"};\n\t\t\tconst char *mod_name = gmt_current_name (module, not_used);\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Detected a classic module name (%s) in modern mode - please use the modern mode name %s instead.\\n\", module, mod_name);\n\t\t}\n\t\treturn;\t/* Done, since we know it is a modern mode session */\n\t}\n\n\thead = GMT_Create_Options (API, mode, args);\t/* Get option list */\n\tif ((opt = GMT_Find_Option (API, 'V', head)))\t/* Remove -V here so that we can run gmt plot -? -Vd and still get modern mode usage plus debug info */\n\t\tGMT_Delete_Option (API, opt, &head);\n\n\tif (!strcmp (module, \"grdcontour\") && GMT_Find_Option (API, 'N', head)) {\t/* Special case of two module calls cannot be oneliner here */\n\t\tif (GMT_Destroy_Options (API, &head))\t/* Done with these here */\n\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Unable to free options in gmtapi_check_for_modern_oneliner?\\n\");\n\t\treturn;\n\t}\n\n\tAPI->GMT->current.setting.use_modern_name = gmtlib_is_modern_name (API, module);\n\n\tif (API->GMT->current.setting.use_modern_name) {\t/* Make some checks needed to handle synopsis and usage messages in classic vs modern mode */\n\t\tif (head == NULL) {\t/* Gave none or a single argument */\n\t\t\tif (API->GMT->current.setting.run_mode == GMT_CLASSIC)\n\t\t\t\tAPI->usage = true;\t/* Modern mode name given with no args so not yet in modern mode - allow it to get usage */\n\t\t\treturn;\n\t\t}\n\t\tif (head->next == NULL) {\t/* Gave a single argument */\n\t\t\tif (head->option == GMT_OPT_USAGE || head->option == GMT_OPT_SYNOPSIS || (head->option == '+' && !head->arg[0])) modern = 1;\n\t\t\tif (modern) usage = true;\n\t\t}\n\t}\n\n\t/* Finally, must check if a one-liner with special graphics format settings were given, e.g., \"gmt pscoast -Rg -JH0/15c -Gred -png map\" */\n\tfor (opt = head; opt; opt = opt->next) {\n\t\tif (opt->option == GMT_OPT_INFILE || opt->option == GMT_OPT_OUTFILE) continue;\t/* Skip file names */\n\t\tif (strchr (\"bejpPt\", opt->option) == NULL) continue;\t/* Option not the first letter of a valid graphics format [UPDATE LIST IF ADDING MORE FORMATS IN FUTURE] */\n\t\tif ((len = strlen (opt->arg)) == 0 || len >= GMT_LEN128) continue;\t/* No arg or very long args that are filenames can be skipped */\n\t\tsnprintf (format, GMT_LEN128, \"%c%s\", opt->option, opt->arg);\t/* Get a local copy so we can mess with it */\n\t\tif ((c = strchr (format, ','))) c[0] = 0;\t/* Chop off other formats for the initial id test */\n\t\tif (gmt_get_graphics_id (API->GMT, format) != GMT_NOTSET) {\t/* Found a valid graphics format option */\n\t\t\tmodern = 1;\t/* Seems like it is, but check the rest of the formats, if there are more */\n\t\t\tif (c == NULL) continue;\t/* Nothing else to check, go to next option */\n\t\t\t/* Make sure any other formats are valid, too */\n\t\t\tif (c) c[0] = ',';\t/* Restore any comma we found */\n\t\t\tpos = 0;\n\t\t\twhile (modern && gmt_strtok (format, \",\", &pos, p)) {\t/* Check each format to make sure each is OK */\n\t\t\t\tif (gmt_get_graphics_id (API->GMT, p) == GMT_NOTSET)\t/* Oh, something wrong was given, cannot be modern */\n\t\t\t\t\tmodern = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (modern) {\t/* This is indeed a modern mode one-liner command */\n\t\tAPI->GMT->current.setting.run_mode = GMT_MODERN;\n\t\tAPI->usage = usage;\n\t}\n\tif (API->GMT->current.setting.run_mode == GMT_MODERN)\t/* If running in modern mode we want to use modern names */\n\t\tAPI->GMT->current.setting.use_modern_name = true;\n\n\tif (GMT_Destroy_Options (API, &head))\t/* Done with these here */\n\t\tGMT_Report (API, GMT_MSG_WARNING, \"Unable to free options in gmtapi_check_for_modern_oneliner?\\n\");\n}\n\n/* Function to get PPID under Windows is a bit different */\n#ifdef _WIN32\n#include <TlHelp32.h>\nGMT_LOCAL int gmtapi_winppid (int pidin) {\n\t/* If pidin == 0 get the PPID of current process\n\t   otherwise, get the PPID of pidin process\n\t*/\n\tint pid, ppid = -1;\n\tif (pidin)\n\t\tpid = pidin;\n\telse\n\t\tpid = GetCurrentProcessId ();\n\tHANDLE h = CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);\n\tPROCESSENTRY32 pe = { 0 };\n\tpe.dwSize = sizeof (PROCESSENTRY32);\n\n\tif (Process32First(h, &pe)) {\n\t\tdo {\n\t\t\tif (pe.th32ProcessID == (unsigned int)pid)\n\t\t\t\tppid = pe.th32ParentProcessID;\n\t\t} while (ppid == -1 && Process32Next(h, &pe));\n\t}\n\tCloseHandle (h);\n\treturn (ppid);\n}\n#endif\n\n/* Safety valve to remove non-alphanumeric characters =*/\nGMT_LOCAL char * gmtapi_alnum_only (struct GMTAPI_CTRL *API, char *string) {\n\tunsigned int k = 0, n_changed = 0;\n\twhile (string[k]) {\n\t\tif (!isalnum (string[k])) {\n\t\t\tn_changed++;\n\t\t\tstring[k] = '#';\n\t\t}\n\t\tk++;\n\t}\n\tif (n_changed)\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Cleaned GMT_SESSION_NAME to %s\\n\", string);\n\treturn (string);\n}\n\n/*! . */\nGMT_LOCAL char * gmtapi_get_ppid (struct GMTAPI_CTRL *API) {\n\t/* Return the parent process ID [i.e., shell for command line use or gmt app for API] */\n\tint ppid = -1;\n\tunsigned int k = 0;\n\tstatic char *source[4] = {\"GMT_SESSION_NAME\", \"parent\", \"app\", \"hardwired choice\"};\n\tchar *str = NULL, string[GMT_LEN8];\n\tif ((str = getenv (\"GMT_SESSION_NAME\")) != NULL) {\t/* GMT_SESSION_NAME was set in the environment */\n\t\tchar *tmp = strdup (str);\t/* Duplicate the given string */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Obtained GMT_SESSION_NAME from the environment: %s\\n\", str);\n\t\treturn (gmtapi_alnum_only (API, tmp)); /* Replace any non-alphanumeric characters with # */\n\t}\n\t/* Here we just need to get the PPID and format to string */\n#ifdef DEBUG_MODERN\t/* To simplify debugging we set it to 1 */\n\tif (ppid == -1) ppid = 1, k = 3;\n#elif defined(WIN32)\n\t/* OK, the trouble is the following. On Win, if the Windows executables are run from within a bash window\n\t   gmtapi_get_ppid returns different values for each call, and this completely breaks the idea\n\t   of using the constant PPID (parent PID) to create unique file names for each session.\n\t   So, given that we didn't yet find a way to make this work from within MSYS (and likely Cygwin)\n\t   we are forcing PPID = 0 in all Windows variants unless set via GMT_SESSION_NAME. A corollary of this\n\t   is that Windows users running many bash windows concurrently should use GMT_SESSION_NAME in their scripts\n\t   to give unique values to different scripts.  */\n\tif ((str = getenv (\"SHELL\")) != NULL) {\t/* GMT_SESSION_NAME was set in the environment */\n\t\t//if (ppid == -1) ppid = 0, k = 3;\n\t\tppid = gmtapi_winppid(0);\t\t/* First time get PPID of current process */\n\t\tppid = gmtapi_winppid(ppid);\t/* Second time get PPPID of current process */\n\t\tk = 1;\n\t}\n\telse {\n\t\tif (ppid == -1) ppid = gmtapi_winppid(0), k = 1;\n\t}\n#else\t/* Normal situation */\n\telse if (API->external)\t/* Return PID of the controlling app instead for external interfaces */\n\t\tppid = getpid (), k = 2;\n\telse\t/* Here we are probably running from the command line and want the shell's PID */\n\t\tppid = getppid(), k = 1; /* parent process id */\n#endif\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Obtained the ppid from %s: %d\\n\", source[k], ppid);\n\tsnprintf (string, GMT_LEN8, \"%d\", ppid);\n\treturn (strdup (string));\n}\n\n/*! . */\nGMT_LOCAL char * gmtapi_lib_tag (char *name) {\n\t/* Pull out the tag from a name like <tag>[.extension] */\n\tchar *extension = NULL, *pch = NULL, *tag = NULL;\n\tif (!strchr (name, '.')) return NULL;\t/* No file with extension given, probably just a directory due to user confusion */\n\ttag = strdup (name);\n\textension = strrchr (tag, '.'); /* last period in name */\n\tif (extension) *extension = '\\0'; /* remove extension */\n\t/* if name has the \"_w32|64\" suffix or any other suffix that starts with a '_', remove it. */\n\tpch = strrchr(tag, '_');\n\tif (pch) *pch = '\\0';\n\treturn (tag);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_init_sharedlibs (struct GMTAPI_CTRL *API) {\n\t/* At the end of GMT_Create_Session we are done with processing gmt.conf.\n\t * We can now determine how many shared libraries and plugins to consider, and open the core lib */\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tunsigned int n_custom_libs, k, e, n_alloc = GMT_TINY_CHUNK;\n\tchar text[PATH_MAX] = {\"\"}, plugindir[PATH_MAX] = {\"\"}, path[PATH_MAX] = {\"\"};\n\tchar *libname = NULL, **list = NULL;\n#ifdef WIN32\n\tchar *extension[1] = {\".dll\"};\n\tunsigned int n_extensions = 1;\n#elif  defined(__APPLE__)\t/* Look for both .so and .dylib shared libs on OSX */\n\tchar *extension[2] = {\".so\", \".dylib\"};\n\tunsigned int n_extensions = 2;\n#else\t/* Linux, etc. only use .so */\n\tchar *extension[1] = {\".so\"};\n\tunsigned int n_extensions = 1;\n#endif\n\n#ifdef SUPPORT_EXEC_IN_BINARY_DIR\n\t/* If SUPPORT_EXEC_IN_BINARY_DIR is defined we try to load plugins from the\n\t * build tree */\n\n\t/* Only true, when we are running in a subdir of GMT_BINARY_DIR_SRC_DEBUG: */\n\tbool running_in_bindir_src = !strncmp (GMT->init.runtime_bindir, GMT_BINARY_DIR_SRC_DEBUG, strlen(GMT_BINARY_DIR_SRC_DEBUG));\n#endif\n\n\tAPI->lib = gmt_M_memory (GMT, NULL, n_alloc, struct GMT_LIBINFO);\n\n\t/* 1. Load the GMT core library by default [unless libgmt is used externally] */\n\t/* Note: To extract symbols from the currently executing process we need to load it as a special library.\n\t * This is done by passing NULL under Linux and by calling GetModuleHandleEx under Windows, hence we\n\t * use the dlopen_special call which is defined in gmt_sharedlibs.c.  If the gmt core and supplemental\n\t * libraries are being used by 3rd party externals then no library is special and they are all opened\n\t * the first time we need access. */\n\n\tAPI->lib[0].name = strdup (\"core\");\n\tn_custom_libs = 1;\t/* Always have at least one shared gmt library */\n\tif (API->external) {\t/* Determine the path to this library */\n\t\tif (GMT->init.runtime_libdir) {\t/* Successfully determined runtime dir for shared libs */\n\t\t\tsprintf (path, \"%s/%s\", GMT->init.runtime_libdir, GMT_CORE_LIB_NAME);\n\t\t\tAPI->lib[0].path = strdup (path);\n\t\t}\n\t\telse\t/* Rely on the OS to find it */\n\t\t\tAPI->lib[0].path = strdup (GMT_CORE_LIB_NAME);\n\t}\n\telse {\t/* The handling of the core library is only special when gmt.c is used. */\n\t\tAPI->lib[0].path = strdup (GMT_CORE_LIB_NAME);\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Loading core GMT shared library: %s\\n\", API->lib[0].path);\n\t\tif ((API->lib[0].handle = dlopen_special (API->lib[0].path)) == NULL) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Failure while loading core GMT shared library (%s): %s\\n\", API->lib[0].path, dlerror());\n\t\t\treturn -GMT_RUNTIME_ERROR;\n\t\t}\n\t\tdlerror (); /* Clear any existing error */\n\t}\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Shared Library # 0 (core). Path = %s\\n\", API->lib[0].path);\n\n\t/* 3. Add any plugins installed in <installdir>/lib/gmt/plugins */\n\n\tif (GMT->init.runtime_libdir) {\t/* Successfully determined runtime dir for shared libs */\n#ifdef SUPPORT_EXEC_IN_BINARY_DIR\n\t\tif ( running_in_bindir_src && access (GMT_BINARY_DIR_SRC_DEBUG \"/plugins\", R_OK|X_OK) == 0 ) {\n\t\t\t/* Running in build dir: search plugins in build-dir/src/plugins */\n\t\t\tstrncat (plugindir, GMT_BINARY_DIR_SRC_DEBUG \"/plugins\", PATH_MAX-1);\n#ifdef XCODER\n\t\t\tstrcat (plugindir, \"/Debug\");\t/* The Xcode plugin path for Debug */\n#endif\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t/* Set full path to the core library */\n\t\tsnprintf (plugindir, PATH_MAX, \"%s/%s\", GMT->init.runtime_libdir, GMT_CORE_LIB_NAME);\n\t\tif (!GMT->init.runtime_library) GMT->init.runtime_library = strdup (plugindir);\n\n#ifdef WIN32\n\t\t\tsnprintf (plugindir, PATH_MAX, \"%s/gmt_plugins\", GMT->init.runtime_libdir);\t/* Generate the Win standard plugins path */\n#else\n\t\t\tsnprintf (plugindir, PATH_MAX, \"%s/gmt\" GMT_INSTALL_NAME_SUFFIX \"/plugins\", GMT->init.runtime_libdir);\t/* Generate the *nix standard plugins path */\n#endif\n\t\t}\n\t\tif (!GMT->init.runtime_plugindir) GMT->init.runtime_plugindir = strdup (plugindir);\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Loading GMT plugins from: %s\\n\", plugindir);\n\t\tfor (e = 0; e < n_extensions; e++) {\t/* Handle case of more than one allowed shared library extension */\n\t\t\tif ((list = gmtlib_get_dir_list (GMT, plugindir, extension[e]))) {\t/* Add these files to the libs */\n\t\t\t\tfor (k = 0; list[k] && strncmp (list[k], GMT_SUPPL_LIB_NAME, strlen(GMT_SUPPL_LIB_NAME)); k++);\t/* Look for official supplements */\n\t\t\t\tif (list[k] && k) gmt_M_charp_swap (list[0], list[k]);\t/* Put official supplements first if not first already */\n\t\t\t\tk = 0;\n\t\t\t\twhile (list[k]) {\n\t\t\t\t\tsnprintf (path, PATH_MAX, \"%s/%s\", plugindir, list[k]);\n\t\t\t\t\tif (access (path, R_OK))\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Shared Library %s cannot be found or read!\\n\", path);\n\t\t\t\t\telse {\n\t\t\t\t\t\tAPI->lib[n_custom_libs].name = gmtapi_lib_tag (list[k]);\n\t\t\t\t\t\tAPI->lib[n_custom_libs].path = strdup (path);\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Shared Library # %d (%s). Path = %s\\n\", n_custom_libs, API->lib[n_custom_libs].name, API->lib[n_custom_libs].path);\n\t\t\t\t\t\tn_custom_libs++;\t\t\t/* Add up entries found */\n\t\t\t\t\t\tif (n_custom_libs == n_alloc) {\t\t/* Allocate more memory for list */\n\t\t\t\t\t\t\tn_alloc <<= 1;\n\t\t\t\t\t\t\tAPI->lib = gmt_M_memory (GMT, API->lib, n_alloc, struct GMT_LIBINFO);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++k;\n\t\t\t\t}\n\t\t\t\tgmtlib_free_dir_list (GMT, &list);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* 4. Add any custom GMT libraries to the list of libraries/plugins to consider, if specified.\n\t      We will find when trying to open if any of these are actually available. */\n\n\tif (GMT->session.CUSTOM_LIBS) {\t/* We specified custom shared libraries */\n\t\tk = (unsigned int)strlen (GMT->session.CUSTOM_LIBS) - 1;\t/* Index of last char in CUSTOM_LIBS */\n\t\tif (GMT->session.CUSTOM_LIBS[k] == '/' || GMT->session.CUSTOM_LIBS[k] == '\\\\') {\t/* We gave CUSTOM_LIBS as a subdirectory, add all files found inside it to shared libs list */\n\t\t\tstrcpy (plugindir, GMT->session.CUSTOM_LIBS);\n\t\t\tplugindir[k] = '\\0';\t/* Chop off trailing slash */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Loading custom GMT plugins from: %s\\n\", plugindir);\n\t\t\tfor (e = 0; e < n_extensions; e++) {\n\t\t\t\tif ((list = gmtlib_get_dir_list (GMT, plugindir, extension[e]))) {\t/* Add these to the libs */\n\t\t\t\t\tk = 0;\n\t\t\t\t\twhile (list[k]) {\n\t\t\t\t\t\tsnprintf (path, PATH_MAX, \"%s/%s\", plugindir, list[k]);\n\t\t\t\t\t\tif (access (path, R_OK)) {\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Shared Library %s cannot be found or read!\\n\", path);\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Check that your GMT_CUSTOM_LIBS (in %s, perhaps) is correct\\n\", GMT_SETTINGS_FILE);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((API->lib[n_custom_libs].name = gmtapi_lib_tag (list[k]))) {\n\t\t\t\t\t\t\tAPI->lib[n_custom_libs].path = strdup (path);\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Shared Library # %d (%s). Path = \\n\", n_custom_libs, API->lib[n_custom_libs].name, API->lib[n_custom_libs].path);\n\t\t\t\t\t\t\tn_custom_libs++;\t\t/* Add up entries found */\n\t\t\t\t\t\t\tif (n_custom_libs == n_alloc) {\t/* Allocate more memory for list */\n\t\t\t\t\t\t\t\tn_alloc <<= 1;\n\t\t\t\t\t\t\t\tAPI->lib = gmt_M_memory (GMT, API->lib, n_alloc, struct GMT_LIBINFO);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Shared Library %s has no extension! Ignored\\n\", list[k]);\n\t\t\t\t\t\t++k;\n\t\t\t\t\t}\n\t\t\t\t\tgmtlib_free_dir_list (GMT, &list);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\t/* Just a list with one or more comma-separated library paths */\n\t\t\tunsigned int pos = 0;\n\t\t\twhile (gmt_strtok (GMT->session.CUSTOM_LIBS, \",\", &pos, text)) {\n\t\t\t\tlibname = strdup (basename (text));\t\t/* Last component from the pathname */\n\t\t\t\tif (access (text, R_OK)) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Shared Library %s cannot be found or read!\\n\", text);\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Check that your GMT_CUSTOM_LIBS (in %s, perhaps) is correct\\n\", GMT_SETTINGS_FILE);\n\t\t\t\t}\n\t\t\t\telse if ((API->lib[n_custom_libs].name = gmtapi_lib_tag (libname))) {\n\t\t\t\t\tAPI->lib[n_custom_libs].path = strdup (text);\n\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Shared Library # %d (%s). Path = \\n\", n_custom_libs, API->lib[n_custom_libs].name, API->lib[n_custom_libs].path);\n\t\t\t\t\tn_custom_libs++;\t\t/* Add up entries found */\n\t\t\t\t\tif (n_custom_libs == n_alloc) {\t/* Allocate more memory for list */\n\t\t\t\t\t\tn_alloc <<= 1;\n\t\t\t\t\t\tAPI->lib = gmt_M_memory (GMT, API->lib, n_alloc, struct GMT_LIBINFO);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Shared Library %s has no extension! Ignored\\n\", text);\n\t\t\t\tgmt_M_str_free (libname);\n\t\t\t}\n\t\t}\n\t}\n\n\tAPI->n_shared_libs = n_custom_libs;\t/* Update total number of shared libraries */\n\tAPI->lib = gmt_M_memory (GMT, API->lib, API->n_shared_libs, struct GMT_LIBINFO);\n\n\treturn (GMT_NOERROR);\n}\n\n/*! Free items in the shared lib list */\nGMT_LOCAL void gmtapi_free_sharedlibs (struct GMTAPI_CTRL *API) {\n\tunsigned int k;\n\tfor (k = 0; k < API->n_shared_libs; k++) {\n\t\tif (k > 0 && API->lib[k].handle && dlclose (API->lib[k].handle))\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Failure while closing GMT %s shared library: %s\\n\", API->lib[k].name, dlerror());\n\t\tgmt_M_str_free (API->lib[k].name);\n\t\tgmt_M_str_free (API->lib[k].path);\n\t}\n\tgmt_M_free (API->GMT, API->lib);\n\tAPI->n_shared_libs = 0;\n}\n\n/* The basic gmtread|write module meat; used by external APIs only, such as the GMT/MATLAB API */\n\n/*! Duplicate ifile on ofile.  Calling program is responsible to ensure correct args are passed */\nint gmt_copy (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int direction, char *ifile, char *ofile) {\n\tdouble *wesn = NULL;\t/* For grid and image subsets */\n\tstruct GMT_DATASET *D = NULL;\n\tstruct GMT_PALETTE *C = NULL;\n\tstruct GMT_GRID *G = NULL;\n\tstruct GMT_CUBE *U = NULL;\n\tstruct GMT_POSTSCRIPT *P = NULL;\n\tstruct GMT_IMAGE *I = NULL;\n\tstruct GMT_MATRIX *M = NULL;\n\tstruct GMT_VECTOR *V = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\tstruct GMT_DATASET_HIDDEN *DH = NULL;\n\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tAPI->error = GMT_NOERROR;\n\tGMT_Report (API, GMT_MSG_INFORMATION, \"Read %s from %s and write to %s\\n\", GMT_family[family], ifile, ofile);\n\tGMT = API->GMT;\n\n\tswitch (family) {\n\t\tcase GMT_IS_DATASET:\n\t\t\tif ((D = GMT_Read_Data (API, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_POINT, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tDH = gmt_get_DD_hidden (D);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_DATASET, GMT_IS_FILE, D->geometry, DH->io_mode | GMT_IO_RESET, NULL, ofile, D) != GMT_NOERROR)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_GRID:\n\t\t\twesn = (direction == GMT_IN && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;\n\t\t\tif ((G = GMT_Read_Data (API, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_READ_NORMAL, wesn, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\twesn = (direction == GMT_OUT && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;\n\t\t\tif (GMT_Write_Data (API, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA | GMT_IO_RESET, wesn, ofile, G) != GMT_NOERROR)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\twesn = (direction == GMT_IN && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;\n\t\t\tif ((I = GMT_Read_Data (API, GMT_IS_IMAGE, GMT_IS_FILE, GMT_IS_SURFACE, GMT_READ_NORMAL, wesn, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\twesn = (direction == GMT_OUT && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;\n\t\t\tif (GMT_Write_Data (API, GMT_IS_IMAGE, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA | GMT_IO_RESET, wesn, ofile, I) != GMT_NOERROR)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_CUBE:\n\t\t\twesn = (direction == GMT_IN && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;\n\t\t\tif ((U = GMT_Read_Data (API, GMT_IS_CUBE, GMT_IS_FILE, GMT_IS_VOLUME, GMT_READ_NORMAL, wesn, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\twesn = (direction == GMT_OUT && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;\n\t\t\tif (GMT_Write_Data (API, GMT_IS_CUBE, GMT_IS_FILE, GMT_IS_VOLUME, GMT_CONTAINER_AND_DATA | GMT_IO_RESET, wesn, ofile, U) != GMT_NOERROR)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\n\t\t\tif ((C = GMT_Read_Data (API, GMT_IS_PALETTE, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_PALETTE, GMT_IS_FILE, GMT_IS_NONE, C->mode | GMT_IO_RESET, NULL, ofile, C) != GMT_NOERROR)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\n\t\t\tif ((P = GMT_Read_Data (API, GMT_IS_POSTSCRIPT, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_POSTSCRIPT, GMT_IS_FILE, GMT_IS_NONE, GMT_IO_RESET, NULL, ofile, P) != GMT_NOERROR)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\n\t\t\tif ((M = GMT_Read_Data (API, GMT_IS_MATRIX, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_MATRIX, GMT_IS_FILE, GMT_IS_NONE, GMT_IO_RESET, NULL, ofile, M) != GMT_NOERROR)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\n\t\t\tif ((V = GMT_Read_Data (API, GMT_IS_VECTOR, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, ifile, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\tif (GMT_Write_Data (API, GMT_IS_VECTOR, GMT_IS_FILE, GMT_IS_NONE, GMT_IO_RESET, NULL, ofile, V) != GMT_NOERROR)\n\t\t\t\treturn (API->error);\n\t\t\tbreak;\n\t\tcase GMT_IS_COORD:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"No external read or write support yet for object %s\\n\", GMT_family[family]);\n\t\t\treturn_error(API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Internal error, family = %d\\n\", family);\n\t\t\treturn_error(API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t}\n\n\treturn (API->error);\n}\n\n/* Note: Many/all of these do not need to check if API == NULL since they are called from functions that do. */\n/* Private functions used by this library only.  These are not accessed outside this file. */\n\nGMT_LOCAL unsigned int gmtapi_pick_out_col_number (struct GMT_CTRL *GMT, unsigned int col) {\n\t/* Return the next column to be reported on output */\n\tunsigned int col_pos;\n\tif (GMT->common.o.select)\t/* -o has selected some columns */\n\t\tcol_pos = GMT->current.io.col[GMT_OUT][col].col;\t/* Which data column to pick */\n\telse if (GMT->current.setting.io_lonlat_toggle[GMT_OUT] && col < GMT_Z)\t/* Worry about -: for lon,lat */\n\t\tcol_pos = 1 - col;\t/* Write lat/lon instead of lon/lat */\n\telse\n\t\tcol_pos = col;\t/* Just goto that column */\n\treturn (col_pos);\n}\n\n/*! . */\nGMT_LOCAL double gmtapi_select_dataset_value (struct GMT_CTRL *GMT, struct GMT_DATASEGMENT *S, unsigned int row, unsigned int col) {\n\t/* For binary output of a data table segment via external matrix, we must select correct col entry and possibly make adjustments */\n\tdouble val;\n\tunsigned int col_pos = gmtapi_pick_out_col_number (GMT, col);\n\tval = (col_pos >= S->n_columns) ? GMT->session.d_NaN : S->data[col_pos][row];\t/* If we request a column beyond length of array, return NaN */\n\tif (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (val)) val = GMT->common.d.nan_proxy[GMT_OUT];\t/* Write this value instead of NaNs */\n\tif (gmt_M_is_type (GMT, GMT_OUT, col_pos, GMT_IS_LON)) gmt_lon_range_adjust (GMT->current.io.geo.range, &val);\t/* Set longitude range */\n\treturn (val);\n}\n\n/*! . */\nGMT_LOCAL double gmtapi_select_record_value (struct GMT_CTRL *GMT, double *record, unsigned int col, unsigned int n_colums) {\n\t/* For binary output of data record via external matrix, we must select correct col entry and possibly make adjustments */\n\tdouble val;\n\tunsigned int col_pos = gmtapi_pick_out_col_number (GMT, col);\n\tval = (col_pos >= n_colums) ? GMT->session.d_NaN : record[col_pos];\t/* If we request a column beyond length of array, return NaN */\n\tif (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (val)) val = GMT->common.d.nan_proxy[GMT_OUT];\t/* Write this value instead of NaNs */\n\tif (gmt_M_is_type (GMT, GMT_OUT, col_pos, GMT_IS_LON)) gmt_lon_range_adjust (GMT->current.io.geo.range, &val);\t/* Set longitude range */\n\treturn (val);\n}\n\nGMT_LOCAL unsigned int gmtapi_pick_in_col_number (struct GMT_CTRL *GMT, unsigned int col) {\n\t/* Return the next column to be selected on input */\n\tunsigned int col_pos;\n\tif (GMT->common.i.select)\t/* -i has selected some columns */\n\t\tcol_pos = GMT->current.io.col[GMT_IN][col].col;\t/* Which data column to pick */\n#if 0\n\telse if (GMT->current.setting.io_lonlat_toggle[GMT_IN] && col < GMT_Z)\t/* Worry about -: for lon,lat */\n\t\tcol_pos = 1 - col;\t/* Read lat/lon instead of lon/lat */\n#endif\n\telse\n\t\tcol_pos = col;\t/* Just goto that column */\n\treturn (col_pos);\n}\n\n/*! . */\nGMT_LOCAL double gmtapi_get_record_value (struct GMT_CTRL *GMT, double *record, uint64_t col, uint64_t n_colums) {\n\t/* For binary input of data record via external matrix, we must select correct col entry and possibly make adjustments */\n\tdouble val;\n\tunsigned int col_pos;\n\tcol_pos = gmtapi_pick_in_col_number (GMT, (unsigned int)col);\n\tval = (col_pos >= n_colums) ? GMT->session.d_NaN : record[col_pos];\t/* If we request a column beyond length of array, return NaN */\n\tif (GMT->common.d.active[GMT_IN] && gmt_M_is_dnan (val)) val = GMT->common.d.nan_proxy[GMT_IN];\t/* Write this value instead of NaNs */\n\tif (gmt_M_is_type (GMT, GMT_IN, col_pos, GMT_IS_LON)) gmt_lon_range_adjust (GMT->current.io.geo.range, &val);\t/* Set longitude range */\n\treturn (val);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_bin_input_memory (struct GMT_CTRL *GMT, uint64_t n, uint64_t n_use) {\n\t/* Read function which gets one record from the memory reference.\n \t * The current data record has already been read from wherever and is available in GMT->current.io.curr_rec */\n\tunsigned int status;\n\tgmt_M_unused(n);\n\n\tGMT->current.io.status = GMT_IO_DATA_RECORD;\t/* Default status we expect, but this may change below */\n\tGMT->current.io.rec_no++;\t\t\t/* One more input record read */\n\tstatus = gmtlib_process_binary_input (GMT, n_use);\t/* Check for segment headers */\n\tif (status == 1) return (GMTAPI_GOT_SEGHEADER);\t/* A segment header was found and we are done here */\n\tif (gmtlib_gap_detected (GMT)) { gmtlib_set_gap (GMT); return (GMTAPI_GOT_SEGGAP); }\t/* Gap forced a segment header to be issued and we get out */\n\tGMT->current.io.data_record_number_in_set[GMT_IN]++;\t/* Actually got a valid data record */\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL char * gmtapi_tictoc_string (struct GMTAPI_CTRL *API, unsigned int mode) {\n\t/* Optionally craft a leading timestamp.\n\t * mode = 0:\tNo time stamp\n\t * mode = 1:\tAbs time stamp formatted via GMT_TIME_STAMP\n\t * mode = 2:\tReport elapsed time since last reset.\n\t * mode = 4:\tReset elapsed time to 0, no time stamp.\n\t * mode = 6:\tReset elapsed time and report it as well.\n\t */\n\ttime_t right_now;\n\tclock_t toc = 0;\n\tunsigned int H, M, S, milli;\n\tdouble T;\n\tstatic char stamp[GMT_LEN256] = {\"\"};\n\n\tif (mode == 0) return NULL;\t\t/* no timestamp requested */\n\tif (mode > 1) toc = clock ();\t\t/* Elapsed time requested */\n\tif (mode & 4) API->GMT->current.time.tic = toc;\t/* Reset previous timestamp to now */\n\n\tswitch (mode) {\t/* Form output timestamp string */\n\t\tcase 1:\t/* Absolute time stamp */\n\t\t\tright_now = time ((time_t *)0);\n\t\t\tstrftime (stamp, sizeof(stamp), API->GMT->current.setting.format_time_stamp, localtime (&right_now));\n\t\t\tbreak;\n\t\tcase 2:\t/* Elapsed time stamp */\n\t\tcase 6:\n\t\t\tT = (double)(toc - (clock_t)API->GMT->current.time.tic);\t/* Elapsed time in ticks */\n\t\t\tT /= CLOCKS_PER_SEC;\t/* Elapsed time in seconds */\n\t\t\tH = urint (floor (T * GMT_SEC2HR));\n\t\t\tT -= H * GMT_HR2SEC_I;\n\t\t\tM = urint (floor (T * GMT_SEC2MIN));\n\t\t\tT -= M * GMT_MIN2SEC_I;\n\t\t\tS = urint (floor (T));\n\t\t\tT -= S;\n\t\t\tmilli = urint (T*1000.0);\t/* Residual milli-seconds */\n\t\t\tsnprintf (stamp, GMT_LEN256, \"Elapsed time %2.2u:%2.2u:%2.2u.%3.3u\", H, M, S, milli);\n\t\t\tbreak;\n\t\tdefault: break;\n\t}\n\treturn (stamp);\n}\n\n/*! . */\nGMT_LOCAL unsigned int gmtapi_add_existing (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int geometry, unsigned int direction, int *first_ID) {\n\t/* In this mode, we find all registrered resources of matching family,geometry,direction that are unused and turn variable selected to true. */\n\tunsigned int i, n, this_geo;\n\n\t*first_ID = GMT_NOTSET;\t/* Not found yet */\n\tfor (i = n = 0; i < API->n_objects; i++) {\n\t\tif (!API->object[i]) continue;\t/* A freed object, skip */\n\t\tif (API->object[i]->direction != (enum GMT_enum_std)direction) continue; /* Wrong direction */\n\t\tif (API->object[i]->status    != GMT_IS_UNUSED) continue;  /* Already used */\n\t\tif (family != API->object[i]->family) continue;\t\t   /* Wrong data type */\n\t\t//if (API->object[i]->geometry  != (enum GMT_enum_geometry)geometry) continue;  /* Wrong geometry */\n\t\t/* More careful check for geometry that allows the PLP (1+2+4) be match by any of those using logical and */\n\t\tthis_geo = (unsigned int)API->object[i]->geometry;\n\t\tif (!(this_geo & geometry)) continue;  /* Wrong geometry */\n\t\tn++;\t/* Found one that satisfied requirements */\n\t\tif (*first_ID == GMT_NOTSET) *first_ID = API->object[i]->ID;\t/* Get the ID of the first that passed the test */\n\t\tAPI->object[i]->selected = true;\t/* Make this an active object for the coming i/o operation */\n\t}\n\treturn (n);\n}\n\n/* These functions are support functions for the API function GMT_Encode_Options:\n *\tgmtapi_key_to_family\n *\tgmtapi_process_keys\n *\tgmtapi_get_key\n *\tgmtapi_found_marker\n *\n * The \"keys\" refer to the contents of the THIS_MODULE_KEYS set in each module.\n */\n\n/* Indices into the keys triple codes */\n#define K_OPT\t\t\t0\n#define K_FAMILY\t\t1\n#define K_DIR\t\t\t2\n#define K_EQUAL\t\t\t3\n#define K_MODIFIER\t\t4\n#define GMT_FILE_NONE\t\t0\n#define GMT_FILE_EXPLICIT\t1\n#define GMT_FILE_IMPLICIT\t2\n\n#define K_PRIMARY\t\t\t0\n#define K_SECONDARY\t\t\t1\n\n#define K_OR\t\t\t0\n#define K_AND\t\t\t1\n\n#define API_PRIMARY_INPUT\t\t'{'\n#define API_PRIMARY_OUTPUT\t\t'}'\n#define API_SECONDARY_INPUT\t\t'('\n#define API_SECONDARY_OUTPUT\t')'\n\nGMT_LOCAL int gmtapi_key_to_family (void *API, char *key, int *family, int *geometry) {\n\t/* Assign direction, family, and geometry based on the key.\n\t   Note: No Vector or Matrix here since those always masquerade as DATASET in modules. */\n\n\tswitch (key[K_FAMILY]) {\t/* 2nd char contains the data type code */\n\t\tcase 'G':\n\t\t\t*family = GMT_IS_GRID;\n\t\t\t*geometry = GMT_IS_SURFACE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\t*family = GMT_IS_DATASET;\n\t\t\t*geometry = GMT_IS_POLY;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t*family = GMT_IS_DATASET;\n\t\t\t*geometry = GMT_IS_LINE;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\t*family = GMT_IS_DATASET;\n\t\t\t*geometry = GMT_IS_POINT;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t*family = GMT_IS_PALETTE;\n\t\t\t*geometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\t*family = GMT_IS_IMAGE;\n\t\t\t*geometry = GMT_IS_SURFACE;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\t*family = GMT_IS_CUBE;\n\t\t\t*geometry = GMT_IS_VOLUME;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\t*family = GMT_IS_POSTSCRIPT;\n\t\t\t*geometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t*family = GMT_IS_NONE;\n\t\t\t*geometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"gmtapi_key_to_family: Key family (%c) not recognized\\n\", key[K_FAMILY]);\n\t\t\treturn GMT_NOTSET;\n\t\t\tbreak;\n\t}\n\n\t/* Third key character contains the in/out code */\n\treturn ((key[K_DIR] == API_SECONDARY_OUTPUT || key[K_DIR] == API_PRIMARY_OUTPUT) ? GMT_OUT : GMT_IN);\t/* Return the direction of the i/o */\n}\n\nGMT_LOCAL char * gmtapi_prepare_keys (struct GMTAPI_CTRL *API, const char *string) {\n\tchar *tmp = NULL, *c = NULL, *string_;\n\tstring_ = strdup(string);\t/* Have to make a copy because \"string\" is const and the c[0] = '\\0' make it crash on Win for non-debug builds */\n\tif ((c = strchr (string_, '@'))) {\t/* Split KEYS: classic@modern, must get the relevant half */\n\t\tc[0] = '\\0';\t/* Chop into two */\n\t\ttmp = (API->GMT->current.setting.run_mode == GMT_MODERN) ? strdup (&c[1]) : strdup (string_);\n\t\t//c[0] = '@';\t/* Restore */\n\t}\n\telse\t/* Only one set of KEYS */\n\t\ttmp = strdup (string);\t\t/* Get a working copy of string */\n\n\tfree(string_);\n\treturn (tmp);\n}\n\nGMT_LOCAL char ** gmtapi_process_keys (void *V_API, const char *string, char type, struct GMT_OPTION *head, int *n_to_add, unsigned int *n_items) {\n\t/* Turn the comma-separated list of 3-char codes in string into an array of such codes.\n \t * In the process, replace any ?-types with the selected type if type is not 0.\n\t * We return the array of strings and its number (n_items). */\n\tsize_t len, k, kk, n;\n\tint o_id = GMT_NOTSET, family = GMT_NOTSET, geometry = GMT_NOTSET;\n\tbool change_type = false;\n\tchar **s = NULL, *next = NULL, *tmp = NULL, magic = 0, revised[GMT_LEN64] = {\"\"};\n\tstruct GMT_OPTION *opt = NULL;\n\tstruct GMTAPI_CTRL *API = gmtapi_get_api_ptr (V_API);\n\n\t*n_items = 0;\t/* No keys yet */\n\n\tfor (k = 0; k < GMT_N_FAMILIES; k++) n_to_add[k] = GMT_NOTSET;\t/* Initially no input counts */\n\tif (!string) return NULL;\t/* Got NULL, so just give up */\n\ttmp = gmtapi_prepare_keys (API, string);\t/* Get the correct KEYS if there are separate ones for Classic and Modern mode */\n\tlen = strlen (tmp);\t\t\t/* Get the length of this item */\n\tif (len == 0) { \t\t\t/* Got no characters, so give up */\n\t\tgmt_M_str_free (tmp);\n\t\treturn NULL;\n\t}\n\t/* Replace unknown types (marked as ?) in tmp with selected type give by input variable \"type\" */\n\tif (type) {\t/* Got a nonzero type */\n\t\tfor (k = 0; k < strlen (tmp); k++)\n\t\t\tif (tmp[k] == '?') tmp[k] = type;\n\t}\n\t/* Count the number of items (start n at 1 since there are one less comma than items) */\n\tfor (k = 0, n = 1; k < len; k++)\n\t\tif (tmp[k] == ',') n++;\n\t/* Allocate and populate the character array, then return it and n_items */\n\ts = (char **) calloc (n, sizeof (char *));\n\tk = 0;\n\twhile ((next = strsep (&tmp, \",\")) != NULL) {\t/* Get each comma-separated key */\n\t\tif (strlen (next) < 3) {\n\t\t\tGMT_Report (API, GMT_MSG_WARNING,\n\t\t\t            \"gmtapi_process_keys: Key %s contains less than 3 characters\\n\", next);\n\t\t\tcontinue;\n\t\t}\n\t\tif (strchr (next, '!')) {\t/* Type did not get determined in GMT_Encode_Options so key is skipped */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG,\n\t\t\t            \"gmtapi_process_keys: key %s contains type = ! so we skip it\\n\", next);\n\t\t\tn--;\n\t\t\tcontinue;\n\t\t}\n\t\ts[k] = strdup (next);\n\t\tif (next[K_DIR] == API_PRIMARY_OUTPUT) {\t/* Identified primary output key */\n\t\t\tif (o_id >= 0)\t/* Already had a primary output key */\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING,\n\t\t\t\t            \"gmtapi_process_keys: Keys %s contain more than one primary output key\\n\", tmp);\n\t\t\telse\n\t\t\t\to_id = (int)k;\n\t\t}\n\t\tk++;\n\t}\n\n\t/* While processing the array we also determine the key # for the primary output (if there is one) */\n\tfor (k = 0; k < n; k++) {\t/* Check for presence of any of the magic X,Y,Z keys */\n\t\tif (s[k][K_OPT] == '-') {\t/* Key letter X missing: Means that option -Y, if given, changes the type of input|output */\n\t\t\t/* Must first determine which data type we are dealing with via -Y<type> */\n\t\t\tif ((opt = GMT_Find_Option (API, s[k][K_FAMILY], head))) {\t/* A -Y<type> option was passed to the module */\n\t\t\t\ttype = (char)toupper (opt->arg[0]);\t/* Find type and replace any ? in keys with this type in uppercase (CDGIP) in gmtapi_process_keys below */\n\t\t\t\tif (type == 'T')\t/* There is no longer a T type but we may honor T from GMT5.  The gmtread|write module will decide depending on compatibility level set */\n\t\t\t\t\ttype = 'D';\t/* opt->arg will still be 't' and is handled in the modules */\n\t\t\t\tif (!strchr (\"CDGIP\", type)) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"gmtapi_process_keys: No or bad data type given to read|write (%c)\\n\", type);\n\t\t\t\t\treturn_null (NULL, GMT_NOT_A_VALID_TYPE);\t/* Unknown type */\n\t\t\t\t}\n\t\t\t\tif (type == 'P') type = 'X';\t/* We use X for PostScript internally since P may stand for polygon... */\n\t\t\t\tfor (kk = 0; kk < n; kk++) {\t/* Do the substitution for all keys that matches ? */\n\t\t\t\t\tif (s[kk][K_FAMILY] == '?' && strchr (\"-({\", s[kk][K_DIR])) s[kk][K_FAMILY] = type;\t/* Want input to handle this type of data */\n\t\t\t\t\tif (s[kk][K_FAMILY] == '?' && strchr (\"-)}\", s[kk][K_DIR])) s[kk][K_FAMILY] = type;\t/* Want output to handle this type of data */\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING,\n\t\t\t\t            \"gmtapi_process_keys: Required runtime type-getting option (-%c) was not given\\n\", s[k][K_FAMILY]);\n\t\t\tgmt_M_str_free (s[k]);\t\t/* Free the inactive key that has now served its purpose */\n\t\t}\n\t\telse if (s[k][K_FAMILY] == '-') {\t/* Key letter Y missing: Means that -X, if given, changes primary input|output set by -Z to secondary (i.e., not required) */\n\t\t\t/* However, if +<mod> is appended then the primary input setting is left as is */\n\t\t\tif ((opt = GMT_Find_Option (API, s[k][K_OPT], head))) {\t/* Got the option that removes the requirement of an input or output dataset */\n\t\t\t\tif (!(s[k][3] == '+' && strstr (opt->arg, &s[k][3]))) {\t/* Got the option and no modifier to turn it off */\n\t\t\t\t\tfor (kk = 0; kk < n; kk++) {\t/* Change all primary input|output flags to secondary, depending on Z */\n\t\t\t\t\t\tif (!s[kk]) continue;\t\t/* A previously processed/freed key */\n\t\t\t\t\t\tif (s[kk][K_OPT] != s[k][K_DIR]) continue;\t\t/* Not the \"-Z \"option */\n\t\t\t\t\t\tif (s[kk][K_DIR] == API_PRIMARY_INPUT) s[kk][K_DIR] = API_SECONDARY_INPUT;\t\t/* No longer an implicit input */\n\t\t\t\t\t\telse if (s[kk][K_DIR] == API_PRIMARY_OUTPUT) s[kk][K_DIR] = API_SECONDARY_OUTPUT;\t/* No longer an implicit output */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_M_str_free (s[k]);\t\t/* Free the inactive key that has served its purpose */\n\t\t}\n\t\telse if (!strchr (\"{}()-\", s[k][K_DIR])) {\t/* Key letter Z not in {|(|}|)|-: which means that option -Z, if given, changes the type of primary output to Y */\n\t\t\t/* E.g, pscoast has >DM and this turns >X} to >D} only when -M is used.  Also, modifiers may be involved.\n\t\t\t   e.g, gmtspatial : New key \">TN+r\" means if -N+r is given then set >T}.  Just giving -N will not trigger the change.\n\t\t\t   e.g., pscoast \">TE+w-rR\" means if -E is given with modifier +w _and_ one of +r or +R is then set to >T}.\n\t\t\t   If X is not - then we will find the other KEY with X and select that as the one to change; this could\n\t\t\t   be used to change the primary INPUT type.  For instance, grdimage expects grid input (<G{+) but with\n\t\t\t   magic sequence <ID we change <G{+ to <I{+.  */\n\t\t\tmagic = s[k][K_DIR];\n\t\t\tif ((opt = GMT_Find_Option (API, magic, head))) {\t/* Got the magic option that changes output type */\n\t\t\t\tchar modifier[3] = {'+', '?', 0};\t/* We will replace ? with an actual modifier */\n\t\t\t\tsize_t this_k;\n\t\t\t\tif (o_id == GMT_NOTSET)\n\t\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"gmtapi_process_keys: No primary output identified but magic Z key present\\n\");\n\t\t\t\t/* Check if modifier(s) were given also and that one of them were selected */\n\t\t\t\tif (strlen (s[k]) > 3) {\t/* Not enough to just find option, must examine the modifiers */\n\t\t\t\t\t/* Full syntax: XYZ+abc...-def...: We do the substitution of output type to Y only if\n\t\t\t\t\t * 1. -Z is given\n\t\t\t\t\t * 2. -Z contains ALL the modifiers +a, +b, +c, ... (if any \"+\"-list is given)\n\t\t\t\t\t * 3. -Z contains AT LEAST ONE of the modifiers +d, +e, +f, ... (if any \"-\"=list is given)\n\t\t\t\t\t * At least one item from 2 or 3 must be given.\n\t\t\t\t\t */\n\t\t\t\t\tunsigned int kase = 0, count[2] = {0, 0}, given[2] = {0, 0};\n\t\t\t\t\tchange_type = false;\n\t\t\t\t\tfor (kk = 3; s[k][kk]; kk++) {\t/* Examine characters in the modifier string */\n\t\t\t\t\t\tif (strchr (\"-+\", s[k][kk])) {\t/* Start of all (+) versus at least one (-) */\n\t\t\t\t\t\t\tkase = (s[k][kk] == '-') ? K_OR : K_AND;\t/* Set kase and go to next letter */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount[kase]++;\t/* How many AND and how many OR modifiers (depending on kase) */\n\t\t\t\t\t\tmodifier[1] = s[k][kk];\t/* Set current modifier */\n\t\t\t\t\t\tif (strstr (opt->arg, modifier)) given[kase]++;\t/* Match found with given option */\n\t\t\t\t\t}\n\t\t\t\t\t/* Only change the key if we found all the AND modifiers and at least one of the OR modifiers (if any were given) */\n\t\t\t\t\tif ((count[K_OR] == 0 || (count[K_OR] && given[K_OR])) && count[K_AND] == given[K_AND]) change_type = true;\n\t\t\t\t}\n\t\t\t\telse\t/* true since we found the option and no modifiers were given */\n\t\t\t\t\tchange_type = true;\n\t\t\t\tif (s[k][K_OPT] != '-') {\t/* Find the relevant option to change [primary output key] */\n\t\t\t\t\tchar match = (s[k][K_OPT] == '<') ? API_PRIMARY_INPUT : API_PRIMARY_OUTPUT;\n\t\t\t\t\tfor (kk = 0, this_k = n; kk < n; kk++) {\n\t\t\t\t\t\tif (kk == k || s[kk] == NULL) continue;\n\t\t\t\t\t\tif (s[kk][K_OPT] == s[k][K_OPT] && s[kk][K_DIR] == match)\n\t\t\t\t\t\t\tthis_k = kk;\n\t\t\t\t\t}\n\t\t\t\t\tif (this_k == n) this_k = o_id;\n\t\t\t\t}\n\t\t\t\telse\t/* Select the primary output key */\n\t\t\t\t\tthis_k = o_id;\n\t\t\t\tif (change_type) {\n\t\t\t\t\tif (strchr (\"{<\", s[this_k][K_DIR])) {\n\t\t\t\t\t\tint new_family = 0, old_family = 0;\n\t\t\t\t\t\t(void)gmtapi_key_to_family (API, s[k], &new_family, &geometry);\n\t\t\t\t\t\t(void)gmtapi_key_to_family (API, s[this_k], &old_family, &geometry);\n\t\t\t\t\t\tif (new_family != old_family) gmt_M_int_swap (n_to_add[new_family], n_to_add[old_family]);\t/* Must swap our counts */\n\t\t\t\t\t}\n\t\t\t\t\ts[this_k][K_FAMILY] = s[k][K_FAMILY];\t/* Required input/output now implies this data type */\n\t\t\t\t\ts[this_k][K_OPT]    = s[k][K_OPT];\t/* Required input/output now implies this option */\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_M_str_free (s[k]);\t\t/* Free the inactive key that has served its purpose */\n\t\t}\n\t\telse if (s[k][K_DIR] == API_PRIMARY_INPUT) {\t/* Non-magic key: This one identified a primary input key */\n\t\t\t(void)gmtapi_key_to_family (API, s[k], &family, &geometry);\t/* Get datatype, and geometry, then set how many are requested */\n\t\t\tif (family != GMT_NOTSET) {\t/* Safeguard: If family not found then we don't want to crash below... */\n\t\t\t\tif (s[k][K_DIR+1])\t/* Gave an argument: This is either a number (a specific count) or + (1 or more) */\n\t\t\t\t\tn_to_add[family] = (s[k][K_DIR+1] == '+') ? GMTAPI_UNLIMITED : atoi (&s[k][K_DIR+1]);\n\t\t\t\telse\n\t\t\t\t\tn_to_add[family] = (family == GMT_IS_DATASET) ? GMTAPI_UNLIMITED : 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* Shuffle away any NULL entries as a result of magic key processing */\n\tfor (k = kk = 0; k < n; k++) {\n\t\tif (s[k]) {\t/* Must keep this guy */\n\t\t\tif (k > kk) s[kk] = s[k];\n\t\t\tkk++;\n\t\t}\n\t}\n\tn = kk;\t/* May have lost some NULLs.  Make a revised string for debug output */\n\tfor (k = 0; k < n; k++) {\n\t\tif (k) strcat (revised, \",\");\n\t\tstrncat (revised, s[k], GMT_LEN64-1);\n\t}\n\tif (revised[0]) GMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_process_keys: Revised keys string is %s\\n\", revised);\n\t*n_items = (unsigned int)n;\t/* Total number of remaining keys for this module */\n\tgmt_M_str_free (tmp);\n\treturn s;\t/* The array of remaining keys */\n}\n\nGMT_LOCAL int gmtapi_get_key (void *API, char option, char *keys[], int n_keys) {\n\t/* Returns the position in the keys array that matches this option, or GMT_NOTSET if not found */\n\tint k;\n\tif (n_keys && keys == NULL)\n\t\tGMT_Report (API, GMT_MSG_WARNING, \"gmtapi_get_key: Keys array is NULL but n_keys = %d\\n\", n_keys);\n\tfor (k = 0; keys && k < n_keys; k++) if (keys[k][K_OPT] == option) return (k);\n\treturn (GMT_NOTSET);\n}\n\nGMT_LOCAL bool gmtapi_found_marker (char *text) {\n\t/* A single questionmark and nothing else indicates a file marker */\n\tif (text[0] == '?' && text[1] == '\\0') return true;\n\treturn false;\t/* Not found */\n}\n\nGMT_LOCAL unsigned int gmtapi_determine_dimension (struct GMTAPI_CTRL *API, char *text) {\n\t/* Examine greenspline's -R option to learn the dimensionality of the domain (1, 2, or 3) */\n\tunsigned int n_slashes = 0;\n\tsize_t k;\n\tconst size_t s_length = strlen(text);\n\n\t/* First catch the simple -R? which means a grid is passed by the API, hence dimension is 2 */\n\tif (text[0] == '?' && text[1] == '\\0') return 2;\t/* A marker means a grid only, so done */\n\tfor (k = 0; k < s_length; k++)\n\t\tif (text[k] == '/') n_slashes++;\t\t\t/* Count slashes just in case */\n\tif ((text[0] == 'g' || text[0] == 'd') && (text[1] == '\\0' || text[1] == '/')) {\t/* Got -Rg or -Rd, possibly with trailing /zmin/zmax */\n\t\tif (text[1] == '\\0') return 2;\t/* Got -Rg or -Rd and no more */\n\t\tif (n_slashes == 2) return 3;\t/* Got -Rg/zmin/zmax or -Rd/zmin/zmax */\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Option -R: Give 2, 4, or 6 coordinates, a gridfile, or use -Rd|g[/zmin/zmax]\\n\");\n\t\treturn 0;\n\t}\n\tif (!gmt_access (API->GMT, text, R_OK))\t/* Gave a readable file, we assume it is a grid since that is all that is allowed */\n\t\treturn 2;\n\t/* Only get here if the above cases did not trip */\n\tif (!(n_slashes == 1 || n_slashes == 3 || n_slashes == 5)) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Option -R: Give 2, 4, or 6 coordinates\\n\");\n\t\treturn 0;\n\t}\n\treturn ((n_slashes + 1) / 2);\t/* Turns 1,3,5 into 1,2,3 */\n}\n\n/*! . */\nGMT_LOCAL void * gmtapi_retrieve_data (void *V_API, int object_ID) {\n\t/* Function to return pointer to the container for a registered data set.\n\t * Typically used when we wish a module to \"write\" its results to a memory\n\t * location that we wish to access from the calling program.  The procedure\n\t * is to use GMT_Register_IO with GMT_REF|COPY|READONLY and GMT_OUT but use\n\t * NULL as the source/destination.  Data are \"written\" by GMT allocating a\n\t * output container and updating the objects->resource pointer to this container.\n\t * gmtapi_retrieve_data simply returns that pointer given the registered ID.\n\t */\n\n\tint item;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\n\t/* Determine the item in the object list that matches this object_ID */\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET) {\n\t\treturn_null (API, API->error);\n\t}\n\tS_obj = API->object[item];\t/* Short hand */\n\t/* Make sure the resource is present */\n\tif (S_obj->resource == NULL) {\n\t\treturn_null (API, GMT_PTR_IS_NULL);\n\t}\n\n#ifdef DEBUG\n\t//gmtapi_list_objects (API, \"gmtapi_retrieve_data\");\n#endif\n\treturn (S_obj->resource);\t/* Return pointer to the resource container */\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_begin_io (struct GMTAPI_CTRL *API, unsigned int direction) {\n\t/* Initializes the i/o mechanism for either input or output (depends on direction).\n\t * gmtapi_begin_io must be called before any bulk data i/o is allowed.\n\t * direction:\tEither GMT_IN or GMT_OUT.\n\t * Returns:\tfalse if successful, true if error.\n\t */\n\n\tstruct GMT_CTRL *GMT = NULL;\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (API, GMT_NOT_A_VALID_DIRECTION);\n\tAPI->error = GMT_NOERROR;\n\tif (!API->registered[direction])\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_begin_io: No %s resources registered\\n\", GMT_direction[direction]);\n\t/* Passed basic sanity checks */\n\tGMT = API->GMT;\n\tAPI->io_mode[direction] = GMTAPI_BY_SET;\n\tAPI->io_enabled[direction] = true;\t/* OK to access resources */\n\tGMT->current.io.ogr = GMT_OGR_UNKNOWN;\n\tGMT->current.io.variable_in_columns = false;\n\tGMT->current.io.need_previous = (GMT->common.g.active || GMT->current.io.skip_duplicates);\n\tGMT->current.io.segment_header[0] = GMT->current.io.curr_text[0] = 0;\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_begin_io: %s resource access is now enabled [container]\\n\", GMT_direction[direction]);\n\n\treturn (GMT_NOERROR);\t/* No error encountered */\n}\n\n/* Mapping of internal [row][col] indices to a single 1-D index.\n * Internally, row and col both starts at 0.  These will be accessed\n * via pointers to these functions, hence they are not macros.\n * They apply to GMT_MATRIX items, NOT grids/images with pads.\n */\n\n/*! . */\nGMT_LOCAL uint64_t gmtapi_2d_to_index_c_normal (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for C normal row-major grid */\n\treturn ((row * dim) + col);\t/* Normal scanline grid */\n}\n\n/*! . */\nGMT_LOCAL uint64_t gmtapi_2d_to_index_c_cplx_real (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for C complex row-major grid, real component */\n\treturn (2ULL*(row * dim) + col);\t/* Complex scanline grid, real(1) component */\n}\n\n/*! . */\nGMT_LOCAL uint64_t gmtapi_2d_to_index_c_cplx_imag (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for C complex row-major grid, imaginary component */\n\treturn (2ULL*(row * dim) + col + 1ULL);\t/* Complex grid, imag(2) component */\n}\n\n/*! . */\nGMT_LOCAL uint64_t gmtapi_2d_to_index_f_normal (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for Fortran column-major grid */\n\treturn ((col * dim) + row);\n}\n\n/*! . */\nGMT_LOCAL uint64_t gmtapi_2d_to_index_f_cplx_real (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for Fortran complex column-major grid, real component */\n\treturn (2ULL*(col * dim) + row);\t/* Complex grid, real(1) */\n}\n\n/*! . */\nGMT_LOCAL uint64_t gmtapi_2d_to_index_f_cplx_imag (uint64_t row, uint64_t col, uint64_t dim) {\n\t/* Maps (row,col) to 1-D index for Fortran complex column-major grid, imaginary component  */\n\treturn (2ULL*(col * dim) + row + 1ULL);\t/* Complex grid, imag(2) component */\n}\n\n/*! . */\nGMT_LOCAL p_func_uint64_t gmtapi_get_2d_to_index (struct GMTAPI_CTRL *API, enum GMT_enum_fmt shape, unsigned int mode) {\n\t/* Return pointer to the required 2D-index function above for MATRIX.  Here\n\t * shape is either GMT_IS_ROW_FORMAT (C) or GMT_IS_COL_FORMAT (Fortran);\n\t * mode is either 0 (regular grid), GMT_GRID_IS_COMPLEX_REAL (complex real) or GMT_GRID_IS_COMPLEX_IMAG (complex imag)\n\t */\n\tp_func_uint64_t p = NULL;\n\n\tswitch (mode & GMT_GRID_IS_COMPLEX_MASK) {\n\t\tcase GMT_GRID_IS_REAL:\n\t\t\tp = (shape == GMT_IS_ROW_FORMAT) ? gmtapi_2d_to_index_c_normal : gmtapi_2d_to_index_f_normal;\n\t\t\tbreak;\n\t\tcase GMT_GRID_IS_COMPLEX_REAL:\n\t\t\tp = (shape == GMT_IS_ROW_FORMAT) ? gmtapi_2d_to_index_c_cplx_real : gmtapi_2d_to_index_f_cplx_real;\n\t\t\tbreak;\n\t\tcase GMT_GRID_IS_COMPLEX_IMAG:\n\t\t\tp = (shape == GMT_IS_ROW_FORMAT) ? gmtapi_2d_to_index_c_cplx_imag : gmtapi_2d_to_index_f_cplx_imag;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"gmtapi_get_2d_to_index: Illegal mode passed\\n\");\n\t\t\treturn (NULL);\n\t}\n\treturn (p);\n}\n\n#if 0\t/* Unused at the present time */\nGMT_LOCAL void gmtapi_index_to_2d_c (int *row, int *col, size_t index, int dim, int mode) {\n\t/* Maps 1-D index to (row,col) for C */\n\tif (mode) index /= 2;\n\t*col = (index % dim);\n\t*row = (index / dim);\n}\n\nGMT_LOCAL void gmtapi_index_to_2d_f (int *row, int *col, size_t index, int dim, int mode) {\n\t/* Maps 1-D index to (row,col) for Fortran */\n\tif (mode) index /= 2;\n\t*col = (index / dim);\n\t*row = (index % dim);\n}\n#endif\n\n/* Mapping of internal [row][col][layer] indices to a single 1-D index for images.\n * Internally, row and col starts at 0.  These will be accessed\n * via pointers to these functions, hence they are not macros.\n */\n\nGMT_LOCAL inline uint64_t gmtapi_get_index_from_TRB (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index of an array with a band-interleaved layout RRR...RGGG...GBBB...B */\n\treturn (h->pad[XLO] + col) + ((row + h->pad[YHI]) * h->mx) + (layer * h->size);\n}\n\nGMT_LOCAL inline uint64_t gmtapi_get_index_from_TRP (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index of an array with a pixel-interleaved layout RGBRGBRGB...*/\n\treturn ((h->pad[XLO] + col) * h->n_bands) + layer + ((row + h->pad[YHI]) * h->mx * h->n_bands);\n}\n\nGMT_LOCAL inline uint64_t gmtapi_get_index_from_TRL (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index of an array with a line-interleaved layout R...RG..GB...BR...RG...GB...B...*/\n\treturn (h->pad[XLO] + col) + (layer * h->mx) + ((row + h->pad[YHI]) * h->mx * h->n_bands);\n}\n\nGMT_LOCAL inline uint64_t gmtapi_get_index_from_TRS (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index of an default GMT grid */\n\tgmt_M_unused(layer);\n\treturn (gmt_M_ijp (h, row, col));\n}\n\nGMT_LOCAL inline uint64_t gmtapi_get_index_from_TRR (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index to the real component of an default complex GMT grid */\n\tgmt_M_unused(layer);\n\treturn (2ULL*gmt_M_ijp (h, row, col));\n}\n\nGMT_LOCAL inline uint64_t gmtapi_get_index_from_TRI (struct GMT_GRID_HEADER *h, uint64_t row, uint64_t col, uint64_t layer) {\n\t/* Get linear index to the imag component of an default complex GMT grid */\n\tgmt_M_unused(layer);\n\treturn (2ULL*gmt_M_ijp (h, row, col)+1ULL);\n}\n\n/*! . */\nGMT_LOCAL unsigned int gmtapi_decode_layout (struct GMTAPI_CTRL *API, const char *code, enum GMT_enum_family *family) {\n\t/* Convert the 3-letter grid/image layout code to a single integer mode.\n\t * Defaults are TRS for grids and TRB for images. */\n\tunsigned int bits = 0;\t/* Default value */\n\t*family = GMT_IS_IMAGE;\t/* Default value, may be changed later */\n\tswitch (code[0]) {\t/* Char 1: The Y direction */\n\t\tcase 'T':\tbreak;\t\t\t /* Top-to-bottom [Default] */\n\t\tcase 'B':\tbits = 1; break; /* Bottom-to-top */\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Illegal code [%c] for y-direction grid/image layout.  Must be T or B\\n\", code[0]);\n\t\t\tbreak;\n\t}\n\tswitch (code[1]) {\t/* Char 2: The storage mode (rows vs columns) */\n\t\tcase 'R':\tbreak;\t\t \t  /* rows, i.e., scanlines [Default] */\n\t\tcase 'C':\tbits |= 2; break; /* columns (e.g., Fortran) */\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Illegal code [%c] for grid/image storage mode.  Must be R or C\\n\", code[1]);\n\t\t\tbreak;\n\t}\n\tswitch (code[2]) {\t/* Char 3: Grids: Single, complex-Real, complex-Imag.  Images: band interleaving mode B|L|P */\n\t\tcase 'S':\t*family = GMT_IS_GRID; break;\t/* Single-valued grid [Default] */\n\t\tcase 'R':\tbits |= 4; *family = GMT_IS_GRID; break;\t/* Real component of complex grid */\n\t\tcase 'I':\tbits |= 8; *family = GMT_IS_GRID; break;\t/* Imaginary component of complex grid */\n\t\tcase 'B':\tbreak;\t\t\t/* r/g/b separated into three bands (layers) */\n\t\tcase 'L':\tbits |= 4; break;\t/* r/g/b separated into three lines */\n\t\tcase 'P':\tbits |= 8; break;\t/* r/g/b separated into three values per pixel */\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Illegal code [%c] for type of grid or image layout.  Must be SRI (grids) or BLP (images)\\n\", code[1]);\n\t\t\tbreak;\n\t}\n\treturn (bits);\n}\n\nGMT_LOCAL int gmtapi_init_grdheader (struct GMT_CTRL *GMT, unsigned int direction, struct GMT_GRID_HEADER *header, struct GMT_OPTION *options,\n                             uint64_t dim[], double wesn[], double inc[], unsigned int registration, unsigned int mode) {\n\t/* Convenient way of setting a header struct wesn, inc, and registration, then compute dimensions, etc. */\n\tdouble wesn_dup[4] = {0.0, 0.0, 0.0, 0.0}, inc_dup[2] = {0.0, 0.0};\n\tunsigned int n_layers = 1;\n\tchar *regtype[2] = {\"gridline\", \"pixel\"};\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = gmt_get_H_hidden (header);\n\tgmt_M_unused(mode);\n\n\tif (registration & GMT_GRID_DEFAULT_REG) registration |= GMT->common.R.registration;\t/* Set the default registration */\n\tregistration = (registration & 1);\t/* Knock off any GMT_GRID_DEFAULT_REG bit */\n\tif (dim && (wesn == NULL || (gmt_M_is_zero (wesn[XLO]) && gmt_M_is_zero (wesn[XHI]) && gmt_M_is_zero (wesn[YLO]) && gmt_M_is_zero (wesn[YHI]))) && (inc == NULL || (gmt_M_is_zero (inc[GMT_X]) && gmt_M_is_zero (inc[GMT_Y])))) {\t/* Gave dimension instead, set range and inc (1/1) while considering registration */\n\t\tgmt_M_memset (wesn_dup, 4, double);\n\t\twesn_dup[XHI] = (double)(dim[GMT_X]);\n\t\twesn_dup[YHI] = (double)(dim[GMT_Y]);\n\t\tinc_dup[GMT_X] = inc_dup[GMT_Y] = 1.0;\n\t\tif (registration == GMT_GRID_NODE_REG) wesn_dup[XHI] -= 1.0, wesn_dup[YHI] -= 1.0;\n\t\tif (dim[GMT_Z] > 1) n_layers = (unsigned int)dim[GMT_Z];\n\t\tGMT_Report (GMT->parent, GMT_MSG_DEBUG, \"Grid/Image dimensions imply w/e/s/n = 0/%g/0/%g, inc = 1/1, %s registration, n_layers = %u\\n\",\n\t\t\twesn_dup[XHI], wesn_dup[YHI], regtype[registration], n_layers);\n\t}\n\telse {\t/* Must infer dimension etc from wesn, inc, registration */\n\t\tif (wesn == NULL) {\t/* Must select -R setting */\n\t\t\tif (!GMT->common.R.active[RSET]) {\n\t\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"No w/e/s/n given and no -R in effect.  Cannot initialize new grid\\n\");\n\t\t\t\treturn GMT_ARG_IS_NULL;\n\t\t\t}\n\t\t}\n\t\telse\t/* In case user is passing header->wesn etc we must save them first as gmt_grd_init will clobber them */\n\t\t\tgmt_M_memcpy (wesn_dup, wesn, 4, double);\n\t\tif (inc == NULL) {\t/* Must select -I setting */\n\t\t\tif (!GMT->common.R.active[ISET]) {\n\t\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"No increment given and no -I in effect.  Cannot initialize new grid\\n\");\n\t\t\t\treturn GMT_ARG_IS_NULL;\n\t\t\t}\n\t\t}\n\t\telse\t/* In case user is passing header->inc etc we must save them first as gmt_grd_init will clobber them */\n\t\t\tgmt_M_memcpy (inc_dup, inc, 2, double);\n\t\tif (dim && dim[GMT_Z] > 1) n_layers = (unsigned int)dim[GMT_Z];\n\t\tif (inc != NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_DEBUG, \"Grid/Image dimensions imply w/e/s/n = %g/%g/%g/%g, inc = %g/%g, %s registration, n_layers = %u\\n\",\n\t\t\t            wesn_dup[XLO], wesn_dup[XHI], wesn_dup[YLO], wesn_dup[YHI], inc[GMT_X], inc[GMT_Y], regtype[registration], n_layers);\n\t\t}\n\t}\n\t/* Clobber header and reset */\n\tgmt_grd_init (GMT, header, options, false);\t/* This is for new grids only so update is always false */\n\tif (dim == NULL && wesn == NULL)\n\t\tgmt_M_memcpy (header->wesn, GMT->common.R.wesn, 4, double);\n\telse\n\t\tgmt_M_memcpy (header->wesn, wesn_dup, 4, double);\n\tif (dim == NULL && inc == NULL)\n\t\tgmt_M_memcpy (header->inc, GMT->common.R.inc, 2, double);\n\telse\n\t\tgmt_M_memcpy (header->inc, inc_dup, 2, double);\n\theader->registration = registration;\n\t/* Copy row-order from R.row_order, if set */\n\tif (GMT->common.R.row_order) HH->row_order = GMT->common.R.row_order;\n\t/* Mode may contain complex mode information */\n\theader->complex_mode = (mode & GMT_GRID_IS_COMPLEX_MASK);\n\tHH->grdtype = gmtlib_get_grdtype (GMT, direction, header);\n\tgmt_RI_prepare (GMT, header);\t/* Ensure -R -I consistency and set n_columns, n_rows in case of meter units etc. */\n\tgmt_M_err_pass (GMT, gmt_grd_RI_verify (GMT, header, 1), \"\");\n\tgmt_M_grd_setpad (GMT, header, GMT->current.io.pad);\t/* Assign default GMT pad */\n\tif (dim) header->n_bands = n_layers;\n\tgmt_set_grddim (GMT, header);\t/* Set all dimensions before returning */\n\tgmtlib_grd_get_units (GMT, header);\n\tgmt_BC_init (GMT, header);\t/* Initialize grid interpolation and boundary condition parameters */\n\tHH->grdtype = gmtlib_get_grdtype (GMT, direction, header);\t/* Set grid type (i.e. periodicity for global grids) */\n#ifdef DOUBLE_PRECISION_GRID\n\theader->type = GMT_GRID_IS_ND;\n#else\n\theader->type = GMT_GRID_IS_NF;\n#endif\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_init_grid (struct GMTAPI_CTRL *API, struct GMT_OPTION *opt, uint64_t dim[], double *range, double *inc, int registration, unsigned int mode, unsigned int direction, struct GMT_GRID *G) {\n\tif (direction == GMT_OUT) return (GMT_NOERROR);\t/* OK for creating a blank container for output */\n\treturn (gmtapi_init_grdheader (API->GMT, direction, G->header, opt, dim, range, inc, registration, mode));\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_init_image (struct GMTAPI_CTRL *API, struct GMT_OPTION *opt, uint64_t dim[], double *range, double *inc, int registration, unsigned int mode, unsigned int direction, struct GMT_IMAGE *I) {\n\tif (direction == GMT_OUT) return (GMT_NOERROR);\t/* OK for creating blank container for output */\n\treturn (gmtapi_init_grdheader (API->GMT, direction, I->header, opt, dim, range, inc, registration, mode));\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_init_matrix (struct GMTAPI_CTRL *API, uint64_t dim[], double *range, double *inc, int registration, unsigned int mode, unsigned int direction, struct GMT_MATRIX *M) {\n\t/* If range = inc = NULL then add dimensioning is set via dim: ncols, nrow, nlayers, type.\n\t * else, ncols,nrows is set via range and inc and registration. dim, if not null, sets dim[2] = nlayers [1] and dim[3] = type [double]\n\t */\n\tint error;\n\tunsigned int dims = (M->n_layers > 1) ? 3 : 2;\n\tsize_t size = 0;\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Initializing a matrix for handing external %s [mode = %u]\\n\", GMT_direction[direction], mode);\n\tif (direction == GMT_OUT) {\t/* OK to create blank container for output unless dims or range/inc is also set */\n\t\tif (dim && dim[GMTAPI_DIM_ROW]) {\t/* Dimensions are given when we are using external memory for the matrix and must specify the dimensions specifically */\n\t\t\tM->n_rows    = dim[GMTAPI_DIM_ROW];\n\t\t\tM->n_columns = dim[GMTAPI_DIM_COL];\n\t\t\tM->dim = (M->shape == GMT_IS_ROW_FORMAT) ? M->n_columns : M->n_rows;\t/* Matrix layout order */\n\t\t}\n\t\telse if (range) {\t/* Giving dimensions via range and inc when using external memory */\n\t\t\tif (!inc || (inc[GMT_X] == 0.0 && inc[GMT_Y] == 0.0)) return (GMT_VALUE_NOT_SET);\n\t\t\tgmt_M_memcpy (M->range, range, 2 * dims, double);\n\t\t\tgmt_M_memcpy (M->inc, inc, dims, double);\n\t\t\tM->n_rows    = gmt_M_get_n (API->GMT, range[YLO], range[YHI], inc[GMT_Y], registration);\n\t\t\tM->n_columns = gmt_M_get_n (API->GMT, range[XLO], range[XHI], inc[GMT_X], registration);\n\t\t\tM->dim = (M->shape == GMT_IS_ROW_FORMAT) ? M->n_columns : M->n_rows;\t/* Matrix layout order */\n\t\t}\n\t\treturn (GMT_NOERROR);\n\t}\n\tif (full_region (range) && (dims == 2 || (!range || range[ZLO] == range[ZHI]))) {\t/* Not an equidistant vector arrangement, use dim */\n\t\tdouble dummy_range[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\t/* Flag vector as such */\n\t\tgmt_M_memcpy (M->range, dummy_range, 2 * dims, double);\n\t\tgmt_M_memcpy (M->inc, dummy_range, dims, double);\n\t\tM->n_rows    = dim[GMTAPI_DIM_ROW];\n\t\tM->n_columns = dim[GMTAPI_DIM_COL];\n\t}\n\telse {\t/* Was apparently given valid range and inc */\n\t\tif (!inc || (inc[GMT_X] == 0.0 && inc[GMT_Y] == 0.0)) return (GMT_VALUE_NOT_SET);\n\t\tgmt_M_memcpy (M->range, range, 2 * dims, double);\n\t\tgmt_M_memcpy (M->inc, inc, dims, double);\n\t\tM->n_rows    = gmt_M_get_n (API->GMT, range[YLO], range[YHI], inc[GMT_Y], registration);\n\t\tM->n_columns = gmt_M_get_n (API->GMT, range[XLO], range[XHI], inc[GMT_X], registration);\n\t}\n\tM->type = (dim == NULL) ? API->GMT->current.setting.export_type : dim[3];\t/* Use selected data type for export or default to GMT setting */\n\tM->dim = (M->shape == GMT_IS_ROW_FORMAT) ? M->n_columns : M->n_rows;\n\tM->registration = registration;\n\tsize = M->n_rows * M->n_columns * ((size_t)M->n_layers);\t/* Size of the initial matrix allocation (number of elements) */\n\tif ((mode & GMT_CONTAINER_ONLY) == 0) {\t/* Must allocate data memory */\n\t\tstruct GMT_MATRIX_HIDDEN *MH = gmt_get_M_hidden (M);\n\t\tif (size) {\t/* Must allocate data matrix and possibly string array */\n\t\t\tif ((error = gmtlib_alloc_univector (API->GMT, &(M->data), M->type, size)) != GMT_NOERROR)\n\t\t\t\treturn (error);\n\t\t\tif (mode & GMT_WITH_STRINGS) {\t/* Must allocate text pointer array */\n\t\t\t\tif ((M->text = gmt_M_memory (API->GMT, NULL, M->n_rows, char *)) == NULL)\n\t\t\t\t\treturn (GMT_MEMORY_ERROR);\n\t\t\t}\n\t\t}\n\t\tMH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t}\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL uint64_t gmtapi_vector_nrows (uint64_t dim[], double *range, double *inc, int registration, unsigned int dir) {\n\tif (dim && dim[GMTAPI_DIM_ROW]) return dim[GMTAPI_DIM_ROW];\t/* Gave the dimension directly */\n\tif (dir == GMT_IN && (!inc || inc[GMT_X] == 0.0)) return ((uint64_t)GMT_NOTSET);\n\tif (dir == GMT_IN && (!range || (range[XLO] == 0.0 && range[XHI] == 0.0))) return ((uint64_t)GMT_NOTSET);\n\tif (range && inc) return (gmt_M_get_n (API->GMT, range[XLO], range[XHI], inc[GMT_X], registration));\n\treturn (0);\t/* When dir == GMT_OUT */\n}\n\n/*! . */\nGMT_LOCAL int64_t gmtapi_vector_ncols (uint64_t dim[], unsigned int dir) {\n\tif (dim) return (int64_t) dim[GMTAPI_DIM_COL];\t/* Gave the dimension directly */\n\tif (dir == GMT_OUT) return (0);\t\t/* Not set for output to be allocated later */\n\treturn (GMT_NOTSET);\t/* When dir == GMT_IN and we fail */\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_init_vector (struct GMTAPI_CTRL *API, uint64_t dim[], double *range, double *inc, int registration, unsigned int mode, unsigned int direction, struct GMT_VECTOR *V) {\n\t/* If range = inc = NULL then add dimensioning is set via dim: ncols, nrow, type.\n\t * else, ncols,nrows is set via range and inc and registration. dim[2], if not null, sets type [double]\n\t */\n\tint error;\n\tuint64_t col;\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Initializing a vector for handing external %s\\n\", GMT_direction[direction]);\n\tif (direction == GMT_OUT) {\t/* OK for creating blank container for output, but sometimes there are dimensions */\n\t\tif (dim && dim[GMTAPI_DIM_ROW] && V->n_columns)\n\t\t\tV->n_rows = dim[GMTAPI_DIM_ROW];\t/* Set n_rows in case when vectors will be hook on from external memory */\n\t\telse if (range && V->n_columns)\t/* Giving dimensions via range and inc when using external memory */\n\t\t\tV->n_rows = gmtapi_vector_nrows (dim, range, inc, registration, direction);\n\t\treturn (GMT_NOERROR);\n\t}\n\telse if (V->n_columns == 0)\n\t\treturn (GMT_VALUE_NOT_SET);\t/* Must know the number of columns to do this */\n\tif ((range && inc == NULL) || (range == NULL && inc)) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Passed one of range, inc as NULL\\n\");\n\t\treturn (GMT_VALUE_NOT_SET);\n\t}\n\tif ((range == NULL && inc == NULL) || (range[XLO] == range[XHI] && inc[GMT_X] == 0.0)) {\t/* Not an equidistant vector arrangement, use dim */\n\t\tdouble dummy_range[2] = {0.0, 0.0};\t/* Flag vector as such */\n\t\tV->n_rows = dim[GMTAPI_DIM_ROW];\t\t/* If so, n_rows is passed via dim[GMTAPI_DIM_ROW], unless it is GMT_OUT when it is zero */\n\t\tgmt_M_memcpy (V->range, dummy_range, 2, double);\n\t}\n\telse {\t/* Equidistant vector defined by dimension or range/inc */\n\t\tint64_t n = gmtapi_vector_nrows (dim, range, inc, registration, direction);\n\t\tif (n == GMT_NOTSET) return (GMT_VALUE_NOT_SET);\n\t\tV->n_rows = (uint64_t)n;\n\t\tgmt_M_memcpy (V->range, range, 2, double);\n\t}\n\tfor (col = 0; col < V->n_columns; col++)\t/* Set the same export data type for all vectors (or default to double) */\n\t\tV->type[col] = (dim == NULL) ? API->GMT->current.setting.export_type : dim[GMT_Z];\n\tif ((mode & GMT_CONTAINER_ONLY) == 0) {\t/* Must allocate space */\n\t\tstruct GMT_VECTOR_HIDDEN *VH = gmt_get_V_hidden (V);\n\t\tif (V->n_rows) {\t/* Must allocate vector space and possibly strings */\n\t\t\tif ((error = gmtlib_alloc_vectors (API->GMT, V, V->n_rows)) != GMT_NOERROR)\n\t\t\t\treturn (error);\n\t\t\tif (mode & GMT_WITH_STRINGS) {\t/* Must allocate text pointer array */\n\t\t\t\tif ((V->text = gmt_M_memory (API->GMT, NULL, V->n_rows, char *)) == NULL)\n\t\t\t\t\treturn (GMT_MEMORY_ERROR);\n\t\t\t\tVH->alloc_mode_text = GMT_ALLOC_INTERNALLY;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL double * gmtapi_matrix_coord (struct GMTAPI_CTRL *API, int dim, struct GMT_MATRIX *M) {\n\t/* Allocate and compute coordinates along one dimension of a matrix */\n\tdouble *coord = NULL, off;\n\tunsigned int min, max;\n\tuint64_t k, n;\n\n\tif (M->n_layers <= 1 && dim == GMT_Z) return (NULL);\t/* No z-dimension */\n\tn = (dim == GMT_X) ? M->n_columns : ((dim == GMT_Y) ? M->n_rows : M->n_layers);\n\tmin = 2*dim, max = 2*dim + 1;\t/* Indices into the min/max triplets in range */\n\tcoord = gmt_M_memory (API->GMT, NULL, n, double);\n\toff = 0.5 * M->registration;\n\tfor (k = 0; k < n; k++) coord[k] = gmt_M_col_to_x (API->GMT, k, M->range[min], M->range[max], M->inc[dim], off, n);\n\treturn (coord);\n}\n\n/*! . */\nGMT_LOCAL double * gmtapi_vector_coord (struct GMTAPI_CTRL *API, int dim, struct GMT_VECTOR *V) {\n\t/* Allocate and compute coordinates for a vector, if equidistantly defined */\n\tunsigned int k;\n\tdouble *coord = NULL, off, inc;\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_vector_coord called: dim = %d\\n\", dim);\n\tif (V->range[0] == 0.0 && V->range[1] == 0.0) return (NULL);\t/* Not an equidistant vector */\n\tcoord = gmt_M_memory (API->GMT, NULL, V->n_rows, double);\n\toff = 0.5 * V->registration;\n\tinc = gmt_M_get_inc (API->GMT, V->range[0], V->range[1], V->n_rows, V->registration);\n\tfor (k = 0; k < V->n_rows; k++) coord[k] = gmt_M_col_to_x (API->GMT, k, V->range[0], V->range[1], inc, off, V->n_rows);\n\treturn (coord);\n}\n\n/*! . */\nGMT_LOCAL void gmtapi_grdheader_to_matrixinfo (struct GMT_GRID_HEADER *h, struct GMT_MATRIX *M_obj) {\n\t/* Packs the necessary items of the grid header into the matrix parameters */\n\tM_obj->n_columns = h->n_columns;\n\tM_obj->n_rows = h->n_rows;\n\tM_obj->registration = h->registration;\n\tgmt_M_memcpy (M_obj->range, h->wesn, 4, double);\n\tgmt_M_memcpy (M_obj->inc, h->inc, 2, double);\n}\n\n/*! . */\nGMT_LOCAL void gmtapi_matrixinfo_to_grdheader (struct GMT_CTRL *GMT, struct GMT_GRID_HEADER *h, struct GMT_MATRIX *M_obj) {\n\t/* Unpacks the necessary items into the grid header from the matrix parameters */\n\tgmt_M_unused(GMT);\n\th->n_columns = (unsigned int)M_obj->n_columns;\n\th->n_rows = (unsigned int)M_obj->n_rows;\n\th->registration = M_obj->registration;\n\tif (M_obj->range[XLO] == M_obj->range[XHI] && M_obj->range[YLO] == M_obj->range[YHI]) {\t/* No range data given */\n\t\th->wesn[XHI] = h->n_columns - 1.0;\n\t\th->wesn[YHI] = h->n_rows - 1.0;\n\t\th->inc[GMT_X] = h->inc[GMT_Y] = 1.0;\n\t}\n\telse {\n\t\tgmt_M_memcpy (h->wesn, M_obj->range, 4, double);\n\t\tgmt_M_memcpy (h->inc, M_obj->inc, 2, double);\n\t}\n\t/* External matrices have no padding but the internal grid will */\n\t/* Compute xy_off  */\n\th->xy_off = (h->registration == GMT_GRID_NODE_REG) ? 0.0 : 0.5;\n\tgmt_set_grddim (GMT, h);\n}\n\n/*! . */\nGMT_LOCAL bool gmtapi_adjust_grdpadding (struct GMT_GRID_HEADER *h, unsigned int *pad) {\n\t/* Compares current grid pad status to output pad requested.  If we need\n\t * to adjust a pad we return true here, otherwise false. */\n\tunsigned int side;\n\n\tfor (side = 0; side < 4; side++) if (h->pad[side] != pad[side]) return (true);\n\treturn (false);\n}\n\n/*! . */\nstruct GMT_GRID_HEADER * gmt_get_header (struct GMT_CTRL *GMT) {\n\tstruct GMT_GRID_HEADER *h = gmt_M_memory (GMT, NULL, 1, struct GMT_GRID_HEADER);\n\th->hidden = gmt_M_memory (GMT, NULL, 1, struct GMT_GRID_HEADER_HIDDEN);\n\treturn (h);\n}\n\n/*! . */\nGMT_LOCAL size_t gmtapi_set_grdarray_size (struct GMT_CTRL *GMT, struct GMT_GRID_HEADER *h, unsigned int mode, double *wesn) {\n\t/* Determines size of grid given grid spacing and grid domain in h.\n \t * However, if wesn is given and not empty we compute size using the sub-region instead.\n \t * Finally, the current pad is used when calculating the grid size.\n\t * NOTE: This function leaves h unchanged by testing on a temporary header. */\n\tstruct GMT_GRID_HEADER *h_tmp = NULL;\n\tsize_t size;\n\n\t/* Must duplicate header and possibly reset wesn, then set pad and recalculate all dims */\n\th_tmp = gmt_get_header (GMT);\n\tgmt_copy_gridheader (GMT, h_tmp, h);\n\th_tmp->complex_mode = (mode & GMT_GRID_IS_COMPLEX_MASK);\t/* Set the mode-to-be so that if complex the size is doubled */\n\n\tif (!full_region (wesn)) {\n\t\tgmt_M_memcpy (h_tmp->wesn, wesn, 4, double);    /* Use wesn instead of header info */\n\t\tgmt_adjust_loose_wesn (GMT, wesn, h);           /* Subset requested; make sure wesn matches header spacing */\n\t\tgmt_M_memcpy(h_tmp->wesn, wesn, 4, double);\t    /* And update the eventually adjusted wesn */\n\t}\n\tgmt_M_grd_setpad (GMT, h_tmp, GMT->current.io.pad);\t/* Use the system pad setting by default */\n\tgmt_set_grddim (GMT, h_tmp);\t\t\t\t/* Computes all integer parameters */\n\tsize = h_tmp->size;\t\t\t\t\t/* This is the size needed to hold grid + padding */\n\tgmt_M_free (GMT, h_tmp->hidden);\n\tgmt_M_free (GMT, h_tmp);\n\treturn (size);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_open_grd (struct GMT_CTRL *GMT, char *file, struct GMT_GRID *G, char mode, unsigned int access_mode) {\n\t/* Read or write the header structure and initialize row-by-row machinery for grids.\n\t * We fill the GMT_GRID_ROWBYROW structure with all the required information.\n\t * mode can be w or r.  Upper case W or R refers to headerless native\n\t * grid files.  The access_mode dictates if we automatically advance\n\t * row counter to next row after read/write or if we use the rec_no to seek\n\t * first.\n\t */\n\n\tint r_w, err;\n\tbool header = true, magic = true, alloc = false;\n\tint cdf_mode[3] = { NC_NOWRITE, NC_WRITE, NC_WRITE};\t/* These MUST be ints */\n\tchar *bin_mode[3] = { \"rb\", \"rb+\", \"wb\"};\n\tchar *fmt = NULL;\n\tstruct GMT_GRID_HIDDEN *GH = gmt_get_G_hidden (G);\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = gmt_get_H_hidden (G->header);\n\tstruct GMT_GRID_ROWBYROW *R = gmtapi_get_rbr_ptr (GH->extra);\t/* Shorthand to row-by-row book-keeping structure */\n\n\tif (mode == 'r' || mode == 'R') {\t/* Open file for reading */\n\t\tif (mode == 'R') {\t/* File has no header; can only work if G->header has been set already, somehow */\n\t\t\theader = false;\n\t\t\tif (G->header->n_columns == 0 || G->header->n_rows == 0) {\n\t\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Unable to read header-less grid file %s without a preset header structure\\n\", file);\n\t\t\t\treturn (GMT_GRDIO_OPEN_FAILED);\n\t\t\t}\n\t\t}\n\t\tr_w = 0;\tmode = 'r';\n\t}\n\telse if (mode == 'W') {\t/* Write headerless grid */\n\t\tr_w = 2;\tmode = 'w';\n\t\theader = magic = false;\n\t}\n\telse {\t/* Regular writing of grid with header */\n\t\tr_w = 1;\n\t\tmagic = false;\n\t}\n\tif (header) {\n\t\tif (mode == 'r' && !R->open)\t/* First time reading the info */\n\t\t\tgmtlib_read_grd_info (GMT, file, G->header);\n\t\telse if (R->open)\t\t/* Coming back to update the header */\n\t\t\tgmt_update_grd_info (GMT, file, G->header);\n\t\telse\t\t\t\t/* First time writing the header */\n\t\t\tgmtlib_write_grd_info (GMT, file, G->header);\n\t}\n\telse /* Fallback to existing header */\n\t\tgmt_M_err_trap (gmt_grd_get_format (GMT, file, G->header, magic));\n\tif (R->open) return (GMT_NOERROR);\t/* Already set the first time */\n\tfmt = GMT->session.grdformat[G->header->type];\n\tif (fmt[0] == 'c') {\t\t/* Open netCDF file, old format */\n\t\tgmt_M_err_trap (gmt_nc_open (GMT, HH->name, cdf_mode[r_w], &R->fid));\n\t\tR->edge[0] = G->header->n_columns;\n\t\tR->start[0] = 0;\n\t\tR->start[1] = 0;\n\t}\n\telse if (fmt[0] == 'n') {\t/* Open netCDF file, COARDS-compliant format */\n\t\tgmt_M_err_trap (gmt_nc_open (GMT, HH->name, cdf_mode[r_w], &R->fid));\n\t\tR->edge[0] = 1;\n\t\tR->edge[1] = G->header->n_columns;\n\t\tR->start[0] = HH->row_order == k_nc_start_north ? 0 : G->header->n_rows-1;\n\t\tR->start[1] = 0;\n\t}\n\telse {\t\t/* Regular binary file with/w.o standard GMT header, or Sun rasterfile */\n\t\tif (r_w == 0) {\t/* Open for plain reading */\n\t\t\tif ((R->fp = gmt_fopen (GMT, HH->name, bin_mode[0])) == NULL)\n\t\t\t\treturn (GMT_GRDIO_OPEN_FAILED);\n\t\t}\n\t\telse if ((R->fp = gmt_fopen (GMT, HH->name, bin_mode[r_w])) == NULL)\n\t\t\treturn (GMT_GRDIO_CREATE_FAILED);\n\t\t/* Seek past the grid header, unless there is none */\n\t\tif (header && fseek (R->fp, (off_t)GMT_GRID_HEADER_SIZE, SEEK_SET)) return (GMT_GRDIO_SEEK_FAILED);\n\t\talloc = (fmt[1] != GMT_GRD_FORMAT);\t/* Only need to allocate the v_row array if grid is not grdfloat */\n#ifdef DEBUG\n\t\tR->pos = ftell (R->fp);\t/* Where we are */\n#endif\n\t}\n\n\tR->size = gmtlib_grd_data_size (GMT, G->header->type, &G->header->nan_value);\n\tR->check = !isnan (G->header->nan_value);\n\tR->open = true;\n\n\tif (fmt[1] == 'm')\t/* Bit mask */\n\t\tR->n_byte = lrint (ceil (G->header->n_columns / 32.0)) * R->size;\n\telse if (fmt[0] == 'r' && fmt[1] == 'b')\t/* Sun Raster uses multiple of 2 bytes */\n\t\tR->n_byte = lrint (ceil (G->header->n_columns / 2.0)) * 2 * R->size;\n\telse\t/* All other */\n\t\tR->n_byte = G->header->n_columns * R->size;\n\n\tif (alloc) R->v_row = gmt_M_memory (GMT, NULL, R->n_byte, char);\n\n\tR->row = 0;\n\tR->auto_advance = (access_mode & GMT_GRID_ROW_BY_ROW_MANUAL) ? false : true;\t/* Read sequentially or random-access rows */\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL void gmtapi_update_txt_item (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, size_t length, char string[]) {\n\t/* Place desired text in string (fixed size array) which can hold up to length bytes */\n\tsize_t lim;\n\tstatic char buffer[GMT_BUFSIZ];\n\tchar *txt = (mode & GMT_COMMENT_IS_OPTION) ? GMT_Create_Cmd (API, arg) : (char *)arg;\n\tgmt_M_memset (buffer, GMT_BUFSIZ, char);\t/* Start with a clean slate */\n\tif ((mode & GMT_COMMENT_IS_OPTION) == 0 && (mode & GMT_COMMENT_IS_RESET) == 0 && string[0])\n\t\tstrncat (buffer, string, length-1);\t/* Use old text if we are not resetting */\n\tlim = length - strlen (buffer) - 1;\t/* Remaining characters that we can use */\n\tif (mode & GMT_COMMENT_IS_OPTION) {\t/* Must start with module name since it is not part of the option args */\n\t\tstrncat (buffer, API->GMT->init.module_name, lim);\n\t\tlim = length - strlen (buffer) - 1;\t/* Remaining characters that we can use */\n\t\tstrncat (buffer, \" \", lim);\n\t}\n\tlim = length - strlen (buffer) - 1;\t/* Remaining characters that we can use */\n\tstrncat (buffer, txt, lim);\t\t/* Append new text */\n\tgmt_M_memset (string, length, char);\t/* Wipe string completely */\n\tstrncpy (string, buffer, length);\t/* Only copy over max length bytes */\n\tif (mode & GMT_COMMENT_IS_OPTION) gmt_M_free (API->GMT, txt);\n}\n\n/*! . */\nGMT_LOCAL void gmtapi_GI_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_GRID_HEADER *H) {\n\t/* Replace or Append either command or remark field with text or command-line options */\n\tif (mode & GMT_COMMENT_IS_REMARK) \tgmtapi_update_txt_item (API, mode, arg, GMT_GRID_REMARK_LEN160,  H->remark);\n\telse if (mode & GMT_COMMENT_IS_COMMAND) gmtapi_update_txt_item (API, mode, arg, GMT_GRID_COMMAND_LEN320, H->command);\n\telse if (mode & GMT_COMMENT_IS_TITLE)   gmtapi_update_txt_item (API, mode, arg, GMT_GRID_TITLE_LEN80,    H->title);\n\telse if (mode & GMT_COMMENT_IS_NAME_X)  gmtapi_update_txt_item (API, mode, arg, GMT_GRID_UNIT_LEN80,     H->x_units);\n\telse if (mode & GMT_COMMENT_IS_NAME_Y)  gmtapi_update_txt_item (API, mode, arg, GMT_GRID_UNIT_LEN80,     H->y_units);\n\telse if (mode & GMT_COMMENT_IS_NAME_Z)  gmtapi_update_txt_item (API, mode, arg, GMT_GRID_UNIT_LEN80,     H->z_units);\n}\n\n/*! Replace or Append either command or remark field with text or command-line options */\nGMT_LOCAL void gmtapi_grid_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_GRID *G) {\n\tgmtapi_GI_comment (API, mode, arg, G->header);\n}\n\nGMT_LOCAL void gmtapi_cube_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_CUBE *U) {\n\tgmtapi_GI_comment (API, mode, arg, U->header);\n}\n\n/*! Update either command or remark field with text or command-line options */\nGMT_LOCAL void gmtapi_image_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_IMAGE *I) {\n\tgmtapi_GI_comment (API, mode, arg, I->header);\n}\n\n/*! Update either command or remark field with text or command-line options */\nGMT_LOCAL void gmtapi_vector_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_VECTOR *V) {\n\tif (mode & GMT_COMMENT_IS_REMARK)  gmtapi_update_txt_item (API, mode, arg, GMT_GRID_REMARK_LEN160,  V->remark);\n\tif (mode & GMT_COMMENT_IS_COMMAND) gmtapi_update_txt_item (API, mode, arg, GMT_GRID_COMMAND_LEN320, V->command);\n}\n\n/*! Update either command or remark field with text or command-line options */\nGMT_LOCAL void gmtapi_matrix_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_MATRIX *M) {\n\tif (mode & GMT_COMMENT_IS_REMARK)  gmtapi_update_txt_item (API, mode, arg, GMT_GRID_REMARK_LEN160,  M->remark);\n\tif (mode & GMT_COMMENT_IS_COMMAND) gmtapi_update_txt_item (API, mode, arg, GMT_GRID_COMMAND_LEN320, M->command);\n}\n\n/*! Update common.h's various text items; return 1 if successful else 0 */\nGMT_LOCAL int gmtapi_add_comment (struct GMTAPI_CTRL *API, unsigned int mode, char *txt) {\n\tunsigned int k = 0;\n\tstruct GMT_COMMON *C = &API->GMT->common;\t/* Short-hand to the common arg structs */\n\n\tif (mode & GMT_COMMENT_IS_TITLE)  { gmt_M_str_free (C->h.title); C->h.title = strdup (txt); k++; }\n\tif (mode & GMT_COMMENT_IS_REMARK) { gmt_M_str_free (C->h.remark); C->h.remark = strdup (txt); k++; }\n\tif (mode & GMT_COMMENT_IS_COLNAMES) { gmt_M_str_free (C->h.colnames); C->h.colnames = strdup (txt); k++; }\n\treturn (k);\t/* 1 if we did any of the three above; 0 otherwise */\n}\n\n/*! Append or replace data table headers with given text or command-line options */\nGMT_LOCAL void gmtapi_dataset_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_DATASET *D) {\n\tunsigned int tbl, k;\n\tstruct GMT_DATATABLE *T = NULL;\n\tchar *txt = gmtlib_create_header_item (API, mode, arg);\n\n\tif (gmtapi_add_comment (API, mode, txt)) return;\t/* Updated one -h item, or nothing */\n\n\tif (D->table == NULL) {\n\t\tGMT_Report (API, GMT_MSG_WARNING, \"gmtapi_dataset_comment: Trying to access an empty D->table object\\n\");\n\t\treturn;\n\t}\n\n\t/* Here we process free-form comments; these go into the dataset's header structures */\n\tfor (tbl = 0; tbl < D->n_tables; tbl++) {\t/* For each table in the dataset */\n\t\tT = D->table[tbl];\t/* Short-hand for this table */\n\t\tif (mode & GMT_COMMENT_IS_RESET) {\t/* Eliminate all existing headers */\n\t\t\tfor (k = 0; k < T->n_headers; k++) gmt_M_str_free (T->header[k]);\n\t\t\tT->n_headers = 0;\n\t\t}\n\t\tT->header = gmt_M_memory (API->GMT, T->header, T->n_headers + 1, char *);\n\t\tT->header[T->n_headers++] = strdup (txt);\n\t}\n}\n\n/*! Append or replace CPT headers with given text or command-line options */\nGMT_LOCAL void gmtapi_cpt_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_PALETTE *P) {\n\tunsigned int k;\n\tchar *txt = gmtlib_create_header_item (API, mode, arg);\n\n\tif (!gmtapi_add_comment (API, mode, txt)) return;\t/* Updated one -h item or nothing */\n\n\t/* Here we process free-form comments; these go into the CPT's header structures */\n\tif (mode & GMT_COMMENT_IS_RESET) {\t/* Eliminate all existing headers */\n\t\tfor (k = 0; k < P->n_headers; k++) gmt_M_str_free (P->header[k]);\n\t\tP->n_headers = 0;\n\t}\n\tP->header = gmt_M_memory (API->GMT, P->header, P->n_headers + 1, char *);\n\tP->header[P->n_headers++] = strdup (txt);\n}\n\n/*! Append or replace Postscript container headers with given text or command-line options */\nGMT_LOCAL void gmtapi_ps_comment (struct GMTAPI_CTRL *API, unsigned int mode, void *arg, struct GMT_POSTSCRIPT *P) {\n\tunsigned int k;\n\tchar *txt = gmtlib_create_header_item (API, mode, arg);\n\n\tif (!gmtapi_add_comment (API, mode, txt)) return;\t/* Updated one -h item or nothing */\n\n\t/* Here we process free-form comments; these go into the CPT's header structures */\n\tif (mode & GMT_COMMENT_IS_RESET) {\t/* Eliminate all existing headers */\n\t\tfor (k = 0; k < P->n_headers; k++) gmt_M_str_free (P->header[k]);\n\t\tP->n_headers = 0;\n\t}\n\tP->header = gmt_M_memory (API->GMT, P->header, P->n_headers + 1, char *);\n\tP->header[P->n_headers++] = strdup (txt);\n}\n\nGMT_LOCAL unsigned int gmtapi_set_method (struct GMTAPI_DATA_OBJECT *S) {\n\t/* Most objects have a one-to-one path but for vectors and matrices\n\t * we need to set the bit that correspond to their type */\n\tunsigned int m;\n\tif (S->method < GMT_IS_DUPLICATE) return S->method;\n\tswitch (S->actual_family) {\n\t\tcase GMT_IS_VECTOR: m = S->method | GMT_VIA_VECTOR; break;\n\t\tcase GMT_IS_MATRIX: m = S->method | GMT_VIA_MATRIX; break;\n\t\tdefault: m = S->method;\n\t}\n\treturn m;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_next_io_source (struct GMTAPI_CTRL *API, unsigned int direction) {\n\t/* Get ready for the next source/destination (open file, initialize counters, etc.).\n\t * Note this is only a mechanism for dataset files where it is common\n\t * to give many files on the command line (e.g., *.txt) and we do rec-by-rec processing.\n\t * Not used by modules who read entire datasets in one go via GMT_{Read|Write}_Data,\n\t * such as grids, images, palettes, postscript, but also datasets and texsets when\n\t * GMT_Read_Data are used.  This section is strictly related to GMT_Get_Record. */\n\n\tint *fd = NULL;\t/* !!! This MUST be int* due to nature of UNIX system function */\n\tunsigned int method, kind, first = 0;\n\tstatic const char *dir[2] = {\"from\", \"to\"};\n\tstatic const char *operation[3] = {\"Reading\", \"Writing\", \"Appending\"};\n\tchar *mode = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_VECTOR *V_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tS_obj = API->object[API->current_item[direction]];\t/* For shorthand purposes only */\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_next_io_source: Selected object %d\\n\", S_obj->ID);\n\tgmt_M_memset (GMT->current.io.curr_pos[direction], 4U, int64_t);\t/* Reset file, seg, point, header counters */\n\tGMT->current.io.data_record_number_in_tbl[direction] = GMT->current.io.data_record_number_in_seg[direction] = 0;\t/* Start at zero for new table */\n\tif (direction == GMT_IN) {\t/* Set reading mode */\n\t\tmode = GMT->current.io.r_mode;\n\t\tGMT->current.io.curr_pos[GMT_IN][GMT_SEG] = -1;\t/* First segment of input is set to -1 until first segment header have been dealt with */\n\t}\n\telse\t/* Set writing mode (but could be changed to append if GMT_IS_FILE and filename starts with >) */\n\t\tmode = GMT->current.io.w_mode;\n\tS_obj->close_file = false;\t/* Do not want to close file pointers passed to us unless WE open them below */\n\t/* Either use binary n_columns settings or initialize to unknown if ascii input, i.e., GMT_MAX_COLUMNS */\n\tS_obj->n_expected_fields = (GMT->common.b.ncol[direction]) ? GMT->common.b.ncol[direction] : GMT_MAX_COLUMNS;\n\n\tmethod = gmtapi_set_method (S_obj);\t/* Get the actual method to use since may be MATRIX or VECTOR masquerading as DATASET */\n\tswitch (method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\t/* Filename given; we must open the file here */\n\t\t\tassert (S_obj->filename != NULL);\n\t\t\tif (S_obj->family == GMT_IS_GRID || S_obj->family == GMT_IS_IMAGE) return (gmtlib_report_error (API, GMT_NOT_A_VALID_FAMILY));\t/* Grids or images not allowed here */\n\t\t\tif (direction == GMT_IN) {\n\t\t\t\tfirst = gmt_download_file_if_not_found (API->GMT, S_obj->filename, 0);\t/* Deal with downloadable GMT data sets first */\n\t\t\t}\n\t\t\tif (direction == GMT_OUT && S_obj->filename[0] == '>') {\n\t\t\t\tmode = GMT->current.io.a_mode;\t/* Must append to an existing file (we have already checked the file exists) */\n\t\t\t\tfirst = 1;\n\t\t\t}\n\t\t\tif ((S_obj->fp = gmt_fopen (GMT, &(S_obj->filename[first]), mode)) == NULL) {\t/* Trouble opening file */\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to open file %s for %s\\n\", &(S_obj->filename[first]), GMT_direction[direction]);\n\t\t\t\treturn (GMT_ERROR_ON_FOPEN);\n\t\t\t}\n\t\t\tS_obj->close_file = true;\t/* We do want to close files we are opening, but later */\n\t\t\tstrncpy (GMT->current.io.filename[direction], &(S_obj->filename[first]), PATH_MAX-1);\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"%s %s %s file %s\\n\",\n\t\t\t\toperation[direction+first], GMT_family[S_obj->family], dir[direction], &(S_obj->filename[first]));\n\t\t\tif (gmt_M_binary_header (GMT, direction)) {\n\t\t\t\tgmtlib_io_binary_header (GMT, S_obj->fp, direction);\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"%s %d bytes of header %s binary file %s\\n\",\n\t\t\t\t\toperation[direction], GMT->current.setting.io_n_header_items, dir[direction], &(S_obj->filename[first]));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GMT_IS_STREAM:\t/* Given a stream; no need to open (or close) anything */\n#ifdef SET_IO_MODE\n\t\t\tif (S_obj->family == GMT_IS_DATASET && S_obj->fp == GMT->session.std[direction])\n\t\t\t\tgmt_setmode (GMT, (int)direction);\t/* Windows may need to have its read mode changed from text to binary */\n#endif\n\t\t\tkind = (S_obj->fp == GMT->session.std[direction]) ? 0 : 1;\t/* For message only: 0 if stdin/out, 1 otherwise for user pointer */\n\t\t\tsnprintf (GMT->current.io.filename[direction], PATH_MAX-1, \"<%s %s>\", GMT_stream[kind], GMT_direction[direction]);\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"%s %s %s %s %s stream\\n\",\n\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction], GMT_stream[kind], GMT_direction[direction]);\n\t\t\tif (gmt_M_binary_header (GMT, direction)) {\n\t\t\t\tgmtlib_io_binary_header (GMT, S_obj->fp, direction);\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"%s %d bytes of header %s binary %s stream\\n\",\n\t\t\t\t\toperation[direction], GMT->current.setting.io_n_header_items, dir[direction], GMT_stream[kind]);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GMT_IS_FDESC:\t/* Given a pointer to a file handle; otherwise same as stream */\n\t\t\tfd = (int *)S_obj->fp;\t/* Extract the file handle integer */\n\t\t\tif ((S_obj->fp = fdopen (*fd, mode)) == NULL) {\t/* Reopen handle as stream */\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to open file descriptor %d for %s\\n\", *fd, GMT_direction[direction]);\n\t\t\t\treturn (GMT_ERROR_ON_FDOPEN);\n\t\t\t}\n\t\t\tS_obj->method = S_obj->method - GMT_IS_FDESC + GMT_IS_STREAM;\t/* Since fp now holds stream pointer an we have lost the handle */\n\t\t\tkind = (S_obj->fp == GMT->session.std[direction]) ? 0 : 1;\t/* For message only: 0 if stdin/out, 1 otherwise for user pointer */\n\t\t\tsnprintf (GMT->current.io.filename[direction], PATH_MAX-1, \"<%s %s>\", GMT_stream[kind], GMT_direction[direction]);\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"%s %s %s %s %s stream via supplied file descriptor\\n\",\n\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction], GMT_stream[kind], GMT_direction[direction]);\n\t\t\tif (gmt_M_binary_header (GMT, direction)) {\n\t\t\t\tgmtlib_io_binary_header (GMT, S_obj->fp, direction);\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"%s %d bytes of header %s binary %s stream via supplied file descriptor\\n\",\n\t\t\t\t\toperation[direction], GMT->current.setting.io_n_header_items, dir[direction], GMT_stream[kind]);\n\t\t\t}\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* Copy, nothing to do [PW: not tested] */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"%s %s %s memory copy supplied by pointer\\n\",\n\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction]);\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE:\t/* Reference, nothing to do [PW: not tested] */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"%s %s %s memory reference supplied by pointer\\n\",\n\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction]);\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* These 2 mean reading or writing a dataset record-by-record via a user matrix */\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\n\t\t\tif (!(S_obj->family == GMT_IS_DATASET)) return (gmtlib_report_error (API, GMT_NOT_A_VALID_FAMILY));\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"%s %s %s %s memory location via matrix\\n\",\n\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction], GMT_direction[direction]);\n\t\t\tif (direction == GMT_IN) {\t/* Hard-wired limits are passed in from calling program; for output we have nothing yet */\n\t\t\t\tif ((M_obj = S_obj->resource) == NULL) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMTAPI: Internal error: gmtapi_next_io_source got a matrix pointer that is NULL!!!\\n\");\n\t\t\t\t\treturn GMT_NOERROR;\n\t\t\t\t}\n\t\t\t\tS_obj->n_rows    = M_obj->n_rows;\n\t\t\t\tS_obj->n_columns = M_obj->n_columns;\n\t\t\t\tS_obj->rec = 0;\t/* Start of this \"file\" */\n\t\t\t\tGMT->common.b.ncol[direction] = M_obj->n_columns;\t/* Basically doing binary i/o with specified number of columns */\n\t\t\t}\n\t\t\tGMT->common.b.active[direction] = true;\t/* Basically, we are doing what GMT calls binary i/o since it is all in memory */\n\t\t\tstrcpy (GMT->current.io.filename[direction], \"<matrix memory>\");\n\t\t\tbreak;\n\n\t\t case GMT_IS_DUPLICATE|GMT_VIA_VECTOR:\t/* These 2 mean reading or writing a dataset record-by-record via user vector arrays */\n\t\t case GMT_IS_REFERENCE|GMT_VIA_VECTOR:\n\t\t\tif (S_obj->family != GMT_IS_DATASET) return (gmtlib_report_error (API, GMT_NOT_A_VALID_FAMILY));\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"%s %s %s %s memory location via vector\\n\",\n\t\t\t\t\toperation[direction], GMT_family[S_obj->family], dir[direction], GMT_direction[direction]);\n\t\t\tif (direction == GMT_IN) {\t/* Hard-wired limits are passed in from calling program; for output we have nothing yet */\n\t\t\t\tif ((V_obj = S_obj->resource) == NULL) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMTAPI: Internal error: gmtapi_next_io_source got a vector pointer that is NULL!!!\\n\");\n\t\t\t\t\treturn GMT_NOERROR;\n\t\t\t\t}\n\t\t\t\tS_obj->n_rows    = V_obj->n_rows;\n\t\t\t\tS_obj->n_columns = V_obj->n_columns;\n\t\t\t\tS_obj->rec = 0;\t/* Start of this \"file\" */\n\t\t\t\tGMT->common.b.ncol[direction] = V_obj->n_columns;\t/* Basically doing binary i/o with specified number of columns */\n\t\t\t}\n\t\t\tGMT->common.b.active[direction] = true;\t/* Basically, we are doing what GMT calls binary i/o */\n\t\t\tstrcpy (GMT->current.io.filename[direction], \"<vector memory>\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMTAPI: Internal error: gmtapi_next_io_source called with illegal method\\n\");\n\t\t\tbreak;\n\t}\n\n\t/* A few things pertaining only to data/text tables */\n\tGMT->current.io.rec_in_tbl_no = 0;\t/* Start on new table */\n\tif (direction == GMT_IN) API->current_get_obj = S_obj;\n\tif (S_obj->geometry == GMT_IS_TEXT) {\t/* Reading pure text, no coordinates */\n\t\tS_obj->import = &gmtlib_ascii_textinput;\n\t\tGMT->current.io.record.data = NULL;\t/* Since there isn't any data */\n\t}\n\telse\n\t\tS_obj->import = GMT->current.io.input;\t/* import may point to ASCII or binary (if -b) input functions */\n\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_next_data_object (struct GMTAPI_CTRL *API, enum GMT_enum_family family, enum GMT_enum_std direction) {\n\t/* Sets up current_item to be the next unused item of the required direction; or return EOF.\n\t * When EOF is returned, API->current_item[direction] holds the last object ID used. */\n\tbool found = false;\n\tint item = API->current_item[direction] + 1;\t/* Advance to next item, if it exists */\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\twhile (item < (int)API->n_objects && !found) {\n\t\tS_obj = API->object[item];\t/* Current object in list */\n\t\tif (S_obj && S_obj->selected && S_obj->status == GMT_IS_UNUSED && S_obj->direction == direction && S_obj->family == family)\n\t\t\tfound = true;\t/* Got item that is selected and unused, has correct direction and family */\n\t\telse\n\t\t\titem++;\t/* No, keep looking */\n\t}\n\tif (found) {\t/* Update to use next item */\n\t\tAPI->current_item[direction] = item;\t/* The next item */\n\t\treturn (gmtapi_next_io_source (API, direction));\t/* Initialize the next source/destination */\n\t}\n\telse\n\t\treturn (EOF);\t/* No more objects available for this direction; return EOF */\n}\n\n/*! Hook object to end of linked list and assign unique id (> 0) which is returned */\nGMT_LOCAL int gmtapi_add_data_object (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *object) {\n\t/* Find the first entry in the API->object array which is unoccupied, and if\n\t * they are all occupied then reallocate the array to make more space.\n\t * We thus find and return the lowest available ID. */\n\tAPI->error = GMT_NOERROR;\n\tAPI->n_objects++;\t\t/* Must add one more entry to the tally */\n\tif (API->n_objects == API->n_objects_alloc) {\t/* Must allocate more space to hold all data descriptors */\n\t\tsize_t old_n_alloc = API->n_objects_alloc;\n\t\tAPI->n_objects_alloc <<= 1;\t/* Double it */\n\t\tAPI->object = gmt_M_memory (API->GMT, API->object, API->n_objects_alloc, struct GMTAPI_DATA_OBJECT *);\n\t\tif (!(API->object)) {\t\t/* Failed to allocate more memory */\n\t\t\tAPI->n_objects--;\t/* Undo our premature increment */\n\t\t\treturn_value (API, GMT_MEMORY_ERROR, GMT_NOTSET);\n\t\t}\n\t\telse\t/* Set new ones to NULL */\n\t\t\tgmt_M_memset (&(API->object[old_n_alloc]), API->n_objects_alloc - old_n_alloc, struct GMTAPI_DATA_OBJECT *);\n\t}\n\tobject->ID = API->unique_ID++;\t/* Assign a unique object ID */\n\tAPI->object[API->n_objects-1] = object;\t\t/* Hook the current object onto the end of the list */\n\n\treturn (object->ID);\n}\n\n/*! Sanity check that geometry and family are compatible; note they may not be set (GMT_NOTSET) hence the use of signed ints */\nGMT_LOCAL bool gmtapi_validate_geometry (struct GMTAPI_CTRL *API, int family, int geometry) {\n\tbool problem = false;\n\tgmt_M_unused(API);\n\tif (geometry == GMT_NOTSET || family == GMT_NOTSET) return false;\t/* No errors if nothing to check yet */\n\tswitch (family) {\n\t\tcase GMT_IS_DATASET:     if (!(geometry == GMT_IS_NONE || geometry == GMT_IS_TEXT || (geometry & GMT_IS_PLP))) problem = true; break;\t/* Datasets can hold many things... */\n\t\tcase GMT_IS_GRID:        if (geometry != GMT_IS_SURFACE) problem = true;    break;\t/* Only surface is valid */\n\t\tcase GMT_IS_IMAGE:       if (geometry != GMT_IS_SURFACE) problem = true;    break;\t/* Only surface is valid */\n\t\tcase GMT_IS_PALETTE:     if (geometry != GMT_IS_NONE) problem = true;       break;\t/* Only text is valid */\n\t\tcase GMT_IS_POSTSCRIPT:  if (geometry != GMT_IS_NONE) problem = true;       break;\t/* Only text is valid */\n\t\tcase GMT_IS_CUBE:    if (geometry != GMT_IS_VOLUME) problem = true;     break;\t/* Only volume is valid */\n\t\tcase GMT_IS_VECTOR:      if ((geometry & GMT_IS_PLP) == 0) problem = true;  break; \t/* Must be one of those three */\n\t\tcase GMT_IS_MATRIX:      if (geometry == GMT_IS_NONE) problem = true;       break;\t/* Matrix can hold surfaces or DATASETs */\n\t\tcase GMT_IS_COORD:       if (geometry != GMT_IS_NONE) problem = true;       break;\t/* Only text is valid */\n\t}\n\treturn (problem);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_decode_id (const char *filename) {\n\t/* Checking if filename contains a name with embedded GMTAPI Object ID.\n\t * If found we return the ID, otherwise we return GMT_NOTSET.\n \t*/\n\tint object_ID = GMT_NOTSET;\n\n\tif (gmt_M_file_is_memory (filename)) {\t/* Passing ID of a registered object */\n\t\tif (sscanf (&filename[GMTAPI_OBJECT_ID_START], \"%d\", &object_ID) != 1) return (GMT_NOTSET);\t/* Get the object ID unless we fail scanning */\n\t}\n\treturn (object_ID);\t/* Returns GMT_NOTSET if no embedded ID was found */\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_get_object (struct GMTAPI_CTRL *API, int sfamily, void *ptr) {\n\t/* Returns the ID of the first object whose resource pointer matches ptr.\n\t * Unless family is GMT_NOTSET the object must be of the specified family.\n\t */\n\tunsigned int item;\n\tenum GMT_enum_family family = GMT_NOTSET;\n\tint object_ID = GMT_NOTSET;\t/* Not found yet */\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tif (sfamily != GMT_NOTSET) family = sfamily;\n\tfor (item = 0; object_ID == GMT_NOTSET && item < API->n_objects; item++) {\t/* Loop over all objects */\n\t\tif ((S_obj = API->object[item]) == NULL) continue;\t/* Skip freed objects */\n\t\tif (S_obj->resource == NULL) continue;\t/* No resource pointer */\n\t\tif (sfamily != GMT_NOTSET && S_obj->family != family) continue;\t/* Not the right family */\n\t\tif (S_obj->resource == ptr && object_ID == GMT_NOTSET) object_ID = S_obj->ID;\t/* Found a matching data pointer */\n\t}\n\treturn (object_ID);\t/* Return ID or GMT_NOTSET if not found */\n}\n\n/*! . */\nGMT_LOCAL void * gmtapi_pass_object (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *object, unsigned int family, unsigned int mode, double *wesn) {\n\t/* Passes back the input object pointer after possibly performing some minor adjustments to metadata.\n\t * For grids and images we must worry about possible subset requests */\n\tvoid *data = object->resource;\n\tstruct GMT_GRID    *G = NULL;\n\tstruct GMT_IMAGE   *I = NULL;\n\tstruct GMT_DATASET *D = NULL;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = NULL;\n\n\tif (object->resource == NULL)\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"gmtapi_pass_object given a NULL resource!\\n\");\n\n\tswitch (family) {\t/* Do family-specific prepping before passing back the input object */\n\t\tcase GMT_IS_PALETTE:\t/* Make sure the hidden support arrays etc. have been initialized as external interfaces may not care */\n\t\t\tif (data) gmtlib_init_cpt (API->GMT, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_GRID:\t/* Grids need to update the grdtype setting, possibly rotate geographic grids, and maybe deal with subsets */\n\t\t\tG = gmtapi_get_grid_data (data);\t/* Get the right grid pointer */\n\t\t\tHH = gmt_get_H_hidden (G->header);\n\t\t\tgmtlib_grd_get_units (API->GMT, G->header);\t/* Set the unit names */\n\t\t\tHH->grdtype = gmtlib_get_grdtype (API->GMT, GMT_IN, G->header);\n\t\t\tif (wesn && G->data) {\t/* Subset or global rotation was requested */\n\t\t\t\tif (gmt_grd_is_global (API->GMT, G->header)) {\t/* May have to rotate a geographic grid since we are not reading from file this time */\n\t\t\t\t\tdouble shift_amount = wesn[XLO] - G->header->wesn[XLO];\n\t\t\t\t\tif (fabs (shift_amount) >= G->header->inc[GMT_X]) {\t/* Must do it */\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Shifting longitudes in grid by %g degrees to fit -R\\n\", shift_amount);\n\t\t\t\t\t\tgmt_grd_shift (API->GMT, G, shift_amount);\t/* In-memory rotation */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (object->region) {\t/* Possibly adjust the pad so inner region matches requested wesn */\n\t\t\t\t\t/* NOTE: This assumes the memory cannot be adjusted. Probably should distinaguish between GMT_IS_REFERENCE and GMT_IS_DUPLICATE\n\t\t\t\t\t * and offer different behavior.  As it is we assume read-only grids */\n\t\t\t\t\tif (object->reset_pad) {\t/* First undo any prior sub-region used with this memory grid */\n\t\t\t\t\t\tgmtlib_contract_headerpad (API->GMT, G->header, object->orig_pad, object->orig_wesn);\n\t\t\t\t\t\tobject->reset_pad = HH->reset_pad = 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Then apply the new pad adjustment.  Basically we cannot mess with the data so we change what constitute the pad */\n\t\t\t\t\tif (gmtlib_expand_headerpad (API->GMT, G->header, object->wesn, object->orig_pad, object->orig_wesn))\n\t\t\t\t\t\tobject->reset_pad = HH->reset_pad = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* No grid yet */\n\t\t\tgmt_BC_init (API->GMT, G->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (API->GMT, gmt_grd_BC_set (API->GMT, G, GMT_IN), \"Grid memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Failed to set boundary conditions */\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* Images need to update the grdtype setting, possibly rotate geographic grids, and maybe deal with subsets */\n\t\t\tI = gmtapi_get_image_data (data);\t/* Get the right image pointer */\n\t\t\tHH = gmt_get_H_hidden (I->header);\n\t\t\tgmtlib_grd_get_units (API->GMT, I->header);\t/* Set the unit names */\n\t\t\tHH->grdtype = gmtlib_get_grdtype (API->GMT, GMT_IN, I->header);\n\t\t\tif (wesn && I->data) {\t/* Subset or global rotation was requested */\n\t\t\t\tif (gmt_grd_is_global (API->GMT, I->header)) {\t/* May have to rotate geographic grid since we are not reading from file here */\n\t\t\t\t\tdouble shift_amount = wesn[XLO] - I->header->wesn[XLO];\n\t\t\t\t\tif (fabs (shift_amount) >= I->header->inc[GMT_X]) {\t/* Must do it */\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Longitudinal roll for images not implemented yet\\n\");\n#if 0\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Shifting longitudes in grid by %g degrees to fit -R\\n\", shift_amount);\n\t\t\t\t\t\tgmt_grd_shift (API->GMT, I, shift_amount);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (object->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\t\t/* NOTE: This assumes the memory cannot be adjusted. Probably should distinaguish between GMT_IS_REFERENCE and GMT_IS_DUPLICATE\n\t\t\t\t\t * and offer different behavior.  As it is we assume read-only images */\n\t\t\t\t\tif (object->reset_pad) {\t/* First undo a prior sub-region used with this memory grid */\n\t\t\t\t\t\tgmtlib_contract_headerpad (API->GMT, I->header, object->orig_pad, object->orig_wesn);\n\t\t\t\t\t\tobject->reset_pad = HH->reset_pad = 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Then apply the new pad adjustment.  Basically we cannot mess with the data so we change what constitute the pad */\n\t\t\t\t\tif (gmtlib_expand_headerpad (API->GMT, I->header, object->wesn, object->orig_pad, object->orig_wesn))\n\t\t\t\t\t\tobject->reset_pad = HH->reset_pad = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* No image yet */\n\t\t\tgmt_BC_init (API->GMT, I->header);\t/* Initialize image interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (API->GMT, gmtlib_image_BC_set (API->GMT, I), \"Image memory\"))\n\t\t\t\treturn_null (API, GMT_IMAGE_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* Just make sure the min/max values are updated for tables and dataset  */\n\t\t \tD = gmtapi_get_dataset_data (data);\t/* Get the right dataset pointer */\n\t\t\tgmt_set_dataset_minmax (API->GMT, D);\t/* Set the min/max values for the entire dataset */\n\t\t\tbreak;\n\t\tdefault:\t/* Nothing yet for other types */\n\t\t\tbreak;\n\t}\n\treturn (data);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_get_object_id_from_data_ptr (struct GMTAPI_CTRL *API, void *ptr) {\n\t/* Returns the ID of the first object whose data pointer matches *ptr.\n \t * This is necessary since many objects may have the same pointer\n\t * but we only want to destroy the memory once.  This function is\n\t * only used in GMT_Destroy_Data and gmt_is_an_object.\n\t */\n\tunsigned int item;\n\tint object_ID = GMT_NOTSET;\t/* Not found yet */\n\tvoid *data = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tfor (item = 0; object_ID == GMT_NOTSET && item < API->n_objects; item++) {\t/* Loop over all objects */\n\t\tif ((S_obj = API->object[item]) == NULL) continue;\t/* Skip freed objects */\n\t\tdata = gmtapi_return_address (ptr, S_obj->family);\t/* Get void* pointer to resource of this family */\n\t\t/* Try to look for either data or resource pointers since Open_VirtualFile shuffles these two and Destroy needs to find them even if the\n\t\t * function level test will tell it not to free anything */\n\t\tif (object_ID == GMT_NOTSET && S_obj->resource == data) object_ID = S_obj->ID;\t/* Found a matching data pointer */\n\t}\n\treturn (object_ID);\t/* Return ID or GMT_NOTSET if not found */\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_destroy_grid (struct GMTAPI_CTRL *API, struct GMT_GRID **G_obj) {\n\t/* Delete the given grid resource. */\n\tstruct GMT_GRID_HIDDEN *GH = NULL;\n\tif (!(*G_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_destroy_grid: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tGH = gmt_get_G_hidden (*G_obj);\n\tif (GH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmt_free_grid (API->GMT, G_obj, true);\n\treturn GMT_NOERROR;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_destroy_cube (struct GMTAPI_CTRL *API, struct GMT_CUBE **U_obj) {\n\t/* Delete the given grid resource. */\n\tstruct GMT_CUBE_HIDDEN *UH = NULL;\n\tif (!(*U_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_destroy_cube: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tUH = gmt_get_U_hidden (*U_obj);\n\tif (UH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmtlib_free_cube (API->GMT, U_obj, true);\n\treturn GMT_NOERROR;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_destroy_dataset (struct GMTAPI_CTRL *API, struct GMT_DATASET **D_obj) {\n\t/* Delete the given dataset resource. */\n\tstruct GMT_DATASET_HIDDEN *DH = NULL;\n\n\tif (!(*D_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_destroy_dataset: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tDH = gmt_get_DD_hidden (*D_obj);\n\n\tif (DH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmt_free_dataset (API->GMT, D_obj);\n\treturn GMT_NOERROR;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_destroy_palette (struct GMTAPI_CTRL *API, struct GMT_PALETTE **P_obj) {\n\t/* Delete the given CPT resource. */\n\tstruct GMT_PALETTE_HIDDEN *PH = NULL;\n\n\tif (!(*P_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_destroy_palette: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tPH = gmt_get_C_hidden (*P_obj);\n\tif (PH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmtlib_free_palette (API->GMT, P_obj);\n\treturn GMT_NOERROR;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_destroy_postscript (struct GMTAPI_CTRL *API, struct GMT_POSTSCRIPT **P_obj) {\n\t/* Delete the given GMT_POSTSCRIPT resource. */\n\tstruct GMT_POSTSCRIPT_HIDDEN *PH = NULL;\n\tif (!(*P_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_destroy_postscript: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tPH = gmt_get_P_hidden (*P_obj);\n\tif (PH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmtlib_free_ps (API->GMT, P_obj);\n\treturn GMT_NOERROR;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_destroy_matrix (struct GMTAPI_CTRL *API, struct GMT_MATRIX **M_obj) {\n\t/* Delete the given Matrix resource. */\n\tstruct GMT_MATRIX_HIDDEN *MH = NULL;\n\tif (!(*M_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_destroy_matrix: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tMH = gmt_get_M_hidden (*M_obj);\n\tif (MH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmtlib_free_matrix (API->GMT, M_obj, true);\n\treturn GMT_NOERROR;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_destroy_vector (struct GMTAPI_CTRL *API, struct GMT_VECTOR **V_obj) {\n\t/* Delete the given Matrix resource. */\n\tstruct GMT_VECTOR_HIDDEN *VH = NULL;\n\tif (!(*V_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_destroy_vector: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tVH = gmt_get_V_hidden (*V_obj);\n\tif (VH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmt_free_vector (API->GMT, V_obj, true);\n\treturn GMT_NOERROR;\n}\n\n/*! . */\nbool gmt_is_an_object (struct GMT_CTRL *GMT, void *ptr) {\n\t/* Needed by g*math.c so exported as part of the gmt_dev library */\n\treturn (gmtapi_get_object_id_from_data_ptr (GMT->parent, ptr) == GMT_NOTSET) ? false : true;\n}\n\n/*! Determine if resource is a filename that has already been registered */\n#if 0\nGMT_LOCAL int gmtapi_memory_registered (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int direction, void *resource) {\n\tint object_ID = 0, item;\n\tunsigned int module_input = (family & GMT_VIA_MODULE_INPUT);\t/* Are we dealing with a resource that is a module input? */\n\tfamily -= module_input;\n\n\tif (family == GMT_IS_COORD) return (GMT_NOTSET);\t/* Coordinate arrays cannot be a registered memory resource */\n\tif ((object_ID = gmtapi_decode_id (resource)) == GMT_NOTSET) return (GMT_NOTSET);\t/* Not a registered resource */\n\tif ((item = gmtlib_validate_id (API, family, object_ID, direction, GMT_NOTSET)) == GMT_NOTSET) return (GMT_NOTSET);\t/* Not the right attributes */\n\tif (module_input && direction == GMT_IN) API->object[item]->module_input = true;\t/* Flag this object as a module input resource */\n\treturn (object_ID);\t/* resource is a registered and valid item */\n}\n#endif\n\n/*! Determine if resource is a filename that has already been registered */\nGMT_LOCAL int gmtapi_memory_registered (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int direction, char *filename) {\n\tchar SP, D, F, A, G, M;\n\tint k, object_ID;\n\tgmt_M_unused(family);\n\tif (!gmt_M_file_is_memory (filename)) return GMT_NOTSET;\t/* If not a memory reference then there is no ID etc */\n\t/* Name template: @GMTAPI@-S-D-F-A-G-M-###### where # is the 6-digit integer object code.\n\t * S stands for P(rimary) or S(econdary) input or output object (command line is primary, files via options are secondary).\n\t * D stands for Direction and is either I(n) or O(ut).\n\t * F stands for Family and is one of D(ataset), G(rid), I(mage), C(PT), X(PostScript), M(atrix), V(ector), U(ndefined).\n\t * A stands for Actual Family and is one of D, G, I, C, X, M, V, and U as well.\n\t *   Actual family may differ from family if a Dataset is actually passed as a Matrix, for instance.\n\t * G stands for Geometry and is one of (poin)T, L(ine), P(olygon), C(Line|Polygon), A(POint|Line|Polygon), G(rid), N(one), X(text), or U(ndefined).\n\t * M stands for Messenger and is either Y(es) or N(o).\n\t * Limitation:  object_ID must be <= GMTAPI_MAX_ID */\n\n\tSP = D = F = A = G = M = 0;\t/* Initialize */\n\tif ((k = sscanf (&filename[GMTAPI_PREFIX_LEN], \"%c-%c-%c-%c-%c-%c-%d\", &SP, &D, &F, &A, &G, &M, &object_ID)) != 7) {\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_memory_registered: Failed to decode memory name [%s], only %d conversions were successful.\\n\", filename, k);\n\t\treturn (GMT_NOTSET);\t/* Get the object ID unless we fail scanning */\n\t}\n\tif (direction == GMT_IN && D != 'I') return GMT_NOTSET;\t/* Not the right direction */\n\treturn object_ID;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_is_registered (struct GMTAPI_CTRL *API, int family, int geometry, int direction, unsigned int mode, char *filename, void *resource) {\n\t/* Checks to see if the given data pointer has already been registered.\n \t * This can happen for grids which first gets registered reading the header\n \t * and then is registered again when reading the whole grid.  In those cases\n\t * we don't want to register them twice.\n\t */\n\tunsigned int i;\n\tint item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tif (API->n_objects == 0) return (GMT_NOTSET);\t/* There are no known resources yet */\n\n\tif ((item = gmtapi_memory_registered (API, family, direction, filename)) != GMT_NOTSET)\n\t\treturn (item);\t/* OK, return the object ID */\n\n\t /* Search for the object in the active list.  However, if object_ID == GMT_NOTSET we instead pick the first in that direction */\n\n\tfor (i = 0, item = GMT_NOTSET; item == GMT_NOTSET && i < API->n_objects; i++) {\n\t\tif (!(S_obj = API->object[i])) continue;\t/* Skip empty objects */\n\t\tif (S_obj->status != GMT_IS_UNUSED) {\t/* Has already been read - do we wish to reset this status ? */\n\t\t\tif (family == GMT_IS_GRID && (mode & GMT_DATA_ONLY)) {\t/* Requesting data only means we already did the header so OK to reset status */\n\t\t\t\tif (mode & GMT_GRID_IS_COMPLEX_MASK) {\t/* Complex grids are read in stages so handled separately */\n\t\t\t\t\t/* Check if complex grid already has one layer and that we are reading the next layer */\n\t\t\t\t\tstruct GMT_GRID *G = gmtapi_get_grid_data (resource);\t/* Get pointer to this grid */\n\t\t\t\t\tunsigned int cmplx = mode & GMT_GRID_IS_COMPLEX_MASK;\n\t\t\t\t\tif (G->header->complex_mode & GMT_GRID_IS_COMPLEX_MASK && G->header->complex_mode != cmplx && filename) {\n\t\t\t\t\t\t/* Apparently so, either had real and now getting imag, or vice versa. */\n\t\t\t\t\t\tgmt_M_str_free (S_obj->filename);\t/* Free previous grid name and replace with current name */\n\t\t\t\t\t\tS_obj->filename = strdup (filename);\n\t\t\t\t\t\tmode |= GMT_IO_RESET;\t/* Reset so we may read in the 2nd component grid */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\t/* Just read the header earlier, do the reset */\n\t\t\t\t\tmode |= GMT_IO_RESET;\t/* Reset so we may read in the grid data */\n\t\t\t}\n\t\t\telse if (family == GMT_IS_IMAGE && (mode & GMT_DATA_ONLY))\t/* Requesting data only means we already did the header so OK to reset status */\n\t\t\t\tmode |= GMT_IO_RESET;\t/* Reset so we may read in the image data */\n\n\t\t\tif (!(mode & GMT_IO_RESET)) continue;\t/* No reset above so we refuse to do the work */\n\t\t\tS_obj->status = GMT_IS_UNUSED;\t/* Reset so we may continue to read it */\n\t\t}\n\t\tif (direction != GMT_NOTSET && (int)S_obj->direction != direction) continue;\t/* Wrong direction */\n\t\tif (family != GMT_NOTSET && (int)S_obj->family != family) continue;\t\t\t/* Wrong family */\n\t\tif (geometry != GMT_NOTSET && (int)S_obj->geometry != geometry) continue;\t/* Wrong geometry */\n\t\tif (resource && S_obj->resource == resource) item = S_obj->ID;\t/* Yes: already registered. */\n\t}\n\treturn (item);\t\t/* The ID of the object (or GMT_NOTSET) */\n}\n\n/*! . */\nGMT_LOCAL struct GMT_PALETTE * gmtapi_import_palette (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in a CPT palette table.\n \t * The mode controls how the back-, fore-, NaN-color entries are handled.\n\t * Note: Memory is allocated to hold the GMT_PALETTE structure except for method GMT_IS_REFERENCE.\n\t */\n\n\tint item;\n\tunsigned int flag = 0, kind;\n\tchar tmp_cptfile[GMT_LEN64] = {\"\"};\n\tstruct GMT_PALETTE *P_obj = NULL, *P_orig = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_palette: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return_null (API, GMT_NO_INPUT);\t/* Need to know the ID to do anything */\n\tif ((item = gmtlib_validate_id (API, GMT_IS_PALETTE, object_ID, GMT_IN, GMTAPI_OPTION_INPUT)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\t/* Failed basic sanity check */\n\n\tS_obj = API->object[item];\t/* Use S_obj as shorthand */\n\tif (S_obj->status != GMT_IS_UNUSED) { /* Already read this resource before; are we allowed to re-read? */\n\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC)\n\t\t\treturn_null (API, GMT_READ_ONCE); /* Not allowed to re-read streams since they are gone */\n\t\tif (!(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t}\n\n\t/* OK, passed sanity and is allowed to read */\n\n\tswitch (S_obj->method) {\t/* From where are we getting the palette ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtlib_read_cpt will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading CPT from %s %s\\n\", gmtapi_method (S_obj->method), S_obj->filename);\n\t\t\tsnprintf (tmp_cptfile, GMT_LEN64, \"gmtapi_colors2cpt_%d.cpt\", (int)getpid());\n\t\t\tif (!strcmp (tmp_cptfile, S_obj->filename))\t/* This file was created when we gave \"name\" as red,blue,... instead */\n\t\t\t \tflag = GMT_CPT_TEMPORARY;\t/* So we can take action later when we learn if user wanted a discrete or continuous CPT */\n\t\t\tif ((P_obj = gmtlib_read_cpt (GMT, S_obj->filename, S_obj->method, mode|flag)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tif (flag == GMT_CPT_TEMPORARY) {\t/* Remove the temporary file */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Remove temporary CPT %s\\n\", S_obj->filename);\n\t\t\t\tremove (tmp_cptfile);\n\t\t\t}\n\t\t\tS_obj->resource = P_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_STREAM:\n \t\t\t/* gmtlib_read_cpt will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;\t/* 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading CPT from %s %s stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((P_obj = gmtlib_read_cpt (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tS_obj->resource = P_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_read_cpt will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_IN) ? 0 : 1;\t/* 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading CPT from %s %s stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((P_obj = gmtlib_read_cpt (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tS_obj->resource = P_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input CPT palette */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating CPT from GMT_PALETTE memory location\\n\");\n\t\t\tif ((P_orig = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif ((P_obj = GMT_Duplicate_Data (API, GMT_IS_PALETTE, mode, P_orig)) == NULL)\n\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so nothing is allocated */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing CPT from GMT_PALETTE memory location\\n\");\n\t\t\tif ((P_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tgmtlib_init_cpt (GMT, P_obj);\t/* Make sure derived quantities are set */\n\t\t\tbreak;\n\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to import GMT_PALETTE\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\n\treturn (P_obj);\t/* Pass back the palette */\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_export_palette (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_PALETTE *P_obj) {\n\t/* Does the actual work of writing out the specified CPT to a destination.\n\t * The mode controls how the back, for, NaN color entries are handled.\n\t */\n\tint item, error;\n\tunsigned int kind;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_PALETTE *P_copy = NULL;\n\tstruct GMT_PALETTE_HIDDEN *PH = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_export_palette: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtlib_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtlib_validate_id (API, GMT_IS_PALETTE, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtlib_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* This is the API object for the output destination */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET)) {\t/* Only allow writing of a data set once, unless we override by resetting the mode */\n\t\treturn (gmtlib_report_error (API, GMT_WRITTEN_ONCE));\n\t}\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\n\t/* Passed sanity and allowed to write */\n\n\t/* If need to assign non-default BFN do it now sow external interfaces can access that too */\n\tif (mode & GMT_CPT_EXTEND_BNF) {\t/* Use low and high colors as back and foreground */\n\t\tgmt_M_rgb_copy (P_obj->bfn[GMT_BGD].rgb, P_obj->data[0].rgb_low);\n\t\tgmt_M_rgb_copy (P_obj->bfn[GMT_FGD].rgb, P_obj->data[P_obj->n_colors-1].rgb_high);\n\t\tgmt_M_rgb_copy (P_obj->bfn[GMT_BGD].hsv, P_obj->data[0].hsv_low);\n\t\tgmt_M_rgb_copy (P_obj->bfn[GMT_FGD].hsv, P_obj->data[P_obj->n_colors-1].hsv_high);\n\t}\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtlib_write_cpt will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write CPT to %s %s\\n\", gmtapi_method (S_obj->method), S_obj->filename);\n\t\t\tif ((error = gmtlib_write_cpt (GMT, S_obj->filename, S_obj->method, mode, P_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_STREAM:\n\t\t\t/* gmtlib_write_cpt will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;\t/* 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write CPT to %s %s output stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((error = gmtlib_write_cpt (GMT, S_obj->fp, S_obj->method, mode, P_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_write_cpt will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_OUT) ? 0 : 1;\t/* 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write CPT to %s %s output stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((error = gmtlib_write_cpt (GMT, S_obj->fp, S_obj->method, mode, P_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input cpt */\n\t\t\tif (S_obj->resource) return (gmtlib_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating CPT to GMT_PALETTE memory location\\n\");\n\t\t\tP_copy = gmtlib_create_palette (GMT, P_obj->n_colors);\n\t\t\tgmtlib_copy_palette (GMT, P_copy, P_obj);\n\t\t\tS_obj->resource = P_copy;\t/* Set resource pointer from object to this palette */\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location */\n\t\t\tif (S_obj->resource) return (gmtlib_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing CPT to GMT_PALETTE memory location\\n\");\n\t\t\tPH = gmt_get_C_hidden (P_obj);\n\t\t\tPH->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = P_obj;\t/* Set resource pointer from object to this palette */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to export CPTs\\n\");\n\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as written */\n\n\treturn GMT_NOERROR;\n}\n\n/*! . */\nGMT_LOCAL struct GMT_POSTSCRIPT * gmtapi_import_postscript (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in a PS struct.\n \t * The mode is not used yet.\n\t * Note: Memory is allocated to hold the GMT_POSTSCRIPT structure except for method GMT_IS_REFERENCE.\n\t */\n\n\tint item;\n\tunsigned int kind;\n\tstruct GMT_POSTSCRIPT *P_obj = NULL, *P_orig = NULL;\n\tstruct GMT_POSTSCRIPT_HIDDEN *PH = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_postscript: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return_null (API, GMT_NO_INPUT);\n\tif ((item = gmtlib_validate_id (API, GMT_IS_POSTSCRIPT, object_ID, GMT_IN, GMTAPI_OPTION_INPUT)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\n\tS_obj = API->object[item];\t/* Use S_obj as shorthand */\n\tif (S_obj->status != GMT_IS_UNUSED) { /* Already read this resource before; are we allowed to re-read? */\n\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC) return_null (API, GMT_READ_ONCE); /* Not allowed to re-read streams */\n\t\tif (!(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t}\n\n\t/* Passed sanity and allowed to read */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtlib_read_ps will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading PS from %s %s\\n\", gmtapi_method (S_obj->method), S_obj->filename);\n\t\t\tif ((P_obj = gmtlib_read_ps (GMT, S_obj->filename, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tS_obj->resource = P_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_STREAM:\n \t\t\t/* gmtlib_read_ps will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;\t/* 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading PS from %s %s stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((P_obj = gmtlib_read_ps (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tS_obj->resource = P_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_read_ps will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_IN) ? 0 : 1;\t/* 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading PS from %s %s stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((P_obj = gmtlib_read_ps (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tS_obj->resource = P_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input CPT palette */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating PS from GMT_POSTSCRIPT memory location\\n\");\n\t\t\tif ((P_orig = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif ((P_obj = GMT_Duplicate_Data (API, GMT_IS_POSTSCRIPT, mode, P_orig)))\n\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so nothing is allocated */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing PS from GMT_POSTSCRIPT memory location\\n\");\n\t\t\tif ((P_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tbreak;\n\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to import PS\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\tPH = gmt_get_P_hidden (P_obj);\n\tS_obj->alloc_mode = PH->alloc_mode;\n\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\n\treturn (P_obj);\t/* Pass back the PS */\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_export_postscript (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_POSTSCRIPT *P_obj) {\n\t/* Does the actual work of writing out the specified PS to a destination.\n\t * The mode not used yet.\n\t */\n\tint item, error;\n\tunsigned int kind;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_POSTSCRIPT *P_copy = NULL;\n\tstruct GMT_POSTSCRIPT_HIDDEN *PH = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_export_postscript: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtlib_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtlib_validate_id (API, GMT_IS_POSTSCRIPT, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtlib_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* This is the API object for the output destination */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET)) {\t/* Only allow writing of a data set once, unless we override by resetting the mode */\n\t\treturn (gmtlib_report_error (API, GMT_WRITTEN_ONCE));\n\t}\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\n\t/* Passed sanity and allowed to write */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtlib_write_ps will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write PS to %s %s\\n\", gmtapi_method (S_obj->method), S_obj->filename);\n\t\t\tif ((error = gmtlib_write_ps (GMT, S_obj->filename, S_obj->method, mode, P_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_STREAM:\n\t\t\t/* gmtlib_write_ps will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;\t/* 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write PS to %s %s output stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((error = gmtlib_write_ps (GMT, S_obj->fp, S_obj->method, mode, P_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_write_ps will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_OUT) ? 0 : 1;\t/* 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write PS to %s %s output stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((error = gmtlib_write_ps (GMT, S_obj->fp, S_obj->method, mode, P_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t\t/* Duplicate the input cpt */\n\t\t\tif (S_obj->resource) return (gmtlib_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating PS to GMT_POSTSCRIPT memory location\\n\");\n\t\t\tif ((P_copy = GMT_Duplicate_Data (API, GMT_IS_POSTSCRIPT, mode, P_obj)))\n\t\t\t\treturn (gmtlib_report_error (API, GMT_MEMORY_ERROR));\n\t\t\tS_obj->resource = P_copy;\t/* Set resource pointer from object to this PS */\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location */\n\t\t\tif (S_obj->resource) return (gmtlib_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing PS to GMT_POSTSCRIPT memory location\\n\");\n\t\t\tPH = gmt_get_P_hidden (P_obj);\n\t\t\tPH->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = P_obj;\t/* Set resource pointer from object to this PS */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to export PS\\n\");\n\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as written */\n\n\treturn GMT_NOERROR;\n}\n\n#if 0\nGMT_LOCAL bool gmtapi_col_check (struct GMT_DATATABLE *T, uint64_t *n_cols) {\n\tuint64_t seg;\n\t/* Checks that all segments in this table has the correct number of columns.\n\t * If *n_cols == 0 we set it to the number of columns found in the first segment. */\n\n\tfor (seg = 0; seg < T->n_segments; seg++) {\n\t\tif ((*n_cols) == 0 && seg == 0) *n_cols = T->segment[seg]->n_columns;\n\t\tif (T->segment[seg]->n_columns != (*n_cols)) return (true);\n\t}\n\treturn (false);\t/* All is well */\n}\n#endif\n\n/*! . */\nGMT_LOCAL void gmtapi_increment_d (struct GMT_DATASET *D_obj, uint64_t n_rows, uint64_t n_columns, uint64_t n_seg) {\n\t/* Increment dimensions for this single dataset's single table's last segment */\n\tuint64_t last_seg = n_seg - 1;\n\tassert (n_seg > 0);\n\tD_obj->table[D_obj->n_tables]->segment[last_seg]->n_rows = n_rows;\n\tD_obj->table[D_obj->n_tables]->segment[last_seg]->n_columns = D_obj->table[D_obj->n_tables]->n_columns = n_columns;\n\tD_obj->table[D_obj->n_tables]->n_records += n_rows;\n\tD_obj->table[D_obj->n_tables]->n_segments = n_seg;\n\tD_obj->n_tables++;\t/* Since we just read one table */\n}\n\nGMT_LOCAL void gmtapi_switch_cols (struct GMT_CTRL *GMT, struct GMT_DATASET *D, unsigned int direction) {\n\tuint64_t tbl, seg;\n\tstruct GMT_DATASEGMENT *S = NULL;\n\n\t/* Implements the effect of -: when we are not writing to file */\n\n\tif (D->n_columns < 2 || !GMT->current.setting.io_lonlat_toggle[direction]) return;\t/* Nothing to do */\n\tfor (tbl = 0; tbl < D->n_tables; tbl++) {\n\t\tfor (seg = 0; seg < D->table[tbl]->n_segments; seg++) {\n\t\t\tS = D->table[tbl]->segment[seg];\n\t\t\tgmt_M_doublep_swap (S->data[GMT_X], S->data[GMT_Y]);\n\t\t}\n\t}\n}\n\n/*! . */\nGMT_LOCAL struct GMT_DATASET * gmtapi_import_dataset (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in the entire virtual data set (possibly via many sources)\n\t * If object_ID == GMT_NOTSET we get all registered input tables, otherwise we just get the one requested.\n\t * Note: Memory is allocated for the Dataset except for method GMT_IS_REFERENCE.\n\t */\n\n\tint item, first_item = 0, this_item = GMT_NOTSET, last_item, new_item, new_ID, status;\n\tunsigned int geometry = GMT_IS_PLP, n_used = 0, method, smode, type = GMT_READ_DATA;\n\tbool allocate = false, update = false, diff_types, use_GMT_io, greenwich = true;\n\tbool via = false, got_data = false, check_col_switch = false;\n\tsize_t n_alloc, s_alloc = GMT_SMALL_CHUNK;\n\tuint64_t row, seg, col, ij, n_records = 0, n_columns = 0, col_pos, n_use;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_getfunction api_get_val = NULL;\n\tstruct GMT_DATASET *D_obj = NULL, *Din_obj = NULL;\n\tstruct GMT_DATASEGMENT *S = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_VECTOR *V_obj = NULL;\n\tstruct GMT_DATASET_HIDDEN *DH = NULL;\n\tstruct GMT_DATATABLE_HIDDEN *TH = NULL;\n\tstruct GMT_DATASEGMENT_HIDDEN *SH = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_dataset: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) {\t/* Means there is more than one source: Merge all registered data tables into a single virtual data set */\n\t\tlast_item = API->n_objects - 1;\t/* Must check all registered objects */\n\t\tallocate = true;\n\t\tn_alloc = GMT_TINY_CHUNK;\t/* We don't expect that many files to be given initially */\n\t}\n\telse {\t\t/* Requested a single, specific data table/file */\n\t\tint flag = (API->module_input) ? GMTAPI_MODULE_INPUT : GMTAPI_OPTION_INPUT;\t/* Needed by Validate_ID */\n\t\tif ((first_item = gmtlib_validate_id (API, GMT_IS_DATASET, object_ID, GMT_IN, flag)) == GMT_NOTSET)\n\t\t\treturn_null (API, API->error);\n\t\tlast_item = first_item;\n\t\tn_alloc = 1;\n\t}\n\n\t/* Allocate a single data set and an initial allocated list of n_alloc tables */\n\tD_obj = gmt_get_dataset (GMT);\n\tDH = gmt_get_DD_hidden (D_obj);\n\tD_obj->table = gmt_M_memory (GMT, NULL, n_alloc, struct GMT_DATATABLE *);\n\tDH->alloc_mode = GMT_ALLOC_INTERNALLY;\t/* So GMT_* modules can free this memory (may override below) */\n\tDH->alloc_level = GMT->hidden.func_level;\t/* So GMT_* modules can free this memory (may override below) */\n\tuse_GMT_io = !(mode & GMT_IO_ASCII);\t\t/* false if we insist on ASCII reading */\n\tGMT->current.io.seg_no = GMT->current.io.rec_no = GMT->current.io.rec_in_tbl_no = GMT->current.io.data_record_number_in_tbl[GMT_IN] = GMT->current.io.data_record_number_in_seg[GMT_IN] = 0;\t/* Reset for each new dataset */\n\tif (GMT->common.R.active[RSET] && GMT->common.R.wesn[XLO] < -180.0 && GMT->common.R.wesn[XHI] > -180.0) greenwich = false;\n\n\tfor (item = first_item; item <= last_item; item++) {\t/* Look through all sources for registered inputs (or just one) */\n\t\tS_obj = API->object[item];\t/* S_obj is the current data object */\n\t\tif (!S_obj) {\t/* Probably not a good sign. NOTE: Probably cannot happen since skipped in api_next_source, no? */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_dataset: Skipped empty object (item = %d)\\n\", item);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_obj->selected) continue;\t\t\t/* Registered, but not selected */\n\t\tif (S_obj->direction == GMT_OUT) continue;\t/* We're doing reading here, so skip output objects */\n\t\tif (S_obj->family != GMT_IS_DATASET) continue;\t/* We're doing datasets here, so skip other data types */\n\t\tif (API->module_input && !S_obj->module_input) continue;\t/* Do not mix module-inputs and option inputs if knowable */\n\t\tif (S_obj->status != GMT_IS_UNUSED) { \t/* Already read this resource before; are we allowed to re-read? */\n\t\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC) {\n\t\t\t\tgmt_M_free (GMT, D_obj->table);\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\treturn_null (API, GMT_READ_ONCE);\t/* Cannot re-read streams */\n\t\t\t}\n\t\t\tif (!(mode & GMT_IO_RESET)) {\n\t\t\t\tgmt_M_free (GMT, D_obj->table);\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\treturn_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t\t\t}\n\t\t}\n\t\tif (this_item == GMT_NOTSET) this_item = item;\t/* First item that worked */\n\t\tvia = false;\n\t\tgeometry = (GMT->common.a.output) ? GMT->common.a.geometry : S_obj->geometry;\t/* When reading GMT and writing OGR/GMT we must make sure we set this first */\n\t\tmethod = gmtapi_set_method (S_obj);\t/* Get the actual method to use */\n\t\tswitch (method) {\t/* File, array, stream, reference, etc ? */\n\t \t\tcase GMT_IS_FILE:\t/* Import all the segments, then count total number of records */\n#ifdef SET_IO_MODE\n\t\t\t\tif (item == first_item) gmt_setmode (GMT, GMT_IN);\t/* Windows may need to switch read mode from text to binary */\n#endif\n\t\t\t\t/* gmtlib_read_table will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\t\tGMT->current.io.first_rec = true;\n\t\t\t\tif (GMT->current.io.ogr == GMT_OGR_TRUE && D_obj->n_tables > 0) {\t/* Only single tables if GMT/OGR */\n\t\t\t\t\tgmt_M_free (GMT, D_obj->table);\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\t\treturn_null (API, GMT_OGR_ONE_TABLE_ONLY);\n\t\t\t\t}\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION,\n\t\t\t\t            \"Reading %s from %s %s\\n\", GMT_family[S_obj->family], gmtapi_method (S_obj->method), S_obj->filename);\n\t\t\t\tif ((D_obj->table[D_obj->n_tables] = gmtlib_read_table (GMT, S_obj->filename, S_obj->method, greenwich, &geometry, &type, use_GMT_io)) == NULL)\n\t\t\t\t\tcontinue;\t\t/* Ran into an empty file (e.g., /dev/null or equivalent). Skip to next item, */\n\t\t\t\tTH = gmt_get_DT_hidden (D_obj->table[D_obj->n_tables]);\n\t\t\t\tTH->id = D_obj->n_tables;\t/* Give sequential internal object_ID numbers to tables */\n\t\t\t\tD_obj->n_tables++;\t/* Since we just read one */\n\t\t\t\tupdate = true;\t\t/* Have reason to update min/max when done */\n\t\t\t\tbreak;\n\n\t\t\tcase GMT_IS_STREAM:\t/* Import all the segments, then count total number of records */\n\t \t\tcase GMT_IS_FDESC:\n\t\t\t\t/* gmtlib_read_table will report where it is reading from if level is GMT_MSG_INFORMATION */\n#ifdef SET_IO_MODE\n\t\t\t\tif (item == first_item) gmt_setmode (GMT, GMT_IN);\t/* Windows may need to switch read mode from text to binary */\n#endif\n\t\t\t\tGMT->current.io.first_rec = true;\n\t\t\t\tif (GMT->current.io.ogr == GMT_OGR_TRUE && D_obj->n_tables > 0)\t{\t/* Only single tables if GMT/OGR */\n\t\t\t\t\tgmt_M_free (GMT, D_obj);\treturn_null (API, GMT_OGR_ONE_TABLE_ONLY);\n\t\t\t\t}\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading %s from %s %\" PRIxS \"\\n\", GMT_family[S_obj->family], gmtapi_method (S_obj->method), (size_t)S_obj->fp);\n\t\t\t\tif ((D_obj->table[D_obj->n_tables] = gmtlib_read_table (GMT, S_obj->fp, S_obj->method, greenwich, &geometry, &type, use_GMT_io)) == NULL) continue;\t\t/* Ran into an empty file (e.g., /dev/null or equivalent). Skip to next item, */\n\t\t\t\tTH = gmt_get_DT_hidden (D_obj->table[D_obj->n_tables]);\n\t\t\t\tTH->id = D_obj->n_tables;\t/* Give sequential internal object_ID numbers to tables */\n\t\t\t\tD_obj->n_tables++;\t/* Since we just read one */\n\t\t\t\tupdate = true;\t\t/* Have reason to update min/max when done */\n\t\t\t\tbreak;\n\n\t\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input dataset */\n\t\t\t\tgmt_M_free (GMT, D_obj->table);\t/* Free up what we allocated earlier since gmt_duplicate_dataset does it all */\n\t\t\t\tgmt_M_free (GMT, D_obj->hidden);\n\t\t\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\tif (n_used) return_null (API, GMT_ONLY_ONE_ALLOWED);\n\t\t\t\tif ((Din_obj = S_obj->resource) == NULL)\t/* Ooops, noting there? */\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t\tif (GMT->common.q.mode == GMT_RANGE_ROW_IN || GMT->common.q.mode == GMT_RANGE_DATA_IN)\n\t\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Row-selection via -qi is not implemented for GMT_IS_DUPLICATE GMT_IS_DATASET external memory objects\\n\");\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating data table from GMT_DATASET memory location\\n\");\n\t\t\t\tcheck_col_switch = true;\n\t\t\t\tD_obj = gmt_duplicate_dataset (GMT, Din_obj, GMT_ALLOC_NORMAL, NULL);\n\t\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_DATASET, GMT_IS_DUPLICATE, geometry, GMT_IN, NULL, D_obj);\t/* Register a new resource to hold D_obj */\n\t\t\t\tif ((new_item = gmtlib_validate_id (API, GMT_IS_DATASET, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\t\tAPI->object[new_item]->resource = D_obj;\n\t\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\t\tDH = gmt_get_DD_hidden (D_obj);\n\t\t\t\tDH->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\t\tD_obj->geometry = S_obj->geometry;\t/* Since provided when registered */\n\t\t\t\tvia = true;\t/* Since input came via a duplicate */\n\t\t\t\tbreak;\n\n\t\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so free up what we allocated earlier */\n\t\t\t\tgmt_M_free (GMT, D_obj->table);\t/* Free up what we allocated up front since we just wish to pass the pointer */\n\t\t\t\tgmt_M_free (GMT, D_obj->hidden);\n\t\t\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\tif (n_used) return_null (API, GMT_ONLY_ONE_ALLOWED);\n\t\t\t\tif (GMT->common.q.mode == GMT_RANGE_ROW_IN || GMT->common.q.mode == GMT_RANGE_DATA_IN)\n\t\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Row-selection via -qi is not implemented for GMT_IS_REFERENCE GMT_IS_DATASET external memory objects\\n\");\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing data table from GMT_DATASET memory location\\n\");\n\t\t\t\tif ((D_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\t\tcheck_col_switch = true;\n\t\t\t\tDH = gmt_get_DD_hidden (D_obj);\n\t\t\t\tbreak;\n\n\t\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\n\t\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\n\t\t\t\t/* Each matrix source becomes a separate table with a single segment unless there are NaN-records as segment headers */\n\t\t\t\tif ((M_obj = S_obj->resource) == NULL) {\n\t\t\t\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t\t}\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating data table from user matrix location\\n\");\n\t\t\t\tif (GMT->common.q.mode == GMT_RANGE_ROW_IN || GMT->common.q.mode == GMT_RANGE_DATA_IN)\n\t\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Row-selection via -qi is not implemented for [GMT_IS_DUPLICATE,GMT_IS_REFERENCE]|GMT_IS_MATRIX external memory objects\\n\");\n\t\t\t\t/* Allocate a table with a single segment given matrix dimensions, but if nan-record we may end up with more segments */\n\t\t\t\tsmode = (M_obj->text) ? GMT_WITH_STRINGS : GMT_NO_STRINGS;\n\t\t\t\tif (smode) type = GMT_READ_MIXED;\t/* If a matrix has text we have a mixed record */\n\t\t\t\tn_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : M_obj->n_columns;\n\t\t\t\tD_obj->table[D_obj->n_tables] = gmt_get_table (GMT);\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, NULL, s_alloc, struct GMT_DATASEGMENT *);\n\t\t\t\tS = D_obj->table[D_obj->n_tables]->segment[0] = GMT_Alloc_Segment (API, smode, M_obj->n_rows, n_columns, NULL, NULL);\n\t\t\t\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL)) == NULL)\n\t\t\t\t\treturn_null (API, GMT_WRONG_MATRIX_SHAPE);\n\t\t\t\tif ((api_get_val = gmtapi_select_get_function (API, M_obj->type)) == NULL)\n\t\t\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\n\t\t\t\tn_use = gmtapi_n_cols_needed_for_gaps (GMT, M_obj->n_columns);\t/* Number of input columns to process */\n\t\t\t\tfor (row = seg = n_records = 0; row < M_obj->n_rows; row++) {\t/* This loop may include NaN-records and data records */\n\t\t\t\t\tgmtapi_update_prev_rec (GMT, n_use);\t/* Make last current record the previous record if it is required by gap checking */\n\t\t\t\t\tfor (col = 0; col < M_obj->n_columns; col++) {\t/* Extract cols for a single record and store result in curr_rec */\n\t\t\t\t\t\tij = GMT_2D_to_index (row, col, M_obj->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\t\t\t\tapi_get_val (&(M_obj->data), ij, &(GMT->current.io.curr_rec[col]));\n\t\t\t\t\t}\n\t\t\t\t\t/* Now process the current record */\n\t\t\t\t\tif ((status = gmtapi_bin_input_memory (GMT, M_obj->n_columns, n_use)) < 0) {\t/* Segment header found, finish the segment we worked on and goto next */\n\t\t\t\t\t\tif (status == GMTAPI_GOT_SEGGAP) API->current_rec[GMT_IN]--;\t/* Since we inserted a segment header we must revisit this record as the first in next segment */\n\t\t\t\t\t\tif (got_data) {\t/* If first input segment has header then we already have that segment allocated */\n\t\t\t\t\t\t\t(void)GMT_Alloc_Segment (API, GMT_IS_DATASET, n_records, n_columns, NULL, S);\t/* Reallocate to exact length */\n\t\t\t\t\t\t\tD_obj->table[D_obj->n_tables]->n_records += n_records;\t\t\t/* Update record count for this table */\n\t\t\t\t\t\t\tseg++;\t/* Increment number of segments */\n\t\t\t\t\t\t\tif (seg == s_alloc) {\t/* Allocate more space for additional segments */\n\t\t\t\t\t\t\t\ts_alloc <<= 1;\t/* Double current alloc limit for segments, then allocate space for more segments */\n\t\t\t\t\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, D_obj->table[D_obj->n_tables]->segment, s_alloc, struct GMT_DATASEGMENT *);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Allocate next segment with initial size the remainder of the data, which is the maximum length possible */\n\t\t\t\t\t\t\tS = D_obj->table[D_obj->n_tables]->segment[seg] = GMT_Alloc_Segment (API, GMT_IS_DATASET, M_obj->n_rows-n_records, n_columns, NULL, NULL);\n\t\t\t\t\t\t\tn_records = 0;\t/* This is number of recs in current segment so we reset it to zero */\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\t/* Found a data record */\n\t\t\t\t\t\tfor (col = 0; col < n_columns; col++)\t/* Place the record into the dataset segment structure */\n\t\t\t\t\t\t\tS->data[col][n_records] = gmtapi_get_record_value (GMT, GMT->current.io.curr_rec, col, M_obj->n_columns);\n\t\t\t\t\t\tgot_data = true;\t/* No longer before first data record */\n\t\t\t\t\t\tif (smode) S->text[n_records] = strdup (M_obj->text[row]);\n\t\t\t\t\t\tn_records++;\t/* Update count of records in current segment */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (seg)\t/* Got more than one segment, so finalize the reallocation of last segment to exact record count */\n\t\t\t\t\t(void)GMT_Alloc_Segment (API, smode, n_records, n_columns, NULL, S);\t/* Reallocate to exact length */\n\t\t\t\tseg++;\t/* Now holds the total number of segments */\n\t\t\t\t/* Realloc this table's segment array to the actual length [i.e., seg] */\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, D_obj->table[D_obj->n_tables]->segment, seg, struct GMT_DATASEGMENT *);\n\t\t\t\tgmtapi_increment_d (D_obj, n_records, n_columns, seg);\t/* Update counters for D_obj's only table */\n\t\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_DATASET, GMT_IS_DUPLICATE, geometry, GMT_IN, NULL, D_obj);\t/* Register a new resource to hold D_obj */\n\t\t\t\tif ((new_item = gmtlib_validate_id (API, GMT_IS_DATASET, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\t\tAPI->object[new_item]->resource = D_obj;\n\t\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\t\tDH = gmt_get_DD_hidden (D_obj);\n\t\t\t\tDH->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\t\tD_obj->geometry = S_obj->geometry;\t/* Since provided when registered */\n\t\t\t\tupdate = via = true;\n\t\t\t\tbreak;\n\n\t \t\tcase GMT_IS_DUPLICATE|GMT_VIA_VECTOR:\n\t\t\t\t/* Each column array source becomes column arrays in a separate table with one (or more if NaN-records) segments */\n\t\t\t\tif ((V_obj = S_obj->resource) == NULL) {\n\t\t\t\t\tgmt_M_free (GMT, D_obj);\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t\t}\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating data table from user %\" PRIu64 \" column arrays of length %\" PRIu64 \"\\n\",\n\t\t\t\t            V_obj->n_columns, V_obj->n_rows);\n\t\t\t\tif (GMT->common.q.mode == GMT_RANGE_ROW_IN || GMT->common.q.mode == GMT_RANGE_DATA_IN)\n\t\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Row-selection via -qi is not implemented for GMT_IS_DUPLICATE|GMT_VIA_VECTOR external memory objects\\n\");\n\t\t\t\t/* Allocate a single table with one segment - there may be more if there are nan-records */\n\t\t\t\tsmode = (V_obj->text) ? GMT_WITH_STRINGS : GMT_NO_STRINGS;\n\t\t\t\tif (smode) type = GMT_READ_MIXED;\t/* If a vector has text we have a mixed record */\n\t\t\t\tn_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : V_obj->n_columns;\n\t\t\t\tD_obj->table[D_obj->n_tables] = gmt_get_table (GMT);\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, NULL, s_alloc, struct GMT_DATASEGMENT *);\n\t\t\t\tS = D_obj->table[D_obj->n_tables]->segment[0] = GMT_Alloc_Segment (API, smode, V_obj->n_rows, n_columns, NULL, NULL);\n\t\t\t\tfor (col = 1, diff_types = false; !diff_types && col < V_obj->n_columns; col++) if (V_obj->type[col] != V_obj->type[col-1]) diff_types = true;\n\t\t\t\tif (!diff_types && (api_get_val = gmtapi_select_get_function (API, V_obj->type[0])) == NULL)\n\t\t\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\n\t\t\t\tfor (row = seg = n_records = 0; row < V_obj->n_rows; row++) {\t/* This loop may include NaN-records and data records */\n\t\t\t\t\tn_use = gmtapi_n_cols_needed_for_gaps (GMT, V_obj->n_columns);\n\t\t\t\t\tgmtapi_update_prev_rec (GMT, n_use);\n\t\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++) {\t/* Process a single record into curr_rec */\n\t\t\t\t\t\tif (diff_types && (api_get_val = gmtapi_select_get_function (API, V_obj->type[col])) == NULL)\n\t\t\t\t\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\t\t\t\tapi_get_val (&(V_obj->data[col]), row, &(GMT->current.io.curr_rec[col]));\n\t\t\t\t\t}\n\t\t\t\t\tif ((status = gmtapi_bin_input_memory (GMT, V_obj->n_columns, n_use)) < 0) {\t/* Segment header found, finish the one we had and add more */\n\t\t\t\t\t\tif (status == GMTAPI_GOT_SEGGAP) API->current_rec[GMT_IN]--;\t/* Since we inserted a segment header we must revisit this record as first in next segment */\n\t\t\t\t\t\tif (got_data) {\t/* If first input segment has header then we already have a segment allocated */\n\t\t\t\t\t\t\t(void)GMT_Alloc_Segment (API, GMT_IS_DATASET, n_records, n_columns, NULL, S);\n\t\t\t\t\t\t\tD_obj->table[D_obj->n_tables]->n_records += n_records;\n\t\t\t\t\t\t\tseg++;\t/* Increment number of segments */\n\t\t\t\t\t\t\tif (seg == s_alloc) {\t/* Allocate more space for segments */\n\t\t\t\t\t\t\t\ts_alloc <<= 1;\n\t\t\t\t\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, D_obj->table[D_obj->n_tables]->segment, s_alloc, struct GMT_DATASEGMENT *);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Allocate next segment with initial size the remainder of the data */\n\t\t\t\t\t\t\tS = D_obj->table[D_obj->n_tables]->segment[seg] = GMT_Alloc_Segment (API, GMT_IS_DATASET, V_obj->n_rows-n_records, n_columns, NULL, NULL);\n\t\t\t\t\t\t\tn_records = 0;\t/* This is number of recs in current segment */\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\t/* Data record */\n\t\t\t\t\t\tfor (col = 0; col < n_columns; col++)\t/* Place the record into the structure */\n\t\t\t\t\t\t\tS->data[col][n_records] = gmtapi_get_record_value (GMT, GMT->current.io.curr_rec, col, V_obj->n_columns);\n\t\t\t\t\t\tif (smode) S->text[n_records] = strdup (V_obj->text[row]);\n\t\t\t\t\t\tgot_data = true;\n\t\t\t\t\t\tn_records++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (seg)\t/* Got more than one segment, finalize the realloc of last segment */\n\t\t\t\t\t(void)GMT_Alloc_Segment (API, smode, n_records, n_columns, NULL, S);\t/* Reallocate to exact length */\n\t\t\t\tseg++;\t/* Total number of segments */\n\t\t\t\t/* Realloc this table's segment array to the actual length [i.e., seg] */\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, D_obj->table[D_obj->n_tables]->segment, seg, struct GMT_DATASEGMENT *);\n\t\t\t\tgmtapi_increment_d (D_obj, n_records, n_columns, seg);\t/* Update counters for D_obj's only table */\n\t\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_DATASET, GMT_IS_DUPLICATE, geometry, GMT_IN, NULL, D_obj);\t/* Register a new resource to hold D_obj */\n\t\t\t\tif ((new_item = gmtlib_validate_id (API, GMT_IS_DATASET, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\t\tAPI->object[new_item]->resource = D_obj;\n\t\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t\t\t/* Mark as read */\n\t\t\t\tDH = gmt_get_DD_hidden (D_obj);\n\t\t\t\tDH->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\t\tD_obj->geometry = S_obj->geometry;\t/* Since provided when registered */\n\t\t\t\tupdate = via = true;\n\t\t\t\tbreak;\n\n\t\t \tcase GMT_IS_REFERENCE|GMT_VIA_VECTOR:\n\t\t\t\tif ((V_obj = S_obj->resource) == NULL) {\n\t\t\t\t\tgmt_M_free (GMT, D_obj);\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t\t}\n\t\t\t\tif (V_obj->type[0] != GMT_DOUBLE) {\n\t\t\t\t\tgmt_M_free (GMT, D_obj);\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\t\t}\n\t\t\t\tif (GMT->common.q.mode == GMT_RANGE_ROW_IN || GMT->common.q.mode == GMT_RANGE_DATA_IN)\n\t\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Row-selection via -qi is not implemented for GMT_IS_REFERENCE|GMT_VIA_VECTOR external memory objects\\n\");\n\t\t\t\t/* Each column double array source becomes preallocated column arrays in a separate table with a single segment */\n\t\t\t\tsmode = (V_obj->text) ? GMT_WITH_STRINGS : GMT_NO_STRINGS;\n\t\t\t\tif (smode) type = GMT_READ_MIXED;\t/* If a matrix has text we have a mixed record */\n\t\t\t\tn_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : V_obj->n_columns;\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing data table from user %\" PRIu64 \" column arrays of length %\" PRIu64 \"\\n\",\n\t\t\t\t            V_obj->n_columns, V_obj->n_rows);\n\t\t\t\tD_obj->table[D_obj->n_tables] = gmt_get_table (GMT);\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment = gmt_M_memory (GMT, NULL, 1, struct GMT_DATASEGMENT *);\n\t\t\t\tD_obj->table[D_obj->n_tables]->segment[0] = GMT_Alloc_Segment (API, smode, 0, n_columns, NULL, NULL);\n\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++) {\n\t\t\t\t\tif (GMT->common.i.select)\t/* -i has selected some columns */\n\t\t\t\t\t\tcol_pos = GMT->current.io.col[GMT_IN][col].col;\t/* Which data column to pick */\n\t\t\t\t\telse if (GMT->current.setting.io_lonlat_toggle[GMT_IN] && col < GMT_Z)\t/* Worry about -: for lon,lat */\n\t\t\t\t\t\tcol_pos = 1 - col;\t/* Read lat/lon instead of lon/lat */\n\t\t\t\t\telse\n\t\t\t\t\t\tcol_pos = col;\t/* Just goto that column */\n\t\t\t\t\tD_obj->table[D_obj->n_tables]->segment[0]->data[col] = V_obj->data[col_pos].f8;\n\t\t\t\t}\n\t\t\t\tDH = gmt_get_DD_hidden (D_obj);\n\t\t\t\tif (smode) D_obj->table[D_obj->n_tables]->segment[0]->text = V_obj->text;\n\t\t\t\tgmtapi_increment_d (D_obj, V_obj->n_rows, n_columns, 1U);\t/* Update counters for D_obj with 1 segment */\n\t\t\t\tDH->alloc_mode = GMT_ALLOC_EXTERNALLY;\t/* Since we just hooked on the arrays */\n\t\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_DATASET, GMT_IS_REFERENCE, geometry, GMT_IN, NULL, D_obj);\t/* Register a new resource to hold D_obj */\n\t\t\t\tif ((new_item = gmtlib_validate_id (API, GMT_IS_DATASET, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\t\tAPI->object[new_item]->resource = D_obj;\n\t\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\t\tDH->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\t\tD_obj->geometry = S_obj->geometry;\t/* Since provided when registered */\n\t\t\t\tS_obj->family = GMT_IS_VECTOR;\t/* Done with the via business now */\n\t\t\t\tupdate = via = check_col_switch = true;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to import data tables\\n\");\n\t\t\t\tgmt_M_free (GMT, D_obj->table);\n\t\t\t\tgmt_M_free (GMT, D_obj);\n\t\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (update) {\t/* Means we got stuff and need to update the total dataset statistics so far */\n\t\t\tD_obj->n_segments += D_obj->table[D_obj->n_tables-1]->n_segments;\t/* Sum up total number of segments in the entire data set */\n\t\t\tD_obj->n_records  += D_obj->table[D_obj->n_tables-1]->n_records;\t\t/* Sum up total number of records in the entire data set */\n\t\t\t/* Update segment IDs so they are sequential across many tables (gmtlib_read_table sets the ids relative to current table). */\n\t\t\tif (D_obj->n_tables > 1) {\n\t\t\t\tfor (seg = 0; seg < D_obj->table[D_obj->n_tables-1]->n_segments; seg++) {\n\t\t\t\t\tSH = gmt_get_DS_hidden (D_obj->table[D_obj->n_tables-1]->segment[seg]);\n\t\t\t\t\tSH->id += D_obj->table[D_obj->n_tables-2]->n_segments;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (allocate && D_obj->n_tables == n_alloc) {\t/* Must allocate more space for additional tables */\n\t\t\t\tsize_t old_n_alloc = n_alloc;\n\t\t\t\tn_alloc += GMT_TINY_CHUNK;\n\t\t\t\tD_obj->table = gmt_M_memory (GMT, D_obj->table, n_alloc, struct GMT_DATATABLE *);\n\t\t\t\tgmt_M_memset (&(D_obj->table[old_n_alloc]), n_alloc - old_n_alloc, struct GMT_DATATABLE *);\t/* Set new memory to NULL */\n\t\t\t}\n\t\t}\n\t\tS_obj->alloc_mode = DH->alloc_mode;\t/* Clarify allocation mode for this object */\n#if 0\n\t\tif (gmtapi_col_check (D_obj->table[D_obj->n_tables-1], &n_cols)) {\t/* Different tables have different number of columns, which is not good */\n\t\t\treturn_null (API, GMT_N_COLS_VARY);\n\t\t}\n#endif\n\t\tS_obj->status = GMT_IS_USED;\t/* Mark input object as read */\n\t\tS_obj->n_expected_fields = GMT_MAX_COLUMNS;\t/* Since need to start over if this object is used again */\n\t\tn_used++;\t/* Number of items actually processed */\n\t}\n\tif (D_obj->n_tables == 0) {\t/* Only found empty files (e.g., /dev/null) and we have nothing to show for our efforts.  Return an single empty table with no segments. */\n\t\tD_obj->table = gmt_M_memory (GMT, D_obj->table, 1, struct GMT_DATATABLE *);\n\t\tD_obj->table[0] = gmt_get_table (GMT);\n\t\tD_obj->n_tables = 1;\t/* But we must indicate we found one (empty) table */\n\t}\n\telse {\t/* Found one or more tables, finalize table allocation, set number of columns, and possibly allocate min/max arrays if not there already */\n\t\tif (allocate && D_obj->n_tables < n_alloc) D_obj->table = gmt_M_memory (GMT, D_obj->table, D_obj->n_tables, struct GMT_DATATABLE *);\n\t\tD_obj->n_columns = D_obj->table[0]->n_columns;\n\t\tif (!D_obj->min) D_obj->min = gmt_M_memory (GMT, NULL, D_obj->n_columns, double);\n\t\tif (!D_obj->max) D_obj->max = gmt_M_memory (GMT, NULL, D_obj->n_columns, double);\n\t}\n\tD_obj->geometry = geometry;\t\t/* Since gmtlib_read_table may have changed it */\n\tD_obj->type = type;\t\t\t/* Since gmtlib_read_table may have changed it */\n\tif (check_col_switch) gmtapi_switch_cols (GMT, D_obj, GMT_IN);\t/* Deals with -:, if it was selected */\n\tgmt_set_dataset_minmax (GMT, D_obj);\t/* Set the min/max values for the entire dataset */\n\tif (!via) API->object[this_item]->resource = D_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\treturn (D_obj);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_destroy_data_ptr (struct GMTAPI_CTRL *API, enum GMT_enum_family family, void *ptr) {\n\t/* Like GMT_Destroy_Data but takes pointer to data rather than address of pointer.\n\t * We pass true to make sure we free the memory.  Some objects (grid, matrix, vector) may\n\t * point to externally allocated memory so we return the alloc_mode for those items.\n\t * This is mostly for information since the pointers to such external memory have now\n\t * been set to NULL instead of being freed.\n\t * The containers are always allocated by GMT so those are freed at the end.\n\t */\n\n\tstruct GMT_CTRL *GMT;\n\tif (API == NULL) return (GMT_NOT_A_SESSION);\n\tif (!ptr) return (GMT_NOERROR);\t/* Null pointer */\n\tGMT = API->GMT;\n\n\tswitch (family) {\n\t\tcase GMT_IS_GRID:\n\t\t\tgmtlib_free_grid_ptr (GMT, ptr, true);\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\n\t\t\tgmtlib_free_dataset_ptr (GMT, ptr);\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\n\t\t\tgmtlib_free_cpt_ptr (GMT, ptr);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\tgmtlib_free_image_ptr (GMT, ptr, true);\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\n\t\t\tgmtlib_free_ps_ptr (GMT, ptr);\n\t\t\tbreak;\n\t\tcase GMT_IS_CUBE:\n\t\t\tgmtlib_free_cube_ptr (GMT, ptr, true);\n\t\t\tbreak;\n\t\tcase GMT_IS_COORD:\n\t\t\t/* Nothing to do as gmt_M_free below will do it */\n\t\t\tbreak;\n\n\t\t/* Also allow destroying of intermediate vector and matrix containers */\n\t\tcase GMT_IS_MATRIX:\n\t\t\tgmtlib_free_matrix_ptr (GMT, ptr, true);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\n\t\t\tgmtlib_free_vector_ptr (GMT, ptr, true);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_FAMILY));\n\t\t\tbreak;\n\t}\n\tgmt_M_free (GMT, ptr);\t/* OK to free container */\n\treturn (GMT_NOERROR);\t/* Null pointer */\n}\n\nvoid gmtapi_flip_vectors (struct GMT_CTRL *GMT, struct GMT_VECTOR *V, unsigned int direction) {\n\tenum GMT_enum_type etmp;\n\tunion GMT_UNIVECTOR utmp;\n\n\t/* Implements the effect of -: on output via vectors */\n\n\tif (V->n_columns < 2 || !GMT->current.setting.io_lonlat_toggle[direction]) return;\t/* Nothing to do */\n\t/* Flip first two vector pointers */\n\tetmp = V->type[GMT_X];\tV->type[GMT_X] = V->type[GMT_Y];\tV->type[GMT_Y] = etmp;\n\tutmp = V->data[GMT_X];\tV->data[GMT_X] = V->data[GMT_Y];\tV->data[GMT_Y] = utmp;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_export_dataset (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_DATASET *D_obj) {\n \t/* Does the actual work of writing out the specified data set to a single destination.\n\t * If object_ID == GMT_NOTSET we use the first registered output destination, otherwise we just use the one specified.\n\t * See the GMT API documentation for how mode is used to create multiple files from segments or tables of a dataset.\n\t */\n\tint item, error, default_method;\n\tunsigned int method, hdr;\n\tuint64_t tbl, col, kol, row_out, row, seg, ij, n_columns, n_rows;\n\tbool save, diff_types = false, toggle;\n\tdouble value;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_DATASET *D_copy = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_VECTOR *V_obj = NULL;\n\tstruct GMT_MATRIX_HIDDEN *MH = NULL;\n\tstruct GMT_VECTOR_HIDDEN *VH = NULL;\n\tstruct GMT_DATASEGMENT *S = NULL;\n\tstruct GMT_DATASET_HIDDEN *DH = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tvoid *ptr = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_export_dataset: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtlib_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtlib_validate_id (API, GMT_IS_DATASET, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtlib_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* S is the object whose data we will export */\n\tif (S_obj->family != GMT_IS_DATASET) return (gmtlib_report_error (API, GMT_NOT_A_VALID_FAMILY));\t/* Called with wrong data type */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET))\t/* Only allow writing of a data set once unless overridden by mode */\n\t\treturn (gmtlib_report_error (API, GMT_WRITTEN_ONCE));\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\t/* Remove the reset bit */\n\tif (mode >= GMT_WRITE_TABLE && !S_obj->filename) return (gmtlib_report_error (API, GMT_OUTPUT_NOT_SET));\t/* Must have filename when segments are to be written */\n\tdefault_method = GMT_IS_FILE;\n\tif (S_obj->filename)\t/* Write to this file */\n\t\tptr = S_obj->filename;\n\telse {\t\t\t/* No filename so we switch default method to writing to a stream or fdesc */\n\t\tdefault_method = (S_obj->method == GMT_IS_FILE) ? GMT_IS_STREAM : S_obj->method;\n\t\tptr = S_obj->fp;\n#ifdef SET_IO_MODE\n\t\tgmt_setmode (GMT, GMT_OUT);\t/* Windows may need to switch write mode from text to binary */\n#endif\n\t}\n\tgmt_set_dataset_minmax (GMT, D_obj);\t/* Update all counters and min/max arrays */\n\tif (API->GMT->common.o.end || GMT->common.o.text)\t/* Asked for unspecified last column on input (e.g., -i3,2,5:), supply the missing last column number */\n\t\tgmtlib_reparse_o_option (GMT, (GMT->common.o.text) ? 0 : D_obj->n_columns);\n\ttoggle = (GMT->current.setting.io_lonlat_toggle[GMT_OUT] && D_obj->n_columns >= 2);\n\tGMT->current.io.data_record_number_in_tbl[GMT_OUT] = GMT->current.io.data_record_number_in_seg[GMT_OUT] = 0;\n\tDH = gmt_get_DD_hidden (D_obj);\n\tDH->io_mode = mode;\t/* Handles if tables or segments should be written to separate files, according to mode */\n\tmethod = gmtapi_set_method (S_obj);\t/* Get the actual method to use */\n\tswitch (method) {\t/* File, array, stream, etc. */\n\t \tcase GMT_IS_STREAM:\n#ifdef SET_IO_MODE\n\t\t\tgmt_setmode (GMT, GMT_OUT);\t/* Windows may need to switch write mode from text to binary */\n#endif\n\t\tcase GMT_IS_FILE:\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* gmtlib_write_dataset (or lower) will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tif ((error = gmtlib_write_dataset (GMT, ptr, default_method, D_obj, true, GMT_NOTSET))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE:\t\t/* Duplicate the input dataset on output */\n\t\t\tif (S_obj->resource) return (gmtlib_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tif (GMT->common.q.mode == GMT_RANGE_ROW_OUT || GMT->common.q.mode == GMT_RANGE_DATA_OUT)\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Row-selection via -qo is not implemented for GMT_IS_DUPLICATE GMT_IS_DATASET external memory objects\\n\");\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating data table to GMT_DATASET memory location\\n\");\n\t\t\tD_copy = gmt_duplicate_dataset (GMT, D_obj, GMT_ALLOC_NORMAL, NULL);\n\t\t\tgmtlib_change_dataset (GMT, D_copy);\t/* Deal with any -o settings */\n\t\t\tgmtapi_switch_cols (GMT, D_copy, GMT_OUT);\t/* Deals with -:, if it was selected */\n\t\t\tS_obj->resource = D_copy;\t/* Set resource pointer from object to this dataset */\n\t\t\tbreak;\n\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location */\n\t\t\tif (S_obj->resource) return (gmtlib_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource must be NULL */\n\t\t\tif (GMT->common.q.mode == GMT_RANGE_ROW_OUT || GMT->common.q.mode == GMT_RANGE_DATA_OUT)\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Row-selection via -qo is not implemented for GMT_IS_REFERENCE GMT_IS_DATASET external memory objects\\n\");\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing data table to GMT_DATASET memory location\\n\");\n\t\t\tgmtlib_change_dataset (GMT, D_obj);\t/* Deal with any -o settings */\n\t\t\tgmtapi_switch_cols (GMT, D_obj, GMT_OUT);\t/* Deals with -:, if it was selected */\n\t\t\tS_obj->resource = D_obj;\t\t/* Set resource pointer from object to this dataset */\n\t\t\tDH->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating data table to user matrix location\\n\");\n\t\t\tif (GMT->common.q.mode == GMT_RANGE_ROW_OUT || GMT->common.q.mode == GMT_RANGE_DATA_OUT)\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Row-selection via -qo is not implemented for GMT_IS_DUPLICATE|GMT_VIA_MATRIX external memory objects\\n\");\n\t\t\tsave = GMT->current.io.multi_segments[GMT_OUT];\n\t\t\tif (GMT->current.io.skip_headers_on_outout) GMT->current.io.multi_segments[GMT_OUT] = false;\n\t\t\tn_rows = (GMT->current.io.multi_segments[GMT_OUT]) ? D_obj->n_records + D_obj->n_segments : D_obj->n_records;\t/* Number of rows needed to hold the data [incl any segment headers] */\n\t\t\tn_columns = (GMT->common.o.select) ? GMT->common.o.n_cols : D_obj->n_columns;\t\t\t\t\t/* Number of columns needed to hold the data records */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) {\t/* Must allocate suitable matrix */\n\t\t\t\tM_obj = gmtlib_create_matrix (GMT, 1U, GMT_OUT, 0);\t/* 1-layer matrix (i.e., 2-D) */\n\t\t\t\t/* Allocate final output space since we now know all dimensions */\n\t\t\t\tMH = gmt_get_M_hidden (M_obj);\n\t\t\t\tM_obj->n_rows = n_rows;\n\t\t\t\tM_obj->n_columns = n_columns;\n\t\t\t\tM_obj->dim = (M_obj->shape == GMT_IS_ROW_FORMAT) ? M_obj->n_columns : M_obj->n_rows;\t\t\t\t\t\t/* Matrix layout order */\n\t\t\t\tS_obj->n_alloc = M_obj->n_rows * M_obj->n_columns;\t/* Get total number of elements as n_rows * n_columns */\n\t\t\t\tM_obj->type = S_obj->type;\t/* Use selected data type for the export */\n\t\t\t\t/* Allocate output matrix space or die */\n\t\t\t\tif ((error = gmtlib_alloc_univector (GMT, &(M_obj->data), M_obj->type, S_obj->n_alloc)) != GMT_NOERROR) return (gmtlib_report_error (API, error));\n\t\t\t\tMH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\t\tif (D_obj->type >= GMT_READ_TEXT) { /* Also has trailing text */\n\t\t\t\t\tM_obj->text = gmt_M_memory (GMT, NULL, n_rows, char *);\n\t\t\t\t\tMH->alloc_mode_text = GMT_ALLOC_INTERNALLY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t/* We passed in a matrix so must check it is big enough */\n\t\t\t\tif (M_obj->n_rows < n_rows || M_obj->n_columns < n_columns)\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_DIM_TOO_SMALL));\n\t\t\t\tMH = gmt_get_M_hidden (M_obj);\n\t\t\t}\n\t\t\t/* Consider header records from first table only */\n\t\t\tif (D_obj->table[0]->n_headers) {\n\t\t\t\tM_obj->header = gmt_M_memory (GMT, NULL, D_obj->table[0]->n_headers, char *);\n\t\t\t\tfor (hdr = M_obj->n_headers = 0; hdr < D_obj->table[0]->n_headers; hdr++)\n\t\t\t\t\tM_obj->header[M_obj->n_headers++] = strdup (D_obj->table[0]->header[hdr]);\n\t\t\t}\n\n\t\t\t/* Set up index and put-value functions for this matrix */\n\t\t\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL)) == NULL)\n\t\t\t\treturn (gmtlib_report_error (API, GMT_WRONG_MATRIX_SHAPE));\n\t\t\tif ((api_put_val = gmtapi_select_put_function (API, M_obj->type)) == NULL)\n\t\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_TYPE));\n\n\t\t\tfor (tbl = row_out = 0; tbl < D_obj->n_tables; tbl++) {\t/* Loop over tables and segments */\n\t\t\t\tfor (seg = 0; seg < D_obj->table[tbl]->n_segments; seg++) {\n\t\t\t\t\tS = D_obj->table[tbl]->segment[seg];\t/* Shorthand for the current segment */\n\t\t\t\t\tif (GMT->current.io.multi_segments[GMT_OUT]) {\t/* Must write a NaN-segment record to indicate segment break */\n\t\t\t\t\t\tfor (col = 0; col < M_obj->n_columns; col++) {\n\t\t\t\t\t\t\tij = GMT_2D_to_index (row_out, col, M_obj->dim);\n\t\t\t\t\t\t\tapi_put_val (&(M_obj->data), ij, GMT->session.d_NaN);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trow_out++;\t/* Due to the extra NaN-data header record we just wrote */\n\t\t\t\t\t}\n\t\t\t\t\tfor (row = 0; row < S->n_rows; row++, row_out++) {\t/* Write this segment's data records to the matrix */\n\t\t\t\t\t\tfor (col = 0; col < M_obj->n_columns; col++) {\n\t\t\t\t\t\t\tif (col < 2 && toggle)\t/* Deal with -: since we are writing to matrix memory and not file */\n\t\t\t\t\t\t\t\tkol = 1 - col;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tkol = col;\n\t\t\t\t\t\t\tij = GMT_2D_to_index (row_out, kol, M_obj->dim);\n\t\t\t\t\t\t\tvalue = gmtapi_select_dataset_value (GMT, S, (unsigned int)row, (unsigned int)col);\n\t\t\t\t\t\t\tapi_put_val (&(M_obj->data), ij, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (S->text) M_obj->text[row_out] = strdup (S->text[row]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (M_obj->n_rows == row_out);\t/* Sanity check */\n\t\t\tMH->alloc_level = S_obj->alloc_level;\n\t\t\tS_obj->resource = M_obj;\t\t/* Set resource pointer from object to this matrix */\n\t\t\tGMT->current.io.multi_segments[GMT_OUT] = save;\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE|GMT_VIA_VECTOR:\n\t\t\tif (GMT->common.q.mode == GMT_RANGE_ROW_OUT || GMT->common.q.mode == GMT_RANGE_DATA_OUT)\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Row-selection via -qo is not implemented for GMT_IS_DUPLICATE|GMT_VIA_VECTOR external memory objects\\n\");\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating data table to user column arrays location\\n\");\n\t\t\tsave = GMT->current.io.multi_segments[GMT_OUT];\n\t\t\tif (GMT->current.io.skip_headers_on_outout) GMT->current.io.multi_segments[GMT_OUT] = false;\n\t\t\tn_columns = (GMT->common.o.select) ? GMT->common.o.n_cols : D_obj->n_columns;\t/* Number of columns needed to hold the data records */\n\t\t\tn_rows = (GMT->current.io.multi_segments[GMT_OUT]) ? D_obj->n_records + D_obj->n_segments : D_obj->n_records;\t/* Number of data records [and any segment headers] */\n\t\t\tif ((V_obj = S_obj->resource) == NULL) {\t/* Must create output container given data dimensions */\n\t\t\t\tif ((V_obj = gmt_create_vector (GMT, n_columns, GMT_OUT)) == NULL)\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_PTR_IS_NULL));\n\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++) V_obj->type[col] = S_obj->type;\t/* Set same data type for all columns */\n\t\t\t\tV_obj->n_rows = n_rows;\n\t\t\t\tif ((error = gmtlib_alloc_vectors (GMT, V_obj, n_rows)) != GMT_NOERROR) return (gmtlib_report_error (API, error));\t/* Allocate space for all columns */\n\t\t\t\tif (D_obj->type >= GMT_READ_TEXT) { /* Also has trailing text */\n\t\t\t\t\tstruct GMT_VECTOR_HIDDEN *VH = gmt_get_V_hidden (V_obj);\n\t\t\t\t\tV_obj->text = gmt_M_memory (GMT, NULL, n_rows, char *);\n\t\t\t\t\tVH->alloc_mode_text = GMT_ALLOC_INTERNALLY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t/* Got a preallocated container */\n\t\t\t\tif (V_obj->n_rows < n_rows || V_obj->n_columns < n_columns)\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_DIM_TOO_SMALL));\n\t\t\t\tfor (col = 1, diff_types = false; !diff_types && col < V_obj->n_columns; col++) if (V_obj->type[col] != V_obj->type[col-1]) diff_types = true;\n\t\t\t}\n\t\t\t/* Consider header records from first table only */\n\t\t\tif (D_obj->table[0]->n_headers) {\n\t\t\t\tV_obj->header = gmt_M_memory (GMT, NULL, D_obj->table[0]->n_headers, char *);\n\t\t\t\tfor (hdr = V_obj->n_headers = 0; hdr < D_obj->table[0]->n_headers; hdr++)\n\t\t\t\t\tV_obj->header[V_obj->n_headers++] = strdup (D_obj->table[0]->header[hdr]);\n\t\t\t}\n\n\t\t\t/* Set up put-value functions for this vector */\n\t\t\tif (!diff_types && (api_put_val = gmtapi_select_put_function (API, V_obj->type[0])) == NULL)\t/* Get function to write 1st column (possibly all columns) */\n\t\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_TYPE));\n\t\t\tfor (tbl = row_out = 0; tbl < D_obj->n_tables; tbl++) {\t/* Loop over all tables and segments */\n\t\t\t\tfor (seg = 0; seg < D_obj->table[tbl]->n_segments; seg++) {\n\t\t\t\t\tS = D_obj->table[tbl]->segment[seg];\t/* Shorthand for this segment */\n\t\t\t\t\tif (GMT->current.io.multi_segments[GMT_OUT]) {\t\t/* Must write a NaN-segment record */\n\t\t\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++)\n\t\t\t\t\t\t\tapi_put_val (&(V_obj->data[col]), row_out, GMT->session.d_NaN);\n\t\t\t\t\t\trow_out++;\t/* Due to the extra NaN-data header */\n\t\t\t\t\t}\n\t\t\t\t\tfor (row = 0; row < S->n_rows; row++, row_out++) {\t/* Copy the data records */\n\t\t\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++) {\n\t\t\t\t\t\t\tif (diff_types && (api_put_val = gmtapi_select_put_function (API, V_obj->type[col])) == NULL)\n\t\t\t\t\t\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_TYPE));\n\t\t\t\t\t\t\tvalue = gmtapi_select_dataset_value (GMT, S, (unsigned int)row, (unsigned int)col);\n\t\t\t\t\t\t\tapi_put_val (&(V_obj->data[col]), row_out, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (S->text) V_obj->text[row_out] = strdup (S->text[row]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (V_obj->n_rows == row_out);\t/* Sanity check */\n\t\t\tif (toggle) gmtapi_flip_vectors (GMT, V_obj, GMT_OUT);\n\t\t\tVH = gmt_get_V_hidden (V_obj);\n\t\t\tVH->alloc_level = S_obj->alloc_level;\n\t\t\tS_obj->resource = V_obj;\n\t\t\tGMT->current.io.multi_segments[GMT_OUT] = save;\n\t\t\tbreak;\n\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_VECTOR:\n\t\t\tif (GMT->common.q.mode == GMT_RANGE_ROW_OUT || GMT->common.q.mode == GMT_RANGE_DATA_OUT)\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Row-selection via -qo is not implemented for GMT_IS_REFERENCE|GMT_VIA_VECTOR external memory objects\\n\");\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Referencing data table to users column-vector location\\n\");\n\t\t\tif (D_obj->n_tables > 1 || D_obj->n_segments > 1) {\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Reference by vector requires a single segment!\\n\");\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Output may be truncated or an error may occur!\\n\");\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating data table to user column arrays location\\n\");\n\t\t\tn_columns = (GMT->common.o.select) ? GMT->common.o.n_cols : D_obj->n_columns;\t/* Number of columns needed to hold the data records */\n\t\t\tn_rows = D_obj->n_records;\t/* Number of data records */\n\t\t\tS = D_obj->table[0]->segment[0];\t/* Shorthand for this single segment */\n\t\t\tif ((V_obj = S_obj->resource) == NULL) {\t/* Must create output container given data dimensions */\n\t\t\t\tstruct GMT_DATASEGMENT_HIDDEN *SH = gmt_get_DS_hidden (S);\n\t\t\t\tif ((V_obj = gmt_create_vector (GMT, n_columns, GMT_OUT)) == NULL)\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_PTR_IS_NULL));\n\t\t\t\tVH = gmt_get_V_hidden (V_obj);\n\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++) {\n\t\t\t\t\tV_obj->type[col] = S_obj->type;\t/* Set same data type for all columns */\n\t\t\t\t\tV_obj->data[col].f8 = S->data[col];\t/* Set pointer only */\n\t\t\t\t\tVH->alloc_mode[col] = GMT_ALLOC_EXTERNALLY;\t/* Since not duplicated, just pointed to */\n\t\t\t\t}\n\t\t\t\tif (S->text) {\n\t\t\t\t\tV_obj->text = S->text;\n\t\t\t\t\tVH->alloc_mode_text = GMT_ALLOC_EXTERNALLY;\t/* Since not duplicated, just pointed to */\n\t\t\t\t}\n\t\t\t\tV_obj->n_rows = n_rows;\n\t\t\t\tVH->alloc_level = S_obj->alloc_level;\t/* Otherwise D_obj will be freed before we get to use data */\n\t\t\t\tS_obj->alloc_mode = DH->alloc_mode;\t/* Otherwise D_obj will be freed before we get to use data */\n\t\t\t\tSH->alloc_mode = GMT_ALLOC_EXTERNALLY;\t/* To prevent freeing in D_obj */\n\t\t\t}\n\t\t\telse {\t/* Got a preallocated container */\n\t\t\t\tif (V_obj->n_rows < n_rows || V_obj->n_columns < n_columns)\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_DIM_TOO_SMALL));\n\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++)\n\t\t\t\t\tgmt_M_memcpy (V_obj->data[col].f8, S->data[col], n_rows, double);\t/* Duplicate data */\n\t\t\t}\n\t\t\t/* Consider header records from first table only and will set pointers only */\n\t\t\tif (D_obj->table[0]->n_headers) {\n\t\t\t\tV_obj->header = gmt_M_memory (GMT, NULL, D_obj->table[0]->n_headers, char *);\n\t\t\t\tfor (hdr = V_obj->n_headers = 0; hdr < D_obj->table[0]->n_headers; hdr++)\n\t\t\t\t\tV_obj->header[V_obj->n_headers++] = strdup (D_obj->table[0]->header[hdr]);\n\t\t\t}\n\t\t\tif (toggle) gmtapi_flip_vectors (GMT, V_obj, GMT_OUT);\n\t\t\tS_obj->resource = V_obj;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to export data tables\\n\");\n\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->alloc_mode = DH->alloc_mode;\t/* Clarify allocation mode for this entity */\n\tS_obj->status = GMT_IS_USED;\t/* Mark as written */\n\n\treturn GMT_NOERROR;\n}\n\nGMT_LOCAL int gmtapi_import_ppm_header (struct GMT_CTRL *GMT, char *fname, bool close, FILE **fp_ppm, struct GMT_IMAGE *I) {\n\t/* Reads a Portable Pixel Map (PPM) file header if fname extension is .ppm, else returns nonzero value */\n\tchar *ext = gmt_get_ext (fname), text[GMT_LEN128] = {\"\"}, c;\n\tint k = 0, max, n;\n\tFILE *fp = NULL;\n\tif (ext == NULL || strcmp (ext, \"ppm\")) return GMT_NOT_A_VALID_FAMILY;\t/* Not requesting a PPM file - return GMT_NOT_A_VALID_FAMILY and let GDAL take over */\n\n\tif ((fp = gmt_fopen (GMT, fname, GMT->current.io.r_mode)) == NULL) {\t/* Return GMT_ERROR_ON_FOPEN to signify failure */\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot open file %s\\n\", fname);\n\t\treturn GMT_ERROR_ON_FOPEN;\n\t}\n\twhile ((c = fgetc (fp)) != '\\n' && k < GMT_LEN128) text[k++] = c;\t/* Get first record up to newline */\n\ttext[MIN(k,GMT_LEN128-1)] = '\\0';\t/* Terminate line & check that we don't overflow */\n\tif (text[1] == '5') /* Used P5 for grayscale image */\n\t\tI->header->n_bands = 1;\n\telse if (text[1] == '6')\t/* Used P6 for rgb image */\n\t\tI->header->n_bands = 3;\n\telse {\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot decode PPM magic key (%s) from file %s\\n\", text, fname);\n\t\tgmt_fclose (GMT, fp);\n\t\treturn GMT_NOT_A_VALID_TYPE;\n\t}\n\tc = fgetc (fp);\t/* Need to peak ahead to know what record we are dealing with.  PPM can have comments */\n\twhile (c == '#') {\t/* Wind past comment */\n\t\twhile ((c = fgetc (fp)) != '\\n' ) k++;\t/* Ends when c is newline */\n\t\tc = fgetc (fp);\t/* Peak ahead again */\n\t}\n\t/* Put back last read character to the stream */\n\tungetc (c, fp);\n\tk = 0;\n\twhile ((c = fgetc (fp)) != '\\n' && k < GMT_LEN128) text[k++] = c;\t/* Get next record up to newline */\n\ttext[MIN(k,GMT_LEN128-1)] = '\\0';\t/* Terminate line & check that we don't overflow */\n\tn = sscanf (text, \"%d %d %d\", &I->header->n_rows, &I->header->n_columns, &max);\n\tif (n == 2) {\t/* Must skip past a separate record with the max pixel value */\n\t\twhile ((c = fgetc (fp)) != '\\n' ) k++;\n\t}\n\t/* Any read now would start reading the image pixels; done in gmtapi_import_ppm */\n\tI->header->registration = GMT_GRID_PIXEL_REG;\n\tif (GMT->common.R.active[RSET]) {\t/* Got -Rw/e/s/n, we use that as the region for this image */\n\t\tgmt_M_memcpy (I->header->wesn, GMT->common.R.wesn, 4, double);\n\t\tI->header->inc[GMT_X] = gmt_M_get_inc (GMT, I->header->wesn[XLO], I->header->wesn[XHI], I->header->n_columns, GMT_GRID_PIXEL_REG);\n\t\tI->header->inc[GMT_Y] = gmt_M_get_inc (GMT, I->header->wesn[YLO], I->header->wesn[YHI], I->header->n_rows, GMT_GRID_PIXEL_REG);\n\t}\n\telse {\t/* Must just use dimensions to set a dummy -R -I */\n\t\tI->header->wesn[XLO] = I->header->wesn[YLO] = 0.0;\n\t\tI->header->wesn[XHI] = I->header->n_columns;\n\t\tI->header->wesn[YHI] = I->header->n_rows;\n\t\tI->header->inc[GMT_X] = I->header->inc[GMT_Y] = 1.0;\n\t}\n\tgmt_M_memset (I->header->pad, 4, unsigned int);\n\tgmt_set_grddim (GMT, I->header);\t/* Update all header dimensions */\n\tstrcpy (I->header->mem_layout, \"TRP\");\t/* Layout use in all PPM files */\n\tif (close)\t/* Close file, we only wanted the header information */\n\t\tgmt_fclose (GMT, fp);\n\telse\t/* Pass back FILE pointers since we want to read the rest as well */\n\t\t*fp_ppm = fp;\n\treturn GMT_NOERROR;\n}\n\nGMT_LOCAL int gmtapi_import_ppm (struct GMT_CTRL *GMT, char *fname, struct GMT_IMAGE *I) {\n\t/* Reads a Portable Pixel Map (PPM) file if fname extension is .ppm, else returns 1 */\n\tFILE *fp = NULL;\n\tsize_t size;\n\n\tif (gmtapi_import_ppm_header (GMT, fname, false, &fp, I)) return GMT_NOT_A_VALID_FAMILY;\t/* Not a PPM */\n\t/* Now read the image in scanline order, with each pixel as (R, G, B) or (gray) */\n\tsize = I->header->nm * I->header->n_bands;\n\tif (fread (I->data, sizeof(char), size, fp) != size) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Failed to read the image from %s\\n\", fname);\n\t\tgmt_fclose (GMT, fp);\n\t\treturn GMT_IMAGE_READ_ERROR;\n\t}\n\tgmt_fclose (GMT, fp);\n\treturn GMT_NOERROR;\n}\n\n#ifdef HAVE_GDAL\nGMT_LOCAL bool gmtapi_expand_index_image (struct GMT_CTRL *GMT, struct GMT_IMAGE *I_in, struct GMT_IMAGE **I_out) {\n\t/* In most situations we can use an input image given to a module as the dataset to\n\t * plot.  However, if the image is indexed then we must expand it to rgb since we may\n\t * need to interpolate the r/g/b planes due to projections. If the image is read-only\n\t * then we cannot reallocate the array and must duplicate, otherwise we reallocate the\n\t * image array and expand to rgb.  This function is called at the end of gmtapi_import_image\n\t * if the GMT_IMAGE_NO_INDEX bitflag is passed. The image layout honors the current setting\n\t * of API_IMAGE_LAYOUT. */\n\tbool new = false;\n\tunsigned char *data = NULL;\n\tuint64_t node, off[3];\n\tunsigned int start_c, c, index;\n\tstruct GMT_IMAGE *I = NULL;\n\tstruct GMT_IMAGE_HIDDEN *IH = gmt_get_I_hidden (I_in);\n\tstruct GMT_GRID_HEADER *h = I_in->header;\n\n\tif (I_in->n_indexed_colors == 0) {\t/* Regular gray or r/g/b image - use as is */\n\t\t(*I_out) = I_in;\n\t\treturn (false);\n\t}\n\t/* Here we have an indexed image */\n\tif (IH->alloc_mode == GMT_ALLOC_EXTERNALLY) {\t/* Cannot reallocate a non-GMT read-only input array */\n\t\tif ((I = GMT_Duplicate_Data (GMT->parent, GMT_IS_IMAGE, GMT_DUPLICATE_DATA, I_in)) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Unable to duplicate image! - this is not a good thing and may crash this module\\n\");\n\t\t\t(*I_out) = I_in;\n\t\t}\n\t\telse {\n\t\t\tstruct GMT_IMAGE_HIDDEN *IH = gmt_get_I_hidden (I);\n\t\t\tIH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t}\n\t\tnew = true;\n\t}\n\telse\t/* Here we may overwrite the input image and just pass the pointer back */\n\t\tI = I_in;\n\n\t/* Here, I is an image we can reallocate the array when expanding the colors */\n\n\th = I->header;\n\tdata = gmt_M_memory_aligned (GMT, NULL, h->size * 3, unsigned char);\t/* The new r,g,b image */\n\n\tif (GMT->parent->GMT->current.gdal_read_in.O.mem_layout[0] && strncmp (GMT->parent->GMT->current.gdal_read_in.O.mem_layout, \"TRB\", 3U) == 0) {\t/* Band interleave */\n\t\tstrncpy (h->mem_layout, \"TRB \", 4);\t/* Fill out red, green, and blue bands */\n\t\tfor (c = 0; c < 3; c++) off[c] = c * h->size;\n\t\tfor (node = 0; node < h->size; node++) {\t/* For all pixels, including the pad */\n\t\t\tindex = I->data[node];\t/* Pixel index into color table */\n\t\t\tstart_c = index * 4;\t/* Start of the r,g,b entry in the color table for this index */\n\t\t\tfor (c = 0; c < 3; c++) data[node+off[c]] = I->colormap[start_c+c];\t/* Place r,g,b in separate bands */\n\t\t}\n\t}\n\telse {\t/* Pixel interleave */\n\t\tuint64_t k;\n\t\tstrncpy (h->mem_layout, \"TRP \", 4);\t/* Fill out red, green, and blue pixels */\n\t\tfor (node = k = 0; node < h->size; node++) {\t/* For all pixels, including the pad */\n\t\t\tindex = I->data[node];\t/* Pixel index into color table */\n\t\t\tstart_c = index * 4;\t/* Start of the r,g,b entry in the color table for this index */\n\t\t\tfor (c = 0; c < 3; c++, k++) data[k] = I->colormap[start_c+c];\t/* Place r,g,b in separate bands */\n\t\t}\n\t\t/* If neither TRB or TRP we call for a changed layout, which may or may not have been implemented */\n\t\tGMT_Change_Layout (GMT->parent, GMT_IS_IMAGE, GMT->parent->GMT->current.gdal_read_in.O.mem_layout, 0, I, NULL, NULL);\n\t}\n\tgmt_M_free_aligned (GMT, I->data);\t/* Free previous aligned image memory */\n\tI->data = data;\t/* Pass the reallocated rgb TRB image back */\n\t/* Reset meta data to reflect a regular 3-band r,g,b image */\n\th->n_bands = 3;\n\tI->n_indexed_colors = 0;\n\tgmt_M_free (GMT, I->colormap);\t/* Free the colormap */\n\tI->color_interp = NULL;\n\n\t(*I_out) = I;\n\treturn (new);\n}\n\nint gmtlib_ind2rgb (struct GMT_CTRL *GMT, struct GMT_IMAGE **I_in) {\n\t/* Convert an indexed image to RGB. Other than indirect calls to gmtapi_expand_index_image, e.g., the one\n\t   called by gmtapi_import_image, there are other cases when we need also to convert from indexed to RGB.\n\t   For example in grdimage when the image was sent in via an external wrapper. In this case the code flow goes\n\t   through gmtapi_get_image_data() (in GMT_Read_Data -> gmtapi_pass_object (API, S_obj, family, mode, wesn))\n\t   and deliver that Image object directly to the calling module amd may thus have indexed pixels.\n\t*/\n\tstruct GMT_IMAGE* Irgb = NULL;\n\tif ((*I_in)->header->n_bands == 1 && (*I_in)->n_indexed_colors > 0) {\t\t/* Indexed image, convert to RGB */\n\t\tgmtapi_expand_index_image (GMT, *I_in, &Irgb);\t/* true if we have a read-only indexed image and we had to allocate a new one */\n\t\tif (GMT_Destroy_Data (GMT->parent, I_in) != GMT_NOERROR) {\n\t\t\tgmtlib_report_error(GMT->parent, GMT->parent->error);\n\t\t\treturn GMT->parent->error;\n\t\t}\n\t\t(*I_in) = Irgb;\n\t}\n\treturn GMT_NOERROR;\n}\n#endif\n\n/*! . */\nGMT_LOCAL struct GMT_IMAGE *gmtapi_import_image (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_IMAGE *image) {\n\t/* Handles the reading of a 2-D image given in one of several ways.\n\t * Get the entire image:\n \t * \tmode = GMT_CONTAINER_AND_DATA reads both header and image;\n\t * Get a subset of the image:  Call gmtapi_import_image twice:\n\t * \t1. first with mode = GMT_CONTAINER_ONLY which reads header only.  Then, pass\n\t *\t   the new S_obj-> wesn to match your desired subregion\n\t *\t2. 2nd with mode = GMT_DATA_ONLY, which reads image based on header's settings\n\t * If the image->data array is NULL it will be allocated for you.\n\t */\n\n\tint item, new_item, new_ID;\n\tbool done = true, via = false, must_be_image = true, no_index = false;\n\tuint64_t i0, i1, j0, j1, ij, ij_orig, row, col;\n\tunsigned int both_set = (GMT_CONTAINER_ONLY | GMT_DATA_ONLY);\n\tdouble dx, dy, d;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_getfunction api_get_val = NULL;\n\tstruct GMT_IMAGE *I_obj = NULL, *I_orig = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_MATRIX_HIDDEN  *MH = NULL;\n\tstruct GMT_IMAGE_HIDDEN *IH = NULL;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n#ifdef HAVE_GDAL\n\tbool new = false;\n\tsize_t size;\n\tstruct GMT_IMAGE *Irgb = NULL;\n#endif\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_image: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif ((item = gmtlib_validate_id (API, GMT_IS_IMAGE, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET) return_null (API, API->error);\n\n\tS_obj = API->object[item];\t\t/* Current data object */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET))\n\t\treturn_null (API, GMT_READ_ONCE);\t/* Already read this resources before, so fail unless overridden by mode */\n\tif ((mode & GMT_IMAGE_NO_INDEX)) no_index = true, mode -= GMT_IMAGE_NO_INDEX;\t/* Must expand any index to rgb */\n\tif ((mode & both_set) == both_set) mode -= both_set;\t/* Allow users to have set GMT_CONTAINER_ONLY | GMT_DATA_ONLY; reset to GMT_CONTAINER_AND_DATA */\n\tif ((mode & GMT_GRID_IS_IMAGE) == GMT_GRID_IS_IMAGE) {\t/* Only allowed when fishing the image header and it may in fact be a grid */\n\t\tif (mode & GMT_DATA_ONLY) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Cannot pass mode = GMT_GRID_IS_IMAGE when reading the image for file %s\\n\", S_obj->filename);\n\t\t\treturn_null (API, GMT_IMAGE_READ_ERROR);\n\t\t}\n\t\tmode -= GMT_GRID_IS_IMAGE;\n\t\tmust_be_image = false;\n\t}\n\n\tswitch (S_obj->method) {\n\t\tcase GMT_IS_FILE:\t/* Name of an image file on disk */\n#ifdef HAVE_GDAL\n\t\t\tif (image == NULL) {\t/* Only allocate image struct when not already allocated */\n\t\t\t\tif (mode & GMT_DATA_ONLY) return_null (API, GMT_NO_GRDHEADER);\t\t/* For mode & GMT_DATA_ONLY image must already be allocated */\n\t\t\t\tI_obj = gmtlib_create_image (GMT);\n\t\t\t\tnew = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tI_obj = image;\t/* We are passing in an image already allocated */\n\t\t\tHH = gmt_get_H_hidden (I_obj->header);\n\t\t\tI_obj->header->complex_mode = (mode & GMT_GRID_IS_COMPLEX_MASK);\t\t/* Pass on any bitflags */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read image */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\t\t/* Must init header and read the header information from file */\n\t\t\t\tif (gmtapi_import_ppm_header (GMT, S_obj->filename, true, NULL, I_obj) == GMT_NOERROR)\n\t\t\t\t\td = 0.0;\t/* Placeholder */\n\t\t\t\telse if (gmt_M_err_pass (GMT, gmtlib_read_image_info (GMT, S_obj->filename, must_be_image, I_obj), S_obj->filename)) {\n\t\t\t\t\tif (new) gmtlib_free_image (GMT, &I_obj, false);\n\t\t\t\t\treturn_null (API, GMT_IMAGE_READ_ERROR);\n\t\t\t\t}\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header, get out of here */\n\t\t\t}\n\t\t\t/* Here we will read the image data themselves. */\n\t\t\t/* To get a subset we use wesn that is not NULL or contain 0/0/0/0.\n\t\t\t * Otherwise we extract the entire file domain */\n\t\t\tif (!I_obj->data) {\t/* Array is not allocated yet, do so now. We only expect header (and possibly w/e/s/n subset) to have been set correctly */\n\t\t\t\tif (I_obj->type <= GMT_UCHAR)\n\t\t\t\t\tI_obj->data = gmt_M_memory (GMT, NULL, I_obj->header->size * I_obj->header->n_bands, unsigned char);\n\t\t\t\telse if (I_obj->type <= GMT_USHORT)\n\t\t\t\t\tI_obj->data = gmt_M_memory (GMT, NULL, I_obj->header->size * I_obj->header->n_bands, unsigned short);\n\t\t\t\telse if (I_obj->type <= GMT_UINT)\n\t\t\t\t\tI_obj->data = gmt_M_memory (GMT, NULL, I_obj->header->size * I_obj->header->n_bands, unsigned int);\n\t\t\t\telse {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unsupported image data type %d\\n\", I_obj->type);\n\t\t\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t/* Already have allocated space; check that it is enough */\n\t\t\t\tsize = gmtapi_set_grdarray_size (GMT, I_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which includes padding. DANGER DANGER JL*/\n\t\t\t\tif (size > I_obj->header->size) return_null (API, GMT_IMAGE_READ_ERROR);\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading image from file %s\\n\", S_obj->filename);\n\t\t\tif (gmtapi_import_ppm (GMT, S_obj->filename, I_obj) == GMT_NOERROR)\n\t\t\t\td = 0.0;\t/* Placeholder */\n\t\t\telse if (gmt_M_err_pass (GMT, gmtlib_read_image (GMT, S_obj->filename, I_obj, S_obj->wesn,\n\t\t\t\tI_obj->header->pad, mode), S_obj->filename))\n\t\t\t\treturn_null (API, GMT_IMAGE_READ_ERROR);\n\t\t\tif (gmt_M_err_pass (GMT, gmtlib_image_BC_set (GMT, I_obj), S_obj->filename))\n\t\t\t\treturn_null (API, GMT_IMAGE_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tIH = gmt_get_I_hidden (I_obj);\n\t\t\tIH->alloc_mode = GMT_ALLOC_INTERNALLY;\n#else\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GDAL required to read image from file %s\\n\", S_obj->filename);\n#endif\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* GMT image and header in a GMT_IMAGE container object. */\n\t\t\tif ((I_orig = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (image == NULL) {\t/* Only allocate when not already allocated */\n\t\t\t\tif (mode & GMT_DATA_ONLY) return_null (API, GMT_NO_GRDHEADER);\t\t/* For mode & GMT_DATA_ONLY image must already be allocated */\n\t\t\t\tI_obj = gmtlib_create_image (GMT);\n\t\t\t}\n\t\t\telse\n\t\t\t\tI_obj = image;\t/* We are passing in an image already */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read image */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\t/* Must init header and copy the header information from the existing image */\n\t\t\t\tgmt_copy_gridheader (GMT, I_obj->header, I_orig->header);\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header, get out of here */\n\t\t\t}\n\t\t\t/* Here we will read image data. */\n\t\t\t/* To get a subset we use wesn that is not NULL or contain 0/0/0/0.\n\t\t\t * Otherwise we use everything passed in */\n\t\t\tif (!I_obj->data) {\t/* Array is not allocated, do so now. We only expect header (and possibly subset w/e/s/n) to have been set correctly */\n\t\t\t\tI_obj->header->size = gmtapi_set_grdarray_size (GMT, I_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which may include padding */\n\t\t\t\tI_obj->data = gmt_M_memory (GMT, NULL, I_obj->header->size * I_obj->header->n_bands, unsigned char);\n\t\t\t\tif (I_orig->alpha) I_obj->alpha = gmt_M_memory (GMT, NULL, I_obj->header->size , unsigned char);\n\t\t\t}\n\t\t\tIH = gmt_get_I_hidden (I_obj);\n\t\t\tIH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tif (!S_obj->region && gmt_grd_pad_status (GMT, I_obj->header, GMT->current.io.pad)) {\t/* Want an exact copy with no subset and same padding */\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating image data from GMT_IMAGE memory location\\n\");\n\t\t\t\tgmt_M_memcpy (I_obj->data, I_orig->data, I_orig->header->size * I_orig->header->n_bands, char);\n\t\t\t\tif (I_orig->alpha) gmt_M_memcpy (I_obj->alpha, I_orig->alpha, I_orig->header->size, char);\n\t\t\t\tbreak;\t\t/* Done with this image */\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Extracting subset image data from GMT_IMAGE memory location\\n\");\n\t\t\t/* Here we need to do more work: Either extract subset or add/change padding, or both. */\n\t\t\t/* Get start/stop row/cols for subset (or the entire domain) */\n\t\t\t/* dx,dy are needed when the image is pixel-registered as the w/e/s/n bounds are off by 0.5 {dx,dy} relative to node coordinates */\n\t\t\tdx = I_obj->header->inc[GMT_X] * I_obj->header->xy_off;\tdy = I_obj->header->inc[GMT_Y] * I_obj->header->xy_off;\n\t\t\tj1 = (uint64_t) gmt_M_grd_y_to_row (GMT, I_obj->header->wesn[YLO]+dy, I_orig->header);\n\t\t\tj0 = (uint64_t) gmt_M_grd_y_to_row (GMT, I_obj->header->wesn[YHI]-dy, I_orig->header);\n\t\t\ti0 = (uint64_t) gmt_M_grd_x_to_col (GMT, I_obj->header->wesn[XLO]+dx, I_orig->header);\n\t\t\ti1 = (uint64_t) gmt_M_grd_x_to_col (GMT, I_obj->header->wesn[XHI]-dx, I_orig->header);\n\t\t\tgmt_M_memcpy (I_obj->header->pad, GMT->current.io.pad, 4, int);\t/* Set desired padding */\n\t\t\tfor (row = j0; row <= j1; row++) {\n\t\t\t\tfor (col = i0; col <= i1; col++, ij++) {\n\t\t\t\t\tij_orig = gmt_M_ijp (I_orig->header, row, col);\t/* Position of this (row,col) in original image organization */\n\t\t\t\t\tij = gmt_M_ijp (I_obj->header, row, col);\t\t/* Position of this (row,col) in output image organization */\n\t\t\t\t\tI_obj->data[ij] = I_orig->data[ij_orig];\n\t\t\t\t\tif (I_orig->alpha) I_obj->alpha[ij] = I_orig->alpha[ij_orig];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE:\t/* GMT image and header in a GMT_IMAGE container object by reference */\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing image data from GMT_IMAGE memory location\\n\");\n\t\t\tif ((I_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read image */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_image: Change alloc mode\\n\");\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_image: Check pad\\n\");\n\t\t\tif (!gmtapi_adjust_grdpadding (I_obj->header, GMT->current.io.pad)) break;\t/* Pad is correct so we are done */\n\t\t\t/* Here we extend G_obj->data to allow for padding, then rearrange rows, but only if item was allocated by GMT */\n\t\t\tIH = gmt_get_I_hidden (I_obj);\n\t\t\tif (IH->alloc_mode == GMT_ALLOC_EXTERNALLY) return_null (API, GMT_PADDING_NOT_ALLOWED);\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_image: Add pad\\n\");\n#if 0\n\t\t\tgmt_grd_pad_on (GMT, image, GMT->current.io.pad);\n#endif\n\t\t\tif (done && S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tHH = gmt_get_H_hidden (I_obj->header);\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory image */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, I_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = HH->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, I_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = HH->reset_pad = 1;\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_image: Return from GMT_IS_REFERENCE\\n\");\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* The user's 2-D image array of some sort, + info in the args [NOT YET FULLY TESTED] */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tI_obj = (image == NULL) ? gmtlib_create_image (GMT) : image;\t/* Only allocate when not already allocated */\n\t\t\tHH = gmt_get_H_hidden (I_obj->header);\n\t\t\tI_obj->header->complex_mode = (mode & GMT_GRID_IS_COMPLEX_MASK);\t/* Set the complex mode */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\n\t\t\t\tgmtapi_matrixinfo_to_grdheader (GMT, I_obj->header, M_obj);\t/* Populate a GRD header structure */\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header */\n\t\t\t}\n\t\t\tIH = gmt_get_I_hidden (I_obj);\n\t\t\tIH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\t/* Must convert to new array */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Importing image data from user memory location\\n\");\n\t\t\tgmt_set_grddim (GMT, I_obj->header);\t/* Set all dimensions */\n\t\t\tI_obj->data = gmt_M_memory (GMT, NULL, I_obj->header->size, unsigned char);\n\t\t\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL)) == NULL)\n\t\t\t\treturn_null (API, GMT_WRONG_MATRIX_SHAPE);\n\t\t\tif ((api_get_val = gmtapi_select_get_function (API, M_obj->type)) == NULL)\n\t\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tgmt_M_grd_loop (GMT, I_obj, row, col, ij) {\n\t\t\t\tij_orig = GMT_2D_to_index (row, col, M_obj->dim);\n\t\t\t\tapi_get_val (&(M_obj->data), ij_orig, &d);\n\t\t\t\tI_obj->data[ij] = (char)d;\n\t\t\t}\n\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_IMAGE, GMT_IS_DUPLICATE, S_obj->geometry, GMT_IN, NULL, I_obj);\t/* Register a new resource to hold I_obj */\n\t\t\tif ((new_item = gmtlib_validate_id (API, GMT_IS_IMAGE, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\tAPI->object[new_item]->resource = I_obj;\n\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\tAPI->object[new_item]->method = S_obj->method;\n\t\t\tIH->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\tvia = true;\n\t\t\tif (S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory image */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, I_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = HH->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, I_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = HH->reset_pad = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\t/* The user's 2-D image array of some sort, + info in the args [NOT YET FULLY TESTED] */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tI_obj = (image == NULL) ? gmtlib_create_image (GMT) : image;\t/* Only allocate when not already allocated */\n\t\t\tHH = gmt_get_H_hidden (I_obj->header);\n\t\t\tI_obj->header->complex_mode = (mode & GMT_GRID_IS_COMPLEX_MASK);\t/* Set the complex mode */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\n\t\t\t\tgmtapi_matrixinfo_to_grdheader (GMT, I_obj->header, M_obj);\t/* Populate a GRD header structure */\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header */\n\t\t\t}\n\t\t\tMH = gmt_get_M_hidden (M_obj);\n\t\t\tif (!(M_obj->shape == GMT_IS_ROW_FORMAT && M_obj->type == GMT_FLOAT && MH->alloc_mode == GMT_ALLOC_EXTERNALLY && (mode & GMT_GRID_IS_COMPLEX_MASK))) {\n\t\t\t\treturn_null (API, GMT_NOT_A_VALID_IO_ACCESS);\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing image data from user memory location\\n\");\n\t\t\tIH = gmt_get_I_hidden (I_obj);\n\t\t\tI_obj->data = (unsigned char *)(M_obj->data.sc1);\n\t\t\tS_obj->alloc_mode = MH->alloc_mode;\t/* Pass on allocation mode of matrix */\n\t\t\tIH->alloc_mode = MH->alloc_mode;\n\t\t\tif (!gmtapi_adjust_grdpadding (I_obj->header, GMT->current.io.pad)) break;\t/* Pad is correct so we are done */\n\t\t\tif (IH->alloc_mode == GMT_ALLOC_EXTERNALLY) {\n\t\t\t\treturn_null (API, GMT_PADDING_NOT_ALLOWED);\n\t\t\t}\n\t\t\t/* Here we extend I_obj->data to allow for padding, then rearrange rows */\n\t\t\t/* gmt_grd_pad_on (GMT, I, GMT->current.io.pad);*/\n\t\t\tnew_ID = GMT_Register_IO (API, GMT_IS_IMAGE, GMT_IS_REFERENCE, S_obj->geometry, GMT_IN, NULL, I_obj);\t/* Register a new resource to hold I_obj */\n\t\t\tif ((new_item = gmtlib_validate_id (API, GMT_IS_IMAGE, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Some internal error... */\n\t\t\tAPI->object[new_item]->resource = I_obj;\n\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\tIH->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\tvia = true;\n\t\t\tif (S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory image */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, I_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = HH->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, I_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = HH->reset_pad = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to import image\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\tif ((mode & GMT_CONTAINER_ONLY) == 0) {\t/* Also allocate and initialize the x and y vectors */\n\t\tI_obj->x = gmtapi_image_coord (API, GMT_X, I_obj);\t/* Get array of x coordinates */\n\t\tI_obj->y = gmtapi_image_coord (API, GMT_Y, I_obj);\t/* Get array of y coordinates */\n\t}\n\n\tif (done) S_obj->status = GMT_IS_USED;\t/* Mark as read (unless we just got the header) */\n\n#ifdef HAVE_GDAL\n\tif (no_index && gmtapi_expand_index_image (API->GMT, I_obj, &Irgb)) {\t/* true if we have a read-only indexed image and we had to allocate a new one */\n\t\tif (GMT_Destroy_Data (API, &I_obj) != GMT_NOERROR) {\n\t\t\treturn_null (API, API->error);\n\t\t}\n\t\tI_obj = Irgb;\n\t}\n#endif\n\n\tif (!via) S_obj->resource = I_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\n\treturn (I_obj);\t/* Pass back out what we have so far */\n}\n\nGMT_LOCAL int gmtapi_export_ppm (struct GMT_CTRL *GMT, char *fname, struct GMT_IMAGE *I) {\n\t/* Write a Portable Pixel Map (PPM) file if fname extension is .ppm, else returns 1.\n\t * We assume there is no pad, otherwise the pad will be part of the image on output. */\n\t//uint32_t row, col, band;\n\tstatic char *comment = \"# Produced by GMT\\n\";\n\tchar *ext = gmt_get_ext (fname), dim[GMT_LEN32] = {\"\"};\n\tsize_t n;\n\tFILE *fp = NULL;\n\tif (ext == NULL || strcmp (ext, \"ppm\")) return GMT_NOT_A_VALID_FAMILY;\t/* Not requesting a PPM file - return GMT_NOT_A_VALID_FAMILY and let GDAL take over */\n\n\tif ((fp = gmt_fopen (GMT, fname, GMT->current.io.w_mode)) == NULL) {\t/* Return GMT_ERROR_ON_FOPEN to signify failure */\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot create PPM file %s\\n\", fname);\n\t\treturn GMT_ERROR_ON_FOPEN;\n\t}\n\tif (I->header->n_bands == 1) /* Use P5 for grayscale image */\n\t\tn = fwrite (\"P5\\n\", sizeof (char), 3U, fp);\t/* Write magic number, linefeed */\n\telse\t/* Use P6 for rgb image */\n\t\tn = fwrite (\"P6\\n\", sizeof (char), 3U, fp);\t/* Write magic number, linefeed */\n\tif (n != 3U) {\n\t\tgmt_fclose (GMT, fp);\n\t\treturn GMT_IMAGE_WRITE_ERROR;\n\t}\n\tn = strlen (comment);\n\tif (fwrite (comment, sizeof (char), n, fp) != n) {\n\t\tgmt_fclose (GMT, fp);\n\t\treturn GMT_IMAGE_WRITE_ERROR;\t/* Write comment and linefeed */\n\t}\n\tsnprintf (dim, GMT_LEN32, \"%d %d\\n255\\n\", I->header->mx, I->header->my);\n\tn = strlen (dim);\n\tif (fwrite (dim, sizeof (char), n, fp) != n) return GMT_IMAGE_WRITE_ERROR;\t/* Write dimensions and max color value + linefeeds */\n\t/* Now dump the image in scanline order, with each pixel as (R, G, B) */\n\tif (I->alpha)\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Alpha-channel not supported by PPM format - ignored\\n\");\n\tn = I->header->size * I->header->n_bands;\n\tif (!strncmp (I->header->mem_layout, \"TRP\", 3U)) { /* Easy street! */\n\t\tif (fwrite (I->data, sizeof(char), n, fp) != n) {\n\t\t\tgmt_fclose (GMT, fp);\n\t\t\treturn GMT_IMAGE_WRITE_ERROR;\n\t\t}\n\t}\n\telse {\t/* Must change image layout first as PPM is strictly TRP */\n\t\tchar *data = NULL;\n\t\tGMT_Report (GMT->parent, GMT_MSG_VERBOSE, \"Must convert image from %s to TRP in order to write PPM file\\n\", I->header->mem_layout);\n\t\tif ((data = gmt_M_memory_aligned (GMT, NULL, n, char)) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Unable to allocate image memory in gmtapi_export_ppm to force TRP format - written as is\\n\");\n\t\t\tif (fwrite (I->data, sizeof(char), n, fp) != n) {\n\t\t\t\tgmt_fclose (GMT, fp);\n\t\t\t\treturn GMT_IMAGE_WRITE_ERROR;\n\t\t\t}\n\t\t}\n\t\telse {\t/* Convert from TRB to TRP */\n\t\t\tGMT_Change_Layout (GMT->parent, GMT_IS_IMAGE, \"TRP\", 0, I, data, NULL);\n\t\t\tif (fwrite (data, sizeof(char), n, fp) != n) return GMT_IMAGE_WRITE_ERROR;\n\t\t\tgmt_M_free_aligned (GMT, data);\n\t\t}\n\t}\n\tgmt_fclose (GMT, fp);\n\n\treturn GMT_NOERROR;\n}\n\n/*! Writes out a single image to destination */\nGMT_LOCAL int gmtapi_export_image (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_IMAGE *I_obj) {\n\tint item, error;\n\tbool done = true;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_IMAGE *I_copy = NULL;\n\tstruct GMT_IMAGE_HIDDEN *IH = gmt_get_I_hidden (I_obj);\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_export_image: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtlib_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif (I_obj->data == NULL && !(mode & GMT_CONTAINER_ONLY)) return (gmtlib_report_error (API, GMT_PTR_IS_NULL));\n\tif ((item = gmtlib_validate_id (API, GMT_IS_IMAGE, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtlib_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* The current object whose data we will export */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET))\n\t\treturn (gmtlib_report_error (API, GMT_WRITTEN_ONCE));\t/* Only allow writing of a data set once, unless overridden by mode */\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\tswitch (S_obj->method) {\n\t\tcase GMT_IS_FILE:\t/* Name of an image file on disk */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Writing image to file %s\\n\", S_obj->filename);\n\t\t\tif ((error = gmtapi_export_ppm (API->GMT, S_obj->filename, I_obj)) == GMT_NOERROR)\n\t\t\t\tbreak;\t/* OK, wrote a PPM and we are done */\n\t\t\telse if (error == GMT_ERROR_ON_FOPEN) {\t/* Failed to open file */\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to export image\\n\");\n\t\t\t\treturn (gmtlib_report_error (API, GMT_ERROR_ON_FOPEN));\n\t\t\t}\n#ifdef HAVE_GDAL\n\t\t\telse if (gmt_M_err_pass (API->GMT, gmt_export_image (API->GMT, S_obj->filename, I_obj), S_obj->filename))\n\t\t\t\treturn (gmtlib_report_error (API, GMT_IMAGE_WRITE_ERROR));\n#else\n\t\t\telse\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GDAL required to write image to file %s\\n\", S_obj->filename);\n#endif\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* Duplicate GMT image to a new GMT_IMAGE container object */\n\t\t\tif (S_obj->resource) return (gmtlib_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource pointer must be NULL */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtlib_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating image data to GMT_IMAGE memory location\\n\");\n\t\t\tif ((I_copy = GMT_Duplicate_Data (API, GMT_IS_IMAGE, mode, I_obj)) == NULL)\n\t\t\t\treturn (gmtlib_report_error (API, GMT_MEMORY_ERROR));\n\t\t\tS_obj->resource = I_copy;\t/* Set resource pointer to the image */\n\t\t\tbreak;\t\t/* Done with this image */\n\n\t \tcase GMT_IS_REFERENCE:\t/* GMT image and header in a GMT_IMAGE container object - just pass the reference */\n\t\t\tif (S_obj->region) return (gmtlib_report_error (API, GMT_SUBSET_NOT_ALLOWED));\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtlib_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing image data to GMT_IMAGE memory location\\n\");\n\t\t\tS_obj->resource = I_obj;\t/* Set resource pointer to the image */\n\t\t\tIH->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to export image\\n\");\n\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\n\tif (done) S_obj->status = GMT_IS_USED;\t/* Mark as written (unless we only updated header) */\n\n\treturn (GMT_NOERROR);\n}\n\nunsigned int gmt_whole_earth (struct GMT_CTRL *GMT, double we_in[], double we_out[]) {\n\t/* Determines if this is a global geographic grid and we want the whole world, regardless of central longitude */\n\tif (!gmt_M_is_geographic (GMT, GMT_IN)) return 0;\n\tif (!gmt_M_360_range (we_in[XLO],  we_in[XHI])) return 0;\n\tif (!gmt_M_360_range (we_out[XLO], we_out[XHI])) return 0;\n\tif (doubleAlmostEqualZero (we_in[XLO], we_out[XLO])) return 2;\t/* Both regions are the same */\n\treturn 1;\t/* Different central meridians */\n}\n\n/*! . */\nGMT_LOCAL struct GMT_GRID *gmtapi_import_grid (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_GRID *grid) {\n\t/* Handles the reading of a 2-D grid given in one of several ways.\n\t * Get the entire grid:\n \t * \tmode = GMT_CONTAINER_AND_DATA reads both header and grid;\n\t * Get a subset of the grid:  Call gmtapi_import_grid twice:\n\t * \t1. first with mode = GMT_CONTAINER_ONLY which reads header only.  Then, pass\n\t *\t   the new S_obj-> wesn to match your desired subregion\n\t *\t2. 2nd with mode = GMT_DATA_ONLY, which reads grid based on header's settings\n\t * If the grid->data array is NULL it will be allocated for you.\n\t */\n\n\tint item, new_item, new_ID;\n\tbool done = true, new = false, row_by_row;\n \tuint64_t row, col, kol, row_out, i0, i1, j0, j1, ij, ij_orig;\n\tsize_t size;\n\tunsigned int both_set = (GMT_CONTAINER_ONLY | GMT_DATA_ONLY);\n\tunsigned int method, start_over_method = 0;\n\tdouble dx, dy, d;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tstruct GMT_GRID *G_obj = NULL, *G_orig = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_MATRIX_HIDDEN *MH = NULL;\n\tstruct GMT_GRID_HIDDEN *GH = NULL;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tGMT_getfunction api_get_val = NULL;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_grid: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif ((item = gmtlib_validate_id (API, GMT_IS_GRID, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET) return_null (API, API->error);\n\n\tS_obj = API->object[item];\t\t/* Current data object */\n\tif (S_obj->status != GMT_IS_UNUSED && S_obj->method == GMT_IS_FILE && !(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Already read this file before, so fail unless overridden by mode */\n\tif ((mode & both_set) == both_set) mode -= both_set;\t/* Allow users to have set GMT_CONTAINER_ONLY | GMT_DATA_ONLY; reset to GMT_CONTAINER_AND_DATA */\n\trow_by_row = ((mode & GMT_GRID_ROW_BY_ROW) || (mode & GMT_GRID_ROW_BY_ROW_MANUAL));\n\tif (row_by_row && S_obj->method != GMT_IS_FILE) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Can only use method GMT_IS_FILE when row-by-row reading of grid is selected\\n\");\n\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t}\n\tif ((mode & GMT_CONTAINER_ONLY) && S_obj->region && S_obj->method == GMT_IS_FILE) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Cannot request a subset when just inquiring about the grid header\\n\");\n\t\treturn_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t}\n\n\tif (S_obj->region && grid) {\t/* See if this is really a subset or just the same region as the grid */\n\t\tif (grid->header->wesn[XLO] == S_obj->wesn[XLO] && grid->header->wesn[XHI] == S_obj->wesn[XHI] && grid->header->wesn[YLO] == S_obj->wesn[YLO] && grid->header->wesn[YHI] == S_obj->wesn[YHI]) S_obj->region = false;\n\t}\n\tmethod = gmtapi_set_method (S_obj);\t/* Get the actual method to use since may be MATRIX or VECTOR masquerading as GRID */\n\nstart_over_import_grid:\t\t/* We may get here if we cannot honor a GMT_IS_REFERENCE from below */\n\n\tswitch (method) {\n\t\t/* Status: This case is fully tested and operational */\n\t\tcase GMT_IS_FILE:\t/* Name of a grid file on disk */\n\t\t\tif (gmt_file_is_tiled_list (API, S_obj->filename, NULL, NULL, NULL)) {\t/* Special list file */\n\t\t\t\tif (grid == NULL) {\t/* Only allocate grid struct when not already allocated */\n\t\t\t\t\tif ((G_obj = gmtlib_assemble_tiles (API, NULL, S_obj->filename)) == NULL)\n\t\t\t\t\t\treturn_null (API, GMT_GRID_READ_ERROR);\n\t\t\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), S_obj->filename))\n\t\t\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\t\t\tGH = gmt_get_G_hidden (G_obj);\n\t\t\t\t\tGH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tG_obj = grid;\t/* We are working on a srtm grid already allocated and here we also read the data so nothing to do */\n\t\t\t\tS_obj->resource = G_obj;\t/* Set resource pointer to the grid */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* When source is an actual file we place the grid container into the S_obj->resource slot; no new object required */\n\t\t\tif (grid == NULL) {\t/* Only allocate grid struct when not already allocated */\n\t\t\t\tif (mode & GMT_DATA_ONLY) return_null (API, GMT_NO_GRDHEADER);\t\t/* For mode & GMT_DATA_ONLY grid must already be allocated */\n\t\t\t\tG_obj = gmt_create_grid (GMT);\n\t\t\t\tnew = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tG_obj = grid;\t/* We are working on a grid already allocated */\n\t\t\tS_obj->resource = G_obj;\t/* Set resource pointer to the grid */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read grid */\n\t\t\tGH = gmt_get_G_hidden (G_obj);\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\t\t/* Must init header and read the header information from file */\n\t\t\t\tif (row_by_row) {\t/* Special row-by-row processing mode */\n\t\t\t\t\tchar r_mode = (mode & GMT_GRID_NO_HEADER) ? 'R' : 'r';\n\t\t\t\t\t/* If we get here more than once we only allocate extra once */\n\t\t\t\t\tif (GH->extra == NULL) GH->extra = gmt_M_memory (GMT, NULL, 1, struct GMT_GRID_ROWBYROW);\n\t\t\t\t\tif (gmtapi_open_grd (GMT, S_obj->filename, G_obj, r_mode, mode)) {\t/* Open the grid for incremental row reading */\n\t\t\t\t\t\tif (new) gmt_free_grid (GMT, &G_obj, false);\n\t\t\t\t\t\treturn_null (API, GMT_GRID_READ_ERROR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (gmt_M_err_pass (GMT, gmtlib_read_grd_info (GMT, S_obj->filename, G_obj->header), S_obj->filename)) {\n\t\t\t\t\tif (new) gmt_free_grid (GMT, &G_obj, false);\n\t\t\t\t\treturn_null (API, GMT_GRID_READ_ERROR);\n\t\t\t\t}\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header, get out of here */\n\t\t\t}\n\t\t\t/* Here we will read the grid data themselves. */\n\t\t\t/* To get a subset we use wesn that is not NULL or contain 0/0/0/0.\n\t\t\t * Otherwise we extract the entire file domain */\n\t\t\tHH = gmt_get_H_hidden (G_obj->header);\n\t\t\tsize = gmtapi_set_grdarray_size (GMT, G_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which includes padding */\n\t\t\tif (!G_obj->data) {\t/* Array is not allocated yet, do so now. We only expect header (and possibly w/e/s/n subset) to have been set correctly */\n\t\t\t\tG_obj->header->size = size;\n\t\t\t\tG_obj->data = gmt_M_memory_aligned (GMT, NULL, G_obj->header->size, gmt_grdfloat);\n\t\t\t}\n\t\t\telse {\t/* Already have allocated space; check that it is enough */\n\t\t\t\tif (size > G_obj->header->size) return_null (API, GMT_GRID_READ_ERROR);\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading grid from file %s\\n\", S_obj->filename);\n\t\t\tif (gmt_M_err_pass (GMT, gmtlib_read_grd (GMT, S_obj->filename, G_obj->header, G_obj->data, S_obj->wesn,\n\t\t\t\t\t\t\tGMT->current.io.pad, mode), S_obj->filename))\n\t\t\t\treturn_null (API, GMT_GRID_READ_ERROR);\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), S_obj->filename))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tGH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* GMT grid and header in a GMT_GRID container object. */\n\t\t\t/* Must duplicate the grid container from S_obj->resource and hence a new object is required */\n\t\t\tif ((G_orig = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (grid == NULL) {\t/* Only allocate when not already allocated */\n\t\t\t\tif (mode & GMT_DATA_ONLY) return_null (API, GMT_NO_GRDHEADER);\t\t/* For mode & GMT_DATA_ONLY grid must already be allocated */\n\t\t\t\tif ((G_obj = GMT_Duplicate_Data (API, GMT_IS_GRID, GMT_DUPLICATE_NONE, G_orig)) == NULL)\n\t\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t\t}\n\t\t\telse\n\t\t\t\tG_obj = grid;\t/* We are passing in a grid already */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read grid */\n            if (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header, get out of here */\n\t\t\t/* Here we will read grid data. */\n\t\t\t/* To get a subset we use wesn that is not NULL or contain 0/0/0/0.\n\t\t\t * Otherwise we use everything passed in */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating grid data from GMT_GRID memory location\\n\");\n\t\t\tif (!G_obj->data) {\t/* Array is not allocated, do so now. We only expect header (and possibly subset w/e/s/n) to have been set correctly */\n\t\t\t\tG_obj->header->size = gmtapi_set_grdarray_size (GMT, G_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which may include padding */\n\t\t\t\tG_obj->data = gmt_M_memory_aligned (GMT, NULL, G_obj->header->size, gmt_grdfloat);\n\t\t\t}\n\t\t\tGH = gmt_get_G_hidden (G_obj);\n\t\t\tGH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tif (!S_obj->region && gmt_grd_pad_status (GMT, G_obj->header, GMT->current.io.pad)) {\t/* Want an exact copy with no subset and same padding */\n\t\t\t\tgmt_M_memcpy (G_obj->data, G_orig->data, G_orig->header->size, gmt_grdfloat);\n\t\t\t\tgmt_BC_init (GMT, G_obj->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), \"Grid memory\"))\n\t\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\t\tbreak;\t\t/* Done with this grid */\n\t\t\t}\n\t\t\t/* Here we need to do more work: Either extract subset or add/change padding, or both. */\n\t\t\t/* Get start/stop row/cols for subset (or the entire domain) */\n\t\t\t/* dx,dy are needed when the grid is pixel-registered as the w/e/s/n bounds are off by 0.5 {dx,dy} relative to node coordinates */\n\t\t\tdx = G_obj->header->inc[GMT_X] * G_obj->header->xy_off;\tdy = G_obj->header->inc[GMT_Y] * G_obj->header->xy_off;\n\t\t\tj1 = (unsigned int)gmt_M_grd_y_to_row (GMT, S_obj->wesn[YLO]+dy, G_orig->header);\n\t\t\tj0 = (unsigned int)gmt_M_grd_y_to_row (GMT, S_obj->wesn[YHI]-dy, G_orig->header);\n\t\t\ti0 = (unsigned int)gmt_M_grd_x_to_col (GMT, S_obj->wesn[XLO]+dx, G_orig->header);\n\t\t\ti1 = (unsigned int)gmt_M_grd_x_to_col (GMT, S_obj->wesn[XHI]-dx, G_orig->header);\n\t\t\tgmt_M_memcpy (G_obj->header->pad, GMT->current.io.pad, 4, int);\t/* Set desired padding */\n\t\t\tgmt_M_memcpy (G_obj->header->wesn, S_obj->wesn, 4U, double);\t/* Update the grid header region to match subset request */\n\t\t\tgmt_set_grddim (GMT, G_obj->header);\t/* Adjust all dimensions accordingly before accessing the grid for output */\n\t\t\t/* get stats */\n\t\t\tHH = gmt_get_H_hidden (G_obj->header);\n\t\t\tG_obj->header->z_min = DBL_MAX;\n\t\t\tG_obj->header->z_max = -DBL_MAX;\n\t\t\tHH->has_NaNs = GMT_GRID_NO_NANS;\t/* We are about to check for NaNs and if none are found we retain 1, else 2 */\n\t\t\tfor (row = j0, row_out = 0; row <= j1; row++, row_out++) {\n\t\t\t\tij = gmt_M_ijp (G_obj->header, row_out, 0);\t/* Position in output grid at start of current row */\n\t\t\t\tfor (col = i0; col <= i1; col++, ij++) {\n\t\t\t\t\tkol = col % G_orig->header->n_columns;\n\t\t\t\t\tij_orig = gmt_M_ijp (G_orig->header, row, kol);\t/* Position of this (row,col) in original grid organization */\n\t\t\t\t\tG_obj->data[ij] = G_orig->data[ij_orig];\n\t\t\t\t\tif (gmt_M_is_fnan (G_obj->data[ij]))\n\t\t\t\t\t\tHH->has_NaNs = GMT_GRID_HAS_NANS;\n\t\t\t\t\telse {\n\t\t\t\t\t\tG_obj->header->z_min = MIN (G_obj->header->z_min, G_obj->data[ij]);\n\t\t\t\t\t\tG_obj->header->z_max = MAX (G_obj->header->z_max, G_obj->data[ij]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_BC_init (GMT, G_obj->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), \"Grid memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE:\t/* GMT grid and header in a GMT_GRID container object by reference [NOT SURE ABOUT THIS] */\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing grid data from GMT_GRID memory location\\n\");\n\t\t\tif ((G_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read grid */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_grid: Change alloc mode\\n\");\n\t\t\tGH = gmt_get_G_hidden (G_obj);\n\t\t\tS_obj->alloc_mode = GH->alloc_mode;\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_grid: Check pad\\n\");\n\t\t\tgmt_BC_init (GMT, G_obj->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), \"Grid memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tif (!gmtapi_adjust_grdpadding (G_obj->header, GMT->current.io.pad)) break;\t/* Pad is correct so we are done */\n\t\t\t/* Here we extend G_obj->data to allow for padding, then rearrange rows */\n\t\t\tif (GH->alloc_mode == GMT_ALLOC_EXTERNALLY) return_null (API, GMT_PADDING_NOT_ALLOWED);\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_grid: Add pad\\n\");\n\t\t\tgmt_grd_pad_on (GMT, G_obj, GMT->current.io.pad);\n\t\t\tif (done && S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tHH = gmt_get_H_hidden (G_obj->header);\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory grid */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, G_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = HH->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, G_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = HH->reset_pad = 1;\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_grid: Return from GMT_IS_REFERENCE\\n\");\n\t\t\tbreak;\n\n\t\t/* Status: This case is fully tested and operational */\n\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* The user's 2-D grid array of some sort, + info in the matrix header */\n\t\t\t/* Must create a grid container from matrix info S_obj->resource and hence a new object is required */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (grid == NULL) {\t/* Only allocate when not already allocated, and only allocate container */\n\t\t\t\tuint64_t dim[3] = {M_obj->n_columns, M_obj->n_rows, 1};\n\t\t\t\tif ((G_obj = GMT_Create_Data (API, GMT_IS_GRID, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, dim, M_obj->range, M_obj->inc, M_obj->registration, GMT_NOTSET, NULL)) == NULL)\n\t\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t\t}\n\t\t\telse\n\t\t\t\tG_obj = grid;\n\t\t\tif ((new_ID = gmtapi_get_object (API, GMT_IS_GRID, G_obj)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t\tif ((new_item = gmtlib_validate_id (API, GMT_IS_GRID, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t\tAPI->object[new_item]->method = S_obj->method;\n\t\t\tGH = gmt_get_G_hidden (G_obj);\n\t\t\tHH = gmt_get_H_hidden (G_obj->header);\n\t\t\tG_obj->header->complex_mode = (mode & GMT_GRID_IS_COMPLEX_MASK);\t/* Set the complex mode */\n\t\t\tGH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read grid */\n\t\t\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL)) == NULL)\n\t\t\t\treturn_null (API, GMT_WRONG_MATRIX_SHAPE);\n\t\t\tif ((api_get_val = gmtapi_select_get_function (API, M_obj->type)) == NULL)\n\t\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tHH = gmt_get_H_hidden (G_obj->header);\n\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\t/* Must first init header and copy the header information from the matrix header */\n\t\t\t\tgmtapi_matrixinfo_to_grdheader (GMT, G_obj->header, M_obj);\t/* Populate a GRD header structure */\n\t\t\t\t/* Must get the full zmin/max range since not provided by the matrix header */\n\t\t\t\t\tG_obj->header->z_min = +DBL_MAX;\n\t\t\t\t\tG_obj->header->z_max = -DBL_MAX;\n\t\t\t\t\tHH->has_NaNs = GMT_GRID_NO_NANS;\t/* We are about to check for NaNs and if none are found we retain 1, else 2 */\n\t\t\t\t\tgmt_M_grd_loop (GMT, G_obj, row, col, ij) {\n\t\t\t\t\tij_orig = GMT_2D_to_index (row, col, M_obj->dim);\n\t\t\t\t\tapi_get_val (&(M_obj->data), ij_orig, &d);\n\t\t\t\t\tif (gmt_M_is_dnan (d))\n\t\t\t\t\t\tHH->has_NaNs = GMT_GRID_HAS_NANS;\n\t\t\t\t\telse {\n\t\t\t\t\t\tG_obj->header->z_min = MIN (G_obj->header->z_min, (gmt_grdfloat)d);\n\t\t\t\t\t\tG_obj->header->z_max = MAX (G_obj->header->z_max, (gmt_grdfloat)d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY)\t/* Just needed the header */\n\t\t\t\t\tbreak;\t/* Done for now */\n\t\t\t}\n\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Importing grid data from user matrix memory location\\n\");\n\n\t\t\t/* Get start/stop row/cols for subset (or the entire domain) */\n\t\t\t/* dx,dy are needed when the grid is pixel-registered as the w/e/s/n bounds are off by 0.5 {dx,dy} relative to node coordinates */\n\t\t\tif (!S_obj->region || gmt_whole_earth (GMT, M_obj->range, S_obj->wesn)) {\t/* Easy, get the whole enchilada */\n\t\t\t\tj0 = i0 = 0;\n\t\t\t\tj1 = G_obj->header->n_rows    - 1;\t/* Minus 1 since we loop up to and including below */\n\t\t\t\ti1 = G_obj->header->n_columns - 1;\n\t\t\t}\n\t\t\telse {\t/* Want a subset */\n\t\t\t\tdx = G_obj->header->inc[GMT_X] * G_obj->header->xy_off;\tdy = G_obj->header->inc[GMT_Y] * G_obj->header->xy_off;\n\t\t\t\tj1 = (unsigned int)gmt_M_grd_y_to_row (GMT, S_obj->wesn[YLO]+dy, G_obj->header);\n\t\t\t\tj0 = (unsigned int)gmt_M_grd_y_to_row (GMT, S_obj->wesn[YHI]-dy, G_obj->header);\n\t\t\t\ti0 = (unsigned int)gmt_M_grd_x_to_col (GMT, S_obj->wesn[XLO]+dx, G_obj->header);\n\t\t\t\ti1 = (unsigned int)gmt_M_grd_x_to_col (GMT, S_obj->wesn[XHI]-dx, G_obj->header);\n\t\t\t\tgmt_M_memcpy (G_obj->header->wesn, S_obj->wesn, 4U, double);\t/* Update the grid header region to match subset request */\n\t\t\t\tgmt_set_grddim (GMT, G_obj->header);\t/* Adjust all dimensions accordingly before allocating space */\n\t\t\t}\n\t\t\tif (G_obj->data) {\t/* This is an error - there cannot be a data pointer yet */\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"G->data is not NULL when memory allocation is about to happen\\n\");\n\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t}\n\t\t\telse\n\t\t\t\tG_obj->data = gmt_M_memory_aligned (GMT, NULL, G_obj->header->size, gmt_grdfloat);\n\n\t\t\tfor (row = j0, row_out = 0; row <= j1; row++, row_out++) {\n\t\t\t\tij = gmt_M_ijp (G_obj->header, row_out, 0);\t/* Position in output grid at start of current row */\n\t\t\t\tfor (col = i0; col <= i1; col++, ij++) {\n\t\t\t\t\tkol = col % M_obj->n_columns;\n\t\t\t\t\tij_orig = GMT_2D_to_index (row, kol, M_obj->dim);\t/* Position of this (row,col) in input matrix organization */\n\t\t\t\t\tapi_get_val (&(M_obj->data), ij_orig, &d);\t/* Get the next item from the matrix */\n\t\t\t\t\tG_obj->data[ij] = (gmt_grdfloat)d;\n\t\t\t\t\tif (gmt_M_is_dnan (d))\n\t\t\t\t\t\tHH->has_NaNs = GMT_GRID_HAS_NANS;\n\t\t\t\t\telse {\n\t\t\t\t\t\tG_obj->header->z_min = MIN (G_obj->header->z_min, (gmt_grdfloat)d);\n\t\t\t\t\t\tG_obj->header->z_max = MAX (G_obj->header->z_max, (gmt_grdfloat)d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gmt_whole_earth (GMT, M_obj->range, S_obj->wesn)) {\n\t\t\t\t/* Global grids passed via matrix are not rotated to fit the desired global region, so we need to correct the wesn for this grid to match the matrix */\n\t\t\t\tgmt_M_memcpy (G_obj->header->wesn, M_obj->range, 4U, double);\n\t\t\t}\n\t\t\tgmt_BC_init (GMT, G_obj->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_IN), \"Grid memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\tAPI->object[new_item]->actual_family = GMT_IS_GRID;\t/* Done reading from matrix */\n\t\t\tif (start_over_method) API->object[new_item]->method = start_over_method;\t/* We changed our mind from reference to duplicate due to region */\n\t\t\tGH->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\t/* The user's 2-D grid array of some sort, + info in the args [NOT YET FULLY TESTED] */\n\t\t\t/* Getting a matrix info S_obj->resource. Create grid header and then pass the grid pointer via the matrix pointer */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\t/* Determine if it is possible to use the matrix given the region selected and the fact we chose GMT_IS_REFERENCE. This test will\n\t\t\t * only kick in after we allocate the G_obj and come back the second time (after getting header) since otherwise S_obj->wesn is not set yet */\n\t\t\tif (!(!S_obj->region ||\n\t\t\t\t(S_obj->wesn[XLO] >= M_obj->range[XLO] && S_obj->wesn[XHI] <= M_obj->range[XHI] && S_obj->wesn[YLO] >= M_obj->range[YLO] && S_obj->wesn[YHI] <= M_obj->range[YHI]) ||\n\t\t\t\tgmt_whole_earth (GMT, M_obj->range, S_obj->wesn))) {\t/* Cannot do this by reference, switch to duplication */\n\t\t\t\tmethod -= GMT_IS_REFERENCE;\n\t\t\t\tmethod += GMT_IS_DUPLICATE;\n\t\t\t\tstart_over_method = GMT_IS_DUPLICATE;\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Subset selection requires GMT_IS_DUPLICATION instead of GMT_IS_REFERENCE - method has been switched\\n\");\n\t\t\t\tgoto start_over_import_grid;\n\t\t\t}\n\n\t\t\t/* This method requires the input data to be a GMT_GRD_FORMAT matrix - otherwise we should be DUPLICATING */\n\t\t\tMH = gmt_get_M_hidden (M_obj);\n\t\t\tif (!(M_obj->shape == GMT_IS_ROW_FORMAT && M_obj->type == GMT_GRDFLOAT && (mode & GMT_GRID_IS_COMPLEX_MASK) == 0))\n\t\t\t\t return_null (API, GMT_NOT_A_VALID_IO_ACCESS);\n\t\t\tif (grid == NULL) {\t/* Only allocate when not already allocated, and only get container.  Note: Cannot have pad since input matrix won't have one */\n\t\t\t\tuint64_t dim[3] = {M_obj->n_rows, M_obj->n_columns, 1};\n\t\t\t\tif ((G_obj = GMT_Create_Data (API, GMT_IS_GRID, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, dim, M_obj->range, M_obj->inc, M_obj->registration, 0, NULL)) == NULL)\n\t\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t\t}\n\t\t\telse\n\t\t\t\tG_obj = grid;\n\t\t\tHH = gmt_get_H_hidden (G_obj->header);\n\t\t\tG_obj->header->complex_mode = (mode & GMT_GRID_IS_COMPLEX_MASK);\t/* Set the complex mode */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read grid */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\n\t\t\t\tgmtapi_matrixinfo_to_grdheader (GMT, G_obj->header, M_obj);\t/* Populate a GRD header structure */\n\t\t\t\t/* Temporarily set data pointer for convenience; removed later */\n#ifdef DOUBLE_PRECISION_GRID\n\t\t\t\tG_obj->data = M_obj->data.f8;\n#else\n\t\t\t\tG_obj->data = M_obj->data.f4;\n#endif\n\t\t\t\tG_obj->header->z_min = +DBL_MAX;\n\t\t\t\tG_obj->header->z_max = -DBL_MAX;\n\t\t\t\tHH->has_NaNs = GMT_GRID_NO_NANS;\t/* We are about to check for NaNs and if none are found we retain 1, else 2 */\n\t\t\t\tgmt_M_grd_loop (GMT, G_obj, row, col, ij) {\n\t\t\t\t\tif (gmt_M_is_fnan (G_obj->data[ij]))\n\t\t\t\t\t\tHH->has_NaNs = GMT_GRID_HAS_NANS;\n\t\t\t\t\telse {\n\t\t\t\t\t\tG_obj->header->z_min = MIN (G_obj->header->z_min, G_obj->data[ij]);\n\t\t\t\t\t\tG_obj->header->z_max = MAX (G_obj->header->z_max, G_obj->data[ij]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tG_obj->data = NULL;\t/* Since data are not requested yet */\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY)\t/* Just needed the header but had to set zmin/zmax first */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((new_ID = gmtapi_get_object (API, GMT_IS_GRID, G_obj)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t\tif ((new_item = gmtlib_validate_id (API, GMT_IS_GRID, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing grid data from user memory location\\n\");\n#ifdef DOUBLE_PRECISION_GRID\n\t\t\tG_obj->data = M_obj->data.f8;\n#else\n\t\t\tG_obj->data = M_obj->data.f4;\n#endif\n\t\t\tGH = gmt_get_G_hidden (G_obj);\n\t\t\tS_obj->alloc_mode = MH->alloc_mode;\t/* Pass on alloc_mode of matrix */\n\t\t\tGH->alloc_mode = GMT_ALLOC_EXTERNALLY;\t/* Since we cannot have both M and G try to free */\n\t\t\tAPI->object[new_item]->resource = G_obj;\n\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\tGH->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\tif (gmt_whole_earth (GMT, M_obj->range, S_obj->wesn)) {\n\t\t\t\t/* Global grids passed via matrix are not rotated to fit the desired global region, so we need to correct the wesn for this grid to match the matrix */\n\t\t\t\tgmt_M_memcpy (G_obj->header->wesn, M_obj->range, 4U, double);\n\t\t\t}\n\t\t\telse if (S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory grid */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, G_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, G_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to import grid\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\tif ((mode & GMT_CONTAINER_ONLY) == 0) {\t/* Also allocate and initialize the x and y vectors unless already present  */\n\t\tif (G_obj->x == NULL) {\n\t\t\tGH->xy_alloc_mode[GMT_X] = GMT_ALLOC_INTERNALLY;\n\t\t\tif (GMT->current.io.nc_xarray)\t/* Got variable x-array and asked to used this instead */\n\t\t\t\tG_obj->x = GMT->current.io.nc_xarray, GMT->current.io.nc_xarray = NULL;\n\t\t\telse\n\t\t\t\tG_obj->x = gmtapi_grid_coord (API, GMT_X, G_obj);\t/* Get array of x coordinates */\n\t\t}\n\t\tif (G_obj->y == NULL) {\n\t\t\tGH->xy_alloc_mode[GMT_Y] = GMT_ALLOC_INTERNALLY;\n\t\t\tif (GMT->current.io.nc_yarray)\t/* Got variable y-array and asked to used this instead */\n\t\t\t\tG_obj->y = GMT->current.io.nc_yarray, GMT->current.io.nc_yarray = NULL;\n\t\t\telse\n\t\t\t\tG_obj->y = gmtapi_grid_coord (API, GMT_Y, G_obj);\t/* Get array of y coordinates */\n\t\t}\n\t}\n\n\tif (done) S_obj->status = GMT_IS_USED;\t/* Mark as read (unless we just got the header) */\n\n\treturn (G_obj);\t/* Pass back out what we have so far */\n}\n\nGMT_LOCAL void gmtapi_cube_set_units (struct GMT_CTRL *GMT, struct GMT_CUBE *U) {\n\t/* Set unit strings for cube coordinates x, y and z based on\n\t   output data types for columns 0, 1, and 2.\n\t*/\n\tunsigned int i;\n\tchar *string[4] = {NULL, NULL, NULL, NULL}, unit[GMT_GRID_UNIT_LEN80] = {\"\"};\n\tchar date[GMT_LEN16] = {\"\"}, clock[GMT_LEN16] = {\"\"};\n\tstruct GMT_GRID_HEADER *header = U->header;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = gmt_get_H_hidden (header);\n\n\t/* Copy pointers to unit strings */\n\tstring[0] = header->x_units;\n\tstring[1] = header->y_units;\n\tstring[2] = U->units;\n\tstring[3] = header->z_units;\n\n\t/* Use input data type as backup for output data type */\n\tfor (i = 0; i < 4; i++)\n\t\tif (gmt_M_type (GMT, GMT_OUT, i) == GMT_IS_UNKNOWN) GMT->current.io.col_type[GMT_OUT][i] = GMT->current.io.col_type[GMT_IN][i];\n\n\t/* Catch some anomalies */\n\tif (gmt_M_type (GMT, GMT_OUT, GMT_X) == GMT_IS_LAT && gmt_M_type (GMT, GMT_OUT, GMT_Y) == GMT_IS_LAT) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_WARNING, \"Output type for X-coordinate of grid %s is LAT. Replaced by LON.\\n\", HH->name);\n\t\tgmt_set_column_type (GMT, GMT_OUT, GMT_X, GMT_IS_LON);\n\n\t}\n\tif (gmt_M_type (GMT, GMT_OUT, GMT_Y) == GMT_IS_LON && gmt_M_type (GMT, GMT_OUT, GMT_X) == GMT_IS_LON) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_WARNING, \"Output type for Y-coordinate of grid %s is LON. Replaced by LAT.\\n\", HH->name);\n\t\tgmt_set_column_type (GMT, GMT_OUT, GMT_Y, GMT_IS_LAT);\n\t}\n\n\t/* Set unit strings one by one based on output type - or fall through if Cartesian floats */\n\tfor (i = 0; i < 4; i++) {\n\t\tswitch (gmt_M_type (GMT, GMT_OUT, i)) {\n\t\t\tcase GMT_IS_LON:\n\t\t\t\tstrcpy (string[i], \"longitude [degrees_east]\"); break;\n\t\t\tcase GMT_IS_LAT:\n\t\t\t\tstrcpy (string[i], \"latitude [degrees_north]\"); break;\n\t\t\tcase GMT_IS_ABSTIME:\n\t\t\tcase GMT_IS_RELTIME:\n\t\t\tcase GMT_IS_RATIME:\n\t\t\t\t/* Determine time unit */\n\t\t\t\tswitch (GMT->current.setting.time_system.unit) {\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tstrcpy (unit, \"years\"); break;\n\t\t\t\t\tcase 'o':\n\t\t\t\t\t\tstrcpy (unit, \"months\"); break;\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tstrcpy (unit, \"days\"); break;\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tstrcpy (unit, \"hours\"); break;\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tstrcpy (unit, \"minutes\"); break;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstrcpy (unit, \"seconds\"); break;\n\t\t\t\t}\n\t\t\t\tgmt_format_calendar (GMT, date, clock, &GMT->current.io.date_output, &GMT->current.io.clock_output, false, 1, 0.0);\n\t\t\t\tsnprintf (string[i], GMT_GRID_UNIT_LEN80, \"time [%s since %s %s]\", unit, date, clock);\n\t\t\t\t/* Warning for non-double cubes */\n\t\t\t\tif (i == 3 && GMT->session.grdformat[header->type][1] != 'd')\n\t\t\t\t\tGMT_Report (GMT->parent, GMT_MSG_WARNING, \"Use double precision output cube to avoid loss of significance of time coordinate.\\n\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*! Writes out a single grid to destination */\nGMT_LOCAL int gmtapi_export_grid (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_GRID *G_obj) {\n\tint item, error;\n\tbool done = true, row_by_row;\n\tunsigned int method;\n\tuint64_t row, col, i0, i1, j0, j1, ij, ijp, ij_orig;\n\tsize_t size;\n\tdouble dx, dy;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_GRID *G_copy = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_MATRIX_HIDDEN *MH = NULL;\n\tstruct GMT_GRID_HIDDEN *GH = gmt_get_G_hidden (G_obj), *GH2 = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_export_grid: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtlib_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif (G_obj->data == NULL && !(mode & GMT_CONTAINER_ONLY)) return (gmtlib_report_error (API, GMT_PTR_IS_NULL));\n\tif ((item = gmtlib_validate_id (API, GMT_IS_GRID, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtlib_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* The current object whose data we will export */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET))\n\t\treturn (gmtlib_report_error (API, GMT_WRITTEN_ONCE));\t/* Only allow writing of a data set once, unless overridden by mode */\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\trow_by_row = ((mode & GMT_GRID_ROW_BY_ROW) || (mode & GMT_GRID_ROW_BY_ROW_MANUAL));\n\tif (row_by_row && S_obj->method != GMT_IS_FILE) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Can only use method GMT_IS_FILE when row-by-row writing of grid is selected\\n\");\n\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t}\n\tif (S_obj->region) {\t/* See if this is really a subset or just the same region as the grid */\n\t\tif (G_obj->header->wesn[XLO] == S_obj->wesn[XLO] && G_obj->header->wesn[XHI] == S_obj->wesn[XHI] && G_obj->header->wesn[YLO] == S_obj->wesn[YLO] && G_obj->header->wesn[YHI] == S_obj->wesn[YHI]) S_obj->region = false;\n\t}\n\tif (mode & GMT_GRID_IS_GEO) gmt_set_geographic (GMT, GMT_OUT);\t/* From API to tell grid is geographic */\n\tgmtlib_grd_set_units (GMT, G_obj->header);\t/* Ensure unit strings are set, regardless of destination */\n\tmethod = gmtapi_set_method (S_obj);\t/* Get the actual method to use since may be MATRIX or VECTOR masquerading as GRID */\n\tswitch (method) {\n\t\tcase GMT_IS_FILE:\t/* Name of a grid file on disk */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) {\t/* Update header structure only */\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Updating grid header for file %s\\n\", S_obj->filename);\n\t\t\t\tif (row_by_row) {\t/* Special row-by-row processing mode */\n\t\t\t\t\tchar w_mode = (mode & GMT_GRID_NO_HEADER) ? 'W' : 'w';\n\t\t\t\t\t/* Since we may get here twice (initial write; later update) we only allocate extra if NULL */\n\t\t\t\t\tif (GH->extra == NULL) GH->extra = gmt_M_memory (GMT, NULL, 1, struct GMT_GRID_ROWBYROW);\n\t\t\t\t\tif (gmtapi_open_grd (GMT, S_obj->filename, G_obj, w_mode, mode))\t/* Open the grid for incremental row writing */\n\t\t\t\t\t\treturn (gmtlib_report_error (API, GMT_GRID_WRITE_ERROR));\n\t\t\t\t}\n\t\t\t\telse if (gmt_update_grd_info (GMT, NULL, G_obj->header))\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_GRID_WRITE_ERROR));\n\t\t\t\tdone = false;\t/* Since we are not done with writing */\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Writing grid to file %s\\n\", S_obj->filename);\n\t\t\t\tif (gmt_M_err_pass (GMT, gmtlib_write_grd (GMT, S_obj->filename, G_obj->header, G_obj->data, S_obj->wesn, G_obj->header->pad, mode), S_obj->filename)) return (gmtlib_report_error (API, GMT_GRID_WRITE_ERROR));\n\t\t\t}\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* Duplicate GMT grid and header to a GMT_GRID container object. Subset allowed */\n\t\t\tif (S_obj->resource) return (gmtlib_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource pointer must be NULL */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtlib_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating grid data to GMT_GRID memory location\\n\");\n\t\t\tif (!S_obj->region) {\t/* No subset, possibly same padding */\n\t\t\t\tG_copy = gmt_duplicate_grid (API->GMT, G_obj, GMT_DUPLICATE_DATA);\n\t\t\t\tGH2 = gmt_get_G_hidden (G_copy);\n\t\t\t\tGH2->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\t\tif (gmtapi_adjust_grdpadding (G_copy->header, GMT->current.io.pad))\n\t\t\t\t\tgmt_grd_pad_on (GMT, G_copy, GMT->current.io.pad);\n\t\t\t\tgmt_BC_init (GMT, G_copy->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_copy, GMT_OUT), \"Grid memory\")) return (gmtlib_report_error (API, GMT_GRID_BC_ERROR));\t/* Set boundary conditions */\n\t\t\t\tS_obj->resource = G_copy;\t/* Set resource pointer to the grid */\n\t\t\t\tbreak;\t\t/* Done with this grid */\n\t\t\t}\n\t\t\t/* Here we need to extract subset, and possibly change padding. */\n\t\t\t/* Get start/stop row/cols for subset (or the entire domain) */\n\t\t\tG_copy = gmt_create_grid (GMT);\n\t\t\tGH2 = gmt_get_G_hidden (G_copy);\n\t\t\tGH2->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tgmt_copy_gridheader (GMT, G_copy->header, G_obj->header);\n\t\t\tgmt_M_memcpy (G_copy->header->wesn, S_obj->wesn, 4, double);\n\t\t\t/* dx,dy are needed when the grid is pixel-registered as the w/e/s/n bounds are off by 0.5 {dx,dy} relative to node coordinates */\n\t\t\tdx = G_obj->header->inc[GMT_X] * G_obj->header->xy_off;\tdy = G_obj->header->inc[GMT_Y] * G_obj->header->xy_off;\n\t\t\tj1 = (unsigned int) gmt_M_grd_y_to_row (GMT, G_obj->header->wesn[YLO]+dy, G_obj->header);\n\t\t\tj0 = (unsigned int) gmt_M_grd_y_to_row (GMT, G_obj->header->wesn[YHI]-dy, G_obj->header);\n\t\t\ti0 = (unsigned int) gmt_M_grd_x_to_col (GMT, G_obj->header->wesn[XLO]+dx, G_obj->header);\n\t\t\ti1 = (unsigned int) gmt_M_grd_x_to_col (GMT, G_obj->header->wesn[XHI]-dx, G_obj->header);\n\t\t\tgmt_M_memcpy (G_obj->header->pad, GMT->current.io.pad, 4, int);\t\t/* Set desired padding */\n\t\t\tG_copy->header->size = gmtapi_set_grdarray_size (GMT, G_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which may include padding */\n\t\t\tG_copy->data = gmt_M_memory_aligned (GMT, NULL, G_copy->header->size, gmt_grdfloat);\n\t\t\tG_copy->header->z_min = DBL_MAX;\tG_copy->header->z_max = -DBL_MAX;\t/* Must set zmin/zmax since we are not writing */\n\t\t\tfor (row = j0; row <= j1; row++) {\n\t\t\t\tfor (col = i0; col <= i1; col++, ij++) {\n\t\t\t\t\tij_orig = gmt_M_ijp (G_obj->header, row, col);\t/* Position of this (row,col) in original grid organization */\n\t\t\t\t\tij = gmt_M_ijp (G_copy->header, row, col);\t/* Position of this (row,col) in output grid organization */\n\t\t\t\t\tG_copy->data[ij] = G_obj->data[ij_orig];\n\t\t\t\t\tif (gmt_M_is_fnan (G_copy->data[ij])) continue;\n\t\t\t\t\t/* Update z_min, z_max */\n\t\t\t\t\tG_copy->header->z_min = MIN (G_copy->header->z_min, (double)G_copy->data[ij]);\n\t\t\t\t\tG_copy->header->z_max = MAX (G_copy->header->z_max, (double)G_copy->data[ij]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tS_obj->resource = G_copy;\t/* Set resource pointer to the grid */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE:\t/* GMT grid and header in a GMT_GRID container object - just pass the reference */\n\t\t\tif (S_obj->region) return (gmtlib_report_error (API, GMT_SUBSET_NOT_ALLOWED));\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtlib_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing grid data to GMT_GRID memory location\\n\");\n\t\t\tgmt_grd_zminmax (GMT, G_obj->header, G_obj->data);\t/* Must set zmin/zmax since we are not writing */\n\t\t\tgmt_BC_init (GMT, G_obj->header);\t/* Initialize grid interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_grd_BC_set (GMT, G_obj, GMT_OUT), \"Grid memory\")) return (gmtlib_report_error (API, GMT_GRID_BC_ERROR));\t/* Set boundary conditions */\n\t\t\tS_obj->resource = G_obj;\t/* Set resource pointer to the grid */\n\t\t\tGH->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* The user's 2-D grid array of some sort, + info in the args [NOT FULLY TESTED] */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtlib_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tif (S_obj->resource) {\t/* The output resource pointer already exist for matrix */\n\t\t\t\tM_obj = gmtapi_get_matrix_data (S_obj->resource);\n\t\t\t\tif (M_obj->n_rows < G_obj->header->n_rows || M_obj->n_columns < G_obj->header->n_columns)\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_DIM_TOO_SMALL));\n\t\t\t}\n\t\t\telse {\t/* Must allocate stuff */\n\t\t \t\tM_obj = gmtlib_create_matrix (API->GMT, 1, GMT_IS_OUTPUT, 0);\n\t\t\t\tM_obj->type = S_obj->type;\n\t\t\t}\n\t\t\tMH = gmt_get_M_hidden (M_obj);\n\t\t\tgmtapi_grdheader_to_matrixinfo (G_obj->header, M_obj);\t/* Populate an array with GRD header information */\n\t\t\tM_obj->dim = (M_obj->shape == GMT_IS_ROW_FORMAT) ? M_obj->n_columns : M_obj->n_rows;\t/* Matrix layout order */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Exporting grid data to user memory location\\n\");\n\t\t\tif (S_obj->resource == NULL) {\t/* Must allocate output */\n\t\t\t\tsize = gmt_M_get_nm (GMT, G_obj->header->n_columns, G_obj->header->n_rows);\n\t\t\t\tif ((error = gmtlib_alloc_univector (GMT, &(M_obj->data), M_obj->type, size)) != GMT_NOERROR) return (error);\n\t\t\t\tMH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\t}\n\t\t\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL)) == NULL)\n\t\t\t\treturn (gmtlib_report_error (API, GMT_WRONG_MATRIX_SHAPE));\n\t\t\tif ((api_put_val = gmtapi_select_put_function (API, M_obj->type)) == NULL)\n\t\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_TYPE));\n\t\t\tgmt_M_grd_loop (GMT, G_obj, row, col, ijp) {\n\t\t\t\tij = GMT_2D_to_index (row, col, M_obj->dim);\n\t\t\t\tapi_put_val (&(M_obj->data), ij, (double)G_obj->data[ijp]);\n\t\t\t}\n\t\t\tMH->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = M_obj;\t/* Set resource pointer to the matrix */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\t/* Write to a user matrix of type gmt_grdfloat */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtlib_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tif (mode & GMT_GRID_IS_COMPLEX_MASK)\t/* Cannot do a complex grid this way */\n\t\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_IO_ACCESS));\n\t\t\tif (S_obj->resource) {\t/* The output resource pointer already exist for matrix */\n\t\t\t\tM_obj = gmtapi_get_matrix_data (S_obj->resource);\n\t\t\t\tif (M_obj->n_rows < G_obj->header->n_rows || M_obj->n_columns < G_obj->header->n_columns)\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_DIM_TOO_SMALL));\n\t\t\t\tassert (M_obj->type == GMT_GRDFLOAT);\t/* That is the whole point of getting here, no? */\n\t\t\t}\n\t\t\telse {\t/* Must allocate stuff */\n\t\t \t\tM_obj = gmtlib_create_matrix (API->GMT, 1, GMT_IS_OUTPUT, 1);\n\t\t\t\tM_obj->type = GMT_GRDFLOAT;\t/* A grid is always gmt_grdfloat */\n\t\t\t}\n\t\t\tMH = gmt_get_M_hidden (M_obj);\n\t\t\tif (gmtapi_adjust_grdpadding (G_obj->header, GMT_no_pad))\n\t\t\t\tgmt_grd_pad_on (GMT, G_obj, GMT_no_pad);\t/* Adjust pad */\n\t\t\t/* This method requires the output data to be a gmt_grdfloat matrix - otherwise we should be DUPLICATING.\n\t\t\t   This distinction is set in GMT_Open_VirtualFile */\n\t\t\tgmtapi_grdheader_to_matrixinfo (G_obj->header, M_obj);\t/* Populate an array with GRD header information */\n\t\t\tM_obj->shape = GMT_IS_ROW_FORMAT;\t/* Because it is a direct GMT gmt_grdfloat grid */\n\t\t\tif (S_obj->resource) {\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Memcpy grid data to user memory location\\n\");\n#ifdef DOUBLE_PRECISION_GRID\n\t\t\t\tgmt_M_memcpy (M_obj->data.f8, G_obj->data, G_obj->header->nm, double);\n#else\n\t\t\t\tgmt_M_memcpy (M_obj->data.f4, G_obj->data, G_obj->header->nm, float);\n#endif\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing grid data to user memory location\\n\");\n#ifdef DOUBLE_PRECISION_GRID\n\t\t\t\tM_obj->data.f8 = G_obj->data;\n#else\n\t\t\t\tM_obj->data.f4 = G_obj->data;\n#endif\n\t\t\t}\n\t\t\tMH->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = M_obj;\t/* Set resource pointer to the matrix */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to export grids\\n\");\n\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\n\tif (done) S_obj->status = GMT_IS_USED;\t/* Mark as written (unless we only updated header) */\n\n\treturn (GMT_NOERROR);\n}\n\nint GMT_Put_Levels (void *V_API, struct GMT_CUBE *C, double *levels, uint64_t n_levels) {\n\t/* Duplicate and assign a level array to the cube for its 3rd dimension coordinates */\n\tstruct GMT_CUBE_HIDDEN *CU;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\t/* Check for NULL and void arguments */\n\tif (V_API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tif (levels == NULL) return_error (API, GMT_PTR_IS_NULL);\n\tif (n_levels == 0) return_error (API, GMT_DIM_TOO_SMALL);\n\tif (C == NULL) return_error (API, GMT_PTR_IS_NULL);\n\tif (C->z) return_error (API, GMT_PTR_NOT_NULL);\n\tif (C->header == NULL) return_error (API, GMT_PTR_IS_NULL);\n\tif (C->header->n_bands > 0) {\t/* If set then it better match */\n\t\tif ((uint64_t)C->header->n_bands < n_levels) return_error (API, GMT_DIM_TOO_SMALL);\n\t\tif ((uint64_t)C->header->n_bands > n_levels) return_error (API, GMT_DIM_TOO_LARGE);\n\t}\n\tif ((CU = gmt_get_U_hidden (C)) == NULL) return_error (API, GMT_PTR_IS_NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tif ((C->z = gmt_duplicate_array (API->GMT, levels, n_levels)) == NULL) return_error (API, GMT_MEMORY_ERROR);\n\tCU->xyz_alloc_mode[GMT_Z] = GMT_ALLOC_INTERNALLY;\t/* Since allocated by GMT */\n\tC->header->n_bands = (uint32_t)n_levels;\n\n\treturn (GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Put_Levels_ (struct GMT_CUBE *C, double *level, uint64_t *n) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Put_Levels (GMT_FORTRAN, C, level, *n));\n}\n#endif\n\n/*! . */\nGMT_LOCAL struct GMT_CUBE * gmtapi_import_cube (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_CUBE *cube) {\n\t/* Handles the reading of a 3-D data cube given in one of several ways.\n\t * Get the entire cube:\n \t * \tmode = GMT_CONTAINER_AND_DATA reads both header and cube;\n\t * Get a subset of the cube:  Call gmtapi_import_cube twice:\n\t * \t1. first with mode = GMT_CONTAINER_ONLY which reads header only.  Then, pass\n\t *\t   the new S_obj-> wesn to match your desired subregion\n\t *\t2. 2nd with mode = GMT_DATA_ONLY, which reads cube based on header's settings\n\t * If the cube->data array is NULL it will be allocated for you.\n\t */\n\n\tchar file[PATH_MAX] = {\"\"};\n\tint item, new_item, new_ID;\n\tbool done = true;\n \tuint64_t row, col, kol, row_out, i0, i1, j0, j1, k0, k1, ij, ij_orig;\n\tuint64_t n_layers = 0, k, n_layers_used, here;\n\tunsigned int both_set = (GMT_CONTAINER_ONLY | GMT_DATA_ONLY);\n\tunsigned int method, start_over_method = 0;\n\tdouble dx, dy, d;\n\tdouble *level = NULL, z_min, z_max, w_range[2] = {0.0, 0.0};\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tstruct GMT_CUBE *U_obj = NULL, *U_orig = NULL;\n\tstruct GMT_GRID *G = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_MATRIX_HIDDEN *MH = NULL;\n\tstruct GMT_CUBE_HIDDEN *UH = NULL;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tGMT_getfunction api_get_val = NULL;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_cube: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif ((item = gmtlib_validate_id (API, GMT_IS_CUBE, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET) return_null (API, API->error);\n\n\tS_obj = API->object[item];\t\t/* Current data object */\n\tif (S_obj->status != GMT_IS_UNUSED && S_obj->method == GMT_IS_FILE && !(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Already read this file before, so fail unless overridden by mode */\n\tif ((mode & both_set) == both_set) mode -= both_set;\t/* Allow users to have set GMT_CONTAINER_ONLY | GMT_DATA_ONLY; reset to GMT_CONTAINER_AND_DATA */\n\tif ((mode & GMT_CONTAINER_ONLY) && S_obj->region && S_obj->method == GMT_IS_FILE) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Cannot request a subset when just inquiring about the cube header\\n\");\n\t\treturn_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t}\n\n\tif (S_obj->region && cube) {\t/* See if this is really a subset or just the same region as the cube */\n\t\tif (cube->header->wesn[XLO] == S_obj->wesn[XLO] && cube->header->wesn[XHI] == S_obj->wesn[XHI] && \\\n\t\t\tcube->header->wesn[YLO] == S_obj->wesn[YLO] && cube->header->wesn[YHI] == S_obj->wesn[YHI] && \\\n\t\t\tcube->z_range[0] == S_obj->wesn[ZLO] && cube->z_range[1] == S_obj->wesn[ZHI])\n\t\t\t\tS_obj->region = false;\n\t}\n\tmethod = gmtapi_set_method (S_obj);\t/* Get the actual method to use since may be MATRIX or VECTOR masquerading as GRID */\n\nstart_over_import_cube:\t\t/* We may get here if we cannot honor a GMT_IS_REFERENCE from below */\n\n\tswitch (method) {\n\t\t/* Status: This case is fully tested and operational */\n\t\tcase GMT_IS_FILE:\t/* Name of a cube file on disk */\n\t\t\t/* When source is an actual file we place the cube container into the S_obj->resource slot; no new object required */\n\t\t\t/* If we need to read the header etc then we based this on the first layer in the cube */\n\t\t\tif ((mode & GMT_DATA_ONLY) == 0) {\t/* Get the cube header information */\n\t\t\t\tchar cube_layer[GMT_LEN64] = {\"\"}, *nc_z_named = NULL, *the_file = NULL;\n\t\t\t\t/* Got a single 3-D cube netCDF name, possibly selecting a specific variable via ?<name> */\n\t\t\t\tthe_file = strdup (S_obj->filename);\t\t/* Duplicate filename since we may change it */\n\t\t\t\tnc_z_named = strchr (the_file, '?');\t/* Maybe given a specific variable? */\n\t\t\t\tif (nc_z_named) {\t/* Gave a specific layer. Keep variable name and truncate the filename */\n\t\t\t\t\tstrcpy (cube_layer, &nc_z_named[1]);\t/* Place variable name in cube_layer string */\n\t\t\t\t\tnc_z_named[0] = '\\0';\t/* Chop off layer name for now */\n\t\t\t\t}\n\t\t\t\tif (gmt_nc_read_cube_info (GMT, the_file, w_range, &n_layers, &level)) {\t/* Learn the basics about the cube */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"gmtapi_import_cube: Unable to examine cube %s.\\n\", the_file);\n\t\t\t\t\tgmt_M_str_free (the_file);\n\t\t\t\t\treturn_null (API, GMT_RUNTIME_ERROR);\n\t\t\t\t}\n\t\t\t\tsprintf (file, \"%s?%s[0]\", the_file, cube_layer);\t/* Read cube header from the first layer in the cube */\n\t\t\t\t/* Read the first layer grid */\n\t\t\t\tif ((G = GMT_Read_Data (API, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, NULL, file, NULL)) == NULL) {\n\t\t\t\t\tgmt_M_str_free (the_file);\n\t\t\t\t\treturn_null (API, GMT_RUNTIME_ERROR);\n\t\t\t\t}\n\t\t\t\t/* Allocate a data cube structure and fill in the file information */\n\t\t\t\tU_obj = gmtlib_create_cube (GMT);\n\t\t\t\tgmt_copy_gridheader (GMT, U_obj->header, G->header);\n\t\t\t\tif (level) {\t/* Got an array of levels from the 3-D grid */\n\t\t\t\t\tU_obj->z_range[0] = level[0];\tU_obj->z_range[1] = level[n_layers-1];\n\t\t\t\t\tif (n_layers < 3 || !gmtlib_var_inc (level, n_layers))\t/* Equidistant layering */\n\t\t\t\t\t\tU_obj->z_inc = level[1] - level[0];\t/* Since they are all the same */\n\t\t\t\t\tU_obj->z = level;\t/* Let C be the owner of this array from now on */\n\t\t\t\t\tUH = gmt_get_U_hidden (U_obj);\n\t\t\t\t\tUH->xyz_alloc_mode[GMT_Z] = GMT_ALLOC_INTERNALLY;\n\t\t\t\t}\n\t\t\t\tU_obj->header->n_bands = n_layers;\n\t\t\t\tU_obj->mode = mode;\n\t\t\t\tif (nc_z_named) strncpy (U_obj->name, cube_layer, GMT_GRID_VARNAME_LEN80);\t/* Remember this name if given */\n\t\t\t\tHH = gmt_get_H_hidden (U_obj->header);\n\t\t\t\tstrncpy (HH->name, the_file, GMT_GRID_NAME_LEN256);\t/* Filename minus any specified variable */\n\t\t\t\tif (nc_z_named) nc_z_named[0] = '?';\t/* Restore layer name in file name */\n\t\t\t\tgmt_M_str_free (the_file);\n\t\t\t\tif (GMT_Destroy_Data (API, &G)) {\t/* Must use GMT_Destroy_Data since G was registered in GMT_Read_Data */\n\t\t\t\t\tgmtlib_free_cube (GMT, &U_obj, true);\n\t\t\t\t\treturn_null (API, GMT_RUNTIME_ERROR);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tU_obj = cube;\t/* We are working on a cube already allocated */\n\t\t\tS_obj->resource = U_obj;\t/* Set resource pointer to the cube */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read cube */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header, get out of here */\n\n\t\t\t/* Here we have the cube header and possibly the levels */\n\t\t\tHH = gmt_get_H_hidden (U_obj->header);\n\n\t\t\t/* Determine which layers we want to read */\n\t\t\tk0 = 0;\tk1 = U_obj->header->n_bands - 1;\t/* All layers selected */\n\t\t\tif (S_obj->region && S_obj->wesn[ZHI] > S_obj->wesn[ZLO]) {\t/* Want a subset of layers */\n\t\t\t\tif (U_obj->z == NULL) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"gmtapi_import_cube: No layer level array available in GMT_IS_CUBE.\\n\");\n\t\t\t\t\tgmtlib_free_cube (GMT, &U_obj, true);\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t\t}\n\t\t\t\telse if (gmt_get_active_layers (GMT, U_obj, &(S_obj->wesn[ZLO]), &k0, &k1) == 0) {\n\t\t\t\t\tgmtlib_free_cube (GMT, &U_obj, true);\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tn_layers_used = k1 - k0 + 1;\t/* Total number of layers actually to be read */\n\t\t\tif (n_layers_used == 0) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"gmtapi_import_cube: No layers selected from GMT_IS_CUBE.\\n\");\n\t\t\t\tgmtlib_free_cube (GMT, &U_obj, true);\n\t\t\t\treturn_null (API, GMT_DIM_TOO_SMALL);\n\t\t\t}\n\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading cube from file %s\\n\", S_obj->filename);\n\t\t\tfor (k = k0; k <= k1; k++) {\t/* Read the required layers into individual grid structures */\n\t\t\t\t/* Get the k'th layer from 3D cube possibly via a selected variable name */\n\t\t\t\tsprintf (file, \"%s?%s[%\" PRIu64 \"]\", HH->name, U_obj->name, k);\n\t\t\t\t/* Read in the layer as a temporary grid */\n\t\t\t\tif ((G = GMT_Read_Data (API, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_GRID_ALL, S_obj->wesn, file, NULL)) == NULL) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"gmtapi_import_cube: Unable to read layer %\" PRIu64 \" from file %s.\\n\", k, file);\n\t\t\t\t\tgmtlib_free_cube (GMT, &U_obj, true);\n\t\t\t\t\treturn_null (API, GMT_GRID_READ_ERROR);\n\t\t\t\t}\n\t\t\t\tif (U_obj->data == NULL) {\t/* Update grid header (due to possible subsets) and allocate cube the first time */\n\t\t\t\t\tn_layers = U_obj->header->n_bands;\t/* Remember full number of layers before overwriting in the next line */\n\t\t\t\t\tif (S_obj->region) gmt_copy_gridheader (GMT, U_obj->header, G->header);\t/* Since subset can have changed dims and ranges */\n\t\t\t\t\tU_obj->header->n_bands = n_layers_used;\t/* New number of layers */\n\t\t\t\t\tU_obj->z_range[0] = U_obj->z[k0];\n\t\t\t\t\tU_obj->z_range[1] = U_obj->z[k1];\n\t\t\t\t\tif (k0) {\t/* Eliminate levels not included and shrink length of array */\n\t\t\t\t\t\tmemmove (U_obj->z, &U_obj->z[k0], n_layers_used * sizeof(double));\n\t\t\t\t\t\tgmt_M_memset (&U_obj->z[n_layers_used], n_layers-n_layers_used, double);\n\t\t\t\t\t\tU_obj->z = gmt_M_memory (API->GMT, U_obj->z, n_layers_used, double);\n\t\t\t\t\t}\n\t\t\t\t\t/* Allocate cube data (note: each layer has padding) */\n\t\t\t\t\tU_obj->data = gmt_M_memory_aligned (API->GMT, NULL, U_obj->header->size * n_layers_used, gmt_grdfloat);\n\t\t\t\t\tz_min = U_obj->header->z_min;\t/* Initialize cube min/max values based on this first layer */\n\t\t\t\t\tz_max = U_obj->header->z_max;\n\t\t\t\t\there = 0;\t/* Initialize offset into k'th layer */\n\t\t\t\t}\n\t\t\t\telse {\t/* Here we update min/max for subsequent layers read */\n\t\t\t\t\tif (G->header->z_min < z_min) z_min = G->header->z_min;\n\t\t\t\t\tif (G->header->z_max > z_max) z_max = G->header->z_max;\n\t\t\t\t}\n\t\t\t\t/* Place this layer in the cube */\n\t\t\t\tgmt_M_memcpy (&U_obj->data[here], G->data, U_obj->header->size, gmt_grdfloat);\n\t\t\t\there += U_obj->header->size;\t/* Advance the offset */\n\t\t\t\tif (GMT_Destroy_Data (API, &G)) {\t/* Must eliminate this registered resource */\n\t\t\t\t\tgmtlib_free_cube (GMT, &U_obj, true);\n\t\t\t\t\treturn_null (API, GMT_RUNTIME_ERROR);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update cube min/max */\n\t\t\tU_obj->header->z_min = z_min;\n\t\t\tU_obj->header->z_max = z_max;\n\t\t\t/* Set BCs per layer */\n\t\t\tgmt_BC_init (GMT, U_obj->header);\t/* Initialize cube interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_cube_BC_set (GMT, U_obj, GMT_IN), \"Cube memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* GMT cube and header in a GMT_CUBE container object. */\n\t\t\t/* Must duplicate the cube container from S_obj->resource and hence a new object is required */\n\t\t\tif ((U_orig = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (cube == NULL) {\t/* Only allocate when not already allocated */\n\t\t\t\tif (mode & GMT_DATA_ONLY) return_null (API, GMT_NO_GRDHEADER);\t\t/* For mode & GMT_DATA_ONLY cube must already be allocated */\n\t\t\t\tif ((U_obj = GMT_Duplicate_Data (API, GMT_IS_GRID, GMT_DUPLICATE_NONE, U_orig)) == NULL)\n\t\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t\t}\n\t\t\telse\n\t\t\t\tU_obj = cube;\t/* We are passing in a cube already */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read cube */\n            if (mode & GMT_CONTAINER_ONLY) break;\t/* Just needed the header, get out of here */\n\t\t\t/* Here we will read cube data. */\n\t\t\t/* To get a subset we use region that is not NULL or contain 0/0/0/0/0/0.\n\t\t\t * Otherwise we use everything passed in */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating cube data from GMT_CUBE memory location\\n\");\n\t\t\tif (!U_obj->data) {\t/* Array is not allocated, do so now. We only expect header (and possibly subset w/e/s/n/z0/z1) to have been set correctly */\n\t\t\t\tU_obj->header->size = gmtapi_set_grdarray_size (GMT, U_obj->header, mode, S_obj->wesn);\t/* Get x/y array dimension only, which may include padding */\n\t\t\t\tU_obj->data = gmt_M_memory_aligned (GMT, NULL, U_obj->header->size * U_obj->header->n_bands, gmt_grdfloat);\n\t\t\t}\n\t\t\tUH = gmt_get_U_hidden (U_obj);\n\t\t\tUH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tif (!S_obj->region && gmt_grd_pad_status (GMT, U_obj->header, GMT->current.io.pad)) {\t/* Want an exact copy with no subset and same padding */\n\t\t\t\tgmt_M_memcpy (U_obj->data, U_orig->data, U_orig->header->size * U_orig->header->n_bands, gmt_grdfloat);\n\t\t\t\tgmt_BC_init (GMT, U_obj->header);\t/* Initialize cube interpolation and boundary condition parameters */\n\t\t\t\tif (gmt_M_err_pass (GMT, gmt_cube_BC_set (GMT, U_obj, GMT_IN), \"Cube memory\"))\n\t\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\t\tbreak;\t\t/* Done with this cube */\n\t\t\t}\n\t\t\t/* Here we need to do more work: Either extract subset or add/change padding, or both. */\n\t\t\t/* Get start/stop row/cols for subset (or the entire domain) */\n\t\t\t/* dx,dy are needed when the cube is pixel-registered as the w/e/s/n bounds are off by 0.5 {dx,dy} relative to node coordinates */\n\t\t\tdx = U_obj->header->inc[GMT_X] * U_obj->header->xy_off;\tdy = U_obj->header->inc[GMT_Y] * U_obj->header->xy_off;\n\t\t\tj1 = (unsigned int)gmt_M_grd_y_to_row (GMT, S_obj->wesn[YLO]+dy, U_orig->header);\n\t\t\tj0 = (unsigned int)gmt_M_grd_y_to_row (GMT, S_obj->wesn[YHI]-dy, U_orig->header);\n\t\t\ti0 = (unsigned int)gmt_M_grd_x_to_col (GMT, S_obj->wesn[XLO]+dx, U_orig->header);\n\t\t\ti1 = (unsigned int)gmt_M_grd_x_to_col (GMT, S_obj->wesn[XHI]-dx, U_orig->header);\n\t\t\t(void) gmt_get_active_layers (GMT, U_orig, &(S_obj->wesn[ZLO]), &k0, &k1);\n\t\t\tgmt_M_memcpy (U_obj->header->pad, GMT->current.io.pad, 4, int);\t/* Set desired padding */\n\t\t\tgmt_M_memcpy (U_obj->header->wesn, S_obj->wesn, 4U, double);\t/* Update the cube header region to match subset request */\n\t\t\tgmt_M_memcpy (U_obj->z_range, &(S_obj->wesn[ZLO]), 2U, double);\t/* Update the cube range to match subset request */\n\t\t\tgmt_set_grddim (GMT, U_obj->header);\t/* Adjust all dimensions accordingly before accessing the cube for output */\n\t\t\tU_obj->header->n_bands = k1 - k0 + 1;\n\t\t\t/* get stats */\n\t\t\tHH = gmt_get_H_hidden (U_obj->header);\n\t\t\tU_obj->header->z_min = DBL_MAX;\n\t\t\tU_obj->header->z_max = -DBL_MAX;\n\t\t\tHH->has_NaNs = GMT_GRID_NO_NANS;\t/* We are about to check for NaNs and if none are found we retain 1, else 2 */\n\t\t\tfor (k = k0; k <= k1; k++) {\n\t\t\t\tfor (row = j0, row_out = 0; row <= j1; row++, row_out++) {\n\t\t\t\t\tij = gmt_M_ijp (U_obj->header, row_out, 0) + (k - k0) * U_obj->header->size;\t/* Position in output cube at start of current row */\n\t\t\t\t\tfor (col = i0; col <= i1; col++, ij++) {\n\t\t\t\t\t\tkol = col % U_orig->header->n_columns;\n\t\t\t\t\t\tij_orig = gmt_M_ijp (U_orig->header, row, kol) + k * U_orig->header->size;\t/* Position of this (row,col) in original cube organization */\n\t\t\t\t\t\tU_obj->data[ij] = U_orig->data[ij_orig];\n\t\t\t\t\t\tif (gmt_M_is_fnan (U_obj->data[ij]))\n\t\t\t\t\t\t\tHH->has_NaNs = GMT_GRID_HAS_NANS;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tU_obj->header->z_min = MIN (U_obj->header->z_min, U_obj->data[ij]);\n\t\t\t\t\t\t\tU_obj->header->z_max = MAX (U_obj->header->z_max, U_obj->data[ij]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgmt_BC_init (GMT, U_obj->header);\t/* Initialize cube interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_cube_BC_set (GMT, U_obj, GMT_IN), \"Cube memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE:\t/* GMT cube and header in a GMT_CUBE container object by reference [NOT SURE ABOUT THIS] */\n\t\t\tif (S_obj->region) return_null (API, GMT_SUBSET_NOT_ALLOWED);\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing cube data from GMT_CUBE memory location\\n\");\n\t\t\tif ((U_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read cube */\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_cube: Change alloc mode\\n\");\n\t\t\tUH = gmt_get_U_hidden (U_obj);\n\t\t\tS_obj->alloc_mode = UH->alloc_mode;\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_cube: Check pad\\n\");\n\t\t\tgmt_BC_init (GMT, U_obj->header);\t/* Initialize cube interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_cube_BC_set (GMT, U_obj, GMT_IN), \"Cube memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tif (gmtapi_adjust_grdpadding (U_obj->header, GMT->current.io.pad)) {\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reference cube must have standard padding\\n\");\n\t\t\t\treturn_null (API, GMT_PADDING_NOT_ALLOWED);\t/* Set boundary conditions */\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_cube: Return from GMT_IS_REFERENCE\\n\");\n\t\t\tbreak;\n\n\t\t/* Status: This case is fully tested and operational */\n\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* The user's 3-D cube matrix of some sort, + info in the matrix header */\n\t\t\t/* Must create a cube container from matrix info S_obj->resource and hence a new object is required */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif (cube == NULL) {\t/* Only allocate when not already allocated, and only get container */\n\t\t\t\tuint64_t dim[3] = {M_obj->n_columns, M_obj->n_rows, M_obj->n_layers};\n\t\t\t\tif ((U_obj = GMT_Create_Data (API, GMT_IS_CUBE, GMT_IS_VOLUME, GMT_CONTAINER_ONLY, dim, M_obj->range, M_obj->inc, M_obj->registration, GMT_NOTSET, NULL)) == NULL)\n\t\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t\t}\n\t\t\telse\n\t\t\t\tU_obj = cube;\n\t\t\tif ((new_ID = gmtapi_get_object (API, GMT_IS_CUBE, U_obj)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t\tif ((new_item = gmtlib_validate_id (API, GMT_IS_CUBE, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t\tAPI->object[new_item]->method = S_obj->method;\n\t\t\tUH = gmt_get_U_hidden (U_obj);\n\t\t\tHH = gmt_get_H_hidden (U_obj->header);\n\t\t\tU_obj->header->complex_mode = (mode & GMT_GRID_IS_COMPLEX_MASK);\t/* Set the complex mode */\n\t\t\tUH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read cube */\n\t\t\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL)) == NULL)\n\t\t\t\treturn_null (API, GMT_WRONG_MATRIX_SHAPE);\n\t\t\tif ((api_get_val = gmtapi_select_get_function (API, M_obj->type)) == NULL)\n\t\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tHH = gmt_get_H_hidden (U_obj->header);\n\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\t/* Must first init header and copy the header information from the matrix header */\n\t\t\t\tgmtapi_matrixinfo_to_grdheader (GMT, U_obj->header, M_obj);\t/* Populate a GRD header structure */\n\t\t\t\t/* Must get the full zmin/max range since not provided by the matrix header */\n\t\t\t\t\tU_obj->header->z_min = +DBL_MAX;\n\t\t\t\t\tU_obj->header->z_max = -DBL_MAX;\n\t\t\t\t\tHH->has_NaNs = GMT_GRID_NO_NANS;\t/* We are about to check for NaNs and if none are found we retain 1, else 2 */\n\t\t\t\t\tfor (k = 0; k < M_obj->n_layers; k++) {\n\t\t\t\t\t\tfor (row = 0; row < M_obj->n_rows; row++) {\n\t\t\t\t\t\t\tfor (col = 0; col < M_obj->n_columns; col++) {\n\t\t\t\t\t\t\tij_orig = GMT_2D_to_index (row, col, M_obj->dim) + k * M_obj->size;\n\t\t\t\t\t\t\tij_orig = GMT_2D_to_index (row, col, M_obj->dim);\n\t\t\t\t\t\t\tapi_get_val (&(M_obj->data), ij_orig, &d);\n\t\t\t\t\t\t\tif (gmt_M_is_dnan (d))\n\t\t\t\t\t\t\t\tHH->has_NaNs = GMT_GRID_HAS_NANS;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tU_obj->header->z_min = MIN (U_obj->header->z_min, (gmt_grdfloat)d);\n\t\t\t\t\t\t\t\tU_obj->header->z_max = MAX (U_obj->header->z_max, (gmt_grdfloat)d);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY)\t/* Just needed the header */\n\t\t\t\t\tbreak;\t/* Done for now */\n\t\t\t}\n\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Importing cube data from user matrix memory location\\n\");\n\n\t\t\t/* Get start/stop row/cols for subset (or the entire domain) */\n\t\t\t/* dx,dy are needed when the cube is pixel-registered as the w/e/s/n bounds are off by 0.5 {dx,dy} relative to node coordinates */\n\t\t\tk0 = 0;\tk1 = M_obj->n_layers - 1;\n\t\t\tif (!S_obj->region || gmt_whole_earth (GMT, M_obj->range, S_obj->wesn)) {\t/* Easy, get the whole enchilada */\n\t\t\t\tj0 = i0 = 0;\n\t\t\t\tj1 = U_obj->header->n_rows    - 1;\t/* Minus 1 since we loop up to and including below */\n\t\t\t\ti1 = U_obj->header->n_columns - 1;\n\t\t\t}\n\t\t\telse {\t/* Want a subset */\n\t\t\t\tdx = U_obj->header->inc[GMT_X] * U_obj->header->xy_off;\tdy = U_obj->header->inc[GMT_Y] * U_obj->header->xy_off;\n\t\t\t\tj1 = (unsigned int)gmt_M_grd_y_to_row (GMT, S_obj->wesn[YLO]+dy, U_obj->header);\n\t\t\t\tj0 = (unsigned int)gmt_M_grd_y_to_row (GMT, S_obj->wesn[YHI]-dy, U_obj->header);\n\t\t\t\ti0 = (unsigned int)gmt_M_grd_x_to_col (GMT, S_obj->wesn[XLO]+dx, U_obj->header);\n\t\t\t\ti1 = (unsigned int)gmt_M_grd_x_to_col (GMT, S_obj->wesn[XHI]-dx, U_obj->header);\n\t\t\t\twhile (k0 < k1 && S_obj->wesn[ZLO] > (M_obj->range[ZLO] + k0 * M_obj->inc[GMT_Z])) k0++;\t/* Set first layer */\n\t\t\t\twhile (k1 && S_obj->wesn[ZHI] > (M_obj->range[ZHI] - (M_obj->n_layers-k1 - 1) * M_obj->inc[GMT_Z])) k1++;\t/* Set last layer */\n\t\t\t\tgmt_M_memcpy (U_obj->header->wesn, S_obj->wesn, 4U, double);\t/* Update the cube header region to match subset request */\n\t\t\t\tgmt_set_grddim (GMT, U_obj->header);\t/* Adjust all dimensions accordingly before allocating space */\n\t\t\t\tgmt_M_memcpy (U_obj->z_range, &(S_obj->wesn[ZLO]), 2U, double);\t/* Update the cube header range to match subset request */\n\t\t\t\tU_obj->header->n_bands = k1 - k0 + 1;\n\t\t\t}\n\t\t\tif (U_obj->data) {\t/* This is an error - there cannot be a data pointer yet */\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"U->data is not NULL when memory allocation is about to happen\\n\");\n\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\n\t\t\t}\n\t\t\telse\n\t\t\t\tU_obj->data = gmt_M_memory_aligned (GMT, NULL, U_obj->header->size * U_obj->header->n_bands, gmt_grdfloat);\n\n\t\t\there = 0;\n\t\t\tfor (k = k0; k <= k1; k++) {\n\t\t\t\tfor (row = j0, row_out = 0; row <= j1; row++, row_out++) {\n\t\t\t\t\tij = gmt_M_ijp (U_obj->header, row_out, 0) + here;\t/* Position in output cube at start of current row */\n\t\t\t\t\tfor (col = i0; col <= i1; col++, ij++) {\n\t\t\t\t\t\tkol = col % M_obj->n_columns;\n\t\t\t\t\t\tij_orig = GMT_2D_to_index (row, kol, M_obj->dim) + k * M_obj->size;\t/* Position of this (row,col) in input matrix organization */\n\t\t\t\t\t\tapi_get_val (&(M_obj->data), ij_orig, &d);\t/* Get the next item from the matrix */\n\t\t\t\t\t\tU_obj->data[ij] = (gmt_grdfloat)d;\n\t\t\t\t\t\tif (gmt_M_is_dnan (d))\n\t\t\t\t\t\t\tHH->has_NaNs = GMT_GRID_HAS_NANS;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tU_obj->header->z_min = MIN (U_obj->header->z_min, (gmt_grdfloat)d);\n\t\t\t\t\t\t\tU_obj->header->z_max = MAX (U_obj->header->z_max, (gmt_grdfloat)d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\there += U_obj->header->size;\n\t\t\t}\n\t\t\tif (gmt_whole_earth (GMT, M_obj->range, S_obj->wesn)) {\n\t\t\t\t/* Global cubes passed via matrix are not rotated to fit the desired global region, so we need to correct the wesn for this cube to match the matrix */\n\t\t\t\tgmt_M_memcpy (U_obj->header->wesn, M_obj->range, 4U, double);\n\t\t\t}\n\t\t\tgmt_BC_init (GMT, U_obj->header);\t/* Initialize cube interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_cube_BC_set (GMT, U_obj, GMT_IN), \"Cube memory\"))\n\t\t\t\treturn_null (API, GMT_GRID_BC_ERROR);\t/* Set boundary conditions */\n\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\tAPI->object[new_item]->actual_family = GMT_IS_CUBE;\t/* Done reading from matrix */\n\t\t\tif (start_over_method) API->object[new_item]->method = start_over_method;\t/* We changed our mind from reference to duplicate due to region */\n\t\t\tUH->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\t/* The user's 3-D matrix of some sort, + info in the args [NOT YET FULLY TESTED] */\n\t\t\t/* Getting a matrix info S_obj->resource. Create cube header and then pass the cube pointer via the matrix pointer */\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\t/* Determine if it is possible to use the matrix given the region selected and the fact we chose GMT_IS_REFERENCE. This test will\n\t\t\t * only kick in after we allocate the U_obj and come back the second time (after getting header) since otherwise S_obj->wesn is not set yet */\n\t\t\tif (!(!S_obj->region ||\n\t\t\t\t(S_obj->wesn[XLO] >= M_obj->range[XLO] && S_obj->wesn[XHI] <= M_obj->range[XHI] && S_obj->wesn[YLO] >= M_obj->range[YLO] && S_obj->wesn[YHI] <= M_obj->range[YHI]) ||\n\t\t\t\tgmt_whole_earth (GMT, M_obj->range, S_obj->wesn))) {\t/* Cannot do this by reference, switch to duplication */\n\t\t\t\tmethod -= GMT_IS_REFERENCE;\n\t\t\t\tmethod += GMT_IS_DUPLICATE;\n\t\t\t\tstart_over_method = GMT_IS_DUPLICATE;\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Cube subset selection requires GMT_IS_DUPLICATION instead of GMT_IS_REFERENCE - method has been switched\\n\");\n\t\t\t\tgoto start_over_import_cube;\n\t\t\t}\n\n\t\t\t/* This method requires the input data to be a GMT_GRD_FORMAT matrix - otherwise we should be DUPLICATING */\n\t\t\tMH = gmt_get_M_hidden (M_obj);\n\t\t\tif (!(M_obj->shape == GMT_IS_ROW_FORMAT && M_obj->type == GMT_GRDFLOAT && (mode & GMT_GRID_IS_COMPLEX_MASK) == 0))\n\t\t\t\t return_null (API, GMT_NOT_A_VALID_IO_ACCESS);\n\t\t\tif (cube == NULL) {\t/* Only allocate when not already allocated.  Note cannot have pad since input matrix wont have one */\n\t\t\t\tuint64_t dim[3] = {M_obj->n_rows, M_obj->n_columns, M_obj->n_layers};\n\t\t\t\tif ((U_obj = GMT_Create_Data (API, GMT_IS_CUBE, GMT_IS_VOLUME, GMT_CONTAINER_ONLY, dim, M_obj->range, M_obj->inc, M_obj->registration, 0, NULL)) == NULL)\n\t\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t\t}\n\t\t\telse\n\t\t\t\tU_obj = cube;\n\t\t\tHH = gmt_get_H_hidden (U_obj->header);\n\t\t\tU_obj->header->complex_mode = (mode & GMT_GRID_IS_COMPLEX_MASK);\t/* Set the complex mode */\n\t\t\tdone = (mode & GMT_CONTAINER_ONLY) ? false : true;\t/* Not done until we read cube */\n\t\t\tif (! (mode & GMT_DATA_ONLY)) {\n\t\t\t\tgmtapi_matrixinfo_to_grdheader (GMT, U_obj->header, M_obj);\t/* Populate a GRD header structure */\n\t\t\t\t/* Temporarily set data pointer for convenience; removed later */\n#ifdef DOUBLE_PRECISION_GRID\n\t\t\t\tU_obj->data = M_obj->data.f8;\n#else\n\t\t\t\tU_obj->data = M_obj->data.f4;\n#endif\n\t\t\t\tU_obj->header->z_min = +DBL_MAX;\n\t\t\t\tU_obj->header->z_max = -DBL_MAX;\n\t\t\t\tHH->has_NaNs = GMT_GRID_NO_NANS;\t/* We are about to check for NaNs and if none are found we retain 1, else 2 */\n\t\t\t\there = 0;\n\t\t\t\tfor (k = 0; k < M_obj->n_layers; k++) {\n\t\t\t\t\tfor (row = 0; row < M_obj->n_rows; row++) {\n\t\t\t\t\t\tij = gmt_M_ijp (U_obj->header, row, 0) + here;\n\t\t\t\t\t\tfor (col = 0; col < M_obj->n_columns; col++, ij++) {\n\t\t\t\t\t\t\tif (gmt_M_is_fnan (U_obj->data[ij]))\n\t\t\t\t\t\t\t\tHH->has_NaNs = GMT_GRID_HAS_NANS;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tU_obj->header->z_min = MIN (U_obj->header->z_min, U_obj->data[ij]);\n\t\t\t\t\t\t\t\tU_obj->header->z_max = MAX (U_obj->header->z_max, U_obj->data[ij]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\there += U_obj->header->size;\n\t\t\t\t}\n\t\t\t\tU_obj->data = NULL;\t/* Since data are not requested yet */\n\t\t\t\tif (mode & GMT_CONTAINER_ONLY)\t/* Just needed the header but had to set zmin/zmax first */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((new_ID = gmtapi_get_object (API, GMT_IS_CUBE, U_obj)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t\tif ((new_item = gmtlib_validate_id (API, GMT_IS_CUBE, new_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing cube data from user memory location\\n\");\n#ifdef DOUBLE_PRECISION_GRID\n\t\t\tU_obj->data = M_obj->data.f8;\n#else\n\t\t\tU_obj->data = M_obj->data.f4;\n#endif\n\t\t\tUH = gmt_get_U_hidden (U_obj);\n\t\t\tS_obj->alloc_mode = MH->alloc_mode;\t/* Pass on alloc_mode of matrix */\n\t\t\tUH->alloc_mode = GMT_ALLOC_EXTERNALLY;\t/* Since we cannot have both M and G try to free */\n\t\t\tAPI->object[new_item]->resource = U_obj;\n\t\t\tAPI->object[new_item]->status = GMT_IS_USED;\t/* Mark as read */\n\t\t\tUH->alloc_level = API->object[new_item]->alloc_level;\t/* Since allocated here */\n\t\t\tif (gmt_whole_earth (GMT, M_obj->range, S_obj->wesn)) {\n\t\t\t\t/* Global cubes passed via matrix are not rotated to fit the desired global region, so we need to correct the wesn for this cube to match the matrix */\n\t\t\t\tgmt_M_memcpy (U_obj->header->wesn, M_obj->range, 4U, double);\n\t\t\t}\n\t\t\telse if (S_obj->region) {\t/* Possibly adjust the pad so inner region matches wesn */\n\t\t\t\tif (S_obj->reset_pad) {\t/* First undo a prior sub-region used with this memory cube */\n\t\t\t\t\tgmtlib_contract_headerpad (GMT, U_obj->header, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\t\tS_obj->reset_pad = 0;\n\t\t\t\t}\n\t\t\t\tif (gmtlib_expand_headerpad (GMT, U_obj->header, S_obj->wesn, S_obj->orig_pad, S_obj->orig_wesn))\n\t\t\t\t\tS_obj->reset_pad = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to import cube\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\n\tif ((mode & GMT_CONTAINER_ONLY) == 0) {\t/* Also allocate and initialize the x and y vectors unless already present  */\n\t\tstruct GMT_CUBE_HIDDEN *GU = gmt_get_U_hidden (U_obj);\n\t\tif (U_obj->x == NULL) {\n\t\t\tGU->xyz_alloc_mode[GMT_X] = GMT_ALLOC_INTERNALLY;\n\t\t\tif (GMT->current.io.nc_xarray)\t/* Got variable x-array and asked to used this instead */\n\t\t\t\tU_obj->x = GMT->current.io.nc_xarray, GMT->current.io.nc_xarray = NULL;\n\t\t\telse\n\t\t\t\tU_obj->x = gmtapi_cube_coord (API, GMT_X, U_obj);\t/* Get array of x coordinates */\n\t\t}\n\t\tif (U_obj->y == NULL) {\n\t\t\tGU->xyz_alloc_mode[GMT_Y] = GMT_ALLOC_INTERNALLY;\n\t\t\tif (GMT->current.io.nc_yarray)\t/* Got variable y-array and asked to used this instead */\n\t\t\t\tU_obj->y = GMT->current.io.nc_yarray, GMT->current.io.nc_yarray = NULL;\n\t\t\telse\n\t\t\t\tU_obj->y = gmtapi_cube_coord (API, GMT_Y, U_obj);\t/* Get array of y coordinates */\n\t\t}\n\t}\n\n\tif (done) S_obj->status = GMT_IS_USED;\t/* Mark as read (unless we just got the header) */\n\n\treturn (U_obj);\t/* Pass back out what we have so far */\n}\n\n/*! Writes out a single cube to destination */\nGMT_LOCAL int gmtapi_export_cube (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_CUBE *U_obj) {\n\tint item, error;\n\tbool done = true;\n\tunsigned int method;\n\tuint64_t row, col, i0, i1, j0, j1, k0, k1, ij, ijp, ij_orig;\n\tuint64_t k, here = 0;\n\tsize_t size;\n\tdouble dx, dy;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CUBE *U_copy = NULL;\n\tstruct GMT_MATRIX *M_obj = NULL;\n\tstruct GMT_MATRIX_HIDDEN *MH = NULL;\n\tstruct GMT_CUBE_HIDDEN *UH = gmt_get_U_hidden (U_obj), *UH2 = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_export_cube: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtlib_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif (U_obj->data == NULL && !(mode & GMT_CONTAINER_ONLY)) return (gmtlib_report_error (API, GMT_PTR_IS_NULL));\n\tif ((item = gmtlib_validate_id (API, GMT_IS_CUBE, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtlib_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* The current object whose data we will export */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET))\n\t\treturn (gmtlib_report_error (API, GMT_WRITTEN_ONCE));\t/* Only allow writing of a data set once, unless overridden by mode */\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\tif (S_obj->region) {\t/* See if this is really a subset or just the same region as the cube */\n\t\tif (U_obj->header->wesn[XLO] == S_obj->wesn[XLO] && U_obj->header->wesn[XHI] == S_obj->wesn[XHI] && \\\n\t\t\tU_obj->header->wesn[YLO] == S_obj->wesn[YLO] && U_obj->header->wesn[YHI] == S_obj->wesn[YHI] && \\\n\t\t\tU_obj->z_range[0] == S_obj->wesn[ZLO] && U_obj->z_range[1] == S_obj->wesn[ZHI])\n\t\t\t\tS_obj->region = false;\n\t}\n\tif (mode & GMT_GRID_IS_GEO) gmt_set_geographic (GMT, GMT_OUT);\t/* From API to tell cube is geographic */\n\tgmtapi_cube_set_units (GMT, U_obj);\t/* Ensure unit strings are set, regardless of destination */\n\n\tmethod = gmtapi_set_method (S_obj);\t/* Get the actual method to use since may be MATRIX or VECTOR masquerading as GRID */\n\tswitch (method) {\n\t\tcase GMT_IS_FILE:\t/* Name of a cube file to write to disk */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) {\t/* Update header structure only */\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Updating cube header for file %s not implemented\\n\", S_obj->filename);\n\t\t\t\treturn (gmtlib_report_error (API, GMT_RUNTIME_ERROR));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Writing cube to file %s\\n\", S_obj->filename);\n\t\t\t\tif (gmt_nc_write_cube (GMT, U_obj, S_obj->wesn, S_obj->filename) != GMT_NOERROR)\n\t\t\t\t\treturn (gmtlib_report_error (API, API->error));\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE:\t/* Duplicate GMT cube and header to a GMT_CUBE container object. Subset allowed */\n\t\t\tif (S_obj->resource) return (gmtlib_report_error (API, GMT_PTR_NOT_NULL));\t/* The output resource pointer must be NULL */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtlib_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tif (gmtapi_adjust_grdpadding (U_obj->header, GMT->current.io.pad)) {\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reference cube must have standard padding\\n\");\n\t\t\t\tgmtlib_report_error (API, GMT_PADDING_NOT_ALLOWED);\n\t\t\t}\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating cube data to GMT_GRID memory location\\n\");\n\t\t\tif (!S_obj->region) {\t/* No subset, possibly same padding */\n\t\t\t\tU_copy = gmtlib_duplicate_cube (API->GMT, U_obj, GMT_DUPLICATE_DATA);\n\t\t\t\tUH2 = gmt_get_U_hidden (U_copy);\n\t\t\t\tUH2->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\t\tgmt_BC_init (GMT, U_copy->header);\t/* Initialize cube interpolation and boundary condition parameters */\n\t\t\t\tif (gmt_M_err_pass (GMT, gmt_cube_BC_set (GMT, U_copy, GMT_OUT), \"Cube memory\")) return (gmtlib_report_error (API, GMT_GRID_BC_ERROR));\t/* Set boundary conditions */\n\t\t\t\tS_obj->resource = U_copy;\t/* Set resource pointer to the cube */\n\t\t\t\tbreak;\t\t/* Done with this cube */\n\t\t\t}\n\t\t\t/* Here we need to extract subset, and possibly change padding. */\n\t\t\t/* Get start/stop row/cols for subset (or the entire domain) */\n\t\t\tU_copy = gmtlib_create_cube (GMT);\n\t\t\tUH2 = gmt_get_U_hidden (U_copy);\n\t\t\tUH2->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tgmt_copy_gridheader (GMT, U_copy->header, U_obj->header);\n\t\t\tgmt_M_memcpy (U_copy->header->wesn, S_obj->wesn, 4, double);\n\t\t\tgmt_M_memcpy (U_copy->z_range, &(S_obj->wesn[ZLO]), 2U, double);\t/* Update the cube range to match subset request */\n\t\t\t/* dx,dy are needed when the cube is pixel-registered as the w/e/s/n bounds are off by 0.5 {dx,dy} relative to node coordinates */\n\t\t\tdx = U_obj->header->inc[GMT_X] * U_obj->header->xy_off;\tdy = U_obj->header->inc[GMT_Y] * U_obj->header->xy_off;\n\t\t\tj1 = (unsigned int) gmt_M_grd_y_to_row (GMT, U_obj->header->wesn[YLO]+dy, U_obj->header);\n\t\t\tj0 = (unsigned int) gmt_M_grd_y_to_row (GMT, U_obj->header->wesn[YHI]-dy, U_obj->header);\n\t\t\ti0 = (unsigned int) gmt_M_grd_x_to_col (GMT, U_obj->header->wesn[XLO]+dx, U_obj->header);\n\t\t\ti1 = (unsigned int) gmt_M_grd_x_to_col (GMT, U_obj->header->wesn[XHI]-dx, U_obj->header);\n\t\t\t(void) gmt_get_active_layers (GMT, U_obj, &(S_obj->wesn[ZLO]), &k0, &k1);\n\t\t\tgmt_M_memcpy (U_obj->header->pad, GMT->current.io.pad, 4, int);\t\t/* Set desired padding */\n\t\t\tU_copy->header->size = gmtapi_set_grdarray_size (GMT, U_obj->header, mode, S_obj->wesn);\t/* Get array dimension only, which may include padding */\n\t\t\tU_copy->data = gmt_M_memory_aligned (GMT, NULL, U_copy->header->size, gmt_grdfloat);\n\t\t\tU_copy->header->z_min = DBL_MAX;\tU_copy->header->z_max = -DBL_MAX;\t/* Must set zmin/zmax since we are not writing */\n\t\t\tU_copy->header->n_bands = k1 - k0 + 1;\n\t\t\tfor (k = k0; k <= k1; k++) {\n\t\t\t\tfor (row = j0; row <= j1; row++) {\n\t\t\t\t\tfor (col = i0; col <= i1; col++, ij++) {\n\t\t\t\t\t\tij_orig = gmt_M_ijp (U_obj->header, row, col) + (k - k0) * U_obj->header->size;\t/* Position of this (row,col) in original cube organization */\n\t\t\t\t\t\tij = gmt_M_ijp (U_copy->header, row, col) + k * U_copy->header->size;\t/* Position of this (row,col) in output cube organization */\n\t\t\t\t\t\tU_copy->data[ij] = U_obj->data[ij_orig];\n\t\t\t\t\t\tif (gmt_M_is_fnan (U_copy->data[ij])) continue;\n\t\t\t\t\t\t/* Update z_min, z_max */\n\t\t\t\t\t\tU_copy->header->z_min = MIN (U_copy->header->z_min, (double)U_copy->data[ij]);\n\t\t\t\t\t\tU_copy->header->z_max = MAX (U_copy->header->z_max, (double)U_copy->data[ij]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\tS_obj->resource = U_copy;\t/* Set resource pointer to the cube */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE:\t/* GMT cube and header in a GMT_CUBE container object - just pass the reference */\n\t\t\tif (S_obj->region) return (gmtlib_report_error (API, GMT_SUBSET_NOT_ALLOWED));\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtlib_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing cube data to GMT_CUBE memory location\\n\");\n\t\t\tgmt_grd_zminmax (GMT, U_obj->header, U_obj->data);\t/* Must set zmin/zmax since we are not writing */\n\t\t\tgmt_BC_init (GMT, U_obj->header);\t/* Initialize cube interpolation and boundary condition parameters */\n\t\t\tif (gmt_M_err_pass (GMT, gmt_cube_BC_set (GMT, U_obj, GMT_OUT), \"Cube memory\")) return (gmtlib_report_error (API, GMT_GRID_BC_ERROR));\t/* Set boundary conditions */\n\t\t\tS_obj->resource = U_obj;\t/* Set resource pointer to the cube */\n\t\t\tUH->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* The user's 3-D matrix of some sort, + info in the args [NOT FULLY TESTED] */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtlib_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tif (S_obj->resource) {\t/* The output resource pointer already exist for matrix */\n\t\t\t\tM_obj = gmtapi_get_matrix_data (S_obj->resource);\n\t\t\t\tif (M_obj->n_rows < U_obj->header->n_rows || M_obj->n_columns < U_obj->header->n_columns || M_obj->n_layers < U_obj->header->n_bands)\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_DIM_TOO_SMALL));\n\t\t\t}\n\t\t\telse {\t/* Must allocate stuff */\n\t\t \t\tM_obj = gmtlib_create_matrix (API->GMT, U_obj->header->n_bands, GMT_IS_OUTPUT, 0);\n\t\t\t\tM_obj->type = S_obj->type;\n\t\t\t}\n\t\t\tMH = gmt_get_M_hidden (M_obj);\n\t\t\tgmtapi_grdheader_to_matrixinfo (U_obj->header, M_obj);\t/* Populate an array with GRD header information */\n\t\t\tgmt_M_memcpy (&(M_obj->range[ZLO]), U_obj->z_range, 2U, double);\t/* Update the cube range to match subset request */\n\t\t\tM_obj->inc[GMT_Z] = U_obj->z_inc;\n\t\t\tM_obj->dim = (M_obj->shape == GMT_IS_ROW_FORMAT) ? M_obj->n_columns : M_obj->n_rows;\t/* Matrix layout order */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Exporting cube data to user memory location\\n\");\n\t\t\tif (S_obj->resource == NULL) {\t/* Must allocate output */\n\t\t\t\tsize = gmt_M_get_nm (GMT, U_obj->header->n_columns, U_obj->header->n_rows) * M_obj->n_layers;\n\t\t\t\tif ((error = gmtlib_alloc_univector (GMT, &(M_obj->data), M_obj->type, size)) != GMT_NOERROR) return (error);\n\t\t\t\tMH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\t}\n\t\t\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, M_obj->shape, GMT_GRID_IS_REAL)) == NULL)\n\t\t\t\treturn (gmtlib_report_error (API, GMT_WRONG_MATRIX_SHAPE));\n\t\t\tif ((api_put_val = gmtapi_select_put_function (API, M_obj->type)) == NULL)\n\t\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_TYPE));\n\t\t\tsize = gmt_M_get_nm (GMT, M_obj->n_columns, M_obj->n_rows);\n\t\t\tfor (k = 0; k < U_obj->header->n_bands; k++) {\n\t\t\t\tgmt_M_grd_loop (GMT, U_obj, row, col, ijp) {\n\t\t\t\t\tij = GMT_2D_to_index (row, col, M_obj->dim) + k * size;\n\t\t\t\t\tapi_put_val (&(M_obj->data), ij, (double)U_obj->data[ijp+here]);\n\t\t\t\t}\n\t\t\t\there += U_obj->header->size;\n\t\t\t}\n\t\t\tMH->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = M_obj;\t/* Set resource pointer to the matrix */\n\t\t\tbreak;\n\n\t \tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\t/* Write to a user matrix of type gmt_grdfloat */\n\t\t\tif (mode & GMT_CONTAINER_ONLY) return (gmtlib_report_error (API, GMT_NOT_A_VALID_MODE));\n\t\t\tif (mode & GMT_GRID_IS_COMPLEX_MASK)\t/* Cannot do a complex cube this way */\n\t\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_IO_ACCESS));\n\t\t\tif (S_obj->resource) {\t/* The output resource pointer already exist for matrix */\n\t\t\t\tM_obj = gmtapi_get_matrix_data (S_obj->resource);\n\t\t\t\tif (M_obj->n_rows < U_obj->header->n_rows || M_obj->n_columns < U_obj->header->n_columns || M_obj->n_layers < U_obj->header->n_bands)\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_DIM_TOO_SMALL));\n\t\t\t\tassert (M_obj->type == GMT_GRDFLOAT);\t/* That is the whole point of getting here, no? */\n\t\t\t}\n\t\t\telse {\t/* Must allocate stuff */\n\t\t \t\tM_obj = gmtlib_create_matrix (API->GMT, U_obj->header->n_bands, GMT_IS_OUTPUT, 1);\n\t\t\t\tM_obj->type = GMT_GRDFLOAT;\t/* A cube is always gmt_grdfloat */\n\t\t\t}\n\t\t\tMH = gmt_get_M_hidden (M_obj);\n\t\t\tif (gmtapi_adjust_grdpadding (U_obj->header, GMT_no_pad))\n\t\t\t\tgmt_cube_pad_off (GMT, U_obj);\t/* Remove pad */\n\t\t\t/* This method requires the output data to be a gmt_grdfloat matrix - otherwise we should be DUPLICATING.\n\t\t\t   This distinction is set in GMT_Open_VirtualFile */\n\t\t\tgmtapi_grdheader_to_matrixinfo (U_obj->header, M_obj);\t/* Populate an array with GRD header information */\n\t\t\tgmt_M_memcpy (&(M_obj->range[ZLO]), U_obj->z_range, 2U, double);\t/* Update the cube range to match subset request */\n\t\t\tM_obj->inc[GMT_Z] = U_obj->z_inc;\n\t\t\tM_obj->shape = GMT_IS_ROW_FORMAT;\t/* Because it is a direct GMT gmt_grdfloat cube */\n\t\t\tif (S_obj->resource) {\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Memcpy cube data to user memory location\\n\");\n#ifdef DOUBLE_PRECISION_GRID\n\t\t\t\tgmt_M_memcpy (M_obj->data.f8, U_obj->data, U_obj->header->nm * U_obj->header->n_bands, double);\n#else\n\t\t\t\tgmt_M_memcpy (M_obj->data.f4, U_obj->data, U_obj->header->nm * U_obj->header->n_bands, float);\n#endif\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing cube data to user memory location\\n\");\n#ifdef DOUBLE_PRECISION_GRID\n\t\t\t\tM_obj->data.f8 = U_obj->data;\n#else\n\t\t\t\tM_obj->data.f4 = U_obj->data;\n#endif\n\t\t\t}\n\t\t\tMH->alloc_level = S_obj->alloc_level;\t/* Since we are passing it up to the caller */\n\t\t\tS_obj->resource = M_obj;\t/* Set resource pointer to the matrix */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to export cubes\\n\");\n\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\n\tif (done) S_obj->status = GMT_IS_USED;\t/* Mark as written (unless we only updated header) */\n\n\treturn (GMT_NOERROR);\n}\n\n\nGMT_LOCAL struct GMT_MATRIX * gmtapi_read_matrix (struct GMT_CTRL *GMT, void *source, unsigned int src_type, unsigned int mode) {\n\t/* We read the MATRIX from fp [or stdin].\n\t * src_type can be GMT_IS_[FILE|STREAM|FDESC]\n\t * Notes: mode is not used yet.  We only do ascii file for now - later need to deal with -b, if needed.\n\t */\n\n\tbool close_file = false, first = true, add_first_segheader = false, in_header_section = true;\n\tunsigned int pos;\n\tint error = 0;\n\tuint64_t row = 0, col, ij, n_col, nt_alloc = 0, nh_alloc = 0, n_headers = 0, dim[4] = {0, 0, 0, GMT->current.setting.export_type};\n\tchar M_file[PATH_MAX] = {\"\"}, line[GMT_BUFSIZ] = {\"\"};\n\tchar **text = NULL, **header = NULL;\n\tFILE *fp = NULL;\n\tstruct GMT_MATRIX *M = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tgmt_M_unused(mode);\n\n\tif (src_type == GMT_IS_FILE && !source) src_type = GMT_IS_STREAM;\t/* No filename given, default to stdin */\n\n\tif (src_type == GMT_IS_FILE) {\t/* dest is a file name */\n\t\tstrncpy (M_file, source, PATH_MAX-1);\n\t\tif ((fp = gmt_fopen (GMT, M_file, GMT->current.io.r_mode)) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot open Matrix file %s\\n\", M_file);\n\t\t\treturn_null (GMT->parent, GMT_ERROR_ON_FOPEN);\n\t\t}\n\t\tclose_file = true;\t/* We only close files we have opened here */\n\t}\n\telse if (src_type == GMT_IS_STREAM) {\t/* Open file pointer given, just copy */\n\t\tfp = (FILE *)source;\n\t\tif (fp == NULL) fp = GMT->session.std[GMT_IN];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_IN])\n\t\t\tstrcpy (M_file, \"<stdin>\");\n\t\telse\n\t\t\tstrcpy (M_file, \"<input stream>\");\n\t}\n\telse if (src_type == GMT_IS_FDESC) {\t\t/* Open file descriptor given, just convert to file pointer */\n\t\tint *fd = source;\n\t\tif (fd && (fp = fdopen (*fd, \"r\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot convert Matrix file descriptor %d to stream in gmtapi_read_matrix\\n\", *fd);\n\t\t\treturn_null (GMT->parent, GMT_ERROR_ON_FDOPEN);\n\t\t}\n\t\tif (fd == NULL) fp = GMT->session.std[GMT_IN];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_IN])\n\t\t\tstrcpy (M_file, \"<stdin>\");\n\t\telse\n\t\t\tstrcpy (M_file, \"<input file descriptor>\");\n\t\tclose_file = true;\t/* since fdopen allocates space */\n\t}\n\telse {\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Unrecognized source type %d in gmtapi_read_matrix\\n\", src_type);\n\t\treturn_null (GMT->parent, GMT_NOT_A_VALID_METHOD);\n\t}\n\tGMT_Report (GMT->parent, GMT_MSG_DEBUG, \"Read Matrix from %s\\n\", M_file);\n\n\twhile (!error && fgets (line, GMT_BUFSIZ, fp)) {\n\t\tgmt_chop (line);\t/* Remove linefeeds */\n\t\tif (strchr (GMT->current.setting.io_head_marker_in, line[0])) {\n\t\t\tif (in_header_section) {\n\t\t\t\tif (nh_alloc <= n_headers) header = gmt_M_memory (GMT, NULL, nh_alloc += GMT_TINY_CHUNK, char *);\n\t\t\t\theader[n_headers++] = strdup (line);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tin_header_section = false;\n\t\tif (line[0] == '>') {\n\t\t\tif (first) {\t/* Have not allocated yet so just skip that row for now and deal with it later */\n\t\t\t\tfirst = false;\n\t\t\t\tadd_first_segheader = true;\n\t\t\t}\n\t\t\telse {\t/* Already allocated so place NaNs as segment header */\n\t\t\t\tgmt_prep_tmp_arrays (GMT, GMT_IN, row, dim[0]);\t/* Init or reallocate tmp vectors */\n\t\t\t\tfor (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->session.d_NaN;\n\t\t\t}\n\t\t}\n\t\telse {\t/* Regular data record */\n\t\t\tif (dim[0] == 0)\t/* First time we must establish how many columns */\n\t\t\t\tdim[0] = gmtlib_conv_text2datarec (GMT, line, GMT_BUFSIZ, GMT->current.io.curr_rec, &pos);\n\t\t\tif ((n_col = gmtlib_conv_text2datarec (GMT, line, dim[0], GMT->current.io.curr_rec, &pos)) != dim[0]) {\n\t\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Matrix record %\" PRIu64 \" only had %\" PRIu64 \" columns but %\" PRIu64 \" was expected.  Record skipped\\n\", row, n_col, dim[0]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgmt_prep_tmp_arrays (GMT, GMT_IN, row, dim[0]);\t/* Init or reallocate tmp vectors */\n\t\t\tfor (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->current.io.curr_rec[col];\n\t\t\tif (line[pos]) {\t/* Deal with trailing text */\n\t\t\t\tif (nt_alloc <= row) text = gmt_M_memory (GMT, NULL, nt_alloc += GMT_INITIAL_MEM_ROW_ALLOC, char **);\n\t\t\t\ttext[row] = strdup (&line[pos]);\n\t\t\t}\n\t\t}\n\t\trow++;\n\t}\n\t/* Possibly restore the missing first segment header */\n\tif (add_first_segheader) for (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][0] = GMT->session.d_NaN;\n\tdim[1] = row;\t/* Allocate all vectors using current type setting in the defaults [GMT_DOUBLE] */\n\tif ((M = GMT_Create_Data (GMT->parent, GMT_IS_MATRIX, GMT_IS_POINT, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {\n\t\tif (close_file) fclose (fp);\n\t\treturn_null (GMT->parent, GMT_MEMORY_ERROR);\n\t}\n\tif ((api_put_val = gmtapi_select_put_function (GMT->parent, M->type)) == NULL)\t/* Get correct put function given data type */\n\t\treturn_null (GMT->parent, GMT_NOT_A_VALID_TYPE);\n\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (GMT->parent, M->shape, GMT_GRID_IS_REAL)) == NULL)\t/* Get ij index function */\n\t\treturn_null (GMT->parent, GMT_WRONG_MATRIX_SHAPE);\n\tfor (col = 0; col < M->n_columns; col++) {\n\t\tfor (row = 0; row < M->n_rows; row++) {\n\t\t\tij = GMT_2D_to_index (row, col, M->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\tapi_put_val (&(M->data), ij, GMT->hidden.mem_coord[col][row]);\n\t\t}\n\t}\n\tM->size = dim[GMT_X] * dim[GMT_Y];\n\t/* Set Default range and inc to reflect dim, with inc = 1 */\n\tM->range[XHI] = dim[GMT_X] - 1.0;\n\tM->range[YHI] = dim[GMT_Y] - 1.0;\n\tM->inc[GMT_X] = M->inc[GMT_Y] = 1.0;\n\n\tif (text) {\t/* Attach the trailing text to the vector */\n\t\tstruct GMT_MATRIX_HIDDEN *MH = gmt_get_M_hidden (M);\n\t\tif (nt_alloc > row) text = gmt_M_memory (GMT, text, row, char **);\n\t\tGMT_Put_Strings (GMT->parent, GMT_IS_MATRIX, M, text);\n\t\tMH->alloc_mode_text = GMT_ALLOC_INTERNALLY;\t/* Override since it is allocated internally in GMT */\n\t}\n\tif (n_headers) {\t/* Pass out the header records as well */\n\t\tif (nh_alloc > n_headers) header = gmt_M_memory (GMT, header, n_headers, char *);\n\t\tM->header = header;\n\t\tM->n_headers = n_headers;\n\t}\n\n\tif (close_file) gmt_fclose (GMT, fp);\n\treturn (M);\n}\n\nGMT_LOCAL void *gmtapi_grid2matrix (struct GMTAPI_CTRL *API, struct GMT_GRID *In, struct GMT_MATRIX *Out) {\n\tbool alloc = (Out == NULL);\n\tuint64_t row, col, ij, ij_M;\n\tdouble d;\n\tGMT_putfunction api_put_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\n\tif (alloc) Out = gmtlib_create_matrix (API->GMT, 1U, GMT_OUT, 0);\n\n\tgmtapi_grdheader_to_matrixinfo (In->header, Out);\n\tif (alloc) {\t/* Allocate the matrix itself */\n\t\tint error;\n\t\tOut->type = API->GMT->current.setting.export_type;\n\t\tOut->registration = In->header->registration;\n\t\tOut->shape = GMT_IS_ROW_FORMAT;\t/* For now */\n\t\tOut->dim = (Out->shape == GMT_IS_ROW_FORMAT) ? Out->n_columns : Out->n_rows;\t/* Matrix layout order */\n\n\t\tif ((error = gmtlib_alloc_univector (API->GMT, &(Out->data), Out->type, Out->n_rows * Out->n_columns)) != GMT_NOERROR) {\n\t\t\tgmt_M_free (API->GMT, Out);\n\t\t\treturn_null (API, error);\n\t\t}\n\t}\n\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, Out->shape, GMT_GRID_IS_REAL)) == NULL) {\n\t\tif (alloc) gmt_M_free (API->GMT, Out);\n\t\treturn_null (API, GMT_WRONG_MATRIX_SHAPE);\n\t}\n\tif ((api_put_val = gmtapi_select_put_function (API, Out->type)) == NULL) {\n\t\tif (alloc) gmt_M_free (API->GMT, Out);\n\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t}\n\n\tgmt_M_grd_loop (API->GMT, In, row, col, ij) {\n\t\td = In->data[ij];\n\t\tij_M = GMT_2D_to_index (row, col, Out->dim);\n\t\tapi_put_val (&(Out->data), ij_M, d);\n\t}\n\n\treturn Out;\n}\n\nGMT_LOCAL void *gmtapi_matrix2grid (struct GMTAPI_CTRL *API, struct GMT_MATRIX *In, struct GMT_GRID *Out) {\n\tbool alloc = (Out == NULL);\n\tuint64_t row, col, ij, ij_M;\n\tdouble d;\n\tGMT_getfunction api_get_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = NULL;\n\n\tif (alloc) Out = gmt_create_grid (API->GMT);\n\n\tgmtapi_matrixinfo_to_grdheader (API->GMT, Out->header, In);\n\tif (alloc) {\t/* Allocate the grid itself */\n\t\tint error;\n\t\tgmt_set_grddim (API->GMT, Out->header);\t/* Set all dimensions */\n\t\tif ((Out->data = gmt_M_memory (API->GMT, NULL, Out->header->size, gmt_grdfloat)) == NULL) {\n\t\t\tgmt_M_free (API->GMT, Out);\n\t\t\treturn_null (API, API->error);\n\t\t}\n\t\tif ((error = gmtapi_alloc_grid_xy (API, Out)) != GMT_NOERROR) {\n\t\t\tgmt_M_free (API->GMT, Out);\n\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t}\n\t}\n\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, In->shape, GMT_GRID_IS_REAL)) == NULL) {\n\t\tif (alloc) gmt_M_free (API->GMT, Out);\n\t\treturn_null (API, GMT_WRONG_MATRIX_SHAPE);\n\t}\n\tif ((api_get_val = gmtapi_select_get_function (API, In->type)) == NULL) {\n\t\tif (alloc) gmt_M_free (API->GMT, Out);\n\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t}\n\n\tHH = gmt_get_H_hidden (Out->header);\n\tOut->header->z_min = DBL_MAX;\n\tOut->header->z_max = -DBL_MAX;\n\tHH->has_NaNs = GMT_GRID_NO_NANS;\t/* We are about to check for NaNs and if none are found we retain 1, else 2 */\n\tgmt_M_grd_loop (API->GMT, Out, row, col, ij) {\n\t\tij_M = GMT_2D_to_index (row, col, In->dim);\n\t\tapi_get_val (&(In->data), ij_M, &d);\n\t\tOut->data[ij] = (gmt_grdfloat)d;\n\t\tif (gmt_M_is_fnan (Out->data[ij]))\n\t\t\tHH->has_NaNs = GMT_GRID_HAS_NANS;\n\t\telse {\n\t\t\tOut->header->z_min = MIN (Out->header->z_min, Out->data[ij]);\n\t\t\tOut->header->z_max = MAX (Out->header->z_max, Out->data[ij]);\n\t\t}\n\t}\n\n\treturn Out;\n}\n\n/*! . */\nGMT_LOCAL struct GMT_MATRIX *gmtapi_import_matrix (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in a GMT matrix. This could either be from a grid file or a 2-D table. */\n\tint item;\n\tunsigned int kind;\n\tstruct GMT_MATRIX *M_obj = NULL, *M_orig = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_matrix: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return_null (API, GMT_NO_INPUT);\n\tif ((item = gmtlib_validate_id (API, GMT_IS_MATRIX, object_ID, GMT_IN, GMTAPI_OPTION_INPUT)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\n\tS_obj = API->object[item];\t/* Use S_obj as shorthand */\n\tif (S_obj->status != GMT_IS_UNUSED) { /* Already read this resource before; are we allowed to re-read? */\n\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC)\n\t\t\treturn_null (API, GMT_READ_ONCE); /* Not allowed to re-read streams */\n\t\tif (!(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t}\n\n\t/* Passed sanity and allowed to read */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtapi_read_vector will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading MATRIX from %s %s\\n\", gmtapi_method (S_obj->method), S_obj->filename);\n\t\t\tif (S_obj->geometry == GMT_IS_SURFACE) {\t/* Read a grid file and convert to MATRIX */\n\t\t\t\tstruct GMT_GRID *G = NULL;\n\t\t\t\tif ((G = gmtapi_import_grid (API, object_ID, mode, NULL)) == NULL)\n\t\t\t\t\treturn_null (API, GMT_DATA_READ_ERROR);\n\t\t\t\tM_obj = gmtapi_grid2matrix (API, G, NULL);\t/* Convert the grid to a matrix */\n\t\t\t\tif (gmtapi_destroy_grid (API, &G))\n\t\t\t\t\treturn_null (API, GMT_DATA_READ_ERROR);\n\t\t\t}\n\t\t\telse if ((M_obj = gmtapi_read_matrix (GMT, S_obj->filename, S_obj->method, mode)) == NULL)\t/* Read a 2-D table */\n\t\t\t\treturn_null (API, GMT_DATA_READ_ERROR);\n\t\t\tS_obj->resource = M_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_STREAM:\n \t\t\t/* gmtapi_read_vector will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;\t/* Used for message: 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading MATRIX from %s %s stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((M_obj = gmtapi_read_matrix (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_DATA_READ_ERROR);\n\t\t\tS_obj->resource = M_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_FDESC:\n\t\t\t/* gmtapi_read_vector will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_IN) ? 0 : 1;\t/* Used for message: 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading MATRIX from %s %s stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((M_obj = gmtapi_read_matrix (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tS_obj->resource = M_obj;\t\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input MATRIX */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating MATRIX from MATRIX memory location\\n\");\n\t\t\tif ((M_orig = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif ((M_obj = GMT_Duplicate_Data (API, GMT_IS_MATRIX, mode, M_orig)))\n\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so nothing is allocated */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing MATRIX from MATRIX memory location\\n\");\n\t\t\tif ((M_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tbreak;\n\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to import MATRIX\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\treturn (M_obj);\t/* Pass back the vector */\n}\n\nGMT_LOCAL int gmtapi_write_matrix (struct GMT_CTRL *GMT, void *dest, unsigned int dest_type, unsigned int mode, struct GMT_MATRIX *M) {\n\t/* We write the MATRIX to fp [or stdout].\n\t * dest_type can be GMT_IS_[FILE|STREAM|FDESC]\n\t * mode is not used yet.\n\t */\n\n\tbool close_file = false, append = false, was;\n\tuint64_t row, col, ij;\n\tunsigned int hdr;\n\tchar M_file[PATH_MAX] = {\"\"};\n\tstatic char *msg1[2] = {\"Writing\", \"Appending\"};\n\tFILE *fp = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tGMT_getfunction api_get_val = NULL;\n\tgmt_M_unused(mode);\n\n\tif (dest_type == GMT_IS_FILE && !dest) dest_type = GMT_IS_STREAM;\t/* No filename given, default to stdout */\n\n\tif (dest_type == GMT_IS_FILE) {\t/* dest is a file name */\n\t\tstatic char *msg2[2] = {\"create\", \"append to\"};\n\t\tstrncpy (M_file, dest, PATH_MAX-1);\n\t\tappend = (M_file[0] == '>');\t/* Want to append to existing file */\n\t\tif ((fp = fopen (&M_file[append], (append) ? \"a\" : \"w\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot %s Matrix file %s\\n\", msg2[append], &M_file[append]);\n\t\t\treturn (GMT_ERROR_ON_FOPEN);\n\t\t}\n\t\tclose_file = true;\t/* We only close files we have opened here */\n\t}\n\telse if (dest_type == GMT_IS_STREAM) {\t/* Open file pointer given, just copy */\n\t\tfp = (FILE *)dest;\n\t\tif (fp == NULL) fp = GMT->session.std[GMT_OUT];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_OUT])\n\t\t\tstrcpy (M_file, \"<stdout>\");\n\t\telse\n\t\t\tstrcpy (M_file, \"<output stream>\");\n\t}\n\telse if (dest_type == GMT_IS_FDESC) {\t\t/* Open file descriptor given, just convert to file pointer */\n\t\tint *fd = dest;\n\t\tif (fd && (fp = fdopen (*fd, \"w\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot convert Matrix file descriptor %d to stream in gmtapi_write_matrix\\n\", *fd);\n\t\t\treturn (GMT_ERROR_ON_FDOPEN);\n\t\t}\n\t\tif (fd == NULL) fp = GMT->session.std[GMT_OUT];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_OUT])\n\t\t\tstrcpy (M_file, \"<stdout>\");\n\t\telse\n\t\t\tstrcpy (M_file, \"<output file descriptor>\");\n\t\tclose_file = true;\t/* since fdopen allocates space */\n\t}\n\telse {\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Unrecognized source type %d in gmtapi_write_matrix\\n\", dest_type);\n\t\treturn (GMT_NOT_A_VALID_METHOD);\n\t}\n\tGMT_Report (GMT->parent, GMT_MSG_DEBUG, \"%s Matrix to %s\\n\", msg1[append], &M_file[append]);\n\n\t/* Set index and put-value functions */\n\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (GMT->parent, M->shape, GMT_GRID_IS_REAL)) == NULL) {\n\t\tif (close_file) fclose (fp);\n\t\treturn (GMT_WRONG_MATRIX_SHAPE);\n\t}\n\tif ((api_get_val = gmtapi_select_get_function (GMT->parent, M->type)) == NULL) {\n\t\tif (close_file) fclose (fp);\n\t\treturn (GMT_NOT_A_VALID_TYPE);\n\t}\n\n\n\t/* Start writing Matrix to fp */\n\n\tif (M->n_headers) {\t/* Make sure we enable header records to be written */\n\t\twas = GMT->current.setting.io_header[GMT_OUT];\n\t\tGMT->current.setting.io_header[GMT_OUT] = true;\n\t}\n\tfor (hdr = 0; hdr < M->n_headers; hdr++)\n\t\tgmtlib_write_tableheader (GMT, fp, M->header[hdr]);\n\n\tfor (row = 0; row < M->n_rows; row++) {\n\t\tfor (col = 0; col < M->n_columns; col++) {\n\t\t\tij = GMT_2D_to_index (row, col, M->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\tapi_get_val (&(M->data), ij, &(GMT->current.io.curr_rec[col]));\n\t\t}\n\t\tif (gmtapi_bin_input_memory (GMT, M->n_columns, M->n_columns) < 0)\t/* Segment header found, finish the segment we worked on and goto next */\n\t\t\tgmt_write_segmentheader (GMT, fp, M->n_columns);\n\t\telse {\t/* Format an ASCII output record */\n\t\t\tfprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[0]);\n\t\t\tfor (col = 1; col < M->n_columns; col++) {\n\t\t\t\tfprintf (fp, \"%s\", GMT->current.setting.io_col_separator);\n\t\t\t\tfprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[col]);\n\t\t\t}\n\t\t\tif (M->text && M->text[row])\n\t\t\t\tfprintf (fp, \"%s%s\", GMT->current.setting.io_col_separator, M->text[row]);\n\t\t\tfprintf (fp, \"\\n\");\n\t\t}\n\t}\n\tif (M->n_headers) GMT->current.setting.io_header[GMT_OUT] = was;  /* Revert to the original setting */\n\n\tif (close_file) fclose (fp);\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_export_matrix (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_MATRIX *M_obj) {\n\t/* Does the actual work of writing out the specified Matrix to a destination.  Only FILE supported for testing.\n\t * The mode not used yet.\n\t */\n\tint item, error;\n\tunsigned int kind;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_export_matrix: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtlib_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtlib_validate_id (API, GMT_IS_MATRIX, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtlib_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* This is the API object for the output destination */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET)) {\t/* Only allow writing of a data set once, unless we override by resetting the mode */\n\t\treturn (gmtlib_report_error (API, GMT_WRITTEN_ONCE));\n\t}\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\n\t/* Passed sanity and allowed to write */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtapi_write_matrix will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write MATRIX to %s %s\\n\", gmtapi_method (S_obj->method), S_obj->filename);\n\t\t\tif (S_obj->geometry == GMT_IS_SURFACE) {\t/* Must convert matrix to grid then write to file */\n\t\t\t\tstruct GMT_GRID *G;\n\t\t\t\tG = gmtapi_matrix2grid (API, M_obj, NULL);\t/* Convert the matrix to a grid */\n\t\t\t\terror = gmtapi_export_grid (API, object_ID, mode, G);\n\t\t\t\tif (gmtapi_destroy_grid (API, &G))\n\t\t\t\t\treturn (gmtlib_report_error (API, GMT_DATA_READ_ERROR));\n\t\t\t}\n\t\t\telse if ((error = gmtapi_write_matrix (GMT, S_obj->filename, S_obj->method, mode, M_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_STREAM:\n\t\t\t/* gmtapi_write_matrix will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;\t/* For message only: 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write MATRIX to %s %s output stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((error = gmtapi_write_matrix (GMT, S_obj->fp, S_obj->method, mode, M_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* gmtapi_write_matrix will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_OUT) ? 0 : 1;\t/* For message only: 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write MATRIX to %s %s output stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((error = gmtapi_write_matrix (GMT, S_obj->fp, S_obj->method, mode, M_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to export MATRIX\\n\");\n\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as written */\n\n\treturn GMT_NOERROR;\n}\n\nGMT_LOCAL int gmtapi_write_vector (struct GMT_CTRL *GMT, void *dest, unsigned int dest_type, unsigned int mode, struct GMT_VECTOR *V) {\n\t/* We write the VECTOR to fp [or stdout].\n\t * dest_type can be GMT_IS_[FILE|STREAM|FDESC]\n\t * mode is not used yet.\n\t */\n\n\tbool close_file = false, append = false, was;\n\tuint64_t row, col;\n\tunsigned int hdr;\n\tchar V_file[PATH_MAX] = {\"\"};\n\tstatic char *msg1[2] = {\"Writing\", \"Appending\"};\n\tFILE *fp = NULL;\n\tGMT_getfunction *api_get_val = NULL;\n\tgmt_M_unused(mode);\n\n\tif (V == NULL) {\n\t\tGMT_Report(GMT->parent, GMT_MSG_ERROR, \"GMTAPI: gmtapi_write_vector passed a NULL pointer *V\\n\");\n\t\treturn GMT_NOTSET;\n\t}\n\tif (dest_type == GMT_IS_FILE && !dest) dest_type = GMT_IS_STREAM;\t/* No filename given, default to stdout */\n\n\tif (dest_type == GMT_IS_FILE) {\t/* dest is a file name */\n\t\tstatic char *msg2[2] = {\"create\", \"append to\"};\n\t\tstrncpy (V_file, dest, PATH_MAX-1);\n\t\tappend = (V_file[0] == '>');\t/* Want to append to existing file */\n\t\tif ((fp = fopen (&V_file[append], (append) ? \"a\" : \"w\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot %s Vector file %s\\n\", msg2[append], &V_file[append]);\n\t\t\treturn (GMT_ERROR_ON_FOPEN);\n\t\t}\n\t\tclose_file = true;\t/* We only close files we have opened here */\n\t}\n\telse if (dest_type == GMT_IS_STREAM) {\t/* Open file pointer given, just copy */\n\t\tfp = (FILE *)dest;\n\t\tif (fp == NULL) fp = GMT->session.std[GMT_OUT];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_OUT])\n\t\t\tstrcpy (V_file, \"<stdout>\");\n\t\telse\n\t\t\tstrcpy (V_file, \"<output stream>\");\n\t}\n\telse if (dest_type == GMT_IS_FDESC) {\t\t/* Open file descriptor given, just convert to file pointer */\n\t\tint *fd = dest;\n\t\tif (fd && (fp = fdopen (*fd, \"a\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot convert Vector file descriptor %d to stream in gmtapi_write_vector\\n\", *fd);\n\t\t\treturn (GMT_ERROR_ON_FDOPEN);\n\t\t}\n\t\tif (fd == NULL) fp = GMT->session.std[GMT_OUT];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_OUT])\n\t\t\tstrcpy (V_file, \"<stdout>\");\n\t\telse\n\t\t\tstrcpy (V_file, \"<output file descriptor>\");\n\t\tclose_file = true;\t/* since fdopen allocates space */\n\t}\n\telse {\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Unrecognized source type %d in gmtapi_write_vector\\n\", dest_type);\n\t\treturn (GMT_NOT_A_VALID_METHOD);\n\t}\n\tGMT_Report (GMT->parent, GMT_MSG_DEBUG, \"%s Vector to %s\\n\", msg1[append], &V_file[append]);\n\n\t/* Set get function per vector column */\n\tapi_get_val = gmt_M_memory (GMT, NULL, V->n_columns, GMT_getfunction);\n\tfor (col = 0; col < V->n_columns; col++) {\n\t\tif ((api_get_val[col] = gmtapi_select_get_function (GMT->parent, V->type[col])) == NULL) {\n\t\t\tgmt_M_free (GMT, api_get_val);\n\t\t\treturn (GMT_NOT_A_VALID_TYPE);\n\t\t}\n\t}\n\n\t/* Start writing Vector to fp */\n\n\tif (V->n_headers) {\t/* Make sure we enable header records to be written */\n\t\twas = GMT->current.setting.io_header[GMT_OUT];\n\t\tGMT->current.setting.io_header[GMT_OUT] = true;\n\t}\n\tfor (hdr = 0; hdr < V->n_headers; hdr++)\n\t\tgmtlib_write_tableheader (GMT, fp, V->header[hdr]);\n\n\tfor (row = 0; row < V->n_rows; row++) {\n\t\tfor (col = 0; col < V->n_columns; col++)\n\t\t\tapi_get_val[col] (&(V->data[col]), row, &(GMT->current.io.curr_rec[col]));\n\t\tif (gmtapi_bin_input_memory (GMT, V->n_columns, V->n_columns) < 0)\t/* Segment header found, finish the segment we worked on and goto next */\n\t\t\tgmt_write_segmentheader (GMT, fp, V->n_columns);\n\t\telse {\t/* Format an ASCII record for output */\n\t\t\tfprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[0]);\n\t\t\tfor (col = 1; col < V->n_columns; col++) {\n\t\t\t\tfprintf (fp, \"%s\", GMT->current.setting.io_col_separator);\n\t\t\t\tfprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[col]);\n\t\t\t}\n\t\t\tif (V->text && V->text[row])\n\t\t\t\tfprintf (fp, \"%s%s\", GMT->current.setting.io_col_separator, V->text[row]);\n\t\t\tfprintf (fp, \"\\n\");\n\t\t}\n\t}\n\tgmt_M_free (GMT, api_get_val);\n\n\tif (close_file) fclose (fp);\n\tif (V->n_headers) GMT->current.setting.io_header[GMT_OUT] = was;  /* Revert to the original setting */\n\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_export_vector (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode, struct GMT_VECTOR *V_obj) {\n\t/* Does the actual work of writing out the specified Matrix to a destination.  Only FILE supported for testing.\n\t * The mode not used yet.\n\t */\n\tint item, error;\n\tunsigned int kind;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_export_vector: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return (gmtlib_report_error (API, GMT_OUTPUT_NOT_SET));\n\tif ((item = gmtlib_validate_id (API, GMT_IS_VECTOR, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtlib_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* This is the API object for the output destination */\n\tif (S_obj->status != GMT_IS_UNUSED && !(mode & GMT_IO_RESET)) {\t/* Only allow writing of a data set once, unless we override by resetting the mode */\n\t\treturn (gmtlib_report_error (API, GMT_WRITTEN_ONCE));\n\t}\n\tif (mode & GMT_IO_RESET) mode -= GMT_IO_RESET;\n\n\t/* Passed sanity and allowed to write */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtapi_write_vector will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write VECTOR to %s %s\\n\", gmtapi_method (S_obj->method), S_obj->filename);\n\t\t\tif ((error = gmtapi_write_vector (GMT, S_obj->filename, S_obj->method, mode, V_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_STREAM:\n\t\t\t/* gmtapi_write_vector will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;\t/* For message only: 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write VECTOR to %s %s output stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((error = gmtapi_write_vector (GMT, S_obj->fp, S_obj->method, mode, V_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t \tcase GMT_IS_FDESC:\n\t\t\t/* gmtapi_write_vector will report where it is writing from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_OUT) ? 0 : 1;\t/* For message only: 0 if stdout, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Write VECTOR to %s %s output stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((error = gmtapi_write_vector (GMT, S_obj->fp, S_obj->method, mode, V_obj))) return (gmtlib_report_error (API, error));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to export VECTOR\\n\");\n\t\t\treturn (gmtlib_report_error (API, GMT_NOT_A_VALID_METHOD));\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as written */\n\n\treturn GMT_NOERROR;\n}\n\nGMT_LOCAL struct GMT_VECTOR *gmtapi_read_vector (struct GMT_CTRL *GMT, void *source, unsigned int src_type, unsigned int mode) {\n\t/* We read the VECTOR from fp [or stdin].\n\t * src_type can be GMT_IS_[FILE|STREAM|FDESC]\n\t * mode is not used yet.  We only do ascii file for now - later need to deal with -b\n\t */\n\n\tbool close_file = false, first = true, add_first_segheader = false, in_header_section = true;\n\tunsigned int pos;\n\tuint64_t nt_alloc = 0, nh_alloc = 0, n_headers = 0, row = 0, n_col, col, dim[GMT_DIM_SIZE] = {0, 0, GMT->current.setting.export_type, 0};\n\tchar V_file[PATH_MAX] = {\"\"};\n\tchar line[GMT_BUFSIZ] = {\"\"};\n\tchar **text = NULL, **header = NULL;\n\tFILE *fp = NULL;\n\tstruct GMT_VECTOR *V = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tgmt_M_unused(mode);\n\n\tif (src_type == GMT_IS_FILE && !source) src_type = GMT_IS_STREAM;\t/* No filename given, default to stdin */\n\n\tif (src_type == GMT_IS_FILE) {\t/* dest is a file name */\n\t\tstrncpy (V_file, source, PATH_MAX-1);\n\t\tif ((fp = gmt_fopen (GMT, V_file, \"r\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot open Vector file %s\\n\", V_file);\n\t\t\treturn_null (GMT->parent, GMT_ERROR_ON_FOPEN);\n\t\t}\n\t\tclose_file = true;\t/* We only close files we have opened here */\n\t}\n\telse if (src_type == GMT_IS_STREAM) {\t/* Open file pointer given, just copy */\n\t\tfp = (FILE *)source;\n\t\tif (fp == NULL) fp = GMT->session.std[GMT_IN];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_IN])\n\t\t\tstrcpy (V_file, \"<stdin>\");\n\t\telse\n\t\t\tstrcpy (V_file, \"<input stream>\");\n\t}\n\telse if (src_type == GMT_IS_FDESC) {\t\t/* Open file descriptor given, just convert to file pointer */\n\t\tint *fd = source;\n\t\tif (fd && (fp = fdopen (*fd, \"r\")) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot convert Vector file descriptor %d to stream in gmtapi_read_vector\\n\", *fd);\n\t\t\treturn_null (GMT->parent, GMT_ERROR_ON_FDOPEN);\n\t\t}\n\t\tif (fd == NULL) fp = GMT->session.std[GMT_IN];\t/* Default destination */\n\t\tif (fp == GMT->session.std[GMT_IN])\n\t\t\tstrcpy (V_file, \"<stdin>\");\n\t\telse\n\t\t\tstrcpy (V_file, \"<input file descriptor>\");\n\t\tclose_file = true;\t/* since fdopen allocates space */\n\t}\n\telse {\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Unrecognized source type %d in gmtapi_read_vector\\n\", src_type);\n\t\treturn_null (GMT->parent, GMT_NOT_A_VALID_METHOD);\n\t}\n\tGMT_Report (GMT->parent, GMT_MSG_DEBUG, \"Read Vector from %s\\n\", V_file);\n\n\twhile (fgets (line, GMT_BUFSIZ, fp)) {\n\t\tgmt_chop (line);\t/* Remove linefeeds */\n\t\tif (strchr (GMT->current.setting.io_head_marker_in, line[0])) {\n\t\t\tif (in_header_section) {\n\t\t\t\tif (nh_alloc <= n_headers) header = gmt_M_memory (GMT, NULL, nh_alloc += GMT_TINY_CHUNK, char *);\n\t\t\t\theader[n_headers++] = strdup (line);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tin_header_section = false;\n\t\tif (line[0] == '>') {\n\t\t\tif (first) {\t/* Have not allocated yet so just skip that row for now */\n\t\t\t\tfirst = false;\n\t\t\t\tadd_first_segheader = true;\n\t\t\t}\n\t\t\telse {\t/* Already allocated so place NaNs */\n\t\t\t\tgmt_prep_tmp_arrays (GMT, GMT_IN, row, dim[0]);\t/* Init or reallocate tmp vectors */\n\t\t\t\tfor (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->session.d_NaN;\n\t\t\t}\n\t\t}\n\t\telse {\t/* Regular data record */\n\t\t\tif (dim[0] == 0)\t/* First time we must extablish how many columns */\n\t\t\t\tdim[0] = gmtlib_conv_text2datarec (GMT, line, GMT_BUFSIZ, GMT->current.io.curr_rec, &pos);\n\t\t\tif ((n_col = gmtlib_conv_text2datarec (GMT, line, dim[0], GMT->current.io.curr_rec, &pos)) != dim[0]) {\n\t\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Vector record %\" PRIu64 \" only had %\" PRIu64 \" columns but %\" PRIu64 \" was expected.  Record skipped\\n\", row, n_col, dim[0]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgmt_prep_tmp_arrays (GMT, GMT_IN, row, dim[0]);\t/* Init or reallocate tmp vectors */\n\t\t\tfor (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->current.io.curr_rec[col];\n\t\t\tif (line[pos]) {\t/* Deal with trailing text */\n\t\t\t\tif (nt_alloc <= row) text = gmt_M_memory (GMT, NULL, nt_alloc += GMT_INITIAL_MEM_ROW_ALLOC, char **);\n\t\t\t\ttext[row] = strdup (&line[pos]);\n\t\t\t}\n\t\t}\n\t\trow++;\n\t}\n\tif (add_first_segheader) for (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][0] = GMT->session.d_NaN;\n\tdim[1] = row;\t/* Allocate all vectors using current type setting in the defaults [GMT_DOUBLE] */\n\tif ((V = GMT_Create_Data (GMT->parent, GMT_IS_VECTOR, GMT_IS_POINT, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {\n\t\tif (close_file) gmt_fclose (GMT, fp);\n\t\treturn_null (GMT->parent, GMT_MEMORY_ERROR);\n\t}\n\tfor (col = 0; col < V->n_columns; col++) {\n\t\tif ((api_put_val = gmtapi_select_put_function (GMT->parent, V->type[col])) == NULL)\n\t\t\treturn_null (GMT->parent, GMT_NOT_A_VALID_TYPE);\n\t\tfor (row = 0; row < V->n_rows; row++)\n\t\t\tapi_put_val (&(V->data[col]), row, GMT->hidden.mem_coord[col][row]);\n\t}\n\n\tif (text) {\t/* Attach the trailing text to the vector */\n\t\tstruct GMT_VECTOR_HIDDEN *VH = gmt_get_V_hidden (V);\n\t\tif (nt_alloc > row) text = gmt_M_memory (GMT, text, row, char **);\n\t\tGMT_Put_Strings (GMT->parent, GMT_IS_VECTOR, V, text);\n\t\tVH->alloc_mode_text = GMT_ALLOC_INTERNALLY;\t/* Override since it is allocated internally in GMT */\n\t}\n\tif (n_headers) {\t/* Pass out the header records as well */\n\t\tif (nh_alloc > n_headers) header = gmt_M_memory (GMT, header, n_headers, char *);\n\t\tV->header = header;\n\t\tV->n_headers = n_headers;\n\t}\n\n\tif (close_file) gmt_fclose (GMT, fp);\n\treturn (V);\n}\n\n/*! . */\nGMT_LOCAL struct GMT_VECTOR * gmtapi_import_vector (struct GMTAPI_CTRL *API, int object_ID, unsigned int mode) {\n\t/* Does the actual work of loading in a GMT vector table. */\n\tint item;\n\tunsigned int kind;\n\tstruct GMT_VECTOR *V_obj = NULL, *V_orig = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_import_vector: Passed ID = %d and mode = %d\\n\", object_ID, mode);\n\n\tif (object_ID == GMT_NOTSET) return_null (API, GMT_NO_INPUT);\n\tif ((item = gmtlib_validate_id (API, GMT_IS_VECTOR, object_ID, GMT_IN, GMTAPI_OPTION_INPUT)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\n\tS_obj = API->object[item];\t/* Use S_obj as shorthand */\n\tif (S_obj->status != GMT_IS_UNUSED) { /* Already read this resource before; are we allowed to re-read? */\n\t\tif (S_obj->method == GMT_IS_STREAM || S_obj->method == GMT_IS_FDESC)\n\t\t\treturn_null (API, GMT_READ_ONCE); /* Not allowed to re-read streams */\n\t\tif (!(mode & GMT_IO_RESET)) return_null (API, GMT_READ_ONCE);\t/* Not authorized to re-read */\n\t}\n\n\t/* Passed sanity and allowed to read */\n\n\tswitch (S_obj->method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t\t\t/* gmtapi_read_vector will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading VECTOR from %s %s\\n\", gmtapi_method (S_obj->method), S_obj->filename);\n\t\t\tif ((V_obj = gmtapi_read_vector (GMT, S_obj->filename, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_DATA_READ_ERROR);\n\t\t\tS_obj->resource = V_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_STREAM:\n \t\t\t/* gmtapi_read_vector will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;\t/* For message only: 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading VECTOR from %s %s stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((V_obj = gmtapi_read_vector (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_DATA_READ_ERROR);\n\t\t\tS_obj->resource = V_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_FDESC:\n\t\t\t/* gmtapi_read_vector will report where it is reading from if level is GMT_MSG_INFORMATION */\n\t\t\tkind = (*((int *)S_obj->fp) == GMT_IN) ? 0 : 1;\t/* For message only: 0 if stdin, 1 otherwise for user pointer */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Reading VECTOR from %s %s stream\\n\", gmtapi_method (S_obj->method), GMT_stream[kind]);\n\t\t\tif ((V_obj = gmtapi_read_vector (GMT, S_obj->fp, S_obj->method, mode)) == NULL)\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\n\t\t\tS_obj->resource = V_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\t\tbreak;\n\t\tcase GMT_IS_DUPLICATE:\t/* Duplicate the input VECTOR */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Duplicating VECTOR from VECTOR memory location\\n\");\n\t\t\tif ((V_orig = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tif ((V_obj = GMT_Duplicate_Data (API, GMT_IS_VECTOR, mode, V_orig)))\n\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t\tbreak;\n\t\tcase GMT_IS_REFERENCE:\t/* Just pass memory location, so nothing is allocated */\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Referencing VECTOR from VECTOR memory location\\n\");\n\t\t\tif ((V_obj = S_obj->resource) == NULL) return_null (API, GMT_PTR_IS_NULL);\n\t\t\tbreak;\n\t\tdefault:\t/* Barking up the wrong tree here... */\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Wrong method used to import VECTOR\\n\");\n\t\t\treturn_null (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\tS_obj->status = GMT_IS_USED;\t/* Mark as read */\n\treturn (V_obj);\t/* Pass back the vector */\n}\n\n/*! . */\nGMT_LOCAL void * gmtapi_import_data (struct GMTAPI_CTRL *API, enum GMT_enum_family family, int object_ID, unsigned int mode, void *data) {\n\n\t/* Function that will import the data object referred to by the object_ID (or all registered inputs if object_ID == GMT_NOTSET).\n\t * This is a wrapper functions for CPT, Dataset, Grid, Image and PostScript imports; see the specific functions\n\t * for details on the arguments, in particular the mode setting (or see the GMT API documentation).\n\t */\n\tint item, flag = GMT_NOTSET;\n\tvoid *new_obj = NULL;\n\n\tif (API == NULL) return_null (API, GMT_NOT_A_SESSION);\t\t\t/* GMT_Create_Session has not been called */\n\tif (!API->registered[GMT_IN]) return_null (API, GMT_NO_INPUT);\t\t/* No sources registered yet */\n\n\t/* Get information about this resource first */\n\tif (multiple_files_ok (family)) {\n\t\tflag = (API->module_input) ? GMTAPI_MODULE_INPUT : GMTAPI_OPTION_INPUT;\n\t}\n\tif ((item = gmtlib_validate_id (API, family, object_ID, GMT_IN, flag)) == GMT_NOTSET) return_null (API, API->error);\n\n\tswitch (family) {\n\t\tcase GMT_IS_PALETTE:\n\t\t\tnew_obj = gmtapi_import_palette (API, object_ID, mode);\t\t/* Try to import a CPT */\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\n\t\t\tnew_obj = gmtapi_import_dataset (API, object_ID, mode);\t\t/* Try to import data tables */\n\t\t\tbreak;\n\t\tcase GMT_IS_GRID:\n\t\t\tnew_obj = gmtapi_import_grid (API, object_ID, mode, data);\t/* Try to import a grid */\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\tnew_obj = gmtapi_import_image (API, object_ID, mode, data);\t/* Try to import an image */\n\t\t\tbreak;\n\t\tcase GMT_IS_CUBE:\n\t\t\tnew_obj = gmtapi_import_cube (API, object_ID, mode, data);\t/* Try to import a 3-D cube */\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\n\t\t\tnew_obj = gmtapi_import_matrix (API, object_ID, mode);\t\t/* Try to import a matrix */\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\n\t\t\tnew_obj = gmtapi_import_vector (API, object_ID, mode);\t\t/* Try to import a vector */\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\n\t\t\tnew_obj = gmtapi_import_postscript (API, object_ID, mode);\t\t/* Try to import PS */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\tif (new_obj == NULL) return_null (API, API->error);\t/* Return NULL as something went wrong */\n\treturn (new_obj);\t/* Successful, return pointer */\n}\n\n/*! . */\nGMT_LOCAL void * gmtapi_get_data (void *V_API, int object_ID, unsigned int mode, void *data) {\n\t/* Function to import registered data sources directly into program memory as a set (not record-by-record).\n\t * data is pointer to an existing grid container when we read a grid in two steps, otherwise use NULL.\n\t * ID is the registered resource from which to import.\n\t * Return: Pointer to data container, or NULL if there were errors (passed back via API->error).\n\t */\n\tint item, family, flag = GMT_NOTSET;\n\tbool was_enabled;\n\tvoid *new_obj = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\n\t/* Determine the item in the object list that matches this ID and direction */\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif (object_ID == GMT_NOTSET) {\t/* Must pick up the family from the shelf */\n\t\tfamily = API->shelf;\n\t\tAPI->shelf = GMT_NOTSET;\n\t\tif (multiple_files_ok(family)) flag = (API->module_input) ? GMTAPI_MODULE_INPUT : GMTAPI_OPTION_INPUT;\n\t}\n\telse\n\t\tfamily = GMT_NOTSET;\n\tif ((item = gmtlib_validate_id (API, family, object_ID, GMT_IN, flag)) == GMT_NOTSET) {\n\t\treturn_null (API, API->error);\n\t}\n\n\twas_enabled = API->io_enabled[GMT_IN];\n\tif (!was_enabled && gmtapi_begin_io (API, GMT_IN) != GMT_NOERROR) {\t/* Enables data input if not already set and sets access mode */\n\t\treturn_null (API, API->error);\n\t}\n\tS_obj = API->object[item];\t/* Short-hand */\n\tS_obj->selected = true;\t/* Make sure it the requested data set is selected */\n\n\t/* OK, try to do the importing */\n\tif ((new_obj = gmtapi_import_data (API, S_obj->family, object_ID, mode, data)) == NULL) {\n\t\treturn_null (API, API->error);\n\t}\n\n\tif (!was_enabled && GMT_End_IO (API, GMT_IN, 0) != GMT_NOERROR) {\t/* Disables data input if we had to set it in this function */\n\t\treturn_null (API, API->error);\n\t}\n#ifdef DEBUG\n\tgmtapi_set_object (API, S_obj);\n\t//gmtapi_list_objects (API, \"gmtapi_get_data\");\n#endif\n\treturn (new_obj);\t\t/* Return pointer to the data container */\n}\n\nGMT_LOCAL void gmtapi_reconsider_messenger (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *S_obj) {\n\t/* A messenger is a dummy container with no memory allocated that is there to tell a\n\t * module that it can be deleted to make space for an actual container with output data.\n\t * However, for MATRIX and VECTOR output we will need to check if user supplied actual\n\t * output memory.  For this to be true we need (a) non-NULL vectors/matrix and (b) known\n\t * dimension(s).  If we pass those tests then we set the messenger flag to false.\n\t */\n\tgmt_M_unused(API);\n\tif (S_obj->messenger == false) return;\t/* Nothing to ponder */\n\tif (S_obj->actual_family == GMT_IS_VECTOR) {\t/* Examine a vector container */\n\t\tstruct GMT_VECTOR *V = S_obj->resource;\n\t\tif (V == NULL) return;\n\t\tif (V->n_rows == 0) return;\n\t\tfor (unsigned int col = 0; col < V->n_columns; col++)\n\t\t\tif (V->data[col].f8 == NULL) return;\t/* Any of the actual members could be used here */\n\t}\n\telse if (S_obj->actual_family == GMT_IS_MATRIX) {\t/* Examine a matrix container */\n\t\tstruct GMT_MATRIX *M = S_obj->resource;\n\t\tif (M == NULL) return;\n\t\tif (M->n_rows == 0 || M->n_columns == 0) return;\n\t\tif (M->data.f8 == NULL) return;\t/* Any of the actual members could be used here */\n\t}\n\telse\t/* Wrong container */\n\t\treturn;\n\t/* Here we need to shoot the messenger */\n\tS_obj->messenger = false;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_export_data (struct GMTAPI_CTRL *API, enum GMT_enum_family family, int object_ID, unsigned int mode, void *data) {\n\t/* Function that will export the single data object referred to by the object_ID as registered by GMT_Register_IO.\n\t */\n\tint error, item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tif (API == NULL) return (GMT_NOT_A_SESSION);\t/* GMT_Create_Session has not been called */\n\tif (data == NULL) return (GMT_PTR_IS_NULL);\t\t/* Got a NULL data pointer */\n\tif (!API->registered[GMT_OUT]) return (gmtlib_report_error (API, GMT_NO_OUTPUT));\t\t/* No destination registered yet */\n\n\t/* Get information about this resource first */\n\tif ((item = gmtlib_validate_id (API, family, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return (gmtlib_report_error (API, API->error));\n\n\tS_obj = API->object[item];\t/* The current object we are trying to export */\n\t/* The case where object_ID is not set but a virtual (memory) file is found is a special case: we must supply the correct object_ID */\n\tif (object_ID == GMT_NOTSET && item && S_obj->method != GMT_IS_FILE)\n\t\tobject_ID = S_obj->ID;\t/* Found virtual file; set actual object_ID */\n\n\t/* Check if this is a container passed from the outside to capture output */\n\tgmtapi_reconsider_messenger (API, S_obj);\t/* This may set S_obj->messenger to false in some cases */\n\tif (S_obj->messenger && S_obj->resource) {\t/* Need to destroy the dummy container before passing data out */\n\t\terror = gmtapi_destroy_data_ptr (API, S_obj->actual_family, S_obj->resource);\t/* Do the dirty deed */\n\t\tif (error) return error;\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_export_data: Messenger dummy output container for object %d [item %d] freed and set resource=data=NULL\\n\", S_obj->ID, item);\n\t\tS_obj->resource  = NULL;\t/* Since we now have nothing */\n\t\tS_obj->messenger = false;\t/* OK, now clean for output */\n\t}\n\n#ifdef DEBUG\n\t//gmtapi_list_objects (API, \"gmtapi_export_data-in\");\n#endif\n\t/* PW Note: Important that any exporter needing to create memory to hold an output\n\t * that will be returned to the caller: Never create/duplicate with the API functions\n\t * as these add memory registrations and thus leads to duplicate entries in the objects\n\t * table.  Symptoms of this are memory junk back in the calling program because two objects\n\t * have a pointer to the same memory and one of them is destroyed, messing up the other.\n\t * Use the gmtlib functions like gmt_duplicate_grid, etc for these purposes herein. */\n\n\tswitch (family) {\n\t\tcase GMT_IS_PALETTE:\t/* Export a CPT */\n\t\t\terror = gmtapi_export_palette (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* Export a Data set */\n\t\t\terror = gmtapi_export_dataset (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_GRID:\t/* Export a GMT grid */\n\t\t\terror = gmtapi_export_grid (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* Export a GMT image */\n\t\t\terror = gmtapi_export_image (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_CUBE:\t/* Export a GMT cube */\n\t\t\terror = gmtapi_export_cube (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\t/* Export PS */\n\t\t\terror = gmtapi_export_postscript (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* Export MATRIX */\n\t\t\terror = gmtapi_export_matrix (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* Export VECTOR */\n\t\t\terror = gmtapi_export_vector (API, object_ID, mode, data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n#ifdef DEBUG\n\t//gmtapi_list_objects (API, \"gmtapi_export_data-out\");\n#endif\n\treturn (gmtlib_report_error (API, error));\t/* Return status */\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_put_data (void *V_API, int object_ID, unsigned int mode, void *data) {\n\t/* Function to write data directly from program memory as a set (not record-by-record).\n\t * We can combine the <register resource - export resource > sequence in\n\t * one combined function.  See GMT_Register_IO for details on arguments.\n\t * Here, *data is the pointer to the data object to save (CPT, dataset, Grid)\n\t * ID is the registered destination.\n\t * While only one output destination is allowed, for DATASETS one can\n\t * have the tables and even segments be written to individual files (see the mode\n\t * description in the documentation for how to enable this feature.)\n\t * Return: false if all is well, true if there was an error (and set API->error).\n\t */\n\tint item;\n\tbool was_enabled;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (data == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\t/* Determine the item in the object list that matches this ID and direction */\n\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET) return_error (API, API->error);\n\n\twas_enabled = API->io_enabled[GMT_OUT];\n\tif (!was_enabled && gmtapi_begin_io (API, GMT_OUT) != GMT_NOERROR) {\t/* Enables data output if not already set and sets access mode */\n\t\treturn_error (API, API->error);\n\t}\n\tS_obj = API->object[item];\t/* The current object we are trying to export */\n\tif (gmtapi_export_data (API, S_obj->family, object_ID, mode, data) != GMT_NOERROR) return_error (API, API->error);\n\n\tif (!was_enabled && GMT_End_IO (API, GMT_OUT, 0) != GMT_NOERROR) {\t/* Disables data output if we had to set it in this function */\n\t\treturn_error (API, API->error);\n\t}\n#ifdef DEBUG\n\tgmtapi_set_object (API, S_obj);\n\t//gmtapi_list_objects (API, \"gmtapi_put_data\");\n#endif\n\treturn (GMT_NOERROR);\t/* No error encountered */\n}\n\n/*! See if this file has already been registered and used.  If so, do not add it again */\nGMT_LOCAL bool gmtapi_not_used (struct GMTAPI_CTRL *API, char *name) {\n\tunsigned int item = 0;\n\tbool not_used = true;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\twhile (item < API->n_objects && not_used) {\n\t\tif ((S_obj = API->object[item]) == NULL) continue;\t/* Skip NULLs */\n\t\t\tif (S_obj->direction == GMT_IN && S_obj->status != GMT_IS_UNUSED && S_obj->filename && !strcmp (S_obj->filename, name))\n\t\t\t/* Used resource with same name */\n\t\t\tnot_used = false;\t/* Got item with same name, but used */\n\t\telse\n\t\t\titem++;\t/* No, keep looking */\n\t}\n\treturn (not_used);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_init_import (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int geometry, unsigned int mode, struct GMT_OPTION *head) {\n\t/* Handle registration of data files given with option arguments and/or stdin as input sources.\n\t * These are the possible actions taken:\n\t * 1. If (mode | GMT_ADD_FILES_IF_NONE) is true and NO resources have previously been registered, then we scan the option list for files (option == '<' (input)).\n\t *    For each file found we register the item as a resource.\n\t * 2. If (mode | GMT_ADD_FILES_ALWAYS) is true then we always scan the option list for files (option == '<' (input)).\n\t *    For each file found we register the item as a resource.\n\t * 3. If (mode & GMT_ADD_STDIO_IF_NONE) is true we will register stdin as an input source only if there are NO input items registered.\n\t * 4. If (mode & GMT_ADD_STDIO_ALWAYS) is true we will register stdin as an input source, regardless of other items already registered.\n\t */\n\n\tint object_ID, first_ID = GMT_NOTSET, item;\n \tunsigned int n_reg = 0;\n\tstruct GMT_OPTION *current = NULL;\n\tdouble *wesn = NULL;\n\n\tAPI->error = GMT_NOERROR;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_init_import: Passed family = %s and geometry = %s\\n\", GMT_family[family], GMT_geometry[gmtapi_gmtry(geometry)]);\n\n\tif (mode & GMT_ADD_EXISTING)\n\t\tn_reg = gmtapi_add_existing (API, family, geometry, GMT_IN, &first_ID);\n\n\tif ((mode & GMT_ADD_FILES_ALWAYS) || ((mode & GMT_ADD_FILES_IF_NONE))) {\t/* Wish to register all command-line file args as sources */\n\t\tcurrent = head;\n\t\twhile (current) {\t/* Loop over the list and look for input files */\n\t\t\tif (current->option == GMT_OPT_INFILE && gmtapi_not_used (API, current->arg)) {\t/* File given, register it if has not already been used */\n\t\t\t\tif (geometry == GMT_IS_SURFACE) {\t/* Grids and images may require a subset */\n\t\t\t\t\tif (API->GMT->common.R.active[RSET]) {\t/* Global subset may have been specified (it might also match the grid/image domain) */\n\t\t\t\t\t\twesn = gmt_M_memory (API->GMT, NULL, 4U, double);\n\t\t\t\t\t\tgmt_M_memcpy (wesn, API->GMT->common.R.wesn, 4U, double);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((object_ID = GMT_Register_IO (API, family|GMT_VIA_MODULE_INPUT, GMT_IS_FILE, geometry, GMT_IN, wesn, current->arg)) == GMT_NOTSET) {\n\t\t\t\t\tgmt_M_free (API->GMT, wesn);\n\t\t\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Failure to register */\n\t\t\t\t}\n\t\t\t\tn_reg++;\t/* Count of new items registered */\n\t\t\t\tgmt_M_free (API->GMT, wesn);\n\t\t\t\tif (first_ID == GMT_NOTSET) first_ID = object_ID;\t/* Found our first ID */\n\t\t\t\tif ((item = gmtlib_validate_id (API, family, object_ID, GMT_IN, GMTAPI_MODULE_INPUT)) == GMT_NOTSET)\n\t\t\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Some internal error... */\n\t\t\t\tAPI->object[item]->selected = true;\t/* We will use this variable to find the files to read later */\n\t\t\t}\n\t\t\tcurrent = current->next;\t/* Go to next option */\n\t\t}\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_init_import: Added %d new sources\\n\", n_reg);\n\t}\n\n\t/* Note that n_reg can have changed if we added file args above */\n\n\tif ((mode & GMT_ADD_STDIO_ALWAYS) || ((mode & GMT_ADD_STDIO_IF_NONE) && n_reg == 0)) {\t/* Wish to register stdin pointer as a source */\n\t\tif ((object_ID = GMT_Register_IO (API, family|GMT_VIA_MODULE_INPUT, GMT_IS_STREAM, geometry, GMT_IN, NULL, API->GMT->session.std[GMT_IN])) == GMT_NOTSET)\n\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Failure to register stdin */\n\t\tn_reg++;\t\t/* Add the single item */\n\t\tif (first_ID == GMT_NOTSET) first_ID = object_ID;\t/* Found our first ID */\n\t\tif ((item = gmtlib_validate_id (API, family, object_ID, GMT_IN, GMTAPI_MODULE_INPUT)) == GMT_NOTSET)\n\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Some internal error... */\n\t\tAPI->object[item]->selected = true;\t/* We will use this variable to find stdin to read from later */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_init_import: Added stdin to registered sources\\n\");\n\t}\n\tif (geometry == GMT_IS_TEXT)\n\t\tAPI->GMT->current.io.trailing_text[GMT_IN] = true;\n\treturn (first_ID);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_init_export (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int geometry, unsigned int mode, struct GMT_OPTION *head) {\n\t/* Handle registration of output file given with option arguments and/or stdout as output destinations.\n\t * Only a single output may be considered.  These are the possible actions taken:\n\t * 1. If (mode | GMT_ADD_FILES_IF_NONE) is true and NO destinations have previously been registered,\n\t *    then we scan the option list for files (option == '>' (output)).\n\t *    Only one file can be registered as a destination; finding more than one results in an error.\n\t * 2. If (mode | GMT_ADD_FILES_ALWAYS) is true then we always scan the option list for files (option == '>' (output)).\n\t *    Only one file can be registered as a destination; finding more than one results in an error.\n\t * 3. If (mode & GMT_ADD_STDIO_IF_NONE) is true we will register stdout as the only destination if there is NO output item registered.\n\t * 4. If (mode & GMT_ADD_STDIO_ALWAYS) is true we will register stdout as an destination,\n\t *    and give error if other output items have already been registered.\n\t */\n\n\tunsigned int n_reg = 0;\n\tint object_ID = GMT_NOTSET, item;\n\tstruct GMT_OPTION *current = NULL, *out_item = NULL;\n\n\tAPI->error = GMT_NOERROR;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_init_export: Passed family = %s and geometry = %s\\n\", GMT_family[family], GMT_geometry[gmtapi_gmtry(geometry)]);\n\n\tif (mode & GMT_ADD_EXISTING)\n\t\tn_reg = gmtapi_add_existing (API, family, geometry, GMT_OUT, &object_ID);\n\tif (n_reg > 1) return_value (API, GMT_ONLY_ONE_ALLOWED, GMT_NOTSET);\t/* Only one output allowed */\n\n\tif ((mode & GMT_ADD_FILES_ALWAYS) || (mode & GMT_ADD_FILES_IF_NONE)) {\t/* Wish to register a single output file arg as destination */\n\t\tcurrent = head;\n\t\twhile (current) {\t/* Loop over the list and look for output files */\n\t\t\tif (current->option == GMT_OPT_OUTFILE) {\t/* Output file given */\n\t\t\t\tn_reg++;\t/* Count it */\n\t\t\t\tout_item = current;\t/* Remember which one it was for later */\n\t\t\t}\n\t\t\tcurrent = current->next;\t\t\t\t/* Go to next option */\n\t\t}\n\t\tif (n_reg > 1) return_value (API, GMT_ONLY_ONE_ALLOWED, GMT_NOTSET);\t/* Only one output allowed */\n\n\t\tif (n_reg == 1 && out_item) {\t/* Register the single output file found above */\n\t\t\tif ((object_ID = GMT_Register_IO (API, family, GMT_IS_FILE, geometry, GMT_OUT, NULL, out_item->arg)) == GMT_NOTSET)\n\t\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Failure to register */\n\t\t\tif ((item = gmtlib_validate_id (API, family, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Some internal error... */\n\t\t\tAPI->object[item]->selected = true;\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_init_export: Added 1 new destination\\n\");\n\t\t}\n\t}\n\t/* Note that n_reg may have changed if we added file arg */\n\n\tif ((mode & GMT_ADD_STDIO_ALWAYS) && n_reg == 1)\n\t\treturn_value (API, GMT_ONLY_ONE_ALLOWED, GMT_NOTSET);\t/* Only one output destination allowed at once */\n\n\tif (n_reg == 0 && ((mode & GMT_ADD_STDIO_ALWAYS) || (mode & GMT_ADD_STDIO_IF_NONE))) {\t/* Wish to register stdout pointer as a destination */\n\t\tif ((object_ID = GMT_Register_IO (API, family, GMT_IS_STREAM, geometry, GMT_OUT, NULL, API->GMT->session.std[GMT_OUT])) == GMT_NOTSET)\n\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Failure to register stdout?*/\n\t\tif ((item = gmtlib_validate_id (API, family, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\treturn_value (API, API->error, GMT_NOTSET);\t/* Some internal error... */\n\t\tAPI->object[item]->selected = true;\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_init_export: Added stdout to registered destinations\\n\");\n\t\tn_reg = 1;\t/* Only have one item */\n\t}\n\tif (n_reg == 0) return_value (API, GMT_OUTPUT_NOT_SET, GMT_NOTSET);\t/* No output set */\n\treturn (object_ID);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_destroy_image (struct GMTAPI_CTRL *API, struct GMT_IMAGE **I_obj) {\n\t/* Delete the given image resource */\n\tstruct GMT_IMAGE_HIDDEN  *IH = NULL;\n\tif (!(*I_obj)) {\t/* Probably not a good sign */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_destroy_image: Passed NULL pointer - skipped\\n\");\n\t\treturn (GMT_PTR_IS_NULL);\n\t}\n\tIH = gmt_get_I_hidden (*I_obj);\n\tif (IH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);\t/* Not the right level */\n\n\tgmtlib_free_image (API->GMT, I_obj, true);\n\treturn GMT_NOERROR;\n}\n\n/*! . */\nGMT_LOCAL struct GMTAPI_DATA_OBJECT * gmtapi_make_dataobject (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int method, unsigned int geometry, void *resource, unsigned int direction) {\n\t/* Simply the creation and initialization of this DATA_OBJECT structure */\n\tstruct GMTAPI_DATA_OBJECT *S_obj = gmt_M_memory (API->GMT, NULL, 1, struct GMTAPI_DATA_OBJECT);\n\n\tS_obj->family    = S_obj->actual_family = family;\t/* At creation we are all equal */\n\tS_obj->method    = method;\n\tS_obj->geometry  = geometry;\n\tS_obj->resource  = resource;\n\tS_obj->direction = direction;\n\n\treturn (S_obj);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_colors2cpt (struct GMTAPI_CTRL *API, char **str, unsigned int *mode) {\n\t/* Take comma-separated color entries given in lieu of a file and build a linear, discrete CPT.\n\t * This may be converted to a continuous CPT if -Z is used by makecpt/grd2cpt.\n\t * We check if a color is valid then write the given entries verbatim to the temp file.\n\t * Returns GMT_NOTSET on error, 0 if no CPT is created (str presumably held a CPT name) and 1 otherwise.\n\t*/\n\tunsigned int pos = 0, z = 0;\n\tchar *pch = NULL, color[GMT_LEN256] = {\"\"}, tmp_file[GMT_LEN64] = \"\";\n\tdouble rgb[4] = {0.0, 0.0, 0.0, 0.0};\n\tFILE *fp = NULL;\n\n\tif (!(pch = strchr (*str, ','))) {\t/* No comma so presumably a regular CPT name, but check for single color entry */\n\t\tbool gray = true;\n\t\tsize_t k;\n\t\tconst size_t s_length = strlen(*str);\n\t\t /* Since \"gray\" is both a master CPT and a shade we must let the CPT take precedence */\n\t\tif (!strcmp (*str, \"gray\"))\n\t\t\treturn (0);\n\t\t/* Because gmtlib_is_color cannot uniquely determine what a single number is, check for that separately first. */\n\t\tfor (k = 0; gray && k < s_length; k++)\n\t\t\tif (!isdigit ((*str)[k])) gray = false;\t/* Not just a bunch of integers */\n\t\tif (gray) {\t/* Must also rule out temporary files like 14334.cpt since the GMT_CPT_EXTENSION is not present */\n\t\t\tsnprintf (tmp_file, GMT_LEN64, \"%s%s\", *str, GMT_CPT_EXTENSION);\t/* Try this as a filename */\n\t\t\tif (!gmt_access (API->GMT, tmp_file, F_OK))\n\t\t\t\treturn 0;\t/* Probably a process id temp file like 13223.cpt */\n\t\t}\n\t\tif (!gray && !gmtlib_is_color (API->GMT, *str))\t/* Not a single color/shade, skip */\n\t\t\treturn (0);\n\t}\n\n\t/* OK, here we need to create the temporary palette file */\n\tsnprintf (tmp_file, GMT_LEN64, \"gmtapi_colors2cpt_%d.cpt\", (int)getpid());\n\tif ((fp = fopen (tmp_file, \"w\")) == NULL) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to open file %s file for writing\\n\", tmp_file);\n\t\treturn (GMT_NOTSET);\n\t}\n\tfprintf (fp, \"# COLOR_LIST\\n\");\t/* Flag that we are building a CPT from a list of discrete colors */\n\n\tif ((*mode) & GMT_CPT_CONTINUOUS) {\t/* Make a continuous cpt from the colors */\n\t\tchar last_color[GMT_LEN256] = {\"\"};\n\t\tif (!gmt_strtok (*str, \",\", &pos, last_color)) {\t/* Get 1st color entry */\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to find 1st color entry in: %s\\n\", *str);\n\t\t\tfclose (fp);\n\t\t\treturn (GMT_NOTSET);\n\t\t}\n\t\tif (gmt_getrgb (API->GMT, last_color, rgb)) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Badly formatted color entry: %s\\n\", color);\n\t\t\tfclose (fp);\n\t\t\treturn (GMT_NOTSET);\n\t\t}\n\t\twhile (gmt_strtok (*str, \",\", &pos, color)) {\t/* Get color entries */\n\t\t\tif (gmt_getrgb (API->GMT, color, rgb)) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Badly formatted color entry: %s\\n\", color);\n\t\t\t\tfclose (fp);\n\t\t\t\treturn (GMT_NOTSET);\n\t\t\t}\n\t\t\tfprintf (fp, \"%d\\t%s\\t%d\\t%s\\n\", z, last_color, z+1, color);\n\t\t\tstrncpy (last_color, color, GMT_LEN256-1);\n\t\t\tz++;\t/* Increment z-slice values */\n\t\t}\n\t\t*mode -= GMT_CPT_CONTINUOUS;\t/* Served its purpose */\n\t\tif (z == 0) {\t/* Needed at least two colors to specify a ramp */\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Cannot make a continuous color ramp from a single color: %s\\n\", *str);\n\t\t\tfclose (fp);\n\t\t\treturn (GMT_NOTSET);\n\t\t}\n\t}\n\telse {\n\t\twhile (gmt_strtok (*str, \",\", &pos, color)) {\t/* Get color entries */\n\t\t\tif (gmt_getrgb (API->GMT, color, rgb)) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Badly formatted color entry: %s\\n\", color);\n\t\t\t\tfclose (fp);\n\t\t\t\treturn (GMT_NOTSET);\n\t\t\t}\n\t\t\tfprintf (fp, \"%d\\t%s\\t%d\\t%s\\n\", z, color, z+1, color);\n\t\t\tz++;\t/* Increment z-slice values */\n\t\t}\n\t}\n\tfclose (fp);\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Converted %s to CPT %s\\n\", *str, tmp_file);\n\n\tgmt_M_str_free (*str);\t\t/* Because it was allocated with strdup */\n\t*str = strdup (tmp_file);\t/* Pass out the temp file name instead */\n\n\treturn (1);\t/* We replaced the name */\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_destroy_coord (struct GMTAPI_CTRL *API, double **ptr) {\n\tgmt_M_free (API->GMT, *ptr);\n\treturn GMT_NOERROR;\n}\n\n/*! Also called in gmt_init.c and prototyped in gmt_internals.h: */\nvoid gmtlib_garbage_collection (struct GMTAPI_CTRL *API, int level) {\n\t/* gmtlib_garbage_collection frees all registered memory associated with the\n\t * current module level or for the entire session if level == GMT_NOTSET (-1). */\n\n\tunsigned int i, j, n_free = 0, u_level = 0;\n\tint error = GMT_NOERROR;\n\tvoid *address = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tif (API->n_objects == 0) return;\t/* Nothing to do */\n\n#ifdef DEBUG\n\tgmtapi_list_objects (API, \"GMTAPI_Garbage_Collection entry\");\n#endif\n\t/* Free memory allocated during data registration (e.g., via GMT_Get|Put_Data).\n\t * Because gmtlib_unregister_io will delete an object and shuffle\n\t * the API->object array, reducing API->n_objects by one we must\n\t * be aware that API->n_objects changes in the loop below, hence the while loop */\n\n\ti = n_free = 0;\n\tif (level != GMT_NOTSET) u_level = level;\n\twhile (i < API->n_objects) {\t/* While there are more objects to consider */\n\t\tS_obj = API->object[i];\t/* Shorthand for the the current object */\n\t\tif (!S_obj) {\t\t/* Skip empty object [NOTE: Should not happen?] */\n\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"gmtlib_garbage_collection found empty object number %d [Bug?]\\n\", i++);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(level == GMT_NOTSET || S_obj->alloc_level == u_level)) {\t/* Not the right module level (or not end of session yet) */\n\t\t\tif (S_obj->reset_pad && S_obj->no_longer_owner == false) {\t/* Temporarily changed pad to access a sub-region of a memory grid - now reset this if still the owner */\n\t\t\t\taddress = S_obj->resource;\t/* Try to get the data object */\n\t\t\t\tgmtlib_contract_pad (API->GMT, address, S_obj->actual_family, S_obj->orig_pad, S_obj->orig_wesn);\n\t\t\t\tS_obj->reset_pad = 0;\n\t\t\t}\n\t\t\ti++;\tcontinue;\n\t\t}\n\t\tif (S_obj->resource == NULL) {\t/* No memory to free (probably freed earlier); handle trashing of empty object after this loop */\n\t\t\ti++;\tcontinue;\n\t\t}\n\t\tif (level != GMT_NOTSET && S_obj->no_longer_owner) {\t/* No memory to free since we passed it on; just NULL the pointers */\n\t\t\tS_obj->resource = NULL;\t\t\t\t/* Since other objects own the data now */\n\t\t\tS_obj->alloc_level = u_level;\t\t\t/* To ensure it will be Unregistered below */\n\t\t\tS_obj->alloc_mode = GMT_ALLOC_INTERNALLY;\t/* To ensure it will be Unregistered below */\n\t\t\ti++;\tcontinue;\n\t\t}\n\t\t/* Here we will try to free the memory pointed to by S_obj->resource|data */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtlib_garbage_collection: Destroying object: C=%d A=%d ID=%d W=%s F=%s M=%s S=%s P=%\" PRIxS \" N=%s\\n\",\n\t\t\tS_obj->close_file, S_obj->alloc_mode, S_obj->ID, GMT_direction[S_obj->direction],\n\t\t\tGMT_family[S_obj->family], gmtapi_method (S_obj->method), GMT_status[S_obj->status&2],\n\t\t\t(size_t)S_obj->resource, S_obj->filename);\n\t\tif (S_obj->resource) {\n\t\t\taddress = S_obj->resource;\t/* Keep a record of what the address was (since S_obj->resource will be set to NULL when freed) */\n\t\t\terror = gmtapi_destroy_data_ptr (API, S_obj->actual_family, API->object[i]->resource);\t/* Do the dirty deed */\n\t\t}\n\n\t\tif (error < 0) {\t/* Failed to destroy this memory; that cannot be a good thing... */\n\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"gmtlib_garbage_collection failed to destroy memory for object % d [Bug?]\\n\", i++);\n\t\t\t/* Skip it for now; but this is possibly a fatal error [Bug]? */\n\t\t}\n\t\telse  {\t/* Successfully freed.  See if this address occurs more than once (e.g., both for in and output); if so just set repeated data pointer to NULL */\n\t\t\tS_obj->resource = NULL;\n\t\t\tfor (j = i; j < API->n_objects; j++) {\n\t\t\t\tif (API->object[j]->resource == address)\n\t\t\t\t\tAPI->object[j]->resource = NULL;\t/* Yes, set to NULL so we don't try to free twice */\n\t\t\t}\n\t\t\tn_free++;\t/* Number of freed n_objects; do not increment i since GMT_Destroy_Data shuffled the array */\n\t\t}\n\t\ti++;\t/* Go to next object */\n\t}\n \tif (n_free) GMT_Report (API, GMT_MSG_DEBUG, \"GMTAPI_Garbage_Collection freed %d memory objects\\n\", n_free);\n\n\t/* Deallocate all remaining objects associated with NULL pointers (e.g., rec-by-rec i/o or those set to NULL above) set during this module (or session) */\n\ti = 0;\n\twhile (i < API->n_objects) {\t/* While there are more objects to consider */\n\t\tS_obj = API->object[i];\t/* Shorthand for the the current object */\n\t\tif (S_obj && (level == GMT_NOTSET || (S_obj->alloc_level == u_level)))\t/* Yes, this object was added at this level, get rid of it; do not increment i */\n\t\t\tgmtlib_unregister_io (API, (int)S_obj->ID, (unsigned int)GMT_NOTSET);\t/* This shuffles the object array and reduces n_objects */\n\t\telse\n\t\t\ti++;\t/* Was allocated higher up, leave alone and go to next */\n\t}\n#ifdef DEBUG\n\tgmtapi_list_objects (API, \"GMTAPI_Garbage_Collection exit\");\n#endif\n}\n\n/*! Determine if file contains a netCDF directive to a specific variable, e.g., table.nc?time[2] */\nGMT_LOCAL bool gmtapi_file_with_netcdf_directive (struct GMTAPI_CTRL *API, const char *file) {\n\tchar *duplicate = NULL, *c = NULL;\n\tif (!strchr (file, '?')) return false;  /* No question mark found */\n\tduplicate = strdup (file);              /* Found a ?, duplicate this const char string and chop off the end */\n\tc = strchr (duplicate, '?');            /* Locate the location of ? again */\n\tif (c) c[0] = '\\0';                     /* Chop off text from ? onwards */\n\tif (gmt_access (API->GMT, duplicate, F_OK)) {\t/* No such file, presumably */\n\t\tfree (duplicate);\n\t\treturn false;\n\t}\n\telse {\t/* Since the file exist we know it is a netCDF directive */\n\t\tfree (duplicate);\n\t\treturn true;\n\t}\n}\n\n/* Several lower-level API function are needed in a few other gmt_*.c library codes and are thus NOT local.\n * They are listed here and declared via EXTERN_MSC where they occur:\n *   gmtlib_report_error\n *   gmtlib_validate_id\n *   gmtlib_unregister_io\n *   gmtlib_count_objects\n *   gmtlib_close_grd\n *   gmtlib_create_header_item\n * If DEBUG is defined then these two are also accessible:\n *   gmtapi_list_objects\n *   gmtapi_set_object\n */\n\n\n/*! ===>  Error message reporting */\n\nint gmtlib_report_error (void *V_API, int error) {\n\t/* Write error message to log or stderr, then return error code back.\n \t * All functions can call this, even if API has not been initialized. */\n\tFILE *fp = NULL;\n\tbool report;\n\tchar message[GMT_LEN256];\n\tstruct GMTAPI_CTRL *API = gmtapi_get_api_ptr (V_API);\n\n\treport = (API) ? API->error != API->last_error : true;\n\tif (report && error != GMT_NOERROR) {\t/* Report error */\n\t\tif (!API || !API->GMT || (fp = API->GMT->session.std[GMT_ERR]) == NULL) fp = stderr;\n\t\tif (API && API->session_tag) {\n\t\t\tsnprintf (message, GMT_LEN256, \"[Session %s (%d)]: Error returned from GMT API: %s (%d)\\n\",\n\t\t\t\tAPI->session_tag, API->session_ID, gmt_api_error_string[error], error);\n\t\t\tGMT_Message (API, GMT_TIME_NONE, message);\n\t\t\tif (API->log_level) fflush (fp);\t/* Flush the latest message to file in case of crash */\n\t\t}\n\t\telse\n\t\t\tfprintf (fp, \"Error returned from GMT API: %s (%d)\\n\", gmt_api_error_string[error], error);\n\t}\n\tif (API) API->last_error = API->error, API->error = error;\t/* Update API error value if API exists */\n\treturn (error);\n}\n\n/*! . */\nint gmtlib_validate_id (struct GMTAPI_CTRL *API, int family, int object_ID, int direction, int module_input) {\n\t/* Checks to see if the given object_ID is listed and of the right direction.  If so\n \t * we return the item number; otherwise return GMT_NOTSET and set API->error to the error code.\n\t * Note: int arguments MAY be GMT_NOTSET, hence we use signed ints.  If object_ID == GMT_NOTSET\n\t * then we only look for DATASETS.  Note: module_input controls if we are being very specific\n\t * about the type of input resource.  There are module inputs and option inputs. We have:\n\t * module_input = GMT_NOTSET [-1]:\tDo not use the resource's module_input status in determining the next ID.\n\t * module_input = GMTAPI_OPTION_INPUT [0]:\tOnly validate resources with module_input = false.\n\t * module_input = GMTAPI_MODULE_INPUT [1]:\tOnly validate resources with module_input = true.\n\t * Finally, since we allow vectors and matrices to masqerade as DATASETs we check for this and\n\t * rebaptize such objects to become GMT_IS_DATASETs. */\n\tunsigned int i;\n\tint item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tAPI->error = GMT_NOERROR;\n\n\t /* Search for the object in the active list.  However, if object_ID == GMT_NOTSET we pick the first in that direction */\n\n\tfor (i = 0, item = GMT_NOTSET; item == GMT_NOTSET && i < API->n_objects; i++) {\n\t\tS_obj = API->object[i];\t/* Shorthand only */\n\t\tif (!S_obj) continue;\t\t\t\t\t\t\t\t/* Empty object */\n\t\tif (direction != GMT_NOTSET && (int)S_obj->direction != direction) continue;\t\t/* Not the same direction */\n\t\tif (direction == GMT_IN && S_obj->status != GMT_IS_UNUSED && object_ID == GMT_NOTSET) continue;\t\t/* Already used this input object once */\n\t\tif (!(family == GMT_NOTSET || (int)S_obj->family == family)) {\t\t/* Not the required data type; check for exceptions... */\n\t\t\tif (family == GMT_IS_DATASET && (S_obj->actual_family == GMT_IS_VECTOR || S_obj->actual_family == GMT_IS_MATRIX))\n\t\t\t\tS_obj->family = GMT_IS_DATASET;\t/* Vectors or Matrix masquerading as dataset are valid. Change their family here. */\n\t\t\telse if (family == GMT_IS_GRID && S_obj->actual_family == GMT_IS_MATRIX)\n\t\t\t\tS_obj->family = GMT_IS_GRID;\t/* Matrix masquerading as grids is valid. Change the family here. */\n\t\t\telse\t/* We don't like your kind */\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (object_ID == GMT_NOTSET && (int)S_obj->direction == direction) item = i;\t/* Pick the first object with the specified direction */\n\t\tif (object_ID == GMT_NOTSET && !(S_obj->family == GMT_IS_DATASET)) continue;\t/* Must be data/text-set */\n\t\telse if (direction == GMT_NOTSET && (int)S_obj->ID == object_ID) item = i;\t/* Pick the requested object regardless of direction */\n\t\telse if ((int)S_obj->ID == object_ID) item = i;\t\t\t\t\t/* Pick the requested object */\n\t\tif (item != GMT_NOTSET && direction == GMT_IN && module_input != GMT_NOTSET) {\t\t/* Must check that object's module_input status matches */\n\t\t\tbool status = (module_input == GMTAPI_MODULE_INPUT) ? true : false;\n\t\t\tif (status != S_obj->module_input) item = GMT_NOTSET;\t/* Not the right type of input resource */\n\t\t}\n\t}\n\tif (item == GMT_NOTSET) return_value (API, GMT_NOT_A_VALID_ID, GMT_NOTSET);\t\t/* No such object found */\n\n\t/* OK, we found the object; is it the right kind (input or output)? */\n\tif (direction != GMT_NOTSET && (int)(API->object[item]->direction) != direction) {\n\t\t/* Passing an input object but it is listed as output, or vice versa */\n\t\tif (direction == GMT_IN)  return_value (API, GMT_NOT_INPUT_OBJECT, GMT_NOTSET);\n\t\tif (direction == GMT_OUT) return_value (API, GMT_NOT_OUTPUT_OBJECT, GMT_NOTSET);\n\t}\n\t/* Here we have been successful in finding the right object */\n\treturn (item);\n}\n\n/*! . */\nint gmtlib_unregister_io (struct GMTAPI_CTRL *API, int object_ID, unsigned int direction) {\n\t/* Remove specified object ID from active list of objects */\n\tint s_item;\n\tunsigned item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\n\tif (API == NULL) return (GMT_NOT_A_SESSION);\t\t/* GMT_Create_Session has not been called */\n\tif (API->n_objects == 0) return (gmtlib_report_error (API, GMT_NO_RESOURCES));\t/* There are no known resources yet */\n\n\t/* Check if this is a valid ID and matches the direction */\n\tif ((s_item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, direction, GMT_NOTSET)) == GMT_NOTSET) return (gmtlib_report_error (API, API->error));\n\n\t/* OK, now it is safe to remove the object; item >= 0 */\n\n\titem = s_item;\n\tS_obj = API->object[item];\t/* Short-hand */\n\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtlib_unregister_io: Unregistering object no %d [n_objects = %d]\\n\", S_obj->ID, API->n_objects-1);\n \tif (S_obj->resource) GMT_Report (API, GMT_MSG_DEBUG, \"gmtlib_unregister_io: Object no %d has non-NULL resource pointer\\n\", S_obj->ID);\n\n\tif (S_obj->method == GMT_IS_FILE) gmt_M_str_free (S_obj->filename);\t/* Free any strdup-allocated filenames */\n\tgmt_M_free (API->GMT, S_obj);\t\t/* Free the current data object */\n\tAPI->n_objects--;\t\t\t\t/* Tally of how many data sets are left */\n\twhile (item < API->n_objects) {\n\t\tAPI->object[item] = API->object[item+1];\t/* Shuffle pointers down one entry */\n\t\titem++;\n\t}\n\n\t/* All active resources are found consecutively from 0 to (API->n_objects-1); those with status == 0 (GMT_IS_UNUSED) are available for use. */\n\treturn GMT_NOERROR;\n}\n\n/*! . */\nunsigned int gmtlib_count_objects (struct GMTAPI_CTRL *API, enum GMT_enum_family family, unsigned int geometry, unsigned int direction, int *first_ID) {\n\t/* Count how many data sets of the given family are currently registered and unused for the given direction (GMT_IN|GMT_OUT).\n \t * Also return the ID of the first unused data object for the given direction, geometry, and family (GMT_NOTSET if not found).\n\t */\n\tunsigned int i, n;\n\n\t*first_ID = GMT_NOTSET;\t/* Not found yet */\n\tfor (i = n = 0; i < API->n_objects; i++) {\n\t\tif (!API->object[i]) continue;\t /* A freed object, skip it */\n\t\tif (API->object[i]->direction != (enum GMT_enum_std)direction) continue;\t  /* Wrong direction */\n\t\tif (API->object[i]->geometry  != (enum GMT_enum_geometry)geometry) continue;\t  /* Wrong geometry */\n\t\tif (API->object[i]->status    != GMT_IS_UNUSED) continue; /* Already used */\n\t\tif (family != API->object[i]->family) continue;\t\t  /* Wrong data type */\n\t\tn++;\t/* Found one that satisfied requirements */\n\t\tif (*first_ID == GMT_NOTSET) *first_ID = API->object[i]->ID;\n\t}\n\treturn (n);\n}\n\n/*! . */\nchar * gmtlib_create_header_item (struct GMTAPI_CTRL *API, unsigned int mode, void *arg) {\n\tsize_t lim;\n\tchar *txt = (mode & GMT_COMMENT_IS_OPTION) ? GMT_Create_Cmd (API, arg) : (char *)arg;\n\tstatic char buffer[GMT_BUFSIZ];\n\tgmt_M_memset (buffer, GMT_BUFSIZ, char);\n\tif (mode & GMT_COMMENT_IS_TITLE) strcat (buffer, \"  Title :\");\n\tif (mode & GMT_COMMENT_IS_COMMAND) {\n\t\tstrcat (buffer, \" Command : \");\n\t\tif (strlen(API->GMT->init.module_name) < 500)\t\t/* 500, just to shut up a Coverity issue */\n\t\t\tstrcat (buffer, API->GMT->init.module_name);\n\t\tstrcat (buffer, \" \");\n\t}\n    if (mode & GMT_COMMENT_IS_REMARK) strcat (buffer, \" Remark : \");\n\tif (mode & GMT_COMMENT_IS_MULTISEG) strcat (buffer, \"> \");\n\tlim = GMT_BUFSIZ - strlen (buffer) - 1;\t/* Max characters left */\n\tstrncat (buffer, txt, lim);\n\tif (mode & GMT_COMMENT_IS_OPTION) gmt_M_free (API->GMT, txt);\n\treturn (buffer);\n}\n\n/*! . */\nvoid gmtlib_close_grd (struct GMT_CTRL *GMT, struct GMT_GRID *G) {\n\tstruct GMT_GRID_HIDDEN *GH = gmt_get_G_hidden (G);\n\tstruct GMT_GRID_ROWBYROW *R = gmtapi_get_rbr_ptr (GH->extra);\t/* Shorthand to row-by-row book-keeping structure */\n\tgmt_M_free (GMT, R->v_row);\n\tif (GMT->session.grdformat[G->header->type][0] == 'c' || GMT->session.grdformat[G->header->type][0] == 'n')\n\t\tgmt_nc_close (GMT, R->fid);\n\telse\n\t\tgmt_fclose (GMT, R->fp);\n\tgmt_M_free (GMT, GH->extra);\n}\n\n/*========================================================================================================\n *          HERE ARE THE PUBLIC GMT API UTILITY FUNCTIONS, WITH THEIR FORTRAN BINDINGS\n *========================================================================================================\n */\n\n/*! ===>  Create a new GMT Session */\n\nvoid * GMT_Create_Session (const char *session, unsigned int pad, unsigned int mode, int (*print_func) (FILE *, const char *)) {\n\t/* Initializes the GMT API for a new session. This is typically called once in a program,\n\t * but programs that manage many threads might call it several times to create as many\n\t * sessions as needed. [Note: There is of yet no thread support built into the GMT API\n\t * but you could still manage many sessions at once].\n\t * The session argument is a textstring used when reporting errors or messages from activity\n\t *   originating within this session.\n\t * Pad sets the default number or rows/cols used for grid padding.  GMT uses 2; users of\n\t *   the API may wish to use 0 if they have no need for BCs, etc.\n\t * The mode argument is a bitflag that controls a few things [0, or GMT_SESSION_NORMAL]:\n\t *   bit 1 (GMT_SESSION_NOEXIT)   means call return and not exit when returning from an error.\n\t *   bit 2 (GMT_SESSION_EXTERNAL) means we are called by an external API (e.g., MATLAB, Python).\n\t *   bit 3 (GMT_SESSION_COLMAJOR) means the external API uses column-major format (e.g., MATLAB, Fortran) [Default is row-major, i.e., C/C++, Python]\n\t *   bit 4 (GMT_SESSION_LOGERRORS) means we redirect stderr to a log file whose name is the session string + log.\n\t *   We reserve the right to add future flags.\n\t * We return the pointer to the allocated API structure.\n\t * If any error occurs we report the error, set the error code via API->error, and return NULL.\n\t * We terminate each session with a call to GMT_Destroy_Session.\n\t */\n\n\tstruct GMTAPI_CTRL *API = NULL;\n\tsize_t len;\n\tstatic char *unknown = \"unknown\";\n\tchar *dir = NULL;\n\n\tif ((API = calloc (1, sizeof (struct GMTAPI_CTRL))) == NULL) return_null (NULL, GMT_MEMORY_ERROR);\t/* Failed to allocate the structure */\n\tAPI->verbose = (mode >> 16);\t/* Pick up any -V settings from gmt.c */\n\tAPI->pad = pad;\t\t/* Preserve the default pad value for this session */\n\tAPI->print_func = (print_func == NULL) ? gmtapi_print_func : print_func;\t/* Pointer to the print function to use in GMT_Message|Report */\n\tAPI->do_not_exit = mode & GMT_SESSION_NOEXIT;\t/* Deprecated, we no longer call exit anywhere in the API (gmt_api.c) */\n\tAPI->external = mode & GMT_SESSION_EXTERNAL;\t/* if false|0 then we don't list read and write as modules */\n\tAPI->shape = (mode & GMT_SESSION_COLMAJOR) ? GMT_IS_COL_FORMAT : GMT_IS_ROW_FORMAT;\t\t/* if set then we must use column-major format [row-major] */\n\tAPI->runmode = mode & GMT_SESSION_RUNMODE;\t\t/* If nonzero we set up modern GMT run-mode, else classic */\n\tAPI->no_history = mode & GMT_SESSION_NOHISTORY;\t\t/* If nonzero we disable the gmt.history mechanism (shorthands) entirely */\n\tif (API->internal) API->leave_grid_scaled = 1;\t/* Do NOT undo grid scaling after write since modules do not reuse grids we save some CPU */\n\tif (session) {\t/* Pick up a tag for this session */\n\t\tchar *tmptag = strdup (session);\n\t\tAPI->session_tag = strdup (basename (tmptag));\t/* Only used in reporting and error messages */\n\t\tgmt_M_str_free (tmptag);\n\t}\n\n\tif ((API->message = calloc (4*GMT_BUFSIZ, sizeof (char))) == NULL) {\t/* Failed to allocate the message string */\n\t \tgmt_M_str_free (API);\t/* Not gmt_M_free since this item was allocated before GMT was initialized */\n\t\treturn_null (NULL, GMT_MEMORY_ERROR);\n\t}\n\n\t/* Set temp directory used by GMT */\n\n#ifdef WIN32\n\tif ((dir = getenv (\"TEMP\")))\t/* Standard Windows temp directory designation */\n\t\tAPI->tmp_dir = strdup (dir);\n\t/* If not found we leave it NULL */\n#else\n\tif ((dir = getenv (\"TMPDIR\")))\t/* Alternate tmp dir for *nix */\n\t\tAPI->tmp_dir = strdup (dir);\n\telse\t/* Set standard temporary directory under *nix */\n\t\tAPI->tmp_dir = strdup (\"/tmp\");\n#endif\n\tif ((len = strlen (API->tmp_dir)) > 2 && API->tmp_dir[len-1] == '/') API->tmp_dir[len-1] = '\\0';\t/* Chop off trailing slash */\n\tAPI->session_name = gmtapi_get_ppid (API);\t\t/* Save session name for the rest of the session */\n\n\t/* gmt_begin initializes, among other things, the settings in the user's (or the system's) gmt.conf file */\n\tif (gmt_begin (API, session, pad) == NULL) {\t\t/* Initializing GMT and PSL machinery failed */\n\t\tgmt_M_str_free (API);\t/* Free API */\n\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t}\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Create_Session initialized GMT structure\\n\");\n\n\tif (mode & GMT_SESSION_LOGERRORS) {\t/* Want to redirect errors to a log file */\n\t\tchar file[PATH_MAX] = {\"\"};\n\t\tFILE *fp = NULL;\n\t\tif (API->session_tag == NULL) {\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Must pass a session tag to be used for error log file name\\n\");\n\t\t\treturn_null (API, GMT_ARG_IS_NULL);\n\t\t}\n\t\tsnprintf (file, PATH_MAX, \"%s.log\", API->session_tag);\n\t\tif ((fp = fopen (file, \"w\")) == NULL) {\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Unable to open error log file %s\\n\", file);\n\t\t\treturn_null (API, GMT_ERROR_ON_FOPEN);\n\t\t}\n\t\tAPI->GMT->session.std[GMT_ERR] = fp;\t/* Set the error fp pointer */\n\t\tAPI->log_level = GMT_LOG_SET;\n\t}\n\n\tAPI->n_cores = gmtlib_get_num_processors();\t/* Get number of available CPU cores */\n\tGMTAPI_index_function = gmtapi_get_index_from_TRS;\t/* Default grid node lookup */\n\n\t/* Allocate memory to keep track of registered data resources */\n\n\tAPI->n_objects_alloc = GMT_SMALL_CHUNK;\t/* Start small; this may grow as more resources are registered */\n\tAPI->object = gmt_M_memory (API->GMT, NULL, API->n_objects_alloc, struct GMTAPI_DATA_OBJECT *);\n\n\t/* Set the unique Session parameters */\n\n\tAPI->session_ID = GMTAPI_session_counter++;\t\t/* Guarantees each session ID will be unique and sequential from 0 up */\n\tif (session)\n\t\tAPI->GMT->init.module_name = API->session_tag;\t/* So non-modules can report name of program, */\n\telse\n\t\tAPI->GMT->init.module_name = unknown; /* or unknown */\n\n\tif (gmtapi_init_sharedlibs (API) < 0)\t\t\t\t/* Count how many shared libraries we should know about, and get their names and paths */\n\t\treturn_null (API, GMT_RUNTIME_ERROR);\n\n\treturn (API);\t/* Pass the structure back out */\n}\n\n#ifdef FORTRAN_API\n/* Fortran binding [THESE MAY CHANGE ONCE WE ACTUALLY TRY TO USE THESE] */\nstruct GMTAPI_CTRL * GMT_Create_Session_ (const char *tag, unsigned int *pad, unsigned int *mode, void *print, int len) {\n\t/* Fortran version: We pass the hidden global GMT_FORTRAN structure */\n\treturn (GMT_Create_Session (tag, *pad, *mode, print));\n}\n#endif\n\n/*! ===>  Destroy a registered GMT Session */\n\nint GMT_Destroy_Session (void *V_API) {\n\t/* GMT_Destroy_Session terminates the information for the specified session and frees all memory.\n\t * Returns false if all is well and true if there were errors. */\n\n\tunsigned int i;\n\tchar *module = NULL;\n\tstruct GMTAPI_CTRL *API = gmtapi_get_api_ptr (V_API);\n\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\t/* GMT_Create_Session has not been called */\n\tAPI->error = GMT_NOERROR;\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Entering GMT_Destroy_Session\\n\");\n\tmodule = strdup (API->GMT->init.module_name);\t/* Need a copy as the pointer to static memory in library will close soon */\n\tgmtlib_garbage_collection (API, GMT_NOTSET);\t/* Free any remaining memory from data registration during the session */\n\tgmtapi_free_sharedlibs (API);\t\t\t/* Close shared libraries and free list */\n\tAPI->GMT->init.module_name = module;\t\t/* So GMT_Report will function after GMT_SUPPL_LIB_NAME.so shut down */\n\n\t/* Deallocate all remaining objects associated with NULL pointers (e.g., rec-by-rec i/o) */\n\tfor (i = 0; i < API->n_objects; i++) gmtlib_unregister_io (API, (int)API->object[i]->ID, (unsigned int)GMT_NOTSET);\n\tgmt_M_free (API->GMT, API->object);\n\tif (API->GMT->session.std[GMT_ERR] != stderr)\t/* Close the error log fp pointer */\n\t\tfclose (API->GMT->session.std[GMT_ERR]);\n\tgmt_end (API->GMT);\t/* Terminate GMT machinery */\n\tgmt_M_str_free (API->session_tag);\n\tgmt_M_str_free (API->session_name);\n\tgmt_M_str_free (API->tmp_dir);\n\tgmt_M_str_free (API->session_dir);\n\tgmt_M_str_free (API->message);\n\tgmt_M_memset (API, 1U, struct GMTAPI_CTRL);\t/* Wipe it clean first */\n \tgmt_M_str_free (API);\t/* Not gmt_M_free since this item was allocated before GMT was initialized */\n \tgmt_M_str_free (module);\n\n\treturn (GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Destroy_Session_ () {\n\t/* Fortran version: We pass the hidden global GMT_FORTRAN structure */\n\treturn (GMT_Destroy_Session (GMT_FORTRAN));\n}\n#endif\n\n/*! . */\nGMT_LOCAL char gmtapi_debug_geometry_code (unsigned int geometry) {\n\tchar c;\n\tswitch (geometry) {\n\t\tcase GMT_IS_POINT:\t c = 'T'; break;\n\t\tcase GMT_IS_LINE:\t c = 'L'; break;\n\t\tcase GMT_IS_POLY:\t c = 'P'; break;\n\t\tcase GMT_IS_LP:\t\t c = 'C'; break;\n\t\tcase GMT_IS_PLP:\t c = 'A'; break;\n\t\tcase GMT_IS_SURFACE: c = 'G'; break;\n\t\tcase GMT_IS_VOLUME:\t c = 'U'; break;\n\t\tcase GMT_IS_NONE:\t c = 'N'; break;\n\t\tcase GMT_IS_TEXT:\t c = 'X'; break;\n\t\tdefault:\t \t\t c = '-'; break;\n\t}\n\treturn c;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_encode_id (struct GMTAPI_CTRL *API, unsigned int module_input, unsigned int direction, unsigned int family, unsigned int actual_family, unsigned int geometry, unsigned int messenger, int object_ID, char *filename) {\n\t/* Creates a virtual filename with the embedded object information .  Space for up to GMT_VF_LEN characters in filename must exist.\n\t * Name template: @GMTAPI@-S-D-F-A-G-M-###### where # is the 6-digit integer object code.  Total length is 27 chars (GMTAPI_MEMFILE_LEN)\n\t * S stands for P(rimary) or S(econdary) input or output object (command line is primary, files via options are secondary).\n\t * D stands for Direction and is either I(n) or O(ut).\n\t * F stands for Family and is one of D(ataset), G(rid), I(mage), C(PT), X(PostScript), M(atrix), V(ector), U(cube)-(undefined).\n\t * A stands for Actual Family and is one of D, G, I, C, X, M, V, and U as well.\n\t *   Actual family may differ from family if a Dataset is actually passed as a Matrix, for instance.\n\t * G stands for Geometry and is one of (poin)T, L(ine), P(olygon), C(Line|Polygon), A(POint|Line|Polygon), G(rid), V(olume), N(one), X(text), or -(ndefined).\n\t * M stands for Messenger and is either Y(es) or N(o).\n\t * Limitation:  object_ID must be <= GMTAPI_MAX_ID */\n\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\t/* GMT_Create_Session has not been called */\n\tif (!filename) return_error (API, GMT_MEMORY_ERROR);\t\t/* Oops, cannot write to that variable */\n\tif (object_ID <= GMT_NOTSET) return_error (API, GMT_NOT_A_VALID_ID);\t/* ID is not set yet */\n\tif (object_ID > GMTAPI_MAX_ID) return_error (API, GMT_ID_TOO_LARGE);\t/* ID is too large to fit in %06d format below */\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (API, GMT_NOT_A_VALID_DIRECTION);\n\tif (!gmtapi_valid_input_family (family))  return_error (API, GMT_NOT_A_VALID_FAMILY);\n\tif (!gmtapi_valid_actual_family (actual_family))  return_error (API, GMT_NOT_A_VALID_FAMILY);\n\tif (gmtapi_validate_geometry (API, family, geometry)) return_error (API, GMT_BAD_GEOMETRY);\n\tif (!(messenger == 0 || messenger == 1)) return_error (API, GMT_RUNTIME_ERROR);\n\tif (module_input) module_input = 1;\t/* It may be GMT_VIA_MODULE_INPUT but here we want just 0 or 1 */\n\n\tgmt_M_memset (filename, GMT_VF_LEN, char);\t/* Wipe any trace of previous text */\n\tsprintf (filename, \"@GMTAPI@-%c-%c-%s-%s-%c-%c-%06d\", (module_input) ? 'P' : 'S', (direction == GMT_IN) ? 'I' : 'O', GMT_family_abbrev[family], GMT_family_abbrev[actual_family], gmtapi_debug_geometry_code (geometry), (messenger) ? 'Y' : 'N', object_ID);\n\tGMT_Report (API, GMT_MSG_DEBUG, \"VirtualFile name created: %s\\n\", filename);\n\n\treturn_error (API, GMT_NOERROR);\t/* No error encountered */\n}\n\n/* Data registration: The main reason for data registration is the following:\n * Unlike GMT 4, GMT 5 may be used as modules by another calling program.  In\n * that case, the input data file may not be a file but a memory location (i.e.,\n * a data array).  To allow the program to pass such information we needed a\n * way to abstract things so that the modules have no idea of where things are\n * coming from (and were output is going as well).\n * The API session maintains a single linked linear list of data objects; these\n * objects contain information about all the data resources (sources and destinations)\n * that it has been told about.  Because GMT programs (hence the GMT modules) must\n * be able to find data from stdin, command line files, and command options (e.g.,\n * -Gmyfile.txt) we must be flexible in how things are done.\n *\n * Source registration is done in one of several ways:\n *  1. Call GMT_Register_IO directly and specify the source.  The specifics about the\n *     source will be stored in a new data object which is added to the linked list.\n *     This is what top-level programs must do to allow a GMT module to read via a\n *     memory location.\n *  2. Give file names via the option list (this is what happens when stand-alone\n *     GMT programs process the command line argv list).  Depending on the GMT module,\n *     the module will call GMT_Init_IO to scan for such option arguments and then add\n *     each file found as a new data object.\n *  3. Again, depending on the GMT module, if no unused resources are found, the module\n *     will, via GMT_Init_IO, add stdin as an input resource.  This can be in addition\n *     to any other registered sources, but most often it is added because no other\n *     sources were found.\n *\n * The lower-level GMT i/o machinery will handle complications such as 0 (stdin), 1, or\n * many data files so that the modules themselves simply read the next record with\n * GMT_Get_Record until EOF (as if there is only one input source).  Modules that need\n * to store all the data in memory for further processing will call gmtapi_get_data instead,\n * which will return a single entity (grid, dataset, cpt, etc).\n *\n * Destination registration is done in the same way, with the exception that for most\n * modules (those processing data tables, at least), only one output destination (e.g., file)\n * can be specified.  However, data sets such as tables with segments can, via mode\n * options, be specified to be written to separate table files or even segment files.\n * The actual writing is done by lower-level functions so that the GMT modules are simply\n * calling gmtapi_put_data (all in one go).  For record-by-record output the modules will use\n * GMT_Put_Record.  This keeps data i/o in the modules uniform and simple across GMT.\n */\n\n /*! . */\nint GMT_Register_IO (void *V_API, unsigned int family, unsigned int method, unsigned int geometry, unsigned int direction, double wesn[], void *resource) {\n\t/* Adds a new data object to the list of registered objects and returns a unique object ID.\n\t * Arguments are as listed for api_Register_Im|Export (); see those for details.\n\t * During the registration we make sure files exist and are readable.\n\t *\n\t * if direction == GMT_IN:\n\t * A program uses this routine to pass information about input data to GMT.\n\t * family:\tSpecifies the data type we are trying to import; select one of 6 families:\n\t *   GMT_IS_PALETTE:\tA GMT_PALETTE structure:\n\t *   GMT_IS_DATASET:\tA GMT_DATASET structure:\n\t *   GMT_IS_GRID:\tA GMT_GRID structure:\n\t *   GMT_IS_IMAGE:\tA GMT_IMAGE structure:\n\t *   GMT_IS_CUBE:\t\tA GMT_CUBE structure:\n\t *   GMT_IS_POSTSCRIPT:\t\tA GMT_POSTSCRIPT structure:\n\t * method:\tSpecifies by what method we will import this data set:\n\t *   GMT_IS_FILE:\tA file name is given via input.  The program will read data from this file\n\t *   GMT_IS_STREAM:\tA file pointer to an open file is passed via input. --\"--\n\t *   GMT_IS_FDESC:\tA file descriptor to an open file is passed via input. --\"--\n\t *   GMT_IS_DUPLICATE:\tA pointer to a data set to be copied\n\t *   GMT_IS_REFERENCE:\tA pointer to a data set to be passed as is [we may reallocate sizes only if GMT-allocated]\n\t * The following approaches can be added to the method for all but CPT:\n\t *   GMT_VIA_MATRIX:\tA 2-D user matrix is passed via input as a source for copying.\n\t *\t\t\tThe GMT_MATRIX structure must have parameters filled out.\n\t *   GMT_VIA_VECTOR:\tAn array of user column vectors is passed via input as a source for copying.\n\t *\t\t\tThe GMT_VECTOR structure must have parameters filled out.\n\t * geometry:\tOne of GMT_IS_{TEXT|POINT|LINE|POLY|SURF} (the last for GMT grids)\n\t * input:\tPointer to the source filename, stream, handle, array position, etc.\n\t * wesn:\tGrid subset defined by 4 doubles (or 6 for cubes); otherwise use NULL\n\t * RETURNED:\tUnique ID assigned to this input resource, or GMT_NOTSET (-1) if error.\n\t *\n\t * An error status is returned if problems are encountered via API->error [GMT_NOERROR].\n\t *\n\t * GMT_IS_GRID & GMT_VIA_MATRIX: Since GMT internally uses floats in C arrangement, anything else will be converted to gmt_grdfloat.\n\t * GMT_IS_DATASET & GMT_VIA_MATRIX: Since GMT internally uses doubles in C arrangement, anything else will be converted to double.\n\t *\n\t * api_Register_Import will allocate and populate a GMTAPI_DATA_OBJECT structure which\n\t * is appended to the data list maintained by the GMTAPI_CTRL API structure.\n\t *\n\t * if direction == GMT_OUT:\n\t * The main program uses this routine to pass information about output data from GMT.\n\t * family:\tSpecifies the data type we are trying to export; select one of:\n\t *   GMT_IS_PALETTE:\tA GMT_PALETTE structure:\n\t *   GMT_IS_DATASET:\tA GMT_DATASET structure:\n\t *   GMT_IS_IMAGE:\tA GMT_IMAGE structure:\n\t *   GMT_IS_GRID:\tA GMT_GRID structure:\n\t *   GMT_IS_CUBE:\tA GMT_CUBE structure:\n\t *   GMT_IS_POSTSCRIPT:\tA GMT_POSTSCRIPT structure:\n\t * method:\tSpecifies by what method we will export this data set:\n\t *   GMT_IS_FILE:\tA file name is given via output.  The program will write data to this file\n\t *   GMT_IS_STREAM:\tA file pointer to an open file is passed via output. --\"--\n\t *   GMT_IS_FDESC:\tA file descriptor to an open file is passed via output. --\"--\n\t *   GMT_IS_DUPLICATE:\tA pointer to a data set to be copied\n\t *   GMT_IS_REFERENCE:\tA pointer to a data set to be passed as is [we may reallocate sizes only if GMT-allocated]\n\t * geometry:\tOne of GMT_IS_{TEXT|POINT|LINE|POLY|SURFACE|VOLUME} (the last for GMT grids and cubes)\n\t * output:\tPointer to the destination filename, stream, handle, array position, etc.\n\t * wesn:\tGrid/volume subset defined by 4/6 doubles; otherwise use NULL\n\t * RETURNED:\tUnique ID assigned to this output resource, or GMT_NOTSET (-1) if error.\n\t *\n\t * An error status is returned if problems are encountered via API->error [GMT_NOERROR].\n\t *\n\t * api_Register_Export will allocate and populate a GMTAPI_DATA_OBJECT structure which\n\t * is appended to the data list maintained by the GMTAPI_CTRL API structure.\n\t */\n\tint item, object_ID;\n\tunsigned int module_input, mode = method & GMT_IO_RESET;\t/* In case we wish to reuse this resource */\n\tunsigned int first = 0;\n\tchar message[GMT_LEN256], *file = NULL;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_value (V_API, GMT_NOT_A_SESSION, GMT_NOTSET);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\t/* Reset in case it has some previous error */\n\tmodule_input = (family & GMT_VIA_MODULE_INPUT);\t/* Are we registering a resource that is a module input? */\n\tfamily -= module_input;\n\tif (gmtapi_validate_geometry (API, family, geometry)) return_value (API, GMT_BAD_GEOMETRY, GMT_NOTSET);\n\n\tif ((object_ID = gmtapi_is_registered (API, family, geometry, direction, mode, resource, resource)) != GMT_NOTSET) {\t/* Registered before */\n\t\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, direction, GMT_NOTSET)) == GMT_NOTSET) return_value (API, API->error, GMT_NOTSET);\n\t\tS_obj = API->object[item];\t/* Use S as shorthand */\n\t\tif (module_input) S_obj->module_input = true;\n\t\tif ((a_grid_or_image (family) || a_matrix_surface(family,geometry)) && !full_region (wesn)) {\t/* Update the subset region if given (for grids/images only) */\n\t\t\tgmt_M_memcpy (S_obj->wesn, wesn, 4, double);\n\t\t\tS_obj->region = true;\n\t\t}\n\t\telse if (family == GMT_IS_CUBE && (!full_region (wesn) || (wesn && wesn[ZLO] != wesn[ZHI]))) {\n\t\t\tgmt_M_memcpy (S_obj->wesn, wesn, 6, double);\n\t\t\tS_obj->region = true;\n\t\t}\n\t\treturn (object_ID);\t/* Already registered so we are done */\n\t}\n\tmethod -= mode;\t/* Remove GMT_IO_RESET if it was passed */\n\tGMT = API->GMT;\n\n\tswitch (method) {\t/* Consider CPT, data, text, and grids, accessed via a variety of methods */\n\t\tcase GMT_IS_FILE:\t/* Registration via a single file name */\n\t\t\t/* No, so presumably it is a regular file name */\n\t\t\tfile = strdup (resource);\n\t\t\tif (direction == GMT_IN) {\t/* For input we can check if the file exists and can be read. */\n\t\t\t\tchar *p = NULL;\n\t\t\t\tbool not_url = true, is_plus_sign = false;\n\t\t\t\tif (a_grid_or_image_or_cube (family) && !gmtlib_remote_file_is_tiled (API, file, NULL) && (p = strchr (file, '='))) *p = '\\0';\t/* Chop off any =<stuff> for grids and images so access can work */\n\t\t\t\telse if (family == GMT_IS_IMAGE && (p = strchr (file, '+'))) {\n\t\t\t\t\tchar *c = strchr (file, '.');\t/* The period before an extension */\n\t\t\t\t\t /* PW 1/30/2014: Protect images with band requests, e.g., my_image.jpg+b2 */\n\t\t\t\t\tif (c && c < p && p[1] == 'b' && isdigit (p[2])) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Truncating +b modifier for image filename %s\\n\", file);\n\t\t\t\t\t\t*p = '\\0';\t/* Chop off any +b<band> for images at end of extension so access can work */\n\t\t\t\t\t\tis_plus_sign = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\t/* Make sure p is NULL so we don't restore a character below */\n\t\t\t\t\t\tp = NULL;\n\t\t\t\t}\n\t\t\t\tif (a_grid_or_image (family))\t/* Only grid and images can be URLs so far */\n\t\t\t\t\tnot_url = !(gmtlib_found_url_for_gdal (file) || gmt_M_file_is_url (file));\t/* true if neither special GDAL-remote files nor regular URLs */\n\t\t\t\tfirst = gmt_download_file_if_not_found (API->GMT, file, 0);\t/* Deal with downloadable GMT data sets first */\n\t\t\t\tif (gmt_access (GMT, &file[first], F_OK) && not_url) {\t/* For input we can check if the file exists (except if via Web) */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"File %s not found\\n\", &file[first]);\n\t\t\t\t\tgmt_M_str_free (file);\n\t\t\t\t\treturn_value (API, GMT_FILE_NOT_FOUND, GMT_NOTSET);\n\t\t\t\t}\n\t\t\t\tif (gmt_access (GMT, &file[first], R_OK) && not_url) {\t/* Found it but we cannot read. */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Not permitted to read file %s\\n\", &file[first]);\n\t\t\t\t\tgmt_M_str_free (file);\n\t\t\t\t\treturn_value (API, GMT_BAD_PERMISSION, GMT_NOTSET);\n\t\t\t\t}\n\t\t\t\tif (p) p[0] = (is_plus_sign) ? '+' : '=';\t/* Restore the extensions */\n\t\t\t}\n\t\t\telse if (resource == NULL) {\t/* No file given [should this mean stdin/stdout?] */\n\t\t\t\tgmt_M_str_free (file);\n\t\t\t\treturn_value (API, GMT_OUTPUT_NOT_SET, GMT_NOTSET);\n\t\t\t}\n\t\t\t/* Create a new data object and initialize variables */\n\t\t\tif ((S_obj = gmtapi_make_dataobject (API, family, method, geometry, NULL, direction)) == NULL) {\n\t\t\t\tgmt_M_str_free (file);\n\t\t\t\treturn_value (API, GMT_MEMORY_ERROR, GMT_NOTSET);\t/* No more memory */\n\t\t\t}\n\t\t\tif (strlen (resource))\t/* Strip off any beginning of the name */\n\t\t\t\tS_obj->filename = strdup (&file[first]);\n\t\t\tgmt_M_str_free (file);\n\t\t\tsnprintf (message, GMT_LEN256, \"Object ID %%d : Registered %s %s %s as an %s resource with geometry %s [n_objects = %%d]\\n\", GMT_family[family], gmtapi_method (method), S_obj->filename, GMT_direction[direction], GMT_geometry[gmtapi_gmtry(geometry)]);\n\t\t\tbreak;\n\n\t\tcase GMT_IS_STREAM:\t/* Methods that indirectly involve a file */\n\t\tcase GMT_IS_FDESC:\n\t\t\tif (resource == NULL) {\t/* No file given [should this mean stdin/stdout?] */\n\t\t\t\treturn_value (API, GMT_OUTPUT_NOT_SET, GMT_NOTSET);\n\t\t\t}\n\t\t\tif ((S_obj = gmtapi_make_dataobject (API, family, method, geometry, NULL, direction)) == NULL) {\n\t\t\t\treturn_value (API, GMT_MEMORY_ERROR, GMT_NOTSET);\t/* No more memory */\n\t\t\t}\n\t\t\tS_obj->fp = resource;\t/* Pass the stream of fdesc onward */\n\t\t\tsnprintf (message, GMT_LEN256, \"Object ID %%d : Registered %s %s %\" PRIxS \" as an %s resource with geometry %s [n_objects = %%d]\\n\", GMT_family[family], gmtapi_method (method), (size_t)resource, GMT_direction[direction], GMT_geometry[gmtapi_gmtry(geometry)]);\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE:\n\t\tcase GMT_IS_REFERENCE:\n\t\t\tif (direction == GMT_IN && resource == NULL) {\n\t\t\t\treturn_value (API, GMT_PTR_IS_NULL, GMT_NOTSET);\t/* Input registration of memory takes a resource */\n\t\t\t}\n\t\t\tif ((S_obj = gmtapi_make_dataobject (API, family, method, geometry, resource, direction)) == NULL) {\n\t\t\t\treturn_value (API, GMT_MEMORY_ERROR, GMT_NOTSET);\t/* No more memory */\n\t\t\t}\n\t\t\tsnprintf (message, GMT_LEN256, \"Object ID %%d : Registered %s %s %\" PRIxS \" as an %s resource with geometry %s [n_objects = %%d]\\n\", GMT_family[family], gmtapi_method (method), (size_t)resource, GMT_direction[direction], GMT_geometry[gmtapi_gmtry(geometry)]);\n\t\t\tbreak;\n\n\t\tcase GMT_IS_COORD:\t/* Internal registration of coordinate arrays so that GMT_Destroy_Data can free them */\n\t\t\tif ((S_obj = gmtapi_make_dataobject (API, family, method, geometry, resource, direction)) == NULL) {\n\t\t\t\treturn_value (API, GMT_MEMORY_ERROR, GMT_NOTSET);\t/* No more memory */\n\t\t\t}\n\t\t\tsnprintf (message, GMT_LEN256, \"Object ID %%d : Registered double array %\" PRIxS \" as an %s resource [n_objects = %%d]\\n\", (size_t)resource, GMT_direction[direction]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Failure in GMT_Register_IO (%s): Unrecognized method %d\\n\", GMT_direction[direction], method);\n\t\t\treturn_value (API, GMT_NOT_A_VALID_METHOD, GMT_NOTSET);\n\t\t\tbreak;\n\t}\n\n\tif ((a_grid_or_image (family) || a_matrix_surface(family,geometry)) && !full_region (wesn)) {\t/* Copy the subset region if it was given (for grids) */\n\t\tgmt_M_memcpy (S_obj->wesn, wesn, 4, double);\n\t\tS_obj->region = true;\n\t}\n\telse if (family == GMT_IS_CUBE && (!full_region (wesn) || (wesn && wesn[ZLO] != wesn[ZHI]))) {\n\t\tgmt_M_memcpy (S_obj->wesn, wesn, 6, double);\n\t\tS_obj->region = true;\n\t}\n\n\tS_obj->alloc_level = GMT->hidden.func_level;\t/* Object was allocated at this module nesting level */\n\tif (module_input) S_obj->module_input = true;\n\n\t/* Here S is not NULL and no errors have occurred (yet) */\n\n\tif (direction == GMT_OUT && resource == NULL) S_obj->messenger = true;\t/* Output messenger */\n\tif (method != GMT_IS_COORD) API->registered[direction] = true;\t/* We have at least registered one item */\n\tobject_ID = gmtapi_add_data_object (API, S_obj);\n\tGMT_Report (API, GMT_MSG_DEBUG, message, object_ID, API->n_objects);\n#ifdef DEBUG\n\t//gmtapi_list_objects (API, \"GMT_Register_IO\");\n#endif\n\treturn_value (API, API->error, object_ID);\n}\n\n#ifdef FORTRAN_API\nint GMT_Register_IO_ (unsigned int *family, unsigned int *method, unsigned int *geometry, unsigned int *direction, double wesn[], void *input) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Register_IO (GMT_FORTRAN, *family, *method, *geometry, *direction, wesn, input));\n}\n#endif\n\n\n /*! . */\nint GMT_Init_IO (void *V_API, unsigned int family, unsigned int geometry, unsigned int direction, unsigned int mode, unsigned int n_args, void *args) {\n\t/* Registers program option file arguments as sources/destinations for the current module.\n\t * All modules planning to use std* and/or command-line file args must call GMT_Init_IO to register these resources.\n\t * family:\tThe kind of data (GMT_IS_DATASET|CPT|GRID|IMAGE|PS)\n\t * geometry:\tEither GMT_IS_NONE|TEXT|POINT|LINE|POLYGON|SURFACE\n\t * direction:\tEither GMT_IN or GMT_OUT\n\t * mode:\tBitflags composed of 1 = add command line (option) files, 2 = add std* if no other input/output,\n\t *\t\t4 = add std* regardless.  mode must be > 0.\n\t * n_args:\tEither 0 if we pass linked option structs or argc if we pass argv[]\n\t * args:\tEither linked list of program option arguments (n_args == 0) or char *argv[].\n\t *\n\t * Returns:\tfalse if successful, true if error.\n\t */\n\tint object_ID;\t/* ID of first object [only for debug purposes - not used in this function; ignore -Wunused-but-set-variable warning */\n\tstruct GMT_OPTION *head = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\t/* Reset in case it has some previous error */\n\tif (gmtapi_validate_geometry (API, family, geometry)) return_error (API, GMT_BAD_GEOMETRY);\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (API, GMT_NOT_A_VALID_DIRECTION);\n\tif (!((mode & GMT_ADD_FILES_IF_NONE) || (mode & GMT_ADD_FILES_ALWAYS) || (mode & GMT_ADD_STDIO_IF_NONE) || (mode & GMT_ADD_STDIO_ALWAYS) || (mode & GMT_ADD_EXISTING))) return_error (API, GMT_NOT_A_VALID_MODE);\n\n\tif (n_args == 0) /* Passed the head of linked option structures */\n\t\thead = args;\n\telse\t\t/* Passed argc, argv, likely from Fortran */\n\t\thead = GMT_Create_Options (API, n_args, args);\n\tgmtlib_io_banner (API->GMT, direction);\t/* Message for binary i/o */\n\tif (direction == GMT_IN)\n\t\tobject_ID = gmtapi_init_import (API, family, geometry, mode, head);\n\telse\n\t\tobject_ID = gmtapi_init_export (API, family, geometry, mode, head);\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Init_IO: Returned first %s object ID = %d\\n\", GMT_direction[direction], object_ID);\n\treturn (API->error);\n}\n\n#ifdef FORTRAN_API\nint GMT_Init_IO_ (unsigned int *family, unsigned int *geometry, unsigned int *direction, unsigned int *mode, unsigned int *n_args, void *args) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Init_IO (GMT_FORTRAN, *family, *geometry, *direction, *mode, *n_args, args));\n}\n#endif\n\nGMT_LOCAL int gmtapi_end_io_dataset (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *S, unsigned int *item) {\n\t/* These are the steps we must take to finalize a GMT_DATASET that was written to\n\t * record-by-record via GMT_Put_Record.  It needs to set number of records and set\n\t * the min/max per segments and table */\n\tint check, object_ID;\n\tint64_t *count = API->GMT->current.io.curr_pos[GMT_OUT];\t\t/* Short-hand for counts of tbl, seg, rows */\n\tstruct GMT_DATASET *D = S->resource;\n\tstruct GMT_DATATABLE *T = NULL;\n\tstruct GMT_DATASET_HIDDEN *DH = NULL;\n\tstruct GMT_DATATABLE_HIDDEN *TH = NULL;\n\tif (D == NULL) {\t/* No output records produced by module; just return an empty dataset with no rows instead of NULL */\n\t\tunsigned int smode = (API->GMT->current.io.record_type[GMT_OUT] & GMT_WRITE_TEXT) ? GMT_WITH_STRINGS : GMT_NO_STRINGS;\n\t\tD = gmtlib_create_dataset (API->GMT, 1, 1, 0, 0, S->geometry, smode, true);\t/* 1 table, 1 segment; no cols or rows yet */\n\t\tS->resource = D;\n\t}\n\n\tT = D->table[0];\t/* Shorthand to the only table */\n\tDH = gmt_get_DD_hidden (D);\n\tTH = gmt_get_DT_hidden (T);\n\tif (count[GMT_SEG] >= 0) {\t/* Finalize segment allocations */\n\t\tif (!T->segment[count[GMT_SEG]]) T->segment[count[GMT_SEG]] = gmt_get_segment (API->GMT);\n\t\tgmtlib_assign_segment (API->GMT, GMT_OUT, T->segment[count[GMT_SEG]], count[GMT_ROW], T->n_columns);\t/* Allocate and place arrays into segment */\n\t\tcount[GMT_SEG]++;\t/* Set final number of segments */\n\t\tT->n_segments++;\n\t}\n\tif (count[GMT_SEG] < (int64_t)TH->n_alloc) {\t/* Realloc final number of segments */\n\t\tuint64_t s;\n\t\tfor (s = T->n_segments; s < TH->n_alloc; s++) {\t/* Free the extra structures */\n\t\t\tif (T->segment[s] == NULL) continue;\n\t\t\tgmt_M_free (API->GMT, T->segment[s]->hidden);\n\t\t\tgmt_M_free (API->GMT, T->segment[s]);\n\t\t}\n\t\tT->segment = gmt_M_memory (API->GMT, T->segment, T->n_segments, struct GMT_DATASEGMENT *);\t/* Finalize pointer array */\n\t\tTH->n_alloc = T->n_segments;\t/* Update allocation count */\n\t}\n\tif (S->h_delay) {\t/* Must do the first table headers now since we finally have allocated the table */\n\t\tT->header = API->tmp_header;\n\t\tT->n_headers = API->n_tmp_headers;\n\t\tAPI->n_tmp_headers = 0;\n\t\tAPI->tmp_header = NULL;\n\t\tS->h_delay = false;\n\t}\n\tif (S->s_delay) {\t/* Must do the first segment header now since we finally have allocated the table */\n\t\tT->segment[0]->header = API->tmp_segmentheader;\n\t\tAPI->tmp_segmentheader = NULL;\n\t\tS->s_delay = false;\n\t}\n\tD->n_segments = T->n_segments;\n\tgmt_set_dataset_minmax (API->GMT, D);\t/* Update the min/max values for this dataset */\n\tD->n_records = T->n_records = count[GMT_ROW];\n\tDH->alloc_level = S->alloc_level;\t/* Since we are passing it up to the caller */\n\t/* Register this resource */\n\tif ((object_ID = GMT_Register_IO (API, GMT_IS_DATASET, GMT_IS_REFERENCE, D->geometry, GMT_OUT, NULL, D)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t\t/* Failure to register */\n\tif ((check = gmtlib_validate_id (API, GMT_IS_DATASET, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t\t/* Failure to validate */\n\t*item = (unsigned int) check;\n\treturn (GMT_NOERROR);\n}\n\nGMT_LOCAL int gmtapi_end_io_matrix (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *S, unsigned int *item) {\n\t/* These are the steps we must take to finalize a GMT_MATRIX that was written to\n\t * record-by-record vai GMT_Put_Record.  It needs to set number of rows and possibly\n\t * add leading NaN-record(s) if there were segment headers at the beginning of file. */\n\tint error = 0, check, object_ID;\n\tstruct GMT_MATRIX *M = S->resource;\n\tstruct GMT_MATRIX_HIDDEN *MH = gmt_get_M_hidden (M);\n\tif (S->alloc_mode != GMT_ALLOC_EXTERNALLY && S->n_alloc != S->rec) {\t/* Must finalize matrix memory */\n\t\tsize_t size = S->n_alloc = S->rec;\n\t\tsize *= M->n_columns;\n\t\tif ((error = gmtlib_alloc_univector (API->GMT, &(M->data), M->type, size)) != GMT_NOERROR)\n\t\t\treturn_error (API, error);\n\t}\n\tMH->alloc_level = S->alloc_level;\t/* Since we are passing it up to the caller */\n\tif (S->h_delay) {\t/* Must do the first table headers now since we finally have allocated the table */\n\t\tM->header = API->tmp_header;\n\t\tM->n_headers = API->n_tmp_headers;\n\t\tAPI->n_tmp_headers = 0;\n\t\tS->h_delay = false;\n\t}\n\tif (S->delay) {\t/* Must place delayed NaN record(s) signifying segment header(s) */\n\t\tGMT_putfunction api_put_val = gmtapi_select_put_function (API, M->type);\n\t\tif (api_put_val == NULL) return_error (API, GMT_NOT_A_VALID_TYPE);\n\t\tp_func_uint64_t GMT_2D_to_index = NULL;\n\t\tuint64_t col, ij;\n\t\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, GMT_IS_ROW_FORMAT, GMT_GRID_IS_REAL)) == NULL)\t/* Can only do row-format until end of this function */\n\t\t\treturn_error (API, GMT_WRONG_MATRIX_SHAPE);\n\t\twhile (S->delay) {\t/* Place delayed NaN-rows(s) up front */\n\t\t\tS->delay--;\n\t\t\tfor (col = 0; col < M->n_columns; col++) {\t/* Place the output items */\n\t\t\t\tij = GMT_2D_to_index (S->delay, col, M->dim);\n\t\t\t\tapi_put_val (&(M->data), ij, API->GMT->session.d_NaN);\n\t\t\t}\n\t\t}\n\t}\n\tif (M->shape == GMT_IS_COL_FORMAT) {\t/* Oh no, must do a transpose in place */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"gmtapi_end_io_matrix: Must transpose union matrix to GMT_IS_COL_FORMAT arrangement\\n\");\n\t\tgmtlib_union_transpose (API->GMT, &(M->data), M->n_rows, M->n_columns, M->type);\n\t\tM->dim = M->n_rows;\t/* Since now it is in FORTRAN column format */\n\t}\n\t/* Register this resource */\n\tif ((object_ID = GMT_Register_IO (API, GMT_IS_MATRIX, GMT_IS_REFERENCE, GMT_IS_SURFACE, GMT_OUT, NULL, M)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t/* Failure to register */\n\tif ((check = gmtlib_validate_id (API, GMT_IS_MATRIX, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t/* Failure to validate */\n\t*item = (unsigned int) check;\n\treturn (GMT_NOERROR);\n}\n\nGMT_LOCAL int gmtapi_end_io_vector (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *S, unsigned int *item) {\n\t/* These are the steps we must take to finalize a GMT_VECTOR that was written to\n\t * record-by-record via GMT_Put_Record.  It needs to set number of rows and possibly\n\t * add leading NaN-record(s) if there were segment headers at the beginning of file. */\n\tint error = 0, check, object_ID;\n\tstruct GMT_VECTOR *V = S->resource;\n\tstruct GMT_VECTOR_HIDDEN *VH = gmt_get_V_hidden (V);\n\tif (S->alloc_mode != GMT_ALLOC_EXTERNALLY && S->n_alloc != S->rec) {\t/* Must finalize memory */\n\t\tS->n_alloc = S->rec;\n\t\tif ((error = gmtlib_alloc_vectors (API->GMT, V, S->n_alloc)) != GMT_NOERROR)\n\t\t\treturn_error (API, error);\n\t}\n\tif ((object_ID = GMT_Register_IO (API, GMT_IS_VECTOR, GMT_IS_REFERENCE, S->geometry, GMT_OUT, NULL, V)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t/* Failure to register */\n\tif ((check = gmtlib_validate_id (API, GMT_IS_VECTOR, object_ID, GMT_OUT, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, API->error);\t/* Failure to validate */\n\tVH->alloc_level = S->alloc_level;\t/* Since we are passing it up to the caller */\n\tif (S->h_delay) {\t/* Must do the first table headers now since we finally have allocated the table */\n\t\tV->header = API->tmp_header;\n\t\tV->n_headers = API->n_tmp_headers;\n\t\tAPI->n_tmp_headers = 0;\n\t\tS->h_delay = false;\n\t}\n\tif (S->delay) {\t/* Must place delayed NaN record(s) signifying segment header(s) */\n\t\tuint64_t col;\n\t\twhile (S->delay) {\t/* Place delayed NaN-record(s) as leading rows */\n\t\t\tS->delay--;\n\t\t\tV->n_rows++;\t/* Since could not be incremented before V was created */\n\t\t\tfor (col = 0; col < V->n_columns; col++)\n\t\t\t\tAPI->current_put_V_val[col] (&(V->data[col]), S->delay, API->GMT->session.d_NaN);\n\t\t}\n\t}\n\tgmt_M_free (API->GMT, API->current_put_V_val);\n\t*item = (unsigned int) check;\n\treturn (GMT_NOERROR);\n}\n\n/*! . */\nint GMT_End_IO (void *V_API, unsigned int direction, unsigned int mode) {\n\t/* Terminates the i/o mechanism for either input or output (given by direction).\n\t * GMT_End_IO must be called after all data i/o is completed.\n\t * direction:\tEither GMT_IN or GMT_OUT\n\t * mode:\tEither GMT_IO_DONE (nothing), GMT_IO_RESET (let all resources be accessible again), or GMT_IO_UNREG (unreg all accessed resources).\n\t * NOTE: \tMode not yet implemented until we see a use.\n\t * Returns:\tfalse if successful, true if error.\n\t * For memory output we finalized the container, register it, sets the alloc_level to the calling entity\n\t * and pass the resource upwards.\n\t */\n\tunsigned int item = 0;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (V_API, GMT_NOT_A_VALID_DIRECTION);\n\tif (mode > GMT_IO_UNREG) return_error (V_API, GMT_NOT_A_VALID_IO_MODE);\n\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tgmtlib_free_ogr (API->GMT, &(API->GMT->current.io.OGR), 0);\t/* Free segment-related array */\n\tif (direction == GMT_OUT && API->io_mode[GMT_OUT] == GMTAPI_BY_REC) {\n\t\t/* Finalize record-by-record output object dimensions */\n\t\tS_obj = API->object[API->current_item[GMT_OUT]];\t/* Shorthand for the data object we are working on */\n\t\tif (S_obj) {\n\t\t\tS_obj->status = GMT_IS_USED;\t/* Done \"writing\" to this destination */\n\t\t\tif ((S_obj->method == GMT_IS_DUPLICATE || S_obj->method == GMT_IS_REFERENCE)) {\t/* Used GMT_Put_Record: Must now realloc dimensions given known sizes */\n\t\t\t\tint error = GMT_NOERROR;\t/* If all goes well */\n\t\t\t\tif (S_obj->actual_family == GMT_IS_DATASET)\t\t\t/* Dataset type */\n\t\t\t\t\terror = gmtapi_end_io_dataset (API, S_obj, &item);\n\t\t\t\telse if (S_obj->actual_family == GMT_IS_MATRIX)\t\t/* Matrix type */\n\t\t\t\t\terror = gmtapi_end_io_matrix (API, S_obj, &item);\n\t\t\t\telse if (S_obj->actual_family == GMT_IS_VECTOR)\t\t/* Vector type */\n\t\t\t\t\terror = gmtapi_end_io_vector (API, S_obj, &item);\n\t\t\t\telse\t/* Should not get here... */\n\t\t\t\t\terror = GMT_NOT_A_VALID_FAMILY;\n\t\t\t\tif (error) return_error (API, error);\t/* Failure to finalize */\n\t\t\t\tAPI->object[item]->no_longer_owner = true;\t/* Since we passed it via S_obj */\n\t\t\t}\n\t\t\tif (S_obj->close_file) {\t/* Close any file that we opened earlier */\n\t\t\t\tgmt_fclose (API->GMT, S_obj->fp);\n\t\t\t\tS_obj->close_file = false;\n\t\t\t}\n\t\t}\n\t}\n\telse {\t/* Input files were closed when we tried to go to next item */\n\t\tif (API->current_get_V_val) gmt_M_free (API->GMT, API->current_get_V_val);\n\t}\n\tAPI->is_file = true;\n\tAPI->io_enabled[direction] = false;\t/* No longer OK to access resources or destinations */\n\tAPI->current_rec[direction] = 0;\t/* Reset count for next time */\n\tfor (item = 0; item < API->n_objects; item++) {\t/* Deselect the used resources */\n\t\tif (!API->object[item]) continue;\t/* Skip empty object */\n\t\tif (API->object[item]->direction != (enum GMT_enum_std)direction) continue;\t/* Not the required direction */\n\t\tif (API->object[item]->selected) API->object[item]->selected = false;\t/* No longer a selected resource */\n\t}\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_End_IO: %s resource access is now disabled\\n\", GMT_direction[direction]);\n\n\treturn_error (V_API, GMT_NOERROR);\t/* No error encountered */\n}\n\n#ifdef FORTRAN_API\nint GMT_End_IO_ (unsigned int *direction, unsigned int *mode) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_End_IO (GMT_FORTRAN, *direction, *mode));\n}\n#endif\n\n/*! . */\nint GMT_Get_Status (void *V_API, unsigned int mode) {\n\t/* Returns nonzero (true) or 0 (false) if the current io status\n\t * associated with record-by-record reading matches the\n\t * specified mode.  The modes are:\n\t * GMT_IO_TABLE_HEADER\t\t: Is current record a table header?\n\t * GMT_IO_SEGMENT_HEADER\t: Is current record a segment header?\n\t * GMT_IO_ANY_HEADER\t\t: Is current record a header or segment header?\n\t * GMT_IO_MISMATCH\t\t: Did current record result in a parsing error?\n\t * GMT_IO_EOF\t\t\t: Did we reach end-of-file for entire data set(EOF)?\n\t * GMT_IO_NAN\t\t\t: Did we encounter any NaNs in current record?\n\t * GMT_IO_GAP\t\t\t: Did current record indicate a data gap?\n\t * GMT_IO_NEW_SEGMENT\t\t: Is current record the start of a new segment (gap or header)\n\t * GMT_IO_LINE_BREAK\t\t: Any sort of new line break (gap, headers, nan)\n\t * GMT_IO_FILE_BREAK\t\t: Did we reach end-of-file for a single table (EOF)?\n\t * GMT_IO_DATA\t\t\t: Is current record a data record (including nans)?\n\t */\n\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_IO *IO = NULL;\n\n\tif (V_API == NULL) return_value (V_API, GMT_NOT_A_SESSION, GMT_NOTSET);\n\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tIO = &(API->GMT->current.io);\t/* Pointer to the GMT IO structure */\n\tif (mode == GMT_IO_DATA_RECORD) return (IO->status == 0 || IO->status == GMT_IO_NAN);\n\treturn (IO->status & mode);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Status_ (unsigned int *mode) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Status (GMT_FORTRAN, *mode));\n}\n#endif\n\n/*! . */\nGMT_LOCAL int gmtapi_get_id (void *V_API, unsigned int family, unsigned int direction, void *resource) {\n\tunsigned int i;\n\tint item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\t/* GMT_Create_Session has not been called */\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tfor (i = 0, item = GMT_NOTSET; item == GMT_NOTSET && i < API->n_objects; i++) {\n\t\tif ((S_obj = API->object[i]) == NULL) continue;\t/* Empty object */\n\t\tif (!S_obj->resource) continue;\t\t/* Empty resource */\n\t\tif (S_obj->family != (enum GMT_enum_family)family) {\t\t/* Not the required data type, but check for exceptions */\n\t\t\tif (family == GMT_IS_DATASET && (S_obj->family == GMT_IS_MATRIX || S_obj->family == GMT_IS_VECTOR))\n\t\t\t\tS_obj->family = GMT_IS_DATASET;\t/* Vectors or Matrix masquerading as dataset are valid. Change their family here. */\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (S_obj->direction != (enum GMT_enum_std)direction) continue;\t/* Not the required direction */\n\t\tif (S_obj->resource == resource) item = i;\t/* Pick the requested object regardless of direction */\n\t}\n\tif (item == GMT_NOTSET) return_value (API, GMT_NOT_A_VALID_ID, GMT_NOTSET);\t/* No such resource found */\n\treturn (S_obj->ID);\n}\n\nGMT_LOCAL bool gmtapi_matrix_data_conforms_to_grid (struct GMT_MATRIX *M) {\n\t/* Check if a matrix data array matches the form of a GMT grid (row-oriented floats) */\n\tif (M->shape == GMT_IS_COL_FORMAT) return (false);\t/* Must transpose */\n\tif (M->data.f4 == NULL) return (false);\t/* Having nothing means we must allocate */\n\treturn (M->type == GMT_GRDFLOAT);\t\t/* Having gmt_grdfloat means we can use as is */\n}\n\nGMT_LOCAL bool gmtapi_matrix_data_conforms_to_dataset (struct GMT_MATRIX *M) {\n\t/* Check if a matrix data array matches the form of a GMT dataset (columns of doubles) */\n\tif (M->shape == GMT_IS_ROW_FORMAT) return (false);\t/* Must transpose */\n\tif (M->data.f8 == NULL) return (false);\t/* Having nothing means we must allocate */\n\treturn (M->type == GMT_DOUBLE);\t\t\t/* Having double means we can use as is */\n}\n\nGMT_LOCAL bool gmtapi_vector_data_conforms_to_dataset (struct GMT_VECTOR *V, enum GMT_enum_type type) {\n\t/* Check if the vector data arrays matches the form of a GMT dataset (columns of doubles) */\n\tif (type != GMT_DOUBLE) {\t/* Only doubles can be passed or memcpy directly */\n\t\tif (V->n_columns == 0) return (false);\t/* Having nothing yet means we must duplicate */\n\t\tif (V->type == NULL) return (false);\t/* Having nothing yet means we must duplicate */\n\t\tif (V->data == NULL) return (false);\t/* Having nothing yet means we must duplicate */\n\t}\n\tfor (unsigned int col = 0; col < V->n_columns; col++) {\n\t\tif (V->data[col].f8 == NULL) return (false);\t/* Having nothing means we must duplicate */\n\t\tif (V->type[col] != GMT_DOUBLE) return (false);\t/* Not having double means must duplicate */\n\t}\n\treturn true;\t/* Seems OK */\n}\n\n /*! . */\nGMT_LOCAL unsigned int gmtapi_separate_families (unsigned int *family) {\n\tunsigned int actual_family;\n\tif ((*family) & GMT_VIA_VECTOR) {\t/* Must allocate a GMT_VECTOR despite family being something else (like DATASET) */\n\t\tactual_family = GMT_IS_VECTOR;\n\t\t(*family) -=  GMT_VIA_VECTOR;\n\t}\n\telse if ((*family) & GMT_VIA_MATRIX) {\t/* Must allocate a GMT_MATRIX despite family being something else (like GRID) */\n\t\tactual_family = GMT_IS_MATRIX;\n\t\t(*family) -=  GMT_VIA_MATRIX;\n\t}\n\telse\n\t\tactual_family = (*family);\t/* It is what it says it is */\n\treturn actual_family;\n}\n\nGMT_LOCAL void gmtapi_maybe_change_method_to_duplicate (struct GMTAPI_CTRL *API, struct GMTAPI_DATA_OBJECT *S_obj) {\n\t/* We want to pass a matrix or set of vectors from the outside as a grid or as a dataset.\n\t * grid: If it is a float matrix in row-order layout then we can, else we must duplicate\n\t * dataset: If matrix or vector are in columns and they are all doubles then we can, else we must duplicate */\n\tif (S_obj->actual_family == GMT_IS_MATRIX && S_obj->family == GMT_IS_GRID && !gmtapi_matrix_data_conforms_to_grid (S_obj->resource)) {\n\t\tS_obj->method = GMT_IS_DUPLICATE;\t/* Must duplicate this resource */\n\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"GMT_Open_VirtualFile: Switch method to GMT_IS_DUPLICATE as input matrix is not compatible with a GMT gmt_grdfloat grid\\n\");\n\t}\n\telse if (S_obj->actual_family == GMT_IS_MATRIX && S_obj->family == GMT_IS_DATASET && !gmtapi_matrix_data_conforms_to_dataset (S_obj->resource)) {\n\t\tS_obj->method = GMT_IS_DUPLICATE;\t/* Must duplicate this resource */\n\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"GMT_Open_VirtualFile: Switch method to GMT_IS_DUPLICATE as input matrix is not compatible with a GMT dataset\\n\");\n\t}\n\telse if (S_obj->actual_family == GMT_IS_VECTOR && S_obj->family == GMT_IS_GRID) {\n\t\tS_obj->method = GMT_IS_DUPLICATE;\t/* Must duplicate this resource */\n\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"GMT_Open_VirtualFile: Switch method to GMT_IS_DUPLICATE as vectors are not compatible with a GMT grid\\n\");\n\t}\n\telse if (S_obj->actual_family == GMT_IS_VECTOR && S_obj->family == GMT_IS_DATASET && !gmtapi_vector_data_conforms_to_dataset (S_obj->resource, S_obj->type)) {\n\t\tS_obj->method = GMT_IS_DUPLICATE;\t/* Must duplicate this resource */\n\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"GMT_Open_VirtualFile: Switch method to GMT_IS_DUPLICATE as input vectors are not compatible with a GMT dataset\\n\");\n\t}\n}\n\n /*! . */\nint GMT_Open_VirtualFile (void *V_API, unsigned int family, unsigned int geometry, unsigned int direction, void *data, char *name) {\n\t/* Associate a virtual file with a data object for either reading or writing.\n\t * Family and geometry specifies the nature of the data to be read or written.\n\t * Direction is either GMT_IN or GMT_OUT and determines if we read or write.\n\t * Reading: data must point to a data container we wish to read from via a module.\n\t * Writing: data is either an existing output data container that the user created\n\t *  beforehand or it is NULL and we create an expanding output resource.\n\t * name is the name given to the virtual file and is returned. */\n\tint object_ID = GMT_NOTSET, item_s = 0;\n\tunsigned int item, orig_family, actual_family = 0, via_type = 0, messenger = 0, module_input, the_mode = GMT_IS_DUPLICATE;\n\tbool readonly = false;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tmodule_input = (family & GMT_VIA_MODULE_INPUT);\t/* Are we registering a resource that is a module input? */\n\tfamily -= module_input;\n\tif (direction & GMT_IS_REFERENCE) {\t/* Treat this memory as read-only */\n\t\treadonly = true;\n\t\tdirection -= GMT_IS_REFERENCE;\n\t\tthe_mode = GMT_IS_REFERENCE;\n\t}\n\telse if (direction & GMT_IS_DUPLICATE)\t/* This is the default - just remove the mode flag */\n\t\tdirection -= GMT_IS_DUPLICATE;\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return GMT_NOT_A_VALID_DIRECTION;\n\tif (direction == GMT_IN && data == NULL) return GMT_PTR_IS_NULL;\n\tif (name == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\torig_family = family;\t/* In case we will call GMT_Create_Data later */\n\tactual_family = gmtapi_separate_families (&family);\t/* In case via have a VIA situation */\n\tif (geometry >= GMT_VIA_CHAR) {\n\t\tvia_type = (geometry / 100);\t/* via_type is 1 higher than GMT_CHAR */\n\t\tgeometry %= 100;\n\t}\n\tif (direction == GMT_IN  && !gmtapi_valid_input_family (family))  return GMT_NOT_A_VALID_FAMILY;\n\tif (direction == GMT_OUT && !gmtapi_valid_output_family (family)) return GMT_NOT_A_VALID_FAMILY;\n\tif (via_type && data && !gmtapi_valid_type (via_type-1)) return GMT_NOT_A_VALID_TYPE;\t/* via type only valid if not passing any data but want vector or matrix */\n\tif (actual_family != family && !gmtapi_valid_via_family (actual_family)) return GMT_NOT_A_VALID_FAMILY;\n\tAPI = gmtapi_get_api_ptr (V_API);\n\n\tif (data) {\t/* Data container provided, see if registered */\n\t\tfor (item = 0; object_ID == GMT_NOTSET && item < API->n_objects; item++) {\t/* Loop over all objects */\n\t\t\tif (!API->object[item]) continue;\t/* Skip freed objects */\n\t\t\tif (API->object[item]->resource == data) object_ID = API->object[item]->ID;\t/* Found a matching data pointer */\n\t\t}\n\t\tif (object_ID != GMT_NOTSET && (item_s = gmtapi_get_item (API, family, data)) == GMT_NOTSET) {\t/* Not found in list */\n\t\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find that item in the array despite finding its ID? */\n\t\t}\n\t\tS_obj = API->object[item_s];\t/* Short-hand for later */\n\t\tif (!(S_obj->family == family && S_obj->actual_family == actual_family))\n\t\t\t return GMT_NOT_A_VALID_FAMILY;\n\t}\n\tif (direction == GMT_IN) {\t/* Set things up for reading */\n\t\t/* See if this one is known to us already */\n\t\tif (object_ID == GMT_NOTSET) {\t/* Register data as a new object for reading [GMT_IN] and reset its status to unread */\n\t\t\tif ((object_ID = GMT_Register_IO (API, family, the_mode|GMT_IO_RESET, geometry, GMT_IN, NULL, data)) == GMT_NOTSET)\n\t\t\t\treturn (API->error);\n\t\t\tif ((item_s = gmtapi_get_item (API, family, data)) == GMT_NOTSET) {\t/* Not found in list */\n\t\t\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find that item in the array despite finding its ID? */\n\t\t\t}\n\t\t\tS_obj = API->object[item_s];\t/* Short-hand for later */\n\t\t}\n\t\telse {\t/* Found the object earlier; recycle the address and ensure it is a readable object */\n\t\t\tif (S_obj->family != family || S_obj->actual_family != actual_family)\n\t\t\t\treturn_error (API, GMT_WRONG_FAMILY);\t/* Mixup between what was created and what was passed in */\n\t\t\tS_obj->status = 0;\t\t\t\t\t/* Open for business */\n\t\t\tS_obj->method = the_mode;\t\t\t/* Now a memory resource */\n\t\t\tS_obj->direction = GMT_IN;\t\t\t/* Make sure it now is flagged for reading */\n\t\t}\n\t\t/* If the input a container masquerading as another then we may have to replace method GMT_IS_REFERENCE by GMT_IS_DUPLICATE if REFERENCE was specified */\n\t\tif (S_obj->method == GMT_IS_REFERENCE) gmtapi_maybe_change_method_to_duplicate (API, S_obj);\n\t}\n\telse {\t/* Set things up for writing */\n\t\tif (data) {\t/* Was provided an object to use */\n\t\t\tif (object_ID == GMT_NOTSET) {\t/* Register a new object for writing [GMT_OUT] and reset its status to unread */\n\t\t\t\tif ((object_ID = GMT_Register_IO (API, orig_family, the_mode|GMT_IO_RESET, geometry, GMT_OUT, NULL, data)) == GMT_NOTSET)\n\t\t\t\t\treturn (API->error);\n\t\t\t\tif ((item_s = gmtapi_get_item (API, family, data)) == GMT_NOTSET) {\t/* Not found in list */\n\t\t\t\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find that item in the array despite finding its ID? */\n\t\t\t\t}\n\t\t\t\tS_obj = API->object[item_s];\t/* Short-hand for later */\n\t\t\t}\n\t\t\telse {\t/* Here we have the item and can recycle the address */\n\t\t\t\tS_obj->status = 0;\t\t\t\t/* Open for business */\n\t\t\t\tS_obj->method = the_mode;\t\t/* Now a memory resource */\n\t\t\t\tS_obj->direction = GMT_OUT;\t\t/* Make sure it now is flagged for writing */\n\t\t\t}\n\t\t}\n\t\telse {\t/* New expanding output resource */\n\t\t\tvoid *object = NULL;\n\t\t\t/* GMT_Create_Data may return error code if there are issues with the values of family, or geometry */\n\t\t\t/* Creating an empty object with mode & GMT_IS_OUTPUT means it is intended to hold output [GMT_OUT] from a module */\n\t\t\tif ((object = GMT_Create_Data (API, orig_family, geometry, GMT_IS_OUTPUT, NULL, NULL, NULL, 0, 0, NULL)) == NULL)\n\t\t\t\treturn (API->error);\n\t\t\t/* Obtain the object's ID */\n\t\t\tif ((object_ID = gmtapi_get_id (API, family, GMT_OUT, object)) == GMT_NOTSET)\n\t\t\t\treturn (API->error);\n\t\t\tif ((item_s = gmtapi_get_item (API, family, object)) == GMT_NOTSET) {\t/* Not found in list */\n\t\t\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find that item in the array despite finding its ID? */\n\t\t\t}\n\t\t\tS_obj = API->object[item_s];\t/* Short-hand for later */\n\t\t\tS_obj->type = (via_type) ? via_type - 1 : API->GMT->current.setting.export_type;\t/* Remember what output type we want */\n\t\t\tS_obj->method = the_mode;\t/* Now a memory resource */\n\t\t\tmessenger = 1;\n\t\t}\n\t\t/* If the output is a matrix masquerading as grid then it must be GMT_FLOAT, otherwise change to DUPLICATE if REFERENCE was specified */\n\t\tif (S_obj->method == GMT_IS_REFERENCE) gmtapi_maybe_change_method_to_duplicate (API, S_obj);\n\t}\n\tS_obj->region = false;\t/* No subset of anything is being considered here */\n\tgmt_M_memset (S_obj->wesn, 6U, double);\n\t/* Obtain the unique VirtualFile name */\n\tif (gmtapi_encode_id (API, module_input, direction, family, actual_family, geometry, messenger, object_ID, name) != GMT_NOERROR)\n\t\treturn (API->error);\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Open_VirtualFile_ (unsigned int *family, unsigned int *geometry, unsigned int *direction, void *data, char *string, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Open_VirtualFile (GMT_FORTRAN, *family, *geometry, *direction, data, string));\n}\n#endif\n\nint GMT_Close_VirtualFile (void *V_API, const char *string) {\n\t/* Given a VirtualFile name, close it */\n\tint object_ID, item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (string == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tif ((object_ID = gmtapi_decode_id (string)) == GMT_NOTSET)\n\t\treturn_error (V_API, GMT_OBJECT_NOT_FOUND);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\n\tS_obj = API->object[item];\t/* Short-hand */\n\tif (S_obj->family != S_obj->actual_family)\t/* Reset the un-masquerading that GMT_Open_VirtualFile did */\n\t\tS_obj->family = S_obj->actual_family;\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Close_VirtualFile_ (unsigned int *family, char *string, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Close_VirtualFile (GMT_FORTRAN, string));\n}\n#endif\n\nint gmtlib_delete_virtualfile (void *V_API, const char *string) {\n\t/* Given a VirtualFile name, delete its record bu NULLing it */\n\tint object_ID, item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (string == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tif ((object_ID = gmtapi_decode_id (string)) == GMT_NOTSET)\n\t\treturn_error (V_API, GMT_OBJECT_NOT_FOUND);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\n\tS_obj = API->object[item];\t/* Short-hand */\n\tif (S_obj->family != S_obj->actual_family)\t/* Reset the un-masquerading that GMT_Open_VirtualFile did */\n\t\tS_obj->family = S_obj->actual_family;\n\tS_obj->no_longer_owner = true;\n\tS_obj->resource = NULL;\n\n\treturn GMT_NOERROR;\n}\n\nvoid * GMT_Read_VirtualFile (void *V_API, const char *string) {\n\t/* Given a VirtualFile name, retrieve the resulting object */\n\tint object_ID;\n\tvoid *object = NULL;\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (string == NULL) return_null (V_API, GMT_PTR_IS_NULL);\n\tif ((object_ID = gmtapi_decode_id (string)) == GMT_NOTSET)\n\t\treturn_null (V_API, GMT_OBJECT_NOT_FOUND);\n\tif ((object = gmtapi_retrieve_data (V_API, object_ID)) == NULL)\n\t\treturn_null (V_API, GMT_OBJECT_NOT_FOUND);\n\treturn object;\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_Read_VirtualFile_ (char *string, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Read_VirtualFile (GMT_FORTRAN, string));\n}\n#endif\n\nint GMT_Inquire_VirtualFile (void *V_API, const char *string) {\n\t/* Given a VirtualFile name, retrieve the family of the resulting object */\n\tint object_ID, item;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (string == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tif ((object_ID = gmtapi_decode_id (string)) == GMT_NOTSET)\n\t\treturn_error (V_API, GMT_OBJECT_NOT_FOUND);\n\tif ((item = gmtlib_validate_id (V_API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\treturn API->object[item]->family;\n}\n\n#ifdef FORTRAN_API\nint GMT_Inquire_VirtualFile_ (char *string, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Inquire_VirtualFile (GMT_FORTRAN, string));\n}\n#endif\n\n /*! . */\nint GMT_Init_VirtualFile (void *V_API, unsigned int mode, const char *name) {\n\t/* Reset a virtual file back to its original configuration so that it can be\n\t * repurposed for reading or writing again.\n\t */\n\tint object_ID = GMT_NOTSET, item;\n\tstruct GMTAPI_DATA_OBJECT *S = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tgmt_M_unused (mode);\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (name == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tif ((object_ID = gmtapi_decode_id (name)) == GMT_NOTSET) return (GMT_OBJECT_NOT_FOUND);\t/* Not a registered resource */\n\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_error (API, GMT_OBJECT_NOT_FOUND);\n\tS = API->object[item];\t/* Short-hand pointer */\n\tS->rec = 0;\t/* Start at first record */\n\tS->delay = 0;\t/* No Nan-fuckery yet */\n\tS->s_delay = S->h_delay = false;\t/* No header issues yet */\n\tS->status = GMT_IS_UNUSED;\n\tS->selected = true;\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Init_VirtualFile_ (unsigned int mode, char *string, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Init_VirtualFile (GMT_FORTRAN, mode, string));\n}\n#endif\n\nGMT_LOCAL bool gmtapi_is_passable (struct GMTAPI_DATA_OBJECT *S_obj, unsigned int family) {\n\tif (family != (unsigned int)S_obj->actual_family) return false;\t/* Cannot deal with masquerading containers */\n\tif (S_obj->resource == NULL) return false;\t/* Certainly cannot pass this guy */\n\tif (S_obj->method != GMT_IS_REFERENCE) return false;\t/* Only references can be passed */\n\tif (S_obj->family == GMT_IS_GRID) {\n\t\tstruct GMT_GRID *G = gmtapi_get_grid_data (S_obj->resource);\n\t\treturn (G->data == NULL) ? false : true;\n\t}\n\tif (S_obj->family == GMT_IS_IMAGE) {\n\t\tstruct GMT_IMAGE *I = gmtapi_get_image_data (S_obj->resource);\n\t\treturn (I->data == NULL) ? false : true;\n\t}\n\treturn true; /* True to its word, otherwise we fall through and read the data */\n}\n\n/* Simple macro to tell us if this file (which we know is a memory file when called) is an output file */\n#define gmtapi_M_is_output(file) (file[GMTAPI_OBJECT_DIR_START] == 'O')\n\n/*! . */\nvoid * GMT_Read_Data (void *V_API, unsigned int family, unsigned int method, unsigned int geometry, unsigned int mode, double wesn[], const char *infile, void *data) {\n\t/* Function to read data files directly into program memory as a set (not record-by-record).\n\t * We can combine the <register resource - import resource > sequence in\n\t * one combined function.  See GMT_Register_IO for details on arguments.\n\t * data is pointer to an existing grid container when we read a grid in two steps, otherwise it must be NULL.\n\t * Case 1: infile != NULL: Register input as the source and import data.\n\t * Case 2: infile == NULL: Register stdin as the source and import data.\n\t * Case 3: geometry == 0: Loop over all previously registered AND unread sources and combine as virtual dataset [DATASET only]\n\t * Case 4: family is GRID|IMAGE and method = GMT_DATA_ONLY: Just find already registered resource\n\t * Return: Pointer to data container, or NULL if there were errors (passed back via API->error).\n\t */\n\tint in_ID = GMT_NOTSET, item = GMT_NOTSET;\n\tunsigned int module_input = 0;\n\tbool just_get_data, reset, reg_here = false;\n\tvoid *new_obj = NULL;\n\tchar *input = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif (infile) input = strdup (infile);\n\tjust_get_data = (gmt_M_file_is_memory (input));     /* A regular GMT resource passed via memory */\n\tif (just_get_data && gmtapi_M_is_output (input)) {  /* A virtual output file created elsewhere, retrieve and we are done */\n\t\tgmt_M_str_free (input);\n\t\treturn (GMT_Read_VirtualFile (API, infile));\n\t}\n\treset = (mode & GMT_IO_RESET);\t/* We want to reset resource as unread after reading it */\n\tif (reset) mode -= GMT_IO_RESET;\n\tmodule_input = (family & GMT_VIA_MODULE_INPUT);\t/* Are we reading a resource that should be considered a module input? */\n\tfamily -= module_input;\n\tAPI->module_input = (module_input) ? true : false;\n\tif (a_grid_or_image_or_cube (family)) {\t/* Further checks on the data argument */\n\t\tif ((mode & GMT_DATA_ONLY) && data == NULL) {\n\t\t\tfree (input);\n\t\t\treturn_null (V_API, GMT_PTR_IS_NULL);\n\t\t}\n\t\tif ((mode & GMT_CONTAINER_ONLY) && data != NULL) {\n\t\t\tfree (input);\n\t\t\treturn_null (V_API, GMT_PTR_NOT_NULL);\n\t\t}\n\t}\n\n\tif (!gmt_M_file_is_remote (infile) && !gmt_M_file_is_url(infile) && infile && strpbrk (infile, \"*?[]\") && !gmtapi_file_with_netcdf_directive (API, infile)) {\n\t\t/* Gave a wildcard filename */\n\t\tuint64_t n_files;\n\t\tunsigned int k;\n\t\tchar **filelist = NULL;\n\t\tif (!multiple_files_ok (family)) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Read_Data: Wildcards only allowed for DATASET. \"\n\t\t\t                                 \"Use GMT_Read_Group to read groups of other data types\\n\");\n\t\t\tfree (input);\n\t\t\treturn_null (API, GMT_ONLY_ONE_ALLOWED);\n\t\t}\n\t\tif ((n_files = gmtlib_glob_list (API->GMT, infile, &filelist)) == 0) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Read_Data: Expansion of \\\"%s\\\" gave no results\\n\", infile);\n\t\t\tfree (input);\n\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t}\n\t\tAPI->shelf = family;\t/* Save which one it is so we know in gmtapi_get_data */\n\t\tAPI->module_input = true;\t/* Since we are passing NULL as file name we must loop over registered resources */\n\t\tfor (k = 0; k < n_files; k++) {\n\t\t\tif ((in_ID = GMT_Register_IO (API, family|GMT_VIA_MODULE_INPUT, GMT_IS_FILE, geometry, GMT_IN, NULL, filelist[k])) == GMT_NOTSET) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Read_Data: Could not register file for input: \\n\", filelist[k]);\n\t\t\t\tgmt_M_str_free (input);\n\t\t\t\tgmt_free_list (API->GMT, filelist, n_files);\t/* Free the file list */\n\t\t\t\treturn_null (API, API->error);\n\t\t\t}\n\t\t\tif ((item = gmtlib_validate_id (API, family, in_ID, GMT_IN, GMTAPI_MODULE_INPUT)) == GMT_NOTSET) {\n\t\t\t\tgmt_M_str_free (input);\n\t\t\t\tgmt_free_list (API->GMT, filelist, n_files);\t/* Free the file list */\n\t\t\t\treturn_null (API, API->error);\t/* Some internal error... */\n\t\t\t}\n\t\t\tAPI->object[item]->selected = true;\n\t\t}\n\t\tgmt_free_list (API->GMT, filelist, n_files);\t/* Free the file list */\n\t\tin_ID = GMT_NOTSET;\n\t}\n\telse if (a_grid_or_image (family) && (mode & GMT_DATA_ONLY)) {\t/* Case 4: Already registered when we obtained header, find object ID */\n\t\tif ((in_ID = gmtapi_is_registered (API, family, geometry, GMT_IN, mode, input, data)) == GMT_NOTSET) {\n\t\t\tif (input) gmt_M_str_free (input);\n\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find it */\n\t\t}\n\t\tif (!full_region (wesn) || (family == GMT_IS_CUBE && wesn && wesn[ZLO] != wesn[ZHI])) {\t/* Must update subset selection */\n\t\t\tint item;\n\t\t\tif ((item = gmtlib_validate_id (API, family, in_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET) {\n\t\t\t\tif (input) gmt_M_str_free (input);\n\t\t\t\treturn_null (API, API->error);\n\t\t\t}\n\t\t\tif (family == GMT_IS_CUBE)\n\t\t\t\tgmt_M_memcpy (API->object[item]->wesn, wesn, 6, double);\n\t\t\telse\n\t\t\t\tgmt_M_memcpy (API->object[item]->wesn, wesn, 4, double);\n\t\t\tAPI->object[item]->region = true;\n\t\t}\n\t}\n\telse if (input) {\t/* Case 1: Load from a single input, given source. Register it first. */\n\t\tunsigned int first = 0;\n\t\t/* Must handle special case when a list of colors are given instead of a CPT name.  We make a temp CPT from the colors */\n\t\tif (family == GMT_IS_PALETTE && !just_get_data) { /* CPTs must be handled differently since the master files live in share/cpt and filename is missing .cpt */\n\t\t\tint c_err = 0;\n\t\t\tchar CPT_file[PATH_MAX] = {\"\"}, *file = NULL, *m = NULL, *f = NULL;\n\t\t\tif (input[0] == '@') first = gmt_download_file_if_not_found (API->GMT, input, 0);\t/* Deal with downloadable CPTs */\n\t\t\tfile = strdup (&input[first]);\n\t\t\tif ((c_err = gmtapi_colors2cpt (API, &file, &mode)) < 0) { /* Maybe converted colors to new CPT */\n\t\t\t\tgmt_M_str_free (input);\n\t\t\t\tgmt_M_str_free (file);\n\t\t\t\treturn_null (API, GMT_CPT_READ_ERROR);\t/* Failed in the conversion */\n\t\t\t}\n\t\t\telse if (c_err == 0) {\t/* Regular cpt (master or local), append .cpt and set path */\n\t\t\t\tbool is_cpt_master = gmt_is_cpt_master (API->GMT, file);\n\t\t\t\tchar *q = NULL;\n\n\t\t\t\t/* Need to check for CPT filename modifiers */\n\t\t\t\tif ((f = gmt_strrstr (file, GMT_CPT_EXTENSION)))\n\t\t\t\t\tm = gmtlib_last_valid_file_modifier (API, f, GMT_CPTFILE_MODIFIERS);\n\t\t\t\telse\n\t\t\t\t\tm = gmtlib_last_valid_file_modifier (API, file, GMT_CPTFILE_MODIFIERS);\n\n\t\t\t\tif (m) {\t/* Got one or more valid CPT file modifiers */\n\t\t\t\t\tif ((q = gmtlib_cptfile_unitscale (API, m))) q[0] = '\\0';    /* Truncate modifier after processing the unit */\n\t\t\t\t\tif (m[0] && (q = strstr (m, \"+h\"))) q[0] = '\\0';    /* Truncate +h modifier (checking for m[0] since the line above could leave it blank) */\n\t\t\t\t}\n\t\t\t\tif (is_cpt_master)\t/* Master: Append extension and supply path */\n\t\t\t\t\tgmt_getsharepath (API->GMT, \"cpt\", file, GMT_CPT_EXTENSION, CPT_file, R_OK);\n\t\t\t\telse if (!gmt_getdatapath (API->GMT, file, CPT_file, R_OK)) {\t/* Use name.cpt as is but look for it */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Read_Data: File not found: %s\\n\", file);\n\t\t\t\t\tgmt_M_str_free (input);\n\t\t\t\t\treturn_null (API, GMT_FILE_NOT_FOUND);\t/* Failed to find the file anywhere */\n\t\t\t\t}\n\t\t\t\tif (m && q) {q[0] = '+'; strncat (CPT_file, q, PATH_MAX-1);}\t/* Add back the z modifiers */\n\t\t\t}\n\t\t\telse\t/* Got color list, now a temp CPT instead */\n\t\t\t\tstrncpy (CPT_file, file, PATH_MAX-1);\n\t\t\tgmt_M_str_free (file);\t/* Free temp CPT name */\n\t\t\tif ((in_ID = GMT_Register_IO (API, family, method, geometry, GMT_IN, wesn, CPT_file)) == GMT_NOTSET) {\n\t\t\t\tgmt_M_str_free (input);\n\t\t\t\treturn_null (API, API->error);\n\t\t\t}\n\t\t}\n\t\telse {\t/* Not a CPT file but could be remote */\n\t\t\tint k_data;\n\t\t\tchar file[PATH_MAX] = {\"\"};\n\t\t\tif (API->remote_info == NULL && !API->GMT->current.io.internet_error && input[0] == '@') {\n\t\t\t\t/* Maybe using the API without a module call first so server has not been refreshed yet */\n\t\t\t\tgmt_refresh_server (API);\n\t\t\t}\n\t\t\tgmt_set_unspecified_remote_registration (API, &input);\t/* Same, this call otherwise only happens with modules */\n\t\t\tfirst = gmt_download_file_if_not_found (API->GMT, input, 0);\t/* Deal with downloadable GMT data sets first */\n\t\t\tstrncpy (file, &input[first], PATH_MAX-1);\n\t\t\tif ((k_data = gmt_remote_no_extension (API, input)) != GMT_NOTSET)\t/* A remote @earth_relief_xxm|s grid without extension */\n\t\t\t\tstrcat (file, API->remote_info[k_data].ext);\t/* Must supply the .extension */\n\t\t\tif ((in_ID = GMT_Register_IO (API, family|module_input, method, geometry, GMT_IN, wesn, file)) == GMT_NOTSET) {\n\t\t\t\tgmt_M_str_free (input);\n\t\t\t\treturn_null (API, API->error);\n\t\t\t}\n\t\t}\n\t\treg_here = true;\n\t}\n\telse if (input == NULL && geometry) {\t/* Case 2: Load from stdin.  Register stdin first */\n\t\tif ((in_ID = GMT_Register_IO (API, family|module_input, GMT_IS_STREAM, geometry, GMT_IN, wesn, API->GMT->session.std[GMT_IN])) == GMT_NOTSET) {\n\t\t\tgmt_M_str_free (input);\n\t\t\treturn_null (API, API->error);\t/* Failure to register std??? */\n\t\t}\n\t\treg_here = true;\n\t}\n\telse {\t/* Case 3: input == NULL && geometry == 0, so use all previously registered sources (unless already used). */\n\t\tif (!multiple_files_ok (family))\n\t\t\treturn_null (API, GMT_ONLY_ONE_ALLOWED);\t/* Virtual source only applies to data and text tables */\n\t\tAPI->shelf = family;\t/* Save which one it is so we know in gmtapi_get_data */\n\t\tAPI->module_input = true;\t/* Since we are passing NULL as file name we must loop over registered resources */\n\t}\n\tif (just_get_data) {\n\t\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\t\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, in_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET) {\n\t\t\tgmt_M_str_free (input);\n\t\t\treturn_null (API, API->error);\n\t\t}\n\t\tS_obj = API->object[item];\t/* Current object */\n\t\t/* Try to catch a matrix or vector masquerading as dataset by examining the object's actual family  */\n\t\tif (gmtapi_is_passable (S_obj, family)) {\t/* True to its word, otherwise we fall through and read the data */\n#ifdef DEBUG\n\t\t\tgmtapi_set_object (API, S_obj);\n#endif\n\t\t\tif (reset) S_obj->status = 0;\t/* Reset  to unread */\n\t\t\treturn (gmtapi_pass_object (API, S_obj, family, mode, wesn));\n\t\t}\n\t}\n\n\t/* OK, try to do the importing */\n\tif (in_ID != GMT_NOTSET) {\t/* Make sure we select the item we just registered */\n\t\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, in_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET) {\n\t\t\tgmt_M_str_free (input);\n\t\t\treturn_null (API, API->error);\n\t\t}\n\t\tAPI->object[item]->selected = true;\t/* Make sure the item we want is now selected */\n\t}\n\tif ((new_obj = gmtapi_get_data (API, in_ID, mode, data)) == NULL) {\n\t\tif (reg_here) gmtlib_unregister_io (API, in_ID, GMT_IN);\t/* Since reading failed */\n\t\tgmt_M_str_free (input);\t/* Done with this variable) */\n\t\treturn_null (API, API->error);\n\t}\n\tif (reset) API->object[item]->status = 0;\t/* Reset  to unread */\n\tgmt_M_str_free (input);\t/* Done with this variable) */\n\tAPI->module_input = false;\t/* Reset to normal */\n\n#ifdef DEBUG\n\tgmtapi_list_objects (API, \"GMT_Read_Data\");\n#endif\n\n\treturn (new_obj);\t\t/* Return pointer to the data container */\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_Read_Data_ (unsigned int *family, unsigned int *method, unsigned int *geometry, unsigned int *mode, double *wesn, char *input, void *data, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Read_Data (GMT_FORTRAN, *family, *method, *geometry, *mode, wesn, input, data));\n}\n#endif\n\n/*! . */\nvoid * GMT_Read_Group (void *V_API, unsigned int family, unsigned int method, unsigned int geometry, unsigned int mode, double wesn[], void *sources, unsigned int *n_items, void *data) {\n\t/* Function to read a group of data files directly into program memory given an array of objects.\n\t * data is pointer to an existing array of grid container when we read a grid in two steps, otherwise use NULL.\n\t * *n_items = 0: sources is a character string with wildcard-specification for file names.\n\t * *n_items > 0: sources is an array of *n_items character strings with filenames.\n\t * If n_items == NULL then it means 0 but we do not return back the number of items.\n\t * Note: For DATASET you can also use wildcard expressions in GMT_Read_Data but there we combine then into one data|test-set.\n\t * Return: Pointer to array of data container, or NULL if there were errors (passed back via API->error).\n\t */\n\tbool free_list = false;\n\tunsigned int n_files, k;\n\tchar **file = NULL, *pattern = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tvoid **object = NULL;\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tif (data && !a_grid_or_image (family)) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Read_Group: data pointer must be NULL except for GRID and IMAGE\\n\");\n\t\treturn_null (API, GMT_PTR_NOT_NULL);\n\t}\n\tif (n_items && *n_items > 0) {\t/* Gave list of files */\n\t\tn_files = *n_items;\n\t\tfile = (char **)sources;\n\t}\n\telse {\t/* Gave wildcard expression(s) */\n\t\tpattern = (void *)sources;\n\t\tif ((n_files = (unsigned int)gmtlib_glob_list (API->GMT, pattern, &file)) == 0) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Read_Group: Expansion of \\\"%s\\\" gave no results\\n\", pattern);\n\t\t\treturn_null (API, GMT_OBJECT_NOT_FOUND);\n\t\t}\n\t\tfree_list = true;\n\t}\n\t/* Reuse data or allocate empty array of containers */\n\tobject = (data == NULL) ? gmtapi_alloc_object_array (API, n_files, family) : data;\n\tfor (k = 0; k < n_files; k++) {\n\t\tif ((object[k] = GMT_Read_Data (API, family, method, geometry, mode, wesn, file[k], object[k])) == NULL)\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Read_Group: Reading of %s failed, returning NULL\\n\", file[k]);\n\t}\n\tif (free_list) {\t/* Free the file list we created above and optionally return back how many we found */\n\t\tgmt_free_list (API->GMT, file, n_files);\n\t\tif (n_items) *n_items = n_files;\t/* Return how many items we allocated, if n_items is not NULL */\n\t}\n\treturn (object);\t/* Return pointer to the data containers */\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_Read_Group_ (unsigned int *family, unsigned int *method, unsigned int *geometry, unsigned int *mode, double *wesn, void *sources, unsigned int *n_items, void *data) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Read_Group (GMT_FORTRAN, *family, *method, *geometry, *mode, wesn, sources, n_items, data));\n}\n#endif\n\n/*! . */\nvoid * GMT_Duplicate_Data (void *V_API, unsigned int family, unsigned int mode, void *data) {\n\t/* Create an duplicate container of the requested kind and optionally allocate space\n\t * or duplicate content.\n\t * The known families are GMT_IS_{DATASET,GRID,PALETTE,IMAGE,POSTSCRIPT}.\n \t * Pass mode as one of GMT_DUPLICATE_{NONE|ALLOC|DATA} to just duplicate the\n\t * container and header structures, allocate space of same dimensions as original,\n\t * or allocate space and duplicate contents.  For GMT_IS_{DATA|TEXT}SET you may add\n\t * the modifiers GMT_ALLOC_VERTICAL or GMT_ALLOC_HORIZONTAL. Also, for GMT_IS_DATASET\n\t * you can manipulate the incoming data->dim to overwrite the number of items allocated.\n\t * [By default we follow the dimensions of the incoming data].\n\t *\n\t * Return: Pointer to new resource, or NULL if an error (set via API->error).\n\t */\n\n\tint object_ID, item;\n\tunsigned int geometry = 0U, pmode = 0U;\n\tvoid *new_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (data == NULL)  return_null (V_API, GMT_PTR_IS_NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tGMT = API->GMT;\n\n\tswitch (family) {\t/* dataset, cpt, text, grid , image, vector, matrix */\n\t\tcase GMT_IS_GRID:\t/* GMT grid, allocate header and possibly data array */\n\t\t\tnew_obj = gmt_duplicate_grid (GMT, data, mode);\n\t\t\tgeometry = GMT_IS_SURFACE;\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* GMT image, allocate header but not data array */\n\t\t\tnew_obj = gmtlib_duplicate_image (GMT, data, mode);\n\t\t\tgeometry = GMT_IS_SURFACE;\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* GMT dataset, allocate the requested tables, segments, rows, and columns */\n\t\t\tpmode = (mode & (GMT_ALLOC_VERTICAL + GMT_ALLOC_HORIZONTAL));\t/* Just isolate any special allocation modes */\n\t\t\tmode -= pmode;\t/* Remove the hor/ver flags from the rest of mode */\n\t\t\tif (mode == GMT_DUPLICATE_DATA)\n\t\t\t\tnew_obj = gmt_duplicate_dataset (GMT, data, pmode, &geometry);\n\t\t\telse if (mode == GMT_DUPLICATE_ALLOC) {\t/* Allocate data set of same size, possibly modulated by Din->dim (of > 0) and pmode */\n\t\t\t\tstruct GMT_DATASET *Din = gmtapi_get_dataset_data (data);\t/* We know this is a GMT_DATASET pointer */\n\t\t\t\tstruct GMT_DATASET_HIDDEN *DH = gmt_get_DD_hidden (Din);\n\t\t\t\tnew_obj = gmt_alloc_dataset (GMT, data, DH->dim[GMT_ROW], DH->dim[GMT_COL], pmode);\n\t\t\t\tgeometry = Din->geometry;\n\t\t\t\tgmt_M_memset (DH->dim, 4U, uint64_t);\t/* Reset alloc dimensions */\n\t\t\t}\n\t\t\telse {\t/* Just want a dataset structure */\n\t\t\t\tstruct GMT_DATASET *Din = gmtapi_get_dataset_data (data);\t/* We know this is a GMT_DATASET pointer */\n\t\t\t\tnew_obj = gmt_get_dataset (GMT);\n\t\t\t\tgeometry = Din->geometry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\t/* GMT CPT, allocate one with space for dim[0] color entries */\n\t\t\tnew_obj = gmtlib_duplicate_palette (GMT, data, 0);\n\t\t\tgeometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\t/* GMT PS, allocate one with space for the original */\n\t\t\tnew_obj = gmtlib_duplicate_ps (GMT, data, 0);\n\t\t\tgeometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tcase GMT_IS_CUBE:\t/* GMT cube, allocate header and possibly data array */\n\t\t\tnew_obj = gmtlib_duplicate_cube (GMT, data, mode);\n\t\t\tgeometry = GMT_IS_VOLUME;\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* GMT MATRIX */\n\t\t\tnew_obj = gmtlib_duplicate_matrix (GMT, data, mode);\n\t\t\tgeometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* GMT VECTOR */\n\t\t\tnew_obj = gmtlib_duplicate_vector (GMT, data, mode);\n\t\t\tgeometry = GMT_IS_NONE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\tif (API->error) return_null (API, API->error);\n\n\t/* Now register this dataset so it can be deleted by GMT_Destroy_Data */\n\tif ((object_ID = GMT_Register_IO (API, family, GMT_IS_REFERENCE, geometry, GMT_IN, NULL, new_obj)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\t/* Failure to register */\n\tif ((item = gmtlib_validate_id (API, family, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\tAPI->object[item]->geometry = geometry;\t/* Ensure same geometry */\n\tAPI->object[item]->resource = new_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Successfully duplicated a %s\\n\", GMT_family[family]);\n#ifdef DEBUG\n\tgmtapi_list_objects (API, \"GMT_Duplicate_Data\");\n#endif\n\n\treturn (new_obj);\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_Duplicate_Data_ (unsigned int *family,  unsigned int *mode, void *data) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Duplicate_Data (GMT_FORTRAN, *family, *mode, data));\n}\n#endif\n\n/*! . */\nint GMT_Write_Data (void *V_API, unsigned int family, unsigned int method, unsigned int geometry, unsigned int mode, double wesn[], const char *outfile, void *data) {\n\t/* Function to write data directly from program memory as a set (not record-by-record).\n\t * We can combine the <register resource - export resource > sequence in\n\t * one combined function.  See GMT_Register_IO for details on arguments.\n\t * Here, *data is the pointer to the data object to save (CPT, dataset, Grid)\n\t * Case 1: outfile != NULL: Register this as the destination and export data.\n\t * Case 2: outfile == NULL: Register stdout as the destination and export data.\n\t * Case 3: geometry == 0: Use a previously registered single destination.\n\t * While only one output destination is allowed, for DATASETS one can\n\t * have the tables and even segments be written to individual files (see the mode\n\t * description in the documentation for how to enable this feature.)\n\t * Return: false if all is well, true if there was an error (and set API->error).\n\t */\n\tunsigned int n_reg;\n\tint out_ID;\n\tchar *output = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (data == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif (outfile) output = strdup (outfile);\n\n\tif (output) {\t/* Case 1: Save to a single specified destination (file or memory).  Register it first. */\n\t\tif ((out_ID = gmtapi_memory_registered (API, family, GMT_OUT, output)) != GMT_NOTSET) {\n\t\t\t/* Output is a memory resource, passed via a @GMTAPI@-###### file name, and ###### is the out_ID.\n\t\t\t   In this case we must make some further checks.  We need to find the API object that holds data.\n\t\t\t   We do this below and get in_ID (the id of the data to write), while out_ID is the id of where\n\t\t\t   things go (the output \"memory\").  Having the in_ID we get the array index in_item that matches\n\t\t\t   this ID and of the correct family.  We set direction to GMT_NOTSET since otherwise we may be\n\t\t\t   denied a hit as we don't really know what the direction is for in_ID.  Once in_item has been\n\t\t\t   secured we transfer ownership of this data from the in_ID object to the out_ID object.  That\n\t\t\t   way we avoid accidental premature freeing of the data object via the in_ID object since it now\n\t\t\t   will live on via out_ID and outlive the current module.\n\t\t\t    */\n\t\t\tint in_ID = GMT_NOTSET,  in_item = GMT_NOTSET;\n\t\t\tin_ID = gmtapi_get_object (API, family, data);\t/* Get the object ID of the input source */\n\t\t\tif (in_ID != GMT_NOTSET) in_item = gmtlib_validate_id (API, family, in_ID, GMT_NOTSET, GMT_NOTSET);\t/* Get the item in the API array; pass dir = GMT_NOTSET to bypass status check */\n\t\t\tif (in_item != GMT_NOTSET) {\n\t\t\t\tint out_item = gmtlib_validate_id (API, GMT_NOTSET, out_ID, GMT_OUT, GMT_NOTSET);\t/* Get the item in the API array; pass family = GMT_NOTSET to bypass status check */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Write_Data: Writing %s to memory object %d from object %d which transfers ownership\\n\", GMT_family[family], out_ID, in_ID);\n\t\t\t\tif (API->object[out_item]->method == GMT_IS_REFERENCE) API->object[in_item]->no_longer_owner = true;\t/* Since we have passed the content onto an output object */\n\t\t\t\tif (!API->object[out_item]->filename) API->object[out_item]->filename = strdup (output);\n\t\t\t}\n\t\t}\t/* else it is a regular file and we just register it and get the new out_ID needed below */\n\t\telse if ((out_ID = GMT_Register_IO (API, family, method, geometry, GMT_OUT, wesn, output)) == GMT_NOTSET) {\n\t\t\tgmt_M_str_free (output);\t/* Done with this variable */\n\t\t\treturn_error (API, API->error);\n\t\t}\n\t}\n\telse if (output == NULL && geometry) {\t/* Case 2: Save to stdout.  Register stdout first. */\n\t\tif (family == GMT_IS_GRID) return_error (API, GMT_STREAM_NOT_ALLOWED);\t/* Cannot write grids to stream */\n\t\tif ((out_ID = GMT_Register_IO (API, family, GMT_IS_STREAM, geometry, GMT_OUT, wesn, API->GMT->session.std[GMT_OUT])) == GMT_NOTSET) return_error (API, API->error);\t/* Failure to register std??? */\n\t}\n\telse {\t/* Case 3: output == NULL && geometry == 0, so use the previously registered destination */\n\t\tif ((n_reg = gmtlib_count_objects (API, family, geometry, GMT_OUT, &out_ID)) != 1) {\n\t\t\tgmt_M_str_free (output);\t/* Done with this variable */\n\t\t\treturn_error (API, GMT_NO_OUTPUT);\t/* There is no registered output */\n\t\t}\n\t}\n\tgmt_M_str_free (output);\t/* Done with this variable */\n\t/* With out_ID in hand we can now put the data where it should go */\n\tif (gmtapi_put_data (API, out_ID, mode, data) != GMT_NOERROR)\n\t\treturn_error (API, API->error);\n\n#ifdef DEBUG\n\tgmtapi_list_objects (API, \"GMT_Write_Data\");\n#endif\n\treturn (GMT_NOERROR);\t/* No error encountered */\n}\n\n#ifdef FORTRAN_API\nint GMT_Write_Data_ (unsigned int *family, unsigned int *method, unsigned int *geometry, unsigned int *mode, double *wesn, char *output, void *data, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Write_Data (GMT_FORTRAN, *family, *method, *geometry, *mode, wesn, output, data));\n}\n#endif\n\nstatic inline int gmtapi_wind_to_next_datarecord (int64_t *count, struct GMT_DATASET *D, unsigned int mode) {\n\t/* Increment row, seg, tbl to next record and return current record status */\n\tif (count[GMT_SEG] == -1) {\t/* Special flag to processes table header(s) */\n\t\tif (count[GMTAPI_HDR_POS] < D->table[count[GMT_TBL]]->n_headers) {\t/* Must first handle table headers */\n\t\t\tcount[GMTAPI_HDR_POS]++;\t/* Increment counter for each one we return until done */\n\t\t\treturn GMT_IO_TABLE_HEADER;\n\t\t}\n\t\t/* Must be out of table headers - time for the segment header */\n\t\tcount[GMT_SEG] = count[GMT_ROW] = 0;\n\t\treturn GMT_IO_SEGMENT_HEADER;\n\t}\n\tif (count[GMT_ROW] == (int64_t)D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->n_rows) {\t/* Previous record was last in segment, go to next */\n\t\tcount[GMT_SEG]++;\t/* Next segment number */\n\t\tcount[GMT_ROW] = 0;\n\t\tif (count[GMT_SEG] == (int64_t)D->table[count[GMT_TBL]]->n_segments) {\t\t/* Also the end of a table (\"file\") */\n\t\t\tcount[GMT_TBL]++;\t/* Next table number */\n\t\t\tcount[GMT_SEG] = -1;\t/* Reset to start at first segment in this table */\n\t\t\tcount[GMTAPI_HDR_POS] = 0;\t/* Ready to process headers from next table */\n\t\t\tif (count[GMT_TBL] == (int64_t)D->n_tables)\t/* End of entire data set */\n\t\t\t\treturn GMT_IO_EOF;\n\t\t\t/* Just end of a file */\n\t\t\tif (mode & GMT_READ_FILEBREAK)\t/* Return empty handed to indicate a break between files */\n\t\t\t\treturn GMT_IO_NEXT_FILE;\n\t\t}\n\t\treturn GMT_IO_SEGMENT_HEADER;\n\t}\n\t/* No drama, here we have a data record just go to next row */\n\treturn GMT_IO_DATA_RECORD;\n}\n\n/*! . */\nint GMT_Set_Geometry (void *V_API, unsigned int direction, unsigned int geometry) {\n\t/* Sets the geometry of direction resource for record-by-record i/o.\n\t * This currently only applies to external interfaces receiving data via rec-by-rec writing.\n\t */\n\tunsigned int method;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tif (!API->io_enabled[GMT_OUT]) return_error (API, GMT_ACCESS_NOT_ENABLED);\n\tAPI->error = GMT_NOERROR;\n\n\tS_obj = API->object[API->current_item[direction]];\t/* Shorthand for the data source we are working on */\n\tif (S_obj == NULL) return_error (API, GMT_OBJECT_NOT_FOUND);\t/* No such object */\n\tmethod = gmtapi_set_method (S_obj);\t/* Get the actual method to use */\n\tswitch (method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_DUPLICATE:\n\t\tcase GMT_IS_REFERENCE:\n\t\t\tif (S_obj->family == GMT_IS_DATASET) {\n\t\t\t\tstruct GMT_DATASET *D_obj = gmtapi_get_dataset_data (S_obj->resource);\n\t\t\t\tif (!D_obj)\t/* Not allocated yet? */\n\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMTAPI: GMT_Set_Geometry called but no object available\\n\");\n\t\t\t\telse\n\t\t\t\t\tD_obj->geometry = geometry;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\t/* For all others there is no geometry requirement, so quietly skip */\n\t\t\tbreak;\n\t}\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Set_Geometry_ (unsigned int *direction, unsigned int *geometry) {\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Set_Geometry (GMT_FORTRAN, *direction, *geometry));\n}\n#endif\n\nGMT_LOCAL void * gmtapi_get_record_fp_sub (struct GMTAPI_CTRL *API, unsigned int mode, int *n_fields, struct GMTAPI_DATA_OBJECT **S_obj) {\n\t/* Gets next data record from current open stream */\n\tint status;\n\tstruct GMTAPI_DATA_OBJECT *S = API->current_get_obj;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tvoid *record = S->import (GMT, S->fp, &(S->n_expected_fields), &status);\t/* Get that next record */\n\t*n_fields = status;\t/* Number of fields read */\n\tS->n_columns = (uint64_t)status;\t/* Number of fields read */\n\n\tif (GMT->current.io.status & GMT_IO_EOF) {\t/* Hit end-of-file in current file (but there may be many files in queue) */\n\t\tS->status = GMT_IS_USED;\t/* Mark this file object as read */\n\t\tif (S->close_file) {\t/* Close if it was a file that we opened earlier */\n\t\t\tgmt_fclose (GMT, S->fp);\n\t\t\tS->close_file = false;\n\t\t}\n\t\t/* Move on to next data source, if any */\n\t\tif (gmtapi_next_data_object (API, S->family, GMT_IN) == EOF)\t/* That was the last source, we are done */\n\t\t\t*n_fields = EOF;\t\t\t\t/* EOF is ONLY returned when we reach the end of the LAST data file */\n\t\telse if (mode & GMT_READ_FILEBREAK) {\t\t\t/* Return empty handed to indicate a break between files */\n\t\t\t*n_fields = GMT_IO_NEXT_FILE;\t\t\t/* We flag this situation with a special return value */\n\t\t\tGMT->current.io.status = GMT_IO_NEXT_FILE;\t/* And set the status accordingly */\n\t\t}\n\t\telse {\t/* Get ready to read the next data file */\n\t\t\tS = API->current_get_obj = API->object[API->current_item[GMT_IN]];\t/* Shorthand for the next data source to work on */\n\t\t\tAPI->get_next_record = true;\t\t\t/* Since we haven't read the next record yet */\n\t\t\tgmtapi_get_record_init (API);\t\t\t/* Perform init steps on the new resource */\n\t\t}\n\t\tGMT->current.io.tbl_no++;\t\t\t\t/* Update number of tables we have processed */\n\t}\n\telse\n\t\tS->status = GMT_IS_USING;\t\t\t\t/* Mark current object as being read */\n\t*S_obj = S;\n\treturn record;\n}\n\nstruct GMT_RECORD *api_get_record_fp (struct GMTAPI_CTRL *API, unsigned int mode, int *n_fields) {\n\t/* Gets other data record from current open stream */\n\tstruct GMTAPI_DATA_OBJECT *S;\n\treturn (gmtapi_get_record_fp_sub (API, mode, n_fields, &S));\n}\n\nstruct GMT_RECORD *api_get_record_fp_first (struct GMTAPI_CTRL *API, unsigned int mode, int *n_fields) {\n\t/* Gets first data record from current open stream */\n\tstruct GMTAPI_DATA_OBJECT *S = NULL;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tvoid *record = gmtapi_get_record_fp_sub (API, mode, n_fields, &S);\n\n\tif (gmt_M_rec_is_data (GMT) && S->n_expected_fields != GMT_MAX_COLUMNS) {\t/* Set the actual column count */\n\t\tGMT->common.b.ncol[GMT_IN] = S->n_expected_fields;\n\t\tAPI->api_get_record = api_get_record_fp;\t/* From now on we can read just the record */\n\t}\n\treturn record;\n}\n\nstruct GMT_RECORD *api_get_record_matrix (struct GMTAPI_CTRL *API, unsigned int mode, int *n_fields) {\n\t/* Gets next data record from current matrix */\n\tstruct GMTAPI_DATA_OBJECT *S = API->current_get_obj;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_RECORD *record;\n\n\tif (S->rec >= S->n_rows) {\t/* Our only way of knowing we are done is to quit when we reach the number of rows that was registered */\n\t\tS->status = (API->allow_reuse) ? GMT_IS_UNUSED : GMT_IS_USED;\t/* Mark as finished reading this guy unless we may reuse */\n\t\tif (gmtapi_next_data_object (API, S->family, GMT_IN) == EOF) {\t/* That was the last source, return */\n\t\t\t*n_fields = EOF;\t\t\t\t/* EOF is ONLY returned when we reach the end of the LAST data file */\n\t\t\tGMT->current.io.status = GMT_IO_EOF;\n\t\t}\n\t\telse if (mode & GMT_READ_FILEBREAK) {\t\t\t/* Return empty handed to indicate a break between files */\n\t\t\t*n_fields = GMT_IO_NEXT_FILE;\t\t\t/* We flag this situation with a special return value */\n\t\t\tGMT->current.io.status = GMT_IO_NEXT_FILE;\n\t\t}\n\t\telse {\t/* Get ready to read the next data file */\n\t\t\tS = API->current_get_obj = API->object[API->current_item[GMT_IN]];\t/* Shorthand for the next data source to work on */\n\t\t\tAPI->get_next_record = true;\t/* Since we haven't read the next record yet */\n\t\t}\n\t\tAPI->current_get_M = gmtapi_get_matrix_data (S->resource);\n\t\tAPI->current_get_n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : S->n_columns;\n\t\tif ((API->current_get_M_index = gmtapi_get_2d_to_index (API, API->current_get_M->shape, GMT_GRID_IS_REAL)) == NULL)\n\t\t\treturn NULL;\n\t\tif ((API->current_get_M_val = gmtapi_select_get_function (API, API->current_get_M->type)) == NULL)\n\t\t\treturn NULL;\n\t\trecord = NULL;\n\t}\n\telse {\t/* Read from the current resource */\n\t\tstruct GMT_MATRIX *M = API->current_get_M;\n\t\tuint64_t col, ij, n_use, col_pos;\n\t\tint status;\n\t\tS->status = GMT_IS_USING;\t\t\t\t/* Mark as being read */\n\t\tn_use = gmtapi_n_cols_needed_for_gaps (GMT, S->n_columns);\n\t\tgmtapi_update_prev_rec (GMT, n_use);\n\t\tfor (col = 0; col < API->current_get_n_columns; col++) {\t/* We know the number of columns from registration */\n\t\t\tcol_pos = gmtapi_pick_in_col_number (GMT, (unsigned int)col);\n\t\t\tij = API->current_get_M_index (S->rec, col_pos, M->dim);\n\t\t\tAPI->current_get_M_val (&(M->data), ij, &(GMT->current.io.curr_rec[col]));\n\t\t}\n\t\tS->rec++;\n\t\tif ((status = gmtapi_bin_input_memory (GMT, S->n_columns, n_use)) < 0) {\t/* Process the data record */\n\t\t\tif (status == GMTAPI_GOT_SEGGAP)\t /* Since we inserted a segment header we must revisit this record as first in next segment */\n\t\t\t\tS->rec--, API->current_rec[GMT_IN]--;\n\t\t\trecord = NULL;\n\t\t}\n\t\telse {\t/* Valid data record */\n\t\t\tif (M->text)\t/* Also have text as part of record */\n\t\t\t\tstrncpy (GMT->current.io.curr_trailing_text, M->text[S->rec-1], GMT_BUFSIZ-1);\n\t\t\trecord = &GMT->current.io.record;\n\t\t\t*n_fields = (int)API->current_get_n_columns;\n\t\t}\n\t}\n\treturn (record);\n}\n\nstruct GMT_RECORD *api_get_record_vector (struct GMTAPI_CTRL *API, unsigned int mode, int *n_fields) {\n\t/* Gets next data record from current vector */\n\tstruct GMTAPI_DATA_OBJECT *S = API->current_get_obj;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_RECORD *record;\n\tuint64_t col;\n\n\tif (S->rec == S->n_rows) {\t/* Our only way of knowing we are done is to quit when we reach the number of rows that was registered */\n\t\tS->status = (API->allow_reuse) ? GMT_IS_UNUSED : GMT_IS_USED;\t/* Mark as finished reading this guy unless we may reuse */\n\t\tif (gmtapi_next_data_object (API, S->family, GMT_IN) == EOF) {\t/* That was the last source, return */\n\t\t\t*n_fields = EOF;\t\t\t\t/* EOF is ONLY returned when we reach the end of the LAST data file */\n\t\t\tGMT->current.io.status = GMT_IO_EOF;\n\t\t}\n\t\telse if (mode & GMT_READ_FILEBREAK) {\t\t\t/* Return empty handed to indicate a break between files */\n\t\t\t*n_fields = GMT_IO_NEXT_FILE;\t\t\t/* We flag this situation with a special return value */\n\t\t\tGMT->current.io.status = GMT_IO_NEXT_FILE;\n\t\t}\n\t\telse {\t/* Get ready to read the next data file */\n\t\t\tS = API->current_get_obj = API->object[API->current_item[GMT_IN]];\t/* Shorthand for the next data source to work on */\n\t\t\tAPI->get_next_record = true;\t/* Since we haven't read the next record yet */\n\t\t}\n\t\tAPI->current_get_V = gmtapi_get_vector_data (S->resource);\n\t\tAPI->current_get_n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : S->n_columns;\n\t\tAPI->current_get_V_val = gmt_M_memory (GMT, API->current_get_V_val, API->current_get_V->n_columns, GMT_getfunction);\t/* Array of functions */\n\t\tfor (col = 0; col < API->current_get_V->n_columns; col++)\t/* We know the number of columns from registration */\n\t\t\tAPI->current_get_V_val[col] = gmtapi_select_get_function (API, API->current_get_V->type[col]);\n\t\trecord = NULL;\n\t}\n\telse {\t/* Read from this resource */\n\t\tstruct GMT_VECTOR *V = API->current_get_V;\n\t\tuint64_t n_use, col_pos;\n\t\tint status;\n\t\tS->status = GMT_IS_USING;\t\t\t\t/* Mark as being read */\n\t\tn_use = gmtapi_n_cols_needed_for_gaps (GMT, S->n_columns);\n\t\tgmtapi_update_prev_rec (GMT, n_use);\n\t\tfor (col = 0; col < API->current_get_n_columns; col++) {\t/* We know the number of columns from registration */\n\t\t\tcol_pos = gmtapi_pick_in_col_number (GMT, (unsigned int)col);\n\t\t\tAPI->current_get_V_val[col] (&(V->data[col_pos]), S->rec, &(GMT->current.io.curr_rec[col]));\n\t\t}\n\t\tS->rec++;\n\t\tif ((status = gmtapi_bin_input_memory (GMT, S->n_columns, n_use)) < 0) {\t/* Process the data record */\n\t\t\tif (status == GMTAPI_GOT_SEGGAP)\t /* Since we inserted a segment header we must revisit this record as first in next segment */\n\t\t\t\tS->rec--, API->current_rec[GMT_IN]--;\n\t\t\trecord = NULL;\n\t\t}\n\t\telse {\t/* Valid data record */\n\t\t\tif (V->text)\t/* Also have text as part of record */\n\t\t\t\tstrncpy (GMT->current.io.curr_trailing_text, V->text[S->rec-1], GMT_BUFSIZ-1);\n\t\t\trecord = &GMT->current.io.record;\n\t\t\t*n_fields = (int)API->current_get_n_columns;\n\t\t}\n\t}\n\treturn record;\n}\n\nGMT_LOCAL struct GMT_RECORD * gmtapi_get_record_dataset (struct GMTAPI_CTRL *API, unsigned int mode, int *n_fields) {\n\t/* Gets next data record from current dataset */\n\tstruct GMTAPI_DATA_OBJECT *S = API->current_get_obj;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATASET *D = API->current_get_D_set;\t/* Get the current dataset */\n\tstruct GMT_RECORD *record = NULL;\n\tint64_t *count = GMT->current.io.curr_pos[GMT_IN];\t/* Shorthand used below */\n\tuint64_t col, col_pos;\n\tint status = gmtapi_wind_to_next_datarecord (count, D, mode);\t/* Get current record status and wind counters if needed */\n\n\tswitch (status) {\n\t\tcase GMT_IO_DATA_RECORD:\t/* Got a data record */\n\t\t\tS->status = GMT_IS_USING;\t\t/* Mark this resource as currently being read */\n\t\t\tfor (col = 0; col < API->current_get_n_columns; col++) {\t/* Copy from row to curr_rec */\n\t\t\t\tcol_pos = gmtapi_pick_in_col_number (GMT, (unsigned int)col);\n\t\t\t\tGMT->current.io.curr_rec[col] = D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->data[col_pos][count[GMT_ROW]];\n\t\t\t}\n\t\t\tif (D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->text && D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->text[count[GMT_ROW]])\n\t\t\t\tstrncpy (GMT->current.io.curr_trailing_text, D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->text[count[GMT_ROW]], GMT_BUFSIZ-1);\n\t\t\tif (GMT->current.setting.io_lonlat_toggle[GMT_IN] && API->current_get_n_columns >= 2) {\n\t\t\t\tgmt_M_double_swap (GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y]);\t/* Got lat/lon instead of lon/lat */\n\t\t\t}\n\t\t\trecord = &GMT->current.io.record;\n\t\t\tGMT->common.b.ncol[GMT_IN] = API->current_get_n_columns;\n\t\t\t*n_fields = (int)API->current_get_n_columns;\n\t\t\tcount[GMT_ROW]++;\t/* Advance to next row for next time GMT_Get_Record is called */\n\t\t\tbreak;\n\t\tcase GMT_IO_SEGMENT_HEADER:\t/* Segment break */\n\t\t\tif (D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->header)\n\t\t\t\tstrncpy (GMT->current.io.segment_header, D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->header, GMT_BUFSIZ-1);\n\t\t\telse\n\t\t\t\tGMT->current.io.segment_header[0] = '\\0';\t/* No header for this segment */\n\t\t\trecord = NULL;\t/* No data record to return */\n\t\t\t*n_fields = 0;\n\t\t\tbreak;\n\t\tcase GMT_IO_TABLE_HEADER:\t/* Table header(s) */\n\t\t\tstrncpy (GMT->current.io.curr_text, D->table[count[GMT_TBL]]->header[count[GMTAPI_HDR_POS]-1], GMT_BUFSIZ-1);\n\t\t\trecord = NULL;\t/* No data record to return */\n\t\t\t*n_fields = 0;\n\t\t\tbreak;\n\t\tcase GMT_IO_NEXT_FILE:\t/* End of a table but more tables to come */\n\t\t\trecord = NULL;\t/* No data record to return */\n\t\t\t*n_fields = GMT_IO_NEXT_FILE;\n\t\t\tbreak;\n\t\tcase GMT_IO_EOF:\t/* End of entire data set */\n\t\t\tS->status = (API->allow_reuse) ? GMT_IS_UNUSED : GMT_IS_USED;\t/* Mark as finished reading this guy unless we may reuse */\n\t\t\trecord = NULL;\t/* No more to return anyway */\n\t\t\t*n_fields = EOF;\n\t\t\tbreak;\n\t}\n\tGMT->current.io.status = status;\n\treturn record;\n}\n\n/*! . */\nGMT_LOCAL void gmtapi_get_record_init (struct GMTAPI_CTRL *API) {\n\t/* Initializes reading from current source. We must redo this after\n\t * selecting a new source since there is no guarantee that the sources\n\t * are all of the same kind. */\n\n\tunsigned int method;\n\tuint64_t col;\n\tstruct GMTAPI_DATA_OBJECT *S;\n\tstruct GMT_CTRL *GMT;\n\n\tif (!API->io_enabled[GMT_IN]) {\n\t\tAPI->error = GMT_ACCESS_NOT_ENABLED;\n\t\treturn;\n\t}\n\tAPI->error = GMT_NOERROR;\n\tAPI->is_file = false;\n\tS = API->current_get_obj;\t/* Shorthand for the current data source we are working on */\n\tGMT = API->GMT;\t\t\t/* Shorthand for GMT access */\n\t/* Reset to default association for current record's data and text pointers */\n\tGMT->current.io.record.text = GMT->current.io.curr_trailing_text;\n\tGMT->current.io.record.data = GMT->current.io.curr_rec;\n\n\tmethod = gmtapi_set_method (S);\t/* Get the actual method to use */\n\tGMT->current.io.status = 0;\t/* Initialize status to OK */\n\tS->status = GMT_IS_USING;\t\t\t\t/* Mark as being read */\n\tswitch (method) {\n\t\tcase GMT_IS_FILE:\t/* File, stream, and fd are all the same for us, regardless of data or text input */\n\t \tcase GMT_IS_STREAM:\n\t \tcase GMT_IS_FDESC:\n\t\t\tAPI->api_get_record = api_get_record_fp_first;\n\t\t\tGMT->current.io.first_rec = true;\n\t\t\tgmtlib_reset_input (GMT);\t/* Go back to being agnostic about number of columns, etc. */\n\t\t\tAPI->is_file = true;\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* Here we copy/read from a user memory location which is a matrix */\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\n\t\t\tAPI->current_get_M = gmtapi_get_matrix_data (S->resource);\n\t\t\tAPI->current_get_n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : S->n_columns;\n\t\t\tif ((API->current_get_M_index = gmtapi_get_2d_to_index (API, API->current_get_M->shape, GMT_GRID_IS_REAL)) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMTAPI: Internal error: gmtapi_get_record_init called gmtapi_get_2d_to_index with wring shape\\n\");\n\t\t\t}\n\t\t\tAPI->current_get_M_val = gmtapi_select_get_function (API, API->current_get_M->type);\n\t\t\tif (API->current_get_M->text == NULL) GMT->current.io.record.text = NULL;\n\t\t\tAPI->api_get_record = api_get_record_matrix;\n\t\t\tbreak;\n\n\t\t case GMT_IS_DUPLICATE|GMT_VIA_VECTOR:\t/* Here we copy from a user memory location that points to an array of column vectors */\n\t\t case GMT_IS_REFERENCE|GMT_VIA_VECTOR:\n\t\t\tAPI->current_get_n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : S->n_columns;\n\t\t\tAPI->current_get_V = gmtapi_get_vector_data (S->resource);\n\t\t\tAPI->current_get_V_val = gmt_M_memory (GMT, NULL, API->current_get_V->n_columns, GMT_getfunction);\t/* Array of functions */\n\t\t\tfor (col = 0; col < API->current_get_V->n_columns; col++)\t/* We know the number of columns from registration */\n\t\t\t\tAPI->current_get_V_val[col] = gmtapi_select_get_function (API, API->current_get_V->type[col]);\n\t\t\tAPI->api_get_record = api_get_record_vector;\n\t\t\tif (API->current_get_V->text == NULL) GMT->current.io.record.text = NULL;\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE:\t/* Only for datasets */\n\t\tcase GMT_IS_REFERENCE:\t/* Only for datasets */\n\t\t\tAPI->current_get_D_set = gmtapi_get_dataset_data (S->resource);\t/* Get the right dataset */\n\t\t\tAPI->current_get_n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : API->current_get_D_set->n_columns;\n\t\t\tAPI->api_get_record = gmtapi_get_record_dataset;\n\t\t\tif (!(API->current_get_D_set->type & GMT_READ_TEXT)) GMT->current.io.record.text = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMTAPI: Internal error: gmtapi_get_record_init called with illegal method\\n\");\n\t\t\tbreak;\n\t}\n}\n\nvoid * GMT_Get_Record (void *V_API, unsigned int mode, int *retval) {\n\t/* Retrieves the next data record from the virtual input source and\n\t * returns the number of columns found via *retval (unless retval == NULL).\n\t * If current record is a segment header then we return 0.\n\t * If we reach EOF then we return EOF.\n\t * mode is either GMT_READ_DATA (data columns), GMT_READ_TEXT (text string) or\n\t *\tGMT_READ_MIXED (expect data but tolerate read errors).\n\t * Also, if (mode | GMT_READ_FILEBREAK) is true then we will return empty-handed\n\t *\twhen we get to the end of a file except the final file (which is EOF).\n\t *\tThe calling module can then take actions appropriate between data files.\n\t * The double array OR text string is returned via the pointer *record.\n\t * If not a data record we return NULL, and pass status via API->GMT->current.io.status.\n\t */\n\n\tint n_fields;\n\tstruct GMTAPI_CTRL *API;\n\tstruct GMT_CTRL *GMT;\n\tvoid *record;\n\n\t/* Top level check of active session */\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\t/* Various initializations before reading */\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif (retval) *retval = 0;\n\tGMT = API->GMT;\t/* Shorthand for GMT access */\n\n\tdo {\t/* We do this until we can secure the next record or we run out of records (and return EOF) */\n\t\tAPI->get_next_record = false;\t/* We expect to read one data record and return */\n\t\tGMT->current.io.status = 0;\t/* Initialize status to OK */\n\t\trecord = API->api_get_record (API, mode, &n_fields);\n\t} while (API->get_next_record);\n\n\tif (!(n_fields == EOF || n_fields == GMT_IO_NEXT_FILE)) API->current_rec[GMT_IN]++;\t/* Increase record count, unless EOF */\n\n\tif (retval) *retval = n_fields;\t/* Requested we return the number of fields found */\n\treturn (record);\t\t/* Return pointer to current record */\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_Get_Record_ (unsigned int *mode, int *status) {\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Record (GMT_FORTRAN, *mode, status));\n}\n#endif\n\nGMT_LOCAL int gmtapi_put_record_fp (struct GMTAPI_CTRL *API, unsigned int mode, struct GMT_RECORD *record) {\n\t/* Function to use for rec-by-rec output to stream */\n\tint error = GMT_NOERROR;\n\tchar *s;\n\tstruct GMT_CTRL *GMT = API->GMT;\t\t/* Short hand */\n\tswitch (mode) {\n\t\tcase GMT_WRITE_TABLE_HEADER:\t/* Export a table header record; skip if binary */\n\t\t\ts = (record) ? (char*) (record) : GMT->current.io.curr_text;\t/* Default to last input record if NULL */\n\t\t\tgmtlib_write_tableheader (GMT, API->current_fp, s);\terror = 1;\t/* Write one item */\n\t\t\tbreak;\n\t\tcase GMT_WRITE_SEGMENT_HEADER:\t/* Export a segment header record; write NaNs if binary  */\n\t\t\tif (record) strncpy (GMT->current.io.segment_header, (char*) (record), GMT_BUFSIZ-1);\t/* Default to last segment record if NULL */\n\t\t\tgmt_write_segmentheader (GMT, API->current_fp, GMT->common.b.ncol[GMT_OUT]);\terror = 1;\t/* Write one item */\n\t\t\tbreak;\n\t\tcase GMT_WRITE_DATA:\t\t/* Export either a formatted ASCII data record or a binary record */\n\t\t\tif (GMT->common.b.ncol[GMT_OUT] == UINT_MAX) GMT->common.b.ncol[GMT_OUT] = GMT->common.b.ncol[GMT_IN];\n\t\t\terror = GMT->current.io.output (GMT, API->current_fp, GMT->common.b.ncol[GMT_OUT], record->data, record->text);\n\t\t\tbreak;\n\t\tcase GMT_WRITE_TABLE_START:\t/* Write title and command to start of file; skip if binary */\n\t\t\tgmtlib_write_newheaders (GMT, API->current_fp, API->current_put_n_columns);\terror = 1;\t/* Write one item */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMTAPI: Internal error: GMT_Put_Record called with illegal mode %u\\n\", mode);\n\t\t\treturn_error (API, GMT_NOT_A_VALID_IO_MODE);\n\t\t\tbreak;\n\t}\n\treturn ((error) ? GMT_NOTSET : 0);\n}\n\nGMT_LOCAL int gmtapi_put_record_dataset (struct GMTAPI_CTRL *API, unsigned int mode, struct GMT_RECORD *record) {\n\t/* Function to use for rec-by-rec output to a memory dataset */\n\tchar *s = NULL;\n\tdouble value;\n\tstruct GMT_DATATABLE *T = API->current_put_D_table;\t/* Short hand */\n\tstruct GMT_DATATABLE_HIDDEN *TH = gmt_get_DT_hidden (T);\n\tstruct GMT_CTRL *GMT = API->GMT;\t\t/* Short hand */\n\tint64_t *count = GMT->current.io.curr_pos[GMT_OUT];\t/* Short hand to counters for table (not used as == 0), segment, row */\n\tuint64_t col;\n\tswitch (mode) {\n\t\tcase GMT_WRITE_TABLE_HEADER:\t/* Export a table header record; skip if binary */\n\t\t\ts = (record) ? (char *)record : GMT->current.io.curr_text;\t/* Default to last input record if NULL */\n\t\t\t/* Hook into table header list */\n\t\t\tif (count[GMT_SEG] == -1 && strlen(s)) {\t/* Only allow headers for first segment in a table */\n\t\t\t\tT->header = gmt_M_memory (GMT, T->header, T->n_headers+1, char *);\n\t\t\t\tT->header[T->n_headers++] = strdup (s);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_WRITE_SEGMENT_HEADER:\t/* Export a segment header record; write NaNs if binary  */\n\t\t\tcount[GMT_SEG]++;\t/* Start of new segment */\n\t\t\tif (count[GMT_SEG]) {\t/* Must first copy over records for the previous segments; last (or only) segment will be done by GMT_End_IO */\n\t\t\t\tif (!T->segment[count[GMT_SEG]-1]) T->segment[count[GMT_SEG]-1] = gmt_get_segment (API->GMT);\n\t\t\t\tgmtlib_assign_segment (GMT, GMT_OUT, T->segment[count[GMT_SEG]-1], count[GMT_ROW], T->n_columns);\t/* Allocate and place arrays into previous segment */\n\t\t\t\tcount[GMT_ROW] = 0;\t/* Reset for next segment */\n\t\t\t\tT->n_segments++;\n\t\t\t}\n\t\t\tif (count[GMT_SEG] == (int64_t)TH->n_alloc) {\t/* Extend but set new members to NULL */\n\t\t\t\tsize_t was = TH->n_alloc;\n\t\t\t\tT->segment = gmt_M_malloc (GMT, T->segment, count[GMT_SEG], &TH->n_alloc, struct GMT_DATASEGMENT *);\n\t\t\t\tgmt_M_memset (&T->segment[was], TH->n_alloc - was, struct GMT_DATASEGMENT *);\n\t\t\t}\n\t\t\tif (!T->segment[count[GMT_SEG]]) T->segment[count[GMT_SEG]] = gmt_get_segment (GMT);\n\t\t\ts = (record) ? (char *)record : GMT->current.io.segment_header;\t/* Default to last segment header record if NULL */\n\t\t\tif (s && strlen(s)) {\t/* Found a segment header */\n\t\t\t\tif (T->segment[count[GMT_SEG]]->header) gmt_M_str_free (T->segment[count[GMT_SEG]]->header);\t/* Hm, better free the old guy before strdup'ing a new one */\n\t\t\t\tT->segment[count[GMT_SEG]]->header = strdup (s);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_WRITE_DATA:\t\t/* Export a segment row */\n\t\t\tif (gmt_skip_output (GMT, record->data, T->n_columns))\t/* Record was skipped via -s[a|r] */\n\t\t\t\tbreak;\n\t\t\tif (count[GMT_SEG] == -1) {\t/* Most likely a file with one segment but no segment header */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMTAPI: GMT_Put_Record (double) called before any segments declared\\n\");\n\t\t\t\tcount[GMT_SEG] = 0;\n\t\t\t}\n\t\t\tgmt_prep_tmp_arrays (GMT, GMT_OUT, count[GMT_ROW], T->n_columns);\t/* Init or reallocate tmp read vectors */\n\t\t\tfor (col = 0; col < T->n_columns; col++) {\n\t\t\t\tvalue = gmtapi_select_record_value (GMT, record->data, (unsigned int)col, (unsigned int)GMT->common.b.ncol[GMT_OUT]);\n\t\t\t\tif (GMT->current.io.col_type[GMT_OUT][col] & GMT_IS_LON) gmt_lon_range_adjust (GMT->current.io.geo.range, &value);\n\t\t\t\tGMT->hidden.mem_coord[col][count[GMT_ROW]] = value;\n\t\t\t}\n\t\t\tif (GMT->current.setting.io_lonlat_toggle[GMT_OUT] && T->n_columns >= 2) {\n\t\t\t\tgmt_M_double_swap (GMT->hidden.mem_coord[GMT_X][count[GMT_ROW]], GMT->hidden.mem_coord[GMT_Y][count[GMT_ROW]]);\t/* Got lat/lon instead of lon/lat */\n\t\t\t}\n\n\t\t\tif (record->text && record->text[0])\t/* Also write trailing text */\n\t\t\t\tGMT->hidden.mem_txt[count[GMT_ROW]] = strdup (record->text);\n\t\t\tcount[GMT_ROW]++;\t/* Increment rows in this segment */\n\t\t\tbreak;\n\t\tcase GMT_WRITE_TABLE_START:\t/* Write title and command to start of file; skip if binary */\n\t\t\tbreak;\t/* Ignore for this method */\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMTAPI: Internal error: GMT_Put_Record called with illegal mode %u\\n\", mode);\n\t\t\treturn_error (API, GMT_NOT_A_VALID_IO_MODE);\n\t\t\tbreak;\n\t}\n\treturn GMT_NOERROR;\n}\n\nGMT_LOCAL int gmtapi_put_record_matrix (struct GMTAPI_CTRL *API, unsigned int mode, struct GMT_RECORD *record) {\n\t/* Function to use for rec-by-rec output to a memory matrix */\n\tint error = GMT_NOERROR;\n\tstruct GMT_MATRIX *M = API->current_put_M;\n\tstruct GMT_CTRL *GMT = API->GMT;\t\t/* Short hand */\n\tuint64_t col, kol, ij;\n\tchar *s = NULL;\n\n\tswitch (mode) {\n\t\tcase GMT_WRITE_TABLE_HEADER:\t/* Export a table header record; skip if binary */\n\t\t\ts = (record) ? (char *)record : GMT->current.io.curr_text;\t/* Default to last input record if NULL */\n\t\t\t/* Hook into matrix header list */\n\t\t\tif (strlen(s)) {\t/* Only allow headers for first segment in a table */\n\t\t\t\tM->header = gmt_M_memory (GMT, M->header, M->n_headers+1, char *);\n\t\t\t\tM->header[M->n_headers++] = strdup (s);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_WRITE_SEGMENT_HEADER:\t/* Segment header */\n\t\t\tif (GMT->current.io.multi_segments[GMT_OUT]) {\t/* Flag in data as NaNs in current_record (d) */\n\t\t\t\tfor (col = 0; col < M->n_columns; col++) {\t/* Place the output items */\n\t\t\t\t\tij = API->current_put_M_index (API->current_put_obj->rec, col, M->dim);\n\t\t\t\t\tAPI->current_put_M_val (&(M->data), ij, GMT->session.d_NaN);\n\t\t\t\t}\n\t\t\t\tM->n_rows++;\t\t\t/* Since the NaN-record becomes an actual data record that encodes a segment break */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_WRITE_DATA:\t/* Data record */\n\t\t\tif (!record) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMTAPI: gmtapi_put_record_matrix got a NULL data pointer for method GMT_WRITE_DATA\\n\");\n\t\t\t\terror = GMT_NOTSET;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (gmt_skip_output (GMT, record->data, M->n_columns))\t/* Record was skipped via -s[a|r] */\n\t\t\t\t\terror = GMT_NOTSET;\n\t\t\t\telse {\n\t\t\t\t\tdouble value;\n\t\t\t\t\tbool toggle = (GMT->current.setting.io_lonlat_toggle[GMT_OUT] && M->n_columns >= 2);\n\n\t\t\t\t\tfor (col = 0; col < M->n_columns; col++) {\t/* Place the output items */\n\t\t\t\t\t\tif (col < 2 && toggle)\t/* Deal with -: since we are writing to matrix memory and not file */\n\t\t\t\t\t\t\tkol = 1 - col;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tkol = col;\n\t\t\t\t\t\tij = API->current_put_M_index (API->current_put_obj->rec, kol, M->dim);\n\t\t\t\t\t\tvalue = gmtapi_select_record_value (GMT, record->data, (unsigned int)col, (unsigned int)GMT->common.b.ncol[GMT_OUT]);\n\t\t\t\t\t\tAPI->current_put_M_val (&(M->data), ij, value);\n\t\t\t\t\t}\n\t\t\t\t\tif (record->text)\n\t\t\t\t\t\tM->text[API->current_put_obj->rec] = strdup (record->text);\n\t\t\t\t\tM->n_rows++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMTAPI: Internal error: gmtapi_put_record_matrix called with illegal mode %u\\n\", mode);\n\t\t\treturn_error (API, GMT_NOT_A_VALID_IO_MODE);\n\t\t\tbreak;\n\t}\n\tif (!error) {\t/* Only increment if we placed a record on the output */\n\t\tAPI->current_rec[GMT_OUT]++;\n\t\tAPI->current_put_obj->rec++;\n\t}\n\n\tif (API->current_put_obj->n_alloc && API->current_put_obj->rec == API->current_put_obj->n_alloc) {\t/* Must allocate more memory for vectors or matrices */\n\t\tAPI->current_put_obj->n_alloc <<= 1;\n\t\tif ((API->current_put_obj->method == GMT_IS_DUPLICATE || API->current_put_obj->method == GMT_IS_REFERENCE) && API->current_put_obj->actual_family == GMT_IS_MATRIX) {\n\t\t\tsize_t size = API->current_put_obj->n_alloc * M->n_columns;\t/* Only one layer in this context */\n\t\t\tif ((error = gmtlib_alloc_univector (API->GMT, &(M->data), M->type, size)) != GMT_NOERROR) return (error);\n\t\t\tif (M->text) M->text = gmt_M_memory (API->GMT, M->text, API->current_put_obj->n_alloc, char *);\n\t\t}\n\t}\n\treturn error;\n}\n\nGMT_LOCAL int gmtapi_put_record_vector (struct GMTAPI_CTRL *API, unsigned int mode, struct GMT_RECORD *record) {\n\t/* Function to use for rec-by-rec output to a memory vector */\n\tint error = GMT_NOERROR;\n\tstruct GMT_VECTOR *V = API->current_put_V;\n\tstruct GMT_CTRL *GMT = API->GMT;\t\t/* Short hand */\n\tuint64_t col, kol;\n\tchar *s = NULL;\n\n\tswitch (mode) {\n\t\tcase GMT_WRITE_TABLE_HEADER:\t/* Export a table header record; skip if binary */\n\t\t\ts = (record) ? (char *)record : GMT->current.io.curr_text;\t/* Default to last input record if NULL */\n\t\t\t/* Hook into vector header list */\n\t\t\tif (strlen(s)) {\t/* Only allow headers for first segment in a table */\n\t\t\t\tV->header = gmt_M_memory (GMT, V->header, V->n_headers+1, char *);\n\t\t\t\tV->header[V->n_headers++] = strdup (s);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_WRITE_SEGMENT_HEADER: /* Segment header */\n\t\t\tif (GMT->current.io.multi_segments[GMT_OUT]) {\t/* Segment header - flag in data as NaNs */\n\t\t\t\tfor (col = 0; col < V->n_columns; col++)\t/* Place the output items */\n\t\t\t\t\tAPI->current_put_V_val[col] (&(V->data[col]), API->current_put_obj->rec, GMT->session.d_NaN);\n\t\t\t\tV->n_rows++;\t\t/* Same */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_WRITE_DATA:\t/* Data record */\n\t\t\tif (!record) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Put_Record passed a NULL data pointer for method GMT_IS_DATASET|VECTOR\\n\");\n\t\t\t\terror = GMT_NOTSET;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble value;\n\t\t\t\tif (gmt_skip_output (GMT, record->data, V->n_columns))\t/* Record was skipped via -s[a|r] */\n\t\t\t\t\terror = GMT_NOTSET;\n\t\t\t\telse {\n\t\t\t\t\tbool toggle = (GMT->current.setting.io_lonlat_toggle[GMT_OUT] && V->n_columns >= 2);\n\t\t\t\t\tfor (col = 0; col < V->n_columns; col++) {\t/* Place the output items */\n\t\t\t\t\t\tif (col < 2 && toggle)\t/* Deal with -: since we are writing to matrix memory and not file */\n\t\t\t\t\t\t\tkol = 1 - col;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tkol = col;\n\t\t\t\t\t\tvalue = gmtapi_select_record_value (GMT, record->data, (unsigned int)col, (unsigned int)GMT->common.b.ncol[GMT_OUT]);\n\t\t\t\t\t\tAPI->current_put_V_val[kol] (&(V->data[kol]), API->current_put_obj->rec, value);\n\t\t\t\t\t}\n\t\t\t\t\tif (record->text)\n\t\t\t\t\t\tV->text[API->current_put_obj->rec] = strdup (record->text);\n\t\t\t\t\tV->n_rows++;\t/* Note that API->current_rec[GMT_OUT] and API->current_put_obj->rec are incremented separately at end of function */\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMTAPI: Internal error: gmtapi_put_record_vector called with illegal mode %u\\n\", mode);\n\t\t\treturn_error (API, GMT_NOT_A_VALID_IO_MODE);\n\t\t\tbreak;\n\t}\n\n\tif (!error) {\t/* Only increment if we placed a record on the output */\n\t\tAPI->current_rec[GMT_OUT]++;\n\t\tAPI->current_put_obj->rec++;\n\t}\n\n\tif (API->current_put_obj->n_alloc && API->current_put_obj->rec == API->current_put_obj->n_alloc) {\t/* Must allocate more memory for vectors or matrices */\n\t\tAPI->current_put_obj->n_alloc <<= 1;\n\t\tif ((error = gmtlib_alloc_vectors (GMT, V, API->current_put_obj->n_alloc)) != GMT_NOERROR) return (error);\n\t\tif (V->text) V->text = gmt_M_memory (API->GMT, V->text, API->current_put_obj->n_alloc, char *);\n\t}\n\treturn error;\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_put_record_init (struct GMTAPI_CTRL *API, unsigned int mode, struct GMT_RECORD *record) {\n\t/* Writes a single data record to destimation.\n\t * We use mode to signal the kind of record:\n\t *   GMT_WRITE_TABLE_HEADER: Write an ASCII table header\n\t *   GMT_WRITE_SEGMENT_HEADER: Write an ASCII or binary segment header\n\t *   GMT_WRITE_DATA:    Write an data record\n\t * For text: If record == NULL use internal current record or header.\n\t * Returns 0 if a record was written successfully (See what -s[r] can do).\n\t * If an error occurs we return GMT_NOTSET and set API->error.\n\t */\n\tint error = 0;\n\tunsigned int method;\n\tuint64_t col;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMT_MATRIX *M_obj  = NULL;\n\tstruct GMT_VECTOR *V_obj  = NULL;\n\tstruct GMT_DATASET *D_obj = NULL;\n\tstruct GMT_MATRIX_HIDDEN *MH = NULL;\n\tstruct GMT_CTRL *GMT;\n\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tGMT = API->GMT;\t\t/* Short hand */\n\tif (!API->io_enabled[GMT_OUT]) return_error (API, GMT_ACCESS_NOT_ENABLED);\n\tAPI->error = GMT_NOERROR;\n\n\tS_obj = API->object[API->current_item[GMT_OUT]];\t/* Shorthand for the data source we are working on */\n\tif (S_obj->status == GMT_IS_USED) return_error (API, GMT_WRITTEN_ONCE);\t/* Only allow writing of a data set once [unless we reset status] */\n\tmethod = gmtapi_set_method (S_obj);\t/* Get the actual method to use */\n\tAPI->current_put_obj = S_obj;\n\n\tswitch (method) {\t/* File, array, stream etc ? */\n\t\tcase GMT_IS_FILE:\n\t \tcase GMT_IS_STREAM:\n\t \tcase GMT_IS_FDESC:\n\t\t\tAPI->api_put_record = gmtapi_put_record_fp;\n\t\t\tAPI->current_fp = S_obj->fp;\n\t\t\tAPI->current_put_n_columns = S_obj->n_columns;\n\t\t\tif (API->GMT->common.o.end || API->GMT->common.o.text)\t/* Asked for unspecified last column on input (e.g., -i3,2,5:), supply the missing last column number */\n\t\t\t\tgmtlib_reparse_o_option (API->GMT, (API->GMT->common.o.text) ? 0 : S_obj->n_columns);\n\t\t\terror = gmtapi_put_record_fp (API, mode, record);\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE:\t/* Fill in a DATASET structure with one table only */\n\t\tcase GMT_IS_REFERENCE:\n\t\t\tD_obj = gmtapi_get_dataset_data (S_obj->resource);\n\t\t\tif (!D_obj) {\t/* First time allocation of the single output table */\n\t\t\t\tunsigned int smode;\n\t\t\t\tif (mode == GMT_WRITE_TABLE_HEADER) {\t/* Cannot do this yet since we don't know sizes. Delay */\n\t\t\t\t\tAPI->tmp_header = gmt_M_memory (GMT, API->tmp_header, API->n_tmp_headers+1, char *);\n\t\t\t\t\tif (record) strncpy (GMT->current.io.curr_text, (char*) (record), GMT_BUFSIZ-1);\t/* Default to last segment record if NULL */\n\t\t\t\t\tAPI->tmp_header[API->n_tmp_headers++] = strdup (GMT->current.io.curr_text);\n\t\t\t\t\tS_obj->h_delay = true;\n\t\t\t\t\tS_obj->status = GMT_IS_USING;\t/* Have started writing to this destination */\n\t\t\t\t\treturn GMT_NOERROR;\n\t\t\t\t}\n\t\t\t\telse if (mode == GMT_WRITE_SEGMENT_HEADER) {\t/* Cannot do this yet since we don't know sizes. Delay */\n\t\t\t\t\tif (API->tmp_segmentheader) gmt_M_str_free (API->tmp_segmentheader);\t/* Can happen if empty segment is written */\n\t\t\t\t\tif (record) strncpy (GMT->current.io.segment_header, (char*) (record), GMT_BUFSIZ-1);\t/* Default to last segment record if NULL */\n\t\t\t\t\tAPI->tmp_segmentheader = strdup (GMT->current.io.segment_header);\n\t\t\t\t\tS_obj->s_delay = true;\n\t\t\t\t\tS_obj->status = GMT_IS_USING;\t/* Have started writing to this destination */\n\t\t\t\t\treturn GMT_NOERROR;\n\t\t\t\t}\n\t\t\t\telse if (record->data == NULL && record->text == NULL) {\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Put_Record give NULL record? - Must skip\\n\");\n\t\t\t\t\treturn GMT_NOERROR;\n\t\t\t\t}\n\t\t\t\t/* Ensure record_type[GMT_OUT] is set correctly given we now have a data record to examine */\n\t\t\t\tif (record->text == NULL)\n\t\t\t\t\tGMT->current.io.record_type[GMT_OUT] = GMT_WRITE_DATA;\n\t\t\t\telse if (record->data == NULL)\n\t\t\t\t\tGMT->current.io.record_type[GMT_OUT] = GMT_WRITE_TEXT;\n\t\t\t\telse\n\t\t\t\t\tGMT->current.io.record_type[GMT_OUT] = GMT_WRITE_MIXED;\n\t\t\t\tsmode = (GMT->current.io.record_type[GMT_OUT] & GMT_WRITE_TEXT) ? GMT_WITH_STRINGS : GMT_NO_STRINGS;\n\t\t\t\tD_obj = gmtlib_create_dataset (GMT, 1, GMT_TINY_CHUNK, 0, 0, S_obj->geometry, smode, true);\t/* 1 table, alloc segments array; no cols or rows yet */\n\t\t\t\tS_obj->resource = D_obj;\t/* Save this pointer for next time we call GMT_Put_Record */\n\t\t\t\tGMT->current.io.curr_pos[GMT_OUT][GMT_SEG] = -1;\t/* Start at seg = -1 and increment at first segment header */\n\t\t\t\tcol = (GMT->common.o.select) ? GMT->common.o.n_cols : GMT->common.b.ncol[GMT_OUT];\t/* Number of columns needed to hold the data records */\n\t\t\t\tif ((GMT->current.io.record_type[GMT_OUT] & GMT_WRITE_DATA) && col == 0) {\t/* Still don't know # of columns */\n\t\t\t\t\tif (GMT->common.b.ncol[GMT_IN] < GMT_MAX_COLUMNS) {\t/* Hail Mary pass to input columns */\n\t\t\t\t\t\tcol = GMT->common.b.ncol[GMT_IN];\t/* Set output cols to equal input cols since not set */\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMTAPI: GMT_Put_Record does not know the number of output columns - set to equal input at %d\\n\", (int)GMT->common.b.ncol[GMT_IN]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Put_Record does not know the number of columns - must abort!\\n\");\n\t\t\t\t\t\treturn_error (API, GMT_N_COLS_NOT_SET);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (GMT->current.io.record_type[GMT_OUT] == GMT_WRITE_TEXT) col = 0;\t/* Just to be safe rather than fucked */\n\t\t\t\tD_obj->n_columns = D_obj->table[0]->n_columns = col;\t/* The final actual output column number */\n\t\t\t\tif (GMT->common.b.ncol[GMT_OUT] == 0) GMT->common.b.ncol[GMT_OUT] = col;\n\t\t\t}\n\t\t\tAPI->current_put_D_table = D_obj->table[0];\t/* GMT_Put_Record only writes one table with one or more segments */\n\t\t\tAPI->api_put_record = gmtapi_put_record_dataset;\n\t\t\terror = gmtapi_put_record_dataset (API, mode, record);\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE|GMT_VIA_MATRIX:\t/* Data matrix only */\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_MATRIX:\n\t\t\t/* At the first output record the output matrix has not been allocated.\n\t\t\t * So first we do that, then later we can increment its size when needed.\n\t\t\t * The realloc to final size takes place in GMT_End_IO. */\n\t\t\tif (mode == GMT_WRITE_TABLE_HEADER) {\t/* Cannot do this yet since we don't know sizes. Delay */\n\t\t\t\tAPI->tmp_header = gmt_M_memory (GMT, API->tmp_header, API->n_tmp_headers+1, char *);\n\t\t\t\tif (record) strncpy (GMT->current.io.curr_text, (char*) (record), GMT_BUFSIZ-1);\t/* Default to last segment record if NULL */\n\t\t\t\tAPI->tmp_header[API->n_tmp_headers++] = strdup (GMT->current.io.curr_text);\n\t\t\t\tS_obj->h_delay = true;\n\t\t\t\tS_obj->status = GMT_IS_USING;\t/* Have started writing to this destination */\n\t\t\t\treturn GMT_NOERROR;\n\t\t\t}\n\t\t\tif (S_obj->n_rows && S_obj->rec >= S_obj->n_rows)\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"GMTAPI: GMT_Put_Record exceeding limits on rows(?) - possible bug\\n\");\n\t\t\tif (S_obj->resource == NULL) {\t/* First time allocating space; S_obj->n_rows == S_obj->n_alloc == 0 */\n\t\t\t\tsize_t size;\n\t\t\t\tcol = (GMT->common.o.select) ? GMT->common.o.n_cols : GMT->common.b.ncol[GMT_OUT];\t/* Number of columns needed to hold the data records */\n\t\t\t\tif (col == 0 && mode == GMT_WRITE_SEGMENT_HEADER && GMT->current.io.multi_segments[GMT_OUT]) {\n\t\t\t\t\t/* Cannot place the NaN records since we don't know the number of columns yet */\n\t\t\t\t\tS_obj->delay++;\n\t\t\t\t\tS_obj->rec++;\t\t\t\t\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\t\tAPI->current_rec[GMT_OUT]++;\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = S_obj->n_alloc = GMT_CHUNK;\n\t\t\t\tM_obj = gmtlib_create_matrix (GMT, 1U, GMT_OUT, 0);\n\t\t\t\tM_obj->type = S_obj->type;\t/* Use selected data type for export */\n\t\t\t\tM_obj->dim = M_obj->n_columns = col;\t/* If COL_FORMAT the dim will change in end_io_matrix after transpose */\n\t\t\t\tsize *= M_obj->n_columns;\t/* Size in bytes of the initial matrix allocation */\n\t\t\t\tif ((error = gmtlib_alloc_univector (GMT, &(M_obj->data), M_obj->type, size)) != GMT_NOERROR) return (gmtlib_report_error (API, error));\n\t\t\t\tif (record->text) M_obj->text = gmt_M_memory (GMT, NULL, S_obj->n_alloc, char *);\n\t\t\t\tMH = gmt_get_M_hidden (M_obj);\n\t\t\t\tS_obj->alloc_mode = MH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t\t\t\tS_obj->resource = M_obj;\t/* Save so we can get it next time */\n\t\t\t\tM_obj->n_rows = S_obj->rec;\t/* So we start on the same output record due to the delayed NaNs */\n\t\t\t}\n\t\t\t/* Place current matrix parameters in API */\n\t\t\tAPI->current_put_M = M_obj;\n\t\t\tif ((API->current_put_M_index = gmtapi_get_2d_to_index (API, GMT_IS_ROW_FORMAT, GMT_GRID_IS_REAL)) == NULL)\t/* Since we cannot do col_format without knowing dimension - see end_io_matrix */\n\t\t\t\treturn GMT_WRONG_MATRIX_SHAPE;\n\t\t\tif ((API->current_put_M_val = gmtapi_select_put_function (API, M_obj->type)) == NULL)\n\t\t\t\treturn GMT_NOT_A_VALID_TYPE;\n\t\t\tAPI->api_put_record = gmtapi_put_record_matrix;\n\t\t\terror = gmtapi_put_record_matrix (API, mode, record);\n\t\t\tbreak;\n\n\t\tcase GMT_IS_DUPLICATE|GMT_VIA_VECTOR:\t/* List of column arrays */\n\t\tcase GMT_IS_REFERENCE|GMT_VIA_VECTOR:\n\t\t\tif (mode == GMT_WRITE_TABLE_HEADER) {\t/* Cannot do this yet since we don't know sizes. Delay. */\n\t\t\t\tAPI->tmp_header = gmt_M_memory (GMT, API->tmp_header, API->n_tmp_headers+1, char *);\n\t\t\t\tif (record) strncpy (GMT->current.io.curr_text, (char*) (record), GMT_BUFSIZ-1);\t/* Default to last segment record if NULL */\n\t\t\t\tAPI->tmp_header[API->n_tmp_headers++] = strdup (GMT->current.io.curr_text);\n\t\t\t\tS_obj->h_delay = true;\n\t\t\t\tS_obj->status = GMT_IS_USING;\t/* Have started writing to this destination */\n\t\t\t\treturn GMT_NOERROR;\n\t\t\t}\n\t\t\tif (S_obj->n_rows && S_obj->rec >= S_obj->n_rows)\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"GMTAPI: GMT_Put_Record exceeding limits on rows(?) - possible bug\\n\");\n\t\t\tif ((V_obj = S_obj->resource) == NULL) {\t/* First time allocating space; S_obj->n_rows == S_obj->n_alloc == 0 */\n\t\t\t\tcol = (GMT->common.o.select) ? GMT->common.o.n_cols : GMT->common.b.ncol[GMT_OUT];\t/* Number of columns needed to hold the data records */\n\t\t\t\tif (col == 0 && mode == GMT_WRITE_SEGMENT_HEADER && GMT->current.io.multi_segments[GMT_OUT]) {\n\t\t\t\t\t/* Cannot place the NaN records since we don't know the number of columns yet */\n\t\t\t\t\tS_obj->delay++;\n\t\t\t\t\tS_obj->rec++;\t\t\t\t\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\t\tAPI->current_rec[GMT_OUT]++;\t/* Since the NaN-record is an actual data record that encodes a segment break */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tS_obj->n_alloc = GMT_CHUNK;\t/* Size in bytes of the initial matrix allocation */\n\t\t\t\tif ((V_obj = gmt_create_vector (GMT, col, GMT_OUT)) == NULL)\n\t\t\t\t\treturn_error (API, GMT_MEMORY_ERROR);\n\t\t\t\tfor (col = 0; col < V_obj->n_columns; col++)\t/* Set same export data type for all vectors */\n\t\t\t\t\tV_obj->type[col] = GMT->current.setting.export_type;\n\t\t\t\tif ((error = gmtlib_alloc_vectors (GMT, V_obj, S_obj->n_alloc)) != GMT_NOERROR) {\n\t\t\t\t\t/* Have to free V_obj here */\n\t\t\t\t\treturn (gmtlib_report_error (API, error));\n\t\t\t\t}\n\t\t\t\tif (record->text) V_obj->text = gmt_M_memory (GMT, NULL, S_obj->n_alloc, char *);\n\t\t\t\tS_obj->resource = V_obj;\t/* Save so we can get it next time */\n\t\t\t}\n\t\t\t/* Place current vector parameters in API */\n\t\t\tAPI->current_put_V = V_obj;\n\t\t\tAPI->current_put_V_val = gmt_M_memory (GMT, NULL, V_obj->n_columns, GMT_putfunction);\t/* Array of functions */\n\t\t\tfor (col = 0; col < V_obj->n_columns; col++) {\t/* Assign the functions */\n\t\t\t\tif ((API->current_put_V_val[col] = gmtapi_select_put_function (API, V_obj->type[col])) == NULL)\n\t\t\t\t\treturn GMT_NOT_A_VALID_TYPE;\n\t\t\t}\n\t\t\tAPI->api_put_record = gmtapi_put_record_vector;\n\t\t\terror = gmtapi_put_record_vector (API, mode, record);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Put_Record called with illegal method\\n\");\n\t\t\treturn_error (API, GMT_NOT_A_VALID_METHOD);\n\t\t\tbreak;\n\t}\n\n\tS_obj->status = GMT_IS_USING;\t/* Have started writing to this destination */\n\n\treturn ((error) ? GMT_NOTSET : 0);\n}\n\n/*! . */\nint GMT_Put_Record (void *V_API, unsigned int mode, void *record) {\n\t/* Writes a single data record to destimation.\n\t * We use mode to signal the kind of record:\n\t *   GMT_WRITE_TABLE_HEADER:   Write an ASCII table header\n\t *   GMT_WRITE_SEGMENT_HEADER: Write an ASCII or binary segment header\n\t *   GMT_WRITE_DATA:           Write an data record\n\t * For text: If record == NULL we use internal current record or header.\n\t * Returns GMT_NOERROR if a record was written successfully (See what -s[r] can do).\n\t * If an error occurs we return GMT_NOTSET and set API->error.\n\t *\n\t * GMT_Put_Record calls api_put_record is a pointer to various container-specific\n\t * output functions.  It is initialized to gmtapi_put_record_init by GMT_Begin_IO.\n\t * gmtapi_put_record_init initializes the machinery and assigns api_put_record. */\n\n\tstruct GMTAPI_CTRL *API = gmtapi_get_api_ptr (V_API);\n\treturn (API->api_put_record (API, mode, record));\n}\n\n#ifdef FORTRAN_API\nint GMT_Put_Record_ (unsigned int *mode, void *record) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Put_Record (GMT_FORTRAN, *mode, record));\n}\n#endif\n\n /*! . */\nint GMT_Begin_IO (void *V_API, unsigned int family, unsigned int direction, unsigned int mode) {\n\t/* Initializes the rec-by-rec i/o mechanism for either input or output (given by direction).\n\t * GMT_Begin_IO must be called before any data i/o is allowed.\n\t * family:\tThe family of data must be GMT_IS_DATASET.\n\t * direction:\tEither GMT_IN or GMT_OUT.\n\t * mode:\tCurrently unused\n\t * Returns:\tfalse if successful, true if error.\n\t */\n\tint error, item;\n\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (V_API, GMT_NOT_A_VALID_DIRECTION);\n\tif (!multiple_files_ok (family)) return_error (V_API, GMT_NOT_A_VALID_IO_ACCESS);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\t/* Reset in case it has some previous error */\n\tif (!API->registered[direction]) GMT_Report (API, GMT_MSG_DEBUG, \"GMT_Begin_IO: No %s resources registered\\n\", GMT_direction[direction]);\n\tif (mode) GMT_Report (API, GMT_MSG_DEBUG, \"GMT_Begin_IO: Mode value %u not considered (ignored)\\n\", mode);\n\n\tGMT = API->GMT;\n\t/* Must initialize record-by-record machinery for dataset */\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Begin_IO: Initialize record-by-record access for %s\\n\", GMT_direction[direction]);\n\tAPI->current_item[direction] = -1;\t/* gmtapi_next_data_object (below) will wind it to the first item >= 0 */\n\tif ((error = gmtapi_next_data_object (API, family, direction))) return_error (API, GMT_NO_RESOURCES);\t/* Something went bad */\n\titem = API->current_item[direction];\t/* Next item */\n\tS_obj = API->object[item];\t/* Short-hand for next object */\n\tAPI->io_mode[direction] = GMTAPI_BY_REC;\n\tAPI->io_enabled[direction] = true;\t/* OK to access resources */\n\tGMT->current.io.need_previous = (GMT->common.g.active || GMT->current.io.skip_duplicates);\n\tGMT->current.io.ogr = GMT_OGR_UNKNOWN;\n\tGMT->current.io.segment_header[0] = GMT->current.io.curr_text[0] = 0;\n\tGMT->current.io.first_rec = true;\n\tif (direction == GMT_OUT) {\t/* Special checks for output */\n\t\tif (S_obj->messenger && S_obj->resource) {\t/* Need to destroy the dummy container before passing data out */\n\t\t\tif ((error = gmtapi_destroy_data_ptr (API, S_obj->actual_family, S_obj->resource)))\t/* Do the dirty deed */\n\t\t\t\treturn_error (API,error);\n\t\t\tS_obj->resource  = NULL;\t/* Since we now have nothing */\n\t\t\tS_obj->messenger = false;\t/* OK, now clean for output */\n\t\t}\n\t\tAPI->current_put_obj = S_obj;\n\t\tAPI->api_put_record = gmtapi_put_record_init;\n\t\tAPI->GMT->current.io.record_type[GMT_OUT] = API->GMT->current.io.record_type[GMT_IN];\t/* Can be overruled by GMT_Set_Columns */\n\t\t//if (header == GMT_HEADER_ON && !GMT->common.b.active[GMT_OUT]) GMT_Put_Record (API, GMT_WRITE_TABLE_START, NULL);\t/* Write standard ASCII header block */\n\t\tif (!GMT->common.o.active) GMT->current.io.trailing_text[GMT_OUT] = true;\t/* Default reads and writes any trailing text */\n\t}\n\telse {\t/* Special checks for input */\n\t\tAPI->current_get_obj = S_obj;\n\t\tif (!GMT->common.i.active) GMT->current.io.trailing_text[GMT_IN] = true;\t/* Default reads and writes any trailing text */\n\t\tgmtapi_get_record_init (API);\n\t}\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Begin_IO: %s resource access is now enabled [record-by-record]\\n\", GMT_direction[direction]);\n\n\treturn_error (V_API, GMT_NOERROR);\t/* No error encountered */\n}\n\n#ifdef FORTRAN_API\nint GMT_Begin_IO_ (unsigned int *family, unsigned int *direction, unsigned int *mode) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Begin_IO (GMT_FORTRAN, *family, *direction, *mode));\n}\n#endif\n\n/*! . */\nint GMT_Get_Row (void *V_API, int row_no, struct GMT_GRID *G, gmt_grdfloat *row) {\n\t/* Reads the entire row vector from the grdfile.\n\t * If row_no is NEGATIVE it is interpreted to mean that we just want to\n\t * fseek to the start of the abs(row_no) record and no reading takes place.\n\t * If R->auto_advance is false we must set R->start explicitly to row_no.\n\t * If R->auto_advance is true it reads the current row and advances R->row++.\n\t * In this case row_no is not actually used.\n\t */\n\tunsigned int err;\n \tunsigned int col;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar *fmt = NULL;\n\tstruct GMT_GRID_HIDDEN *GH = NULL;\n\tstruct GMT_GRID_ROWBYROW *R = NULL;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tGMT = API->GMT;\n\tGH = gmt_get_G_hidden (G);\n\tR = gmtapi_get_rbr_ptr (GH->extra);\n\tHH = gmt_get_H_hidden (G->header);\n\tfmt = GMT->session.grdformat[G->header->type];\n\tif (fmt[0] == 'c') {\t\t/* Get one NetCDF row, old format */\n\t\tif (row_no < 0) {\t/* Special seek instruction, then return */\n\t\t\tR->row = abs (row_no);\n\t\t\tR->start[0] = R->row * R->edge[0];\n\t\t\treturn (GMT_NOERROR);\n\t\t}\n\t\telse if (!R->auto_advance) {\t/* Go to specified row and read it */\n\t\t\tR->row = row_no;\n\t\t\tR->start[0] = R->row * R->edge[0];\n\t\t}\n\t\tgmt_M_err_trap (gmt_nc_get_vara_grdfloat (R->fid, HH->z_id, R->start, R->edge, row));\n\t\tif (R->auto_advance) R->start[0] += R->edge[0];\t/* Advance to next row if auto */\n\t}\n\telse if (fmt[0] == 'n') {\t/* Get one NetCDF row, COARDS-compliant format */\n\t\tif (row_no < 0) {\t/* Special seek instruction */\n\t\t\tR->row = abs (row_no);\n\t\t\tR->start[0] = HH->row_order == k_nc_start_north ? R->row : G->header->n_rows - 1 - R->row;\n\t\t\treturn (GMT_NOERROR);\n\t\t}\n\t\telse if (!R->auto_advance) {\n\t\t\tR->row = row_no;\n\t\t\tR->start[0] = HH->row_order == k_nc_start_north ? R->row : G->header->n_rows - 1 - R->row;\n\t\t}\n\t\tgmt_M_err_trap (gmt_nc_get_vara_grdfloat (R->fid, HH->z_id, R->start, R->edge, row));\n\t\tif (R->auto_advance) R->start[0] -= HH->row_order;\t/* Advance to next row if auto */\n\t}\n\telse {\t\t\t/* Get a native binary row */\n\t\tsize_t n_items;\n\t\tif (row_no < 0) {\t/* Special seek instruction */\n\t\t\tR->row = abs (row_no);\n\t\t\tif (fseek (R->fp, (off_t)(GMT_GRID_HEADER_SIZE + R->row * R->n_byte), SEEK_SET)) return (GMT_GRDIO_SEEK_FAILED);\n\t\t\treturn (GMT_NOERROR);\n\t\t}\n\t\tR->row = row_no;\n\t\tif (!R->auto_advance && fseek (R->fp, (off_t)(GMT_GRID_HEADER_SIZE + R->row * R->n_byte), SEEK_SET)) return (GMT_GRDIO_SEEK_FAILED);\n\n\t\tn_items = G->header->n_columns;\n\t\tif (fmt[1] == GMT_GRD_FORMAT) {\t/* Binary gmt_grdfloat, no need to mess with decoding */\n\t\t\tif (gmt_M_fread (row, R->size, n_items, R->fp) != n_items) return (GMT_GRDIO_READ_FAILED);\t/* Get one row */\n\t\t}\n\t\telse {\n\t\t\tif (gmt_M_fread (R->v_row, R->size, n_items, R->fp) != n_items) return (GMT_GRDIO_READ_FAILED);\t/* Get one row */\n\t\t\tfor (col = 0; col < G->header->n_columns; col++)\n\t\t\t\trow[col] = gmtlib_decode (GMT, R->v_row, col, fmt[1]);\t/* Convert whatever to gmt_grdfloat */\n\t\t}\n#ifdef DEBUG\n\t\tR->pos = ftell (R->fp);\t/* Update where we are */\n#endif\n\t}\n\tif (R->check) {\t/* Replace NaN-marker with actual NaN */\n\t\tfor (col = 0; col < G->header->n_columns; col++)\n\t\t\tif (row[col] == G->header->nan_value)\n\t\t\t\trow[col] = GMT->session.f_NaN;\n\t}\n\tgmt_scale_and_offset_f (GMT, row, G->header->n_columns, G->header->z_scale_factor, G->header->z_add_offset);\n\tif (R->auto_advance) R->row++;\n\treturn (GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Row_ (int *rec_no, struct GMT_GRID *G, gmt_grdfloat *row) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Row (GMT_FORTRAN, *rec_no, G, row));\n}\n#endif\n\n/*! . */\nint GMT_Put_Row (void *V_API, int rec_no, struct GMT_GRID *G, gmt_grdfloat *row) {\n\t/* Writes the entire row vector to the grdfile.\n\t * If row_no is NEGATIVE it is interpreted to mean that we just want to\n\t * fseek to the start of the abs(row_no) record and no reading takes place.\n\t * If R->auto_advance is false we must set R->start explicitly to row_no.\n\t * If R->auto_advance is true it writes at the current row and advances R->row++.\n\t * In this case row_no is not actually used.\n\t */\n\n\tunsigned int err;\t/* Required by gmt_M_err_trap */\n\tunsigned int col;\n\tsize_t n_items;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar *fmt = NULL;\n\tstruct GMT_GRID_ROWBYROW *R = NULL;\n\tstruct GMT_GRID_HIDDEN *GH = NULL;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tGMT = API->GMT;\n\tGH = gmt_get_G_hidden (G);\n\tR = gmtapi_get_rbr_ptr (GH->extra);\n\tHH = gmt_get_H_hidden (G->header);\n\tgmt_scale_and_offset_f (GMT, row, G->header->n_columns, G->header->z_scale_factor, G->header->z_add_offset);\n\tif (R->check) {\t/* Replace NaNs with special value */\n\t\tfor (col = 0; col < G->header->n_columns; col++)\n\t\t\tif (gmt_M_is_fnan (row[col]))\n\t\t\t\trow[col] = G->header->nan_value;\n\t}\n\n\tfmt = GMT->session.grdformat[G->header->type];\n\tswitch (fmt[0]) {\n\t\tcase 'c':\n\t\t\tif (!R->auto_advance) R->start[0] = rec_no * R->edge[0];\n\t\t\tgmt_M_err_trap (gmt_nc_put_vara_grdfloat (R->fid, HH->z_id, R->start, R->edge, row));\n\t\t\tif (R->auto_advance) R->start[0] += R->edge[0];\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tif (!R->auto_advance) {\n\t\t\t\tHH->row_order = k_nc_start_north ? rec_no : (int)G->header->n_rows - 1 - rec_no;\n\t\t\t\tR->start[0] = (size_t)HH->row_order;\n\t\t\t}\n\t\t\tgmt_M_err_trap (gmt_nc_put_vara_grdfloat (R->fid, HH->z_id, R->start, R->edge, row));\n\t\t\tif (R->auto_advance) R->start[0] -= HH->row_order;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!R->auto_advance && fseek (R->fp, (off_t)(GMT_GRID_HEADER_SIZE + rec_no * R->n_byte), SEEK_SET)) return (GMT_GRDIO_SEEK_FAILED);\n\t\t\tn_items = G->header->n_columns;\n\t\t\tif (fmt[1] == GMT_GRD_FORMAT) {\t/* Regular grdfloats */\n\t\t\t\tif (gmt_M_fwrite (row, R->size, n_items, R->fp) < n_items) return (GMT_GRDIO_WRITE_FAILED);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (col = 0; col < G->header->n_columns; col++) gmtlib_encode (GMT, R->v_row, col, row[col], fmt[1]);\n\t\t\t\tif (gmt_M_fwrite (R->v_row, R->size, n_items, R->fp) < n_items) return (GMT_GRDIO_WRITE_FAILED);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tif (R->auto_advance) R->row++;\n\n\treturn (GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Put_Row_ (int *rec_no, struct GMT_GRID *G, gmt_grdfloat *row) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Put_Row (GMT_FORTRAN, *rec_no, G, row));\n}\n#endif\n\nGMT_LOCAL char * gmtapi_ptrvoid (char ** p) { \t/* Handle as char ** just to determine if address is of a NULL pointer */\n\treturn *p;\n}\n\n/*! . */\nint GMT_Destroy_Data (void *V_API, void *object) {\n\t/* Destroy a resource that is no longer needed.\n\t * Returns the error code.  If passed an object allocated at a higher level then\n\t * we quietly return no error.\n\t */\n\tint error, item, object_ID = GMT_NOTSET;\n\tenum GMT_enum_family family;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\t/* This is a cardinal sin */\n\tif (object == NULL) return (false);\t/* Null address, quietly skip */\n\tif (!gmtapi_ptrvoid(object)) return (false);\t/* Null pointer, quietly skip */\n\tAPI = gmtapi_get_api_ptr (V_API);\t\t/* Now we need to get that API pointer to check further */\n\tif ((object_ID = gmtapi_get_object_id_from_data_ptr (API, object)) == GMT_NOTSET) return_error (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find the object in the list */\n\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET) return_error (API, API->error);\t/* Could not find that item */\n\tfamily = API->object[item]->actual_family;\n\n\tswitch (family) {\t/* Standard 6 families, plus matrix/vector and coordinates */\n\t\tcase GMT_IS_GRID:\t/* GMT grid */\n\t\t\terror = gmtapi_destroy_grid (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\n\t\t\terror = gmtapi_destroy_dataset (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\n\t\t\terror = gmtapi_destroy_palette (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\terror = gmtapi_destroy_image (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\n\t\t\terror = gmtapi_destroy_postscript (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_CUBE:\n\t\t\terror = gmtapi_destroy_cube (API, object);\n\t\t\tbreak;\n\n\t\t/* Also allow destroying of intermediate vector and matrix containers */\n\t\tcase GMT_IS_MATRIX:\n\t\t\terror = gmtapi_destroy_matrix (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\n\t\t\terror = gmtapi_destroy_vector (API, object);\n\t\t\tbreak;\n\t\tcase GMT_IS_COORD:\n\t\t\terror = gmtapi_destroy_coord (API, object);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn_error (API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t}\n\tif (error == GMT_NOERROR) {\t/* We successfully freed the items, now remove from IO list */\n\t\tunsigned int j;\n\t\tvoid *address = API->object[item]->resource;\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Destroy_Data: freed memory for a %s for object %d\\n\", GMT_family[family], object_ID);\n\t\tif ((error = gmtlib_unregister_io (API, object_ID, (unsigned int)GMT_NOTSET))) return_error (API, error);\t/* Did not find object */\n\t\tfor (j = 0; j < API->n_objects; j++) {\n\t\t\tif (API->object[j]->resource == address) API->object[j]->resource = NULL;\t/* Set matching resources to NULL so we don't try to read from there again either */\n\t\t}\n#ifdef DEBUG\n\t\tgmtapi_list_objects (API, \"GMT_Destroy_Data\");\n#endif\n\n\t}\n\telse if (error != GMT_FREE_WRONG_LEVEL) {\n\t\t/* Quietly ignore these errors: GMT_PTR_IS_NULL, GMT_FREE_EXTERNAL_NOT_ALLOWED as they are not considered errors here. */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Destroy_Data: Ignored warning %d for object %d\\n\", error, object_ID);\n\t}\n\telse\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Destroy_Data: Skipped due to wrong level for object %d\\n\", object_ID);\n\treturn_error (API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Destroy_Data_ (void *object) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Destroy_Data (GMT_FORTRAN, object));\n}\n#endif\n\nGMT_LOCAL int gmtapi_destroy_grids (struct GMTAPI_CTRL *API, struct GMT_GRID ***obj, unsigned int n_items) {\n\t/* Used to destroy a group of grids read via GMT_Read_Group */\n\tunsigned int k;\n\tint error;\n\tstruct GMT_GRID **G = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &G[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, G);\t*obj = NULL;\n\treturn_error (API, GMT_NOERROR);\n}\n\nGMT_LOCAL int gmtapi_destroy_datasets (struct GMTAPI_CTRL *API, struct GMT_DATASET ***obj, unsigned int n_items) {\n\t/* Used to destroy a group of datasets read via GMT_Read_Group */\n\tunsigned int k;\n\tint error;\n\tstruct GMT_DATASET **D = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &D[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, D);\t*obj = NULL;\n\treturn_error (API, GMT_NOERROR);\n}\n\nGMT_LOCAL int gmtapi_destroy_images (struct GMTAPI_CTRL *API, struct GMT_IMAGE ***obj, unsigned int n_items) {\n\t/* Used to destroy a group of images read via GMT_Read_Group */\n\tunsigned int k;\n\tint error;\n\tstruct GMT_IMAGE **I = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &I[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, I);\t*obj = NULL;\n\treturn_error (API, GMT_NOERROR);\n}\n\nGMT_LOCAL int gmtapi_destroy_palettes (struct GMTAPI_CTRL *API, struct GMT_PALETTE ***obj, unsigned int n_items) {\n\tunsigned int k;\n\tint error;\n\tstruct GMT_PALETTE **C = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &C[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, C);\t*obj = NULL;\n\treturn_error (API, GMT_NOERROR);\n}\n\nGMT_LOCAL int gmtapi_destroy_postscripts (struct GMTAPI_CTRL *API, struct GMT_POSTSCRIPT ***obj, unsigned int n_items) {\n\t/* Used to destroy a group of palettes read via GMT_Read_Group */\n\tunsigned int k;\n\tint error;\n\tstruct GMT_POSTSCRIPT **P = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &P[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, P);\t*obj = NULL;\n\treturn_error (API, GMT_NOERROR);\n}\n\nGMT_LOCAL int gmtapi_destroy_cubes (struct GMTAPI_CTRL *API, struct GMT_CUBE ***obj, unsigned int n_items) {\n\t/* Used to destroy a group of grids read via GMT_Read_Group */\n\tunsigned int k;\n\tint error;\n\tstruct GMT_CUBE **U = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &U[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, U);\t*obj = NULL;\n\treturn_error (API, GMT_NOERROR);\n}\n\nGMT_LOCAL int gmtapi_destroy_matrices (struct GMTAPI_CTRL *API, struct GMT_MATRIX ***obj, unsigned int n_items) {\n\t/* Used to destroy a group of matrices read via GMT_Read_Group */\n\tunsigned int k;\n\tint error;\n\tstruct GMT_MATRIX **M = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &M[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, M);\t*obj = NULL;\n\treturn_error (API, GMT_NOERROR);\n}\n\nGMT_LOCAL int gmtapi_destroy_vectors (struct GMTAPI_CTRL *API, struct GMT_VECTOR ***obj, unsigned int n_items) {\n\t/* Used to destroy a group of vectors read via GMT_Read_Group */\n\tunsigned int k;\n\tint error;\n\tstruct GMT_VECTOR **V = *obj;\n\tfor (k = 0; k < n_items; k++) if ((error = GMT_Destroy_Data (API, &V[k]))) return_error (API, error);\n\tgmt_M_free (API->GMT, V);\t*obj = NULL;\n\treturn_error (API, GMT_NOERROR);\n}\n\nGMT_LOCAL void ** gmtapi_void3_to_void2 (void ***p) { return (*p); }\t/* To avoid warnings and troubles */\n\n/*! . */\nint GMT_Destroy_Group (void *V_API, void *object, unsigned int n_items) {\n\t/* Destroy an array of resources that are no longer needed.\n\t * Returns the error code.\n\t */\n\tint error, object_ID, item;\n\tvoid **ptr = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\t/* This is a cardinal sin */\n\tif (object == NULL) return (false);\t/* Null address, quietly skip */\n\tAPI = gmtapi_get_api_ptr (V_API);\t\t/* Now we need to get that API pointer to check further */\n\tptr = gmtapi_void3_to_void2 (object);\t\t/* Get the array of pointers */\n\tif ((object_ID = gmtapi_get_object_id_from_data_ptr (API, ptr)) == GMT_NOTSET) return_error (API, GMT_OBJECT_NOT_FOUND);\t/* Could not find the object in the list */\n\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, GMT_NOTSET, GMT_NOTSET)) == GMT_NOTSET) return_error (API, API->error);\t/* Could not find that item */\n\tswitch (API->object[item]->actual_family) {\n\t\tcase GMT_IS_GRID:       error = gmtapi_destroy_grids       (API, object, n_items); break;\n\t\tcase GMT_IS_DATASET:    error = gmtapi_destroy_datasets    (API, object, n_items); break;\n\t\tcase GMT_IS_IMAGE:      error = gmtapi_destroy_images      (API, object, n_items); break;\n\t\tcase GMT_IS_PALETTE:    error = gmtapi_destroy_palettes    (API, object, n_items); break;\n\t\tcase GMT_IS_CUBE:   error = gmtapi_destroy_cubes   (API, object, n_items); break;\n\t\tcase GMT_IS_POSTSCRIPT: error = gmtapi_destroy_postscripts (API, object, n_items); break;\n\t\tcase GMT_IS_MATRIX:     error = gmtapi_destroy_matrices    (API, object, n_items); break;\n\t\tcase GMT_IS_VECTOR:     error = gmtapi_destroy_vectors     (API, object, n_items); break;\n\t\tdefault: return_error (API, GMT_NOT_A_VALID_FAMILY); break;\n\t}\n\treturn_error (API, error);\n}\n\n#ifdef FORTRAN_API\nint GMT_Destroy_Group_ (void *object, unsigned int *n_items) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Destroy_Group (GMT_FORTRAN, object, *n_items));\n}\n#endif\n\n/*! . */\nvoid * GMT_Create_Data (void *V_API, unsigned int family, unsigned int geometry, unsigned int mode, uint64_t dim[], double *range, double *inc, unsigned int registration, int pad, void *data) {\n\t/* Create an empty container of the requested kind and allocate space for content.\n\t * The known families are GMT_IS_{DATASET,GRID,PALETTE,IMAGE,POSTSCRIPT}, but we\n\t * also allow for creation of the containers for GMT_IS_{VECTOR,MATRIX}. Note\n\t * that for VECTOR|MATRIX we don't allocate space to hold data as it is the users\n\t * responsibility to hook their data pointers in.  The VECTOR allocates the array\n\t * of column vector type and data pointers.\n\t * Geometry should reflect the resource, e.g. GMT_IS_SURFACE for grid, etc.\n\t * There are two ways to define the dimensions needed to actually allocate memory:\n\t * (A) Via uint64_t dim[]:\n\t *     The dim array contains up to 4 dimensions for:\n\t *\t   0: dim[GMT_TBL] = number of tables,\n\t *\t   1: dim[GMT_SEG] = number of segments per table\n\t *\t   2: dim[GMT_ROW] = number of rows per segment.\n\t *\t   3: dim[GMT_COL] = number of columns per row.\n\t *     The dim array is ignored for CPTs.\n\t *     For GMT_IS_IMAGE & GMT_IS_MATRIX, par[GMT_Z] = GMT[2] holds the number of bands or layers (dim == NULL means just 1).\n\t *     For GMT_IS_GRID, GMT_IS_IMAGE, & GMT_IS_MATRIX: dim[0] holds the number of columns and dim[1] holds the number\n\t *         of rows; this implies that wesn = 0-<dim-1>, inc = 1, and registration is pixel-registration.\n\t *     For GMT_IS_VECTOR, dim[0] holds the number of columns, optionally dim[1] holds number of rows, if known, or 0.\n\t *\t   dim[2] can hold the data type (GMT_DOUBLE, etc). If dim[1] > 0 then we allocate the rows.\n\t * (B) Via range, inc, registration:\n\t *     Convert user domain range, increments, and registration into dimensions\n\t *     for the container.  For grids and images we fill out the GMT_GRID_HEADER;\n\t *     for vectors and matrices we fill out their internal parameters.\n\t *     For complex grids pass registration + GMT_GRID_IS_COMPLEX_{REAL|IMAG}\n\t *     For GMT_IS_MATRIX and GMT_IS_IMAGE, dim[GMT_Z] = holds the number of layers or bands (dim == NULL means just 1),\n\t *     and dim[3] holds the data type (dim == NULL means GMT_DOUBLE).\n\t *     For GMT_IS_VECTOR, dim[GMT_Z] holds the data type (dim == NULL means GMT_DOUBLE).\n\t * pad sets the padding for grids and images, while for matrices it can be\n\t *     0 for the default row/col orientation\n\t *     1 for row-major format (C)\n\t *     2 for column major format (Fortran)\n\t   pad is ignored for other resources.\n\t * Some default actions for grids:\n\t * range = NULL: Select current -R setting if present.\n\t * registration = GMT_NOTSET: Gridline unless -r is in effect.\n\t * Give -1 (GMT_NOTSET) to accept GMT default padding [2].\n\t *\n\t * For creating grids and images you can do it in one or two steps:\n \t * (A) Pass mode = GMT_CONTAINER_AND_DATA; this creates both header and allocates grid|image;\n\t * (B) Call GMT_Create_Data twice:\n\t * \t1. First with mode = GMT_CONTAINER_ONLY which creates header only\n\t *\t   and computes the dimensions based on the other arguments.\n\t *\t2. 2nd with mode = GMT_DATA_ONLY, which allocates the grid|image array\n\t *\t   based on the dimensions already set.  This time you pass NULL/0\n\t *\t   for dim, wesn, inc, registration, pad but let data be your grid|image\n\t *\t   returned to you after step 1.\n\t *\n\t * By default, the created resource is consider an input resource (direction == GMT_IN).\n\t * However, for the interface containers GMT_VECTOR and GMT_MATRIX they will have their\n\t * direction set to GMT_OUT if the row-dimension is not set.\n\t *\n\t * For containers GMT_IS_DATASET, GMT_IS_MATRIX and GMT_IS VECTOR: If you add the constant\n\t * GMT_WITH_STRINGS to the mode it will allocate the corresponding arrays of string pointers.\n\t * You can then add actual strings in addition to data values.  Note: GMT will assume\n\t * the individual strings was allocated using functions like malloc or strdup and will\n\t * free them when the container goes out of scope.  If you don't want that to happen then\n\t * you must set those pointers to NULL beforehand.\n\t *\n\t * Return: Pointer to resource, or NULL if an error (set via API->error).\n\t */\n\n\tint error = GMT_NOERROR;\n\tint def_direction = GMT_IN;\t/* Default direction is GMT_IN  */\n\tunsigned int module_input, actual_family, i_mode;\n\tuint64_t n_layers = 0, zero_dim[4] = {0, 0, 0, 0}, *this_dim = dim;\n\tint64_t n_cols = 0;\n\tbool already_registered = false, has_ID = false;\n\tstruct GMT_CUBE *C = NULL;\n\tstruct GMT_CUBE_HIDDEN *HU = NULL;\n\tstruct GMT_GRID *G = NULL;\n\tvoid *new_obj = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\ti_mode = (family & GMT_IMAGE_ALPHA_LAYER);\n\tfamily -= i_mode;\n\tmodule_input = (family & GMT_VIA_MODULE_INPUT);\t/* Are we creating a resource that is a module input? */\n\tfamily -= module_input;\n\tactual_family = gmtapi_separate_families (&family);\n\n\tif (mode & GMT_IS_OUTPUT) {\t/* Flagged to be an output container */\n\t\tdef_direction = GMT_OUT;\t/* Set output as default direction*/\n\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data pointer is not NULL */\n\t\tif (dim && !(actual_family == GMT_IS_MATRIX || actual_family == GMT_IS_VECTOR))\n\t\t\treturn_null (API, GMT_PTR_NOT_NULL);\t/* Error if dim pointer is not NULL except for matrix and vector */\n\t\tif (this_dim == NULL) this_dim = zero_dim;\t/* Provide dimensions set to zero */\n\t}\n\n\tif (mode & GMT_GRID_IS_GEO) gmt_set_geographic (API->GMT, GMT_OUT);\t/* From API to tell a grid is geographic */\n\n\t/* Below, data can only be non-NULL for Grids or Images passing back G or I to allocate the data array */\n\n\tswitch (actual_family) {\t/* dataset, cpt, text, grid , image, vector, matrix */\n\t\tcase GMT_IS_GRID:\t/* GMT grid, allocate header but not data array */\n\t\t\tif (mode & GMT_WITH_STRINGS) return_null (API, GMT_NO_STRINGS_ALLOWED);\t/* Error if given unsuitable mode */\n\t\t\tif (mode & GMT_IS_OUTPUT || (mode & GMT_DATA_ONLY) == 0) {\t/* Create new grid unless we only ask for data only */\n\t\t\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data pointer is not NULL */\n\t \t\t\tif ((new_obj = gmt_create_grid (API->GMT)) == NULL)\n\t \t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\t\tif (pad != GMT_NOTSET) gmt_set_pad (API->GMT, pad);\t/* Change the default pad; give -1 to leave as is */\n\t\t\t\tif ((error = gmtapi_init_grid (API, NULL, this_dim, range, inc, registration, mode, def_direction, new_obj)))\n\t\t\t\t\treturn_null (API, error);\n\t\t\t\tif (pad != GMT_NOTSET) gmt_set_pad (API->GMT, API->pad);\t/* Reset to the default pad */\n\t\t\t}\n\t\t\telse {\t/* Already registered so has_ID must be false */\n\t\t\t\tif (has_ID || (new_obj = data) == NULL)\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\t/* Error if data pointer is NULL */\n\t\t\t\talready_registered = true;\n\t\t\t}\n\t\t\tif (def_direction == GMT_IN && (mode & GMT_CONTAINER_ONLY) == 0) {\t/* Allocate the grid array unless we asked for header only */\n\t\t\t\tif ((error = gmtapi_alloc_grid (API->GMT, new_obj)) != GMT_NOERROR)\n\t\t\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t\t\t/* Also allocate and populate the x,y vectors */\n\t\t\t\tif ((error = gmtapi_alloc_grid_xy (API, new_obj)) != GMT_NOERROR)\n\t\t\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* GMT image, allocate header but not data array */\n\t\t\tif (mode & GMT_WITH_STRINGS) return_null (API, GMT_NO_STRINGS_ALLOWED);\t/* Error if given unsuitable mode */\n\t\t\tif (mode & GMT_IS_OUTPUT || (mode & GMT_DATA_ONLY) == 0) {\t/* Create new image unless we only ask for data only */\n\t\t\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data is not NULL */\n\t \t\t\tif ((new_obj = gmtlib_create_image (API->GMT)) == NULL)\n\t \t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\t\tif (pad != GMT_NOTSET) gmt_set_pad (API->GMT, pad);\t/* Change the default pad; give -1 to leave as is */\n\t\t\t\tif ((error = gmtapi_init_image (API, NULL, this_dim, range, inc, registration, mode, def_direction, new_obj)))\n\t\t\t\t\treturn_null (API, error);\n\t\t\t\tif (pad != GMT_NOTSET) gmt_set_pad (API->GMT, API->pad);\t/* Reset to the default pad */\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((new_obj = data) == NULL)\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\t/* Error if data is NULL */\n\t\t\t\talready_registered = true;\n\t\t\t}\n\t\t\tif (def_direction == GMT_IN && (mode & GMT_CONTAINER_ONLY) == 0) {\t/* Allocate the image array unless we asked for header only */\n\t\t\t\tif ((error = gmtapi_alloc_image (API->GMT, dim, i_mode, new_obj)) != GMT_NOERROR)\n\t\t\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t\t\t\t/* Also allocate and populate the image x,y vectors */\n\t\t\t\tif ((error = gmtapi_alloc_image_xy (API, new_obj)) != GMT_NOERROR)\n\t\t\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* GMT dataset, allocate the requested tables, segments, rows, and columns */\n\t\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data is not NULL */\n\t\t\tif (this_dim[GMT_TBL] > UINT_MAX || this_dim[GMT_ROW] > UINT_MAX)\n\t\t\t\treturn_null (API, GMT_DIM_TOO_LARGE);\n\t\t\t/* We basically create a blank slate(s), with n_tables, n_segments, and n_columns set [unless 0], but all n_rows == 0 (even if known; S->n_alloc has the lengths) */\n\t\t\tif ((new_obj = gmtlib_create_dataset (API->GMT, this_dim[GMT_TBL], this_dim[GMT_SEG], this_dim[GMT_ROW], this_dim[GMT_COL], geometry, mode & GMT_WITH_STRINGS, false)) == NULL)\n\t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\t/* GMT CPT, allocate one with space for dim[0] color entries */\n\t\t\tif (mode & GMT_WITH_STRINGS) return_null (API, GMT_NO_STRINGS_ALLOWED);\t/* Error if given unsuitable mode */\n\t\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data is not NULL */\n\t\t\t/* If dim is NULL then we ask for 0 color entries as direction here is GMT_OUT for return to an external API */\n\t\t \tif ((new_obj = gmtlib_create_palette (API->GMT, this_dim[0])) == NULL)\n\t\t \t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\t/* GMT PS struct, allocate one struct */\n\t\t\tif (mode & GMT_WITH_STRINGS) return_null (API, GMT_NO_STRINGS_ALLOWED);\t/* Error if given unsuitable mode */\n\t\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data is not NULL */\n\t\t \tif ((new_obj = gmtlib_create_ps (API->GMT, this_dim[0])) == NULL)\n\t\t \t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* GMT matrix container, allocate one with the requested number of layers, rows & columns */\n\t\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data is not NULL */\n\t\t\tn_layers = (this_dim == NULL || (this_dim[GMTAPI_DIM_COL] == 0 && this_dim[GMTAPI_DIM_ROW] == 0)) ? 1U : this_dim[GMT_Z];\t/* Only by specifying nx,ny dimension might there be > 1 layer */\n\t\t \tnew_obj = gmtlib_create_matrix (API->GMT, n_layers, def_direction, pad);\n\t\t\tif ((API->error = gmtapi_init_matrix (API, this_dim, range, inc, registration, mode, def_direction, new_obj))) {\t/* Failure, must free the object */\n\t\t\t\tstruct GMT_MATRIX *M = gmtapi_return_address (new_obj, GMT_IS_MATRIX);\t/* Get pointer to resource */\n\t\t\t\tgmtlib_free_matrix (API->GMT, &M, true);\n\t\t \t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* GMT vector container, allocate one with the requested number of columns & rows */\n\t\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data is not NULL */\n\t\t\tn_cols = gmtapi_vector_ncols (dim, def_direction);\n\t\t\tif (n_cols == GMT_NOTSET) return_null (API, GMT_N_COLS_NOT_SET);\n\t \t\tnew_obj = gmt_create_vector (API->GMT, n_cols, def_direction);\n\t\t\tif (pad) GMT_Report (API, GMT_MSG_DEBUG, \"Pad argument (%d) ignored in initialization of %s\\n\", pad, GMT_family[family]);\n\t\t\tif ((API->error = gmtapi_init_vector (API, this_dim, range, inc, registration, mode, def_direction, new_obj))) {\t/* Failure, must free the object */\n\t\t\t\tstruct GMT_VECTOR *V = gmtapi_return_address (new_obj, GMT_IS_VECTOR);\t/* Get pointer to resource */\n\t\t\t\tgmt_free_vector (API->GMT, &V, true);\n\t\t \t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_CUBE:\n\t\t\tif (mode & GMT_WITH_STRINGS) return_null (API, GMT_NO_STRINGS_ALLOWED);\t/* Error if given unsuitable mode */\n\t\t\tif (mode & GMT_IS_OUTPUT || (mode & GMT_DATA_ONLY) == 0) {\t/* Create new cube unless we only ask for data only */\n\t\t\t\tif (data) return_null (API, GMT_PTR_NOT_NULL);\t/* Error if data pointer is not NULL */\n\t \t\t\tif ((C = gmtlib_create_cube (API->GMT)) == NULL)\n\t \t\t\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\t\tif (pad != GMT_NOTSET) gmt_set_pad (API->GMT, pad);\t/* Change the default pad; give -1 to leave as is */\n\t\t\t\tif ((G = gmt_create_grid (API->GMT)) == NULL)\n\t\t \t\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\t\tif ((error = gmtapi_init_grid (API, NULL, this_dim, range, inc, registration, mode, def_direction, G)))\n\t\t\t\t\treturn_null (API, error);\n\t\t\t\tif (pad != GMT_NOTSET) gmt_set_pad (API->GMT, API->pad);\t/* Reset to the default pad */\n\t\t\t\tif (def_direction == GMT_IN) {\n\t\t\t\t\tif (range == NULL) return_null (API, GMT_PTR_IS_NULL);\t/* Need at least the z-range for cubes */\n\t\t\t\t\tgmt_copy_gridheader (API->GMT, C->header, G->header);\n\t\t\t\t\tC->z_range[0] = range[ZLO];\tC->z_range[1] = range[ZHI];\n\t\t\t\t\tif (inc && inc[GMT_Z] > 0.0) {\t/* Must make equidistant array, else we lave it as NULL to be set by calling module */\n\t\t\t\t\t\tHU = gmt_get_U_hidden (C);\n\t\t\t\t\t\tC->header->n_bands = gmt_make_equidistant_array (API->GMT, range[ZLO], range[ZHI], inc[GMT_Z], &(C->z));\n\t\t\t\t\t\tC->z_inc = inc[GMT_Z];\n\t\t\t\t\t\tHU->xyz_alloc_mode[GMT_Z] = GMT_ALLOC_INTERNALLY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t/* Already registered so has_ID must be false */\n\t\t\t\tif (has_ID || (C = data) == NULL)\n\t\t\t\t\treturn_null (API, GMT_PTR_IS_NULL);\t/* Error if data pointer is NULL */\n\t\t\t\talready_registered = true;\n\t\t\t}\n\t\t\tif (def_direction == GMT_IN && (mode & GMT_CONTAINER_ONLY) == 0) {\t/* Allocate the grid array unless we asked for header only */\n\t\t\t\tsize_t chunk = C->header->size * ((size_t)C->header->n_bands);\t/* Total memory needed for the entire cube */\n\t\t\t\tif ((C->data = gmt_M_memory_aligned (API->GMT, NULL, chunk, gmt_grdfloat)) == NULL)\n\t\t\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t\t\t/* Also allocate and populate the x,y vectors */\n\t\t\t\tif ((error = gmtapi_alloc_grid_xy (API, G)) != GMT_NOERROR)\n\t\t\t\t\treturn_null (API, error);\t/* Allocation error */\n\t\t\t\tC->x = G->x;\tC->y = G->y;\t/* Let these be the cube's from now on */\n\t\t\t\tG->x = G->y = NULL;\t/* No longer anything to do with G */\n\t\t\t\tHU = gmt_get_U_hidden (C);\n\t\t\t\tHU->xyz_alloc_mode[GMT_X] = HU->xyz_alloc_mode[GMT_Y] = GMT_ALLOC_INTERNALLY;\n\t\t\t\tif (gmtapi_destroy_grid (API, &G))\t/* Use this instead of GMT_Destroy_Data since G was local and never registered */\n\t\t \t\t\treturn_null (API, GMT_MEMORY_ERROR);\t/* Allocation error */\n\t\t\t}\n\t\t\tnew_obj = C;\t/* Finally assign to new_obj */\n\t\t\tbreak;\n\n\t\tdefault:\n \t\t\treturn_null (API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t}\n\tassert (API->error == GMT_NOERROR);\t/* All errors were dealt with so why this? */\n\n\tif (!already_registered) {\t/* Register this object so it can be deleted by GMT_Destroy_Data or gmtlib_garbage_collection */\n\t\tenum GMT_enum_method method = (mode & GMT_IS_OUTPUT) ? GMT_IS_DUPLICATE : GMT_IS_REFERENCE;\t/* Since it is a memory object */\n\t\tint item = GMT_NOTSET, object_ID = GMT_NOTSET;\n\t\tstruct GMTAPI_DATA_OBJECT *S_obj = NULL;\n\t\tif ((object_ID = GMT_Register_IO (API, actual_family|module_input, method, geometry, def_direction, range, new_obj)) == GMT_NOTSET)\n\t\t\treturn_null (API, API->error);\t/* Failure to register */\n\t\tif ((item = gmtlib_validate_id (API, actual_family, object_ID, def_direction, GMT_NOTSET)) == GMT_NOTSET)\n\t\t\treturn_null (API, API->error);\n\t\tS_obj = API->object[item];\t\t/* Short-hand notation */\n\t\tAPI->object[item]->resource = new_obj;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\t\tS_obj->actual_family = actual_family;\n\t\tS_obj->family = family;\n\t\tif (def_direction == GMT_OUT) S_obj->messenger = true;\t/* We are passing a dummy container that should be destroyed before returning actual data */\n\t\tif (family == actual_family)\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Successfully created a new %s container\\n\", GMT_family[actual_family]);\n\t\telse\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Successfully created a new %s container to represent a %s\\n\", GMT_family[actual_family], GMT_family[family]);\n#ifdef DEBUG\n\t\tgmtapi_set_object (API, S_obj);\n#endif\n\t}\n\telse\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Successfully added data array to previously registered %s container\\n\", GMT_family[family]);\n#ifdef DEBUG\n\tgmtapi_list_objects (API, \"GMT_Create_Data\");\n#endif\n\n\treturn (new_obj);\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_Create_Data_ (unsigned int *family, unsigned int *geometry, unsigned int *mode, uint64_t *dim, double *range, double *inc, unsigned int *registration, int *pad, void *container) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Create_Data (GMT_FORTRAN, *family, *geometry, *mode, dim, range, inc, *registration, *pad, container));\n}\n#endif\n\nint GMT_Get_Info (void *V_API, unsigned int family, void *data, unsigned int *geometry, uint64_t dim[], double *range, double *inc, unsigned int *registration, int *pad) {\n\t/* Return information for this object identified by family and data pointer.\n\t * The known families are GMT_IS_{DATASET,GRID,PALETTE,IMAGE,POSTSCRIPT,GMT_IS_CUBE,GMT_IS_{VECTOR,MATRIX}.\n\t * Not all output args may be set as it depends on the family, and any output argument that\n\t * is NULL is always skipped.  This function is mostly useful for applications where the containers\n\t * are not easily inspected directly, e.g., we are calling from another programming language.\n\t */\n\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (data == NULL) return_error (API, GMT_PTR_IS_NULL);\t/* Error if data is NULL */\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tswitch (family) {\t/* dataset, cpt, text, grid , image, vector, matrix */\n\t\tcase GMT_IS_GRID:\t/* GMT grid, allocate header but not data array */\n\t\t\t{\t/* Deal with a local grid pointer */\n\t\t\t\tstruct GMT_GRID *G = gmtapi_get_grid_data (data);\n\t\t\t\tif (dim) { dim[GMT_X] = G->header->n_columns; dim[GMT_Y] = G->header->n_rows; }\n\t\t\t\tif (range) gmt_M_memcpy (range, G->header->wesn, 4U, double);\n\t\t\t\tif (inc) gmt_M_memcpy (inc, G->header->inc, 2U, double);\n\t\t\t\tif (geometry) *geometry = GMT_IS_SURFACE;\n\t\t\t\tif (registration) *registration = G->header->registration;\n\t\t\t\tif (pad) {\t/* Need to check they are all the same, if not return undefined or something */\n\t\t\t\t\tunsigned int bad = 0, k;\n\t\t\t\t\tfor (k = XHI; k <= YHI; k++) if (G->header->pad[k] != G->header->pad[XLO]) bad++;\n\t\t\t\t\tif (bad) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Grid sides have different padding, return pad as not set [-1]\\n\");\n\t\t\t\t\t\t*pad = GMT_NOTSET;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*pad = G->header->pad[XLO];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* GMT image, allocate header but not data array */\n\t\t\t{\t/* Deal with a local image pointer */\n\t\t\t\tstruct GMT_IMAGE *I = gmtapi_get_image_data (data);\n\t\t\t\tif (dim) { dim[GMT_X] = I->header->n_columns; dim[GMT_Y] = I->header->n_rows; dim[GMT_Z] = I->header->n_bands; }\n\t\t\t\tif (range) gmt_M_memcpy (range, I->header->wesn, 4U, double);\n\t\t\t\tif (inc) gmt_M_memcpy (inc, I->header->inc, 2U, double);\n\t\t\t\tif (geometry) *geometry = GMT_IS_IMAGE;\n\t\t\t\tif (registration) *registration = I->header->registration;\n\t\t\t\tif (pad) {\t/* Need to check they are all the same, if not return undefined or something */\n\t\t\t\t\tunsigned int bad = 0, k;\n\t\t\t\t\tfor (k = XHI; k <= YHI; k++) if (I->header->pad[k] != I->header->pad[XLO]) bad++;\n\t\t\t\t\tif (bad) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Image sides have different padding, return pad as not set [-1]\\n\");\n\t\t\t\t\t\t*pad = GMT_NOTSET;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*pad = I->header->pad[XLO];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* GMT dataset, allocate the requested tables, segments, rows, and columns */\n\t\t\t{\t/* Deal with a local image pointer */\n\t\t\t\tstruct GMT_DATASET *D = gmtapi_get_dataset_data (data);\n\t\t\t\tif (dim) { dim[GMT_TBL] = D->n_tables; dim[GMT_SEG] = D->n_segments; dim[GMT_ROW] = D->n_records;  dim[GMT_COL] = D->n_columns; }\n\t\t\t\tif (geometry) *geometry = D->geometry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\t/* GMT CPT, allocate one with space for dim[0] color entries */\n\t\t\t{\t/* Deal with a local palette pointer */\n\t\t\t\tstruct GMT_PALETTE *P = gmtapi_get_palette_data (data);\n\t\t\t\tif (dim) dim[0] = P->n_colors;\n\t\t\t\tif (range) gmt_M_memcpy (range, P->minmax, 2U, double);\n\t\t\t\tif (geometry) *geometry = GMT_IS_NONE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\t/* GMT PS struct, allocate one struct */\n\t\t\t{\t/* Deal with a local PostScript pointer */\n\t\t\t\tstruct GMT_POSTSCRIPT *X = gmtapi_get_postscript_data (data);\n\t\t\t\tif (dim) dim[0] = X->n_bytes;\n\t\t\t\tif (geometry) *geometry = GMT_IS_NONE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_CUBE:\t/* GMT cube, allocate header but not data array */\n\t\t\t{\t/* Deal with a local grid pointer */\n\t\t\t\tstruct GMT_CUBE *U = gmtapi_get_cube_data (data);\n\t\t\t\tif (dim) { dim[GMT_X] = U->header->n_columns; dim[GMT_Y] = U->header->n_rows; dim[GMT_Z] = U->header->n_bands; }\n\t\t\t\tif (range) {\n\t\t\t\t\tgmt_M_memcpy (range, U->header->wesn, 4U, double);\n\t\t\t\t\tgmt_M_memcpy (&range[4], U->z_range, 2U, double);\n\t\t\t\t}\n\t\t\t\tif (inc) {\n\t\t\t\t\tgmt_M_memcpy (inc, U->header->inc, 2U, double);\n\t\t\t\t\tinc[GMT_Z] = U->z_inc;\n\t\t\t\t}\n\t\t\t\tif (geometry) *geometry = GMT_IS_VOLUME;\n\t\t\t\tif (registration) *registration = U->header->registration;\n\t\t\t\tif (pad) {\t/* Need to check they are all the same, if not return undefined or something */\n\t\t\t\t\tunsigned int bad = 0, k;\n\t\t\t\t\tfor (k = XHI; k <= YHI; k++) if (U->header->pad[k] != U->header->pad[XLO]) bad++;\n\t\t\t\t\tif (bad) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Cube x/y sides have different padding, return pad as not set [-1]\\n\");\n\t\t\t\t\t\t*pad = GMT_NOTSET;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*pad = U->header->pad[XLO];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* GMT matrix container, allocate one with the requested number of layers, rows & columns */\n\t\t\t{\t/* Deal with a local matrix pointer */\n\t\t\t\tstruct GMT_MATRIX *M = gmtapi_get_matrix_data (data);\n\t\t\t\tif (dim) { dim[GMT_X] = M->n_columns; dim[GMT_Y] = M->n_rows; dim[GMT_Z] = M->n_layers; }\n\t\t\t\tif (range) gmt_M_memcpy (range, M->range, (M->n_layers > 1) ? 6U : 4U, double);\n\t\t\t\tif (inc) gmt_M_memcpy (inc, M->inc, (M->n_layers > 1) ? 3U : 2U, double);\n\t\t\t\tif (registration) *registration = M->registration;\n\t\t\t\tif (geometry) *geometry = GMT_IS_SURFACE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* GMT vector container, allocate one with the requested number of columns & rows */\n\t\t\t{\t/* Deal with a local image pointer */\n\t\t\t\tstruct GMT_VECTOR *V = gmtapi_get_vector_data (data);\n\t\t\t\tif (dim) { dim[GMT_X] = V->n_columns; dim[GMT_Y] = V->n_rows; }\n\t\t\t\tif (range) gmt_M_memcpy (range, V->range, 2U, double);\n\t\t\t\tif (registration) *registration = V->registration;\n\t\t\t\tif (geometry) *geometry = GMT_IS_PLP;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n \t\t\treturn_error (API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t}\n\n\treturn (API->error);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Info_ (unsigned int *family, void *container, unsigned int *geometry, uint64_t *dim, double *range, double *inc, unsigned int *registration, int *pad) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Info (GMT_FORTRAN, *family, container, geometry, dim, range, inc, registration, pad));\n}\n#endif\n\n/*! Convenience function to get grid or image node */\nuint64_t GMT_Get_Index (void *V_API, struct GMT_GRID_HEADER *header, int row, int col) {\n\t/* V_API not used but all API functions take V_API so no exceptions! */\n\tgmt_M_unused(V_API);\n\treturn (GMTAPI_index_function (header, row, col, 0));\n}\n\n#ifdef FORTRAN_API\nuint64_t GMT_Get_Index_ (void *h, int *row, int *col) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Index (GMT_FORTRAN, h, *row, *col));\n}\n#endif\n\n/*! Convenience function to get image layer node */\nuint64_t GMT_Get_Pixel (void *V_API, struct GMT_GRID_HEADER *header, int row, int col, int layer) {\n\t/* V_API not used but all API functions take V_API so no exceptions! */\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = gmt_get_H_hidden (header);\n\tgmt_M_unused(V_API);\n\treturn (HH->index_function (header, row, col, layer));\n}\n\n#ifdef FORTRAN_API\nuint64_t GMT_Get_Pixel_ (void *h, int *row, int *col, int *layer) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Pixel (GMT_FORTRAN, h, *row, *col, *layer));\n}\n#endif\n\n/*! Convenience function to get cube node */\nuint64_t GMT_Get_Index3 (void *V_API, struct GMT_GRID_HEADER *header, int row, int col, int layer) {\n\t/* V_API not used but all API functions take V_API so no exceptions! */\n\tgmt_M_unused(V_API);\n\treturn (GMTAPI_index_function (header, row, col, 0) + layer * header->size);\n}\n\n#ifdef FORTRAN_API\nuint64_t GMT_Get_Index3_ (void *h, int *row, int *col, int *layer) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Index3 (GMT_FORTRAN, h, *row, *col, *layer));\n}\n#endif\n\n/*! Specify image memory layout */\nint GMT_Set_Index (void *V_API, struct GMT_GRID_HEADER *header, char *code) {\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = gmt_get_H_hidden (header);\n\tenum GMT_enum_family family;\n\tunsigned int mode;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tmode = gmtapi_decode_layout (API, code, &family);\n\tswitch (family) {\n\t\tcase GMT_IS_GRID:\n\t\t\tswitch (mode) {\n\t\t\t\tcase 0:\t/* Default scanline C grid */\n\t\t\t\t\tHH->index_function = gmtapi_get_index_from_TRS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* Same for real component in complex grid */\n\t\t\t\t\tHH->index_function = gmtapi_get_index_from_TRR;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\t/* Same for imag component in complex grid */\n\t\t\t\t\tHH->index_function = gmtapi_get_index_from_TRI;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unrecognized mode for grid layout [%u]\\n\", mode);\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_MODULE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\tswitch (mode) {\n\t\t\t\tcase 0:\t/* band-interleaved layout */\n\t\t\t\t\tHH->index_function = gmtapi_get_index_from_TRB;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* pixel-interleaved layout */\n\t\t\t\t\tHH->index_function = gmtapi_get_index_from_TRP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\t/* line-interleaved layout */\n\t\t\t\t\tHH->index_function = gmtapi_get_index_from_TRL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unrecognized mode for image layout [%u]\\n\", mode);\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_MODULE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unrecognized family for gmtapi_decode_layout [%s]\\n\", code);\n\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\tGMTAPI_index_function = HH->index_function;\n\treturn API->error;\n}\n\n#ifdef FORTRAN_API\nint GMT_Set_Index_ (void *h, char *code, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Set_Index (GMT_FORTRAN, h, code));\n}\n#endif\n\n/*! . */\ndouble * GMT_Get_Coord (void *V_API, unsigned int family, unsigned int dim, void *container) {\n\t/* Return an array of coordinates for the nodes along the specified dimension.\n\t * For GMT_GRID and GMT_IMAGE, dim is either 0 (GMT_X) or 1 (GMT_Y) while for\n\t * GMT_MATRIX it may be 2 (GMT_Z), provided the matrix has more than 1 layer.\n\t * For GMT_VECTOR that was registered as equidistant it will return coordinates\n\t * along the single dimension.\n\t * Cannot be used on other resources (GMT_DATASET, GMT_PALETTE).\n\t */\n\tint object_ID, item;\n\tdouble *coord = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (container == NULL) return_null (V_API, GMT_ARG_IS_NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tswitch (family) {\t/* grid, image, or matrix */\n\t\tcase GMT_IS_GRID:\t/* GMT grid */\n\t\t\tif (dim > GMT_Y) return_null (API, GMT_DIM_TOO_LARGE);\n\t\t\tcoord = gmtapi_grid_coord (API, dim, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* GMT image */\n\t\t\tif (dim > GMT_Y) return_null (API, GMT_DIM_TOO_LARGE);\n\t\t\tcoord = gmtapi_image_coord (API, dim, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* GMT vector */\n\t\t\tif (dim != GMT_Y) return_null (API, GMT_DIM_TOO_LARGE);\n\t\t\tcoord = gmtapi_vector_coord (API, dim, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* GMT matrix */\n\t\t\tif (dim > GMT_Z) return_null (API, GMT_DIM_TOO_LARGE);\n\t\t\tcoord = gmtapi_matrix_coord (API, dim, container);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn_null (API, GMT_NOT_A_VALID_FAMILY);\n\t\t\tbreak;\n\t}\n\t/* We register the coordinate array so that GMT_Destroy_Data can free them later */\n\tif ((object_ID = GMT_Register_IO (V_API, GMT_IS_COORD, GMT_IS_COORD, GMT_IS_NONE, GMT_IN, NULL, coord)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\tif ((item = gmtlib_validate_id (API, GMT_IS_COORD, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\tAPI->object[item]->resource = coord;\t/* Retain pointer to the allocated data so we use garbage collection later */\n\tGMT_Report (API, GMT_MSG_DEBUG, \"Successfully created a new coordinate array for %s\\n\", GMT_family[family]);\n\n\treturn (coord);\n}\n\n#ifdef FORTRAN_API\ndouble * GMT_Get_Coord_ (unsigned int *family, unsigned int *dim, void *container) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Coord (GMT_FORTRAN, *family, *dim, container));\n}\n#endif\n\n/*! . */\nint GMT_Set_Comment (void *V_API, unsigned int family, unsigned int mode, void *arg, void *container) {\n\t/* Set new header comment or grid command|remark to container */\n\n\tint error = GMT_NOERROR;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (container == NULL) return_error (V_API, GMT_ARG_IS_NULL);\n\tif (arg == NULL) return_error (V_API, GMT_ARG_IS_NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\n\tswitch (family) {\t/* grid, image, dataset, cpt, PS or matrix */\n\t\tcase GMT_IS_GRID:\t/* GMT grid */\n\t\t\tgmtapi_grid_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* GMT image */\n\t\t\tgmtapi_image_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* GMT dataset */\n\t\t\tgmtapi_dataset_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\t/* GMT CPT */\n\t\t\tgmtapi_cpt_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\t\t/* GMT PS */\n\t\t\tgmtapi_ps_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_CUBE:\t/* GMT cube */\n\t\t\tgmtapi_cube_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* GMT Vector [PW: Why do we need these?]*/\n\t\t\tgmtapi_vector_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* GMT Vector */\n\t\t\tgmtapi_matrix_comment (API, mode, arg, container);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\treturn_error (API, error);\n}\n\n/* FFT Extension: Functions available to do FFT work within the API */\n\n/*! . */\nunsigned int GMT_FFT_Option (void *V_API, char option, unsigned int dim, const char *string) {\n\t/* For programs that needs to do either 1-D or 2-D FFT work */\n\tunsigned int d1 = dim - 1;\t/* Index into the info text strings below for 1-D (0) and 2-D (1) case */\n\tchar *data_type[2] = {\"table\", \"grid\"}, *dim_name[2] = {\"<n_columns>\", \"<n_columns>/<n_rows>\"}, *trend_type[2] = {\"line\", \"plane\"};\n\tchar *dim_ref[2] = {\"dimension\", \"dimensions\"}, *linear_type[2] = {\"linear\", \"planar\"};\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (dim > 2) return_error (V_API, GMT_DIM_TOO_LARGE);\n\tif (dim == 0) return_error (V_API, GMT_DIM_TOO_SMALL);\n\tif (string && string[0] == ' ') GMT_Report (V_API, GMT_MSG_ERROR, \"Option -%c parsing failure.  Correct syntax:\\n\", option);\n\tif (string)\n\t\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t-%c %s\\n\", option, string);\n\telse\n\t\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t-%c Choose or inquire about suitable %s %s for %u-D FFT, and set modifiers.\\n\", option, data_type[d1], dim_ref[d1], dim);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t   Setting the FFT %s:\\n\", dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -Na will select %s promising the most accurate results.\\n\", dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -Nf will force the FFT to use the %s of the %s.\\n\", dim_ref[d1], data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -Nm will select %s using the least work storage.\\n\", dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -Nr will select %s promising the most rapid calculation.\\n\", dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -Ns will list Singleton's [1967] recommended %s, then exit.\\n\", dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     -N%s will do FFT on array size %s (Must be >= %s size).\\n\", dim_name[d1], dim_name[d1], data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     Default chooses %s >= %s %s to optimize speed and accuracy of the FFT.\\n\", dim_ref[d1], data_type[d1], dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t   Append modifiers for removing a %s trend:\\n\", linear_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +d: Detrend data, i.e., remove best-fitting %s [Default].\\n\", trend_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +a: Only remove mean value.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +h: Only remove mid value, i.e., 0.5 * (max + min).\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +l: Leave data alone.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t   Append modifiers for extending the %s via symmetries:\\n\", data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     If FFT %s > %s %s, data are extended via edge point symmetry\\n\", dim_ref[d1], data_type[d1], dim_ref[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     and tapered to zero.  Several modifiers can be set to change this behavior:\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +e: Extend data via edge point symmetry [Default].\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +m: Extend data via edge mirror symmetry.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +n: Do NOT extend data.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +t<w>: Limit tapering to <w> %% of the extended margins [100].\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     If +n is set then +t instead sets the boundary width of the interior\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     %s margin to be tapered [0].\\n\", data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t   Append modifiers for saving modified %s before or after the %u-D FFT is called:\\n\", data_type[d1], dim);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +w[<suffix>] will write the intermediate %s passed to FFT after detrending/extension/tapering.\\n\", data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t       File name will have _<suffix> [tapered] inserted before file extension.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +z[p] will write raw complex spectrum to two separate %s files.\\n\", data_type[d1]);\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t       File name will have _real/_imag inserted before the file extensions.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t       Append p to store polar forms, using _mag/_phase instead.\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t   Append modifiers for messages:\\n\");\n\tGMT_Message (V_API, GMT_TIME_NONE, \"\\t     +v will report all suitable dimensions (except when -Nf is selected).\\n\");\n\n\treturn_error (V_API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nunsigned int GMT_FFT_Option_ (char *option, unsigned int *dim, const char *string, int *length) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_Option (GMT_FORTRAN, *option, *dim, string));\n}\n#endif\n\n/* first 2 cols from table III of Singleton's paper on fft.... */\n#define N_SINGLETON_LIST\t117\nstatic int Singleton_list[N_SINGLETON_LIST] = {\n\t64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,\n\t216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,\n\t486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,\n\t972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,\n\t1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,\n\t2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,\n\t3600,3645,3750,3840,3888,4000,4096,4320,4374,4500,4608,4800,4860,5000};\n\nGMT_LOCAL void gmtapi_fft_Singleton_list (struct GMTAPI_CTRL *API) {\n\tunsigned int k;\n\tchar message[GMT_LEN16] = {\"\"};\n\tGMT_Message (API, GMT_TIME_NONE, \"\\t\\\"Good\\\" numbers for FFT dimensions [Singleton, 1967]:\\n\");\n\tfor (k = 0; k < N_SINGLETON_LIST; k++) {\n\t\tsnprintf (message, GMT_LEN16, \"\\t%d\", Singleton_list[k]);\n\t\tif ((k+1) % 10 == 0 || k == (N_SINGLETON_LIST-1)) strcat (message, \"\\n\");\n\t\tGMT_Message (API, GMT_TIME_NONE, message);\n\t}\n}\n\n/*! . */\nvoid * GMT_FFT_Parse (void *V_API, char option, unsigned int dim, const char *args) {\n\t/* Parse the 1-D or 2-D FFT options such as -N in grdfft */\n\tunsigned int n_errors = 0, pos = 0;\n\tchar p[GMT_BUFSIZ] = {\"\"}, *c = NULL;\n\tstruct GMT_FFT_INFO *info = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (args == NULL) return_null (V_API, GMT_ARG_IS_NULL);\n\tif (dim == 0) return_null (V_API, GMT_DIM_TOO_SMALL);\n\tif (dim > 2) return_null (V_API, GMT_DIM_TOO_LARGE);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tinfo = gmt_M_memory (API->GMT, NULL, 1, struct GMT_FFT_INFO);\n\tinfo->taper_width = -1.0;\t\t\t\t/* Not set yet */\n\tinfo->taper_mode = GMT_FFT_EXTEND_NOT_SET;\t\t/* Not set yet */\n\tinfo->trend_mode = GMT_FFT_REMOVE_NOT_SET;\t\t/* Not set yet */\n\tinfo->info_mode = GMT_FFT_UNSPECIFIED;\t\t\t/* Not set yet */\n\tinfo->suggest = GMT_FFT_N_SUGGEST;\t\t\t\t/* Not yet set */\n\n\tif ((c = strchr (args, '+'))) {\t/* Handle modifiers */\n\t\twhile ((gmt_strtok (c, \"+\", &pos, p))) {\n\t\t\tswitch (p[0]) {\n\t\t\t\t/* Detrending modifiers */\n\t\t\t\tcase 'a':  info->trend_mode = GMT_FFT_REMOVE_MEAN;  break;\n\t\t\t\tcase 'd':  info->trend_mode = GMT_FFT_REMOVE_TREND; break;\n\t\t\t\tcase 'h':  info->trend_mode = GMT_FFT_REMOVE_MID;   break;\n\t\t\t\tcase 'l':  info->trend_mode = GMT_FFT_REMOVE_NOTHING;  break;\n\t\t\t\t/* Taper modifiers */\n\t\t\t\tcase 'e':  info->taper_mode = GMT_FFT_EXTEND_POINT_SYMMETRY; break;\n\t\t\t\tcase 'n':  info->taper_mode = GMT_FFT_EXTEND_NONE; break;\n\t\t\t\tcase 'm':  info->taper_mode = GMT_FFT_EXTEND_MIRROR_SYMMETRY; break;\n\t\t\t\tcase 't':\t/* Set taper width */\n\t\t\t\t\tif ((info->taper_width = atof (&p[1])) < 0.0) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Option -%c: Negative taper width given\\n\", option);\n\t\t\t\t\t\tn_errors++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/* i/o modifiers */\n\t\t\t\tcase 'w':\t/* Save FFT input; optionally append file suffix */\n\t\t\t\t\tinfo->save[GMT_IN] = true;\n\t\t\t\t\tif (p[1]) strncpy (info->suffix, &p[1], GMT_LEN64-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':  info->verbose = true; break;\t/* Report FFT suggestions */\n\t\t\t\tcase 'z': \t/* Save FFT output in two files; append p for polar form */\n\t\t\t\t\tinfo->save[GMT_OUT] = true;\n\t\t\t\t\tif (p[1] == 'p') info->polar = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Option -%c: Unrecognized modifier +%s.\\n\", option, p);\n\t\t\t\t\tn_errors++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (info->taper_mode == GMT_FFT_EXTEND_NOT_SET)\n\t\tinfo->taper_mode = GMT_FFT_EXTEND_POINT_SYMMETRY;\t/* Default action is edge-point symmetry */\n\tif (info->taper_mode == GMT_FFT_EXTEND_NONE) {\n\t\tif (info->taper_width < 0.0) info->taper_width = 0.0;\t/* No tapering unless specified */\n\t}\n\tif (info->taper_width < 0.0)\n\t\tinfo->taper_width = 100.0;\t\t/* Taper over entire margin strip by default */\n\n\tswitch (args[0]) {\n\t\tcase '\\0': info->suggest = GMT_FFT_N_SUGGEST;  break;\t/* Pick dimensions for the \"best\" solution */\n\t\tcase 'a': info->suggest = GMT_FFT_ACCURATE;  break;\t/* Pick dimensions for most accurate solution */\n\t\tcase 'f': info->info_mode = GMT_FFT_FORCE; break;\t/* Default is force actual grid dimensions */\n\t\tcase 'm': info->suggest = GMT_FFT_STORAGE;  break;\t/* Pick dimensions for minimum storage */\n\t\tcase 'q': info->verbose = true; break;\t/* No longer a mode.  Backwards compatibility; see +v instead */\n\t\tcase 'r': info->suggest = GMT_FFT_FAST;  break;\t/* Pick dimensions for most rapid solution */\n\t\tcase 's': info->info_mode = GMT_FFT_LIST;  break;\n\t\tdefault:\n\t\t\tif (dim == 2U) {\t/* 2-D */\n\t\t\t\tpos = sscanf (args, \"%d/%d\", &info->n_columns, &info->n_rows);\n\t\t\t\tif (pos == 1) info->n_rows = info->n_columns;\n\t\t\t}\n\t\t\telse {\t/* 1-D */\n\t\t\t\tpos = sscanf (args, \"%d\", &info->n_columns);\n\t\t\t\tinfo->n_rows = 0;\n\t\t\t}\n\t\t\tif (pos) info->info_mode = GMT_FFT_SET;\n\t}\n\tif (info->suffix[0] == '\\0') strncpy (info->suffix, \"tapered\", GMT_LEN64-1);\t/* Default suffix */\n\tinfo->set = true;\t/* We parsed this option */\n\tif (info->info_mode == GMT_FFT_SET) {\n\t\tif (dim == 2U && (info->n_columns <= 0 || info->n_rows <= 0)) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Option -%c: n_columns and/or n_rows are <= 0\\n\", option);\n\t\t\tn_errors++;\n\t\t}\n\t\telse if (dim == 1U && info->n_columns <= 0) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Option -%c: n_columns is <= 0\\n\", option);\n\t\t\tn_errors++;\n\t\t}\n\t}\n\tif (info->taper_mode == GMT_FFT_EXTEND_NONE && info->taper_width == 100.0) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Option -%c: +n requires +t with width << 100!\\n\", option);\n\t\tn_errors++;\n\t}\n\tif (info->info_mode == GMT_FFT_LIST) {\n\t\tgmtapi_fft_Singleton_list (API);\n\t}\n\tif (n_errors) {\n\t\tgmt_M_free (API->GMT, info);\n\t\tinfo = NULL;\n\t}\n\treturn (info);\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_FFT_Parse_ (char *option, unsigned int *dim, char *args, int *length) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_Parse (GMT_FORTRAN, *option, *dim, args));\n}\n#endif\n\n/*! . */\nGMT_LOCAL struct GMT_FFT_WAVENUMBER * gmtapi_fft_init_1d (struct GMTAPI_CTRL *API, struct GMT_DATASET *D, unsigned int mode, void *v_info) {\n\tstruct GMT_FFT_WAVENUMBER *K = NULL;\n\tgmt_M_unused(API); gmt_M_unused(D); gmt_M_unused(mode); gmt_M_unused(v_info);\n\n#if 0\t/* Have not finalized 1-D FFT usage in general; this will probably happen when we add gmtfft [1-D FFT equivalent to grdfft] */\n\tunsigned n_cols = 1;\n\tstruct GMT_FFT_INFO *F = gmtapi_get_fftinfo_ptr (v_info);\n\t/* Determine number of columns in [t] x [y] input */\n\tif (mode & GMT_FFT_CROSS_SPEC) n_cols++;\n\tif (Din->n_columns < n_cols) {\n\t\tGMT_report (API, GMT_MSG_ERROR, \"2 columns needed but only 1 provided\\n\");\n\t\treturn NULL;\n\t}\n\tcross = (n_cols == 2);\n\tif (mode & GMT_FFT_DELTA) n_cols++;\n\tdelta_t = (mode & GMT_FFT_DELTA) ? F->delta_t : D->table[0]->segment[0]->data[0][1] - D->table[0]->segment[0]->data[0][0];\n\tK->delta_kx = 2.0 * M_PI / (F->n_columns * delta_t);\n\n\tGMT_table_detrend (C, D, F->trend_mode, K->coeff);\t/* Detrend data, if requested */\n\tgmt_table_taper (C, G, F);\t\t\t\t/* Taper data, if requested */\n\tK->dim = 1;\t/* 1-D FFT */\n#endif\n\treturn (K);\n}\n\n/*! . */\nGMT_LOCAL void gmtapi_fft_taper2d (struct GMT_CTRL *GMT, struct GMT_GRID *Grid, struct GMT_FFT_INFO *F) {\n\t/* mode sets if and how tapering will be performed [see GMT_FFT_EXTEND_* constants].\n\t * width is relative width in percent of the margin that will be tapered [100]. */\n\tint il1, ir1, il2, ir2, jb1, jb2, jt1, jt2, im, jm, j, end_i, end_j, min_i, min_j, one;\n\tint i, i_data_start, j_data_start, mx, i_width, j_width, width_percent;\n\tunsigned int ju, start_component = 0, stop_component = 0, component;\n\tuint64_t off;\n\tchar *method[2] = {\"edge-point\", \"mirror\"}, *comp[2] = {\"real\", \"imaginary\"};\n\tgmt_grdfloat *datac = Grid->data, scale, cos_wt;\n\tdouble width;\n\tstruct GMT_GRID_HEADER *h = Grid->header;\t/* For shorthand */\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = gmt_get_H_hidden (h);\n\n\twidth_percent = irint (F->taper_width);\n\n\tif ((Grid->header->n_columns == F->n_columns && Grid->header->n_rows == F->n_rows) || F->taper_mode == GMT_FFT_EXTEND_NONE) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_INFORMATION, \"Data and FFT dimensions are equal - no data extension will take place\\n\");\n\t\t/* But there may still be interior tapering */\n\t\tif (F->taper_mode != GMT_FFT_EXTEND_NONE) {\t/* Nothing to do since no outside pad */\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_INFORMATION, \"Data and FFT dimensions are equal - no tapering will be performed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (F->taper_mode == GMT_FFT_EXTEND_NONE && width_percent == 100) {\t/* No interior taper specified */\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_INFORMATION, \"No interior tapering will be performed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (HH->arrangement == GMT_GRID_IS_INTERLEAVED) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_INFORMATION, \"Demultiplexing complex grid before tapering can take place.\\n\");\n\t\tgmt_grd_mux_demux (GMT, Grid->header, Grid->data, GMT_GRID_IS_SERIAL);\n\t}\n\n\t/* Note that if nx2 = nx+1 and ny2 = n_rows + 1, then this routine\n\t * will do nothing; thus a single row/column of zeros may be\n\t * added to the bottom/right of the input array and it cannot\n\t * be tapered.  But when (nx2 - nx)%2 == 1 or ditto for y,\n\t * this is zero anyway.  */\n\n\ti_data_start = GMT->current.io.pad[XLO];\t/* Some shorthands for readability */\n\tj_data_start = GMT->current.io.pad[YHI];\n\tmx = h->mx;\n\tone = (F->taper_mode == GMT_FFT_EXTEND_NONE) ? 0 : 1;\t/* 0 is the boundary point which we want to taper to 0 for the interior taper */\n\n\tif (width_percent == 0) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_WARNING, \"Tapering has been disabled via +t0\\n\");\n\t}\n\tif (width_percent == 100 && F->taper_mode == GMT_FFT_EXTEND_NONE) {\t/* Means user set +n but did not specify +t<taper> as 100% is unreasonable for interior */\n\t\twidth_percent = 0;\n\t\twidth = 0.0;\n\t}\n\telse\n\t\twidth = F->taper_width / 100.0;\t/* Was percent, now fraction */\n\n\tif (F->taper_mode == GMT_FFT_EXTEND_NONE) {\t/* No extension, just tapering inside the data grid */\n\t\ti_width = irint (Grid->header->n_columns * width);\t/* Interior columns over which tapering will take place */\n\t\tj_width = irint (Grid->header->n_rows * width);\t/* Extended rows over which tapering will take place */\n\t}\n\telse {\t/* We wish to extend data into the margin pads between FFT grid and data grid */\n\t\ti_width = irint (i_data_start * width);\t/* Extended columns over which tapering will take place */\n\t\tj_width = irint (j_data_start * width);\t/* Extended rows over which tapering will take place */\n\t}\n\tif (i_width == 0 && j_width == 0) one = 1;\t/* So we do nothing further down */\n\n\t/* Determine how many complex components (1 or 2) to taper, and which one(s) */\n\tstart_component = (h->complex_mode & GMT_GRID_IS_COMPLEX_REAL) ? 0 : 1;\n\tstop_component  = (h->complex_mode & GMT_GRID_IS_COMPLEX_IMAG) ? 1 : 0;\n\n\tfor (component = start_component; component <= stop_component; component++) {\t/* Loop over 1 or 2 components */\n\t\toff = component * h->size / 2;\t/* offset to start of this component in grid */\n\n\t\t/* First reflect about xmin and xmax, either point symmetric about edge point OR mirror symmetric */\n\n\t\tif (F->taper_mode != GMT_FFT_EXTEND_NONE) {\n\t\t\tfor (im = 1; im <= i_width; im++) {\n\t\t\t\til1 = -im;\t/* Outside xmin; left of edge 1  */\n\t\t\t\tir1 = im;\t/* Inside xmin; right of edge 1  */\n\t\t\t\til2 = il1 + h->n_columns - 1;\t/* Inside xmax; left of edge 2  */\n\t\t\t\tir2 = ir1 + h->n_columns - 1;\t/* Outside xmax; right of edge 2  */\n\t\t\t\tfor (ju = 0; ju < h->n_rows; ju++) {\n\t\t\t\t\tif (F->taper_mode == GMT_FFT_EXTEND_POINT_SYMMETRY) {\n\t\t\t\t\t\tdatac[gmt_M_ijp(h,ju,il1)+off] = 2.0f * datac[gmt_M_ijp(h,ju,0)+off]       - datac[gmt_M_ijp(h,ju,ir1)+off];\n\t\t\t\t\t\tdatac[gmt_M_ijp(h,ju,ir2)+off] = 2.0f * datac[gmt_M_ijp(h,ju,h->n_columns-1)+off] - datac[gmt_M_ijp(h,ju,il2)+off];\n\t\t\t\t\t}\n\t\t\t\t\telse {\t/* Mirroring */\n\t\t\t\t\t\tdatac[gmt_M_ijp(h,ju,il1)+off] = datac[gmt_M_ijp(h,ju,ir1)+off];\n\t\t\t\t\t\tdatac[gmt_M_ijp(h,ju,ir2)+off] = datac[gmt_M_ijp(h,ju,il2)+off];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Next, reflect about ymin and ymax.\n\t\t * At the same time, since x has been reflected,\n\t\t * we can use these vals and taper on y edges */\n\n\t\tscale = (gmt_grdfloat)(M_PI / (j_width + 1));\t/* Full 2*pi over y taper range */\n\t\tmin_i = (F->taper_mode == GMT_FFT_EXTEND_NONE) ? 0 : -i_width;\n\t\tend_i = (F->taper_mode == GMT_FFT_EXTEND_NONE) ? (int)Grid->header->n_columns : mx - i_width;\n\t\tfor (jm = one; jm <= j_width; jm++) {\t/* Loop over width of strip to taper */\n\t\t\tjb1 = -jm;\t/* Outside ymin; bottom side of edge 1  */\n\t\t\tjt1 = jm;\t/* Inside ymin; top side of edge 1  */\n\t\t\tjb2 = jb1 + h->n_rows - 1;\t/* Inside ymax; bottom side of edge 2  */\n\t\t\tjt2 = jt1 + h->n_rows - 1;\t/* Outside ymax; bottom side of edge 2  */\n\t\t\tcos_wt = 0.5f * (1.0f + cosf (jm * scale));\n\t\t\tif (F->taper_mode == GMT_FFT_EXTEND_NONE) cos_wt = 1.0f - cos_wt;\t/* Reverse weights for the interior */\n\t\t\tfor (i = min_i; i < end_i; i++) {\n\t\t\t\tif (F->taper_mode == GMT_FFT_EXTEND_POINT_SYMMETRY) {\n\t\t\t\t\tdatac[gmt_M_ijp(h,jb1,i)+off] = cos_wt * (2.0f * datac[gmt_M_ijp(h,0,i)+off]       - datac[gmt_M_ijp(h,jt1,i)+off]);\n\t\t\t\t\tdatac[gmt_M_ijp(h,jt2,i)+off] = cos_wt * (2.0f * datac[gmt_M_ijp(h,h->n_rows-1,i)+off] - datac[gmt_M_ijp(h,jb2,i)+off]);\n\t\t\t\t}\n\t\t\t\telse if (F->taper_mode == GMT_FFT_EXTEND_MIRROR_SYMMETRY) {\n\t\t\t\t\tdatac[gmt_M_ijp(h,jb1,i)+off] = cos_wt * datac[gmt_M_ijp(h,jt1,i)+off];\n\t\t\t\t\tdatac[gmt_M_ijp(h,jt2,i)+off] = cos_wt * datac[gmt_M_ijp(h,jb2,i)+off];\n\t\t\t\t}\n\t\t\t\telse {\t/* Interior tapering only */\n\t\t\t\t\tdatac[gmt_M_ijp(h,jt1,i)+off] *= cos_wt;\n\t\t\t\t\tdatac[gmt_M_ijp(h,jb2,i)+off] *= cos_wt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Now, cos taper the x edges */\n\t\tscale = (gmt_grdfloat)(M_PI / (i_width + 1));\t/* Full 2*pi over x taper range */\n\t\tend_j = (F->taper_mode == GMT_FFT_EXTEND_NONE) ? h->n_rows : h->my - j_data_start;\n\t\tmin_j = (F->taper_mode == GMT_FFT_EXTEND_NONE) ? 0 : -j_width;\n\t\tfor (im = one; im <= i_width; im++) {\n\t\t\til1 = -im;\n\t\t\tir1 = im;\n\t\t\til2 = il1 + h->n_columns - 1;\n\t\t\tir2 = ir1 + h->n_columns - 1;\n\t\t\tcos_wt = (gmt_grdfloat)(0.5f * (1.0f + cosf (im * scale)));\n\t\t\tif (F->taper_mode == GMT_FFT_EXTEND_NONE) cos_wt = 1.0f - cos_wt;\t/* Switch to weights for the interior */\n\t\t\tfor (j = min_j; j < end_j; j++) {\n\t\t\t\tif (F->taper_mode == GMT_FFT_EXTEND_NONE) {\n\t\t\t\t\tdatac[gmt_M_ijp(h,j,ir1)+off] *= cos_wt;\n\t\t\t\t\tdatac[gmt_M_ijp(h,j,il2)+off] *= cos_wt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdatac[gmt_M_ijp(h,j,il1)+off] *= cos_wt;\n\t\t\t\t\tdatac[gmt_M_ijp(h,j,ir2)+off] *= cos_wt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (F->taper_mode == GMT_FFT_EXTEND_NONE)\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_INFORMATION, \"Grid margin (%s component) tapered to zero over %d %% of data width and height\\n\", comp[component], width_percent);\n\t\telse\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_INFORMATION, \"Grid (%s component) extended via %s symmetry at all edges, then tapered to zero over %d %% of extended area\\n\", comp[component], method[F->taper_mode], width_percent);\n\t}\n}\n\n/*! . */\nGMT_LOCAL struct GMT_FFT_WAVENUMBER * gmtapi_fft_init_2d (struct GMTAPI_CTRL *API, struct GMT_GRID *G, unsigned int mode, void *v_info) {\n\t/* Initialize grid dimensions for FFT machinery and set up wavenumbers */\n\tunsigned int k, factors[32];\n\tuint64_t node;\n\tsize_t worksize;\n\tbool stop;\n\tdouble tdummy, edummy;\n\tstruct GMT_FFT_SUGGESTION fft_sug[GMT_FFT_N_SUGGEST];\n\tstruct GMT_FFT_INFO *F = NULL, *F_in = gmtapi_get_fftinfo_ptr (v_info);\n\tstruct GMT_FFT_WAVENUMBER *K = NULL;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (API == NULL) return_null (API, GMT_NOT_A_SESSION);\n\tif (G == NULL) return_null (API, GMT_ARG_IS_NULL);\n\tHH = gmt_get_H_hidden (G->header);\n\tGMT = API->GMT;\n\tK = gmt_M_memory (GMT, NULL, 1, struct GMT_FFT_WAVENUMBER);\n\n\tF = gmt_M_memory (GMT, NULL, 1, struct GMT_FFT_INFO);\n\tif (F_in) {\t/* User specified -N so default settings should take effect */\n\t\tgmt_M_memcpy (F, F_in, 1, struct GMT_FFT_INFO);\n\t\tif (F->K) GMT_Report (API, GMT_MSG_DEBUG, \"F->K already set; investigate.\\n\");\n\t}\n\tif (!F->set || F->info_mode == GMT_FFT_UNSPECIFIED) {\t/* User is accepting the default values of extend via edge-point symmetry over 100% of margin */\n\t\tF->info_mode = GMT_FFT_EXTEND_POINT_SYMMETRY;\n\t\tF->taper_width = 100.0;\n\t\tif (!F->set) F->suggest = GMT_FFT_N_SUGGEST;\n\t\tF->set = true;\n\t}\n\n\t/* Get dimensions as may be appropriate */\n\tif (F->info_mode == GMT_FFT_SET) {\t/* User specified the n_columns/n_rows dimensions */\n\t\tif (F->n_columns < G->header->n_columns || F->n_rows < G->header->n_rows) {\n\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"You specified a FFT n_columns/n_rows smaller than input grid.  Ignored.\\n\");\n\t\t\tF->info_mode = GMT_FFT_EXTEND;\n\t\t}\n\t}\n\n\tif (F->info_mode != GMT_FFT_SET) {\t/* Either adjust, force, inquiery */\n\t\tif (F->info_mode == GMT_FFT_FORCE) {\n\t\t\tF->n_columns = G->header->n_columns;\n\t\t\tF->n_rows = G->header->n_rows;\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Selected FFT dimensions == Grid dimensions.\\n\");\n\t\t}\n\t\telse {\t/* Determine best FFT dimensions */\n\t\t\tunsigned int pick;\n\t\t\tchar *mode[GMT_FFT_N_SUGGEST] = {\"fastest\", \"most accurate\", \"least storage\"};\n\t\t\tgmtlib_suggest_fft_dim (GMT, G->header->n_columns, G->header->n_rows, fft_sug, (gmt_M_is_verbose (GMT, GMT_MSG_WARNING) || F->verbose));\n\t\t\tif (F->suggest == GMT_FFT_N_SUGGEST) {\t/* Must choose smallest of accurate and fast */\n\t\t\t\tpick = (fft_sug[GMT_FFT_ACCURATE].totalbytes < fft_sug[GMT_FFT_FAST].totalbytes) ? GMT_FFT_ACCURATE : GMT_FFT_FAST;\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Selected FFT dimensions for the overall best solution (%s).\\n\", mode[pick]);\n\t\t\t}\n\t\t\telse {\t/* Pick the one we selected up front */\n\t\t\t\tpick = F->suggest;\n\t\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Selected FFT dimensions for the %s solution.\\n\", mode[pick]);\n\t\t\t}\n\t\t\tF->n_columns = fft_sug[pick].n_columns;\n\t\t\tF->n_rows    = fft_sug[pick].n_rows;\n\t\t}\n\t}\n\n\t/* Because we taper and reflect below we DO NOT want any BCs set since that code expects 2 BC rows/cols */\n\tfor (k = 0; k < 4; k++) HH->BC[k] = GMT_BC_IS_DATA;\n\n\t/* Get here when F->n_columns and F->n_rows are set to the values we will use.  */\n\n\tgmtlib_fourt_stats (GMT, F->n_columns, F->n_rows, factors, &edummy, &worksize, &tdummy);\n\tGMT_Report (API, GMT_MSG_INFORMATION, \"Grid dimensions (n_rows by n_columns): %d x %d\\tFFT dimensions: %d x %d\\n\", G->header->n_rows, G->header->n_columns, F->n_rows, F->n_columns);\n\n\t/* Put the data in the middle of the padded array */\n\n\tGMT->current.io.pad[XLO] = (F->n_columns - G->header->n_columns) / 2;\t/* zero if n_columns < G->header->n_columns+1  */\n\tGMT->current.io.pad[YHI] = (F->n_rows - G->header->n_rows) / 2;\n\tGMT->current.io.pad[XHI] = F->n_columns - G->header->n_columns - GMT->current.io.pad[XLO];\n\tGMT->current.io.pad[YLO] = F->n_rows - G->header->n_rows - GMT->current.io.pad[YHI];\n\n\t/* Precompute wavenumber increments and initialize the GMT_FFT machinery */\n\n\tK->delta_kx = 2.0 * M_PI / (F->n_columns * G->header->inc[GMT_X]);\n\tK->delta_ky = 2.0 * M_PI / (F->n_rows * G->header->inc[GMT_Y]);\n\tK->nx2 = F->n_columns;\tK->ny2 = F->n_rows;\n\n\tif (gmt_M_is_geographic (GMT, GMT_IN)) {\t/* Give delta_kx, delta_ky units of 2pi/meters via Flat Earth assumption  */\n\t\tK->delta_kx /= (GMT->current.proj.DIST_M_PR_DEG * cosd (0.5 * (G->header->wesn[YLO] + G->header->wesn[YHI])));\n\t\tK->delta_ky /= GMT->current.proj.DIST_M_PR_DEG;\n\t}\n\n\tgmt_fft_set_wave (GMT, GMT_FFT_K_IS_KR, K);\t/* Initialize for use with radial wavenumbers */\n\n\tF->K = K;\t/* So that F can access information in K later */\n\tK->info = F;\t/* So K can have access to information in F later */\n\n\t/* Read in the data or change pad to match the nx2/ny2 determined */\n\n\tif (G->data) {\t/* User already read the data, check padding and possibly extend it */\n\t\tif (G->header->complex_mode == 0) {\t/* Grid was not read in interleaved, must do so now */\n\t\t\t/* Because of no realloc for aligned memory we must do it the hard way */\n\t\t\tgmt_grdfloat *f = NULL;\n\t\t\tsize_t new_size = 2 * G->header->size;\n\t\t\tGMT_Report (API, GMT_MSG_INFORMATION, \"Must double memory and multiplex external grid before we can do FFT\\n\", HH->name);\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_INFORMATION, \"Extend grid via copy onto larger memory-aligned grid\\n\");\n\t\t\tf = gmt_M_memory_aligned (GMT, NULL, new_size, gmt_grdfloat);\t/* New, larger grid size */\n\t\t\tgmt_M_memcpy (f, G->data, G->header->size, gmt_grdfloat);\t/* Copy over previous grid values */\n\t\t\tgmt_M_free_aligned (GMT, G->data);\t\t\t/* Free previous aligned grid memory */\n\t\t\tG->data = f;\t\t\t\t\t\t/* Attach the new, larger aligned memory */\n\t\t\tG->header->complex_mode = GMT_GRID_IS_COMPLEX_REAL;\t/* Flag as complex grid with real components only */\n\t\t\tG->header->size = new_size;\t\t\t\t\t/* Update the size of complex grid */\n\t\t}\n\t\tif (!(G->header->mx == F->n_columns && G->header->my == F->n_rows)) {\t/* Must re-pad, possibly re-allocate the grid */\n\t\t\tgmt_grd_pad_on (GMT, G, GMT->current.io.pad);\n\t\t}\n\t}\n\telse {\t/* Read the data into a grid of approved dimension */\n\t\tG->header->mx = G->header->n_columns;\tG->header->my = G->header->n_rows;\t/* Undo misleading padding since we have not read the data yet and GMT pad has changed above */\n\t\tif (GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY | mode, NULL, HH->name, G) == NULL)\t/* Get data only */\n\t\t\treturn (NULL);\n\t}\n#ifdef DEBUG\n\tgmt_grd_dump (G->header, G->data, mode & GMT_GRID_IS_COMPLEX_MASK, \"Read in FFT_Create\");\n#endif\n\t/* Make sure there are no NaNs in the grid - that is a fatal flaw */\n\n\tfor (node = 0, stop = false; !stop && node < G->header->size; node++) stop = gmt_M_is_fnan (G->data[node]);\n\tif (stop) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Input grid %s contain NaNs, cannot do FFT!\\n\", HH->name);\n\t\treturn (NULL);\n\t}\n\n\tif (F->trend_mode == GMT_FFT_REMOVE_NOT_SET) F->trend_mode = GMT_FFT_REMOVE_NOTHING;\t/* Delayed default */\n\tgmt_grd_detrend (GMT, G, F->trend_mode, K->coeff);\t/* Detrend data, if requested */\n#ifdef DEBUG\n\tgmt_grd_dump (G->header, G->data, mode & GMT_GRID_IS_COMPLEX_MASK, \"After detrend\");\n#endif\n\tgmtapi_fft_taper2d (GMT, G, F);\t\t\t\t/* Taper data, if requested */\n#ifdef DEBUG\n\tgmt_grd_dump (G->header, G->data, mode & GMT_GRID_IS_COMPLEX_MASK, \"After Taper\");\n#endif\n\tK->dim = 2;\t/* 2-D FFT */\n\treturn (K);\n}\n\n/*! . */\nvoid * GMT_FFT_Create (void *V_API, void *X, unsigned int dim, unsigned int mode, void *v_info) {\n\t/* Initialize 1-D or 2-D FFT machinery and set up wavenumbers */\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (dim == 1) return (gmtapi_fft_init_1d (V_API, X, mode, v_info));\n\tif (dim == 2) return (gmtapi_fft_init_2d (V_API, X, mode, v_info));\n\tGMT_Report (V_API, GMT_MSG_ERROR, \"GMT FFT only supports dimensions 1 and 2, not %u\\n\", dim);\n\treturn_null (V_API, (dim == 0) ? GMT_DIM_TOO_SMALL : GMT_DIM_TOO_LARGE);\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_FFT_Create_ (void *X, unsigned int *dim, unsigned int *mode, void *v_info) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_Create (GMT_FORTRAN, X, *dim, *mode, v_info));\n}\n#endif\n\n/*! . */\nGMT_LOCAL int gmtapi_fft_1d (struct GMTAPI_CTRL *API, struct GMT_DATASET *D, int direction, unsigned int mode, struct GMT_FFT_WAVENUMBER *K) {\n\t/* The 1-D FFT operating on DATASET segments */\n\tint status = 0;\n\tuint64_t seg, row, tbl, last = 0, col = 0;\n\tgmt_grdfloat *data = NULL;\n\tstruct GMT_DATASEGMENT *S = NULL;\n\tgmt_M_unused(K);\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\t/* Not at all finished; will require gmtfft.c to be developed and tested */\n\tfor (tbl = 0; tbl < D->n_tables; tbl++) {\n\t\tfor (seg = 0; seg < D->table[tbl]->n_segments; seg++) {\n\t\t\tS = D->table[tbl]->segment[seg];\n\t\t\tif (S->n_rows > last) {\t/* Extend array */\n\t\t\t\tdata = gmt_M_memory (API->GMT, data, S->n_rows, gmt_grdfloat);\n\t\t\t\tlast = S->n_rows;\n\t\t\t}\n\t\t\tfor (row = 0; S->n_rows; row++) data[row] = (gmt_grdfloat)S->data[col][row];\n\t\t\tstatus = GMT_FFT_1D (API, data, S->n_rows, direction, mode);\n\t\t\tfor (row = 0; S->n_rows; row++) S->data[col][row] = data[row];\n\t\t}\n\t}\n\tgmt_M_free (API->GMT, data);\n\treturn (status);\n}\n\nGMT_LOCAL char * gmtapi_fft_file_name_with_suffix (struct GMT_CTRL *GMT, char *name, char *suffix) {\n\tstatic char file[PATH_MAX] = {\"\"};\n\tuint64_t i, j;\n\tsize_t len;\n\n\tif ((len = strlen (name)) == 0) {\t/* Grids that are being created have no filename yet */\n\t\tsnprintf (file, PATH_MAX, \"tmpgrid_%s.grd\", suffix);\n\t\tGMT_Report (GMT->parent, GMT_MSG_WARNING, \"Created grid has no name to derive new names from; choose %s\\n\", file);\n\t\treturn (file);\n\t}\n\tfor (i = len; i > 0 && !(name[i] == '/' || name[i] == '\\\\'); i--);\t/* i points to 1st char in name after slash, or 0 if no leading dirs */\n\tif (i) i++;\t/* Move to 1st char after / */\n\tfor (j = len; j > 0 && name[j] != '.'; j--);\t/* j points to period before extension, or it is 0 if no extension */\n\tlen = strlen (&name[i]);\n\tstrncpy (file, &name[i], PATH_MAX-1);\t\t/* Make a full copy of filename without leading directories */\n\tfor (i = len; i > 0 && file[i] != '.'; i--);\t/* i now points to period before extension in file, or it is 0 if no extension */\n\tif (i) file[i] = '\\0';\t/* Truncate at the extension */\n\t/* Determine length of new filename and make sure it fits */\n\tlen = strlen (file);\n\tif (j) len += strlen (&name[j]);\n\tlen += (1 + strlen(suffix));\n\tif ((GMT_BUFSIZ - len) > 0) {\t/* Have enough space */\n\t\tstrcat (file, \"_\");\n\t\tstrcat (file, suffix);\n\t\tif (j) strncat (file, &name[j], PATH_MAX-1);\n\t}\n\telse\n\t\tGMT_Report (GMT->parent, GMT_MSG_WARNING, \"File name [ %s] way too long - trouble in gmtapi_fft_file_name_with_suffix\\n\", file);\n\treturn (file);\n}\n\nGMT_LOCAL void gmtapi_fft_grd_save_taper (struct GMT_CTRL *GMT, struct GMT_GRID *Grid, char *suffix) {\n\t/* Write the intermediate grid that will be passed to the FFT to file.\n\t * This grid may have been a mean, mid-value, or plane removed, may\n\t * have data filled into an extended margin, and may have been taperer.\n\t * Normally, the complex grid will be in serial layout, but just in case\n\t * we check and add a demux step if required.  The FFT will also check\n\t * and multiplex the grid (again) if needed.\n\t */\n\tunsigned int pad[4];\n\tstruct GMT_GRID_HEADER *save = gmt_get_header (GMT);\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = gmt_get_H_hidden (Grid->header);\n\tchar *file = NULL;\n\n\tif (HH->arrangement == GMT_GRID_IS_INTERLEAVED) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_INFORMATION, \"Demultiplexing complex grid before saving can take place.\\n\");\n\t\tgmt_grd_mux_demux (GMT, Grid->header, Grid->data, GMT_GRID_IS_SERIAL);\n\t}\n\tgmt_copy_gridheader (GMT, save, Grid->header);\n\tgmt_M_memcpy (pad, Grid->header->pad, 4U, unsigned int);\t\t/* Save current pad, then set pad to zero */\n\t/* Extend w/e/s/n to what it would be if the pad was not present */\n\tGrid->header->wesn[XLO] -= Grid->header->pad[XLO] * Grid->header->inc[GMT_X];\n\tGrid->header->wesn[XHI] += Grid->header->pad[XHI] * Grid->header->inc[GMT_X];\n\tGrid->header->wesn[YLO] -= Grid->header->pad[YLO] * Grid->header->inc[GMT_Y];\n\tGrid->header->wesn[YHI] += Grid->header->pad[YHI] * Grid->header->inc[GMT_Y];\n\tgmt_M_memset (Grid->header->pad,   4U, unsigned int);\t/* Set header pad to {0,0,0,0} */\n\tgmt_M_memset (GMT->current.io.pad, 4U, unsigned int);\t/* set GMT default pad to {0,0,0,0} */\n\tgmt_set_grddim (GMT, Grid->header);\t/* Recompute all dimensions */\n\tif ((file = gmtapi_fft_file_name_with_suffix (GMT, HH->name, suffix)) == NULL) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Unable to get file name for file %s\\n\", HH->name);\n\t\treturn;\n\t}\n\n\tif (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY | GMT_GRID_IS_COMPLEX_REAL, NULL, file, Grid) != GMT_NOERROR)\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Intermediate detrended, extended, and tapered grid could not be written to %s\\n\", file);\n\telse\n\t\tGMT_Report (GMT->parent, GMT_MSG_INFORMATION, \"Intermediate detrended, extended, and tapered grid written to %s\\n\", file);\n\n\tgmt_copy_gridheader (GMT, Grid->header, save);\t/* Restore original, including the original pad */\n\tgmt_M_memcpy (GMT->current.io.pad, pad, 4U, unsigned int);\t/* Restore GMT default pad */\n\tgmt_M_free (GMT, save->hidden);\n\tgmt_M_free (GMT, save);\n}\n\nGMT_LOCAL void gmtapi_fft_grd_save_fft (struct GMT_CTRL *GMT, struct GMT_GRID *G, struct GMT_FFT_INFO *F) {\n\t/* Save the raw spectrum as two files (real,imag) or (mag,phase), depending on mode.\n\t * We must first do an \"fftshift\" operation as in Matlab, to put the 0 frequency\n\t * value in the center of the grid. */\n\tuint64_t i_ij, o_ij,  offset;\n\tint row_in, col_in, row_out, col_out, nx_2, ny_2;\n\tsize_t len;\n\tunsigned int k, pad[4], mode, wmode[2] = {GMT_GRID_IS_COMPLEX_REAL, GMT_GRID_IS_COMPLEX_IMAG};\n\tdouble wesn[6], inc[2];\n\tgmt_grdfloat re, im, i_scale;\n\tchar *file = NULL, *suffix[2][2] = {{\"real\", \"imag\"}, {\"mag\", \"phase\"}};\n\tstruct GMT_GRID *Out = NULL;\n\tstruct GMT_GRID_HEADER_HIDDEN *HH = gmt_get_H_hidden (G->header);\n\tstruct GMT_FFT_WAVENUMBER *K = F->K;\n\n\tif (K == NULL) return;\n\n\tmode = (F->polar) ? 1 : 0;\n\n\tGMT_Report (GMT->parent, GMT_MSG_INFORMATION, \"Write components of complex raw spectrum with file suffix %s and %s\\n\", suffix[mode][0], suffix[mode][1]);\n\n\tif (HH->arrangement == GMT_GRID_IS_SERIAL) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Cannot save complex grid unless it is interleaved.\\n\");\n\t\treturn;\n\t}\n\t/* Prepare wavenumber domain limits and increments */\n\tnx_2 = K->nx2 / 2;\tny_2 = K->ny2 / 2;\n\twesn[XLO] = -K->delta_kx * nx_2;\twesn[XHI] =  K->delta_kx * (nx_2 - 1);\n\twesn[YLO] = -K->delta_ky * (ny_2 - 1);\twesn[YHI] =  K->delta_ky * ny_2;\n\tinc[GMT_X] = K->delta_kx;\t\tinc[GMT_Y] = K->delta_ky;\n\tgmt_M_memcpy (pad, GMT->current.io.pad, 4U, unsigned int);\t/* Save current GMT pad */\n\tfor (k = 0; k < 4; k++) GMT->current.io.pad[k] = 0;\t\t/* No pad is what we need for this application */\n\n\t/* Set up and allocate the temporary grid which is always gridline registered. */\n\tif ((Out = GMT_Create_Data (GMT->parent, GMT_IS_GRID, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA | GMT_GRID_IS_COMPLEX_MASK,\n\t                            NULL, wesn, inc, GMT_GRID_NODE_REG, 0, NULL)) == NULL) {\t/* Note: 0 for pad since no BC work needed for this temporary grid */\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Unable to create complex output grid for %s\\n\", HH->name);\n\t\treturn;\n\t}\n\n\tstrcpy (Out->header->x_units, \"xunit^(-1)\");\tstrcpy (Out->header->y_units, \"yunit^(-1)\");\n\tstrcpy (Out->header->z_units, G->header->z_units);\n\tstrcpy (Out->header->remark, \"Applied fftshift: kx,ky = (0,0) now at (n_columns/2 + 1,n_rows/2\");\n\n\toffset = Out->header->size / 2;\n\ti_scale = (gmt_grdfloat)(1.0  / Out->header->nm);\n\tfor (row_in = 0; row_in < K->ny2; row_in++) {\n\t\trow_out = (row_in + ny_2) % K->ny2;\n\t\tfor (col_in = 0; col_in < K->nx2; col_in++) {\n\t\t\tcol_out = (col_in + nx_2) % K->nx2;\n\t\t\to_ij = gmt_M_ij0 (Out->header, row_out, col_out);\n\t\t\ti_ij = 2 * gmt_M_ij0 (G->header,   row_in,  col_in);\n\t\t\tre = G->data[i_ij] * i_scale; im = G->data[i_ij+1] * i_scale;\n\t\t\tif (F->polar) {\t/* Want magnitude and phase */\n\t\t\t\tOut->data[o_ij]   = (gmt_grdfloat)hypot (re, im);\n\t\t\t\tOut->data[o_ij+offset] = (gmt_grdfloat)d_atan2 (im, re);\n\t\t\t}\n\t\t\telse {\t\t/* Retain real and imag components as is */\n\t\t\t\tOut->data[o_ij] = re;\tOut->data[o_ij+offset] = im;\n\t\t\t}\n\t\t}\n\t}\n\tfor (k = 0; k < 2; k++) {\t/* Write the two grids */\n\t\tif ((file = gmtapi_fft_file_name_with_suffix (GMT, HH->name, suffix[mode][k])) == NULL) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Unable to get file name for file %s\\n\", HH->name);\n\t\t\treturn;\n\t\t}\n\t\tOut->header->complex_mode = wmode[k];\n\t\tfor (len = strlen (HH->name); len > 0 && !(HH->name[len-1] == '/' || HH->name[len-1] == '\\\\'); len--);\t/* Find start of file name minus any leading directories */\n\t\tsnprintf (Out->header->title, GMT_GRID_TITLE_LEN80, \"The %s part of FFT transformed grid %s\", suffix[mode][k], &HH->name[len]);\n\t\tif (k == 1 && mode) strcpy (Out->header->z_units, \"radians\");\n\t\tif (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA | wmode[k], NULL, file, Out) != GMT_NOERROR) {\n\t\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"%s could not be written\\n\", file);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (GMT_Destroy_Data (GMT->parent, &Out) != GMT_NOERROR) {\n\t\tGMT_Report (GMT->parent, GMT_MSG_ERROR, \"Failure while freeing temporary grid\\n\");\n\t}\n\n\tgmt_M_memcpy (GMT->current.io.pad, pad, 4U, unsigned int);\t/* Restore GMT pad */\n}\n\nGMT_LOCAL void gmtapi_fft_save2d (struct GMT_CTRL *GMT, struct GMT_GRID *G, unsigned int direction, struct GMT_FFT_WAVENUMBER *K) {\n\t/* Handle the writing of the grid going into the FFT and comping out of the FFT, per F settings */\n\n\tif (G == NULL || (K == NULL ||  K->info == NULL)) return;\n\tif (direction == GMT_IN  && K->info->save[GMT_IN])  gmtapi_fft_grd_save_taper (GMT, G, K->info->suffix);\n\tif (direction == GMT_OUT && K->info->save[GMT_OUT]) gmtapi_fft_grd_save_fft (GMT, G, K->info);\n}\n\n/*! . */\nGMT_LOCAL int gmtapi_fft_2d (struct GMTAPI_CTRL *API, struct GMT_GRID *G, int direction, unsigned int mode, struct GMT_FFT_WAVENUMBER *K) {\n\t/* The 2-D FFT operating on GMT_GRID arrays */\n\tint status;\n\tif (K && direction == GMT_FFT_FWD) gmtapi_fft_save2d (API->GMT, G, GMT_IN, K);\t/* Save intermediate grid, if requested, before interleaving */\n\tgmt_grd_mux_demux (API->GMT, G->header, G->data, GMT_GRID_IS_INTERLEAVED);\n#ifdef DEBUG\n\tgmt_grd_dump (G->header, G->data, true, \"After demux\");\n#endif\n\tstatus = GMT_FFT_2D (API, G->data, G->header->mx, G->header->my, direction, mode);\n#ifdef DEBUG\n\tgmt_grd_dump (G->header, G->data, true, \"After FFT\");\n#endif\n\tif (K && direction == GMT_FFT_FWD) gmtapi_fft_save2d (API->GMT, G, GMT_OUT, K);\t/* Save complex grid, if requested */\n\treturn (status);\n}\n\n/*! . */\nint GMT_FFT (void *V_API, void *X, int direction, unsigned int mode, void *v_K) {\n\t/* The 1-D or 2-D FFT operating on GMT_DATASET or GMT_GRID arrays */\n\tstruct GMT_FFT_WAVENUMBER *K = gmtapi_get_fftwave_ptr (v_K);\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (K->dim == 2) return (gmtapi_fft_2d (V_API, X, direction, mode, K));\n\telse return (gmtapi_fft_1d (V_API, X, direction, mode, K));\n}\n\n#ifdef FORTRAN_API\nint GMT_FFT_ (void *X, int *direction, unsigned int *mode, void *v_K) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT (GMT_FORTRAN, X, *direction, *mode, v_K));\n}\n#endif\n\n/*! . */\nint GMT_FFT_Destroy (void *V_API, void *v_info) {\n\t/* Perform any final duties, perhaps report.  For now just free */\n\tstruct GMT_FFT_WAVENUMBER **K = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tK = gmtapi_get_fftwave_addr (v_info);\n\tgmt_M_free (API->GMT, (*K)->info);\n\tgmt_M_free (API->GMT, (*K));\n\treturn_error (V_API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_FFT_Destroy_ (void *v_K) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_Destroy (GMT_FORTRAN, v_K));\n}\n#endif\n\n/*! Pretty print core module names and purposes */\nconst char * gmt_show_name_and_purpose (void *V_API, const char *component, const char *name, const char *purpose) {\n\tchar message[GMT_LEN256] = {\"\"};\n\tstatic char full_name[GMT_LEN32] = {\"\"};\n\tconst char *lib = NULL, *mode_name = name;\n\tstatic char *core = \"core\";\n\tstruct GMTAPI_CTRL *API = NULL;\n\tassert (V_API != NULL);\n\tassert (name != NULL);\n\tassert (purpose != NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tmode_name = gmtlib_get_active_name (API, name);\n\tlib = (component) ? component : core;\n\tsnprintf (full_name, GMT_LEN32, \"gmt %s\", mode_name);\n\tsnprintf (message, GMT_LEN256, \"%s [%s] %s - %s\\n\\n\", full_name, lib, GMT_version(), purpose);\n\tGMT_Message (V_API, GMT_TIME_NONE, message);\n\tgmtlib_set_KOP_strings (API);\n\treturn full_name;\n}\n\n/* Module Extension: Allow listing and calling modules by name */\n\n/*! . */\nGMT_LOCAL void * gmtapi_get_shared_module_func (struct GMTAPI_CTRL *API, const char *module, unsigned int lib_no) {\n\t/* Function that returns a pointer to the function named module in specified shared library lib_no, or NULL if not found  */\n\tvoid *p_func = NULL;       /* function pointer */\n\tif (API->lib[lib_no].skip) return (NULL);\t/* Tried to open this shared library before and it was not available */\n\tif (API->lib[lib_no].handle == NULL && (API->lib[lib_no].handle = dlopen (API->lib[lib_no].path, RTLD_LAZY)) == NULL) {\t/* Not opened this shared library yet */\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to open GMT shared %s library: %s\\n\", API->lib[lib_no].name, dlerror());\n\t\tAPI->lib[lib_no].skip = true;\t/* Not bother the next time... */\n\t\treturn (NULL);\t\t\t/* ...and obviously no function would be found */\n\t}\n\t/* Here the library handle is available; try to get pointer to specified module */\n\t*(void **) (&p_func) = dlsym (API->lib[lib_no].handle, module);\n\treturn (p_func);\n}\n\n/*! . */\nGMT_LOCAL void * gmtapi_get_module_func (struct GMTAPI_CTRL *API, const char *module, unsigned int lib_no) {\n\treturn (gmtapi_get_shared_module_func (API, module, lib_no));\n}\n\n/*! . */\nint GMT_Call_Module (void *V_API, const char *module, int mode, void *args) {\n\t/* Call the specified shared module and pass it the mode and args.\n \t * mode can be one of the following:\n\t * GMT_MODULE_CLASSIC [-7]:\tAs GMT_MODULE_PURPOSE, but only lists the classic modules.\n\t * GMT_MODULE_LIST [-6]:\tAs GMT_MODULE_PURPOSE, but only lists the modern modules.\n\t * GMT_MODULE_CLASSIC_CORE [-5]:\tAs GMT_MODULE_PURPOSE, but only lists the classic modules (core only).\n\t * GMT_MODULE_LIST_CORE [-4]:\tAs GMT_MODULE_PURPOSE, but only lists the modern modules (core only).\n\t * GMT_MODULE_EXIST [-3]:\tReturn GMT_NOERROR (0) if module exists, GMT_NOT_A_VALID_MODULE otherwise.\n\t * GMT_MODULE_PURPOSE [-2]:\tAs GMT_MODULE_EXIST, but also print the module purpose.\n\t * GMT_MODULE_OPT [-1]:\t\tArgs is a linked list of option structures.\n\t * GMT_MODULE_CMD [0]:\t\tArgs is a single textstring with multiple options\n\t * mode > 0:\t\t\t\tArgs is an array of text strings (e.g., argv[]).\n\t */\n\tint status = GMT_NOERROR;\n\tunsigned int lib;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar gmt_module[GMT_LEN64] = \"GMT_\";\n\tint (*p_func)(void*, int, void*) = NULL;       /* function pointer */\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (module == NULL && !(mode == GMT_MODULE_LIST || mode == GMT_MODULE_LIST_CORE || mode == GMT_MODULE_CLASSIC || mode == GMT_MODULE_CLASSIC_CORE || mode == GMT_MODULE_PURPOSE))\n\t\treturn_error (V_API, GMT_ARG_IS_NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tif (module == NULL) {\t/* Did not specify any specific module, so list purpose of all modules in all shared libs */\n\t\tchar gmt_module[GMT_LEN256] = {\"\"};\t/* To form name of gmt_<lib>_module_show|list_all function */\n\t\tchar *listfunc = (mode == GMT_MODULE_LIST || mode == GMT_MODULE_LIST_CORE) ? \"list\" : ( (mode == GMT_MODULE_CLASSIC || mode == GMT_MODULE_CLASSIC_CORE) ? \"classic\" : \"show\");\n\t\tvoid (*l_func)(void*);       /* function pointer to gmt_<lib>_module_show|list_all which takes one arg (the API) */\n\t\tunsigned int n_libs = (mode == GMT_MODULE_LIST_CORE || mode == GMT_MODULE_CLASSIC_CORE) ? 1 : API->n_shared_libs;\n\t\t/* Here we list purpose of all the available modules in each shared library */\n\t\tfor (lib = 0; lib < n_libs; lib++) {\n\t\t\tsnprintf (gmt_module, GMT_LEN64, \"%s_module_%s_all\", API->lib[lib].name, listfunc);\n\t\t\t*(void **) (&l_func) = gmtapi_get_module_func (API, gmt_module, lib);\n\t\t\tif (l_func == NULL) continue;\t/* Not found in this shared library */\n\t\t\t(*l_func) (V_API);\t/* Run this function */\n\t\t}\n\t\treturn (status);\n\t}\n\n\t/* Here we call a named module */\n\n\tstrncat (gmt_module, module, GMT_LEN64-5);\t\t/* Concatenate GMT_-prefix and module name to get function name */\n\tfor (lib = 0; lib < API->n_shared_libs; lib++) {\t/* Look for gmt_module in any of the shared libs */\n\t\t*(void **) (&p_func) = gmtapi_get_module_func (API, gmt_module, lib);\n\t\tif (p_func) break;\t/* Found it in this shared library */\n\t}\n\tif (p_func == NULL) {\t/* Not in any of the shared libraries */\n\t\tstatus = GMT_NOT_A_VALID_MODULE;\t/* Most likely, but we will try again: */\n\t\tif (strncasecmp (module, \"gmt\", 3)) {\t/* For any module not already starting with \"gmt...\" */\n\t\t\tchar gmt_module[GMT_LEN64] = \"gmt\";\n\t\t\tstrncat (gmt_module, module, GMT_LEN64-4);\t/* Prepend \"gmt\" to module and try again */\n\t\t\tstatus = GMT_Call_Module (V_API, gmt_module, mode, args);\t/* Recursive call to try with the 'gmt' prefix this time */\n\t\t}\n\t}\n\telse if (mode == GMT_MODULE_EXIST)\t/* Just wanted to know it is a valid module */\n\t\treturn (GMT_NOERROR);\n\telse {\t/* Call the function and pass back its return value */\n\t\tgmt_manage_workflow (API, GMT_USE_WORKFLOW, NULL);\t\t/* First detect and set modern mode if modern mode session dir is found */\n\t\tgmtapi_check_for_modern_oneliner (API, module, mode, args);\t/* If a modern mode one-liner we must switch run--mode here */\n\t\tif (API->external && gmt_M_is_verbose (API->GMT, GMT_MSG_DEBUG)) {\n\t\t\t/* For externals only, print the equivalent command-line string under -Vd */\n\t\t\tchar *text = (mode == GMT_MODULE_OPT) ? GMT_Create_Cmd (API, args) : args;\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Call_Command string: %s %s\\n\", module, text);\n\t\t\tif (mode == GMT_MODULE_OPT) GMT_Destroy_Cmd (API, &text);\n\t\t}\n\t\tstatus = (*p_func) (V_API, mode, args);\t\t\t\t/* Call the module in peace */\n\t}\n\treturn (status);\n}\n\n#ifdef FORTRAN_API\nint GMT_Call_Module_ (const char *module, int *mode, void *args, int *length) {\n\treturn (GMT_Call_Module (GMT_FORTRAN, module, *mode, args));\n}\n#endif\n\n/*! . */\nGMT_LOCAL const char *gmtapi_get_shared_module_keys (struct GMTAPI_CTRL *API, char *module, unsigned int lib_no) {\n\t/* Function that returns a pointer to the module keys in specified shared library lib_no, or NULL if not found  */\n\t/* DO not rename this function */\n\tchar function[GMT_LEN64] = {\"\"};\n\tconst char *keys = NULL;       /* char pointer to module keys */\n\tconst char *(*func)(void*, char*) = NULL;       /* function pointer */\n\tif (API->lib[lib_no].skip) return (NULL);\t/* Tried to open this shared library before and it was not available */\n\tif (API->lib[lib_no].handle == NULL && (API->lib[lib_no].handle = dlopen (API->lib[lib_no].path, RTLD_LAZY)) == NULL) {\t/* Not opened this shared library yet */\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to open GMT shared %s library: %s\\n\", API->lib[lib_no].name, dlerror());\n\t\tAPI->lib[lib_no].skip = true;\t/* Not bother the next time... */\n\t\treturn (NULL);\t\t\t/* ...and obviously no keys would be found */\n\t}\n\tsnprintf (function, GMT_LEN64, \"%s_module_keys\", API->lib[lib_no].name);\n\t/* Here the library handle is available; try to get pointer to specified module */\n\t*(void **) (&func) = dlsym (API->lib[lib_no].handle, function);\n\tif (func) keys = (*func) (API, module);\n\treturn (keys);\n}\n\n/*! . */\nGMT_LOCAL const char *gmtapi_get_shared_module_group (struct GMTAPI_CTRL *API, char *module, unsigned int lib_no) {\n\t/* Function that returns a pointer to the module group string in specified shared library lib_no, or NULL if not found  */\n\t/* DO not rename this function */\n\tchar function[GMT_LEN64] = {\"\"};\n\tconst char *group = NULL;       /* char pointer to module group */\n\tconst char * (*func)(void*, char*) = NULL;       /* function pointer */\n\tif (API->lib[lib_no].skip) return (NULL);\t/* Tried to open this shared library before and it was not available */\n\tif (API->lib[lib_no].handle == NULL && (API->lib[lib_no].handle = dlopen (API->lib[lib_no].path, RTLD_LAZY)) == NULL) {\t/* Not opened this shared library yet */\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to open GMT shared %s library: %s\\n\", API->lib[lib_no].name, dlerror());\n\t\tAPI->lib[lib_no].skip = true;\t/* Not bother the next time... */\n\t\treturn (NULL);\t\t\t/* ...and obviously no keys would be found */\n\t}\n\tsnprintf (function, GMT_LEN64, \"%s_module_group\", API->lib[lib_no].name);\n\t/* Here the library handle is available; try to get pointer to specified module */\n\t*(void **) (&func) = dlsym (API->lib[lib_no].handle, function);\n\tif (func) group = (*func) (API, module);\n\treturn (group);\n}\n\n/*! . */\nconst char *gmt_get_module_group (void *V_API, char *module) {\n\t/* Call the specified shared module and retrieve the group of the module.\n \t * This function, while in the API, is only for API developers and thus has a\n\t * \"undocumented\" status in the API documentation.\n\t */\n\tunsigned int lib;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar gmt_module[GMT_LEN32] = \"gmt\";\n\tconst char *group = NULL;\n\n\tif (V_API == NULL) return_null (NULL, GMT_NOT_A_SESSION);\n\tif (module == NULL) return_null (V_API, GMT_ARG_IS_NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tfor (lib = 0; lib < API->n_shared_libs; lib++) {\t/* Look for module in any of the shared libs */\n\t\tgroup = gmtapi_get_shared_module_group (API, module, lib);\n\t\tif (group) return (group);\t/* Found it in this shared library, return the group */\n\t}\n\t/* If we get here we did not found it.  Try to prefix module with gmt */\n\tstrncat (gmt_module, module, GMT_LEN32-4);\t\t/* Concatenate gmt and module name to get function name */\n\tfor (lib = 0; lib < API->n_shared_libs; lib++) {\t/* Look for gmt_module in any of the shared libs */\n\t\tgroup = gmtapi_get_shared_module_group (API, gmt_module, lib);\n\t\tif (group) {\t/* Found it in this shared library, adjust module name and return the group */\n\t\t\tstrncpy (module, gmt_module, strlen(gmt_module));\t/* Rewrite module name to contain prefix of gmt */\n\t\t\treturn (group);\n\t\t}\n\t}\n\t/* Not in any of the shared libraries */\n\tGMT_Report (API, GMT_MSG_ERROR, \"Shared GMT module not found: %s \\n\", module);\n\treturn_null (V_API, GMT_NOT_A_VALID_MODULE);\n}\n\n/*! . */\nGMT_LOCAL const char *gmtapi_retrieve_module_keys (void *V_API, char *module) {\n\t/* Call the specified shared module and retrieve the API developer options keys.\n\t */\n\tunsigned int lib;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar gmt_module[GMT_LEN32] = \"gmt\";\n\tconst char *keys = NULL;\n\n\tif (V_API == NULL) return_null (NULL, GMT_NOT_A_SESSION);\n\tif (module == NULL) return_null (V_API, GMT_ARG_IS_NULL);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tfor (lib = 0; lib < API->n_shared_libs; lib++) {\t/* Look for module in any of the shared libs */\n\t\tkeys = gmtapi_get_shared_module_keys (API, module, lib);\n\t\tif (keys) return (keys);\t/* Found it in this shared library, return the keys */\n\t}\n\t/* If we get here we did not found it.  Try to prefix module with gmt */\n\tstrncat (gmt_module, module, GMT_LEN32-4);\t\t/* Concatenate gmt and module name to get function name */\n\tfor (lib = 0; lib < API->n_shared_libs; lib++) {\t/* Look for gmt_module in any of the shared libs */\n\t\tkeys = gmtapi_get_shared_module_keys (API, gmt_module, lib);\n\t\tif (keys) {\t/* Found it in this shared library, adjust module name and return the keys */\n\t\t\tstrncpy (module, gmt_module, strlen(gmt_module));\t/* Rewrite module name to contain prefix of gmt */\n\t\t\treturn (keys);\n\t\t}\n\t}\n\t/* Not in any of the shared libraries */\n\tGMT_Report (API, GMT_MSG_ERROR, \"Shared GMT module not found: %s \\n\", module);\n\treturn_null (V_API, GMT_NOT_A_VALID_MODULE);\n}\n\nGMT_LOCAL int gmtapi_extract_argument (char *optarg, char *argument, char **key, int k, bool colon, int *n_pre) {\n\t/* Two separate actions:\n\t * 1) If key ends with \"=\" then we pull out the option argument after stripping off +<stuff>.\n\t * 2) If key ends with \"=q\" then we see if +q is given and return pos to this modifiers argument.\n\t * 3) Else we just copy input to output.\n\t * We also set n_pre which is the number of characters to skip after the -X option\n\t *   before looking for an argument.\n\t * If colon is true we also strip argument from the first colon onwards.\n\t * If this all sounds messy it is because the GMT command-line syntax of some modules are\n\t *   messy and predate the whole API business...\n\t */\n\tchar *c = NULL;\n\tunsigned int pos = 0;\n\t*n_pre = 0;\n\tif (k >= 0 && key[k][K_EQUAL] == '=') {\t/* Special handling */\n\t\t*n_pre = (key[k][K_MODIFIER] && isdigit (key[k][K_MODIFIER])) ? (int)(key[k][K_MODIFIER]-'0') : 0;\n\t\tif ((*n_pre || key[k][K_MODIFIER] == 0) && (c = strchr (optarg, '+'))) {\t/* Strip off trailing +<modifiers> */\n\t\t\tc[0] = 0;\n\t\t\tstrcpy (argument, optarg);\n\t\t\tc[0] = '+';\n\t\t}\n\t\telse if (key[k][K_MODIFIER]) {\t/* Look for +<mod> */\n\t\t\tchar code[3] = {\"+?\"};\n\t\t\tcode[1] = key[k][K_MODIFIER];\n\t\t\tif ((c = strstr (optarg, code))) {\t/* Found +<modifier> */\n\t\t\t\tstrcpy (argument, optarg);\n\t\t\t\tpos = (unsigned int) (c - optarg + 2);\t/* Position of this modifiers argument */\n\t\t\t}\n\t\t\telse\n\t\t\t\tstrcpy (argument, optarg);\n\t\t}\n\t\telse\n\t\t\tstrcpy (argument, optarg);\n\t}\n\telse\n\t\tstrcpy (argument, optarg);\n\tif (colon && (c = strchr (argument, ':')))\t/* Also chop of :<more arguments> */\n\t\tc[0] = '\\0';\n\n\treturn pos;\n}\n\nGMT_LOCAL int gmtapi_B_custom_annotations (struct GMT_OPTION *opt) {\n\t/* Replace -B[p|s][x|y|z]c with -B[p|s][x|y|z]c? */\n\tunsigned int k = 0;\n\tif (opt->option != 'B') return 0;\t/* Not the right option */\n\tif (strchr (\"ps\", opt->arg[k])) k++;\t/* Skip a leading p|s for primary|secondary axis */\n\tif (strchr (\"xyz\", opt->arg[k])) k++;\t/* Skip optional x|y|z for specific axis */\n\tif (opt->arg[k] != 'c') return 0;\t/* Not a custom annotation request */\n\tif (opt->arg[k+1]) return 0;\t\t/* Should be empty if we are to add ? */\n\topt->arg = realloc (opt->arg, strlen (opt->arg)+2);\t/* Make space for ? */\n\tstrcat (opt->arg, \"?\");\n\treturn 1;\n}\n\nGMT_LOCAL bool gmtapi_operator_takes_dataset (struct GMT_OPTION *opt, int *geometry) {\n\t/* Check if the sequence ? OPERATOR is one that requires reading a dataset instead of a grid.\n\t * Here, opt is an input argument with value ? and we inquire about the next option (the operator).\n\t * geometry is already set to GMT_IS_GRID */\n\tif (opt == NULL) return false;\t/* Just being paranoid */\n\tif (opt->next == NULL) return false;\t/* Just being extra paranoid */\n\tif (opt->next->option != GMT_OPT_INFILE) return false;\t/* Cannot be an operator */\n\tif (!opt->next->arg[0]) return false;\t/* No argument given */\n\tif (!strncmp (opt->next->arg, \"INSIDE\", 6U)) {\t/* Are nodes inside/outside a polygon */\n\t\t*geometry = GMT_IS_POLY;\n\t\treturn true;\n\t}\n\tif (!strncmp (opt->next->arg, \"POINT\", 5U) || !strncmp (opt->next->arg, \"PDIST\", 5U)) {\n\t\t*geometry = GMT_IS_POINT;\n\t\treturn true;\t/* One of the dataset-requiring operators */\n\t}\n\tif (!strncmp (opt->next->arg, \"LDIST\", 5U)) {\t/* Distance to lines of some sort */\n\t\t*geometry = GMT_IS_LINE;\n\t\treturn true;\t/* One of the dataset-requiring operators */\n\t}\n\treturn false;\t/* No, something else */\n}\n\nGMT_LOCAL char gmtapi_grdinterpolate_type (struct GMTAPI_CTRL *API, struct GMT_OPTION *options) {\n\tunsigned int n_files = 0;\n\tchar type = 'D';\t/* For -S */\n\tstruct GMT_OPTION *opt = NULL, *E = NULL, *S = NULL, *T = NULL;\n\tgmt_M_unused (API);\n\n\tfor (opt = options; opt; opt = opt->next) {\t/* Process all the options given */\n\t\tif (opt->option == GMT_OPT_INFILE) n_files++;\n\t\telse if (opt->option == 'E') E = opt;\n\t\telse if (opt->option == 'S') S = opt;\n\t\telse if (opt->option == 'T') T = opt;\n\t}\n\t/* Now determine the various cases that yield different return types */\n\tif (E == NULL && S == NULL) {\t/* Interpolating onto a single grid or a new cube */\n\t\tif (T == NULL && n_files > 1)\t/* Repackaging multiple grids as a single cube */\n\t\t\ttype = 'U';\n\t\telse if (T && (strchr (T->arg, '/') || strchr (T->arg, ',')))\t/* Making more than one output layer */\n\t\t\ttype = 'U';\n\t\telse\n\t\t\ttype = 'G';\t/* Making a single grid layer */\n\t}\n\telse if (E)\t/* Sample a vertical slice as a grid */\n\t\ttype = 'G';\n\n\treturn (type);\n}\n\n#define api_is_required_IO(key) (key == API_PRIMARY_INPUT || key == API_PRIMARY_OUTPUT)\t\t\t/* Returns true if this is a primary input or output item */\n#define api_not_required_io(key) ((key == API_PRIMARY_INPUT || key == API_SECONDARY_INPUT) ? API_SECONDARY_INPUT : API_SECONDARY_OUTPUT)\t/* Returns the optional input or output flag */\n\n/*! . */\nstruct GMT_RESOURCE * GMT_Encode_Options (void *V_API, const char *module_name, int n_in, struct GMT_OPTION **head, unsigned int *n) {\n\t/* This function determines which input sources and output destinations are required given the module options.\n\t * It is only used to assist developers of external APIs, such as the MATLAB, Julia, Python, R, and others.\n\t * \"Keys\" referred to below is the unique combination given near the top of every module via the macro\n\t * THIS_MODULE_KEYS.  For instance, here are the keys for grdtrack:\n\t *\n\t * #define THIS_MODULE_KEYS        \"<D{,DD),GG(,>D}\"\n\t *\n\t * Here are the GMT_Encode_Options arguments:\n\t *   API\tControls all things within GMT.\n\t *   module\tName of the GMT module.\n\t *   n_in\tKnown number of objects given as input resources (-1 if not known).\n\t *   head\tLinked list of GMT options passed for this module. We may hook on 1-2 additional options.\n\t *   *n\t\tNumber of structures returned by the function. Struct GMT_RESOURCE is defined in gmt.h\n\t *\n\t * We also return an array of structures with information about registered resources going to/from GMT.\n\t * Basically, given the module we look up the keys for that module, which tells us which options provide\n\t * the input and output selections and which ones are required and which ones are optional.  We then\n\t * scan the given options and if file arguments to the options listed in the keys are missing we are\n\t * to insert ? as the filename. Some options may already have the question mark. After scanning\n\t * the options we examine the keys for any required input or output argument that have yet to be specified\n\t * explicitly. If so we create the missing options, with filename = ?, and append them to the end of\n\t * the option list (head). The API developers can then use this array of encoded options in concert with\n\t * the information passed back via the structure list to attach actual resources.\n\t *\n\t * For each option that may take a file we need to know what kind of file and if it is input or output.\n\t * We encode this information in a 3-character word XYZ, explained below.  Note that each module may\n\t * need several comma-separated XYZ words and these are returned as one string via GMT_Get_Moduleinfo.\n\t * The X, Y, and Z letter position represent different information, as discussed below:\n\t *\n\t * X stands for the specific program OPTION (e.g., L for -L, F for -F). For tables or grids read from files or\n\t * tables processed via standard input we use '<', while '>' is used for standard (table) output.\n\t * Y stands for data TYPE (C = CPT, D = Dataset/Point, L = Dataset/Line, P = Dataset/Polygon,\n\t *    G = Grid, I = Image, X = PostScript, ? = type specified via a module option [more later]),\n\t *    while a hyphen (-) means there is NO data when this option is set (see Z for whether this is for in- or output).\n\t * Z stands for PRIMARY inputs '{', primary output '}' OR SECONDARY input '(', or secondary output ')'.\n\t *   Primary inputs and outputs MUST be assigned, and if not explicitly given will result in\n\t *   a syntax error. However, external APIs (mex, Python) can override this and supply the missing items\n\t *   via any given left- and right-hand side arguments to supply inputs or accept outputs.\n\t *   Secondary inputs means they are only assigned if an option is actually given.  If the in|out designation\n\t *   is irrelevant for an option we use '-'.\n\t *\n\t * There are a few special cases where X, Y, or Z take on \"magic\" behavior:\n\t *\n\t *   A few modules with have X = - (hyphen). This means the primary input or output (determined by Z)\n\t *   has a data type that is not known until runtime.  A module option will tells us which type it is, and this\n\t *   option is encoded in Y.  So a -Y<type> option is _required_ and that is how we can update the primary\n\t *   data type.  Example: gmtread can read any GMT object but requires -T<type>.  It thus has the keys\n\t *   \"<?{,>?},-T-\".  Hence, we examine -T<type> and replace ? with the dataset implied by <type> both for input\n\t *   AND output (since Z was indeterminate).  Use i|o if only input or output should have this treatment.\n\t *\n\t *   A few modules will have Y = - which is another magic key: If the -X option is given then either the input\n\t *   or output (depending on what Z is) will NOT be required. As an example of this behavior, consider psxy\n\t *   which has a -T option that means \"read no input, just write trailer\". So the key \"T-<\" in psxy means that\n\t *   when -T is used then NO input is required.  This means the primary input key \"<D{\" is changed to \"<D(\" (secondary)\n\t *   and no attempt is made to connect external input to the psxy input.  If Z is none of () then we expect Z to\n\t *   be one of the options with required input (or output) and we change that option to option input (or output).\n\t *   Example: grdtrack has two required inputs (the grid(s) and the track/point file.  However, if -E is set then\n\t *   the track/point file is not expected so we need to change it to secondary.  We thus add E-< which then will\n\t *   change <D{ to <D(.  A modifier is also possible.  For instance -F<grid>[+d] is used by several modules, such\n\t *   as triangulate, to use the non-NaN nodes in a grid as the input data instead of reading the primary input\n\t *   source.  So F-( would turn off primary input.  However, if +d is present then we want to combine the grid with\n\t *   the primary input and hence we read that as well.\n\t *\n\t *   A few modules will specify Z as some letter not in {|(|}|)|-, which means that normally these modules\n\t *   will expect/produce whatever input/output is specified by the primary setting, but if the \"-Z\" option is given the primary\n\t *   input/output will be changed to the given type Y.  Also, modifiers may be involved. The full syntax for this is\n\t *   XYZ[+abc...][-def...]: We do the substitution of output type to Y only if\n\t *      1. -Z is given on the command line\n\t *      2. -Z contains ALL the modifiers from the first \"+\"-list: +a, +b, +c, ... [optional]\n\t *      3. -Z contains AT LEAST ONE of the modifiers from the second \"-\"-list: +d, +e, +f. [optional]\n\t *   At least on case from 2 or 3 must be specified.\n\t *   The Z magic is a bit confusing so here is some examples:\n\t *   1. grdcontour normally writes PostScript but grdcontour -D will instead export data to std (or a file set by -D), so its key\n\t *      contains the entry \"DDD\": When -D is active then the PostScript key \">X}\" morphs into \"DD}\" and\n\t *      thus allows for a data set export instead.\n\t *   2. pscoast normally plots PostSCript but pscoast -E+l only want to return a text listing of countries.  We allow for this\n\t *      switch by using the key >DE-lL so that if -E with either +l or +L are used we change primary output to D.\n\t *\n\t *   After processing, all magic key sequences are set to \"---\" to render them inactive.\n\t *\n\t */\n\n\tunsigned int n_keys, direction = 0, kind, pos = 0, n_items = 0, ku, n_out = 0, nn[2][2];\n\tunsigned int output_pos = 0, input_pos = 0, mod_pos;\n\tint family = GMT_NOTSET;\t/* -1, or one of GMT_IS_DATASET, GMT_IS_GRID, GMT_IS_PALETTE, GMT_IS_IMAGE */\n\tint geometry = GMT_NOTSET;\t/* -1, or one of GMT_IS_NONE, GMT_IS_TEXT, GMT_IS_POINT, GMT_IS_LINE, GMT_IS_POLY, GMT_IS_SURFACE */\n\tint sdir, k = 0, n_in_added = 0, n_to_add, e, n_pre_arg, n_per_family[GMT_N_FAMILIES];\n\tbool deactivate_output = false, deactivate_input = false, strip_colon = false, strip = false, is_grdmath = false;\n\tsize_t n_alloc, len;\n\tconst char *keys = NULL;\t/* This module's option keys */\n\tchar **key = NULL;\t\t/* Array of items in keys */\n\tchar *text = NULL, *LR[2] = {\"rhs\", \"lhs\"}, *S[2] = {\" IN\", \"OUT\"}, txt[GMT_LEN256] = {\"\"}, type = 0;\n\tchar module[GMT_LEN32] = {\"\"}, argument[PATH_MAX] = {\"\"}, strip_colon_opt = 0;\n\tchar *special_text[3] = {\" [satisfies required input]\", \" [satisfies required output]\", \"\"}, *satisfy = NULL;\n\tstruct GMT_OPTION *opt = NULL, *new_ptr = NULL;\t/* Pointer to a GMT option structure */\n\tstruct GMT_RESOURCE *info = NULL;\t/* Our return array of n_items info structures */\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\t*n = 0;\t/* Initialize counter to zero in case we return prematurely */\n\n\tif (V_API == NULL) return_null (NULL, GMT_NOT_A_SESSION);\n\tif (module_name == NULL) return_null (V_API, GMT_ARG_IS_NULL);\n\n\tif ((*head) && ((*head)->option == GMT_OPT_USAGE || (*head)->option == GMT_OPT_SYNOPSIS)) {\t/* Nothing to do */\n\t\t*n = UINT_MAX;\n\t\treturn NULL;\n\t}\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\t(void) gmt_current_name (module_name, module);\n\tgmt_manage_workflow (API, GMT_USE_WORKFLOW, NULL);\t\t/* Detect and set modern mode if modern mode session dir is found */\n\t/* 0. Get the keys for the module, possibly prepend \"gmt\" to module if required, or list modules and return NULL if unknown module */\n\tif ((keys = gmtapi_retrieve_module_keys (V_API, module)) == NULL) {\t/* Gave an unknown module */\n\t\tif (GMT_Call_Module (V_API, NULL, GMT_MODULE_PURPOSE, NULL))\t/* List the available modules */\n\t\t\treturn_null (NULL, GMT_NOT_A_VALID_MODULE);\n\t\treturn_null (NULL, GMT_NOT_A_VALID_MODULE);\t/* Unknown module code */\n\t}\n\n\t/* First some special checks related to unusual GMT syntax or hidden modules */\n\n\t/* 1a. Check if this is the pscoast module, where output type is either PostScript or Dataset */\n\tif (!strncmp (module, \"pscoast\", 7U)) {\n\t\t/* Potential problem under modern mode: No -J -R set but will be provided later, and we are doing -E for coloring or lines */\n\t\tif (GMT_Find_Option (API, 'M', *head)) type = 'D';\t/* -M means dataset dump */\n\t\telse if (GMT_Find_Option (API, 'C', *head) || GMT_Find_Option (API, 'G', *head) || GMT_Find_Option (API, 'I', *head) || GMT_Find_Option (API, 'N', *head) || GMT_Find_Option (API, 'W', *head)) type = 'X';\t/* Clearly plotting GSHHG */\n\t\telse if ((opt = GMT_Find_Option (API, 'E', *head)) && (strstr (opt->arg, \"+g\") || strstr (opt->arg, \"+p\"))) type = 'X';\t/* Clearly plotting DCW polygons */\n\t\telse if ((opt = GMT_Find_Option (API, 'E', *head)) && (strstr (opt->arg, \"+l\") || strstr (opt->arg, \"+L\"))) type = 'D';\t/* Clearly requesting listing of DCW countries/states */\n\t\telse if (!GMT_Find_Option (API, 'J', *head)) type = 'D';\t/* No -M and no -J means -Rstring as dataset */\n\t\telse type = 'X';\t/* Otherwise we are still most likely plotting PostScript */\n\t}\n\t/* 1b. Check if this is psxy or psxyz modules with quoted or decorated lines. For any other -S~|q? flavor we kill the key with ! */\n\telse if ((!strncmp (module, \"psxy\", 4U) || !strncmp (module, \"psxyz\", 5U)) && (opt = GMT_Find_Option (API, 'S', *head))) {\n\t\t/* Found the -S option, check if we requested quoted or decorated lines via fixed or crossing lines */\n\t\t/* If not f|x then we don't want this at all and set type = ! */\n\t\ttype = (!strchr (\"~q\", opt->arg[0]) || !strchr (\"fx\", opt->arg[1])) ? '!' : 'D';\n\t\tstrip_colon = (type && strchr (opt->arg, ':'));\n\t\tstrip_colon_opt = opt->option;\n\t\tif (strip_colon)\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Got quoted or decorate line and must strip argument %s from colon to end\\n\", opt->arg);\n\t}\n\t/* 1c. Check if this is either gmtmath or grdmath which both use the special = outfile syntax and replace that by -=<outfile> */\n\telse if (!strncmp (module, \"gmtmath\", 7U) || (is_grdmath = (strncmp (module, \"grdmath\", 7U) == 0))) {\n\t\tstruct GMT_OPTION *delete = NULL;\n\t\tfor (opt = *head; opt && opt->next; opt = opt->next) {\t/* Here opt will end up being the last option */\n\t\t\tif (!strcmp (opt->arg, \"=\")) {\n\t\t\t\tif (opt->next) {\t/* Combine the previous = and <whatever> options into a single -=<whatever> option, then delete the former */\n\t\t\t\t\topt->next->option = '=';\n\t\t\t\t\tdelete = opt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGMT_Delete_Option (API, delete, head);\n\t}\n\t/* 1d. Check if this is the write special module, which has flagged its output file as input... */\n\telse if (!strncmp (module, \"gmtwrite\", 8U) && (opt = GMT_Find_Option (API, GMT_OPT_INFILE, *head))) {\n\t\t/* Found a -<\"file\" option; this is actually the output file so we simply change the option to output */\n\t\topt->option = GMT_OPT_OUTFILE;\n\t\tdeactivate_output = true;\t/* Remember to turn off implicit output option since we got one */\n\t}\n\t/* 1e. Check if this is the grdconvert module, which uses the syntax \"infile outfile\" without any option flags */\n\telse if (!strncmp (module, \"grdconvert\", 10U) && (opt = GMT_Find_Option (API, GMT_OPT_INFILE, *head))) {\n\t\t/* Found a -<\"file\" option; this is indeed the input file but the 2nd \"input\" is actually output */\n\t\tif (opt->next && (opt = GMT_Find_Option (API, GMT_OPT_INFILE, opt->next)))\t/* Found the next input file option */\n\t\t\topt->option = GMT_OPT_OUTFILE;\t/* Switch it to an output option */\n\t}\n\t/* 1f. Check if this is the greenspline module, where output type is grid for dimension == 2 else it is dataset */\n\telse if (!strncmp (module, \"greenspline\", 11U) && (opt = GMT_Find_Option (API, 'R', *head))) {\n\t\t/* Found the -R\"domain\" option; determine the dimensionality of the output */\n\t\tunsigned dim = gmtapi_determine_dimension (API, opt->arg);\n\t\tswitch (dim) {\t/* Determine if output is D, G, or U */\n\t\t\tcase 1: type = 'D'; break;\t/* 1-D is a data table */\n\t\t\tcase 2: type = 'G'; break;\t/* 2-D is always a grid */\n\t\t\tdefault:\t/* 3-D, but can be dataset or cube */\n\t\t\t\ttype = ((opt = GMT_Find_Option (API, 'G', *head))) ? 'U' : 'D';\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* 1g. Check if this is the triangulate module, where primary dataset output should be turned off if -G given without -M,N,Q,S */\n\telse if (!strncmp (module, \"triangulate\", 11U) && (opt = GMT_Find_Option (API, 'G', *head))) {\n\t\t/* Found the -G<grid> option; determine if any of -M,N,Q,S are also set */\n\t\tif (!((opt = GMT_Find_Option (API, 'M', *head)) || (opt = GMT_Find_Option (API, 'N', *head))\n\t\t\t|| (opt = GMT_Find_Option (API, 'Q', *head)) || (opt = GMT_Find_Option (API, 'S', *head))))\n\t\t\t\tdeactivate_output = true;\t/* Turn off implicit output since none is in effect */\n\t}\n\t/* 1h. Check if this is a *contour modules with -Gf|x given. For any other -G? flavor we kill the key with ! */\n\telse if ((!strncmp (module, \"grdcontour\", 10U) || !strncmp (module, \"pscontour\", 9U)) && (opt = GMT_Find_Option (API, 'G', *head))) {\n\t\t/* Found the -G option, check if any strings are requested */\n\t\t/* If not -Gf|x then we don't want this at all and set type = ! */\n\t\ttype = (opt->arg[0] == 'f' || opt->arg[0] == 'x') ? 'D' : '!';\n\t}\n\t/* 1i. Check if this is the talwani3d module, where output type is grid except with -N it is dataset */\n\telse if (!strncmp (module, \"talwani3d\", 9U)) {\n\t\t/* If we find the -N option, we set type to D, else G */\n\t\ttype = (GMT_Find_Option (API, 'N', *head)) ? 'D' : 'G';\n\t}\n\t/* 1j. Check if this is a blockm* module using -A to set n output grids */\n\telse if (!strncmp (module, \"block\", 5U) && (opt = GMT_Find_Option (API, 'A', *head))) {\n\t\t/* Below, k is the number of under=the-hood -G? options we must add for returning grids to externals */\n\t\tk = 0;\t/* Make sure we initialize this first */\n\t\tif (opt->arg[0]) {\t/* Gave -A: Determine how many output grids are requested */\n\t\t\tfor (k = 1, len = 0; len < strlen (opt->arg); len++) if (opt->arg[len] == ',') k++;\n\t\t}\n\t\tif ((opt = GMT_Find_Option (API, 'G', *head))) {\t/* This is a problem unless -G actually sent in a file name */\n\t\t\tif (opt->arg[0] == '\\0') {\t/* Cannot just give -G here */\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Encode_Options: %s cannot set -G when called externally\\n\", module);\n\t\t\t\treturn_null (NULL, GMT_NOT_A_VALID_OPTION);\n\t\t\t}\n\t\t\telse\t/* Gave a (presumably) file argument, no need to add -G? */\n\t\t\t\tk = 0;\n\t\t}\n\t\telse\t/* No -A or -G; default is to just add the z grid via -G?  */\n\t\t\tk = 1;\n\t\twhile (k) {\t/* Add -G? option k times */\n\t\t\tnew_ptr = GMT_Make_Option (API, 'G', \"?\");\t/* Create new output grid option(s) with filename \"?\" */\n\t\t\t*head = GMT_Append_Option (API, new_ptr, *head);\n\t\t\tk--;\n\t\t}\n\t\tdeactivate_output = true;\t/* Turn off implicit table output since only secondary -G output(s) is in effect */\n\t}\n\t/* 1k. Check if this is the earthtide module requesting output grids */\n\telse if (!strncmp (module, \"earthtide\", 9U) && !GMT_Find_Option (API, 'L', *head) && !GMT_Find_Option (API, 'S', *head)) {\n\t\t/* Below, k is the number of under=the-hood -G? options we must add for returning grids to externals */\n\t\tk = 0;\t/* Make sure we initialize this first */\n\t\tif ((opt = GMT_Find_Option (API, 'C', *head))) {\t/* Gave -C: Determine how many output grids are requested */\n\t\t\tfor (k = 1, len = 0; len < strlen (opt->arg); len++) if (opt->arg[len] == ',') k++;\n\t\t}\n\t\tif ((opt = GMT_Find_Option(API, 'G', *head))) {\t/* This is a problem unless -G actually sent in a file name */\n\t\t\tif (opt->arg[0] == '\\0') {\t/* Cannot just give -G here */\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Encode_Options: %s cannot set -G (with no argument) when called externally\\n\", module);\n\t\t\t\treturn_null (NULL, GMT_NOT_A_VALID_OPTION);\n\t\t\t}\n\t\t\telse\t/* Gave a (presumably) file argument, no need to add -G? */\n\t\t\t\tk = 0;\n\t\t}\n\t\telse if (k == 0) \t/* No -C or -G; default is to just add the -Gz grid via -G? */\n\t\t\tk = 1;\n\t\twhile (k) {\t/* Add -G? option k times */\n\t\t\tnew_ptr = GMT_Make_Option (API, 'G', \"?\");\t/* Create new output grid option(s) with filename \"?\" */\n\t\t\t*head = GMT_Append_Option (API, new_ptr, *head);\n\t\t\tk--;\n\t\t}\n\t\tdeactivate_output = true;\t/* Turn off implicit table output since only secondary -G output(s) is in effect */\n\t}\n\t/* 1l. Check if this is makecpt using -E or -S with no args */\n\telse if (!strncmp (module, \"makecpt\", 7U)) {\n\t\tif (((opt = GMT_Find_Option (API, 'E', *head)) || (opt = GMT_Find_Option (API, 'S', *head)))) {\n\t\t\tif (opt->arg[0] == '\\0') {\t/* Found the -E or -S option without arguments */\n\t\t\t\tgmt_M_str_free (opt->arg);\n\t\t\t\tif (opt->option == 'E')\t/* Gave -E but we need to pass -E0 */\n\t\t\t\t\topt->arg = strdup (\"0\");\n\t\t\t\telse\t/* Replace -S with -Sr */\n\t\t\t\t\topt->arg = strdup (\"r\");\n\t\t\t}\n\t\t\t/* Then add implicit ? if no input file found */\n\t\t\tif ((opt = GMT_Find_Option (API, GMT_OPT_INFILE, *head)) == NULL) {\t/* Must assume implicit input file is available */\n\t\t\t\tnew_ptr = GMT_Make_Option (API, GMT_OPT_INFILE, \"?\");\n\t\t\t\t*head = GMT_Append_Option (API, new_ptr, *head);\n\t\t\t}\n\t\t}\n\t\telse if (API->GMT->current.setting.run_mode == GMT_MODERN && (opt = GMT_Find_Option (API, 'H', *head)) == NULL) {\t/* Modern mode, no -H */\n\t\t\tdeactivate_output = true;\t/* Turn off implicit output since none is in effect */\n\t\t}\n\t}\n\t/* 1m. Check if this is the grdgradient module, where primary dataset output should be turned off if -Qc and no -G is set */\n\telse if (!strncmp (module, \"grdgradient\", 11U) && (opt = GMT_Find_Option (API, 'G', *head)) == NULL) {\n\t\t/* Found no -G<grid> option; determine if -Qc is set */\n\t\tif ((opt = GMT_Find_Option (API, 'Q', *head)) && opt->arg[0] == 'c')\n\t\t\tdeactivate_output = true;\t/* Turn off implicit output since none is in effect */\n\t}\n\t/* 1m. Check if this is the grdgradient module, where primary dataset output should be turned off if -Qc and no -G is set */\n\telse if (!strncmp (module, \"pstext\", 6U) && (opt = GMT_Find_Option (API, 'F', *head))) {\n\t\t/* With -F+c<just>+t<label> there is no file to read */\n\t\tif (gmt_no_pstext_input (API, opt->arg))\n\t\t\tdeactivate_input = true;\t/* Turn off implicit input since none is in effect */\n\t}\n\t/* 1n. Check that in modern mode, grd2cpt requires -H to write out to stdout */\n\telse if (!strncmp (module, \"grd2cpt\", 7U)) {\n\t\tif (API->GMT->current.setting.run_mode == GMT_MODERN && (opt = GMT_Find_Option (API, 'H', *head)) == NULL) {\t/* Modern mode, no -H */\n\t\t\tdeactivate_output = true;\t/* Turn off implicit output since none is in effect */\n\t\t}\n\t}\n\t/* 1o. Check if grdinterpolate is producing grids or datasets */\n\telse if (!strncmp (module, \"grdinterpolate\", 14U)) {\n\t\ttype = gmtapi_grdinterpolate_type (API, *head);\t/* Determine the right type for the output */\n\t}\n\t/* 1p. Check if grdgdal is reading a dataset */\n\telse if (!strncmp (module, \"grdgdal\", 7U)) {\t/* Set input data type based on options */\n\t\tif ((opt = GMT_Find_Option (API, 'A', *head)) && (strstr (opt->arg, \"grid\") || strstr (opt->arg, \"rasterize\")))\n\t\t\ttype = 'D';\n\t\telse\n\t\t\ttype = 'G';\n\t}\n\t/* 1q. Check if gmtget is downloading dataset */\n\telse if (!strncmp (module, \"gmtget\", 6U) && (opt = GMT_Find_Option (API, 'D', *head))) {\n\t\tdeactivate_output = true;\t/* Download, turn off output */\n\t}\n\t/* 1r. Check if gmtbinstats is doing hexagonal tiling */\n\telse if (!strncmp (module, \"gmtbinstats\", 11U)) {\n\t\ttype = ((opt = GMT_Find_Option (API, 'T', *head)) && opt->arg[0] != 'r') ? 'D' : 'G';\t/* Giving -T[h] means we change default output from grid to dataset */\n\t}\n\t/* 1s. Check if psevents is doing data prep */\n\telse if (!strncmp (module, \"psevents\", 8U)) {\n\t\ttype = ((opt = GMT_Find_Option (API, 'A', *head)) && opt->arg[0] == 'r' && opt->arg[1] && isdigit (opt->arg[1])) ? 'D' : 'X';\t/* Giving -Ar<dpi> means we resample a line, else plotting */\n\t}\n\t/* 1t. Check if grdinfo is reading cubes or grids */\n\telse if (!strncmp (module, \"grdinfo\", 7U)) {\n\t\ttype = ((opt = GMT_Find_Option (API, 'Q', *head))) ? 'U' : 'G';\t/* Giving -Q means we are reading 3-D cubes */\n\t}\n\n\t/* 2a. Get the option key array for this module */\n\tkey = gmtapi_process_keys (API, keys, type, *head, n_per_family, &n_keys);\t/* This is the array of keys for this module, e.g., \"<D{,GG},...\" */\n\tif (n_keys == 0) {\t\t/* gmtset and begin for instances have no keys */\n\t\t*n = UINT_MAX;\n\t\treturn NULL;\n\t}\n\n\tif (gmt_M_is_verbose (API->GMT, GMT_MSG_DEBUG)) {\n\t\tchar txt[4] = {\"\"};\n\t\tfor (k = 0; k < GMT_N_FAMILIES; k++) if (n_per_family[k] != GMT_NOTSET) {\n\t\t\t(n_per_family[k] == GMTAPI_UNLIMITED) ? snprintf (txt, 4, \">1\") : snprintf (txt, 4, \"%d\", n_per_family[k]);\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: For %s we expect %s input objects\\n\", GMT_family[k], txt);\n\t\t}\n\t}\n\n\t/* 2b. Make some specific modifications to the keys given the options passed */\n\tif (deactivate_output && (k = gmtapi_get_key (API, GMT_OPT_OUTFILE, key, n_keys)) >= 0)\n\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Since an explicit output file already specified or not required */\n\n\t/* 2c. Make some specific modifications to the keys given the options passed */\n\tif (deactivate_input && (k = gmtapi_get_key (API, GMT_OPT_INFILE, key, n_keys)) >= 0)\n\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Since an explicit input file already specified or not required */\n\n\t/* 3. Count command line output files */\n\tfor (opt = *head; opt; opt = opt->next)\n\t\tif (opt->option == GMT_OPT_OUTFILE) n_out++;\n\tif (n_out > 1) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Encode_Options: Can only specify one main output object via command line\\n\");\n\t\treturn_null (NULL, GMT_ONLY_ONE_ALLOWED);\t/* Too many output objects */\n\t}\n\tn_alloc = n_keys;\t/* Initial number of allocations */\n\tif ((info = gmt_M_memory (API->GMT, NULL, n_alloc, struct GMT_RESOURCE)) == NULL) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Encode_Options: Unable to allocate GMT_RESOURCE array\\n\");\n\t\treturn_null (NULL, GMT_MEMORY_ERROR);\n\t}\n\n\tif (!strncmp (module, \"psrose\", 6U) && (opt = GMT_Find_Option (API, 'E', *head)) && strcmp (opt->arg, \"m\")) {\n\t\t/* Giving any -E option but -Em means we have either input or output so must update the key accordingly */\n\t\tif (strstr (opt->arg, \"+w\")) {\t/* Writing output to file */\n\t\t\tk = gmtapi_get_key (API, 'E', key, n_keys);\t/* We know this key exist so k is not -1 */\n\t\t\tgmt_M_str_free (key[k]);\n\t\t\tkey[k] = strdup (\"ED)=w\");\t/* Require key to select output to file given via -E+w<file> */\n\t\t}\n\t}\n\n\t/* 4. Determine position of file args given as ? or via missing arg (proxy for input matrix) */\n\t/* Note: All explicit objects must be given after all implicit matrices have been listed */\n\tfor (opt = *head; opt; opt = opt->next) {\t/* Process options */\n\t\tstrip = (strip_colon_opt == opt->option) ? strip_colon : false;\t/* Just turn strip possibly true for the relevant option */\n\t\tk = gmtapi_get_key (API, opt->option, key, n_keys);\t/* If k >= 0 then this option is among those listed in the keys array */\n\t\tfamily = geometry = GMT_NOTSET;\t/* Not set yet */\n\t\tif (k >= 0) {\t/* Got a key, so split out family and geometry flags */\n\t\t\tsdir = gmtapi_key_to_family (API, key[k], &family, &geometry);\t/* Get dir, datatype, and geometry */\n\t\t\tif (sdir < 0) {\t/* Could not determine direction */\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"GMT_Encode_Options: Key not understood so direction is undefined? Notify developers\\n\");\n\t\t\t\tsdir = GMT_IN;\n\t\t\t}\n\t\t\tdirection = (unsigned int) sdir;\n\t\t}\n\t\tmod_pos = gmtapi_extract_argument (opt->arg, argument, key, k, strip, &n_pre_arg);\t/* Pull out the option argument, possibly modified by the key */\n\t\tif (gmtapi_B_custom_annotations (opt)) {\t/* Special processing for -B[p|s][x|y|z]c<nofilegiven>] */\n\t\t\t/* Add this item to our list */\n\t\t\tdirection = GMT_IN;\n\t\t\tinfo[n_items].option    = opt;\n\t\t\tinfo[n_items].family    = GMT_IS_DATASET;\n\t\t\tinfo[n_items].geometry  = GMT_IS_POINT;\n\t\t\tinfo[n_items].direction = GMT_IN;\n\t\t\tinfo[n_items].pos = pos = input_pos++;\t/* Explicitly given arguments are the first given on the r.h.s. */\n\t\t\tkind = GMT_FILE_EXPLICIT;\n\t\t\tn_items++;\n\t\t\tn_in_added++;\n\t\t}\n\t\telse if (gmtapi_found_marker (argument)) {\t/* Found an explicit questionmark within the option, e.g., -G?, -R? or -<? */\n\t\t\tif (opt->option == 'R' && !strcmp (opt->arg, \"?\")) {\t/* -R? means append a grid so set those parameters here */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Option -R? found: explicit grid will be substituted\\n\");\n\t\t\t\tfamily = GMT_IS_GRID;\n\t\t\t\tgeometry = GMT_IS_SURFACE;\n\t\t\t\tdirection = GMT_IN;\n\t\t\t}\n\t\t\telse if (k == GMT_NOTSET) {\t/* Found questionmark but no corresponding key found? */\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"GMT_Encode_Options: Got a -<option>? argument but not listed in keys\\n\");\n\t\t\t\tdirection = GMT_IN;\t/* Have to assume it is an input file if not specified */\n\t\t\t}\n\t\t\tif (is_grdmath && gmtapi_operator_takes_dataset (opt, &geometry))\n\t\t\t\tfamily = GMT_IS_DATASET;\n\t\t\tinfo[n_items].mode = (k >= 0 && api_is_required_IO (key[k][K_DIR])) ? K_PRIMARY : K_SECONDARY;\n\t\t\tif (k >= 0 && key[k][K_DIR] != '-')\n\t\t\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Make sure required { becomes ( and } becomes ) so we don't add them later */\n\t\t\t/* Add this item to our list */\n\t\t\tinfo[n_items].option    = opt;\n\t\t\tinfo[n_items].family    = family;\n\t\t\tinfo[n_items].geometry  = geometry;\n\t\t\tinfo[n_items].direction = direction;\n\t\t\tinfo[n_items].pos = pos = (direction == GMT_IN) ? input_pos++ : output_pos++;\t/* Explicitly given arguments are the first given on the r.h.s. */\n\t\t\tkind = GMT_FILE_EXPLICIT;\n\t\t\tn_items++;\n\t\t\tif (direction == GMT_IN) n_in_added++;\n\t\t}\n\t\telse if (k >= 0 && key[k][K_OPT] != GMT_OPT_INFILE && family != GMT_NOTSET && key[k][K_DIR] != '-') {\t/* Got some option like -G or -Lu with further args */\n\t\t\tbool implicit = true;\n\t\t\tif ((len = strlen (argument)) == (size_t)n_pre_arg)\t/* Got some option like -G or -Lu with no further args */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Option -%c needs implicit arg [offset = %d]\\n\", opt->option, n_pre_arg);\n\t\t\telse if (mod_pos && (argument[mod_pos] == '\\0' || argument[mod_pos] == '+'))\t/* Found an embedded +q<noarg> */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Option -%c needs implicit arg via argument-less +%c modifier\\n\", opt->option, key[k][K_MODIFIER]);\n\t\t\telse\n\t\t\t\timplicit = false;\n\t\t\tif (implicit) {\n\t\t\t\t/* This is an implicit reference and we must explicitly add the missing item by adding the questionmark */\n\t\t\t\tinfo[n_items].option    = opt;\n\t\t\t\tinfo[n_items].family    = family;\n\t\t\t\tinfo[n_items].geometry  = geometry;\n\t\t\t\tinfo[n_items].direction = direction;\n\t\t\t\tinfo[n_items].mode = (api_is_required_IO (key[k][K_DIR])) ? K_PRIMARY : K_SECONDARY;\n\t\t\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Change to ( or ) since option was provided, albeit implicitly */\n\t\t\t\tinfo[n_items].pos = pos = (direction == GMT_IN) ? input_pos++ : output_pos++;\n\t\t\t\t/* Explicitly add the missing marker (e.g., ?) to the option argument */\n\t\t\t\tif (mod_pos) {\t/* Must expand something like 300k+s+d+u into 300k+s?+d+u (assuming +s triggered this test) */\n\t\t\t\t\tstrncpy (txt, opt->arg, mod_pos);\n\t\t\t\t\tstrcat (txt, \"?\");\n\t\t\t\t\tif (opt->arg[mod_pos]) strcat (txt, &opt->arg[mod_pos]);\n\t\t\t\t}\n\t\t\t\telse if (strip)\t/* Special case for quoted and decorated lines with colon separating label info */\n\t\t\t\t\tsnprintf (txt, GMT_LEN256, \"%s?%s\", argument, &opt->arg[2]);\n\t\t\t\telse if (n_pre_arg)\t/* Something like -Lu becomes -Lu? */\n\t\t\t\t\tsnprintf (txt, GMT_LEN256, \"%s?\", opt->arg);\n\t\t\t\telse\t/* Something like -C or -C+d200k becomes -C? or -C?+d200k */\n\t\t\t\t\tsnprintf (txt, GMT_LEN256, \"?%s\", opt->arg);\n\t\t\t\tgmt_M_str_free (opt->arg);\n\t\t\t\topt->arg = strdup (txt);\n\t\t\t\tkind = GMT_FILE_EXPLICIT;\n\t\t\t\tn_items++;\n\t\t\t\tif (direction == GMT_IN) n_in_added++;\n\t\t\t}\n\t\t\telse {\t/* No implicit file argument involved, just check if this satisfies a required option */\n\t\t\t\tkind = GMT_FILE_NONE;\n\t\t\t\tif (k >= 0) {\t/* If this was a required input|output it has now been satisfied */\n\t\t\t\t\t/* Add check to make sure argument for input is an existing file! */\n\t\t\t\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Change to ( or ) since option was provided, albeit implicitly */\n\t\t\t\t\tsatisfy = special_text[direction];\n\t\t\t\t}\n\t\t\t\telse\t/* Nothing special about this option */\n\t\t\t\t\tsatisfy = special_text[2];\n\t\t\t}\n\t\t}\n\t\telse {\t/* No implicit file argument involved, just check if this satisfies a required option */\n\t\t\tkind = GMT_FILE_NONE;\n\t\t\tif (k >= 0) {\t/* If this was a required input|output it has now been satisfied */\n\t\t\t\t/* Add check to make sure argument for input is an existing file! */\n\t\t\t\tkey[k][K_DIR] = api_not_required_io (key[k][K_DIR]);\t/* Change to ( or ) since option was provided, albeit implicitly */\n\t\t\t\tsatisfy = special_text[direction];\n\t\t\t}\n\t\t\telse\t/* Nothing special about this option */\n\t\t\t\tsatisfy = special_text[2];\n\t\t}\n\t\tif (kind == GMT_FILE_EXPLICIT)\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"%s: Option -%c%s includes a memory reference to %s argument # %d\\n\",\n\t\t\t            S[direction], opt->option, opt->arg, LR[direction], pos);\n\t\telse\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"---: Option -%c%s includes no memory reference%s\\n\",\n\t\t\t            opt->option, opt->arg, satisfy);\n\t\tif (n_items == n_alloc) {\n\t\t\tn_alloc <<= 1;\n\t\t\tif ((info = gmt_M_memory (API->GMT, info, n_alloc, struct GMT_RESOURCE)) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Encode_Options: Unable to reallocate GMT_RESOURCE array\\n\");\n\t\t\t\treturn_null (NULL, GMT_MEMORY_ERROR);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Done processing references that were explicitly given in the options.  Now determine if module\n\t * has required input or output references that we must add (if not specified explicitly above) */\n\n\tfor (ku = 0; ku < n_keys; ku++) {\t/* Each set of keys specifies if the item is required via the 3rd key letter */\n\t\tif (api_is_required_IO (key[ku][K_DIR])) {\t/* Required input|output that was not specified explicitly above */\n\t\t\tchar str[2] = {'?',0};\n\t\t\tif ((sdir = gmtapi_key_to_family (API, key[ku], &family, &geometry)) == GMT_NOTSET) {\t/* Extract family and geometry */\n\t\t\t\tGMT_Report (API, GMT_MSG_WARNING, \"Failure to extract family, geometry, and direction!!!!\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (API->GMT->current.setting.run_mode == GMT_MODERN && family == GMT_IS_POSTSCRIPT) continue;\t/* No PS output in modern mode please */\n\t\t\tdirection = (unsigned int) sdir;\n\t\t\t/* We need to know how many implicit items for a given family we might have to add.  For instance,\n\t\t\t * one can usually give any number of data or text tables but only one grid file.  However, this is\n\t\t\t * not a fixed thing, hence we counted up n_per_family from the keys earlier so we have some limits */\n\t\t\tif (direction == GMT_OUT || n_in == GMT_NOTSET)\t/* For output or lack of info we only add one item per key */\n\t\t\t\tn_to_add = 1;\n\t\t\telse\t/* More information to act on for inputs */\n\t\t\t\tn_to_add = (n_per_family[family] == GMTAPI_UNLIMITED) ? n_in - n_in_added : n_per_family[family];\n\t\t\tfor (e = 0; e < n_to_add; e++) {\n\t\t\t\tnew_ptr = GMT_Make_Option (API, key[ku][K_OPT], str);\t/* Create new option(s) with filename \"?\" */\n\t\t\t\t/* Append the new option to the list */\n\t\t\t\t*head = GMT_Append_Option (API, new_ptr, *head);\n\t\t\t\tinfo[n_items].option    = new_ptr;\n\t\t\t\tinfo[n_items].family    = family;\n\t\t\t\tinfo[n_items].geometry  = geometry;\n\t\t\t\tinfo[n_items].direction = direction;\n\t\t\t\tinfo[n_items].pos = (direction == GMT_IN) ? input_pos++ : output_pos++;\n\t\t\t\tinfo[n_items].mode = K_PRIMARY;\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"%s: Must add -%c? as implicit memory reference to %s argument # %d\\n\",\n\t\t\t\t\tS[direction], key[ku][K_OPT], LR[direction], info[n_items].pos);\n\t\t\t\tn_items++;\n\t\t\t\tif (direction == GMT_IN) n_in_added++;\n\t\t\t\tif (n_items == n_alloc) {\n\t\t\t\t\tn_alloc <<= 1;\n\t\t\t\t\tif ((info = gmt_M_memory (API->GMT, info, n_alloc, struct GMT_RESOURCE)) == NULL) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Encode_Options: Unable to reallocate GMT_RESOURCE array\\n\");\n\t\t\t\t\t\treturn_null (NULL, GMT_MEMORY_ERROR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgmt_M_str_free (key[ku]);\t/* Free up this key */\n\t}\n\t/* Free up the temporary key array */\n\tgmt_M_str_free (key);\n\n\t/* Reallocate the information structure array or remove entirely if nothing given. */\n\tif (n_items && n_items < n_alloc) {\n\t\tif ((info = gmt_M_memory (API->GMT, info, n_items, struct GMT_RESOURCE)) == NULL) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Encode_Options: Unable to finalize size of GMT_RESOURCE array\\n\");\n\t\t\treturn_null (NULL, GMT_MEMORY_ERROR);\n\t\t}\n\t}\n\telse if (n_items == 0)\n\t\tgmt_M_free (API->GMT, info);\t/* No containers used */\n\n\tgmt_M_memset (nn, 4, unsigned int);\n\tfor (ku = 0; ku < n_items; ku++)\t/* Count how many primary and secondary objects each for input and output */\n\t\tnn[info[ku].direction][info[ku].mode]++;\n\n\tfor (ku = 0; ku < n_items; ku++) {\t/* Reorder positions so that primary objects are listed before secondary objects */\n\t\tif (info[ku].mode == K_SECONDARY) info[ku].pos += nn[info[ku].direction][K_PRIMARY];\t/* Move secondary objects after all primary objects for this direction */\n\t\telse info[ku].pos -= nn[info[ku].direction][K_SECONDARY];\t/* Move any primary objects to start of list for this direction */\n\t}\n\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Found %d inputs and %d outputs that need memory hook-up\\n\", input_pos, output_pos);\n\t/* Just checking that the options were properly processed */\n\tif (gmt_M_is_verbose (API->GMT, GMT_MSG_DEBUG)) {\n\t\tstatic char *omode[2] = {\"Primary\", \"Secondary\"};\n\t\ttext = GMT_Create_Cmd (API, *head);\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: Revised command before memory-substitution: %s\\n\", text);\n\t\tGMT_Destroy_Cmd (API, &text);\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Encode_Options: List of items returned:\\n\");\n\t\tfor (ku = 0; ku < n_items; ku++) {\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"External API item %2d: Family: %14s Direction: %6s Pos: %d Mode: %s\\n\",\n\t\t\t\tku, GMT_family[info[ku].family], GMT_direction[info[ku].direction], info[ku].pos, omode[info[ku].mode]);\n\t\t}\n\t}\n\n\t/* Pass back the info array and the number of items */\n\t*n = (n_items == 0) ? UINT_MAX : n_items;\t/* E.g., n_keys = 0 for gmtset, gmtdefaults, gmtlogo */\n\treturn (info);\n}\n\n#ifdef FORTRAN_API\nstruct GMT_RESOURCE *GMT_Encode_Options_ (const char *module, int *n_in, struct GMT_OPTION **head, unsigned int *n, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Encode_Options (GMT_FORTRAN, module, *n_in, head, n));\n}\n#endif\n\n/* Parsing API: to present, examine GMT Common Option current settings and GMT Default settings */\n\n/*! . */\nint GMT_Get_Common (void *V_API, unsigned int option, double par[]) {\n\t/* Inquires if specified GMT option has been set and obtains current values for some of them, if par is not NULL.\n\t * Returns GMT_NOTSET if the option has not been specified.  Otherwise, returns the number of parameters\n\t * it passed back via the par[] array.  Only some options passes back parameters; these are\n\t * -R, -I, -X, -Y, -b, -f, -i, -o, -r, -t, -:, while the others return 0.\n\t */\n\tint ret = GMT_NOTSET;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tGMT = API->GMT;\n\n\tswitch (option) {\n\t\tcase 'B':\tif (API->common_snapshot->B.active[0] || API->common_snapshot->B.active[1]) ret = 0; break;\n\t\tcase 'I':\n\t\t\tif (API->common_snapshot->R.active[ISET]) {\n\t\t\t\tret = 2;\n\t\t\t\tif (par) gmt_M_memcpy (par, API->common_snapshot->R.inc, 2, double);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'J':\tif (API->common_snapshot->J.active) ret = 0; break;\n\t\tcase 'K':\tif (API->common_snapshot->K.active) ret = 0; break;\n\t\tcase 'O':\tif (API->common_snapshot->O.active) ret = 0; break;\n\t\tcase 'P':\tif (API->common_snapshot->P.active) ret = 0; break;\n\t\tcase 'R':\n\t\t\tif (API->common_snapshot->R.active[RSET]) {\n\t\t\t\tret = 4;\n\t\t\t\tif (par) gmt_M_memcpy (par, API->common_snapshot->R.wesn, 4, double);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\tif (API->common_snapshot->U.active) ret = 0; break;\n\t\tcase 'V':\tif (API->common_snapshot->V.active) ret = GMT->current.setting.verbose; break;\n\t\tcase 'X':\n\t\t\tif (API->common_snapshot->X.active) {\n\t\t\t\tret = 1;\n\t\t\t\tif (par) par[0] = API->common_snapshot->X.off;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Y':\n\t\t\tif (API->common_snapshot->Y.active) {\n\t\t\t\tret = 1;\n\t\t\t\tif (par) par[0] = API->common_snapshot->Y.off;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':\tif (API->common_snapshot->a.active) ret = API->common_snapshot->a.geometry; break;\n\t\tcase 'b':\tif (API->common_snapshot->b.active[GMT_IN]) ret = GMT_IN; else if (API->common_snapshot->b.active[GMT_OUT]) ret = GMT_OUT; break;\n\t\tcase 'f':\tif (API->common_snapshot->f.active[GMT_IN]) ret = GMT_IN; else if (API->common_snapshot->f.active[GMT_OUT]) ret = GMT_OUT; break;\n\t\tcase 'g':\tif (API->common_snapshot->g.active) ret = 0; break;\n\t\tcase 'h':\tif (API->common_snapshot->h.active) ret = API->common_snapshot->h.mode; break;\n\t\tcase 'i':\tif (API->common_snapshot->i.select) ret = (int)API->common_snapshot->i.n_cols; break;\n\t\tcase 'n':\tif (API->common_snapshot->n.active) ret = 0; break;\n\t\tcase 'o':\tif (API->common_snapshot->o.select) ret = (int)API->common_snapshot->o.n_cols; break;\n\t\tcase 'p':\tif (API->common_snapshot->p.active) ret = 0; break;\n\t\tcase 'r':\tif (API->common_snapshot->R.active[GSET]) ret = API->common_snapshot->R.registration; break;\n\t\tcase 's':\tif (API->common_snapshot->s.active) ret = 0; break;\n\t\tcase 't':\n\t\t\tif (API->common_snapshot->t.active) {\n\t\t\t\tret = 2;\n\t\t\t\tif (par) gmt_M_memcpy (par, API->common_snapshot->t.value, 2, double);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\tif (API->common_snapshot->colon.toggle[GMT_IN]) ret = GMT_IN; else if (API->common_snapshot->colon.toggle[GMT_OUT]) ret = GMT_OUT; break;\n\t\tdefault:\n\t\t\tgmtlib_report_error (API, GMT_OPTION_NOT_FOUND);\n\t\t\tbreak;\n\t}\n\n\treturn (ret);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Common_ (unsigned int *option, double par[]) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Common (GMT_FORTRAN, *option, par));\n}\n#endif\n\n/*! . */\nint GMT_Get_Default (void *V_API, const char *keyword, char *value) {\n\t/* Given the text representation of a GMT parameter keyword, return its setting as text.\n\t * value must have enough space for the return information.\n\t */\n\tint error = GMT_NOERROR;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (keyword == NULL) return_error (V_API, GMT_NO_PARAMETERS);\n\tif (value == NULL) return_error (V_API, GMT_NO_PARAMETERS);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\t/* First intercept any API Keywords */\n\tif (!strncmp (keyword, \"API_VERSION\", 11U))\t/* The API version */\n\t\tsprintf (value, \"%s\", GMT_PACKAGE_VERSION);\n\telse if (!strncmp (keyword, \"API_PAD\", 7U))\t/* Change the grid padding setting */\n\t\tsprintf (value, \"%d\", API->pad);\n\telse if (!strncmp (keyword, \"API_BINDIR\", 10U))\t/* Report binary directory */\n\t\tsprintf (value, \"%s\", API->GMT->init.runtime_bindir);\n\telse if (!strncmp (keyword, \"API_SHAREDIR\", 12U))\t/* Report share directory */\n\t\tsprintf (value, \"%s\", API->GMT->session.SHAREDIR);\n\telse if (!strncmp (keyword, \"API_DATADIR\", 12U))\t/* Report data directory */\n\t\tsprintf (value, \"%s\", API->GMT->session.DATADIR);\n\telse if (!strncmp (keyword, \"API_PLUGINDIR\", 14U))\t/* Report plugin directory */\n\t\tsprintf (value, \"%s\", API->GMT->init.runtime_plugindir);\n\telse if (!strncmp (keyword, \"API_LIBRARY\", 11U))\t/* Report core library */\n\t\tsprintf (value, \"%s\", API->GMT->init.runtime_library);\n\telse if (!strncmp (keyword, \"API_CORES\", 9U))\t/* Report number of cores */\n\t\tsprintf (value, \"%d\", API->n_cores);\n#ifdef HAVE_GDAL\n\telse if (!strncmp (keyword, \"API_IMAGE_LAYOUT\", 16U))\t/* Report image/band layout */\n\t\tgmt_M_memcpy (value, API->GMT->current.gdal_read_in.O.mem_layout, 4, char);\n#endif\n\telse if (!strncmp (keyword, \"API_GRID_LAYOUT\", 15U)) {\t/* Report grid layout */\n\t\tif (API->shape == GMT_IS_COL_FORMAT)\n\t\t\tstrcpy (value, \"columns\");\n\t\telse if (API->shape == GMT_IS_ROW_FORMAT)\n\t\t\tstrcpy (value, \"rows\");\n\t}\n\telse {\t/* Must process as a GMT setting */\n\t\tstrcpy (value, gmtlib_putparameter (API->GMT, keyword));\n\t\terror = (value[0] == '\\0') ? GMT_OPTION_NOT_FOUND : GMT_NOERROR;\n\t}\n\treturn_error (V_API, error);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Default_ (char *keyword, char *value, int len1, int len2) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Default (GMT_FORTRAN, keyword, value));\n}\n#endif\n\n/*! . */\nint GMT_Set_Default (void *V_API, const char *keyword, const char *txt_val) {\n\t/* Given the text representation of a GMT or API parameter keyword, assign its value.\n\t */\n\tunsigned int error = GMT_NOERROR;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tchar *value = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (keyword == NULL) return_error (V_API, GMT_NOT_A_VALID_PARAMETER);\n\tif (txt_val == NULL) return_error (V_API, GMT_NO_PARAMETERS);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tvalue = strdup (txt_val);\t/* Make local copy to be safe */\n\t/* First intercept any API Keywords */\n\tif (!strncmp (keyword, \"API_PAD\", 7U)) {\t/* Change the grid padding setting */\n\t\tint pad = atoi (value);\n\t\tif (pad >= 0) {\n\t\t\tgmt_set_pad (API->GMT, pad);\t/* Change the default pad; give GMT_NOTSET to leave as is */\n\t\t\tAPI->pad = pad;\n\t\t}\n\t}\n#ifdef HAVE_GDAL\n\telse if (!strncmp (keyword, \"API_IMAGE_LAYOUT\", 16U)) {\t/* Change image/band layout */\n\t\tif (strlen (value) != 4U) {\n\t\t\terror = 1;\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"API_IMAGE_LAYOUT requires a 4-character specification. %s is ignored\",  value);\n\t\t}\n\t\telse\n\t\t\tgmt_M_memcpy (API->GMT->current.gdal_read_in.O.mem_layout, value, 4, char);\n\t}\n#endif\n\telse if (!strncmp (keyword, \"API_GRID_LAYOUT\", 15U)) {\t/* Change grid layout */\n\t\t\tif (!strncmp (value, \"columns\", 7U) || (strlen(value) >= 2 && value[1] == 'C'))\t\t/* Accept also TC, though ignore 1st and 3-end chars. Accept this to be consistent with the \"API_IMAGE_LAYOUT\" case */\n\t\t\tAPI->shape = GMT_IS_COL_FORMAT;\t/* Switch to column-major format */\n\t\telse if (!strncmp (value, \"rows\", 4U) || (strlen(value) >= 2 && value[1] == 'R'))\n\t\t\tAPI->shape = GMT_IS_ROW_FORMAT;\t/* Switch to row-major format */\n\t\telse\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"API_GRID_LAYOUT must be either \\\"columns\\\" (or TC) or \\\"rows\\\" (TR)\",  value);\n\t\terror = 1;\n\t}\n\telse\t/* Must process as a GMT setting */\n\t\terror = gmtlib_setparameter (API->GMT, keyword, value, false);\n\tgmt_M_str_free (value);\n\treturn_error (V_API, (error) ? GMT_NOT_A_VALID_PARAMETER : GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Set_Default_ (char *keyword, char *value, int len1, int len2) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Set_Default (GMT_FORTRAN, keyword, value));\n}\n#endif\n\n/*! . */\nint GMT_Option (void *V_API, const char *options) {\n\t/* Take comma-separated GMT options and print the corresponding usage message(s).\n\t * Taken: jbSGzCDkFyA */\n\tunsigned int pos = 0, k = 0, n = 0;\n\tchar p[GMT_LEN64] = {\"\"}, arg[GMT_LEN64] = {\"\"};\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (options == NULL) return_error (V_API, GMT_NO_PARAMETERS);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\n\t/* The following does the translation between the rules for the option string and the convoluted items gmtlib_explain_options expects. */\n\twhile (gmt_strtok (options, \",\", &pos, p) && k < (GMT_LEN64-1)) {\n\t\tswitch (p[0]) {\n\t\t\tcase 'B':\t/* Let B be B and B- be b */\n\t\t\t\targ[k++] = (p[1] == '-') ? 'b' : 'B';\n\t\t\t\tbreak;\n\t\t\tcase 'J':\t/* Let J be -J and J- be j, JX is -Jx|X only, and -J[-]3 be adding -Z for 3-D scaling */\n\t\t\t\tn = 1;\n\t\t\t\tif (p[1] == '-') { arg[k++] = 'j'; n++; }\n\t\t\t\telse if (p[1] == 'X') { arg[k++] = 'x'; n++; }\n\t\t\t\telse arg[k++] = 'J';\n\t\t\t\tif (p[n] == 'Z' || p[n] == 'z') arg[k++] = 'Z';\n\t\t\t\tbreak;\n\t\t\tcase 'R':\t/* Want -R region usage */\n\t\t\t\tif (p[1]) {\t/* Gave modifiers */\n\t\t\t\t\tif (p[1] == 'x') arg[k++] = 'S';\t/* CarteSian region */\n\t\t\t\t\telse if (p[1] == 'g') arg[k++] = 'G';\t/* Geographic region */\n\t\t\t\t\telse arg[k++] = 'R';\t\t\t/* Generic region [Default] */\n\t\t\t\t\tif (p[1] == '3' || p[2] == '3') arg[k++] = 'z';\t/* 3-D region */\n\t\t\t\t}\n\t\t\t\telse arg[k++] = 'R';\t\t\t/* Generic region [Default] */\n\t\t\t\tbreak;\n\t\t\tcase 'b':\t/* Binary i/o -bi -bo */\n\t\t\t\targ[k++] = (p[1] == 'i') ? 'C' : 'D';\n\t\t\t\targ[k++] = (p[2]) ? p[2] : '0';\n\t\t\t\tbreak;\n\t\t\tcase 'd':\t/* Nodata flag -d, -di, -do */\n\t\t\t\tif (p[1] == 'i') arg[k++] = 'k';\n\t\t\t\telse if (p[1] == 'o') arg[k++] = 'm';\n\t\t\t\telse arg[k++] = 'd';\n\t\t\t\tbreak;\n\t\t\tcase 'j':\t/* Spherical distance calculation mode */\n\t\t\t\targ[k++] = 'A';\n\t\t\t\tbreak;\n\t\t\tcase 'q':\t/* Row selection, either just input, output, or both */\n\t\t\t\tif (p[1] == 'i')\n\t\t\t\t\targ[k++] = 'u';\n\t\t\t\telse if (p[1] == 'o')\n\t\t\t\t\targ[k++] = 'v';\n\t\t\t\telse\n\t\t\t\t\targ[k++] = p[0];\n\t\t\t\tbreak;\n\t\t\tcase 'r':\t/* Pixel registration */\n\t\t\t\targ[k++] = 'F';\n\t\t\t\tbreak;\n\t\t\tcase 'x':\t/* Number of threads (for multi-threaded progs) */\n\t\t\t\targ[k++] = 'y';\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* All others are pass-through */\n\t\t\t\targ[k++] = p[0];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgmtlib_explain_options (API->GMT, arg);\t/* Call the underlying explain_options machinery */\n\treturn_error (V_API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Option_ (char *options, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Option (GMT_FORTRAN, options));\n}\n#endif\n\n/*! . */\nint GMT_Message (void *V_API, unsigned int mode, const char *format, ...) {\n\t/* Message independent of verbosity, optionally with timestamp.\n\t * mode = 0:\tNo time stamp\n\t * mode = 1:\tAbs time stamp formatted via GMT_TIME_STAMP\n\t * mode = 2:\tReport elapsed time since last reset.\n\t * mode = 4:\tReset elapsed time to 0, no time stamp.\n\t * mode = 6:\tReset elapsed time and report it as well.\n\t */\n\tsize_t source_info_len;\n\tchar *stamp = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tFILE *err = stderr;\n\tva_list args;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (format == NULL) return GMT_PTR_IS_NULL;\t/* Format cannot be NULL */\n\tAPI = gmtapi_get_api_ptr (V_API);\t/* Get the typecast structure pointer to API */\n\tAPI->message[0] = '\\0';\t/* Start fresh */\n\tif (mode) stamp = gmtapi_tictoc_string (API, mode);\t/* Pointer to a timestamp string */\n\tif (mode % 4) sprintf (API->message, \"%s | \", stamp);\t/* Lead with the time stamp */\n\tsource_info_len = strlen (API->message);\n\n\tva_start (args, format);\n\tvsnprintf (API->message + source_info_len, GMT_MSGSIZ - source_info_len, format, args);\n\tva_end (args);\n\tassert (strlen (API->message) < GMT_MSGSIZ);\n\tif (API->GMT) err = API->GMT->session.std[GMT_ERR];\n\tAPI->print_func (err, API->message);\t/* Do the printing */\n\treturn_error (V_API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Message_ (unsigned int *mode, const char *message, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Message (GMT_FORTRAN, *mode, message));\n}\n#endif\n\n/*! . */\nint GMT_Report (void *V_API, unsigned int level, const char *format, ...) {\n\t/* Message whose output depends on verbosity setting */\n\tsize_t source_info_len = 0;\n\tunsigned int g_level;\n\tconst char *module_name;\n\tchar not_used[GMT_LEN32];\n\tFILE *err = stderr;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\tva_list args;\n\t/* GMT_Report may be called before GMT is set so take precautions */\n\tif (V_API == NULL) return GMT_NOERROR;\t\t/* Not a fatal issue here but we cannot report anything */\n\tif (level == GMT_MSG_QUIET)\t\t/* We don't want to hear it, period. */\n\t\treturn GMT_NOERROR;\n\tAPI = gmtapi_get_api_ptr (V_API);\t/* Get the typecast structure pointer to API */\n\tGMT = API->GMT;\t/* Short-hand for the GMT sub-structure */\n\tg_level = (GMT) ? GMT->current.setting.verbose : GMT_MSG_QUIET;\n\tif (GMT) err = GMT->session.std[GMT_ERR];\n\tif (level > MAX(API->verbose, g_level))\n\t\treturn GMT_NOERROR;\n\tif (format == NULL) return GMT_PTR_IS_NULL;\t/* Format cannot be NULL */\n\tAPI->message[0] = '\\0';\t/* Start fresh */\n\tif (GMT && GMT->current.setting.timer_mode > GMT_NO_TIMER) {\n\t\tchar *stamp = gmtapi_tictoc_string (API, GMT->current.setting.timer_mode);\t/* NULL or pointer to a timestamp string */\n\t\tif (stamp) {\n\t\t\tsprintf (API->message, \"%s | \", stamp);\t/* Lead with the time stamp */\n\t\t\tsource_info_len = strlen (API->message);\t/* Update length of message from 0 */\n\t\t}\n\t}\n\tif (GMT && GMT->init.module_name)\n\t\tmodule_name = ((GMT->current.setting.run_mode == GMT_MODERN)) ? gmt_current_name (GMT->init.module_name, not_used) : GMT->init.module_name;\n\telse\n\t\tmodule_name = API->session_tag;\n\n\tsnprintf (API->message + source_info_len, GMT_MSGSIZ-source_info_len, \"%s [%s]: \", module_name, GMT_class[level]);\n\tsource_info_len = strlen (API->message);\n\tva_start (args, format);\n\t/* append format to the message: */\n\tvsnprintf (API->message + source_info_len, GMT_MSGSIZ - source_info_len, format, args);\n\tva_end (args);\n\tassert (strlen (API->message) < GMT_MSGSIZ);\n\tgmt_M_memcpy (API->error_msg, API->message, GMT_BUFSIZ-1, char);\n\tAPI->print_func (err, API->message);\n\treturn_error (V_API, GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Report_ (unsigned int *level, const char *format, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Report (GMT_FORTRAN, *level, format));\n}\n#endif\n\nchar * GMT_Error_Message (void *V_API) {\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\t/* Get the typecast structure pointer to API */\n\treturn (API->error_msg);\n}\n\n#ifdef FORTRAN_API\nchar * GMT_Error_Message_ () {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Error_Message (GMT_FORTRAN));\n}\n#endif\n\n/*! . */\nint GMT_Handle_Messages (void *V_API, unsigned int mode, unsigned int method, void *dest) {\n\t/* Change where verbosity messages go */\n\tstruct GMTAPI_CTRL *API = NULL;\n\tFILE *fp = NULL;\n\tint *fd = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tswitch (mode) {\n\t\tcase GMT_LOG_OFF:\t/* Close log file and reset to stderr */\n\t\t\tif (API->log_level == GMT_LOG_SET)\n\t\t\t\tfclose (API->GMT->session.std[GMT_ERR]);\n\t\t\tAPI->GMT->session.std[GMT_ERR] = stderr;\n\t\t\tbreak;\n\t\tcase GMT_LOG_ONCE:\t/* Redirect message just until end of next module */\n\t\tcase GMT_LOG_SET:\t/* Redirect message until end of session (or changed) */\n\t\t\tif (API->log_level)\t/* Cannot turn on when already on */\n\t\t\t\treturn_error (V_API, GMT_LOGGING_ALREADY_ACTIVE);\n\t\t\tswitch (method) {\n\t\t\t\tcase GMT_IS_FILE:\n\t\t\t\t\tif ((fp = fopen (dest, \"w\")) == NULL) {\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to open error log file %s\\n\", dest);\n\t\t\t\t\t\treturn_error (API, GMT_ERROR_ON_FOPEN);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_STREAM:\n\t\t\t\t\tfp = dest;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_FDESC:\n\t\t\t\t\tfd = (int *)dest;\t/* Extract the file handle integer */\n\t\t\t\t\tif ((fp = fdopen (*fd, \"w\")) == NULL) {\t/* Reopen handle as stream */\n\t\t\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to open file descriptor %d for error log\\n\", *fd);\n\t\t\t\t\t\treturn_error (API, GMT_ERROR_ON_FDOPEN);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn_error (API, GMT_NOT_A_VALID_METHOD);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAPI->GMT->session.std[GMT_ERR] = fp;\t/* Set the error fp pointer */\n\t\t\tAPI->log_level = mode;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn_error (API, GMT_NOT_A_VALID_LOGMODE);\n\t\t\tbreak;\n\t}\n\treturn (GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Handle_Messages_ (unsigned int *mode, unsigned int *method, void *dest) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Handle_Messages (GMT_FORTRAN, *mode, *method, dest));\n}\n#endif\n\n/*! . */\nint GMT_Get_Values (void *V_API, const char *arg, double par[], int maxpar) {\n\t/* Parse any number of comma, space, tab, semi-colon or slash-separated values.\n\t * The array par must have enough space to hold a maximum of maxpar items.\n\t * Function returns the number of items, or GMT_NOTSET if there was an error.\n\t * When there are more than maxpar items, only the first maxpar are stored, and\n\t * the value of maxpar is returned.\n\t * We can handle dimension units (c|i|p), distance units (d|m|s|e|f|k|M|n|u),\n\t * geographic coordinates, absolute dateTtime strings, and regular floats.\n\t *\n\t * Dimensions are returned in the current length unit [inch or cm].\n\t * Distances are returned in meters.\n\t * Arc distances are returned in degrees.\n\t * Geographic dd:mm:ss[W|E|S|N] coordinates are returned in decimal degrees.\n\t * DateTtime moments are returned in time in chosen units [sec] since chosen epoch [1970] */\n\n\tunsigned int pos = 0, mode, col_type_save[2][2];\n\tint npar = 0;\n\tsize_t len;\n\tchar p[GMT_BUFSIZ] = {\"\"}, unit, col_set_save[2][2];\n\tdouble value;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_CTRL *GMT = NULL;\n\tstatic const char separators[] = \" \\t,;/\";\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (arg == NULL || arg[0] == '\\0') return_value (V_API, GMT_NO_PARAMETERS, GMT_NOTSET);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tGMT = API->GMT;\n\tAPI->error = GMT_NOERROR;\n\n\t/* Because gmt_init_distaz and possibly gmt_scanf_arg may decide to change the GMT col_type\n\t * for x and y we make a copy here and reset when done */\n\tgmt_M_memcpy (col_type_save[GMT_IN],  GMT->current.io.col_type[GMT_IN],   2, unsigned int);\n\tgmt_M_memcpy (col_type_save[GMT_OUT], GMT->current.io.col_type[GMT_OUT],  2, unsigned int);\n\tgmt_M_memcpy (col_set_save[GMT_IN],   GMT->current.io.col_set[GMT_IN],    2, char);\n\tgmt_M_memcpy (col_set_save[GMT_OUT],  GMT->current.io.col_set[GMT_OUT],   2, char);\n\n\twhile (gmt_strtok (arg, separators, &pos, p)) {\t/* Loop over input arguments */\n\t\tif ((len = strlen (p)) == 0) continue;\n\t\tif (npar >= maxpar) {\t/* Bail out when already maxpar values are stored */\n\t\t\tgmtlib_report_error (API, GMT_DIM_TOO_LARGE);\n\t\t\tbreak;\n\t\t}\n\t\tlen--;\t/* Position of last char, possibly a unit */\n\t\tif (strchr (GMT_DIM_UNITS, p[len]))\t/* Dimension unit (c|i|p), return distance in GMT default length unit [inch or cm] */\n\t\t\tvalue = gmt_convert_units (GMT, p, GMT->current.setting.proj_length_unit, GMT->current.setting.proj_length_unit);\n\t\telse if (strchr (GMT_LEN_UNITS, p[len])) {\t/* Distance units, return as meters [or degrees if arc] */\n\t\t\tmode = gmt_get_distance (GMT, p, &value, &unit);\n\t\t\tif (gmt_init_distaz (GMT, unit, mode, GMT_MAP_DIST) == GMT_NOT_A_VALID_TYPE) return_value (V_API, GMT_NOT_A_VALID_TYPE, GMT_NOTSET);\n\t\t\tvalue /= GMT->current.map.dist[GMT_MAP_DIST].scale;\t/* Convert to default unit */\n\t\t}\n\t\telse\t/* Perhaps coordinates or floats */\n\t\t\t(void) gmt_scanf_arg (GMT, p, GMT_IS_UNKNOWN, false, &value);\n\t\tpar[npar++] = value;\n\t}\n\t/* Reset col_types to what they were before the parsing */\n\tgmt_M_memcpy (GMT->current.io.col_type[GMT_IN],  col_type_save[GMT_IN],  2, unsigned int);\n\tgmt_M_memcpy (GMT->current.io.col_type[GMT_OUT], col_type_save[GMT_OUT], 2, unsigned int);\n\tgmt_M_memcpy (GMT->current.io.col_set[GMT_IN],   col_set_save[GMT_IN],   2, char);\n\tgmt_M_memcpy (GMT->current.io.col_set[GMT_OUT],  col_set_save[GMT_OUT],  2, char);\n\n\treturn (npar);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Values_ (char *arg, double par[], int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Values (GMT_FORTRAN, arg, par, len));\n}\n#endif\n\n/* Here lies the very basic F77 support for grid read and write only. It is assumed that no grid padding is required */\n\n#define F_STRNCPY(dst,src,ldst,lsrc) { int l = MIN(ldst-1, lsrc); strncpy (dst, src, l); dst[l] = '\\0'; }\n\nint gmt_f77_readgrdinfo_ (unsigned int dim[], double limit[], double inc[], char *title, char *remark, const char *name, int ltitle, int lremark, int lname) {\n\t/* Note: When returning, dim[2] holds the registration (0 = gridline, 1 = pixel).\n\t * limit[4-5] holds zmin/zmax. limit must thus at least have a length of 6.\n\t */\n\tconst char *argv = \"GMT_F77_readgrdinfo\";\n\tchar *file = NULL;\n\tstruct GMT_GRID_HEADER header;\n\tstruct GMTAPI_CTRL *API = NULL;\t/* The API pointer assigned below */\n\n\tif (name == NULL) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"No filename given to GMT_F77_readgrdinfo\\n\");\n\t\treturn GMT_ARG_IS_NULL;\n\t}\n\tif ((API = GMT_Create_Session (argv, 0U, 0U, NULL)) == NULL) return GMT_MEMORY_ERROR;\n\tfile = strndup (name, lname);\n\n\t/* Read the grid header */\n\n\tgmt_M_memset (&header, 1, struct GMT_GRID_HEADER);\t/* To convince Coverity that header->index_function has been initialized */\n\tif (gmtlib_read_grd_info (API->GMT, file, &header)) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Failure while opening file %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_GRID_READ_ERROR;\n\t}\n\tgmt_M_str_free (file);\n\n\t/* Assign variables from header structure items */\n\tdim[GMT_X] = header.n_columns;\tdim[GMT_Y] = header.n_rows;\n\tgmt_M_memcpy (limit, header.wesn, 4U, double);\n\tgmt_M_memcpy (inc, header.inc, 2U, double);\n\tlimit[ZLO] = header.z_min;\n\tlimit[ZHI] = header.z_max;\n\tdim[GMT_Z] = header.registration;\n\tif (title) F_STRNCPY (title, header.title, ltitle, GMT_GRID_TITLE_LEN80);\n\tif (remark) F_STRNCPY (remark, header.remark, lremark, GMT_GRID_REMARK_LEN160);\n\n\tif (GMT_Destroy_Session (API) != GMT_NOERROR) return GMT_RUNTIME_ERROR;\n\treturn GMT_NOERROR;\n}\n\nint gmt_f77_readgrd_ (gmt_grdfloat *array, unsigned int dim[], double limit[], double inc[], char *title, char *remark, const char *name, int ltitle, int lremark, int lname) {\n\t/* Note: When called, dim[2] is 1 we allocate the array, otherwise we assume it has enough space\n\t * Also, if dim[3] == 1 then we transpose the array before writing.\n\t * When returning, dim[2] holds the registration (0 = gridline, 1 = pixel).\n\t * limit[4-5] holds zmin/zmax. limit must thus at least have a length of 6.\n\t */\n\tdouble no_wesn[4] = {0.0, 0.0, 0.0, 0.0};\n\tconst char *argv = \"GMT_F77_readgrd\";\n\tchar *file = NULL;\n\tstruct GMT_GRID_HEADER *header = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\t/* The API pointer assigned below */\n\n\tif (name == NULL) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"No filename given to GMT_F77_readgrd\\n\");\n\t\treturn GMT_ARG_IS_NULL;\n\t}\n\tif ((API = GMT_Create_Session (argv, 0U, 0U, NULL)) == NULL) return GMT_MEMORY_ERROR;\n\tfile = strndup (name, lname);\n\n\theader = gmt_get_header (API->GMT);\n\t/* Read the grid header */\n\tgmt_grd_init (API->GMT, header, NULL, false);\n\tif (gmtlib_read_grd_info (API->GMT, file, header)) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Failure while opening file %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tgmt_free_header (API->GMT, &header);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_GRID_READ_ERROR;\n\t}\n\n\t/* Read the grid, possibly after first allocating array space */\n\tif (dim[GMT_Z] == 1) array = gmt_M_memory (API->GMT, NULL, header->size, gmt_grdfloat);\n\tif (gmtlib_read_grd (API->GMT, file, header, array, no_wesn, GMT_no_pad, 0)) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Failure while reading file %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tgmt_free_header (API->GMT, &header);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_GRID_READ_ERROR;\n\t}\n\tgmt_M_str_free (file);\n\n\tif (dim[3] == 1) gmtlib_inplace_transpose (array, header->n_rows, header->n_columns);\n\n\t/* Assign variables from header structure items */\n\tdim[GMT_X] = header->n_columns;\tdim[GMT_Y] = header->n_rows;\n\tgmt_M_memcpy (limit, header->wesn, 4U, double);\n\tgmt_M_memcpy (inc, header->inc, 2U, double);\n\tlimit[ZLO] = header->z_min;\n\tlimit[ZHI] = header->z_max;\n\tdim[GMT_Z] = header->registration;\n\tif (title) F_STRNCPY (title, header->title, ltitle, GMT_GRID_TITLE_LEN80);\n\tif (remark) F_STRNCPY (remark, header->remark, lremark, GMT_GRID_REMARK_LEN160);\n\n\tgmt_M_free (API->GMT, header->hidden);\n\tgmt_M_free (API->GMT, header);\n\n\tif (GMT_Destroy_Session (API) != GMT_NOERROR) return GMT_RUNTIME_ERROR;\n\treturn GMT_NOERROR;\n}\n\nint gmt_f77_writegrd_ (gmt_grdfloat *array, unsigned int dim[], double limit[], double inc[], const char *title, const char *remark, const char *name, int ltitle, int lremark, int lname) {\n\t/* Note: When called, dim[2] holds the registration (0 = gridline, 1 = pixel).\n\t * Also, if dim[3] == 1 then we transpose the array before writing.  */\n\tconst char *argv = \"GMT_F77_writegrd\";\n\tchar *file = NULL;\n\tdouble no_wesn[4] = {0.0, 0.0, 0.0, 0.0};\n\tstruct GMT_GRID_HEADER header;\n\tstruct GMTAPI_CTRL *API = NULL;\t/* The API pointer assigned below */\n\n\t/* Initialize with default values */\n\n\tif (name == NULL) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"No filename given to GMT_F77_writegrd\\n\");\n\t\treturn GMT_ARG_IS_NULL;\n\t}\n\tif ((API = GMT_Create_Session (argv, 0U, 0U, NULL)) == NULL) return GMT_MEMORY_ERROR;\n\tfile = strndup (name, lname);\n\n\tgmt_M_memset (&header, 1, struct GMT_GRID_HEADER);\t/* To convince Coverity that header->index_function has been initialized */\n\tgmt_grd_init (API->GMT, &header, NULL, false);\n\tif (full_region (limit)) {\t/* Here that means limit was not properly given */\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Grid domain not specified for %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_ARG_IS_NULL;\n\t}\n\tif (inc[GMT_X] == 0.0 || inc[GMT_Y] == 0.0) {\t/* Here that means grid spacing was not properly given */\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Grid spacing not specified for %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_ARG_IS_NULL;\n\t}\n\n\t/* Set header parameters */\n\n\tgmt_M_memcpy (header.wesn, limit, 4U, double);\n\tgmt_M_memcpy (header.inc, inc, 2U, double);\n\theader.n_columns = dim[GMT_X];\theader.n_rows = dim[GMT_Y];\n\theader.registration = dim[GMT_Z];\n\tgmt_set_grddim (API->GMT, &header);\n\tif (title) F_STRNCPY (header.title, title, GMT_GRID_TITLE_LEN80, ltitle);\n\tif (remark) F_STRNCPY (header.remark, remark, GMT_GRID_REMARK_LEN160, lremark);\n\n\tif (dim[3] == 1) gmtlib_inplace_transpose (array, header.n_rows, header.n_columns);\n\n\t/* Write the file */\n\n\tif (gmtlib_write_grd (API->GMT, file, &header, array, no_wesn, GMT_no_pad, 0)) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Failure while writing file %s\\n\", file);\n\t\tgmt_M_str_free (file);\n\t\tGMT_Destroy_Session (API);\n\t\treturn GMT_GRID_WRITE_ERROR;\n\t}\n\tgmt_M_str_free (file);\n\n\tif (GMT_Destroy_Session (API) != GMT_NOERROR) return GMT_MEMORY_ERROR;\n\treturn GMT_NOERROR;\n}\n\n/* wrappers for several Fortran compilers */\n#define F77_ARG1 unsigned int dim[], double limit[], double inc[], char *title, char *remark, const char *name, int ltitle, int lremark, int lname\n#define F77_ARG2 dim, limit, inc, title, remark, name, ltitle, lremark, lname\nint gmt_f77_readgrdinfo__(F77_ARG1) { return gmt_f77_readgrdinfo_ (F77_ARG2); }\nint gmt_f77_readgrdinfo  (F77_ARG1) { return gmt_f77_readgrdinfo_ (F77_ARG2); }\nint GMT_F77_READGRDINFO_ (F77_ARG1) { return gmt_f77_readgrdinfo_ (F77_ARG2); }\nint GMT_F77_READGRDINFO  (F77_ARG1) { return gmt_f77_readgrdinfo_ (F77_ARG2); }\n#undef  F77_ARG1\n#undef  F77_ARG2\n\n#define F77_ARG1 gmt_grdfloat *array, unsigned int dim[], double limit[], double inc[], char *title, char *remark, const char *name, int ltitle, int lremark, int lname\n#define F77_ARG2 array, dim, limit, inc, title, remark, name, ltitle, lremark, lname\nint gmt_f77_readgrd__ (F77_ARG1) { return gmt_f77_readgrd_ (F77_ARG2); }\nint gmt_f77_readgrd   (F77_ARG1) { return gmt_f77_readgrd_ (F77_ARG2); }\nint GMT_F77_READGRD_  (F77_ARG1) { return gmt_f77_readgrd_ (F77_ARG2); }\nint GMT_F77_READGRD   (F77_ARG1) { return gmt_f77_readgrd_ (F77_ARG2); }\n#undef  F77_ARG1\n\n#define F77_ARG1 gmt_grdfloat *array, unsigned int dim[], double limit[], double inc[], const char *title, const char *remark, const char *name, int ltitle, int lremark, int lname\nint gmt_f77_writegrd__ (F77_ARG1) { return gmt_f77_writegrd_ (F77_ARG2); }\nint gmt_f77_writegrd   (F77_ARG1) { return gmt_f77_writegrd_ (F77_ARG2); }\nint GMT_F77_WRITEGRD_  (F77_ARG1) { return gmt_f77_writegrd_ (F77_ARG2); }\nint GMT_F77_WRITEGRD   (F77_ARG1) { return gmt_f77_writegrd_ (F77_ARG2); }\n#undef  F77_ARG1\n#undef  F77_ARG2\n\nchar *GMT_Duplicate_String (void *API, const char* string) {\n\t/* Duplicate a string. The interest of this function is to make the memory allocation\n\t   inside the GMT lib so that GMT_Destroy_Data we can free it without any concerns of\n\t   Windows DLL hell */\n\tgmt_M_unused(API);\n\treturn strdup (string);\n}\n\n\n/* Sub-functions to perform specific conversions */\n\n#define do_tbl_header(flag) (flag == 0 || flag == 2)\n#define do_seg_header(flag) (flag == 0 || flag == 1)\n\n/* GMT_DATASET to GMT_* : */\n\nGMT_LOCAL void * gmtapi_dataset2dataset (struct GMTAPI_CTRL *API, struct GMT_DATASET *In, struct GMT_DATASET *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a dataset to another dataset using current formatting and column type information.\n\t * If Out is not NULL then we assume it has exact same dimension as the dataset, but no headers/records allocated.\n\t * header controls what we do with headers.\n\t * If mode == GMT_WRITE_TABLE_SEGMENT then we combine all segments into a SINGLE segment in ONE table\n\t * If mode == GMT_WRITE_TABLE then we collect all segments into ONE table.\n\t * If mode == GMT_WRITE_SEGMENT then we combine segments into ONE segment per table.\n\t */\n\tunsigned int hdr;\n\tuint64_t tbl, seg, row, col, n_rows, tbl_out = 0, row_out = 0, seg_out = 0;\n\tbool s_alloc, t_alloc, alloc, was;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATATABLE *Tin = NULL;\n\tstruct GMT_DATATABLE *Tout = NULL;\n\tstruct GMT_DATASEGMENT *Sin = NULL;\n\tstruct GMT_DATASEGMENT *Sout = NULL;\n\tstruct GMT_DATATABLE_HIDDEN *TH = NULL;\n\ts_alloc = t_alloc = alloc = (Out == NULL);\n\tif (alloc) {\t/* Must allocate output dataset */\n\t\tOut = gmt_get_dataset (GMT);\n\t\tOut->n_tables = (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) ? 1 : In->n_tables;\n\t\tOut->table = gmt_M_memory (GMT, NULL, Out->n_tables, struct GMT_DATATABLE *);\n\t}\n\twas = GMT->current.setting.io_header[GMT_OUT];\n\tGMT->current.setting.io_header[GMT_OUT] = do_tbl_header (header);\n\tOut->n_segments = (mode == GMT_WRITE_TABLE_SEGMENT) ? 1 : ((mode == GMT_WRITE_SEGMENT) ? In->n_tables : In->n_segments);\n\tOut->n_records  = In->n_records;\n\tOut->n_columns  = In->n_columns;\n\tfor (tbl = 0; tbl < In->n_tables; tbl++) {\n\t\tif (mode == GMT_WRITE_SEGMENT) row_out = 0;\t/* Reset row output counter on a per table basis */\n\t\telse if (mode == 0) seg_out = 0;\t/* Reset segment output counter on a per table basis */\n\t\tif (alloc && (mode == 0 || mode == GMT_WRITE_SEGMENT)) s_alloc = true;\t/* Need to allocate at least one segment per table */\n\t\tTin = In->table[tbl];\t/* Shorthand to current input data table */\n\t\tif (t_alloc) {\n\t\t\tOut->table[tbl_out] = Tout = gmt_get_table (GMT);\n\t\t\tTH = gmt_get_DT_hidden (Tout);\n\t\t\tTout->n_segments = TH->n_alloc = (mode == GMT_WRITE_TABLE_SEGMENT || mode == GMT_WRITE_SEGMENT) ? 1 : ((mode == GMT_WRITE_TABLE) ? In->n_segments : Tin->n_segments);\t/* Number of segments in this table */\n\t\t\tTout->n_records  = (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) ? In->n_records : Tin->n_records;\t/* Number of data records int this table */\n\t\t\tTout->n_columns = In->n_columns;\n\t\t}\n\t\telse\n\t\t\tTout = Out->table[tbl_out];\n\t\tif (t_alloc) {\n\t\t\tif (Tin->n_headers && do_tbl_header(header)) {\t/* Allocate and duplicate headers */\n\t\t\t\tTout->n_headers = Tin->n_headers;\t/* Same number of header records as input table */\n\t\t\t\tif (alloc) Tout->header = gmt_M_memory (GMT, NULL, Tout->n_headers, char *);\n\t\t\t\tfor (hdr = 0; hdr < Tout->n_headers; hdr++) Tout->header[hdr] = strdup (Tin->header[hdr]);\n\t\t\t}\n\t\t\tTout->segment = gmt_M_memory (GMT, NULL, Tout->n_segments, struct GMT_DATASEGMENT *);\n\t\t}\n\t\tfor (seg = 0; seg < Tin->n_segments; seg++) {\t/* For each input table segment */\n\t\t\tif (mode == 0 || mode == GMT_WRITE_TABLE) row_out = 0;\t/* Reset row output counter on a per segment basis */\n\t\t\tSin = Tin->segment[seg];\t/* Shorthand to current data segment */\n\t\t\tif (s_alloc) {\t/* Allocate another segment */\n\t\t\t\tunsigned int smode = (Sin->text) ? GMT_WITH_STRINGS : GMT_NO_STRINGS;\n\t\t\t\tn_rows = (mode == GMT_WRITE_TABLE_SEGMENT) ? In->n_records : ((mode == GMT_WRITE_SEGMENT) ? Tin->n_records : Sin->n_rows);\n\t\t\t\tTout->segment[seg_out] = GMT_Alloc_Segment (API, smode, n_rows, In->n_columns, NULL, NULL);\n\t\t\t\tSout = Tout->segment[seg_out];\t/* Shorthand to current text segment */\n\t\t\t\tif (Sin->header && do_seg_header(header)) Sout->header = strdup (Sin->header);\n\t\t\t}\n\t\t\telse\n\t\t\t\tSout = Tout->segment[seg_out];\n\t\t\tfor (row = 0; row < Sin->n_rows; row++, row_out++) {\t/* Copy each row to (new) segment */\n\t\t\t\tfor (col = 0; col < Sin->n_columns; col++)\n\t\t\t\t\tSout->data[col][row_out] = Sin->data[col][row];\n\t\t\t}\n\t\t\tif (mode == GMT_WRITE_SEGMENT || mode == GMT_WRITE_TABLE_SEGMENT) s_alloc = false;\t/* Only allocate this single segment, at least for this table */\n\t\t\tif (mode == 0 || mode == GMT_WRITE_TABLE) seg_out++;\t/* More than one segment on output */\n\t\t}\n\t\tif (mode == GMT_WRITE_TABLE || mode == GMT_WRITE_TABLE_SEGMENT) t_alloc = false;\t/* Only allocate this single table */\n\t\tif (mode == 0 || mode == GMT_WRITE_SEGMENT) tbl_out++;\t/* More than one segment on output */\n\t}\n\tGMT->current.setting.io_header[GMT_OUT] = was;\n\treturn Out;\n}\n\nGMT_LOCAL void *gmtapi_dataset2matrix (struct GMTAPI_CTRL *API, struct GMT_DATASET *In, struct GMT_MATRIX *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a dataset to a matrix.\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t * Header controls if segment headers are written as NaN recs\n\t * If mode > 0 then it is assumed to hold GMT_TYPE-1, else we assume the GMT default setting.\n\t * If there are more than one segment we will insert NaN-records between segments.\n\t */\n\tuint64_t tbl, seg, row, row_out, col, ij;\n\tbool alloc = (Out == NULL), add_NaN_record = (In->n_segments > 1 && do_seg_header(header));\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATATABLE *D = NULL;\n\tstruct GMT_DATASEGMENT *SD = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\n\tif (alloc) {\t/* Must allocate the output matrix */\n\t\tstruct GMT_MATRIX_HIDDEN *MH = NULL;\n\t\tif ((Out = gmtlib_create_matrix (GMT, 1U, GMT_OUT, 0)) == NULL) return (NULL);\n\t\tOut->n_rows = In->n_records + (add_NaN_record ? In->n_segments : 0);\n\t\tOut->n_columns = Out->dim = In->n_columns;\n\t\tOut->type = (mode) ? mode - 1 : API->GMT->current.setting.export_type;\n\t\tif (gmtlib_alloc_univector (GMT, &(Out->data), Out->type, Out->n_rows * Out->n_columns)) {\n\t\t\tgmt_M_free (GMT, Out);\n\t\t\treturn (NULL);\n\t\t}\n\t\tMH = gmt_get_M_hidden (Out);\n\t\tMH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t}\n\tif ((api_put_val = gmtapi_select_put_function (API, Out->type)) == NULL) {\n\t\tgmt_M_free (GMT, Out);\n\t\treturn (NULL);\n\t}\n\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, Out->shape, GMT_GRID_IS_REAL)) == NULL) {\n\t\tgmt_M_free (GMT, Out);\n\t\treturn (NULL);\n\t}\n\tfor (tbl = row_out = 0; tbl < In->n_tables; tbl++) {\n\t\tD = In->table[tbl];\t/* Shorthand to current input data table */\n\t\tfor (seg = 0; seg < D->n_segments; seg++) {\n\t\t\tSD = D->segment[seg];\t/* Shorthand */\n\t\t\tif (add_NaN_record) {\n\t\t\t\tfor (col = 0; col < SD->n_columns; col++) {\n\t\t\t\t\tij = GMT_2D_to_index (row_out, col, Out->dim);\n\t\t\t\t\tapi_put_val (&(Out->data), ij, GMT->session.d_NaN);\n\t\t\t\t}\n\t\t\t\trow_out++;\t/* Due to the extra NaN-data header record we just wrote */\n\t\t\t}\n\t\t\tfor (row = 0; row < SD->n_rows; row++, row_out++) {\n\t\t\t\tfor (col = 0; col < SD->n_columns; col++) {\n\t\t\t\t\tij = GMT_2D_to_index (row_out, col, Out->dim);\n\t\t\t\t\tapi_put_val (&(Out->data), ij, SD->data[col][row]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn Out;\n}\n\nGMT_LOCAL void * gmtapi_dataset2vector (struct GMTAPI_CTRL *API, struct GMT_DATASET *In, struct GMT_VECTOR *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a dataset to vectors.\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t * If mode > 0 then it is assumed to hold GMT_TYPE-1, else we assume the GMT default setting.\n\t * If there are more than one segment we will insert NaN-records between segments.\n\t */\n\tuint64_t tbl, seg, row, row_out, col;\n\tbool alloc = (Out == NULL), add_NaN_record = (In->n_segments > 1 && do_seg_header(header));\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATATABLE *D = NULL;\n\tstruct GMT_DATASEGMENT *SD = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tif (alloc) {\n\t\tif ((Out = gmt_create_vector (GMT, In->n_columns, GMT_OUT)) == NULL) return NULL;\n\t\tOut->n_rows = In->n_records + (add_NaN_record ? In->n_segments : 0);\n\t\tfor (col = 0; col < Out->n_columns; col++)\t/* Set same export data type for all vectors */\n\t\t\tOut->type[col] = (mode) ? mode - 1 : API->GMT->current.setting.export_type;\n\t\tif ((API->error = gmtlib_alloc_vectors (GMT, Out, Out->n_rows)) != GMT_NOERROR) {\n\t\t\tgmt_M_free (GMT, Out);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tif ((api_put_val = gmtapi_select_put_function (API, Out->type[0])) == NULL) { /* Since all columns are of same type we get the pointer here */\n\t\tgmt_M_free (GMT, Out);\n\t\treturn NULL;\n\t}\n\tfor (tbl = row_out = 0; tbl < In->n_tables; tbl++) {\n\t\tD = In->table[tbl];\t/* Shorthand to current input data table */\n\t\tfor (seg = 0; seg < D->n_segments; seg++) {\n\t\t\tSD = D->segment[seg];\t/* Shorthand */\n\t\t\tif (add_NaN_record) {\n\t\t\t\tfor (col = 0; col < SD->n_columns; col++)\n\t\t\t\t\tapi_put_val (&(Out->data[col]), row_out, GMT->session.d_NaN);\n\t\t\t\trow_out++;\t/* Due to the extra NaN-data header record we just wrote */\n\t\t\t}\n\t\t\tfor (row = 0; row < SD->n_rows; row++, row_out++) {\n\t\t\t\tfor (col = 0; col < SD->n_columns; col++)\n\t\t\t\t\tapi_put_val (&(Out->data[col]), row_out, SD->data[col][row]);\n\t\t\t}\n\t\t}\n\t}\n\treturn Out;\n}\n\n/* GMT_MATRIX to GMT_* : */\n\nGMT_LOCAL void * gmtapi_matrix2dataset (struct GMTAPI_CTRL *API, struct GMT_MATRIX *In, struct GMT_DATASET *Out, unsigned int header) {\n\t/* Convert a matrix to a dataset (one table with one segment).\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t * header controls what we do with headers.\n\t */\n\tuint64_t row, col, ij;\n\tunsigned int mode = (In->text) ? GMT_WITH_STRINGS : 0;\n\tbool alloc = (Out == NULL);\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATASEGMENT *SD = NULL;\n\tGMT_getfunction api_get_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tif (header) GMT_Report (API, GMT_MSG_WARNING, \"gmtapi_matrix2dataset: Header stripping not implemented yet - ignored!\\n\");\n\tif (alloc && (Out = gmtlib_create_dataset (GMT, 1U, 1U, In->n_rows, In->n_columns, GMT_IS_POINT, mode, true)) == NULL)\n\t\treturn_null (API, GMT_MEMORY_ERROR);\n\tSD = Out->table[0]->segment[0];\t/* Shorthand to only segment in the dataset */\n\tif ((api_get_val = gmtapi_select_get_function (API, In->type)) == NULL)\n\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, In->shape, GMT_GRID_IS_REAL)) == NULL)\n\t\treturn_null (API, GMT_WRONG_MATRIX_SHAPE);\n\tfor (row = 0; row < In->n_rows; row++) {\n\t\tfor (col = 0; col < In->n_columns; col++) {\n\t\t\tij = GMT_2D_to_index (row, col, In->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\tapi_get_val (&(In->data), ij, &(SD->data[col][row]));\n\t\t}\n\t\tif (mode) SD->text[row] = strdup (In->text[row]);\n\t}\n\treturn Out;\n}\n\nGMT_LOCAL void *gmtapi_matrix2vector (struct GMTAPI_CTRL *API, struct GMT_MATRIX *In, struct GMT_VECTOR *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a matrix to vectors.\n\t * If Out is not NULL then we assume it has enough rows to hold the vector rows.\n\t * header controls what we do with headers.\n\t * If mode > 0 then it is assumed to hold GMT_TYPE-1, else we assume the GMT default setting.\n\t */\n\tuint64_t row, col, ij;\n\tbool alloc = (Out == NULL);\n\tdouble value;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tGMT_getfunction api_get_val_m = NULL;\n\tGMT_putfunction api_put_val_v = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tif (header) GMT_Report (API, GMT_MSG_WARNING, \"gmtapi_matrix2vector: Header stripping not implemented yet - ignored!\\n\");\n\tif (alloc) {\n\t\tif ((Out = gmt_create_vector (GMT, In->n_columns, GMT_OUT)) == NULL)\n\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\tOut->n_rows = In->n_rows;\n\t\tfor (col = 0; col < Out->n_columns; col++)\t/* Set same export data type for all vectors */\n\t\t\tOut->type[col] = (mode) ? mode - 1 : API->GMT->current.setting.export_type;\n\t\tif ((API->error = gmtlib_alloc_vectors (GMT, Out, Out->n_rows)) != GMT_NOERROR) {\n\t\t\tgmt_M_free (GMT, Out);\n\t\t\treturn_null (API, GMT_MEMORY_ERROR);\n\t\t}\n\t}\n\n\tif ((api_get_val_m = gmtapi_select_get_function (API, In->type)) == NULL) {\n\t\tif (alloc) gmt_M_free (GMT, Out);\n\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t}\n\tif ((api_put_val_v = gmtapi_select_put_function (API, GMT->current.setting.export_type)) == NULL) {\t/* Since all columns are of same type we get the pointer here */\n\t\tif (alloc) gmt_M_free (GMT, Out);\n\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t}\n\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, In->shape, GMT_GRID_IS_REAL)) == NULL) {\n\t\tif (alloc) gmt_M_free (GMT, Out);\n\t\treturn_null (API, GMT_WRONG_MATRIX_SHAPE);\n\t}\n\tfor (row = 0; row < In->n_rows; row++) {\n\t\tfor (col = 0; col < In->n_columns; col++) {\n\t\t\tij = GMT_2D_to_index (row, col, In->dim);\t/* Index into the user data matrix depends on layout (M->shape) */\n\t\t\tapi_get_val_m (&(In->data), ij, &value);\n\t\t\tapi_put_val_v (&(Out->data[col]), row, value);\n\t\t}\n\t}\n\treturn Out;\n}\n\n/* GMT_VECTOR to GMT_* : */\n\nGMT_LOCAL void * gmtapi_vector2dataset (struct GMTAPI_CTRL *API, struct GMT_VECTOR *In, struct GMT_DATASET *Out, unsigned int header) {\n\t/* Convert a vector to a dataset (one table with one segment).\n\t * header controls what we do with headers.\n\t * If Out is not NULL then we assume it has enough rows and columns to hold the dataset records.\n\t */\n\tuint64_t row, col;\n\tunsigned int mode = (In->text) ? GMT_WITH_STRINGS : 0;\n\tbool alloc = (Out == NULL);\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tstruct GMT_DATASEGMENT *SD = NULL;\n\tGMT_getfunction api_get_val;\n\tif (header) GMT_Report (API, GMT_MSG_WARNING, \"gmtapi_vector2dataset: Header stripping not implemented yet - ignored!\\n\");\n\tif (alloc && (Out = gmtlib_create_dataset (GMT, 1U, 1U, In->n_rows, In->n_columns, GMT_IS_POINT, mode, true)) == NULL)\n\t\treturn_null (API, GMT_MEMORY_ERROR);\n\tSD = Out->table[0]->segment[0];\t/* Shorthand to only segment in the dataset */\n\tfor (col = 0; col < In->n_columns; col++) {\n\t\tif ((api_get_val = gmtapi_select_get_function (API, In->type[col])) == NULL)\n\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\tfor (row = 0; row < In->n_rows; row++)\n\t\t\tapi_get_val (&(In->data[col]), row, &(SD->data[col][row]));\n\t}\n\tif (mode) {\t/* Duplicate the strings */\n\t\tfor (row = 0; row < In->n_rows; row++)\n\t\t\tSD->text[row] = strdup (In->text[row]);\t/* Duplicate the strings */\n\t}\n\treturn Out;\n}\n\nGMT_LOCAL void * gmtapi_vector2matrix (struct GMTAPI_CTRL *API, struct GMT_VECTOR *In, struct GMT_MATRIX *Out, unsigned int header, unsigned int mode) {\n\t/* Convert a vector to a matrix.\n\t * If Out is not NULL then we assume it has enough rows to hold the rows.\n\t * header controls what we do with headers.\n\t * If mode > 0 then it is assumed to hold GMT_TYPE-1, else we assume the GMT default setting.\n\t */\n\tuint64_t row, col, ij;\n\tbool alloc = (Out == NULL);\n\tdouble value;\n\tstruct GMT_CTRL *GMT = API->GMT;\n\tGMT_getfunction api_get_val = NULL;\n\tGMT_putfunction api_put_val = NULL;\n\tp_func_uint64_t GMT_2D_to_index = NULL;\n\tif (header) GMT_Report (API, GMT_MSG_WARNING, \"gmtapi_vector2matrix: Header stripping not implemented yet - ignored!\\n\");\n\tif (alloc) {\n\t\tstruct GMT_MATRIX_HIDDEN *MH = NULL;\n\t\tOut = gmtlib_create_matrix (GMT, 1U, GMT_OUT, 0);\n\t\tOut->n_columns = In->n_columns;\n\t\tOut->n_rows = In->n_rows;\n\t\tOut->type = (mode) ? mode - 1 : API->GMT->current.setting.export_type;\n\t\tif (gmtlib_alloc_univector (GMT, &(Out->data), Out->type, Out->n_rows * Out->n_columns)) {\n\t\t\tgmt_M_free (GMT, Out);\n\t\t\treturn (NULL);\n\t\t}\n\t\tMH = gmt_get_M_hidden (Out);\n\t\tMH->alloc_mode = GMT_ALLOC_INTERNALLY;\n\t}\n\n\tif ((GMT_2D_to_index = gmtapi_get_2d_to_index (API, Out->shape, GMT_GRID_IS_REAL)) == NULL) {\n\t\tgmt_M_free (GMT, Out);\n\t\treturn (NULL);\n\t}\n\tif ((api_put_val = gmtapi_select_put_function (API, Out->type)) == NULL) {\t/* Since all columns are of same type we get the pointer here */\n\t\tgmt_M_free (GMT, Out);\n\t\treturn (NULL);\n\t}\n\tfor (col = 0; col < In->n_columns; col++) {\n\t\tif ((api_get_val = gmtapi_select_get_function (API, In->type[col])) == NULL) {\n\t\t\tgmt_M_free (GMT, Out);\n\t\t\treturn (NULL);\n\t\t}\n\t\tfor (row = 0; row < In->n_rows; row++) {\n\t\t\tapi_get_val (&(In->data[col]), row, &value);\n\t\t\tij = GMT_2D_to_index (row, col, Out->dim);\n\t\t\tapi_put_val (&(Out->data), ij, value);\n\t\t}\n\t}\n\treturn Out;\n}\n\n/* New function to convert between objects */\n\n#define GMT_HEADER_MODE\t0\n#define GMT_TYPE_MODE\t1\n#define GMT_FORMAT_MODE\t1\t/* Same as GMT_TYPE_MODE [not a typo] */\n\nvoid *GMT_Convert_Data (void *V_API, void *In, unsigned int family_in, void *Out, unsigned int family_out, unsigned int flag[]) {\n\t/* Convert between valid pairs of objects,  If Out == NULL then we allocate an output object,\n\t * otherwise we assume we are given adequate space already.  This is most likely restricted to a GMT_MATRIX.\n\t * flag is an array with two unsigned integers controlling various aspects of the conversion:\n\t * flag[0]: Controls how headers are handled on output:\n\t * \t 0 : All headers are passed on as is.  For Matrix/Vector all table headers are always ignored but\n\t * \t     segment headers will be encoded as NaN records\n\t * \t 1 : Headers are not copied, but segment headers are preserved\n\t * \t 2 : Headers are preserved, but segment headers are initialized to blank\n\t * \t 3 : All headers headers are eliminated\n\t *\t     The GMT Default settings in effect will control any output to files later.\n\t * [Note if that happens it is not considered an error, so API->error is GMT_NOERROR].\n\t * flag[1]: Controls the data type to use for MATRIX and VECTOR.\n\t * \t0: Use the GMT default data type [GMT_EXPORT_TYPE]\n\t * \t>0: Assumed to contain datatype + 1 (e.g., GMT_FLOAT+1, GMT_DOUBLE+1)\n\t * If DATASET, this integer controls the restructuring of the set:\n\t * \tGMT_WRITE_TABLE_SEGMENT: Combine all segments into a SINGLE segment in ONE table\n\t * \tGMT_WRITE_TABLE: Collect all segments into ONE table.\n\t * \tGMT_WRITE_SEGMENT: Combine segments into ONE segment per table.\n\t * \t0: Retain initial layout.\n\t * If GRID then flags are not yet used\n\t *\n\t * The following conversions are valid; the brackets indicate any side-effects or limitations]\n\t *\n\t * DATASET -> MATRIX,  VECTOR\n\t * MATRIX  -> DATASET, VECTOR\n\t * VECTOR  -> DATASET, MATRIX\n\t * GRID    -> MATRIX\n\t */\n\tint object_ID, item;\n\tvoid *X = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tswitch (family_in) {\n\t\tcase GMT_IS_DATASET:\n\t\t\tswitch (family_out) {\n\t\t\t\tcase GMT_IS_DATASET:\n\t\t\t\t\tX = gmtapi_dataset2dataset (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_MATRIX:\n\t\t\t\t\tX = gmtapi_dataset2matrix(API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_VECTOR:\n\t\t\t\t\tX = gmtapi_dataset2vector (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\n\t\t\tswitch (family_out) {\n\t\t\t\tcase GMT_IS_DATASET:\n\t\t\t\t\tX = gmtapi_matrix2dataset (API, In, Out, flag[GMT_HEADER_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_VECTOR:\n\t\t\t\t\tX = gmtapi_matrix2vector (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\n\t\t\tswitch (family_out) {\n\t\t\t\tcase GMT_IS_DATASET:\n\t\t\t\t\tX = gmtapi_vector2dataset (API, In, Out, flag[GMT_HEADER_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GMT_IS_MATRIX:\n\t\t\t\t\tX = gmtapi_vector2matrix (API, In, Out, flag[GMT_HEADER_MODE], flag[GMT_TYPE_MODE]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_GRID:\n\t\t\tswitch (family_out) {\n\t\t\t\tcase GMT_IS_MATRIX:\n\t\t\t\t\tX = gmtapi_grid2matrix (API, In, Out);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tAPI->error = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\tif (X == NULL)\n\t\treturn_null (API, GMT_PTR_IS_NULL);\n\tif (API->error)\n\t\treturn_null (API, API->error);\n\tif ((object_ID = GMT_Register_IO (API, family_out, GMT_IS_REFERENCE, GMT_IS_POINT, GMT_IN, NULL, X)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\t/* Failure to register */\n\tif ((item = gmtlib_validate_id (API, family_out, object_ID, GMT_IN, GMT_NOTSET)) == GMT_NOTSET)\n\t\treturn_null (API, API->error);\n\tAPI->object[item]->resource = X;\t/* Retain pointer to the allocated data so we use garbage collection later */\n#ifdef DEBUG\n\tgmtapi_list_objects (API, \"GMT_Convert_Data\");\n#endif\n\treturn (X);\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_Convert_Data_ (void *In, unsigned int *family_in, void *Out, unsigned int *family_out, unsigned int flag[]) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Convert_Data (GMT_FORTRAN, In, *family_in, Out, *family_out, flag));\n}\n#endif\n\nvoid * GMT_Alloc_Segment (void *V_API, unsigned int mode, uint64_t n_rows, uint64_t n_columns, char *header, void *S) {\n\t/* Allocate or reallocate a GMT_DATASEGMENT.\n\t * The n_columns may be 0 if no numerical data in the segment.\n\t * header, if not NULL or blank, sets the segment header.\n\t * if mode == GMT_WITH_STRINGS then we also allocate the empty array of string pointers */\n\tstruct GMT_DATASEGMENT *Snew = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tbool first = true, alloc;\n\tchar *H = header;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif ((Snew = S) != NULL)\t/* Existing segment given */\n\t\tfirst = false;\n\telse if ((Snew = gmt_get_segment (API->GMT)) == NULL) /* Something went wrong */\n\t\treturn_null (V_API, GMT_MEMORY_ERROR);\n\t\t/* Only reallocate if desired n_rows differ from current n_rows */\n\talloc = (first || (n_rows && n_rows != Snew->n_rows));\t/* Alloc first time or reallocate later if necessary */\n\tif (alloc && gmt_alloc_segment (API->GMT, Snew, n_rows, n_columns, mode, first))  {\t/* Something went wrong */\n\t\tif (first) gmt_M_free (API->GMT, Snew);\n\t\treturn_null (V_API, GMT_MEMORY_ERROR);\n\t}\n\tif (H && H[0] == API->GMT->current.setting.io_seg_marker[GMT_IN]) {\t/* User gave a record with segment marker in it */\n\t\tH++;\t/* Skip the segment marker */\n\t\twhile (*H && (*H == ' ' || *H == '\\t')) H++;\t/* Then skip any leading whitespace */\n\t}\n\tif (H && strlen (H)) {\t/* Gave a header string to (re)place in the segment */\n\t\tif (Snew->header) gmt_M_str_free (Snew->header);\n\t\tSnew->header = strdup (H);\n\t}\n\treturn Snew;\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_Alloc_Segment_ (unsigned int *family, uint64_t *n_rows, uint64_t *n_columns, char *header, void *S, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Alloc_Segment (GMT_FORTRAN, *family, *n_rows, *n_columns, header, S));\n}\n#endif\n\nint GMT_Set_Columns (void *V_API, unsigned int direction, unsigned int n_cols, unsigned int mode) {\n\t/* Specify how many input or output columns to use for record-by-record output, if fixed */\n\tint error = 0;\n\tuint64_t n_in = 0;\n\tstruct GMTAPI_CTRL *API = NULL;\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (V_API, GMT_NOT_A_VALID_DIRECTION);\n\tif (direction == GMT_IN && !(mode == GMT_COL_FIX || mode == GMT_COL_VAR || mode == GMT_COL_FIX_NO_TEXT)) return_error (V_API, GMT_NOT_A_VALID_MODE);\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tif (direction == GMT_OUT) {\t/* Output */\n\t\tif ((mode == GMT_COL_ADD || mode == GMT_COL_SUB) && (n_in = gmt_get_cols (API->GMT, GMT_IN)) == 0) {\t/* Get number of input columns */\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Set_Columns: Premature call - number of input columns not known yet\\n\");\n\t\t\treturn_error (API, GMT_N_COLS_NOT_SET);\n\t\t}\n\t\t/* If no columns specified we set output to the same as input columns */\n\t\tif (n_cols == 0 && mode != GMT_COL_FIX && (error = gmt_set_cols (API->GMT, GMT_OUT, n_in)) != 0)\n\t\t\treturn_error (API, GMT_N_COLS_NOT_SET);\n\t\t/* Set output record type */\n\t\tif (n_cols == 0)\n\t\t\tAPI->GMT->current.io.record_type[GMT_OUT] = GMT_WRITE_TEXT;\n\t\telse if (mode == GMT_COL_FIX_NO_TEXT)\n\t\t\tAPI->GMT->current.io.record_type[GMT_OUT] = GMT_WRITE_DATA;\n\t\telse\n\t\t\tAPI->GMT->current.io.record_type[GMT_OUT] = GMT_WRITE_MIXED;\n\t}\n\n\t/* Get here when n_cols is not zero (of we have a special case), so must consult mode */\n\n\tswitch (mode) {\n\t\tcase GMT_COL_FIX_NO_TEXT:\t/* Specific a fixed number of columns, and ignore trailing text */\n\t\t\tAPI->GMT->current.io.trailing_text[direction] = false;\n\t\t\t/* Intentionally fall through - to set columns */\n\t\tcase GMT_COL_FIX:\t/* Specific a fixed number of columns */\n\t\t\terror = gmt_set_cols (API->GMT, direction, n_cols);\n\t\t\tbreak;\n\t\tcase GMT_COL_VAR:\t/* Flag we have a variable number of input columns */\n\t\t\tAPI->GMT->current.io.variable_in_columns = true;\n\t\t\tbreak;\n\t\tcase GMT_COL_ADD:\t/* Add to the number of input columns */\n\t\t\terror = gmt_set_cols (API->GMT, GMT_OUT, n_in + n_cols);\n\t\t\tbreak;\n\t\tcase GMT_COL_SUB:\t/* Subtract from the number of input columns */\n\t\t\tif (n_cols >= n_in) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Set_Columns: Cannot specify less than one output column!\\n\");\n\t\t\t\treturn_error (API, GMT_DIM_TOO_SMALL);\n\t\t\t}\n\t\t\terror = gmt_set_cols (API->GMT, GMT_OUT, n_in - n_cols);\n\t\t\tbreak;\n\t}\n\tif (error) return_error (API, GMT_N_COLS_NOT_SET);\n\treturn (GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Set_Columns_ (unsigned int *direction, unsigned int *n_cols, unsigned int *mode) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Set_Columns (GMT_FORTRAN, *direction, *n_cols, *mode));\n}\n#endif\n\nGMT_LOCAL int gmtapi_change_gridlayout (struct GMTAPI_CTRL *API, char *code, unsigned int mode, struct GMT_GRID *G, gmt_grdfloat *out) {\n\tenum GMT_enum_family family;\n\tunsigned int row, col, pad[4], old_layout, new_layout;\n\tuint64_t from_node, to_node;\n\tgmt_grdfloat *tmp = NULL;\n\tgmt_M_unused(mode);\n\n\told_layout = gmtapi_decode_layout (API, G->header->mem_layout, &family);\n\tif (family != GMT_IS_GRID) return GMT_NOT_A_VALID_FAMILY;\n\tnew_layout = gmtapi_decode_layout (API, code, &family);\n\tif (old_layout == new_layout) return GMT_NOERROR;\t/* Nothing to do */\n\n\t/* Remove the high bits for complex data */\n\told_layout &= 3;\tnew_layout &= 3;\n\t/* Grids may be column vs row oriented and from top or from bottom */\n\tgmt_M_memcpy (pad, G->header->pad, 4, unsigned int);\t/* Remember the pad */\n\tif (((tmp = out) == NULL) && (tmp = gmt_M_memory_aligned (API->GMT, NULL, G->header->size, gmt_grdfloat)) == NULL)\n\t\treturn (GMT_MEMORY_ERROR);\t\t/* Something went wrong */\n\n\tgmt_grd_pad_off (API->GMT, G);\t/* Simplify working with no pad */\n\tif (old_layout == 0 && new_layout == 2) { /* Change from TR to TC */\n\t\tfor (row = 0, from_node = 0; row < G->header->n_rows; row++)\n\t\t\tfor (col = 0; col < G->header->n_columns; col++, from_node++)\n\t\t\t\ttmp[(uint64_t)col * (uint64_t)G->header->n_rows + row] = G->data[from_node];\n\t}\n\telse if (old_layout == 0 && new_layout == 3) {\t/* Change from TR to BC */\n\t\tfor (row = 0, from_node = 0; row < G->header->n_rows; row++)\n\t\t\tfor (col = 0; col < G->header->n_columns; col++, from_node++)\n\t\t\t\ttmp[(uint64_t)col * (uint64_t)G->header->n_rows + (G->header->n_rows - row - 1)] = G->data[from_node];\n\t}\n\telse if (old_layout == 2 && new_layout == 0) {\t/* Change from TC to TR */\n\t\tfor (row = 0, to_node = 0; row < G->header->n_rows; row++)\n\t\t\tfor (col = 0; col < G->header->n_columns; col++, to_node++)\n\t\t\t\ttmp[to_node] = G->data[(uint64_t)col * (uint64_t)G->header->n_rows + row];\n\t}\n\telse if (old_layout == 3 && new_layout == 0) {\t/* Change from BC to TR */\n\t\tfor (row = 0, to_node = 0; row < G->header->n_rows; row++)\n\t\t\tfor (col = 0; col < G->header->n_columns; col++, to_node++)\n\t\t\t\ttmp[to_node] = G->data[(uint64_t)col * (uint64_t)G->header->n_rows + (G->header->n_rows - row - 1)];\n\t}\n\telse {\t\t/* Other cases to be added later ...*/\n\t\tGMT_Report (API, GMT_MSG_WARNING, \"gmtapi_change_gridlayout: reordering function for case %s -> %s not yet written. Doing nothing\\n\",\n\t\t            G->header->mem_layout, code);\n\t\tfor (to_node = 0; to_node < G->header->size; to_node++)\n\t\t\ttmp[to_node] = G->data[to_node];\n\t}\n\n\tif (out == 0) {\t/* Means we must update the grid data */\n\t\tgmt_M_free_aligned (API->GMT, G->data);\t\t\t/* Free previous aligned grid memory */\n\t\tG->data = tmp;\n\t}\n\tgmt_grd_pad_on (API->GMT, G, pad);\t/* Restore pad on grid */\n\treturn (GMT_NOERROR);\n}\n\nGMT_LOCAL int gmtapi_change_imagelayout (struct GMTAPI_CTRL *API, char *code, unsigned int mode, struct GMT_IMAGE *I, unsigned char *out1, unsigned char *out2) {\n\t/* code: The new memory layout code, e.g \"TRB\"\n\t   mode: Currently unused (for future expansion)\n\t   out1: Array with the image data converted to the requested layout.\n\t   out2: Array with the transparencies converted to the requested layout.\n\t         If NULL on input the necessary memory is allocated inside this function, otherwise\n\t         it is ASSUMED that it points a memory chunk big enough to hold the reshuffled data.\n\t*/\n\tbool changed = true;\n\tunsigned char *tmp = NULL, *alpha = NULL;\n\tenum GMT_enum_family family;\n\tunsigned int old_layout, new_layout;\n\tuint64_t band, row, col, to_node, from_node;\n\tstruct GMT_IMAGE_HIDDEN *IH = NULL;\n\tgmt_M_unused(mode);\n\n\told_layout = gmtapi_decode_layout (API, I->header->mem_layout, &family);\n\tnew_layout = gmtapi_decode_layout(API, code, &family);\n\tif (old_layout == new_layout) return GMT_NOERROR;\t/* Nothing to do */\n\n\tif ((tmp = out1) == NULL && (tmp = gmt_M_memory_aligned (API->GMT, NULL, I->header->n_bands * I->header->size, unsigned char)) == NULL)\n\t\treturn (GMT_MEMORY_ERROR);\t\t/* Something went wrong */\n\tif (I->alpha && (alpha = out2) == NULL && (alpha = gmt_M_memory_aligned (API->GMT, NULL, I->header->size, unsigned char)) == NULL) {\n\t\tif (out2 == NULL) gmt_M_free (API->GMT, alpha);\n\t\tgmt_M_free_aligned (API->GMT, tmp);\n\t\treturn (GMT_MEMORY_ERROR);\t\t/* Something went wrong */\n\t}\n\n\t/* Images may be column vs row oriented, from top or from bottom and may be Band|Line|Pixel interleaved\n\t   That sums up to a lot of combinations. We will add them on a by-need basis. */\n\n\tif (old_layout == 8 && new_layout == 2) {\t\t/* Change from TRP to TCB */\n\t\tfor (row = from_node = 0; row < I->header->my; row++)\n\t\t\tfor (col = 0; col < I->header->mx; col++)\n\t\t\t\tfor (band = 0; band < I->header->n_bands; band++, from_node++) {\n\t\t\t\t\tto_node = row + col*I->header->my + band * I->header->size;\n\t\t\t\t\ttmp[to_node] = (uint8_t)I->data[from_node];\n\t\t\t\t}\n\t\tif (I->alpha) {\n\t\t\tfor (row = from_node = 0; row < I->header->my; row++)\n\t\t\t\tfor (col = 0; col < I->header->mx; col++, from_node++) {\n\t\t\t\t\tto_node = row + col*I->header->my;\n\t\t\t\t\talpha[to_node] = (uint8_t)I->alpha[from_node];\n\t\t\t\t}\n\t\t}\n\t}\n\telse if (old_layout == 0 && new_layout == 4) {\t\t/* Change from TRB to TRL [UNTESTED] */\n\t\tfor (row = 0; row < I->header->my; row++)\n\t\t\tfor (col = 0; col < I->header->mx; col++)\n\t\t\t\tfor (band = 0; band < I->header->n_bands; band++) {\n\t\t\t\t\tfrom_node = col + row*I->header->mx + band * I->header->size;\n\t\t\t\t\tto_node = col + (band + row * I->header->n_bands) * I->header->mx;\n\t\t\t\t\ttmp[to_node] = (uint8_t)I->data[from_node];\n\t\t\t\t}\n\t\tif (I->alpha)\t/* Same since only one band of alpha */\n\t\t\tgmt_M_memcpy (alpha, I->alpha, I->header->size, uint8_t);\n\t}\n\telse if (old_layout == 4 && new_layout == 0) {\t\t/* Change from TRL to TRB [UNTESTED] */\n\t\tfor (row = 0; row < I->header->my; row++)\n\t\t\tfor (col = 0; col < I->header->mx; col++)\n\t\t\t\tfor (band = 0; band < I->header->n_bands; band++) {\n\t\t\t\t\tto_node = col + row*I->header->mx + band * I->header->size;\n\t\t\t\t\tfrom_node = col + (band + row * I->header->n_bands) * I->header->mx;\n\t\t\t\t\ttmp[to_node] = (uint8_t)I->data[from_node];\n\t\t\t\t}\n\t\tif (I->alpha)\t/* Same since only one band of alpha */\n\t\t\tgmt_M_memcpy (alpha, I->alpha, I->header->size, uint8_t);\n\t}\n\telse if (old_layout == 0 && new_layout == 8) {\t\t/* Change from TRB to TRP */\n\t\tfor (row = to_node = 0; row < I->header->my; row++)\n\t\t\tfor (col = 0; col < I->header->mx; col++)\n\t\t\t\tfor (band = 0; band < I->header->n_bands; band++, to_node++) {\n\t\t\t\t\tfrom_node = col + row*I->header->mx + band * I->header->size;\n\t\t\t\t\ttmp[to_node] = (uint8_t)I->data[from_node];\n\t\t\t\t}\n\t\tif (I->alpha)\t/* Same since only one band of alpha */\n\t\t\tgmt_M_memcpy (alpha, I->alpha, I->header->size, uint8_t);\n\t}\n\telse if (old_layout == 8 && new_layout == 0) {\t\t/* Change from TRP to TRB [UNTESTED] */\n\t\tfor (row = from_node = 0; row < I->header->my; row++)\n\t\t\tfor (col = 0; col < I->header->mx; col++)\n\t\t\t\tfor (band = 0; band < I->header->n_bands; band++, from_node++) {\n\t\t\t\t\tto_node = col + row*I->header->mx + band * I->header->size;\n\t\t\t\t\ttmp[to_node] = (uint8_t)I->data[from_node];\n\t\t\t\t}\n\t\tif (I->alpha)\t/* Same since only one band of alpha */\n\t\t\tgmt_M_memcpy (alpha, I->alpha, I->header->size, uint8_t);\n\t}\n\telse if (old_layout == 0 && new_layout == 9) {\t\t/* Change from TRB to BRP */\n\t\tfor (row = to_node = 0; row < I->header->my; row++)\t\t/* Not UD flipping so what we call B is probably T */\n\t\t\tfor (col = 0; col < I->header->mx; col++)\n\t\t\t\tfor (band = 0; band < I->header->n_bands; band++, to_node++) {\n\t\t\t\t\tfrom_node = col + row*I->header->mx + band * I->header->size;\n\t\t\t\t\ttmp[to_node] = (uint8_t)I->data[from_node];\n\t\t\t\t}\n\t\tif (I->alpha)\t/* Same since only one band of alpha and no transposition */\n\t\t\tgmt_M_memcpy (alpha, I->alpha, I->header->size, uint8_t);\n\t}\n\telse if (old_layout == 2 && new_layout == 9) {\t\t/* Change from TCB to BRP */\n\t\tfor (row = to_node = 0; row < I->header->my; row++)\t\t/* Not UD flipping so what we call B is probably T */\n\t\t\tfor (col = 0; col < I->header->mx; col++)\n\t\t\t\tfor (band = 0; band < I->header->n_bands; band++, to_node++) {\n\t\t\t\t\tfrom_node = row + col*I->header->my + band * I->header->size;\n\t\t\t\t\ttmp[to_node] = (uint8_t)I->data[from_node];\n\t\t\t\t}\n\t\tif (I->alpha) {\n\t\t\tfor (row = to_node = 0; row < I->header->my; row++)\n\t\t\t\tfor (col = 0; col < I->header->mx; col++, to_node++) {\n\t\t\t\t\tfrom_node = row + col*I->header->my;\n\t\t\t\t\talpha[to_node] = (uint8_t)I->alpha[from_node];\n\t\t\t\t}\n\t\t}\n\t}\n\telse if (old_layout == 11 && new_layout == 9) {\t\t/* Change from BCP to BRP */\n\t\tfor (row = to_node = 0; row < I->header->my; row++)\n\t\t\tfor (col = 0; col < I->header->mx; col++)\n\t\t\t\tfor (band = 0; band < I->header->n_bands; band++, to_node++) {\n\t\t\t\t\tfrom_node = row + col*I->header->my + band * I->header->size;\n\t\t\t\t\ttmp[to_node] = (uint8_t)I->data[from_node];\n\t\t\t\t}\n\t\tif (I->alpha)\t/* Same since only one band of alpha and no transposition */\n\t\t\tgmt_M_memcpy (alpha, I->alpha, I->header->size, uint8_t);\n\t}\n\telse if (old_layout == 3 && new_layout == 9) {\t\t/* Change from BCB to BRP. Here we believe in first B but not 2nd */\n\t\tfor (row = to_node = 0; row < I->header->my; row++)\n\t\t\tfor (col = 0; col < I->header->mx; col++)\n\t\t\t\tfor (band = 0; band < I->header->n_bands; band++, to_node++) {\n\t\t\t\t\tfrom_node = (I->header->my - 1 - row) + col*I->header->my + band * I->header->size;\n\t\t\t\t\ttmp[to_node] = (uint8_t)I->data[from_node];\n\t\t\t\t}\n\t\tif (I->alpha) {\n\t\t\tfor (row = to_node = 0; row < I->header->my; row++)\n\t\t\t\tfor (col = 0; col < I->header->mx; col++, to_node++) {\n\t\t\t\t\tfrom_node = (I->header->my - 1 - row) + col*I->header->my;\n\t\t\t\t\talpha[to_node] = (uint8_t)I->alpha[from_node];\n\t\t\t\t}\n\t\t}\n\t}\n\telse if (old_layout == 9 && new_layout == 0) {\t\t/* Change from BRP to TRB */\n\t\tfor (row = from_node = 0; row < I->header->my; row++)\n\t\t\tfor (col = 0; col < I->header->mx; col++)\n\t\t\t\tfor (band = 0; band < I->header->n_bands; band++, from_node++) {\n\t\t\t\t\t//to_node = col + (I->header->my - 1 - row)*I->header->my + band*I->header->size;  /* PW: This was always like this - commented out, so where is the B->T happening? */\n\t\t\t\t\tto_node = col + row*I->header->my + band * I->header->size;\n\t\t\t\t\ttmp[to_node] = (uint8_t)I->data[from_node];\n\t\t\t\t}\n\t\tif (I->alpha) {\n\t\t\tfor (row = from_node = 0; row < I->header->my; row++)\n\t\t\t\tfor (col = 0; col < I->header->mx; col++, from_node++) {\n\t\t\t\t\tto_node = col + row*I->header->my;\n\t\t\t\t\talpha[to_node] = (uint8_t)I->alpha[from_node];\n\t\t\t\t}\n\t\t}\n\t}\n\t//else if (old_layout == 2 && new_layout == 0) {}\t/* Change from TCB to TRB */\n\telse {\t\t/* Other cases to be added later ...*/\n\t\tGMT_Report (API, GMT_MSG_WARNING, \"gmtapi_change_imagelayout: reordering function for case %s -> %s not yet written. Doing nothing.\\n\",\n\t\t\tI->header->mem_layout, code);\n\t\tfor (from_node = 0; from_node < I->header->size; from_node++)\n\t\t\ttmp[from_node] = I->data[from_node];\n\t\tchanged = false;\n\t}\n\n\tif (out1 == NULL) {\t/* Means we must update the Image data */\n\t\tIH = gmt_get_I_hidden (I);\n\t\tif (IH->alloc_mode != GMT_ALLOC_EXTERNALLY)\n\t\t\tgmt_M_free_aligned (API->GMT, I->data);\t\t\t/* Free previous aligned image memory */\n\t\tI->data = tmp;\n\t}\n\tif (out2 == NULL && alpha) {\t/* Means we must update the alpha data */\n\t\tif (!IH) IH = gmt_get_I_hidden (I);\n\t\tif (IH->alloc_mode != GMT_ALLOC_EXTERNALLY)\n\t\t\tgmt_M_free_aligned (API->GMT, I->alpha);\t\t/* Free previous aligned image transparency */\n\t\tI->alpha = alpha;\n\t}\n\n\tif (changed) {\t/* Update the mem_layout for this image */\n\t\tstrncpy (I->header->mem_layout, code, MIN(strlen(code),4));\n\t\tif (I->alpha) I->header->mem_layout[3] = 'a';\t/* Flag that we have transparency */\n\t}\n\n\treturn (GMT_NOERROR);\n}\n\nint GMT_Change_Layout (void *V_API, unsigned int family, char *code, unsigned int mode, void *obj, void *out, void *alpha) {\n\t/* Reorder the memory layout of a grid or image given the new desired layout in code.\n\t * If out == NULL then we allocate space to hold the new grid|image and replace obj->data with this new array.\n\t *   For grids we preserve any padding in effect for the object but for out we have no padding.\n\t * Otherwise we assume out points to allocated memory and we simply fill it out, assuming no pad.\n\t * mode is presently unused.\n\t * alpha is only considered for images and may be used to return a modified transparency array.\n\t */\n\tstruct GMTAPI_CTRL *API = NULL;\n\tint error;\n\tif (V_API == NULL) return_error (V_API, GMT_NOERROR);\t/* Not fuss if nothing is given */\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\tif (code == NULL || code[0] == '\\0') return_error (V_API, GMT_NOT_A_SESSION);\n\tswitch (family) {\n\t\tcase GMT_IS_GRID:\n\t\t\terror = gmtapi_change_gridlayout (V_API, code, mode, obj, out);\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\terror = gmtapi_change_imagelayout (V_API, code, mode, obj, out, alpha);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\treturn_error (API, error);\n}\n\n#ifdef FORTRAN_API\nint GMT_Change_Layout_ (unsigned int *family, char *code, unsigned int *mode, void *obj, void *out, void *alpha, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Change_Layout (GMT_FORTRAN, *family, code, *mode, obj, out, alpha));\n}\n#endif\n\n/* Deal with assignments of custom vectors and matrices to GMT containers */\n\nint GMT_Put_Vector (void *V_API, struct GMT_VECTOR *V, unsigned int col, unsigned int type, void *vector) {\n\t/* Hooks a users custom vector onto V's column array and sets the type.\n\t * It is the user's responsibility to pass correct type for the given vector.\n\t * We also check that the number of rows have been set earlier. */\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_VECTOR_HIDDEN *VH = NULL;\n\tchar **dt = NULL;\n\tdouble *t_vector = NULL;\n\tuint64_t row, n_bad = 0;\n\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tif (V == NULL) return_error (API, GMT_PTR_IS_NULL);\n\tif (V->n_rows == 0) return_error (API, GMT_DIM_TOO_SMALL);\n\tif (col >= V->n_columns) return_error (API, GMT_DIM_TOO_LARGE);\n\tswitch (type) {\n\t\tcase GMT_DOUBLE:\tV->type[col] = GMT_DOUBLE;\tV->data[col].f8  = vector;\tbreak;\n\t\tcase GMT_FLOAT:\t\tV->type[col] = GMT_FLOAT;\tV->data[col].f4  = vector;\tbreak;\n\t\tcase GMT_ULONG:\t\tV->type[col] = GMT_ULONG;\tV->data[col].ui8 = vector;\tbreak;\n\t\tcase GMT_LONG:\t\tV->type[col] = GMT_LONG;\tV->data[col].si8 = vector;\tbreak;\n\t\tcase GMT_UINT:\t\tV->type[col] = GMT_UINT;\tV->data[col].ui4 = vector;\tbreak;\n\t\tcase GMT_INT:\t\tV->type[col] = GMT_INT;\t\tV->data[col].si4 = vector;\tbreak;\n\t\tcase GMT_USHORT:\tV->type[col] = GMT_USHORT;\tV->data[col].ui2 = vector;\tbreak;\n\t\tcase GMT_SHORT:\t\tV->type[col] = GMT_SHORT;\tV->data[col].si2 = vector;\tbreak;\n\t\tcase GMT_UCHAR:\t\tV->type[col] = GMT_UCHAR;\tV->data[col].uc1 = vector;\tbreak;\n\t\tcase GMT_CHAR:\t\tV->type[col] = GMT_CHAR;\tV->data[col].sc1 = vector;\tbreak;\n\t\tcase GMT_DATETIME:\t/* Must convert from string-time to double */\n\t\t\tif ((dt = gmtapi_get_char_char_ptr (vector)) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Datetime string array is NULL\\n\");\n\t\t\t\treturn GMT_MEMORY_ERROR;\n\t\t\t}\n\t\t\tif ((t_vector = malloc (V->n_rows * sizeof(double))) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to allocate array of %\" PRIu64 \" doubles for converted datetime strings\\n\", V->n_rows);\n\t\t\t\treturn GMT_MEMORY_ERROR;\n\t\t\t}\n\t\t\tfor (row = 0; row < V->n_rows; row++) {\n\t\t\t\tif (gmt_scanf (API->GMT, dt[row], GMT_IS_ABSTIME, &(t_vector[row])) == GMT_IS_NAN) {\n\t\t\t\t\tn_bad++;\n\t\t\t\t\tt_vector[row] = API->GMT->session.d_NaN;\n\t\t\t\t}\n\t\t\t}\n\t\t\tV->type[col] = GMT_DOUBLE;\tV->data[col].f8 = t_vector;\n\t\t\tif (n_bad) GMT_Report (API, GMT_MSG_WARNING, \"Unable to parse %\" PRIu64 \" datetime strings (ISO datetime format required)\\n\", n_bad);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn_error (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tbreak;\n\t}\n\tVH = gmt_get_V_hidden (V);\n\tVH->alloc_mode[col] = (type == GMT_DATETIME) ? GMT_ALLOC_INTERNALLY : GMT_ALLOC_EXTERNALLY;\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Put_Vector_ (struct GMT_VECTOR *V, unsigned int *col, unsigned int *type, void *vector) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Put_Vector (GMT_FORTRAN, V, *col, *type, vector));\n}\n#endif\n\nvoid * GMT_Get_Vector (void *API, struct GMT_VECTOR *V, unsigned int col) {\n\t/* Returns a pointer to the specified column array. Users can consult\n\t * V->type[col] to know what data type is pointed to.  */\n\tvoid *vector = NULL;\n\tif (API == NULL) return_null (API, GMT_NOT_A_SESSION);\n\tif (V == NULL) return_null (API, GMT_PTR_IS_NULL);\n\tif (col >= V->n_columns) return_null (API, GMT_DIM_TOO_LARGE);\n\tswitch (V->type[col]) {\n\t\tcase GMT_DOUBLE:\tvector = V->data[col].f8;\tbreak;\n\t\tcase GMT_FLOAT:\t\tvector = V->data[col].f4;\tbreak;\n\t\tcase GMT_ULONG:\t\tvector = V->data[col].ui8;\tbreak;\n\t\tcase GMT_LONG:\t\tvector = V->data[col].si8;\tbreak;\n\t\tcase GMT_UINT:\t\tvector = V->data[col].ui4;\tbreak;\n\t\tcase GMT_INT:\t\tvector = V->data[col].si4;\tbreak;\n\t\tcase GMT_USHORT:\tvector = V->data[col].ui2;\tbreak;\n\t\tcase GMT_SHORT:\t\tvector = V->data[col].si2;\tbreak;\n\t\tcase GMT_UCHAR:\t\tvector = V->data[col].uc1;\tbreak;\n\t\tcase GMT_CHAR:\t\tvector = V->data[col].sc1;\tbreak;\n\t\tdefault:\n\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tbreak;\n\t}\n\treturn vector;\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_Get_Vector_ (struct GMT_VECTOR *V, unsigned int *col) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Vector (GMT_FORTRAN, V, *col));\n}\n#endif\n\nint GMT_Put_Matrix (void *API, struct GMT_MATRIX *M, unsigned int type, int pad, void *matrix) {\n\t/* Hooks a user's custom matrix onto M's data array and sets the type.\n\t * It is the user's responsibility to pass correct type for the given matrix.\n\t * We check that dimensions have been set earlier */\n\tstruct GMT_MATRIX_HIDDEN *MH = NULL;\n\tif (API == NULL) return_error (API, GMT_NOT_A_SESSION);\n\tif (M == NULL) return_error (API, GMT_PTR_IS_NULL);\n\tif (M->n_columns == 0 || M->n_rows == 0) return_error (API, GMT_DIM_TOO_SMALL);\n\tswitch (type) {\n\t\tcase GMT_DOUBLE:\tM->type = GMT_DOUBLE;\tM->data.f8  = matrix;\tbreak;\n\t\tcase GMT_FLOAT:\t\tM->type = GMT_FLOAT;\tM->data.f4  = matrix;\tbreak;\n\t\tcase GMT_ULONG:\t\tM->type = GMT_ULONG;\tM->data.ui8 = matrix;\tbreak;\n\t\tcase GMT_LONG:\t\tM->type = GMT_LONG;\tM->data.si8 = matrix;\tbreak;\n\t\tcase GMT_UINT:\t\tM->type = GMT_UINT;\tM->data.ui4 = matrix;\tbreak;\n\t\tcase GMT_INT:\t\tM->type = GMT_INT;\tM->data.si4 = matrix;\tbreak;\n\t\tcase GMT_USHORT:\tM->type = GMT_USHORT;\tM->data.ui2 = matrix;\tbreak;\n\t\tcase GMT_SHORT:\t\tM->type = GMT_SHORT;\tM->data.si2 = matrix;\tbreak;\n\t\tcase GMT_UCHAR:\t\tM->type = GMT_UCHAR;\tM->data.uc1 = matrix;\tbreak;\n\t\tcase GMT_CHAR:\t\tM->type = GMT_CHAR;\tM->data.sc1 = matrix;\tbreak;\n\t\tdefault:\n\t\t\treturn_error (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tbreak;\n\t}\n\tMH = gmt_get_M_hidden (M);\n\tMH->alloc_mode = GMT_ALLOC_EXTERNALLY;\t/* Since it clearly is a user array */\n\tMH->pad = pad;\t/* Placing the pad argument here */\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Put_Matrix_ (struct GMT_MATRIX *M, unsigned int *type, int *pad, void *matrix) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Put_Matrix (GMT_FORTRAN, M, *type, *pad, matrix));\n}\n#endif\n\nvoid * GMT_Get_Matrix (void *API, struct GMT_MATRIX *M) {\n\t/* Returns a pointer to the matrix.  Users can consult\n\t * M->type to know what data type is pointed to.  */\n\tvoid *matrix = NULL;\n\tif (API == NULL) return_null (API, GMT_NOT_A_SESSION);\n\tif (M == NULL) return_null (API, GMT_PTR_IS_NULL);\n\tswitch (M->type) {\n\t\tcase GMT_DOUBLE:\tmatrix = M->data.f8;\tbreak;\n\t\tcase GMT_FLOAT:\t\tmatrix = M->data.f4;\tbreak;\n\t\tcase GMT_ULONG:\t\tmatrix = M->data.ui8;\tbreak;\n\t\tcase GMT_LONG:\t\tmatrix = M->data.si8;\tbreak;\n\t\tcase GMT_UINT:\t\tmatrix = M->data.ui4;\tbreak;\n\t\tcase GMT_INT:\t\tmatrix = M->data.si4;\tbreak;\n\t\tcase GMT_USHORT:\tmatrix = M->data.ui2;\tbreak;\n\t\tcase GMT_SHORT:\t\tmatrix = M->data.si2;\tbreak;\n\t\tcase GMT_UCHAR:\t\tmatrix = M->data.uc1;\tbreak;\n\t\tcase GMT_CHAR:\t\tmatrix = M->data.sc1;\tbreak;\n\t\tdefault:\n\t\t\treturn_null (API, GMT_NOT_A_VALID_TYPE);\n\t\t\tbreak;\n\t}\n\treturn matrix;\n}\n\n#ifdef FORTRAN_API\nvoid * GMT_Get_Matrix_ (struct GMT_MATRIX *M) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Matrix (GMT_FORTRAN, M));\n}\n#endif\n\nint GMT_Put_Strings (void *V_API, unsigned int family, void *object, char **array) {\n\t/* Hook pointer to the text array in a matrix or vector */\n\tbool dup = false;\n\tenum GMT_enum_CPT code;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (object == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tif (array == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\tif (family & GMT_IS_DUPLICATE) {\t/* Need to duplicate the strings */\n\t\tdup = true;\n\t\tfamily -= GMT_IS_DUPLICATE;\n\t}\n\telse if (family & GMT_IS_REFERENCE)\t/* This is the default action, just remove the mode */\n\t\tfamily -= GMT_IS_REFERENCE;\n\tif (family & GMT_IS_PALETTE_KEY) {\n\t\tfamily -= GMT_IS_PALETTE_KEY;\n\t\tcode = GMT_IS_PALETTE_KEY;\n\t}\n\telse if (family & GMT_IS_PALETTE_LABEL) {\n\t\tfamily -= GMT_IS_PALETTE_LABEL;\n\t\tcode = GMT_IS_PALETTE_LABEL;\n\t}\n\tif (family == GMT_IS_PALETTE && code == 0) {\t/* This is specific to CPTs */\n\t\treturn_error (V_API, GMT_VALUE_NOT_SET);\n\t}\n\tif (!(family == GMT_IS_VECTOR || family == GMT_IS_MATRIX || family == GMT_IS_PALETTE)) return_error (V_API, GMT_NOT_A_VALID_FAMILY);\n\n\tif (family == GMT_IS_VECTOR) {\n\t\tstruct GMT_VECTOR *V = gmtapi_get_vector_data (object);\n\t\tstruct GMT_VECTOR_HIDDEN *VH = gmt_get_V_hidden (V);\n\t\tif (dup) {\t/* Must duplicate the input array of strings */\n\t\t\tuint64_t k;\n\t\t\tstruct GMTAPI_CTRL *API = gmtapi_get_api_ptr (V_API);\n\t\t\tif ((V->text = gmt_M_memory (API->GMT, NULL, V->n_rows, char **)) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Put_Strings: Unable to allocate text string array for vector\\n\");\n\t\t\t\treturn (GMT_MEMORY_ERROR);\n\t\t\t}\n\t\t\tfor (k = 0; k < V->n_rows; k++)\n\t\t\t\tif (array[k]) V->text[k] = strdup (array[k]);\n\t\t\tVH->alloc_mode_text = GMT_ALLOC_INTERNALLY;\n\t\t}\n\t\telse {\t/* By reference */\n\t\t\tV->text = array;\n\t\t\tVH->alloc_mode_text = GMT_ALLOC_EXTERNALLY;\n\t\t}\n\t}\n\telse if (family == GMT_IS_MATRIX) {\n\t\tstruct GMT_MATRIX *M = gmtapi_get_matrix_data (object);\n\t\tstruct GMT_MATRIX_HIDDEN *MH = gmt_get_M_hidden (M);\n\t\tif (dup) {\t/* Must duplicate the input array of strings */\n\t\t\tuint64_t k;\n\t\t\tstruct GMTAPI_CTRL *API = gmtapi_get_api_ptr (V_API);\n\t\t\tif ((M->text = gmt_M_memory (API->GMT, NULL, M->n_rows, char **)) == NULL) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Put_Strings: Unable to allocate text string array for matrix\\n\");\n\t\t\t\treturn (GMT_MEMORY_ERROR);\n\t\t\t}\n\t\t\tfor (k = 0; k < M->n_rows; k++)\n\t\t\t\tif (array[k]) M->text[k] = strdup (array[k]);\n\t\t\tMH->alloc_mode_text = GMT_ALLOC_INTERNALLY;\n\t\t}\n\t\telse {\t/* By reference */\n\t\t\tM->text = array;\n\t\t\tMH->alloc_mode_text = GMT_ALLOC_EXTERNALLY;\n\t\t}\n\t}\n\telse if (family == GMT_IS_PALETTE) {\n\t\tunsigned int k, item = (code == GMT_IS_PALETTE_LABEL) ? GMT_CPT_INDEX_LBL : GMT_CPT_INDEX_KEY;\n\t\tstruct GMT_PALETTE *P = gmtapi_get_palette_data (object);\n\t\tstruct GMT_PALETTE_HIDDEN *CH = gmt_get_C_hidden (P);\n\t\tfor (k = 0; k < P->n_colors; k++) {\n\t\t\tif (array[k] == NULL) continue;\t/* No string given for this entry */\n\t\t\tif (code == GMT_IS_PALETTE_LABEL) {\n\t\t\t\tif (dup && P->data[k].label) gmt_M_str_free (P->data[k].label);\t/* Free any old entry */\n\t\t\t\tP->data[k].label = (dup) ? strdup (array[k]) : array[k];\n\t\t\t}\n\t\t\telse if (code == GMT_IS_PALETTE_KEY) {\n\t\t\t\tif (dup && P->data[k].key) gmt_M_str_free (P->data[k].key);\t/* Free any old entry */\n\t\t\t\tP->data[k].key = (dup) ? strdup (array[k]) : array[k];\n\t\t\t}\n\t\t}\n\t\tCH->alloc_mode_text[item] = (dup) ? GMT_ALLOC_INTERNALLY : GMT_ALLOC_EXTERNALLY;\n\t}\n\treturn (GMT_NOERROR);\n}\n\n#ifdef FORTRAN_API\nint GMT_Put_Strings_ (unsigned int *family, void *object, char **array, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Put_Strings (GMT_FORTRAN, *family, object, array));\n}\n#endif\n\nchar ** GMT_Get_Strings (void *V_API, unsigned int family, void *object) {\n\t/* Return pointer to the text array in a matrix or vector */\n\tchar **array = NULL;\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tif (object == NULL) return_null (V_API, GMT_PTR_IS_NULL);\n\tif (!(family == GMT_IS_VECTOR || family == GMT_IS_MATRIX)) return_null (V_API, GMT_NOT_A_VALID_FAMILY);\n\tif (family == GMT_IS_VECTOR) {\n\t\tstruct GMT_VECTOR *V = gmtapi_get_vector_data (object);\n\t\tarray = V->text;\n\t}\n\telse if (family == GMT_IS_MATRIX) {\n\t\tstruct GMT_MATRIX *M = gmtapi_get_matrix_data (object);\n\t\tarray = M->text;\n\t}\n\tif (array == NULL)\n\t\treturn_null (V_API, GMT_PTR_IS_NULL);\n\treturn (array);\n}\n\n#ifdef FORTRAN_API\nchar ** GMT_Get_Strings_ (unsigned int *family, void *object) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Strings (GMT_FORTRAN, *family, object));\n}\n#endif\n\n#define GMT_NO_SUCH_ENUM -99999\n#include \"gmt_enum_dict.h\"\n\nint GMT_Get_Enum (void *V_API, char *key) {\n\t/* Access to GMT enums from environments unable to parse in gmt_resources.h.\n\t * Return value of enum or GMT_NO_SUCH_ENUM if not found */\n\tint lo = 0, hi = GMT_N_API_ENUMS, mid, value;\n\tgmt_M_unused (V_API);\n\tif (key == NULL || key[0] == '\\0') return GMT_NO_SUCH_ENUM;\n\twhile (lo != hi) {\t/* Do a binary search since gmt_api_enums is lexically sorted */\n\t\tmid = (lo + hi) / 2;\n\t\tvalue = strcmp (key, gmt_api_enums[mid].name);\n\t\tif (value == 0) return gmt_api_enums[mid].value;\n\t\tif ((hi-lo) == 1)\n\t\t\tlo = hi = mid;\n\t\telse if (value > 0)\n\t\t\tlo = mid;\n\t\telse if (value < 0)\n\t\t\thi = mid;\n\t}\n\treturn GMT_NO_SUCH_ENUM;\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Enum_ (char *arg, int len) {\n\treturn (GMT_Get_Enum (GMT_FORTRAN, arg));\n}\n#endif\n\n/* A few more FORTRAN bindings moved from gmt_fft.c: */\n\n#ifdef FORTRAN_API\ndouble GMT_FFT_Wavenumber_ (uint64_t *k, unsigned int *mode, void *v_K) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_Wavenumber (GMT_FORTRAN, *k, *mode, v_K));\n}\n#endif\n\n#ifdef FORTRAN_API\nint GMT_FFT_1D_ (gmt_grdfloat *data, uint64_t *n, int *direction, unsigned int *mode) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_1D (GMT_FORTRAN, data, *n, *direction, *mode));\n}\n#endif\n\n#ifdef FORTRAN_API\nint GMT_FFT_2D_ (gmt_grdfloat *data, unsigned int *n_columns, unsigned int *n_rows, int *direction, unsigned int *mode) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_FFT_2D (GMT_FORTRAN, data, *n_columns, *n_rows, *direction, *mode));\n}\n#endif\n\nint GMT_Get_Family (void *V_API, unsigned int direction, struct GMT_OPTION *head) {\n\t/* Scan the registered module input|output resources to learn what their family is.\n\t * direction:\tEither GMT_IN or GMT_OUT\n\t * head:\tHead of the list of module options\n\t *\n\t * Returns:\tThe family value (GMT_IS_DATASET|CPT|GRID|IMAGE|PS) or GMT_NOTSET if not known\n\t */\n\tstruct GMTAPI_CTRL *API = NULL;\n\tstruct GMT_OPTION *current = NULL;\n\tint item, object_ID, family = GMT_NOTSET;\n\t//int flag = (direction == GMT_IN) ? GMTAPI_MODULE_INPUT : GMT_NOTSET;\n\tunsigned int n_kinds = 0, k, counter[GMT_N_FAMILIES];\n\tchar desired_option = (direction == GMT_IN) ? GMT_OPT_INFILE : GMT_OPT_OUTFILE;\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tgmt_M_memset (counter, GMT_N_FAMILIES, unsigned int);\t/* Initialize counter */\n\tAPI->error = GMT_NOERROR;\t/* Reset in case it has some previous error */\n\n\tfor (current = head; current; current = current->next) {\t\t/* Loop over the list and look for input files */\n\t\tif (current->option != desired_option) continue;\t\t\t\t/* Not a module resource argument */\n\t\tif ((object_ID = gmtapi_decode_id (current->arg)) == GMT_NOTSET) continue;\t/* Not a registered resource */\n\t\t//if ((item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, direction, flag)) == GMT_NOTSET) continue;\t/* Not the right attributes */\n\t\tif ((item = gmtlib_validate_id (API, GMT_NOTSET, object_ID, direction, GMT_NOTSET)) == GMT_NOTSET) continue;\t/* Not the right attributes */\n\t\tcounter[(API->object[item]->family)]++;\t/* Update counts of this family */\n\t}\n\tfor (k = 0; k < GMT_N_FAMILIES; k++) {\t/* Determine which family we found, if any */\n\t\tif (counter[k]) n_kinds++, family = k;\n\t}\n\tif (n_kinds != 1) {\t/* Could not determine family */\n\t\tfamily = GMT_NOTSET;\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Get_Family: Could not determine family\\n\");\n\t}\n\telse\t/* Found a unique family */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Get_Family: Determined family to be %s\\n\", GMT_family[family]);\n\treturn (family);\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_Family_ (unsigned int *direction, struct GMT_OPTION *head) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_Family (GMT_FORTRAN, *direction, head));\n}\n#endif\n\nint GMT_Set_AllocMode (void *V_API, unsigned int family, void *object) {\n\tint error = GMT_NOERROR;\n\tuint64_t col;\n\tstruct GMT_VECTOR      *V = NULL;\n\tstruct GMT_DATASET_HIDDEN     *DH = NULL;\n\tstruct GMT_PALETTE_HIDDEN     *CH = NULL;\n\tstruct GMT_POSTSCRIPT_HIDDEN  *PH = NULL;\n\tstruct GMT_CUBE_HIDDEN    *UH = NULL;\n\tstruct GMT_VECTOR_HIDDEN      *VH = NULL;\n\tstruct GMT_MATRIX_HIDDEN      *MH = NULL;\n\tstruct GMT_GRID_HIDDEN        *GH = NULL;\n\tstruct GMT_IMAGE_HIDDEN       *IH = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (object == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\n\tswitch (family) {\t/* grid, image, or matrix */\n\t\tcase GMT_IS_GRID:\t/* GMT grid */\n\t\t\tGH = gmt_get_G_hidden (gmtapi_get_grid_data (object));\n\t\t\tGH->alloc_mode = GMT_ALLOC_EXTERNALLY;\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\t/* GMT image */\n\t\t\tIH = gmt_get_I_hidden (gmtapi_get_image_data (object));\n\t\t\tIH->alloc_mode = GMT_ALLOC_EXTERNALLY;\n\t\t\tbreak;\n\t\tcase GMT_IS_DATASET:\t/* GMT dataset */\n\t\t\tDH = gmt_get_DD_hidden (gmtapi_get_dataset_data (object));\n\t\t\tDH->alloc_mode = GMT_ALLOC_EXTERNALLY;\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\t/* GMT CPT */\n\t\t\tCH = gmt_get_C_hidden (gmtapi_get_palette_data (object));\n\t\t\tCH->alloc_mode = GMT_ALLOC_EXTERNALLY;\n\t\t\tbreak;\n\t\tcase GMT_IS_CUBE:\t/* GMT cube */\n\t\t\tUH = gmt_get_U_hidden (gmtapi_get_cube_data (object));\n\t\t\tCH->alloc_mode = GMT_ALLOC_EXTERNALLY;\n\t\t\tbreak;\n\t\tcase GMT_IS_POSTSCRIPT:\t\t/* GMT PS */\n\t\t\tPH = gmt_get_P_hidden (gmtapi_get_postscript_data (object));\n\t\t\tPH->alloc_mode = GMT_ALLOC_EXTERNALLY;\n\t\t\tbreak;\n\t\tcase GMT_IS_VECTOR:\t/* GMT Vector */\n\t\t\tV = gmtapi_get_vector_data (object);\n\t\t\tVH = gmt_get_V_hidden (V);\n\t\t\tfor (col = 0; col < V->n_columns; col++)\n\t\t\t\tVH->alloc_mode[col] = GMT_ALLOC_EXTERNALLY;\n\t\t\tbreak;\n\t\tcase GMT_IS_MATRIX:\t/* GMT Matrix */\n\t\t\tMH = gmt_get_M_hidden (gmtapi_get_matrix_data (object));\n\t\t\tMH->alloc_mode = GMT_ALLOC_EXTERNALLY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = GMT_NOT_A_VALID_FAMILY;\n\t\t\tbreak;\n\t}\n\treturn_error (V_API, error);\n}\n\n#ifdef FORTRAN_API\nint GMT_Set_AllocMode_ (unsigned int *family, void *object) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Set_AllocMode (GMT_FORTRAN, *family, object));\n}\n#endif\n\n/*! . */\nint GMT_Get_FilePath (void *V_API, unsigned int family, unsigned int direction, unsigned int mode, char **file_ptr) {\n\t/* Replace file with its full path if that file exists, else return an error.\n\t * If (mode & GMT_FILE_REMOTE) then we try to download any remote files\n\t * given but not yet cached locally), and if the downloaded file is readable then\n\t * we update file_ptr with the local path, otherwise return an error.\n\t * If (mode & GMT_FILE_CHECK) then we only return error code and don't update file_ptr.\n\t * The explicit mode for only examining local files is GMT_FILE_LOCAL [0].\n\t *\n\t * Filename complications:  Both grid, image and CPT filenames may have modifiers or\n\t * format identifiers appended to their names.  Thus, as given, file may name be a valid\n\t * filename until we have chopped off these strings.  Here is a summary of what GMT allows:\n\t *\n\t * imagefile[=gd[+b<band>]]\n\t * grdfile[=<id>][+o<offset>][+n<invalid>][+s<scale>][+u|U<unit>]\n\t * cptfile[+h<hinge>][+u|U<unit>]\n\t *   Note: Some modules also allows cptfile[+h<hinge>][+u|U<unit>][i<dz>] but the +d\n\t *   modifier is processed and removed in the module (grd-image/view/vector/2kml).\n\t *\n\t * gridfiles may also have strings to select specific layers of nigher-dimension netCDFfiles, using\n\t * grdfile?<variables>[layer]|(value).\n\t *\n\t * URL queries also use ? as in http://<address>?<par1>=<val1>...\n\t * Remote grids may also have format specification and modifiers like local grids:\n\t * https://<address>/grdfile[=<id>][+o<offset>][+n<invalid>][+s<scale>][+u|U<unit>]\n\t */\n\n\tchar remote_path[PATH_MAX] = {\"\"}, local_path[PATH_MAX] = {\"\"}, was, *file = NULL, *c = NULL, *f = NULL;\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (!(direction == GMT_IN || direction == GMT_OUT)) return_error (API, GMT_NOT_A_VALID_DIRECTION);\n\tif (!gmtapi_valid_input_family (family)) return_error (API, GMT_NOT_A_VALID_FAMILY);\n\tif (mode > (GMT_FILE_CHECK+GMT_FILE_REMOTE)) return_error (API, GMT_NOT_A_VALID_MODE);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\tAPI->error = GMT_NOERROR;\n\n\tif (file_ptr == NULL || (file = *file_ptr) == NULL || file[0] == '\\0') {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"No filename provided\\n\");\n\t\treturn_error (V_API, GMT_ARG_IS_NULL);\n\t}\n\n\tif (direction == GMT_OUT) return GMT_NOERROR;\n\n\tif (gmt_M_file_is_memory (file)) return GMT_NOERROR;\t/* Memory files are always fine */\n\n\tif (gmtlib_found_url_for_gdal (file)) {\t/* Special URLs for grids to be read via GDAL */\n\t\treturn GMT_NOERROR;\n\t}\n\n\tif ((mode & GMT_FILE_CHECK) == 0) gmt_set_unspecified_remote_registration (API, file_ptr);\t/* Complete remote filenames without registration information */\n\n\tswitch (family) {\n\t\tcase GMT_IS_GRID:\n\t\t\tif (!gmt_file_is_tiled_list (API, file, NULL, NULL, NULL) && (c = strchr (file, '='))) {\t/* Got filename=id[+modifiers] */\n\t\t\t\t/* Nothing*/\n\t\t\t}\n\t\t\telse if (gmt_M_file_is_netcdf (file))\t/* Meaning it specifies a layer etc via ?<args> */\n\t\t\t\tc = strchr (file, '?');\n\t\t\telse {\t/* Check for possible file modifiers */\n\t\t\t\tif ((f = gmt_strrstr (file, \".grd\")) || (f = gmt_strrstr (file, \".nc\")))\n\t\t\t\t\tc = gmtlib_last_valid_file_modifier (API, f, GMT_GRIDFILE_MODIFIERS);\n\t\t\t\telse\n\t\t\t\t\tc = gmtlib_last_valid_file_modifier (API, file, GMT_GRIDFILE_MODIFIERS);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GMT_IS_IMAGE:\n\t\t\tc = strstr (file, \"=gd\");\t/* Got image=gd[+modifiers] */\n\t\t\tbreak;\n\t\tcase GMT_IS_PALETTE:\n\t\t\tif ((f = gmt_strrstr (file, GMT_CPT_EXTENSION)))\n\t\t\t\tc = gmtlib_last_valid_file_modifier (API, f, GMT_CPTFILE_MODIFIERS);\n\t\t\telse\n\t\t\t\tc = gmtlib_last_valid_file_modifier (API, file, GMT_CPTFILE_MODIFIERS);\n\t\t\tbreak;\n\t\tdefault:\t/* No checks for the other families */\n\t\t\tbreak;\n\t}\n\n\tif (c && !gmt_M_file_is_url (file)) {\t/* Other that queries, we don't want to pass modifiers when copying files */\n\t\twas = c[0];\n\t\tc[0] = '\\0';\n\t}\n\n\tif (gmt_set_remote_and_local_filenames (API->GMT, file, local_path, remote_path, GMT_AUTO_DIR)) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"Cannot find file %s\\n\", file);\n\t\treturn_error (V_API, GMT_FILE_NOT_FOUND);\n\t}\n\n\t/* Here we have found a local file or we must download from server first */\n\n\tif (remote_path[0]) {\t/* Remote file given but not yet stored locally */\n\t\tif (mode & GMT_FILE_REMOTE) {\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Download %s to %s\\n\", remote_path, local_path);\n\t\t\tif (gmt_download_file (API->GMT, file, remote_path, local_path, true)) {\n\t\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"Unable to obtain remote file %s\\n\", file);\n\t\t\t\treturn_error (V_API, GMT_FILE_NOT_FOUND);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Given a remote file %s but mode is not GMT_ADD_REMOTE\\n\", file);\n\t\t\treturn_error (V_API, GMT_FILE_NOT_FOUND);\n\t\t}\n\t}\n\n\tif (c) c[0] = was; /* Restore what we did*/\n\tif ((mode & GMT_FILE_CHECK) == 0) {\t/* Pass the local path back */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Replace file %s with %s\\n\", file, local_path);\n\t\tif (c) /* Also append any file directives via modifiers */\n\t\t\tstrncat (local_path, c, PATH_MAX-1);\n\t\tgmt_M_str_free (*file_ptr);\n\t\t*file_ptr = strdup (local_path);\n\t}\n\n\treturn GMT_NOERROR;\n}\n\n#ifdef FORTRAN_API\nint GMT_Get_FilePath_ (unsigned int *family, unsigned int *direction, unsigned int *mode, char **file, int len) {\n\t/* Fortran version: We pass the global GMT_FORTRAN structure */\n\treturn (GMT_Get_FilePath (GMT_FORTRAN, *family, *direction, *mode, file));\n}\n#endif\n\nint GMT_Extract_Region (void *V_API, char *file, double wesn[]) {\n\tFILE *fp = NULL;\n\tbool found = false;\n\tstruct GMTAPI_CTRL *API = gmtapi_get_api_ptr (V_API);\n\tchar xx1[GMT_LEN64] = {\"\"}, xx2[GMT_LEN64] = {\"\"}, yy1[GMT_LEN64] = {\"\"}, yy2[GMT_LEN64] = {\"\"}, line[GMT_LEN256] = {\"\"};\n\n\tif (V_API == NULL) return_error (V_API, GMT_NOT_A_SESSION);\n\tif (wesn == NULL) return_error (V_API, GMT_PTR_IS_NULL);\n\n\tif (API->GMT->current.setting.run_mode == GMT_MODERN) {\t/* Modern mode, file must be NULL */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Extract_Region: Modern mode\\n\");\n\t\tif (file) {\t/* Cannot specify file in modern mode */\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Extract_Region: Cannot give a PostScript filename in modern mode\\n\");\n\t\t\treturn_error (V_API, GMT_FILE_NOT_FOUND);\n\t\t}\n\t\tif (gmt_set_psfilename (API->GMT) == 0) {\t/* Get hidden file name for current PS */\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"No hidden PS file found\\n\");\n\t\t\treturn_error (V_API, GMT_FILE_NOT_FOUND);\n\t\t}\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Hidden PS file %s found\\n\", API->GMT->current.ps.filename);\n\t\tif ((fp = fopen (API->GMT->current.ps.filename, \"r\")) == NULL) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Extract_Region: Failed to find/open current PS file %s\\n\", API->GMT->current.ps.filename);\n\t\t\treturn_error (V_API, GMT_FILE_NOT_FOUND);\n\t\t}\n\t}\n\telse {\t/* Classic mode, file must be given */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"GMT_Extract_Region: Classic mode\\n\");\n\t\tif (file == NULL) {\t/* Must specify file in classic mode */\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Extract_Region: Filename required in classic mode\\n\");\n\t\t\treturn_error (V_API, GMT_FILE_NOT_FOUND);\n\t\t}\n\t\tif ((fp = fopen (file, \"r\")) == NULL) {\n\t\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Extract_Region: Failed to find/open %s\\n\", file);\n\t\t\treturn_error (V_API, GMT_FILE_NOT_FOUND);\n\t\t}\n\t}\n\n\t/* We expect GMT_Extract_Region to be applied to GMT-produced PS files so we know they are clean records readable with fgets */\n\n\twhile (!found && gmt_fgets (API->GMT, line, GMT_LEN256, fp)) {\n\t\tif (!strncmp (&line[2], \"PROJ\", 4)) {\t/* Search for the PROJ tag in the ps file */\n\t\t\tsscanf (&line[8], \"%*s %s %s %s %s\", xx1, xx2, yy1, yy2);\n\t\t\twesn[XLO] = atof (xx1);\t\twesn[XHI] = atof (xx2);\n\t\t\twesn[YLO] = atof (yy1);\t\twesn[YHI] = atof (yy2);\n\t\t\tif (wesn[XLO] > 180.0 && wesn[XHI] > 180.0) {\n\t\t\t\twesn[XLO] -= 360.0;\n\t\t\t\twesn[XHI] -= 360.0;\n\t\t\t}\n\t\t\tfound = true;\n\t\t}\n\t}\n\tfclose (fp);\n\tif (!found) {\n\t\tGMT_Report (API, GMT_MSG_ERROR, \"GMT_Extract_Region: Failed to find the PROJ tag with the region\\n\");\n\t\treturn_error (V_API, GMT_VALUE_NOT_SET);\n\t}\n\treturn_error (V_API, GMT_NOERROR);\n}\n\nfloat GMT_Get_Version (void *API, unsigned int *major, unsigned int *minor, unsigned int *patch) {\n\t/* Return the current lib version as a float, e.g. 6.0, and optionally its constituents.\n\t * Either one or all of in *major, *minor, *patch args can be NULL. If they are not, one\n\t * gets the corresponding version component. */\n\tint major_loc, minor_loc, patch_loc;\n\tgmt_M_unused(API);\n\n\tmajor_loc = GMT_PACKAGE_VERSION_MAJOR;\n\tminor_loc = GMT_PACKAGE_VERSION_MINOR;\n\tpatch_loc = GMT_PACKAGE_VERSION_PATCH;\n\tif (major) *major = (unsigned int)major_loc;\n\tif (minor) *minor = (unsigned int)minor_loc;\n\tif (patch) *patch = (unsigned int)patch_loc;\n\treturn major_loc + (float)minor_loc / 10;\n}\n\n/* Help functions specific to the Julia/GMT API.  They are not documented */\n\nEXTERN_MSC int gmtlib_blind_change_struct(void *V_API, void *ptr, void *what, char *type, size_t off) {\n\t/* This is a magic backdoor to change static members of API structures that had to be declared as\n\t   immutables types in Julia and therefore impossible to change from within Julia.\n\t   *ptr  -> structure pointer whose member identified by the offset 'off' is to be changed.\n\t   *what -> pointer to the new value of the struct member that will be changed.\n\t   *type -> string with the type description, using the Julia types names. e.g. 'UInt32' or 'Float64'\n\t   The offset value 'off' is that obtained with the Julia's fieldoffsets() function, which is\n\t   equivalent to the 'offsetof()' C macro.\n\t*/\n\tif (!strcmp(type, \"Int32\"))\n\t\t*(int *)((char *)ptr + off) = *(int *)what;\n\telse if (!strcmp(type, \"UInt32\"))\n\t\t*(unsigned int *)((char *)ptr + off) = *(unsigned int *)what;\n\telse if (!strcmp(type, \"Int64\"))\n\t\t*(int64_t *)((char *)ptr + off) = *(int64_t *)what;\n\telse if (!strcmp(type, \"UInt64\"))\n\t\t*(uint64_t *)((char *)ptr + off) = *(uint64_t *)what;\n\telse if (!strcmp(type, \"Float32\"))\n\t\t*(float *)((char *)ptr + off) = *(float *)what;\n\telse if (!strcmp(type, \"Float64\"))\n\t\t*(double *)((char *)ptr + off) = *(double *)what;\n\telse if (!strcmp(type, \"Int16\"))\n\t\t*(signed short *)((char *)ptr + off) = *(signed short *)what;\n\telse if (!strcmp(type, \"UInt16\"))\n\t\t*(unsigned short *)((char *)ptr + off) = *(unsigned short *)what;\n\telse if (!strcmp(type, \"UInt8\"))\n\t\t*(unsigned char *)((char *)ptr + off) = *(unsigned char *)what;\n\telse if (!strcmp(type, \"Int8\"))\n\t\t*(char *)((char *)ptr + off) = *(char *)what;\n\telse {\n\t\tGMT_Report(V_API, GMT_MSG_ERROR, \"GMT/Julia Backdoor: Type (%s) not accepted. Possibly a pointer to something.\\n\", type);\n\t\treturn_error (V_API, GMT_NOT_A_VALID_PARAMETER);\n\t}\n\treturn GMT_NOERROR;\n}\n\nEXTERN_MSC void * gmtlib_get_ctrl (void *V_API) {\n\t/* For external environments that need to get the GMT pointer for calling\n\t * lower-level GMT library functions that expects the GMT pointer */\n\tstruct GMTAPI_CTRL *API = NULL;\n\n\tif (V_API == NULL) return_null (V_API, GMT_NOT_A_SESSION);\n\tAPI = gmtapi_get_api_ptr (V_API);\n\treturn API->GMT;\t/* Pass back the GMT ctrl pointer as void pointer */\n}\n\nint64_t gmt_eliminate_duplicates (struct GMTAPI_CTRL *API, struct GMT_DATASET *D, uint64_t cols[], uint64_t ncols, bool text) {\n\t/* Scan dataset per segment and eliminate any duplicate records as identified by having no change in all the specified cols.\n\t * If no change then we skip the duplicate records.  No segment will be eliminated since first record always survives.\n\t * Including the trailing text in the comparison is optional and requires setting of the text flag to true. */\n\tbool may_be_duplicate;\t/* Initially true, gets set to false if we fail any of the one or more tests */\n\tuint64_t tbl, seg, row, last_row, k, n_dup_seg, n_dup = 0;\n\tint64_t n_skip;\t/* Number of consecutive duplicate rows */\n\tunsigned int mode;\n\tstruct GMT_DATASEGMENT *S = NULL;\n\n\tif (ncols == 0 || cols == NULL) {\n\t\tgmtlib_report_error (API, GMT_N_COLS_NOT_SET);\n\t\treturn -GMT_N_COLS_NOT_SET;\n\t}\n\tfor (k = 0; k < ncols; k++) if (cols[k] >= D->n_columns) {\n\t\tgmtlib_report_error (API, GMT_DIM_TOO_LARGE);\n\t\treturn -GMT_DIM_TOO_LARGE;\n\t}\n\n\tfor (tbl = 0; tbl < D->n_tables; tbl++) {\t/* Examine each table */\n\t\tfor (seg = 0; seg < D->table[tbl]->n_segments; seg++) {\t/* Examine each segment */\n\t\t\tS = D->table[tbl]->segment[seg];\t/* Current segment shorthand */\n\t\t\tmode = (S->text) ? GMT_WITH_STRINGS : GMT_NO_STRINGS;\n\t\t\tlast_row = 0;\t/* Always keep the first row of any segment */\n\t\t\tn_dup_seg = 0;\t/* None yet found in this segment */\n\t\t\trow = 0;\n\t\t\twhile (row < (S->n_rows-1)) {\t/* Since we increase row inside we must stop this loop at one less */\n\t\t\t\tn_skip = -1;\t/* Since incremented before the test */\n\t\t\t\tdo {\t/* Check if this row is same as last, for given cols */\n\t\t\t\t\trow++;\t/* Advance to next record */\n\t\t\t\t\tn_skip++;\t/* So now it is 0 the very first time */\n\t\t\t\t\tmay_be_duplicate = true;\t/* See if we can fail a test */\n\t\t\t\t\tfor (k = 0; may_be_duplicate && k < ncols; k++) {\t/* Check the columns indicated as long as the records may be duplicates */\n\t\t\t\t\t\tif (!doubleAlmostEqualZero (S->data[cols[k]][row], S->data[cols[k]][last_row]))\n\t\t\t\t\t\t\tmay_be_duplicate = false;\t/* Failed to match across these two rows for this column */\n\t\t\t\t\t}\n\t\t\t\t\tif (may_be_duplicate && text && mode && S->text[row] && S->text[last_row] && strcmp (S->text[row], S->text[last_row]))\n\t\t\t\t\t\tmay_be_duplicate = false;\t/* Failed to match across these two rows for trailing text */\n\t\t\t\t} while (may_be_duplicate && row < S->n_rows);\n\n\t\t\t\tif (n_skip) {\t/* Must move up all memory and bury this repeat record */\n\t\t\t\t\tfor (k = 0; k < S->n_columns; k++)\n\t\t\t\t\t\tmemmove (&S->data[k][row-n_skip], &S->data[k][row], (S->n_rows-row)*sizeof(double));\n\t\t\t\t\tif (mode & GMT_WITH_STRINGS)\n\t\t\t\t\t\tmemmove (&S->text[row-n_skip], &S->text[row], (S->n_rows-row)*sizeof(char *));\n\t\t\t\t\tS->n_rows -= n_skip;\t/* Since we lost records */\n\t\t\t\t\tn_dup_seg += n_skip;\n\t\t\t\t\trow -= n_skip;\n\t\t\t\t}\n\t\t\t\tlast_row++;\n\t\t\t}\n\t\t\tif (n_dup_seg) {\t/* Found duplicates, need  to reallocate arrays */\n\t\t\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Removed %\" PRIu64 \" duplicate records from table %\" PRIu64\", segment %\" PRIu64\"\\n\", n_dup_seg, tbl, seg);\n\t\t\t\tif (gmt_alloc_segment (API->GMT, S, S->n_rows, S->n_columns, mode, false))\n\t\t\t\t\treturn -GMT_RUNTIME_ERROR;\t/* Failure of some sort */\n\t\t\t\tn_dup += n_dup_seg;\n\t\t\t}\n\t\t}\n\t}\n\tif (n_dup) {\n\t\tgmt_set_dataset_minmax (API->GMT, D);\t/* Update min/max for each column */\n\t\tGMT_Report (API, GMT_MSG_DEBUG, \"Removed %\" PRIu64 \" duplicate records from the entire dataset\\n\", n_dup);\n\t}\n\n\treturn (n_dup);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/src/gmt_sharedlibs.h.in": "/*\n *\tCopyright (c) 2012-2021 by the GMT Team (https://www.generic-mapping-tools.org/team.html)\n * by the GMT Team (https://www.generic-mapping-tools.org/team.html)\n * See LICENSE.TXT file for copying and redistribution conditions.\n */\n\n/*!\n * \\file gmt_sharedlibs.h\n * \\brief Structures needed by the various shared libraries.\n */\n\n#pragma once\n#ifndef GMT_SHAREDLIBS_H\n#define GMT_SHAREDLIBS_H\n\n#ifdef __cplusplus /* Basic C++ support */\nextern \"C\" {\n#endif\n\n#define GMT_SUPPL_LIB_NAME \"@GMT_SUPPL_LIB_NAME@\"\n\n#ifdef _WIN32\n#include <windows.h>\n\n/* Various functions declared in gmt_sharedlibs.c */\nEXTERN_MSC void *dlopen (const char *module_name, int mode);\nEXTERN_MSC int dlclose (void *handle);\nEXTERN_MSC void *dlsym (void *handle, const char *name);\nEXTERN_MSC char *dlerror (void);\n#else\n#include <dlfcn.h>\n#endif\n\nEXTERN_MSC void *dlopen_special (const char *name);\n\n/*! Info for each GMT shared library. This array is filled out when parsing GMT_CUSTOM_LIBS at end of GMT_Create_Session */\n\nstruct GMT_LIBINFO {\n\tchar *name;\t/* Library tag name [without leading \"lib\" and extension], e.g. \"gmt\", \"supplements\" */\n\tchar *path;\t/* Full path to library as given in GMT_CUSTOM_LIBS */\n\tbool skip;\t/* true if we tried to open it and it was not available the first time */\n\tvoid *handle;\t/* Handle to the shared library, returned by dlopen or dlopen_special */\n};\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !GMT_SHAREDLIBS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/src/gmt_sharedlibs.c": "/*\n *\tCopyright (c) 2012-2021 by the GMT Team (https://www.generic-mapping-tools.org/team.html)\n * See LICENSE.TXT file for copying and redistribution conditions.\n */\n\n/* Here are Windows implementations of standard POSIX shared\n * library function.  Borrowed from this website:\n * http://www.refcode.net/2013/02/posix-dynamic-library-loading-calls-for.html\n * which says it is open source.\n */\n\n#include \"gmt_dev.h\"\n#include \"gmt_sharedlibs.h\" \t/* Common shared libs structures */\n\n#if defined(_WIN32)\nvoid *dlopen (const char *module_name, int mode) {\t/* Opens a dll file*/\n\tUINT err_code;\n\tHINSTANCE dll_handle;\n\tgmt_M_unused (mode);\n\n\terr_code = SetErrorMode (SEM_FAILCRITICALERRORS);\n\tdll_handle = LoadLibrary (module_name);\n\tif (!dll_handle) {\n\t\tdll_handle = LoadLibraryEx (module_name, NULL, 0);\n\t\tif (!dll_handle)\n\t\t\treturn (void *)dll_handle;\n \t}\n\n\t/* Clear the last error*/\n\tSetLastError (0);\n\treturn (void *)dll_handle;\n}\n\nint dlclose (void *handle) {\n\t/* Closes handle */\n\t/* POSIX call returns zero for success, non-zero for failure */\n\treturn (!FreeLibrary (handle));\n}\n\nvoid *dlsym (void *handle, const char *name) {\n\t/* Get a symbol from dll */\n\treturn GetProcAddress (handle, name);\n}\n\nchar *dlerror (void) {\n\t/* Reports last error occurred */\n\tint len, error_code;\n\tstatic char errstr[GMT_LEN128];\n\n\tif ((error_code = GetLastError ()) == 0)\n\t\treturn NULL;\n\n\t/* POSIX dlerror call needs to report no error (null)\n\t   when it is called 2nd time consequently, so clear error */\n\tSetLastError (0);\n\n\t/* Format the error string */\n\tlen = snprintf (errstr, GMT_LEN128, \"Error <%d>: \", error_code);\n\tlen += FormatMessage (\n\t\tFORMAT_MESSAGE_FROM_SYSTEM,\n\t\tNULL,\n\t\terror_code,\n\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */\n\t\t(LPTSTR) errstr + len,\n\t\tsizeof(errstr) - len,\n\t\tNULL\n\t\t);\n\n\t/* Replace \\r\\n */\n\tif (len > 1 && errstr[len-2] == '\\r' && errstr[len-1] == '\\n') {\n\t\tif (len > 2 && errstr[len-3] == '.')\n\t\t\tlen--;\n\t}\n\n\treturn errstr;\n}\n\n/* Extra convenience function for opening DLL of current process */\nHINSTANCE GetMyModuleHandle() {\n\t/* http://stackoverflow.com/questions/846044/how-to-get-the-filename-of-a-dll */\n\tMEMORY_BASIC_INFORMATION mbi;\n\tVirtualQuery(GetMyModuleHandle, &mbi, sizeof(mbi));\n\treturn (HINSTANCE) (mbi.AllocationBase);\n}\nvoid *dlopen_special(const char *name) {\n\t/* Opens the dll file of the current process.  This is how it is done\n\t * under Windows, per http://en.wikipedia.org/wiki/Dynamic_loading */\n\t/*HMODULE this_process, this_process_again;\n\tGetModuleHandleEx (0, 0, &this_process);\n\tthis_process_again = GetModuleHandle (NULL);\n\treturn (this_process_again);*/\n\tgmt_M_unused (name);\n\tHINSTANCE this_dll_process;\n\tthis_dll_process = GetMyModuleHandle();\n\treturn (this_dll_process);\n}\n#elif defined(__CYGWIN__)\n\t/* Cygwin behaves differently than most Unix and we must use regular dlopen with library name */\nvoid *dlopen_special(const char *name) {\n\t/* Opens the shared library file of the current process under *nix.\n\t * Just call dlopen with NULL and RTLD_LAZY */\n\treturn (dlopen (name, RTLD_LAZY));\n}\n#else\n\n/* Extra convenience function for opening shared library of current process */\n\nvoid *dlopen_special(const char *name) {\n\t/* Opens the shared library file of the current process under *nix.\n\t * Just call dlopen with NULL and RTLD_LAZY */\n\tgmt_M_unused(name);\n\treturn (dlopen (NULL, RTLD_LAZY));\n}\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/admin/PS_orig_for_gs.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/admin/PS_orig_for_gs.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/.git/objects/pack/pack-26486eed2de3e16cc5cd9084af7f8a1d7df8e453.pack",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/.git/objects/pack/pack-26486eed2de3e16cc5cd9084af7f8a1d7df8e453.idx",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_gr.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_jp.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_fi.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_pl.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_is.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_cn1.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_ru.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_cn2.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_se.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_es.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_hu.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_tr.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_de.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_dk.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_fr.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/localization/gmt_il.locale",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/share/spotter/Global_EarthByte_Plate_ID_Table.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/grdread.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/grdimage.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/force_global.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/marbles.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/afr.grd",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/subset.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/rounding.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/autointense.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/SST.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/grdclip.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/grdcyclic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/grdwrap.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/mask.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/rendering.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/hovmuller.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/emag_v2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/lonshift.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/const_intens.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdimage/globalgrid.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/latex/latexlabel.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscontour/saver.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscontour/thickness.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscontour/hilow.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/x2sys/x2sys_04.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/x2sys/ss_faa.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/x2sys/x2sys_02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/x2sys/x2sys_06.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/x2sys/x2sys_07.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/x2sys/x2sys_01.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/x2sys/x2sys_03.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfft/gfilter.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfft/in_taper.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfft/out_taper.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfft/power2D.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfft/bworthr.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfft/cylundulation.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/trend1d/trend1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/nuvel1.vx.1.5.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/shrink.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/wrapped.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/cartvec.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/tworegions.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/nuvel1.vy.1.5.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/cartpol.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/bothg.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/sample.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/wy_grd000.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/plate.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/vec_scales.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/wx_grd000.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvector/grdgeovec.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pshistogram/distributions.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pshistogram/altwidth.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pshistogram/mmm.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdmath/ldist.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdmath/ops.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdmath/daynight.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdmath/reduce.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/sample1d/splines.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/sample1d/sample.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/sample1d/smooth.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grd2cpt/paintallzs.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grd2cpt/equalarea.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdinterpolate/cube.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdinterpolate/fake_geot_cube.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdinterpolate/slices_file.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdinterpolate/slices.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdinterpolate/fake_geoz_cube.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdedit/transrot.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdedit/edit.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdedit/grdflip.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/mapproject/waypoints.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/mapproject/oblmerc_down.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/mapproject/oblmerc_up.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/mapproject/azimuth.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/seis/seis_04.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/seis/seis_02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/seis/seis_03.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/seis/seis_01.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/seis/seis_08.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/seis/seis_05.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/seis/seis_10.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/seis/seis_07.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdclip/limits.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/img/imgtrack.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/img/imgmap.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pswiggle/wiggles.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtinfo/tp2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/geodesy/geodesy_02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/geodesy/case_largeR_withW.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/geodesy/geodesy_01.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/geodesy/geodesy_05.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/geodesy/gpsgridder1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/geodesy/case_smallR_withW.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/geodesy/case_largeR_noW.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/geodesy/case_smallR_noW.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/geodesy/geodesy_03.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/geodesy/gpsgridder2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/clipping5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/datagrep.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/mixed_axes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/units.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/ErrorEllipseGeo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/bezvec.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/vector.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/vec_choice.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/tiling1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/conic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/endarrows.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/hexagone.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/tiling2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/plane_geo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/twovtypes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/rectclip.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/urlquakes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/cartvec.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/ErrorEllipseCart.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/connections.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/colorlines.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/rotrectangle.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/binarypie.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/gtec_tx_daily.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/linetrim.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/wrapping.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/windbarb.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/cmdargs.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/condcust_symbol.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/scaling.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/clipping8.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/custom_textsymbol.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/linearrow.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/tiling.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/line_geo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/repeat1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/matharrow.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/arrows.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/txtsymb.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/gallo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/repeat2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/line_wraps.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/bezierline.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/categorical.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/vectypes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/plane_cart.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/gallo_road.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/tissot_TM.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/split_mean.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/poleline.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/autocolorlines.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/clipping7.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/lon_vs_time.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/diagonal.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/japquakes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/antwrap.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/custom_textconditional.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/gaps.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/lineclip.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/badpols.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/quotedlinedash.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/polar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/custom_symbol.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/clipping4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/macros.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/nojump.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/geosegmentize.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/clipping3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/polyholes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/variable_z.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/stairs.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/matharcvar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/longjump.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/custom_azim.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/comparesymbols.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/clipping1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/condcust_symbol_xy.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/clipping2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/geovector.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxy/geovector2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gshhg/comb_ants.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gshhg/two_ants.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtregress/regress_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtregress/rls_on_rma.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdmask/geoholes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdmask/sphinout.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdmask/twoblobs.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdmask/ogrtest.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdmask/polarhole.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdmask/holes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/byteswap/binary.be",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/byteswap/binary.le",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtsplit/split.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/surface/periodic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/surface/periodic_pix.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psevents/varline.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psevents/events.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/east_map_7.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/snyder_map.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/gridlines2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/east_map_0.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/hyperbolic_map.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/polar2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/east_map_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/pacific_map_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/gridlines.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/pacific_map_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/east_map_5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/east_map_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/east_map_4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/polar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/east_map_3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/east_map_8.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/genper/east_map_6.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/project/cartesian.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/project/ellipses.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/project/circles.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdvolume/sphere_volume.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pslegend/legend3D.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pslegend/autolegendcolor.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pslegend/autolegendcolorL.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pslegend/legend.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pslegend/legcpt.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pslegend/lines.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/segy/segy_01.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/segy/wa1_mig13.segy",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/segy/segy_02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/segy/segy_04.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/segy/segy_05.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/segy/segy_03.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfilter/openmp.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfilter/varfilter.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfilter/highpass.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfilter/filtertest.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pstext/ISO-8859-2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pstext/cliptxtbox.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pstext/composite.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pstext/test.grd",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pstext/utf8.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pstext/shade_text.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pstext/supersub.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/ogr/select.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/ogr/quakes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/ogr/lookup.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/trend2d/trend.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdsample/straddle.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdsample/sample.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdsample/resample.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtvector/translate_geo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtvector/meanvec.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfill/constfill.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfill/splinefill.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfill/nnfill.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdfill/showregions.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdblend/center_nf_g.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdblend/center_cf_p.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdblend/center_cf_g.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdblend/center_bf_g.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdblend/center_bf_p.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdblend/center_nf_p.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/longtitles_hat.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/azim_polar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/polarcases.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/map_JE.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/inside.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/radians.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/mapscales.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/absrelaxis.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/annotations4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/asymm_grid.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/rose_dir.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/mapbardefault.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/annotations1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/longtitles_break.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/custxlabel.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/horlabel.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/rose_mag2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/oblique.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/test-JXd.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/polarcircles.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/azim_global.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/fancyannot.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/compass.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/azim_radial.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/merc_origin.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/annotations2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/mapbarlat.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/zscaling.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/zrotation.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/rose_mag1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/JOb_pole.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psbasemap/polarapex.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdtrend/trend_robust.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/sph2grd/one.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/sph2grd/EGM96.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_12.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_10.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_05.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_03.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_01.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_04.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_11.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_08.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_07.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spotter/spotter_09.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtspatial/crossings.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtspatial/lonjump.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtspatial/nn.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtspatial/intersect.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtspatial/atruncate.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/makecpt/autocpt.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtconnect/connect.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/greenspline/gspline_5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/mgd77/cm4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/mgd77/track.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/seis.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/horsclpanel.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/cbars.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/hardsoft.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/horizontal.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/categoricalcpt.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/versclpanel.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/psscale.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/cpthinges.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/vertical.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psscale/pattern.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxyz/vector.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxyz/vec_choice.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxyz/cartvec.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxyz/rotrectangle.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxyz/linez.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxyz/cmdargs.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxyz/3dbars.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxyz/variable_z.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxyz/geovector.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psxyz/geovector2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/sph/sph_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/sph/sph_4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/sph/sph_5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/sph/sph_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/sph/sph_3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/pssac_G.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/pssac_common-options.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/pssac_geo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/seis.sac",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/sdkl.z",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/onkl.z",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/pssac_T.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/pssac_W.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/pssac_F.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/ntkl.z",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/pssac_D.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/nykl.z",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/pssac_C.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssac/pssac_Q.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdpaste/paste_gridreg_underlap.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdpaste/paste_gridreg_underlap_bf.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdpaste/paste_pixreg_overlap.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdpaste/paste_x.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdpaste/paste_pixreg.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/psmask/holes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtsimplify/reduce.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdlandmask/greenwich.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdlandmask/lmask.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdlandmask/trace1g.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdlandmask/trace1p.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdlandmask/mask.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/filter1d/smooth_track.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/filter1d/filter.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/filter1d/highpass.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/filter1d/cfilter.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_2.3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/4legends.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_3.0.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_2.2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_1.3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_1.2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_4.3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_1.1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_4.0.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_3.1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_2.1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_4.1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_1.0.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_2.0.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_4.2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_3.2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/linpanels.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/subplot_3.3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/subplot/linpanelsnew.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/grdgravmag3D_grav_sph.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/sombrero_mag.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/sphtest.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/flexure_e.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/fc_okb.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/admittance.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/grdokb_grav.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/flex2d.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/fields.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/cseamounts.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/smt_poly.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/firmoviscous2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/variablerho.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/deflections.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/firmoviscous.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/flexapprox.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/gseamounts.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/cyltest.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/cyl2d.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/flexure_gl.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/cube_mag.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/flexure_en.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/spheres.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/potential/flex_inplane.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grd2xyz/extract.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pspolar/pspolar_-T.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdgradient/illum_var.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdgradient/illum_manip.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdgradient/illum_lambert.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdgradient/illum_classic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtselect/selectlines.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtselect/near_a_line.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/grdview.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/domo-filtrado.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/icelandbox.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/texture.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/cuerpo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/categorical.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/test.grd",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/autointense.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/denver.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/rgb.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdview/super2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdtrack/layout.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdtrack/profiles.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssolar/pssolar_fill.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pssolar/pssolar_fill2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/api/apivec.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/api/apimat.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/api/apimat_io.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/api/apimatgrd.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/api/apivec_io.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/api/apimat2grd.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/api/api_matrix_as_grid.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtmath/pdfs2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtmath/cdfs1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtmath/pdfs1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtmath/lsfit.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/spectrum1d/power1D.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/kml/kml2gmt.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/closed.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/contours.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/bigisland.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/grdcontour.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/test.grd",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/grdtime.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/pen_choice.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/varpens.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/polcontr.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/contourlegend.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/sombrero.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/TMcontours.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/grdtxtclip.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcontour/colorwithtitle.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtconvert/mix_binary_data.b",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtbinstats/weightedrect.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtbinstats/nonweighted.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtbinstats/nonweightedrect.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtbinstats/weighted.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/modern/viewpluscpt.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/modern/longbasemap.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/modern/imagepluscpt.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/modern/somepanels.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/modern/polarpanels.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/modern/inset.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/postscriptlight/psldemo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtmex/WL_example_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtmex/WL_example_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/gmtmex/WL_example_3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcut/subset.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/grdcut/origin.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/vert_obl_merc.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/pscoast_JE3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/pscoast_180.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/pscoast_Madagascar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/gshhs_A.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/pscoast_JS.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/pscoast_JW.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/spain.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/pscoast_JM.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/pscoast_mess.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/oblCA.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/pscoast_JQ.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/test/pscoast/dumpvsplot.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/cmake/dist/GMT.icns",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/formatting.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/formatpicture.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/srtm1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/xcode-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/GMT5_external.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/xcode-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/GMT5_mode.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/GMT_record.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/GMT6_Summit_2019.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/GMT4_mode.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/dem.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/xcode-5.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/xcode-7.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/GMT_Environment.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/nasa-logo-web-rgb.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/xcode-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/igpp.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/noantialias.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/gshhg.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/rendering.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/dcw-figure.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/hsv-cone.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/xcode-6.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/GMT_Environment.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/EarthByte_logo_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/xcode-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/highres.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/gimp-sliders+panel.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/withantialias.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/xcode-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/GMT_record.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/fig/daynight.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/atlantwhitesided.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/commonporpoise_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/humpbacktail_two_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/bottlenose_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/beluga_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/killerwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/jumpback_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/bowhead_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/spermwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/commondolphin_midlow.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/spermwhaletail.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/stripeddolphin_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/srightwhaledolphin_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/longfinnedpilotwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/beluga.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/graywhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/unidentifieddolphin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/southernrightwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/spectacledporpoise_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/bottlenose.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/graywhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/jumpback.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/pigmyspermwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/northernrightwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/seiwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/shortfinnedpilotwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/bowhead_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/commondolphin_midhigh.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/spermwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/humpbacktail_one_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/commondolphin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/stripeddolphin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/minkewhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/atlantwhitesided_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/commonporpoise.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/unidentifieddolphin_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/cuviersbeaked_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/pigmyspermwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/stripeddolphin_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/rissosdolphin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/bottlenose_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/humpbacktail_one.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/spermwhaletail_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/unidentifiedbeakedwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/commondolphin_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/shortfinnedpilotwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/unidentifiedwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/minkewhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/southernrightwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/spermwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/graywhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/seiwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/cuviersbeaked.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/finwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/finwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/finwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/shortfinnedpilotwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/burmeistersporpoise_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/srightwhaledolphin_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/commonporpoise_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/seiwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/jumpback_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/killerwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/unidentifieddolphin_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/killerwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/atlantwhitesided_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/longfinnedpilotwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/pigmyspermwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/northernrightwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/beluga_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/northernrightwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/minkewhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/bowhead.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/southernrightwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/cuviersbeaked_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/spectacledporpoise.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/burmeistersporpoise.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/unidentifiedwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/spectacledporpoise_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/commondolphin_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/rissosdolphin_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/humpbacktail_two.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/rissosdolphin_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/burmeistersporpoise_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/unidentifiedbeakedwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/spermwhaletail_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/srightwhaledolphin.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/longfinnedpilotwhale_high.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/unidentifiedwhale_low.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/biology/images/unidentifiedbeakedwhale.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/misc/images/pirata.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-cleavage_hor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-lineation-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-plane.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-plane_inv.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-foliation-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-foliation_hor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-lineation-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-plane_rake.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-joint.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-foliation-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-foliation_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-cleavage.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-lineation_hor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-plane_medium.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-lineation.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-plane_gentle.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-plane_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-joint_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-lineation_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-cleavage_vert.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-joint_hor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-foliation.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-plane_und.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-plane_hor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-symbols/geology/images/geo-plane_steep.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/source/users-contrib-scripts/images/vertical-slice.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/lato-normal.woff",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/Roboto-Slab-Regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/Roboto-Slab-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/Roboto-Slab-Bold.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/fontawesome-webfont.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/lato-bold-italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/lato-bold.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/lato-bold-italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/lato-normal.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/lato-normal-italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/Roboto-Slab-Bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/fontawesome-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/fontawesome-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/fontawesome-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/lato-bold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/static/css/fonts/lato-normal-italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/nl/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/es/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/pt_BR/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/ru/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/et/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/tr/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/fr/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/de/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/en/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/zh_CN/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/themes/rtd/locale/sv/LC_MESSAGES/sphinx.mo",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/rst/_static/favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex33/ex33.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex27/ex27.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex39/ex39.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex41/ex41.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex44/ex44.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex24/ex24.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex08/ex08.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex10/ex10.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/anim03/anim03.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex43/ex43.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex42/ex42.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex07/ex07.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex15/ex15.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex20/ex20.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex49/ex49.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex26/ex26.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex22/ex22.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex02/ex02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex05/ex05.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex51/ex51.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex28/ex28.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex36/ex36.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/ex31.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/fonts/LinLibertine_Bd-4.1.5.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/fonts/LinBiolinum_Kb-0.5.4.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/fonts/LinLibertine_It-4.2.6.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/fonts/LinLibertine_Re-4.7.5.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/fonts/LinLibertine_C-4.0.4.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/fonts/LinBiolinum_Re-0.6.4.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/fonts/LinBiolinum_It-0.5.1.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/fonts/LinBiolinum_Bd-0.5.5.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/fonts/LinBiolinum_Sl-0.4.9.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex31/fonts/LinLibertine_BI-4.1.0.otf",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex13/ex13.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex38/ex38.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex09/ex09.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex46/ex46.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex18/ex18.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex45/ex45.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex23/ex23.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex34/ex34.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex29/ex29.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex17/ex17.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex04/ex04.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex04/ex04c.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex35/ex35.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/anim02/anim02.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex25/ex25.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/examples/ex40/ex40.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_colorbar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_general_cyl.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_G.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_slopes.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_TM.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_15.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_linear_d.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_11.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_M_1a.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_albers.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_-B_geo_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_13.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_Defaults_1a.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_K_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_K_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_O_9.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_CPTscale.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_RGBchart_tabloid.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_stereographic_polar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_polyconic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_SRTM.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_9.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_equi_cyl.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_RGBchart.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_Defaults_1c.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_-B_geo_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_K_4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_6.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_O_6.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_O_3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_base_symbols1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_obl_merc.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_17.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_mag_rose.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_O_4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_obl_baja.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_K_3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_O_2.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_lambert_az_rect.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_18.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_3.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_vertscale.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_atan.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_cycle_6.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_O_5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_linearrow.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_O_7.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_dir_rose.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_stereographic_rect.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_miller.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_16.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_perspective.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_12.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_earthmask.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_utm_zones.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_mapscale.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_-R.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_title_fade.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_K_5.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_Defaults_1b.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_O_1.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_inset.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_transverse_merc.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_equidistant_conic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_lineoffset.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_seislegend.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_polar.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_gnomonic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_lambert_conic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_obl_nz.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_movie_canvas.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_19.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_gall_stereo.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_cyclic.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_stereographic_general.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_colorlist.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_legend.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_App_O_8.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_cassini.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_tut_4.ps",
        "/tmp/vanessa/spack-stage/spack-stage-gmt-master-vn3j5wzntrftdut7heqprdyuoifcfgjj/spack-src/doc/scripts/GMT_mercator.ps"
    ],
    "total_files": 3989
}