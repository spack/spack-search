{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-r-uuid-0.1-4-7aqdtk5oadqgdbxc5sbavsiejnfegemj/spack-src/configure.ac": "# Process this file with autoconf to produce a configure script.\nAC_INIT(uuid, 0.1, Simon.Urbanek@r-project.org)\nAC_CONFIG_SRCDIR([src/R.c])\nAC_CONFIG_HEADER([src/config.h])\n\n# find R home and set CC/CFLAGS\n: ${R_HOME=`R RHOME`}\nif test -z \"${R_HOME}\"; then\n  echo \"could not determine R_HOME\"\n  exit 1\nfi\nRBIN=\"${R_HOME}/bin/R\"\nCC=`\"${RBIN}\" CMD config CC`;\n## since R 3.6 we can't use CPP but NEWS recommends $CC -E\nCPP=\"${CC} -E\"\nCFLAGS=`\"${RBIN}\" CMD config CFLAGS`\nCPPFLAGS=`\"${RBIN}\" CMD config CPPFLAGS`\nif test -n \"${PKG_CPPFLAGS}\"; then\n   CPPFLAGS=\"${CPPFLAGS} ${PKG_CPPFLAGS}\"\nfi\n\nAC_PROG_CC\n\nLIBS=\"${PKG_LIBS}\"\n\nAC_CHECK_HEADERS([netinet/in.h stdlib.h sys/file.h \\\n sys/ioctl.h sys/socket.h sys/sockio.h sys/syscall.h sys/time.h sys/un.h \\\n unistd.h])\nAC_CHECK_HEADERS([net/if.h net/if_dl.h], [], [], \n[#if HAVE_NETINET_IN_H \n#include <netinet/in.h> \n#endif \n])\n\nAC_CHECK_FUNCS([jrand48])\nAC_CHECK_FUNCS([flock],\n[#if HAVE_SYS_FILE_H\n#include <sys/file.h>\n#endif\n])\nAC_CHECK_MEMBER(struct sockaddr.sa_len,\n                AC_DEFINE_UNQUOTED(HAVE_SA_LEN,1,[Define if struct sockaddr contains sa_len]),,\n        [#include <sys/types.h>\n         #include <sys/socket.h>])\n\nAC_CHECK_HEADERS([dlfcn.h])\nAC_SEARCH_LIBS(dlsym, dl, [AC_DEFINE(HAS_DLSYM, 1, [defined if the system supports dlsym])])\n\n## NOTE: the current util-linux which has taken over libuuid also uses\n## check for HAVE_TLS (thread local storage).\n## However, the AX_CHECK_TLS test in util-linux/m4/tls.m4 is taken from\n## GCC under GPLv2 and we don't want it to infect our license, so we\n## don't check for it. In the current code the only difference when\n## HAVE_TLS is defined is that it adds __thread to static declarations.\n## Given that R uses libuuid only on the main thread this should have\n## no real impact.\n\nAC_CONFIG_FILES([src/Makevars])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-uuid-0.1-4-7aqdtk5oadqgdbxc5sbavsiejnfegemj/spack-src/src/config.h.in": "/* src/config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* defined if the system supports dlsym */\n#undef HAS_DLSYM\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#undef HAVE_DLFCN_H\n\n/* Define to 1 if you have the `flock' function. */\n#undef HAVE_FLOCK\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* Define to 1 if you have the `jrand48' function. */\n#undef HAVE_JRAND48\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n#undef HAVE_NETINET_IN_H\n\n/* Define to 1 if you have the <net/if_dl.h> header file. */\n#undef HAVE_NET_IF_DL_H\n\n/* Define to 1 if you have the <net/if.h> header file. */\n#undef HAVE_NET_IF_H\n\n/* Define if struct sockaddr contains sa_len */\n#undef HAVE_SA_LEN\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#undef HAVE_STDINT_H\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#undef HAVE_STDLIB_H\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#undef HAVE_STRING_H\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#undef HAVE_SYS_FILE_H\n\n/* Define to 1 if you have the <sys/ioctl.h> header file. */\n#undef HAVE_SYS_IOCTL_H\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#undef HAVE_SYS_SOCKET_H\n\n/* Define to 1 if you have the <sys/sockio.h> header file. */\n#undef HAVE_SYS_SOCKIO_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#undef HAVE_SYS_STAT_H\n\n/* Define to 1 if you have the <sys/syscall.h> header file. */\n#undef HAVE_SYS_SYSCALL_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#undef HAVE_SYS_TIME_H\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#undef HAVE_SYS_TYPES_H\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n#undef HAVE_SYS_UN_H\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#undef HAVE_UNISTD_H\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n\n/* Define to 1 if you have the ANSI C header files. */\n#undef STDC_HEADERS\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-uuid-0.1-4-7aqdtk5oadqgdbxc5sbavsiejnfegemj/spack-src/src/rand.c": "/* this provides an isolation between system rand()/srand() and\n   the R package (where possible) to avoid API warnings.\n   It started as a small proof of concept, but got quite a bit\n   out of hand due to Win32 not providing dl* POSIX API ..\n*/\n#include \"config.h\"\n\n#include <R.h>\n\n#ifdef HAVE_DLFCN_H\n/* on Liunx this need to be set, otherwise RTLD_DEFAULT is not defined */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <dlfcn.h>\n/* it *should* be defined in dlfcn.h, but if it's not, we take a guess */\n#ifndef RTLD_DEFAULT\n#define RTLD_DEFAULT ((void *) 0)\n#endif\n#endif\n\n/* there is no dlsym() on Windows, implement it */\n#ifdef _WIN32\n#include <windows.h>\n#define HAS_DLSYM 1\n#define RTLD_DEFAULT NULL\ntypedef void(*fn_t)();\nstatic BOOL (WINAPI *EnumProcessModulesFn)(HANDLE, HMODULE*, DWORD, LPDWORD);\nstatic fn_t dlsym(void *whatever, const char *name) {\n    FARPROC sym;\n    HMODULE hModule = GetModuleHandle(NULL);\n    /* can we resolve it directly? */\n    if ((sym = GetProcAddress(hModule, name)))\n\treturn (fn_t) sym; /* good */\n\n    /* nope, so we have to walk loaded DLLs - annoying, for that we need PSAPI */\n    /* FIXME: if we knew the library with the desired symbols, we could load it directly ...\n       (on Windows 2008 we found all entries in msvcrt.dll - is that reliable?) */\n    if (!EnumProcessModulesFn) { /* load from psapi.dll */\n\tHMODULE psapi = LoadLibraryA(\"psapi.dll\");\n\tif (psapi)\n\t    EnumProcessModulesFn = (BOOL (WINAPI*)(HANDLE, HMODULE*, DWORD, LPDWORD)) GetProcAddress(psapi, \"EnumProcessModules\");\n    }\n    if (!EnumProcessModulesFn)\n\tRf_error(\"Cannot find PSAPI.DLL\");\n    {\n        static HMODULE mods[512]; /* we use a static buffer to avoid dynamic allocations */\n        DWORD n, i;\n\n        if (EnumProcessModulesFn(GetCurrentProcess(), mods, sizeof(mods), &n)) {\n\t    if (n > sizeof(mods))\n\t\tRf_error(\"Too many DLL modules.\");\n\t    n /= sizeof(HMODULE);\n\t    for (i = 0; i < n; i++) {\n#ifdef PRINT_DLL_SEARCH\n\t\tstatic char tb[512];\n\t\t*tb = 0;\n\t\tGetModuleFileNameA(mods[i], tb, sizeof(tb));\n\t\tRprintf(\"> %s\\n\", tb);\n\t\tif ((sym = GetProcAddress(mods[i], name))) {\n\t\t    Rprintf(\"^-- %s found here\\n\", name);\n\t\t    return (fn_t) sym;\n\t\t}\n#else\n\t\tif ((sym = GetProcAddress(mods[i], name)))\n\t\t    return (fn_t) sym;\n#endif\n\t    }\n\t}\n    }\n    return 0;\n}\n#endif\n\n/* if we can, let's get the symbols dynamically */\n#ifdef HAS_DLSYM\ntypedef int(*rand_t)();\ntypedef void(*srand_t)(unsigned);\n#ifdef _WIN32\ntypedef errno_t (*rand_s_t)(unsigned int *);\nstatic rand_s_t fn_rand_s;\n#endif\nstatic rand_t  fn_rand;\nstatic srand_t fn_srand;\n\nstatic void load_rand() {\n    if (!(fn_rand = (rand_t) dlsym(RTLD_DEFAULT, \"rand\")) ||\n#ifdef _WIN32\n\t!(fn_rand_s = (rand_s_t) dlsym(RTLD_DEFAULT, \"rand_s\")) ||\n#endif\n\t!(fn_srand = (srand_t) dlsym(RTLD_DEFAULT, \"srand\")))\n\tRf_error(\"Cannot find entry points for random number generators!\");\n}\n\nint uuid_rand(void) {\n    if (!fn_rand)\n\tload_rand();\n#ifdef _WIN32\n    /* on Windows there is no good source and no jrand, and relying on\n       rand() is terribly bad for repeated calls, so we\n       try to use rand_s() which is reportedly tied to crypto API */\n    if (fn_rand_s) {\n\tunsigned int res;\n\tif (!fn_rand_s(&res))\n\t    return (int) res;\n    }\n#endif\n    return fn_rand();\n}\n\nvoid uuid_srand(unsigned seed) {\n    if (!fn_srand)\n\tload_rand();\n    fn_srand(seed);\n}\n#else\n\n/* no way to find symbols, link them directly and deal with the warnings */\n#include <stdlib.h>\n\nint uuid_rand(void) { return rand(); }\nvoid uuid_srand(unsigned seed) { srand(seed); }\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-uuid-0.1-4-7aqdtk5oadqgdbxc5sbavsiejnfegemj/spack-src/src/win32/config.h": "/* src/config.h.  Generated from config.h.in by configure.  */\n/* src/config.h.in.  Generated from configure.ac by autoheader.  */\n/* -- reflects MinGW + Win32 -- */\n\n/* defined if the system supports dlsym */\n/* #undef HAS_DLSYM */\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n/* #undef HAVE_DLFCN_H */\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#define HAVE_INTTYPES_H 1\n\n/* Define to 1 if you have the `flock' function. */\n#define HAVE_FLOCK 1\n\n/* Define to 1 if you have the `jrand48' function. */\n/* #undef HAVE_JRAND48 */\n\n/* Define to 1 if you have the <memory.h> header file. */\n#define HAVE_MEMORY_H 1\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n/* #undef HAVE_NETINET_IN_H */\n\n/* Define to 1 if you have the <net/if_dl.h> header file. */\n/* #undef HAVE_NET_IF_DL_H */\n\n/* Define to 1 if you have the <net/if.h> header file. */\n/* #undef HAVE_NET_IF_H */\n\n/* Define if struct sockaddr contains sa_len */\n/* #undef HAVE_SA_LEN */\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#define HAVE_STDINT_H 1\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H 1\n\n/* Define to 1 if you have the <strings.h> header file. */\n#define HAVE_STRINGS_H 1\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H 1\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#define HAVE_SYS_FILE_H 1\n\n/* Define to 1 if you have the <sys/ioctl.h> header file. */\n/* #undef HAVE_SYS_IOCTL_H */\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n/* #undef HAVE_SYS_SOCKET_H */\n\n/* Define to 1 if you have the <sys/sockio.h> header file. */\n/* #undef HAVE_SYS_SOCKIO_H */\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#define HAVE_SYS_STAT_H 1\n\n/* Define to 1 if you have the <sys/syscall.h> header file. */\n/* #undef HAVE_SYS_SYSCALL_H */\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#define HAVE_SYS_TIME_H 1\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#define HAVE_SYS_TYPES_H 1\n\n/* Define to 1 if you have the <sys/un.h> header file. */\n/* #undef HAVE_SYS_UN_H */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#define HAVE_UNISTD_H 1\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT \"Simon.Urbanek@r-project.org\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME \"uuid\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING \"uuid 0.1\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME \"uuid\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION \"0.1\"\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS 1\n"
    },
    "skipped": [],
    "total_files": 21
}