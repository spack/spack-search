{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/bin/java_md_common.c": "/*\n * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n#include \"java.h\"\n\n/*\n * If app is \"/foo/bin/javac\", or \"/foo/bin/sparcv9/javac\" then put\n * \"/foo\" into buf.\n */\njboolean\nGetApplicationHome(char *buf, jint bufsize)\n{\n    const char *execname = GetExecName();\n    if (execname != NULL) {\n        JLI_Snprintf(buf, bufsize, \"%s\", execname);\n        buf[bufsize-1] = '\\0';\n    } else {\n        return JNI_FALSE;\n    }\n\n    if (JLI_StrRChr(buf, '/') == 0) {\n        buf[0] = '\\0';\n        return JNI_FALSE;\n    }\n    *(JLI_StrRChr(buf, '/')) = '\\0';    /* executable file      */\n    if (JLI_StrLen(buf) < 4 || JLI_StrRChr(buf, '/') == 0) {\n        buf[0] = '\\0';\n        return JNI_FALSE;\n    }\n    if (JLI_StrCmp(\"/bin\", buf + JLI_StrLen(buf) - 4) != 0)\n        *(JLI_StrRChr(buf, '/')) = '\\0';        /* sparcv9 or amd64     */\n    if (JLI_StrLen(buf) < 4 || JLI_StrCmp(\"/bin\", buf + JLI_StrLen(buf) - 4) != 0) {\n        buf[0] = '\\0';\n        return JNI_FALSE;\n    }\n    *(JLI_StrRChr(buf, '/')) = '\\0';    /* bin                  */\n\n    return JNI_TRUE;\n}\n/*\n * Return true if the named program exists\n */\nstatic int\nProgramExists(char *name)\n{\n    struct stat sb;\n    if (stat(name, &sb) != 0) return 0;\n    if (S_ISDIR(sb.st_mode)) return 0;\n    return (sb.st_mode & S_IEXEC) != 0;\n}\n\n/*\n * Find a command in a directory, returning the path.\n */\nstatic char *\nResolve(char *indir, char *cmd)\n{\n    char name[PATH_MAX + 2], *real;\n\n    if ((JLI_StrLen(indir) + JLI_StrLen(cmd) + 1)  > PATH_MAX) return 0;\n    JLI_Snprintf(name, sizeof(name), \"%s%c%s\", indir, FILE_SEPARATOR, cmd);\n    if (!ProgramExists(name)) return 0;\n    real = JLI_MemAlloc(PATH_MAX + 2);\n    if (!realpath(name, real))\n        JLI_StrCpy(real, name);\n    return real;\n}\n\n/*\n * Find a path for the executable\n */\nchar *\nFindExecName(char *program)\n{\n    char cwdbuf[PATH_MAX+2];\n    char *path;\n    char *tmp_path;\n    char *f;\n    char *result = NULL;\n\n    /* absolute path? */\n    if (*program == FILE_SEPARATOR ||\n        (FILE_SEPARATOR=='\\\\' && JLI_StrRChr(program, ':')))\n        return Resolve(\"\", program+1);\n\n    /* relative path? */\n    if (JLI_StrRChr(program, FILE_SEPARATOR) != 0) {\n        char buf[PATH_MAX+2];\n        return Resolve(getcwd(cwdbuf, sizeof(cwdbuf)), program);\n    }\n\n    /* from search path? */\n    path = getenv(\"PATH\");\n    if (!path || !*path) path = \".\";\n    tmp_path = JLI_MemAlloc(JLI_StrLen(path) + 2);\n    JLI_StrCpy(tmp_path, path);\n\n    for (f=tmp_path; *f && result==0; ) {\n        char *s = f;\n        while (*f && (*f != PATH_SEPARATOR)) ++f;\n        if (*f) *f++ = 0;\n        if (*s == FILE_SEPARATOR)\n            result = Resolve(s, program);\n        else {\n            /* relative path element */\n            char dir[2*PATH_MAX];\n            JLI_Snprintf(dir, sizeof(dir), \"%s%c%s\", getcwd(cwdbuf, sizeof(cwdbuf)),\n                    FILE_SEPARATOR, s);\n            result = Resolve(dir, program);\n        }\n        if (result != 0) break;\n    }\n\n    JLI_MemFree(tmp_path);\n    return result;\n}\n\nvoid JLI_ReportErrorMessage(const char* fmt, ...) {\n    va_list vl;\n    va_start(vl, fmt);\n    vfprintf(stderr, fmt, vl);\n    fprintf(stderr, \"\\n\");\n    va_end(vl);\n}\n\nvoid JLI_ReportErrorMessageSys(const char* fmt, ...) {\n    va_list vl;\n    char *emsg;\n\n    /*\n     * TODO: its safer to use strerror_r but is not available on\n     * Solaris 8. Until then....\n     */\n    emsg = strerror(errno);\n    if (emsg != NULL) {\n        fprintf(stderr, \"%s\\n\", emsg);\n    }\n\n    va_start(vl, fmt);\n    vfprintf(stderr, fmt, vl);\n    fprintf(stderr, \"\\n\");\n    va_end(vl);\n}\n\nvoid  JLI_ReportExceptionDescription(JNIEnv * env) {\n  (*env)->ExceptionDescribe(env);\n}\n\n/*\n *      Since using the file system as a registry is a bit risky, perform\n *      additional sanity checks on the identified directory to validate\n *      it as a valid jre/sdk.\n *\n *      Return 0 if the tests fail; otherwise return non-zero (true).\n *\n *      Note that checking for anything more than the existence of an\n *      executable object at bin/java relative to the path being checked\n *      will break the regression tests.\n */\nstatic int\nCheckSanity(char *path, char *dir)\n{\n    char    buffer[PATH_MAX];\n\n    if (JLI_StrLen(path) + JLI_StrLen(dir) + 11 > PATH_MAX)\n        return (0);     /* Silently reject \"impossibly\" long paths */\n\n    JLI_Snprintf(buffer, sizeof(buffer), \"%s/%s/bin/java\", path, dir);\n    return ((access(buffer, X_OK) == 0) ? 1 : 0);\n}\n\n/*\n *      Determine if there is an acceptable JRE in the directory dirname.\n *      Upon locating the \"best\" one, return a fully qualified path to\n *      it. \"Best\" is defined as the most advanced JRE meeting the\n *      constraints contained in the manifest_info. If no JRE in this\n *      directory meets the constraints, return NULL.\n *\n *      Note that we don't check for errors in reading the directory\n *      (which would be done by checking errno).  This is because it\n *      doesn't matter if we get an error reading the directory, or\n *      we just don't find anything interesting in the directory.  We\n *      just return NULL in either case.\n *\n *      The historical names of j2sdk and j2re were changed to jdk and\n *      jre respecively as part of the 1.5 rebranding effort.  Since the\n *      former names are legacy on Linux, they must be recognized for\n *      all time.  Fortunately, this is a minor cost.\n */\nstatic char\n*ProcessDir(manifest_info *info, char *dirname)\n{\n    DIR     *dirp;\n    struct dirent *dp;\n    char    *best = NULL;\n    int     offset;\n    int     best_offset = 0;\n    char    *ret_str = NULL;\n    char    buffer[PATH_MAX];\n\n    if ((dirp = opendir(dirname)) == NULL)\n        return (NULL);\n\n    do {\n        if ((dp = readdir(dirp)) != NULL) {\n            offset = 0;\n            if ((JLI_StrNCmp(dp->d_name, \"jre\", 3) == 0) ||\n                (JLI_StrNCmp(dp->d_name, \"jdk\", 3) == 0))\n                offset = 3;\n            else if (JLI_StrNCmp(dp->d_name, \"j2re\", 4) == 0)\n                offset = 4;\n            else if (JLI_StrNCmp(dp->d_name, \"j2sdk\", 5) == 0)\n                offset = 5;\n            if (offset > 0) {\n                if ((JLI_AcceptableRelease(dp->d_name + offset,\n                    info->jre_version)) && CheckSanity(dirname, dp->d_name))\n                    if ((best == NULL) || (JLI_ExactVersionId(\n                      dp->d_name + offset, best + best_offset) > 0)) {\n                        if (best != NULL)\n                            JLI_MemFree(best);\n                        best = JLI_StringDup(dp->d_name);\n                        best_offset = offset;\n                    }\n            }\n        }\n    } while (dp != NULL);\n    (void) closedir(dirp);\n    if (best == NULL)\n        return (NULL);\n    else {\n        ret_str = JLI_MemAlloc(JLI_StrLen(dirname) + JLI_StrLen(best) + 2);\n        sprintf(ret_str, \"%s/%s\", dirname, best);\n        JLI_MemFree(best);\n        return (ret_str);\n    }\n}\n\n/*\n *      This is the global entry point. It examines the host for the optimal\n *      JRE to be used by scanning a set of directories.  The set of directories\n *      is platform dependent and can be overridden by the environment\n *      variable JAVA_VERSION_PATH.\n *\n *      This routine itself simply determines the set of appropriate\n *      directories before passing control onto ProcessDir().\n */\nchar*\nLocateJRE(manifest_info* info)\n{\n    char        *path;\n    char        *home;\n    char        *target = NULL;\n    char        *dp;\n    char        *cp;\n\n    /*\n     * Start by getting JAVA_VERSION_PATH\n     */\n    if (info->jre_restrict_search) {\n        path = JLI_StringDup(system_dir);\n    } else if ((path = getenv(\"JAVA_VERSION_PATH\")) != NULL) {\n        path = JLI_StringDup(path);\n    } else {\n        if ((home = getenv(\"HOME\")) != NULL) {\n            path = (char *)JLI_MemAlloc(JLI_StrLen(home) + \\\n                        JLI_StrLen(system_dir) + JLI_StrLen(user_dir) + 2);\n            sprintf(path, \"%s%s:%s\", home, user_dir, system_dir);\n        } else {\n            path = JLI_StringDup(system_dir);\n        }\n    }\n\n    /*\n     * Step through each directory on the path. Terminate the scan with\n     * the first directory with an acceptable JRE.\n     */\n    cp = dp = path;\n    while (dp != NULL) {\n        cp = JLI_StrChr(dp, (int)':');\n        if (cp != NULL)\n            *cp = '\\0';\n        if ((target = ProcessDir(info, dp)) != NULL)\n            break;\n        dp = cp;\n        if (dp != NULL)\n            dp++;\n    }\n    JLI_MemFree(path);\n    return (target);\n}\n\n/*\n * Given a path to a jre to execute, this routine checks if this process\n * is indeed that jre.  If not, it exec's that jre.\n *\n * We want to actually check the paths rather than just the version string\n * built into the executable, so that given version specification (and\n * JAVA_VERSION_PATH) will yield the exact same Java environment, regardless\n * of the version of the arbitrary launcher we start with.\n */\nvoid\nExecJRE(char *jre, char **argv)\n{\n    char    wanted[PATH_MAX];\n    const char* progname = GetProgramName();\n    const char* execname = NULL;\n\n    /*\n     * Resolve the real path to the directory containing the selected JRE.\n     */\n    if (realpath(jre, wanted) == NULL) {\n        JLI_ReportErrorMessage(JRE_ERROR9, jre);\n        exit(1);\n    }\n\n    /*\n     * Resolve the real path to the currently running launcher.\n     */\n    SetExecname(argv);\n    execname = GetExecName();\n    if (execname == NULL) {\n        JLI_ReportErrorMessage(JRE_ERROR10);\n        exit(1);\n    }\n\n    /*\n     * If the path to the selected JRE directory is a match to the initial\n     * portion of the path to the currently executing JRE, we have a winner!\n     * If so, just return.\n     */\n    if (JLI_StrNCmp(wanted, execname, JLI_StrLen(wanted)) == 0)\n        return;                 /* I am the droid you were looking for */\n\n\n    /*\n     * This should never happen (because of the selection code in SelectJRE),\n     * but check for \"impossibly\" long path names just because buffer overruns\n     * can be so deadly.\n     */\n    if (JLI_StrLen(wanted) + JLI_StrLen(progname) + 6 > PATH_MAX) {\n        JLI_ReportErrorMessage(JRE_ERROR11);\n        exit(1);\n    }\n\n    /*\n     * Construct the path and exec it.\n     */\n    (void)JLI_StrCat(JLI_StrCat(wanted, \"/bin/\"), progname);\n    argv[0] = JLI_StringDup(progname);\n    if (JLI_IsTraceLauncher()) {\n        int i;\n        printf(\"ReExec Command: %s (%s)\\n\", wanted, argv[0]);\n        printf(\"ReExec Args:\");\n        for (i = 1; argv[i] != NULL; i++)\n            printf(\" %s\", argv[i]);\n        printf(\"\\n\");\n    }\n    JLI_TraceLauncher(\"TRACER_MARKER:About to EXEC\\n\");\n    (void)fflush(stdout);\n    (void)fflush(stderr);\n    execv(wanted, argv);\n    JLI_ReportErrorMessageSys(JRE_ERROR12, wanted);\n    exit(1);\n}\n\n/*\n * \"Borrowed\" from Solaris 10 where the unsetenv() function is being added\n * to libc thanks to SUSv3 (Standard Unix Specification, version 3). As\n * such, in the fullness of time this will appear in libc on all relevant\n * Solaris/Linux platforms and maybe even the Windows platform.  At that\n * time, this stub can be removed.\n *\n * This implementation removes the environment locking for multithreaded\n * applications.  (We don't have access to these mutexes within libc and\n * the launcher isn't multithreaded.)  Note that what remains is platform\n * independent, because it only relies on attributes that a POSIX environment\n * defines.\n *\n * Returns 0 on success, -1 on failure.\n *\n * Also removed was the setting of errno.  The only value of errno set\n * was EINVAL (\"Invalid Argument\").\n */\n\n/*\n * s1(environ) is name=value\n * s2(name) is name(not the form of name=value).\n * if names match, return value of 1, else return 0\n */\nstatic int\nmatch_noeq(const char *s1, const char *s2)\n{\n        while (*s1 == *s2++) {\n                if (*s1++ == '=')\n                        return (1);\n        }\n        if (*s1 == '=' && s2[-1] == '\\0')\n                return (1);\n        return (0);\n}\n\n/*\n * added for SUSv3 standard\n *\n * Delete entry from environ.\n * Do not free() memory!  Other threads may be using it.\n * Keep it around forever.\n */\nstatic int\nborrowed_unsetenv(const char *name)\n{\n        long    idx;            /* index into environ */\n\n        if (name == NULL || *name == '\\0' ||\n            JLI_StrChr(name, '=') != NULL) {\n                return (-1);\n        }\n\n        for (idx = 0; environ[idx] != NULL; idx++) {\n                if (match_noeq(environ[idx], name))\n                        break;\n        }\n        if (environ[idx] == NULL) {\n                /* name not found but still a success */\n                return (0);\n        }\n        /* squeeze up one entry */\n        do {\n                environ[idx] = environ[idx+1];\n        } while (environ[++idx] != NULL);\n\n        return (0);\n}\n/* --- End of \"borrowed\" code --- */\n\n/*\n * Wrapper for unsetenv() function.\n */\nint\nUnsetEnv(char *name)\n{\n    return(borrowed_unsetenv(name));\n}\n\nconst char *\njlong_format_specifier() {\n    return \"%lld\";\n}\n\njboolean\nIsJavaw()\n{\n    /* noop on UNIX */\n    return JNI_FALSE;\n}\n\nvoid\nInitLauncher(jboolean javaw)\n{\n    JLI_SetTraceLauncher();\n}\n\n/*\n * The implementation for finding classes from the bootstrap\n * class loader, refer to java.h\n */\nstatic FindClassFromBootLoader_t *findBootClass = NULL;\n\njclass\nFindBootStrapClass(JNIEnv *env, const char* classname)\n{\n   if (findBootClass == NULL) {\n       findBootClass = (FindClassFromBootLoader_t *)dlsym(RTLD_DEFAULT,\n          \"JVM_FindClassFromBootLoader\");\n       if (findBootClass == NULL) {\n           JLI_ReportErrorMessage(DLL_ERROR4,\n               \"JVM_FindClassFromBootLoader\");\n           return NULL;\n       }\n   }\n   return findBootClass(env, classname);\n}\n\nStdArg\n*JLI_GetStdArgs()\n{\n    return NULL;\n}\n\nint\nJLI_GetStdArgc() {\n    return 0;\n}\n\njobjectArray\nCreateApplicationArgs(JNIEnv *env, char **strv, int argc)\n{\n    return NewPlatformStringArray(env, strv, argc);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/bin/java_md_solinux.c": "/*\n * Copyright (c) 1998, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"java.h\"\n#include \"jvm_md.h\"\n#include <dirent.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include \"manifest_info.h\"\n#include \"version_comp.h\"\n\n\n#define JVM_DLL \"libjvm.so\"\n#define JAVA_DLL \"libjava.so\"\n#ifdef AIX\n#define LD_LIBRARY_PATH \"LIBPATH\"\n#else\n#define LD_LIBRARY_PATH \"LD_LIBRARY_PATH\"\n#endif\n\n/* help jettison the LD_LIBRARY_PATH settings in the future */\n#ifndef SETENV_REQUIRED\n#define SETENV_REQUIRED\n#endif\n/*\n * If a processor / os combination has the ability to run binaries of\n * two data models and cohabitation of jre/jdk bits with both data\n * models is supported, then DUAL_MODE is defined.  When DUAL_MODE is\n * defined, the architecture names for the narrow and wide version of\n * the architecture are defined in LIBARCH64NAME and LIBARCH32NAME.\n * Currently  only Solaris on sparc/sparcv9 and i586/amd64 is DUAL_MODE;\n * linux i586/amd64 could be defined as DUAL_MODE but that is not the\n * current policy.\n */\n\n#ifdef __solaris__\n#  ifndef LIBARCH32NAME\n#    error \"The macro LIBARCH32NAME was not defined on the compile line\"\n#  endif\n#  ifndef LIBARCH64NAME\n#    error \"The macro LIBARCH64NAME was not defined on the compile line\"\n#  endif\n#  include <sys/systeminfo.h>\n#  include <sys/elf.h>\n#  include <stdio.h>\n#endif\n\n/*\n * Flowchart of launcher execs and options processing on unix\n *\n * The selection of the proper vm shared library to open depends on\n * several classes of command line options, including vm \"flavor\"\n * options (-client, -server) and the data model options, -d32  and\n * -d64, as well as a version specification which may have come from\n * the command line or from the manifest of an executable jar file.\n * The vm selection options are not passed to the running\n * virtual machine; they must be screened out by the launcher.\n *\n * The version specification (if any) is processed first by the\n * platform independent routine SelectVersion.  This may result in\n * the exec of the specified launcher version.\n *\n * Previously the launcher modified the LD_LIBRARY_PATH appropriately for the\n * desired data model path, regardless if data models matched or not. The\n * launcher subsequently exec'ed the desired executable, in order to make the\n * LD_LIBRARY_PATH path available, for the runtime linker.\n *\n * Now, in most cases,the launcher will dlopen the target libjvm.so. All\n * required libraries are loaded by the runtime linker, using the\n * $RPATH/$ORIGIN baked into the shared libraries at compile time. Therefore,\n * in most cases, the launcher will only exec, if the data models are\n * mismatched, and will not set any environment variables, regardless of the\n * data models.\n *\n * However, if the environment contains a LD_LIBRARY_PATH, this will cause the\n * launcher to inspect the LD_LIBRARY_PATH. The launcher will check\n *  a. if the LD_LIBRARY_PATH's first component is the the path to the desired\n *     libjvm.so\n *  b. if any other libjvm.so is found in any of the paths.\n * If case b is true, then the launcher will set the LD_LIBRARY_PATH to the\n * desired JRE and reexec, in order to propagate the environment.\n *\n *  Main\n *  (incoming argv)\n *  |\n * \\|/\n * SelectVersion\n * (selects the JRE version, note: not data model)\n *  |\n * \\|/\n * CreateExecutionEnvironment\n * (determines desired data model)\n *  |\n *  |\n * \\|/\n *  Have Desired Model ? --> NO --> Is Dual-Mode ? --> NO --> Exit(with error)\n *  |                                          |\n *  |                                          |\n *  |                                         \\|/\n *  |                                         YES\n *  |                                          |\n *  |                                          |\n *  |                                         \\|/\n *  |                                CheckJvmType\n *  |                               (removes -client, -server etc.)\n *  |                                          |\n *  |                                          |\n * \\|/                                        \\|/\n * YES                             Find the desired executable/library\n *  |                                          |\n *  |                                          |\n * \\|/                                        \\|/\n * CheckJvmType                          RequiresSetenv\n * (removes -client, -server, etc.)\n *  |\n *  |\n * \\|/\n * TranslateDashJArgs...\n * (Prepare to pass args to vm)\n *  |\n *  |\n * \\|/\n * ParseArguments\n * (removes -d32 and -d64 if any,\n *  processes version options,\n *  creates argument list for vm,\n *  etc.)\n *   |\n *   |\n *  \\|/\n * RequiresSetenv\n * Is LD_LIBRARY_PATH\n * and friends set ? --> NO --> Have Desired Model ? NO --> Re-exec --> Main\n *  YES                              YES --> Continue\n *   |\n *   |\n *  \\|/\n * Path is desired JRE ? YES --> Have Desired Model ? NO --> Re-exec --> Main\n *  NO                               YES --> Continue\n *   |\n *   |\n *  \\|/\n * Paths have well known\n * jvm paths ?       --> NO --> Have Desired Model ? NO --> Re-exec --> Main\n *  YES                              YES --> Continue\n *   |\n *   |\n *  \\|/\n *  Does libjvm.so exit\n *  in any of them ? --> NO --> Have Desired Model ? NO --> Re-exec --> Main\n *   YES                             YES --> Continue\n *   |\n *   |\n *  \\|/\n *  Set the LD_LIBRARY_PATH\n *   |\n *   |\n *  \\|/\n * Re-exec\n *   |\n *   |\n *  \\|/\n * Main\n */\n\n#define GetArch() GetArchPath(CURRENT_DATA_MODEL)\n\n/* Store the name of the executable once computed */\nstatic char *execname = NULL;\n\n/*\n * execname accessor from other parts of platform dependent logic\n */\nconst char *\nGetExecName() {\n    return execname;\n}\n\nconst char *\nGetArchPath(int nbits)\n{\n    switch(nbits) {\n#ifdef DUAL_MODE\n        case 32:\n            return LIBARCH32NAME;\n        case 64:\n            return LIBARCH64NAME;\n#endif /* DUAL_MODE */\n        default:\n            return LIBARCHNAME;\n    }\n}\n\n#ifdef SETENV_REQUIRED\nstatic jboolean\nJvmExists(const char *path) {\n    char tmp[PATH_MAX + 1];\n    struct stat statbuf;\n    JLI_Snprintf(tmp, PATH_MAX, \"%s/%s\", path, JVM_DLL);\n    if (stat(tmp, &statbuf) == 0) {\n        return JNI_TRUE;\n    }\n    return JNI_FALSE;\n}\n/*\n * contains a lib/$LIBARCH/{server,client}/libjvm.so ?\n */\nstatic jboolean\nContainsLibJVM(int wanted, const char *env) {\n    char clientPattern[PATH_MAX + 1];\n    char serverPattern[PATH_MAX + 1];\n    char *envpath;\n    char *path;\n    jboolean clientPatternFound;\n    jboolean serverPatternFound;\n\n    /* fastest path */\n    if (env == NULL) {\n        return JNI_FALSE;\n    }\n\n    /* the usual suspects */\n    JLI_Snprintf(clientPattern, PATH_MAX, \"lib/%s/client\", GetArchPath(wanted));\n    JLI_Snprintf(serverPattern, PATH_MAX, \"lib/%s/server\", GetArchPath(wanted));\n\n    /* to optimize for time, test if any of our usual suspects are present. */\n    clientPatternFound = JLI_StrStr(env, clientPattern) != NULL;\n    serverPatternFound = JLI_StrStr(env, serverPattern) != NULL;\n    if (clientPatternFound == JNI_FALSE && serverPatternFound == JNI_FALSE) {\n        return JNI_FALSE;\n    }\n\n    /*\n     * we have a suspicious path component, check if it contains a libjvm.so\n     */\n    envpath = JLI_StringDup(env);\n    for (path = JLI_StrTok(envpath, \":\"); path != NULL; path = JLI_StrTok(NULL, \":\")) {\n        if (clientPatternFound && JLI_StrStr(path, clientPattern) != NULL) {\n            if (JvmExists(path)) {\n                JLI_MemFree(envpath);\n                return JNI_TRUE;\n            }\n        }\n        if (serverPatternFound && JLI_StrStr(path, serverPattern)  != NULL) {\n            if (JvmExists(path)) {\n                JLI_MemFree(envpath);\n                return JNI_TRUE;\n            }\n        }\n    }\n    JLI_MemFree(envpath);\n    return JNI_FALSE;\n}\n\n/*\n * Test whether the environment variable needs to be set, see flowchart.\n */\nstatic jboolean\nRequiresSetenv(int wanted, const char *jvmpath) {\n    char jpath[PATH_MAX + 1];\n    char *llp;\n    char *dmllp = NULL;\n    char *p; /* a utility pointer */\n\n#ifdef AIX\n    /* We always have to set the LIBPATH on AIX because ld doesn't support $ORIGIN. */\n    return JNI_TRUE;\n#endif\n\n    llp = getenv(\"LD_LIBRARY_PATH\");\n#ifdef __solaris__\n    dmllp = (CURRENT_DATA_MODEL == 32)\n            ? getenv(\"LD_LIBRARY_PATH_32\")\n            : getenv(\"LD_LIBRARY_PATH_64\");\n#endif /* __solaris__ */\n    /* no environment variable is a good environment variable */\n    if (llp == NULL && dmllp == NULL) {\n        return JNI_FALSE;\n    }\n#ifdef __linux\n    /*\n     * On linux, if a binary is running as sgid or suid, glibc sets\n     * LD_LIBRARY_PATH to the empty string for security purposes. (In contrast,\n     * on Solaris the LD_LIBRARY_PATH variable for a privileged binary does not\n     * lose its settings; but the dynamic linker does apply more scrutiny to the\n     * path.) The launcher uses the value of LD_LIBRARY_PATH to prevent an exec\n     * loop, here and further downstream. Therefore, if we are running sgid or\n     * suid, this function's setting of LD_LIBRARY_PATH will be ineffective and\n     * we should case a return from the calling function.  Getting the right\n     * libraries will be handled by the RPATH. In reality, this check is\n     * redundant, as the previous check for a non-null LD_LIBRARY_PATH will\n     * return back to the calling function forthwith, it is left here to safe\n     * guard against any changes, in the glibc's existing security policy.\n     */\n    if ((getgid() != getegid()) || (getuid() != geteuid())) {\n        return JNI_FALSE;\n    }\n#endif /* __linux */\n\n    /*\n     * Prevent recursions. Since LD_LIBRARY_PATH is the one which will be set by\n     * previous versions of the JRE, thus it is the only path that matters here.\n     * So we check to see if the desired JRE is set.\n     */\n    JLI_StrNCpy(jpath, jvmpath, PATH_MAX);\n    p = JLI_StrRChr(jpath, '/');\n    *p = '\\0';\n    if (llp != NULL && JLI_StrNCmp(llp, jpath, JLI_StrLen(jpath)) == 0) {\n        return JNI_FALSE;\n    }\n\n    /* scrutinize all the paths further */\n    if (llp != NULL &&  ContainsLibJVM(wanted, llp)) {\n        return JNI_TRUE;\n    }\n    if (dmllp != NULL && ContainsLibJVM(wanted, dmllp)) {\n        return JNI_TRUE;\n    }\n    return JNI_FALSE;\n}\n#endif /* SETENV_REQUIRED */\n\nvoid\nCreateExecutionEnvironment(int *pargc, char ***pargv,\n                           char jrepath[], jint so_jrepath,\n                           char jvmpath[], jint so_jvmpath,\n                           char jvmcfg[],  jint so_jvmcfg) {\n  /*\n   * First, determine if we are running the desired data model.  If we\n   * are running the desired data model, all the error messages\n   * associated with calling GetJREPath, ReadKnownVMs, etc. should be\n   * output.  However, if we are not running the desired data model,\n   * some of the errors should be suppressed since it is more\n   * informative to issue an error message based on whether or not the\n   * os/processor combination has dual mode capabilities.\n   */\n    jboolean jvmpathExists;\n\n    /* Compute/set the name of the executable */\n    SetExecname(*pargv);\n\n    /* Check data model flags, and exec process, if needed */\n    {\n      char *arch        = (char *)GetArch(); /* like sparc or sparcv9 */\n      char * jvmtype    = NULL;\n      int  argc         = *pargc;\n      char **argv       = *pargv;\n      int running       = CURRENT_DATA_MODEL;\n\n      int wanted        = running;      /* What data mode is being\n                                           asked for? Current model is\n                                           fine unless another model\n                                           is asked for */\n#ifdef SETENV_REQUIRED\n      jboolean mustsetenv = JNI_FALSE;\n      char *runpath     = NULL; /* existing effective LD_LIBRARY_PATH setting */\n      char* new_runpath = NULL; /* desired new LD_LIBRARY_PATH string */\n      char* newpath     = NULL; /* path on new LD_LIBRARY_PATH */\n      char* lastslash   = NULL;\n      char** newenvp    = NULL; /* current environment */\n#ifdef __solaris__\n      char*  dmpath     = NULL;  /* data model specific LD_LIBRARY_PATH,\n                                    Solaris only */\n#endif /* __solaris__ */\n#endif  /* SETENV_REQUIRED */\n\n      char** newargv    = NULL;\n      int    newargc    = 0;\n\n      /*\n       * Starting in 1.5, all unix platforms accept the -d32 and -d64\n       * options.  On platforms where only one data-model is supported\n       * (e.g. ia-64 Linux), using the flag for the other data model is\n       * an error and will terminate the program.\n       */\n\n      { /* open new scope to declare local variables */\n        int i;\n\n        newargv = (char **)JLI_MemAlloc((argc+1) * sizeof(char*));\n        newargv[newargc++] = argv[0];\n\n        /* scan for data model arguments and remove from argument list;\n           last occurrence determines desired data model */\n        for (i=1; i < argc; i++) {\n\n          if (JLI_StrCmp(argv[i], \"-J-d64\") == 0 || JLI_StrCmp(argv[i], \"-d64\") == 0) {\n            wanted = 64;\n            continue;\n          }\n          if (JLI_StrCmp(argv[i], \"-J-d32\") == 0 || JLI_StrCmp(argv[i], \"-d32\") == 0) {\n            wanted = 32;\n            continue;\n          }\n          newargv[newargc++] = argv[i];\n\n          if (IsJavaArgs()) {\n            if (argv[i][0] != '-') continue;\n          } else {\n            if (JLI_StrCmp(argv[i], \"-classpath\") == 0 || JLI_StrCmp(argv[i], \"-cp\") == 0) {\n              i++;\n              if (i >= argc) break;\n              newargv[newargc++] = argv[i];\n              continue;\n            }\n            if (argv[i][0] != '-') { i++; break; }\n          }\n        }\n\n        /* copy rest of args [i .. argc) */\n        while (i < argc) {\n          newargv[newargc++] = argv[i++];\n        }\n        newargv[newargc] = NULL;\n\n        /*\n         * newargv has all proper arguments here\n         */\n\n        argc = newargc;\n        argv = newargv;\n      }\n\n      /* If the data model is not changing, it is an error if the\n         jvmpath does not exist */\n      if (wanted == running) {\n        /* Find out where the JRE is that we will be using. */\n        if (!GetJREPath(jrepath, so_jrepath, arch, JNI_FALSE) ) {\n          JLI_ReportErrorMessage(JRE_ERROR1);\n          exit(2);\n        }\n        JLI_Snprintf(jvmcfg, so_jvmcfg, \"%s%slib%s%s%sjvm.cfg\",\n                     jrepath, FILESEP, FILESEP,  arch, FILESEP);\n        /* Find the specified JVM type */\n        if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {\n          JLI_ReportErrorMessage(CFG_ERROR7);\n          exit(1);\n        }\n\n        jvmpath[0] = '\\0';\n        jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);\n        if (JLI_StrCmp(jvmtype, \"ERROR\") == 0) {\n            JLI_ReportErrorMessage(CFG_ERROR9);\n            exit(4);\n        }\n\n        if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath, arch, 0 )) {\n          JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);\n          exit(4);\n        }\n        /*\n         * we seem to have everything we need, so without further ado\n         * we return back, otherwise proceed to set the environment.\n         */\n#ifdef SETENV_REQUIRED\n        mustsetenv = RequiresSetenv(wanted, jvmpath);\n        JLI_TraceLauncher(\"mustsetenv: %s\\n\", mustsetenv ? \"TRUE\" : \"FALSE\");\n\n        if (mustsetenv == JNI_FALSE) {\n            JLI_MemFree(newargv);\n            return;\n        }\n#else\n        JLI_MemFree(newargv);\n        return;\n#endif /* SETENV_REQUIRED */\n      } else {  /* do the same speculatively or exit */\n#ifdef DUAL_MODE\n        if (running != wanted) {\n          /* Find out where the JRE is that we will be using. */\n          if (!GetJREPath(jrepath, so_jrepath, GetArchPath(wanted), JNI_TRUE)) {\n            /* give up and let other code report error message */\n            JLI_ReportErrorMessage(JRE_ERROR2, wanted);\n            exit(1);\n          }\n          JLI_Snprintf(jvmcfg, so_jvmcfg, \"%s%slib%s%s%sjvm.cfg\",\n                       jrepath, FILESEP, FILESEP, GetArchPath(wanted), FILESEP);\n          /*\n           * Read in jvm.cfg for target data model and process vm\n           * selection options.\n           */\n          if (ReadKnownVMs(jvmcfg, JNI_TRUE) < 1) {\n            /* give up and let other code report error message */\n            JLI_ReportErrorMessage(JRE_ERROR2, wanted);\n            exit(1);\n          }\n          jvmpath[0] = '\\0';\n          jvmtype = CheckJvmType(pargc, pargv, JNI_TRUE);\n          if (JLI_StrCmp(jvmtype, \"ERROR\") == 0) {\n            JLI_ReportErrorMessage(CFG_ERROR9);\n            exit(4);\n          }\n\n          /* exec child can do error checking on the existence of the path */\n          jvmpathExists = GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath, GetArchPath(wanted), 0);\n#ifdef SETENV_REQUIRED\n          mustsetenv = RequiresSetenv(wanted, jvmpath);\n#endif /* SETENV_REQUIRED */\n        }\n#else /* ! DUALMODE */\n        JLI_ReportErrorMessage(JRE_ERROR2, wanted);\n        exit(1);\n#endif /* DUAL_MODE */\n        }\n#ifdef SETENV_REQUIRED\n        if (mustsetenv) {\n            /*\n             * We will set the LD_LIBRARY_PATH as follows:\n             *\n             *     o          $JVMPATH (directory portion only)\n             *     o          $JRE/lib/$LIBARCHNAME\n             *     o          $JRE/../lib/$LIBARCHNAME\n             *\n             * followed by the user's previous effective LD_LIBRARY_PATH, if\n             * any.\n             */\n\n#ifdef __solaris__\n            /*\n             * Starting in Solaris 7, ld.so.1 supports three LD_LIBRARY_PATH\n             * variables:\n             *\n             * 1. LD_LIBRARY_PATH -- used for 32 and 64 bit searches if\n             * data-model specific variables are not set.\n             *\n             * 2. LD_LIBRARY_PATH_64 -- overrides and replaces LD_LIBRARY_PATH\n             * for 64-bit binaries.\n             *\n             * 3. LD_LIBRARY_PATH_32 -- overrides and replaces LD_LIBRARY_PATH\n             * for 32-bit binaries.\n             *\n             * The vm uses LD_LIBRARY_PATH to set the java.library.path system\n             * property.  To shield the vm from the complication of multiple\n             * LD_LIBRARY_PATH variables, if the appropriate data model\n             * specific variable is set, we will act as if LD_LIBRARY_PATH had\n             * the value of the data model specific variant and the data model\n             * specific variant will be unset.  Note that the variable for the\n             * *wanted* data model must be used (if it is set), not simply the\n             * current running data model.\n             */\n\n            switch (wanted) {\n                case 0:\n                    if (running == 32) {\n                        dmpath = getenv(\"LD_LIBRARY_PATH_32\");\n                        wanted = 32;\n                    } else {\n                        dmpath = getenv(\"LD_LIBRARY_PATH_64\");\n                        wanted = 64;\n                    }\n                    break;\n\n                case 32:\n                    dmpath = getenv(\"LD_LIBRARY_PATH_32\");\n                    break;\n\n                case 64:\n                    dmpath = getenv(\"LD_LIBRARY_PATH_64\");\n                    break;\n\n                default:\n                    JLI_ReportErrorMessage(JRE_ERROR3, __LINE__);\n                    exit(1); /* unknown value in wanted */\n                    break;\n            }\n\n            /*\n             * If dmpath is NULL, the relevant data model specific variable is\n             * not set and normal LD_LIBRARY_PATH should be used.\n             */\n            if (dmpath == NULL) {\n                runpath = getenv(\"LD_LIBRARY_PATH\");\n            } else {\n                runpath = dmpath;\n            }\n#else /* ! __solaris__ */\n            /*\n             * If not on Solaris, assume only a single LD_LIBRARY_PATH\n             * variable.\n             */\n            runpath = getenv(LD_LIBRARY_PATH);\n#endif /* __solaris__ */\n\n            /* runpath contains current effective LD_LIBRARY_PATH setting */\n\n            jvmpath = JLI_StringDup(jvmpath);\n            size_t new_runpath_size = ((runpath != NULL) ? JLI_StrLen(runpath) : 0) +\n                    2 * JLI_StrLen(jrepath) + 2 * JLI_StrLen(arch) +\n#ifdef AIX\n                    /* On AIX we additionally need 'jli' in the path because ld doesn't support $ORIGIN. */\n                    JLI_StrLen(jrepath) + JLI_StrLen(arch) + JLI_StrLen(\"/lib//jli:\") +\n#endif\n                    JLI_StrLen(jvmpath) + 52;\n            new_runpath = JLI_MemAlloc(new_runpath_size);\n            newpath = new_runpath + JLI_StrLen(LD_LIBRARY_PATH \"=\");\n\n\n            /*\n             * Create desired LD_LIBRARY_PATH value for target data model.\n             */\n            {\n                /* remove the name of the .so from the JVM path */\n                lastslash = JLI_StrRChr(jvmpath, '/');\n                if (lastslash)\n                    *lastslash = '\\0';\n\n                sprintf(new_runpath, LD_LIBRARY_PATH \"=\"\n                        \"%s:\"\n                        \"%s/lib/%s:\"\n#ifdef AIX\n                        \"%s/lib/%s/jli:\" /* Needed on AIX because ld doesn't support $ORIGIN. */\n#endif\n                        \"%s/../lib/%s\",\n                        jvmpath,\n#ifdef DUAL_MODE\n                        jrepath, GetArchPath(wanted),\n                        jrepath, GetArchPath(wanted)\n#else /* !DUAL_MODE */\n                        jrepath, arch,\n#ifdef AIX\n                        jrepath, arch,\n#endif\n                        jrepath, arch\n#endif /* DUAL_MODE */\n                        );\n\n\n                /*\n                 * Check to make sure that the prefix of the current path is the\n                 * desired environment variable setting, though the RequiresSetenv\n                 * checks if the desired runpath exists, this logic does a more\n                 * comprehensive check.\n                 */\n                if (runpath != NULL &&\n                        JLI_StrNCmp(newpath, runpath, JLI_StrLen(newpath)) == 0 &&\n                        (runpath[JLI_StrLen(newpath)] == 0 || runpath[JLI_StrLen(newpath)] == ':') &&\n                        (running == wanted) /* data model does not have to be changed */\n#ifdef __solaris__\n                        && (dmpath == NULL) /* data model specific variables not set  */\n#endif /* __solaris__ */\n                        ) {\n                    JLI_MemFree(newargv);\n                    JLI_MemFree(new_runpath);\n                    return;\n                }\n            }\n\n            /*\n             * Place the desired environment setting onto the prefix of\n             * LD_LIBRARY_PATH.  Note that this prevents any possible infinite\n             * loop of execv() because we test for the prefix, above.\n             */\n            if (runpath != 0) {\n                /* ensure storage for runpath + colon + NULL */\n                if ((JLI_StrLen(runpath) + 1 + 1) > new_runpath_size) {\n                    JLI_ReportErrorMessageSys(JRE_ERROR11);\n                    exit(1);\n                }\n                JLI_StrCat(new_runpath, \":\");\n                JLI_StrCat(new_runpath, runpath);\n            }\n\n            if (putenv(new_runpath) != 0) {\n                exit(1); /* problem allocating memory; LD_LIBRARY_PATH not set\n                    properly */\n            }\n\n            /*\n             * Unix systems document that they look at LD_LIBRARY_PATH only\n             * once at startup, so we have to re-exec the current executable\n             * to get the changed environment variable to have an effect.\n             */\n\n#ifdef __solaris__\n            /*\n             * If dmpath is not NULL, remove the data model specific string\n             * in the environment for the exec'ed child.\n             */\n            if (dmpath != NULL)\n                (void)UnsetEnv((wanted == 32) ? \"LD_LIBRARY_PATH_32\" : \"LD_LIBRARY_PATH_64\");\n#endif /* __solaris */\n\n            newenvp = environ;\n        }\n#endif /* SETENV_REQUIRED */\n        {\n            char *newexec = execname;\n#ifdef DUAL_MODE\n            /*\n             * If the data model is being changed, the path to the\n             * executable must be updated accordingly; the executable name\n             * and directory the executable resides in are separate.  In the\n             * case of 32 => 64, the new bits are assumed to reside in, e.g.\n             * \"olddir/LIBARCH64NAME/execname\"; in the case of 64 => 32,\n             * the bits are assumed to be in \"olddir/../execname\".  For example,\n             *\n             * olddir/sparcv9/execname\n             * olddir/amd64/execname\n             *\n             * for Solaris SPARC and Linux amd64, respectively.\n             */\n\n            if (running != wanted) {\n                char *oldexec = JLI_StrCpy(JLI_MemAlloc(JLI_StrLen(execname) + 1), execname);\n                char *olddir = oldexec;\n                char *oldbase = JLI_StrRChr(oldexec, '/');\n\n\n                newexec = JLI_MemAlloc(JLI_StrLen(execname) + 20);\n                *oldbase++ = 0;\n                sprintf(newexec, \"%s/%s/%s\", olddir,\n                        ((wanted == 64) ? LIBARCH64NAME : \"..\"), oldbase);\n                argv[0] = newexec;\n            }\n#endif /* DUAL_MODE */\n            JLI_TraceLauncher(\"TRACER_MARKER:About to EXEC\\n\");\n            (void) fflush(stdout);\n            (void) fflush(stderr);\n#ifdef SETENV_REQUIRED\n            if (mustsetenv) {\n                execve(newexec, argv, newenvp);\n            } else {\n                execv(newexec, argv);\n            }\n#else /* !SETENV_REQUIRED */\n            execv(newexec, argv);\n#endif /* SETENV_REQUIRED */\n            JLI_ReportErrorMessageSys(JRE_ERROR4, newexec);\n\n#ifdef DUAL_MODE\n            if (running != wanted) {\n                JLI_ReportErrorMessage(JRE_ERROR5, wanted, running);\n#ifdef __solaris__\n#ifdef __sparc\n                JLI_ReportErrorMessage(JRE_ERROR6);\n#else  /* ! __sparc__ */\n                JLI_ReportErrorMessage(JRE_ERROR7);\n#endif  /* __sparc */\n#endif /* __solaris__ */\n            }\n#endif /* DUAL_MODE */\n\n        }\n        exit(1);\n    }\n}\n\n/*\n * On Solaris VM choosing is done by the launcher (java.c),\n * bitsWanted is used by MacOSX,  on Solaris and Linux this.\n * parameter is unused.\n */\nstatic jboolean\nGetJVMPath(const char *jrepath, const char *jvmtype,\n           char *jvmpath, jint jvmpathsize, const char * arch, int bitsWanted)\n{\n    struct stat s;\n\n    if (JLI_StrChr(jvmtype, '/')) {\n        JLI_Snprintf(jvmpath, jvmpathsize, \"%s/\" JVM_DLL, jvmtype);\n    } else {\n        JLI_Snprintf(jvmpath, jvmpathsize, \"%s/lib/%s/%s/\" JVM_DLL, jrepath, arch, jvmtype);\n    }\n\n    JLI_TraceLauncher(\"Does `%s' exist ... \", jvmpath);\n\n    if (stat(jvmpath, &s) == 0) {\n        JLI_TraceLauncher(\"yes.\\n\");\n        return JNI_TRUE;\n    } else {\n        JLI_TraceLauncher(\"no.\\n\");\n        return JNI_FALSE;\n    }\n}\n\n/*\n * Find path to JRE based on .exe's location or registry settings.\n */\nstatic jboolean\nGetJREPath(char *path, jint pathsize, const char * arch, jboolean speculative)\n{\n    char libjava[MAXPATHLEN];\n\n    if (GetApplicationHome(path, pathsize)) {\n        /* Is JRE co-located with the application? */\n        JLI_Snprintf(libjava, sizeof(libjava), \"%s/lib/%s/\" JAVA_DLL, path, arch);\n        if (access(libjava, F_OK) == 0) {\n            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n            return JNI_TRUE;\n        }\n        /* ensure storage for path + /jre + NULL */\n        if ((JLI_StrLen(path) + 4  + 1) > pathsize) {\n            JLI_TraceLauncher(\"Insufficient space to store JRE path\\n\");\n            return JNI_FALSE;\n        }\n        /* Does the app ship a private JRE in <apphome>/jre directory? */\n        JLI_Snprintf(libjava, sizeof(libjava), \"%s/jre/lib/%s/\" JAVA_DLL, path, arch);\n        if (access(libjava, F_OK) == 0) {\n            JLI_StrCat(path, \"/jre\");\n            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n            return JNI_TRUE;\n        }\n    }\n\n    if (!speculative)\n      JLI_ReportErrorMessage(JRE_ERROR8 JAVA_DLL);\n    return JNI_FALSE;\n}\n\njboolean\nLoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)\n{\n    void *libjvm;\n\n    JLI_TraceLauncher(\"JVM path is %s\\n\", jvmpath);\n\n    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n    if (libjvm == NULL) {\n#if defined(__solaris__) && defined(__sparc) && !defined(_LP64) /* i.e. 32-bit sparc */\n      FILE * fp;\n      Elf32_Ehdr elf_head;\n      int count;\n      int location;\n\n      fp = fopen(jvmpath, \"r\");\n      if (fp == NULL) {\n        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n        return JNI_FALSE;\n      }\n\n      /* read in elf header */\n      count = fread((void*)(&elf_head), sizeof(Elf32_Ehdr), 1, fp);\n      fclose(fp);\n      if (count < 1) {\n        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n        return JNI_FALSE;\n      }\n\n      /*\n       * Check for running a server vm (compiled with -xarch=v8plus)\n       * on a stock v8 processor.  In this case, the machine type in\n       * the elf header would not be included the architecture list\n       * provided by the isalist command, which is turn is gotten from\n       * sysinfo.  This case cannot occur on 64-bit hardware and thus\n       * does not have to be checked for in binaries with an LP64 data\n       * model.\n       */\n      if (elf_head.e_machine == EM_SPARC32PLUS) {\n        char buf[257];  /* recommended buffer size from sysinfo man\n                           page */\n        long length;\n        char* location;\n\n        length = sysinfo(SI_ISALIST, buf, 257);\n        if (length > 0) {\n            location = JLI_StrStr(buf, \"sparcv8plus \");\n          if (location == NULL) {\n            JLI_ReportErrorMessage(JVM_ERROR3);\n            return JNI_FALSE;\n          }\n        }\n      }\n#endif\n        JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);\n        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n        return JNI_FALSE;\n    }\n\n    ifn->CreateJavaVM = (CreateJavaVM_t)\n        dlsym(libjvm, \"JNI_CreateJavaVM\");\n    if (ifn->CreateJavaVM == NULL) {\n        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n        return JNI_FALSE;\n    }\n\n    ifn->GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t)\n        dlsym(libjvm, \"JNI_GetDefaultJavaVMInitArgs\");\n    if (ifn->GetDefaultJavaVMInitArgs == NULL) {\n        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n        return JNI_FALSE;\n    }\n\n    ifn->GetCreatedJavaVMs = (GetCreatedJavaVMs_t)\n        dlsym(libjvm, \"JNI_GetCreatedJavaVMs\");\n    if (ifn->GetCreatedJavaVMs == NULL) {\n        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n        return JNI_FALSE;\n    }\n\n    return JNI_TRUE;\n}\n\n/*\n * Compute the name of the executable\n *\n * In order to re-exec securely we need the absolute path of the\n * executable. On Solaris getexecname(3c) may not return an absolute\n * path so we use dladdr to get the filename of the executable and\n * then use realpath to derive an absolute path. From Solaris 9\n * onwards the filename returned in DL_info structure from dladdr is\n * an absolute pathname so technically realpath isn't required.\n * On Linux we read the executable name from /proc/self/exe.\n * As a fallback, and for platforms other than Solaris and Linux,\n * we use FindExecName to compute the executable name.\n */\nconst char*\nSetExecname(char **argv)\n{\n    char* exec_path = NULL;\n#if defined(__solaris__)\n    {\n        Dl_info dlinfo;\n        int (*fptr)();\n\n        fptr = (int (*)())dlsym(RTLD_DEFAULT, \"main\");\n        if (fptr == NULL) {\n            JLI_ReportErrorMessage(DLL_ERROR3, dlerror());\n            return JNI_FALSE;\n        }\n\n        if (dladdr((void*)fptr, &dlinfo)) {\n            char *resolved = (char*)JLI_MemAlloc(PATH_MAX+1);\n            if (resolved != NULL) {\n                exec_path = realpath(dlinfo.dli_fname, resolved);\n                if (exec_path == NULL) {\n                    JLI_MemFree(resolved);\n                }\n            }\n        }\n    }\n#elif defined(__linux__)\n    {\n        const char* self = \"/proc/self/exe\";\n        char buf[PATH_MAX+1];\n        int len = readlink(self, buf, PATH_MAX);\n        if (len >= 0) {\n            buf[len] = '\\0';            /* readlink(2) doesn't NUL terminate */\n            exec_path = JLI_StringDup(buf);\n        }\n    }\n#else /* !__solaris__ && !__linux__ */\n    {\n        /* Not implemented */\n    }\n#endif\n\n    if (exec_path == NULL) {\n        exec_path = FindExecName(argv[0]);\n    }\n    execname = exec_path;\n    return exec_path;\n}\n\n/* --- Splash Screen shared library support --- */\nstatic const char* SPLASHSCREEN_SO = JNI_LIB_NAME(\"splashscreen\");\nstatic void* hSplashLib = NULL;\n\nvoid* SplashProcAddress(const char* name) {\n    if (!hSplashLib) {\n        int ret;\n        char jrePath[MAXPATHLEN];\n        char splashPath[MAXPATHLEN];\n\n        if (!GetJREPath(jrePath, sizeof(jrePath), GetArch(), JNI_FALSE)) {\n            JLI_ReportErrorMessage(JRE_ERROR1);\n            return NULL;\n        }\n        ret = JLI_Snprintf(splashPath, sizeof(splashPath), \"%s/lib/%s/%s\",\n                     jrePath, GetArch(), SPLASHSCREEN_SO);\n\n        if (ret >= (int) sizeof(splashPath)) {\n            JLI_ReportErrorMessage(JRE_ERROR11);\n            return NULL;\n        }\n        if (ret < 0) {\n            JLI_ReportErrorMessage(JRE_ERROR13);\n            return NULL;\n        }\n        hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);\n        JLI_TraceLauncher(\"Info: loaded %s\\n\", splashPath);\n    }\n    if (hSplashLib) {\n        void* sym = dlsym(hSplashLib, name);\n        return sym;\n    } else {\n        return NULL;\n    }\n}\n\nvoid SplashFreeLibrary() {\n    if (hSplashLib) {\n        dlclose(hSplashLib);\n        hSplashLib = NULL;\n    }\n}\n\n/*\n * Block current thread and continue execution in a new thread\n */\nint\nContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {\n    int rslt;\n#ifndef __solaris__\n    pthread_t tid;\n    pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    if (stack_size > 0) {\n      pthread_attr_setstacksize(&attr, stack_size);\n    }\n\n    if (pthread_create(&tid, &attr, (void *(*)(void*))continuation, (void*)args) == 0) {\n      void * tmp;\n      pthread_join(tid, &tmp);\n      rslt = (int)tmp;\n    } else {\n     /*\n      * Continue execution in current thread if for some reason (e.g. out of\n      * memory/LWP)  a new thread can't be created. This will likely fail\n      * later in continuation as JNI_CreateJavaVM needs to create quite a\n      * few new threads, anyway, just give it a try..\n      */\n      rslt = continuation(args);\n    }\n\n    pthread_attr_destroy(&attr);\n#else /* __solaris__ */\n    thread_t tid;\n    long flags = 0;\n    if (thr_create(NULL, stack_size, (void *(*)(void *))continuation, args, flags, &tid) == 0) {\n      void * tmp;\n      thr_join(tid, NULL, &tmp);\n      rslt = (int)tmp;\n    } else {\n      /* See above. Continue in current thread if thr_create() failed */\n      rslt = continuation(args);\n    }\n#endif /* !__solaris__ */\n    return rslt;\n}\n\n/* Coarse estimation of number of digits assuming the worst case is a 64-bit pid. */\n#define MAX_PID_STR_SZ   20\n\nvoid SetJavaLauncherPlatformProps() {\n   /* Linux only */\n#ifdef __linux__\n    const char *substr = \"-Dsun.java.launcher.pid=\";\n    char *pid_prop_str = (char *)JLI_MemAlloc(JLI_StrLen(substr) + MAX_PID_STR_SZ + 1);\n    sprintf(pid_prop_str, \"%s%d\", substr, getpid());\n    AddOption(pid_prop_str, NULL);\n#endif /* __linux__ */\n}\n\nint\nJVMInit(InvocationFunctions* ifn, jlong threadStackSize,\n        int argc, char **argv,\n        int mode, char *what, int ret)\n{\n    ShowSplashScreen();\n    return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);\n}\n\nvoid\nPostJVMInit(JNIEnv *env, jstring mainClass, JavaVM *vm)\n{\n    // stubbed out for windows and *nixes.\n}\n\nvoid\nRegisterThread()\n{\n    // stubbed out for windows and *nixes.\n}\n\n/*\n * on unix, we return a false to indicate this option is not applicable\n */\njboolean\nProcessPlatformOption(const char *arg)\n{\n    return JNI_FALSE;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/jdga/dgalock.c": "/*\n * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#if sparc\n\n/* #define DGA_DEBUG */\n\n#ifdef DGA_DEBUG\n#define DEBUG_PRINT(x)  printf x\n#else\n#define DEBUG_PRINT(x)\n#endif\n\n#include <dga/dga.h>\n#include <unistd.h>     /* ioctl */\n#include <stdlib.h>\n#include <sys/mman.h>   /* mmap */\n#include <sys/visual_io.h>\n#include <string.h>\n\n/* X11 */\n#include <X11/Xlib.h>\n\n#include \"jni.h\"\n#include \"jvm_md.h\"\n#include \"jdga.h\"\n#include \"jdgadevice.h\"\n\n#include <dlfcn.h>\n\n#define min(x, y)       ((x) < (y) ? (x) : (y))\n#define max(x, y)       ((x) > (y) ? (x) : (y))\n\ntypedef struct _SolarisDgaLibInfo SolarisDgaLibInfo;\n\nstruct _SolarisDgaLibInfo {\n    /* The general (non-device specific) information */\n    unsigned long       count;\n    Drawable            drawable;\n    Drawable            virtual_drawable;\n\n    /* The device specific memory mapping information */\n    SolarisJDgaDevInfo  *devInfo;\n    SolarisJDgaWinInfo  winInfo;\n};\n\ntypedef Bool IsXineramaOnFunc(Display *display);\ntypedef Drawable GetVirtualDrawableFunc(Display *display, Drawable drawable);\n\n#define MAX_CACHED_INFO 16\nstatic SolarisDgaLibInfo cachedInfo[MAX_CACHED_INFO];\nstatic jboolean needsSync = JNI_FALSE;\n\n#define MAX_FB_TYPES 16\nstatic SolarisJDgaDevInfo devicesInfo[MAX_FB_TYPES];\n\nstatic IsXineramaOnFunc *IsXineramaOn = NULL;\nstatic GetVirtualDrawableFunc GetVirtualDrawableStub;\n\nDrawable GetVirtualDrawableStub(Display *display, Drawable drawable) {\n    return drawable;\n}\nstatic GetVirtualDrawableFunc * GetVirtualDrawable = GetVirtualDrawableStub;\n\nstatic void Solaris_DGA_XineramaInit(Display *display) {\n    void * handle = NULL;\n    if (IsXineramaOn == NULL) {\n        handle = dlopen(JNI_LIB_NAME(\"xinerama\"), RTLD_NOW);\n        if (handle != NULL) {\n            void *sym = dlsym(handle, \"IsXineramaOn\");\n            IsXineramaOn = (IsXineramaOnFunc *)sym;\n            if (IsXineramaOn != 0 && (*IsXineramaOn)(display)) {\n                sym = dlsym(handle, \"GetVirtualDrawable\");\n                if (sym != 0) {\n                    GetVirtualDrawable = (GetVirtualDrawableFunc *)sym;\n                }\n            } else {\n                dlclose(handle);\n            }\n        }\n    }\n}\n\nstatic SolarisJDgaDevInfo * getDevInfo(Dga_drawable dgadraw) {\n    void *handle = 0;\n    struct vis_identifier visid;\n    int fd;\n    char libName[64];\n    int i;\n    SolarisJDgaDevInfo *curDevInfo = devicesInfo;\n\n    fd = dga_draw_devfd(dgadraw);\n    if (ioctl(fd, VIS_GETIDENTIFIER, &visid) != 1) {\n        /* check in the devices list */\n        for (i = 0; (i < MAX_FB_TYPES) && (curDevInfo->visidName);\n             i++, curDevInfo++) {\n            if (strcmp(visid.name, curDevInfo->visidName) == 0) {\n                /* we already have such a device, return it */\n                return curDevInfo;\n            }\n        }\n        if (i == MAX_FB_TYPES) {\n            /* we're out of slots, return NULL */\n            return NULL;\n        }\n\n        strcpy(libName, \"libjdga\");\n        strcat(libName, visid.name);\n        strcat(libName,\".so\");\n        /* we use RTLD_NOW because of bug 4032715 */\n        handle = dlopen(libName, RTLD_NOW);\n        if (handle != 0) {\n            JDgaStatus ret = JDGA_FAILED;\n            void *sym = dlsym(handle, \"SolarisJDgaDevOpen\");\n            if (sym != 0) {\n                curDevInfo->majorVersion = JDGALIB_MAJOR_VERSION;\n                curDevInfo->minorVersion = JDGALIB_MINOR_VERSION;\n                ret = (*(SolarisJDgaDevOpenFunc *)sym)(curDevInfo);\n            }\n            if (ret == JDGA_SUCCESS) {\n                curDevInfo->visidName = strdup(visid.name);\n                return curDevInfo;\n            }\n            dlclose(handle);\n        }\n    }\n    return NULL;\n}\nstatic int\nmmap_dgaDev(SolarisDgaLibInfo *libInfo, Dga_drawable dgadraw)\n{\n\n    if (!libInfo->devInfo) {\n        libInfo->devInfo = getDevInfo(dgadraw);\n        if (!libInfo->devInfo) {\n            return JDGA_FAILED;\n        }\n    }\n    return (*libInfo->devInfo->function->winopen)(&(libInfo->winInfo));\n}\n\nstatic void\nunmap_dgaDev(SolarisDgaLibInfo *pDevInfo)\n{\n    DEBUG_PRINT((\"winclose() called\\n\"));\n   (*pDevInfo->devInfo->function->winclose)(&(pDevInfo->winInfo));\n}\n\nstatic jboolean\nSolaris_DGA_Available(Display *display)\n{\n    Window root;\n    int screen;\n    Dga_drawable dgaDrawable;\n    SolarisJDgaDevInfo * devinfo;\n\n    /* return true if any screen supports DGA and we\n     have a library for this type of framebuffer */\n    for (screen = 0; screen < XScreenCount(display); screen++) {\n        root = RootWindow(display, screen);\n\n        dgaDrawable = XDgaGrabDrawable(display, root);\n        if (dgaDrawable != 0) {\n            devinfo = getDevInfo(dgaDrawable);\n            XDgaUnGrabDrawable(dgaDrawable);\n            if (devinfo != NULL) {\n                return JNI_TRUE;\n            }\n        }\n    }\n    return JNI_FALSE;\n}\n\nstatic JDgaLibInitFunc          Solaris_DGA_LibInit;\nstatic JDgaGetLockFunc          Solaris_DGA_GetLock;\nstatic JDgaReleaseLockFunc      Solaris_DGA_ReleaseLock;\nstatic JDgaXRequestSentFunc     Solaris_DGA_XRequestSent;\nstatic JDgaLibDisposeFunc       Solaris_DGA_LibDispose;\nstatic int firstInitDone = 0;\n\n#pragma weak JDgaLibInit = Solaris_DGA_LibInit\n\nstatic JDgaStatus\nSolaris_DGA_LibInit(JNIEnv *env, JDgaLibInfo *ppInfo)\n{\n    /* Note: DGA_INIT can be called multiple times according to docs */\n    DEBUG_PRINT((\"DGA_INIT called\\n\"));\n    DGA_INIT();\n\n    if (!Solaris_DGA_Available(ppInfo->display)) {\n        return JDGA_FAILED;\n    }\n    Solaris_DGA_XineramaInit(ppInfo->display);\n\n    ppInfo->pGetLock = Solaris_DGA_GetLock;\n    ppInfo->pReleaseLock = Solaris_DGA_ReleaseLock;\n    ppInfo->pXRequestSent = Solaris_DGA_XRequestSent;\n    ppInfo->pLibDispose = Solaris_DGA_LibDispose;\n\n    return JDGA_SUCCESS;\n}\n\nstatic JDgaStatus\nSolaris_DGA_GetLock(JNIEnv *env, Display *display, void **dgaDev,\n                        Drawable drawable, JDgaSurfaceInfo *pSurface,\n                        jint lox, jint loy, jint hix, jint hiy)\n{\n    SolarisDgaLibInfo *pDevInfo;\n    SolarisDgaLibInfo *pCachedInfo = cachedInfo;\n    int vis;\n    int dlox, dloy, dhix, dhiy;\n    int i;\n    int type, site;\n    unsigned long k;\n    Drawable prev_virtual_drawable = 0;\n    Dga_drawable dgaDrawable;\n\n    if (*dgaDev) {\n        if (((SolarisDgaLibInfo *)(*dgaDev))->drawable != drawable) {\n            *dgaDev = 0;\n        }\n    }\n\n    if (*dgaDev == 0) {\n        pCachedInfo = cachedInfo;\n        for (i = 0 ; (i < MAX_CACHED_INFO) && (pCachedInfo->drawable) ;\n             i++, pCachedInfo++) {\n            if (pCachedInfo->drawable == drawable) {\n                *dgaDev = pCachedInfo;\n                break;\n            }\n        }\n        if (*dgaDev == 0) {\n            if (i < MAX_CACHED_INFO) { /* slot can be used for new info */\n                 *dgaDev = pCachedInfo;\n            } else {\n                pCachedInfo = cachedInfo;\n                /* find the least used slot but does not handle an overflow of\n                   the counter */\n                for (i = 0, k = 0xffffffff; i < MAX_CACHED_INFO ;\n                     i++, pCachedInfo++) {\n                    if (k > pCachedInfo->count) {\n                        k = pCachedInfo->count;\n                        *dgaDev = pCachedInfo;\n                    }\n                    pCachedInfo->count = 0; /* reset all counters */\n                }\n                pCachedInfo = *dgaDev;\n                if (pCachedInfo->winInfo.dgaDraw != 0) {\n                    XDgaUnGrabDrawable(pCachedInfo->winInfo.dgaDraw);\n                }\n                pCachedInfo->winInfo.dgaDraw = 0;\n                /* the slot might be used for another device */\n                pCachedInfo->devInfo = 0;\n            }\n        }\n    }\n\n    pDevInfo = *dgaDev;\n    pDevInfo->drawable = drawable;\n\n    prev_virtual_drawable = pDevInfo->virtual_drawable;\n    pDevInfo->virtual_drawable = GetVirtualDrawable(display, drawable);\n    if (pDevInfo->virtual_drawable == NULL) {\n        /* this usually means that the drawable is spanned across\n           screens in xinerama mode - we can't handle this for now */\n        return JDGA_FAILED;\n    } else {\n        /* check if the drawable has been moved to another screen\n           since last time */\n        if (pDevInfo->winInfo.dgaDraw != 0 &&\n            pDevInfo->virtual_drawable != prev_virtual_drawable) {\n            XDgaUnGrabDrawable(pDevInfo->winInfo.dgaDraw);\n            pDevInfo->winInfo.dgaDraw = 0;\n        }\n    }\n\n    pDevInfo->count++;\n\n    if (pDevInfo->winInfo.dgaDraw == 0) {\n        pDevInfo->winInfo.dgaDraw = XDgaGrabDrawable(display, pDevInfo->virtual_drawable);\n        if (pDevInfo->winInfo.dgaDraw == 0) {\n            DEBUG_PRINT((\"DgaGrabDrawable failed for 0x%08x\\n\", drawable));\n            return JDGA_UNAVAILABLE;\n        }\n        type = dga_draw_type(pDevInfo->winInfo.dgaDraw);\n        if (type != DGA_DRAW_PIXMAP &&\n            mmap_dgaDev(pDevInfo, pDevInfo->winInfo.dgaDraw) != JDGA_SUCCESS) {\n            DEBUG_PRINT((\"memory map failed for 0x%08x (depth = %d)\\n\",\n                         drawable, dga_draw_depth(pDevInfo->winInfo.dgaDraw)));\n            XDgaUnGrabDrawable(pDevInfo->winInfo.dgaDraw);\n            pDevInfo->winInfo.dgaDraw = 0;\n            return JDGA_UNAVAILABLE;\n        }\n    } else {\n        type = dga_draw_type(pDevInfo->winInfo.dgaDraw);\n    }\n\n    if (needsSync) {\n        XSync(display, False);\n        needsSync = JNI_FALSE;\n    }\n\n    dgaDrawable = pDevInfo->winInfo.dgaDraw;\n\n    DGA_DRAW_LOCK(dgaDrawable, -1);\n\n    site = dga_draw_site(dgaDrawable);\n    if (type == DGA_DRAW_PIXMAP) {\n        if (site == DGA_SITE_SYSTEM) {\n            pDevInfo->winInfo.mapDepth = dga_draw_depth(dgaDrawable);\n            pDevInfo->winInfo.mapAddr = dga_draw_address(dgaDrawable);\n            dga_draw_bbox(dgaDrawable, &dlox, &dloy, &dhix, &dhiy);\n            pDevInfo->winInfo.mapWidth = dhix;\n            pDevInfo->winInfo.mapHeight = dhiy;\n            if (pDevInfo->winInfo.mapDepth == 8) {\n                pDevInfo->winInfo.mapLineStride = dga_draw_linebytes(dgaDrawable);\n                pDevInfo->winInfo.mapPixelStride = 1;\n            } else {\n                pDevInfo->winInfo.mapLineStride = dga_draw_linebytes(dgaDrawable)/4;\n                pDevInfo->winInfo.mapPixelStride = 4;\n            }\n        } else {\n            XDgaUnGrabDrawable(dgaDrawable);\n            pDevInfo->winInfo.dgaDraw = 0;\n            return JDGA_UNAVAILABLE;\n        }\n    } else {\n        if (site == DGA_SITE_NULL) {\n            DEBUG_PRINT((\"zombie drawable = 0x%08x\\n\", dgaDrawable));\n            DGA_DRAW_UNLOCK(dgaDrawable);\n            unmap_dgaDev(pDevInfo);\n            XDgaUnGrabDrawable(dgaDrawable);\n            pDevInfo->winInfo.dgaDraw = 0;\n            return JDGA_UNAVAILABLE;\n        }\n        dga_draw_bbox(dgaDrawable, &dlox, &dloy, &dhix, &dhiy);\n    }\n\n    /* get the screen address of the drawable */\n    dhix += dlox;\n    dhiy += dloy;\n    DEBUG_PRINT((\"window at (%d, %d) => (%d, %d)\\n\", dlox, dloy, dhix, dhiy));\n    pSurface->window.lox = dlox;\n    pSurface->window.loy = dloy;\n    pSurface->window.hix = dhix;\n    pSurface->window.hiy = dhiy;\n\n            /* translate rendering coordinates relative to device bbox */\n    lox += dlox;\n    loy += dloy;\n    hix += dlox;\n    hiy += dloy;\n    DEBUG_PRINT((\"render at (%d, %d) => (%d, %d)\\n\", lox, loy, hix, hiy));\n\n    vis = dga_draw_visibility(dgaDrawable);\n    switch (vis) {\n    case DGA_VIS_UNOBSCURED:\n        pSurface->visible.lox = max(dlox, lox);\n        pSurface->visible.loy = max(dloy, loy);\n        pSurface->visible.hix = min(dhix, hix);\n        pSurface->visible.hiy = min(dhiy, hiy);\n        DEBUG_PRINT((\"unobscured vis at (%d, %d) => (%d, %d)\\n\",\n                     pSurface->visible.lox,\n                     pSurface->visible.loy,\n                     pSurface->visible.hix,\n                     pSurface->visible.hiy));\n        break;\n    case DGA_VIS_PARTIALLY_OBSCURED: {\n        /*\n         * fix for #4305271\n         * the dga_draw_clipinfo call returns the clipping bounds\n         * in short ints, but use only full size ints for all comparisons.\n         */\n        short *ptr;\n        int x0, y0, x1, y1;\n        int cliplox, cliploy, cliphix, cliphiy;\n\n        /*\n         * iterate to find out whether the clipped blit draws to a\n         * single clipping rectangle\n         */\n        cliplox = cliphix = lox;\n        cliploy = cliphiy = loy;\n        ptr = dga_draw_clipinfo(dgaDrawable);\n        while (*ptr != DGA_Y_EOL) {\n            y0 = *ptr++;\n            y1 = *ptr++;\n            DEBUG_PRINT((\"DGA y range loy=%d hiy=%d\\n\", y0, y1));\n            if (y0 < loy) {\n                y0 = loy;\n            }\n            if (y1 > hiy) {\n                y1 = hiy;\n            }\n            while (*ptr != DGA_X_EOL) {\n                x0 = *ptr++;\n                x1 = *ptr++;\n                DEBUG_PRINT((\"  DGA x range lox=%d hix=%d\\n\", x0, x1));\n                if (x0 < lox) {\n                    x0 = lox;\n                }\n                if (x1 > hix) {\n                    x1 = hix;\n                }\n                if (x0 < x1 && y0 < y1) {\n                    if (cliploy == cliphiy) {\n                                /* First rectangle intersection */\n                        cliplox = x0;\n                        cliploy = y0;\n                        cliphix = x1;\n                        cliphiy = y1;\n                    } else {\n                                /* Can we merge this rect with previous? */\n                        if (cliplox == x0 && cliphix == x1 &&\n                            cliploy <= y1 && cliphiy >= y0)\n                            {\n                                /* X ranges match, Y ranges touch */\n                                /* => absorb the Y ranges together */\n                                cliploy = min(cliploy, y0);\n                                cliphiy = max(cliphiy, y1);\n                            } else if (cliploy == y0 && cliphiy == y1 &&\n                                       cliplox <= x1 && cliphix >= x0)\n                                {\n                                    /* Y ranges match, X ranges touch */\n                                    /* => Absorb the X ranges together */\n                                    cliplox = min(cliplox, x0);\n                                    cliphix = max(cliphix, x1);\n                                } else {\n                                    /* Assertion: any other combination */\n                                    /* means non-rectangular intersect */\n                                    DGA_DRAW_UNLOCK(dgaDrawable);\n                                    return JDGA_FAILED;\n                                }\n                    }\n                }\n            }\n            ptr++; /* advance past DGA_X_EOL */\n        }\n        DEBUG_PRINT((\"DGA drawable fits\\n\"));\n        pSurface->visible.lox = cliplox;\n        pSurface->visible.loy = cliploy;\n        pSurface->visible.hix = cliphix;\n        pSurface->visible.hiy = cliphiy;\n        break;\n    }\n    case DGA_VIS_FULLY_OBSCURED:\n        pSurface->visible.lox =\n            pSurface->visible.hix = lox;\n        pSurface->visible.loy =\n            pSurface->visible.hiy = loy;\n        DEBUG_PRINT((\"fully obscured vis\\n\"));\n        break;\n    default:\n        DEBUG_PRINT((\"unknown visibility = %d!\\n\", vis));\n        DGA_DRAW_UNLOCK(dgaDrawable);\n        return JDGA_FAILED;\n    }\n\n    pSurface->basePtr = pDevInfo->winInfo.mapAddr;\n    pSurface->surfaceScan = pDevInfo->winInfo.mapLineStride;\n    pSurface->surfaceWidth = pDevInfo->winInfo.mapWidth;\n    pSurface->surfaceHeight = pDevInfo->winInfo.mapHeight;\n    pSurface->surfaceDepth = pDevInfo->winInfo.mapDepth;\n\n    return JDGA_SUCCESS;\n}\n\nstatic JDgaStatus\nSolaris_DGA_ReleaseLock(JNIEnv *env, void *dgaDev, Drawable drawable)\n{\n    SolarisDgaLibInfo *pDevInfo = (SolarisDgaLibInfo *) dgaDev;\n\n    if (pDevInfo != 0 && pDevInfo->drawable == drawable &&\n        pDevInfo->winInfo.dgaDraw != 0) {\n        DGA_DRAW_UNLOCK(pDevInfo->winInfo.dgaDraw);\n    }\n    return JDGA_SUCCESS;\n}\n\nstatic void\nSolaris_DGA_XRequestSent(JNIEnv *env, void *dgaDev, Drawable drawable)\n{\n    needsSync = JNI_TRUE;\n}\n\nstatic void\nSolaris_DGA_LibDispose(JNIEnv *env)\n{\n    SolarisDgaLibInfo *pCachedInfo = cachedInfo;\n    SolarisJDgaDevInfo *curDevInfo = devicesInfo;\n    int i;\n\n    for (i = 0 ; (i < MAX_CACHED_INFO) && (pCachedInfo->drawable) ;\n         i++, pCachedInfo++) {\n        if (pCachedInfo->winInfo.dgaDraw != 0) {\n            if (dga_draw_type(pCachedInfo->winInfo.dgaDraw) == DGA_DRAW_WINDOW &&\n                pCachedInfo->winInfo.mapDepth != 0) {\n                unmap_dgaDev(pCachedInfo);\n            }\n            XDgaUnGrabDrawable(pCachedInfo->winInfo.dgaDraw);\n            pCachedInfo->winInfo.dgaDraw = 0;\n        }\n    }\n    for (i = 0; (i < MAX_FB_TYPES) && (curDevInfo->visidName);\n         i++, curDevInfo++) {\n        curDevInfo->function->devclose(curDevInfo);\n        free(curDevInfo->visidName);\n    }\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/jdga/jdgadevice.h": "/*\n * Copyright (c) 1998, 2000, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#ifndef _JDGADEVICE_H_\n#define _JDGADEVICE_H_\n\n/*\n *   Interface for Supporting DGA to Framebuffers under Java\n *   -------------------------------------------------------\n *\n *  This interface will allow third party (and Sun) framebuffers which\n *  support the Direct Graphics Access (DGA) interface to be accessed with\n *  DGA in Java applications.\n *\n *  It coexists with the existing device-independent interfaces provided in\n *  libsunwjdga.so.\n *\n *  Framebuffers desiring access to Java DGA must supply a dynamically\n *  loaded library named \"libjdga<fbname>.so\", where <fbname> is the name\n *  returned by the VIS_GETIDENTIFIER ioctl as defined in the Solaris\n *  VISUAL environment (visual_io(7i)). For example, the Java DGA library\n *  for Sun's cg6 framebuffer will be named libjdgaSUNWcg6.so.\n *\n *  Because multiple instances of a framebuffer type may exist on a system,\n *  the device-dependent library must avoid the use of static or global\n *  variables for any framebuffer-related variables. In other words it\n *  must be reentrant.\n *\n *  The device-independent function Solaris_JDga_LibInit() is called in the\n *  static initializer for X11Graphics.java. Solaris_JDga_LibInit() will be\n *  modified to seek out a device-dependent DGA library as follows.\n *\n *  - DGA grab the DefaultRootWindow to get a Dga_drawable.\n *\n *  - Use the Dga_drawable ID to get the device file descriptor\n *       fd = dga_win_devfd(dga_draw_id)\n *\n *  - Use the VIS_GETIDENTIFIER ioctl to get the device name string.\n *\n *  - Construct the library path name using the device name string.\n *    The device-dependent library must be located in a location specified\n *    in the LD_LIBRARY_PATH.\n *\n *  - The device-dependent library will be dlopen'ed and then a dlsym will\n *    be performed for the function \"SolarisJDgaDevOpen\", which must\n *    be implemented by the device-dependent library writer.\n *\n *  - The function SolarisJDgaDevOpen() will then be called with a\n *    pointer to a SolarisJDgaDevInfo structure. This structure will\n *    have its major and minor version numbers filled in with their\n *    current values by the device-independent calling code. The\n *    device-dependent library must examine these version numbers and\n *    act as follows:\n *\n *      - In all cases, the device-dependent code should reset the\n *        supplied major and minor version numbers to those of the\n *        device-dependent library.\n *\n *      - If the supplied major version number is not the same as that\n *        of the device library, the open must fail and return JDGA_FAILED.\n *\n *      - If the supplied minor version number is less than or equal to\n *        the device minor version number, then backward compatibility\n *        is assumed and the open should return JDGA_SUCCESS.\n *\n *      - If the supplied minor version number is greater than the\n *        device minor version number, the open should also return\n *        JDGA_SUCCESS. The returned device minor version number will\n *        indicate to the device-independent code what features are\n *        supported in the device library.\n *\n *  - The function SolarisJDgaDevOpen() must also return a structure\n *    containing function pointers as given in the SolarisJDgaDevFunc\n *    structure below. The winlock and winunlock functions are\n *    required only if there is some device-specific locking to be done\n *    in addition to the DGA lock. If this is not required for the device\n *    these function pointers may be specified as NULL pointers.\n *\n */\n\n#include <dga/dga.h>\n#include <unistd.h>     /* ioctl */\n#include <stdlib.h>\n#include <sys/mman.h>   /* mmap */\n#include <sys/visual_io.h>\n#include <X11/Xlib.h>\n\n/*\n * Status return codes\n */\n#ifndef _DEFINE_JDGASTATUS_\n#define _DEFINE_JDGASTATUS_\ntypedef enum {\n    JDGA_SUCCESS        = 0,    /* operation succeeded */\n    JDGA_FAILED         = 1     /* unable to complete operation */\n} JDgaStatus;\n#endif\n\n/*\n * Structure to be filled in by device-dependent library's\n * SolarisJDgaDevOpen() function\n */\ntypedef struct {\n  char *                         visidName; /* device name from ioctl */\n  int                         majorVersion;\n  int                         minorVersion;\n  struct _SolarisJDgaDevFuncList* function;    /* Device function pointers */\n} SolarisJDgaDevInfo;\n\n/*\n * Structure returned by device-dependent library for a window\n */\ntypedef struct {\n  SolarisJDgaDevInfo* devInfo;        /* Supplied by caller */\n  Dga_drawable        dgaDraw;        /* Supplied by caller */\n  caddr_t             mapAddr;        /* FB mapping for this window */\n  int                 mapDepth;       /* Depth in bits */\n  int                 mapWidth;       /* Width in pixels */\n  int                 mapHeight;      /* Height in lines */\n  int                 mapLineStride;  /* Byte stride line-to-line */\n  int                 mapPixelStride; /* Byte stride pixel-to-pixel */\n  void*               privateData;    /* Handle for device-dependent library */\n} SolarisJDgaWinInfo;\n\ntypedef JDgaStatus (*SolarisJDgaDevFunction)(SolarisJDgaDevInfo*);\ntypedef JDgaStatus (*SolarisJDgaWinFunction)(SolarisJDgaWinInfo*);\n\n/*\n * Structure for device-dependent functions\n */\ntypedef struct _SolarisJDgaDevFuncList {\n  SolarisJDgaDevFunction devclose;\n  SolarisJDgaWinFunction winopen;\n  SolarisJDgaWinFunction winclose;\n  SolarisJDgaWinFunction winlock;\n  SolarisJDgaWinFunction winunlock;\n} SolarisJDgaDevFuncList;\n\n/*\n * Function to be supplied by the device-dependent library implementor.\n * It will accept a SolarisJDgaDevInfo structure with a filled-in\n * major and minor version number and will return updated version\n * numbers and the function pointers described below.\n */\ntypedef JDgaStatus SolarisJDgaDevOpenFunc(SolarisJDgaDevInfo* devInfo);\n\nJDgaStatus SolarisJDgaDevOpen(SolarisJDgaDevInfo* devInfo);\n\n/*\n * Functions supplied by the device-dependent library.\n * These function pointers will be returned to the\n * device-independent code in the SolarisJDgaDevFunc structure.\n */\n\nJDgaStatus (*winopen)(SolarisJDgaWinInfo* info);\n\n/*\n *  Fills in window-specific information in the supplied SolarisJDgaWinInfo\n *  structure. Because multiple windows may be open concurrently,\n *  implementations should avoid the use of static structures.\n */\n\nJDgaStatus (*winclose)(SolarisJDgaWinInfo* info);\n\n/*\n *  Frees any resources allocated by the device-dependent library for\n *  this window.  It may also perform an unmap if this is the last\n *  window using this particular memory map. Devices, such as the FFB,\n *  which support multiple depths, can have different device memory\n *  mappings for different depths.\n */\n\nJDgaStatus (*winlock)(SolarisJDgaWinInfo* info);\n\n/*\n *  Performs any device-specific locking needed for the framebuffer.\n *  In most cases it will be unnecessary. In those cases, the\n *  device-dependent library can supply NULL for this function pointer.\n */\n\nJDgaStatus (*winunlock)(SolarisJDgaWinInfo* info);\n\n/*\n *  Performs any device-specific unlocking needed for the framebuffer.\n *  In most cases it will be unnecessary. In those cases, the\n *  device-dependent library can supply NULL for this function pointer.\n */\n\nJDgaStatus (*devclose)(SolarisJDgaDevInfo* info);\n\n/*\n *  This function will be called at the last usage of the framebuffer\n *  device to allow the library to clean up any remaining resources.\n */\n\n#endif  /* _JDGADEVICE_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/nio/fs/UnixNativeDispatcher.c": "/*\n * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <sys/time.h>\n\n#ifdef __solaris__\n#include <strings.h>\n#endif\n\n#if defined(__linux__) || defined(_AIX)\n#include <string.h>\n#endif\n\n#ifdef _ALLBSD_SOURCE\n#include <string.h>\n\n#define stat64 stat\n#define statvfs64 statvfs\n\n#define open64 open\n#define fstat64 fstat\n#define lstat64 lstat\n#define dirent64 dirent\n#define readdir64_r readdir_r\n#endif\n\n#include \"jni.h\"\n#include \"jni_util.h\"\n#include \"jlong.h\"\n\n#include \"sun_nio_fs_UnixNativeDispatcher.h\"\n\n/**\n * Size of password or group entry when not available via sysconf\n */\n#define ENT_BUF_SIZE   1024\n\n#define RESTARTABLE(_cmd, _result) do { \\\n  do { \\\n    _result = _cmd; \\\n  } while((_result == -1) && (errno == EINTR)); \\\n} while(0)\n\n#define RESTARTABLE_RETURN_PTR(_cmd, _result) do { \\\n  do { \\\n    _result = _cmd; \\\n  } while((_result == NULL) && (errno == EINTR)); \\\n} while(0)\n\nstatic jfieldID attrs_st_mode;\nstatic jfieldID attrs_st_ino;\nstatic jfieldID attrs_st_dev;\nstatic jfieldID attrs_st_rdev;\nstatic jfieldID attrs_st_nlink;\nstatic jfieldID attrs_st_uid;\nstatic jfieldID attrs_st_gid;\nstatic jfieldID attrs_st_size;\nstatic jfieldID attrs_st_atime_sec;\nstatic jfieldID attrs_st_atime_nsec;\nstatic jfieldID attrs_st_mtime_sec;\nstatic jfieldID attrs_st_mtime_nsec;\nstatic jfieldID attrs_st_ctime_sec;\nstatic jfieldID attrs_st_ctime_nsec;\n\n#ifdef _DARWIN_FEATURE_64_BIT_INODE\nstatic jfieldID attrs_st_birthtime_sec;\n#endif\n\nstatic jfieldID attrs_f_frsize;\nstatic jfieldID attrs_f_blocks;\nstatic jfieldID attrs_f_bfree;\nstatic jfieldID attrs_f_bavail;\n\nstatic jfieldID entry_name;\nstatic jfieldID entry_dir;\nstatic jfieldID entry_fstype;\nstatic jfieldID entry_options;\nstatic jfieldID entry_dev;\n\n/**\n * System calls that may not be available at run time.\n */\ntypedef int openat64_func(int, const char *, int, ...);\ntypedef int fstatat64_func(int, const char *, struct stat64 *, int);\ntypedef int unlinkat_func(int, const char*, int);\ntypedef int renameat_func(int, const char*, int, const char*);\ntypedef int futimesat_func(int, const char *, const struct timeval *);\ntypedef DIR* fdopendir_func(int);\n\nstatic openat64_func* my_openat64_func = NULL;\nstatic fstatat64_func* my_fstatat64_func = NULL;\nstatic unlinkat_func* my_unlinkat_func = NULL;\nstatic renameat_func* my_renameat_func = NULL;\nstatic futimesat_func* my_futimesat_func = NULL;\nstatic fdopendir_func* my_fdopendir_func = NULL;\n\n/**\n * fstatat missing from glibc on Linux. Temporary workaround\n * for x86/x64.\n */\n#if defined(__linux__) && defined(__i386)\n#define FSTATAT64_SYSCALL_AVAILABLE\nstatic int fstatat64_wrapper(int dfd, const char *path,\n                             struct stat64 *statbuf, int flag)\n{\n    #ifndef __NR_fstatat64\n    #define __NR_fstatat64  300\n    #endif\n    return syscall(__NR_fstatat64, dfd, path, statbuf, flag);\n}\n#endif\n\n#if defined(__linux__) && defined(__x86_64__)\n#define FSTATAT64_SYSCALL_AVAILABLE\nstatic int fstatat64_wrapper(int dfd, const char *path,\n                             struct stat64 *statbuf, int flag)\n{\n    #ifndef __NR_newfstatat\n    #define __NR_newfstatat  262\n    #endif\n    return syscall(__NR_newfstatat, dfd, path, statbuf, flag);\n}\n#endif\n\n/**\n * Call this to throw an internal UnixException when a system/library\n * call fails\n */\nstatic void throwUnixException(JNIEnv* env, int errnum) {\n    jobject x = JNU_NewObjectByName(env, \"sun/nio/fs/UnixException\",\n        \"(I)V\", errnum);\n    if (x != NULL) {\n        (*env)->Throw(env, x);\n    }\n}\n\n/**\n * Initialization\n */\nJNIEXPORT jint JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_init(JNIEnv* env, jclass this)\n{\n    jint capabilities = 0;\n    jclass clazz;\n\n    clazz = (*env)->FindClass(env, \"sun/nio/fs/UnixFileAttributes\");\n    CHECK_NULL_RETURN(clazz, 0);\n    attrs_st_mode = (*env)->GetFieldID(env, clazz, \"st_mode\", \"I\");\n    CHECK_NULL_RETURN(attrs_st_mode, 0);\n    attrs_st_ino = (*env)->GetFieldID(env, clazz, \"st_ino\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_ino, 0);\n    attrs_st_dev = (*env)->GetFieldID(env, clazz, \"st_dev\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_dev, 0);\n    attrs_st_rdev = (*env)->GetFieldID(env, clazz, \"st_rdev\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_rdev, 0);\n    attrs_st_nlink = (*env)->GetFieldID(env, clazz, \"st_nlink\", \"I\");\n    CHECK_NULL_RETURN(attrs_st_nlink, 0);\n    attrs_st_uid = (*env)->GetFieldID(env, clazz, \"st_uid\", \"I\");\n    CHECK_NULL_RETURN(attrs_st_uid, 0);\n    attrs_st_gid = (*env)->GetFieldID(env, clazz, \"st_gid\", \"I\");\n    CHECK_NULL_RETURN(attrs_st_gid, 0);\n    attrs_st_size = (*env)->GetFieldID(env, clazz, \"st_size\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_size, 0);\n    attrs_st_atime_sec = (*env)->GetFieldID(env, clazz, \"st_atime_sec\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_atime_sec, 0);\n    attrs_st_atime_nsec = (*env)->GetFieldID(env, clazz, \"st_atime_nsec\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_atime_nsec, 0);\n    attrs_st_mtime_sec = (*env)->GetFieldID(env, clazz, \"st_mtime_sec\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_mtime_sec, 0);\n    attrs_st_mtime_nsec = (*env)->GetFieldID(env, clazz, \"st_mtime_nsec\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_mtime_nsec, 0);\n    attrs_st_ctime_sec = (*env)->GetFieldID(env, clazz, \"st_ctime_sec\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_ctime_sec, 0);\n    attrs_st_ctime_nsec = (*env)->GetFieldID(env, clazz, \"st_ctime_nsec\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_ctime_nsec, 0);\n\n#ifdef _DARWIN_FEATURE_64_BIT_INODE\n    attrs_st_birthtime_sec = (*env)->GetFieldID(env, clazz, \"st_birthtime_sec\", \"J\");\n    CHECK_NULL_RETURN(attrs_st_birthtime_sec, 0);\n#endif\n\n    clazz = (*env)->FindClass(env, \"sun/nio/fs/UnixFileStoreAttributes\");\n    CHECK_NULL_RETURN(clazz, 0);\n    attrs_f_frsize = (*env)->GetFieldID(env, clazz, \"f_frsize\", \"J\");\n    CHECK_NULL_RETURN(attrs_f_frsize, 0);\n    attrs_f_blocks = (*env)->GetFieldID(env, clazz, \"f_blocks\", \"J\");\n    CHECK_NULL_RETURN(attrs_f_blocks, 0);\n    attrs_f_bfree = (*env)->GetFieldID(env, clazz, \"f_bfree\", \"J\");\n    CHECK_NULL_RETURN(attrs_f_bfree, 0);\n    attrs_f_bavail = (*env)->GetFieldID(env, clazz, \"f_bavail\", \"J\");\n    CHECK_NULL_RETURN(attrs_f_bavail, 0);\n\n    clazz = (*env)->FindClass(env, \"sun/nio/fs/UnixMountEntry\");\n    CHECK_NULL_RETURN(clazz, 0);\n    entry_name = (*env)->GetFieldID(env, clazz, \"name\", \"[B\");\n    CHECK_NULL_RETURN(entry_name, 0);\n    entry_dir = (*env)->GetFieldID(env, clazz, \"dir\", \"[B\");\n    CHECK_NULL_RETURN(entry_dir, 0);\n    entry_fstype = (*env)->GetFieldID(env, clazz, \"fstype\", \"[B\");\n    CHECK_NULL_RETURN(entry_fstype, 0);\n    entry_options = (*env)->GetFieldID(env, clazz, \"opts\", \"[B\");\n    CHECK_NULL_RETURN(entry_options, 0);\n    entry_dev = (*env)->GetFieldID(env, clazz, \"dev\", \"J\");\n    CHECK_NULL_RETURN(entry_dev, 0);\n\n    /* system calls that might not be available at run time */\n\n#if (defined(__solaris__) && defined(_LP64)) || defined(_ALLBSD_SOURCE)\n    /* Solaris 64-bit does not have openat64/fstatat64 */\n    my_openat64_func = (openat64_func*)dlsym(RTLD_DEFAULT, \"openat\");\n    my_fstatat64_func = (fstatat64_func*)dlsym(RTLD_DEFAULT, \"fstatat\");\n#else\n    my_openat64_func = (openat64_func*) dlsym(RTLD_DEFAULT, \"openat64\");\n    my_fstatat64_func = (fstatat64_func*) dlsym(RTLD_DEFAULT, \"fstatat64\");\n#endif\n    my_unlinkat_func = (unlinkat_func*) dlsym(RTLD_DEFAULT, \"unlinkat\");\n    my_renameat_func = (renameat_func*) dlsym(RTLD_DEFAULT, \"renameat\");\n    my_futimesat_func = (futimesat_func*) dlsym(RTLD_DEFAULT, \"futimesat\");\n    my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, \"fdopendir\");\n\n#if defined(FSTATAT64_SYSCALL_AVAILABLE)\n    /* fstatat64 missing from glibc */\n    if (my_fstatat64_func == NULL)\n        my_fstatat64_func = (fstatat64_func*)&fstatat64_wrapper;\n#endif\n\n    /* supports futimes or futimesat */\n\n#ifdef _ALLBSD_SOURCE\n    capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;\n#else\n    if (my_futimesat_func != NULL)\n        capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;\n#endif\n\n    /* supports openat, etc. */\n\n    if (my_openat64_func != NULL &&  my_fstatat64_func != NULL &&\n        my_unlinkat_func != NULL && my_renameat_func != NULL &&\n        my_futimesat_func != NULL && my_fdopendir_func != NULL)\n    {\n        capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_OPENAT;\n    }\n\n    /* supports file birthtime */\n\n#ifdef _DARWIN_FEATURE_64_BIT_INODE\n    capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_BIRTHTIME;\n#endif\n\n    return capabilities;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_getcwd(JNIEnv* env, jclass this) {\n    jbyteArray result = NULL;\n    char buf[PATH_MAX+1];\n\n    /* EINTR not listed as a possible error */\n    char* cwd = getcwd(buf, sizeof(buf));\n    if (cwd == NULL) {\n        throwUnixException(env, errno);\n    } else {\n        jsize len = (jsize)strlen(buf);\n        result = (*env)->NewByteArray(env, len);\n        if (result != NULL) {\n            (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte*)buf);\n        }\n    }\n    return result;\n}\n\nJNIEXPORT jbyteArray\nJava_sun_nio_fs_UnixNativeDispatcher_strerror(JNIEnv* env, jclass this, jint error)\n{\n    char tmpbuf[1024];\n    jsize len;\n    jbyteArray bytes;\n\n    getErrorString((int)errno, tmpbuf, sizeof(tmpbuf));\n    len = strlen(tmpbuf);\n    bytes = (*env)->NewByteArray(env, len);\n    if (bytes != NULL) {\n        (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)tmpbuf);\n    }\n    return bytes;\n}\n\nJNIEXPORT jint\nJava_sun_nio_fs_UnixNativeDispatcher_dup(JNIEnv* env, jclass this, jint fd) {\n\n    int res = -1;\n\n    RESTARTABLE(dup((int)fd), res);\n    if (res == -1) {\n        throwUnixException(env, errno);\n    }\n    return (jint)res;\n}\n\nJNIEXPORT jlong JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_fopen0(JNIEnv* env, jclass this,\n    jlong pathAddress, jlong modeAddress)\n{\n    FILE* fp = NULL;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n    const char* mode = (const char*)jlong_to_ptr(modeAddress);\n\n    do {\n        fp = fopen(path, mode);\n    } while (fp == NULL && errno == EINTR);\n\n    if (fp == NULL) {\n        throwUnixException(env, errno);\n    }\n\n    return ptr_to_jlong(fp);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_fclose(JNIEnv* env, jclass this, jlong stream)\n{\n    FILE* fp = jlong_to_ptr(stream);\n\n    /* NOTE: fclose() wrapper is only used with read-only streams.\n     * If it ever is used with write streams, it might be better to add\n     * RESTARTABLE(fflush(fp)) before closing, to make sure the stream\n     * is completely written even if fclose() failed.\n     */\n    if (fclose(fp) == EOF && errno != EINTR) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_open0(JNIEnv* env, jclass this,\n    jlong pathAddress, jint oflags, jint mode)\n{\n    jint fd;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    RESTARTABLE(open64(path, (int)oflags, (mode_t)mode), fd);\n    if (fd == -1) {\n        throwUnixException(env, errno);\n    }\n    return fd;\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_openat0(JNIEnv* env, jclass this, jint dfd,\n    jlong pathAddress, jint oflags, jint mode)\n{\n    jint fd;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    if (my_openat64_func == NULL) {\n        JNU_ThrowInternalError(env, \"should not reach here\");\n        return -1;\n    }\n\n    RESTARTABLE((*my_openat64_func)(dfd, path, (int)oflags, (mode_t)mode), fd);\n    if (fd == -1) {\n        throwUnixException(env, errno);\n    }\n    return fd;\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_close(JNIEnv* env, jclass this, jint fd) {\n    int err;\n    /* TDB - need to decide if EIO and other errors should cause exception */\n    RESTARTABLE(close((int)fd), err);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_read(JNIEnv* env, jclass this, jint fd,\n    jlong address, jint nbytes)\n{\n    ssize_t n;\n    void* bufp = jlong_to_ptr(address);\n    RESTARTABLE(read((int)fd, bufp, (size_t)nbytes), n);\n    if (n == -1) {\n        throwUnixException(env, errno);\n    }\n    return (jint)n;\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_write(JNIEnv* env, jclass this, jint fd,\n    jlong address, jint nbytes)\n{\n    ssize_t n;\n    void* bufp = jlong_to_ptr(address);\n    RESTARTABLE(write((int)fd, bufp, (size_t)nbytes), n);\n    if (n == -1) {\n        throwUnixException(env, errno);\n    }\n    return (jint)n;\n}\n\n/**\n * Copy stat64 members into sun.nio.fs.UnixFileAttributes\n */\nstatic void prepAttributes(JNIEnv* env, struct stat64* buf, jobject attrs) {\n    (*env)->SetIntField(env, attrs, attrs_st_mode, (jint)buf->st_mode);\n    (*env)->SetLongField(env, attrs, attrs_st_ino, (jlong)buf->st_ino);\n    (*env)->SetLongField(env, attrs, attrs_st_dev, (jlong)buf->st_dev);\n    (*env)->SetLongField(env, attrs, attrs_st_rdev, (jlong)buf->st_rdev);\n    (*env)->SetIntField(env, attrs, attrs_st_nlink, (jint)buf->st_nlink);\n    (*env)->SetIntField(env, attrs, attrs_st_uid, (jint)buf->st_uid);\n    (*env)->SetIntField(env, attrs, attrs_st_gid, (jint)buf->st_gid);\n    (*env)->SetLongField(env, attrs, attrs_st_size, (jlong)buf->st_size);\n    (*env)->SetLongField(env, attrs, attrs_st_atime_sec, (jlong)buf->st_atime);\n    (*env)->SetLongField(env, attrs, attrs_st_mtime_sec, (jlong)buf->st_mtime);\n    (*env)->SetLongField(env, attrs, attrs_st_ctime_sec, (jlong)buf->st_ctime);\n\n#ifdef _DARWIN_FEATURE_64_BIT_INODE\n    (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->st_birthtime);\n#endif\n\n#if (_POSIX_C_SOURCE >= 200809L) || defined(__solaris__)\n    (*env)->SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf->st_atim.tv_nsec);\n    (*env)->SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf->st_mtim.tv_nsec);\n    (*env)->SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf->st_ctim.tv_nsec);\n#endif\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_stat0(JNIEnv* env, jclass this,\n    jlong pathAddress, jobject attrs)\n{\n    int err;\n    struct stat64 buf;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    RESTARTABLE(stat64(path, &buf), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    } else {\n        prepAttributes(env, &buf, attrs);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_lstat0(JNIEnv* env, jclass this,\n    jlong pathAddress, jobject attrs)\n{\n    int err;\n    struct stat64 buf;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    RESTARTABLE(lstat64(path, &buf), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    } else {\n        prepAttributes(env, &buf, attrs);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_fstat(JNIEnv* env, jclass this, jint fd,\n    jobject attrs)\n{\n    int err;\n    struct stat64 buf;\n\n    RESTARTABLE(fstat64((int)fd, &buf), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    } else {\n        prepAttributes(env, &buf, attrs);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_fstatat0(JNIEnv* env, jclass this, jint dfd,\n    jlong pathAddress, jint flag, jobject attrs)\n{\n    int err;\n    struct stat64 buf;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    if (my_fstatat64_func == NULL) {\n        JNU_ThrowInternalError(env, \"should not reach here\");\n        return;\n    }\n    RESTARTABLE((*my_fstatat64_func)((int)dfd, path, &buf, (int)flag), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    } else {\n        prepAttributes(env, &buf, attrs);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_chmod0(JNIEnv* env, jclass this,\n    jlong pathAddress, jint mode)\n{\n    int err;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    RESTARTABLE(chmod(path, (mode_t)mode), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_fchmod(JNIEnv* env, jclass this, jint filedes,\n    jint mode)\n{\n    int err;\n\n    RESTARTABLE(fchmod((int)filedes, (mode_t)mode), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_chown0(JNIEnv* env, jclass this,\n    jlong pathAddress, jint uid, jint gid)\n{\n    int err;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    RESTARTABLE(chown(path, (uid_t)uid, (gid_t)gid), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_lchown0(JNIEnv* env, jclass this, jlong pathAddress, jint uid, jint gid)\n{\n    int err;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    RESTARTABLE(lchown(path, (uid_t)uid, (gid_t)gid), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_fchown(JNIEnv* env, jclass this, jint filedes, jint uid, jint gid)\n{\n    int err;\n\n    RESTARTABLE(fchown(filedes, (uid_t)uid, (gid_t)gid), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_utimes0(JNIEnv* env, jclass this,\n    jlong pathAddress, jlong accessTime, jlong modificationTime)\n{\n    int err;\n    struct timeval times[2];\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    times[0].tv_sec = accessTime / 1000000;\n    times[0].tv_usec = accessTime % 1000000;\n\n    times[1].tv_sec = modificationTime / 1000000;\n    times[1].tv_usec = modificationTime % 1000000;\n\n    RESTARTABLE(utimes(path, &times[0]), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_futimes(JNIEnv* env, jclass this, jint filedes,\n    jlong accessTime, jlong modificationTime)\n{\n    struct timeval times[2];\n    int err = 0;\n\n    times[0].tv_sec = accessTime / 1000000;\n    times[0].tv_usec = accessTime % 1000000;\n\n    times[1].tv_sec = modificationTime / 1000000;\n    times[1].tv_usec = modificationTime % 1000000;\n\n#ifdef _ALLBSD_SOURCE\n    RESTARTABLE(futimes(filedes, &times[0]), err);\n#else\n    if (my_futimesat_func == NULL) {\n        JNU_ThrowInternalError(env, \"my_ftimesat_func is NULL\");\n        return;\n    }\n    RESTARTABLE((*my_futimesat_func)(filedes, NULL, &times[0]), err);\n#endif\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT jlong JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_opendir0(JNIEnv* env, jclass this,\n    jlong pathAddress)\n{\n    DIR* dir;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    /* EINTR not listed as a possible error */\n    dir = opendir(path);\n    if (dir == NULL) {\n        throwUnixException(env, errno);\n    }\n    return ptr_to_jlong(dir);\n}\n\nJNIEXPORT jlong JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_fdopendir(JNIEnv* env, jclass this, int dfd) {\n    DIR* dir;\n\n    if (my_fdopendir_func == NULL) {\n        JNU_ThrowInternalError(env, \"should not reach here\");\n        return (jlong)-1;\n    }\n\n    /* EINTR not listed as a possible error */\n    dir = (*my_fdopendir_func)((int)dfd);\n    if (dir == NULL) {\n        throwUnixException(env, errno);\n    }\n    return ptr_to_jlong(dir);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_closedir(JNIEnv* env, jclass this, jlong dir) {\n    DIR* dirp = jlong_to_ptr(dir);\n\n    if (closedir(dirp) == -1 && errno != EINTR) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_readdir(JNIEnv* env, jclass this, jlong value) {\n    struct dirent64* result;\n    struct {\n        struct dirent64 buf;\n        char name_extra[PATH_MAX + 1 - sizeof result->d_name];\n    } entry;\n    struct dirent64* ptr = &entry.buf;\n    int res;\n    DIR* dirp = jlong_to_ptr(value);\n\n    /* EINTR not listed as a possible error */\n    /* TDB: reentrant version probably not required here */\n    res = readdir64_r(dirp, ptr, &result);\n\n#ifdef _AIX\n    /* On AIX, readdir_r() returns EBADF (i.e. '9') and sets 'result' to NULL for the */\n    /* directory stream end. Otherwise, 'errno' will contain the error code. */\n    if (res != 0) {\n        res = (result == NULL && res == EBADF) ? 0 : errno;\n    }\n#endif\n\n    if (res != 0) {\n        throwUnixException(env, res);\n        return NULL;\n    } else {\n        if (result == NULL) {\n            return NULL;\n        } else {\n            jsize len = strlen(ptr->d_name);\n            jbyteArray bytes = (*env)->NewByteArray(env, len);\n            if (bytes != NULL) {\n                (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)(ptr->d_name));\n            }\n            return bytes;\n        }\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_mkdir0(JNIEnv* env, jclass this,\n    jlong pathAddress, jint mode)\n{\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    /* EINTR not listed as a possible error */\n    if (mkdir(path, (mode_t)mode) == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_rmdir0(JNIEnv* env, jclass this,\n    jlong pathAddress)\n{\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    /* EINTR not listed as a possible error */\n    if (rmdir(path) == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_link0(JNIEnv* env, jclass this,\n    jlong existingAddress, jlong newAddress)\n{\n    int err;\n    const char* existing = (const char*)jlong_to_ptr(existingAddress);\n    const char* newname = (const char*)jlong_to_ptr(newAddress);\n\n    RESTARTABLE(link(existing, newname), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_unlink0(JNIEnv* env, jclass this,\n    jlong pathAddress)\n{\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    /* EINTR not listed as a possible error */\n    if (unlink(path) == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_unlinkat0(JNIEnv* env, jclass this, jint dfd,\n                                               jlong pathAddress, jint flags)\n{\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    if (my_unlinkat_func == NULL) {\n        JNU_ThrowInternalError(env, \"should not reach here\");\n        return;\n    }\n\n    /* EINTR not listed as a possible error */\n    if ((*my_unlinkat_func)((int)dfd, path, (int)flags) == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_rename0(JNIEnv* env, jclass this,\n    jlong fromAddress, jlong toAddress)\n{\n    const char* from = (const char*)jlong_to_ptr(fromAddress);\n    const char* to = (const char*)jlong_to_ptr(toAddress);\n\n    /* EINTR not listed as a possible error */\n    if (rename(from, to) == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_renameat0(JNIEnv* env, jclass this,\n    jint fromfd, jlong fromAddress, jint tofd, jlong toAddress)\n{\n    const char* from = (const char*)jlong_to_ptr(fromAddress);\n    const char* to = (const char*)jlong_to_ptr(toAddress);\n\n    if (my_renameat_func == NULL) {\n        JNU_ThrowInternalError(env, \"should not reach here\");\n        return;\n    }\n\n    /* EINTR not listed as a possible error */\n    if ((*my_renameat_func)((int)fromfd, from, (int)tofd, to) == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_symlink0(JNIEnv* env, jclass this,\n    jlong targetAddress, jlong linkAddress)\n{\n    const char* target = (const char*)jlong_to_ptr(targetAddress);\n    const char* link = (const char*)jlong_to_ptr(linkAddress);\n\n    /* EINTR not listed as a possible error */\n    if (symlink(target, link) == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_readlink0(JNIEnv* env, jclass this,\n    jlong pathAddress)\n{\n    jbyteArray result = NULL;\n    char target[PATH_MAX+1];\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    /* EINTR not listed as a possible error */\n    int n = readlink(path, target, sizeof(target));\n    if (n == -1) {\n        throwUnixException(env, errno);\n    } else {\n        jsize len;\n        if (n == sizeof(target)) {\n            n--;\n        }\n        target[n] = '\\0';\n        len = (jsize)strlen(target);\n        result = (*env)->NewByteArray(env, len);\n        if (result != NULL) {\n            (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte*)target);\n        }\n    }\n    return result;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_realpath0(JNIEnv* env, jclass this,\n    jlong pathAddress)\n{\n    jbyteArray result = NULL;\n    char resolved[PATH_MAX+1];\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    /* EINTR not listed as a possible error */\n    if (realpath(path, resolved) == NULL) {\n        throwUnixException(env, errno);\n    } else {\n        jsize len = (jsize)strlen(resolved);\n        result = (*env)->NewByteArray(env, len);\n        if (result != NULL) {\n            (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte*)resolved);\n        }\n    }\n    return result;\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_access0(JNIEnv* env, jclass this,\n    jlong pathAddress, jint amode)\n{\n    int err;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    RESTARTABLE(access(path, (int)amode), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_statvfs0(JNIEnv* env, jclass this,\n    jlong pathAddress, jobject attrs)\n{\n    int err;\n    struct statvfs64 buf;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n\n    RESTARTABLE(statvfs64(path, &buf), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    } else {\n#ifdef _AIX\n        /* AIX returns ULONG_MAX in buf.f_blocks for the /proc file system. */\n        /* This is too big for a Java signed long and fools various tests.  */\n        if (buf.f_blocks == ULONG_MAX) {\n            buf.f_blocks = 0;\n        }\n        /* The number of free or available blocks can never exceed the total number of blocks */\n        if (buf.f_blocks == 0) {\n            buf.f_bfree = 0;\n            buf.f_bavail = 0;\n        }\n#endif\n        (*env)->SetLongField(env, attrs, attrs_f_frsize, long_to_jlong(buf.f_frsize));\n        (*env)->SetLongField(env, attrs, attrs_f_blocks, long_to_jlong(buf.f_blocks));\n        (*env)->SetLongField(env, attrs, attrs_f_bfree,  long_to_jlong(buf.f_bfree));\n        (*env)->SetLongField(env, attrs, attrs_f_bavail, long_to_jlong(buf.f_bavail));\n    }\n}\n\nJNIEXPORT jlong JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_pathconf0(JNIEnv* env, jclass this,\n    jlong pathAddress, jint name)\n{\n    long err;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    err = pathconf(path, (int)name);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n    return (jlong)err;\n}\n\nJNIEXPORT jlong JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_fpathconf(JNIEnv* env, jclass this,\n    jint fd, jint name)\n{\n    long err;\n\n    err = fpathconf((int)fd, (int)name);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n    return (jlong)err;\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_mknod0(JNIEnv* env, jclass this,\n    jlong pathAddress, jint mode, jlong dev)\n{\n    int err;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n\n    RESTARTABLE(mknod(path, (mode_t)mode, (dev_t)dev), err);\n    if (err == -1) {\n        throwUnixException(env, errno);\n    }\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_getpwuid(JNIEnv* env, jclass this, jint uid)\n{\n    jbyteArray result = NULL;\n    int buflen;\n    char* pwbuf;\n\n    /* allocate buffer for password record */\n    buflen = (int)sysconf(_SC_GETPW_R_SIZE_MAX);\n    if (buflen == -1)\n        buflen = ENT_BUF_SIZE;\n    pwbuf = (char*)malloc(buflen);\n    if (pwbuf == NULL) {\n        JNU_ThrowOutOfMemoryError(env, \"native heap\");\n    } else {\n        struct passwd pwent;\n        struct passwd* p = NULL;\n        int res = 0;\n\n        errno = 0;\n        #ifdef __solaris__\n            RESTARTABLE_RETURN_PTR(getpwuid_r((uid_t)uid, &pwent, pwbuf, (size_t)buflen), p);\n        #else\n            RESTARTABLE(getpwuid_r((uid_t)uid, &pwent, pwbuf, (size_t)buflen, &p), res);\n        #endif\n\n        if (res != 0 || p == NULL || p->pw_name == NULL || *(p->pw_name) == '\\0') {\n            /* not found or error */\n            if (errno == 0)\n                errno = ENOENT;\n            throwUnixException(env, errno);\n        } else {\n            jsize len = strlen(p->pw_name);\n            result = (*env)->NewByteArray(env, len);\n            if (result != NULL) {\n                (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte*)(p->pw_name));\n            }\n        }\n        free(pwbuf);\n    }\n\n    return result;\n}\n\n\nJNIEXPORT jbyteArray JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_getgrgid(JNIEnv* env, jclass this, jint gid)\n{\n    jbyteArray result = NULL;\n    int buflen;\n    int retry;\n\n    /* initial size of buffer for group record */\n    buflen = (int)sysconf(_SC_GETGR_R_SIZE_MAX);\n    if (buflen == -1)\n        buflen = ENT_BUF_SIZE;\n\n    do {\n        struct group grent;\n        struct group* g = NULL;\n        int res = 0;\n\n        char* grbuf = (char*)malloc(buflen);\n        if (grbuf == NULL) {\n            JNU_ThrowOutOfMemoryError(env, \"native heap\");\n            return NULL;\n        }\n\n        errno = 0;\n        #ifdef __solaris__\n            RESTARTABLE_RETURN_PTR(getgrgid_r((gid_t)gid, &grent, grbuf, (size_t)buflen), g);\n        #else\n            RESTARTABLE(getgrgid_r((gid_t)gid, &grent, grbuf, (size_t)buflen, &g), res);\n        #endif\n\n        retry = 0;\n        if (res != 0 || g == NULL || g->gr_name == NULL || *(g->gr_name) == '\\0') {\n            /* not found or error */\n            if (errno == ERANGE) {\n                /* insufficient buffer size so need larger buffer */\n                buflen += ENT_BUF_SIZE;\n                retry = 1;\n            } else {\n                if (errno == 0)\n                    errno = ENOENT;\n                throwUnixException(env, errno);\n            }\n        } else {\n            jsize len = strlen(g->gr_name);\n            result = (*env)->NewByteArray(env, len);\n            if (result != NULL) {\n                (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte*)(g->gr_name));\n            }\n        }\n\n        free(grbuf);\n\n    } while (retry);\n\n    return result;\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_getpwnam0(JNIEnv* env, jclass this,\n    jlong nameAddress)\n{\n    jint uid = -1;\n    int buflen;\n    char* pwbuf;\n\n    /* allocate buffer for password record */\n    buflen = (int)sysconf(_SC_GETPW_R_SIZE_MAX);\n    if (buflen == -1)\n        buflen = ENT_BUF_SIZE;\n    pwbuf = (char*)malloc(buflen);\n    if (pwbuf == NULL) {\n        JNU_ThrowOutOfMemoryError(env, \"native heap\");\n    } else {\n        struct passwd pwent;\n        struct passwd* p = NULL;\n        int res = 0;\n        const char* name = (const char*)jlong_to_ptr(nameAddress);\n\n        errno = 0;\n        #ifdef __solaris__\n            RESTARTABLE_RETURN_PTR(getpwnam_r(name, &pwent, pwbuf, (size_t)buflen), p);\n        #else\n            RESTARTABLE(getpwnam_r(name, &pwent, pwbuf, (size_t)buflen, &p), res);\n        #endif\n\n        if (res != 0 || p == NULL || p->pw_name == NULL || *(p->pw_name) == '\\0') {\n            /* not found or error */\n            if (errno != 0 && errno != ENOENT && errno != ESRCH)\n                throwUnixException(env, errno);\n        } else {\n            uid = p->pw_uid;\n        }\n        free(pwbuf);\n    }\n\n    return uid;\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_fs_UnixNativeDispatcher_getgrnam0(JNIEnv* env, jclass this,\n    jlong nameAddress)\n{\n    jint gid = -1;\n    int buflen, retry;\n\n    /* initial size of buffer for group record */\n    buflen = (int)sysconf(_SC_GETGR_R_SIZE_MAX);\n    if (buflen == -1)\n        buflen = ENT_BUF_SIZE;\n\n    do {\n        struct group grent;\n        struct group* g = NULL;\n        int res = 0;\n        char *grbuf;\n        const char* name = (const char*)jlong_to_ptr(nameAddress);\n\n        grbuf = (char*)malloc(buflen);\n        if (grbuf == NULL) {\n            JNU_ThrowOutOfMemoryError(env, \"native heap\");\n            return -1;\n        }\n\n        errno = 0;\n        #ifdef __solaris__\n            RESTARTABLE_RETURN_PTR(getgrnam_r(name, &grent, grbuf, (size_t)buflen), g);\n        #else\n            RESTARTABLE(getgrnam_r(name, &grent, grbuf, (size_t)buflen, &g), res);\n        #endif\n\n        retry = 0;\n        if (res != 0 || g == NULL || g->gr_name == NULL || *(g->gr_name) == '\\0') {\n            /* not found or error */\n            if (errno != 0 && errno != ENOENT && errno != ESRCH) {\n                if (errno == ERANGE) {\n                    /* insufficient buffer size so need larger buffer */\n                    buflen += ENT_BUF_SIZE;\n                    retry = 1;\n                } else {\n                    throwUnixException(env, errno);\n                }\n            }\n        } else {\n            gid = g->gr_gid;\n        }\n\n        free(grbuf);\n\n    } while (retry);\n\n    return gid;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/nio/fs/MagicFileTypeDetector.c": "/*\n * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"jni.h\"\n#include \"jni_util.h\"\n#include \"jvm.h\"\n#include \"jlong.h\"\n\n#include <dlfcn.h>\n#include <string.h>\n\n#define MAGIC_MIME_TYPE 0x000010 /* Return the MIME type */\n\ntypedef struct magic_set magic_t;\n\ntypedef magic_t* (*magic_open_func)(int flags);\ntypedef int (*magic_load_func)(magic_t* cookie, const char* filename);\ntypedef const char* (*magic_file_func)(magic_t* cookie, const char* filename);\ntypedef void (*magic_close_func)(magic_t* cookie);\n\nstatic void* magic_handle;\nstatic magic_open_func magic_open;\nstatic magic_load_func magic_load;\nstatic magic_file_func magic_file;\nstatic magic_close_func magic_close;\n\n#include \"sun_nio_fs_MagicFileTypeDetector.h\"\n\nJNIEXPORT jboolean JNICALL\nJava_sun_nio_fs_MagicFileTypeDetector_initialize0\n    (JNIEnv* env, jclass this)\n{\n    magic_handle = dlopen(\"libmagic.so\", RTLD_LAZY);\n    if (magic_handle == NULL) {\n        magic_handle = dlopen(\"libmagic.so.1\", RTLD_LAZY);\n        if (magic_handle == NULL) {\n            return JNI_FALSE;\n        }\n    }\n\n    magic_open = (magic_open_func)dlsym(magic_handle, \"magic_open\");\n\n    magic_load = (magic_load_func)dlsym(magic_handle, \"magic_load\");\n\n    magic_file = (magic_file_func)dlsym(magic_handle, \"magic_file\");\n\n    magic_close = (magic_close_func)dlsym(magic_handle, \"magic_close\");\n\n    if (magic_open == NULL ||\n        magic_load == NULL ||\n        magic_file == NULL ||\n        magic_close == NULL)\n    {\n        dlclose(magic_handle);\n        return JNI_FALSE;\n    }\n\n    return JNI_TRUE;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_sun_nio_fs_MagicFileTypeDetector_probe0\n    (JNIEnv* env, jclass this, jlong pathAddress)\n{\n    char* path = (char*)jlong_to_ptr(pathAddress);\n    magic_t* cookie;\n    jbyteArray result = NULL;\n\n    cookie = (*magic_open)(MAGIC_MIME_TYPE);\n\n    if (cookie != NULL) {\n        if ((*magic_load)(cookie, NULL) != -1) {\n            const char* type = (*magic_file)(cookie, path);\n            if (type != NULL) {\n                jsize len = strlen(type);\n                result = (*env)->NewByteArray(env, len);\n                if (result != NULL) {\n                    (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte*)type);\n                }\n            }\n        }\n        (*magic_close)(cookie);\n    }\n\n    return result;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/nio/fs/LinuxNativeDispatcher.c": "/*\n * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"jni.h\"\n#include \"jni_util.h\"\n#include \"jvm.h\"\n#include \"jlong.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <mntent.h>\n\n#include \"sun_nio_fs_LinuxNativeDispatcher.h\"\n\ntypedef size_t fgetxattr_func(int fd, const char* name, void* value, size_t size);\ntypedef int fsetxattr_func(int fd, const char* name, void* value, size_t size, int flags);\ntypedef int fremovexattr_func(int fd, const char* name);\ntypedef int flistxattr_func(int fd, char* list, size_t size);\n\nfgetxattr_func* my_fgetxattr_func = NULL;\nfsetxattr_func* my_fsetxattr_func = NULL;\nfremovexattr_func* my_fremovexattr_func = NULL;\nflistxattr_func* my_flistxattr_func = NULL;\n\nstatic jfieldID entry_name;\nstatic jfieldID entry_dir;\nstatic jfieldID entry_fstype;\nstatic jfieldID entry_options;\n\nstatic void throwUnixException(JNIEnv* env, int errnum) {\n    jobject x = JNU_NewObjectByName(env, \"sun/nio/fs/UnixException\",\n        \"(I)V\", errnum);\n    if (x != NULL) {\n        (*env)->Throw(env, x);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_LinuxNativeDispatcher_init(JNIEnv *env, jclass clazz)\n{\n    my_fgetxattr_func = (fgetxattr_func*)dlsym(RTLD_DEFAULT, \"fgetxattr\");\n    my_fsetxattr_func = (fsetxattr_func*)dlsym(RTLD_DEFAULT, \"fsetxattr\");\n    my_fremovexattr_func = (fremovexattr_func*)dlsym(RTLD_DEFAULT, \"fremovexattr\");\n    my_flistxattr_func = (flistxattr_func*)dlsym(RTLD_DEFAULT, \"flistxattr\");\n\n    clazz = (*env)->FindClass(env, \"sun/nio/fs/UnixMountEntry\");\n    CHECK_NULL(clazz);\n    entry_name = (*env)->GetFieldID(env, clazz, \"name\", \"[B\");\n    CHECK_NULL(entry_name);\n    entry_dir = (*env)->GetFieldID(env, clazz, \"dir\", \"[B\");\n    CHECK_NULL(entry_dir);\n    entry_fstype = (*env)->GetFieldID(env, clazz, \"fstype\", \"[B\");\n    CHECK_NULL(entry_fstype);\n    entry_options = (*env)->GetFieldID(env, clazz, \"opts\", \"[B\");\n    CHECK_NULL(entry_options);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_fs_LinuxNativeDispatcher_fgetxattr0(JNIEnv* env, jclass clazz,\n    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)\n{\n    size_t res = -1;\n    const char* name = jlong_to_ptr(nameAddress);\n    void* value = jlong_to_ptr(valueAddress);\n\n    if (my_fgetxattr_func == NULL) {\n        errno = ENOTSUP;\n    } else {\n        /* EINTR not documented */\n        res = (*my_fgetxattr_func)(fd, name, value, valueLen);\n    }\n    if (res == (size_t)-1)\n        throwUnixException(env, errno);\n    return (jint)res;\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_LinuxNativeDispatcher_fsetxattr0(JNIEnv* env, jclass clazz,\n    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)\n{\n    int res = -1;\n    const char* name = jlong_to_ptr(nameAddress);\n    void* value = jlong_to_ptr(valueAddress);\n\n    if (my_fsetxattr_func == NULL) {\n        errno = ENOTSUP;\n    } else {\n        /* EINTR not documented */\n        res = (*my_fsetxattr_func)(fd, name, value, valueLen, 0);\n    }\n    if (res == -1)\n        throwUnixException(env, errno);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_LinuxNativeDispatcher_fremovexattr0(JNIEnv* env, jclass clazz,\n    jint fd, jlong nameAddress)\n{\n    int res = -1;\n    const char* name = jlong_to_ptr(nameAddress);\n\n    if (my_fremovexattr_func == NULL) {\n        errno = ENOTSUP;\n    } else {\n        /* EINTR not documented */\n        res = (*my_fremovexattr_func)(fd, name);\n    }\n    if (res == -1)\n        throwUnixException(env, errno);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_fs_LinuxNativeDispatcher_flistxattr(JNIEnv* env, jclass clazz,\n    jint fd, jlong listAddress, jint size)\n{\n    size_t res = -1;\n    char* list = jlong_to_ptr(listAddress);\n\n    if (my_flistxattr_func == NULL) {\n        errno = ENOTSUP;\n    } else {\n        /* EINTR not documented */\n        res = (*my_flistxattr_func)(fd, list, (size_t)size);\n    }\n    if (res == (size_t)-1)\n        throwUnixException(env, errno);\n    return (jint)res;\n}\n\nJNIEXPORT jlong JNICALL\nJava_sun_nio_fs_LinuxNativeDispatcher_setmntent0(JNIEnv* env, jclass this, jlong pathAddress,\n                                                 jlong modeAddress)\n{\n    FILE* fp = NULL;\n    const char* path = (const char*)jlong_to_ptr(pathAddress);\n    const char* mode = (const char*)jlong_to_ptr(modeAddress);\n\n    do {\n        fp = setmntent(path, mode);\n    } while (fp == NULL && errno == EINTR);\n    if (fp == NULL) {\n        throwUnixException(env, errno);\n    }\n    return ptr_to_jlong(fp);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_fs_LinuxNativeDispatcher_getmntent(JNIEnv* env, jclass this,\n    jlong value, jobject entry)\n{\n    struct mntent ent;\n    char buf[1024];\n    int buflen = sizeof(buf);\n    struct mntent* m;\n    FILE* fp = jlong_to_ptr(value);\n    jsize len;\n    jbyteArray bytes;\n    char* name;\n    char* dir;\n    char* fstype;\n    char* options;\n\n    m = getmntent_r(fp, &ent, (char*)&buf, buflen);\n    if (m == NULL)\n        return -1;\n    name = m->mnt_fsname;\n    dir = m->mnt_dir;\n    fstype = m->mnt_type;\n    options = m->mnt_opts;\n\n    len = strlen(name);\n    bytes = (*env)->NewByteArray(env, len);\n    if (bytes == NULL)\n        return -1;\n    (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)name);\n    (*env)->SetObjectField(env, entry, entry_name, bytes);\n\n    len = strlen(dir);\n    bytes = (*env)->NewByteArray(env, len);\n    if (bytes == NULL)\n        return -1;\n    (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)dir);\n    (*env)->SetObjectField(env, entry, entry_dir, bytes);\n\n    len = strlen(fstype);\n    bytes = (*env)->NewByteArray(env, len);\n    if (bytes == NULL)\n        return -1;\n    (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)fstype);\n    (*env)->SetObjectField(env, entry, entry_fstype, bytes);\n\n    len = strlen(options);\n    bytes = (*env)->NewByteArray(env, len);\n    if (bytes == NULL)\n        return -1;\n    (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)options);\n    (*env)->SetObjectField(env, entry, entry_options, bytes);\n\n    return 0;\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_fs_LinuxNativeDispatcher_endmntent(JNIEnv* env, jclass this, jlong stream)\n{\n    FILE* fp = jlong_to_ptr(stream);\n    /* FIXME - man page doesn't explain how errors are returned */\n    endmntent(fp);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/nio/fs/GnomeFileTypeDetector.c": "/*\n * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"jni.h\"\n#include \"jni_util.h\"\n#include \"jvm.h\"\n#include \"jlong.h\"\n\n#include <stdlib.h>\n#include <dlfcn.h>\n\n#ifdef __solaris__\n#include <strings.h>\n#endif\n\n#if defined(__linux__)\n#include <string.h>\n#endif\n\n/* Definitions for GIO */\n\n#define G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE \"standard::content-type\"\n\ntypedef void* gpointer;\ntypedef struct _GFile GFile;\ntypedef struct _GFileInfo GFileInfo;\ntypedef struct _GCancellable GCancellable;\ntypedef struct _GError GError;\n\ntypedef enum {\n  G_FILE_QUERY_INFO_NONE = 0\n} GFileQueryInfoFlags;\n\ntypedef void (*g_type_init_func)(void);\ntypedef void (*g_object_unref_func)(gpointer object);\ntypedef GFile* (*g_file_new_for_path_func)(const char* path);\ntypedef GFileInfo* (*g_file_query_info_func)(GFile *file,\n    const char *attributes, GFileQueryInfoFlags flags,\n    GCancellable *cancellable, GError **error);\ntypedef char* (*g_file_info_get_content_type_func)(GFileInfo *info);\n\nstatic g_type_init_func g_type_init;\nstatic g_object_unref_func g_object_unref;\nstatic g_file_new_for_path_func g_file_new_for_path;\nstatic g_file_query_info_func g_file_query_info;\nstatic g_file_info_get_content_type_func g_file_info_get_content_type;\n\n\n/* Definitions for GNOME VFS */\n\ntypedef int gboolean;\n\ntypedef gboolean (*gnome_vfs_init_function)(void);\ntypedef const char* (*gnome_vfs_mime_type_from_name_function)\n    (const char* filename);\n\nstatic gnome_vfs_init_function gnome_vfs_init;\nstatic gnome_vfs_mime_type_from_name_function gnome_vfs_mime_type_from_name;\n\n\n#include \"sun_nio_fs_GnomeFileTypeDetector.h\"\n\n\nJNIEXPORT jboolean JNICALL\nJava_sun_nio_fs_GnomeFileTypeDetector_initializeGio\n    (JNIEnv* env, jclass this)\n{\n    void* gio_handle;\n\n    gio_handle = dlopen(\"libgio-2.0.so\", RTLD_LAZY);\n    if (gio_handle == NULL) {\n        gio_handle = dlopen(\"libgio-2.0.so.0\", RTLD_LAZY);\n        if (gio_handle == NULL) {\n            return JNI_FALSE;\n        }\n    }\n\n    g_type_init = (g_type_init_func)dlsym(gio_handle, \"g_type_init\");\n    (*g_type_init)();\n\n    g_object_unref = (g_object_unref_func)dlsym(gio_handle, \"g_object_unref\");\n\n    g_file_new_for_path =\n        (g_file_new_for_path_func)dlsym(gio_handle, \"g_file_new_for_path\");\n\n    g_file_query_info =\n        (g_file_query_info_func)dlsym(gio_handle, \"g_file_query_info\");\n\n    g_file_info_get_content_type = (g_file_info_get_content_type_func)\n        dlsym(gio_handle, \"g_file_info_get_content_type\");\n\n\n    if (g_type_init == NULL ||\n        g_object_unref == NULL ||\n        g_file_new_for_path == NULL ||\n        g_file_query_info == NULL ||\n        g_file_info_get_content_type == NULL)\n    {\n        dlclose(gio_handle);\n        return JNI_FALSE;\n    }\n\n    (*g_type_init)();\n    return JNI_TRUE;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_sun_nio_fs_GnomeFileTypeDetector_probeUsingGio\n    (JNIEnv* env, jclass this, jlong pathAddress)\n{\n    char* path = (char*)jlong_to_ptr(pathAddress);\n    GFile* gfile;\n    GFileInfo* gfileinfo;\n    jbyteArray result = NULL;\n\n    gfile = (*g_file_new_for_path)(path);\n    gfileinfo = (*g_file_query_info)(gfile, G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE,\n        G_FILE_QUERY_INFO_NONE, NULL, NULL);\n    if (gfileinfo != NULL) {\n        const char* mime = (*g_file_info_get_content_type)(gfileinfo);\n        if (mime != NULL) {\n            jsize len = strlen(mime);\n            result = (*env)->NewByteArray(env, len);\n            if (result != NULL) {\n                (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte*)mime);\n            }\n        }\n        (*g_object_unref)(gfileinfo);\n    }\n    (*g_object_unref)(gfile);\n\n    return result;\n}\n\nJNIEXPORT jboolean JNICALL\nJava_sun_nio_fs_GnomeFileTypeDetector_initializeGnomeVfs\n    (JNIEnv* env, jclass this)\n{\n    void* vfs_handle;\n\n    vfs_handle = dlopen(\"libgnomevfs-2.so\", RTLD_LAZY);\n    if (vfs_handle == NULL) {\n        vfs_handle = dlopen(\"libgnomevfs-2.so.0\", RTLD_LAZY);\n    }\n    if (vfs_handle == NULL) {\n        return JNI_FALSE;\n    }\n\n    gnome_vfs_init = (gnome_vfs_init_function)dlsym(vfs_handle, \"gnome_vfs_init\");\n    gnome_vfs_mime_type_from_name = (gnome_vfs_mime_type_from_name_function)\n        dlsym(vfs_handle, \"gnome_vfs_mime_type_from_name\");\n\n    if (gnome_vfs_init == NULL ||\n        gnome_vfs_mime_type_from_name == NULL)\n    {\n        dlclose(vfs_handle);\n        return JNI_FALSE;\n    }\n\n    (*gnome_vfs_init)();\n    return JNI_TRUE;\n}\n\nJNIEXPORT jbyteArray JNICALL\nJava_sun_nio_fs_GnomeFileTypeDetector_probeUsingGnomeVfs\n    (JNIEnv* env, jclass this, jlong pathAddress)\n{\n    char* path = (char*)jlong_to_ptr(pathAddress);\n    const char* mime = (*gnome_vfs_mime_type_from_name)(path);\n\n    if (mime == NULL) {\n        return NULL;\n    } else {\n        jbyteArray result;\n        jsize len = strlen(mime);\n        result = (*env)->NewByteArray(env, len);\n        if (result != NULL) {\n            (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte*)mime);\n        }\n        return result;\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/nio/ch/sctp/SctpNet.c": "/*\n * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <stdlib.h>\n#include <string.h>\n\n#ifndef USE_SYSTEM_SCTP\n#include <dlfcn.h>\n#endif\n\n#include \"Sctp.h\"\n#include \"jni.h\"\n#include \"jni_util.h\"\n#include \"nio_util.h\"\n#include \"nio.h\"\n#include \"net_util.h\"\n#include \"net_util_md.h\"\n#include \"sun_nio_ch_sctp_SctpNet.h\"\n#include \"sun_nio_ch_sctp_SctpStdSocketOption.h\"\n\nstatic jclass isaCls = 0;\nstatic jmethodID isaCtrID = 0;\n\nstatic const char* nativeSctpLib = \"libsctp.so.1\";\nstatic jboolean funcsLoaded = JNI_FALSE;\n\nJNIEXPORT jint JNICALL JNI_OnLoad\n  (JavaVM *vm, void *reserved) {\n    return JNI_VERSION_1_2;\n}\n\nstatic int preCloseFD = -1;     /* File descriptor to which we dup other fd's\n                                   before closing them for real */\n\n/**\n * Loads the native sctp library that contains the socket extension\n * functions, as well as locating the individual functions.\n * There will be a pending exception if this method returns false.\n */\njboolean loadSocketExtensionFuncs\n  (JNIEnv* env) {\n#ifndef USE_SYSTEM_SCTP\n    if (dlopen(nativeSctpLib, RTLD_GLOBAL | RTLD_LAZY) == NULL) {\n        JNU_ThrowByName(env, \"java/lang/UnsupportedOperationException\",\n              dlerror());\n        return JNI_FALSE;\n    }\n\n    if ((nio_sctp_getladdrs = (sctp_getladdrs_func*)\n            dlsym(RTLD_DEFAULT, \"sctp_getladdrs\")) == NULL) {\n        JNU_ThrowByName(env, \"java/lang/UnsupportedOperationException\",\n              dlerror());\n        return JNI_FALSE;\n    }\n\n    if ((nio_sctp_freeladdrs = (sctp_freeladdrs_func*)\n            dlsym(RTLD_DEFAULT, \"sctp_freeladdrs\")) == NULL) {\n        JNU_ThrowByName(env, \"java/lang/UnsupportedOperationException\",\n              dlerror());\n        return JNI_FALSE;\n    }\n\n    if ((nio_sctp_getpaddrs = (sctp_getpaddrs_func*)\n            dlsym(RTLD_DEFAULT, \"sctp_getpaddrs\")) == NULL) {\n        JNU_ThrowByName(env, \"java/lang/UnsupportedOperationException\",\n              dlerror());\n        return JNI_FALSE;\n    }\n\n    if ((nio_sctp_freepaddrs = (sctp_freepaddrs_func*)\n            dlsym(RTLD_DEFAULT, \"sctp_freepaddrs\")) == NULL) {\n        JNU_ThrowByName(env, \"java/lang/UnsupportedOperationException\",\n              dlerror());\n        return JNI_FALSE;\n    }\n\n    if ((nio_sctp_bindx = (sctp_bindx_func*)\n            dlsym(RTLD_DEFAULT, \"sctp_bindx\")) == NULL) {\n        JNU_ThrowByName(env, \"java/lang/UnsupportedOperationException\",\n              dlerror());\n        return JNI_FALSE;\n    }\n\n    if ((nio_sctp_peeloff = (sctp_peeloff_func*)\n            dlsym(RTLD_DEFAULT, \"sctp_peeloff\")) == NULL) {\n        JNU_ThrowByName(env, \"java/lang/UnsupportedOperationException\",\n              dlerror());\n        return JNI_FALSE;\n    }\n#endif\n    funcsLoaded = JNI_TRUE;\n    return JNI_TRUE;\n}\n\njint\nhandleSocketError(JNIEnv *env, jint errorValue)\n{\n    char *xn;\n    switch (errorValue) {\n        case EINPROGRESS:     /* Non-blocking connect */\n            return 0;\n        case EPROTO:\n            xn= JNU_JAVANETPKG \"ProtocolException\";\n            break;\n        case ECONNREFUSED:\n            xn = JNU_JAVANETPKG \"ConnectException\";\n            break;\n        case ETIMEDOUT:\n            xn = JNU_JAVANETPKG \"ConnectException\";\n            break;\n        case EHOSTUNREACH:\n            xn = JNU_JAVANETPKG \"NoRouteToHostException\";\n            break;\n        case EADDRINUSE:  /* Fall through */\n        case EADDRNOTAVAIL:\n            xn = JNU_JAVANETPKG \"BindException\";\n            break;\n        default:\n            xn = JNU_JAVANETPKG \"SocketException\";\n            break;\n    }\n    errno = errorValue;\n    JNU_ThrowByNameWithLastError(env, xn, \"NioSocketError\");\n    return IOS_THROWN;\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    init\n * Signature: ()V\n */\nJNIEXPORT void JNICALL\nJava_sun_nio_ch_sctp_SctpNet_init\n  (JNIEnv *env, jclass cl) {\n    int sp[2];\n    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) < 0) {\n        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n        return;\n    }\n    preCloseFD = sp[0];\n    close(sp[1]);\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    socket0\n * Signature: (Z)I\n */\nJNIEXPORT jint JNICALL Java_sun_nio_ch_sctp_SctpNet_socket0\n  (JNIEnv *env, jclass klass, jboolean oneToOne) {\n    int fd;\n    struct sctp_event_subscribe event;\n#ifdef AF_INET6\n    int domain = ipv6_available() ? AF_INET6 : AF_INET;\n#else\n    int domain = AF_INET;\n#endif\n\n    /* Try to load the socket API extension functions */\n    if (!funcsLoaded && !loadSocketExtensionFuncs(env)) {\n        return 0;\n    }\n\n    fd = socket(domain, (oneToOne ? SOCK_STREAM : SOCK_SEQPACKET), IPPROTO_SCTP);\n\n    if (fd < 0) {\n        return handleSocketError(env, errno);\n    }\n\n    /* Enable events */\n    memset(&event, 0, sizeof(event));\n    event.sctp_data_io_event = 1;\n    event.sctp_association_event = 1;\n    event.sctp_address_event = 1;\n    event.sctp_send_failure_event = 1;\n    //event.sctp_peer_error_event = 1;\n    event.sctp_shutdown_event = 1;\n    //event.sctp_partial_delivery_event = 1;\n    //event.sctp_adaptation_layer_event = 1;\n    if (setsockopt(fd, IPPROTO_SCTP, SCTP_EVENTS, &event, sizeof(event)) != 0) {\n       handleSocketError(env, errno);\n    }\n    return fd;\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    bindx\n * Signature: (I[Ljava/net/InetAddress;IIZ)V\n */\nJNIEXPORT void JNICALL Java_sun_nio_ch_sctp_SctpNet_bindx\n  (JNIEnv *env, jclass klass, jint fd, jobjectArray addrs, jint port,\n   jint addrsLength, jboolean add, jboolean preferIPv6) {\n    SOCKADDR *sap, *tmpSap;\n    int i, sa_len = sizeof(SOCKADDR);\n    jobject ia;\n\n    if (addrsLength < 1)\n        return;\n\n    if ((sap = calloc(addrsLength,  sa_len)) == NULL) {\n          JNU_ThrowOutOfMemoryError(env, \"heap allocation failure\");\n        return;\n    }\n\n    tmpSap = sap;\n    for (i=0; i<addrsLength; i++) {\n        ia = (*env)->GetObjectArrayElement(env, addrs, i);\n        if (NET_InetAddressToSockaddr(env, ia, port, (struct sockaddr*)tmpSap,\n                                      &sa_len, preferIPv6) != 0) {\n            free(sap);\n            return;\n        }\n        tmpSap++;\n    }\n\n    if (nio_sctp_bindx(fd, (void*)sap, addrsLength, add ? SCTP_BINDX_ADD_ADDR :\n                       SCTP_BINDX_REM_ADDR) != 0) {\n        handleSocketError(env, errno);\n    }\n\n    free(sap);\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    listen0\n * Signature: (II)V\n */\nJNIEXPORT void JNICALL\nJava_sun_nio_ch_sctp_SctpNet_listen0\n  (JNIEnv *env, jclass cl, jint fd, jint backlog) {\n    if (listen(fd, backlog) < 0)\n        handleSocketError(env, errno);\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    connect0\n * Signature: (ILjava/net/InetAddress;I)I\n */\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_sctp_SctpNet_connect0\n  (JNIEnv *env, jclass clazz, int fd, jobject iao, jint port) {\n    SOCKADDR sa;\n    int sa_len = SOCKADDR_LEN;\n    int rv;\n\n    if (NET_InetAddressToSockaddr(env, iao, port, (struct sockaddr *) &sa,\n                                  &sa_len, JNI_TRUE) != 0) {\n        return IOS_THROWN;\n    }\n\n    rv = connect(fd, (struct sockaddr *)&sa, sa_len);\n    if (rv != 0) {\n        if (errno == EINPROGRESS) {\n            return IOS_UNAVAILABLE;\n        } else if (errno == EINTR) {\n            return IOS_INTERRUPTED;\n        }\n        return handleSocketError(env, errno);\n    }\n    return 1;\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    close0\n * Signature: (I)V\n */\nJNIEXPORT void JNICALL\nJava_sun_nio_ch_sctp_SctpNet_close0\n  (JNIEnv *env, jclass clazz, jint fd) {\n    if (fd != -1) {\n        int rv = close(fd);\n        if (rv < 0)\n            JNU_ThrowIOExceptionWithLastError(env, \"Close failed\");\n    }\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    preClose0\n * Signature: (I)V\n */\nJNIEXPORT void JNICALL\nJava_sun_nio_ch_sctp_SctpNet_preClose0\n  (JNIEnv *env, jclass clazz, jint fd) {\n    if (preCloseFD >= 0) {\n        if (dup2(preCloseFD, fd) < 0)\n            JNU_ThrowIOExceptionWithLastError(env, \"dup2 failed\");\n    }\n}\n\nvoid initializeISA\n  (JNIEnv* env) {\n    if (isaCls == 0) {\n        jclass c = (*env)->FindClass(env, \"java/net/InetSocketAddress\");\n        CHECK_NULL(c);\n        isaCtrID = (*env)->GetMethodID(env, c, \"<init>\",\n                                     \"(Ljava/net/InetAddress;I)V\");\n        CHECK_NULL(isaCtrID);\n        isaCls = (*env)->NewGlobalRef(env, c);\n        CHECK_NULL(isaCls);\n        (*env)->DeleteLocalRef(env, c);\n    }\n}\n\njobject SockAddrToInetSocketAddress\n  (JNIEnv *env, struct sockaddr* sap) {\n    int port = 0;\n\n    jobject ia = NET_SockaddrToInetAddress(env, sap, &port);\n    if (ia == NULL)\n        return NULL;\n\n    if (isaCls == 0) {\n        initializeISA(env);\n        CHECK_NULL_RETURN(isaCls, NULL);\n    }\n\n    return (*env)->NewObject(env, isaCls, isaCtrID, ia, port);\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    getLocalAddresses0\n * Signature: (I)[Ljava/net/SocketAddress;\n */\nJNIEXPORT jobjectArray JNICALL Java_sun_nio_ch_sctp_SctpNet_getLocalAddresses0\n  (JNIEnv *env, jclass klass, jint fd) {\n    void *addr_buf, *laddr;\n    struct sockaddr* sap;\n    int i, addrCount;\n    jobjectArray isaa;\n\n#ifdef __solaris__\n    if ((addrCount = nio_sctp_getladdrs(fd, 0, (void **)&addr_buf)) == -1) {\n#else /* __linux__ */\n    if ((addrCount = nio_sctp_getladdrs(fd, 0, (struct sockaddr **)&addr_buf)) == -1) {\n#endif\n        handleSocketError(env, errno);\n        return NULL;\n    }\n\n    if (addrCount < 1)\n        return NULL;\n\n    if (isaCls == 0) {\n        initializeISA(env);\n        CHECK_NULL_RETURN(isaCls, NULL);\n    }\n\n    isaa = (*env)->NewObjectArray(env, addrCount, isaCls, NULL);\n    if (isaa == NULL) {\n        nio_sctp_freeladdrs(addr_buf);\n        return NULL;\n    }\n\n    laddr = addr_buf;\n    for (i=0; i<addrCount; i++) {\n        int port = 0;\n        jobject isa = NULL, ia;\n        sap = (struct sockaddr*)addr_buf;\n        ia = NET_SockaddrToInetAddress(env, sap, &port);\n        if (ia != NULL)\n            isa = (*env)->NewObject(env, isaCls, isaCtrID, ia, port);\n        if (isa == NULL)\n            break;\n        (*env)->SetObjectArrayElement(env, isaa, i, isa);\n\n        if (sap->sa_family == AF_INET)\n            addr_buf = ((struct sockaddr_in*)addr_buf) + 1;\n        else\n            addr_buf = ((struct sockaddr_in6*)addr_buf) + 1;\n    }\n\n    nio_sctp_freeladdrs(laddr);\n    return isaa;\n}\n\njobjectArray getRemoteAddresses\n  (JNIEnv *env, jint fd, sctp_assoc_t id) {\n    void *addr_buf, *paddr;\n    struct sockaddr* sap;\n    int i, addrCount;\n    jobjectArray isaa;\n\n#if __solaris__\n    if ((addrCount = nio_sctp_getpaddrs(fd, id, (void **)&addr_buf)) == -1) {\n#else /* __linux__ */\n    if ((addrCount = nio_sctp_getpaddrs(fd, id, (struct sockaddr**)&addr_buf)) == -1) {\n#endif\n        handleSocketError(env, errno);\n        return NULL;\n    }\n\n    if (addrCount < 1)\n        return NULL;\n\n    if (isaCls == 0) {\n        initializeISA(env);\n        CHECK_NULL_RETURN(isaCls, NULL);\n    }\n\n    isaa = (*env)->NewObjectArray(env, addrCount, isaCls, NULL);\n    if (isaa == NULL) {\n        nio_sctp_freepaddrs(addr_buf);\n        return NULL;\n    }\n\n    paddr = addr_buf;\n    for (i=0; i<addrCount; i++) {\n        jobject ia, isa = NULL;\n        int port;\n        sap = (struct sockaddr*)addr_buf;\n        ia = NET_SockaddrToInetAddress(env, sap, &port);\n        if (ia != NULL)\n            isa = (*env)->NewObject(env, isaCls, isaCtrID, ia, port);\n        if (isa == NULL)\n            break;\n        (*env)->SetObjectArrayElement(env, isaa, i, isa);\n\n        if (sap->sa_family == AF_INET)\n            addr_buf = ((struct sockaddr_in*)addr_buf) + 1;\n        else\n            addr_buf = ((struct sockaddr_in6*)addr_buf) + 1;\n    }\n\n    nio_sctp_freepaddrs(paddr);\n\n    return isaa;\n}\n\n /*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    getRemoteAddresses0\n * Signature: (II)[Ljava/net/SocketAddress;\n */\nJNIEXPORT jobjectArray JNICALL Java_sun_nio_ch_sctp_SctpNet_getRemoteAddresses0\n  (JNIEnv *env, jclass klass, jint fd, jint assocId) {\n    return getRemoteAddresses(env, fd, assocId);\n}\n\n/* Map the Java level option to the native level */\nint mapSocketOption\n  (jint cmd, int *level, int *optname) {\n    static struct {\n        jint cmd;\n        int level;\n        int optname;\n    } const opts[] = {\n        { sun_nio_ch_sctp_SctpStdSocketOption_SCTP_DISABLE_FRAGMENTS,   IPPROTO_SCTP, SCTP_DISABLE_FRAGMENTS },\n        { sun_nio_ch_sctp_SctpStdSocketOption_SCTP_EXPLICIT_COMPLETE,   IPPROTO_SCTP, SCTP_EXPLICIT_EOR },\n        { sun_nio_ch_sctp_SctpStdSocketOption_SCTP_FRAGMENT_INTERLEAVE, IPPROTO_SCTP, SCTP_FRAGMENT_INTERLEAVE },\n        { sun_nio_ch_sctp_SctpStdSocketOption_SCTP_NODELAY,             IPPROTO_SCTP, SCTP_NODELAY },\n        { sun_nio_ch_sctp_SctpStdSocketOption_SO_SNDBUF,                SOL_SOCKET,   SO_SNDBUF },\n        { sun_nio_ch_sctp_SctpStdSocketOption_SO_RCVBUF,                SOL_SOCKET,   SO_RCVBUF },\n        { sun_nio_ch_sctp_SctpStdSocketOption_SO_LINGER,                SOL_SOCKET,   SO_LINGER } };\n\n    int i;\n    for (i=0; i<(int)(sizeof(opts) / sizeof(opts[0])); i++) {\n        if (cmd == opts[i].cmd) {\n            *level = opts[i].level;\n            *optname = opts[i].optname;\n            return 0;\n        }\n    }\n\n    /* not found */\n    return -1;\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    setIntOption0\n * Signature: (III)V\n */\nJNIEXPORT void JNICALL Java_sun_nio_ch_sctp_SctpNet_setIntOption0\n  (JNIEnv *env, jclass klass, jint fd, jint opt, int arg) {\n    int klevel, kopt;\n    int result;\n    struct linger linger;\n    void *parg;\n    int arglen;\n\n    if (mapSocketOption(opt, &klevel, &kopt) < 0) {\n        JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"SocketException\",\n                                     \"Unsupported socket option\");\n        return;\n    }\n\n    if (opt == sun_nio_ch_sctp_SctpStdSocketOption_SO_LINGER) {\n        parg = (void *)&linger;\n        arglen = sizeof(linger);\n        if (arg >= 0) {\n            linger.l_onoff = 1;\n            linger.l_linger = arg;\n        } else {\n            linger.l_onoff = 0;\n            linger.l_linger = 0;\n        }\n    } else {\n        parg = (void *)&arg;\n        arglen = sizeof(arg);\n    }\n\n    if (NET_SetSockOpt(fd, klevel, kopt, parg, arglen) < 0) {\n        JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"SocketException\",\n                                     \"sun_nio_ch_sctp_SctpNet.setIntOption0\");\n    }\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    getIntOption0\n * Signature: (II)I\n */\nJNIEXPORT int JNICALL Java_sun_nio_ch_sctp_SctpNet_getIntOption0\n  (JNIEnv *env, jclass klass, jint fd, jint opt) {\n    int klevel, kopt;\n    int result;\n    struct linger linger;\n    void *arg;\n    int arglen;\n\n    if (mapSocketOption(opt, &klevel, &kopt) < 0) {\n        JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"SocketException\",\n                                     \"Unsupported socket option\");\n        return -1;\n    }\n\n    if (opt == sun_nio_ch_sctp_SctpStdSocketOption_SO_LINGER) {\n        arg = (void *)&linger;\n        arglen = sizeof(linger);\n    } else {\n        arg = (void *)&result;\n        arglen = sizeof(result);\n    }\n\n    if (NET_GetSockOpt(fd, klevel, kopt, arg, &arglen) < 0) {\n        JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"SocketException\",\n                                     \"sun.nio.ch.Net.getIntOption\");\n        return -1;\n    }\n\n    if (opt == sun_nio_ch_sctp_SctpStdSocketOption_SO_LINGER)\n        return linger.l_onoff ? linger.l_linger : -1;\n    else\n        return result;\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    getPrimAddrOption0\n * Signature: (II)Ljava/net/SocketAddress;\n */\nJNIEXPORT jobject JNICALL Java_sun_nio_ch_sctp_SctpNet_getPrimAddrOption0\n  (JNIEnv *env, jclass klass, jint fd, jint assocId) {\n    struct sctp_setprim prim;\n    unsigned int prim_len = sizeof(prim);\n    struct sockaddr* sap = (struct sockaddr*)&prim.ssp_addr;\n\n    prim.ssp_assoc_id = assocId;\n\n    if (getsockopt(fd, IPPROTO_SCTP, SCTP_PRIMARY_ADDR, &prim, &prim_len) < 0) {\n        JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"SocketException\",\n                                     \"sun.nio.ch.SctpNet.getPrimAddrOption0\");\n        return NULL;\n    }\n\n    return SockAddrToInetSocketAddress(env, sap);\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    setPrimAddrOption0\n * Signature: (IILjava/net/InetAddress;I)V\n */\nJNIEXPORT void JNICALL Java_sun_nio_ch_sctp_SctpNet_setPrimAddrOption0\n  (JNIEnv *env, jclass klass, jint fd, jint assocId, jobject iaObj, jint port) {\n    struct sctp_setprim prim;\n    struct sockaddr* sap = (struct sockaddr*)&prim.ssp_addr;\n    int sap_len;\n\n    if (NET_InetAddressToSockaddr(env, iaObj, port, sap,\n                                  &sap_len, JNI_TRUE) != 0) {\n        return;\n    }\n\n    prim.ssp_assoc_id = assocId;\n\n    if (setsockopt(fd, IPPROTO_SCTP, SCTP_PRIMARY_ADDR, &prim, sizeof(prim)) < 0) {\n        JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"SocketException\",\n                                     \"sun.nio.ch.SctpNet.setPrimAddrOption0\");\n    }\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    setPeerPrimAddrOption0\n * Signature: (IILjava/net/InetAddress;I)V\n */\nJNIEXPORT void JNICALL Java_sun_nio_ch_sctp_SctpNet_setPeerPrimAddrOption0\n  (JNIEnv *env, jclass klass, jint fd, jint assocId,\n   jobject iaObj, jint port, jboolean preferIPv6) {\n    struct sctp_setpeerprim prim;\n    struct sockaddr* sap = (struct sockaddr*)&prim.sspp_addr;\n    int sap_len;\n\n    if (NET_InetAddressToSockaddr(env, iaObj, port, sap,\n                                  &sap_len, preferIPv6) != 0) {\n        return;\n    }\n\n    prim.sspp_assoc_id = assocId;\n\n    if (setsockopt(fd, IPPROTO_SCTP, SCTP_SET_PEER_PRIMARY_ADDR, &prim,\n            sizeof(prim)) < 0) {\n        JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"SocketException\",\n                                     \"sun.nio.ch.SctpNet.setPeerPrimAddrOption0\");\n    }\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    getInitMsgOption0\n * Signature: (I[I)V\n */\nJNIEXPORT void JNICALL Java_sun_nio_ch_sctp_SctpNet_getInitMsgOption0\n  (JNIEnv *env, jclass klass, jint fd, jintArray retVal) {\n    struct sctp_initmsg sctp_initmsg;\n    unsigned int sim_len = sizeof(sctp_initmsg);\n    int vals[2];\n\n    if (getsockopt(fd, IPPROTO_SCTP, SCTP_INITMSG, &sctp_initmsg,\n            &sim_len) < 0) {\n        JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"SocketException\",\n                                     \"sun.nio.ch.SctpNet.getInitMsgOption0\");\n        return;\n    }\n\n    vals[0] = sctp_initmsg.sinit_max_instreams;\n    vals[1] = sctp_initmsg.sinit_num_ostreams;\n    (*env)->SetIntArrayRegion(env, retVal, 0, 2, vals);\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    setInitMsgOption0\n * Signature: (III)V\n */\nJNIEXPORT void JNICALL Java_sun_nio_ch_sctp_SctpNet_setInitMsgOption0\n  (JNIEnv *env, jclass klass, jint fd, jint inArg, jint outArg) {\n    struct sctp_initmsg sctp_initmsg;\n\n    sctp_initmsg.sinit_max_instreams = (unsigned int)inArg;\n    sctp_initmsg.sinit_num_ostreams = (unsigned int)outArg;\n    sctp_initmsg.sinit_max_attempts = 0;  // default\n    sctp_initmsg.sinit_max_init_timeo = 0;  // default\n\n    if (setsockopt(fd, IPPROTO_SCTP, SCTP_INITMSG, &sctp_initmsg,\n          sizeof(sctp_initmsg)) < 0) {\n        JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"SocketException\",\n                                     \"sun.nio.ch.SctpNet.setInitMsgOption0\");\n    }\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    shutdown0\n * Signature: (II)V\n */\nJNIEXPORT void JNICALL Java_sun_nio_ch_sctp_SctpNet_shutdown0\n  (JNIEnv *env, jclass klass, jint fd, jint assocId) {\n    int rv;\n    struct msghdr msg[1];\n    struct iovec iov[1];\n    int cbuf_size = CMSG_SPACE(sizeof (struct sctp_sndrcvinfo));\n    char cbuf[CMSG_SPACE(sizeof (struct sctp_sndrcvinfo))];\n    struct cmsghdr* cmsg;\n    struct sctp_sndrcvinfo *sri;\n\n    /* SctpSocketChannel */\n    if (assocId < 0) {\n        shutdown(fd, SHUT_WR);\n        return;\n    }\n\n    memset(msg, 0, sizeof (*msg));\n    memset(cbuf, 0, cbuf_size);\n    msg->msg_name = NULL;\n    msg->msg_namelen = 0;\n    iov->iov_base = NULL;\n    iov->iov_len = 0;\n    msg->msg_iov = iov;\n    msg->msg_iovlen = 1;\n    msg->msg_control = cbuf;\n    msg->msg_controllen = cbuf_size;\n    msg->msg_flags = 0;\n\n    cmsg = CMSG_FIRSTHDR(msg);\n    cmsg->cmsg_level = IPPROTO_SCTP;\n    cmsg->cmsg_type = SCTP_SNDRCV;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\n\n    /* Initialize the payload: */\n    sri = (struct sctp_sndrcvinfo*) CMSG_DATA(cmsg);\n    memset(sri, 0, sizeof (*sri));\n\n    if (assocId > 0) {\n        sri->sinfo_assoc_id = assocId;\n    }\n\n    sri->sinfo_flags = sri->sinfo_flags | SCTP_EOF;\n\n    /* Sum of the length of all control messages in the buffer. */\n    msg->msg_controllen = cmsg->cmsg_len;\n\n    if ((rv = sendmsg(fd, msg, 0)) < 0) {\n        handleSocketError(env, errno);\n    }\n}\n\n/*\n * Class:     sun_nio_ch_sctp_SctpNet\n * Method:    branch\n * Signature: (II)I\n */\nJNIEXPORT int JNICALL Java_sun_nio_ch_sctp_SctpNet_branch0\n  (JNIEnv *env, jclass klass, jint fd, jint assocId) {\n    int newfd = 0;\n    if ((newfd = nio_sctp_peeloff(fd, assocId)) < 0) {\n        handleSocketError(env, errno);\n    }\n\n    return newfd;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/java2d/x11/X11SurfaceData.c": "/*\n * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"X11SurfaceData.h\"\n#include \"GraphicsPrimitiveMgr.h\"\n#include \"Region.h\"\n#include \"Trace.h\"\n\n/* Needed to define intptr_t */\n#include \"gdefs.h\"\n\n#include \"jni_util.h\"\n#include \"jvm_md.h\"\n#include \"awt_Component.h\"\n#include \"awt_GraphicsEnv.h\"\n\n#include <dlfcn.h>\n\n#ifndef HEADLESS\nstatic JDgaLibInfo DgaLibInfoStub;\nstatic JDgaLibInfo theJDgaInfo;\nstatic JDgaLibInfo *pJDgaInfo = &DgaLibInfoStub;\n\n\n/**\n * This file contains support code for loops using the SurfaceData\n * interface to talk to an X11 drawable from native code.\n */\n\ntypedef struct _X11RIPrivate {\n    jint                lockType;\n    jint                lockFlags;\n    XImage              *img;\n    int                 x, y;\n} X11RIPrivate;\n\n#define XSD_MAX(a,b) ((a) > (b) ? (a) : (b))\n#define XSD_MIN(a,b) ((a) < (b) ? (a) : (b))\n\nstatic LockFunc X11SD_Lock;\nstatic GetRasInfoFunc X11SD_GetRasInfo;\nstatic UnlockFunc X11SD_Unlock;\nstatic DisposeFunc X11SD_Dispose;\nstatic GetPixmapBgFunc X11SD_GetPixmapWithBg;\nstatic ReleasePixmapBgFunc X11SD_ReleasePixmapWithBg;\nextern int XShmAttachXErrHandler(Display *display, XErrorEvent *xerr);\nextern AwtGraphicsConfigDataPtr\n    getGraphicsConfigFromComponentPeer(JNIEnv *env, jobject this);\nextern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;\n\nstatic int X11SD_FindClip(SurfaceDataBounds *b, SurfaceDataBounds *bounds,\n                          X11SDOps *xsdo);\nstatic int X11SD_ClipToRoot(SurfaceDataBounds *b, SurfaceDataBounds *bounds,\n                            X11SDOps *xsdo);\nstatic void X11SD_SwapBytes(X11SDOps *xsdo, XImage *img, int depth, int bpp);\nstatic XImage * X11SD_GetImage(JNIEnv *env, X11SDOps *xsdo,\n                               SurfaceDataBounds *bounds,\n                               jint lockFlags);\n\nextern jfieldID validID;\n\nstatic int nativeByteOrder;\nstatic jboolean dgaAvailable = JNI_FALSE;\nstatic jboolean useDGAWithPixmaps = JNI_FALSE;\nstatic jclass xorCompClass;\n\njint useMitShmExt = CANT_USE_MITSHM;\njint useMitShmPixmaps = CANT_USE_MITSHM;\njint forceSharedPixmaps = JNI_FALSE;\nint mitShmPermissionMask = MITSHM_PERM_OWNER;\n\n/* Cached shared image, one for all surface datas. */\nstatic XImage * cachedXImage;\n\n#endif /* !HEADLESS */\n\njboolean XShared_initIDs(JNIEnv *env, jboolean allowShmPixmaps)\n{\n#ifndef HEADLESS\n   union {\n        char c[4];\n        int i;\n    } endian;\n\n    endian.i = 0xff000000;\n    nativeByteOrder = (endian.c[0]) ? MSBFirst : LSBFirst;\n\n    dgaAvailable = JNI_FALSE;\n\n    cachedXImage = NULL;\n\n    if (sizeof(X11RIPrivate) > SD_RASINFO_PRIVATE_SIZE) {\n        JNU_ThrowInternalError(env, \"Private RasInfo structure too large!\");\n        return JNI_FALSE;\n    }\n\n#ifdef MITSHM\n    if (getenv(\"NO_AWT_MITSHM\") == NULL &&\n        getenv(\"NO_J2D_MITSHM\") == NULL) {\n        char * force;\n        char * permission = getenv(\"J2D_MITSHM_PERMISSION\");\n        if (permission != NULL) {\n            if (strcmp(permission, \"common\") == 0) {\n                mitShmPermissionMask = MITSHM_PERM_COMMON;\n            }\n        }\n\n        TryInitMITShm(env, &useMitShmExt, &useMitShmPixmaps);\n\n        if(allowShmPixmaps) {\n          useMitShmPixmaps = (useMitShmPixmaps == CAN_USE_MITSHM);\n          force = getenv(\"J2D_PIXMAPS\");\n          if (force != NULL) {\n              if (useMitShmPixmaps && (strcmp(force, \"shared\") == 0)) {\n                  forceSharedPixmaps = JNI_TRUE;\n              } else if (strcmp(force, \"server\") == 0) {\n                  useMitShmPixmaps = JNI_FALSE;\n              }\n          }\n        }else {\n          useMitShmPixmaps = JNI_FALSE;\n        }\n    }\n#endif /* MITSHM */\n\n#endif /* !HEADLESS */\n\n    return JNI_TRUE;\n}\n\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    initIDs\n * Signature: (Ljava/lang/Class;Z)V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_X11SurfaceData_initIDs(JNIEnv *env, jclass xsd,\n                                           jclass XORComp, jboolean tryDGA)\n{\n#ifndef HEADLESS\n  if(XShared_initIDs(env, JNI_TRUE))\n  {\n    void *lib = 0;\n\n    xorCompClass = (*env)->NewGlobalRef(env, XORComp);\n\n    if (tryDGA && (getenv(\"NO_J2D_DGA\") == NULL)) {\n    /* we use RTLD_NOW because of bug 4032715 */\n        lib = dlopen(JNI_LIB_NAME(\"sunwjdga\"), RTLD_NOW);\n    }\n\n    if (lib != NULL) {\n        JDgaStatus ret = JDGA_FAILED;\n        void *sym = dlsym(lib, \"JDgaLibInit\");\n        if (sym != NULL) {\n            theJDgaInfo.display = awt_display;\n            AWT_LOCK();\n            ret = (*(JDgaLibInitFunc *)sym)(env, &theJDgaInfo);\n            AWT_UNLOCK();\n        }\n        if (ret == JDGA_SUCCESS) {\n            pJDgaInfo = &theJDgaInfo;\n            dgaAvailable = JNI_TRUE;\n            useDGAWithPixmaps = (getenv(\"USE_DGA_PIXMAPS\") != NULL);\n        } else {\n            dlclose(lib);\n            lib = NULL;\n        }\n    }\n  }\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    isDrawableValid\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_java2d_x11_XSurfaceData_isDrawableValid(JNIEnv *env, jobject this)\n{\n    jboolean ret = JNI_FALSE;\n\n#ifndef HEADLESS\n    X11SDOps *xsdo = X11SurfaceData_GetOps(env, this);\n\n    AWT_LOCK();\n    if (xsdo->drawable != 0 || X11SD_InitWindow(env, xsdo) == SD_SUCCESS) {\n        ret = JNI_TRUE;\n    }\n    AWT_UNLOCK();\n#endif /* !HEADLESS */\n\n    return ret;\n}\n\n/*\n * Class: sun_java2d_x11_X11SurfaceData\n * Method: isShmPMAvailable\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_java2d_x11_X11SurfaceData_isShmPMAvailable(JNIEnv *env, jobject this)\n{\n#if defined(HEADLESS) || !defined(MITSHM)\n    return JNI_FALSE;\n#else\n    return (jboolean)useMitShmPixmaps;\n#endif /* HEADLESS, MITSHM */\n}\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    isDgaAvailable\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_java2d_x11_X11SurfaceData_isDgaAvailable(JNIEnv *env, jobject this)\n{\n#if defined(HEADLESS) || defined(__linux__)\n    return JNI_FALSE;\n#else\n    return dgaAvailable;\n#endif /* HEADLESS */\n}\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    initOps\n * Signature: (Ljava/lang/Object;I)V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_XSurfaceData_initOps(JNIEnv *env, jobject xsd,\n                                           jobject peer,\n                                           jobject graphicsConfig, jint depth)\n{\n#ifndef HEADLESS\n    X11SDOps *xsdo = (X11SDOps*)SurfaceData_InitOps(env, xsd, sizeof(X11SDOps));\n    jboolean hasException;\n    if (xsdo == NULL) {\n        JNU_ThrowOutOfMemoryError(env, \"Initialization of SurfaceData failed.\");\n        return;\n    }\n    xsdo->sdOps.Lock = X11SD_Lock;\n    xsdo->sdOps.GetRasInfo = X11SD_GetRasInfo;\n    xsdo->sdOps.Unlock = X11SD_Unlock;\n    xsdo->sdOps.Dispose = X11SD_Dispose;\n    xsdo->GetPixmapWithBg = X11SD_GetPixmapWithBg;\n    xsdo->ReleasePixmapWithBg = X11SD_ReleasePixmapWithBg;\n    xsdo->widget = NULL;\n    if (peer != NULL) {\n        xsdo->drawable = JNU_CallMethodByName(env, &hasException, peer, \"getWindow\", \"()J\").j;\n        if (hasException) {\n            return;\n        }\n    } else {\n        xsdo->drawable = 0;\n    }\n    xsdo->depth = depth;\n    xsdo->dgaAvailable = dgaAvailable;\n    xsdo->isPixmap = JNI_FALSE;\n    xsdo->bitmask = 0;\n    xsdo->bgPixel = 0;\n    xsdo->isBgInitialized = JNI_FALSE;\n#ifdef MITSHM\n    xsdo->shmPMData.shmSegInfo = NULL;\n    xsdo->shmPMData.xRequestSent = JNI_FALSE;\n    xsdo->shmPMData.pmSize = 0;\n    xsdo->shmPMData.usingShmPixmap = JNI_FALSE;\n    xsdo->shmPMData.pixmap = 0;\n    xsdo->shmPMData.shmPixmap = 0;\n    xsdo->shmPMData.numBltsSinceRead = 0;\n    xsdo->shmPMData.pixelsReadSinceBlt = 0;\n    xsdo->shmPMData.numBltsThreshold = 2;\n#endif /* MITSHM */\n\n    xsdo->configData = (AwtGraphicsConfigDataPtr)\n        JNU_GetLongFieldAsPtr(env,\n                              graphicsConfig,\n                              x11GraphicsConfigIDs.aData);\n    if (xsdo->configData == NULL) {\n        JNU_ThrowNullPointerException(env,\n                                      \"Native GraphicsConfig data block missing\");\n        return;\n    }\n    if (depth > 12) {\n        xsdo->pixelmask = (xsdo->configData->awt_visInfo.red_mask |\n                           xsdo->configData->awt_visInfo.green_mask |\n                           xsdo->configData->awt_visInfo.blue_mask);\n    } else if (depth == 12) {\n        xsdo->pixelmask = 0xfff;\n    } else {\n        xsdo->pixelmask = 0xff;\n    }\n\n    xsdo->xrPic = None;\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    flushNativeSurface\n * Signature: ()V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_XSurfaceData_flushNativeSurface(JNIEnv *env, jobject xsd)\n{\n#ifndef HEADLESS\n    SurfaceDataOps *ops = SurfaceData_GetOps(env, xsd);\n\n    if (ops != NULL) {\n        X11SD_Dispose(env, ops);\n    }\n#endif /* !HEADLESS */\n}\n\n\nJNIEXPORT X11SDOps * JNICALL\nX11SurfaceData_GetOps(JNIEnv *env, jobject sData)\n{\n#ifdef HEADLESS\n    return NULL;\n#else\n    SurfaceDataOps *ops = SurfaceData_GetOps(env, sData);\n    if (ops != NULL && ops->Lock != X11SD_Lock) {\n        SurfaceData_ThrowInvalidPipeException(env, \"not an X11 SurfaceData\");\n        ops = NULL;\n    }\n    return (X11SDOps *) ops;\n#endif /* !HEADLESS */\n}\n\n/*\n * Method for disposing X11SD-specific data\n */\nstatic void\nX11SD_Dispose(JNIEnv *env, SurfaceDataOps *ops)\n{\n#ifndef HEADLESS\n    /* ops is assumed non-null as it is checked in SurfaceData_DisposeOps */\n    X11SDOps * xsdo = (X11SDOps*)ops;\n\n    AWT_LOCK();\n\n    xsdo->invalid = JNI_TRUE;\n\n    if (xsdo->xrPic != None) {\n        XRenderFreePicture(awt_display, xsdo->xrPic);\n        xsdo->xrPic = None;\n     }\n\n    if (xsdo->isPixmap == JNI_TRUE && xsdo->drawable != 0) {\n#ifdef MITSHM\n        if (xsdo->shmPMData.shmSegInfo != NULL) {\n            X11SD_DropSharedSegment(xsdo->shmPMData.shmSegInfo);\n            xsdo->shmPMData.shmSegInfo = NULL;\n        }\n        if (xsdo->shmPMData.pixmap) {\n            XFreePixmap(awt_display, xsdo->shmPMData.pixmap);\n            xsdo->shmPMData.pixmap = 0;\n        }\n        if (xsdo->shmPMData.shmPixmap) {\n            XFreePixmap(awt_display, xsdo->shmPMData.shmPixmap);\n            xsdo->shmPMData.shmPixmap = 0;\n        }\n#else\n        XFreePixmap(awt_display, xsdo->drawable);\n#endif /* MITSHM */\n        xsdo->drawable = 0;\n    }\n    if (xsdo->bitmask != 0) {\n        XFreePixmap(awt_display, xsdo->bitmask);\n        xsdo->bitmask = 0;\n    }\n    if (xsdo->javaGC != NULL) {\n        XFreeGC(awt_display, xsdo->javaGC);\n        xsdo->javaGC = NULL;\n    }\n    if (xsdo->cachedGC != NULL) {\n        XFreeGC(awt_display, xsdo->cachedGC);\n        xsdo->cachedGC = NULL;\n    }\n\n    if(xsdo->xrPic != None) {\n      XRenderFreePicture(awt_display, xsdo->xrPic);\n    }\n\n    AWT_UNLOCK();\n#endif /* !HEADLESS */\n}\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    setInvalid\n * Signature: ()V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_XSurfaceData_setInvalid(JNIEnv *env, jobject xsd)\n{\n#ifndef HEADLESS\n    X11SDOps *xsdo = (X11SDOps *) SurfaceData_GetOps(env, xsd);\n\n    if (xsdo != NULL) {\n        xsdo->invalid = JNI_TRUE;\n    }\n#endif /* !HEADLESS */\n}\n\n\njboolean XShared_initSurface(JNIEnv *env, X11SDOps *xsdo, jint depth, jint width, jint height, jlong drawable)\n{\n#ifndef HEADLESS\n\n    if (drawable != (jlong)0) {\n        /* Double-buffering */\n        xsdo->drawable = drawable;\n        xsdo->isPixmap = JNI_FALSE;\n    } else {\n        /*\n         * width , height must be nonzero otherwise XCreatePixmap\n         * generates BadValue in error_handler\n         */\n        if (width <= 0 || height <= 0 || width > 32767 || height > 32767) {\n            JNU_ThrowOutOfMemoryError(env,\n                                  \"Can't create offscreen surface\");\n            return JNI_FALSE;\n        }\n        xsdo->isPixmap = JNI_TRUE;\n        /* REMIND: workaround for bug 4420220 on pgx32 boards:\n           don't use DGA with pixmaps unless USE_DGA_PIXMAPS is set.\n         */\n        xsdo->dgaAvailable = useDGAWithPixmaps;\n\n        xsdo->pmWidth = width;\n        xsdo->pmHeight = height;\n\n#ifdef MITSHM\n        xsdo->shmPMData.pmSize = width * height * depth;\n        xsdo->shmPMData.pixelsReadThreshold = width * height / 8;\n        if (forceSharedPixmaps) {\n            AWT_LOCK();\n            xsdo->drawable = X11SD_CreateSharedPixmap(xsdo);\n            AWT_UNLOCK();\n            JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n            if (xsdo->drawable) {\n                xsdo->shmPMData.usingShmPixmap = JNI_TRUE;\n                xsdo->shmPMData.shmPixmap = xsdo->drawable;\n                return JNI_TRUE;\n            }\n        }\n#endif /* MITSHM */\n\n        AWT_LOCK();\n        xsdo->drawable =\n            XCreatePixmap(awt_display,\n                          RootWindow(awt_display,\n                                     xsdo->configData->awt_visInfo.screen),\n                          width, height, depth);\n        AWT_UNLOCK();\n        JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n#ifdef MITSHM\n        xsdo->shmPMData.usingShmPixmap = JNI_FALSE;\n        xsdo->shmPMData.pixmap = xsdo->drawable;\n#endif /* MITSHM */\n    }\n    if (xsdo->drawable == 0) {\n        JNU_ThrowOutOfMemoryError(env,\n                                  \"Can't create offscreen surface\");\n        return JNI_FALSE;\n    }\n\n#endif /* !HEADLESS */\n    return JNI_TRUE;\n}\n\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    initSurface\n * Signature: ()V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_X11SurfaceData_initSurface(JNIEnv *env, jclass xsd,\n                                               jint depth,\n                                               jint width, jint height,\n                                               jlong drawable)\n{\n#ifndef HEADLESS\n    X11SDOps *xsdo = X11SurfaceData_GetOps(env, xsd);\n    if (xsdo == NULL) {\n        return;\n    }\n\n    if (xsdo->configData->awt_cmap == (Colormap)NULL) {\n        awtJNI_CreateColorData(env, xsdo->configData, 1);\n        JNU_CHECK_EXCEPTION(env);\n    }\n    /* color_data will be initialized in awtJNI_CreateColorData for\n       8-bit visuals */\n    xsdo->cData = xsdo->configData->color_data;\n\n    XShared_initSurface(env, xsdo, depth, width, height, drawable);\n    xsdo->xrPic = None;\n#endif /* !HEADLESS */\n}\n\n#ifndef HEADLESS\n\n#ifdef MITSHM\n\nvoid X11SD_DropSharedSegment(XShmSegmentInfo *shminfo)\n{\n    if (shminfo != NULL) {\n        XShmDetach(awt_display, shminfo);\n        shmdt(shminfo->shmaddr);\n/*      REMIND: we don't need shmctl(shminfo->shmid, IPC_RMID, 0); here. */\n/*      Check X11SD_CreateSharedImage() for the explanation */\n    }\n}\n\nXImage* X11SD_CreateSharedImage(X11SDOps *xsdo,\n                                   jint width, jint height)\n{\n    XImage *img = NULL;\n    XShmSegmentInfo *shminfo;\n\n    shminfo = malloc(sizeof(XShmSegmentInfo));\n    if (shminfo == NULL) {\n        return NULL;\n    }\n    memset(shminfo, 0, sizeof(XShmSegmentInfo));\n\n    img = XShmCreateImage(awt_display, xsdo->configData->awt_visInfo.visual,\n                          xsdo->depth, ZPixmap, NULL, shminfo,\n                          width, height);\n    if (img == NULL) {\n        free((void *)shminfo);\n        return NULL;\n    }\n    shminfo->shmid =\n        shmget(IPC_PRIVATE, height * img->bytes_per_line,\n               IPC_CREAT|mitShmPermissionMask);\n    if (shminfo->shmid < 0) {\n        J2dRlsTraceLn1(J2D_TRACE_ERROR,\n                       \"X11SD_SetupSharedSegment shmget has failed: %s\",\n                       strerror(errno));\n        free((void *)shminfo);\n        XDestroyImage(img);\n        return NULL;\n    }\n\n    shminfo->shmaddr = (char *) shmat(shminfo->shmid, 0, 0);\n    if (shminfo->shmaddr == ((char *) -1)) {\n        shmctl(shminfo->shmid, IPC_RMID, 0);\n        J2dRlsTraceLn1(J2D_TRACE_ERROR,\n                       \"X11SD_SetupSharedSegment shmat has failed: %s\",\n                       strerror(errno));\n        free((void *)shminfo);\n        XDestroyImage(img);\n        return NULL;\n    }\n\n    shminfo->readOnly = False;\n\n    resetXShmAttachFailed();\n    EXEC_WITH_XERROR_HANDLER(XShmAttachXErrHandler,\n                             XShmAttach(awt_display, shminfo));\n\n    /*\n     * Once the XSync round trip has finished then we\n     * can get rid of the id so that this segment does not stick\n     * around after we go away, holding system resources.\n     */\n    shmctl(shminfo->shmid, IPC_RMID, 0);\n\n    if (isXShmAttachFailed() == JNI_TRUE) {\n        J2dRlsTraceLn1(J2D_TRACE_ERROR,\n                       \"X11SD_SetupSharedSegment XShmAttach has failed: %s\",\n                       strerror(errno));\n        shmdt(shminfo->shmaddr);\n        free((void *)shminfo);\n        XDestroyImage(img);\n        return NULL;\n    }\n\n    img->data = shminfo->shmaddr;\n    img->obdata = (char *)shminfo;\n\n    return img;\n}\n\nXImage* X11SD_GetSharedImage(X11SDOps *xsdo, jint width, jint height,\n                             jint maxWidth, jint maxHeight, jboolean readBits)\n{\n    XImage * retImage = NULL;\n    if (cachedXImage != NULL &&\n        X11SD_CachedXImageFits(width, height, maxWidth, maxHeight,\n                               xsdo->depth, readBits)) {\n        /* sync so previous data gets flushed */\n        XSync(awt_display, False);\n        retImage = cachedXImage;\n        cachedXImage = (XImage *)NULL;\n    } else if (width * height * xsdo->depth > 0x10000) {\n        retImage = X11SD_CreateSharedImage(xsdo, width, height);\n    }\n    return retImage;\n}\n\nDrawable X11SD_CreateSharedPixmap(X11SDOps *xsdo)\n{\n    XShmSegmentInfo *shminfo;\n    XImage *img = NULL;\n    Drawable pixmap;\n    int scan;\n    int width = xsdo->pmWidth;\n    int height = xsdo->pmHeight;\n\n    if (xsdo->shmPMData.pmSize < 0x10000) {\n        /* only use shared mem pixmaps for relatively big images */\n        return 0;\n    }\n\n    /* need to create shared(!) image to get bytes_per_line */\n    img = X11SD_CreateSharedImage(xsdo, width, height);\n    if (img == NULL) {\n        return 0;\n    }\n    scan = img->bytes_per_line;\n    shminfo = (XShmSegmentInfo*)img->obdata;\n    XFree(img);\n\n    pixmap =\n        XShmCreatePixmap(awt_display,\n                         RootWindow(awt_display,\n                                    xsdo->configData->awt_visInfo.screen),\n                         shminfo->shmaddr, shminfo,\n                         width, height, xsdo->depth);\n    if (pixmap == 0) {\n        X11SD_DropSharedSegment(shminfo);\n        return 0;\n    }\n\n    xsdo->shmPMData.shmSegInfo = shminfo;\n    xsdo->shmPMData.bytesPerLine = scan;\n    return pixmap;\n}\n\nvoid X11SD_PuntPixmap(X11SDOps *xsdo, jint width, jint height)\n{\n\n    if (useMitShmPixmaps != CAN_USE_MITSHM || forceSharedPixmaps) {\n        return;\n    }\n\n    /* we wouldn't be here if it's a shared pixmap, so no check\n     * for !usingShmPixmap.\n     */\n\n    xsdo->shmPMData.numBltsSinceRead = 0;\n\n    xsdo->shmPMData.pixelsReadSinceBlt += width * height;\n    if (xsdo->shmPMData.pixelsReadSinceBlt >\n        xsdo->shmPMData.pixelsReadThreshold) {\n        if (!xsdo->shmPMData.shmPixmap) {\n            xsdo->shmPMData.shmPixmap =\n                X11SD_CreateSharedPixmap(xsdo);\n        }\n        if (xsdo->shmPMData.shmPixmap) {\n            GC xgc = XCreateGC(awt_display, xsdo->shmPMData.shmPixmap, 0L, NULL);\n            if (xgc != NULL) {\n                xsdo->shmPMData.usingShmPixmap = JNI_TRUE;\n                xsdo->drawable = xsdo->shmPMData.shmPixmap;\n                XCopyArea(awt_display,\n                          xsdo->shmPMData.pixmap, xsdo->drawable, xgc,\n                          0, 0, xsdo->pmWidth, xsdo->pmHeight, 0, 0);\n                XSync(awt_display, False);\n                xsdo->shmPMData.xRequestSent = JNI_FALSE;\n                XFreeGC(awt_display, xgc);\n            }\n        }\n    }\n}\n\nvoid X11SD_UnPuntPixmap(X11SDOps *xsdo)\n{\n    if (useMitShmPixmaps != CAN_USE_MITSHM || forceSharedPixmaps) {\n        return;\n    }\n    xsdo->shmPMData.pixelsReadSinceBlt = 0;\n    if (xsdo->shmPMData.numBltsSinceRead >=\n        xsdo->shmPMData.numBltsThreshold)\n    {\n        if (xsdo->shmPMData.usingShmPixmap) {\n            if (!xsdo->shmPMData.pixmap) {\n                xsdo->shmPMData.pixmap =\n                    XCreatePixmap(awt_display,\n                                  RootWindow(awt_display,\n                                             xsdo->configData->awt_visInfo.screen),\n                                  xsdo->pmWidth, xsdo->pmHeight, xsdo->depth);\n            }\n            if (xsdo->shmPMData.pixmap) {\n                GC xgc = XCreateGC(awt_display, xsdo->shmPMData.pixmap, 0L, NULL);\n                if (xgc != NULL) {\n                    xsdo->drawable = xsdo->shmPMData.pixmap;\n                    XCopyArea(awt_display,\n                              xsdo->shmPMData.shmPixmap, xsdo->drawable, xgc,\n                              0, 0, xsdo->pmWidth, xsdo->pmHeight, 0, 0);\n                    XSync(awt_display, False);\n                    XFreeGC(awt_display, xgc);\n                    xsdo->shmPMData.xRequestSent = JNI_FALSE;\n                    xsdo->shmPMData.usingShmPixmap = JNI_FALSE;\n                    xsdo->shmPMData.numBltsThreshold *= 2;\n                }\n            }\n        }\n    } else {\n        xsdo->shmPMData.numBltsSinceRead++;\n    }\n}\n\n/**\n * Determines if the cached image can be used for current operation.\n * If the image is to be used to be read into by XShmGetImage,\n * it must be close enough to avoid excessive reading from the screen;\n * otherwise it should just be at least the size requested.\n */\njboolean X11SD_CachedXImageFits(jint width, jint height, jint maxWidth,\n                                jint maxHeight, jint depth, jboolean readBits)\n{\n    /* we assume here that the cached image exists */\n    jint imgWidth = cachedXImage->width;\n    jint imgHeight = cachedXImage->height;\n\n    if (imgWidth < width || imgHeight < height || depth != cachedXImage->depth)  {\n        /* doesn't fit if any of the cached image dimensions is smaller\n           or the depths are different */\n        return JNI_FALSE;\n    }\n\n    if (!readBits) {\n        /* Not reading from this image, so any image at least of the\n           size requested will do */\n        return JNI_TRUE;\n    }\n\n    if ((imgWidth < width + 64) && (imgHeight < height + 64)\n         && imgWidth <= maxWidth && imgHeight <= maxHeight)\n    {\n        /* Cached image's width/height shouldn't be more than 64 pixels\n         * larger than requested, because the region in XShmGetImage\n         * can't be specified and we don't want to read too much.\n         * Furthermore it has to be smaller than maxWidth/Height\n         * so drawables are not read out of bounds.\n         */\n        return JNI_TRUE;\n    }\n\n    return JNI_FALSE;\n}\n#endif /* MITSHM */\n\njint X11SD_InitWindow(JNIEnv *env, X11SDOps *xsdo)\n{\n    if (xsdo->isPixmap == JNI_TRUE) {\n        return SD_FAILURE;\n    }\n    xsdo->cData = xsdo->configData->color_data;\n\n    return SD_SUCCESS;\n}\n\nstatic jint X11SD_Lock(JNIEnv *env,\n                       SurfaceDataOps *ops,\n                       SurfaceDataRasInfo *pRasInfo,\n                       jint lockflags)\n{\n    X11SDOps *xsdo = (X11SDOps *) ops;\n    X11RIPrivate *xpriv = (X11RIPrivate *) &(pRasInfo->priv);\n    int ret = SD_SUCCESS;\n\n    AWT_LOCK();\n\n    if (xsdo->invalid) {\n        AWT_UNLOCK();\n        SurfaceData_ThrowInvalidPipeException(env, \"bounds changed\");\n        return SD_FAILURE;\n    }\n    xsdo->cData = xsdo->configData->color_data;\n    if (xsdo->drawable == 0 && X11SD_InitWindow(env, xsdo) == SD_FAILURE) {\n        AWT_UNLOCK();\n        return SD_FAILURE;\n    }\n    if ((lockflags & SD_LOCK_LUT) != 0 &&\n        (xsdo->cData == NULL ||\n         xsdo->cData->awt_icmLUT == NULL))\n    {\n        AWT_UNLOCK();\n        if (!(*env)->ExceptionCheck(env))\n        {\n             JNU_ThrowNullPointerException(env, \"colormap lookup table\");\n        }\n        return SD_FAILURE;\n    }\n    if ((lockflags & SD_LOCK_INVCOLOR) != 0 &&\n        (xsdo->cData == NULL ||\n         xsdo->cData->img_clr_tbl == NULL ||\n         xsdo->cData->img_oda_red == NULL ||\n         xsdo->cData->img_oda_green == NULL ||\n         xsdo->cData->img_oda_blue == NULL))\n    {\n        AWT_UNLOCK();\n        if (!(*env)->ExceptionCheck(env))\n        {\n             JNU_ThrowNullPointerException(env, \"inverse colormap lookup table\");\n        }\n        return SD_FAILURE;\n    }\n    if ((lockflags & SD_LOCK_INVGRAY) != 0 &&\n        (xsdo->cData == NULL ||\n         xsdo->cData->pGrayInverseLutData == NULL))\n    {\n        AWT_UNLOCK();\n        if (!(*env)->ExceptionCheck(env))\n        {\n            JNU_ThrowNullPointerException(env, \"inverse gray lookup table\");\n        }\n        return SD_FAILURE;\n    }\n    if (xsdo->dgaAvailable && (lockflags & (SD_LOCK_RD_WR))) {\n        int dgaret;\n\n        dgaret = (*pJDgaInfo->pGetLock)(env, awt_display, &xsdo->dgaDev,\n                                        xsdo->drawable, &xsdo->surfInfo,\n                                        pRasInfo->bounds.x1,\n                                        pRasInfo->bounds.y1,\n                                        pRasInfo->bounds.x2,\n                                        pRasInfo->bounds.y2);\n        if (dgaret == JDGA_SUCCESS) {\n            int wx = xsdo->surfInfo.window.lox;\n            int wy = xsdo->surfInfo.window.loy;\n            pRasInfo->bounds.x1 = xsdo->surfInfo.visible.lox - wx;\n            pRasInfo->bounds.y1 = xsdo->surfInfo.visible.loy - wy;\n            pRasInfo->bounds.x2 = xsdo->surfInfo.visible.hix - wx;\n            pRasInfo->bounds.y2 = xsdo->surfInfo.visible.hiy - wy;\n            xpriv->lockType = X11SD_LOCK_BY_DGA;\n            xpriv->lockFlags = lockflags;\n            return SD_SUCCESS;\n        } else if (dgaret == JDGA_UNAVAILABLE) {\n            xsdo->dgaAvailable = JNI_FALSE;\n        }\n    }\n    if (lockflags & SD_LOCK_RD_WR) {\n        if (lockflags & SD_LOCK_FASTEST) {\n            ret = SD_SLOWLOCK;\n        }\n        xpriv->lockType = X11SD_LOCK_BY_XIMAGE;\n        if (xsdo->isPixmap) {\n#ifdef MITSHM\n            if (xsdo->shmPMData.usingShmPixmap) {\n                xpriv->lockType = X11SD_LOCK_BY_SHMEM;\n            }\n#endif /* MITSHM */\n            if (pRasInfo->bounds.x1 < 0) {\n                pRasInfo->bounds.x1 = 0;\n            }\n            if (pRasInfo->bounds.y1 < 0) {\n                pRasInfo->bounds.y1 = 0;\n            }\n            if (pRasInfo->bounds.x2 > xsdo->pmWidth) {\n                pRasInfo->bounds.x2 = xsdo->pmWidth;\n            }\n            if (pRasInfo->bounds.y2 > xsdo->pmHeight) {\n                pRasInfo->bounds.y2 = xsdo->pmHeight;\n            }\n        }\n    } else {\n        /* They didn't lock for anything - we won't give them anything */\n        xpriv->lockType = X11SD_LOCK_BY_NULL;\n    }\n    xpriv->lockFlags = lockflags;\n    xpriv->img = NULL;\n\n    return ret;\n    /* AWT_UNLOCK() called in Unlock */\n}\n\nstatic void X11SD_GetRasInfo(JNIEnv *env,\n                             SurfaceDataOps *ops,\n                             SurfaceDataRasInfo *pRasInfo)\n{\n    X11SDOps *xsdo = (X11SDOps *) ops;\n    X11RIPrivate *xpriv = (X11RIPrivate *) &(pRasInfo->priv);\n    jint lockFlags = xpriv->lockFlags;\n    jint depth = xsdo->depth;\n    int mult = xsdo->configData->pixelStride;\n\n    if (xsdo->dgaAvailable &&\n        xpriv->lockType == X11SD_LOCK_BY_XIMAGE &&\n        (lockFlags & SD_LOCK_FASTEST))\n    {\n        /* Try one more time to use DGA (now with smaller bounds)... */\n        int dgaret;\n\n        dgaret = (*pJDgaInfo->pGetLock)(env, awt_display, &xsdo->dgaDev,\n                                        xsdo->drawable, &xsdo->surfInfo,\n                                        pRasInfo->bounds.x1,\n                                        pRasInfo->bounds.y1,\n                                        pRasInfo->bounds.x2,\n                                        pRasInfo->bounds.y2);\n        if (dgaret == JDGA_SUCCESS) {\n            int wx = xsdo->surfInfo.window.lox;\n            int wy = xsdo->surfInfo.window.loy;\n            pRasInfo->bounds.x1 = xsdo->surfInfo.visible.lox - wx;\n            pRasInfo->bounds.y1 = xsdo->surfInfo.visible.loy - wy;\n            pRasInfo->bounds.x2 = xsdo->surfInfo.visible.hix - wx;\n            pRasInfo->bounds.y2 = xsdo->surfInfo.visible.hiy - wy;\n            xpriv->lockType = X11SD_LOCK_BY_DGA;\n        } else if (dgaret == JDGA_UNAVAILABLE) {\n            xsdo->dgaAvailable = JNI_FALSE;\n        }\n    }\n\n    if (xpriv->lockType == X11SD_LOCK_BY_DGA) {\n        int scan = xsdo->surfInfo.surfaceScan;\n        int wx = xsdo->surfInfo.window.lox;\n        int wy = xsdo->surfInfo.window.loy;\n        pRasInfo->rasBase =\n            (void *)(((uintptr_t) xsdo->surfInfo.basePtr) + (scan*wy + wx) * mult);\n        pRasInfo->pixelStride = mult;\n        pRasInfo->pixelBitOffset = 0;\n        pRasInfo->scanStride = scan * mult;\n#ifdef MITSHM\n    } else if (xpriv->lockType == X11SD_LOCK_BY_SHMEM) {\n        if (xsdo->shmPMData.xRequestSent == JNI_TRUE) {\n            /* need to sync before using shared mem pixmap\n             if any x calls were issued for this pixmap */\n            XSync(awt_display, False);\n            xsdo->shmPMData.xRequestSent = JNI_FALSE;\n        }\n        xpriv->x = pRasInfo->bounds.x1;\n        xpriv->y = pRasInfo->bounds.y1;\n        pRasInfo->rasBase = xsdo->shmPMData.shmSegInfo->shmaddr;\n        pRasInfo->pixelStride = mult;\n        pRasInfo->pixelBitOffset = 0;\n        pRasInfo->scanStride = xsdo->shmPMData.bytesPerLine;\n#endif /* MITSHM */\n    } else if (xpriv->lockType == X11SD_LOCK_BY_XIMAGE) {\n        int x, y, w, h;\n        x = pRasInfo->bounds.x1;\n        y = pRasInfo->bounds.y1;\n        w = pRasInfo->bounds.x2 - x;\n        h = pRasInfo->bounds.y2 - y;\n\n        xpriv->img = X11SD_GetImage(env, xsdo, &pRasInfo->bounds, lockFlags);\n        if (xpriv->img) {\n            int scan = xpriv->img->bytes_per_line;\n            xpriv->x = x;\n            xpriv->y = y;\n            pRasInfo->rasBase = xpriv->img->data - x * mult - y * scan;\n            pRasInfo->pixelStride = mult;\n            pRasInfo->pixelBitOffset = 0;\n            pRasInfo->scanStride = scan;\n        } else {\n            pRasInfo->rasBase = NULL;\n            pRasInfo->pixelStride = 0;\n            pRasInfo->pixelBitOffset = 0;\n            pRasInfo->scanStride = 0;\n        }\n    } else {\n        /* They didn't lock for anything - we won't give them anything */\n        pRasInfo->rasBase = NULL;\n        pRasInfo->pixelStride = 0;\n        pRasInfo->pixelBitOffset = 0;\n        pRasInfo->scanStride = 0;\n    }\n    if (lockFlags & SD_LOCK_LUT) {\n        pRasInfo->lutBase = (jint *) xsdo->cData->awt_icmLUT;\n        pRasInfo->lutSize = xsdo->cData->awt_numICMcolors;\n    } else {\n        pRasInfo->lutBase = NULL;\n        pRasInfo->lutSize = 0;\n    }\n    if (lockFlags & SD_LOCK_INVCOLOR) {\n        pRasInfo->invColorTable = xsdo->cData->img_clr_tbl;\n        pRasInfo->redErrTable = xsdo->cData->img_oda_red;\n        pRasInfo->grnErrTable = xsdo->cData->img_oda_green;\n        pRasInfo->bluErrTable = xsdo->cData->img_oda_blue;\n    } else {\n        pRasInfo->invColorTable = NULL;\n        pRasInfo->redErrTable = NULL;\n        pRasInfo->grnErrTable = NULL;\n        pRasInfo->bluErrTable = NULL;\n    }\n    if (lockFlags & SD_LOCK_INVGRAY) {\n        pRasInfo->invGrayTable = xsdo->cData->pGrayInverseLutData;\n    } else {\n        pRasInfo->invGrayTable = NULL;\n    }\n}\n\nstatic void X11SD_Unlock(JNIEnv *env,\n                         SurfaceDataOps *ops,\n                         SurfaceDataRasInfo *pRasInfo)\n{\n    X11SDOps *xsdo = (X11SDOps *) ops;\n    X11RIPrivate *xpriv = (X11RIPrivate *) &(pRasInfo->priv);\n\n    if (xpriv->lockType == X11SD_LOCK_BY_DGA) {\n        (*pJDgaInfo->pReleaseLock)(env, xsdo->dgaDev, xsdo->drawable);\n    } else if (xpriv->lockType == X11SD_LOCK_BY_XIMAGE &&\n               xpriv->img != NULL)\n    {\n        if (xpriv->lockFlags & SD_LOCK_WRITE) {\n            int x = xpriv->x;\n            int y = xpriv->y;\n            int w = pRasInfo->bounds.x2 - x;\n            int h = pRasInfo->bounds.y2 - y;\n            Drawable drawable = xsdo->drawable;\n            GC xgc = xsdo->cachedGC;\n            if (xgc == NULL) {\n                xsdo->cachedGC = xgc =\n                    XCreateGC(awt_display, drawable, 0L, NULL);\n            }\n\n            if (xpriv->img->byte_order != nativeByteOrder) {\n                /* switching bytes back in 24 and 32 bpp cases. */\n                /* For 16 bit XLib will switch for us.          */\n                if (xsdo->depth > 16) {\n                    X11SD_SwapBytes(xsdo, xpriv->img, xsdo->depth,\n                        xsdo->configData->awtImage->wsImageFormat.bits_per_pixel);\n                }\n            }\n\n#ifdef MITSHM\n            if (xpriv->img->obdata != NULL) {\n                XShmPutImage(awt_display, drawable, xgc,\n                             xpriv->img, 0, 0, x, y, w, h, False);\n                XFlush(awt_display);\n            } else {\n                XPutImage(awt_display, drawable, xgc,\n                          xpriv->img, 0, 0, x, y, w, h);\n            }\n            if (xsdo->shmPMData.usingShmPixmap) {\n                xsdo->shmPMData.xRequestSent = JNI_TRUE;\n            }\n#else\n            XPutImage(awt_display, drawable, xgc,\n                      xpriv->img, 0, 0, x, y, w, h);\n#endif /* MITSHM */\n\n            (*pJDgaInfo->pXRequestSent)(env, xsdo->dgaDev, drawable);\n        }\n        X11SD_DisposeOrCacheXImage(xpriv->img);\n        xpriv->img = (XImage *)NULL;\n    }\n    /* the background pixel is not valid anymore */\n    if (xpriv->lockFlags & SD_LOCK_WRITE) {\n        xsdo->isBgInitialized = JNI_FALSE;\n    }\n    xpriv->lockType = X11SD_LOCK_UNLOCKED;\n    AWT_UNLOCK();\n}\n\nstatic int\nX11SD_ClipToRoot(SurfaceDataBounds *b, SurfaceDataBounds *bounds,\n                 X11SDOps *xsdo)\n{\n    Position x1=0, y1=0, x2=0, y2=0;\n    int tmpx, tmpy;\n    Window tmpchild;\n\n    Window window = (Window)(xsdo->drawable); /* is always a Window */\n    XWindowAttributes winAttr;\n\n    Status status = XGetWindowAttributes(awt_display, window, &winAttr);\n    if (status == 0) {\n        /* Failure, X window no longer valid. */\n        return FALSE;\n    }\n    if (!XTranslateCoordinates(awt_display, window,\n                               RootWindowOfScreen(winAttr.screen),\n                               0, 0, &tmpx, &tmpy, &tmpchild)) {\n        return FALSE;\n    }\n\n    x1 = -(x1 + tmpx);\n    y1 = -(y1 + tmpy);\n\n    x2 = x1 + DisplayWidth(awt_display, xsdo->configData->awt_visInfo.screen);\n    y2 = y1 + DisplayHeight(awt_display, xsdo->configData->awt_visInfo.screen);\n\n    x1 = XSD_MAX(bounds->x1, x1);\n    y1 = XSD_MAX(bounds->y1, y1);\n    x2 = XSD_MIN(bounds->x2, x2);\n    y2 = XSD_MIN(bounds->y2, y2);\n    if ((x1 >= x2) || (y1 >= y2)) {\n        return FALSE;\n    }\n    b->x1 = x1;\n    b->y1 = y1;\n    b->x2 = x2;\n    b->y2 = y2;\n\n    return TRUE;\n}\n\n/*\n * x1, y1, x2, y2 - our rectangle in the coord system of\n * the widget\n * px1, xy1, px2, py2 - current parent rect coords in the\n * same system\n */\nstatic int\nX11SD_FindClip(SurfaceDataBounds *b, SurfaceDataBounds *bounds, X11SDOps *xsdo)\n{\n    return TRUE;\n}\n\nstatic void\nX11SD_SwapBytes(X11SDOps *xsdo, XImage * img, int depth, int bpp) {\n    int lengthInBytes = img->height * img->bytes_per_line;\n    int i;\n\n    switch (depth) {\n    case 12:\n    case 15:\n    case 16:\n        {\n            /* AB -> BA */\n            unsigned short *d = (unsigned short *)img->data;\n            unsigned short t;\n            for (i = 0; i < lengthInBytes/2; i++) {\n                t = *d;\n                *d++ = (t >> 8) | (t << 8);\n            }\n            img->byte_order = nativeByteOrder;\n            img->bitmap_bit_order = nativeByteOrder;\n            break;\n        }\n    case 24:\n        {\n            /* ABC -> CBA */\n            if (bpp == 24) {\n                // 4517321: Only swap if we have a \"real\" ThreeByteBgr\n                // visual (denoted by a red_mask of 0xff).  Due to ambiguity\n                // in the X11 spec, it appears that the swap is not required\n                // on Linux configurations that use 24 bits per pixel (denoted\n                // by a red_mask of 0xff0000).\n                if (xsdo->configData->awt_visInfo.red_mask == 0xff) {\n                    int scan = img->bytes_per_line;\n                    unsigned char *d = (unsigned char *) img->data;\n                    unsigned char *d1;\n                    unsigned int t;\n                    int j;\n\n                    for (i = 0; i < img->height; i++, d += scan) {\n                        d1 = d;\n                        for (j = 0; j < img->width; j++, d1 += 3) {\n                            /* not obvious opt from XLib src */\n                            t = d1[0]; d1[0] = d1[2]; d1[2] = t;\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        /* FALL THROUGH for 32-bit case */\n    case 32:\n        {\n            /* ABCD -> DCBA */\n            unsigned int *d = (unsigned int *) img->data;\n            unsigned int t;\n            for (i = 0; i < lengthInBytes/4; i++) {\n                t = *d;\n                *d++ = ((t >> 24) |\n                        ((t >> 8) & 0xff00) |\n                        ((t & 0xff00) << 8) |\n                        (t << 24));\n            }\n            break;\n        }\n    }\n}\n\nstatic XImage * X11SD_GetImage(JNIEnv *env, X11SDOps *xsdo,\n                               SurfaceDataBounds *bounds,\n                               jint lockFlags)\n{\n    int x, y, w, h, maxWidth, maxHeight;\n    int scan;\n    XImage * img = NULL;\n    Drawable drawable;\n    int depth = xsdo->depth;\n    int mult = xsdo->configData->pixelStride;\n    int pad = (mult == 3) ? 32 : mult * 8; // pad must be 8, 16, or 32\n    jboolean readBits = lockFlags & SD_LOCK_NEED_PIXELS;\n\n    x = bounds->x1;\n    y = bounds->y1;\n    w = bounds->x2 - x;\n    h = bounds->y2 - y;\n\n#ifdef MITSHM\n    if (useMitShmExt == CAN_USE_MITSHM) {\n        if (xsdo->isPixmap) {\n            if (readBits) {\n                X11SD_PuntPixmap(xsdo, w, h);\n            }\n            maxWidth = xsdo->pmWidth;\n            maxHeight = xsdo->pmHeight;\n        } else {\n            XWindowAttributes winAttr;\n            if (XGetWindowAttributes(awt_display,\n                                     (Window) xsdo->drawable, &winAttr) != 0) {\n                maxWidth = winAttr.width;\n                maxHeight = winAttr.height;\n           } else {\n                /* XGWA failed which isn't a good thing. Defaulting to using\n                 * x,y means that after the subtraction of these we will use\n                 * w=0, h=0 which is a reasonable default on such a failure.\n                 */\n                maxWidth = x;\n                maxHeight = y;\n           }\n        }\n        maxWidth -= x;\n        maxHeight -= y;\n\n        img = X11SD_GetSharedImage(xsdo, w, h, maxWidth, maxHeight, readBits);\n    }\n#endif /* MITSHM */\n    drawable = xsdo->drawable;\n\n    if (readBits) {\n#ifdef MITSHM\n        if (img != NULL) {\n            if (!XShmGetImage(awt_display, drawable, img, x, y, -1)) {\n                X11SD_DisposeOrCacheXImage(img);\n                img = NULL;\n            }\n        }\n        if (img == NULL) {\n            img = XGetImage(awt_display, drawable, x, y, w, h, -1, ZPixmap);\n            if (img != NULL) {\n                img->obdata = NULL;\n            }\n        }\n#else\n        img = XGetImage(awt_display, drawable, x, y, w, h, -1, ZPixmap);\n#endif /* MITSHM */\n        if (img == NULL) {\n            SurfaceDataBounds temp;\n            img = XCreateImage(awt_display,\n                               xsdo->configData->awt_visInfo.visual,\n                               depth, ZPixmap, 0, NULL, w, h, pad, 0);\n            if (img == NULL) {\n                return NULL;\n            }\n\n            scan = img->bytes_per_line;\n            img->data = malloc(h * scan);\n            if (img->data == NULL) {\n                XFree(img);\n                return NULL;\n            }\n\n            if (xsdo->isPixmap == JNI_FALSE &&\n                X11SD_ClipToRoot(&temp, bounds, xsdo)) {\n\n                XImage * temp_image;\n                temp_image = XGetImage(awt_display, drawable,\n                                       temp.x1, temp.y1,\n                                       temp.x2 - temp.x1,\n                                       temp.y2 - temp.y1,\n                                       -1, ZPixmap);\n                if (temp_image == NULL) {\n                    XGrabServer(awt_display);\n                    if (X11SD_FindClip(&temp, bounds, xsdo)) {\n                        temp_image =\n                            XGetImage(awt_display, drawable,\n                                      temp.x1, temp.y1,\n                                      temp.x2 - temp.x1,\n                                      temp.y2 - temp.y1,\n                                      -1, ZPixmap);\n                    }\n                    XUngrabServer(awt_display);\n                    /* Workaround for bug 5039226 */\n                    XSync(awt_display, False);\n                }\n                if (temp_image != NULL) {\n                    int temp_scan, bytes_to_copy;\n                    char * img_addr, * temp_addr;\n                    int i;\n\n                    img_addr = img->data +\n                        (temp.y1 - y) * scan + (temp.x1 - x) * mult;\n                    temp_scan = temp_image->bytes_per_line;\n                    temp_addr = temp_image->data;\n                    bytes_to_copy = (temp.x2 - temp.x1) * mult;\n                    for (i = temp.y1; i < temp.y2; i++) {\n                        memcpy(img_addr, temp_addr, bytes_to_copy);\n                        img_addr += scan;\n                        temp_addr += temp_scan;\n                    }\n                    XDestroyImage(temp_image);\n                }\n            }\n            img->obdata = NULL;\n        }\n        if (depth > 8 && img->byte_order != nativeByteOrder) {\n            X11SD_SwapBytes(xsdo, img, depth,\n                xsdo->configData->awtImage->wsImageFormat.bits_per_pixel);\n        }\n    } else {\n        /*\n         * REMIND: This might be better to move to the Lock function\n         * to avoid lengthy I/O pauses inside what may be a critical\n         * section.  This will be more critical when SD_LOCK_READ is\n         * implemented.  Another solution is to cache the pixels\n         * to avoid reading for every operation.\n         */\n        if (img == NULL) {\n            img = XCreateImage(awt_display,\n                               xsdo->configData->awt_visInfo.visual,\n                               depth, ZPixmap, 0, NULL, w, h, pad, 0);\n            if (img == NULL) {\n                return NULL;\n            }\n\n            img->data = malloc(h * img->bytes_per_line);\n            if (img->data == NULL) {\n                XFree(img);\n                return NULL;\n            }\n\n            img->obdata = NULL;\n\n            if (img->byte_order != nativeByteOrder &&\n                (depth == 15 || depth == 16 || depth == 12)) {\n                /* bytes will be swapped by XLib. */\n                img->byte_order = nativeByteOrder;\n                img->bitmap_bit_order = nativeByteOrder;\n            }\n        }\n    }\n    return img;\n}\n\nvoid X11SD_DisposeOrCacheXImage(XImage * image) {\n    /* REMIND: might want to check if the new image worth caching. */\n    /* Cache only shared images. Passed image is assumed to be non-null. */\n    if (image->obdata != NULL) {\n        if (cachedXImage != NULL) {\n            X11SD_DisposeXImage(cachedXImage);\n        }\n        cachedXImage = image;\n    } else {\n        X11SD_DisposeXImage(image);\n    }\n}\n\nvoid X11SD_DisposeXImage(XImage * image) {\n    if (image != NULL) {\n#ifdef MITSHM\n        if (image->obdata != NULL) {\n            X11SD_DropSharedSegment((XShmSegmentInfo*)image->obdata);\n            image->obdata = NULL;\n        }\n#endif /* MITSHM */\n        XDestroyImage(image);\n    }\n}\n\nstatic JDgaStatus\n    GetLockStub(JNIEnv *env, Display *display, void **dgaDev,\n                Drawable d, JDgaSurfaceInfo *pSurface,\n                jint lox, jint loy, jint hix, jint hiy)\n{\n    return JDGA_UNAVAILABLE;\n}\n\nstatic JDgaStatus\n    ReleaseLockStub(JNIEnv *env, void *dgaDev, Drawable d)\n{\n    return JDGA_FAILED;\n}\n\nstatic void\n    XRequestSentStub(JNIEnv *env, void *dgaDev, Drawable d)\n{\n}\n\nstatic void\n    LibDisposeStub(JNIEnv *env)\n{\n}\n\nstatic JDgaLibInfo DgaLibInfoStub = {\n    NULL,\n    GetLockStub,\n    ReleaseLockStub,\n    XRequestSentStub,\n    LibDisposeStub,\n};\n\nvoid X11SD_LibDispose(JNIEnv *env) {\n    AWT_LOCK();\n    if (pJDgaInfo != NULL) {\n        pJDgaInfo->pLibDispose(env);\n        pJDgaInfo = &DgaLibInfoStub;\n    }\n    AWT_UNLOCK();\n}\n\nvoid\nX11SD_DirectRenderNotify(JNIEnv *env, X11SDOps *xsdo)\n{\n#ifdef MITSHM\n    if (xsdo->shmPMData.usingShmPixmap) {\n        xsdo->shmPMData.xRequestSent = JNI_TRUE;\n    }\n#endif /* MITSHM */\n    (*pJDgaInfo->pXRequestSent)(env, xsdo->dgaDev, xsdo->drawable);\n    awt_output_flush();\n}\n\n/*\n * Sets transparent pixels in the pixmap to\n * the specified solid background color and returns it.\n * Doesn't update source pixmap unless the color of the\n * transparent pixels is different from the specified color.\n *\n * Note: The AWT lock must be held by the current thread\n * while calling into this method.\n */\nstatic Drawable\nX11SD_GetPixmapWithBg(JNIEnv *env, X11SDOps *xsdo, jint pixel)\n{\n    /* assert AWT_CHECK_HAVE_LOCK(); */\n\n    if (xsdo->invalid) {\n        AWT_UNLOCK();\n        SurfaceData_ThrowInvalidPipeException(env, \"bounds changed\");\n        return 0;\n    }\n\n    /* the image doesn't have transparency, just return it */\n    if (xsdo->bitmask == 0) {\n        /* don't need to unlock here, the caller will unlock through\n           the release call */\n        return xsdo->drawable;\n    }\n\n    /* Check if current color of the transparent pixels is different\n       from the specified one */\n    if (xsdo->isBgInitialized == JNI_FALSE || xsdo->bgPixel != pixel) {\n        GC srcGC;\n        GC bmGC;\n\n        if (xsdo->drawable == 0) {\n            AWT_UNLOCK();\n            return 0;\n        }\n\n        bmGC = XCreateGC(awt_display, xsdo->bitmask, 0, NULL);\n        if (bmGC == NULL) {\n            AWT_UNLOCK();\n            return 0;\n        }\n\n        /* invert the bitmask */\n        XSetFunction(awt_display, bmGC, GXxor);\n        XSetForeground(awt_display, bmGC, 1);\n        XFillRectangle(awt_display, xsdo->bitmask, bmGC,\n                       0, 0, xsdo->pmWidth, xsdo->pmHeight);\n\n        srcGC = XCreateGC(awt_display, xsdo->drawable, 0L, NULL);\n        if (srcGC == NULL) {\n            XFreeGC(awt_display, bmGC);\n            AWT_UNLOCK();\n            return 0;\n        }\n\n        /* set transparent pixels in the source pm to the bg color */\n        XSetClipMask(awt_display, srcGC, xsdo->bitmask);\n        XSetForeground(awt_display, srcGC, pixel);\n        XFillRectangle(awt_display, xsdo->drawable, srcGC,\n                       0, 0, xsdo->pmWidth, xsdo->pmHeight);\n\n        /* invert the mask back */\n        XFillRectangle(awt_display, xsdo->bitmask, bmGC,\n                       0, 0, xsdo->pmWidth, xsdo->pmHeight);\n\n        XFreeGC(awt_display, bmGC);\n        XFreeGC(awt_display, srcGC);\n        xsdo->bgPixel = pixel;\n        xsdo->isBgInitialized = JNI_TRUE;\n    }\n\n    return xsdo->drawable;\n}\n\nstatic void\nX11SD_ReleasePixmapWithBg(JNIEnv *env, X11SDOps *xsdo)\n{\n#ifdef MITSHM\n    if (xsdo->shmPMData.usingShmPixmap) {\n        xsdo->shmPMData.xRequestSent = JNI_TRUE;\n    }\n#endif /* MITSHM */\n}\n\n#endif /* !HEADLESS */\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    XCreateGC\n * Signature: (I)J\n */\nJNIEXPORT jlong JNICALL\nJava_sun_java2d_x11_XSurfaceData_XCreateGC\n    (JNIEnv *env, jclass xsd, jlong pXSData)\n{\n    jlong ret;\n\n#ifndef HEADLESS\n    X11SDOps *xsdo;\n\n    J2dTraceLn(J2D_TRACE_INFO, \"in X11SurfaceData_XCreateGC\");\n\n    xsdo = (X11SDOps *) pXSData;\n    if (xsdo == NULL) {\n        return 0L;\n    }\n\n    xsdo->javaGC = XCreateGC(awt_display, xsdo->drawable, 0, NULL);\n    ret = (jlong) xsdo->javaGC;\n#else /* !HEADLESS */\n    ret = 0L;\n#endif /* !HEADLESS */\n\n    return ret;\n}\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    XResetClip\n * Signature: (JIIIILsun/java2d/pipe/Region;)V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_XSurfaceData_XResetClip\n    (JNIEnv *env, jclass xsd, jlong xgc)\n{\n#ifndef HEADLESS\n    J2dTraceLn(J2D_TRACE_INFO, \"in X11SurfaceData_XResetClip\");\n    XSetClipMask(awt_display, (GC) xgc, None);\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    XSetClip\n * Signature: (JIIIILsun/java2d/pipe/Region;)V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_XSurfaceData_XSetClip\n    (JNIEnv *env, jclass xsd, jlong xgc,\n     jint x1, jint y1, jint x2, jint y2,\n     jobject complexclip)\n{\n#ifndef HEADLESS\n    int numrects;\n    XRectangle rects[256];\n    XRectangle *pRect = rects;\n\n    J2dTraceLn(J2D_TRACE_INFO, \"in X11SurfaceData_XSetClip\");\n\n    numrects = RegionToYXBandedRectangles(env,\n            x1, y1, x2, y2, complexclip,\n            &pRect, 256);\n\n    XSetClipRectangles(awt_display, (GC) xgc, 0, 0, pRect, numrects, YXBanded);\n\n    if (pRect != rects) {\n        free(pRect);\n    }\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    XSetCopyMode\n * Signature: (J)V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_X11SurfaceData_XSetCopyMode\n    (JNIEnv *env, jclass xsd, jlong xgc)\n{\n#ifndef HEADLESS\n    J2dTraceLn(J2D_TRACE_INFO, \"in X11SurfaceData_XSetCopyMode\");\n    XSetFunction(awt_display, (GC) xgc, GXcopy);\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    XSetXorMode\n * Signature: (J)V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_X11SurfaceData_XSetXorMode\n    (JNIEnv *env, jclass xr, jlong xgc)\n{\n#ifndef HEADLESS\n    J2dTraceLn(J2D_TRACE_INFO, \"in X11SurfaceData_XSetXorMode\");\n    XSetFunction(awt_display, (GC) xgc, GXxor);\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    XSetForeground\n * Signature: (JI)V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_X11SurfaceData_XSetForeground\n    (JNIEnv *env, jclass xsd, jlong xgc, jint pixel)\n{\n#ifndef HEADLESS\n    J2dTraceLn(J2D_TRACE_INFO, \"in X11SurfaceData_XSetForeground\");\n    XSetForeground(awt_display, (GC) xgc, pixel);\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_java2d_x11_X11SurfaceData\n * Method:    XSetGraphicsExposures\n * Signature: (JZ)V\n */\nJNIEXPORT void JNICALL\nJava_sun_java2d_x11_XSurfaceData_XSetGraphicsExposures\n    (JNIEnv *env, jclass xsd, jlong xgc, jboolean needExposures)\n{\n#ifndef HEADLESS\n    J2dTraceLn(J2D_TRACE_INFO, \"in X11SurfaceData_XSetGraphicsExposures\");\n    XSetGraphicsExposures(awt_display, (GC) xgc, needExposures ? True : False);\n#endif /* !HEADLESS */\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/java2d/x11/XRBackendNative.c": "/*\n * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"X11SurfaceData.h\"\n#include <jni.h>\n#include <math.h>\n#include \"Region.h\"\n#include \"fontscalerdefs.h\"\n\n#include <X11/extensions/Xrender.h>\n\n#ifdef __linux__\n    #include <sys/utsname.h>\n#endif\n\n/* On Solaris 10 updates 8, 9, the render.h file defines these\n * protocol values but does not define the structs in Xrender.h.\n * Thus in order to get these always defined on Solaris 10\n * we will undefine the symbols if we have determined via the\n * makefiles that Xrender.h is lacking the structs. This will\n * trigger providing our own definitions as on earlier updates.\n * We could assume that *all* Solaris 10 update versions will lack the updated\n * Xrender.h and do this based solely on O/S being any 5.10 version, but this\n * could still change and we'd be broken again as we'd be re-defining them.\n */\n#ifdef SOLARIS10_NO_XRENDER_STRUCTS\n#undef X_RenderCreateLinearGradient\n#undef X_RenderCreateRadialGradient\n#endif\n\n#ifndef X_RenderCreateLinearGradient\ntypedef struct _XLinearGradient {\n    XPointFixed p1;\n    XPointFixed p2;\n} XLinearGradient;\n#endif\n\n#ifndef X_RenderCreateRadialGradient\ntypedef struct _XCircle {\n    XFixed x;\n    XFixed y;\n    XFixed radius;\n} XCircle;\n\ntypedef struct _XRadialGradient {\n    XCircle inner;\n    XCircle outer;\n} XRadialGradient;\n#endif\n\n#include <dlfcn.h>\n\n#if defined(__solaris__) || defined(_AIX)\n/* Solaris 10 and AIX will not have these symbols at runtime */\n\ntypedef Picture (*XRenderCreateLinearGradientFuncType)\n                                     (Display *dpy,\n                                     const XLinearGradient *gradient,\n                                     const XFixed *stops,\n                                     const XRenderColor *colors,\n                                     int nstops);\n\ntypedef Picture (*XRenderCreateRadialGradientFuncType)\n                                     (Display *dpy,\n                                     const XRadialGradient *gradient,\n                                     const XFixed *stops,\n                                     const XRenderColor *colors,\n                                     int nstops);\n\nstatic\nXRenderCreateLinearGradientFuncType XRenderCreateLinearGradientFunc = NULL;\nstatic\n XRenderCreateRadialGradientFuncType XRenderCreateRadialGradientFunc = NULL;\n#endif\n\n#define BUILD_TRANSFORM_MATRIX(TRANSFORM, M00, M01, M02, M10, M11, M12)                        \\\n    {                                                                                          \\\n      TRANSFORM.matrix[0][0] = M00;                                                            \\\n      TRANSFORM.matrix[0][1] = M01;                                                            \\\n      TRANSFORM.matrix[0][2] = M02;                                                            \\\n      TRANSFORM.matrix[1][0] = M10;                                                            \\\n      TRANSFORM.matrix[1][1] = M11;                                                            \\\n      TRANSFORM.matrix[1][2] = M12;                                                            \\\n      TRANSFORM.matrix[2][0] = 0;                                                              \\\n      TRANSFORM.matrix[2][1] = 0;                                                              \\\n      TRANSFORM.matrix[2][2] = 1<<16;                                                          \\\n    }\n\n/* The xrender pipleine requires libXrender.so version 0.9.3 or later. */\n#define REQUIRED_XRENDER_VER1 0\n#define REQUIRED_XRENDER_VER2 9\n#define REQUIRED_XRENDER_VER3 3\n\n#define PKGINFO_LINE_LEN_MAX 256\n#define PKGINFO_LINE_CNT_MAX 50\n\n/*\n * X protocol uses (u_int16)length to specify the length in 4 bytes quantities\n * of the whole request.  Both XRenderFillRectangles() and XFillRectangles()\n * have provisions to fragment into several requests if the number of rectangles\n * plus the current x request does not fit into 65535*4 bytes.  While\n * XRenderCreateLinearGradient() and XRenderCreateRadialGradient() have\n * provisions to gracefully degrade if the resulting request would exceed\n * 65535*4 bytes.\n *\n * Below, we define a cap of 65535*4 bytes for the maximum X request payload\n * allowed for Non-(XRenderFillRectangles() or XFillRectangles()) API calls,\n * just to be conservative.  This is offset by the size of our maximum x*Req\n * type in this compilation unit, which is xRenderCreateRadiaGradientReq.\n *\n * Note that sizeof(xRenderCreateRadiaGradientReq) = 36\n */\n#define MAX_PAYLOAD (262140u - 36u)\n#define MAXUINT (0xffffffffu)\n\nstatic jboolean IsXRenderAvailable(jboolean verbose, jboolean ignoreLinuxVersion) {\n\n    void *xrenderlib;\n\n    int major_opcode, first_event, first_error;\n    jboolean available = JNI_TRUE;\n\n    if (!XQueryExtension(awt_display, \"RENDER\",\n                         &major_opcode, &first_event, &first_error)) {\n        return JNI_FALSE;\n    }\n\n#if defined(__solaris__) || defined(_AIX)\n    xrenderlib = dlopen(\"libXrender.so\",RTLD_GLOBAL|RTLD_LAZY);\n    if (xrenderlib != NULL) {\n\n      XRenderCreateLinearGradientFunc =\n        (XRenderCreateLinearGradientFuncType)\n        dlsym(xrenderlib, \"XRenderCreateLinearGradient\");\n\n      XRenderCreateRadialGradientFunc =\n        (XRenderCreateRadialGradientFuncType)\n        dlsym(xrenderlib, \"XRenderCreateRadialGradient\");\n\n      if (XRenderCreateLinearGradientFunc == NULL ||\n          XRenderCreateRadialGradientFunc == NULL)\n      {\n        available = JNI_FALSE;\n      }\n      dlclose(xrenderlib);\n    } else {\n      available = JNI_FALSE;\n    }\n#else\n    Dl_info info;\n    jboolean versionInfoIsFound = JNI_FALSE;\n\n    memset(&info, 0, sizeof(Dl_info));\n    if (dladdr(&XRenderChangePicture, &info) && info.dli_fname != NULL) {\n      char pkgInfoPath[FILENAME_MAX];\n      char *pkgFileName = \"/pkgconfig/xrender.pc\";\n      size_t pkgFileNameLen = strlen(pkgFileName);\n      size_t pos, len = strlen(info.dli_fname);\n\n      pos = len;\n      while (pos > 0 && info.dli_fname[pos] != '/') {\n        pos -= 1;\n      }\n\n      if (pos > 0 && pos < (FILENAME_MAX - pkgFileNameLen - 1)) {\n        struct stat stat_info;\n\n        // compose absolute filename to package config\n        strncpy(pkgInfoPath, info.dli_fname, pos);\n\n        strcpy(pkgInfoPath + pos, pkgFileName);\n        pkgInfoPath[pos + pkgFileNameLen] = '\\0';\n\n        // check whether the config file exist and is a regular file\n        if ((stat(pkgInfoPath, &stat_info)== 0) &&\n            S_ISREG(stat_info.st_mode))\n        {\n          FILE *fp = fopen(pkgInfoPath, \"r\");\n          if (fp != NULL) {\n            char line[PKGINFO_LINE_LEN_MAX];\n            int lineCount = PKGINFO_LINE_CNT_MAX;\n            char *versionPrefix = \"Version: \";\n            size_t versionPrefixLen = strlen(versionPrefix);\n\n            // look for version\n            while(fgets(line,sizeof(line),fp) != NULL && --lineCount > 0) {\n              size_t lineLen = strlen(line);\n\n              if (lineLen > versionPrefixLen &&\n                  strncmp(versionPrefix, line, versionPrefixLen) == 0)\n              {\n                int v1 = 0, v2 = 0, v3 = 0;\n                int numNeeded = 3,numProcessed;\n                char* version = line + versionPrefixLen;\n                numProcessed = sscanf(version, \"%d.%d.%d\", &v1, &v2, &v3);\n\n                if (numProcessed == numNeeded) {\n                  // we successfuly read the library version\n                  versionInfoIsFound = JNI_TRUE;\n\n                  if (REQUIRED_XRENDER_VER1 == v1 &&\n                      ((REQUIRED_XRENDER_VER2 > v2) ||\n                       ((REQUIRED_XRENDER_VER2 == v2) && (REQUIRED_XRENDER_VER3 > v3))))\n                  {\n                    available = JNI_FALSE;\n\n                    if (verbose) {\n                      printf(\"INFO: the version %d.%d.%d of libXrender.so is \"\n                             \"not supported.\\n\\tSee release notes for more details.\\n\",\n                             v1, v2, v3);\n                      fflush(stdout);\n                    }\n                  } else {\n                    if (verbose) {\n                      printf(\"INFO: The version of libXrender.so \"\n                             \"is detected as %d.%d%d\\n\", v1, v2, v3);\n                      fflush(stdout);\n                    }\n                  }\n                }\n                break;\n              }\n            }\n            fclose(fp);\n          }\n        }\n      }\n    }\n    if (verbose && !versionInfoIsFound) {\n      printf(\"WARNING: The version of libXrender.so cannot be detected.\\n,\"\n             \"The pipe line will be enabled, but note that versions less than 0.9.3\\n\"\n             \"may cause hangs and crashes\\n\"\n             \"\\tSee the release notes for more details.\\n\");\n      fflush(stdout);\n    }\n#endif\n\n#ifdef __linux__\n    /*\n     * Check for Linux >= 3.5 (Ubuntu 12.04.02 LTS) to avoid hitting\n     * https://bugs.freedesktop.org/show_bug.cgi?id=48045\n     */\n    struct utsname utsbuf;\n    if(uname(&utsbuf) >= 0) {\n        int major, minor, revision;\n        if(sscanf(utsbuf.release, \"%i.%i.%i\", &major, &minor, &revision) == 3) {\n            if(major < 3 || (major == 3 && minor < 5)) {\n                if(!ignoreLinuxVersion) {\n                    available = JNI_FALSE;\n                }\n                else if(verbose) {\n                 printf(\"WARNING: Linux < 3.5 detected.\\n\"\n                        \"The pipeline will be enabled, but graphical \"\n                        \"artifacts can occur with old graphic drivers.\\n\"\n                        \"See the release notes for more details.\\n\");\n                        fflush(stdout);\n                }\n            }\n        }\n    }\n#endif // __linux__\n\n    return available;\n}\n/*\n * Class:     sun_awt_X11GraphicsEnvironment\n * Method:    initGLX\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_X11GraphicsEnvironment_initXRender\n(JNIEnv *env, jclass x11ge, jboolean verbose, jboolean ignoreLinuxVersion)\n{\n#ifndef HEADLESS\n    static jboolean xrenderAvailable = JNI_FALSE;\n    static jboolean firstTime = JNI_TRUE;\n\n    if (firstTime) {\n#ifdef DISABLE_XRENDER_BY_DEFAULT\n        if (verbose == JNI_FALSE) {\n            xrenderAvailable = JNI_FALSE;\n            firstTime = JNI_FALSE;\n            return xrenderAvailable;\n        }\n#endif\n        AWT_LOCK();\n        xrenderAvailable = IsXRenderAvailable(verbose, ignoreLinuxVersion);\n        AWT_UNLOCK();\n        firstTime = JNI_FALSE;\n    }\n    return xrenderAvailable;\n#else\n    return JNI_FALSE;\n#endif /* !HEADLESS */\n}\n\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_initIDs(JNIEnv *env, jclass cls) {\n    char *maskData;\n    XImage* defaultImg;\n    jfieldID maskImgID;\n    jlong fmt8;\n    jlong fmt32;\n\n    jfieldID a8ID = (*env)->GetStaticFieldID(env, cls, \"FMTPTR_A8\", \"J\");\n    if (a8ID == NULL) {\n        return;\n    }\n    jfieldID argb32ID = (*env)->GetStaticFieldID(env, cls, \"FMTPTR_ARGB32\", \"J\");\n    if (argb32ID == NULL) {\n        return;\n    }\n\n    if (awt_display == (Display *)NULL) {\n        return;\n    }\n\n    fmt8 = ptr_to_jlong(XRenderFindStandardFormat(awt_display, PictStandardA8));\n    fmt32 = ptr_to_jlong(XRenderFindStandardFormat(awt_display, PictStandardARGB32));\n\n    (*env)->SetStaticLongField(env, cls, a8ID, fmt8);\n    (*env)->SetStaticLongField(env, cls, argb32ID, fmt32);\n\n    maskData = (char *) malloc(32*32);\n    if (maskData == NULL) {\n       return;\n    }\n\n    defaultImg = XCreateImage(awt_display, NULL, 8, ZPixmap, 0, maskData, 32, 32, 8, 0);\n    defaultImg->data = maskData; //required?\n    maskImgID = (*env)->GetStaticFieldID(env, cls, \"MASK_XIMG\", \"J\");\n    if (maskImgID == NULL) {\n       return;\n    }\n\n    (*env)->SetStaticLongField(env, cls, maskImgID, ptr_to_jlong(defaultImg));\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_freeGC\n (JNIEnv *env, jobject this, jlong gc) {\n    XFreeGC(awt_display, (GC) jlong_to_ptr(gc));\n}\n\nJNIEXPORT jlong JNICALL\nJava_sun_java2d_xr_XRBackendNative_createGC\n (JNIEnv *env, jobject this, jint drawable) {\n  GC xgc = XCreateGC(awt_display, (Drawable) drawable, 0L, NULL);\n  return ptr_to_jlong(xgc);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_java2d_xr_XRBackendNative_createPixmap(JNIEnv *env, jobject this,\n                                                jint drawable, jint depth,\n                                                jint width, jint height) {\n    return (jint) XCreatePixmap(awt_display, (Drawable) drawable,\n                                width, height, depth);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_java2d_xr_XRBackendNative_createPictureNative\n (JNIEnv *env, jclass cls, jint drawable, jlong formatPtr) {\n  XRenderPictureAttributes pict_attr;\n  return XRenderCreatePicture(awt_display, (Drawable) drawable,\n                              (XRenderPictFormat *) jlong_to_ptr(formatPtr),\n                               0, &pict_attr);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_freePicture\n (JNIEnv *env, jobject this, jint picture) {\n      XRenderFreePicture(awt_display, (Picture) picture);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_freePixmap\n (JNIEnv *env, jobject this, jint pixmap) {\n   XFreePixmap(awt_display, (Pixmap) pixmap);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_setPictureRepeat\n (JNIEnv *env, jobject this, jint picture, jint repeat) {\n    XRenderPictureAttributes pict_attr;\n    pict_attr.repeat = repeat;\n    XRenderChangePicture (awt_display, (Picture) picture, CPRepeat, &pict_attr);\n}\n\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_setGCExposures\n (JNIEnv *env, jobject this, jlong gc, jboolean exposure) {\n    XSetGraphicsExposures(awt_display,\n                         (GC) jlong_to_ptr(gc), exposure ? True : False); //TODO: ????\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_setGCForeground\n (JNIEnv *env, jobject this, jlong gc, jint pixel) {\n    XSetForeground(awt_display, (GC) jlong_to_ptr(gc), (unsigned long) pixel);\n}\n\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_copyArea\n (JNIEnv *env, jobject this, jint src, jint dst, jlong gc,\n  jint srcx, jint srcy, jint width, jint height, jint dstx, jint dsty) {\n    XCopyArea(awt_display, (Drawable) src, (Drawable) dst,\n             (GC) jlong_to_ptr(gc), srcx, srcy, width, height, dstx, dsty);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_renderComposite\n (JNIEnv *env, jobject this, jbyte op, jint src, jint mask, jint dst,\n  jint srcX, jint srcY, jint maskX, jint maskY,\n  jint dstX, jint dstY, jint width, jint height) {\n    XRenderComposite (awt_display, op,\n                      (Picture)src, (Picture)mask, (Picture)dst,\n                       srcX, srcY, maskX, maskY, dstX, dstY, width, height);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_renderRectangle\n (JNIEnv *env, jobject this, jint dst, jbyte op,\n  jshort red, jshort green, jshort blue, jshort alpha,\n  jint x, jint y, jint width, jint height) {\n    XRenderColor color;\n    color.alpha = alpha;\n    color.red = red;\n    color.green = green;\n    color.blue = blue;\n    XRenderFillRectangle(awt_display, op, (Picture) dst, &color,\n                         x, y, width, height);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_XRenderRectanglesNative\n (JNIEnv *env, jclass xsd, jint dst, jbyte op,\n  jshort red, jshort green, jshort blue, jshort alpha,\n  jintArray rectArray, jint rectCnt) {\n    int i;\n    jint* rects;\n    XRectangle *xRects;\n    XRectangle sRects[256];\n\n    XRenderColor color;\n    color.alpha = alpha;\n    color.red = red;\n    color.green = green;\n    color.blue = blue;\n\n    if (rectCnt <= 256) {\n        xRects = &sRects[0];\n    } else {\n        if (MAXUINT / sizeof(XRectangle) < (unsigned)rectCnt) {\n            /* rectCnt too big, integer overflow */\n            return;\n        }\n        xRects = (XRectangle *) malloc(sizeof(XRectangle) * rectCnt);\n        if (xRects == NULL) {\n            return;\n        }\n    }\n\n    if ((rects = (jint *)\n         (*env)->GetPrimitiveArrayCritical(env, rectArray, NULL)) == NULL) {\n        if (xRects != &sRects[0]) {\n            free(xRects);\n        }\n        return;\n    }\n\n    for (i=0; i < rectCnt; i++) {\n        xRects[i].x = rects[i*4 + 0];\n        xRects[i].y = rects[i*4 + 1];\n        xRects[i].width = rects[i*4 + 2];\n        xRects[i].height = rects[i*4 + 3];\n    }\n\n    XRenderFillRectangles(awt_display, op,\n                          (Picture) dst, &color, xRects, rectCnt);\n\n    (*env)->ReleasePrimitiveArrayCritical(env, rectArray, rects, JNI_ABORT);\n    if (xRects != &sRects[0]) {\n        free(xRects);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_XRSetTransformNative\n (JNIEnv *env, jclass xsd, jint pic,\n  jint m00, jint m01, jint m02, jint m10, jint m11, jint m12) {\n\n  XTransform tr;\n  BUILD_TRANSFORM_MATRIX(tr, m00, m01, m02, m10, m11, m12);\n  XRenderSetPictureTransform (awt_display, (Picture) pic, &tr);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_java2d_xr_XRBackendNative_XRCreateLinearGradientPaintNative\n    (JNIEnv *env, jclass xsd, jfloatArray fractionsArray,\n     jshortArray pixelsArray, jint x1, jint y1, jint x2, jint y2,\n     jint numStops, jint repeat) {\n   jint i;\n   jshort* pixels;\n   jfloat* fractions;\n   XRenderPictureAttributes pict_attr;\n   Picture gradient = 0;\n   XRenderColor *colors;\n   XFixed *stops;\n   XLinearGradient grad;\n\n   if (MAX_PAYLOAD / (sizeof(XRenderColor) + sizeof(XFixed))\n       < (unsigned)numStops) {\n       /* numStops too big, payload overflow */\n       return -1;\n   }\n\n   if ((pixels = (jshort *)\n        (*env)->GetPrimitiveArrayCritical(env, pixelsArray, NULL)) == NULL) {\n       return -1;\n   }\n   if ((fractions = (jfloat *)\n       (*env)->GetPrimitiveArrayCritical(env, fractionsArray, NULL)) == NULL) {\n       (*env)->ReleasePrimitiveArrayCritical(env,\n                                              pixelsArray, pixels, JNI_ABORT);\n       return -1;\n   }\n\n    grad.p1.x = x1;\n    grad.p1.y = y1;\n    grad.p2.x = x2;\n    grad.p2.y = y2;\n\n    /*TODO optimized & malloc check*/\n    colors = (XRenderColor *) malloc(numStops * sizeof(XRenderColor));\n    stops =  (XFixed *) malloc(numStops * sizeof(XFixed));\n\n    if (colors == NULL || stops == NULL) {\n        if (colors != NULL) {\n            free(colors);\n        }\n        if (stops != NULL) {\n            free(stops);\n        }\n        (*env)->ReleasePrimitiveArrayCritical(env, pixelsArray, pixels, JNI_ABORT);\n        (*env)->ReleasePrimitiveArrayCritical(env, fractionsArray, fractions, JNI_ABORT);\n        return -1;\n    }\n\n    for (i=0; i < numStops; i++) {\n      stops[i] = XDoubleToFixed(fractions[i]);\n      colors[i].alpha = pixels[i*4 + 0];\n      colors[i].red = pixels[i*4 + 1];\n      colors[i].green = pixels[i*4 + 2];\n      colors[i].blue = pixels[i*4 + 3];\n    }\n#ifdef __solaris__\n    if (XRenderCreateLinearGradientFunc!=NULL) {\n      gradient = (*XRenderCreateLinearGradientFunc)(awt_display, &grad, stops, colors, numStops);\n    }\n#else\n    gradient = XRenderCreateLinearGradient(awt_display, &grad, stops, colors, numStops);\n#endif\n    free(colors);\n    free(stops);\n\n   (*env)->ReleasePrimitiveArrayCritical(env, pixelsArray, pixels, JNI_ABORT);\n   (*env)->ReleasePrimitiveArrayCritical(env, fractionsArray, fractions, JNI_ABORT);\n\n    if (gradient != 0) {\n        pict_attr.repeat = repeat;\n        XRenderChangePicture (awt_display, gradient, CPRepeat, &pict_attr);\n    }\n\n   return (jint) gradient;\n}\n\n\nJNIEXPORT jint JNICALL\nJava_sun_java2d_xr_XRBackendNative_XRCreateRadialGradientPaintNative\n    (JNIEnv *env, jclass xsd, jfloatArray fractionsArray,\n     jshortArray pixelsArray, jint numStops,\n     jint centerX, jint centerY,\n     jint innerRadius, jint outerRadius, jint repeat) {\n   jint i;\n   jshort* pixels;\n   jfloat* fractions;\n   XRenderPictureAttributes pict_attr;\n   Picture gradient = 0;\n   XRenderColor *colors;\n   XFixed *stops;\n   XRadialGradient grad;\n\n   if (MAX_PAYLOAD / (sizeof(XRenderColor) + sizeof(XFixed))\n       < (unsigned)numStops) {\n       /* numStops too big, payload overflow */\n       return -1;\n   }\n\n   if ((pixels =\n       (jshort *)(*env)->GetPrimitiveArrayCritical(env, pixelsArray, NULL)) == NULL) {\n       return -1;\n   }\n   if ((fractions = (jfloat *)\n        (*env)->GetPrimitiveArrayCritical(env, fractionsArray, NULL)) == NULL) {\n       (*env)->ReleasePrimitiveArrayCritical(env,\n                                             pixelsArray, pixels, JNI_ABORT);\n       return -1; //TODO release pixels first\n   }\n\n    grad.inner.x = centerX;\n    grad.inner.y = centerY;\n    grad.inner.radius = innerRadius;\n    grad.outer.x = centerX;\n    grad.outer.y = centerY;\n    grad.outer.radius = outerRadius;\n\n    /*TODO optimized & malloc check*/\n    colors = (XRenderColor *) malloc(numStops * sizeof(XRenderColor));\n    stops =  (XFixed *) malloc(numStops * sizeof(XFixed));\n\n    if (colors == NULL || stops == NULL) {\n        if (colors != NULL) {\n            free(colors);\n        }\n        if (stops != NULL) {\n            free(stops);\n        }\n        (*env)->ReleasePrimitiveArrayCritical(env, pixelsArray, pixels, JNI_ABORT);\n        (*env)->ReleasePrimitiveArrayCritical(env, fractionsArray, fractions, JNI_ABORT);\n        return -1;\n    }\n\n    for (i=0; i < numStops; i++) {\n      stops[i] = XDoubleToFixed(fractions[i]);\n      colors[i].alpha = pixels[i*4 + 0];\n      colors[i].red = pixels[i*4 + 1];\n      colors[i].green = pixels[i*4 + 2];\n      colors[i].blue = pixels[i*4 + 3];\n    }\n#ifdef __solaris__\n    if (XRenderCreateRadialGradientFunc != NULL) {\n        gradient = (jint) (*XRenderCreateRadialGradientFunc)(awt_display, &grad, stops, colors, numStops);\n    }\n#else\n    gradient = (jint) XRenderCreateRadialGradient(awt_display, &grad, stops, colors, numStops);\n#endif\n    free(colors);\n    free(stops);\n\n   (*env)->ReleasePrimitiveArrayCritical(env, pixelsArray, pixels, JNI_ABORT);\n   (*env)->ReleasePrimitiveArrayCritical(env, fractionsArray, fractions, JNI_ABORT);\n\n\n    if (gradient != 0) {\n        pict_attr.repeat = repeat;\n        XRenderChangePicture (awt_display, gradient, CPRepeat, &pict_attr);\n    }\n\n   return (jint) gradient;\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_setFilter\n (JNIEnv *env, jobject this, jint picture, jint filter) {\n\n  char * filterName = \"fast\";\n\n  switch(filter) {\n    case 0:\n      filterName = \"fast\";\n      break;\n\n    case 1:\n      filterName = \"good\";\n      break;\n\n    case 2:\n      filterName = \"best\";\n      break;\n  }\n\n    XRenderSetPictureFilter(awt_display, (Picture) picture, filterName, NULL, 0);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_XRSetClipNative\n    (JNIEnv *env, jclass xsd, jlong dst,\n     jint x1, jint y1, jint x2, jint y2,\n     jobject complexclip, jboolean isGC)\n{\n    int numrects;\n    XRectangle rects[256];\n    XRectangle *pRect = rects;\n\n    numrects = RegionToYXBandedRectangles(env,\n            x1, y1, x2, y2, complexclip,\n            &pRect, 256);\n\n    if (isGC == JNI_TRUE) {\n      if (dst != (jlong) 0) {\n          XSetClipRectangles(awt_display, (GC) jlong_to_ptr(dst), 0, 0, pRect, numrects, YXBanded);\n      }\n    } else {\n       XRenderSetPictureClipRectangles (awt_display, (Picture) dst, 0, 0, pRect, numrects);\n    }\n\n    if (pRect != rects) {\n        free(pRect);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_putMaskNative\n (JNIEnv *env, jclass cls, jint drawable, jlong gc, jbyteArray imageData,\n  jint sx, jint sy, jint dx, jint dy, jint width, jint height,\n  jint maskOff, jint maskScan, jfloat ea, jlong imgPtr) {\n\n    int line, pix;\n    char *mask;\n    char *defaultData;\n    XImage *defaultImg, *img;\n    jboolean imageFits;\n\n    if ((mask = (char *)\n         (*env)->GetPrimitiveArrayCritical(env, imageData, NULL)) == NULL) {\n        return;\n     }\n\n    defaultImg = (XImage *) jlong_to_ptr(imgPtr);\n\n    if (ea != 1.0f) {\n        for (line=0; line < height; line++) {\n            for (pix=0; pix < width; pix++) {\n                int index = maskScan*line + pix + maskOff;\n                mask[index] = (((unsigned char) mask[index])*ea);\n            }\n        }\n    }\n\n    /*\n    * 1. If existing XImage and supplied buffer match, only adjust the data pointer\n    * 2. If existing XImage is large enough to hold the data but does not match in\n    *    scan the data is copied to fit the XImage.\n    * 3. If data is larger than the existing XImage a new temporary XImage is\n    *    allocated.\n    * The default XImage is optimized for the AA tiles, which are currently 32x32.\n    */\n    defaultData = defaultImg->data;\n    img = defaultImg;\n    imageFits = defaultImg->width >= width && defaultImg->height >= height;\n\n    if (imageFits &&\n        maskOff == defaultImg->xoffset && maskScan == defaultImg->bytes_per_line) {\n        defaultImg->data = mask;\n    } else {\n        if (imageFits) {\n            for (line=0; line < height; line++) {\n                for (pix=0; pix < width; pix++) {\n                    img->data[line*img->bytes_per_line + pix] =\n                        (unsigned char) (mask[maskScan*line + pix + maskOff]);\n                }\n            }\n        } else {\n            img = XCreateImage(awt_display, NULL, 8, ZPixmap,\n                               maskOff, mask, maskScan, height, 8, 0);\n        }\n    }\n\n    XPutImage(awt_display, (Pixmap) drawable, (GC) jlong_to_ptr(gc),\n              img, 0, 0, 0, 0, width, height);\n    (*env)->ReleasePrimitiveArrayCritical(env, imageData, mask, JNI_ABORT);\n\n    if (img != defaultImg) {\n        img->data = NULL;\n        XDestroyImage(img);\n    }\n    defaultImg->data = defaultData;\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_XRAddGlyphsNative\n (JNIEnv *env, jclass cls, jint glyphSet,\n  jlongArray glyphInfoPtrsArray, jint glyphCnt,\n  jbyteArray pixelDataArray, int pixelDataLength) {\n    jlong *glyphInfoPtrs;\n    unsigned char *pixelData;\n    int i;\n\n    if (MAX_PAYLOAD / (sizeof(XGlyphInfo) + sizeof(Glyph))\n        < (unsigned)glyphCnt) {\n        /* glyphCnt too big, payload overflow */\n        return;\n    }\n\n    XGlyphInfo *xginfo = (XGlyphInfo *) malloc(sizeof(XGlyphInfo) * glyphCnt);\n    Glyph *gid = (Glyph *) malloc(sizeof(Glyph) * glyphCnt);\n\n    if (xginfo == NULL || gid == NULL) {\n        if (xginfo != NULL) {\n            free(xginfo);\n        }\n        if (gid != NULL) {\n            free(gid);\n        }\n        return;\n    }\n\n    if ((glyphInfoPtrs = (jlong *)(*env)->\n        GetPrimitiveArrayCritical(env, glyphInfoPtrsArray, NULL)) == NULL)\n    {\n        free(xginfo);\n        free(gid);\n        return;\n    }\n\n    if ((pixelData = (unsigned char *)\n        (*env)->GetPrimitiveArrayCritical(env, pixelDataArray, NULL)) == NULL)\n    {\n        (*env)->ReleasePrimitiveArrayCritical(env,\n                                glyphInfoPtrsArray, glyphInfoPtrs, JNI_ABORT);\n        free(xginfo);\n        free(gid);\n        return;\n    }\n\n    for (i=0; i < glyphCnt; i++) {\n      GlyphInfo *jginfo = (GlyphInfo *) jlong_to_ptr(glyphInfoPtrs[i]);\n\n      // 'jginfo->cellInfo' is of type 'void*'\n      // (see definition of 'GlyphInfo' in fontscalerdefs.h)\n      // 'Glyph' is typedefed to 'unsigned long'\n      // (see http://www.x.org/releases/X11R7.7/doc/libXrender/libXrender.txt)\n      // Maybe we should assert that (sizeof(void*) == sizeof(Glyph)) ?\n      gid[i] = (Glyph) (jginfo->cellInfo);\n      xginfo[i].x = (-jginfo->topLeftX);\n      xginfo[i].y = (-jginfo->topLeftY);\n      xginfo[i].width = jginfo->width;\n      xginfo[i].height = jginfo->height;\n      xginfo[i].xOff = round(jginfo->advanceX);\n      xginfo[i].yOff = round(jginfo->advanceY);\n    }\n\n    XRenderAddGlyphs(awt_display, glyphSet, &gid[0], &xginfo[0], glyphCnt,\n                     (const char*)pixelData, pixelDataLength);\n\n    (*env)->ReleasePrimitiveArrayCritical(env, glyphInfoPtrsArray, glyphInfoPtrs, JNI_ABORT);\n    (*env)->ReleasePrimitiveArrayCritical(env, pixelDataArray, pixelData, JNI_ABORT);\n\n    free(xginfo);\n    free(gid);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_XRFreeGlyphsNative\n (JNIEnv *env, jclass cls, jint glyphSet, jintArray gidArray, jint glyphCnt) {\n\n    if (MAX_PAYLOAD / sizeof(Glyph) < (unsigned)glyphCnt) {\n        /* glyphCnt too big, payload overflow */\n        return;\n    }\n\n    /* The glyph ids are 32 bit but may be stored in a 64 bit long on\n     * a 64 bit architecture. So optimise the 32 bit case to avoid\n     * extra stack or heap allocations by directly referencing the\n     * underlying Java array and only allocate on 64 bit.\n     */\n    if (sizeof(jint) == sizeof(Glyph)) {\n        jint *gids =\n            (*env)->GetPrimitiveArrayCritical(env, gidArray, NULL);\n        if (gids == NULL) {\n            return;\n        } else {\n             XRenderFreeGlyphs(awt_display,\n                               (GlyphSet)glyphSet, (Glyph *)gids, glyphCnt);\n             (*env)->ReleasePrimitiveArrayCritical(env, gidArray,\n                                                   gids, JNI_ABORT);\n        }\n        return;\n    } else {\n        Glyph stack_ids[64];\n        Glyph *gids = NULL;\n        jint* jgids = NULL;\n        int i;\n\n        if (glyphCnt <= 64) {\n            gids = stack_ids;\n        } else {\n            gids = (Glyph *)malloc(sizeof(Glyph) * glyphCnt);\n            if (gids == NULL) {\n                return;\n            }\n        }\n        jgids = (*env)->GetPrimitiveArrayCritical(env, gidArray, NULL);\n        if (jgids == NULL) {\n            if (gids != stack_ids) {\n                free(gids);\n            }\n            return;\n        }\n        for (i=0; i < glyphCnt; i++) {\n            gids[i] = jgids[i];\n        }\n        XRenderFreeGlyphs(awt_display,\n                          (GlyphSet) glyphSet, gids, glyphCnt);\n        (*env)->ReleasePrimitiveArrayCritical(env, gidArray,\n                                              jgids, JNI_ABORT);\n        if (gids != stack_ids) {\n            free(gids);\n        }\n    }\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_java2d_xr_XRBackendNative_XRenderCreateGlyphSetNative\n (JNIEnv *env, jclass cls, jlong format) {\n  return XRenderCreateGlyphSet(awt_display, (XRenderPictFormat *) jlong_to_ptr(format));\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_XRenderCompositeTextNative\n (JNIEnv *env, jclass cls, jint op, jint src, jint dst,\n  jint sx, jint sy, jlong maskFmt, jintArray eltArray,\n  jintArray  glyphIDArray, jint eltCnt, jint glyphCnt) {\n    jint i;\n    jint *ids;\n    jint *elts;\n    XGlyphElt32 *xelts;\n    unsigned int *xids;\n    XGlyphElt32 selts[24];\n    unsigned int sids[256];\n    int charCnt = 0;\n\n    if ((MAX_PAYLOAD / sizeof(XGlyphElt32) < (unsigned)eltCnt)\n        || (MAX_PAYLOAD / sizeof(unsigned int) < (unsigned)glyphCnt)\n        || ((MAX_PAYLOAD - sizeof(XGlyphElt32)*(unsigned)eltCnt) /\n            sizeof(unsigned int) < (unsigned)glyphCnt))\n    {\n        /* (eltCnt, glyphCnt) too big, payload overflow */\n        return;\n    }\n\n    if (eltCnt <= 24) {\n      xelts = &selts[0];\n    }else {\n      xelts = (XGlyphElt32 *) malloc(sizeof(XGlyphElt32) * eltCnt);\n      if (xelts == NULL) {\n          return;\n      }\n    }\n\n    if (glyphCnt <= 256) {\n      xids = &sids[0];\n    } else {\n      xids = (unsigned int*)malloc(sizeof(unsigned int) * glyphCnt);\n      if (xids == NULL) {\n          if (xelts != &selts[0]) {\n            free(xelts);\n          }\n          return;\n      }\n    }\n\n    if ((ids = (jint *)\n         (*env)->GetPrimitiveArrayCritical(env, glyphIDArray, NULL)) == NULL) {\n        if (xelts != &selts[0]) {\n            free(xelts);\n        }\n        if (xids != &sids[0]) {\n            free(xids);\n        }\n        return;\n    }\n    if ((elts = (jint *)\n          (*env)->GetPrimitiveArrayCritical(env, eltArray, NULL)) == NULL) {\n        (*env)->ReleasePrimitiveArrayCritical(env,\n                                              glyphIDArray, ids, JNI_ABORT);\n        if (xelts != &selts[0]) {\n            free(xelts);\n        }\n        if (xids != &sids[0]) {\n            free(xids);\n        }\n        return;\n    }\n\n    for (i=0; i < glyphCnt; i++) {\n      xids[i] = ids[i];\n    }\n\n    for (i=0; i < eltCnt; i++) {\n      xelts[i].nchars = elts[i*4 + 0];\n      xelts[i].xOff = elts[i*4 + 1];\n      xelts[i].yOff = elts[i*4 + 2];\n      xelts[i].glyphset = (GlyphSet) elts[i*4 + 3];\n      xelts[i].chars = &xids[charCnt];\n\n      charCnt += xelts[i].nchars;\n    }\n\n    XRenderCompositeText32(awt_display, op, (Picture) src, (Picture) dst,\n                           (XRenderPictFormat *) jlong_to_ptr(maskFmt),\n                            sx, sy, 0, 0, xelts, eltCnt);\n\n    (*env)->ReleasePrimitiveArrayCritical(env, glyphIDArray, ids, JNI_ABORT);\n    (*env)->ReleasePrimitiveArrayCritical(env, eltArray, elts, JNI_ABORT);\n\n    if (xelts != &selts[0]) {\n        free(xelts);\n    }\n\n    if (xids != &sids[0]) {\n        free(xids);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_setGCMode\n (JNIEnv *env, jobject this, jlong gc, jboolean copy) {\n  GC xgc = (GC) jlong_to_ptr(gc);\n\n  if (copy == JNI_TRUE) {\n    XSetFunction(awt_display, xgc, GXcopy);\n  } else {\n    XSetFunction(awt_display, xgc, GXxor);\n  }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_GCRectanglesNative\n (JNIEnv *env, jclass xsd, jint dst, jlong gc,\n  jintArray rectArray, jint rectCnt) {\n    int i;\n    jint* rects;\n    XRectangle *xRects;\n    XRectangle sRects[256];\n\n    if (rectCnt <= 256) {\n      xRects = &sRects[0];\n    } else {\n      if (MAXUINT / sizeof(XRectangle) < (unsigned)rectCnt) {\n        /* rectCnt too big, integer overflow */\n        return;\n      }\n\n      xRects = (XRectangle *) malloc(sizeof(XRectangle) * rectCnt);\n      if (xRects == NULL) {\n        return;\n      }\n    }\n\n    if ((rects = (jint*)\n         (*env)->GetPrimitiveArrayCritical(env, rectArray, NULL)) == NULL) {\n        if (xRects != &sRects[0]) {\n            free(xRects);\n        }\n        return;\n    }\n\n    for (i=0; i < rectCnt; i++) {\n      xRects[i].x = rects[i*4 + 0];\n      xRects[i].y = rects[i*4 + 1];\n      xRects[i].width = rects[i*4 + 2];\n      xRects[i].height = rects[i*4 + 3];\n    }\n\n    XFillRectangles(awt_display, (Drawable) dst, (GC) jlong_to_ptr(gc), xRects, rectCnt);\n\n    (*env)->ReleasePrimitiveArrayCritical(env, rectArray, rects, JNI_ABORT);\n    if (xRects != &sRects[0]) {\n      free(xRects);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_java2d_xr_XRBackendNative_renderCompositeTrapezoidsNative\n (JNIEnv *env, jclass cls, jbyte op, jint src, jlong maskFmt,\n jint dst, jint srcX, jint srcY, jintArray  trapArray) {\n    jint *traps;\n\n    if ((traps = (jint *) (*env)->GetPrimitiveArrayCritical(env, trapArray, NULL)) == NULL) {\n      return;\n    }\n\n    XRenderCompositeTrapezoids(awt_display, op, (Picture) src, (Picture) dst,\n                               (XRenderPictFormat *) jlong_to_ptr(maskFmt),\n                               srcX, srcY, (XTrapezoid *) (traps+5), traps[0]);\n\n    (*env)->ReleasePrimitiveArrayCritical(env, trapArray, traps, JNI_ABORT);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h": "/*\n * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#ifndef OGLFuncs_md_h_Included\n#define OGLFuncs_md_h_Included\n\n#include <stdlib.h>\n#ifndef MACOSX\n#include <dlfcn.h>\n#endif\n#include \"jvm_md.h\"\n#include \"J2D_GL/glx.h\"\n#include \"OGLFuncMacros.h\"\n\n/**\n * GLX 1.2 functions\n */\ntypedef void (GLAPIENTRY *glXDestroyContextType)(Display *dpy, GLXContext ctx);\ntypedef GLXContext (GLAPIENTRY *glXGetCurrentContextType)(void);\ntypedef GLXDrawable (GLAPIENTRY *glXGetCurrentDrawableType)(void);\ntypedef Bool (GLAPIENTRY *glXIsDirectType)(Display *dpy, GLXContext ctx);\ntypedef Bool (GLAPIENTRY *glXQueryExtensionType)(Display *dpy, int *errorBase, int *eventBase);\ntypedef Bool (GLAPIENTRY *glXQueryVersionType)(Display *dpy, int *major, int *minor);\ntypedef void (GLAPIENTRY *glXSwapBuffersType)(Display *dpy, GLXDrawable drawable);\ntypedef const char * (GLAPIENTRY *glXGetClientStringType)(Display *dpy, int name);\ntypedef const char * (GLAPIENTRY *glXQueryServerStringType)(Display *dpy, int screen, int name);\ntypedef const char * (GLAPIENTRY *glXQueryExtensionsStringType)(Display *dpy, int screen);\ntypedef void (GLAPIENTRY *glXWaitGLType)(void);\n\n/**\n * GLX 1.3 functions\n */\ntypedef GLXFBConfig * (GLAPIENTRY *glXGetFBConfigsType)(Display *dpy, int screen, int *nelements);\ntypedef GLXFBConfig * (GLAPIENTRY *glXChooseFBConfigType)(Display *dpy, int screen, const int *attrib_list, int *nelements);\ntypedef int (GLAPIENTRY *glXGetFBConfigAttribType)(Display *dpy, GLXFBConfig  config, int attribute, int *value);\ntypedef XVisualInfo * (GLAPIENTRY *glXGetVisualFromFBConfigType)(Display *dpy, GLXFBConfig  config);\ntypedef GLXWindow (GLAPIENTRY *glXCreateWindowType)(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);\ntypedef void (GLAPIENTRY *glXDestroyWindowType)(Display *dpy, GLXWindow win);\ntypedef GLXPbuffer (GLAPIENTRY *glXCreatePbufferType)(Display *dpy, GLXFBConfig config, const int *attrib_list);\ntypedef void (GLAPIENTRY *glXDestroyPbufferType)(Display *dpy, GLXPbuffer pbuffer);\ntypedef void (GLAPIENTRY *glXQueryDrawableType)(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);\ntypedef GLXContext (GLAPIENTRY *glXCreateNewContextType)(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);\ntypedef Bool (GLAPIENTRY *glXMakeContextCurrentType)(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);\ntypedef GLXDrawable (GLAPIENTRY *glXGetCurrentReadDrawableType)(void);\ntypedef int (GLAPIENTRY *glXQueryContextType)(Display *dpy, GLXContext ctx, int attribute, int *value);\ntypedef void (GLAPIENTRY *glXSelectEventType)(Display *dpy, GLXDrawable draw, unsigned long event_mask);\ntypedef void (GLAPIENTRY *glXGetSelectedEventType)(Display *dpy, GLXDrawable draw, unsigned long *event_mask);\n\n/**\n * GLX extension functions\n */\ntypedef void * (GLAPIENTRY *glXGetProcAddressType)(const char *);\n\n/*\n * Note: Historically we have used dlopen/dlsym() to load function pointers\n * from libgl.so, and things have worked fine.  However, we have run into at\n * least one case (on ATI's Linux drivers) where dlsym() will return NULL\n * when trying to load functions from the GL_ARB_fragment_shader extension.\n * Plausibly this is a bug in their drivers (other extension functions load\n * just fine on those same drivers), but for a number of years there has been\n * a glXGetProcAddressARB() extension available that is intended to be the\n * primary means for an application to load extension functions in a reliable\n * manner.  So while dlsym() will return NULL for those shader-related\n * functions, glXGetProcAddressARB() works just fine.\n *\n * I haven't used the glXGetProcAddress() approach in the past because it\n * seemed unnecessary (i.e. dlsym() was working fine), but upon further\n * reading I think we should use glXGetProcAddress() in favor of dlsym(),\n * not only to work around this \"bug\", but also to be safer going forward.\n *\n * Just to complicate matters, glXGetProcAddress() was proposed to be added\n * into the GLX 1.4 spec, which is still (as yet) unfinalized.  Sun's OGL 1.3\n * implementation reports its GLX version as 1.4, and therefore includes\n * the glXGetProcAddress() entrypoint, but does not include\n * GLX_ARB_get_proc_address in its extension string nor does it export the\n * glXGetProcAddressARB() entrypoint.  On the other hand, ATI's Linux drivers\n * (as well as Nvidia's Linux and Solaris drivers) currently report their\n * GLX version as 1.3, but they do export the glXGetProcAddressARB()\n * entrypoint and its associated extension string.  So to make this work\n * everywhere, we first try to load the glXGetProcAddress() entrypoint,\n * failing that we try the glXGetProcAddressARB() entrypoint, and if that\n * fails too, then we close libGL.so and do not bother trying to initialize\n * the rest of the OGL pipeline.\n */\n\n#define OGL_LIB_HANDLE pLibGL\n#define OGL_DECLARE_LIB_HANDLE() \\\n    static glXGetProcAddressType j2d_glXGetProcAddress; \\\n    static void *OGL_LIB_HANDLE = NULL\n#define OGL_LIB_IS_UNINITIALIZED() \\\n    (OGL_LIB_HANDLE == NULL)\n#define OGL_OPEN_LIB() \\\ndo { \\\n    { \\\n        char *libGLPath = getenv(\"J2D_ALT_LIBGL_PATH\"); \\\n        if (libGLPath == NULL) { \\\n            libGLPath = VERSIONED_JNI_LIB_NAME(\"GL\", \"1\"); \\\n        } \\\n        OGL_LIB_HANDLE = dlopen(libGLPath, RTLD_LAZY | RTLD_LOCAL); \\\n    } \\\n    if (OGL_LIB_HANDLE) { \\\n        j2d_glXGetProcAddress = (glXGetProcAddressType) \\\n            dlsym(OGL_LIB_HANDLE, \"glXGetProcAddress\"); \\\n        if (j2d_glXGetProcAddress == NULL) { \\\n            j2d_glXGetProcAddress = (glXGetProcAddressType) \\\n                dlsym(OGL_LIB_HANDLE, \"glXGetProcAddressARB\"); \\\n            if (j2d_glXGetProcAddress == NULL) { \\\n                dlclose(OGL_LIB_HANDLE); \\\n                OGL_LIB_HANDLE = NULL; \\\n            } \\\n        } \\\n    } \\\n} while (0)\n#define OGL_CLOSE_LIB() \\\n    dlclose(OGL_LIB_HANDLE)\n#define OGL_GET_PROC_ADDRESS(f) \\\n    j2d_glXGetProcAddress(#f)\n#define OGL_GET_EXT_PROC_ADDRESS(f) \\\n    OGL_GET_PROC_ADDRESS(f)\n\n#define OGL_EXPRESS_PLATFORM_FUNCS(action) \\\n    OGL_##action##_FUNC(glXDestroyContext); \\\n    OGL_##action##_FUNC(glXGetCurrentContext); \\\n    OGL_##action##_FUNC(glXGetCurrentDrawable); \\\n    OGL_##action##_FUNC(glXIsDirect); \\\n    OGL_##action##_FUNC(glXQueryExtension); \\\n    OGL_##action##_FUNC(glXQueryVersion); \\\n    OGL_##action##_FUNC(glXSwapBuffers); \\\n    OGL_##action##_FUNC(glXGetClientString); \\\n    OGL_##action##_FUNC(glXQueryServerString); \\\n    OGL_##action##_FUNC(glXQueryExtensionsString); \\\n    OGL_##action##_FUNC(glXWaitGL); \\\n    OGL_##action##_FUNC(glXGetFBConfigs); \\\n    OGL_##action##_FUNC(glXChooseFBConfig); \\\n    OGL_##action##_FUNC(glXGetFBConfigAttrib); \\\n    OGL_##action##_FUNC(glXGetVisualFromFBConfig); \\\n    OGL_##action##_FUNC(glXCreateWindow); \\\n    OGL_##action##_FUNC(glXDestroyWindow); \\\n    OGL_##action##_FUNC(glXCreatePbuffer); \\\n    OGL_##action##_FUNC(glXDestroyPbuffer); \\\n    OGL_##action##_FUNC(glXQueryDrawable); \\\n    OGL_##action##_FUNC(glXCreateNewContext); \\\n    OGL_##action##_FUNC(glXMakeContextCurrent); \\\n    OGL_##action##_FUNC(glXGetCurrentReadDrawable); \\\n    OGL_##action##_FUNC(glXQueryContext); \\\n    OGL_##action##_FUNC(glXSelectEvent); \\\n    OGL_##action##_FUNC(glXGetSelectedEvent);\n\n#define OGL_EXPRESS_PLATFORM_EXT_FUNCS(action)\n\n#endif /* OGLFuncs_md_h_Included */\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/security/smartcardio/pcsc_md.c": "/*\n * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include <dlfcn.h>\n\n#include <winscard.h>\n\n#include \"sun_security_smartcardio_PlatformPCSC.h\"\n\n#include \"pcsc_md.h\"\n\n#ifndef USE_SYSTEM_PCSC\nvoid *hModule;\nFPTR_SCardEstablishContext scardEstablishContext;\nFPTR_SCardConnect scardConnect;\nFPTR_SCardDisconnect scardDisconnect;\nFPTR_SCardStatus scardStatus;\nFPTR_SCardGetStatusChange scardGetStatusChange;\nFPTR_SCardTransmit scardTransmit;\nFPTR_SCardListReaders scardListReaders;\nFPTR_SCardBeginTransaction scardBeginTransaction;\nFPTR_SCardEndTransaction scardEndTransaction;\nFPTR_SCardControl scardControl;\n#endif\n\n/*\n * Throws a Java Exception by name\n */\nvoid throwByName(JNIEnv *env, const char *name, const char *msg)\n{\n    jclass cls = (*env)->FindClass(env, name);\n\n    if (cls != 0) /* Otherwise an exception has already been thrown */\n        (*env)->ThrowNew(env, cls, msg);\n}\n\n/*\n * Throws java.lang.NullPointerException\n */\nvoid throwNullPointerException(JNIEnv *env, const char *msg)\n{\n    throwByName(env, \"java/lang/NullPointerException\", msg);\n}\n\n/*\n * Throws java.io.IOException\n */\nvoid throwIOException(JNIEnv *env, const char *msg)\n{\n    throwByName(env, \"java/io/IOException\", msg);\n}\n\n#ifndef USE_SYSTEM_PCSC\nvoid *findFunction(JNIEnv *env, void *hModule, char *functionName) {\n    void *fAddress = dlsym(hModule, functionName);\n    if (fAddress == NULL) {\n        char errorMessage[256];\n        snprintf(errorMessage, sizeof(errorMessage), \"Symbol not found: %s\", functionName);\n        throwNullPointerException(env, errorMessage);\n        return NULL;\n    }\n    return fAddress;\n}\n#endif\n\nJNIEXPORT void JNICALL Java_sun_security_smartcardio_PlatformPCSC_initialize\n        (JNIEnv *env, jclass thisClass, jstring jLibName) {\n#ifndef USE_SYSTEM_PCSC\n    const char *libName = (*env)->GetStringUTFChars(env, jLibName, NULL);\n    if (libName == NULL) {\n        throwNullPointerException(env, \"PCSC library name is null\");\n        return;\n    }\n    hModule = dlopen(libName, RTLD_LAZY);\n    (*env)->ReleaseStringUTFChars(env, jLibName, libName);\n\n    if (hModule == NULL) {\n        throwIOException(env, dlerror());\n        return;\n    }\n    scardEstablishContext = (FPTR_SCardEstablishContext)findFunction(env, hModule, \"SCardEstablishContext\");\n    if ((*env)->ExceptionCheck(env)) {\n         return;\n    }\n    scardConnect          = (FPTR_SCardConnect)         findFunction(env, hModule, \"SCardConnect\");\n    if ((*env)->ExceptionCheck(env)) {\n         return;\n    }\n    scardDisconnect       = (FPTR_SCardDisconnect)      findFunction(env, hModule, \"SCardDisconnect\");\n    if ((*env)->ExceptionCheck(env)) {\n         return;\n    }\n    scardStatus           = (FPTR_SCardStatus)          findFunction(env, hModule, \"SCardStatus\");\n    if ((*env)->ExceptionCheck(env)) {\n         return;\n    }\n    scardGetStatusChange  = (FPTR_SCardGetStatusChange) findFunction(env, hModule, \"SCardGetStatusChange\");\n    if ((*env)->ExceptionCheck(env)) {\n         return;\n    }\n    scardTransmit         = (FPTR_SCardTransmit)        findFunction(env, hModule, \"SCardTransmit\");\n    if ((*env)->ExceptionCheck(env)) {\n         return;\n    }\n    scardListReaders      = (FPTR_SCardListReaders)     findFunction(env, hModule, \"SCardListReaders\");\n    if ((*env)->ExceptionCheck(env)) {\n         return;\n    }\n    scardBeginTransaction = (FPTR_SCardBeginTransaction)findFunction(env, hModule, \"SCardBeginTransaction\");\n    if ((*env)->ExceptionCheck(env)) {\n         return;\n    }\n    scardEndTransaction   = (FPTR_SCardEndTransaction)  findFunction(env, hModule, \"SCardEndTransaction\");\n    if ((*env)->ExceptionCheck(env)) {\n         return;\n    }\n#ifndef __APPLE__\n    scardControl          = (FPTR_SCardControl)         findFunction(env, hModule, \"SCardControl\");\n#else\n    scardControl          = (FPTR_SCardControl)         findFunction(env, hModule, \"SCardControl132\");\n#endif // __APPLE__\n\n#endif // USE_SYSTEM_PCSC\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c": "/*\n * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include \"NativeFunc.h\"\n\n/* standard GSS method names (ordering is from mapfile) */\nstatic const char RELEASE_NAME[]                = \"gss_release_name\";\nstatic const char IMPORT_NAME[]                 = \"gss_import_name\";\nstatic const char COMPARE_NAME[]                = \"gss_compare_name\";\nstatic const char CANONICALIZE_NAME[]           = \"gss_canonicalize_name\";\nstatic const char EXPORT_NAME[]                 = \"gss_export_name\";\nstatic const char DISPLAY_NAME[]                = \"gss_display_name\";\nstatic const char ACQUIRE_CRED[]                = \"gss_acquire_cred\";\nstatic const char RELEASE_CRED[]                = \"gss_release_cred\";\nstatic const char INQUIRE_CRED[]                = \"gss_inquire_cred\";\nstatic const char IMPORT_SEC_CONTEXT[]          = \"gss_import_sec_context\";\nstatic const char INIT_SEC_CONTEXT[]            = \"gss_init_sec_context\";\nstatic const char ACCEPT_SEC_CONTEXT[]          = \"gss_accept_sec_context\";\nstatic const char INQUIRE_CONTEXT[]             = \"gss_inquire_context\";\nstatic const char DELETE_SEC_CONTEXT[]          = \"gss_delete_sec_context\";\nstatic const char CONTEXT_TIME[]                = \"gss_context_time\";\nstatic const char WRAP_SIZE_LIMIT[]             = \"gss_wrap_size_limit\";\nstatic const char EXPORT_SEC_CONTEXT[]          = \"gss_export_sec_context\";\nstatic const char GET_MIC[]                     = \"gss_get_mic\";\nstatic const char VERIFY_MIC[]                  = \"gss_verify_mic\";\nstatic const char WRAP[]                        = \"gss_wrap\";\nstatic const char UNWRAP[]                      = \"gss_unwrap\";\nstatic const char INDICATE_MECHS[]              = \"gss_indicate_mechs\";\nstatic const char INQUIRE_NAMES_FOR_MECH[]      = \"gss_inquire_names_for_mech\";\n\n/* additional GSS methods not public thru mapfile */\n\nstatic const char ADD_OID_SET_MEMBER[]          = \"gss_add_oid_set_member\";\nstatic const char DISPLAY_STATUS[]              = \"gss_display_status\";\nstatic const char CREATE_EMPTY_OID_SET[]        = \"gss_create_empty_oid_set\";\nstatic const char RELEASE_OID_SET[]             = \"gss_release_oid_set\";\nstatic const char RELEASE_BUFFER[]              = \"gss_release_buffer\";\n\n/**\n * Initialize native GSS function pointers\n */\nchar* loadNative(const char *libName) {\n\n    char *error;\n    void *gssLib;\n    int failed;\n    OM_uint32 minor, major;\n\n    ftab = NULL;\n    failed = FALSE;\n    error = NULL;\n\n    gssLib = dlopen(libName, RTLD_NOW);\n    if (gssLib == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    /* global function table instance */\n    ftab = (GSS_FUNCTION_TABLE_PTR)malloc(sizeof(GSS_FUNCTION_TABLE));\n    if (ftab == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->releaseName = (RELEASE_NAME_FN_PTR)dlsym(gssLib, RELEASE_NAME);\n    if (ftab->releaseName == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->importName = (IMPORT_NAME_FN_PTR)dlsym(gssLib, IMPORT_NAME);\n    if (ftab->importName == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->compareName = (COMPARE_NAME_FN_PTR)dlsym(gssLib, COMPARE_NAME);\n    if (ftab->compareName == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->canonicalizeName = (CANONICALIZE_NAME_FN_PTR)\n                                dlsym(gssLib, CANONICALIZE_NAME);\n    if (ftab->canonicalizeName == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->exportName = (EXPORT_NAME_FN_PTR)dlsym(gssLib, EXPORT_NAME);\n    if (ftab->exportName == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->displayName = (DISPLAY_NAME_FN_PTR)dlsym(gssLib, DISPLAY_NAME);\n    if (ftab->displayName == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->acquireCred = (ACQUIRE_CRED_FN_PTR)dlsym(gssLib, ACQUIRE_CRED);\n    if (ftab->acquireCred == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->releaseCred = (RELEASE_CRED_FN_PTR)dlsym(gssLib, RELEASE_CRED);\n    if (ftab->releaseCred == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->inquireCred = (INQUIRE_CRED_FN_PTR)dlsym(gssLib, INQUIRE_CRED);\n    if (ftab->inquireCred == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->importSecContext = (IMPORT_SEC_CONTEXT_FN_PTR)\n                        dlsym(gssLib, IMPORT_SEC_CONTEXT);\n    if (ftab->importSecContext == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->initSecContext = (INIT_SEC_CONTEXT_FN_PTR)\n                        dlsym(gssLib, INIT_SEC_CONTEXT);\n    if (ftab->initSecContext == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->acceptSecContext = (ACCEPT_SEC_CONTEXT_FN_PTR)\n                        dlsym(gssLib, ACCEPT_SEC_CONTEXT);\n    if (ftab->acceptSecContext == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->inquireContext = (INQUIRE_CONTEXT_FN_PTR)\n                        dlsym(gssLib, INQUIRE_CONTEXT);\n    if (ftab->inquireContext == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->deleteSecContext = (DELETE_SEC_CONTEXT_FN_PTR)\n                        dlsym(gssLib, DELETE_SEC_CONTEXT);\n    if (ftab->deleteSecContext == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->contextTime = (CONTEXT_TIME_FN_PTR)dlsym(gssLib, CONTEXT_TIME);\n    if (ftab->contextTime == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->wrapSizeLimit = (WRAP_SIZE_LIMIT_FN_PTR)\n                        dlsym(gssLib, WRAP_SIZE_LIMIT);\n    if (ftab->wrapSizeLimit == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->exportSecContext = (EXPORT_SEC_CONTEXT_FN_PTR)\n                        dlsym(gssLib, EXPORT_SEC_CONTEXT);\n    if (ftab->exportSecContext == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->getMic = (GET_MIC_FN_PTR)dlsym(gssLib, GET_MIC);\n    if (ftab->getMic == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->verifyMic = (VERIFY_MIC_FN_PTR)dlsym(gssLib, VERIFY_MIC);\n    if (ftab->verifyMic == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->wrap = (WRAP_FN_PTR)dlsym(gssLib, WRAP);\n    if (ftab->wrap == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->unwrap = (UNWRAP_FN_PTR)dlsym(gssLib, UNWRAP);\n    if (ftab->unwrap == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->indicateMechs = (INDICATE_MECHS_FN_PTR)dlsym(gssLib, INDICATE_MECHS);\n    if (ftab->indicateMechs == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->inquireNamesForMech = (INQUIRE_NAMES_FOR_MECH_FN_PTR)\n                        dlsym(gssLib, INQUIRE_NAMES_FOR_MECH);\n    if (ftab->inquireNamesForMech == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->addOidSetMember = (ADD_OID_SET_MEMBER_FN_PTR)\n                        dlsym(gssLib, ADD_OID_SET_MEMBER);\n    if (ftab->addOidSetMember == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->displayStatus = (DISPLAY_STATUS_FN_PTR)\n                        dlsym(gssLib, DISPLAY_STATUS);\n    if (ftab->displayStatus == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->createEmptyOidSet = (CREATE_EMPTY_OID_SET_FN_PTR)\n                        dlsym(gssLib, CREATE_EMPTY_OID_SET);\n    if (ftab->createEmptyOidSet == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->releaseOidSet = (RELEASE_OID_SET_FN_PTR)\n                        dlsym(gssLib, RELEASE_OID_SET);\n    if (ftab->releaseOidSet == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->releaseBuffer = (RELEASE_BUFFER_FN_PTR)\n                        dlsym(gssLib, RELEASE_BUFFER);\n    if (ftab->releaseBuffer == NULL) {\n        failed = TRUE;\n        goto out;\n    }\n\n    ftab->mechs = GSS_C_NO_OID_SET;\n    major = (*ftab->indicateMechs)(&minor, &(ftab->mechs));\n    if (ftab->mechs == NULL || ftab->mechs == GSS_C_NO_OID_SET) {\n        failed = TRUE;\n        goto out;\n    }\n\n\nout:\n    if (failed == TRUE) {\n        error = dlerror();\n        if (gssLib != NULL) dlclose(gssLib);\n        if (ftab != NULL) free(ftab);\n    }\n    return error;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/security/pkcs11/j2secmod_md.c": "/*\n * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <dlfcn.h>\n\n#include <jni_util.h>\n\n#include \"j2secmod.h\"\n#include \"wrapper/pkcs11wrapper.h\"\n\nvoid *findFunction(JNIEnv *env, jlong jHandle, const char *functionName) {\n    void *hModule = (void*)jlong_to_ptr(jHandle);\n    void *fAddress = dlsym(hModule, functionName);\n    if (fAddress == NULL) {\n        char errorMessage[256];\n        snprintf(errorMessage, sizeof(errorMessage), \"Symbol not found: %s\", functionName);\n        throwNullPointerException(env, errorMessage);\n        return NULL;\n    }\n    return fAddress;\n}\n\nJNIEXPORT jlong JNICALL Java_sun_security_pkcs11_Secmod_nssGetLibraryHandle\n  (JNIEnv *env, jclass thisClass, jstring jLibName)\n{\n    const char *libName = (*env)->GetStringUTFChars(env, jLibName, NULL);\n    if (libName == NULL) {\n        return 0L;\n    }\n\n    // look up existing handle only, do not load\n#if defined(AIX)\n    void *hModule = dlopen(libName, RTLD_LAZY);\n#else\n    void *hModule = dlopen(libName, RTLD_NOLOAD);\n#endif\n    dprintf2(\"-handle for %s: %u\\n\", libName, hModule);\n    (*env)->ReleaseStringUTFChars(env, jLibName, libName);\n    return ptr_to_jlong(hModule);\n}\n\nJNIEXPORT jlong JNICALL Java_sun_security_pkcs11_Secmod_nssLoadLibrary\n  (JNIEnv *env, jclass thisClass, jstring jLibName)\n{\n    void *hModule;\n    const char *libName = (*env)->GetStringUTFChars(env, jLibName, NULL);\n    if (libName == NULL) {\n        return 0L;\n    }\n\n    dprintf1(\"-lib %s\\n\", libName);\n    hModule = dlopen(libName, RTLD_LAZY);\n    (*env)->ReleaseStringUTFChars(env, jLibName, libName);\n    dprintf2(\"-handle: %u (0X%X)\\n\", hModule, hModule);\n\n    if (hModule == NULL) {\n        throwIOException(env, dlerror());\n        return 0;\n    }\n\n    return ptr_to_jlong(hModule);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c": "/*\n * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.\n */\n\n/* Copyright  (c) 2002 Graz University of Technology. All rights reserved.\n *\n * Redistribution and use in  source and binary forms, with or without\n * modification, are permitted  provided that the following conditions are met:\n *\n * 1. Redistributions of  source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in  binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. The end-user documentation included with the redistribution, if any, must\n *    include the following acknowledgment:\n *\n *    \"This product includes software developed by IAIK of Graz University of\n *     Technology.\"\n *\n *    Alternately, this acknowledgment may appear in the software itself, if\n *    and wherever such third-party acknowledgments normally appear.\n *\n * 4. The names \"Graz University of Technology\" and \"IAIK of Graz University of\n *    Technology\" must not be used to endorse or promote products derived from\n *    this software without prior written permission.\n *\n * 5. Products derived from this software may not be called\n *    \"IAIK PKCS Wrapper\", nor may \"IAIK\" appear in their name, without prior\n *    written permission of Graz University of Technology.\n *\n *  THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESSED OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LICENSOR BE\n *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n *  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n *  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY  OF SUCH DAMAGE.\n */\n\n/*\n * pkcs11wrapper.c\n * 18.05.2001\n *\n * This module contains the native functions of the Java to PKCS#11 interface\n * which are platform dependent. This includes loading a dynamic link libary,\n * retrieving the function list and unloading the dynamic link library.\n *\n * @author Karl Scheibelhofer <Karl.Scheibelhofer@iaik.at>\n */\n\n#include \"pkcs11wrapper.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include <dlfcn.h>\n\n#include <jni.h>\n\n#include \"sun_security_pkcs11_wrapper_PKCS11.h\"\n\n/*\n * Class:     sun_security_pkcs11_wrapper_PKCS11\n * Method:    connect\n * Signature: (Ljava/lang/String;)V\n */\nJNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_connect\n    (JNIEnv *env, jobject obj, jstring jPkcs11ModulePath, jstring jGetFunctionList)\n{\n    void *hModule;\n    char *error;\n    CK_C_GetFunctionList C_GetFunctionList=NULL;\n    CK_RV rv;\n    ModuleData *moduleData;\n    jobject globalPKCS11ImplementationReference;\n    char *systemErrorMessage;\n    char *exceptionMessage;\n    const char *getFunctionListStr;\n\n    const char *libraryNameStr = (*env)->GetStringUTFChars(env, jPkcs11ModulePath, 0);\n    if (libraryNameStr == NULL) {\n        return;\n    }\n    TRACE1(\"DEBUG: connect to PKCS#11 module: %s ... \", libraryNameStr);\n\n\n    /*\n     * Load the PKCS #11 DLL\n     */\n    dlerror(); /* clear any old error message not fetched */\n#ifdef DEBUG\n    hModule = dlopen(libraryNameStr, RTLD_NOW);\n#else\n    hModule = dlopen(libraryNameStr, RTLD_LAZY);\n#endif /* DEBUG */\n\n    if (hModule == NULL) {\n        systemErrorMessage = dlerror();\n        exceptionMessage = (char *) malloc(sizeof(char) * (strlen(systemErrorMessage) + strlen(libraryNameStr) + 1));\n        if (exceptionMessage == NULL) {\n            throwOutOfMemoryError(env, 0);\n            return;\n        }\n        strcpy(exceptionMessage, systemErrorMessage);\n        strcat(exceptionMessage, libraryNameStr);\n        throwIOException(env, exceptionMessage);\n        (*env)->ReleaseStringUTFChars(env, jPkcs11ModulePath, libraryNameStr);\n        free(exceptionMessage);\n        return;\n    }\n\n    /*\n     * Get function pointer to C_GetFunctionList\n     */\n    dlerror(); /* clear any old error message not fetched */\n    // with the old JAR file jGetFunctionList is null, temporarily check for that\n    if (jGetFunctionList != NULL) {\n        getFunctionListStr = (*env)->GetStringUTFChars(env, jGetFunctionList, 0);\n        if (getFunctionListStr == NULL) {\n            return;\n        }\n        C_GetFunctionList = (CK_C_GetFunctionList) dlsym(hModule, getFunctionListStr);\n        (*env)->ReleaseStringUTFChars(env, jGetFunctionList, getFunctionListStr);\n    }\n    if (C_GetFunctionList == NULL) {\n        throwIOException(env, \"ERROR: C_GetFunctionList == NULL\");\n        return;\n    } else if ( (systemErrorMessage = dlerror()) != NULL ){\n        throwIOException(env, systemErrorMessage);\n        return;\n    }\n\n    /*\n     * Get function pointers to all PKCS #11 functions\n     */\n    moduleData = (ModuleData *) malloc(sizeof(ModuleData));\n    if (moduleData == NULL) {\n        dlclose(hModule);\n        throwOutOfMemoryError(env, 0);\n        return;\n    }\n    moduleData->hModule = hModule;\n    moduleData->applicationMutexHandler = NULL;\n    rv = (C_GetFunctionList)(&(moduleData->ckFunctionListPtr));\n    globalPKCS11ImplementationReference = (*env)->NewGlobalRef(env, obj);\n    putModuleEntry(env, globalPKCS11ImplementationReference, moduleData);\n\n    (*env)->ReleaseStringUTFChars(env, jPkcs11ModulePath, libraryNameStr);\n    TRACE0(\"FINISHED\\n\");\n\n    if(ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n}\n\n/*\n * Class:     sun_security_pkcs11_wrapper_PKCS11\n * Method:    disconnect\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_disconnect\n    (JNIEnv *env, jobject obj)\n{\n    ModuleData *moduleData;\n    TRACE0(\"DEBUG: disconnecting module...\");\n    moduleData = removeModuleEntry(env, obj);\n\n    if (moduleData != NULL) {\n        dlclose(moduleData->hModule);\n    }\n\n    free(moduleData);\n    TRACE0(\"FINISHED\\n\");\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/xawt/gnome_interface.c": "/*\n * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"gnome_interface.h\"\n\nGNOME_URL_SHOW_TYPE *gnome_url_show = NULL;\n\ngboolean gnome_load() {\n     void *vfs_handle;\n     void *gnome_handle;\n     const char *errmsg;\n     GNOME_VFS_INIT_TYPE *gnome_vfs_init;\n\n     // trying to open the gnomevfs. VERSIONED_JNI_LIB_NAME\n     // macros formats the library name in a system specific manner\n     // see jdk/src/solaris/javavm/export/jvm_md.h for more details\n     vfs_handle = dlopen(VERSIONED_JNI_LIB_NAME(\"gnomevfs-2\", \"0\"), RTLD_LAZY);\n     if (vfs_handle == NULL) {\n         // if we cannot load the library using a version assumed by JNI\n         // we are trying to load the library without a version suffix\n         vfs_handle = dlopen(JNI_LIB_NAME(\"gnomevfs-2\"), RTLD_LAZY);\n         if (vfs_handle == NULL) {\n #ifdef INTERNAL_BUILD\n             fprintf(stderr, \"can not load libgnomevfs-2.so\\n\");\n #endif\n             return FALSE;\n         }\n     }\n     dlerror(); /* Clear errors */\n     gnome_vfs_init = (GNOME_VFS_INIT_TYPE*)dlsym(vfs_handle, \"gnome_vfs_init\");\n     if (gnome_vfs_init == NULL){\n #ifdef INTERNAL_BUILD\n         fprintf(stderr, \"dlsym( gnome_vfs_init) returned NULL\\n\");\n #endif\n         return FALSE;\n     }\n     if ((errmsg = dlerror()) != NULL) {\n #ifdef INTERNAL_BUILD\n         fprintf(stderr, \"can not find symbol gnome_vfs_init %s \\n\", errmsg);\n #endif\n         return FALSE;\n     }\n     // call gonme_vfs_init()\n     (*gnome_vfs_init)();\n\n     gnome_handle = dlopen(VERSIONED_JNI_LIB_NAME(\"gnome-2\", \"0\"), RTLD_LAZY);\n     if (gnome_handle == NULL) {\n         gnome_handle = dlopen(JNI_LIB_NAME(\"gnome-2\"), RTLD_LAZY);\n         if (gnome_handle == NULL) {\n #ifdef INTERNAL_BUILD\n             fprintf(stderr, \"can not load libgnome-2.so\\n\");\n #endif\n             return FALSE;\n         }\n     }\n     dlerror(); /* Clear errors */\n     gnome_url_show = (GNOME_URL_SHOW_TYPE*)dlsym(gnome_handle, \"gnome_url_show\");\n     if ((errmsg = dlerror()) != NULL) {\n #ifdef INTERNAL_BUILD\n         fprintf(stderr, \"can not find symble gnome_url_show\\n\");\n #endif\n         return FALSE;\n     }\n     return TRUE;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/awt/fontpath.c": "/*\n * Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#if defined(__linux__)\n#include <string.h>\n#endif /* __linux__ */\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#ifdef __solaris__\n#include <sys/systeminfo.h>\n#endif\n\n#include <jni.h>\n#include <jni_util.h>\n#include <jvm_md.h>\n#include <sizecalc.h>\n#ifndef HEADLESS\n#include <X11/Xlib.h>\n#include <awt.h>\n#else\n/* locks ought to be included from awt.h */\n#define AWT_LOCK()\n#define AWT_UNLOCK()\n#endif /* !HEADLESS */\n\n#if defined(__linux__) && !defined(MAP_FAILED)\n#define MAP_FAILED ((caddr_t)-1)\n#endif\n\n#ifndef HEADLESS\nextern Display *awt_display;\n#endif /* !HEADLESS */\n\n#define FONTCONFIG_DLL_VERSIONED VERSIONED_JNI_LIB_NAME(\"fontconfig\", \"1\")\n#define FONTCONFIG_DLL JNI_LIB_NAME(\"fontconfig\")\n\n#define MAXFDIRS 512    /* Max number of directories that contain fonts */\n\n#if defined(__solaris__)\n/*\n * This can be set in the makefile to \"/usr/X11\" if so desired.\n */\n#ifndef OPENWINHOMELIB\n#define OPENWINHOMELIB \"/usr/openwin/lib/\"\n#endif\n\n/* This is all known Solaris X11 directories on Solaris 8, 9 and 10.\n * It is ordered to give precedence to TrueType directories.\n * It is needed if fontconfig is not installed or configured properly.\n */\nstatic char *fullSolarisFontPath[] = {\n    OPENWINHOMELIB \"X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/euro_fonts/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/iso_8859_2/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/iso_8859_5/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/iso_8859_7/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/iso_8859_8/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/iso_8859_9/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/iso_8859_13/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/iso_8859_15/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/ar/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/hi_IN.UTF-8/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/ja/X11/fonts/TT\",\n    OPENWINHOMELIB \"locale/ko/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/ko.UTF-8/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/KOI8-R/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/ru.ansi-1251/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/th_TH/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/zh_TW/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/zh_TW.BIG5/X11/fonts/TT\",\n    OPENWINHOMELIB \"locale/zh_HK.BIG5HK/X11/fonts/TT\",\n    OPENWINHOMELIB \"locale/zh_CN.GB18030/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/zh/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"locale/zh.GBK/X11/fonts/TrueType\",\n    OPENWINHOMELIB \"X11/fonts/Type1\",\n    OPENWINHOMELIB \"X11/fonts/Type1/sun\",\n    OPENWINHOMELIB \"X11/fonts/Type1/sun/outline\",\n    OPENWINHOMELIB \"locale/iso_8859_2/X11/fonts/Type1\",\n    OPENWINHOMELIB \"locale/iso_8859_4/X11/fonts/Type1\",\n    OPENWINHOMELIB \"locale/iso_8859_5/X11/fonts/Type1\",\n    OPENWINHOMELIB \"locale/iso_8859_7/X11/fonts/Type1\",\n    OPENWINHOMELIB \"locale/iso_8859_8/X11/fonts/Type1\",\n    OPENWINHOMELIB \"locale/iso_8859_9/X11/fonts/Type1\",\n    OPENWINHOMELIB \"locale/iso_8859_13/X11/fonts/Type1\",\n    OPENWINHOMELIB \"locale/ar/X11/fonts/Type1\",\n    NULL, /* terminates the list */\n};\n\n#elif defined( __linux__)\n/* All the known interesting locations we have discovered on\n * various flavors of Linux\n */\nstatic char *fullLinuxFontPath[] = {\n    \"/usr/X11R6/lib/X11/fonts/TrueType\",  /* RH 7.1+ */\n    \"/usr/X11R6/lib/X11/fonts/truetype\",  /* SuSE */\n    \"/usr/X11R6/lib/X11/fonts/tt\",\n    \"/usr/X11R6/lib/X11/fonts/TTF\",\n    \"/usr/X11R6/lib/X11/fonts/OTF\",       /* RH 9.0 (but empty!) */\n    \"/usr/share/fonts/ja/TrueType\",       /* RH 7.2+ */\n    \"/usr/share/fonts/truetype\",\n    \"/usr/share/fonts/ko/TrueType\",       /* RH 9.0 */\n    \"/usr/share/fonts/zh_CN/TrueType\",    /* RH 9.0 */\n    \"/usr/share/fonts/zh_TW/TrueType\",    /* RH 9.0 */\n    \"/var/lib/defoma/x-ttcidfont-conf.d/dirs/TrueType\", /* Debian */\n    \"/usr/X11R6/lib/X11/fonts/Type1\",\n    \"/usr/share/fonts/default/Type1\",     /* RH 9.0 */\n    NULL, /* terminates the list */\n};\n#elif defined(_AIX)\nstatic char *fullAixFontPath[] = {\n    \"/usr/lpp/X11/lib/X11/fonts/Type1\",    /* from X11.fnt.iso_T1  */\n    \"/usr/lpp/X11/lib/X11/fonts/TrueType\", /* from X11.fnt.ucs.ttf */\n    NULL, /* terminates the list */\n};\n#endif\n\nstatic char **getFontConfigLocations();\n\ntypedef struct {\n    const char *name[MAXFDIRS];\n    int  num;\n} fDirRecord, *fDirRecordPtr;\n\n#ifndef HEADLESS\n\n/*\n * Returns True if display is local, False of it's remote.\n */\njboolean isDisplayLocal(JNIEnv *env) {\n    static jboolean isLocal = False;\n    static jboolean isLocalSet = False;\n    jboolean ret;\n\n    if (! isLocalSet) {\n      jclass geCls = (*env)->FindClass(env, \"java/awt/GraphicsEnvironment\");\n      CHECK_NULL_RETURN(geCls, JNI_FALSE);\n      jmethodID getLocalGE = (*env)->GetStaticMethodID(env, geCls,\n                                                 \"getLocalGraphicsEnvironment\",\n                                           \"()Ljava/awt/GraphicsEnvironment;\");\n      CHECK_NULL_RETURN(getLocalGE, JNI_FALSE);\n      jobject ge = (*env)->CallStaticObjectMethod(env, geCls, getLocalGE);\n      JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n\n      jclass sgeCls = (*env)->FindClass(env,\n                                        \"sun/java2d/SunGraphicsEnvironment\");\n      CHECK_NULL_RETURN(sgeCls, JNI_FALSE);\n      if ((*env)->IsInstanceOf(env, ge, sgeCls)) {\n        jmethodID isDisplayLocal = (*env)->GetMethodID(env, sgeCls,\n                                                       \"isDisplayLocal\",\n                                                       \"()Z\");\n        JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n        isLocal = (*env)->CallBooleanMethod(env, ge, isDisplayLocal);\n      } else {\n        isLocal = True;\n      }\n      isLocalSet = True;\n    }\n\n    return isLocal;\n}\n\nstatic void AddFontsToX11FontPath ( fDirRecord *fDirP )\n{\n    char *onePath;\n    int index, nPaths;\n    int origNumPaths, length;\n    int origIndex;\n    int totalDirCount;\n    char  **origFontPath;\n    char  **tempFontPath;\n    int doNotAppend;\n    int *appendDirList;\n    char **newFontPath;\n    int err, compareLength;\n    char fontDirPath[512];\n    int dirFile;\n\n    doNotAppend = 0;\n\n    if ( fDirP->num == 0 ) return;\n\n    appendDirList = SAFE_SIZE_ARRAY_ALLOC(malloc, fDirP->num, sizeof ( int ));\n    if ( appendDirList == NULL ) {\n      return;  /* if it fails we cannot do much */\n    }\n\n    origFontPath = XGetFontPath ( awt_display, &nPaths );\n\n    totalDirCount = nPaths;\n    origNumPaths = nPaths;\n    tempFontPath = origFontPath;\n\n\n    for (index = 0; index < fDirP->num; index++ ) {\n\n        doNotAppend = 0;\n\n        tempFontPath = origFontPath;\n        for ( origIndex = 0; origIndex < nPaths; origIndex++ ) {\n\n            onePath = *tempFontPath;\n\n            compareLength = strlen ( onePath );\n            if ( onePath[compareLength -1] == '/' )\n              compareLength--;\n\n            /* there is a slash at the end of every solaris X11 font path name */\n            if ( strncmp ( onePath, fDirP->name[index], compareLength ) == 0 ) {\n              doNotAppend = 1;\n              break;\n            }\n            tempFontPath++;\n        }\n\n        appendDirList[index] = 0;\n        if ( doNotAppend == 0 ) {\n            strcpy ( fontDirPath, fDirP->name[index] );\n            strcat ( fontDirPath, \"/fonts.dir\" );\n            dirFile = open ( fontDirPath, O_RDONLY, 0 );\n            if ( dirFile == -1 ) {\n                doNotAppend = 1;\n            } else {\n               close ( dirFile );\n               totalDirCount++;\n               appendDirList[index] = 1;\n            }\n        }\n\n    }\n\n    /* if no changes are required do not bother to do a setfontpath */\n    if ( totalDirCount == nPaths ) {\n      free ( ( void *) appendDirList );\n      XFreeFontPath ( origFontPath );\n      return;\n    }\n\n\n    newFontPath = SAFE_SIZE_ARRAY_ALLOC(malloc, totalDirCount, sizeof ( char **) );\n    /* if it fails free things and get out */\n    if ( newFontPath == NULL ) {\n      free ( ( void *) appendDirList );\n      XFreeFontPath ( origFontPath );\n      return;\n    }\n\n    for ( origIndex = 0; origIndex < nPaths; origIndex++ ) {\n      onePath = origFontPath[origIndex];\n      newFontPath[origIndex] = onePath;\n    }\n\n    /* now add the other font paths */\n\n    for (index = 0; index < fDirP->num; index++ ) {\n\n      if ( appendDirList[index] == 1 ) {\n\n        /* printf ( \"Appending %s\\n\", fDirP->name[index] ); */\n\n        onePath = SAFE_SIZE_ARRAY_ALLOC(malloc, strlen (fDirP->name[index]) + 2, sizeof( char ) );\n        if (onePath == NULL) {\n            free ( ( void *) appendDirList );\n            XFreeFontPath ( origFontPath );\n            return;\n        }\n        strcpy ( onePath, fDirP->name[index] );\n        strcat ( onePath, \"/\" );\n        newFontPath[nPaths++] = onePath;\n        /* printf ( \"The path to be appended is %s\\n\", onePath ); */\n      }\n    }\n\n    /*   printf ( \"The dir count = %d\\n\", totalDirCount ); */\n    free ( ( void *) appendDirList );\n\n    XSetFontPath ( awt_display, newFontPath, totalDirCount );\n\n        for ( index = origNumPaths; index < totalDirCount; index++ ) {\n                free( newFontPath[index] );\n    }\n\n        free ( (void *) newFontPath );\n    XFreeFontPath ( origFontPath );\n    return;\n}\n#endif /* !HEADLESS */\n\n\n#ifndef HEADLESS\nstatic char **getX11FontPath ()\n{\n    char **x11Path, **fontdirs;\n    int i, pos, slen, nPaths, numDirs;\n\n    x11Path = XGetFontPath (awt_display, &nPaths);\n\n    /* This isn't ever going to be perfect: the font path may contain\n     * much we aren't interested in, but the cost should be moderate\n     * Exclude all directories that contain the strings \"Speedo\",\"/F3/\",\n     * \"75dpi\", \"100dpi\", \"misc\" or \"bitmap\", or don't begin with a \"/\",\n     * the last of which should exclude font servers.\n     * Also exclude the user specific \".gnome*\" directories which\n     * aren't going to contain the system fonts we need.\n     * Hopefully we are left only with Type1 and TrueType directories.\n     * It doesn't matter much if there are extraneous directories, it'll just\n     * cost us a little wasted effort upstream.\n     */\n    fontdirs = (char**)calloc(nPaths+1, sizeof(char*));\n    pos = 0;\n    for (i=0; i < nPaths; i++) {\n        if (x11Path[i][0] != '/') {\n            continue;\n        }\n        if (strstr(x11Path[i], \"/75dpi\") != NULL) {\n            continue;\n        }\n        if (strstr(x11Path[i], \"/100dpi\") != NULL) {\n            continue;\n        }\n        if (strstr(x11Path[i], \"/misc\") != NULL) {\n            continue;\n        }\n        if (strstr(x11Path[i], \"/Speedo\") != NULL) {\n            continue;\n        }\n        if (strstr(x11Path[i], \".gnome\") != NULL) {\n            continue;\n        }\n#ifdef __solaris__\n        if (strstr(x11Path[i], \"/F3/\") != NULL) {\n            continue;\n        }\n        if (strstr(x11Path[i], \"bitmap\") != NULL) {\n            continue;\n        }\n#endif\n        fontdirs[pos] = strdup(x11Path[i]);\n        slen = strlen(fontdirs[pos]);\n        if (slen > 0 && fontdirs[pos][slen-1] == '/') {\n            fontdirs[pos][slen-1] = '\\0'; /* null out trailing \"/\"  */\n        }\n        pos++;\n    }\n\n    XFreeFontPath(x11Path);\n    if (pos == 0) {\n        free(fontdirs);\n        fontdirs = NULL;\n    }\n    return fontdirs;\n}\n\n\n#endif /* !HEADLESS */\n\n#if defined(__linux__)\n/* from awt_LoadLibrary.c */\nJNIEXPORT jboolean JNICALL AWTIsHeadless();\n#endif\n\n/* This eliminates duplicates, at a non-linear but acceptable cost\n * since the lists are expected to be reasonably short, and then\n * deletes references to non-existent directories, and returns\n * a single path consisting of unique font directories.\n */\nstatic char* mergePaths(char **p1, char **p2, char **p3, jboolean noType1) {\n\n    int len1=0, len2=0, len3=0, totalLen=0, numDirs=0,\n        currLen, i, j, found, pathLen=0;\n    char **ptr, **fontdirs;\n    char *fontPath = NULL;\n\n    if (p1 != NULL) {\n        ptr = p1;\n        while (*ptr++ != NULL) len1++;\n    }\n    if (p2 != NULL) {\n        ptr = p2;\n\n        while (*ptr++ != NULL) len2++;\n    }\n    if (p3 != NULL) {\n        ptr = p3;\n        while (*ptr++ != NULL) len3++;\n    }\n    totalLen = len1+len2+len3;\n    fontdirs = (char**)calloc(totalLen, sizeof(char*));\n\n    for (i=0; i < len1; i++) {\n        if (noType1 && strstr(p1[i], \"Type1\") != NULL) {\n            continue;\n        }\n        fontdirs[numDirs++] = p1[i];\n    }\n\n    currLen = numDirs; /* only compare against previous path dirs */\n    for (i=0; i < len2; i++) {\n        if (noType1 && strstr(p2[i], \"Type1\") != NULL) {\n            continue;\n        }\n        found = 0;\n        for (j=0; j < currLen; j++) {\n            if (strcmp(fontdirs[j], p2[i]) == 0) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n           fontdirs[numDirs++] = p2[i];\n        }\n    }\n\n    currLen = numDirs; /* only compare against previous path dirs */\n    for (i=0; i < len3; i++) {\n        if (noType1 && strstr(p3[i], \"Type1\") != NULL) {\n            continue;\n        }\n        found = 0;\n        for (j=0; j < currLen; j++) {\n            if (strcmp(fontdirs[j], p3[i]) == 0) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n           fontdirs[numDirs++] = p3[i];\n        }\n    }\n\n    /* Now fontdirs contains unique dirs and numDirs records how many.\n     * What we don't know is if they all exist. On reflection I think\n     * this isn't an issue, so for now I will return all these locations,\n     * converted to one string */\n    for (i=0; i<numDirs; i++) {\n        pathLen += (strlen(fontdirs[i]) + 1);\n    }\n    if (pathLen > 0 && (fontPath = malloc(pathLen))) {\n        *fontPath = '\\0';\n        for (i = 0; i<numDirs; i++) {\n            if (i != 0) {\n                strcat(fontPath, \":\");\n            }\n            strcat(fontPath, fontdirs[i]);\n        }\n    }\n    free (fontdirs);\n\n    return fontPath;\n}\n\n/*\n * The goal of this function is to find all \"system\" fonts which\n * are needed by the JRE to display text in supported locales etc, and\n * to support APIs which allow users to enumerate all system fonts and use\n * them from their Java applications.\n * The preferred mechanism is now using the new \"fontconfig\" library\n * This exists on newer versions of Linux and Solaris (S10 and above)\n * The library is dynamically located. The results are merged with\n * a set of \"known\" locations and with the X11 font path, if running in\n * a local X11 environment.\n * The hardwired paths are built into the JDK binary so as new font locations\n * are created on a host plaform for them to be located by the JRE they will\n * need to be added ito the host's font configuration database, typically\n * /etc/fonts/local.conf, and to ensure that directory contains a fonts.dir\n * NB: Fontconfig also depends heavily for performance on the host O/S\n * maintaining up to date caches.\n * This is consistent with the requirements of the desktop environments\n * on these OSes.\n * This also frees us from X11 APIs as JRE is required to function in\n * a \"headless\" mode where there is no Xserver.\n */\nstatic char *getPlatformFontPathChars(JNIEnv *env, jboolean noType1, jboolean isX11) {\n\n    char **fcdirs = NULL, **x11dirs = NULL, **knowndirs = NULL, *path = NULL;\n\n    /* As of 1.5 we try to use fontconfig on both Solaris and Linux.\n     * If its not available NULL is returned.\n     */\n    fcdirs = getFontConfigLocations();\n\n#if defined(__linux__)\n    knowndirs = fullLinuxFontPath;\n#elif defined(__solaris__)\n    knowndirs = fullSolarisFontPath;\n#elif defined(_AIX)\n    knowndirs = fullAixFontPath;\n#endif\n    /* REMIND: this code requires to be executed when the GraphicsEnvironment\n     * is already initialised. That is always true, but if it were not so,\n     * this code could throw an exception and the fontpath would fail to\n     * be initialised.\n     */\n#ifndef HEADLESS\n    if (isX11) { // The following only works in an x11 environment.\n#if defined(__linux__)\n    /* There's no headless build on linux ... */\n    if (!AWTIsHeadless()) { /* .. so need to call a function to check */\n#endif\n      /* Using the X11 font path to locate font files is now a fallback\n       * useful only if fontconfig failed, or is incomplete. So we could\n       * remove this code completely and the consequences should be rare\n       * and non-fatal. If this happens, then the calling Java code can\n       * be modified to no longer require that the AWT lock (the X11GE)\n       * be initialised prior to calling this code.\n       */\n    AWT_LOCK();\n    if (isDisplayLocal(env)) {\n        x11dirs = getX11FontPath();\n    }\n    AWT_UNLOCK();\n#if defined(__linux__)\n    }\n#endif\n    }\n#endif /* !HEADLESS */\n    path = mergePaths(fcdirs, x11dirs, knowndirs, noType1);\n    if (fcdirs != NULL) {\n        char **p = fcdirs;\n        while (*p != NULL)  free(*p++);\n        free(fcdirs);\n    }\n\n    if (x11dirs != NULL) {\n        char **p = x11dirs;\n        while (*p != NULL) free(*p++);\n        free(x11dirs);\n    }\n\n    return path;\n}\n\nJNIEXPORT jstring JNICALL Java_sun_awt_FcFontManager_getFontPathNative\n(JNIEnv *env, jobject thiz, jboolean noType1, jboolean isX11) {\n    jstring ret;\n    static char *ptr = NULL; /* retain result across calls */\n\n    if (ptr == NULL) {\n        ptr = getPlatformFontPathChars(env, noType1, isX11);\n    }\n    ret = (*env)->NewStringUTF(env, ptr);\n    return ret;\n}\n\n#include <dlfcn.h>\n\n#include \"fontconfig.h\"\n\n\nstatic void* openFontConfig() {\n\n    char *homeEnv;\n    static char *homeEnvStr = \"HOME=\"; /* must be static */\n    void* libfontconfig = NULL;\n#ifdef __solaris__\n#define SYSINFOBUFSZ 8\n    char sysinfobuf[SYSINFOBUFSZ];\n#endif\n\n    /* Private workaround to not use fontconfig library.\n     * May be useful during testing/debugging\n     */\n    char *useFC = getenv(\"USE_J2D_FONTCONFIG\");\n    if (useFC != NULL && !strcmp(useFC, \"no\")) {\n        return NULL;\n    }\n\n#ifdef __solaris__\n    /* fontconfig is likely not properly configured on S8/S9 - skip it,\n     * although allow user to override this behaviour with an env. variable\n     * ie if USE_J2D_FONTCONFIG=yes then we skip this test.\n     * NB \"4\" is the length of a string which matches our patterns.\n     */\n    if (useFC == NULL || strcmp(useFC, \"yes\")) {\n        if (sysinfo(SI_RELEASE, sysinfobuf, SYSINFOBUFSZ) == 4) {\n            if ((!strcmp(sysinfobuf, \"5.8\") || !strcmp(sysinfobuf, \"5.9\"))) {\n                return NULL;\n            }\n        }\n    }\n#endif\n\n#if defined(_AIX)\n    /* On AIX, fontconfig is not a standard package supported by IBM.\n     * instead it has to be installed from the \"AIX Toolbox for Linux Applications\"\n     * site http://www-03.ibm.com/systems/power/software/aix/linux/toolbox/alpha.html\n     * and will be installed under /opt/freeware/lib/libfontconfig.a.\n     * Notice that the archive contains the real 32- and 64-bit shared libraries.\n     * We first try to load 'libfontconfig.so' from the default library path in the\n     * case the user has installed a private version of the library and if that\n     * doesn't succeed, we try the version from /opt/freeware/lib/libfontconfig.a\n     */\n    libfontconfig = dlopen(\"libfontconfig.so\", RTLD_LOCAL|RTLD_LAZY);\n    if (libfontconfig == NULL) {\n        libfontconfig = dlopen(\"/opt/freeware/lib/libfontconfig.a(libfontconfig.so.1)\", RTLD_MEMBER|RTLD_LOCAL|RTLD_LAZY);\n        if (libfontconfig == NULL) {\n            return NULL;\n        }\n    }\n#else\n    /* 64 bit sparc should pick up the right version from the lib path.\n     * New features may be added to libfontconfig, this is expected to\n     * be compatible with old features, but we may need to start\n     * distinguishing the library version, to know whether to expect\n     * certain symbols - and functionality - to be available.\n     * Also add explicit search for .so.1 in case .so symlink doesn't exist.\n     */\n    libfontconfig = dlopen(FONTCONFIG_DLL_VERSIONED, RTLD_LOCAL|RTLD_LAZY);\n    if (libfontconfig == NULL) {\n        libfontconfig = dlopen(FONTCONFIG_DLL, RTLD_LOCAL|RTLD_LAZY);\n        if (libfontconfig == NULL) {\n            return NULL;\n        }\n    }\n#endif\n\n    /* Version 1.0 of libfontconfig crashes if HOME isn't defined in\n     * the environment. This should generally never happen, but we can't\n     * control it, and can't control the version of fontconfig, so iff\n     * its not defined we set it to an empty value which is sufficient\n     * to prevent a crash. I considered unsetting it before exit, but\n     * it doesn't appear to work on Solaris, so I will leave it set.\n     */\n    homeEnv = getenv(\"HOME\");\n    if (homeEnv == NULL) {\n        putenv(homeEnvStr);\n    }\n\n    return libfontconfig;\n}\n\ntypedef void* (FcFiniFuncType)();\n\nstatic void closeFontConfig(void* libfontconfig, jboolean fcFini) {\n\n  /* NB FcFini is not in (eg) the Solaris 10 version of fontconfig. Its not\n   * clear if this means we are really leaking resources in those cases\n   * but it seems we should call this function when its available.\n   * But since the Swing GTK code may be still accessing the lib, its probably\n   * safest for now to just let this \"leak\" rather than potentially\n   * concurrently free global data still in use by other code.\n   */\n#if 0\n    if (fcFini) { /* release resources */\n        FcFiniFuncType FcFini = (FcFiniFuncType)dlsym(libfontconfig, \"FcFini\");\n\n        if (FcFini != NULL) {\n            (*FcFini)();\n        }\n    }\n#endif\n    dlclose(libfontconfig);\n}\n\ntypedef FcConfig* (*FcInitLoadConfigFuncType)();\ntypedef FcPattern* (*FcPatternBuildFuncType)(FcPattern *orig, ...);\ntypedef FcObjectSet* (*FcObjectSetFuncType)(const char *first, ...);\ntypedef FcFontSet* (*FcFontListFuncType)(FcConfig *config,\n                                         FcPattern *p,\n                                         FcObjectSet *os);\ntypedef FcResult (*FcPatternGetBoolFuncType)(const FcPattern *p,\n                                               const char *object,\n                                               int n,\n                                               FcBool *b);\ntypedef FcResult (*FcPatternGetIntegerFuncType)(const FcPattern *p,\n                                                const char *object,\n                                                int n,\n                                                int *i);\ntypedef FcResult (*FcPatternGetStringFuncType)(const FcPattern *p,\n                                               const char *object,\n                                               int n,\n                                               FcChar8 ** s);\ntypedef FcChar8* (*FcStrDirnameFuncType)(const FcChar8 *file);\ntypedef void (*FcPatternDestroyFuncType)(FcPattern *p);\ntypedef void (*FcFontSetDestroyFuncType)(FcFontSet *s);\ntypedef FcPattern* (*FcNameParseFuncType)(const FcChar8 *name);\ntypedef FcBool (*FcPatternAddStringFuncType)(FcPattern *p,\n                                             const char *object,\n                                             const FcChar8 *s);\ntypedef void (*FcDefaultSubstituteFuncType)(FcPattern *p);\ntypedef FcBool (*FcConfigSubstituteFuncType)(FcConfig *config,\n                                             FcPattern *p,\n                                             FcMatchKind kind);\ntypedef FcPattern* (*FcFontMatchFuncType)(FcConfig *config,\n                                          FcPattern *p,\n                                          FcResult *result);\ntypedef FcFontSet* (*FcFontSetCreateFuncType)();\ntypedef FcBool (*FcFontSetAddFuncType)(FcFontSet *s, FcPattern *font);\n\ntypedef FcResult (*FcPatternGetCharSetFuncType)(FcPattern *p,\n                                                const char *object,\n                                                int n,\n                                                FcCharSet **c);\ntypedef FcFontSet* (*FcFontSortFuncType)(FcConfig *config,\n                                         FcPattern *p,\n                                         FcBool trim,\n                                         FcCharSet **csp,\n                                         FcResult *result);\ntypedef FcCharSet* (*FcCharSetUnionFuncType)(const FcCharSet *a,\n                                             const FcCharSet *b);\ntypedef FcChar32 (*FcCharSetSubtractCountFuncType)(const FcCharSet *a,\n                                                   const FcCharSet *b);\n\ntypedef int (*FcGetVersionFuncType)();\n\ntypedef FcStrList* (*FcConfigGetCacheDirsFuncType)(FcConfig *config);\ntypedef FcChar8* (*FcStrListNextFuncType)(FcStrList *list);\ntypedef FcChar8* (*FcStrListDoneFuncType)(FcStrList *list);\n\nstatic char **getFontConfigLocations() {\n\n    char **fontdirs;\n    int numdirs = 0;\n    FcInitLoadConfigFuncType FcInitLoadConfig;\n    FcPatternBuildFuncType FcPatternBuild;\n    FcObjectSetFuncType FcObjectSetBuild;\n    FcFontListFuncType FcFontList;\n    FcPatternGetStringFuncType FcPatternGetString;\n    FcStrDirnameFuncType FcStrDirname;\n    FcPatternDestroyFuncType FcPatternDestroy;\n    FcFontSetDestroyFuncType FcFontSetDestroy;\n\n    FcConfig *fontconfig;\n    FcPattern *pattern;\n    FcObjectSet *objset;\n    FcFontSet *fontSet;\n    FcStrList *strList;\n    FcChar8 *str;\n    int i, f, found, len=0;\n    char **fontPath;\n\n    void* libfontconfig = openFontConfig();\n\n    if (libfontconfig == NULL) {\n        return NULL;\n    }\n\n    FcPatternBuild     =\n        (FcPatternBuildFuncType)dlsym(libfontconfig, \"FcPatternBuild\");\n    FcObjectSetBuild   =\n        (FcObjectSetFuncType)dlsym(libfontconfig, \"FcObjectSetBuild\");\n    FcFontList         =\n        (FcFontListFuncType)dlsym(libfontconfig, \"FcFontList\");\n    FcPatternGetString =\n        (FcPatternGetStringFuncType)dlsym(libfontconfig, \"FcPatternGetString\");\n    FcStrDirname       =\n        (FcStrDirnameFuncType)dlsym(libfontconfig, \"FcStrDirname\");\n    FcPatternDestroy   =\n        (FcPatternDestroyFuncType)dlsym(libfontconfig, \"FcPatternDestroy\");\n    FcFontSetDestroy   =\n        (FcFontSetDestroyFuncType)dlsym(libfontconfig, \"FcFontSetDestroy\");\n\n    if (FcPatternBuild     == NULL ||\n        FcObjectSetBuild   == NULL ||\n        FcPatternGetString == NULL ||\n        FcFontList         == NULL ||\n        FcStrDirname       == NULL ||\n        FcPatternDestroy   == NULL ||\n        FcFontSetDestroy   == NULL) { /* problem with the library: return. */\n        closeFontConfig(libfontconfig, JNI_FALSE);\n        return NULL;\n    }\n\n    /* Make calls into the fontconfig library to build a search for\n     * outline fonts, and to get the set of full file paths from the matches.\n     * This set is returned from the call to FcFontList(..)\n     * We allocate an array of char* pointers sufficient to hold all\n     * the matches + 1 extra which ensures there will be a NULL after all\n     * valid entries.\n     * We call FcStrDirname strip the file name from the path, and\n     * check if we have yet seen this directory. If not we add a pointer to\n     * it into our array of char*. Note that FcStrDirname returns newly\n     * allocated storage so we can use this in the return char** value.\n     * Finally we clean up, freeing allocated resources, and return the\n     * array of unique directories.\n     */\n    pattern = (*FcPatternBuild)(NULL, FC_OUTLINE, FcTypeBool, FcTrue, NULL);\n    objset = (*FcObjectSetBuild)(FC_FILE, NULL);\n    fontSet = (*FcFontList)(NULL, pattern, objset);\n    fontdirs = (char**)calloc(fontSet->nfont+1, sizeof(char*));\n    for (f=0; f < fontSet->nfont; f++) {\n        FcChar8 *file;\n        FcChar8 *dir;\n        if ((*FcPatternGetString)(fontSet->fonts[f], FC_FILE, 0, &file) ==\n                                  FcResultMatch) {\n            dir = (*FcStrDirname)(file);\n            found = 0;\n            for (i=0;i<numdirs; i++) {\n                if (strcmp(fontdirs[i], (char*)dir) == 0) {\n                    found = 1;\n                    break;\n                }\n            }\n            if (!found) {\n                fontdirs[numdirs++] = (char*)dir;\n            } else {\n                free((char*)dir);\n            }\n        }\n    }\n\n    /* Free memory and close the \".so\" */\n    (*FcFontSetDestroy)(fontSet);\n    (*FcPatternDestroy)(pattern);\n    closeFontConfig(libfontconfig, JNI_TRUE);\n    return fontdirs;\n}\n\n/* These are copied from sun.awt.SunHints.\n * Consider initialising them as ints using JNI for more robustness.\n */\n#define TEXT_AA_OFF 1\n#define TEXT_AA_ON  2\n#define TEXT_AA_LCD_HRGB 4\n#define TEXT_AA_LCD_HBGR 5\n#define TEXT_AA_LCD_VRGB 6\n#define TEXT_AA_LCD_VBGR 7\n\nJNIEXPORT jint JNICALL\nJava_sun_font_FontConfigManager_getFontConfigAASettings\n(JNIEnv *env, jclass obj, jstring localeStr, jstring fcNameStr) {\n\n    FcNameParseFuncType FcNameParse;\n    FcPatternAddStringFuncType FcPatternAddString;\n    FcConfigSubstituteFuncType FcConfigSubstitute;\n    FcDefaultSubstituteFuncType  FcDefaultSubstitute;\n    FcFontMatchFuncType FcFontMatch;\n    FcPatternGetBoolFuncType FcPatternGetBool;\n    FcPatternGetIntegerFuncType FcPatternGetInteger;\n    FcPatternDestroyFuncType FcPatternDestroy;\n\n    FcPattern *pattern, *matchPattern;\n    FcResult result;\n    FcBool antialias = FcFalse;\n    int rgba = 0;\n    const char *locale=NULL, *fcName=NULL;\n    void* libfontconfig;\n\n    if (fcNameStr == NULL || localeStr == NULL) {\n        return -1;\n    }\n\n    fcName = (*env)->GetStringUTFChars(env, fcNameStr, 0);\n    if (fcName == NULL) {\n        return -1;\n    }\n    locale = (*env)->GetStringUTFChars(env, localeStr, 0);\n\n    if ((libfontconfig = openFontConfig()) == NULL) {\n        (*env)->ReleaseStringUTFChars (env, fcNameStr, (const char*)fcName);\n        if (locale) {\n            (*env)->ReleaseStringUTFChars (env, localeStr,(const char*)locale);\n        }\n        return -1;\n    }\n\n    FcNameParse = (FcNameParseFuncType)dlsym(libfontconfig, \"FcNameParse\");\n    FcPatternAddString =\n        (FcPatternAddStringFuncType)dlsym(libfontconfig, \"FcPatternAddString\");\n    FcConfigSubstitute =\n        (FcConfigSubstituteFuncType)dlsym(libfontconfig, \"FcConfigSubstitute\");\n    FcDefaultSubstitute = (FcDefaultSubstituteFuncType)\n        dlsym(libfontconfig, \"FcDefaultSubstitute\");\n    FcFontMatch = (FcFontMatchFuncType)dlsym(libfontconfig, \"FcFontMatch\");\n    FcPatternGetBool = (FcPatternGetBoolFuncType)\n        dlsym(libfontconfig, \"FcPatternGetBool\");\n    FcPatternGetInteger = (FcPatternGetIntegerFuncType)\n        dlsym(libfontconfig, \"FcPatternGetInteger\");\n    FcPatternDestroy =\n        (FcPatternDestroyFuncType)dlsym(libfontconfig, \"FcPatternDestroy\");\n\n    if (FcNameParse          == NULL ||\n        FcPatternAddString   == NULL ||\n        FcConfigSubstitute   == NULL ||\n        FcDefaultSubstitute  == NULL ||\n        FcFontMatch          == NULL ||\n        FcPatternGetBool     == NULL ||\n        FcPatternGetInteger  == NULL ||\n        FcPatternDestroy     == NULL) { /* problem with the library: return. */\n\n        (*env)->ReleaseStringUTFChars (env, fcNameStr, (const char*)fcName);\n        if (locale) {\n            (*env)->ReleaseStringUTFChars (env, localeStr,(const char*)locale);\n        }\n        closeFontConfig(libfontconfig, JNI_FALSE);\n        return -1;\n    }\n\n\n    pattern = (*FcNameParse)((FcChar8 *)fcName);\n    if (locale != NULL) {\n        (*FcPatternAddString)(pattern, FC_LANG, (unsigned char*)locale);\n    }\n    (*FcConfigSubstitute)(NULL, pattern, FcMatchPattern);\n    (*FcDefaultSubstitute)(pattern);\n    matchPattern = (*FcFontMatch)(NULL, pattern, &result);\n    /* Perhaps should call FcFontRenderPrepare() here as some pattern\n     * elements might change as a result of that call, but I'm not seeing\n     * any difference in testing.\n     */\n    if (matchPattern) {\n        (*FcPatternGetBool)(matchPattern, FC_ANTIALIAS, 0, &antialias);\n        (*FcPatternGetInteger)(matchPattern, FC_RGBA, 0, &rgba);\n        (*FcPatternDestroy)(matchPattern);\n    }\n    (*FcPatternDestroy)(pattern);\n\n    (*env)->ReleaseStringUTFChars (env, fcNameStr, (const char*)fcName);\n    if (locale) {\n        (*env)->ReleaseStringUTFChars (env, localeStr, (const char*)locale);\n    }\n    closeFontConfig(libfontconfig, JNI_TRUE);\n\n    if (antialias == FcFalse) {\n        return TEXT_AA_OFF;\n    } else if (rgba <= FC_RGBA_UNKNOWN || rgba >= FC_RGBA_NONE) {\n        return TEXT_AA_ON;\n    } else {\n        switch (rgba) {\n        case FC_RGBA_RGB : return TEXT_AA_LCD_HRGB;\n        case FC_RGBA_BGR : return TEXT_AA_LCD_HBGR;\n        case FC_RGBA_VRGB : return TEXT_AA_LCD_VRGB;\n        case FC_RGBA_VBGR : return TEXT_AA_LCD_VBGR;\n        default : return TEXT_AA_LCD_HRGB; // should not get here.\n        }\n    }\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_font_FontConfigManager_getFontConfigVersion\n    (JNIEnv *env, jclass obj) {\n\n    void* libfontconfig;\n    FcGetVersionFuncType FcGetVersion;\n    int version = 0;\n\n    if ((libfontconfig = openFontConfig()) == NULL) {\n        return 0;\n    }\n\n    FcGetVersion = (FcGetVersionFuncType)dlsym(libfontconfig, \"FcGetVersion\");\n\n    if (FcGetVersion == NULL) {\n        closeFontConfig(libfontconfig, JNI_FALSE);\n        return 0;\n    }\n    version = (*FcGetVersion)();\n    closeFontConfig(libfontconfig, JNI_FALSE);\n\n    return version;\n}\n\n\nJNIEXPORT void JNICALL\nJava_sun_font_FontConfigManager_getFontConfig\n(JNIEnv *env, jclass obj, jstring localeStr, jobject fcInfoObj,\n jobjectArray fcCompFontArray,  jboolean includeFallbacks) {\n\n    FcNameParseFuncType FcNameParse;\n    FcPatternAddStringFuncType FcPatternAddString;\n    FcConfigSubstituteFuncType FcConfigSubstitute;\n    FcDefaultSubstituteFuncType  FcDefaultSubstitute;\n    FcFontMatchFuncType FcFontMatch;\n    FcPatternGetStringFuncType FcPatternGetString;\n    FcPatternDestroyFuncType FcPatternDestroy;\n    FcPatternGetCharSetFuncType FcPatternGetCharSet;\n    FcFontSortFuncType FcFontSort;\n    FcFontSetDestroyFuncType FcFontSetDestroy;\n    FcCharSetUnionFuncType FcCharSetUnion;\n    FcCharSetSubtractCountFuncType FcCharSetSubtractCount;\n    FcGetVersionFuncType FcGetVersion;\n    FcConfigGetCacheDirsFuncType FcConfigGetCacheDirs;\n    FcStrListNextFuncType FcStrListNext;\n    FcStrListDoneFuncType FcStrListDone;\n\n    int i, arrlen;\n    jobject fcCompFontObj;\n    jstring fcNameStr, jstr;\n    const char *locale, *fcName;\n    FcPattern *pattern;\n    FcResult result;\n    void* libfontconfig;\n    jfieldID fcNameID, fcFirstFontID, fcAllFontsID, fcVersionID, fcCacheDirsID;\n    jfieldID familyNameID, styleNameID, fullNameID, fontFileID;\n    jmethodID fcFontCons;\n    char* debugMinGlyphsStr = getenv(\"J2D_DEBUG_MIN_GLYPHS\");\n\n    CHECK_NULL(fcInfoObj);\n    CHECK_NULL(fcCompFontArray);\n\n    jclass fcInfoClass =\n        (*env)->FindClass(env, \"sun/font/FontConfigManager$FontConfigInfo\");\n    CHECK_NULL(fcInfoClass);\n    jclass fcCompFontClass =\n        (*env)->FindClass(env, \"sun/font/FontConfigManager$FcCompFont\");\n    CHECK_NULL(fcCompFontClass);\n    jclass fcFontClass =\n         (*env)->FindClass(env, \"sun/font/FontConfigManager$FontConfigFont\");\n    CHECK_NULL(fcFontClass);\n\n\n    CHECK_NULL(fcVersionID = (*env)->GetFieldID(env, fcInfoClass, \"fcVersion\", \"I\"));\n    CHECK_NULL(fcCacheDirsID = (*env)->GetFieldID(env, fcInfoClass, \"cacheDirs\",\n                                                  \"[Ljava/lang/String;\"));\n    CHECK_NULL(fcNameID = (*env)->GetFieldID(env, fcCompFontClass,\n                                             \"fcName\", \"Ljava/lang/String;\"));\n    CHECK_NULL(fcFirstFontID = (*env)->GetFieldID(env, fcCompFontClass, \"firstFont\",\n                                        \"Lsun/font/FontConfigManager$FontConfigFont;\"));\n    CHECK_NULL(fcAllFontsID = (*env)->GetFieldID(env, fcCompFontClass, \"allFonts\",\n                                        \"[Lsun/font/FontConfigManager$FontConfigFont;\"));\n    CHECK_NULL(fcFontCons = (*env)->GetMethodID(env, fcFontClass, \"<init>\", \"()V\"));\n    CHECK_NULL(familyNameID = (*env)->GetFieldID(env, fcFontClass,\n                                      \"familyName\", \"Ljava/lang/String;\"));\n    CHECK_NULL(styleNameID = (*env)->GetFieldID(env, fcFontClass,\n                                    \"styleStr\", \"Ljava/lang/String;\"));\n    CHECK_NULL(fullNameID = (*env)->GetFieldID(env, fcFontClass,\n                                    \"fullName\", \"Ljava/lang/String;\"));\n    CHECK_NULL(fontFileID = (*env)->GetFieldID(env, fcFontClass,\n                                    \"fontFile\", \"Ljava/lang/String;\"));\n\n    if ((libfontconfig = openFontConfig()) == NULL) {\n        return;\n    }\n\n    FcNameParse = (FcNameParseFuncType)dlsym(libfontconfig, \"FcNameParse\");\n    FcPatternAddString =\n        (FcPatternAddStringFuncType)dlsym(libfontconfig, \"FcPatternAddString\");\n    FcConfigSubstitute =\n        (FcConfigSubstituteFuncType)dlsym(libfontconfig, \"FcConfigSubstitute\");\n    FcDefaultSubstitute = (FcDefaultSubstituteFuncType)\n        dlsym(libfontconfig, \"FcDefaultSubstitute\");\n    FcFontMatch = (FcFontMatchFuncType)dlsym(libfontconfig, \"FcFontMatch\");\n    FcPatternGetString =\n        (FcPatternGetStringFuncType)dlsym(libfontconfig, \"FcPatternGetString\");\n    FcPatternDestroy =\n        (FcPatternDestroyFuncType)dlsym(libfontconfig, \"FcPatternDestroy\");\n    FcPatternGetCharSet =\n        (FcPatternGetCharSetFuncType)dlsym(libfontconfig,\n                                           \"FcPatternGetCharSet\");\n    FcFontSort =\n        (FcFontSortFuncType)dlsym(libfontconfig, \"FcFontSort\");\n    FcFontSetDestroy =\n        (FcFontSetDestroyFuncType)dlsym(libfontconfig, \"FcFontSetDestroy\");\n    FcCharSetUnion =\n        (FcCharSetUnionFuncType)dlsym(libfontconfig, \"FcCharSetUnion\");\n    FcCharSetSubtractCount =\n        (FcCharSetSubtractCountFuncType)dlsym(libfontconfig,\n                                              \"FcCharSetSubtractCount\");\n    FcGetVersion = (FcGetVersionFuncType)dlsym(libfontconfig, \"FcGetVersion\");\n\n    if (FcNameParse          == NULL ||\n        FcPatternAddString   == NULL ||\n        FcConfigSubstitute   == NULL ||\n        FcDefaultSubstitute  == NULL ||\n        FcFontMatch          == NULL ||\n        FcPatternGetString   == NULL ||\n        FcPatternDestroy     == NULL ||\n        FcPatternGetCharSet  == NULL ||\n        FcFontSetDestroy     == NULL ||\n        FcCharSetUnion       == NULL ||\n        FcGetVersion         == NULL ||\n        FcCharSetSubtractCount == NULL) {/* problem with the library: return.*/\n        closeFontConfig(libfontconfig, JNI_FALSE);\n        return;\n    }\n\n    (*env)->SetIntField(env, fcInfoObj, fcVersionID, (*FcGetVersion)());\n\n    /* Optionally get the cache dir locations. This isn't\n     * available until v 2.4.x, but this is OK since on those later versions\n     * we can check the time stamps on the cache dirs to see if we\n     * are out of date. There are a couple of assumptions here. First\n     * that the time stamp on the directory changes when the contents are\n     * updated. Secondly that the locations don't change. The latter is\n     * most likely if a new version of fontconfig is installed, but we also\n     * invalidate the cache if we detect that. Arguably even that is \"rare\",\n     * and most likely is tied to an OS upgrade which gets a new file anyway.\n     */\n    FcConfigGetCacheDirs =\n        (FcConfigGetCacheDirsFuncType)dlsym(libfontconfig,\n                                            \"FcConfigGetCacheDirs\");\n    FcStrListNext =\n        (FcStrListNextFuncType)dlsym(libfontconfig, \"FcStrListNext\");\n    FcStrListDone =\n        (FcStrListDoneFuncType)dlsym(libfontconfig, \"FcStrListDone\");\n    if (FcStrListNext != NULL && FcStrListDone != NULL &&\n        FcConfigGetCacheDirs != NULL) {\n\n        FcStrList* cacheDirs;\n        FcChar8* cacheDir;\n        int cnt = 0;\n        jobject cacheDirArray =\n            (*env)->GetObjectField(env, fcInfoObj, fcCacheDirsID);\n        int max = (*env)->GetArrayLength(env, cacheDirArray);\n\n        cacheDirs = (*FcConfigGetCacheDirs)(NULL);\n        if (cacheDirs != NULL) {\n            while ((cnt < max) && (cacheDir = (*FcStrListNext)(cacheDirs))) {\n                jstr = (*env)->NewStringUTF(env, (const char*)cacheDir);\n                JNU_CHECK_EXCEPTION(env);\n\n                (*env)->SetObjectArrayElement(env, cacheDirArray, cnt++, jstr);\n            }\n            (*FcStrListDone)(cacheDirs);\n        }\n    }\n\n    locale = (*env)->GetStringUTFChars(env, localeStr, 0);\n    if (locale == NULL) {\n        (*env)->ExceptionClear(env);\n        JNU_ThrowOutOfMemoryError(env, \"Could not create locale\");\n        return;\n    }\n\n    arrlen = (*env)->GetArrayLength(env, fcCompFontArray);\n    for (i=0; i<arrlen; i++) {\n        FcFontSet* fontset;\n        int fn, j, fontCount, nfonts;\n        unsigned int minGlyphs;\n        FcChar8 **family, **styleStr, **fullname, **file;\n        jarray fcFontArr;\n\n        fcCompFontObj = (*env)->GetObjectArrayElement(env, fcCompFontArray, i);\n        fcNameStr =\n            (jstring)((*env)->GetObjectField(env, fcCompFontObj, fcNameID));\n        fcName = (*env)->GetStringUTFChars(env, fcNameStr, 0);\n        if (fcName == NULL) {\n            continue;\n        }\n        pattern = (*FcNameParse)((FcChar8 *)fcName);\n        (*env)->ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);\n        if (pattern == NULL) {\n            closeFontConfig(libfontconfig, JNI_FALSE);\n            return;\n        }\n\n        /* locale may not usually be necessary as fontconfig appears to apply\n         * this anyway based on the user's environment. However we want\n         * to use the value of the JDK startup locale so this should take\n         * care of it.\n         */\n        if (locale != NULL) {\n            (*FcPatternAddString)(pattern, FC_LANG, (unsigned char*)locale);\n        }\n        (*FcConfigSubstitute)(NULL, pattern, FcMatchPattern);\n        (*FcDefaultSubstitute)(pattern);\n        fontset = (*FcFontSort)(NULL, pattern, FcTrue, NULL, &result);\n        if (fontset == NULL) {\n            (*FcPatternDestroy)(pattern);\n            closeFontConfig(libfontconfig, JNI_FALSE);\n            return;\n        }\n\n        /* fontconfig returned us \"nfonts\". If we are just getting the\n         * first font, we set nfont to zero. Otherwise we use \"nfonts\".\n         * Next create separate C arrrays of length nfonts for family file etc.\n         * Inspect the returned fonts and the ones we like (adds enough glyphs)\n         * are added to the arrays and we increment 'fontCount'.\n         */\n        nfonts = fontset->nfont;\n        family   = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));\n        styleStr = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));\n        fullname = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));\n        file     = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));\n        if (family == NULL || styleStr == NULL ||\n            fullname == NULL || file == NULL) {\n            if (family != NULL) {\n                free(family);\n            }\n            if (styleStr != NULL) {\n                free(styleStr);\n            }\n            if (fullname != NULL) {\n                free(fullname);\n            }\n            if (file != NULL) {\n                free(file);\n            }\n            (*FcPatternDestroy)(pattern);\n            (*FcFontSetDestroy)(fontset);\n            closeFontConfig(libfontconfig, JNI_FALSE);\n            return;\n        }\n        fontCount = 0;\n        minGlyphs = 20;\n        if (debugMinGlyphsStr != NULL) {\n            int val = minGlyphs;\n            sscanf(debugMinGlyphsStr, \"%5d\", &val);\n            if (val >= 0 && val <= 65536) {\n                minGlyphs = val;\n            }\n        }\n        FcCharSet *unionCharset = NULL;\n        for (j=0; j<nfonts; j++) {\n            FcPattern *fontPattern = fontset->fonts[j];\n            FcChar8 *fontformat;\n            FcCharSet *charset = NULL;\n\n            fontformat = NULL;\n            (*FcPatternGetString)(fontPattern, FC_FONTFORMAT, 0, &fontformat);\n            /* We only want TrueType fonts but some Linuxes still depend\n             * on Type 1 fonts for some Locale support, so we'll allow\n             * them there.\n             */\n            if (fontformat != NULL\n                && (strcmp((char*)fontformat, \"TrueType\") != 0)\n#if defined(__linux__) || defined(_AIX)\n                && (strcmp((char*)fontformat, \"Type 1\") != 0)\n#endif\n             ) {\n                continue;\n            }\n            result = (*FcPatternGetCharSet)(fontPattern,\n                                            FC_CHARSET, 0, &charset);\n            if (result != FcResultMatch) {\n                free(family);\n                free(fullname);\n                free(styleStr);\n                free(file);\n                (*FcPatternDestroy)(pattern);\n                (*FcFontSetDestroy)(fontset);\n                closeFontConfig(libfontconfig, JNI_FALSE);\n                return;\n            }\n\n            /* We don't want 20 or 30 fonts, so once we hit 10 fonts,\n             * then require that they really be adding value. Too many\n             * adversely affects load time for minimal value-add.\n             * This is still likely far more than we've had in the past.\n             */\n            if (j==10) {\n                minGlyphs = 50;\n            }\n            if (unionCharset == NULL) {\n                unionCharset = charset;\n            } else {\n                if ((*FcCharSetSubtractCount)(charset, unionCharset)\n                    > minGlyphs) {\n                    unionCharset = (* FcCharSetUnion)(unionCharset, charset);\n                } else {\n                    continue;\n                }\n            }\n\n            fontCount++; // found a font we will use.\n            (*FcPatternGetString)(fontPattern, FC_FILE, 0, &file[j]);\n            (*FcPatternGetString)(fontPattern, FC_FAMILY, 0, &family[j]);\n            (*FcPatternGetString)(fontPattern, FC_STYLE, 0, &styleStr[j]);\n            (*FcPatternGetString)(fontPattern, FC_FULLNAME, 0, &fullname[j]);\n            if (!includeFallbacks) {\n                break;\n            }\n            if (fontCount == 254) {\n                break; // CompositeFont will only use up to 254 slots from here.\n            }\n        }\n\n        /* Once we get here 'fontCount' is the number of returned fonts\n         * we actually want to use, so we create 'fcFontArr' of that length.\n         * The non-null entries of \"family[]\" etc are those fonts.\n         * Then loop again over all nfonts adding just those non-null ones\n         * to 'fcFontArr'. If its null (we didn't want the font)\n         * then we don't enter the main body.\n         * So we should never get more than 'fontCount' entries.\n         */\n        if (includeFallbacks) {\n            fcFontArr =\n                (*env)->NewObjectArray(env, fontCount, fcFontClass, NULL);\n            if (IS_NULL(fcFontArr)) {\n                free(family);\n                free(fullname);\n                free(styleStr);\n                free(file);\n                (*FcPatternDestroy)(pattern);\n                (*FcFontSetDestroy)(fontset);\n                closeFontConfig(libfontconfig, JNI_FALSE);\n                return;\n            }\n            (*env)->SetObjectField(env,fcCompFontObj, fcAllFontsID, fcFontArr);\n        }\n        fn=0;\n\n        for (j=0;j<nfonts;j++) {\n            if (family[j] != NULL) {\n                jobject fcFont =\n                    (*env)->NewObject(env, fcFontClass, fcFontCons);\n                if (IS_NULL(fcFont)) break;\n                jstr = (*env)->NewStringUTF(env, (const char*)family[j]);\n                if (IS_NULL(jstr)) break;\n                (*env)->SetObjectField(env, fcFont, familyNameID, jstr);\n                if (file[j] != NULL) {\n                    jstr = (*env)->NewStringUTF(env, (const char*)file[j]);\n                    if (IS_NULL(jstr)) break;\n                    (*env)->SetObjectField(env, fcFont, fontFileID, jstr);\n                }\n                if (styleStr[j] != NULL) {\n                    jstr = (*env)->NewStringUTF(env, (const char*)styleStr[j]);\n                    if (IS_NULL(jstr)) break;\n                    (*env)->SetObjectField(env, fcFont, styleNameID, jstr);\n                }\n                if (fullname[j] != NULL) {\n                    jstr = (*env)->NewStringUTF(env, (const char*)fullname[j]);\n                    if (IS_NULL(jstr)) break;\n                    (*env)->SetObjectField(env, fcFont, fullNameID, jstr);\n                }\n                if (fn==0) {\n                    (*env)->SetObjectField(env, fcCompFontObj,\n                                           fcFirstFontID, fcFont);\n                }\n                if (includeFallbacks) {\n                    (*env)->SetObjectArrayElement(env, fcFontArr, fn++,fcFont);\n                } else {\n                    break;\n                }\n            }\n        }\n        (*FcFontSetDestroy)(fontset);\n        (*FcPatternDestroy)(pattern);\n        free(family);\n        free(styleStr);\n        free(fullname);\n        free(file);\n    }\n\n    /* release resources and close the \".so\" */\n\n    if (locale) {\n        (*env)->ReleaseStringUTFChars (env, localeStr, (const char*)locale);\n    }\n    closeFontConfig(libfontconfig, JNI_TRUE);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/awt/awt_LoadLibrary.c": "/*\n * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <stdio.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <jni.h>\n#include <jni_util.h>\n#include <jvm.h>\n#include \"gdefs.h\"\n\n#include <sys/param.h>\n#include <sys/utsname.h>\n\n#ifdef AIX\n#include \"porting_aix.h\" /* For the 'dladdr' function. */\n#endif\n\n#ifdef DEBUG\n#define VERBOSE_AWT_DEBUG\n#endif\n\nstatic void *awtHandle = NULL;\n\ntypedef jint JNICALL JNI_OnLoad_type(JavaVM *vm, void *reserved);\n\n/* Initialize the Java VM instance variable when the library is\n   first loaded */\nJavaVM *jvm;\n\nJNIEXPORT jboolean JNICALL AWTIsHeadless() {\n    static JNIEnv *env = NULL;\n    static jboolean isHeadless;\n    jmethodID headlessFn;\n    jclass graphicsEnvClass;\n\n    if (env == NULL) {\n        env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);\n        graphicsEnvClass = (*env)->FindClass(env,\n                                             \"java/awt/GraphicsEnvironment\");\n        if (graphicsEnvClass == NULL) {\n            return JNI_TRUE;\n        }\n        headlessFn = (*env)->GetStaticMethodID(env,\n                                               graphicsEnvClass, \"isHeadless\", \"()Z\");\n        if (headlessFn == NULL) {\n            return JNI_TRUE;\n        }\n        isHeadless = (*env)->CallStaticBooleanMethod(env, graphicsEnvClass,\n                                                     headlessFn);\n    }\n    return isHeadless;\n}\n\n#define CHECK_EXCEPTION_FATAL(env, message) \\\n    if ((*env)->ExceptionCheck(env)) { \\\n        (*env)->ExceptionClear(env); \\\n        (*env)->FatalError(env, message); \\\n    }\n\n/*\n * Pathnames to the various awt toolkits\n */\n\n#ifdef MACOSX\n  #define LWAWT_PATH \"/libawt_lwawt.dylib\"\n  #define DEFAULT_PATH LWAWT_PATH\n#else\n  #define XAWT_PATH \"/libawt_xawt.so\"\n  #define DEFAULT_PATH XAWT_PATH\n  #define HEADLESS_PATH \"/libawt_headless.so\"\n#endif\n\njint\nAWT_OnLoad(JavaVM *vm, void *reserved)\n{\n    Dl_info dlinfo;\n    char buf[MAXPATHLEN];\n    int32_t len;\n    char *p, *tk;\n    JNI_OnLoad_type *JNI_OnLoad_ptr;\n    struct utsname name;\n    JNIEnv *env = (JNIEnv *)JNU_GetEnv(vm, JNI_VERSION_1_2);\n    void *v;\n    jstring fmanager = NULL;\n    jstring fmProp = NULL;\n\n    if (awtHandle != NULL) {\n        /* Avoid several loading attempts */\n        return JNI_VERSION_1_2;\n    }\n\n    jvm = vm;\n\n    /* Get address of this library and the directory containing it. */\n    dladdr((void *)AWT_OnLoad, &dlinfo);\n    realpath((char *)dlinfo.dli_fname, buf);\n    len = strlen(buf);\n    p = strrchr(buf, '/');\n\n    /*\n     * The code below is responsible for:\n     * 1. Loading appropriate awt library, i.e. libawt_xawt or libawt_headless\n     * 2. Set the \"sun.font.fontmanager\" system property.\n     */\n\n    fmProp = (*env)->NewStringUTF(env, \"sun.font.fontmanager\");\n    CHECK_EXCEPTION_FATAL(env, \"Could not allocate font manager property\");\n\n#ifdef MACOSX\n        fmanager = (*env)->NewStringUTF(env, \"sun.font.CFontManager\");\n        tk = LWAWT_PATH;\n#else\n        fmanager = (*env)->NewStringUTF(env, \"sun.awt.X11FontManager\");\n        tk = XAWT_PATH;\n#endif\n    CHECK_EXCEPTION_FATAL(env, \"Could not allocate font manager name\");\n\n    if (fmanager && fmProp) {\n        JNU_CallStaticMethodByName(env, NULL, \"java/lang/System\", \"setProperty\",\n                                   \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\",\n                                   fmProp, fmanager);\n        CHECK_EXCEPTION_FATAL(env, \"Could not allocate set properties\");\n    }\n\n#ifndef MACOSX\n    if (AWTIsHeadless()) {\n        tk = HEADLESS_PATH;\n    }\n#endif\n\n    /* Calculate library name to load */\n    strncpy(p, tk, MAXPATHLEN-len-1);\n\n    if (fmProp) {\n        (*env)->DeleteLocalRef(env, fmProp);\n    }\n    if (fmanager) {\n        (*env)->DeleteLocalRef(env, fmanager);\n    }\n\n    jstring jbuf = JNU_NewStringPlatform(env, buf);\n    CHECK_EXCEPTION_FATAL(env, \"Could not allocate library name\");\n    JNU_CallStaticMethodByName(env, NULL, \"java/lang/System\", \"load\",\n                               \"(Ljava/lang/String;)V\",\n                               jbuf);\n\n    awtHandle = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);\n\n    return JNI_VERSION_1_2;\n}\n\nJNIEXPORT jint JNICALL\nJNI_OnLoad(JavaVM *vm, void *reserved)\n{\n    return AWT_OnLoad(vm, reserved);\n}\n\n/*\n * This entry point must remain in libawt.so as part of a contract\n * with the CDE variant of Java Media Framework. (sdtjmplay)\n * Reflect this call over to the correct libawt_<toolkit>.so.\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_motif_XsessionWMcommand(JNIEnv *env, jobject this,\n                                     jobject frame, jstring jcommand)\n{\n    /* type of the old backdoor function */\n    typedef void JNICALL\n        XsessionWMcommand_type(JNIEnv *env, jobject this,\n                               jobject frame, jstring jcommand);\n\n    static XsessionWMcommand_type *XsessionWMcommand = NULL;\n\n    if (XsessionWMcommand == NULL && awtHandle == NULL) {\n        return;\n    }\n\n    XsessionWMcommand = (XsessionWMcommand_type *)\n        dlsym(awtHandle, \"Java_sun_awt_motif_XsessionWMcommand\");\n\n    if (XsessionWMcommand == NULL)\n        return;\n\n    (*XsessionWMcommand)(env, this, frame, jcommand);\n}\n\n\n/*\n * This entry point must remain in libawt.so as part of a contract\n * with the CDE variant of Java Media Framework. (sdtjmplay)\n * Reflect this call over to the correct libawt_<toolkit>.so.\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_motif_XsessionWMcommand_New(JNIEnv *env, jobjectArray jargv)\n{\n    typedef void JNICALL\n        XsessionWMcommand_New_type(JNIEnv *env, jobjectArray jargv);\n\n    static XsessionWMcommand_New_type *XsessionWMcommand = NULL;\n\n    if (XsessionWMcommand == NULL && awtHandle == NULL) {\n        return;\n    }\n\n    XsessionWMcommand = (XsessionWMcommand_New_type *)\n        dlsym(awtHandle, \"Java_sun_awt_motif_XsessionWMcommand_New\");\n\n    if (XsessionWMcommand == NULL)\n        return;\n\n    (*XsessionWMcommand)(env, jargv);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/awt/gtk2_interface.c": "/*\n * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n#include <dlfcn.h>\n#include <setjmp.h>\n#include <X11/Xlib.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include \"gtk2_interface.h\"\n#include \"java_awt_Transparency.h\"\n#include \"jvm_md.h\"\n#include \"sizecalc.h\"\n#include <jni_util.h>\n#include \"awt.h\"\n\n#define GTHREAD_LIB_VERSIONED VERSIONED_JNI_LIB_NAME(\"gthread-2.0\", \"0\")\n#define GTHREAD_LIB JNI_LIB_NAME(\"gthread-2.0\")\n\n#define GTK_TYPE_BORDER                 ((*fp_gtk_border_get_type)())\n\n#define G_TYPE_FUNDAMENTAL_SHIFT        (2)\n#define G_TYPE_MAKE_FUNDAMENTAL(x)      ((GType) ((x) << G_TYPE_FUNDAMENTAL_SHIFT))\n\n#define CONV_BUFFER_SIZE 128\n\n#define NO_SYMBOL_EXCEPTION 1\n\nstatic void *gtk2_libhandle = NULL;\nstatic void *gthread_libhandle = NULL;\n\nstatic jmp_buf j;\n\n/* Widgets */\nstatic GtkWidget *gtk2_widget = NULL;\nstatic GtkWidget *gtk2_window = NULL;\nstatic GtkFixed  *gtk2_fixed  = NULL;\n\n/* Paint system */\nstatic GdkPixmap *gtk2_white_pixmap = NULL;\nstatic GdkPixmap *gtk2_black_pixmap = NULL;\nstatic GdkPixbuf *gtk2_white_pixbuf = NULL;\nstatic GdkPixbuf *gtk2_black_pixbuf = NULL;\nstatic int gtk2_pixbuf_width = 0;\nstatic int gtk2_pixbuf_height = 0;\n\n/* Static buffer for conversion from java.lang.String to UTF-8 */\nstatic char convertionBuffer[CONV_BUFFER_SIZE];\n\nstatic gboolean new_combo = TRUE;\nconst char ENV_PREFIX[] = \"GTK_MODULES=\";\n\n\nstatic GtkWidget *gtk2_widgets[_GTK_WIDGET_TYPE_SIZE];\n\n/*************************\n * Glib function pointers\n *************************/\n\nstatic gboolean (*fp_g_main_context_iteration)(GMainContext *context,\n                                             gboolean may_block);\n\nstatic GValue*      (*fp_g_value_init)(GValue *value, GType g_type);\nstatic gboolean     (*fp_g_type_is_a)(GType type, GType is_a_type);\nstatic gboolean     (*fp_g_value_get_boolean)(const GValue *value);\nstatic gchar        (*fp_g_value_get_char)(const GValue *value);\nstatic guchar       (*fp_g_value_get_uchar)(const GValue *value);\nstatic gint         (*fp_g_value_get_int)(const GValue *value);\nstatic guint        (*fp_g_value_get_uint)(const GValue *value);\nstatic glong        (*fp_g_value_get_long)(const GValue *value);\nstatic gulong       (*fp_g_value_get_ulong)(const GValue *value);\nstatic gint64       (*fp_g_value_get_int64)(const GValue *value);\nstatic guint64      (*fp_g_value_get_uint64)(const GValue *value);\nstatic gfloat       (*fp_g_value_get_float)(const GValue *value);\nstatic gdouble      (*fp_g_value_get_double)(const GValue *value);\nstatic const gchar* (*fp_g_value_get_string)(const GValue *value);\nstatic gint         (*fp_g_value_get_enum)(const GValue *value);\nstatic guint        (*fp_g_value_get_flags)(const GValue *value);\nstatic GParamSpec*  (*fp_g_value_get_param)(const GValue *value);\nstatic gpointer*    (*fp_g_value_get_boxed)(const GValue *value);\nstatic gpointer*    (*fp_g_value_get_pointer)(const GValue *value);\nstatic GObject*     (*fp_g_value_get_object)(const GValue *value);\nstatic GParamSpec*  (*fp_g_param_spec_int)(const gchar *name,\n        const gchar *nick, const gchar *blurb,\n        gint minimum, gint maximum, gint default_value,\n        GParamFlags flags);\nstatic void         (*fp_g_object_get)(gpointer object,\n                                       const gchar* fpn, ...);\nstatic void         (*fp_g_object_set)(gpointer object,\n                                       const gchar *first_property_name,\n                                       ...);\n/************************\n * GDK function pointers\n ************************/\nstatic GdkPixmap *(*fp_gdk_pixmap_new)(GdkDrawable *drawable,\n        gint width, gint height, gint depth);\nstatic GdkGC *(*fp_gdk_gc_new)(GdkDrawable*);\nstatic void (*fp_gdk_rgb_gc_set_foreground)(GdkGC*, guint32);\nstatic void (*fp_gdk_draw_rectangle)(GdkDrawable*, GdkGC*, gboolean,\n        gint, gint, gint, gint);\nstatic GdkPixbuf *(*fp_gdk_pixbuf_new)(GdkColorspace colorspace,\n        gboolean has_alpha, int bits_per_sample, int width, int height);\nstatic void (*fp_gdk_drawable_get_size)(GdkDrawable *drawable,\n        gint* width, gint* height);\n\n/************************\n * Gtk function pointers\n ************************/\nstatic gboolean (*fp_gtk_init_check)(int* argc, char** argv);\n\n/* Painting */\nstatic void (*fp_gtk_paint_hline)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n        const gchar* detail, gint x1, gint x2, gint y);\nstatic void (*fp_gtk_paint_vline)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n        const gchar* detail, gint y1, gint y2, gint x);\nstatic void (*fp_gtk_paint_shadow)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        gint x, gint y, gint width, gint height);\nstatic void (*fp_gtk_paint_arrow)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        GtkArrowType arrow_type, gboolean fill, gint x, gint y,\n        gint width, gint height);\nstatic void (*fp_gtk_paint_diamond)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        gint x, gint y, gint width, gint height);\nstatic void (*fp_gtk_paint_box)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        gint x, gint y, gint width, gint height);\nstatic void (*fp_gtk_paint_flat_box)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        gint x, gint y, gint width, gint height);\nstatic void (*fp_gtk_paint_check)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        gint x, gint y, gint width, gint height);\nstatic void (*fp_gtk_paint_option)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        gint x, gint y, gint width, gint height);\nstatic void (*fp_gtk_paint_box_gap)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        gint x, gint y, gint width, gint height,\n        GtkPositionType gap_side, gint gap_x, gint gap_width);\nstatic void (*fp_gtk_paint_extension)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        gint x, gint y, gint width, gint height, GtkPositionType gap_side);\nstatic void (*fp_gtk_paint_focus)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n        const gchar* detail, gint x, gint y, gint width, gint height);\nstatic void (*fp_gtk_paint_slider)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        gint x, gint y, gint width, gint height, GtkOrientation orientation);\nstatic void (*fp_gtk_paint_handle)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GtkShadowType shadow_type,\n        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n        gint x, gint y, gint width, gint height, GtkOrientation orientation);\nstatic void (*fp_gtk_paint_expander)(GtkStyle* style, GdkWindow* window,\n        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n        const gchar* detail, gint x, gint y, GtkExpanderStyle expander_style);\nstatic void (*fp_gtk_style_apply_default_background)(GtkStyle* style,\n        GdkWindow* window, gboolean set_bg, GtkStateType state_type,\n        GdkRectangle* area, gint x, gint y, gint width, gint height);\n\n/* Widget creation */\nstatic GtkWidget* (*fp_gtk_arrow_new)(GtkArrowType arrow_type,\n                                      GtkShadowType shadow_type);\nstatic GtkWidget* (*fp_gtk_button_new)();\nstatic GtkWidget* (*fp_gtk_check_button_new)();\nstatic GtkWidget* (*fp_gtk_check_menu_item_new)();\nstatic GtkWidget* (*fp_gtk_color_selection_dialog_new)(const gchar* title);\nstatic GtkWidget* (*fp_gtk_combo_box_new)();\nstatic GtkWidget* (*fp_gtk_combo_box_entry_new)();\nstatic GtkWidget* (*fp_gtk_entry_new)();\nstatic GtkWidget* (*fp_gtk_fixed_new)();\nstatic GtkWidget* (*fp_gtk_handle_box_new)();\nstatic GtkWidget* (*fp_gtk_hpaned_new)();\nstatic GtkWidget* (*fp_gtk_vpaned_new)();\nstatic GtkWidget* (*fp_gtk_hscale_new)(GtkAdjustment* adjustment);\nstatic GtkWidget* (*fp_gtk_vscale_new)(GtkAdjustment* adjustment);\nstatic GtkWidget* (*fp_gtk_hscrollbar_new)(GtkAdjustment* adjustment);\nstatic GtkWidget* (*fp_gtk_vscrollbar_new)(GtkAdjustment* adjustment);\nstatic GtkWidget* (*fp_gtk_hseparator_new)();\nstatic GtkWidget* (*fp_gtk_vseparator_new)();\nstatic GtkWidget* (*fp_gtk_image_new)();\nstatic GtkWidget* (*fp_gtk_label_new)(const gchar* str);\nstatic GtkWidget* (*fp_gtk_menu_new)();\nstatic GtkWidget* (*fp_gtk_menu_bar_new)();\nstatic GtkWidget* (*fp_gtk_menu_item_new)();\nstatic GtkWidget* (*fp_gtk_notebook_new)();\nstatic GtkWidget* (*fp_gtk_progress_bar_new)();\nstatic GtkWidget* (*fp_gtk_progress_bar_set_orientation)(\n        GtkProgressBar *pbar,\n        GtkProgressBarOrientation orientation);\nstatic GtkWidget* (*fp_gtk_radio_button_new)(GSList *group);\nstatic GtkWidget* (*fp_gtk_radio_menu_item_new)(GSList *group);\nstatic GtkWidget* (*fp_gtk_scrolled_window_new)(GtkAdjustment *hadjustment,\n        GtkAdjustment *vadjustment);\nstatic GtkWidget* (*fp_gtk_separator_menu_item_new)();\nstatic GtkWidget* (*fp_gtk_separator_tool_item_new)();\nstatic GtkWidget* (*fp_gtk_text_view_new)();\nstatic GtkWidget* (*fp_gtk_toggle_button_new)();\nstatic GtkWidget* (*fp_gtk_toolbar_new)();\nstatic GtkWidget* (*fp_gtk_tree_view_new)();\nstatic GtkWidget* (*fp_gtk_viewport_new)(GtkAdjustment *hadjustment,\n        GtkAdjustment *vadjustment);\nstatic GtkWidget* (*fp_gtk_window_new)(GtkWindowType type);\nstatic GtkWidget* (*fp_gtk_dialog_new)();\nstatic GtkWidget* (*fp_gtk_spin_button_new)(GtkAdjustment *adjustment,\n        gdouble climb_rate, guint digits);\nstatic GtkWidget* (*fp_gtk_frame_new)(const gchar *label);\n\n/* Other widget operations */\nstatic GtkObject* (*fp_gtk_adjustment_new)(gdouble value,\n        gdouble lower, gdouble upper, gdouble step_increment,\n        gdouble page_increment, gdouble page_size);\nstatic void (*fp_gtk_container_add)(GtkContainer *window, GtkWidget *widget);\nstatic void (*fp_gtk_menu_shell_append)(GtkMenuShell *menu_shell,\n        GtkWidget *child);\nstatic void (*fp_gtk_menu_item_set_submenu)(GtkMenuItem *menu_item,\n        GtkWidget *submenu);\nstatic void (*fp_gtk_widget_realize)(GtkWidget *widget);\nstatic GdkPixbuf* (*fp_gtk_widget_render_icon)(GtkWidget *widget,\n        const gchar *stock_id, GtkIconSize size, const gchar *detail);\nstatic void (*fp_gtk_widget_set_name)(GtkWidget *widget, const gchar *name);\nstatic void (*fp_gtk_widget_set_parent)(GtkWidget *widget, GtkWidget *parent);\nstatic void (*fp_gtk_widget_set_direction)(GtkWidget *widget,\n        GtkTextDirection direction);\nstatic void (*fp_gtk_widget_style_get)(GtkWidget *widget,\n        const gchar *first_property_name, ...);\nstatic void (*fp_gtk_widget_class_install_style_property)(\n        GtkWidgetClass* class, GParamSpec *pspec);\nstatic GParamSpec* (*fp_gtk_widget_class_find_style_property)(\n        GtkWidgetClass* class, const gchar* property_name);\nstatic void (*fp_gtk_widget_style_get_property)(GtkWidget* widget,\n        const gchar* property_name, GValue* value);\nstatic char* (*fp_pango_font_description_to_string)(\n        const PangoFontDescription* fd);\nstatic GtkSettings* (*fp_gtk_settings_get_default)();\nstatic GtkSettings* (*fp_gtk_widget_get_settings)(GtkWidget *widget);\nstatic GType        (*fp_gtk_border_get_type)();\nstatic void (*fp_gtk_arrow_set)(GtkWidget* arrow,\n                                GtkArrowType arrow_type,\n                                GtkShadowType shadow_type);\nstatic void (*fp_gtk_widget_size_request)(GtkWidget *widget,\n                                          GtkRequisition *requisition);\nstatic GtkAdjustment* (*fp_gtk_range_get_adjustment)(GtkRange* range);\n\n/* Method bodies */\n\nstatic void throw_exception(JNIEnv *env, const char* name, const char* message)\n{\n    jclass class = (*env)->FindClass(env, name);\n\n    if (class != NULL)\n        (*env)->ThrowNew(env, class, message);\n\n    (*env)->DeleteLocalRef(env, class);\n}\n\n/* This is a workaround for the bug:\n * http://sourceware.org/bugzilla/show_bug.cgi?id=1814\n * (dlsym/dlopen clears dlerror state)\n * This bug is specific to Linux, but there is no harm in\n * applying this workaround on Solaris as well.\n */\nstatic void* dl_symbol(const char* name)\n{\n    void* result = dlsym(gtk2_libhandle, name);\n    if (!result)\n        longjmp(j, NO_SYMBOL_EXCEPTION);\n\n    return result;\n}\n\nstatic void* dl_symbol_gthread(const char* name)\n{\n    void* result = dlsym(gthread_libhandle, name);\n    if (!result)\n        longjmp(j, NO_SYMBOL_EXCEPTION);\n\n    return result;\n}\n\ngboolean gtk2_check(const char* lib_name, gboolean load)\n{\n    if (gtk2_libhandle != NULL) {\n        /* We've already successfully opened the GTK libs, so return true. */\n        return TRUE;\n    } else {\n        void *lib = NULL;\n\n#ifdef RTLD_NOLOAD\n        /* Just check if gtk libs are already in the process space */\n        lib = dlopen(lib_name, RTLD_LAZY | RTLD_NOLOAD);\n        if (!load || lib != NULL) {\n            return lib != NULL;\n        }\n#else\n#ifdef _AIX\n        /* On AIX we could implement this with the help of loadquery(L_GETINFO, ..)  */\n        /* (see reload_table() in hotspot/src/os/aix/vm/loadlib_aix.cpp) but it is   */\n        /* probably not worth it because most AIX servers don't have GTK libs anyway */\n#endif\n#endif\n\n        lib = dlopen(lib_name, RTLD_LAZY | RTLD_LOCAL);\n        if (lib == NULL) {\n            return FALSE;\n        }\n\n        fp_gtk_check_version = dlsym(lib, \"gtk_check_version\");\n        /* Check for GTK 2.2+ */\n        if (!fp_gtk_check_version(2, 2, 0)) {\n            return TRUE;\n        }\n\n        // 8048289: workaround for https://bugzilla.gnome.org/show_bug.cgi?id=733065\n        // dlclose(lib);\n\n        return FALSE;\n    }\n}\n\n#define ADD_SUPPORTED_ACTION(actionStr) \\\ndo { \\\n    jfieldID fld_action = (*env)->GetStaticFieldID(env, cls_action, actionStr, \"Ljava/awt/Desktop$Action;\"); \\\n    if (!(*env)->ExceptionCheck(env)) { \\\n        jobject action = (*env)->GetStaticObjectField(env, cls_action, fld_action); \\\n        (*env)->CallBooleanMethod(env, supportedActions, mid_arrayListAdd, action); \\\n    } else { \\\n        (*env)->ExceptionClear(env); \\\n    } \\\n} while(0);\n\n\nstatic void update_supported_actions(JNIEnv *env) {\n    GVfs * (*fp_g_vfs_get_default) (void);\n    const gchar * const * (*fp_g_vfs_get_supported_uri_schemes) (GVfs * vfs);\n    const gchar * const * schemes = NULL;\n\n    jclass cls_action = (*env)->FindClass(env, \"java/awt/Desktop$Action\");\n    CHECK_NULL(cls_action);\n    jclass cls_xDesktopPeer = (*env)->FindClass(env, \"sun/awt/X11/XDesktopPeer\");\n    CHECK_NULL(cls_xDesktopPeer);\n    jfieldID fld_supportedActions = (*env)->GetStaticFieldID(env, cls_xDesktopPeer, \"supportedActions\", \"Ljava/util/List;\");\n    CHECK_NULL(fld_supportedActions);\n    jobject supportedActions = (*env)->GetStaticObjectField(env, cls_xDesktopPeer, fld_supportedActions);\n\n    jclass cls_arrayList = (*env)->FindClass(env, \"java/util/ArrayList\");\n    CHECK_NULL(cls_arrayList);\n    jmethodID mid_arrayListAdd = (*env)->GetMethodID(env, cls_arrayList, \"add\", \"(Ljava/lang/Object;)Z\");\n    CHECK_NULL(mid_arrayListAdd);\n    jmethodID mid_arrayListClear = (*env)->GetMethodID(env, cls_arrayList, \"clear\", \"()V\");\n    CHECK_NULL(mid_arrayListClear);\n\n    (*env)->CallVoidMethod(env, supportedActions, mid_arrayListClear);\n\n    ADD_SUPPORTED_ACTION(\"OPEN\");\n\n    /**\n     * gtk_show_uri() documentation says:\n     *\n     * > you need to install gvfs to get support for uri schemes such as http://\n     * > or ftp://, as only local files are handled by GIO itself.\n     *\n     * So OPEN action was safely added here.\n     * However, it looks like Solaris 11 have gvfs support only for 32-bit\n     * applications only by default.\n     */\n\n    fp_g_vfs_get_default = dl_symbol(\"g_vfs_get_default\");\n    fp_g_vfs_get_supported_uri_schemes = dl_symbol(\"g_vfs_get_supported_uri_schemes\");\n    dlerror();\n\n    if (fp_g_vfs_get_default && fp_g_vfs_get_supported_uri_schemes) {\n        GVfs * vfs = fp_g_vfs_get_default();\n        schemes = vfs ? fp_g_vfs_get_supported_uri_schemes(vfs) : NULL;\n        if (schemes) {\n            int i = 0;\n            while (schemes[i]) {\n                if (strcmp(schemes[i], \"http\") == 0) {\n                    ADD_SUPPORTED_ACTION(\"BROWSE\");\n                    ADD_SUPPORTED_ACTION(\"MAIL\");\n                    break;\n                }\n                i++;\n            }\n        }\n    } else {\n#ifdef INTERNAL_BUILD\n        fprintf(stderr, \"Cannot load g_vfs_get_supported_uri_schemes\\n\");\n#endif /* INTERNAL_BUILD */\n    }\n\n}\n/**\n * Functions for awt_Desktop.c\n */\nstatic gboolean gtk2_show_uri_load(JNIEnv *env) {\n     gboolean success = FALSE;\n     dlerror();\n     const char *gtk_version = fp_gtk_check_version(2, 14, 0);\n     if (gtk_version != NULL) {\n         // The gtk_show_uri is available from GTK+ 2.14\n#ifdef INTERNAL_BUILD\n         fprintf (stderr, \"The version of GTK is %s. \"\n             \"The gtk_show_uri function is supported \"\n             \"since GTK+ 2.14.\\n\", gtk_version);\n#endif /* INTERNAL_BUILD */\n     } else {\n         // Loading symbols only if the GTK version is 2.14 and higher\n         fp_gtk_show_uri = dl_symbol(\"gtk_show_uri\");\n         const char *dlsym_error = dlerror();\n         if (dlsym_error) {\n#ifdef INTERNAL_BUILD\n             fprintf (stderr, \"Cannot load symbol: %s \\n\", dlsym_error);\n#endif /* INTERNAL_BUILD */\n         } else if (fp_gtk_show_uri == NULL) {\n#ifdef INTERNAL_BUILD\n             fprintf(stderr, \"dlsym(gtk_show_uri) returned NULL\\n\");\n#endif /* INTERNAL_BUILD */\n        } else {\n            gtk->gtk_show_uri = fp_gtk_show_uri;\n            update_supported_actions(env);\n            success = TRUE;\n        }\n     }\n     return success;\n}\n\n/**\n * Functions for sun_awt_X11_GtkFileDialogPeer.c\n */\nstatic void gtk2_file_chooser_load()\n{\n    fp_gtk_file_chooser_get_filename = dl_symbol(\n            \"gtk_file_chooser_get_filename\");\n    fp_gtk_file_chooser_dialog_new = dl_symbol(\"gtk_file_chooser_dialog_new\");\n    fp_gtk_file_chooser_set_current_folder = dl_symbol(\n            \"gtk_file_chooser_set_current_folder\");\n    fp_gtk_file_chooser_set_filename = dl_symbol(\n            \"gtk_file_chooser_set_filename\");\n    fp_gtk_file_chooser_set_current_name = dl_symbol(\n            \"gtk_file_chooser_set_current_name\");\n    fp_gtk_file_filter_add_custom = dl_symbol(\"gtk_file_filter_add_custom\");\n    fp_gtk_file_chooser_set_filter = dl_symbol(\"gtk_file_chooser_set_filter\");\n    fp_gtk_file_chooser_get_type = dl_symbol(\"gtk_file_chooser_get_type\");\n    fp_gtk_file_filter_new = dl_symbol(\"gtk_file_filter_new\");\n    if (fp_gtk_check_version(2, 8, 0) == NULL) {\n        fp_gtk_file_chooser_set_do_overwrite_confirmation = dl_symbol(\n                \"gtk_file_chooser_set_do_overwrite_confirmation\");\n    }\n    fp_gtk_file_chooser_set_select_multiple = dl_symbol(\n            \"gtk_file_chooser_set_select_multiple\");\n    fp_gtk_file_chooser_get_current_folder = dl_symbol(\n            \"gtk_file_chooser_get_current_folder\");\n    fp_gtk_file_chooser_get_filenames = dl_symbol(\n            \"gtk_file_chooser_get_filenames\");\n    fp_gtk_g_slist_length = dl_symbol(\"g_slist_length\");\n}\n\nGtkApi* gtk2_load(JNIEnv *env, const char* lib_name)\n{\n    gboolean result;\n    int i;\n    int (*handler)();\n    int (*io_handler)();\n    char *gtk_modules_env;\n\n    gtk2_libhandle = dlopen(lib_name, RTLD_LAZY | RTLD_LOCAL);\n    if (gtk2_libhandle == NULL) {\n        return FALSE;\n    }\n\n    gthread_libhandle = dlopen(GTHREAD_LIB_VERSIONED, RTLD_LAZY | RTLD_LOCAL);\n    if (gthread_libhandle == NULL) {\n        gthread_libhandle = dlopen(GTHREAD_LIB, RTLD_LAZY | RTLD_LOCAL);\n        if (gthread_libhandle == NULL)\n            return FALSE;\n    }\n\n    if (setjmp(j) == 0)\n    {\n        fp_gtk_check_version = dl_symbol(\"gtk_check_version\");\n        /* Check for GTK 2.2+ */\n        if (fp_gtk_check_version(2, 2, 0)) {\n            longjmp(j, NO_SYMBOL_EXCEPTION);\n        }\n\n        /* GLib */\n        fp_glib_check_version = dlsym(gtk2_libhandle, \"glib_check_version\");\n        if (!fp_glib_check_version) {\n            dlerror();\n        }\n        fp_g_free = dl_symbol(\"g_free\");\n        fp_g_object_unref = dl_symbol(\"g_object_unref\");\n\n        fp_g_main_context_iteration =\n            dl_symbol(\"g_main_context_iteration\");\n\n        fp_g_value_init = dl_symbol(\"g_value_init\");\n        fp_g_type_is_a = dl_symbol(\"g_type_is_a\");\n\n        fp_g_value_get_boolean = dl_symbol(\"g_value_get_boolean\");\n        fp_g_value_get_char = dl_symbol(\"g_value_get_char\");\n        fp_g_value_get_uchar = dl_symbol(\"g_value_get_uchar\");\n        fp_g_value_get_int = dl_symbol(\"g_value_get_int\");\n        fp_g_value_get_uint = dl_symbol(\"g_value_get_uint\");\n        fp_g_value_get_long = dl_symbol(\"g_value_get_long\");\n        fp_g_value_get_ulong = dl_symbol(\"g_value_get_ulong\");\n        fp_g_value_get_int64 = dl_symbol(\"g_value_get_int64\");\n        fp_g_value_get_uint64 = dl_symbol(\"g_value_get_uint64\");\n        fp_g_value_get_float = dl_symbol(\"g_value_get_float\");\n        fp_g_value_get_double = dl_symbol(\"g_value_get_double\");\n        fp_g_value_get_string = dl_symbol(\"g_value_get_string\");\n        fp_g_value_get_enum = dl_symbol(\"g_value_get_enum\");\n        fp_g_value_get_flags = dl_symbol(\"g_value_get_flags\");\n        fp_g_value_get_param = dl_symbol(\"g_value_get_param\");\n        fp_g_value_get_boxed = dl_symbol(\"g_value_get_boxed\");\n        fp_g_value_get_pointer = dl_symbol(\"g_value_get_pointer\");\n        fp_g_value_get_object = dl_symbol(\"g_value_get_object\");\n        fp_g_param_spec_int = dl_symbol(\"g_param_spec_int\");\n        fp_g_object_get = dl_symbol(\"g_object_get\");\n        fp_g_object_set = dl_symbol(\"g_object_set\");\n\n        /* GDK */\n        fp_gdk_get_default_root_window =\n            dl_symbol(\"gdk_get_default_root_window\");\n        fp_gdk_pixmap_new = dl_symbol(\"gdk_pixmap_new\");\n        fp_gdk_pixbuf_get_from_drawable =\n            dl_symbol(\"gdk_pixbuf_get_from_drawable\");\n        fp_gdk_pixbuf_scale_simple =\n            dl_symbol(\"gdk_pixbuf_scale_simple\");\n        fp_gdk_gc_new = dl_symbol(\"gdk_gc_new\");\n        fp_gdk_rgb_gc_set_foreground =\n            dl_symbol(\"gdk_rgb_gc_set_foreground\");\n        fp_gdk_draw_rectangle = dl_symbol(\"gdk_draw_rectangle\");\n        fp_gdk_drawable_get_size = dl_symbol(\"gdk_drawable_get_size\");\n\n        /* Pixbuf */\n        fp_gdk_pixbuf_new = dl_symbol(\"gdk_pixbuf_new\");\n        fp_gdk_pixbuf_new_from_file =\n                dl_symbol(\"gdk_pixbuf_new_from_file\");\n        fp_gdk_pixbuf_get_width = dl_symbol(\"gdk_pixbuf_get_width\");\n        fp_gdk_pixbuf_get_height = dl_symbol(\"gdk_pixbuf_get_height\");\n        fp_gdk_pixbuf_get_pixels = dl_symbol(\"gdk_pixbuf_get_pixels\");\n        fp_gdk_pixbuf_get_rowstride =\n                dl_symbol(\"gdk_pixbuf_get_rowstride\");\n        fp_gdk_pixbuf_get_has_alpha =\n                dl_symbol(\"gdk_pixbuf_get_has_alpha\");\n        fp_gdk_pixbuf_get_bits_per_sample =\n                dl_symbol(\"gdk_pixbuf_get_bits_per_sample\");\n        fp_gdk_pixbuf_get_n_channels =\n                dl_symbol(\"gdk_pixbuf_get_n_channels\");\n        fp_gdk_pixbuf_get_colorspace =\n                dl_symbol(\"gdk_pixbuf_get_colorspace\");\n\n        /* GTK painting */\n        fp_gtk_init_check = dl_symbol(\"gtk_init_check\");\n        fp_gtk_paint_hline = dl_symbol(\"gtk_paint_hline\");\n        fp_gtk_paint_vline = dl_symbol(\"gtk_paint_vline\");\n        fp_gtk_paint_shadow = dl_symbol(\"gtk_paint_shadow\");\n        fp_gtk_paint_arrow = dl_symbol(\"gtk_paint_arrow\");\n        fp_gtk_paint_diamond = dl_symbol(\"gtk_paint_diamond\");\n        fp_gtk_paint_box = dl_symbol(\"gtk_paint_box\");\n        fp_gtk_paint_flat_box = dl_symbol(\"gtk_paint_flat_box\");\n        fp_gtk_paint_check = dl_symbol(\"gtk_paint_check\");\n        fp_gtk_paint_option = dl_symbol(\"gtk_paint_option\");\n        fp_gtk_paint_box_gap = dl_symbol(\"gtk_paint_box_gap\");\n        fp_gtk_paint_extension = dl_symbol(\"gtk_paint_extension\");\n        fp_gtk_paint_focus = dl_symbol(\"gtk_paint_focus\");\n        fp_gtk_paint_slider = dl_symbol(\"gtk_paint_slider\");\n        fp_gtk_paint_handle = dl_symbol(\"gtk_paint_handle\");\n        fp_gtk_paint_expander = dl_symbol(\"gtk_paint_expander\");\n        fp_gtk_style_apply_default_background =\n                dl_symbol(\"gtk_style_apply_default_background\");\n\n        /* GTK widgets */\n        fp_gtk_arrow_new = dl_symbol(\"gtk_arrow_new\");\n        fp_gtk_button_new = dl_symbol(\"gtk_button_new\");\n        fp_gtk_spin_button_new = dl_symbol(\"gtk_spin_button_new\");\n        fp_gtk_check_button_new = dl_symbol(\"gtk_check_button_new\");\n        fp_gtk_check_menu_item_new =\n                dl_symbol(\"gtk_check_menu_item_new\");\n        fp_gtk_color_selection_dialog_new =\n                dl_symbol(\"gtk_color_selection_dialog_new\");\n        fp_gtk_entry_new = dl_symbol(\"gtk_entry_new\");\n        fp_gtk_fixed_new = dl_symbol(\"gtk_fixed_new\");\n        fp_gtk_handle_box_new = dl_symbol(\"gtk_handle_box_new\");\n        fp_gtk_image_new = dl_symbol(\"gtk_image_new\");\n        fp_gtk_hpaned_new = dl_symbol(\"gtk_hpaned_new\");\n        fp_gtk_vpaned_new = dl_symbol(\"gtk_vpaned_new\");\n        fp_gtk_hscale_new = dl_symbol(\"gtk_hscale_new\");\n        fp_gtk_vscale_new = dl_symbol(\"gtk_vscale_new\");\n        fp_gtk_hscrollbar_new = dl_symbol(\"gtk_hscrollbar_new\");\n        fp_gtk_vscrollbar_new = dl_symbol(\"gtk_vscrollbar_new\");\n        fp_gtk_hseparator_new = dl_symbol(\"gtk_hseparator_new\");\n        fp_gtk_vseparator_new = dl_symbol(\"gtk_vseparator_new\");\n        fp_gtk_label_new = dl_symbol(\"gtk_label_new\");\n        fp_gtk_menu_new = dl_symbol(\"gtk_menu_new\");\n        fp_gtk_menu_bar_new = dl_symbol(\"gtk_menu_bar_new\");\n        fp_gtk_menu_item_new = dl_symbol(\"gtk_menu_item_new\");\n        fp_gtk_menu_item_set_submenu =\n                dl_symbol(\"gtk_menu_item_set_submenu\");\n        fp_gtk_notebook_new = dl_symbol(\"gtk_notebook_new\");\n        fp_gtk_progress_bar_new =\n            dl_symbol(\"gtk_progress_bar_new\");\n        fp_gtk_progress_bar_set_orientation =\n            dl_symbol(\"gtk_progress_bar_set_orientation\");\n        fp_gtk_radio_button_new =\n            dl_symbol(\"gtk_radio_button_new\");\n        fp_gtk_radio_menu_item_new =\n            dl_symbol(\"gtk_radio_menu_item_new\");\n        fp_gtk_scrolled_window_new =\n            dl_symbol(\"gtk_scrolled_window_new\");\n        fp_gtk_separator_menu_item_new =\n            dl_symbol(\"gtk_separator_menu_item_new\");\n        fp_gtk_text_view_new = dl_symbol(\"gtk_text_view_new\");\n        fp_gtk_toggle_button_new =\n            dl_symbol(\"gtk_toggle_button_new\");\n        fp_gtk_toolbar_new = dl_symbol(\"gtk_toolbar_new\");\n        fp_gtk_tree_view_new = dl_symbol(\"gtk_tree_view_new\");\n        fp_gtk_viewport_new = dl_symbol(\"gtk_viewport_new\");\n        fp_gtk_window_new = dl_symbol(\"gtk_window_new\");\n        fp_gtk_window_present = dl_symbol(\"gtk_window_present\");\n        fp_gtk_window_move = dl_symbol(\"gtk_window_move\");\n        fp_gtk_window_resize = dl_symbol(\"gtk_window_resize\");\n\n          fp_gtk_dialog_new = dl_symbol(\"gtk_dialog_new\");\n        fp_gtk_frame_new = dl_symbol(\"gtk_frame_new\");\n\n        fp_gtk_adjustment_new = dl_symbol(\"gtk_adjustment_new\");\n        fp_gtk_container_add = dl_symbol(\"gtk_container_add\");\n        fp_gtk_menu_shell_append =\n            dl_symbol(\"gtk_menu_shell_append\");\n        fp_gtk_widget_realize = dl_symbol(\"gtk_widget_realize\");\n        fp_gtk_widget_destroy = dl_symbol(\"gtk_widget_destroy\");\n        fp_gtk_widget_render_icon =\n            dl_symbol(\"gtk_widget_render_icon\");\n        fp_gtk_widget_set_name =\n            dl_symbol(\"gtk_widget_set_name\");\n        fp_gtk_widget_set_parent =\n            dl_symbol(\"gtk_widget_set_parent\");\n        fp_gtk_widget_set_direction =\n            dl_symbol(\"gtk_widget_set_direction\");\n        fp_gtk_widget_style_get =\n            dl_symbol(\"gtk_widget_style_get\");\n        fp_gtk_widget_class_install_style_property =\n            dl_symbol(\"gtk_widget_class_install_style_property\");\n        fp_gtk_widget_class_find_style_property =\n            dl_symbol(\"gtk_widget_class_find_style_property\");\n        fp_gtk_widget_style_get_property =\n            dl_symbol(\"gtk_widget_style_get_property\");\n        fp_pango_font_description_to_string =\n            dl_symbol(\"pango_font_description_to_string\");\n        fp_gtk_settings_get_default =\n            dl_symbol(\"gtk_settings_get_default\");\n        fp_gtk_widget_get_settings =\n            dl_symbol(\"gtk_widget_get_settings\");\n        fp_gtk_border_get_type =  dl_symbol(\"gtk_border_get_type\");\n        fp_gtk_arrow_set = dl_symbol(\"gtk_arrow_set\");\n        fp_gtk_widget_size_request =\n            dl_symbol(\"gtk_widget_size_request\");\n        fp_gtk_range_get_adjustment =\n            dl_symbol(\"gtk_range_get_adjustment\");\n\n        fp_gtk_widget_hide = dl_symbol(\"gtk_widget_hide\");\n        fp_gtk_main_quit = dl_symbol(\"gtk_main_quit\");\n        fp_g_signal_connect_data = dl_symbol(\"g_signal_connect_data\");\n        fp_gtk_widget_show = dl_symbol(\"gtk_widget_show\");\n        fp_gtk_main = dl_symbol(\"gtk_main\");\n\n        fp_g_path_get_dirname = dl_symbol(\"g_path_get_dirname\");\n\n        /**\n         * GLib thread system\n         */\n        if (GLIB_CHECK_VERSION(2, 20, 0)) {\n            fp_g_thread_get_initialized = dl_symbol_gthread(\"g_thread_get_initialized\");\n        }\n        fp_g_thread_init = dl_symbol_gthread(\"g_thread_init\");\n        fp_gdk_threads_init = dl_symbol(\"gdk_threads_init\");\n        fp_gdk_threads_enter = dl_symbol(\"gdk_threads_enter\");\n        fp_gdk_threads_leave = dl_symbol(\"gdk_threads_leave\");\n\n        /**\n         * Functions for sun_awt_X11_GtkFileDialogPeer.c\n         */\n        if (fp_gtk_check_version(2, 4, 0) == NULL) {\n            // The current GtkFileChooser is available from GTK+ 2.4\n            gtk2_file_chooser_load();\n        }\n\n        /* Some functions may be missing in pre-2.4 GTK.\n           We handle them specially here.\n         */\n        fp_gtk_combo_box_new = dlsym(gtk2_libhandle, \"gtk_combo_box_new\");\n        if (fp_gtk_combo_box_new == NULL) {\n            fp_gtk_combo_box_new = dl_symbol(\"gtk_combo_new\");\n        }\n\n        fp_gtk_combo_box_entry_new =\n            dlsym(gtk2_libhandle, \"gtk_combo_box_entry_new\");\n        if (fp_gtk_combo_box_entry_new == NULL) {\n            fp_gtk_combo_box_entry_new = dl_symbol(\"gtk_combo_new\");\n            new_combo = FALSE;\n        }\n\n        fp_gtk_separator_tool_item_new =\n            dlsym(gtk2_libhandle, \"gtk_separator_tool_item_new\");\n        if (fp_gtk_separator_tool_item_new == NULL) {\n            fp_gtk_separator_tool_item_new =\n                dl_symbol(\"gtk_vseparator_new\");\n        }\n    }\n    /* Now we have only one kind of exceptions: NO_SYMBOL_EXCEPTION\n     * Otherwise we can check the return value of setjmp method.\n     */\n    else\n    {\n        dlclose(gtk2_libhandle);\n        gtk2_libhandle = NULL;\n\n        dlclose(gthread_libhandle);\n        gthread_libhandle = NULL;\n\n        return FALSE;\n    }\n\n    /*\n     * Strip the AT-SPI GTK_MODULEs if present\n     */\n    gtk_modules_env = getenv (\"GTK_MODULES\");\n\n    if (gtk_modules_env && strstr (gtk_modules_env, \"atk-bridge\") ||\n        gtk_modules_env && strstr (gtk_modules_env, \"gail\"))\n    {\n        /* the new env will be smaller than the old one */\n        gchar *s, *new_env = SAFE_SIZE_STRUCT_ALLOC(malloc,\n                sizeof(ENV_PREFIX), 1, strlen (gtk_modules_env));\n\n        if (new_env != NULL )\n        {\n            /* careful, strtok modifies its args */\n            gchar *tmp_env = strdup (gtk_modules_env);\n            strcpy(new_env, ENV_PREFIX);\n\n            /* strip out 'atk-bridge' and 'gail' */\n            size_t PREFIX_LENGTH = strlen(ENV_PREFIX);\n            while (s = strtok(tmp_env, \":\"))\n            {\n                if ((!strstr (s, \"atk-bridge\")) && (!strstr (s, \"gail\")))\n                {\n                    if (strlen (new_env) > PREFIX_LENGTH) {\n                        new_env = strcat (new_env, \":\");\n                    }\n                    new_env = strcat(new_env, s);\n                }\n                if (tmp_env)\n                {\n                    free (tmp_env);\n                    tmp_env = NULL; /* next call to strtok arg1==NULL */\n                }\n            }\n            putenv (new_env);\n            free (new_env);\n            free (tmp_env);\n        }\n    }\n\n    /*\n     * GTK should be initialized with gtk_init_check() before use.\n     *\n     * gtk_init_check installs its own error handlers. It is critical that\n     * we preserve error handler set from AWT. Otherwise we'll crash on\n     * BadMatch errors which we would normally ignore. The IO error handler\n     * is preserved here, too, just for consistency.\n    */\n    AWT_LOCK();\n    handler = XSetErrorHandler(NULL);\n    io_handler = XSetIOErrorHandler(NULL);\n\n    if (fp_gtk_check_version(2, 2, 0) == NULL) {\n        jclass clazz = (*env)->FindClass(env, \"sun/misc/GThreadHelper\");\n        jmethodID mid_getAndSetInitializationNeededFlag =\n                (*env)->GetStaticMethodID(env, clazz, \"getAndSetInitializationNeededFlag\", \"()Z\");\n        jmethodID mid_lock = (*env)->GetStaticMethodID(env, clazz, \"lock\", \"()V\");\n        jmethodID mid_unlock = (*env)->GetStaticMethodID(env, clazz, \"unlock\", \"()V\");\n\n        // Init the thread system to use GLib in a thread-safe mode\n        (*env)->CallStaticVoidMethod(env, clazz, mid_lock);\n\n        // Calling g_thread_init() multiple times leads to crash on GLib < 2.24\n        // We can use g_thread_get_initialized () but it is available only for\n        // GLib >= 2.20. We rely on GThreadHelper for GLib < 2.20.\n        gboolean is_g_thread_get_initialized = FALSE;\n        if (GLIB_CHECK_VERSION(2, 20, 0)) {\n            is_g_thread_get_initialized = fp_g_thread_get_initialized();\n        }\n\n        if (!(*env)->CallStaticBooleanMethod(env, clazz, mid_getAndSetInitializationNeededFlag)) {\n            if (!is_g_thread_get_initialized) {\n                fp_g_thread_init(NULL);\n            }\n\n            //According the GTK documentation, gdk_threads_init() should be\n            //called before gtk_init() or gtk_init_check()\n            fp_gdk_threads_init();\n        }\n        (*env)->CallStaticVoidMethod(env, clazz, mid_unlock);\n    }\n    result = (*fp_gtk_init_check)(NULL, NULL);\n\n    XSetErrorHandler(handler);\n    XSetIOErrorHandler(io_handler);\n    AWT_UNLOCK();\n\n    /* Initialize widget array. */\n    for (i = 0; i < _GTK_WIDGET_TYPE_SIZE; i++)\n    {\n        gtk2_widgets[i] = NULL;\n    }\n    if (result) {\n        GtkApi* gtk = (GtkApi*)malloc(sizeof(GtkApi));\n        gtk2_init(gtk);\n        return gtk;\n    }\n    return NULL;\n}\n\nint gtk2_unload()\n{\n    int i;\n    char *gtk2_error;\n\n    if (!gtk2_libhandle)\n        return TRUE;\n\n    /* Release painting objects */\n    if (gtk2_white_pixmap != NULL) {\n        (*fp_g_object_unref)(gtk2_white_pixmap);\n        (*fp_g_object_unref)(gtk2_black_pixmap);\n        (*fp_g_object_unref)(gtk2_white_pixbuf);\n        (*fp_g_object_unref)(gtk2_black_pixbuf);\n        gtk2_white_pixmap = gtk2_black_pixmap =\n            gtk2_white_pixbuf = gtk2_black_pixbuf = NULL;\n    }\n    gtk2_pixbuf_width = 0;\n    gtk2_pixbuf_height = 0;\n\n    if (gtk2_window != NULL) {\n        /* Destroying toplevel widget will destroy all contained widgets */\n        (*fp_gtk_widget_destroy)(gtk2_window);\n\n        /* Unset some static data so they get reinitialized on next load */\n        gtk2_window = NULL;\n    }\n\n    dlerror();\n    dlclose(gtk2_libhandle);\n    dlclose(gthread_libhandle);\n    if ((gtk2_error = dlerror()) != NULL)\n    {\n        return FALSE;\n    }\n    return TRUE;\n}\n\n/* Dispatch all pending events from the GTK event loop.\n * This is needed to catch theme change and update widgets' style.\n */\nstatic void flush_gtk_event_loop()\n{\n    while( (*fp_g_main_context_iteration)(NULL, FALSE));\n}\n\n/*\n * Initialize components of containment hierarchy. This creates a GtkFixed\n * inside a GtkWindow. All widgets get realized.\n */\nstatic void init_containers()\n{\n    if (gtk2_window == NULL)\n    {\n        gtk2_window = (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n        gtk2_fixed = (GtkFixed *)(*fp_gtk_fixed_new)();\n        (*fp_gtk_container_add)((GtkContainer*)gtk2_window,\n                                (GtkWidget *)gtk2_fixed);\n        (*fp_gtk_widget_realize)(gtk2_window);\n        (*fp_gtk_widget_realize)((GtkWidget *)gtk2_fixed);\n    }\n}\n\n/*\n * Ensure everything is ready for drawing an element of the specified width\n * and height.\n *\n * We should somehow handle translucent images. GTK can draw to X Drawables\n * only, which don't support alpha. When we retrieve the image back from\n * the server, translucency information is lost. There're several ways to\n * work around this:\n * 1) Subclass GdkPixmap and cache translucent objects on client side. This\n * requires us to implement parts of X server drawing logic on client side.\n * Many X requests can potentially be \"translucent\"; e.g. XDrawLine with\n * fill=tile and a translucent tile is a \"translucent\" operation, whereas\n * XDrawLine with fill=solid is an \"opaque\" one. Moreover themes can (and some\n * do) intermix transparent and opaque operations which makes caching even\n * more problematic.\n * 2) Use Xorg 32bit ARGB visual when available. GDK has no native support\n * for it (as of version 2.6). Also even in JDS 3 Xorg does not support\n * these visuals by default, which makes optimizing for them pointless.\n * We can consider doing this at a later point when ARGB visuals become more\n * popular.\n * 3') GTK has plans to use Cairo as its graphical backend (presumably in\n * 2.8), and Cairo supports alpha. With it we could also get rid of the\n * unnecessary round trip to server and do all the drawing on client side.\n * 4) For now we draw to two different pixmaps and restore alpha channel by\n * comparing results. This can be optimized by using subclassed pixmap and\n * doing the second drawing only if necessary.\n*/\nstatic void gtk2_init_painting(JNIEnv *env, gint width, gint height)\n{\n    GdkGC *gc;\n    GdkPixbuf *white, *black;\n\n    init_containers();\n\n    if (gtk2_pixbuf_width < width || gtk2_pixbuf_height < height)\n    {\n        white = (*fp_gdk_pixbuf_new)(GDK_COLORSPACE_RGB, TRUE, 8, width, height);\n        black = (*fp_gdk_pixbuf_new)(GDK_COLORSPACE_RGB, TRUE, 8, width, height);\n\n        if (white == NULL || black == NULL)\n        {\n            snprintf(convertionBuffer, CONV_BUFFER_SIZE, \"Couldn't create pixbuf of size %dx%d\", width, height);\n            throw_exception(env, \"java/lang/RuntimeException\", convertionBuffer);\n            fp_gdk_threads_leave();\n            return;\n        }\n\n        if (gtk2_white_pixmap != NULL) {\n            /* free old stuff */\n            (*fp_g_object_unref)(gtk2_white_pixmap);\n            (*fp_g_object_unref)(gtk2_black_pixmap);\n            (*fp_g_object_unref)(gtk2_white_pixbuf);\n            (*fp_g_object_unref)(gtk2_black_pixbuf);\n        }\n\n        gtk2_white_pixmap = (*fp_gdk_pixmap_new)(gtk2_window->window, width, height, -1);\n        gtk2_black_pixmap = (*fp_gdk_pixmap_new)(gtk2_window->window, width, height, -1);\n\n        gtk2_white_pixbuf = white;\n        gtk2_black_pixbuf = black;\n\n        gtk2_pixbuf_width = width;\n        gtk2_pixbuf_height = height;\n    }\n\n    /* clear the pixmaps */\n    gc = (*fp_gdk_gc_new)(gtk2_white_pixmap);\n    (*fp_gdk_rgb_gc_set_foreground)(gc, 0xffffff);\n    (*fp_gdk_draw_rectangle)(gtk2_white_pixmap, gc, TRUE, 0, 0, width, height);\n    (*fp_g_object_unref)(gc);\n\n    gc = (*fp_gdk_gc_new)(gtk2_black_pixmap);\n    (*fp_gdk_rgb_gc_set_foreground)(gc, 0x000000);\n    (*fp_gdk_draw_rectangle)(gtk2_black_pixmap, gc, TRUE, 0, 0, width, height);\n    (*fp_g_object_unref)(gc);\n}\n\n/*\n * Restore image from white and black pixmaps and copy it into destination\n * buffer. This method compares two pixbufs taken from white and black\n * pixmaps and decodes color and alpha components. Pixbufs are RGB without\n * alpha, destination buffer is ABGR.\n *\n * The return value is the transparency type of the resulting image, either\n * one of java_awt_Transparency_OPAQUE, java_awt_Transparency_BITMASK, and\n * java_awt_Transparency_TRANSLUCENT.\n */\nstatic gint gtk2_copy_image(gint *dst, gint width, gint height)\n{\n    gint i, j, r, g, b;\n    guchar *white, *black;\n    gint stride, padding;\n    gboolean is_opaque = TRUE;\n    gboolean is_bitmask = TRUE;\n\n    (*fp_gdk_pixbuf_get_from_drawable)(gtk2_white_pixbuf, gtk2_white_pixmap,\n            NULL, 0, 0, 0, 0, width, height);\n    (*fp_gdk_pixbuf_get_from_drawable)(gtk2_black_pixbuf, gtk2_black_pixmap,\n            NULL, 0, 0, 0, 0, width, height);\n\n    white = (*fp_gdk_pixbuf_get_pixels)(gtk2_white_pixbuf);\n    black = (*fp_gdk_pixbuf_get_pixels)(gtk2_black_pixbuf);\n    stride = (*fp_gdk_pixbuf_get_rowstride)(gtk2_black_pixbuf);\n    padding = stride - width * 4;\n\n    for (i = 0; i < height; i++) {\n        for (j = 0; j < width; j++) {\n            int r1 = *white++;\n            int r2 = *black++;\n            int alpha = 0xff + r2 - r1;\n\n            switch (alpha) {\n                case 0:       /* transparent pixel */\n                    r = g = b = 0;\n                    black += 3;\n                    white += 3;\n                    is_opaque = FALSE;\n                    break;\n\n                case 0xff:    /* opaque pixel */\n                    r = r2;\n                    g = *black++;\n                    b = *black++;\n                    black++;\n                    white += 3;\n                    break;\n\n                default:      /* translucent pixel */\n                    r = 0xff * r2 / alpha;\n                    g = 0xff * *black++ / alpha;\n                    b = 0xff * *black++ / alpha;\n                    black++;\n                    white += 3;\n                    is_opaque = FALSE;\n                    is_bitmask = FALSE;\n                    break;\n            }\n\n            *dst++ = (alpha << 24 | r << 16 | g << 8 | b);\n        }\n\n        white += padding;\n        black += padding;\n    }\n    return is_opaque ? java_awt_Transparency_OPAQUE :\n                       (is_bitmask ? java_awt_Transparency_BITMASK :\n                                     java_awt_Transparency_TRANSLUCENT);\n}\n\nstatic void\ngtk2_set_direction(GtkWidget *widget, GtkTextDirection dir)\n{\n    /*\n     * Some engines (inexplicably) look at the direction of the widget's\n     * parent, so we need to set the direction of both the widget and its\n     * parent.\n     */\n    (*fp_gtk_widget_set_direction)(widget, dir);\n    if (widget->parent != NULL) {\n        (*fp_gtk_widget_set_direction)(widget->parent, dir);\n    }\n}\n\n/*\n * Initializes the widget to correct state for some engines.\n * This is a pure empirical method.\n */\nstatic void init_toggle_widget(WidgetType widget_type, gint synth_state)\n{\n    gboolean is_active = ((synth_state & SELECTED) != 0);\n\n    if (widget_type == RADIO_BUTTON ||\n        widget_type == CHECK_BOX ||\n        widget_type == TOGGLE_BUTTON) {\n        ((GtkToggleButton*)gtk2_widget)->active = is_active;\n    }\n\n    if ((synth_state & FOCUSED) != 0) {\n        ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_FOCUS;\n    } else {\n        ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_FOCUS;\n    }\n\n    if ((synth_state & MOUSE_OVER) != 0 && (synth_state & PRESSED) == 0 ||\n           (synth_state & FOCUSED) != 0 && (synth_state & PRESSED) != 0) {\n        gtk2_widget->state = GTK_STATE_PRELIGHT;\n    } else if ((synth_state & DISABLED) != 0) {\n        gtk2_widget->state = GTK_STATE_INSENSITIVE;\n    } else {\n        gtk2_widget->state = is_active ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL;\n    }\n}\n\n/* GTK state_type filter */\nstatic GtkStateType get_gtk_state_type(WidgetType widget_type, gint synth_state)\n{\n    GtkStateType result = GTK_STATE_NORMAL;\n\n    if ((synth_state & DISABLED) != 0) {\n        result = GTK_STATE_INSENSITIVE;\n    } else if ((synth_state & PRESSED) != 0) {\n        result = GTK_STATE_ACTIVE;\n    } else if ((synth_state & MOUSE_OVER) != 0) {\n        result = GTK_STATE_PRELIGHT;\n    }\n    return result;\n}\n\n/* GTK shadow_type filter */\nstatic GtkShadowType get_gtk_shadow_type(WidgetType widget_type, gint synth_state)\n{\n    GtkShadowType result = GTK_SHADOW_OUT;\n\n    if ((synth_state & SELECTED) != 0) {\n        result = GTK_SHADOW_IN;\n    }\n    return result;\n}\n\n\nstatic GtkWidget* gtk2_get_arrow(GtkArrowType arrow_type, GtkShadowType shadow_type)\n{\n    GtkWidget *arrow = NULL;\n    if (NULL == gtk2_widgets[_GTK_ARROW_TYPE])\n    {\n        gtk2_widgets[_GTK_ARROW_TYPE] = (*fp_gtk_arrow_new)(arrow_type, shadow_type);\n        (*fp_gtk_container_add)((GtkContainer *)gtk2_fixed, gtk2_widgets[_GTK_ARROW_TYPE]);\n        (*fp_gtk_widget_realize)(gtk2_widgets[_GTK_ARROW_TYPE]);\n    }\n    arrow = gtk2_widgets[_GTK_ARROW_TYPE];\n\n    (*fp_gtk_arrow_set)(arrow, arrow_type, shadow_type);\n    return arrow;\n}\n\nstatic GtkAdjustment* create_adjustment()\n{\n    return (GtkAdjustment *)\n            (*fp_gtk_adjustment_new)(50.0, 0.0, 100.0, 10.0, 20.0, 20.0);\n}\n\n/**\n * Returns a pointer to the cached native widget for the specified widget\n * type.\n */\nstatic GtkWidget *gtk2_get_widget(WidgetType widget_type)\n{\n    gboolean init_result = FALSE;\n    GtkWidget *result = NULL;\n    switch (widget_type)\n    {\n        case BUTTON:\n        case TABLE_HEADER:\n            if (init_result = (NULL == gtk2_widgets[_GTK_BUTTON_TYPE]))\n            {\n                gtk2_widgets[_GTK_BUTTON_TYPE] = (*fp_gtk_button_new)();\n            }\n            result = gtk2_widgets[_GTK_BUTTON_TYPE];\n            break;\n        case CHECK_BOX:\n            if (init_result = (NULL == gtk2_widgets[_GTK_CHECK_BUTTON_TYPE]))\n            {\n                gtk2_widgets[_GTK_CHECK_BUTTON_TYPE] =\n                    (*fp_gtk_check_button_new)();\n            }\n            result = gtk2_widgets[_GTK_CHECK_BUTTON_TYPE];\n            break;\n        case CHECK_BOX_MENU_ITEM:\n            if (init_result = (NULL == gtk2_widgets[_GTK_CHECK_MENU_ITEM_TYPE]))\n            {\n                gtk2_widgets[_GTK_CHECK_MENU_ITEM_TYPE] =\n                    (*fp_gtk_check_menu_item_new)();\n            }\n            result = gtk2_widgets[_GTK_CHECK_MENU_ITEM_TYPE];\n            break;\n        /************************************************************\n         *    Creation a dedicated color chooser is dangerous because\n         * it deadlocks the EDT\n         ************************************************************/\n/*        case COLOR_CHOOSER:\n            if (init_result =\n                    (NULL == gtk2_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE]))\n            {\n                gtk2_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE] =\n                    (*fp_gtk_color_selection_dialog_new)(NULL);\n            }\n            result = gtk2_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE];\n            break;*/\n        case COMBO_BOX:\n            if (init_result = (NULL == gtk2_widgets[_GTK_COMBO_BOX_TYPE]))\n            {\n                gtk2_widgets[_GTK_COMBO_BOX_TYPE] =\n                    (*fp_gtk_combo_box_new)();\n            }\n            result = gtk2_widgets[_GTK_COMBO_BOX_TYPE];\n            break;\n        case COMBO_BOX_ARROW_BUTTON:\n            if (init_result =\n                    (NULL == gtk2_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE]))\n            {\n                gtk2_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE] =\n                     (*fp_gtk_toggle_button_new)();\n            }\n            result = gtk2_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE];\n            break;\n        case COMBO_BOX_TEXT_FIELD:\n            if (init_result =\n                    (NULL == gtk2_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE]))\n            {\n                result = gtk2_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE] =\n                     (*fp_gtk_entry_new)();\n            }\n            result = gtk2_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE];\n            break;\n        case DESKTOP_ICON:\n        case INTERNAL_FRAME_TITLE_PANE:\n        case LABEL:\n            if (init_result = (NULL == gtk2_widgets[_GTK_LABEL_TYPE]))\n            {\n                gtk2_widgets[_GTK_LABEL_TYPE] =\n                    (*fp_gtk_label_new)(NULL);\n            }\n            result = gtk2_widgets[_GTK_LABEL_TYPE];\n            break;\n        case DESKTOP_PANE:\n        case PANEL:\n        case ROOT_PANE:\n            if (init_result = (NULL == gtk2_widgets[_GTK_CONTAINER_TYPE]))\n            {\n                /* There is no constructor for a container type.  I've\n                 * chosen GtkFixed container since it has a default\n                 * constructor.\n                 */\n                gtk2_widgets[_GTK_CONTAINER_TYPE] =\n                    (*fp_gtk_fixed_new)();\n            }\n            result = gtk2_widgets[_GTK_CONTAINER_TYPE];\n            break;\n        case EDITOR_PANE:\n        case TEXT_AREA:\n        case TEXT_PANE:\n            if (init_result = (NULL == gtk2_widgets[_GTK_TEXT_VIEW_TYPE]))\n            {\n                gtk2_widgets[_GTK_TEXT_VIEW_TYPE] =\n                    (*fp_gtk_text_view_new)();\n            }\n            result = gtk2_widgets[_GTK_TEXT_VIEW_TYPE];\n            break;\n        case FORMATTED_TEXT_FIELD:\n        case PASSWORD_FIELD:\n        case TEXT_FIELD:\n            if (init_result = (NULL == gtk2_widgets[_GTK_ENTRY_TYPE]))\n            {\n                gtk2_widgets[_GTK_ENTRY_TYPE] =\n                    (*fp_gtk_entry_new)();\n            }\n            result = gtk2_widgets[_GTK_ENTRY_TYPE];\n            break;\n        case HANDLE_BOX:\n            if (init_result = (NULL == gtk2_widgets[_GTK_HANDLE_BOX_TYPE]))\n            {\n                gtk2_widgets[_GTK_HANDLE_BOX_TYPE] =\n                    (*fp_gtk_handle_box_new)();\n            }\n            result = gtk2_widgets[_GTK_HANDLE_BOX_TYPE];\n            break;\n        case HSCROLL_BAR:\n        case HSCROLL_BAR_BUTTON_LEFT:\n        case HSCROLL_BAR_BUTTON_RIGHT:\n        case HSCROLL_BAR_TRACK:\n        case HSCROLL_BAR_THUMB:\n            if (init_result = (NULL == gtk2_widgets[_GTK_HSCROLLBAR_TYPE]))\n            {\n                gtk2_widgets[_GTK_HSCROLLBAR_TYPE] =\n                    (*fp_gtk_hscrollbar_new)(create_adjustment());\n            }\n            result = gtk2_widgets[_GTK_HSCROLLBAR_TYPE];\n            break;\n        case HSEPARATOR:\n            if (init_result = (NULL == gtk2_widgets[_GTK_HSEPARATOR_TYPE]))\n            {\n                gtk2_widgets[_GTK_HSEPARATOR_TYPE] =\n                    (*fp_gtk_hseparator_new)();\n            }\n            result = gtk2_widgets[_GTK_HSEPARATOR_TYPE];\n            break;\n        case HSLIDER:\n        case HSLIDER_THUMB:\n        case HSLIDER_TRACK:\n            if (init_result = (NULL == gtk2_widgets[_GTK_HSCALE_TYPE]))\n            {\n                gtk2_widgets[_GTK_HSCALE_TYPE] =\n                    (*fp_gtk_hscale_new)(NULL);\n            }\n            result = gtk2_widgets[_GTK_HSCALE_TYPE];\n            break;\n        case HSPLIT_PANE_DIVIDER:\n        case SPLIT_PANE:\n            if (init_result = (NULL == gtk2_widgets[_GTK_HPANED_TYPE]))\n            {\n                gtk2_widgets[_GTK_HPANED_TYPE] = (*fp_gtk_hpaned_new)();\n            }\n            result = gtk2_widgets[_GTK_HPANED_TYPE];\n            break;\n        case IMAGE:\n            if (init_result = (NULL == gtk2_widgets[_GTK_IMAGE_TYPE]))\n            {\n                gtk2_widgets[_GTK_IMAGE_TYPE] = (*fp_gtk_image_new)();\n            }\n            result = gtk2_widgets[_GTK_IMAGE_TYPE];\n            break;\n        case INTERNAL_FRAME:\n            if (init_result = (NULL == gtk2_widgets[_GTK_WINDOW_TYPE]))\n            {\n                gtk2_widgets[_GTK_WINDOW_TYPE] =\n                    (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n            }\n            result = gtk2_widgets[_GTK_WINDOW_TYPE];\n            break;\n        case TOOL_TIP:\n            if (init_result = (NULL == gtk2_widgets[_GTK_TOOLTIP_TYPE]))\n            {\n                result = (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n                (*fp_gtk_widget_set_name)(result, \"gtk-tooltips\");\n                gtk2_widgets[_GTK_TOOLTIP_TYPE] = result;\n            }\n            result = gtk2_widgets[_GTK_TOOLTIP_TYPE];\n            break;\n        case LIST:\n        case TABLE:\n        case TREE:\n        case TREE_CELL:\n            if (init_result = (NULL == gtk2_widgets[_GTK_TREE_VIEW_TYPE]))\n            {\n                gtk2_widgets[_GTK_TREE_VIEW_TYPE] =\n                    (*fp_gtk_tree_view_new)();\n            }\n            result = gtk2_widgets[_GTK_TREE_VIEW_TYPE];\n            break;\n        case TITLED_BORDER:\n            if (init_result = (NULL == gtk2_widgets[_GTK_FRAME_TYPE]))\n            {\n                gtk2_widgets[_GTK_FRAME_TYPE] = fp_gtk_frame_new(NULL);\n            }\n            result = gtk2_widgets[_GTK_FRAME_TYPE];\n            break;\n        case POPUP_MENU:\n            if (init_result = (NULL == gtk2_widgets[_GTK_MENU_TYPE]))\n            {\n                gtk2_widgets[_GTK_MENU_TYPE] =\n                    (*fp_gtk_menu_new)();\n            }\n            result = gtk2_widgets[_GTK_MENU_TYPE];\n            break;\n        case MENU:\n        case MENU_ITEM:\n        case MENU_ITEM_ACCELERATOR:\n            if (init_result = (NULL == gtk2_widgets[_GTK_MENU_ITEM_TYPE]))\n            {\n                gtk2_widgets[_GTK_MENU_ITEM_TYPE] =\n                    (*fp_gtk_menu_item_new)();\n            }\n            result = gtk2_widgets[_GTK_MENU_ITEM_TYPE];\n            break;\n        case MENU_BAR:\n            if (init_result = (NULL == gtk2_widgets[_GTK_MENU_BAR_TYPE]))\n            {\n                gtk2_widgets[_GTK_MENU_BAR_TYPE] =\n                    (*fp_gtk_menu_bar_new)();\n            }\n            result = gtk2_widgets[_GTK_MENU_BAR_TYPE];\n            break;\n        case COLOR_CHOOSER:\n        case OPTION_PANE:\n            if (init_result = (NULL == gtk2_widgets[_GTK_DIALOG_TYPE]))\n            {\n                gtk2_widgets[_GTK_DIALOG_TYPE] =\n                    (*fp_gtk_dialog_new)();\n            }\n            result = gtk2_widgets[_GTK_DIALOG_TYPE];\n            break;\n        case POPUP_MENU_SEPARATOR:\n            if (init_result =\n                    (NULL == gtk2_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE]))\n            {\n                gtk2_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE] =\n                    (*fp_gtk_separator_menu_item_new)();\n            }\n            result = gtk2_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE];\n            break;\n        case HPROGRESS_BAR:\n            if (init_result = (NULL == gtk2_widgets[_GTK_HPROGRESS_BAR_TYPE]))\n            {\n                gtk2_widgets[_GTK_HPROGRESS_BAR_TYPE] =\n                    (*fp_gtk_progress_bar_new)();\n            }\n            result = gtk2_widgets[_GTK_HPROGRESS_BAR_TYPE];\n            break;\n        case VPROGRESS_BAR:\n            if (init_result = (NULL == gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE]))\n            {\n                gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE] =\n                    (*fp_gtk_progress_bar_new)();\n                /*\n                 * Vertical JProgressBars always go bottom-to-top,\n                 * regardless of the ComponentOrientation.\n                 */\n                (*fp_gtk_progress_bar_set_orientation)(\n                    (GtkProgressBar *)gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE],\n                    GTK_PROGRESS_BOTTOM_TO_TOP);\n            }\n            result = gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE];\n            break;\n        case RADIO_BUTTON:\n            if (init_result = (NULL == gtk2_widgets[_GTK_RADIO_BUTTON_TYPE]))\n            {\n                gtk2_widgets[_GTK_RADIO_BUTTON_TYPE] =\n                    (*fp_gtk_radio_button_new)(NULL);\n            }\n            result = gtk2_widgets[_GTK_RADIO_BUTTON_TYPE];\n            break;\n        case RADIO_BUTTON_MENU_ITEM:\n            if (init_result =\n                    (NULL == gtk2_widgets[_GTK_RADIO_MENU_ITEM_TYPE]))\n            {\n                gtk2_widgets[_GTK_RADIO_MENU_ITEM_TYPE] =\n                    (*fp_gtk_radio_menu_item_new)(NULL);\n            }\n            result = gtk2_widgets[_GTK_RADIO_MENU_ITEM_TYPE];\n            break;\n        case SCROLL_PANE:\n            if (init_result =\n                    (NULL == gtk2_widgets[_GTK_SCROLLED_WINDOW_TYPE]))\n            {\n                gtk2_widgets[_GTK_SCROLLED_WINDOW_TYPE] =\n                    (*fp_gtk_scrolled_window_new)(NULL, NULL);\n            }\n            result = gtk2_widgets[_GTK_SCROLLED_WINDOW_TYPE];\n            break;\n        case SPINNER:\n        case SPINNER_ARROW_BUTTON:\n        case SPINNER_TEXT_FIELD:\n            if (init_result = (NULL == gtk2_widgets[_GTK_SPIN_BUTTON_TYPE]))\n            {\n                result = gtk2_widgets[_GTK_SPIN_BUTTON_TYPE] =\n                    (*fp_gtk_spin_button_new)(NULL, 0, 0);\n            }\n            result = gtk2_widgets[_GTK_SPIN_BUTTON_TYPE];\n            break;\n        case TABBED_PANE:\n        case TABBED_PANE_TAB_AREA:\n        case TABBED_PANE_CONTENT:\n        case TABBED_PANE_TAB:\n            if (init_result = (NULL == gtk2_widgets[_GTK_NOTEBOOK_TYPE]))\n            {\n                gtk2_widgets[_GTK_NOTEBOOK_TYPE] =\n                    (*fp_gtk_notebook_new)(NULL);\n            }\n            result = gtk2_widgets[_GTK_NOTEBOOK_TYPE];\n            break;\n        case TOGGLE_BUTTON:\n            if (init_result = (NULL == gtk2_widgets[_GTK_TOGGLE_BUTTON_TYPE]))\n            {\n                gtk2_widgets[_GTK_TOGGLE_BUTTON_TYPE] =\n                    (*fp_gtk_toggle_button_new)(NULL);\n            }\n            result = gtk2_widgets[_GTK_TOGGLE_BUTTON_TYPE];\n            break;\n        case TOOL_BAR:\n        case TOOL_BAR_DRAG_WINDOW:\n            if (init_result = (NULL == gtk2_widgets[_GTK_TOOLBAR_TYPE]))\n            {\n                gtk2_widgets[_GTK_TOOLBAR_TYPE] =\n                    (*fp_gtk_toolbar_new)(NULL);\n            }\n            result = gtk2_widgets[_GTK_TOOLBAR_TYPE];\n            break;\n        case TOOL_BAR_SEPARATOR:\n            if (init_result =\n                    (NULL == gtk2_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE]))\n            {\n                gtk2_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE] =\n                    (*fp_gtk_separator_tool_item_new)();\n            }\n            result = gtk2_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE];\n            break;\n        case VIEWPORT:\n            if (init_result = (NULL == gtk2_widgets[_GTK_VIEWPORT_TYPE]))\n            {\n                GtkAdjustment *adjustment = create_adjustment();\n                gtk2_widgets[_GTK_VIEWPORT_TYPE] =\n                    (*fp_gtk_viewport_new)(adjustment, adjustment);\n            }\n            result = gtk2_widgets[_GTK_VIEWPORT_TYPE];\n            break;\n        case VSCROLL_BAR:\n        case VSCROLL_BAR_BUTTON_UP:\n        case VSCROLL_BAR_BUTTON_DOWN:\n        case VSCROLL_BAR_TRACK:\n        case VSCROLL_BAR_THUMB:\n            if (init_result = (NULL == gtk2_widgets[_GTK_VSCROLLBAR_TYPE]))\n            {\n                gtk2_widgets[_GTK_VSCROLLBAR_TYPE] =\n                    (*fp_gtk_vscrollbar_new)(create_adjustment());\n            }\n            result = gtk2_widgets[_GTK_VSCROLLBAR_TYPE];\n            break;\n        case VSEPARATOR:\n            if (init_result = (NULL == gtk2_widgets[_GTK_VSEPARATOR_TYPE]))\n            {\n                gtk2_widgets[_GTK_VSEPARATOR_TYPE] =\n                    (*fp_gtk_vseparator_new)();\n            }\n            result = gtk2_widgets[_GTK_VSEPARATOR_TYPE];\n            break;\n        case VSLIDER:\n        case VSLIDER_THUMB:\n        case VSLIDER_TRACK:\n            if (init_result = (NULL == gtk2_widgets[_GTK_VSCALE_TYPE]))\n            {\n                gtk2_widgets[_GTK_VSCALE_TYPE] =\n                    (*fp_gtk_vscale_new)(NULL);\n            }\n            result = gtk2_widgets[_GTK_VSCALE_TYPE];\n            /*\n             * Vertical JSliders start at the bottom, while vertical\n             * GtkVScale widgets start at the top (by default), so to fix\n             * this we set the \"inverted\" flag to get the Swing behavior.\n             */\n            ((GtkRange*)result)->inverted = 1;\n            break;\n        case VSPLIT_PANE_DIVIDER:\n            if (init_result = (NULL == gtk2_widgets[_GTK_VPANED_TYPE]))\n            {\n                gtk2_widgets[_GTK_VPANED_TYPE] = (*fp_gtk_vpaned_new)();\n            }\n            result = gtk2_widgets[_GTK_VPANED_TYPE];\n            break;\n        default:\n            result = NULL;\n            break;\n    }\n\n    if (result != NULL && init_result)\n    {\n        if (widget_type == RADIO_BUTTON_MENU_ITEM ||\n                widget_type == CHECK_BOX_MENU_ITEM ||\n                widget_type == MENU_ITEM ||\n                widget_type == MENU ||\n                widget_type == POPUP_MENU_SEPARATOR)\n        {\n            GtkWidget *menu = gtk2_get_widget(POPUP_MENU);\n            (*fp_gtk_menu_shell_append)((GtkMenuShell *)menu, result);\n        }\n        else if (widget_type == POPUP_MENU)\n        {\n            GtkWidget *menu_bar = gtk2_get_widget(MENU_BAR);\n            GtkWidget *root_menu = (*fp_gtk_menu_item_new)();\n            (*fp_gtk_menu_item_set_submenu)((GtkMenuItem*)root_menu, result);\n            (*fp_gtk_menu_shell_append)((GtkMenuShell *)menu_bar, root_menu);\n        }\n        else if (widget_type == COMBO_BOX_ARROW_BUTTON ||\n                 widget_type == COMBO_BOX_TEXT_FIELD)\n        {\n            /*\n            * We add a regular GtkButton/GtkEntry to a GtkComboBoxEntry\n            * in order to trick engines into thinking it's a real combobox\n            * arrow button/text field.\n            */\n            GtkWidget *combo = (*fp_gtk_combo_box_entry_new)();\n\n            if (new_combo && widget_type == COMBO_BOX_ARROW_BUTTON) {\n                (*fp_gtk_widget_set_parent)(result, combo);\n                ((GtkBin*)combo)->child = result;\n            } else {\n                (*fp_gtk_container_add)((GtkContainer *)combo, result);\n            }\n            (*fp_gtk_container_add)((GtkContainer *)gtk2_fixed, combo);\n        }\n        else if (widget_type != TOOL_TIP &&\n                 widget_type != INTERNAL_FRAME &&\n                 widget_type != OPTION_PANE)\n        {\n            (*fp_gtk_container_add)((GtkContainer *)gtk2_fixed, result);\n        }\n        (*fp_gtk_widget_realize)(result);\n    }\n    return result;\n}\n\nvoid gtk2_paint_arrow(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height,\n        GtkArrowType arrow_type, gboolean fill)\n{\n    static int w, h;\n    static GtkRequisition size;\n\n    if (widget_type == COMBO_BOX_ARROW_BUTTON || widget_type == TABLE)\n        gtk2_widget = gtk2_get_arrow(arrow_type, shadow_type);\n    else\n        gtk2_widget = gtk2_get_widget(widget_type);\n\n    switch (widget_type)\n    {\n        case SPINNER_ARROW_BUTTON:\n            x = 1;\n            y = ((arrow_type == GTK_ARROW_UP) ? 2 : 0);\n            height -= 2;\n            width -= 3;\n\n            w = width / 2;\n            w -= w % 2 - 1;\n            h = (w + 1) / 2;\n            break;\n\n        case HSCROLL_BAR_BUTTON_LEFT:\n        case HSCROLL_BAR_BUTTON_RIGHT:\n        case VSCROLL_BAR_BUTTON_UP:\n        case VSCROLL_BAR_BUTTON_DOWN:\n            w = width / 2;\n            h = height / 2;\n            break;\n\n        case COMBO_BOX_ARROW_BUTTON:\n        case TABLE:\n            x = 1;\n            (*fp_gtk_widget_size_request)(gtk2_widget, &size);\n            w = size.width - ((GtkMisc*)gtk2_widget)->xpad * 2;\n            h = size.height - ((GtkMisc*)gtk2_widget)->ypad * 2;\n            w = h = MIN(MIN(w, h), MIN(width,height)) * 0.7;\n            break;\n\n        default:\n            w = width;\n            h = height;\n            break;\n    }\n    x += (width - w) / 2;\n    y += (height - h) / 2;\n\n    (*fp_gtk_paint_arrow)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail, arrow_type, fill,\n            x, y, w, h);\n    (*fp_gtk_paint_arrow)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail, arrow_type, fill,\n            x, y, w, h);\n}\n\nstatic void gtk2_paint_box(WidgetType widget_type, GtkStateType state_type,\n                    GtkShadowType shadow_type, const gchar *detail,\n                    gint x, gint y, gint width, gint height,\n                    gint synth_state, GtkTextDirection dir)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n\n    /*\n     * The clearlooks engine sometimes looks at the widget's state field\n     * instead of just the state_type variable that we pass in, so to account\n     * for those cases we set the widget's state field accordingly.  The\n     * flags field is similarly important for things like focus/default state.\n     */\n    gtk2_widget->state = state_type;\n\n    if (widget_type == HSLIDER_TRACK) {\n        /*\n         * For horizontal JSliders with right-to-left orientation, we need\n         * to set the \"inverted\" flag to match the native GTK behavior where\n         * the foreground highlight is on the right side of the slider thumb.\n         * This is needed especially for the ubuntulooks engine, which looks\n         * exclusively at the \"inverted\" flag to determine on which side of\n         * the thumb to paint the highlight...\n         */\n        ((GtkRange*)gtk2_widget)->inverted = (dir == GTK_TEXT_DIR_RTL);\n\n        /*\n         * Note however that other engines like clearlooks will look at both\n         * the \"inverted\" field and the text direction to determine how\n         * the foreground highlight is painted:\n         *     !inverted && ltr --> paint highlight on left side\n         *     !inverted && rtl --> paint highlight on right side\n         *      inverted && ltr --> paint highlight on right side\n         *      inverted && rtl --> paint highlight on left side\n         * So the only way to reliably get the desired results for horizontal\n         * JSlider (i.e., highlight on left side for LTR ComponentOrientation\n         * and highlight on right side for RTL ComponentOrientation) is to\n         * always override text direction as LTR, and then set the \"inverted\"\n         * flag accordingly (as we have done above).\n         */\n        dir = GTK_TEXT_DIR_LTR;\n    }\n\n    /*\n     * Some engines (e.g. clearlooks) will paint the shadow of certain\n     * widgets (e.g. COMBO_BOX_ARROW_BUTTON) differently depending on the\n     * the text direction.\n     */\n    gtk2_set_direction(gtk2_widget, dir);\n\n    switch (widget_type) {\n    case BUTTON:\n        if (synth_state & DEFAULT) {\n            ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_DEFAULT;\n        } else {\n            ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_DEFAULT;\n        }\n        break;\n    case TOGGLE_BUTTON:\n        init_toggle_widget(widget_type, synth_state);\n        break;\n    case HSCROLL_BAR_BUTTON_LEFT:\n        /*\n         * The clearlooks engine will draw a \"left\" button when:\n         *   x == w->allocation.x\n         *\n         * The ubuntulooks engine will draw a \"left\" button when:\n         *   [x,y,width,height]\n         *     intersects\n         *   [w->alloc.x,w->alloc.y,width,height]\n         *\n         * The values that are set below should ensure that a \"left\"\n         * button is rendered for both of these (and other) engines.\n         */\n        gtk2_widget->allocation.x = x;\n        gtk2_widget->allocation.y = y;\n        gtk2_widget->allocation.width = width;\n        gtk2_widget->allocation.height = height;\n        break;\n    case HSCROLL_BAR_BUTTON_RIGHT:\n        /*\n         * The clearlooks engine will draw a \"right\" button when:\n         *   x + width == w->allocation.x + w->allocation.width\n         *\n         * The ubuntulooks engine will draw a \"right\" button when:\n         *   [x,y,width,height]\n         *     does not intersect\n         *   [w->alloc.x,w->alloc.y,width,height]\n         *     but does intersect\n         *   [w->alloc.x+width,w->alloc.y,width,height]\n         *\n         * The values that are set below should ensure that a \"right\"\n         * button is rendered for both of these (and other) engines.\n         */\n        gtk2_widget->allocation.x = x+width;\n        gtk2_widget->allocation.y = 0;\n        gtk2_widget->allocation.width = 0;\n        gtk2_widget->allocation.height = height;\n        break;\n    case VSCROLL_BAR_BUTTON_UP:\n        /*\n         * The clearlooks engine will draw an \"up\" button when:\n         *   y == w->allocation.y\n         *\n         * The ubuntulooks engine will draw an \"up\" button when:\n         *   [x,y,width,height]\n         *     intersects\n         *   [w->alloc.x,w->alloc.y,width,height]\n         *\n         * The values that are set below should ensure that an \"up\"\n         * button is rendered for both of these (and other) engines.\n         */\n        gtk2_widget->allocation.x = x;\n        gtk2_widget->allocation.y = y;\n        gtk2_widget->allocation.width = width;\n        gtk2_widget->allocation.height = height;\n        break;\n    case VSCROLL_BAR_BUTTON_DOWN:\n        /*\n         * The clearlooks engine will draw a \"down\" button when:\n         *   y + height == w->allocation.y + w->allocation.height\n         *\n         * The ubuntulooks engine will draw a \"down\" button when:\n         *   [x,y,width,height]\n         *     does not intersect\n         *   [w->alloc.x,w->alloc.y,width,height]\n         *     but does intersect\n         *   [w->alloc.x,w->alloc.y+height,width,height]\n         *\n         * The values that are set below should ensure that a \"down\"\n         * button is rendered for both of these (and other) engines.\n         */\n        gtk2_widget->allocation.x = x;\n        gtk2_widget->allocation.y = y+height;\n        gtk2_widget->allocation.width = width;\n        gtk2_widget->allocation.height = 0;\n        break;\n    default:\n        break;\n    }\n\n    (*fp_gtk_paint_box)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n    (*fp_gtk_paint_box)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n\n    /*\n     * Reset the text direction to the default value so that we don't\n     * accidentally affect other operations and widgets.\n     */\n    gtk2_set_direction(gtk2_widget, GTK_TEXT_DIR_LTR);\n}\n\nvoid gtk2_paint_box_gap(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height,\n        GtkPositionType gap_side, gint gap_x, gint gap_width)\n{\n    /* Clearlooks needs a real clip area to paint the gap properly */\n    GdkRectangle area = { x, y, width, height };\n\n    gtk2_widget = gtk2_get_widget(widget_type);\n    (*fp_gtk_paint_box_gap)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            shadow_type, &area, gtk2_widget, detail,\n            x, y, width, height, gap_side, gap_x, gap_width);\n    (*fp_gtk_paint_box_gap)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            shadow_type, &area, gtk2_widget, detail,\n            x, y, width, height, gap_side, gap_x, gap_width);\n}\n\nstatic void gtk2_paint_check(WidgetType widget_type, gint synth_state,\n        const gchar *detail, gint x, gint y, gint width, gint height)\n{\n    GtkStateType state_type = get_gtk_state_type(widget_type, synth_state);\n    GtkShadowType shadow_type = get_gtk_shadow_type(widget_type, synth_state);\n\n    gtk2_widget = gtk2_get_widget(widget_type);\n    init_toggle_widget(widget_type, synth_state);\n\n    (*fp_gtk_paint_check)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height);\n    (*fp_gtk_paint_check)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height);\n}\n\nstatic void gtk2_paint_diamond(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n    (*fp_gtk_paint_diamond)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height);\n    (*fp_gtk_paint_diamond)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height);\n}\n\nstatic void gtk2_paint_expander(WidgetType widget_type, GtkStateType state_type,\n        const gchar *detail, gint x, gint y, gint width, gint height,\n        GtkExpanderStyle expander_style)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n    (*fp_gtk_paint_expander)(gtk2_widget->style, gtk2_white_pixmap,\n            state_type, NULL, gtk2_widget, detail,\n            x + width / 2, y + height / 2, expander_style);\n    (*fp_gtk_paint_expander)(gtk2_widget->style, gtk2_black_pixmap,\n            state_type, NULL, gtk2_widget, detail,\n            x + width / 2, y + height / 2, expander_style);\n}\n\nstatic void gtk2_paint_extension(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height, GtkPositionType gap_side)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n    (*fp_gtk_paint_extension)(gtk2_widget->style, gtk2_white_pixmap,\n            state_type, shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height, gap_side);\n    (*fp_gtk_paint_extension)(gtk2_widget->style, gtk2_black_pixmap,\n            state_type, shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height, gap_side);\n}\n\nstatic void gtk2_paint_flat_box(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height, gboolean has_focus)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n\n    if (has_focus)\n        ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_FOCUS;\n    else\n        ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_FOCUS;\n\n    (*fp_gtk_paint_flat_box)(gtk2_widget->style, gtk2_white_pixmap,\n            state_type, shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height);\n    (*fp_gtk_paint_flat_box)(gtk2_widget->style, gtk2_black_pixmap,\n            state_type, shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height);\n}\n\nstatic void gtk2_paint_focus(WidgetType widget_type, GtkStateType state_type,\n        const char *detail, gint x, gint y, gint width, gint height)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n    (*fp_gtk_paint_focus)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            NULL, gtk2_widget, detail, x, y, width, height);\n    (*fp_gtk_paint_focus)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            NULL, gtk2_widget, detail, x, y, width, height);\n}\n\nstatic void gtk2_paint_handle(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height, GtkOrientation orientation)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n    (*fp_gtk_paint_handle)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height, orientation);\n    (*fp_gtk_paint_handle)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height, orientation);\n}\n\nstatic void gtk2_paint_hline(WidgetType widget_type, GtkStateType state_type,\n        const gchar *detail, gint x, gint y, gint width, gint height)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n    (*fp_gtk_paint_hline)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            NULL, gtk2_widget, detail, x, x + width, y);\n    (*fp_gtk_paint_hline)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            NULL, gtk2_widget, detail, x, x + width, y);\n}\n\nstatic void gtk2_paint_option(WidgetType widget_type, gint synth_state,\n        const gchar *detail, gint x, gint y, gint width, gint height)\n{\n    GtkStateType state_type = get_gtk_state_type(widget_type, synth_state);\n    GtkShadowType shadow_type = get_gtk_shadow_type(widget_type, synth_state);\n\n    gtk2_widget = gtk2_get_widget(widget_type);\n    init_toggle_widget(widget_type, synth_state);\n\n    (*fp_gtk_paint_option)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height);\n    (*fp_gtk_paint_option)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height);\n}\n\nstatic void gtk2_paint_shadow(WidgetType widget_type, GtkStateType state_type,\n                       GtkShadowType shadow_type, const gchar *detail,\n                       gint x, gint y, gint width, gint height,\n                       gint synth_state, GtkTextDirection dir)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n\n    /*\n     * The clearlooks engine sometimes looks at the widget's state field\n     * instead of just the state_type variable that we pass in, so to account\n     * for those cases we set the widget's state field accordingly.  The\n     * flags field is similarly important for things like focus state.\n     */\n    gtk2_widget->state = state_type;\n\n    /*\n     * Some engines (e.g. clearlooks) will paint the shadow of certain\n     * widgets (e.g. COMBO_BOX_TEXT_FIELD) differently depending on the\n     * the text direction.\n     */\n    gtk2_set_direction(gtk2_widget, dir);\n\n    switch (widget_type) {\n    case COMBO_BOX_TEXT_FIELD:\n    case FORMATTED_TEXT_FIELD:\n    case PASSWORD_FIELD:\n    case SPINNER_TEXT_FIELD:\n    case TEXT_FIELD:\n        if (synth_state & FOCUSED) {\n            ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_FOCUS;\n        } else {\n            ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_FOCUS;\n        }\n        break;\n    default:\n        break;\n    }\n\n    (*fp_gtk_paint_shadow)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n    (*fp_gtk_paint_shadow)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n\n    /*\n     * Reset the text direction to the default value so that we don't\n     * accidentally affect other operations and widgets.\n     */\n    gtk2_set_direction(gtk2_widget, GTK_TEXT_DIR_LTR);\n}\n\nstatic void gtk2_paint_slider(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height, GtkOrientation orientation,\n        gboolean has_focus)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n    (*fp_gtk_paint_slider)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height, orientation);\n    (*fp_gtk_paint_slider)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            shadow_type, NULL, gtk2_widget, detail,\n            x, y, width, height, orientation);\n}\n\nstatic void gtk2_paint_vline(WidgetType widget_type, GtkStateType state_type,\n        const gchar *detail, gint x, gint y, gint width, gint height)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n    (*fp_gtk_paint_vline)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n            NULL, gtk2_widget, detail, y, y + height, x);\n    (*fp_gtk_paint_vline)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n            NULL, gtk2_widget, detail, y, y + height, x);\n}\n\nstatic void gtk_paint_background(WidgetType widget_type, GtkStateType state_type,\n        gint x, gint y, gint width, gint height)\n{\n    gtk2_widget = gtk2_get_widget(widget_type);\n    (*fp_gtk_style_apply_default_background)(gtk2_widget->style,\n            gtk2_white_pixmap, TRUE, state_type, NULL, x, y, width, height);\n    (*fp_gtk_style_apply_default_background)(gtk2_widget->style,\n            gtk2_black_pixmap, TRUE, state_type, NULL, x, y, width, height);\n}\n\nstatic GdkPixbuf *gtk2_get_stock_icon(gint widget_type, const gchar *stock_id,\n        GtkIconSize size, GtkTextDirection direction, const char *detail)\n{\n    init_containers();\n    gtk2_widget = gtk2_get_widget((widget_type < 0) ? IMAGE : widget_type);\n    gtk2_widget->state = GTK_STATE_NORMAL;\n    (*fp_gtk_widget_set_direction)(gtk2_widget, direction);\n    return (*fp_gtk_widget_render_icon)(gtk2_widget, stock_id, size, detail);\n}\n\nstatic jboolean gtk2_get_pixbuf_data(JNIEnv *env, GdkPixbuf* pixbuf,\n                              jmethodID icon_upcall_method, jobject this) {\n    if (!pixbuf) {\n        return JNI_FALSE;\n    }\n    guchar *pixbuf_data = (*fp_gdk_pixbuf_get_pixels)(pixbuf);\n    if (pixbuf_data) {\n        int row_stride = (*fp_gdk_pixbuf_get_rowstride)(pixbuf);\n        int width = (*fp_gdk_pixbuf_get_width)(pixbuf);\n        int height = (*fp_gdk_pixbuf_get_height)(pixbuf);\n        int bps = (*fp_gdk_pixbuf_get_bits_per_sample)(pixbuf);\n        int channels = (*fp_gdk_pixbuf_get_n_channels)(pixbuf);\n        gboolean alpha = (*fp_gdk_pixbuf_get_has_alpha)(pixbuf);\n\n        jbyteArray data = (*env)->NewByteArray(env, (row_stride * height));\n        JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n\n        (*env)->SetByteArrayRegion(env, data, 0, (row_stride * height),\n                                   (jbyte *)pixbuf_data);\n        (*fp_g_object_unref)(pixbuf);\n\n        /* Call the callback method to create the image on the Java side. */\n        (*env)->CallVoidMethod(env, this, icon_upcall_method, data,\n                width, height, row_stride, bps, channels, alpha);\n        return JNI_TRUE;\n    }\n    return JNI_FALSE;\n}\n\nstatic jboolean gtk2_get_file_icon_data(JNIEnv *env, const char *filename,\n                 GError **error, jmethodID icon_upcall_method, jobject this) {\n    GdkPixbuf* pixbuf = fp_gdk_pixbuf_new_from_file(filename, error);\n    return gtk2_get_pixbuf_data(env, pixbuf, icon_upcall_method, this);\n}\n\nstatic jboolean gtk2_get_icon_data(JNIEnv *env, gint widget_type,\n                              const gchar *stock_id, GtkIconSize size,\n                              GtkTextDirection direction, const char *detail,\n                              jmethodID icon_upcall_method, jobject this) {\n    GdkPixbuf* pixbuf = gtk2_get_stock_icon(widget_type, stock_id, size,\n                                       direction, detail);\n    return gtk2_get_pixbuf_data(env, pixbuf, icon_upcall_method, this);\n}\n\n/*************************************************/\nstatic gint gtk2_get_xthickness(JNIEnv *env, WidgetType widget_type)\n{\n    init_containers();\n\n    gtk2_widget = gtk2_get_widget(widget_type);\n    GtkStyle* style = gtk2_widget->style;\n    return style->xthickness;\n}\n\nstatic gint gtk2_get_ythickness(JNIEnv *env, WidgetType widget_type)\n{\n    init_containers();\n\n    gtk2_widget = gtk2_get_widget(widget_type);\n    GtkStyle* style = gtk2_widget->style;\n    return style->ythickness;\n}\n\n/*************************************************/\nstatic guint8 recode_color(guint16 channel)\n{\n    return (guint8)(channel>>8);\n}\n\nstatic gint gtk2_get_color_for_state(JNIEnv *env, WidgetType widget_type,\n                              GtkStateType state_type, ColorType color_type)\n{\n    gint result = 0;\n    GdkColor *color = NULL;\n\n    init_containers();\n\n    gtk2_widget = gtk2_get_widget(widget_type);\n    GtkStyle* style = gtk2_widget->style;\n\n    switch (color_type)\n    {\n        case FOREGROUND:\n            color = &(style->fg[state_type]);\n            break;\n        case BACKGROUND:\n            color = &(style->bg[state_type]);\n            break;\n        case TEXT_FOREGROUND:\n            color = &(style->text[state_type]);\n            break;\n        case TEXT_BACKGROUND:\n            color = &(style->base[state_type]);\n            break;\n        case LIGHT:\n            color = &(style->light[state_type]);\n            break;\n        case DARK:\n            color = &(style->dark[state_type]);\n            break;\n        case MID:\n            color = &(style->mid[state_type]);\n            break;\n        case FOCUS:\n        case BLACK:\n            color = &(style->black);\n            break;\n        case WHITE:\n            color = &(style->white);\n            break;\n    }\n\n    if (color)\n        result = recode_color(color->red)   << 16 |\n                 recode_color(color->green) << 8  |\n                 recode_color(color->blue);\n\n    return result;\n}\n\n/*************************************************/\nstatic jobject create_Boolean(JNIEnv *env, jboolean boolean_value);\nstatic jobject create_Integer(JNIEnv *env, jint int_value);\nstatic jobject create_Long(JNIEnv *env, jlong long_value);\nstatic jobject create_Float(JNIEnv *env, jfloat float_value);\nstatic jobject create_Double(JNIEnv *env, jdouble double_value);\nstatic jobject create_Character(JNIEnv *env, jchar char_value);\nstatic jobject create_Insets(JNIEnv *env, GtkBorder *border);\n\nstatic jobject gtk2_get_class_value(JNIEnv *env, WidgetType widget_type,\n                              const char* key)\n{\n    init_containers();\n\n    gtk2_widget = gtk2_get_widget(widget_type);\n\n    GValue value;\n    value.g_type = 0;\n\n    GParamSpec* param = (*fp_gtk_widget_class_find_style_property)(\n                                    ((GTypeInstance*)gtk2_widget)->g_class, key);\n    if( param )\n    {\n        (*fp_g_value_init)( &value, param->value_type );\n        (*fp_gtk_widget_style_get_property)(gtk2_widget, key, &value);\n\n        if( (*fp_g_type_is_a)( param->value_type, G_TYPE_BOOLEAN ))\n        {\n            gboolean val = (*fp_g_value_get_boolean)(&value);\n            return create_Boolean(env, (jboolean)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_CHAR ))\n        {\n            gchar val = (*fp_g_value_get_char)(&value);\n            return create_Character(env, (jchar)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_UCHAR ))\n        {\n            guchar val = (*fp_g_value_get_uchar)(&value);\n            return create_Character(env, (jchar)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_INT ))\n        {\n            gint val = (*fp_g_value_get_int)(&value);\n            return create_Integer(env, (jint)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_UINT ))\n        {\n            guint val = (*fp_g_value_get_uint)(&value);\n            return create_Integer(env, (jint)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_LONG ))\n        {\n            glong val = (*fp_g_value_get_long)(&value);\n            return create_Long(env, (jlong)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_ULONG ))\n        {\n            gulong val = (*fp_g_value_get_ulong)(&value);\n            return create_Long(env, (jlong)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_INT64 ))\n        {\n            gint64 val = (*fp_g_value_get_int64)(&value);\n            return create_Long(env, (jlong)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_UINT64 ))\n        {\n            guint64 val = (*fp_g_value_get_uint64)(&value);\n            return create_Long(env, (jlong)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_FLOAT ))\n        {\n            gfloat val = (*fp_g_value_get_float)(&value);\n            return create_Float(env, (jfloat)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_DOUBLE ))\n        {\n            gdouble val = (*fp_g_value_get_double)(&value);\n            return create_Double(env, (jdouble)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_ENUM ))\n        {\n            gint val = (*fp_g_value_get_enum)(&value);\n            return create_Integer(env, (jint)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_FLAGS ))\n        {\n            guint val = (*fp_g_value_get_flags)(&value);\n            return create_Integer(env, (jint)val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_STRING ))\n        {\n            const gchar* val = (*fp_g_value_get_string)(&value);\n\n            /* We suppose that all values come in C locale and\n             * utf-8 representation of a string is the same as\n             * the string itself. If this isn't so we should\n             * use g_convert.\n             */\n            return (*env)->NewStringUTF(env, val);\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, GTK_TYPE_BORDER ))\n        {\n            GtkBorder *border = (GtkBorder*)(*fp_g_value_get_boxed)(&value);\n            return border ? create_Insets(env, border) : NULL;\n        }\n\n        /*      TODO: Other types are not supported yet.*/\n/*        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_PARAM ))\n        {\n            GParamSpec* val = (*fp_g_value_get_param)(&value);\n            printf( \"Param: %p\\n\", val );\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_BOXED ))\n        {\n            gpointer* val = (*fp_g_value_get_boxed)(&value);\n            printf( \"Boxed: %p\\n\", val );\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_POINTER ))\n        {\n            gpointer* val = (*fp_g_value_get_pointer)(&value);\n            printf( \"Pointer: %p\\n\", val );\n        }\n        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_OBJECT ))\n        {\n            GObject* val = (GObject*)(*fp_g_value_get_object)(&value);\n            printf( \"Object: %p\\n\", val );\n        }*/\n    }\n\n    return NULL;\n}\n\nstatic void gtk2_set_range_value(WidgetType widget_type, jdouble value,\n                          jdouble min, jdouble max, jdouble visible)\n{\n    GtkAdjustment *adj;\n\n    gtk2_widget = gtk2_get_widget(widget_type);\n\n    adj = (*fp_gtk_range_get_adjustment)((GtkRange *)gtk2_widget);\n    adj->value = (gdouble)value;\n    adj->lower = (gdouble)min;\n    adj->upper = (gdouble)max;\n    adj->page_size = (gdouble)visible;\n}\n\n/*************************************************/\nstatic jobject create_Object(JNIEnv *env, jmethodID *cid,\n                             const char* class_name,\n                             const char* signature,\n                             jvalue* value)\n{\n    jclass  class;\n    jobject result;\n\n    class = (*env)->FindClass(env, class_name);\n    if( class == NULL )\n        return NULL; /* can't find/load the class, exception thrown */\n\n    if( *cid == NULL)\n    {\n        *cid = (*env)->GetMethodID(env, class, \"<init>\", signature);\n        if( *cid == NULL )\n        {\n            (*env)->DeleteLocalRef(env, class);\n            return NULL; /* can't find/get the method, exception thrown */\n        }\n    }\n\n    result = (*env)->NewObjectA(env, class, *cid, value);\n\n    (*env)->DeleteLocalRef(env, class);\n    return result;\n}\n\njobject create_Boolean(JNIEnv *env, jboolean boolean_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.z = boolean_value;\n\n    return create_Object(env, &cid, \"java/lang/Boolean\", \"(Z)V\", &value);\n}\n\njobject create_Integer(JNIEnv *env, jint int_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.i = int_value;\n\n    return create_Object(env, &cid, \"java/lang/Integer\", \"(I)V\", &value);\n}\n\njobject create_Long(JNIEnv *env, jlong long_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.j = long_value;\n\n    return create_Object(env, &cid, \"java/lang/Long\", \"(J)V\", &value);\n}\n\njobject create_Float(JNIEnv *env, jfloat float_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.f = float_value;\n\n    return create_Object(env, &cid, \"java/lang/Float\", \"(F)V\", &value);\n}\n\njobject create_Double(JNIEnv *env, jdouble double_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.d = double_value;\n\n    return create_Object(env, &cid, \"java/lang/Double\", \"(D)V\", &value);\n}\n\njobject create_Character(JNIEnv *env, jchar char_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.c = char_value;\n\n    return create_Object(env, &cid, \"java/lang/Character\", \"(C)V\", &value);\n}\n\n\njobject create_Insets(JNIEnv *env, GtkBorder *border)\n{\n    static jmethodID cid = NULL;\n    jvalue values[4];\n\n    values[0].i = border->top;\n    values[1].i = border->left;\n    values[2].i = border->bottom;\n    values[3].i = border->right;\n\n    return create_Object(env, &cid, \"java/awt/Insets\", \"(IIII)V\", values);\n}\n\n/*********************************************/\nstatic jstring gtk2_get_pango_font_name(JNIEnv *env, WidgetType widget_type)\n{\n    init_containers();\n\n    gtk2_widget = gtk2_get_widget(widget_type);\n    jstring  result = NULL;\n    GtkStyle* style = gtk2_widget->style;\n\n    if (style && style->font_desc)\n    {\n        gchar* val = (*fp_pango_font_description_to_string)(style->font_desc);\n        result = (*env)->NewStringUTF(env, val);\n        (*fp_g_free)( val );\n    }\n\n    return result;\n}\n\n/***********************************************/\nstatic jobject get_string_property(JNIEnv *env, GtkSettings* settings, const gchar* key)\n{\n    jobject result = NULL;\n    gchar*  strval = NULL;\n\n    (*fp_g_object_get)(settings, key, &strval, NULL);\n    result = (*env)->NewStringUTF(env, strval);\n    (*fp_g_free)(strval);\n\n    return result;\n}\n\nstatic jobject get_integer_property(JNIEnv *env, GtkSettings* settings, const gchar* key)\n{\n    gint intval = NULL;\n    (*fp_g_object_get)(settings, key, &intval, NULL);\n    return create_Integer(env, intval);\n}\n\nstatic jobject get_boolean_property(JNIEnv *env, GtkSettings* settings, const gchar* key)\n{\n    gint intval = NULL;\n    (*fp_g_object_get)(settings, key, &intval, NULL);\n    return create_Boolean(env, intval);\n}\n\nstatic jobject gtk2_get_setting(JNIEnv *env, Setting property)\n{\n    GtkSettings* settings = (*fp_gtk_settings_get_default)();\n\n    switch (property)\n    {\n        case GTK_FONT_NAME:\n            return get_string_property(env, settings, \"gtk-font-name\");\n        case GTK_ICON_SIZES:\n            return get_string_property(env, settings, \"gtk-icon-sizes\");\n        case GTK_CURSOR_BLINK:\n            return get_boolean_property(env, settings, \"gtk-cursor-blink\");\n        case GTK_CURSOR_BLINK_TIME:\n            return get_integer_property(env, settings, \"gtk-cursor-blink-time\");\n        case GTK_BUTTON_ORDER:\n\t    return get_boolean_property(env, settings, \"gtk-alternative-button-order\");\n    }\n\n    return NULL;\n}\n\nstatic gboolean gtk2_get_drawable_data(JNIEnv *env, jintArray pixelArray, jint x,\n     jint y, jint width, jint height, jint jwidth, int dx, int dy, jint scale) {\n    GdkPixbuf *pixbuf;\n    jint *ary;\n\n    GdkWindow *root = (*fp_gdk_get_default_root_window)();\n\n    pixbuf = (*fp_gdk_pixbuf_get_from_drawable)(NULL, root, NULL, x, y,\n                                                    0, 0, width, height);\n    if (pixbuf && scale != 1) {\n        GdkPixbuf *scaledPixbuf;\n        x /= scale;\n        y /= scale;\n        width /= scale;\n        height /= scale;\n        dx /= scale;\n        dy /= scale;\n        scaledPixbuf = (*fp_gdk_pixbuf_scale_simple)(pixbuf, width, height,\n                                                     GDK_INTERP_BILINEAR);\n        (*fp_g_object_unref)(pixbuf);\n        pixbuf = scaledPixbuf;\n    }\n\n    if (pixbuf) {\n        int nchan = (*fp_gdk_pixbuf_get_n_channels)(pixbuf);\n        int stride = (*fp_gdk_pixbuf_get_rowstride)(pixbuf);\n\n        if ((*fp_gdk_pixbuf_get_width)(pixbuf) == width\n                && (*fp_gdk_pixbuf_get_height)(pixbuf) == height\n                && (*fp_gdk_pixbuf_get_bits_per_sample)(pixbuf) == 8\n                && (*fp_gdk_pixbuf_get_colorspace)(pixbuf) == GDK_COLORSPACE_RGB\n                && nchan >= 3\n                ) {\n            guchar *p, *pix = (*fp_gdk_pixbuf_get_pixels)(pixbuf);\n\n            ary = (*env)->GetPrimitiveArrayCritical(env, pixelArray, NULL);\n            if (ary) {\n                jint _x, _y;\n                int index;\n                for (_y = 0; _y < height; _y++) {\n                    for (_x = 0; _x < width; _x++) {\n                        p = pix + _y * stride + _x * nchan;\n\n                        index = (_y + dy) * jwidth + (_x + dx);\n                        ary[index] = 0xff000000\n                                        | (p[0] << 16)\n                                        | (p[1] << 8)\n                                        | (p[2]);\n\n                    }\n                }\n                (*env)->ReleasePrimitiveArrayCritical(env, pixelArray, ary, 0);\n            }\n        }\n        (*fp_g_object_unref)(pixbuf);\n    }\n    return JNI_FALSE;\n}\n\nstatic GdkWindow* gtk2_get_window(void *widget) {\n    return ((GtkWidget*)widget)->window;\n}\n\nvoid gtk2_init(GtkApi* gtk) {\n    gtk->version = GTK_2;\n\n    gtk->show_uri_load = &gtk2_show_uri_load;\n    gtk->unload = &gtk2_unload;\n    gtk->flush_event_loop = &flush_gtk_event_loop;\n    gtk->gtk_check_version = fp_gtk_check_version;\n    gtk->get_setting = &gtk2_get_setting;\n\n    gtk->paint_arrow = &gtk2_paint_arrow;\n    gtk->paint_box = &gtk2_paint_box;\n    gtk->paint_box_gap = &gtk2_paint_box_gap;\n    gtk->paint_expander = &gtk2_paint_expander;\n    gtk->paint_extension = &gtk2_paint_extension;\n    gtk->paint_flat_box = &gtk2_paint_flat_box;\n    gtk->paint_focus = &gtk2_paint_focus;\n    gtk->paint_handle = &gtk2_paint_handle;\n    gtk->paint_hline = &gtk2_paint_hline;\n    gtk->paint_vline = &gtk2_paint_vline;\n    gtk->paint_option = &gtk2_paint_option;\n    gtk->paint_shadow = &gtk2_paint_shadow;\n    gtk->paint_slider = &gtk2_paint_slider;\n    gtk->paint_background = &gtk_paint_background;\n    gtk->paint_check = &gtk2_paint_check;\n    gtk->set_range_value = &gtk2_set_range_value;\n\n    gtk->init_painting = &gtk2_init_painting;\n    gtk->copy_image = &gtk2_copy_image;\n\n    gtk->get_xthickness = &gtk2_get_xthickness;\n    gtk->get_ythickness = &gtk2_get_ythickness;\n    gtk->get_color_for_state = &gtk2_get_color_for_state;\n    gtk->get_class_value = &gtk2_get_class_value;\n\n    gtk->get_pango_font_name = &gtk2_get_pango_font_name;\n    gtk->get_icon_data = &gtk2_get_icon_data;\n    gtk->get_file_icon_data = &gtk2_get_file_icon_data;\n    gtk->gdk_threads_enter = fp_gdk_threads_enter;\n    gtk->gdk_threads_leave = fp_gdk_threads_leave;\n    gtk->gtk_show_uri = fp_gtk_show_uri;\n    gtk->get_drawable_data = &gtk2_get_drawable_data;\n    gtk->g_free = fp_g_free;\n\n    gtk->gtk_file_chooser_get_filename = fp_gtk_file_chooser_get_filename;\n    gtk->gtk_widget_hide = fp_gtk_widget_hide;\n    gtk->gtk_main_quit = fp_gtk_main_quit;\n    gtk->gtk_file_chooser_dialog_new = fp_gtk_file_chooser_dialog_new;\n    gtk->gtk_file_chooser_set_current_folder =\n                          fp_gtk_file_chooser_set_current_folder;\n    gtk->gtk_file_chooser_set_filename = fp_gtk_file_chooser_set_filename;\n    gtk->gtk_file_chooser_set_current_name =\n                          fp_gtk_file_chooser_set_current_name;\n    gtk->gtk_file_filter_add_custom = fp_gtk_file_filter_add_custom;\n    gtk->gtk_file_chooser_set_filter = fp_gtk_file_chooser_set_filter;\n    gtk->gtk_file_chooser_get_type = fp_gtk_file_chooser_get_type;\n    gtk->gtk_file_filter_new = fp_gtk_file_filter_new;\n    gtk->gtk_file_chooser_set_do_overwrite_confirmation =\n                          fp_gtk_file_chooser_set_do_overwrite_confirmation;\n    gtk->gtk_file_chooser_set_select_multiple =\n                          fp_gtk_file_chooser_set_select_multiple;\n    gtk->gtk_file_chooser_get_current_folder =\n                          fp_gtk_file_chooser_get_current_folder;\n    gtk->gtk_file_chooser_get_filenames = fp_gtk_file_chooser_get_filenames;\n    gtk->gtk_g_slist_length = fp_gtk_g_slist_length;\n    gtk->g_signal_connect_data = fp_g_signal_connect_data;\n    gtk->gtk_widget_show = fp_gtk_widget_show;\n    gtk->gtk_main = fp_gtk_main;\n    gtk->gtk_main_level = fp_gtk_main_level;\n    gtk->g_path_get_dirname = fp_g_path_get_dirname;\n    gtk->gtk_widget_destroy = fp_gtk_widget_destroy;\n    gtk->gtk_window_present = fp_gtk_window_present;\n    gtk->gtk_window_move = fp_gtk_window_move;\n    gtk->gtk_window_resize = fp_gtk_window_resize;\n    gtk->get_window = &gtk2_get_window;\n\n    gtk->g_object_unref = fp_g_object_unref;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/awt/awt_Mlib.c": "/*\n * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <sys/time.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include \"jni.h\"\n#include <jni_util.h>\n#include \"jvm_md.h\"\n#include \"awt_Mlib.h\"\n#include \"java_awt_image_BufferedImage.h\"\n\nstatic void start_timer(int numsec);\nstatic void stop_timer(int numsec, int ntimes);\n\n/*\n * This is called by awt_ImagingLib.initLib() to figure out if we\n * can use the VIS version of medialib\n */\nmlib_status awt_getImagingLib(JNIEnv *env, mlibFnS_t *sMlibFns,\n                              mlibSysFnS_t *sMlibSysFns) {\n    int status;\n    jstring jstr = NULL;\n    mlibFnS_t *mptr;\n    void *(*vPtr)();\n    int (*intPtr)();\n    mlib_status (*fPtr)();\n    int i;\n    void *handle = NULL;\n    mlibSysFnS_t tempSysFns;\n    static int s_timeIt = 0;\n    static int s_verbose = 1;\n    mlib_status ret = MLIB_SUCCESS;\n    struct utsname name;\n\n    /*\n     * Find out the machine name. If it is an SUN ultra, we\n     * can use the vis library\n     */\n    if ((uname(&name) >= 0) && (getenv(\"NO_VIS\") == NULL) &&\n        (strncmp(name.machine, \"sun4u\" , 5) == 0) ||\n        ((strncmp(name.machine, \"sun4v\" , 5) == 0) &&\n         (getenv(\"USE_VIS_ON_SUN4V\") != NULL)))\n    {\n        handle = dlopen(JNI_LIB_NAME(\"mlib_image_v\"), RTLD_LAZY);\n    }\n\n    if (handle == NULL) {\n        handle = dlopen(JNI_LIB_NAME(\"mlib_image\"), RTLD_LAZY);\n    }\n\n    if (handle == NULL) {\n        if (s_timeIt || s_verbose) {\n            printf (\"error in dlopen: %s\", dlerror());\n        }\n        return MLIB_FAILURE;\n    }\n\n    /* So, if we are here, then either vis or generic version of\n     * medialib library was sucessfuly loaded.\n     * Let's try to initialize handlers...\n     */\n    if ((tempSysFns.createFP = (MlibCreateFP_t)dlsym(handle,\n                                       \"j2d_mlib_ImageCreate\")) == NULL) {\n        if (s_timeIt) {\n            printf (\"error in dlsym: %s\", dlerror());\n        }\n        ret = MLIB_FAILURE;\n    }\n\n    if (ret == MLIB_SUCCESS) {\n        if ((tempSysFns.createStructFP = (MlibCreateStructFP_t)dlsym(handle,\n                                          \"j2d_mlib_ImageCreateStruct\")) == NULL) {\n            if (s_timeIt) {\n                printf (\"error in dlsym: %s\", dlerror());\n            }\n            ret = MLIB_FAILURE;\n        }\n    }\n\n    if (ret == MLIB_SUCCESS) {\n        if ((tempSysFns.deleteImageFP = (MlibDeleteFP_t)dlsym(handle,\n                                                 \"j2d_mlib_ImageDelete\")) == NULL) {\n            if (s_timeIt) {\n                printf (\"error in dlsym: %s\", dlerror());\n            }\n            ret = MLIB_FAILURE;\n        }\n    }\n\n    /* Set the system functions */\n    if (ret == MLIB_SUCCESS) {\n        *sMlibSysFns = tempSysFns;\n    }\n\n    /* Loop through all of the fns and load them from the next library */\n    mptr = sMlibFns;\n    i = 0;\n    while ((ret == MLIB_SUCCESS) && (mptr[i].fname != NULL)) {\n        fPtr = (mlib_status (*)())dlsym(handle, mptr[i].fname);\n        if (fPtr != NULL) {\n            mptr[i].fptr = fPtr;\n        } else {\n            ret = MLIB_FAILURE;\n        }\n        i++;\n    }\n    if (ret != MLIB_SUCCESS) {\n        dlclose(handle);\n    }\n    return ret;\n}\n\nmlib_start_timer awt_setMlibStartTimer() {\n    return start_timer;\n}\n\nmlib_stop_timer awt_setMlibStopTimer() {\n    return stop_timer;\n}\n\n/***************************************************************************\n *                          Static Functions                               *\n ***************************************************************************/\n\nstatic void start_timer(int numsec)\n{\n    struct itimerval interval;\n\n    interval.it_interval.tv_sec = numsec;\n    interval.it_interval.tv_usec = 0;\n    interval.it_value.tv_sec = numsec;\n    interval.it_value.tv_usec = 0;\n    setitimer(ITIMER_REAL, &interval, 0);\n}\n\n\nstatic void stop_timer(int numsec, int ntimes)\n{\n    struct itimerval interval;\n    double sec;\n\n    getitimer(ITIMER_REAL, &interval);\n    sec = (((double) (numsec - 1)) - (double) interval.it_value.tv_sec) +\n            (1000000.0 - interval.it_value.tv_usec)/1000000.0;\n    sec = sec/((double) ntimes);\n    printf(\"%f msec per update\\n\", sec * 1000.0);\n    interval.it_interval.tv_sec = 0;\n    interval.it_interval.tv_usec = 0;\n    interval.it_value.tv_sec = 0;\n    interval.it_value.tv_usec = 0;\n    setitimer(ITIMER_PROF, &interval, 0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/awt/gtk3_interface.c": "/*\n * Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n#include <dlfcn.h>\n#include <setjmp.h>\n#include <X11/Xlib.h>\n#include <limits.h>\n#include <string.h>\n#include \"gtk3_interface.h\"\n#include \"java_awt_Transparency.h\"\n#include \"sizecalc.h\"\n#include <jni_util.h>\n#include <stdio.h>\n#include \"awt.h\"\n\nstatic void *gtk3_libhandle = NULL;\n\nstatic jmp_buf j;\n\n/* Widgets */\nstatic GtkWidget *gtk3_widget = NULL;\nstatic GtkWidget *gtk3_window = NULL;\nstatic GtkFixed  *gtk3_fixed  = NULL;\nstatic GtkStyleProvider *gtk3_css = NULL;\n\n/* Paint system */\nstatic cairo_surface_t *surface = NULL;\nstatic cairo_t *cr = NULL;\n\nstatic const char ENV_PREFIX[] = \"GTK_MODULES=\";\n\nstatic GtkWidget *gtk3_widgets[_GTK_WIDGET_TYPE_SIZE];\n\nstatic void throw_exception(JNIEnv *env, const char* name, const char* message)\n{\n    jclass class = (*env)->FindClass(env, name);\n\n    if (class != NULL)\n        (*env)->ThrowNew(env, class, message);\n\n    (*env)->DeleteLocalRef(env, class);\n}\n\nstatic void gtk3_add_state(GtkWidget *widget, GtkStateType state) {\n    GtkStateType old_state = fp_gtk_widget_get_state(widget);\n    fp_gtk_widget_set_state(widget, old_state | state);\n}\n\nstatic void gtk3_remove_state(GtkWidget *widget, GtkStateType state) {\n    GtkStateType old_state = fp_gtk_widget_get_state(widget);\n    fp_gtk_widget_set_state(widget, old_state & ~state);\n}\n\n/* This is a workaround for the bug:\n * http://sourceware.org/bugzilla/show_bug.cgi?id=1814\n * (dlsym/dlopen clears dlerror state)\n * This bug is specific to Linux, but there is no harm in\n * applying this workaround on Solaris as well.\n */\nstatic void* dl_symbol(const char* name)\n{\n    void* result = dlsym(gtk3_libhandle, name);\n    if (!result)\n        longjmp(j, NO_SYMBOL_EXCEPTION);\n\n    return result;\n}\n\ngboolean gtk3_check(const char* lib_name, gboolean load)\n{\n    if (gtk3_libhandle != NULL) {\n        /* We've already successfully opened the GTK libs, so return true. */\n        return TRUE;\n    } else {\n#ifdef RTLD_NOLOAD\n        void *lib = dlopen(lib_name, RTLD_LAZY | RTLD_NOLOAD);\n        if (!load || lib != NULL) {\n            return lib != NULL;\n        }\n#else\n#ifdef _AIX\n        /* On AIX we could implement this with the help of loadquery(L_GETINFO, ..)  */\n        /* (see reload_table() in hotspot/src/os/aix/vm/loadlib_aix.cpp) but it is   */\n        /* probably not worth it because most AIX servers don't have GTK libs anyway */\n#endif\n#endif\n        return dlopen(lib_name, RTLD_LAZY | RTLD_LOCAL) != NULL;\n    }\n}\n\n#define ADD_SUPPORTED_ACTION(actionStr)                                        \\\ndo {                                                                           \\\n    jfieldID fld_action = (*env)->GetStaticFieldID(env, cls_action, actionStr, \\\n                                                 \"Ljava/awt/Desktop$Action;\"); \\\n    if (!(*env)->ExceptionCheck(env)) {                                        \\\n        jobject action = (*env)->GetStaticObjectField(env, cls_action,         \\\n                                                                  fld_action); \\\n        (*env)->CallBooleanMethod(env, supportedActions, mid_arrayListAdd,     \\\n                                                                      action); \\\n    } else {                                                                   \\\n        (*env)->ExceptionClear(env);                                           \\\n    }                                                                          \\\n} while(0);\n\n\nstatic void update_supported_actions(JNIEnv *env) {\n    GVfs * (*fp_g_vfs_get_default) (void);\n    const gchar * const * (*fp_g_vfs_get_supported_uri_schemes) (GVfs * vfs);\n    const gchar * const * schemes = NULL;\n\n    jclass cls_action = (*env)->FindClass(env, \"java/awt/Desktop$Action\");\n    CHECK_NULL(cls_action);\n    jclass cls_xDesktopPeer = (*env)->\n                                     FindClass(env, \"sun/awt/X11/XDesktopPeer\");\n    CHECK_NULL(cls_xDesktopPeer);\n    jfieldID fld_supportedActions = (*env)->GetStaticFieldID(env,\n                      cls_xDesktopPeer, \"supportedActions\", \"Ljava/util/List;\");\n    CHECK_NULL(fld_supportedActions);\n    jobject supportedActions = (*env)->GetStaticObjectField(env,\n                                        cls_xDesktopPeer, fld_supportedActions);\n\n    jclass cls_arrayList = (*env)->FindClass(env, \"java/util/ArrayList\");\n    CHECK_NULL(cls_arrayList);\n    jmethodID mid_arrayListAdd = (*env)->GetMethodID(env, cls_arrayList, \"add\",\n                                                       \"(Ljava/lang/Object;)Z\");\n    CHECK_NULL(mid_arrayListAdd);\n    jmethodID mid_arrayListClear = (*env)->GetMethodID(env, cls_arrayList,\n                                                                \"clear\", \"()V\");\n    CHECK_NULL(mid_arrayListClear);\n\n    (*env)->CallVoidMethod(env, supportedActions, mid_arrayListClear);\n\n    ADD_SUPPORTED_ACTION(\"OPEN\");\n\n    /**\n     * gtk_show_uri() documentation says:\n     *\n     * > you need to install gvfs to get support for uri schemes such as http://\n     * > or ftp://, as only local files are handled by GIO itself.\n     *\n     * So OPEN action was safely added here.\n     * However, it looks like Solaris 11 have gvfs support only for 32-bit\n     * applications only by default.\n     */\n\n    fp_g_vfs_get_default = dl_symbol(\"g_vfs_get_default\");\n    fp_g_vfs_get_supported_uri_schemes =\n                           dl_symbol(\"g_vfs_get_supported_uri_schemes\");\n    dlerror();\n\n    if (fp_g_vfs_get_default && fp_g_vfs_get_supported_uri_schemes) {\n        GVfs * vfs = fp_g_vfs_get_default();\n        schemes = vfs ? fp_g_vfs_get_supported_uri_schemes(vfs) : NULL;\n        if (schemes) {\n            int i = 0;\n            while (schemes[i]) {\n                if (strcmp(schemes[i], \"http\") == 0) {\n                    ADD_SUPPORTED_ACTION(\"BROWSE\");\n                    ADD_SUPPORTED_ACTION(\"MAIL\");\n                    break;\n                }\n                i++;\n            }\n        }\n    } else {\n#ifdef DEBUG\n        fprintf(stderr, \"Cannot load g_vfs_get_supported_uri_schemes\\n\");\n#endif /* DEBUG */\n    }\n\n}\n/**\n * Functions for awt_Desktop.c\n */\nstatic gboolean gtk3_show_uri_load(JNIEnv *env) {\n    gboolean success = FALSE;\n    dlerror();\n    fp_gtk_show_uri = dl_symbol(\"gtk_show_uri\");\n    const char *dlsym_error = dlerror();\n    if (dlsym_error) {\n#ifdef DEBUG\n        fprintf (stderr, \"Cannot load symbol: %s \\n\", dlsym_error);\n#endif /* DEBUG */\n    } else if (fp_gtk_show_uri == NULL) {\n#ifdef DEBUG\n        fprintf(stderr, \"dlsym(gtk_show_uri) returned NULL\\n\");\n#endif /* DEBUG */\n    } else {\n        gtk->gtk_show_uri = fp_gtk_show_uri;\n        update_supported_actions(env);\n        success = TRUE;\n    }\n    return success;\n}\n\n/**\n * Functions for sun_awt_X11_GtkFileDialogPeer.c\n */\nstatic void gtk3_file_chooser_load()\n{\n    fp_gtk_file_chooser_get_filename = dl_symbol(\n            \"gtk_file_chooser_get_filename\");\n    fp_gtk_file_chooser_dialog_new = dl_symbol(\"gtk_file_chooser_dialog_new\");\n    fp_gtk_file_chooser_set_current_folder = dl_symbol(\n            \"gtk_file_chooser_set_current_folder\");\n    fp_gtk_file_chooser_set_filename = dl_symbol(\n            \"gtk_file_chooser_set_filename\");\n    fp_gtk_file_chooser_set_current_name = dl_symbol(\n            \"gtk_file_chooser_set_current_name\");\n    fp_gtk_file_filter_add_custom = dl_symbol(\"gtk_file_filter_add_custom\");\n    fp_gtk_file_chooser_set_filter = dl_symbol(\"gtk_file_chooser_set_filter\");\n    fp_gtk_file_chooser_get_type = dl_symbol(\"gtk_file_chooser_get_type\");\n    fp_gtk_file_filter_new = dl_symbol(\"gtk_file_filter_new\");\n    fp_gtk_file_chooser_set_do_overwrite_confirmation = dl_symbol(\n                \"gtk_file_chooser_set_do_overwrite_confirmation\");\n    fp_gtk_file_chooser_set_select_multiple = dl_symbol(\n            \"gtk_file_chooser_set_select_multiple\");\n    fp_gtk_file_chooser_get_current_folder = dl_symbol(\n            \"gtk_file_chooser_get_current_folder\");\n    fp_gtk_file_chooser_get_filenames = dl_symbol(\n            \"gtk_file_chooser_get_filenames\");\n    fp_gtk_g_slist_length = dl_symbol(\"g_slist_length\");\n    fp_gdk_x11_drawable_get_xid = dl_symbol(\"gdk_x11_window_get_xid\");\n}\n\nstatic void empty() {}\n\nstatic gboolean gtk3_version_3_10 = TRUE;\nstatic gboolean gtk3_version_3_14 = FALSE;\n\nGtkApi* gtk3_load(JNIEnv *env, const char* lib_name)\n{\n    gboolean result;\n    int i;\n    int (*handler)();\n    int (*io_handler)();\n    char *gtk_modules_env;\n    gtk3_libhandle = dlopen(lib_name, RTLD_LAZY | RTLD_LOCAL);\n    if (gtk3_libhandle == NULL) {\n        return FALSE;\n    }\n\n    if (setjmp(j) == 0)\n    {\n        fp_gtk_check_version = dl_symbol(\"gtk_check_version\");\n\n        /* GLib */\n        fp_glib_check_version = dlsym(gtk3_libhandle, \"glib_check_version\");\n        if (!fp_glib_check_version) {\n            dlerror();\n        }\n        fp_g_free = dl_symbol(\"g_free\");\n        fp_g_object_unref = dl_symbol(\"g_object_unref\");\n\n        fp_g_main_context_iteration =\n            dl_symbol(\"g_main_context_iteration\");\n\n        fp_g_value_init = dl_symbol(\"g_value_init\");\n        fp_g_type_is_a = dl_symbol(\"g_type_is_a\");\n        fp_g_value_get_boolean = dl_symbol(\"g_value_get_boolean\");\n        fp_g_value_get_char = dl_symbol(\"g_value_get_char\");\n        fp_g_value_get_uchar = dl_symbol(\"g_value_get_uchar\");\n        fp_g_value_get_int = dl_symbol(\"g_value_get_int\");\n        fp_g_value_get_uint = dl_symbol(\"g_value_get_uint\");\n        fp_g_value_get_long = dl_symbol(\"g_value_get_long\");\n        fp_g_value_get_ulong = dl_symbol(\"g_value_get_ulong\");\n        fp_g_value_get_int64 = dl_symbol(\"g_value_get_int64\");\n        fp_g_value_get_uint64 = dl_symbol(\"g_value_get_uint64\");\n        fp_g_value_get_float = dl_symbol(\"g_value_get_float\");\n        fp_g_value_get_double = dl_symbol(\"g_value_get_double\");\n        fp_g_value_get_string = dl_symbol(\"g_value_get_string\");\n        fp_g_value_get_enum = dl_symbol(\"g_value_get_enum\");\n        fp_g_value_get_flags = dl_symbol(\"g_value_get_flags\");\n        fp_g_value_get_param = dl_symbol(\"g_value_get_param\");\n        fp_g_value_get_boxed = dl_symbol(\"g_value_get_boxed\");\n        fp_g_value_get_pointer = dl_symbol(\"g_value_get_pointer\");\n\n        fp_g_object_get = dl_symbol(\"g_object_get\");\n        fp_g_object_set = dl_symbol(\"g_object_set\");\n\n        fp_g_str_has_prefix = dl_symbol(\"g_str_has_prefix\");\n        fp_g_strsplit = dl_symbol(\"g_strsplit\");\n        fp_g_strfreev = dl_symbol(\"g_strfreev\");\n\n        /* GDK */\n        fp_gdk_get_default_root_window =\n            dl_symbol(\"gdk_get_default_root_window\");\n\n        /* Pixbuf */\n        fp_gdk_pixbuf_new = dl_symbol(\"gdk_pixbuf_new\");\n        fp_gdk_pixbuf_new_from_file =\n                dl_symbol(\"gdk_pixbuf_new_from_file\");\n        fp_gdk_pixbuf_get_from_drawable =\n                    dl_symbol(\"gdk_pixbuf_get_from_window\");\n        fp_gdk_pixbuf_get_width = dl_symbol(\"gdk_pixbuf_get_width\");\n        fp_gdk_pixbuf_get_height = dl_symbol(\"gdk_pixbuf_get_height\");\n        fp_gdk_pixbuf_get_pixels = dl_symbol(\"gdk_pixbuf_get_pixels\");\n        fp_gdk_pixbuf_get_rowstride =\n                dl_symbol(\"gdk_pixbuf_get_rowstride\");\n        fp_gdk_pixbuf_get_has_alpha =\n                dl_symbol(\"gdk_pixbuf_get_has_alpha\");\n        fp_gdk_pixbuf_get_bits_per_sample =\n                dl_symbol(\"gdk_pixbuf_get_bits_per_sample\");\n        fp_gdk_pixbuf_get_n_channels =\n                dl_symbol(\"gdk_pixbuf_get_n_channels\");\n        fp_gdk_pixbuf_get_colorspace =\n                dl_symbol(\"gdk_pixbuf_get_colorspace\");\n\n        fp_cairo_image_surface_create = dl_symbol(\"cairo_image_surface_create\");\n        fp_cairo_surface_destroy = dl_symbol(\"cairo_surface_destroy\");\n        fp_cairo_create = dl_symbol(\"cairo_create\");\n        fp_cairo_destroy = dl_symbol(\"cairo_destroy\");\n        fp_cairo_fill = dl_symbol(\"cairo_fill\");\n        fp_cairo_rectangle = dl_symbol(\"cairo_rectangle\");\n        fp_cairo_set_source_rgb = dl_symbol(\"cairo_set_source_rgb\");\n        fp_cairo_set_source_rgba = dl_symbol(\"cairo_set_source_rgba\");\n        fp_cairo_surface_flush = dl_symbol(\"cairo_surface_flush\");\n        fp_cairo_paint = dl_symbol(\"cairo_paint\");\n        fp_cairo_clip = dl_symbol(\"cairo_clip\");\n        fp_cairo_image_surface_get_data =\n                       dl_symbol(\"cairo_image_surface_get_data\");\n        fp_cairo_image_surface_get_stride =\n                       dl_symbol(\"cairo_image_surface_get_stride\");\n\n        fp_gdk_pixbuf_get_from_surface =\n                       dl_symbol(\"gdk_pixbuf_get_from_surface\");\n\n        fp_gtk_widget_get_state = dl_symbol(\"gtk_widget_get_state\");\n        fp_gtk_widget_set_state = dl_symbol(\"gtk_widget_set_state\");\n\n        fp_gtk_widget_is_focus = dl_symbol(\"gtk_widget_is_focus\");\n        fp_gtk_widget_set_allocation = dl_symbol(\"gtk_widget_set_allocation\");\n        fp_gtk_widget_get_parent = dl_symbol(\"gtk_widget_get_parent\");\n        fp_gtk_widget_get_window = dl_symbol(\"gtk_widget_get_window\");\n\n        fp_gtk_widget_get_style_context =\n                       dl_symbol(\"gtk_widget_get_style_context\");\n        fp_gtk_style_context_get_color =\n                       dl_symbol(\"gtk_style_context_get_color\");\n        fp_gtk_style_context_get_background_color =\n                       dl_symbol(\"gtk_style_context_get_background_color\");\n        fp_gtk_widget_get_state_flags = dl_symbol(\"gtk_widget_get_state_flags\");\n        fp_gtk_style_context_set_state =\n                       dl_symbol(\"gtk_style_context_set_state\");\n        fp_gtk_style_context_add_class =\n                       dl_symbol(\"gtk_style_context_add_class\");\n        fp_gtk_style_context_save = dl_symbol(\"gtk_style_context_save\");\n        fp_gtk_style_context_restore = dl_symbol(\"gtk_style_context_restore\");\n        fp_gtk_render_check = dl_symbol(\"gtk_render_check\");\n        fp_gtk_render_option = dl_symbol(\"gtk_render_option\");\n        fp_gtk_render_extension = dl_symbol(\"gtk_render_extension\");\n        fp_gtk_render_expander = dl_symbol(\"gtk_render_expander\");\n        fp_gtk_render_frame_gap = dl_symbol(\"gtk_render_frame_gap\");\n        fp_gtk_render_line = dl_symbol(\"gtk_render_line\");\n        fp_gtk_widget_render_icon_pixbuf =\n                      dl_symbol(\"gtk_widget_render_icon_pixbuf\");\n        if (fp_gtk_check_version(3, 10, 0)) {\n            gtk3_version_3_10 = FALSE;\n        } else {\n            fp_gdk_window_create_similar_image_surface =\n                       dl_symbol(\"gdk_window_create_similar_image_surface\");\n        }\n        gtk3_version_3_14 = !fp_gtk_check_version(3, 14, 0);\n\n        fp_gdk_window_create_similar_surface =\n                      dl_symbol(\"gdk_window_create_similar_surface\");\n        fp_gtk_settings_get_for_screen =\n                      dl_symbol(\"gtk_settings_get_for_screen\");\n        fp_gtk_widget_get_screen = dl_symbol(\"gtk_widget_get_screen\");\n        fp_gtk_css_provider_get_named = dl_symbol(\"gtk_css_provider_get_named\");\n        fp_gtk_style_context_add_provider =\n                      dl_symbol(\"gtk_style_context_add_provider\");\n        fp_gtk_render_frame = dl_symbol(\"gtk_render_frame\");\n        fp_gtk_render_focus = dl_symbol(\"gtk_render_focus\");\n        fp_gtk_render_handle = dl_symbol(\"gtk_render_handle\");\n        fp_gtk_render_arrow = dl_symbol(\"gtk_render_arrow\");\n\n        fp_gtk_style_context_get_property =\n                      dl_symbol(\"gtk_style_context_get_property\");\n        fp_gtk_scrolled_window_set_shadow_type =\n                      dl_symbol(\"gtk_scrolled_window_set_shadow_type\");\n        fp_gtk_render_slider = dl_symbol(\"gtk_render_slider\");\n        fp_gtk_style_context_get_padding =\n                      dl_symbol(\"gtk_style_context_get_padding\");\n        fp_gtk_range_set_inverted = dl_symbol(\"gtk_range_set_inverted\");\n        fp_gtk_style_context_get_font = dl_symbol(\"gtk_style_context_get_font\");\n        fp_gtk_widget_get_allocated_width =\n                      dl_symbol(\"gtk_widget_get_allocated_width\");\n        fp_gtk_widget_get_allocated_height =\n                      dl_symbol(\"gtk_widget_get_allocated_height\");\n        fp_gtk_icon_theme_get_default = dl_symbol(\"gtk_icon_theme_get_default\");\n        fp_gtk_icon_theme_load_icon = dl_symbol(\"gtk_icon_theme_load_icon\");\n\n        fp_gtk_adjustment_set_lower = dl_symbol(\"gtk_adjustment_set_lower\");\n        fp_gtk_adjustment_set_page_increment =\n                      dl_symbol(\"gtk_adjustment_set_page_increment\");\n        fp_gtk_adjustment_set_page_size =\n                      dl_symbol(\"gtk_adjustment_set_page_size\");\n        fp_gtk_adjustment_set_step_increment =\n                      dl_symbol(\"gtk_adjustment_set_step_increment\");\n        fp_gtk_adjustment_set_upper = dl_symbol(\"gtk_adjustment_set_upper\");\n        fp_gtk_adjustment_set_value = dl_symbol(\"gtk_adjustment_set_value\");\n\n        fp_gtk_render_activity = dl_symbol(\"gtk_render_activity\");\n        fp_gtk_render_background = dl_symbol(\"gtk_render_background\");\n        fp_gtk_style_context_has_class =\n                      dl_symbol(\"gtk_style_context_has_class\");\n\n        fp_gtk_style_context_set_junction_sides =\n                      dl_symbol(\"gtk_style_context_set_junction_sides\");\n        fp_gtk_style_context_add_region =\n                      dl_symbol(\"gtk_style_context_add_region\");\n\n        fp_gtk_init_check = dl_symbol(\"gtk_init_check\");\n\n        /* GTK widgets */\n        fp_gtk_arrow_new = dl_symbol(\"gtk_arrow_new\");\n        fp_gtk_button_new = dl_symbol(\"gtk_button_new\");\n        fp_gtk_spin_button_new = dl_symbol(\"gtk_spin_button_new\");\n        fp_gtk_check_button_new = dl_symbol(\"gtk_check_button_new\");\n        fp_gtk_check_menu_item_new =\n                dl_symbol(\"gtk_check_menu_item_new\");\n        fp_gtk_color_selection_dialog_new =\n                dl_symbol(\"gtk_color_selection_dialog_new\");\n        fp_gtk_entry_new = dl_symbol(\"gtk_entry_new\");\n        fp_gtk_fixed_new = dl_symbol(\"gtk_fixed_new\");\n        fp_gtk_handle_box_new = dl_symbol(\"gtk_handle_box_new\");\n        fp_gtk_image_new = dl_symbol(\"gtk_image_new\");\n        fp_gtk_hpaned_new = dl_symbol(\"gtk_hpaned_new\");\n        fp_gtk_vpaned_new = dl_symbol(\"gtk_vpaned_new\");\n        fp_gtk_scale_new = dl_symbol(\"gtk_scale_new\");\n        fp_gtk_hscrollbar_new = dl_symbol(\"gtk_hscrollbar_new\");\n        fp_gtk_vscrollbar_new = dl_symbol(\"gtk_vscrollbar_new\");\n        fp_gtk_hseparator_new = dl_symbol(\"gtk_hseparator_new\");\n        fp_gtk_vseparator_new = dl_symbol(\"gtk_vseparator_new\");\n        fp_gtk_label_new = dl_symbol(\"gtk_label_new\");\n        fp_gtk_menu_new = dl_symbol(\"gtk_menu_new\");\n        fp_gtk_menu_bar_new = dl_symbol(\"gtk_menu_bar_new\");\n        fp_gtk_menu_item_new = dl_symbol(\"gtk_menu_item_new\");\n        fp_gtk_menu_item_set_submenu =\n                dl_symbol(\"gtk_menu_item_set_submenu\");\n        fp_gtk_notebook_new = dl_symbol(\"gtk_notebook_new\");\n        fp_gtk_progress_bar_new =\n            dl_symbol(\"gtk_progress_bar_new\");\n        fp_gtk_progress_bar_set_orientation =\n            dl_symbol(\"gtk_orientable_set_orientation\");\n        fp_gtk_radio_button_new =\n            dl_symbol(\"gtk_radio_button_new\");\n        fp_gtk_radio_menu_item_new =\n            dl_symbol(\"gtk_radio_menu_item_new\");\n        fp_gtk_scrolled_window_new =\n            dl_symbol(\"gtk_scrolled_window_new\");\n        fp_gtk_separator_menu_item_new =\n            dl_symbol(\"gtk_separator_menu_item_new\");\n        fp_gtk_text_view_new = dl_symbol(\"gtk_text_view_new\");\n        fp_gtk_toggle_button_new =\n            dl_symbol(\"gtk_toggle_button_new\");\n        fp_gtk_toolbar_new = dl_symbol(\"gtk_toolbar_new\");\n        fp_gtk_tree_view_new = dl_symbol(\"gtk_tree_view_new\");\n        fp_gtk_viewport_new = dl_symbol(\"gtk_viewport_new\");\n        fp_gtk_window_new = dl_symbol(\"gtk_window_new\");\n        fp_gtk_window_present = dl_symbol(\"gtk_window_present\");\n        fp_gtk_window_move = dl_symbol(\"gtk_window_move\");\n        fp_gtk_window_resize = dl_symbol(\"gtk_window_resize\");\n\n          fp_gtk_dialog_new = dl_symbol(\"gtk_dialog_new\");\n        fp_gtk_frame_new = dl_symbol(\"gtk_frame_new\");\n\n        fp_gtk_adjustment_new = dl_symbol(\"gtk_adjustment_new\");\n        fp_gtk_container_add = dl_symbol(\"gtk_container_add\");\n        fp_gtk_menu_shell_append =\n            dl_symbol(\"gtk_menu_shell_append\");\n        fp_gtk_widget_realize = dl_symbol(\"gtk_widget_realize\");\n        fp_gtk_widget_destroy = dl_symbol(\"gtk_widget_destroy\");\n        fp_gtk_widget_render_icon =\n            dl_symbol(\"gtk_widget_render_icon\");\n        fp_gtk_widget_set_name =\n            dl_symbol(\"gtk_widget_set_name\");\n        fp_gtk_widget_set_parent =\n            dl_symbol(\"gtk_widget_set_parent\");\n        fp_gtk_widget_set_direction =\n            dl_symbol(\"gtk_widget_set_direction\");\n        fp_gtk_widget_style_get =\n            dl_symbol(\"gtk_widget_style_get\");\n        fp_gtk_widget_class_install_style_property =\n            dl_symbol(\"gtk_widget_class_install_style_property\");\n        fp_gtk_widget_class_find_style_property =\n            dl_symbol(\"gtk_widget_class_find_style_property\");\n        fp_gtk_widget_style_get_property =\n            dl_symbol(\"gtk_widget_style_get_property\");\n        fp_pango_font_description_to_string =\n            dl_symbol(\"pango_font_description_to_string\");\n        fp_gtk_settings_get_default =\n            dl_symbol(\"gtk_settings_get_default\");\n        fp_gtk_widget_get_settings =\n            dl_symbol(\"gtk_widget_get_settings\");\n        fp_gtk_border_get_type =  dl_symbol(\"gtk_border_get_type\");\n        fp_gtk_arrow_set = dl_symbol(\"gtk_arrow_set\");\n        fp_gtk_widget_size_request =\n            dl_symbol(\"gtk_widget_size_request\");\n        fp_gtk_range_get_adjustment =\n            dl_symbol(\"gtk_range_get_adjustment\");\n\n        fp_gtk_widget_hide = dl_symbol(\"gtk_widget_hide\");\n        fp_gtk_main_quit = dl_symbol(\"gtk_main_quit\");\n        fp_g_signal_connect_data = dl_symbol(\"g_signal_connect_data\");\n        fp_gtk_widget_show = dl_symbol(\"gtk_widget_show\");\n        fp_gtk_main = dl_symbol(\"gtk_main\");\n\n        fp_g_path_get_dirname = dl_symbol(\"g_path_get_dirname\");\n\n        fp_gdk_threads_enter = &empty;\n        fp_gdk_threads_leave = &empty;\n\n        /**\n         * Functions for sun_awt_X11_GtkFileDialogPeer.c\n         */\n        gtk3_file_chooser_load();\n\n        fp_gtk_combo_box_new = dlsym(gtk3_libhandle, \"gtk_combo_box_new\");\n        fp_gtk_combo_box_entry_new = dlsym(gtk3_libhandle,\n                                                \"gtk_combo_box_new_with_entry\");\n        fp_gtk_separator_tool_item_new = dlsym(gtk3_libhandle,\n                                                 \"gtk_separator_tool_item_new\");\n\n    }\n    /* Now we have only one kind of exceptions: NO_SYMBOL_EXCEPTION\n     * Otherwise we can check the return value of setjmp method.\n     */\n    else\n    {\n        dlclose(gtk3_libhandle);\n        gtk3_libhandle = NULL;\n\n        return NULL;\n    }\n\n    /*\n     * Strip the AT-SPI GTK_MODULEs if present\n     */\n    gtk_modules_env = getenv (\"GTK_MODULES\");\n    if (gtk_modules_env && strstr (gtk_modules_env, \"atk-bridge\") ||\n        gtk_modules_env && strstr (gtk_modules_env, \"gail\"))\n    {\n        /* the new env will be smaller than the old one */\n        gchar *s, *new_env = SAFE_SIZE_STRUCT_ALLOC(malloc,\n                sizeof(ENV_PREFIX), 1, strlen (gtk_modules_env));\n\n        if (new_env != NULL )\n        {\n            /* careful, strtok modifies its args */\n            gchar *tmp_env = strdup (gtk_modules_env);\n            strcpy(new_env, ENV_PREFIX);\n\n            /* strip out 'atk-bridge' and 'gail' */\n            size_t PREFIX_LENGTH = strlen(ENV_PREFIX);\n            while (s = strtok(tmp_env, \":\"))\n            {\n                if ((!strstr (s, \"atk-bridge\")) && (!strstr (s, \"gail\")))\n                {\n                    if (strlen (new_env) > PREFIX_LENGTH) {\n                        new_env = strcat (new_env, \":\");\n                    }\n                    new_env = strcat(new_env, s);\n                }\n                if (tmp_env)\n                {\n                    free (tmp_env);\n                    tmp_env = NULL; /* next call to strtok arg1==NULL */\n                }\n            }\n            putenv (new_env);\n            free (new_env);\n            free (tmp_env);\n        }\n    }\n    /*\n     * GTK should be initialized with gtk_init_check() before use.\n     *\n     * gtk_init_check installs its own error handlers. It is critical that\n     * we preserve error handler set from AWT. Otherwise we'll crash on\n     * BadMatch errors which we would normally ignore. The IO error handler\n     * is preserved here, too, just for consistency.\n    */\n    AWT_LOCK();\n    handler = XSetErrorHandler(NULL);\n    io_handler = XSetIOErrorHandler(NULL);\n    result = (*fp_gtk_init_check)(NULL, NULL);\n    XSetErrorHandler(handler);\n    XSetIOErrorHandler(io_handler);\n    AWT_UNLOCK();\n    /* Initialize widget array. */\n    for (i = 0; i < _GTK_WIDGET_TYPE_SIZE; i++)\n    {\n        gtk3_widgets[i] = NULL;\n    }\n    if (result) {\n        GtkApi* gtk = (GtkApi*)malloc(sizeof(GtkApi));\n        gtk3_init(gtk);\n        return gtk;\n    }\n    return NULL;\n}\n\nstatic int gtk3_unload()\n{\n    int i;\n    char *gtk3_error;\n\n    if (!gtk3_libhandle)\n        return TRUE;\n\n    /* Release painting objects */\n    if (surface != NULL) {\n        fp_cairo_destroy(cr);\n        fp_cairo_surface_destroy(surface);\n        surface = NULL;\n    }\n\n    if (gtk3_window != NULL) {\n        /* Destroying toplevel widget will destroy all contained widgets */\n        (*fp_gtk_widget_destroy)(gtk3_window);\n\n        /* Unset some static data so they get reinitialized on next load */\n        gtk3_window = NULL;\n    }\n\n    dlerror();\n    dlclose(gtk3_libhandle);\n    if ((gtk3_error = dlerror()) != NULL)\n    {\n        return FALSE;\n    }\n    return TRUE;\n}\n\n/* Dispatch all pending events from the GTK event loop.\n * This is needed to catch theme change and update widgets' style.\n */\nstatic void flush_gtk_event_loop()\n{\n    while((*fp_g_main_context_iteration)(NULL));\n}\n\n/*\n * Initialize components of containment hierarchy. This creates a GtkFixed\n * inside a GtkWindow. All widgets get realized.\n */\nstatic void init_containers()\n{\n    if (gtk3_window == NULL)\n    {\n        gtk3_window = (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n        gtk3_fixed = (GtkFixed *)(*fp_gtk_fixed_new)();\n        (*fp_gtk_container_add)((GtkContainer*)gtk3_window,\n                                (GtkWidget *)gtk3_fixed);\n        (*fp_gtk_widget_realize)(gtk3_window);\n        (*fp_gtk_widget_realize)((GtkWidget *)gtk3_fixed);\n\n        GtkSettings* settings = fp_gtk_settings_get_for_screen(\n                                         fp_gtk_widget_get_screen(gtk3_window));\n        gchar*  strval = NULL;\n        fp_g_object_get(settings, \"gtk-theme-name\", &strval, NULL);\n        gtk3_css = fp_gtk_css_provider_get_named(strval, NULL);\n    }\n}\n\n/*\n * Ensure everything is ready for drawing an element of the specified width\n * and height.\n *\n * We should somehow handle translucent images. GTK can draw to X Drawables\n * only, which don't support alpha. When we retrieve the image back from\n * the server, translucency information is lost. There're several ways to\n * work around this:\n * 1) Subclass GdkPixmap and cache translucent objects on client side. This\n * requires us to implement parts of X server drawing logic on client side.\n * Many X requests can potentially be \"translucent\"; e.g. XDrawLine with\n * fill=tile and a translucent tile is a \"translucent\" operation, whereas\n * XDrawLine with fill=solid is an \"opaque\" one. Moreover themes can (and some\n * do) intermix transparent and opaque operations which makes caching even\n * more problematic.\n * 2) Use Xorg 32bit ARGB visual when available. GDK has no native support\n * for it (as of version 2.6). Also even in JDS 3 Xorg does not support\n * these visuals by default, which makes optimizing for them pointless.\n * We can consider doing this at a later point when ARGB visuals become more\n * popular.\n * 3') GTK has plans to use Cairo as its graphical backend (presumably in\n * 2.8), and Cairo supports alpha. With it we could also get rid of the\n * unnecessary round trip to server and do all the drawing on client side.\n * 4) For now we draw to two different pixmaps and restore alpha channel by\n * comparing results. This can be optimized by using subclassed pixmap and\n*/\nstatic void gtk3_init_painting(JNIEnv *env, gint width, gint height)\n{\n    init_containers();\n\n    if (cr) {\n        fp_cairo_destroy(cr);\n    }\n\n    if (surface != NULL) {\n        /* free old stuff */\n        fp_cairo_surface_destroy(surface);\n\n    }\n\n    if (gtk3_version_3_10) {\n        surface = fp_gdk_window_create_similar_image_surface(\n                           fp_gtk_widget_get_window(gtk3_window),\n                                         CAIRO_FORMAT_ARGB32, width, height, 1);\n    } else {\n        surface = fp_cairo_image_surface_create(CAIRO_FORMAT_ARGB32,\n                                                                 width, height);\n    }\n\n    cr = fp_cairo_create(surface);\n}\n\n/*\n * Restore image from white and black pixmaps and copy it into destination\n * buffer. This method compares two pixbufs taken from white and black\n * pixmaps and decodes color and alpha components. Pixbufs are RGB without\n * alpha, destination buffer is ABGR.\n *\n * The return value is the transparency type of the resulting image, either\n * one of java_awt_Transparency_OPAQUE, java_awt_Transparency_BITMASK, and\n * java_awt_Transparency_TRANSLUCENT.\n */\nstatic gint gtk3_copy_image(gint *dst, gint width, gint height)\n{\n    gint i, j, r, g, b;\n    guchar *data;\n    gint stride, padding;\n\n    fp_cairo_surface_flush(surface);\n    data = (*fp_cairo_image_surface_get_data)(surface);\n    stride = (*fp_cairo_image_surface_get_stride)(surface);\n    padding = stride - width * 4;\n\n    for (i = 0; i < height; i++) {\n        for (j = 0; j < width; j++) {\n            int r = *data++;\n            int g = *data++;\n            int b = *data++;\n            int a = *data++;\n            *dst++ = (a << 24 | b << 16 | g << 8 | r);\n        }\n        data += padding;\n    }\n    return java_awt_Transparency_TRANSLUCENT;\n}\n\nstatic void gtk3_set_direction(GtkWidget *widget, GtkTextDirection dir)\n{\n    /*\n     * Some engines (inexplicably) look at the direction of the widget's\n     * parent, so we need to set the direction of both the widget and its\n     * parent.\n     */\n    (*fp_gtk_widget_set_direction)(widget, dir);\n    GtkWidget* parent = fp_gtk_widget_get_parent(widget);\n    if (parent != NULL) {\n        fp_gtk_widget_set_direction(parent, dir);\n    }\n}\n\n/* GTK state_type filter */\nstatic GtkStateType get_gtk_state_type(WidgetType widget_type, gint synth_state)\n{\n    GtkStateType result = GTK_STATE_NORMAL;\n\n    if ((synth_state & DISABLED) != 0) {\n        result = GTK_STATE_INSENSITIVE;\n    } else if ((synth_state & PRESSED) != 0) {\n        result = GTK_STATE_ACTIVE;\n    } else if ((synth_state & MOUSE_OVER) != 0) {\n        result = GTK_STATE_PRELIGHT;\n    }\n    return result;\n}\n\nstatic GtkStateFlags get_gtk_state_flags(gint synth_state)\n{\n    GtkStateFlags flags = 0;\n\n    if ((synth_state & DISABLED) != 0) {\n        flags |= GTK_STATE_FLAG_INSENSITIVE;\n    }\n    if (((synth_state & PRESSED) != 0 || (synth_state & SELECTED) != 0)) {\n        flags |= GTK_STATE_FLAG_ACTIVE;\n    }\n    if ((synth_state & MOUSE_OVER) != 0) {\n        flags |= GTK_STATE_FLAG_PRELIGHT;\n    }\n    if ((synth_state & FOCUSED) != 0) {\n        flags |= GTK_STATE_FLAG_FOCUSED;\n    }\n    return flags;\n}\n\nstatic GtkStateFlags get_gtk_flags(GtkStateType state_type) {\n    GtkStateFlags flags = 0;\n    switch (state_type)\n    {\n        case GTK_STATE_PRELIGHT:\n          flags |= GTK_STATE_FLAG_PRELIGHT;\n          break;\n        case GTK_STATE_SELECTED:\n          flags |= GTK_STATE_FLAG_SELECTED;\n          break;\n        case GTK_STATE_INSENSITIVE:\n          flags |= GTK_STATE_FLAG_INSENSITIVE;\n          break;\n        case GTK_STATE_ACTIVE:\n          flags |= GTK_STATE_FLAG_ACTIVE;\n          break;\n        case GTK_STATE_FOCUSED:\n          flags |= GTK_STATE_FLAG_FOCUSED;\n          break;\n        default:\n          break;\n    }\n    return flags;\n}\n\n/* GTK shadow_type filter */\nstatic GtkShadowType get_gtk_shadow_type(WidgetType widget_type,\n                                                               gint synth_state)\n{\n    GtkShadowType result = GTK_SHADOW_OUT;\n\n    if ((synth_state & SELECTED) != 0) {\n        result = GTK_SHADOW_IN;\n    }\n    return result;\n}\n\n\nstatic GtkWidget* gtk3_get_arrow(GtkArrowType arrow_type,\n                                                      GtkShadowType shadow_type)\n{\n    GtkWidget *arrow = NULL;\n    if (NULL == gtk3_widgets[_GTK_ARROW_TYPE])\n    {\n        gtk3_widgets[_GTK_ARROW_TYPE] = (*fp_gtk_arrow_new)(arrow_type,\n                                                                   shadow_type);\n        (*fp_gtk_container_add)((GtkContainer *)gtk3_fixed,\n                                                 gtk3_widgets[_GTK_ARROW_TYPE]);\n        (*fp_gtk_widget_realize)(gtk3_widgets[_GTK_ARROW_TYPE]);\n    }\n    arrow = gtk3_widgets[_GTK_ARROW_TYPE];\n\n    (*fp_gtk_arrow_set)(arrow, arrow_type, shadow_type);\n    return arrow;\n}\n\nstatic GtkAdjustment* create_adjustment()\n{\n    return (GtkAdjustment *)\n            (*fp_gtk_adjustment_new)(50.0, 0.0, 100.0, 10.0, 20.0, 20.0);\n}\n\n/**\n * Returns a pointer to the cached native widget for the specified widget\n * type.\n */\nstatic GtkWidget *gtk3_get_widget(WidgetType widget_type)\n{\n    gboolean init_result = FALSE;\n    GtkWidget *result = NULL;\n    switch (widget_type)\n    {\n        case BUTTON:\n        case TABLE_HEADER:\n            if (init_result = (NULL == gtk3_widgets[_GTK_BUTTON_TYPE]))\n            {\n                gtk3_widgets[_GTK_BUTTON_TYPE] = (*fp_gtk_button_new)();\n            }\n            result = gtk3_widgets[_GTK_BUTTON_TYPE];\n            break;\n        case CHECK_BOX:\n            if (init_result = (NULL == gtk3_widgets[_GTK_CHECK_BUTTON_TYPE]))\n            {\n                gtk3_widgets[_GTK_CHECK_BUTTON_TYPE] =\n                    (*fp_gtk_check_button_new)();\n            }\n            result = gtk3_widgets[_GTK_CHECK_BUTTON_TYPE];\n            break;\n        case CHECK_BOX_MENU_ITEM:\n            if (init_result = (NULL == gtk3_widgets[_GTK_CHECK_MENU_ITEM_TYPE]))\n            {\n                gtk3_widgets[_GTK_CHECK_MENU_ITEM_TYPE] =\n                    (*fp_gtk_check_menu_item_new)();\n            }\n            result = gtk3_widgets[_GTK_CHECK_MENU_ITEM_TYPE];\n            break;\n        /************************************************************\n         *    Creation a dedicated color chooser is dangerous because\n         * it deadlocks the EDT\n         ************************************************************/\n/*        case COLOR_CHOOSER:\n            if (init_result =\n                    (NULL == gtk3_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE]))\n            {\n                gtk3_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE] =\n                    (*fp_gtk_color_selection_dialog_new)(NULL);\n            }\n            result = gtk3_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE];\n            break;*/\n        case COMBO_BOX:\n            if (init_result = (NULL == gtk3_widgets[_GTK_COMBO_BOX_TYPE]))\n            {\n                gtk3_widgets[_GTK_COMBO_BOX_TYPE] =\n                    (*fp_gtk_combo_box_new)();\n            }\n            result = gtk3_widgets[_GTK_COMBO_BOX_TYPE];\n            break;\n        case COMBO_BOX_ARROW_BUTTON:\n            if (init_result =\n                    (NULL == gtk3_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE]))\n            {\n                gtk3_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE] =\n                     (*fp_gtk_toggle_button_new)();\n            }\n            result = gtk3_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE];\n            break;\n        case COMBO_BOX_TEXT_FIELD:\n            if (init_result =\n                    (NULL == gtk3_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE]))\n            {\n                result = gtk3_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE] =\n                     (*fp_gtk_entry_new)();\n            }\n            result = gtk3_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE];\n            break;\n        case DESKTOP_ICON:\n        case INTERNAL_FRAME_TITLE_PANE:\n        case LABEL:\n            if (init_result = (NULL == gtk3_widgets[_GTK_LABEL_TYPE]))\n            {\n                gtk3_widgets[_GTK_LABEL_TYPE] =\n                    (*fp_gtk_label_new)(NULL);\n            }\n            result = gtk3_widgets[_GTK_LABEL_TYPE];\n            break;\n        case DESKTOP_PANE:\n        case PANEL:\n        case ROOT_PANE:\n            if (init_result = (NULL == gtk3_widgets[_GTK_CONTAINER_TYPE]))\n            {\n                /* There is no constructor for a container type.  I've\n                 * chosen GtkFixed container since it has a default\n                 * constructor.\n                 */\n                gtk3_widgets[_GTK_CONTAINER_TYPE] =\n                    (*fp_gtk_fixed_new)();\n            }\n            result = gtk3_widgets[_GTK_CONTAINER_TYPE];\n            break;\n        case EDITOR_PANE:\n        case TEXT_AREA:\n        case TEXT_PANE:\n            if (init_result = (NULL == gtk3_widgets[_GTK_TEXT_VIEW_TYPE]))\n            {\n                gtk3_widgets[_GTK_TEXT_VIEW_TYPE] =\n                    (*fp_gtk_text_view_new)();\n            }\n            result = gtk3_widgets[_GTK_TEXT_VIEW_TYPE];\n            break;\n        case FORMATTED_TEXT_FIELD:\n        case PASSWORD_FIELD:\n        case TEXT_FIELD:\n            if (init_result = (NULL == gtk3_widgets[_GTK_ENTRY_TYPE]))\n            {\n                gtk3_widgets[_GTK_ENTRY_TYPE] =\n                    (*fp_gtk_entry_new)();\n            }\n            result = gtk3_widgets[_GTK_ENTRY_TYPE];\n            break;\n        case HANDLE_BOX:\n            if (init_result = (NULL == gtk3_widgets[_GTK_HANDLE_BOX_TYPE]))\n            {\n                gtk3_widgets[_GTK_HANDLE_BOX_TYPE] =\n                    (*fp_gtk_handle_box_new)();\n            }\n            result = gtk3_widgets[_GTK_HANDLE_BOX_TYPE];\n            break;\n        case HSCROLL_BAR:\n        case HSCROLL_BAR_BUTTON_LEFT:\n        case HSCROLL_BAR_BUTTON_RIGHT:\n        case HSCROLL_BAR_TRACK:\n        case HSCROLL_BAR_THUMB:\n            if (init_result = (NULL == gtk3_widgets[_GTK_HSCROLLBAR_TYPE]))\n            {\n                gtk3_widgets[_GTK_HSCROLLBAR_TYPE] =\n                    (*fp_gtk_hscrollbar_new)(create_adjustment());\n            }\n            result = gtk3_widgets[_GTK_HSCROLLBAR_TYPE];\n            break;\n        case HSEPARATOR:\n            if (init_result = (NULL == gtk3_widgets[_GTK_HSEPARATOR_TYPE]))\n            {\n                gtk3_widgets[_GTK_HSEPARATOR_TYPE] =\n                    (*fp_gtk_hseparator_new)();\n            }\n            result = gtk3_widgets[_GTK_HSEPARATOR_TYPE];\n            break;\n        case HSLIDER:\n        case HSLIDER_THUMB:\n        case HSLIDER_TRACK:\n            if (init_result = (NULL == gtk3_widgets[_GTK_HSCALE_TYPE]))\n            {\n                gtk3_widgets[_GTK_HSCALE_TYPE] =\n                    (*fp_gtk_scale_new)(GTK_ORIENTATION_HORIZONTAL, NULL);\n            }\n            result = gtk3_widgets[_GTK_HSCALE_TYPE];\n            break;\n        case HSPLIT_PANE_DIVIDER:\n        case SPLIT_PANE:\n            if (init_result = (NULL == gtk3_widgets[_GTK_HPANED_TYPE]))\n            {\n                gtk3_widgets[_GTK_HPANED_TYPE] = (*fp_gtk_hpaned_new)();\n            }\n            result = gtk3_widgets[_GTK_HPANED_TYPE];\n            break;\n        case IMAGE:\n            if (init_result = (NULL == gtk3_widgets[_GTK_IMAGE_TYPE]))\n            {\n                gtk3_widgets[_GTK_IMAGE_TYPE] = (*fp_gtk_image_new)();\n            }\n            result = gtk3_widgets[_GTK_IMAGE_TYPE];\n            break;\n        case INTERNAL_FRAME:\n            if (init_result = (NULL == gtk3_widgets[_GTK_WINDOW_TYPE]))\n            {\n                gtk3_widgets[_GTK_WINDOW_TYPE] =\n                    (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n            }\n            result = gtk3_widgets[_GTK_WINDOW_TYPE];\n            break;\n        case TOOL_TIP:\n            if (init_result = (NULL == gtk3_widgets[_GTK_TOOLTIP_TYPE]))\n            {\n                result = (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n                gtk3_widgets[_GTK_TOOLTIP_TYPE] = result;\n            }\n            result = gtk3_widgets[_GTK_TOOLTIP_TYPE];\n            break;\n        case LIST:\n        case TABLE:\n        case TREE:\n        case TREE_CELL:\n            if (init_result = (NULL == gtk3_widgets[_GTK_TREE_VIEW_TYPE]))\n            {\n                gtk3_widgets[_GTK_TREE_VIEW_TYPE] =\n                    (*fp_gtk_tree_view_new)();\n            }\n            result = gtk3_widgets[_GTK_TREE_VIEW_TYPE];\n            break;\n        case TITLED_BORDER:\n            if (init_result = (NULL == gtk3_widgets[_GTK_FRAME_TYPE]))\n            {\n                gtk3_widgets[_GTK_FRAME_TYPE] = fp_gtk_frame_new(NULL);\n            }\n            result = gtk3_widgets[_GTK_FRAME_TYPE];\n            break;\n        case POPUP_MENU:\n            if (init_result = (NULL == gtk3_widgets[_GTK_MENU_TYPE]))\n            {\n                gtk3_widgets[_GTK_MENU_TYPE] =\n                    (*fp_gtk_menu_new)();\n            }\n            result = gtk3_widgets[_GTK_MENU_TYPE];\n            break;\n        case MENU:\n        case MENU_ITEM:\n        case MENU_ITEM_ACCELERATOR:\n            if (init_result = (NULL == gtk3_widgets[_GTK_MENU_ITEM_TYPE]))\n            {\n                gtk3_widgets[_GTK_MENU_ITEM_TYPE] =\n                    (*fp_gtk_menu_item_new)();\n            }\n            result = gtk3_widgets[_GTK_MENU_ITEM_TYPE];\n            break;\n        case MENU_BAR:\n            if (init_result = (NULL == gtk3_widgets[_GTK_MENU_BAR_TYPE]))\n            {\n                gtk3_widgets[_GTK_MENU_BAR_TYPE] =\n                    (*fp_gtk_menu_bar_new)();\n            }\n            result = gtk3_widgets[_GTK_MENU_BAR_TYPE];\n            break;\n        case COLOR_CHOOSER:\n        case OPTION_PANE:\n            if (init_result = (NULL == gtk3_widgets[_GTK_DIALOG_TYPE]))\n            {\n                gtk3_widgets[_GTK_DIALOG_TYPE] =\n                    (*fp_gtk_dialog_new)();\n            }\n            result = gtk3_widgets[_GTK_DIALOG_TYPE];\n            break;\n        case POPUP_MENU_SEPARATOR:\n            if (init_result =\n                    (NULL == gtk3_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE]))\n            {\n                gtk3_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE] =\n                    (*fp_gtk_separator_menu_item_new)();\n            }\n            result = gtk3_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE];\n            break;\n        case HPROGRESS_BAR:\n            if (init_result = (NULL == gtk3_widgets[_GTK_HPROGRESS_BAR_TYPE]))\n            {\n                gtk3_widgets[_GTK_HPROGRESS_BAR_TYPE] =\n                    (*fp_gtk_progress_bar_new)();\n            }\n            result = gtk3_widgets[_GTK_HPROGRESS_BAR_TYPE];\n            break;\n        case VPROGRESS_BAR:\n            if (init_result = (NULL == gtk3_widgets[_GTK_VPROGRESS_BAR_TYPE]))\n            {\n                gtk3_widgets[_GTK_VPROGRESS_BAR_TYPE] =\n                    (*fp_gtk_progress_bar_new)();\n                /*\n                 * Vertical JProgressBars always go bottom-to-top,\n                 * regardless of the ComponentOrientation.\n                 */\n                (*fp_gtk_progress_bar_set_orientation)(\n                    (GtkProgressBar *)gtk3_widgets[_GTK_VPROGRESS_BAR_TYPE],\n                    GTK_PROGRESS_BOTTOM_TO_TOP);\n            }\n            result = gtk3_widgets[_GTK_VPROGRESS_BAR_TYPE];\n            break;\n        case RADIO_BUTTON:\n            if (init_result = (NULL == gtk3_widgets[_GTK_RADIO_BUTTON_TYPE]))\n            {\n                gtk3_widgets[_GTK_RADIO_BUTTON_TYPE] =\n                    (*fp_gtk_radio_button_new)(NULL);\n            }\n            result = gtk3_widgets[_GTK_RADIO_BUTTON_TYPE];\n            break;\n        case RADIO_BUTTON_MENU_ITEM:\n            if (init_result =\n                    (NULL == gtk3_widgets[_GTK_RADIO_MENU_ITEM_TYPE]))\n            {\n                gtk3_widgets[_GTK_RADIO_MENU_ITEM_TYPE] =\n                    (*fp_gtk_radio_menu_item_new)(NULL);\n            }\n            result = gtk3_widgets[_GTK_RADIO_MENU_ITEM_TYPE];\n            break;\n        case SCROLL_PANE:\n            if (init_result =\n                    (NULL == gtk3_widgets[_GTK_SCROLLED_WINDOW_TYPE]))\n            {\n                gtk3_widgets[_GTK_SCROLLED_WINDOW_TYPE] =\n                    (*fp_gtk_scrolled_window_new)(NULL, NULL);\n            }\n            result = gtk3_widgets[_GTK_SCROLLED_WINDOW_TYPE];\n            break;\n        case SPINNER:\n        case SPINNER_ARROW_BUTTON:\n        case SPINNER_TEXT_FIELD:\n            if (init_result = (NULL == gtk3_widgets[_GTK_SPIN_BUTTON_TYPE]))\n            {\n                result = gtk3_widgets[_GTK_SPIN_BUTTON_TYPE] =\n                    (*fp_gtk_spin_button_new)(NULL, 0, 0);\n            }\n            result = gtk3_widgets[_GTK_SPIN_BUTTON_TYPE];\n            break;\n        case TABBED_PANE:\n        case TABBED_PANE_TAB_AREA:\n        case TABBED_PANE_CONTENT:\n        case TABBED_PANE_TAB:\n            if (init_result = (NULL == gtk3_widgets[_GTK_NOTEBOOK_TYPE]))\n            {\n                gtk3_widgets[_GTK_NOTEBOOK_TYPE] =\n                    (*fp_gtk_notebook_new)(NULL);\n            }\n            result = gtk3_widgets[_GTK_NOTEBOOK_TYPE];\n            break;\n        case TOGGLE_BUTTON:\n            if (init_result = (NULL == gtk3_widgets[_GTK_TOGGLE_BUTTON_TYPE]))\n            {\n                gtk3_widgets[_GTK_TOGGLE_BUTTON_TYPE] =\n                    (*fp_gtk_toggle_button_new)(NULL);\n            }\n            result = gtk3_widgets[_GTK_TOGGLE_BUTTON_TYPE];\n            break;\n        case TOOL_BAR:\n        case TOOL_BAR_DRAG_WINDOW:\n            if (init_result = (NULL == gtk3_widgets[_GTK_TOOLBAR_TYPE]))\n            {\n                gtk3_widgets[_GTK_TOOLBAR_TYPE] =\n                    (*fp_gtk_toolbar_new)(NULL);\n            }\n            result = gtk3_widgets[_GTK_TOOLBAR_TYPE];\n            break;\n        case TOOL_BAR_SEPARATOR:\n            if (init_result =\n                    (NULL == gtk3_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE]))\n            {\n                gtk3_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE] =\n                    (*fp_gtk_separator_tool_item_new)();\n            }\n            result = gtk3_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE];\n            break;\n        case VIEWPORT:\n            if (init_result = (NULL == gtk3_widgets[_GTK_VIEWPORT_TYPE]))\n            {\n                GtkAdjustment *adjustment = create_adjustment();\n                gtk3_widgets[_GTK_VIEWPORT_TYPE] =\n                    (*fp_gtk_viewport_new)(adjustment, adjustment);\n            }\n            result = gtk3_widgets[_GTK_VIEWPORT_TYPE];\n            break;\n        case VSCROLL_BAR:\n        case VSCROLL_BAR_BUTTON_UP:\n        case VSCROLL_BAR_BUTTON_DOWN:\n        case VSCROLL_BAR_TRACK:\n        case VSCROLL_BAR_THUMB:\n            if (init_result = (NULL == gtk3_widgets[_GTK_VSCROLLBAR_TYPE]))\n            {\n                gtk3_widgets[_GTK_VSCROLLBAR_TYPE] =\n                    (*fp_gtk_vscrollbar_new)(create_adjustment());\n            }\n            result = gtk3_widgets[_GTK_VSCROLLBAR_TYPE];\n            break;\n        case VSEPARATOR:\n            if (init_result = (NULL == gtk3_widgets[_GTK_VSEPARATOR_TYPE]))\n            {\n                gtk3_widgets[_GTK_VSEPARATOR_TYPE] =\n                    (*fp_gtk_vseparator_new)();\n            }\n            result = gtk3_widgets[_GTK_VSEPARATOR_TYPE];\n            break;\n        case VSLIDER:\n        case VSLIDER_THUMB:\n        case VSLIDER_TRACK:\n            if (init_result = (NULL == gtk3_widgets[_GTK_VSCALE_TYPE]))\n            {\n                gtk3_widgets[_GTK_VSCALE_TYPE] =\n                    (*fp_gtk_scale_new)(GTK_ORIENTATION_VERTICAL, NULL);\n            }\n            result = gtk3_widgets[_GTK_VSCALE_TYPE];\n            /*\n             * Vertical JSliders start at the bottom, while vertical\n             * GtkVScale widgets start at the top (by default), so to fix\n             * this we set the \"inverted\" flag to get the Swing behavior.\n             */\n             fp_gtk_range_set_inverted((GtkRange*)result, TRUE);\n            break;\n        case VSPLIT_PANE_DIVIDER:\n            if (init_result = (NULL == gtk3_widgets[_GTK_VPANED_TYPE]))\n            {\n                gtk3_widgets[_GTK_VPANED_TYPE] = (*fp_gtk_vpaned_new)();\n            }\n            result = gtk3_widgets[_GTK_VPANED_TYPE];\n            break;\n        default:\n            result = NULL;\n            break;\n    }\n\n    if (result != NULL && init_result)\n    {\n        if (widget_type == RADIO_BUTTON_MENU_ITEM ||\n                widget_type == CHECK_BOX_MENU_ITEM ||\n                widget_type == MENU_ITEM ||\n                widget_type == MENU ||\n                widget_type == POPUP_MENU_SEPARATOR)\n        {\n            GtkWidget *menu = gtk3_get_widget(POPUP_MENU);\n            (*fp_gtk_menu_shell_append)((GtkMenuShell *)menu, result);\n        }\n        else if (widget_type == POPUP_MENU)\n        {\n            GtkWidget *menu_bar = gtk3_get_widget(MENU_BAR);\n            GtkWidget *root_menu = (*fp_gtk_menu_item_new)();\n            (*fp_gtk_menu_item_set_submenu)((GtkMenuItem*)root_menu, result);\n            (*fp_gtk_menu_shell_append)((GtkMenuShell *)menu_bar, root_menu);\n        }\n        else if (widget_type == COMBO_BOX_TEXT_FIELD )\n        {\n            GtkWidget* combo = gtk3_get_widget(COMBO_BOX);\n\n            /*\n            * We add a regular GtkButton/GtkEntry to a GtkComboBoxEntry\n            * in order to trick engines into thinking it's a real combobox\n            * arrow button/text field.\n            */\n\n            fp_gtk_container_add ((GtkContainer*)(combo), result);\n            GtkStyleContext* context = fp_gtk_widget_get_style_context (combo);\n            fp_gtk_style_context_add_class (context, \"combobox-entry\");\n            context = fp_gtk_widget_get_style_context (result);\n            fp_gtk_style_context_add_class (context, \"combobox\");\n            fp_gtk_style_context_add_class (context, \"entry\");\n        }\n        else if (widget_type == COMBO_BOX_ARROW_BUTTON )\n        {\n            GtkWidget* combo = gtk3_get_widget(COMBO_BOX);\n            fp_gtk_widget_set_parent(result, combo);\n        }\n        else if (widget_type != TOOL_TIP &&\n                 widget_type != INTERNAL_FRAME &&\n                 widget_type != OPTION_PANE)\n        {\n            (*fp_gtk_container_add)((GtkContainer *)gtk3_fixed, result);\n        }\n        (*fp_gtk_widget_realize)(result);\n    }\n    return result;\n}\n\nstatic void gtk3_paint_arrow(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height,\n        GtkArrowType arrow_type, gboolean fill)\n{\n    gdouble xx, yy, a = G_PI;\n    int s = width;\n    gtk3_widget = gtk3_get_arrow(arrow_type, shadow_type);\n\n    switch (widget_type)\n    {\n        case SPINNER_ARROW_BUTTON:\n            s = (int)(0.4 * width + 0.5) + 1;\n            if (arrow_type == GTK_ARROW_UP) {\n                a = 0;\n            } else if (arrow_type == GTK_ARROW_DOWN) {\n                a = G_PI;\n            }\n            break;\n\n        case HSCROLL_BAR_BUTTON_LEFT:\n            s = (int)(0.5 * MIN(height, width * 2) + 0.5) + 1;\n            a = 3 * G_PI / 2;\n            break;\n\n        case HSCROLL_BAR_BUTTON_RIGHT:\n            s = (int)(0.5 * MIN(height, width * 2) + 0.5) + 1;\n            a = G_PI / 2;\n            break;\n\n        case VSCROLL_BAR_BUTTON_UP:\n            s = (int)(0.5 * MIN(height * 2, width) + 0.5) + 1;\n            a = 0;\n            break;\n\n        case VSCROLL_BAR_BUTTON_DOWN:\n            s = (int)(0.5 * MIN(height * 2, width) + 0.5) + 1;\n            a = G_PI;\n            break;\n\n        case COMBO_BOX_ARROW_BUTTON:\n            s = (int)(0.3 * height + 0.5) + 1;\n            a = G_PI;\n            break;\n\n        case TABLE:\n            s = (int)(0.8 * height + 0.5) + 1;\n            if (arrow_type == GTK_ARROW_UP) {\n                a = G_PI;\n            } else if (arrow_type == GTK_ARROW_DOWN) {\n                a = 0;\n            }\n            break;\n\n        case MENU_ITEM:\n            if (arrow_type == GTK_ARROW_UP) {\n                a = G_PI;\n            } else if (arrow_type == GTK_ARROW_DOWN) {\n                a = 0;\n            } else if (arrow_type == GTK_ARROW_RIGHT) {\n                a = G_PI / 2;\n            } else if (arrow_type == GTK_ARROW_LEFT) {\n                a = 3 * G_PI / 2;\n            }\n            break;\n\n        default:\n            if (arrow_type == GTK_ARROW_UP) {\n                a = G_PI;\n            } else if (arrow_type == GTK_ARROW_DOWN) {\n                a = 0;\n            } else if (arrow_type == GTK_ARROW_RIGHT) {\n                a = G_PI / 2;\n            } else if (arrow_type == GTK_ARROW_LEFT) {\n                a = 3 * G_PI / 2;\n            }\n            break;\n    }\n\n    if (s < width && s < height) {\n        xx = x + (0.5 * (width - s) + 0.5);\n        yy = y + (0.5 * (height - s) + 0.5);\n    } else {\n        xx = x;\n        yy = y;\n    }\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n    fp_gtk_style_context_save (context);\n\n\n    if (detail != NULL) {\n        transform_detail_string(detail, context);\n    }\n\n    GtkStateFlags flags = get_gtk_flags(state_type);\n\n    fp_gtk_style_context_set_state (context, flags);\n\n    (*fp_gtk_render_arrow)(context, cr, a, xx, yy, s);\n\n    fp_gtk_style_context_restore (context);\n}\n\nstatic void gtk3_paint_box(WidgetType widget_type, GtkStateType state_type,\n                    GtkShadowType shadow_type, const gchar *detail,\n                    gint x, gint y, gint width, gint height,\n                    gint synth_state, GtkTextDirection dir)\n{\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    if (widget_type == HSLIDER_TRACK) {\n        /*\n         * For horizontal JSliders with right-to-left orientation, we need\n         * to set the \"inverted\" flag to match the native GTK behavior where\n         * the foreground highlight is on the right side of the slider thumb.\n         * This is needed especially for the ubuntulooks engine, which looks\n         * exclusively at the \"inverted\" flag to determine on which side of\n         * the thumb to paint the highlight...\n         */\n        fp_gtk_range_set_inverted((GtkRange*)gtk3_widget, dir ==\n                                                              GTK_TEXT_DIR_RTL);\n\n        /*\n         * Note however that other engines like clearlooks will look at both\n         * the \"inverted\" field and the text direction to determine how\n         * the foreground highlight is painted:\n         *     !inverted && ltr --> paint highlight on left side\n         *     !inverted && rtl --> paint highlight on right side\n         *      inverted && ltr --> paint highlight on right side\n         *      inverted && rtl --> paint highlight on left side\n         * So the only way to reliably get the desired results for horizontal\n         * JSlider (i.e., highlight on left side for LTR ComponentOrientation\n         * and highlight on right side for RTL ComponentOrientation) is to\n         * always override text direction as LTR, and then set the \"inverted\"\n         * flag accordingly (as we have done above).\n         */\n        dir = GTK_TEXT_DIR_LTR;\n    }\n\n    /*\n     * Some engines (e.g. clearlooks) will paint the shadow of certain\n     * widgets (e.g. COMBO_BOX_ARROW_BUTTON) differently depending on the\n     * the text direction.\n     */\n    gtk3_set_direction(gtk3_widget, dir);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n    fp_gtk_style_context_save (context);\n\n    transform_detail_string(detail, context);\n\n    GtkStateFlags flags = get_gtk_flags(state_type);\n\n    if (shadow_type == GTK_SHADOW_IN && widget_type != COMBO_BOX_ARROW_BUTTON) {\n        flags |= GTK_STATE_FLAG_ACTIVE;\n    }\n\n    if (synth_state & MOUSE_OVER) {\n        flags |= GTK_STATE_FLAG_PRELIGHT;\n    }\n\n    if (synth_state & FOCUSED) {\n        flags |= GTK_STATE_FLAG_FOCUSED;\n    }\n\n    if (synth_state & DEFAULT) {\n        fp_gtk_style_context_add_class (context, \"default\");\n    }\n\n    fp_gtk_style_context_set_state (context, flags);\n\n    if (fp_gtk_style_context_has_class(context, \"progressbar\")) {\n        fp_gtk_render_activity (context, cr, x, y, width, height);\n    } else {\n        fp_gtk_render_background (context, cr, x, y, width, height);\n        if (shadow_type != GTK_SHADOW_NONE) {\n            fp_gtk_render_frame(context, cr, x, y, width, height);\n        }\n    }\n\n    fp_gtk_style_context_restore (context);\n    /*\n     * Reset the text direction to the default value so that we don't\n     * accidentally affect other operations and widgets.\n     */\n    gtk3_set_direction(gtk3_widget, GTK_TEXT_DIR_LTR);\n}\n\nstatic void gtk3_paint_box_gap(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height,\n        GtkPositionType gap_side, gint gap_x, gint gap_width)\n{\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n\n    fp_gtk_style_context_save (context);\n\n    GtkStateFlags flags = get_gtk_flags(state_type);\n    fp_gtk_style_context_set_state(context, flags);\n\n    if (detail != 0) {\n        transform_detail_string(detail, context);\n    }\n    fp_gtk_render_background(context, cr, x, y, width, height);\n\n    if (shadow_type != GTK_SHADOW_NONE) {\n        fp_gtk_render_frame_gap(context, cr, x, y, width, height, gap_side,\n                                    (gdouble)gap_x, (gdouble)gap_x + gap_width);\n    }\n    fp_gtk_style_context_restore (context);\n}\n\nstatic void gtk3_paint_check(WidgetType widget_type, gint synth_state,\n        const gchar *detail, gint x, gint y, gint width, gint height)\n{\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n\n    fp_gtk_style_context_save (context);\n\n    GtkStateFlags flags = get_gtk_state_flags(synth_state);\n    if (gtk3_version_3_14 && (synth_state & SELECTED)) {\n        flags = GTK_STATE_FLAG_CHECKED;\n    }\n    fp_gtk_style_context_set_state(context, flags);\n\n    fp_gtk_style_context_add_class (context, \"check\");\n\n    fp_gtk_render_check (context, cr, x, y, width, height);\n\n    fp_gtk_style_context_restore (context);\n}\n\n\nstatic void gtk3_paint_expander(WidgetType widget_type, GtkStateType state_type,\n        const gchar *detail, gint x, gint y, gint width, gint height,\n        GtkExpanderStyle expander_style)\n{\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n\n    fp_gtk_style_context_save (context);\n\n    GtkStateFlags flags = get_gtk_flags(state_type);\n    fp_gtk_style_context_set_state(context, flags);\n\n    if (detail != 0) {\n        transform_detail_string(detail, context);\n    }\n\n    fp_gtk_render_expander (context, cr, x, y, width, height);\n\n    fp_gtk_style_context_restore (context);\n}\n\nstatic void gtk3_paint_extension(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height, GtkPositionType gap_side)\n{\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n\n    fp_gtk_style_context_save (context);\n\n    GtkStateFlags flags = GTK_STATE_FLAG_NORMAL;\n\n    if (state_type == 0) {\n        flags = GTK_STATE_FLAG_ACTIVE;\n    }\n\n    fp_gtk_style_context_set_state(context, flags);\n\n    if (detail != 0) {\n        transform_detail_string(detail, context);\n    }\n    switch(gap_side) {\n      case GTK_POS_LEFT:\n        fp_gtk_style_context_add_class(context, \"right\");\n        break;\n      case GTK_POS_RIGHT:\n        fp_gtk_style_context_add_class(context, \"left\");\n        break;\n      case GTK_POS_TOP:\n        fp_gtk_style_context_add_class(context, \"bottom\");\n        break;\n      case GTK_POS_BOTTOM:\n        fp_gtk_style_context_add_class(context, \"top\");\n        break;\n      default:\n        break;\n    }\n\n    fp_gtk_render_extension(context, cr, x, y, width, height, gap_side);\n\n    fp_gtk_style_context_restore (context);\n}\n\nstatic void gtk3_paint_flat_box(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height, gboolean has_focus)\n{\n    if (state_type == GTK_STATE_PRELIGHT &&\n        (widget_type == CHECK_BOX || widget_type == RADIO_BUTTON)) {\n        return;\n    }\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n\n    fp_gtk_style_context_save (context);\n\n    if (detail != 0) {\n        transform_detail_string(detail, context);\n    }\n\n    GtkStateFlags flags = get_gtk_flags(state_type);\n\n    if (has_focus) {\n        flags |= GTK_STATE_FLAG_FOCUSED;\n    }\n\n    fp_gtk_style_context_set_state (context, flags);\n\n    if (widget_type == COMBO_BOX_TEXT_FIELD) {\n        width += height /2;\n    }\n\n    fp_gtk_render_background (context, cr, x, y, width, height);\n\n    fp_gtk_style_context_restore (context);\n}\n\nstatic void gtk3_paint_focus(WidgetType widget_type, GtkStateType state_type,\n        const char *detail, gint x, gint y, gint width, gint height)\n{\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n    fp_gtk_style_context_save (context);\n\n    transform_detail_string(detail, context);\n    fp_gtk_render_focus (context, cr, x, y, width, height);\n\n    fp_gtk_style_context_restore (context);\n\n}\n\nstatic void gtk3_paint_handle(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height, GtkOrientation orientation)\n{\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n\n    fp_gtk_style_context_save (context);\n\n    GtkStateFlags flags = get_gtk_flags(state_type);\n    fp_gtk_style_context_set_state(context, GTK_STATE_FLAG_PRELIGHT);\n\n    if (detail != 0) {\n        transform_detail_string(detail, context);\n        fp_gtk_style_context_add_class (context, \"handlebox_bin\");\n    }\n\n    fp_gtk_render_handle(context, cr, x, y, width, height);\n    fp_gtk_render_background(context, cr, x, y, width, height);\n\n    fp_gtk_style_context_restore (context);\n}\n\nstatic void gtk3_paint_hline(WidgetType widget_type, GtkStateType state_type,\n        const gchar *detail, gint x, gint y, gint width, gint height)\n{\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n\n    fp_gtk_style_context_save (context);\n\n    if (detail != 0) {\n        transform_detail_string(detail, context);\n    }\n\n    fp_gtk_render_line(context, cr, x, y, x + width, y);\n\n    fp_gtk_style_context_restore (context);\n}\n\nstatic void gtk3_paint_vline(WidgetType widget_type, GtkStateType state_type,\n        const gchar *detail, gint x, gint y, gint width, gint height)\n{\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n\n    fp_gtk_style_context_save (context);\n\n    if (detail != 0) {\n        transform_detail_string(detail, context);\n    }\n\n    fp_gtk_render_line(context, cr, x, y, x, y + height);\n\n    fp_gtk_style_context_restore (context);\n}\n\nstatic void gtk3_paint_option(WidgetType widget_type, gint synth_state,\n        const gchar *detail, gint x, gint y, gint width, gint height)\n{\n     gtk3_widget = gtk3_get_widget(widget_type);\n\n     GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n\n     fp_gtk_style_context_save (context);\n\n     GtkStateFlags flags = get_gtk_state_flags(synth_state);\n     if (gtk3_version_3_14 && (synth_state & SELECTED)) {\n         flags = GTK_STATE_FLAG_CHECKED;\n     }\n     fp_gtk_style_context_set_state(context, flags);\n\n     if (detail != 0) {\n         transform_detail_string(detail, context);\n     }\n\n     fp_gtk_render_option(context, cr, x, y, width, height);\n\n     fp_gtk_style_context_restore (context);\n}\n\nstatic void gtk3_paint_shadow(WidgetType widget_type, GtkStateType state_type,\n                       GtkShadowType shadow_type, const gchar *detail,\n                       gint x, gint y, gint width, gint height,\n                       gint synth_state, GtkTextDirection dir)\n{\n    if (shadow_type == GTK_SHADOW_NONE) {\n        return;\n    }\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    /*\n     * Some engines (e.g. clearlooks) will paint the shadow of certain\n     * widgets (e.g. COMBO_BOX_TEXT_FIELD) differently depending on the\n     * the text direction.\n     */\n    gtk3_set_direction(gtk3_widget, dir);\n\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n    fp_gtk_style_context_save (context);\n\n    if (detail) {\n        transform_detail_string(detail, context);\n    }\n\n    GtkStateFlags flags = get_gtk_flags(state_type);\n\n    if (synth_state & MOUSE_OVER) {\n        flags |= GTK_STATE_FLAG_PRELIGHT;\n    }\n\n    if (synth_state & FOCUSED) {\n        flags |= GTK_STATE_FLAG_FOCUSED;\n    }\n\n    fp_gtk_style_context_set_state (context, flags);\n\n    if (widget_type == COMBO_BOX_TEXT_FIELD) {\n        width += height / 2;\n    }\n    fp_gtk_render_frame(context, cr, x, y, width, height);\n\n    fp_gtk_style_context_restore (context);\n\n    /*\n     * Reset the text direction to the default value so that we don't\n     * accidentally affect other operations and widgets.\n     */\n    gtk3_set_direction(gtk3_widget, GTK_TEXT_DIR_LTR);\n}\n\nstatic void gtk3_paint_slider(WidgetType widget_type, GtkStateType state_type,\n        GtkShadowType shadow_type, const gchar *detail,\n        gint x, gint y, gint width, gint height, GtkOrientation orientation,\n        gboolean has_focus)\n{\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n\n    fp_gtk_style_context_save (context);\n\n    if (detail) {\n       transform_detail_string(detail, context);\n    }\n\n    GtkStateFlags flags = get_gtk_flags(state_type);\n\n    if (state_type == GTK_STATE_ACTIVE) {\n        flags |= GTK_STATE_FLAG_PRELIGHT;\n    }\n\n    if (has_focus) {\n        flags |= GTK_STATE_FLAG_FOCUSED;\n    }\n\n    fp_gtk_style_context_set_state (context, flags);\n\n    (*fp_gtk_render_slider)(context, cr, x, y, width, height, orientation);\n\n    fp_gtk_style_context_restore (context);\n}\n\nstatic void gtk3_paint_background(WidgetType widget_type,\n             GtkStateType state_type, gint x, gint y, gint width, gint height) {\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n    fp_gtk_style_context_save (context);\n\n    GtkStateFlags flags = get_gtk_flags(state_type);\n\n    fp_gtk_style_context_set_state (context, flags);\n\n    fp_gtk_render_background (context, cr, x, y, width, height);\n\n    fp_gtk_style_context_restore (context);\n}\n\nstatic GdkPixbuf *gtk3_get_stock_icon(gint widget_type, const gchar *stock_id,\n        GtkIconSize size, GtkTextDirection direction, const char *detail)\n{\n    int sz;\n\n    switch(size) {\n      case GTK_ICON_SIZE_MENU:\n        sz = 16;\n        break;\n      case GTK_ICON_SIZE_SMALL_TOOLBAR:\n        sz = 18;\n        break;\n      case GTK_ICON_SIZE_LARGE_TOOLBAR:\n        sz = 24;\n        break;\n      case GTK_ICON_SIZE_BUTTON:\n        sz = 20;\n        break;\n      case GTK_ICON_SIZE_DND:\n        sz = 32;\n        break;\n      case GTK_ICON_SIZE_DIALOG:\n        sz = 48;\n        break;\n      default:\n        sz = 0;\n        break;\n    }\n\n    init_containers();\n    gtk3_widget = gtk3_get_widget((widget_type < 0) ? IMAGE : widget_type);\n    (*fp_gtk_widget_set_direction)(gtk3_widget, direction);\n    GtkIconTheme *icon_theme = fp_gtk_icon_theme_get_default();\n    GdkPixbuf *result = fp_gtk_icon_theme_load_icon(icon_theme, stock_id, sz,\n                                             GTK_ICON_LOOKUP_USE_BUILTIN, NULL);\n    return result;\n}\n\nstatic jboolean gtk3_get_pixbuf_data(JNIEnv *env, GdkPixbuf* pixbuf,\n                              jmethodID icon_upcall_method, jobject this) {\n    if (!pixbuf) {\n        return JNI_FALSE;\n    }\n    guchar *pixbuf_data = (*fp_gdk_pixbuf_get_pixels)(pixbuf);\n    if (pixbuf_data) {\n        int row_stride = (*fp_gdk_pixbuf_get_rowstride)(pixbuf);\n        int width = (*fp_gdk_pixbuf_get_width)(pixbuf);\n        int height = (*fp_gdk_pixbuf_get_height)(pixbuf);\n        int bps = (*fp_gdk_pixbuf_get_bits_per_sample)(pixbuf);\n        int channels = (*fp_gdk_pixbuf_get_n_channels)(pixbuf);\n        gboolean alpha = (*fp_gdk_pixbuf_get_has_alpha)(pixbuf);\n\n        jbyteArray data = (*env)->NewByteArray(env, (row_stride * height));\n        JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n\n        (*env)->SetByteArrayRegion(env, data, 0, (row_stride * height),\n                                   (jbyte *)pixbuf_data);\n        (*fp_g_object_unref)(pixbuf);\n\n        /* Call the callback method to create the image on the Java side. */\n        (*env)->CallVoidMethod(env, this, icon_upcall_method, data,\n                width, height, row_stride, bps, channels, alpha);\n        return JNI_TRUE;\n    }\n    return JNI_FALSE;\n}\n\nstatic jboolean gtk3_get_file_icon_data(JNIEnv *env, const char *filename,\n                 GError **error, jmethodID icon_upcall_method, jobject this) {\n    GdkPixbuf* pixbuf = fp_gdk_pixbuf_new_from_file(filename, error);\n    return gtk3_get_pixbuf_data(env, pixbuf, icon_upcall_method, this);\n}\n\nstatic jboolean gtk3_get_icon_data(JNIEnv *env, gint widget_type,\n                              const gchar *stock_id, GtkIconSize size,\n                              GtkTextDirection direction, const char *detail,\n                              jmethodID icon_upcall_method, jobject this) {\n    GdkPixbuf* pixbuf = gtk3_get_stock_icon(widget_type, stock_id, size,\n                                       direction, detail);\n    return gtk3_get_pixbuf_data(env, pixbuf, icon_upcall_method, this);\n}\n\n/*************************************************/\nstatic gint gtk3_get_xthickness(JNIEnv *env, WidgetType widget_type)\n{\n    init_containers();\n\n    gtk3_widget = gtk3_get_widget(widget_type);\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n    if (context) {\n        GtkBorder padding;\n        fp_gtk_style_context_get_padding(context, 0, &padding);\n        return padding.left + 1;\n    }\n    return 0;\n}\n\nstatic gint gtk3_get_ythickness(JNIEnv *env, WidgetType widget_type)\n{\n    init_containers();\n\n    gtk3_widget = gtk3_get_widget(widget_type);\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n    if (context) {\n        GtkBorder padding;\n        fp_gtk_style_context_get_padding(context, 0, &padding);\n        return padding.top + 1;\n    }\n    return 0;\n}\n\n/*************************************************/\nstatic guint8 recode_color(gdouble channel)\n{\n    guint16 result = (guint16)(channel * 65535);\n    if (result < 0) {\n        result = 0;\n    } else if (result > 65535) {\n        result = 65535;\n    }\n    return (guint8)( result >> 8);\n}\n\nstatic GtkStateFlags gtk3_get_state_flags(GtkStateType state_type) {\n    switch (state_type)\n    {\n        case GTK_STATE_NORMAL:\n            return GTK_STATE_FLAG_NORMAL;\n        case GTK_STATE_ACTIVE:\n            return GTK_STATE_FLAG_ACTIVE;\n        case GTK_STATE_PRELIGHT:\n            return GTK_STATE_FLAG_PRELIGHT;\n        case GTK_STATE_SELECTED:\n            return GTK_STATE_FLAG_SELECTED;\n        case GTK_STATE_INSENSITIVE:\n            return GTK_STATE_FLAG_INSENSITIVE;\n        case GTK_STATE_INCONSISTENT:\n            return GTK_STATE_FLAG_INCONSISTENT;\n        case GTK_STATE_FOCUSED:\n            return GTK_STATE_FLAG_FOCUSED;\n    }\n    return 0;\n}\n\n\nstatic void rgb_to_hls (gdouble *r, gdouble *g, gdouble *b) {\n  gdouble min;\n  gdouble max;\n  gdouble red;\n  gdouble green;\n  gdouble blue;\n  gdouble h, l, s;\n  gdouble delta;\n\n  red = *r;\n  green = *g;\n  blue = *b;\n\n  if (red > green)\n    {\n      if (red > blue)\n        max = red;\n      else\n        max = blue;\n\n      if (green < blue)\n        min = green;\n      else\n        min = blue;\n    }\n  else\n    {\n      if (green > blue)\n        max = green;\n      else\n        max = blue;\n\n      if (red < blue)\n        min = red;\n      else\n        min = blue;\n    }\n\n  l = (max + min) / 2;\n  s = 0;\n  h = 0;\n\n  if (max != min)\n    {\n      if (l <= 0.5)\n        s = (max - min) / (max + min);\n      else\n        s = (max - min) / (2 - max - min);\n\n      delta = max -min;\n      if (red == max)\n        h = (green - blue) / delta;\n      else if (green == max)\n        h = 2 + (blue - red) / delta;\n      else if (blue == max)\n        h = 4 + (red - green) / delta;\n\n      h *= 60;\n      if (h < 0.0)\n        h += 360;\n    }\n\n  *r = h;\n  *g = l;\n  *b = s;\n}\n\nstatic void hls_to_rgb (gdouble *h, gdouble *l, gdouble *s)\n{\n  gdouble hue;\n  gdouble lightness;\n  gdouble saturation;\n  gdouble m1, m2;\n  gdouble r, g, b;\n\n  lightness = *l;\n  saturation = *s;\n\n  if (lightness <= 0.5)\n    m2 = lightness * (1 + saturation);\n  else\n    m2 = lightness + saturation - lightness * saturation;\n  m1 = 2 * lightness - m2;\n\n  if (saturation == 0)\n    {\n      *h = lightness;\n      *l = lightness;\n      *s = lightness;\n    }\n  else\n    {\n      hue = *h + 120;\n      while (hue > 360)\n        hue -= 360;\n      while (hue < 0)\n        hue += 360;\n\n      if (hue < 60)\n        r = m1 + (m2 - m1) * hue / 60;\n      else if (hue < 180)\n        r = m2;\n      else if (hue < 240)\n        r = m1 + (m2 - m1) * (240 - hue) / 60;\n      else\n        r = m1;\n\n      hue = *h;\n      while (hue > 360)\n        hue -= 360;\n      while (hue < 0)\n        hue += 360;\n\n      if (hue < 60)\n        g = m1 + (m2 - m1) * hue / 60;\n      else if (hue < 180)\n        g = m2;\n      else if (hue < 240)\n        g = m1 + (m2 - m1) * (240 - hue) / 60;\n      else\n        g = m1;\n\n      hue = *h - 120;\n      while (hue > 360)\n        hue -= 360;\n      while (hue < 0)\n        hue += 360;\n\n      if (hue < 60)\n        b = m1 + (m2 - m1) * hue / 60;\n      else if (hue < 180)\n        b = m2;\n      else if (hue < 240)\n        b = m1 + (m2 - m1) * (240 - hue) / 60;\n      else\n        b = m1;\n\n      *h = r;\n      *l = g;\n      *s = b;\n    }\n}\n\n\n\nstatic void gtk3_style_shade (const GdkRGBA *a, GdkRGBA *b, gdouble k) {\n  gdouble red = a->red;\n  gdouble green = a->green;\n  gdouble blue = a->blue;\n\n  rgb_to_hls (&red, &green, &blue);\n\n  green *= k;\n  if (green > 1.0)\n    green = 1.0;\n  else if (green < 0.0)\n    green = 0.0;\n\n  blue *= k;\n  if (blue > 1.0)\n    blue = 1.0;\n  else if (blue < 0.0)\n    blue = 0.0;\n\n  hls_to_rgb (&red, &green, &blue);\n\n  b->red = red;\n  b->green = green;\n  b->blue = blue;\n}\n\nstatic GdkRGBA gtk3_get_color_for_flags(GtkStyleContext* context,\n                                  GtkStateFlags flags, ColorType color_type) {\n    GdkRGBA c, color;\n\n    switch (color_type)\n    {\n        case FOREGROUND:\n        case TEXT_FOREGROUND:\n            fp_gtk_style_context_get_color(context, flags, &color);\n            break;\n        case BACKGROUND:\n        case TEXT_BACKGROUND:\n            fp_gtk_style_context_get_background_color(context, flags, &color);\n            break;\n        case LIGHT:\n            c = gtk3_get_color_for_flags(context, flags, BACKGROUND);\n            gtk3_style_shade(&c, &color, LIGHTNESS_MULT);\n            break;\n        case DARK:\n            c = gtk3_get_color_for_flags(context, flags, BACKGROUND);\n            gtk3_style_shade (&c, &color, DARKNESS_MULT);\n            break;\n        case MID:\n            {\n                GdkRGBA c1 = gtk3_get_color_for_flags(context, flags, LIGHT);\n                GdkRGBA c2 = gtk3_get_color_for_flags(context, flags, DARK);\n                color.red = (c1.red + c2.red) / 2;\n                color.green = (c1.green + c2.green) / 2;\n                color.blue = (c1.blue + c2.blue) / 2;\n            }\n            break;\n        case FOCUS:\n        case BLACK:\n            color.red = 0;\n            color.green = 0;\n            color.blue = 0;\n            break;\n        case WHITE:\n            color.red = 1;\n            color.green = 1;\n            color.blue = 1;\n            break;\n    }\n    return color;\n}\n\nstatic gint gtk3_get_color_for_state(JNIEnv *env, WidgetType widget_type,\n                              GtkStateType state_type, ColorType color_type)\n{\n\n    gint result = 0;\n    GdkRGBA color;\n\n    GtkStateFlags flags = gtk3_get_state_flags(state_type);\n\n    init_containers();\n\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GtkStyleContext* context = fp_gtk_widget_get_style_context(gtk3_widget);\n\n    if (widget_type == TOOL_TIP) {\n        fp_gtk_style_context_add_class(context, \"tooltip\");\n    }\n    if (widget_type == CHECK_BOX_MENU_ITEM\n     || widget_type == RADIO_BUTTON_MENU_ITEM) {\n        flags &= GTK_STATE_FLAG_NORMAL | GTK_STATE_FLAG_SELECTED\n                  | GTK_STATE_FLAG_INSENSITIVE | GTK_STATE_FLAG_FOCUSED;\n    }\n\n    color = gtk3_get_color_for_flags(context, flags, color_type);\n\n    if (recode_color(color.alpha) == 0) {\n        color = gtk3_get_color_for_flags(\n        fp_gtk_widget_get_style_context(gtk3_get_widget(INTERNAL_FRAME)),\n        0, BACKGROUND);\n    }\n\n    result = recode_color(color.alpha) << 24 | recode_color(color.red) << 16 |\n             recode_color(color.green) << 8 | recode_color(color.blue);\n\n    return result;\n}\n\n/*************************************************/\nstatic jobject create_Boolean(JNIEnv *env, jboolean boolean_value);\nstatic jobject create_Integer(JNIEnv *env, jint int_value);\nstatic jobject create_Long(JNIEnv *env, jlong long_value);\nstatic jobject create_Float(JNIEnv *env, jfloat float_value);\nstatic jobject create_Double(JNIEnv *env, jdouble double_value);\nstatic jobject create_Character(JNIEnv *env, jchar char_value);\nstatic jobject create_Insets(JNIEnv *env, GtkBorder *border);\n\nstatic jobject gtk3_get_class_value(JNIEnv *env, WidgetType widget_type,\n                                                     const char* key)\n{\n    init_containers();\n\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    GValue value = { 0, { { 0 } } };\n\n    GParamSpec* param = (*fp_gtk_widget_class_find_style_property)(\n                                    ((GTypeInstance*)gtk3_widget)->g_class, key);\n    if ( param )\n    {\n        (*fp_g_value_init)( &value, param->value_type );\n        (*fp_gtk_widget_style_get_property)(gtk3_widget, key, &value);\n\n        if ((*fp_g_type_is_a)( param->value_type, G_TYPE_BOOLEAN ))\n        {\n            gboolean val = (*fp_g_value_get_boolean)(&value);\n            return create_Boolean(env, (jboolean)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_CHAR ))\n        {\n            gchar val = (*fp_g_value_get_char)(&value);\n            return create_Character(env, (jchar)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_UCHAR ))\n        {\n            guchar val = (*fp_g_value_get_uchar)(&value);\n            return create_Character(env, (jchar)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_INT ))\n        {\n            gint val = (*fp_g_value_get_int)(&value);\n            return create_Integer(env, (jint)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_UINT ))\n        {\n            guint val = (*fp_g_value_get_uint)(&value);\n                    return create_Integer(env, (jint)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_LONG ))\n        {\n            glong val = (*fp_g_value_get_long)(&value);\n            return create_Long(env, (jlong)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_ULONG ))\n        {\n            gulong val = (*fp_g_value_get_ulong)(&value);\n            return create_Long(env, (jlong)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_INT64 ))\n        {\n            gint64 val = (*fp_g_value_get_int64)(&value);\n            return create_Long(env, (jlong)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_UINT64 ))\n        {\n            guint64 val = (*fp_g_value_get_uint64)(&value);\n            return create_Long(env, (jlong)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_FLOAT ))\n        {\n            gfloat val = (*fp_g_value_get_float)(&value);\n            return create_Float(env, (jfloat)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_DOUBLE ))\n        {\n            gdouble val = (*fp_g_value_get_double)(&value);\n            return create_Double(env, (jdouble)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_ENUM ))\n        {\n            gint val = (*fp_g_value_get_enum)(&value);\n            return create_Integer(env, (jint)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_FLAGS ))\n        {\n            guint val = (*fp_g_value_get_flags)(&value);\n            return create_Integer(env, (jint)val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, G_TYPE_STRING ))\n        {\n            const gchar* val = (*fp_g_value_get_string)(&value);\n\n            /* We suppose that all values come in C locale and\n             * utf-8 representation of a string is the same as\n             * the string itself. If this isn't so we should\n             * use g_convert.\n             */\n            return (*env)->NewStringUTF(env, val);\n        }\n        else if ((*fp_g_type_is_a)( param->value_type, GTK_TYPE_BORDER ))\n        {\n            GtkBorder *border = (GtkBorder*)(*fp_g_value_get_boxed)(&value);\n            return border ? create_Insets(env, border) : NULL;\n        }\n\n        /*      TODO: Other types are not supported yet.*/\n/*        else if((*fp_g_type_is_a)( param->value_type, G_TYPE_PARAM ))\n        {\n            GParamSpec* val = (*fp_g_value_get_param)(&value);\n            printf( \"Param: %p\\n\", val );\n        }\n        else if((*fp_g_type_is_a)( param->value_type, G_TYPE_BOXED ))\n        {\n            gpointer* val = (*fp_g_value_get_boxed)(&value);\n            printf( \"Boxed: %p\\n\", val );\n        }\n        else if((*fp_g_type_is_a)( param->value_type, G_TYPE_POINTER ))\n        {\n            gpointer* val = (*fp_g_value_get_pointer)(&value);\n            printf( \"Pointer: %p\\n\", val );\n        }\n        else if((*fp_g_type_is_a)( param->value_type, G_TYPE_OBJECT ))\n        {\n            GObject* val = (GObject*)(*fp_g_value_get_object)(&value);\n            printf( \"Object: %p\\n\", val );\n        }*/\n    }\n\n    return NULL;\n}\n\nstatic void gtk3_set_range_value(WidgetType widget_type, jdouble value,\n                          jdouble min, jdouble max, jdouble visible)\n{\n    GtkAdjustment *adj;\n\n    gtk3_widget = gtk3_get_widget(widget_type);\n\n    adj = (*fp_gtk_range_get_adjustment)((GtkRange *)gtk3_widget);\n\n    fp_gtk_adjustment_set_value(adj, value);\n    fp_gtk_adjustment_set_lower(adj, min);\n    fp_gtk_adjustment_set_upper(adj, max);\n    fp_gtk_adjustment_set_page_size(adj, visible);\n}\n\n/*************************************************/\nstatic jobject create_Object(JNIEnv *env, jmethodID *cid,\n                             const char* class_name,\n                             const char* signature,\n                             jvalue* value)\n{\n    jclass  class;\n    jobject result;\n\n    class = (*env)->FindClass(env, class_name);\n    if (class == NULL)\n        return NULL; /* can't find/load the class, exception thrown */\n\n    if (*cid == NULL)\n    {\n        *cid = (*env)->GetMethodID(env, class, \"<init>\", signature);\n        if (*cid == NULL)\n        {\n            (*env)->DeleteLocalRef(env, class);\n            return NULL; /* can't find/get the method, exception thrown */\n        }\n    }\n\n    result = (*env)->NewObjectA(env, class, *cid, value);\n\n    (*env)->DeleteLocalRef(env, class);\n    return result;\n}\n\njobject create_Boolean(JNIEnv *env, jboolean boolean_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.z = boolean_value;\n\n    return create_Object(env, &cid, \"java/lang/Boolean\", \"(Z)V\", &value);\n}\n\njobject create_Integer(JNIEnv *env, jint int_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.i = int_value;\n\n    return create_Object(env, &cid, \"java/lang/Integer\", \"(I)V\", &value);\n}\n\njobject create_Long(JNIEnv *env, jlong long_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.j = long_value;\n\n    return create_Object(env, &cid, \"java/lang/Long\", \"(J)V\", &value);\n}\n\njobject create_Float(JNIEnv *env, jfloat float_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.f = float_value;\n\n    return create_Object(env, &cid, \"java/lang/Float\", \"(F)V\", &value);\n}\n\njobject create_Double(JNIEnv *env, jdouble double_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.d = double_value;\n\n    return create_Object(env, &cid, \"java/lang/Double\", \"(D)V\", &value);\n}\n\njobject create_Character(JNIEnv *env, jchar char_value)\n{\n    static jmethodID cid = NULL;\n    jvalue value;\n\n    value.c = char_value;\n\n    return create_Object(env, &cid, \"java/lang/Character\", \"(C)V\", &value);\n}\n\n\njobject create_Insets(JNIEnv *env, GtkBorder *border)\n{\n    static jmethodID cid = NULL;\n    jvalue values[4];\n\n    values[0].i = border->top;\n    values[1].i = border->left;\n    values[2].i = border->bottom;\n    values[3].i = border->right;\n\n    return create_Object(env, &cid, \"java/awt/Insets\", \"(IIII)V\", values);\n}\n\n/*********************************************/\nstatic jstring gtk3_get_pango_font_name(JNIEnv *env, WidgetType widget_type)\n{\n    init_containers();\n\n    gtk3_widget = gtk3_get_widget(widget_type);\n    jstring  result = NULL;\n    GtkStyleContext* context = fp_gtk_widget_get_style_context (gtk3_widget);\n    if (context)\n    {\n        PangoFontDescription* fd = fp_gtk_style_context_get_font(context, 0);\n        gchar* val = (*fp_pango_font_description_to_string)(fd);\n        result = (*env)->NewStringUTF(env, val);\n        (*fp_g_free)( val );\n    }\n\n    return result;\n}\n\n/***********************************************/\nstatic jobject get_string_property(JNIEnv *env, GtkSettings* settings,\n                                                             const gchar* key) {\n    jobject result = NULL;\n    gchar*  strval = NULL;\n\n    (*fp_g_object_get)(settings, key, &strval, NULL);\n    result = (*env)->NewStringUTF(env, strval);\n    (*fp_g_free)(strval);\n\n    return result;\n}\n\nstatic jobject get_integer_property(JNIEnv *env, GtkSettings* settings,\n                                                             const gchar* key) {\n    gint intval = NULL;\n    (*fp_g_object_get)(settings, key, &intval, NULL);\n    return create_Integer(env, intval);\n}\n\nstatic jobject get_boolean_property(JNIEnv *env, GtkSettings* settings,\n                                                             const gchar* key) {\n    gint intval = NULL;\n    (*fp_g_object_get)(settings, key, &intval, NULL);\n    return create_Boolean(env, intval);\n}\n\nstatic jobject gtk3_get_setting(JNIEnv *env, Setting property)\n{\n    GtkSettings* settings = (*fp_gtk_settings_get_default)();\n\n    switch (property)\n    {\n        case GTK_FONT_NAME:\n            return get_string_property(env, settings, \"gtk-font-name\");\n        case GTK_ICON_SIZES:\n            return get_string_property(env, settings, \"gtk-icon-sizes\");\n        case GTK_CURSOR_BLINK:\n            return get_boolean_property(env, settings, \"gtk-cursor-blink\");\n        case GTK_CURSOR_BLINK_TIME:\n            return get_integer_property(env, settings, \"gtk-cursor-blink-time\");\n        case GTK_BUTTON_ORDER:\n\t    return get_boolean_property(env, settings, \"gtk-alternative-button-order\");\n    }\n\n    return NULL;\n}\n\nstatic void transform_detail_string (const gchar *detail,\n                                                     GtkStyleContext *context) {\n  if (!detail)\n    return;\n\n  if (strcmp (detail, \"arrow\") == 0)\n    fp_gtk_style_context_add_class (context, \"arrow\");\n  else if (strcmp (detail, \"button\") == 0)\n    fp_gtk_style_context_add_class (context, \"button\");\n  else if (strcmp (detail, \"buttondefault\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"button\");\n      fp_gtk_style_context_add_class (context, \"default\");\n    }\n  else if (strcmp (detail, \"calendar\") == 0)\n    fp_gtk_style_context_add_class (context, \"calendar\");\n  else if (strcmp (detail, \"cellcheck\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"cell\");\n      fp_gtk_style_context_add_class (context, \"check\");\n    }\n  else if (strcmp (detail, \"cellradio\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"cell\");\n      fp_gtk_style_context_add_class (context, \"radio\");\n    }\n  else if (strcmp (detail, \"checkbutton\") == 0)\n    fp_gtk_style_context_add_class (context, \"check\");\n  else if (strcmp (detail, \"check\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"check\");\n      fp_gtk_style_context_add_class (context, \"menu\");\n    }\n  else if (strcmp (detail, \"radiobutton\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"radio\");\n    }\n  else if (strcmp (detail, \"option\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"radio\");\n      fp_gtk_style_context_add_class (context, \"menu\");\n    }\n  else if (strcmp (detail, \"entry\") == 0 ||\n           strcmp (detail, \"entry_bg\") == 0)\n    fp_gtk_style_context_add_class (context, \"entry\");\n  else if (strcmp (detail, \"expander\") == 0)\n    fp_gtk_style_context_add_class (context, \"expander\");\n  else if (strcmp (detail, \"tooltip\") == 0)\n    fp_gtk_style_context_add_class (context, \"tooltip\");\n  else if (strcmp (detail, \"frame\") == 0)\n    fp_gtk_style_context_add_class (context, \"frame\");\n  else if (strcmp (detail, \"scrolled_window\") == 0)\n    fp_gtk_style_context_add_class (context, \"scrolled-window\");\n  else if (strcmp (detail, \"viewport\") == 0 ||\n           strcmp (detail, \"viewportbin\") == 0)\n    fp_gtk_style_context_add_class (context, \"viewport\");\n  else if (strncmp (detail, \"trough\", 6) == 0)\n    fp_gtk_style_context_add_class (context, \"trough\");\n  else if (strcmp (detail, \"spinbutton\") == 0)\n    fp_gtk_style_context_add_class (context, \"spinbutton\");\n  else if (strcmp (detail, \"spinbutton_up\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"spinbutton\");\n      fp_gtk_style_context_add_class (context, \"button\");\n      fp_gtk_style_context_set_junction_sides (context, GTK_JUNCTION_BOTTOM);\n    }\n  else if (strcmp (detail, \"spinbutton_down\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"spinbutton\");\n      fp_gtk_style_context_add_class (context, \"button\");\n      fp_gtk_style_context_set_junction_sides (context, GTK_JUNCTION_TOP);\n    }\n  else if ((detail[0] == 'h' || detail[0] == 'v') &&\n           strncmp (&detail[1], \"scrollbar_\", 9) == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"button\");\n      fp_gtk_style_context_add_class (context, \"scrollbar\");\n    }\n  else if (strcmp (detail, \"slider\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"slider\");\n      fp_gtk_style_context_add_class (context, \"scrollbar\");\n    }\n  else if (strcmp (detail, \"vscale\") == 0 ||\n           strcmp (detail, \"hscale\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"slider\");\n      fp_gtk_style_context_add_class (context, \"scale\");\n    }\n  else if (strcmp (detail, \"menuitem\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"menuitem\");\n      fp_gtk_style_context_add_class (context, \"menu\");\n    }\n  else if (strcmp (detail, \"menu\") == 0)\n    {\n      fp_gtk_style_context_add_class (context, \"popup\");\n      fp_gtk_style_context_add_class (context, \"menu\");\n    }\n  else if (strcmp (detail, \"accellabel\") == 0)\n    fp_gtk_style_context_add_class (context, \"accelerator\");\n  else if (strcmp (detail, \"menubar\") == 0)\n    fp_gtk_style_context_add_class (context, \"menubar\");\n  else if (strcmp (detail, \"base\") == 0)\n    fp_gtk_style_context_add_class (context, \"background\");\n  else if (strcmp (detail, \"bar\") == 0 ||\n           strcmp (detail, \"progressbar\") == 0)\n    fp_gtk_style_context_add_class (context, \"progressbar\");\n  else if (strcmp (detail, \"toolbar\") == 0)\n    fp_gtk_style_context_add_class (context, \"toolbar\");\n  else if (strcmp (detail, \"handlebox_bin\") == 0)\n    fp_gtk_style_context_add_class (context, \"dock\");\n  else if (strcmp (detail, \"notebook\") == 0)\n    fp_gtk_style_context_add_class (context, \"notebook\");\n  else if (strcmp (detail, \"tab\") == 0)\n  {\n      fp_gtk_style_context_add_class (context, \"notebook\");\n      fp_gtk_style_context_add_region (context, \"tab\", 0);\n  } else if (strcmp (detail, \"paned\") == 0) {\n      fp_gtk_style_context_add_class (context, \"pane-separator\");\n  }\n  else if (fp_g_str_has_prefix (detail, \"cell\"))\n    {\n      GtkRegionFlags row, col;\n      gboolean ruled = FALSE;\n      gchar** tokens;\n      guint i;\n\n      tokens = fp_g_strsplit (detail, \"_\", -1);\n      row = col = 0;\n      i = 0;\n\n      while (tokens[i])\n        {\n          if (strcmp (tokens[i], \"even\") == 0)\n            row |= GTK_REGION_EVEN;\n          else if (strcmp (tokens[i], \"odd\") == 0)\n            row |= GTK_REGION_ODD;\n          else if (strcmp (tokens[i], \"start\") == 0)\n            col |= GTK_REGION_FIRST;\n          else if (strcmp (tokens[i], \"end\") == 0)\n            col |= GTK_REGION_LAST;\n          else if (strcmp (tokens[i], \"ruled\") == 0)\n            ruled = TRUE;\n          else if (strcmp (tokens[i], \"sorted\") == 0)\n            col |= GTK_REGION_SORTED;\n\n          i++;\n        }\n\n      if (!ruled)\n        row &= ~(GTK_REGION_EVEN | GTK_REGION_ODD);\n\n      fp_gtk_style_context_add_class (context, \"cell\");\n      fp_gtk_style_context_add_region (context, \"row\", row);\n      fp_gtk_style_context_add_region (context, \"column\", col);\n\n      fp_g_strfreev (tokens);\n    }\n}\n\nstatic gboolean gtk3_get_drawable_data(JNIEnv *env, jintArray pixelArray,\n     int x, jint y, jint width, jint height, jint jwidth, int dx, int dy,\n                                                                   jint scale) {\n    GdkPixbuf *pixbuf;\n    jint *ary;\n\n    GdkWindow *root = (*fp_gdk_get_default_root_window)();\n    pixbuf = (*fp_gdk_pixbuf_get_from_drawable)(root, x, y, width, height);\n    if (pixbuf && scale != 1) {\n        GdkPixbuf *scaledPixbuf;\n        x /= scale;\n        y /= scale;\n        width /= scale;\n        height /= scale;\n        dx /= scale;\n        dy /= scale;\n        scaledPixbuf = (*fp_gdk_pixbuf_scale_simple)(pixbuf, width, height,\n                                                     GDK_INTERP_BILINEAR);\n        (*fp_g_object_unref)(pixbuf);\n        pixbuf = scaledPixbuf;\n    }\n\n    if (pixbuf) {\n        int nchan = (*fp_gdk_pixbuf_get_n_channels)(pixbuf);\n        int stride = (*fp_gdk_pixbuf_get_rowstride)(pixbuf);\n        if ((*fp_gdk_pixbuf_get_width)(pixbuf) == width\n                && (*fp_gdk_pixbuf_get_height)(pixbuf) == height\n                && (*fp_gdk_pixbuf_get_bits_per_sample)(pixbuf) == 8\n                && (*fp_gdk_pixbuf_get_colorspace)(pixbuf) == GDK_COLORSPACE_RGB\n                && nchan >= 3\n                ) {\n            guchar *p, *pix = (*fp_gdk_pixbuf_get_pixels)(pixbuf);\n            ary = (*env)->GetPrimitiveArrayCritical(env, pixelArray, NULL);\n            if (ary) {\n                jint _x, _y;\n                int index;\n                for (_y = 0; _y < height; _y++) {\n                    for (_x = 0; _x < width; _x++) {\n                        p = pix + _y * stride + _x * nchan;\n\n                        index = (_y + dy) * jwidth + (_x + dx);\n                        ary[index] = 0xff000000\n                                        | (p[0] << 16)\n                                        | (p[1] << 8)\n                                        | (p[2]);\n\n                    }\n                }\n                (*env)->ReleasePrimitiveArrayCritical(env, pixelArray, ary, 0);\n            }\n        }\n        (*fp_g_object_unref)(pixbuf);\n    }\n    return JNI_FALSE;\n}\n\nstatic GdkWindow* gtk3_get_window(void *widget) {\n    return fp_gtk_widget_get_window((GtkWidget*)widget);\n}\n\nstatic void gtk3_init(GtkApi* gtk) {\n    gtk->version = GTK_3;\n\n    gtk->show_uri_load = &gtk3_show_uri_load;\n    gtk->unload = &gtk3_unload;\n    gtk->flush_event_loop = &flush_gtk_event_loop;\n    gtk->gtk_check_version = fp_gtk_check_version;\n    gtk->get_setting = &gtk3_get_setting;\n\n    gtk->paint_arrow = &gtk3_paint_arrow;\n    gtk->paint_box = &gtk3_paint_box;\n    gtk->paint_box_gap = &gtk3_paint_box_gap;\n    gtk->paint_expander = &gtk3_paint_expander;\n    gtk->paint_extension = &gtk3_paint_extension;\n    gtk->paint_flat_box = &gtk3_paint_flat_box;\n    gtk->paint_focus = &gtk3_paint_focus;\n    gtk->paint_handle = &gtk3_paint_handle;\n    gtk->paint_hline = &gtk3_paint_hline;\n    gtk->paint_vline = &gtk3_paint_vline;\n    gtk->paint_option = &gtk3_paint_option;\n    gtk->paint_shadow = &gtk3_paint_shadow;\n    gtk->paint_slider = &gtk3_paint_slider;\n    gtk->paint_background = &gtk3_paint_background;\n    gtk->paint_check = &gtk3_paint_check;\n    gtk->set_range_value = &gtk3_set_range_value;\n\n    gtk->init_painting = &gtk3_init_painting;\n    gtk->copy_image = &gtk3_copy_image;\n\n    gtk->get_xthickness = &gtk3_get_xthickness;\n    gtk->get_ythickness = &gtk3_get_ythickness;\n    gtk->get_color_for_state = &gtk3_get_color_for_state;\n    gtk->get_class_value = &gtk3_get_class_value;\n\n    gtk->get_pango_font_name = &gtk3_get_pango_font_name;\n    gtk->get_icon_data = &gtk3_get_icon_data;\n    gtk->get_file_icon_data = &gtk3_get_file_icon_data;\n    gtk->gdk_threads_enter = fp_gdk_threads_enter;\n    gtk->gdk_threads_leave = fp_gdk_threads_leave;\n    gtk->gtk_show_uri = fp_gtk_show_uri;\n    gtk->get_drawable_data = &gtk3_get_drawable_data;\n    gtk->g_free = fp_g_free;\n\n    gtk->gtk_file_chooser_get_filename = fp_gtk_file_chooser_get_filename;\n    gtk->gtk_widget_hide = fp_gtk_widget_hide;\n    gtk->gtk_main_quit = fp_gtk_main_quit;\n    gtk->gtk_file_chooser_dialog_new = fp_gtk_file_chooser_dialog_new;\n    gtk->gtk_file_chooser_set_current_folder =\n                          fp_gtk_file_chooser_set_current_folder;\n    gtk->gtk_file_chooser_set_filename = fp_gtk_file_chooser_set_filename;\n    gtk->gtk_file_chooser_set_current_name =\n                          fp_gtk_file_chooser_set_current_name;\n    gtk->gtk_file_filter_add_custom = fp_gtk_file_filter_add_custom;\n    gtk->gtk_file_chooser_set_filter = fp_gtk_file_chooser_set_filter;\n    gtk->gtk_file_chooser_get_type = fp_gtk_file_chooser_get_type;\n    gtk->gtk_file_filter_new = fp_gtk_file_filter_new;\n    gtk->gtk_file_chooser_set_do_overwrite_confirmation =\n                          fp_gtk_file_chooser_set_do_overwrite_confirmation;\n    gtk->gtk_file_chooser_set_select_multiple =\n                          fp_gtk_file_chooser_set_select_multiple;\n    gtk->gtk_file_chooser_get_current_folder =\n                          fp_gtk_file_chooser_get_current_folder;\n    gtk->gtk_file_chooser_get_filenames = fp_gtk_file_chooser_get_filenames;\n    gtk->gtk_g_slist_length = fp_gtk_g_slist_length;\n    gtk->g_signal_connect_data = fp_g_signal_connect_data;\n    gtk->gtk_widget_show = fp_gtk_widget_show;\n    gtk->gtk_main = fp_gtk_main;\n    gtk->gtk_main_level = fp_gtk_main_level;\n    gtk->g_path_get_dirname = fp_g_path_get_dirname;\n    gtk->gdk_x11_drawable_get_xid = fp_gdk_x11_drawable_get_xid;\n    gtk->gtk_widget_destroy = fp_gtk_widget_destroy;\n    gtk->gtk_window_present = fp_gtk_window_present;\n    gtk->gtk_window_move = fp_gtk_window_move;\n    gtk->gtk_window_resize = fp_gtk_window_resize;\n    gtk->get_window = &gtk3_get_window;\n\n    gtk->g_object_unref = fp_g_object_unref;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/awt/CUPSfuncs.c": "/*\n * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <jni.h>\n#include <jni_util.h>\n#include <jvm_md.h>\n#include <dlfcn.h>\n#include <cups/cups.h>\n#include <cups/ppd.h>\n\n//#define CUPS_DEBUG\n\n#ifdef CUPS_DEBUG\n#define DPRINTF(x, y) fprintf(stderr, x, y);\n#else\n#define DPRINTF(x, y)\n#endif\n\ntypedef const char* (*fn_cupsServer)(void);\ntypedef int (*fn_ippPort)(void);\ntypedef http_t* (*fn_httpConnect)(const char *, int);\ntypedef void (*fn_httpClose)(http_t *);\ntypedef char* (*fn_cupsGetPPD)(const char *);\ntypedef ppd_file_t* (*fn_ppdOpenFile)(const char *);\ntypedef void (*fn_ppdClose)(ppd_file_t *);\ntypedef ppd_option_t* (*fn_ppdFindOption)(ppd_file_t *, const char *);\ntypedef ppd_size_t* (*fn_ppdPageSize)(ppd_file_t *, char *);\n\nfn_cupsServer j2d_cupsServer;\nfn_ippPort j2d_ippPort;\nfn_httpConnect j2d_httpConnect;\nfn_httpClose j2d_httpClose;\nfn_cupsGetPPD j2d_cupsGetPPD;\nfn_ppdOpenFile j2d_ppdOpenFile;\nfn_ppdClose j2d_ppdClose;\nfn_ppdFindOption j2d_ppdFindOption;\nfn_ppdPageSize j2d_ppdPageSize;\n\n\n/*\n * Initialize library functions.\n * // REMIND : move tab , add dlClose before return\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_print_CUPSPrinter_initIDs(JNIEnv *env,\n                                         jobject printObj) {\n  void *handle = dlopen(VERSIONED_JNI_LIB_NAME(\"cups\", \"2\"),\n                        RTLD_LAZY | RTLD_GLOBAL);\n\n  if (handle == NULL) {\n    handle = dlopen(JNI_LIB_NAME(\"cups\"), RTLD_LAZY | RTLD_GLOBAL);\n    if (handle == NULL) {\n      return JNI_FALSE;\n    }\n  }\n\n  j2d_cupsServer = (fn_cupsServer)dlsym(handle, \"cupsServer\");\n  if (j2d_cupsServer == NULL) {\n    dlclose(handle);\n    return JNI_FALSE;\n  }\n\n  j2d_ippPort = (fn_ippPort)dlsym(handle, \"ippPort\");\n  if (j2d_ippPort == NULL) {\n    dlclose(handle);\n    return JNI_FALSE;\n  }\n\n  j2d_httpConnect = (fn_httpConnect)dlsym(handle, \"httpConnect\");\n  if (j2d_httpConnect == NULL) {\n    dlclose(handle);\n    return JNI_FALSE;\n  }\n\n  j2d_httpClose = (fn_httpClose)dlsym(handle, \"httpClose\");\n  if (j2d_httpClose == NULL) {\n    dlclose(handle);\n    return JNI_FALSE;\n  }\n\n  j2d_cupsGetPPD = (fn_cupsGetPPD)dlsym(handle, \"cupsGetPPD\");\n  if (j2d_cupsGetPPD == NULL) {\n    dlclose(handle);\n    return JNI_FALSE;\n  }\n\n  j2d_ppdOpenFile = (fn_ppdOpenFile)dlsym(handle, \"ppdOpenFile\");\n  if (j2d_ppdOpenFile == NULL) {\n    dlclose(handle);\n    return JNI_FALSE;\n\n  }\n\n  j2d_ppdClose = (fn_ppdClose)dlsym(handle, \"ppdClose\");\n  if (j2d_ppdClose == NULL) {\n    dlclose(handle);\n    return JNI_FALSE;\n\n  }\n\n  j2d_ppdFindOption = (fn_ppdFindOption)dlsym(handle, \"ppdFindOption\");\n  if (j2d_ppdFindOption == NULL) {\n    dlclose(handle);\n    return JNI_FALSE;\n  }\n\n  j2d_ppdPageSize = (fn_ppdPageSize)dlsym(handle, \"ppdPageSize\");\n  if (j2d_ppdPageSize == NULL) {\n    dlclose(handle);\n    return JNI_FALSE;\n  }\n\n  return JNI_TRUE;\n}\n\n/*\n * Gets CUPS server name.\n *\n */\nJNIEXPORT jstring JNICALL\nJava_sun_print_CUPSPrinter_getCupsServer(JNIEnv *env,\n                                         jobject printObj)\n{\n    jstring cServer = NULL;\n    const char* server = j2d_cupsServer();\n    if (server != NULL) {\n        // Is this a local domain socket?\n        if (strncmp(server, \"/\", 1) == 0) {\n            cServer = JNU_NewStringPlatform(env, \"localhost\");\n        } else {\n            cServer = JNU_NewStringPlatform(env, server);\n        }\n    }\n    return cServer;\n}\n\n/*\n * Gets CUPS port name.\n *\n */\nJNIEXPORT jint JNICALL\nJava_sun_print_CUPSPrinter_getCupsPort(JNIEnv *env,\n                                         jobject printObj)\n{\n    int port = j2d_ippPort();\n    return (jint) port;\n}\n\n\n/*\n * Checks if connection can be made to the server.\n *\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_print_CUPSPrinter_canConnect(JNIEnv *env,\n                                      jobject printObj,\n                                      jstring server,\n                                      jint port)\n{\n    const char *serverName;\n    serverName = (*env)->GetStringUTFChars(env, server, NULL);\n    if (serverName != NULL) {\n        http_t *http = j2d_httpConnect(serverName, (int)port);\n        (*env)->ReleaseStringUTFChars(env, server, serverName);\n        if (http != NULL) {\n            j2d_httpClose(http);\n            return JNI_TRUE;\n        }\n    }\n    return JNI_FALSE;\n}\n\n\n/*\n * Returns list of media: pages + trays\n */\nJNIEXPORT jobjectArray JNICALL\nJava_sun_print_CUPSPrinter_getMedia(JNIEnv *env,\n                                         jobject printObj,\n                                         jstring printer)\n{\n    ppd_file_t *ppd;\n    ppd_option_t *optionTray, *optionPage;\n    ppd_choice_t *choice;\n    const char *name;\n    const char *filename;\n    int i, nTrays=0, nPages=0, nTotal=0;\n    jstring utf_str;\n    jclass cls;\n    jobjectArray nameArray = NULL;\n\n    name = (*env)->GetStringUTFChars(env, printer, NULL);\n    if (name == NULL) {\n        (*env)->ExceptionClear(env);\n        JNU_ThrowOutOfMemoryError(env, \"Could not create printer name\");\n        return NULL;\n    }\n\n    // NOTE: cupsGetPPD returns a pointer to a filename of a temporary file.\n    // unlink() must be caled to remove the file when finished using it.\n    filename = j2d_cupsGetPPD(name);\n    (*env)->ReleaseStringUTFChars(env, printer, name);\n    CHECK_NULL_RETURN(filename, NULL);\n\n    cls = (*env)->FindClass(env, \"java/lang/String\");\n    CHECK_NULL_RETURN(cls, NULL);\n\n    if ((ppd = j2d_ppdOpenFile(filename)) == NULL) {\n        unlink(filename);\n        DPRINTF(\"CUPSfuncs::unable to open PPD  %s\\n\", filename);\n        return NULL;\n    }\n\n    optionPage = j2d_ppdFindOption(ppd, \"PageSize\");\n    if (optionPage != NULL) {\n        nPages = optionPage->num_choices;\n    }\n\n    optionTray = j2d_ppdFindOption(ppd, \"InputSlot\");\n    if (optionTray != NULL) {\n        nTrays = optionTray->num_choices;\n    }\n\n    if ((nTotal = (nPages+nTrays) *2) > 0) {\n        nameArray = (*env)->NewObjectArray(env, nTotal, cls, NULL);\n        if (nameArray == NULL) {\n            unlink(filename);\n            j2d_ppdClose(ppd);\n            DPRINTF(\"CUPSfuncs::bad alloc new array\\n\", \"\")\n            (*env)->ExceptionClear(env);\n            JNU_ThrowOutOfMemoryError(env, \"OutOfMemoryError\");\n            return NULL;\n        }\n\n        for (i = 0; optionPage!=NULL && i<nPages; i++) {\n            choice = (optionPage->choices)+i;\n            utf_str = JNU_NewStringPlatform(env, choice->text);\n            if (utf_str == NULL) {\n                unlink(filename);\n                j2d_ppdClose(ppd);\n                DPRINTF(\"CUPSfuncs::bad alloc new string ->text\\n\", \"\")\n                JNU_ThrowOutOfMemoryError(env, \"OutOfMemoryError\");\n                return NULL;\n            }\n            (*env)->SetObjectArrayElement(env, nameArray, i*2, utf_str);\n            (*env)->DeleteLocalRef(env, utf_str);\n            utf_str = JNU_NewStringPlatform(env, choice->choice);\n            if (utf_str == NULL) {\n                unlink(filename);\n                j2d_ppdClose(ppd);\n                DPRINTF(\"CUPSfuncs::bad alloc new string ->choice\\n\", \"\")\n                JNU_ThrowOutOfMemoryError(env, \"OutOfMemoryError\");\n                return NULL;\n            }\n            (*env)->SetObjectArrayElement(env, nameArray, i*2+1, utf_str);\n            (*env)->DeleteLocalRef(env, utf_str);\n        }\n\n        for (i = 0; optionTray!=NULL && i<nTrays; i++) {\n            choice = (optionTray->choices)+i;\n            utf_str = JNU_NewStringPlatform(env, choice->text);\n            if (utf_str == NULL) {\n                unlink(filename);\n                j2d_ppdClose(ppd);\n                DPRINTF(\"CUPSfuncs::bad alloc new string text\\n\", \"\")\n                JNU_ThrowOutOfMemoryError(env, \"OutOfMemoryError\");\n                return NULL;\n            }\n            (*env)->SetObjectArrayElement(env, nameArray,\n                                          (nPages+i)*2, utf_str);\n            (*env)->DeleteLocalRef(env, utf_str);\n            utf_str = JNU_NewStringPlatform(env, choice->choice);\n            if (utf_str == NULL) {\n                unlink(filename);\n                j2d_ppdClose(ppd);\n                DPRINTF(\"CUPSfuncs::bad alloc new string choice\\n\", \"\")\n                JNU_ThrowOutOfMemoryError(env, \"OutOfMemoryError\");\n                return NULL;\n            }\n            (*env)->SetObjectArrayElement(env, nameArray,\n                                          (nPages+i)*2+1, utf_str);\n            (*env)->DeleteLocalRef(env, utf_str);\n        }\n    }\n    j2d_ppdClose(ppd);\n    unlink(filename);\n    return nameArray;\n}\n\n\n/*\n * Returns list of page sizes and imageable area.\n */\nJNIEXPORT jfloatArray JNICALL\nJava_sun_print_CUPSPrinter_getPageSizes(JNIEnv *env,\n                                         jobject printObj,\n                                         jstring printer)\n{\n    ppd_file_t *ppd;\n    ppd_option_t *option;\n    ppd_choice_t *choice;\n    ppd_size_t *size;\n\n    const char *name = (*env)->GetStringUTFChars(env, printer, NULL);\n    if (name == NULL) {\n        (*env)->ExceptionClear(env);\n        JNU_ThrowOutOfMemoryError(env, \"Could not create printer name\");\n        return NULL;\n    }\n    const char *filename;\n    int i;\n    jobjectArray sizeArray = NULL;\n    jfloat *dims;\n\n    // NOTE: cupsGetPPD returns a pointer to a filename of a temporary file.\n    // unlink() must be called to remove the file after using it.\n    filename = j2d_cupsGetPPD(name);\n    (*env)->ReleaseStringUTFChars(env, printer, name);\n    CHECK_NULL_RETURN(filename, NULL);\n    if ((ppd = j2d_ppdOpenFile(filename)) == NULL) {\n        unlink(filename);\n        DPRINTF(\"unable to open PPD  %s\\n\", filename)\n        return NULL;\n    }\n    option = j2d_ppdFindOption(ppd, \"PageSize\");\n    if (option != NULL && option->num_choices > 0) {\n        // create array of dimensions - (num_choices * 6)\n        //to cover length & height\n        DPRINTF( \"CUPSfuncs::option->num_choices %d\\n\", option->num_choices)\n        // +1 is for storing the default media index\n        sizeArray = (*env)->NewFloatArray(env, option->num_choices*6+1);\n        if (sizeArray == NULL) {\n            unlink(filename);\n            j2d_ppdClose(ppd);\n            DPRINTF(\"CUPSfuncs::bad alloc new float array\\n\", \"\")\n            (*env)->ExceptionClear(env);\n            JNU_ThrowOutOfMemoryError(env, \"OutOfMemoryError\");\n            return NULL;\n        }\n\n        dims = (*env)->GetFloatArrayElements(env, sizeArray, NULL);\n        if (dims == NULL) {\n            unlink(filename);\n            j2d_ppdClose(ppd);\n            (*env)->ExceptionClear(env);\n            JNU_ThrowOutOfMemoryError(env, \"Could not create printer name\");\n            return NULL;\n        }\n        for (i = 0; i<option->num_choices; i++) {\n            choice = (option->choices)+i;\n            // get the index of the default page\n            if (!strcmp(choice->choice, option->defchoice)) {\n                dims[option->num_choices*6] = (float)i;\n            }\n            size = j2d_ppdPageSize(ppd, choice->choice);\n            if (size != NULL) {\n                // paper width and height\n                dims[i*6] = size->width;\n                dims[(i*6)+1] = size->length;\n                // paper printable area\n                dims[(i*6)+2] = size->left;\n                dims[(i*6)+3] = size->top;\n                dims[(i*6)+4] = size->right;\n                dims[(i*6)+5] = size->bottom;\n            }\n        }\n\n        (*env)->ReleaseFloatArrayElements(env, sizeArray, dims, 0);\n    }\n\n    j2d_ppdClose(ppd);\n    unlink(filename);\n    return sizeArray;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/awt/awt_UNIXToolkit.c": "/*\n * Copyright (c) 2004, 2016, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <dlfcn.h>\n\n#include <jni.h>\n#include <sizecalc.h>\n#include \"sun_awt_UNIXToolkit.h\"\n\n#ifndef HEADLESS\n#include \"awt.h\"\n#include \"gtk_interface.h\"\n#endif /* !HEADLESS */\n\n\nstatic jclass this_class = NULL;\nstatic jmethodID icon_upcall_method = NULL;\n\n\n/*\n * Class:     sun_awt_UNIXToolkit\n * Method:    check_gtk\n * Signature: (I)Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_UNIXToolkit_check_1gtk(JNIEnv *env, jclass klass, jint version) {\n#ifndef HEADLESS\n    return (jboolean)gtk_check_version(version);\n#else\n    return JNI_FALSE;\n#endif /* !HEADLESS */\n}\n\n\n/*\n * Class:     sun_awt_UNIXToolkit\n * Method:    load_gtk\n * Signature: (I)Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_UNIXToolkit_load_1gtk(JNIEnv *env, jclass klass, jint version,\n                                                             jboolean verbose) {\n#ifndef HEADLESS\n    return (jboolean)gtk_load(env, version, verbose);\n#else\n    return JNI_FALSE;\n#endif /* !HEADLESS */\n}\n\n\n/*\n * Class:     sun_awt_UNIXToolkit\n * Method:    unload_gtk\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_UNIXToolkit_unload_1gtk(JNIEnv *env, jclass klass)\n{\n#ifndef HEADLESS\n    return (jboolean)gtk->unload();\n#else\n    return JNI_FALSE;\n#endif /* !HEADLESS */\n}\n\njboolean init_method(JNIEnv *env, jobject this)\n{\n    if (this_class == NULL) {\n        this_class = (*env)->NewGlobalRef(env,\n                                          (*env)->GetObjectClass(env, this));\n        icon_upcall_method = (*env)->GetMethodID(env, this_class,\n                                 \"loadIconCallback\", \"([BIIIIIZ)V\");\n        CHECK_NULL_RETURN(icon_upcall_method, JNI_FALSE);\n    }\n    return JNI_TRUE;\n}\n\n/*\n * Class:     sun_awt_UNIXToolkit\n * Method:    load_gtk_icon\n * Signature: (Ljava/lang/String)Z\n *\n * This method assumes that GTK libs are present.\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_UNIXToolkit_load_1gtk_1icon(JNIEnv *env, jobject this,\n        jstring filename)\n{\n#ifndef HEADLESS\n    int len;\n    char *filename_str = NULL;\n    GError **error = NULL;\n\n    if (filename == NULL)\n    {\n        return JNI_FALSE;\n    }\n\n    len = (*env)->GetStringUTFLength(env, filename);\n    filename_str = (char *)SAFE_SIZE_ARRAY_ALLOC(malloc,\n            sizeof(char), len + 1);\n    if (filename_str == NULL) {\n        JNU_ThrowOutOfMemoryError(env, \"OutOfMemoryError\");\n        return JNI_FALSE;\n    }\n    if (!init_method(env, this) ) {\n        return JNI_FALSE;\n    }\n    (*env)->GetStringUTFRegion(env, filename, 0, len, filename_str);\n    jboolean result = gtk->get_file_icon_data(env, filename_str, error,\n                                            icon_upcall_method, this);\n\n    /* Release the strings we've allocated. */\n    free(filename_str);\n\n    return result;\n#else /* HEADLESS */\n    return JNI_FALSE;\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_UNIXToolkit\n * Method:    load_stock_icon\n * Signature: (ILjava/lang/String;IILjava/lang/String;)Z\n *\n * This method assumes that GTK libs are present.\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_UNIXToolkit_load_1stock_1icon(JNIEnv *env, jobject this,\n        jint widget_type, jstring stock_id, jint icon_size,\n        jint text_direction, jstring detail)\n{\n#ifndef HEADLESS\n    int len;\n    char *stock_id_str = NULL;\n    char *detail_str = NULL;\n\n    if (stock_id == NULL)\n    {\n        return JNI_FALSE;\n    }\n\n    len = (*env)->GetStringUTFLength(env, stock_id);\n    stock_id_str = (char *)SAFE_SIZE_ARRAY_ALLOC(malloc,\n            sizeof(char), len + 1);\n    if (stock_id_str == NULL) {\n        JNU_ThrowOutOfMemoryError(env, \"OutOfMemoryError\");\n        return JNI_FALSE;\n    }\n    (*env)->GetStringUTFRegion(env, stock_id, 0, len, stock_id_str);\n\n    /* Detail isn't required so check for NULL. */\n    if (detail != NULL)\n    {\n        len = (*env)->GetStringUTFLength(env, detail);\n        detail_str = (char *)SAFE_SIZE_ARRAY_ALLOC(malloc,\n                sizeof(char), len + 1);\n        if (detail_str == NULL) {\n            JNU_ThrowOutOfMemoryError(env, \"OutOfMemoryError\");\n            return JNI_FALSE;\n        }\n        (*env)->GetStringUTFRegion(env, detail, 0, len, detail_str);\n    }\n\n    if (!init_method(env, this) ) {\n        return JNI_FALSE;\n    }\n    jboolean result = gtk->get_icon_data(env, widget_type, stock_id_str,\n                  icon_size, text_direction, detail_str,\n                  icon_upcall_method, this);\n\n    /* Release the strings we've allocated. */\n    free(stock_id_str);\n    if (detail_str != NULL)\n    {\n        free(detail_str);\n    }\n    return result;\n#else /* HEADLESS */\n    return JNI_FALSE;\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_UNIXToolkit\n * Method:    nativeSync\n * Signature: ()V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_UNIXToolkit_nativeSync(JNIEnv *env, jobject this)\n{\n#ifndef HEADLESS\n    AWT_LOCK();\n    XSync(awt_display, False);\n    AWT_UNLOCK();\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_SunToolkit\n * Method:    closeSplashScreen\n * Signature: ()V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_SunToolkit_closeSplashScreen(JNIEnv *env, jclass cls)\n{\n    typedef void (*SplashClose_t)();\n    SplashClose_t splashClose;\n    void* hSplashLib = dlopen(0, RTLD_LAZY);\n    if (!hSplashLib) {\n        return;\n    }\n    splashClose = (SplashClose_t)dlsym(hSplashLib,\n        \"SplashClose\");\n    if (splashClose) {\n        splashClose();\n    }\n    dlclose(hSplashLib);\n}\n\n/*\n * Class:     sun_awt_UNIXToolkit\n * Method:    gtkCheckVersionImpl\n * Signature: (III)Ljava/lang/String;\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_UNIXToolkit_gtkCheckVersionImpl(JNIEnv *env, jobject this,\n        jint major, jint minor, jint micro)\n{\n    char *ret;\n\n    ret = gtk->gtk_check_version(major, minor, micro);\n    if (ret == NULL) {\n        return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Class:     sun_awt_UNIXToolkit\n * Method:    get_gtk_version\n * Signature: ()I\n */\nJNIEXPORT jint JNICALL\nJava_sun_awt_UNIXToolkit_get_1gtk_1version(JNIEnv *env, jclass klass)\n{\n#ifndef HEADLESS\n    return gtk ? gtk->version : GTK_ANY;\n#else\n    return GTK_ANY;\n#endif /* !HEADLESS */\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/awt/awt_GraphicsEnv.c": "/*\n * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"jni_util.h\"\n#include \"awt_p.h\"\n#include \"awt.h\"\n#include \"color.h\"\n#include <java_awt_DisplayMode.h>\n#include <sun_awt_X11GraphicsEnvironment.h>\n#include <sun_awt_X11GraphicsDevice.h>\n#include <sun_awt_X11GraphicsConfig.h>\n#ifndef HEADLESS\n#include <X11/extensions/Xdbe.h>\n#include <X11/XKBlib.h>\n#include \"Xrandr.h\"\n#include \"GLXGraphicsConfig.h\"\n#endif /* !HEADLESS */\n\n#include <jni.h>\n#include <jni_util.h>\n#include <jvm.h>\n#include <jvm_md.h>\n#include <jlong.h>\n\n#include <stdlib.h>\n\n#include \"awt_GraphicsEnv.h\"\n#include \"awt_util.h\"\n#include \"gdefs.h\"\n#include <dlfcn.h>\n#include \"Trace.h\"\n\n#ifdef NETSCAPE\n#include <signal.h>\nextern int awt_init_xt;\n#endif\n\n#ifndef HEADLESS\n\nint awt_numScreens;     /* Xinerama-aware number of screens */\n\nAwtScreenDataPtr x11Screens;\n\n/*\n * Set in initDisplay() to indicate whether we should attempt to initialize\n * GLX for the default configuration.\n */\nstatic jboolean glxRequested = JNI_FALSE;\n\n#endif /* !HEADLESS */\n\n#ifdef HEADLESS\n#define Display void\n#endif /* HEADLESS */\n\nDisplay *awt_display;\n\njclass tkClass = NULL;\njmethodID awtLockMID = NULL;\njmethodID awtUnlockMID = NULL;\njmethodID awtWaitMID = NULL;\njmethodID awtNotifyMID = NULL;\njmethodID awtNotifyAllMID = NULL;\njboolean awtLockInited = JNI_FALSE;\n\n/** Convenience macro for loading the lock-related method IDs. */\n#define GET_STATIC_METHOD(klass, method_id, method_name, method_sig) \\\n    do { \\\n        method_id = (*env)->GetStaticMethodID(env, klass, \\\n                                              method_name, method_sig); \\\n        if (method_id == NULL) return NULL; \\\n    } while (0)\n\nstruct X11GraphicsConfigIDs x11GraphicsConfigIDs;\nstruct X11GraphicsDeviceIDs x11GraphicsDeviceIDs;\n\n#ifndef HEADLESS\nint awtCreateX11Colormap(AwtGraphicsConfigDataPtr adata);\n#endif /* HEADLESS */\n\nstatic char *x11GraphicsConfigClassName = \"sun/awt/X11GraphicsConfig\";\n\n/* AWT and Xinerama\n *\n * As of fix 4356756, AWT is Xinerama-aware.  X11GraphicsDevices are created for\n * each screen of a Xinerama setup, though X11 itself still only sees a single\n * display.\n * In many places where we talk to X11, a xinawareScreen variable is used to\n * pass the correct Display value, depending on the circumstances (a single\n * X display, multiple X displays, or a single X display with multiple\n * Xinerama screens).\n *\n * Solaris and Linux differ in the functions used to access Xinerama-related\n * data.  This is in part because at this time, the X consortium has not\n * finalized the \"official\" Xinerama API.  Once this spec is available, and\n * both OSes are conformant, one code base should be sufficient for Xinerama\n * operation on both OSes.  Until then, some of the Xinerama-related code\n * is ifdef'd appropriately.  -bchristi, 7/12/01\n */\n\n#define MAXFRAMEBUFFERS 16\n#if defined(__linux__) || defined(MACOSX)\ntypedef struct {\n   int   screen_number;\n   short x_org;\n   short y_org;\n   short width;\n   short height;\n} XineramaScreenInfo;\n\ntypedef XineramaScreenInfo* XineramaQueryScreensFunc(Display*, int*);\n\n#else /* SOLARIS */\ntypedef Status XineramaGetInfoFunc(Display* display, int screen_number,\n         XRectangle* framebuffer_rects, unsigned char* framebuffer_hints,\n         int* num_framebuffers);\ntypedef Status XineramaGetCenterHintFunc(Display* display, int screen_number,\n                                         int* x, int* y);\n\nXineramaGetCenterHintFunc* XineramaSolarisCenterFunc = NULL;\n#endif\n\nBool usingXinerama = False;\nXRectangle fbrects[MAXFRAMEBUFFERS];\n\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsConfig_initIDs (JNIEnv *env, jclass cls)\n{\n    x11GraphicsConfigIDs.aData = NULL;\n    x11GraphicsConfigIDs.bitsPerPixel = NULL;\n    x11GraphicsConfigIDs.screen = NULL;\n\n    x11GraphicsConfigIDs.aData = (*env)->GetFieldID (env, cls, \"aData\", \"J\");\n    CHECK_NULL(x11GraphicsConfigIDs.aData);\n    x11GraphicsConfigIDs.bitsPerPixel = (*env)->GetFieldID (env, cls, \"bitsPerPixel\", \"I\");\n    CHECK_NULL(x11GraphicsConfigIDs.bitsPerPixel);\n    x11GraphicsConfigIDs.screen = (*env)->GetFieldID (env, cls, \"screen\", \"Lsun/awt/X11GraphicsDevice;\");\n    CHECK_NULL(x11GraphicsConfigIDs.screen);\n\n    if (x11GraphicsConfigIDs.aData == NULL ||\n            x11GraphicsConfigIDs.bitsPerPixel == NULL ||\n        x11GraphicsConfigIDs.screen == NULL) {\n\n            JNU_ThrowNoSuchFieldError(env, \"Can't find a field\");\n            return;\n        }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsDevice_initIDs (JNIEnv *env, jclass cls)\n{\n    x11GraphicsDeviceIDs.screen = NULL;\n    x11GraphicsDeviceIDs.screen = (*env)->GetFieldID (env, cls, \"screen\", \"I\");\n    DASSERT(x11GraphicsDeviceIDs.screen);\n}\n\n#ifndef HEADLESS\n\n/*\n * XIOErrorHandler\n */\nstatic int xioerror_handler(Display *disp)\n{\n    if (awtLockInited) {\n        if (errno == EPIPE) {\n            jio_fprintf(stderr, \"X connection to %s host broken (explicit kill or server shutdown)\\n\", XDisplayName(NULL));\n        }\n        /*SignalError(lockedee->lastpc, lockedee, \"fp/ade/gui/GUIException\", \"I/O error\"); */\n    }\n    return 0;\n}\n\nstatic AwtGraphicsConfigDataPtr\nfindWithTemplate(XVisualInfo *vinfo,\n                 long mask)\n{\n\n    XVisualInfo *visualList;\n    XColor color;\n    AwtGraphicsConfigDataPtr defaultConfig;\n    int visualsMatched, i;\n\n    visualList = XGetVisualInfo(awt_display,\n                                mask, vinfo, &visualsMatched);\n    if (visualList) {\n        defaultConfig = ZALLOC(_AwtGraphicsConfigData);\n        for (i = 0; i < visualsMatched; i++) {\n            memcpy(&defaultConfig->awt_visInfo, &visualList[i], sizeof(XVisualInfo));\n            defaultConfig->awt_depth = visualList[i].depth;\n\n            /* we can't use awtJNI_CreateColorData here, because it'll pull,\n               SystemColor, which in turn will cause toolkit to be reinitialized */\n            if (awtCreateX11Colormap(defaultConfig)) {\n                /* Allocate white and black pixels for this visual */\n                color.flags = DoRed | DoGreen | DoBlue;\n                color.red = color.green = color.blue = 0x0000;\n                XAllocColor(awt_display, defaultConfig->awt_cmap, &color);\n                x11Screens[visualList[i].screen].blackpixel = color.pixel;\n                color.flags = DoRed | DoGreen | DoBlue;\n                color.red = color.green = color.blue = 0xffff;\n                XAllocColor(awt_display, defaultConfig->awt_cmap, &color);\n                x11Screens[visualList[i].screen].whitepixel = color.pixel;\n\n                XFree(visualList);\n                return defaultConfig;\n            }\n        }\n        XFree(visualList);\n        free((void *)defaultConfig);\n    }\n    return NULL;\n}\n\n/* default config is based on X11 screen.  All Xinerama screens of that X11\n   screen will have the same default config */\n/* Need more notes about which fields of the structure are based on the X\n   screen, and which are based on the Xinerama screen */\nstatic AwtGraphicsConfigDataPtr\nmakeDefaultConfig(JNIEnv *env, int screen) {\n\n    AwtGraphicsConfigDataPtr defaultConfig;\n    int xinawareScreen = 0;\n    VisualID forcedVisualID = 0, defaultVisualID;\n    char *forcedVisualStr;\n    XVisualInfo vinfo;\n    long mask;\n\n    xinawareScreen = usingXinerama ? 0 : screen;\n    defaultVisualID =\n        XVisualIDFromVisual(DefaultVisual(awt_display, xinawareScreen));\n\n    memset(&vinfo, 0, sizeof(XVisualInfo));\n    vinfo.screen = xinawareScreen;\n\n    if ((forcedVisualStr = getenv(\"FORCEDEFVIS\"))) {\n        mask = VisualIDMask | VisualScreenMask;\n        if (sscanf(forcedVisualStr, \"%lx\", &forcedVisualID) > 0 &&\n            forcedVisualID > 0)\n        {\n            vinfo.visualid = forcedVisualID;\n        } else {\n            vinfo.visualid = defaultVisualID;\n        }\n    } else {\n        VisualID bestGLXVisualID;\n        if (glxRequested &&\n            (bestGLXVisualID = GLXGC_FindBestVisual(env, xinawareScreen)) > 0)\n        {\n            /* we've found the best visual for use with GLX, so use it */\n            vinfo.visualid = bestGLXVisualID;\n            mask = VisualIDMask | VisualScreenMask;\n        } else {\n            /* otherwise, continue looking for the best X11 visual */\n            vinfo.depth = 24;\n            vinfo.class = TrueColor;\n            mask = VisualDepthMask | VisualScreenMask | VisualClassMask;\n        }\n    }\n\n    /* try the best, or forced visual */\n    defaultConfig = findWithTemplate(&vinfo, mask);\n    if (defaultConfig) {\n        return defaultConfig;\n    }\n\n    /* try the default visual */\n    vinfo.visualid = defaultVisualID;\n    mask = VisualIDMask | VisualScreenMask;\n    defaultConfig = findWithTemplate(&vinfo, mask);\n    if (defaultConfig) {\n        return defaultConfig;\n    }\n\n    /* try any TrueColor */\n    vinfo.class = TrueColor;\n    mask = VisualScreenMask | VisualClassMask;\n    defaultConfig = findWithTemplate(&vinfo, mask);\n    if (defaultConfig) {\n        return defaultConfig;\n    }\n\n    /* try 8-bit PseudoColor */\n    vinfo.depth = 8;\n    vinfo.class = PseudoColor;\n    mask = VisualDepthMask | VisualScreenMask | VisualClassMask;\n    defaultConfig = findWithTemplate(&vinfo, mask);\n    if (defaultConfig) {\n        return defaultConfig;\n    }\n\n    /* try any 8-bit */\n    vinfo.depth = 8;\n    mask = VisualDepthMask | VisualScreenMask;\n    defaultConfig = findWithTemplate(&vinfo, mask);\n    if (defaultConfig) {\n        return defaultConfig;\n    }\n\n    /* we tried everything, give up */\n    JNU_ThrowInternalError(env, \"Can't find supported visual\");\n    XCloseDisplay(awt_display);\n    awt_display = NULL;\n    return NULL;\n}\n\nstatic void\ngetAllConfigs (JNIEnv *env, int screen, AwtScreenDataPtr screenDataPtr) {\n\n    int i;\n    int n8p=0, n12p=0, n8s=0, n8gs=0, n8sg=0, n1sg=0, nTrue=0;\n    int nConfig;\n    XVisualInfo *pVI8p, *pVI12p, *pVI8s, *pVITrue, *pVI8gs,\n                *pVI8sg, *pVI1sg = NULL, viTmp;\n    AwtGraphicsConfigDataPtr *graphicsConfigs;\n    AwtGraphicsConfigDataPtr defaultConfig;\n    int ind;\n    char errmsg[128];\n    int xinawareScreen;\n    void* xrenderLibHandle = NULL;\n    XRenderFindVisualFormatFunc* xrenderFindVisualFormat = NULL;\n    int major_opcode, first_event, first_error;\n\n    if (usingXinerama) {\n        xinawareScreen = 0;\n    }\n    else {\n        xinawareScreen = screen;\n    }\n\n    AWT_LOCK ();\n\n    viTmp.screen = xinawareScreen;\n\n    viTmp.depth = 8;\n    viTmp.class = PseudoColor;\n    viTmp.colormap_size = 256;\n    pVI8p = XGetVisualInfo (awt_display,\n                            VisualDepthMask | VisualClassMask |\n                            VisualColormapSizeMask | VisualScreenMask,\n                            &viTmp, &n8p);\n\n    viTmp.depth = 12;\n    viTmp.class = PseudoColor;\n    viTmp.colormap_size = 4096;\n    pVI12p = XGetVisualInfo (awt_display,\n                             VisualDepthMask | VisualClassMask |\n                             VisualColormapSizeMask | VisualScreenMask,\n                             &viTmp, &n12p);\n\n    viTmp.class = TrueColor;\n    pVITrue = XGetVisualInfo (awt_display,\n                              VisualClassMask |\n                              VisualScreenMask,\n                              &viTmp, &nTrue);\n\n    viTmp.depth = 8;\n    viTmp.class = StaticColor;\n    pVI8s = XGetVisualInfo (awt_display, VisualDepthMask | VisualClassMask |\n                            VisualScreenMask, &viTmp, &n8s);\n\n    viTmp.depth = 8;\n    viTmp.class = GrayScale;\n    viTmp.colormap_size = 256;\n    pVI8gs = XGetVisualInfo (awt_display,\n                             VisualDepthMask | VisualClassMask |\n                             VisualColormapSizeMask | VisualScreenMask,\n                             &viTmp, &n8gs);\n    viTmp.depth = 8;\n    viTmp.class = StaticGray;\n    viTmp.colormap_size = 256;\n    pVI8sg = XGetVisualInfo (awt_display,\n                             VisualDepthMask | VisualClassMask |\n                             VisualColormapSizeMask | VisualScreenMask,\n                             &viTmp, &n8sg);\n\n/* REMIND.. remove when we have support for the color classes below */\n/*     viTmp.depth = 1; */\n/*     viTmp.class = StaticGray; */\n/*     pVI1sg = XGetVisualInfo (awt_display, VisualDepthMask | VisualClassMask, */\n/*                              viTmp, &n1sg); */\n\n    nConfig = n8p + n12p + n8s + n8gs + n8sg  + n1sg + nTrue + 1;\n    graphicsConfigs = (AwtGraphicsConfigDataPtr *)\n        calloc(nConfig, sizeof(AwtGraphicsConfigDataPtr));\n    if (graphicsConfigs == NULL) {\n        JNU_ThrowOutOfMemoryError((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2),\n                                  NULL);\n        AWT_UNLOCK();\n        return;\n    }\n\n    if (screenDataPtr->defaultConfig == NULL) {\n        /*\n         * After a display change event, the default config field will have\n         * been reset, so we need to recreate the default config here.\n         */\n        screenDataPtr->defaultConfig = makeDefaultConfig(env, screen);\n    }\n\n    defaultConfig = screenDataPtr->defaultConfig;\n    graphicsConfigs[0] = defaultConfig;\n    nConfig = 1; /* reserve index 0 for default config */\n\n    // Only use the RENDER extension if it is available on the X server\n    if (XQueryExtension(awt_display, \"RENDER\",\n                        &major_opcode, &first_event, &first_error))\n    {\n        xrenderLibHandle = dlopen(\"libXrender.so.1\", RTLD_LAZY | RTLD_GLOBAL);\n\n#ifdef MACOSX\n#define XRENDER_LIB \"/usr/X11/lib/libXrender.dylib\"\n#else\n#define XRENDER_LIB \"libXrender.so\"\n#endif\n\n        if (xrenderLibHandle == NULL) {\n            xrenderLibHandle = dlopen(XRENDER_LIB,\n                                      RTLD_LAZY | RTLD_GLOBAL);\n        }\n\n#ifndef __linux__ /* SOLARIS */\n        if (xrenderLibHandle == NULL) {\n            xrenderLibHandle = dlopen(\"/usr/sfw/lib/libXrender.so.1\",\n                                      RTLD_LAZY | RTLD_GLOBAL);\n        }\n#endif\n\n        if (xrenderLibHandle != NULL) {\n            xrenderFindVisualFormat =\n                (XRenderFindVisualFormatFunc*)dlsym(xrenderLibHandle,\n                                                    \"XRenderFindVisualFormat\");\n        }\n    }\n\n    for (i = 0; i < nTrue; i++) {\n        if (XVisualIDFromVisual(pVITrue[i].visual) ==\n            XVisualIDFromVisual(defaultConfig->awt_visInfo.visual) ||\n            pVITrue[i].depth == 12) {\n            /* Skip the non-supported 12-bit TrueColor visual */\n            continue;\n        } else {\n            ind = nConfig++;\n        }\n        graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);\n        graphicsConfigs [ind]->awt_depth = pVITrue [i].depth;\n        memcpy (&graphicsConfigs [ind]->awt_visInfo, &pVITrue [i],\n                sizeof (XVisualInfo));\n       if (xrenderFindVisualFormat != NULL) {\n            XRenderPictFormat *format = xrenderFindVisualFormat (awt_display,\n                    pVITrue [i].visual);\n            if (format &&\n                format->type == PictTypeDirect &&\n                format->direct.alphaMask)\n            {\n                graphicsConfigs [ind]->isTranslucencySupported = 1;\n                memcpy(&graphicsConfigs [ind]->renderPictFormat, format,\n                        sizeof(*format));\n            }\n        }\n    }\n\n    if (xrenderLibHandle != NULL) {\n        dlclose(xrenderLibHandle);\n        xrenderLibHandle = NULL;\n    }\n\n    for (i = 0; i < n8p; i++) {\n        if (XVisualIDFromVisual(pVI8p[i].visual) ==\n            XVisualIDFromVisual(defaultConfig->awt_visInfo.visual)) {\n            continue;\n        } else {\n            ind = nConfig++;\n        }\n        graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);\n        graphicsConfigs [ind]->awt_depth = pVI8p [i].depth;\n        memcpy (&graphicsConfigs [ind]->awt_visInfo, &pVI8p [i],\n                sizeof (XVisualInfo));\n    }\n\n    for (i = 0; i < n12p; i++) {\n        if (XVisualIDFromVisual(pVI12p[i].visual) ==\n            XVisualIDFromVisual(defaultConfig->awt_visInfo.visual)) {\n            continue;\n        } else {\n            ind = nConfig++;\n        }\n        graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);\n        graphicsConfigs [ind]->awt_depth = pVI12p [i].depth;\n        memcpy (&graphicsConfigs [ind]->awt_visInfo, &pVI12p [i],\n                sizeof (XVisualInfo));\n    }\n\n    for (i = 0; i < n8s; i++) {\n        if (XVisualIDFromVisual(pVI8s[i].visual) ==\n            XVisualIDFromVisual(defaultConfig->awt_visInfo.visual)) {\n            continue;\n        } else {\n            ind = nConfig++;\n        }\n        graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);\n        graphicsConfigs [ind]->awt_depth = pVI8s [i].depth;\n        memcpy (&graphicsConfigs [ind]->awt_visInfo, &pVI8s [i],\n                sizeof (XVisualInfo));\n    }\n\n    for (i = 0; i < n8gs; i++) {\n        if (XVisualIDFromVisual(pVI8gs[i].visual) ==\n            XVisualIDFromVisual(defaultConfig->awt_visInfo.visual)) {\n            continue;\n        } else {\n            ind = nConfig++;\n        }\n        graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);\n        graphicsConfigs [ind]->awt_depth = pVI8gs [i].depth;\n        memcpy (&graphicsConfigs [ind]->awt_visInfo, &pVI8gs [i],\n                sizeof (XVisualInfo));\n    }\n\n    for (i = 0; i < n8sg; i++) {\n        if (XVisualIDFromVisual(pVI8sg[i].visual) ==\n            XVisualIDFromVisual(defaultConfig->awt_visInfo.visual)) {\n            continue;\n        } else {\n            ind = nConfig++;\n        }\n        graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);\n        graphicsConfigs [ind]->awt_depth = pVI8sg [i].depth;\n        memcpy (&graphicsConfigs [ind]->awt_visInfo, &pVI8sg [i],\n                sizeof (XVisualInfo));\n    }\n\n    for (i = 0; i < n1sg; i++) {\n        if (XVisualIDFromVisual(pVI1sg[i].visual) ==\n            XVisualIDFromVisual(defaultConfig->awt_visInfo.visual)) {\n            continue;\n        } else {\n            ind = nConfig++;\n        }\n        graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);\n        graphicsConfigs [ind]->awt_depth = pVI1sg [i].depth;\n        memcpy (&graphicsConfigs [ind]->awt_visInfo, &pVI1sg [i],\n                sizeof (XVisualInfo));\n    }\n\n    if (n8p != 0)\n       XFree (pVI8p);\n    if (n12p != 0)\n       XFree (pVI12p);\n    if (n8s != 0)\n       XFree (pVI8s);\n    if (n8gs != 0)\n       XFree (pVI8gs);\n    if (n8sg != 0)\n       XFree (pVI8sg);\n    if (n1sg != 0)\n       XFree (pVI1sg);\n\n    screenDataPtr->numConfigs = nConfig;\n    screenDataPtr->configs = graphicsConfigs;\n\n    AWT_UNLOCK ();\n}\n\n#ifndef HEADLESS\n#if defined(__linux__) || defined(MACOSX)\nstatic void xinerama_init_linux()\n{\n    void* libHandle = NULL;\n    int32_t locNumScr = 0;\n    XineramaScreenInfo *xinInfo;\n    char* XineramaQueryScreensName = \"XineramaQueryScreens\";\n    XineramaQueryScreensFunc* XineramaQueryScreens = NULL;\n\n    /* load library */\n    libHandle = dlopen(VERSIONED_JNI_LIB_NAME(\"Xinerama\", \"1\"),\n                       RTLD_LAZY | RTLD_GLOBAL);\n    if (libHandle == NULL) {\n        libHandle = dlopen(JNI_LIB_NAME(\"Xinerama\"), RTLD_LAZY | RTLD_GLOBAL);\n    }\n    if (libHandle != NULL) {\n        XineramaQueryScreens = (XineramaQueryScreensFunc*)\n            dlsym(libHandle, XineramaQueryScreensName);\n\n        if (XineramaQueryScreens != NULL) {\n            DTRACE_PRINTLN(\"calling XineramaQueryScreens func on Linux\");\n            xinInfo = (*XineramaQueryScreens)(awt_display, &locNumScr);\n            if (xinInfo != NULL && locNumScr > XScreenCount(awt_display)) {\n                int32_t idx;\n                DTRACE_PRINTLN(\"Enabling Xinerama support\");\n                usingXinerama = True;\n                /* set global number of screens */\n                DTRACE_PRINTLN1(\" num screens = %i\\n\", locNumScr);\n                awt_numScreens = locNumScr;\n\n                /* stuff values into fbrects */\n                for (idx = 0; idx < awt_numScreens; idx++) {\n                    DASSERT(xinInfo[idx].screen_number == idx);\n\n                    fbrects[idx].width = xinInfo[idx].width;\n                    fbrects[idx].height = xinInfo[idx].height;\n                    fbrects[idx].x = xinInfo[idx].x_org;\n                    fbrects[idx].y = xinInfo[idx].y_org;\n                }\n            } else {\n                DTRACE_PRINTLN(\"calling XineramaQueryScreens didn't work\");\n            }\n        } else {\n            DTRACE_PRINTLN(\"couldn't load XineramaQueryScreens symbol\");\n        }\n        dlclose(libHandle);\n    } else {\n        DTRACE_PRINTLN1(\"\\ncouldn't open shared library: %s\\n\", dlerror());\n    }\n}\n#endif\n#if !defined(__linux__) && !defined(MACOSX) /* Solaris */\nstatic void xinerama_init_solaris()\n{\n    void* libHandle = NULL;\n    unsigned char fbhints[MAXFRAMEBUFFERS];\n    int32_t locNumScr = 0;\n    /* load and run XineramaGetInfo */\n    char* XineramaGetInfoName = \"XineramaGetInfo\";\n    char* XineramaGetCenterHintName = \"XineramaGetCenterHint\";\n    XineramaGetInfoFunc* XineramaSolarisFunc = NULL;\n\n    /* load library */\n    libHandle = dlopen(JNI_LIB_NAME(\"Xext\"), RTLD_LAZY | RTLD_GLOBAL);\n    if (libHandle != NULL) {\n        XineramaSolarisFunc = (XineramaGetInfoFunc*)dlsym(libHandle, XineramaGetInfoName);\n        XineramaSolarisCenterFunc =\n            (XineramaGetCenterHintFunc*)dlsym(libHandle, XineramaGetCenterHintName);\n\n        if (XineramaSolarisFunc != NULL) {\n            DTRACE_PRINTLN(\"calling XineramaGetInfo func on Solaris\");\n            if ((*XineramaSolarisFunc)(awt_display, 0, &fbrects[0],\n                                       &fbhints[0], &locNumScr) != 0 &&\n                locNumScr > XScreenCount(awt_display))\n            {\n                DTRACE_PRINTLN(\"Enabling Xinerama support\");\n                usingXinerama = True;\n                /* set global number of screens */\n                DTRACE_PRINTLN1(\" num screens = %i\\n\", locNumScr);\n                awt_numScreens = locNumScr;\n            } else {\n                DTRACE_PRINTLN(\"calling XineramaGetInfo didn't work\");\n            }\n        } else {\n            DTRACE_PRINTLN(\"couldn't load XineramaGetInfo symbol\");\n        }\n        dlclose(libHandle);\n    } else {\n        DTRACE_PRINTLN1(\"\\ncouldn't open shared library: %s\\n\", dlerror());\n    }\n}\n#endif\n\n/*\n * Checks if Xinerama is running and perform Xinerama-related\n * platform dependent initialization.\n */\nstatic void xineramaInit(void) {\n    char* XinExtName = \"XINERAMA\";\n    int32_t major_opcode, first_event, first_error;\n    Bool gotXinExt = False;\n\n    gotXinExt = XQueryExtension(awt_display, XinExtName, &major_opcode,\n                                &first_event, &first_error);\n\n    if (!gotXinExt) {\n        DTRACE_PRINTLN(\"Xinerama extension is not available\");\n        return;\n    }\n\n    DTRACE_PRINTLN(\"Xinerama extension is available\");\n#if defined(__linux__) || defined(MACOSX)\n    xinerama_init_linux();\n#else /* Solaris */\n    xinerama_init_solaris();\n#endif /* __linux__ || MACOSX */\n}\n#endif /* HEADLESS */\n\nDisplay *\nawt_init_Display(JNIEnv *env, jobject this)\n{\n    jclass klass;\n    Display *dpy;\n    char errmsg[128];\n    int i;\n#ifdef NETSCAPE\n    sigset_t alarm_set, oldset;\n#endif\n\n    if (awt_display) {\n        return awt_display;\n    }\n\n#ifdef NETSCAPE\n    /* Disable interrupts during XtOpenDisplay to avoid bugs in unix os select\n       code: some unix systems don't implement SA_RESTART properly and\n       because of this, select returns with EINTR. Most implementations of\n       gethostbyname don't cope with EINTR properly and as a result we get\n       stuck (forever) in the gethostbyname code\n    */\n    sigemptyset(&alarm_set);\n    sigaddset(&alarm_set, SIGALRM);\n    sigprocmask(SIG_BLOCK, &alarm_set, &oldset);\n#endif\n\n    /* Load AWT lock-related methods in SunToolkit */\n    klass = (*env)->FindClass(env, \"sun/awt/SunToolkit\");\n    if (klass == NULL) return NULL;\n    GET_STATIC_METHOD(klass, awtLockMID, \"awtLock\", \"()V\");\n    GET_STATIC_METHOD(klass, awtUnlockMID, \"awtUnlock\", \"()V\");\n    GET_STATIC_METHOD(klass, awtWaitMID, \"awtLockWait\", \"(J)V\");\n    GET_STATIC_METHOD(klass, awtNotifyMID, \"awtLockNotify\", \"()V\");\n    GET_STATIC_METHOD(klass, awtNotifyAllMID, \"awtLockNotifyAll\", \"()V\");\n    tkClass = (*env)->NewGlobalRef(env, klass);\n    awtLockInited = JNI_TRUE;\n\n    if (getenv(\"_AWT_IGNORE_XKB\") != NULL &&\n        strlen(getenv(\"_AWT_IGNORE_XKB\")) > 0) {\n        if (XkbIgnoreExtension(True)) {\n            printf(\"Ignoring XKB.\\n\");\n        }\n    }\n\n    dpy = awt_display = XOpenDisplay(NULL);\n#ifdef NETSCAPE\n    sigprocmask(SIG_SETMASK, &oldset, NULL);\n#endif\n    if (!dpy) {\n        jio_snprintf(errmsg,\n                     sizeof(errmsg),\n                     \"Can't connect to X11 window server using '%s' as the value of the DISPLAY variable.\",\n                     (getenv(\"DISPLAY\") == NULL) ? \":0.0\" : getenv(\"DISPLAY\"));\n        JNU_ThrowByName(env, \"java/awt/AWTError\", errmsg);\n        return NULL;\n    }\n\n    XSetIOErrorHandler(xioerror_handler);\n    JNU_CallStaticMethodByName(env, NULL, \"sun/awt/X11/XErrorHandlerUtil\", \"init\", \"(J)V\",\n        ptr_to_jlong(awt_display));\n    JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n\n    /* set awt_numScreens, and whether or not we're using Xinerama */\n    xineramaInit();\n\n    if (!usingXinerama) {\n        awt_numScreens =  XScreenCount(awt_display);\n    }\n\n    DTRACE_PRINTLN1(\"allocating %i screens\\n\", awt_numScreens);\n    /* Allocate screen data structure array */\n    x11Screens = calloc(awt_numScreens, sizeof(AwtScreenData));\n    if (x11Screens == NULL) {\n        JNU_ThrowOutOfMemoryError((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2),\n                                  NULL);\n        return NULL;\n    }\n\n    for (i = 0; i < awt_numScreens; i++) {\n        if (usingXinerama) {\n            /* All Xinerama screens use the same X11 root for now */\n            x11Screens[i].root = RootWindow(awt_display, 0);\n        }\n        else {\n            x11Screens[i].root = RootWindow(awt_display, i);\n        }\n        x11Screens[i].defaultConfig = makeDefaultConfig(env, i);\n        JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n    }\n\n    return dpy;\n}\n#endif /* !HEADLESS */\n\n/*\n * Class:     sun_awt_X11GraphicsEnvironment\n * Method:    getDefaultScreenNum\n * Signature: ()I\n */\nJNIEXPORT jint JNICALL\nJava_sun_awt_X11GraphicsEnvironment_getDefaultScreenNum(\nJNIEnv *env, jobject this)\n{\n#ifdef HEADLESS\n    return (jint)0;\n#else\n    return DefaultScreen(awt_display);\n#endif /* !HEADLESS */\n}\n\n#ifndef HEADLESS\nstatic void ensureConfigsInited(JNIEnv* env, int screen) {\n   if (x11Screens[screen].numConfigs == 0) {\n       if (env == NULL) {\n           env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);\n       }\n       getAllConfigs (env, screen, &(x11Screens[screen]));\n    }\n}\n#endif\n\n#ifdef HEADLESS\nvoid* getDefaultConfig(int screen) {\n    return NULL;\n}\n#else\nAwtGraphicsConfigDataPtr\ngetDefaultConfig(int screen) {\n    ensureConfigsInited(NULL, screen);\n    return x11Screens[screen].defaultConfig;\n}\n\nAwtScreenDataPtr\ngetScreenData(int screen) {\n    return &(x11Screens[screen]);\n}\n#endif /* !HEADLESS */\n\n/*\n * Class:     sun_awt_X11GraphicsEnvironment\n * Method:    initDisplay\n * Signature: (Z)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsEnvironment_initDisplay(JNIEnv *env, jobject this,\n                                                jboolean glxReq)\n{\n#ifndef HEADLESS\n    glxRequested = glxReq;\n    (void) awt_init_Display(env, this);\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsEnvironment\n * Method:    initGLX\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_X11GraphicsEnvironment_initGLX(JNIEnv *env, jclass x11ge)\n{\n#ifndef HEADLESS\n    jboolean glxAvailable;\n\n    AWT_LOCK();\n    glxAvailable = GLXGC_IsGLXAvailable();\n    AWT_UNLOCK();\n\n    return glxAvailable;\n#else\n    return JNI_FALSE;\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsEnvironment\n * Method:    getNumScreens\n * Signature: ()I\n */\nJNIEXPORT jint JNICALL\nJava_sun_awt_X11GraphicsEnvironment_getNumScreens(JNIEnv *env, jobject this)\n{\n#ifdef HEADLESS\n    return (jint)0;\n#else\n    return awt_numScreens;\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    getDisplay\n * Signature: ()J\n */\nJNIEXPORT jlong JNICALL\nJava_sun_awt_X11GraphicsDevice_getDisplay(JNIEnv *env, jobject this)\n{\n#ifdef HEADLESS\n    return NULL;\n#else\n    return ptr_to_jlong(awt_display);\n#endif /* !HEADLESS */\n}\n\n#ifdef MITSHM\n\nstatic jint canUseShmExt = UNSET_MITSHM;\nstatic jint canUseShmExtPixmaps = UNSET_MITSHM;\nstatic jboolean xshmAttachFailed = JNI_FALSE;\n\nint XShmAttachXErrHandler(Display *display, XErrorEvent *xerr) {\n    if (xerr->minor_code == X_ShmAttach) {\n        xshmAttachFailed = JNI_TRUE;\n    }\n    return 0;\n}\njboolean isXShmAttachFailed() {\n    return xshmAttachFailed;\n}\nvoid resetXShmAttachFailed() {\n    xshmAttachFailed = JNI_FALSE;\n}\n\nextern int mitShmPermissionMask;\n\nvoid TryInitMITShm(JNIEnv *env, jint *shmExt, jint *shmPixmaps) {\n    XShmSegmentInfo shminfo;\n    int XShmMajor, XShmMinor;\n    int a, b, c;\n\n    AWT_LOCK();\n    if (canUseShmExt != UNSET_MITSHM) {\n        *shmExt = canUseShmExt;\n        *shmPixmaps = canUseShmExtPixmaps;\n        AWT_UNLOCK();\n        return;\n    }\n\n    *shmExt = canUseShmExt = CANT_USE_MITSHM;\n    *shmPixmaps = canUseShmExtPixmaps = CANT_USE_MITSHM;\n\n    if (awt_display == (Display *)NULL) {\n        AWT_NOFLUSH_UNLOCK();\n        return;\n    }\n\n    /**\n     * XShmQueryExtension returns False in remote server case.\n     * Unfortunately it also returns True in ssh case, so\n     * we need to test that we can actually do XShmAttach.\n     */\n    if (XShmQueryExtension(awt_display)) {\n        shminfo.shmid = shmget(IPC_PRIVATE, 0x10000,\n                               IPC_CREAT|mitShmPermissionMask);\n        if (shminfo.shmid < 0) {\n            AWT_UNLOCK();\n            J2dRlsTraceLn1(J2D_TRACE_ERROR,\n                           \"TryInitMITShm: shmget has failed: %s\",\n                           strerror(errno));\n            return;\n        }\n        shminfo.shmaddr = (char *) shmat(shminfo.shmid, 0, 0);\n        if (shminfo.shmaddr == ((char *) -1)) {\n            shmctl(shminfo.shmid, IPC_RMID, 0);\n            AWT_UNLOCK();\n            J2dRlsTraceLn1(J2D_TRACE_ERROR,\n                           \"TryInitMITShm: shmat has failed: %s\",\n                           strerror(errno));\n            return;\n        }\n        shminfo.readOnly = True;\n\n        resetXShmAttachFailed();\n        /**\n         * The J2DXErrHandler handler will set xshmAttachFailed\n         * to JNI_TRUE if any Shm error has occured.\n         */\n        EXEC_WITH_XERROR_HANDLER(XShmAttachXErrHandler,\n                                 XShmAttach(awt_display, &shminfo));\n\n        /**\n         * Get rid of the id now to reduce chances of leaking\n         * system resources.\n         */\n        shmctl(shminfo.shmid, IPC_RMID, 0);\n\n        if (isXShmAttachFailed() == JNI_FALSE) {\n            canUseShmExt = CAN_USE_MITSHM;\n            /* check if we can use shared pixmaps */\n            XShmQueryVersion(awt_display, &XShmMajor, &XShmMinor,\n                             (Bool*)&canUseShmExtPixmaps);\n            canUseShmExtPixmaps = canUseShmExtPixmaps &&\n                (XShmPixmapFormat(awt_display) == ZPixmap);\n            XShmDetach(awt_display, &shminfo);\n        }\n        shmdt(shminfo.shmaddr);\n        *shmExt = canUseShmExt;\n        *shmPixmaps = canUseShmExtPixmaps;\n    }\n    AWT_UNLOCK();\n}\n#endif /* MITSHM */\n\n/*\n * Class:     sun_awt_X11GraphicsEnvironment\n * Method:    checkShmExt\n * Signature: ()I\n */\nJNIEXPORT jint JNICALL\nJava_sun_awt_X11GraphicsEnvironment_checkShmExt(JNIEnv *env, jobject this)\n{\n\n    int shmExt = NOEXT_MITSHM, shmPixmaps;\n#ifdef MITSHM\n    TryInitMITShm(env, &shmExt, &shmPixmaps);\n#endif\n    return shmExt;\n}\n\n/*\n * Class:     sun_awt_X11GraphicsEnvironment\n * Method:    getDisplayString\n * Signature: ()Ljava/lang/String\n */\nJNIEXPORT jstring JNICALL\nJava_sun_awt_X11GraphicsEnvironment_getDisplayString\n  (JNIEnv *env, jobject this)\n{\n#ifdef HEADLESS\n    return (jstring)NULL;\n#else\n    return (*env)->NewStringUTF(env, DisplayString(awt_display));\n#endif /* HEADLESS */\n}\n\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    getNumConfigs\n * Signature: ()I\n */\nJNIEXPORT jint JNICALL\nJava_sun_awt_X11GraphicsDevice_getNumConfigs(\nJNIEnv *env, jobject this, jint screen)\n{\n#ifdef HEADLESS\n    return (jint)0;\n#else\n    ensureConfigsInited(env, screen);\n    return x11Screens[screen].numConfigs;\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    getConfigVisualId\n * Signature: (I)I\n */\nJNIEXPORT jint JNICALL\nJava_sun_awt_X11GraphicsDevice_getConfigVisualId(\nJNIEnv *env, jobject this, jint index, jint screen)\n{\n#ifdef HEADLESS\n    return (jint)0;\n#else\n    int visNum;\n\n    ensureConfigsInited(env, screen);\n    if (index == 0) {\n        return ((jint)x11Screens[screen].defaultConfig->awt_visInfo.visualid);\n    } else {\n        return ((jint)x11Screens[screen].configs[index]->awt_visInfo.visualid);\n    }\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    getConfigDepth\n * Signature: (I)I\n */\nJNIEXPORT jint JNICALL\nJava_sun_awt_X11GraphicsDevice_getConfigDepth(\nJNIEnv *env, jobject this, jint index, jint screen)\n{\n#ifdef HEADLESS\n    return (jint)0;\n#else\n    int visNum;\n\n    ensureConfigsInited(env, screen);\n    if (index == 0) {\n        return ((jint)x11Screens[screen].defaultConfig->awt_visInfo.depth);\n    } else {\n        return ((jint)x11Screens[screen].configs[index]->awt_visInfo.depth);\n    }\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    getConfigColormap\n * Signature: (I)I\n */\nJNIEXPORT jint JNICALL\nJava_sun_awt_X11GraphicsDevice_getConfigColormap(\nJNIEnv *env, jobject this, jint index, jint screen)\n{\n#ifdef HEADLESS\n    return (jint)0;\n#else\n    int visNum;\n\n    ensureConfigsInited(env, screen);\n    if (index == 0) {\n        return ((jint)x11Screens[screen].defaultConfig->awt_cmap);\n    } else {\n        return ((jint)x11Screens[screen].configs[index]->awt_cmap);\n    }\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    resetNativeData\n * Signature: (I)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsDevice_resetNativeData\n    (JNIEnv *env, jclass x11gd, jint screen)\n{\n#ifndef HEADLESS\n    /*\n     * Reset references to the various configs; the actual native config data\n     * will be free'd later by the Disposer mechanism when the Java-level\n     * X11GraphicsConfig objects go away.  By setting these values to NULL,\n     * we ensure that they will be reinitialized as necessary (for example,\n     * see the getNumConfigs() method).\n     */\n    if (x11Screens[screen].configs) {\n        free(x11Screens[screen].configs);\n        x11Screens[screen].configs = NULL;\n    }\n    x11Screens[screen].defaultConfig = NULL;\n    x11Screens[screen].numConfigs = 0;\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    dispose\n * Signature: (J)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsConfig_dispose\n    (JNIEnv *env, jclass x11gc, jlong configData)\n{\n#ifndef HEADLESS\n    AwtGraphicsConfigDataPtr aData = (AwtGraphicsConfigDataPtr)\n        jlong_to_ptr(configData);\n\n    if (aData == NULL) {\n        return;\n    }\n\n    AWT_LOCK();\n    if (aData->awt_cmap) {\n        XFreeColormap(awt_display, aData->awt_cmap);\n    }\n    if (aData->awtImage) {\n        free(aData->awtImage);\n    }\n    if (aData->monoImage) {\n        XFree(aData->monoImage);\n    }\n    if (aData->monoPixmap) {\n        XFreePixmap(awt_display, aData->monoPixmap);\n    }\n    if (aData->monoPixmapGC) {\n        XFreeGC(awt_display, aData->monoPixmapGC);\n    }\n    if (aData->color_data) {\n        free(aData->color_data);\n    }\n    AWT_UNLOCK();\n\n    if (aData->glxInfo) {\n        /*\n         * The native GLXGraphicsConfig data needs to be disposed separately\n         * on the OGL queue flushing thread (should not be called while\n         * the AWT lock is held).\n         */\n        JNU_CallStaticMethodByName(env, NULL,\n                                   \"sun/java2d/opengl/OGLRenderQueue\",\n                                   \"disposeGraphicsConfig\", \"(J)V\",\n                                   ptr_to_jlong(aData->glxInfo));\n    }\n\n    free(aData);\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    getXResolution\n * Signature: ()I\n */\nJNIEXPORT jdouble JNICALL\nJava_sun_awt_X11GraphicsConfig_getXResolution(\nJNIEnv *env, jobject this, jint screen)\n{\n#ifdef HEADLESS\n    return (jdouble)0;\n#else\n    return ((DisplayWidth(awt_display, screen) * 25.4) /\n            DisplayWidthMM(awt_display, screen));\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    getYResolution\n * Signature: ()I\n */\nJNIEXPORT jdouble JNICALL\nJava_sun_awt_X11GraphicsConfig_getYResolution(\nJNIEnv *env, jobject this, jint screen)\n{\n#ifdef HEADLESS\n    return (jdouble)0;\n#else\n    return ((DisplayHeight(awt_display, screen) * 25.4) /\n            DisplayHeightMM(awt_display, screen));\n#endif /* !HEADLESS */\n}\n\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    getNumColors\n * Signature: ()I\n */\nJNIEXPORT jint JNICALL\nJava_sun_awt_X11GraphicsConfig_getNumColors(\nJNIEnv *env, jobject this)\n{\n#ifdef HEADLESS\n    return (jint)0;\n#else\n    AwtGraphicsConfigData *adata;\n\n    adata = (AwtGraphicsConfigData *) JNU_GetLongFieldAsPtr(env, this,\n                                              x11GraphicsConfigIDs.aData);\n\n    return adata->awt_num_colors;\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    init\n * Signature: (I)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsConfig_init(\nJNIEnv *env, jobject this, jint visualNum, jint screen)\n{\n#ifndef HEADLESS\n    AwtGraphicsConfigData *adata = NULL;\n    AwtScreenData asd = x11Screens[screen];\n    int i, n;\n    int depth;\n    XImage * tempImage;\n\n    /* If haven't gotten all of the configs yet, do it now. */\n    if (asd.numConfigs == 0) {\n        getAllConfigs (env, screen, &asd);\n    }\n\n    /* Check the graphicsConfig for this visual */\n    for (i = 0; i < asd.numConfigs; i++) {\n        AwtGraphicsConfigDataPtr agcPtr = asd.configs[i];\n        if ((jint)agcPtr->awt_visInfo.visualid == visualNum) {\n           adata = agcPtr;\n           break;\n        }\n    }\n\n    /* If didn't find the visual, throw an exception... */\n    if (adata == (AwtGraphicsConfigData *) NULL) {\n        JNU_ThrowIllegalArgumentException(env, \"Unknown Visual Specified\");\n        return;\n    }\n\n    /*  adata->awt_cmap initialization has been deferred to\n     *  makeColorModel call\n     */\n\n    JNU_SetLongFieldFromPtr(env, this, x11GraphicsConfigIDs.aData, adata);\n\n    depth = adata->awt_visInfo.depth;\n    tempImage = XCreateImage(awt_display,\n                             adata->awt_visInfo.visual,\n                             depth, ZPixmap, 0, NULL, 1, 1, 32, 0);\n    adata->pixelStride = (tempImage->bits_per_pixel + 7) / 8;\n    (*env)->SetIntField(env, this, x11GraphicsConfigIDs.bitsPerPixel,\n                        (jint)tempImage->bits_per_pixel);\n    XDestroyImage(tempImage);\n#endif /* !HEADLESS */\n}\n\n\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    makeColorModel\n * Signature: ()Ljava/awt/image/ColorModel\n */\nJNIEXPORT jobject JNICALL\nJava_sun_awt_X11GraphicsConfig_makeColorModel(\nJNIEnv *env, jobject this)\n{\n#ifdef HEADLESS\n    return NULL;\n#else\n    AwtGraphicsConfigData *adata;\n    jobject colorModel;\n\n    /*\n     * If awt is not locked yet, return null since the toolkit is not\n     * initialized yet.\n     */\n    if (!awtLockInited) {\n        return NULL;\n    }\n\n    AWT_LOCK ();\n\n    adata = (AwtGraphicsConfigData *) JNU_GetLongFieldAsPtr(env, this,\n                                              x11GraphicsConfigIDs.aData);\n\n    /* If colormap entry of adata is NULL, need to create it now */\n    if (adata->awt_cmap == (Colormap) NULL) {\n        awtJNI_CreateColorData (env, adata, 1);\n    }\n\n    /* Make Color Model object for this GraphicsConfiguration */\n    colorModel = (*env)->ExceptionCheck(env)\n                 ? NULL : awtJNI_GetColorModel (env, adata);\n\n    AWT_UNLOCK ();\n\n    return colorModel;\n#endif /* !HEADLESS */\n}\n\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    getBounds\n * Signature: ()Ljava/awt/Rectangle\n */\nJNIEXPORT jobject JNICALL\nJava_sun_awt_X11GraphicsConfig_pGetBounds(JNIEnv *env, jobject this, jint screen)\n{\n#ifdef HEADLESS\n    return NULL;\n#else\n    jclass clazz;\n    jmethodID mid;\n    jobject bounds = NULL;\n    AwtGraphicsConfigDataPtr adata;\n\n    adata = (AwtGraphicsConfigDataPtr)\n        JNU_GetLongFieldAsPtr(env, this, x11GraphicsConfigIDs.aData);\n\n    clazz = (*env)->FindClass(env, \"java/awt/Rectangle\");\n    CHECK_NULL_RETURN(clazz, NULL);\n    mid = (*env)->GetMethodID(env, clazz, \"<init>\", \"(IIII)V\");\n    if (mid != NULL) {\n        if (usingXinerama) {\n            if (0 <= screen && screen < awt_numScreens) {\n                bounds = (*env)->NewObject(env, clazz, mid, fbrects[screen].x,\n                                                            fbrects[screen].y,\n                                                            fbrects[screen].width,\n                                                            fbrects[screen].height);\n            } else {\n                jclass exceptionClass = (*env)->FindClass(env, \"java/lang/IllegalArgumentException\");\n                if (exceptionClass != NULL) {\n                    (*env)->ThrowNew(env, exceptionClass, \"Illegal screen index\");\n                }\n            }\n        } else {\n            XWindowAttributes xwa;\n            memset(&xwa, 0, sizeof(xwa));\n\n            AWT_LOCK ();\n            XGetWindowAttributes(awt_display,\n                    RootWindow(awt_display, adata->awt_visInfo.screen),\n                    &xwa);\n            AWT_UNLOCK ();\n\n            bounds = (*env)->NewObject(env, clazz, mid, 0, 0,\n                    xwa.width, xwa.height);\n        }\n\n        if ((*env)->ExceptionOccurred(env)) {\n            return NULL;\n        }\n    }\n    return bounds;\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    createBackBuffer\n * Signature: (JI)J\n */\nJNIEXPORT jlong JNICALL\nJava_sun_awt_X11GraphicsConfig_createBackBuffer\n    (JNIEnv *env, jobject this, jlong window, jint swapAction)\n{\n    int32_t v1, v2;\n    XdbeBackBuffer ret = (unsigned long) 0;\n    Window w = (Window)window;\n    AWT_LOCK();\n    if (!XdbeQueryExtension(awt_display, &v1, &v2)) {\n        JNU_ThrowByName(env, \"java/lang/Exception\",\n                        \"Could not query double-buffer extension\");\n        AWT_UNLOCK();\n        return (jlong)0;\n    }\n    ret = XdbeAllocateBackBufferName(awt_display, w,\n                                     (XdbeSwapAction)swapAction);\n    AWT_FLUSH_UNLOCK();\n    return (jlong)ret;\n}\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    destroyBackBuffer\n * Signature: (J)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsConfig_destroyBackBuffer\n    (JNIEnv *env, jobject this, jlong backBuffer)\n{\n    AWT_LOCK();\n    XdbeDeallocateBackBufferName(awt_display, (XdbeBackBuffer)backBuffer);\n    AWT_FLUSH_UNLOCK();\n}\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    swapBuffers\n * Signature: (JI)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsConfig_swapBuffers\n    (JNIEnv *env, jobject this,\n     jlong window, jint swapAction)\n{\n    XdbeSwapInfo swapInfo;\n\n    AWT_LOCK();\n\n    XdbeBeginIdiom(awt_display);\n    swapInfo.swap_window = (Window)window;\n    swapInfo.swap_action = (XdbeSwapAction)swapAction;\n    if (!XdbeSwapBuffers(awt_display, &swapInfo, 1)) {\n        JNU_ThrowInternalError(env, \"Could not swap buffers\");\n    }\n    XdbeEndIdiom(awt_display);\n\n    AWT_FLUSH_UNLOCK();\n}\n\n/*\n * Class:     sun_awt_X11GraphicsConfig\n * Method:    isTranslucencyCapable\n * Signature: (J)V\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_X11GraphicsConfig_isTranslucencyCapable\n    (JNIEnv *env, jobject this, jlong configData)\n{\n#ifdef HEADLESS\n    return JNI_FALSE;\n#else\n    AwtGraphicsConfigDataPtr aData = (AwtGraphicsConfigDataPtr)jlong_to_ptr(configData);\n    if (aData == NULL) {\n        return JNI_FALSE;\n    }\n    return aData->isTranslucencySupported ? JNI_TRUE : JNI_FALSE;\n#endif\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    isDBESupported\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_X11GraphicsDevice_isDBESupported(JNIEnv *env, jobject this)\n{\n#ifdef HEADLESS\n    return JNI_FALSE;\n#else\n    int opcode = 0, firstEvent = 0, firstError = 0;\n    jboolean ret;\n\n    AWT_LOCK();\n    ret = (jboolean)XQueryExtension(awt_display, \"DOUBLE-BUFFER\",\n                                    &opcode, &firstEvent, &firstError);\n    AWT_FLUSH_UNLOCK();\n    return ret;\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    getDoubleBufferVisuals\n * Signature: (I)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsDevice_getDoubleBufferVisuals(JNIEnv *env,\n    jobject this, jint screen)\n{\n#ifndef HEADLESS\n    jclass clazz;\n    jmethodID midAddVisual;\n    Window rootWindow;\n    int i, n = 1;\n    XdbeScreenVisualInfo* visScreenInfo;\n    int xinawareScreen;\n\n    if (usingXinerama) {\n        xinawareScreen = 0;\n    }\n    else {\n        xinawareScreen = screen;\n    }\n\n    clazz = (*env)->GetObjectClass(env, this);\n    midAddVisual = (*env)->GetMethodID(env, clazz, \"addDoubleBufferVisual\",\n        \"(I)V\");\n    CHECK_NULL(midAddVisual);\n    AWT_LOCK();\n    rootWindow = RootWindow(awt_display, xinawareScreen);\n    visScreenInfo = XdbeGetVisualInfo(awt_display, &rootWindow, &n);\n    if (visScreenInfo == NULL) {\n        JNU_ThrowInternalError(env, \"Could not get visual info\");\n        AWT_UNLOCK();\n        return;\n    }\n    AWT_FLUSH_UNLOCK();\n    for (i = 0; i < visScreenInfo->count; i++) {\n        XdbeVisualInfo* visInfo = visScreenInfo->visinfo;\n        (*env)->CallVoidMethod(env, this, midAddVisual, (visInfo[i]).visual);\n    }\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsEnvironment\n * Method:    pRunningXinerama\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_X11GraphicsEnvironment_pRunningXinerama(JNIEnv *env,\n    jobject this)\n{\n#ifdef HEADLESS\n    return JNI_FALSE;\n#else\n    return usingXinerama ? JNI_TRUE : JNI_FALSE;\n#endif /* HEADLESS */\n}\n\n/*\n * Can return NULL.\n *\n * Class:     sun_awt_X11GraphicsEnvironment\n * Method:    getXineramaCenterPoint\n * Signature: ()Ljava/awt/Point\n */\nJNIEXPORT jobject JNICALL\nJava_sun_awt_X11GraphicsEnvironment_getXineramaCenterPoint(JNIEnv *env,\n    jobject this)\n{\n    jobject point = NULL;\n#ifndef HEADLESS    /* return NULL in HEADLESS, Linux */\n#if !defined(__linux__) && !defined(MACOSX)\n    int x,y;\n\n    AWT_LOCK();\n    DASSERT(usingXinerama);\n    if (XineramaSolarisCenterFunc != NULL) {\n        (XineramaSolarisCenterFunc)(awt_display, 0, &x, &y);\n        point = JNU_NewObjectByName(env, \"java/awt/Point\",\"(II)V\", x, y);\n        DASSERT(point);\n    } else {\n        DTRACE_PRINTLN(\"unable to call XineramaSolarisCenterFunc: symbol is null\");\n    }\n    AWT_FLUSH_UNLOCK();\n#endif /* __linux __ || MACOSX */\n#endif /* HEADLESS */\n    return point;\n}\n\n\n/**\n * Begin DisplayMode/FullScreen support\n */\n\n#ifndef HEADLESS\n\n#define BIT_DEPTH_MULTI java_awt_DisplayMode_BIT_DEPTH_MULTI\n#define REFRESH_RATE_UNKNOWN java_awt_DisplayMode_REFRESH_RATE_UNKNOWN\n\ntypedef Status\n    (*XRRQueryVersionType) (Display *dpy, int *major_versionp, int *minor_versionp);\ntypedef XRRScreenConfiguration*\n    (*XRRGetScreenInfoType)(Display *dpy, Drawable root);\ntypedef void\n    (*XRRFreeScreenConfigInfoType)(XRRScreenConfiguration *config);\ntypedef short*\n    (*XRRConfigRatesType)(XRRScreenConfiguration *config,\n                          int sizeID, int *nrates);\ntypedef short\n    (*XRRConfigCurrentRateType)(XRRScreenConfiguration *config);\ntypedef XRRScreenSize*\n    (*XRRConfigSizesType)(XRRScreenConfiguration *config,\n                          int *nsizes);\ntypedef SizeID\n    (*XRRConfigCurrentConfigurationType)(XRRScreenConfiguration *config,\n                                         Rotation *rotation);\ntypedef Status\n    (*XRRSetScreenConfigAndRateType)(Display *dpy,\n                                     XRRScreenConfiguration *config,\n                                     Drawable draw,\n                                     int size_index,\n                                     Rotation rotation,\n                                     short rate,\n                                     Time timestamp);\ntypedef Rotation\n    (*XRRConfigRotationsType)(XRRScreenConfiguration *config,\n                              Rotation *current_rotation);\n\nstatic XRRQueryVersionType               awt_XRRQueryVersion;\nstatic XRRGetScreenInfoType              awt_XRRGetScreenInfo;\nstatic XRRFreeScreenConfigInfoType       awt_XRRFreeScreenConfigInfo;\nstatic XRRConfigRatesType                awt_XRRConfigRates;\nstatic XRRConfigCurrentRateType          awt_XRRConfigCurrentRate;\nstatic XRRConfigSizesType                awt_XRRConfigSizes;\nstatic XRRConfigCurrentConfigurationType awt_XRRConfigCurrentConfiguration;\nstatic XRRSetScreenConfigAndRateType     awt_XRRSetScreenConfigAndRate;\nstatic XRRConfigRotationsType            awt_XRRConfigRotations;\n\n#define LOAD_XRANDR_FUNC(f) \\\n    do { \\\n        awt_##f = (f##Type)dlsym(pLibRandR, #f); \\\n        if (awt_##f == NULL) { \\\n            J2dRlsTraceLn1(J2D_TRACE_ERROR, \\\n                           \"X11GD_InitXrandrFuncs: Could not load %s\", #f); \\\n            dlclose(pLibRandR); \\\n            return JNI_FALSE; \\\n        } \\\n    } while (0)\n\nstatic jboolean\nX11GD_InitXrandrFuncs(JNIEnv *env)\n{\n    int rr_maj_ver = 0, rr_min_ver = 0;\n\n    void *pLibRandR = dlopen(VERSIONED_JNI_LIB_NAME(\"Xrandr\", \"2\"),\n                             RTLD_LAZY | RTLD_LOCAL);\n    if (pLibRandR == NULL) {\n        pLibRandR = dlopen(JNI_LIB_NAME(\"Xrandr\"), RTLD_LAZY | RTLD_LOCAL);\n    }\n    if (pLibRandR == NULL) {\n        J2dRlsTraceLn(J2D_TRACE_ERROR,\n                      \"X11GD_InitXrandrFuncs: Could not open libXrandr.so.2\");\n        return JNI_FALSE;\n    }\n\n    LOAD_XRANDR_FUNC(XRRQueryVersion);\n\n    if (!(*awt_XRRQueryVersion)(awt_display, &rr_maj_ver, &rr_min_ver)) {\n        J2dRlsTraceLn(J2D_TRACE_ERROR,\n                      \"X11GD_InitXrandrFuncs: XRRQueryVersion returned an error status\");\n        dlclose(pLibRandR);\n        return JNI_FALSE;\n    }\n\n    if (usingXinerama) {\n        /*\n         * We can proceed as long as this is RANDR 1.2 or above.\n         * As of Xorg server 1.3 onwards the Xinerama backend may actually be\n         * a fake one provided by RANDR itself. See Java bug 6636469 for info.\n         */\n        if (!(rr_maj_ver > 1 || (rr_maj_ver == 1 && rr_min_ver >= 2))) {\n            J2dRlsTraceLn2(J2D_TRACE_INFO, \"X11GD_InitXrandrFuncs: Can't use Xrandr. \"\n                           \"Xinerama is active and Xrandr version is %d.%d\",\n                           rr_maj_ver, rr_min_ver);\n            dlclose(pLibRandR);\n            return JNI_FALSE;\n        }\n\n        /*\n         * REMIND: Fullscreen mode doesn't work quite right with multi-monitor\n         * setups and RANDR 1.2.\n         */\n        if ((rr_maj_ver == 1 && rr_min_ver <= 2) && awt_numScreens > 1) {\n            J2dRlsTraceLn(J2D_TRACE_INFO, \"X11GD_InitXrandrFuncs: Can't use Xrandr. \"\n                          \"Multiple screens in use\");\n            dlclose(pLibRandR);\n            return JNI_FALSE;\n        }\n    }\n\n    LOAD_XRANDR_FUNC(XRRGetScreenInfo);\n    LOAD_XRANDR_FUNC(XRRFreeScreenConfigInfo);\n    LOAD_XRANDR_FUNC(XRRConfigRates);\n    LOAD_XRANDR_FUNC(XRRConfigCurrentRate);\n    LOAD_XRANDR_FUNC(XRRConfigSizes);\n    LOAD_XRANDR_FUNC(XRRConfigCurrentConfiguration);\n    LOAD_XRANDR_FUNC(XRRSetScreenConfigAndRate);\n    LOAD_XRANDR_FUNC(XRRConfigRotations);\n\n    return JNI_TRUE;\n}\n\nstatic jobject\nX11GD_CreateDisplayMode(JNIEnv *env, jint width, jint height,\n                        jint bitDepth, jint refreshRate)\n{\n    jclass displayModeClass;\n    jmethodID cid;\n    jint validRefreshRate = refreshRate;\n\n    displayModeClass = (*env)->FindClass(env, \"java/awt/DisplayMode\");\n    CHECK_NULL_RETURN(displayModeClass, NULL);\n    if (JNU_IsNull(env, displayModeClass)) {\n        JNU_ThrowInternalError(env,\n                               \"Could not get display mode class\");\n        return NULL;\n    }\n\n    cid = (*env)->GetMethodID(env, displayModeClass, \"<init>\", \"(IIII)V\");\n    CHECK_NULL_RETURN(cid, NULL);\n    if (cid == NULL) {\n        JNU_ThrowInternalError(env,\n                               \"Could not get display mode constructor\");\n        return NULL;\n    }\n\n    // early versions of xrandr may report \"empty\" rates (6880694)\n    if (validRefreshRate <= 0) {\n        validRefreshRate = REFRESH_RATE_UNKNOWN;\n    }\n\n    return (*env)->NewObject(env, displayModeClass, cid,\n                             width, height, bitDepth, validRefreshRate);\n}\n\nstatic void\nX11GD_AddDisplayMode(JNIEnv *env, jobject arrayList,\n                     jint width, jint height,\n                     jint bitDepth, jint refreshRate)\n{\n    jobject displayMode = X11GD_CreateDisplayMode(env, width, height,\n                                                  bitDepth, refreshRate);\n    if (!JNU_IsNull(env, displayMode)) {\n        jclass arrayListClass;\n        jmethodID mid;\n        arrayListClass = (*env)->GetObjectClass(env, arrayList);\n        if (JNU_IsNull(env, arrayListClass)) {\n            JNU_ThrowInternalError(env,\n                                   \"Could not get class java.util.ArrayList\");\n            return;\n        }\n        mid = (*env)->GetMethodID(env, arrayListClass, \"add\",\n                                  \"(Ljava/lang/Object;)Z\");\n        CHECK_NULL(mid);\n        if (mid == NULL) {\n            JNU_ThrowInternalError(env,\n                \"Could not get method java.util.ArrayList.add()\");\n            return;\n        }\n        (*env)->CallObjectMethod(env, arrayList, mid, displayMode);\n        (*env)->DeleteLocalRef(env, displayMode);\n    }\n}\n\nstatic void\nX11GD_SetFullscreenMode(Window win, jboolean enabled)\n{\n    Atom wmState = XInternAtom(awt_display, \"_NET_WM_STATE\", False);\n    Atom wmStateFs = XInternAtom(awt_display,\n                                 \"_NET_WM_STATE_FULLSCREEN\", False);\n    XWindowAttributes attr;\n    XEvent event;\n\n    if (wmState == None || wmStateFs == None\n            || !XGetWindowAttributes(awt_display, win, &attr)) {\n        return;\n    }\n\n    memset(&event, 0, sizeof(event));\n    event.xclient.type = ClientMessage;\n    event.xclient.message_type = wmState;\n    event.xclient.display = awt_display;\n    event.xclient.window = win;\n    event.xclient.format = 32;\n    event.xclient.data.l[0] = enabled ? 1 : 0; // 1==add, 0==remove\n    event.xclient.data.l[1] = wmStateFs;\n\n    XSendEvent(awt_display, attr.root, False,\n               SubstructureRedirectMask | SubstructureNotifyMask,\n               &event);\n    XSync(awt_display, False);\n}\n#endif /* !HEADLESS */\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    initXrandrExtension\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_awt_X11GraphicsDevice_initXrandrExtension\n    (JNIEnv *env, jclass x11gd)\n{\n#ifdef HEADLESS\n    return JNI_FALSE;\n#else\n    int opcode = 0, firstEvent = 0, firstError = 0;\n    jboolean ret;\n\n    AWT_LOCK();\n    ret = (jboolean)XQueryExtension(awt_display, \"RANDR\",\n                                    &opcode, &firstEvent, &firstError);\n    if (ret) {\n        ret = X11GD_InitXrandrFuncs(env);\n    }\n    AWT_FLUSH_UNLOCK();\n\n    return ret;\n#endif /* HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    getCurrentDisplayMode\n * Signature: (I)Ljava/awt/DisplayMode;\n */\nJNIEXPORT jobject JNICALL\nJava_sun_awt_X11GraphicsDevice_getCurrentDisplayMode\n    (JNIEnv* env, jclass x11gd, jint screen)\n{\n#ifdef HEADLESS\n    return NULL;\n#else\n    XRRScreenConfiguration *config;\n    jobject displayMode = NULL;\n\n    AWT_LOCK();\n\n    config = awt_XRRGetScreenInfo(awt_display,\n                                  RootWindow(awt_display, screen));\n    if (config != NULL) {\n        Rotation rotation;\n        short curRate;\n        SizeID curSizeIndex;\n        XRRScreenSize *sizes;\n        int nsizes;\n\n        curSizeIndex = awt_XRRConfigCurrentConfiguration(config, &rotation);\n        sizes = awt_XRRConfigSizes(config, &nsizes);\n        curRate = awt_XRRConfigCurrentRate(config);\n\n        if ((sizes != NULL) &&\n            (curSizeIndex < nsizes))\n        {\n            XRRScreenSize curSize = sizes[curSizeIndex];\n            displayMode = X11GD_CreateDisplayMode(env,\n                                                  curSize.width,\n                                                  curSize.height,\n                                                  BIT_DEPTH_MULTI,\n                                                  curRate);\n        }\n\n        awt_XRRFreeScreenConfigInfo(config);\n    }\n\n    AWT_FLUSH_UNLOCK();\n\n    return displayMode;\n#endif /* HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    enumDisplayModes\n * Signature: (ILjava/util/ArrayList;)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsDevice_enumDisplayModes\n    (JNIEnv* env, jclass x11gd,\n     jint screen, jobject arrayList)\n{\n#ifndef HEADLESS\n    XRRScreenConfiguration *config;\n\n    AWT_LOCK();\n\n    config = awt_XRRGetScreenInfo(awt_display,\n                                  RootWindow(awt_display, screen));\n    if (config != NULL) {\n        int nsizes, i, j;\n        XRRScreenSize *sizes = awt_XRRConfigSizes(config, &nsizes);\n\n        if (sizes != NULL) {\n            for (i = 0; i < nsizes; i++) {\n                int nrates;\n                XRRScreenSize size = sizes[i];\n                short *rates = awt_XRRConfigRates(config, i, &nrates);\n\n                for (j = 0; j < nrates; j++) {\n                    X11GD_AddDisplayMode(env, arrayList,\n                                         size.width,\n                                         size.height,\n                                         BIT_DEPTH_MULTI,\n                                         rates[j]);\n                    if ((*env)->ExceptionCheck(env)) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        awt_XRRFreeScreenConfigInfo(config);\n    }\n\n    AWT_FLUSH_UNLOCK();\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    configDisplayMode\n * Signature: (IIII)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsDevice_configDisplayMode\n    (JNIEnv* env, jclass x11gd,\n     jint screen, jint width, jint height, jint refreshRate)\n{\n#ifndef HEADLESS\n    jboolean success = JNI_FALSE;\n    XRRScreenConfiguration *config;\n    Drawable root;\n    Rotation currentRotation = RR_Rotate_0;\n\n    AWT_LOCK();\n\n    root = RootWindow(awt_display, screen);\n    config = awt_XRRGetScreenInfo(awt_display, root);\n    if (config != NULL) {\n        jboolean foundConfig = JNI_FALSE;\n        int chosenSizeIndex = -1;\n        short chosenRate = -1;\n        int nsizes;\n        XRRScreenSize *sizes = awt_XRRConfigSizes(config, &nsizes);\n        awt_XRRConfigRotations(config, &currentRotation);\n\n        if (sizes != NULL) {\n            int i, j;\n\n            /* find the size index that matches the requested dimensions */\n            for (i = 0; i < nsizes; i++) {\n                XRRScreenSize size = sizes[i];\n\n                if ((size.width == width) && (size.height == height)) {\n                    /* we've found our size index... */\n                    int nrates;\n                    short *rates = awt_XRRConfigRates(config, i, &nrates);\n\n                    /* now find rate that matches requested refresh rate */\n                    for (j = 0; j < nrates; j++) {\n                        if (rates[j] == refreshRate) {\n                            /* we've found our rate; break out of the loop */\n                            chosenSizeIndex = i;\n                            chosenRate = rates[j];\n                            foundConfig = JNI_TRUE;\n                            break;\n                        }\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        if (foundConfig) {\n            Status status =\n                awt_XRRSetScreenConfigAndRate(awt_display, config, root,\n                                              chosenSizeIndex,\n                                              currentRotation,\n                                              chosenRate,\n                                              CurrentTime);\n\n            /* issue XSync to ensure immediate mode change */\n            XSync(awt_display, False);\n\n            if (status == RRSetConfigSuccess) {\n                success = JNI_TRUE;\n            }\n        }\n\n        awt_XRRFreeScreenConfigInfo(config);\n    }\n\n    AWT_FLUSH_UNLOCK();\n\n    if (!success && !(*env)->ExceptionCheck(env)) {\n        JNU_ThrowInternalError(env, \"Could not set display mode\");\n    }\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    enterFullScreenExclusive\n * Signature: (J)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsDevice_enterFullScreenExclusive\n    (JNIEnv* env, jclass x11gd,\n     jlong window)\n{\n#ifndef HEADLESS\n    Window win = (Window)window;\n\n    AWT_LOCK();\n    XSync(awt_display, False); /* ensures window is visible first */\n    X11GD_SetFullscreenMode(win, JNI_TRUE);\n    AWT_UNLOCK();\n#endif /* !HEADLESS */\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    exitFullScreenExclusive\n * Signature: (J)V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_X11GraphicsDevice_exitFullScreenExclusive\n    (JNIEnv* env, jclass x11gd,\n     jlong window)\n{\n#ifndef HEADLESS\n    Window win = (Window)window;\n\n    AWT_LOCK();\n    X11GD_SetFullscreenMode(win, JNI_FALSE);\n    AWT_UNLOCK();\n#endif /* !HEADLESS */\n}\n\n/**\n * End DisplayMode/FullScreen support\n */\n\nint getScale(const char *name) {\n    char *uiScale = getenv(name);\n    if (uiScale != NULL) {\n        double scale = strtod(uiScale, NULL);\n        if (errno == ERANGE || scale < 1) {\n            return -1;\n        }\n        return (int) scale;\n    }\n    return -1;\n}\n\n/*\n * Class:     sun_awt_X11GraphicsDevice\n * Method:    getNativeScaleFactor\n * Signature: (I)I\n */\nJNIEXPORT jint JNICALL\nJava_sun_awt_X11GraphicsDevice_getNativeScaleFactor\n    (JNIEnv *env, jobject this, jint screen) {\n\n    // for debug purposes\n    static int scale = -2.0;\n\n    if (scale == -2) {\n        scale = getScale(\"J2D_UISCALE\");\n    }\n\n    if (scale >= 1) {\n        return scale;\n    }\n\n    return getScale(\"GDK_SCALE\");\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/net/spi/DefaultProxySelector.c": "/*\n * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"jni.h\"\n#include \"jni_util.h\"\n#include \"jvm.h\"\n#include \"jvm_md.h\"\n#include \"jlong.h\"\n#include \"sun_net_spi_DefaultProxySelector.h\"\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n\n/**\n * These functions are used by the sun.net.spi.DefaultProxySelector class\n * to access some platform specific settings.\n * This is the Solaris/Linux Gnome 2.x code using the GConf-2 library.\n * Everything is loaded dynamically so no hard link with any library exists.\n * The GConf-2 settings used are:\n * - /system/http_proxy/use_http_proxy          boolean\n * - /system/http_proxy/use_authentcation       boolean\n * - /system/http_proxy/use_same_proxy          boolean\n * - /system/http_proxy/host                    string\n * - /system/http_proxy/authentication_user     string\n * - /system/http_proxy/authentication_password string\n * - /system/http_proxy/port                    int\n * - /system/proxy/socks_host                   string\n * - /system/proxy/mode                         string\n * - /system/proxy/ftp_host                     string\n * - /system/proxy/secure_host                  string\n * - /system/proxy/socks_port                   int\n * - /system/proxy/ftp_port                     int\n * - /system/proxy/secure_port                  int\n * - /system/proxy/no_proxy_for                 list\n * - /system/proxy/gopher_host                  string\n * - /system/proxy/gopher_port                  int\n *\n * The following keys are not used in the new gnome 3\n * - /system/http_proxy/use_http_proxy\n * - /system/http_proxy/use_same_proxy\n */\ntypedef void* gconf_client_get_default_func();\ntypedef char* gconf_client_get_string_func(void *, char *, void**);\ntypedef int   gconf_client_get_int_func(void*, char *, void**);\ntypedef int   gconf_client_get_bool_func(void*, char *, void**);\ntypedef int   gconf_init_func(int, char**, void**);\ntypedef void  g_type_init_func ();\ngconf_client_get_default_func* my_get_default_func = NULL;\ngconf_client_get_string_func* my_get_string_func = NULL;\ngconf_client_get_int_func* my_get_int_func = NULL;\ngconf_client_get_bool_func* my_get_bool_func = NULL;\ngconf_init_func* my_gconf_init_func = NULL;\ng_type_init_func* my_g_type_init_func = NULL;\n\n\n/*\n * GProxyResolver provides synchronous and asynchronous network\n * proxy resolution. It is based on GSettings, which is the standard\n * of Gnome 3, to get system settings.\n *\n * In the current implementation, GProxyResolver has a higher priority\n * than the old GConf. And we only resolve the proxy synchronously. In\n * the future, we can also do the asynchronous network proxy resolution\n * if necessary.\n *\n */\ntypedef struct _GProxyResolver GProxyResolver;\ntypedef struct _GSocketConnectable GSocketConnectable;\ntypedef struct GError GError;\ntypedef GProxyResolver* g_proxy_resolver_get_default_func();\ntypedef char** g_proxy_resolver_lookup_func();\ntypedef GSocketConnectable* g_network_address_parse_uri_func();\ntypedef const char* g_network_address_get_hostname_func();\ntypedef unsigned short g_network_address_get_port_func();\ntypedef void g_strfreev_func();\n\nstatic g_proxy_resolver_get_default_func* g_proxy_resolver_get_default = NULL;\nstatic g_proxy_resolver_lookup_func* g_proxy_resolver_lookup = NULL;\nstatic g_network_address_parse_uri_func* g_network_address_parse_uri = NULL;\nstatic g_network_address_get_hostname_func* g_network_address_get_hostname = NULL;\nstatic g_network_address_get_port_func* g_network_address_get_port = NULL;\nstatic g_strfreev_func* g_strfreev = NULL;\n\n\nstatic jclass proxy_class;\nstatic jclass isaddr_class;\nstatic jclass ptype_class;\nstatic jmethodID isaddr_createUnresolvedID;\nstatic jmethodID proxy_ctrID;\nstatic jfieldID pr_no_proxyID;\nstatic jfieldID ptype_httpID;\nstatic jfieldID ptype_socksID;\n\n\nstatic void* gconf_client = NULL;\n\nstatic int use_gproxyResolver = 0;\nstatic int use_gconf = 0;\n\n#define CHECK_NULL(X) { if ((X) == NULL) fprintf (stderr,\"JNI errror at line %d\\n\", __LINE__); }\n\n\nstatic int initGConf() {\n    /**\n     * Let's try to load GConf-2 library\n     */\n    if (dlopen(JNI_LIB_NAME(\"gconf-2\"), RTLD_GLOBAL | RTLD_LAZY) != NULL ||\n        dlopen(VERSIONED_JNI_LIB_NAME(\"gconf-2\", \"4\"),\n               RTLD_GLOBAL | RTLD_LAZY) != NULL)\n    {\n        /*\n         * Now let's get pointer to the functions we need.\n         */\n        my_g_type_init_func =\n                (g_type_init_func*)dlsym(RTLD_DEFAULT, \"g_type_init\");\n        my_get_default_func =\n                (gconf_client_get_default_func*)dlsym(RTLD_DEFAULT,\n                        \"gconf_client_get_default\");\n\n        if (my_g_type_init_func != NULL && my_get_default_func != NULL) {\n            /**\n             * Try to connect to GConf.\n             */\n            (*my_g_type_init_func)();\n            gconf_client = (*my_get_default_func)();\n            if (gconf_client != NULL) {\n                my_get_string_func =\n                        (gconf_client_get_string_func*)dlsym(RTLD_DEFAULT,\n                                \"gconf_client_get_string\");\n                my_get_int_func =\n                        (gconf_client_get_int_func*)dlsym(RTLD_DEFAULT,\n                                \"gconf_client_get_int\");\n                my_get_bool_func =\n                        (gconf_client_get_bool_func*)dlsym(RTLD_DEFAULT,\n                                \"gconf_client_get_bool\");\n                if (my_get_int_func != NULL && my_get_string_func != NULL &&\n                        my_get_bool_func != NULL)\n                {\n                    /**\n                     * We did get all we need. Let's enable the System Proxy Settings.\n                     */\n                    return 1;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nstatic jobject getProxyByGConf(JNIEnv *env, const char* cproto,\n                               const char* chost)\n{\n    char *phost = NULL;\n    char *mode = NULL;\n    int pport = 0;\n    int use_proxy = 0;\n    int use_same_proxy = 0;\n    jobject isa = NULL;\n    jobject proxy = NULL;\n    jobject type_proxy = NULL;\n\n    // We only check manual proxy configurations\n    mode =  (*my_get_string_func)(gconf_client, \"/system/proxy/mode\", NULL);\n    if (mode && !strcasecmp(mode, \"manual\")) {\n        /*\n         * Even though /system/http_proxy/use_same_proxy is no longer used,\n         * its value is set to false in gnome 3. So it is not harmful to check\n         * it first in case jdk is used with an old gnome.\n         */\n        use_same_proxy = (*my_get_bool_func)(gconf_client, \"/system/http_proxy/use_same_proxy\", NULL);\n        if (use_same_proxy) {\n            phost = (*my_get_string_func)(gconf_client, \"/system/http_proxy/host\", NULL);\n            pport = (*my_get_int_func)(gconf_client, \"/system/http_proxy/port\", NULL);\n            use_proxy = (phost != NULL && pport != 0);\n            if (use_proxy)\n                type_proxy = (*env)->GetStaticObjectField(env, ptype_class, ptype_httpID);\n        }\n\n        if (!use_proxy) {\n            /**\n             * HTTP:\n             * /system/http_proxy/use_http_proxy (boolean) - it's no longer used\n             * /system/http_proxy/host (string)\n             * /system/http_proxy/port (integer)\n             */\n            if (strcasecmp(cproto, \"http\") == 0) {\n                phost = (*my_get_string_func)(gconf_client, \"/system/http_proxy/host\", NULL);\n                pport = (*my_get_int_func)(gconf_client, \"/system/http_proxy/port\", NULL);\n                use_proxy = (phost != NULL && pport != 0);\n                if (use_proxy)\n                    type_proxy = (*env)->GetStaticObjectField(env, ptype_class, ptype_httpID);\n            }\n\n            /**\n             * HTTPS:\n             * /system/proxy/mode (string) [ \"manual\" means use proxy settings ]\n             * /system/proxy/secure_host (string)\n             * /system/proxy/secure_port (integer)\n             */\n            if (strcasecmp(cproto, \"https\") == 0) {\n                phost = (*my_get_string_func)(gconf_client, \"/system/proxy/secure_host\", NULL);\n                pport = (*my_get_int_func)(gconf_client, \"/system/proxy/secure_port\", NULL);\n                use_proxy = (phost != NULL && pport != 0);\n                if (use_proxy)\n                    type_proxy = (*env)->GetStaticObjectField(env, ptype_class, ptype_httpID);\n            }\n\n            /**\n             * FTP:\n             * /system/proxy/mode (string) [ \"manual\" means use proxy settings ]\n             * /system/proxy/ftp_host (string)\n             * /system/proxy/ftp_port (integer)\n             */\n            if (strcasecmp(cproto, \"ftp\") == 0) {\n                phost = (*my_get_string_func)(gconf_client, \"/system/proxy/ftp_host\", NULL);\n                pport = (*my_get_int_func)(gconf_client, \"/system/proxy/ftp_port\", NULL);\n                use_proxy = (phost != NULL && pport != 0);\n                if (use_proxy)\n                    type_proxy = (*env)->GetStaticObjectField(env, ptype_class, ptype_httpID);\n            }\n\n            /**\n             * GOPHER:\n             * /system/proxy/mode (string) [ \"manual\" means use proxy settings ]\n             * /system/proxy/gopher_host (string)\n             * /system/proxy/gopher_port (integer)\n             */\n            if (strcasecmp(cproto, \"gopher\") == 0) {\n                phost = (*my_get_string_func)(gconf_client, \"/system/proxy/gopher_host\", NULL);\n                pport = (*my_get_int_func)(gconf_client, \"/system/proxy/gopher_port\", NULL);\n                use_proxy = (phost != NULL && pport != 0);\n                if (use_proxy)\n                    type_proxy = (*env)->GetStaticObjectField(env, ptype_class, ptype_httpID);\n            }\n\n            /**\n             * SOCKS:\n             * /system/proxy/mode (string) [ \"manual\" means use proxy settings ]\n             * /system/proxy/socks_host (string)\n             * /system/proxy/socks_port (integer)\n             */\n            if (strcasecmp(cproto, \"socks\") == 0) {\n                phost = (*my_get_string_func)(gconf_client, \"/system/proxy/socks_host\", NULL);\n                pport = (*my_get_int_func)(gconf_client, \"/system/proxy/socks_port\", NULL);\n                use_proxy = (phost != NULL && pport != 0);\n                if (use_proxy)\n                    type_proxy = (*env)->GetStaticObjectField(env, ptype_class, ptype_socksID);\n            }\n        }\n    }\n\n    if (use_proxy) {\n        jstring jhost;\n        char *noproxyfor;\n        char *s;\n\n        /**\n         * check for the exclude list (aka \"No Proxy For\" list).\n         * It's a list of comma separated suffixes (e.g. domain name).\n         */\n        noproxyfor = (*my_get_string_func)(gconf_client, \"/system/proxy/no_proxy_for\", NULL);\n        if (noproxyfor != NULL) {\n            char *tmpbuf[512];\n            s = strtok_r(noproxyfor, \", \", tmpbuf);\n\n            while (s != NULL && strlen(s) <= strlen(chost)) {\n                if (strcasecmp(chost+(strlen(chost) - strlen(s)), s) == 0) {\n                    /**\n                     * the URL host name matches with one of the sufixes,\n                     * therefore we have to use a direct connection.\n                     */\n                    use_proxy = 0;\n                    break;\n                }\n                s = strtok_r(NULL, \", \", tmpbuf);\n            }\n        }\n        if (use_proxy) {\n            CHECK_NULL(type_proxy);\n            jhost = (*env)->NewStringUTF(env, phost);\n            isa = (*env)->CallStaticObjectMethod(env, isaddr_class, isaddr_createUnresolvedID, jhost, pport);\n            proxy = (*env)->NewObject(env, proxy_class, proxy_ctrID, type_proxy, isa);\n        }\n    }\n\n    return proxy;\n}\n\nstatic int initGProxyResolver() {\n    void *gio_handle;\n\n    gio_handle = dlopen(\"libgio-2.0.so\", RTLD_LAZY);\n    if (!gio_handle) {\n        gio_handle = dlopen(\"libgio-2.0.so.0\", RTLD_LAZY);\n        if (!gio_handle) {\n            return 0;\n        }\n    }\n\n    my_g_type_init_func = (g_type_init_func*)dlsym(gio_handle, \"g_type_init\");\n\n    g_proxy_resolver_get_default =\n            (g_proxy_resolver_get_default_func*)dlsym(gio_handle,\n                    \"g_proxy_resolver_get_default\");\n\n    g_proxy_resolver_lookup =\n            (g_proxy_resolver_lookup_func*)dlsym(gio_handle,\n                    \"g_proxy_resolver_lookup\");\n\n    g_network_address_parse_uri =\n            (g_network_address_parse_uri_func*)dlsym(gio_handle,\n                    \"g_network_address_parse_uri\");\n\n    g_network_address_get_hostname =\n            (g_network_address_get_hostname_func*)dlsym(gio_handle,\n                    \"g_network_address_get_hostname\");\n\n    g_network_address_get_port =\n            (g_network_address_get_port_func*)dlsym(gio_handle,\n                    \"g_network_address_get_port\");\n\n    g_strfreev = (g_strfreev_func*)dlsym(gio_handle, \"g_strfreev\");\n\n    if (!my_g_type_init_func ||\n        !g_proxy_resolver_get_default ||\n        !g_proxy_resolver_lookup ||\n        !g_network_address_parse_uri ||\n        !g_network_address_get_hostname ||\n        !g_network_address_get_port ||\n        !g_strfreev)\n    {\n        dlclose(gio_handle);\n        return 0;\n    }\n\n    (*my_g_type_init_func)();\n    return 1;\n}\n\nstatic jobject getProxyByGProxyResolver(JNIEnv *env, const char* cproto,\n                                        const char* chost)\n{\n    GProxyResolver* resolver = NULL;\n    char** proxies = NULL;\n    GError *error = NULL;\n\n    size_t protoLen = 0;\n    size_t hostLen = 0;\n    char* uri = NULL;\n\n    jobject objProxy = NULL;\n\n    resolver = (*g_proxy_resolver_get_default)();\n    if (resolver == NULL) {\n        return NULL;\n    }\n\n    // Construct the uri, cproto + \"://\" + chost\n    protoLen = strlen(cproto);\n    hostLen = strlen(chost);\n    uri = malloc(protoLen + hostLen + 4);\n    if (!uri) {\n        // Out of memory\n        return NULL;\n    }\n    memcpy(uri, cproto, protoLen);\n    memcpy(uri + protoLen, \"://\", 3);\n    memcpy(uri + protoLen + 3, chost, hostLen + 1);\n\n    /*\n     * Looks into the system proxy configuration to determine what proxy,\n     * if any, to use to connect to uri. The returned proxy URIs are of\n     * the form <protocol>://[user[:password]@]host:port or direct://,\n     * where <protocol> could be http, rtsp, socks or other proxying protocol.\n     * direct:// is used when no proxy is needed.\n     */\n    proxies = (*g_proxy_resolver_lookup)(resolver, uri, NULL, &error);\n    free(uri);\n\n    if (proxies) {\n        if (!error) {\n            int i;\n            for(i = 0; proxies[i] && !objProxy; i++) {\n                if (strcmp(proxies[i], \"direct://\")) {\n                    GSocketConnectable* conn =\n                            (*g_network_address_parse_uri)(proxies[i], 0,\n                                                           &error);\n                    if (conn && !error) {\n                        const char* phost = NULL;\n                        unsigned short pport = 0;\n                        phost = (*g_network_address_get_hostname)(conn);\n                        pport = (*g_network_address_get_port)(conn);\n                        if (phost && pport > 0) {\n                            jobject type_proxy = NULL;\n                            jstring jhost = NULL;\n                            jobject isa = NULL;\n                            jfieldID ptype_ID = ptype_httpID;\n                            if (!strncmp(proxies[i], \"socks\", 5)) {\n                                ptype_ID = ptype_socksID;\n                            }\n\n                            type_proxy = (*env)->GetStaticObjectField(env,\n                                    ptype_class, ptype_ID);\n                            CHECK_NULL(type_proxy);\n                            jhost = (*env)->NewStringUTF(env, phost);\n                            CHECK_NULL(jhost);\n                            isa = (*env)->CallStaticObjectMethod(env,\n                                    isaddr_class, isaddr_createUnresolvedID,\n                                    jhost, pport);\n                            CHECK_NULL(isa);\n                            objProxy = (*env)->NewObject(env, proxy_class,\n                                    proxy_ctrID, type_proxy, isa);\n                        }\n                    }\n                }\n            }\n        }\n        (*g_strfreev)(proxies);\n    }\n\n    return objProxy;\n}\n\nstatic void initJavaClass(JNIEnv *env) {\n    jclass cls = NULL;\n    CHECK_NULL(cls = (*env)->FindClass(env,\"java/net/Proxy\"));\n    proxy_class = (*env)->NewGlobalRef(env, cls);\n    CHECK_NULL(cls = (*env)->FindClass(env,\"java/net/Proxy$Type\"));\n    ptype_class = (*env)->NewGlobalRef(env, cls);\n    CHECK_NULL(cls = (*env)->FindClass(env, \"java/net/InetSocketAddress\"));\n    isaddr_class = (*env)->NewGlobalRef(env, cls);\n    proxy_ctrID = (*env)->GetMethodID(env, proxy_class, \"<init>\",\n            \"(Ljava/net/Proxy$Type;Ljava/net/SocketAddress;)V\");\n    CHECK_NULL(proxy_ctrID);\n    pr_no_proxyID = (*env)->GetStaticFieldID(env, proxy_class, \"NO_PROXY\",\n            \"Ljava/net/Proxy;\");\n    CHECK_NULL(pr_no_proxyID);\n    ptype_httpID = (*env)->GetStaticFieldID(env, ptype_class, \"HTTP\",\n            \"Ljava/net/Proxy$Type;\");\n    CHECK_NULL(ptype_httpID);\n    ptype_socksID = (*env)->GetStaticFieldID(env, ptype_class, \"SOCKS\",\n            \"Ljava/net/Proxy$Type;\");\n    CHECK_NULL(ptype_socksID);\n    isaddr_createUnresolvedID = (*env)->GetStaticMethodID(env, isaddr_class,\n            \"createUnresolved\",\n            \"(Ljava/lang/String;I)Ljava/net/InetSocketAddress;\");\n    CHECK_NULL(isaddr_createUnresolvedID);\n}\n\n\n/*\n * Class:     sun_net_spi_DefaultProxySelector\n * Method:    init\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_net_spi_DefaultProxySelector_init(JNIEnv *env, jclass clazz) {\n    use_gproxyResolver = initGProxyResolver();\n    if (!use_gproxyResolver)\n        use_gconf = initGConf();\n\n    if (use_gproxyResolver || use_gconf) {\n        initJavaClass(env);\n        return JNI_TRUE;\n    } else\n        return JNI_FALSE;\n}\n\n/*\n * Class:     sun_net_spi_DefaultProxySelector\n * Method:    getSystemProxy\n * Signature: ([Ljava/lang/String;Ljava/lang/String;)Ljava/net/Proxy;\n */\nJNIEXPORT jobject JNICALL\nJava_sun_net_spi_DefaultProxySelector_getSystemProxy(JNIEnv *env,\n                                                     jobject this,\n                                                     jstring proto,\n                                                     jstring host)\n{\n    const char* cproto;\n    const char* chost;\n\n    jboolean isProtoCopy;\n    jboolean isHostCopy;\n\n    jobject proxy = NULL;\n\n    cproto = (*env)->GetStringUTFChars(env, proto, &isProtoCopy);\n\n    if (cproto != NULL && (use_gproxyResolver || use_gconf)) {\n        chost = (*env)->GetStringUTFChars(env, host, &isHostCopy);\n        if (chost != NULL) {\n            if (use_gproxyResolver)\n                proxy = getProxyByGProxyResolver(env, cproto, chost);\n            else if (use_gconf)\n                proxy = getProxyByGConf(env, cproto, chost);\n\n            if (isHostCopy == JNI_TRUE)\n                (*env)->ReleaseStringUTFChars(env, host, chost);\n        }\n        if (isProtoCopy == JNI_TRUE)\n            (*env)->ReleaseStringUTFChars(env, proto, cproto);\n    }\n\n    if (proxy == NULL) {\n        CHECK_NULL(proxy = (*env)->GetStaticObjectField(env, proxy_class,\n                                                        pr_no_proxyID));\n    }\n    return proxy;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/tracing/dtrace/jvm_symbols_md.c": "/*\n * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <dlfcn.h>\n#include <stdlib.h>\n\n#include <jvm.h>\n\n#include \"jvm_symbols.h\"\n\nJvmSymbols* lookupJvmSymbols() {\n    JvmSymbols* syms = (JvmSymbols*)malloc(sizeof(JvmSymbols));\n    if (syms != NULL) {\n        syms->GetVersion = (GetVersion_t)\n            dlsym(RTLD_DEFAULT, \"JVM_DTraceGetVersion\");\n        syms->IsSupported = (IsSupported_t)\n            dlsym(RTLD_DEFAULT, \"JVM_DTraceIsSupported\");\n        syms->Activate = (Activate_t)\n            dlsym(RTLD_DEFAULT, \"JVM_DTraceActivate\");\n        syms->Dispose = (Dispose_t)\n            dlsym(RTLD_DEFAULT, \"JVM_DTraceDispose\");\n        syms->IsProbeEnabled = (IsProbeEnabled_t)\n            dlsym(RTLD_DEFAULT, \"JVM_DTraceIsProbeEnabled\");\n\n        if ( syms->GetVersion == NULL || syms->Activate == NULL ||\n             syms->IsProbeEnabled == NULL || syms->Dispose == NULL ||\n             syms->IsSupported == NULL) {\n            free(syms);\n            syms = NULL;\n        }\n    }\n    return syms;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/common/jdk_util_md.c": "/*\n * Copyright (c) 2004, 2005, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <dlfcn.h>\n#include \"jdk_util.h\"\n\nint JDK_InitJvmHandle() {\n    /* nop */\n    return 1;\n}\n\nvoid* JDK_FindJvmEntry(const char* name) {\n    return dlsym(RTLD_DEFAULT, name);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/java/lang/java_props_macosx.c": "/*\n * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include <dlfcn.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <Security/AuthSession.h>\n#include <CoreFoundation/CoreFoundation.h>\n#include <SystemConfiguration/SystemConfiguration.h>\n#include <Foundation/Foundation.h>\n\n#include \"java_props_macosx.h\"\n\n\n// need dlopen/dlsym trick to avoid pulling in JavaRuntimeSupport before libjava.dylib is loaded\nstatic void *getJRSFramework() {\n    static void *jrsFwk = NULL;\n    if (jrsFwk == NULL) {\n       jrsFwk = dlopen(\"/System/Library/Frameworks/JavaVM.framework/Frameworks/JavaRuntimeSupport.framework/JavaRuntimeSupport\", RTLD_LAZY | RTLD_LOCAL);\n    }\n    return jrsFwk;\n}\n\nchar *getPosixLocale(int cat) {\n    char *lc = setlocale(cat, NULL);\n    if ((lc == NULL) || (strcmp(lc, \"C\") == 0)) {\n        lc = getenv(\"LANG\");\n    }\n    if (lc == NULL) return NULL;\n    return strdup(lc);\n}\n\n#define LOCALEIDLENGTH  128\nchar *getMacOSXLocale(int cat) {\n    switch (cat) {\n    case LC_MESSAGES:\n        {\n            void *jrsFwk = getJRSFramework();\n            if (jrsFwk == NULL) return NULL;\n\n            char *(*JRSCopyPrimaryLanguage)() = dlsym(jrsFwk, \"JRSCopyPrimaryLanguage\");\n            char *primaryLanguage = JRSCopyPrimaryLanguage ? JRSCopyPrimaryLanguage() : NULL;\n            if (primaryLanguage == NULL) return NULL;\n\n            char *(*JRSCopyCanonicalLanguageForPrimaryLanguage)(char *) = dlsym(jrsFwk, \"JRSCopyCanonicalLanguageForPrimaryLanguage\");\n            char *canonicalLanguage = JRSCopyCanonicalLanguageForPrimaryLanguage ?  JRSCopyCanonicalLanguageForPrimaryLanguage(primaryLanguage) : NULL;\n            free (primaryLanguage);\n\n            return canonicalLanguage;\n        }\n        break;\n    default:\n        {\n            char localeString[LOCALEIDLENGTH];\n            if (CFStringGetCString(CFLocaleGetIdentifier(CFLocaleCopyCurrent()),\n                                   localeString, LOCALEIDLENGTH, CFStringGetSystemEncoding())) {\n                return strdup(localeString);\n            }\n        }\n        break;\n    }\n\n    return NULL;\n}\n\nchar *setupMacOSXLocale(int cat) {\n    char * ret = getMacOSXLocale(cat);\n\n    if (cat == LC_MESSAGES && ret != NULL) {\n        void *jrsFwk = getJRSFramework();\n        if (jrsFwk != NULL) {\n            void (*JRSSetDefaultLocalization)(char *) = dlsym(jrsFwk, \"JRSSetDefaultLocalization\");\n            if (JRSSetDefaultLocalization) JRSSetDefaultLocalization(ret);\n        }\n    }\n\n    if (ret == NULL) {\n        return getPosixLocale(cat);\n    } else {\n        return ret;\n    }\n}\n\nint isInAquaSession() {\n    // environment variable to bypass the aqua session check\n    char *ev = getenv(\"AWT_FORCE_HEADFUL\");\n    if (ev && (strncasecmp(ev, \"true\", 4) == 0)) {\n        // if \"true\" then tell the caller we're in an Aqua session without actually checking\n        return 1;\n    }\n    // Is the WindowServer available?\n    SecuritySessionId session_id;\n    SessionAttributeBits session_info;\n    OSStatus status = SessionGetInfo(callerSecuritySession, &session_id, &session_info);\n    if (status == noErr) {\n        if (session_info & sessionHasGraphicAccess) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid setOSNameAndVersion(java_props_t *sprops) {\n    /* Don't rely on JRSCopyOSName because there's no guarantee the value will\n     * remain the same, or even if the JRS functions will continue to be part of\n     * Mac OS X.  So hardcode os_name, and fill in os_version if we can.\n     */\n    sprops->os_name = strdup(\"Mac OS X\");\n\n    void *jrsFwk = getJRSFramework();\n    if (jrsFwk != NULL) {\n        char *(*copyOSVersion)() = dlsym(jrsFwk, \"JRSCopyOSVersion\");\n        if (copyOSVersion != NULL) {\n            sprops->os_version = copyOSVersion();\n            return;\n        }\n    }\n    sprops->os_version = strdup(\"Unknown\");\n}\n\n\nstatic Boolean getProxyInfoForProtocol(CFDictionaryRef inDict, CFStringRef inEnabledKey, CFStringRef inHostKey, CFStringRef inPortKey, CFStringRef *outProxyHost, int *ioProxyPort) {\n    /* See if the proxy is enabled. */\n    CFNumberRef cf_enabled = CFDictionaryGetValue(inDict, inEnabledKey);\n    if (cf_enabled == NULL) {\n        return false;\n    }\n\n    int isEnabled = false;\n    if (!CFNumberGetValue(cf_enabled, kCFNumberIntType, &isEnabled)) {\n        return isEnabled;\n    }\n\n    if (!isEnabled) return false;\n    *outProxyHost = CFDictionaryGetValue(inDict, inHostKey);\n\n    // If cf_host is null, that means the checkbox is set,\n    //   but no host was entered. We'll treat that as NOT ENABLED.\n    // If cf_port is null or cf_port isn't a number, that means\n    //   no port number was entered. Treat this as ENABLED with the\n    //   protocol's default port.\n    if (*outProxyHost == NULL) {\n        return false;\n    }\n\n    if (CFStringGetLength(*outProxyHost) == 0) {\n        return false;\n    }\n\n    int newPort = 0;\n    CFNumberRef cf_port = NULL;\n    if ((cf_port = CFDictionaryGetValue(inDict, inPortKey)) != NULL &&\n        CFNumberGetValue(cf_port, kCFNumberIntType, &newPort) &&\n        newPort > 0) {\n        *ioProxyPort = newPort;\n    } else {\n        // bad port or no port - leave *ioProxyPort unchanged\n    }\n\n    return true;\n}\n\nstatic char *createUTF8CString(const CFStringRef theString) {\n    if (theString == NULL) return NULL;\n\n    const CFIndex stringLength = CFStringGetLength(theString);\n    const CFIndex bufSize = CFStringGetMaximumSizeForEncoding(stringLength, kCFStringEncodingUTF8) + 1;\n    char *returnVal = (char *)malloc(bufSize);\n\n    if (CFStringGetCString(theString, returnVal, bufSize, kCFStringEncodingUTF8)) {\n        return returnVal;\n    }\n\n    free(returnVal);\n    return NULL;\n}\n\n// Return TRUE if str is a syntactically valid IP address.\n// Using inet_pton() instead of inet_aton() for IPv6 support.\n// len is only a hint; cstr must still be nul-terminated\nstatic int looksLikeIPAddress(char *cstr, size_t len) {\n    if (len == 0  ||  (len == 1 && cstr[0] == '.')) return FALSE;\n\n    char dst[16]; // big enough for INET6\n    return (1 == inet_pton(AF_INET, cstr, dst)  ||\n            1 == inet_pton(AF_INET6, cstr, dst));\n}\n\n\n\n// Convert Mac OS X proxy exception entry to Java syntax.\n// See Radar #3441134 for details.\n// Returns NULL if this exception should be ignored by Java.\n// May generate a string with multiple exceptions separated by '|'.\nstatic char * createConvertedException(CFStringRef cf_original) {\n    // This is done with char* instead of CFString because inet_pton()\n    // needs a C string.\n    char *c_exception = createUTF8CString(cf_original);\n    if (!c_exception) return NULL;\n\n    int c_len = strlen(c_exception);\n\n    // 1. sanitize exception prefix\n    if (c_len >= 1  &&  0 == strncmp(c_exception, \".\", 1)) {\n        memmove(c_exception, c_exception+1, c_len);\n        c_len -= 1;\n    } else if (c_len >= 2  &&  0 == strncmp(c_exception, \"*.\", 2)) {\n        memmove(c_exception, c_exception+2, c_len-1);\n        c_len -= 2;\n    }\n\n    // 2. pre-reject other exception wildcards\n    if (strchr(c_exception, '*')) {\n        free(c_exception);\n        return NULL;\n    }\n\n    // 3. no IP wildcarding\n    if (looksLikeIPAddress(c_exception, c_len)) {\n        return c_exception;\n    }\n\n    // 4. allow domain suffixes\n    // c_exception is now \"str\\0\" - change to \"str|*.str\\0\"\n    c_exception = reallocf(c_exception, c_len+3+c_len+1);\n    if (!c_exception) return NULL;\n\n    strncpy(c_exception+c_len, \"|*.\", 3);\n    strncpy(c_exception+c_len+3, c_exception, c_len);\n    c_exception[c_len+3+c_len] = '\\0';\n    return c_exception;\n}\n\n/*\n * Method for fetching the user.home path and storing it in the property list.\n * For signed .apps running in the Mac App Sandbox, user.home is set to the\n * app's sandbox container.\n */\nvoid setUserHome(java_props_t *sprops) {\n    if (sprops == NULL) { return; }\n    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n    sprops->user_home = createUTF8CString((CFStringRef)NSHomeDirectory());\n    [pool drain];\n}\n\n/*\n * Method for fetching proxy info and storing it in the property list.\n */\nvoid setProxyProperties(java_props_t *sProps) {\n    if (sProps == NULL) return;\n\n    char buf[16];    /* Used for %d of an int - 16 is plenty */\n    CFStringRef\n    cf_httpHost = NULL,\n    cf_httpsHost = NULL,\n    cf_ftpHost = NULL,\n    cf_socksHost = NULL,\n    cf_gopherHost = NULL;\n    int\n    httpPort = 80, // Default proxy port values\n    httpsPort = 443,\n    ftpPort = 21,\n    socksPort = 1080,\n    gopherPort = 70;\n\n    CFDictionaryRef dict = SCDynamicStoreCopyProxies(NULL);\n    if (dict == NULL) return;\n\n    /* Read the proxy exceptions list */\n    CFArrayRef cf_list = CFDictionaryGetValue(dict, kSCPropNetProxiesExceptionsList);\n\n    CFMutableStringRef cf_exceptionList = NULL;\n    if (cf_list != NULL) {\n        CFIndex len = CFArrayGetCount(cf_list), idx;\n\n        cf_exceptionList = CFStringCreateMutable(NULL, 0);\n        for (idx = (CFIndex)0; idx < len; idx++) {\n            CFStringRef cf_ehost;\n            if ((cf_ehost = CFArrayGetValueAtIndex(cf_list, idx))) {\n                /* Convert this exception from Mac OS X syntax to Java syntax.\n                 See Radar #3441134 for details. This may generate a string\n                 with multiple Java exceptions separated by '|'. */\n                char *c_exception = createConvertedException(cf_ehost);\n                if (c_exception) {\n                    /* Append the host to the list of exclusions. */\n                    if (CFStringGetLength(cf_exceptionList) > 0) {\n                        CFStringAppendCString(cf_exceptionList, \"|\", kCFStringEncodingMacRoman);\n                    }\n                    CFStringAppendCString(cf_exceptionList, c_exception, kCFStringEncodingMacRoman);\n                    free(c_exception);\n                }\n            }\n        }\n    }\n\n    if (cf_exceptionList != NULL) {\n        if (CFStringGetLength(cf_exceptionList) > 0) {\n            sProps->exceptionList = createUTF8CString(cf_exceptionList);\n        }\n        CFRelease(cf_exceptionList);\n    }\n\n#define CHECK_PROXY(protocol, PROTOCOL)                                     \\\n    sProps->protocol##ProxyEnabled =                                        \\\n    getProxyInfoForProtocol(dict, kSCPropNetProxies##PROTOCOL##Enable,      \\\n    kSCPropNetProxies##PROTOCOL##Proxy,         \\\n    kSCPropNetProxies##PROTOCOL##Port,          \\\n    &cf_##protocol##Host, &protocol##Port);     \\\n    if (sProps->protocol##ProxyEnabled) {                                   \\\n        sProps->protocol##Host = createUTF8CString(cf_##protocol##Host);    \\\n        snprintf(buf, sizeof(buf), \"%d\", protocol##Port);                   \\\n        sProps->protocol##Port = malloc(strlen(buf) + 1);                   \\\n        strcpy(sProps->protocol##Port, buf);                                \\\n    }\n\n    CHECK_PROXY(http, HTTP);\n    CHECK_PROXY(https, HTTPS);\n    CHECK_PROXY(ftp, FTP);\n    CHECK_PROXY(socks, SOCKS);\n    CHECK_PROXY(gopher, Gopher);\n\n#undef CHECK_PROXY\n\n    CFRelease(dict);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/demo/jvmti/hprof/hprof_md.c": "/*\n * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *   - Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *\n *   - Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *\n *   - Neither the name of Oracle nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This source code is provided to illustrate the usage of a given feature\n * or technique and has been deliberately simplified. Additional steps\n * required for a production-quality application, such as security checks,\n * input validation and proper error handling, might not be present in\n * this sample code.\n */\n\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#if !defined(LINUX) && !defined(_ALLBSD_SOURCE) && !defined(AIX)\n#include <procfs.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/errno.h>\n#include <unistd.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include <sys/time.h>\n\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/param.h>\n#include <time.h>\n\n#include \"jni.h\"\n#include \"jvm_md.h\"\n#include \"hprof.h\"\n\n#ifdef AIX\n#include \"porting_aix.h\" /* For the 'dladdr' function. */\n#endif\n\nint\nmd_getpid(void)\n{\n    static int pid = -1;\n\n    if ( pid >= 0 ) {\n        return pid;\n    }\n    pid = getpid();\n    return pid;\n}\n\nvoid\nmd_sleep(unsigned seconds)\n{\n    sleep(seconds);\n}\n\nvoid\nmd_init(void)\n{\n#if defined(LINUX) || defined(_ALLBSD_SOURCE) || defined(AIX)\n    /* No Hi-Res timer option? */\n#else\n    if ( gdata->micro_state_accounting ) {\n        char proc_ctl_fn[48];\n        int  procfd;\n\n        /* Turn on micro state accounting, once per process */\n        (void)md_snprintf(proc_ctl_fn, sizeof(proc_ctl_fn),\n                \"/proc/%d/ctl\", md_getpid());\n\n        procfd = open(proc_ctl_fn, O_WRONLY);\n        if (procfd >= 0) {\n            long ctl_op[2];\n\n            ctl_op[0] = PCSET;\n            ctl_op[1] = PR_MSACCT;\n            (void)write(procfd, ctl_op, sizeof(ctl_op));\n            (void)close(procfd);\n        }\n    }\n#endif\n}\n\nint\nmd_connect(char *hostname, unsigned short port)\n{\n    struct hostent *hentry;\n    struct sockaddr_in s;\n    int fd;\n\n    /* create a socket */\n    fd = socket(AF_INET, SOCK_STREAM, 0);\n    if ( fd < 0 ) {\n        return -1;\n    }\n\n    /* find remote host's addr from name */\n    if ((hentry = gethostbyname(hostname)) == NULL) {\n        (void)close(fd);\n        return -1;\n    }\n    (void)memset((char *)&s, 0, sizeof(s));\n    /* set remote host's addr; its already in network byte order */\n    (void)memcpy(&s.sin_addr.s_addr, *(hentry->h_addr_list),\n           (int)sizeof(s.sin_addr.s_addr));\n    /* set remote host's port */\n    s.sin_port = htons(port);\n    s.sin_family = AF_INET;\n\n    /* now try connecting */\n    if (-1 == connect(fd, (struct sockaddr*)&s, sizeof(s))) {\n        (void)close(fd);\n        return 0;\n    }\n    return fd;\n}\n\nint\nmd_recv(int f, char *buf, int len, int option)\n{\n    return recv(f, buf, len, option);\n}\n\nint\nmd_shutdown(int filedes, int option)\n{\n    return shutdown(filedes, option);\n}\n\nint\nmd_open(const char *filename)\n{\n    return open(filename, O_RDONLY);\n}\n\nint\nmd_open_binary(const char *filename)\n{\n    return md_open(filename);\n}\n\nint\nmd_creat(const char *filename)\n{\n    return open(filename, O_WRONLY | O_CREAT | O_TRUNC,\n            S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n}\n\nint\nmd_creat_binary(const char *filename)\n{\n    return md_creat(filename);\n}\n\njlong\nmd_seek(int filedes, jlong cur)\n{\n    jlong new_pos;\n\n    if ( cur == (jlong)-1 ) {\n        new_pos = lseek(filedes, 0, SEEK_END);\n    } else {\n        new_pos = lseek(filedes, cur, SEEK_SET);\n    }\n    return new_pos;\n}\n\nvoid\nmd_close(int filedes)\n{\n    (void)close(filedes);\n}\n\nint\nmd_send(int s, const char *msg, int len, int flags)\n{\n    int res;\n\n    do {\n        res = send(s, msg, len, flags);\n    } while ((res < 0) && (errno == EINTR));\n\n    return res;\n}\n\nint\nmd_write(int filedes, const void *buf, int nbyte)\n{\n    int res;\n\n    do {\n        res = write(filedes, buf, nbyte);\n    } while ((res < 0) && (errno == EINTR));\n\n    return res;\n}\n\nint\nmd_read(int filedes, void *buf, int nbyte)\n{\n    int res;\n\n    do {\n        res = read(filedes, buf, nbyte);\n    } while ((res < 0) && (errno == EINTR));\n\n    return res;\n}\n\n/* Time of day in milli-seconds */\nstatic jlong\nmd_timeofday(void)\n{\n    struct timeval tv;\n\n    if ( gettimeofday(&tv, (void *)0) != 0 ) {\n        return (jlong)0; /* EOVERFLOW ? */\n    }\n    /*LINTED*/\n    return ((jlong)tv.tv_sec * (jlong)1000) + (jlong)(tv.tv_usec / 1000);\n}\n\n/* Hi-res timer in micro-seconds */\njlong\nmd_get_microsecs(void)\n{\n#if defined(LINUX) || defined(_ALLBSD_SOURCE) || defined(AIX)\n    return (jlong)(md_timeofday() * (jlong)1000); /* Milli to micro */\n#else\n    return (jlong)(gethrtime()/(hrtime_t)1000); /* Nano seconds to micro seconds */\n#endif\n}\n\n/* Time of day in milli-seconds */\njlong\nmd_get_timemillis(void)\n{\n    return md_timeofday();\n}\n\n/* Current CPU hi-res CPU time used */\njlong\nmd_get_thread_cpu_timemillis(void)\n{\n#if defined(LINUX) || defined(_ALLBSD_SOURCE) || defined(AIX)\n    return md_timeofday();\n#else\n    return (jlong)(gethrvtime()/1000); /* Nano seconds to milli seconds */\n#endif\n}\n\nvoid\nmd_get_prelude_path(char *path, int path_len, char *filename)\n{\n    void *addr;\n    char libdir[FILENAME_MAX+1];\n    Dl_info dlinfo;\n\n    libdir[0] = 0;\n#if defined(LINUX) || defined(_ALLBSD_SOURCE) || defined(AIX)\n    addr = (void*)&Agent_OnLoad;\n#else\n    /* Just using &Agent_OnLoad will get the first external symbol with\n     *   this name in the first .so, which may not be libhprof.so.\n     *   On Solaris we can actually ask for the address of our Agent_OnLoad.\n     */\n    addr = dlsym(RTLD_SELF, \"Agent_OnLoad\");\n    /* Just in case the above didn't work (missing linker patch?). */\n    if ( addr == NULL ) {\n        addr = (void*)&Agent_OnLoad;\n    }\n#endif\n\n    /* Use dladdr() to get the full path to libhprof.so, which we use to find\n     *  the prelude file.\n     */\n    dlinfo.dli_fname = NULL;\n    (void)dladdr(addr, &dlinfo);\n    if ( dlinfo.dli_fname != NULL ) {\n        char * lastSlash;\n\n        /* Full path to library name, need to move up one directory to 'lib' */\n        (void)strcpy(libdir, (char *)dlinfo.dli_fname);\n        lastSlash = strrchr(libdir, '/');\n        if ( lastSlash != NULL ) {\n            *lastSlash = '\\0';\n        }\n#ifndef __APPLE__\n        // not sure why other platforms have to go up two levels, but on macos we only need up one\n        lastSlash = strrchr(libdir, '/');\n        if ( lastSlash != NULL ) {\n            *lastSlash = '\\0';\n        }\n#endif /* __APPLE__ */\n    }\n    (void)snprintf(path, path_len, \"%s/%s\", libdir, filename);\n}\n\n\nint\nmd_vsnprintf(char *s, int n, const char *format, va_list ap)\n{\n    return vsnprintf(s, n, format, ap);\n}\n\nint\nmd_snprintf(char *s, int n, const char *format, ...)\n{\n    int ret;\n    va_list ap;\n\n    va_start(ap, format);\n    ret = md_vsnprintf(s, n, format, ap);\n    va_end(ap);\n    return ret;\n}\n\nvoid\nmd_system_error(char *buf, int len)\n{\n    char *p;\n\n    buf[0] = 0;\n    p = strerror(errno);\n    if ( p != NULL ) {\n        (void)strcpy(buf, p);\n    }\n}\n\nunsigned\nmd_htons(unsigned short s)\n{\n    return htons(s);\n}\n\nunsigned\nmd_htonl(unsigned l)\n{\n    return htonl(l);\n}\n\nunsigned\nmd_ntohs(unsigned short s)\n{\n    return ntohs(s);\n}\n\nunsigned\nmd_ntohl(unsigned l)\n{\n    return ntohl(l);\n}\n\nstatic void dll_build_name(char* buffer, size_t buflen,\n                           const char* paths, const char* fname) {\n    char *path, *paths_copy, *next_token;\n\n    paths_copy = strdup(paths);\n    if (paths_copy == NULL) {\n        return;\n    }\n\n    next_token = NULL;\n    path = strtok_r(paths_copy, \":\", &next_token);\n\n    while (path != NULL) {\n        snprintf(buffer, buflen, \"%s/lib%s\" JNI_LIB_SUFFIX, path, fname);\n        if (access(buffer, F_OK) == 0) {\n            break;\n        }\n        *buffer = '\\0';\n        path = strtok_r(NULL, \":\", &next_token);\n    }\n\n    free(paths_copy);\n}\n\n/* Create the actual fill filename for a dynamic library.  */\nvoid\nmd_build_library_name(char *holder, int holderlen, const char *pname, const char *fname)\n{\n    int   pnamelen;\n\n    /* Length of options directory location. */\n    pnamelen = pname ? strlen(pname) : 0;\n\n    *holder = '\\0';\n    /* Quietly truncate on buffer overflow.  Should be an error. */\n    if (pnamelen + (int)strlen(fname) + 10 > holderlen) {\n        return;\n    }\n\n    /* Construct path to library */\n    if (pnamelen == 0) {\n        (void)snprintf(holder, holderlen, \"lib%s\" JNI_LIB_SUFFIX, fname);\n    } else {\n      dll_build_name(holder, holderlen, pname, fname);\n    }\n}\n\n/* Load this library (return NULL on error, and error message in err_buf) */\nvoid *\nmd_load_library(const char *name, char *err_buf, int err_buflen)\n{\n    void * result;\n\n    result = dlopen(name, RTLD_LAZY);\n    if (result == NULL) {\n        (void)strncpy(err_buf, dlerror(), err_buflen-2);\n        err_buf[err_buflen-1] = '\\0';\n    }\n    return result;\n}\n\n/* Unload this library */\nvoid\nmd_unload_library(void *handle)\n{\n    (void)dlclose(handle);\n}\n\n/* Find an entry point inside this library (return NULL if not found) */\nvoid *\nmd_find_library_entry(void *handle, const char *name)\n{\n    void * sym;\n\n    sym =  dlsym(handle, name);\n    return sym;\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/npt/npt_md.h": "/*\n * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/* Native Platform Toolkit */\n\n#ifndef  _NPT_MD_H\n#define _NPT_MD_H\n\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include <jvm_md.h>\n\n#define NPT_LIBNAME \"npt\"\n\n#define NPT_INITIALIZE(path,pnpt,version,options)                       \\\n    {                                                                   \\\n        void   *_handle;                                                \\\n        void   *_sym;                                                   \\\n                                                                        \\\n        if ( (pnpt) == NULL ) NPT_ERROR(\"NptEnv* is NULL\");             \\\n        *(pnpt) = NULL;                                                 \\\n        _handle =  dlopen(path, RTLD_LAZY);                             \\\n        if ( _handle == NULL ) NPT_ERROR(\"Cannot open library\");        \\\n        _sym = dlsym(_handle, \"nptInitialize\");                         \\\n        if ( _sym == NULL ) NPT_ERROR(\"Cannot find nptInitialize\");     \\\n        ((NptInitialize)_sym)((pnpt), version, (options));              \\\n        if ( (*(pnpt)) == NULL ) NPT_ERROR(\"Cannot initialize NptEnv\"); \\\n        (*(pnpt))->libhandle = _handle;                                 \\\n    }\n\n#define NPT_TERMINATE(npt,options)                                      \\\n    {                                                                   \\\n        void *_handle;                                                  \\\n        void *_sym;                                                     \\\n                                                                        \\\n        if ( (npt) == NULL ) NPT_ERROR(\"NptEnv* is NULL\");              \\\n        _handle = (npt)->libhandle;                                     \\\n        _sym = dlsym(_handle, \"nptTerminate\");                          \\\n        if ( _sym == NULL ) NPT_ERROR(\"Cannot find nptTerminate\");      \\\n        ((NptTerminate)_sym)((npt), (options));                         \\\n        if ( _handle != NULL ) (void)dlclose(_handle);                  \\\n    }\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/classes/sun/misc/GThreadHelper.java": "/*\n * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage sun.misc;\n\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * This class is used to prevent multiple calling of g_thread_init ()\n * and gdk_thread_init ().\n *\n * Since version 2.24 of GLib, calling g_thread_init () multiple times is\n * allowed, but it will crash for older versions. There are two ways to\n * find out if g_thread_init () has been called:\n * g_thread_get_initialized (), but it was introduced in 2.20\n * g_thread_supported (), but it is a macro and cannot be loaded with dlsym.\n *\n * usage:\n * <pre>\n * lock();\n * try {\n *    if (!getAndSetInitializationNeededFlag()) {\n *        //call to g_thread_init();\n *        //call to gdk_thread_init();\n *    }\n * } finally {\n *    unlock();\n * }\n * </pre>\n */\npublic final class GThreadHelper {\n\n    private static final ReentrantLock LOCK = new ReentrantLock();\n    private static boolean isGThreadInitialized = false;\n\n    /**\n     * Acquires the lock.\n     */\n    public static void lock() {\n        LOCK.lock();\n    }\n\n    /**\n     * Releases the lock.\n     */\n    public static void unlock() {\n        LOCK.unlock();\n    }\n\n    /**\n     * Gets current value of initialization flag and sets it to {@code true}.\n     * MUST be called under the lock.\n     *\n     * A return value of {@code false} indicates that the calling code\n     * should call the g_thread_init() and gdk_thread_init() functions\n     * before releasing the lock.\n     *\n     * @return {@code true} if initialization has been completed.\n     */\n    public static boolean getAndSetInitializationNeededFlag() {\n        boolean ret = isGThreadInitialized;\n        isGThreadInitialized = true;\n        return ret;\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/back/linker_md.c": "/*\n * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * Adapted from JDK 1.2 linker_md.c v1.37. Note that we #define\n * NATIVE here, whether or not we're running solaris native threads.\n * Outside the VM, it's unclear how we can do the locking that is\n * done in the green threads version of the code below.\n */\n#define NATIVE\n\n/*\n * Machine Dependent implementation of the dynamic linking support\n * for java.  This routine is Solaris specific.\n */\n\n#include <stdio.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"path_md.h\"\n#ifndef NATIVE\n#include \"iomgr.h\"\n#include \"threads_md.h\"\n#endif\n\n#ifdef __APPLE__\n#define LIB_SUFFIX \"dylib\"\n#else\n#define LIB_SUFFIX \"so\"\n#endif\n\nstatic void dll_build_name(char* buffer, size_t buflen,\n                           const char* paths, const char* fname) {\n    char *path, *paths_copy, *next_token;\n\n    paths_copy = strdup(paths);\n    if (paths_copy == NULL) {\n        return;\n    }\n\n    next_token = NULL;\n    path = strtok_r(paths_copy, PATH_SEPARATOR, &next_token);\n\n    while (path != NULL) {\n        snprintf(buffer, buflen, \"%s/lib%s.\" LIB_SUFFIX, path, fname);\n        if (access(buffer, F_OK) == 0) {\n            break;\n        }\n        *buffer = '\\0';\n        path = strtok_r(NULL, PATH_SEPARATOR, &next_token);\n    }\n\n    free(paths_copy);\n}\n\n/*\n * create a string for the JNI native function name by adding the\n * appropriate decorations.\n */\nint\ndbgsysBuildFunName(char *name, int nameLen, int args_size, int encodingIndex)\n{\n  /* On Solaris, there is only one encoding method. */\n    if (encodingIndex == 0)\n        return 1;\n    return 0;\n}\n\n/*\n * create a string for the dynamic lib open call by adding the\n * appropriate pre and extensions to a filename and the path\n */\nvoid\ndbgsysBuildLibName(char *holder, int holderlen, const char *pname, const char *fname)\n{\n    const int pnamelen = pname ? strlen(pname) : 0;\n\n    *holder = '\\0';\n    /* Quietly truncate on buffer overflow.  Should be an error. */\n    if (pnamelen + (int)strlen(fname) + 10 > holderlen) {\n        return;\n    }\n\n    if (pnamelen == 0) {\n        (void)snprintf(holder, holderlen, \"lib%s.\" LIB_SUFFIX, fname);\n    } else {\n      dll_build_name(holder, holderlen, pname, fname);\n    }\n}\n\n#ifndef NATIVE\nextern int thr_main(void);\n#endif\n\nvoid *\ndbgsysLoadLibrary(const char *name, char *err_buf, int err_buflen)\n{\n    void * result;\n#ifdef NATIVE\n    result = dlopen(name, RTLD_LAZY);\n#else\n    sysMonitorEnter(greenThreadSelf(), &_dl_lock);\n    result = dlopen(name, RTLD_NOW);\n    sysMonitorExit(greenThreadSelf(), &_dl_lock);\n    /*\n     * This is a bit of bulletproofing to catch the commonly occurring\n     * problem of people loading a library which depends on libthread into\n     * the VM.  thr_main() should always return -1 which means that libthread\n     * isn't loaded.\n     */\n    if (thr_main() != -1) {\n         VM_CALL(panic)(\"libthread loaded into green threads\");\n    }\n#endif\n    if (result == NULL) {\n        (void)strncpy(err_buf, dlerror(), err_buflen-2);\n        err_buf[err_buflen-1] = '\\0';\n    }\n    return result;\n}\n\nvoid dbgsysUnloadLibrary(void *handle)\n{\n#ifndef NATIVE\n    sysMonitorEnter(greenThreadSelf(), &_dl_lock);\n#endif\n    (void)dlclose(handle);\n#ifndef NATIVE\n    sysMonitorExit(greenThreadSelf(), &_dl_lock);\n#endif\n}\n\nvoid * dbgsysFindLibraryEntry(void *handle, const char *name)\n{\n    void * sym;\n#ifndef NATIVE\n    sysMonitorEnter(greenThreadSelf(), &_dl_lock);\n#endif\n    sym =  dlsym(handle, name);\n#ifndef NATIVE\n    sysMonitorExit(greenThreadSelf(), &_dl_lock);\n#endif\n    return sym;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/aix/native/sun/nio/ch/AixPollPort.c": "/*\n * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.\n * Copyright 2012 SAP AG. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"jni.h\"\n#include \"jni_util.h\"\n#include \"jvm.h\"\n#include \"jlong.h\"\n\n#include \"sun_nio_ch_AixPollPort.h\"\n\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/poll.h>\n#include <sys/pollset.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <dlfcn.h>\n#include <errno.h>\n\n/* Initially copied from src/solaris/native/sun/nio/ch/nio_util.h */\n#define RESTARTABLE(_cmd, _result) do { \\\n  do { \\\n    _result = _cmd; \\\n  } while((_result == -1) && (errno == EINTR)); \\\n} while(0)\n\ntypedef pollset_t pollset_create_func(int maxfd);\ntypedef int pollset_destroy_func(pollset_t ps);\ntypedef int pollset_ctl_func(pollset_t ps, struct poll_ctl *pollctl_array, int array_length);\ntypedef int pollset_poll_func(pollset_t ps, struct pollfd *polldata_array, int array_length, int timeout);\nstatic pollset_create_func* _pollset_create = NULL;\nstatic pollset_destroy_func* _pollset_destroy = NULL;\nstatic pollset_ctl_func* _pollset_ctl = NULL;\nstatic pollset_poll_func* _pollset_poll = NULL;\n\nJNIEXPORT void JNICALL\nJava_sun_nio_ch_AixPollPort_init(JNIEnv* env, jclass this) {\n    _pollset_create = (pollset_create_func*) dlsym(RTLD_DEFAULT, \"pollset_create\");\n    _pollset_destroy = (pollset_destroy_func*) dlsym(RTLD_DEFAULT, \"pollset_destroy\");\n    _pollset_ctl = (pollset_ctl_func*) dlsym(RTLD_DEFAULT, \"pollset_ctl\");\n    _pollset_poll = (pollset_poll_func*) dlsym(RTLD_DEFAULT, \"pollset_poll\");\n    if (_pollset_create == NULL || _pollset_destroy == NULL ||\n        _pollset_ctl == NULL || _pollset_poll == NULL) {\n        JNU_ThrowInternalError(env, \"unable to get address of pollset functions\");\n    }\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_AixPollPort_eventSize(JNIEnv* env, jclass this) {\n    return sizeof(struct pollfd);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_AixPollPort_eventsOffset(JNIEnv* env, jclass this) {\n    return offsetof(struct pollfd, events);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_AixPollPort_reventsOffset(JNIEnv* env, jclass this) {\n    return offsetof(struct pollfd, revents);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_AixPollPort_fdOffset(JNIEnv* env, jclass this) {\n    return offsetof(struct pollfd, fd);\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_AixPollPort_pollsetCreate(JNIEnv *env, jclass c) {\n    /* pollset_create can take the maximum number of fds, but we\n     * cannot predict this number so we leave it at OPEN_MAX. */\n    pollset_t ps = _pollset_create(-1);\n    if (ps < 0) {\n       JNU_ThrowIOExceptionWithLastError(env, \"pollset_create failed\");\n    }\n    return (int)ps;\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_AixPollPort_pollsetCtl(JNIEnv *env, jclass c, jint ps,\n                                       jint opcode, jint fd, jint events) {\n    struct poll_ctl event;\n    int res;\n\n    event.cmd = opcode;\n    event.events = events;\n    event.fd = fd;\n\n    RESTARTABLE(_pollset_ctl((pollset_t)ps, &event, 1 /* length */), res);\n\n    return (res == 0) ? 0 : errno;\n}\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_AixPollPort_pollsetPoll(JNIEnv *env, jclass c,\n                                        jint ps, jlong address, jint numfds) {\n    struct pollfd *events = jlong_to_ptr(address);\n    int res;\n\n    RESTARTABLE(_pollset_poll(ps, events, numfds, -1), res);\n    if (res < 0) {\n        JNU_ThrowIOExceptionWithLastError(env, \"pollset_poll failed\");\n    }\n    return res;\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_ch_AixPollPort_pollsetDestroy(JNIEnv *env, jclass c, jint ps) {\n    int res;\n    RESTARTABLE(_pollset_destroy((pollset_t)ps), res);\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_ch_AixPollPort_socketpair(JNIEnv* env, jclass clazz, jintArray sv) {\n    int sp[2];\n    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) == -1) {\n        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n    } else {\n        jint res[2];\n        res[0] = (jint)sp[0];\n        res[1] = (jint)sp[1];\n        (*env)->SetIntArrayRegion(env, sv, 0, 2, &res[0]);\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_ch_AixPollPort_interrupt(JNIEnv *env, jclass c, jint fd) {\n    int res;\n    int buf[1];\n    buf[0] = 1;\n    RESTARTABLE(write(fd, buf, 1), res);\n    if (res < 0) {\n        JNU_ThrowIOExceptionWithLastError(env, \"write failed\");\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_ch_AixPollPort_drain1(JNIEnv *env, jclass cl, jint fd) {\n    int res;\n    char buf[1];\n    RESTARTABLE(read(fd, buf, 1), res);\n    if (res < 0) {\n        JNU_ThrowIOExceptionWithLastError(env, \"drain1 failed\");\n    }\n}\n\nJNIEXPORT void JNICALL\nJava_sun_nio_ch_AixPollPort_close0(JNIEnv *env, jclass c, jint fd) {\n    int res;\n    RESTARTABLE(close(fd), res);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/macosx/bin/java_md_macosx.c": "/*\n * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"java.h\"\n#include \"jvm_md.h\"\n#include <dirent.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n\n#include \"manifest_info.h\"\n#include \"version_comp.h\"\n\n/* Support Cocoa event loop on the main thread */\n#include <Cocoa/Cocoa.h>\n#include <objc/objc-runtime.h>\n#include <objc/objc-auto.h>\n\n#include <errno.h>\n#include <spawn.h>\n\nstruct NSAppArgs {\n    int argc;\n    char **argv;\n};\n\n#define JVM_DLL \"libjvm.dylib\"\n#define JAVA_DLL \"libjava.dylib\"\n/* FALLBACK avoids naming conflicts with system libraries\n * (eg, ImageIO's libJPEG.dylib) */\n#define LD_LIBRARY_PATH \"DYLD_FALLBACK_LIBRARY_PATH\"\n\n/*\n * If a processor / os combination has the ability to run binaries of\n * two data models and cohabitation of jre/jdk bits with both data\n * models is supported, then DUAL_MODE is defined. MacOSX is a hybrid\n * system in that, the universal library can contain all types of libraries\n * 32/64 and client/server, thus the spawn is capable of linking with the\n * appropriate library as requested.\n *\n * Notes:\n * 1. VM. DUAL_MODE is disabled, and not supported, however, it is left here in\n *    for experimentation and perhaps enable it in the future.\n * 2. At the time of this writing, the universal library contains only\n *    a server 64-bit server JVM.\n * 3. \"-client\" command line option is supported merely as a command line flag,\n *    for, compatibility reasons, however, a server VM will be launched.\n */\n\n/*\n * Flowchart of launcher execs and options processing on unix\n *\n * The selection of the proper vm shared library to open depends on\n * several classes of command line options, including vm \"flavor\"\n * options (-client, -server) and the data model options, -d32  and\n * -d64, as well as a version specification which may have come from\n * the command line or from the manifest of an executable jar file.\n * The vm selection options are not passed to the running\n * virtual machine; they must be screened out by the launcher.\n *\n * The version specification (if any) is processed first by the\n * platform independent routine SelectVersion.  This may result in\n * the exec of the specified launcher version.\n *\n * Now, in most cases,the launcher will dlopen the target libjvm.so. All\n * required libraries are loaded by the runtime linker, using the known paths\n * baked into the shared libraries at compile time. Therefore,\n * in most cases, the launcher will only exec, if the data models are\n * mismatched, and will not set any environment variables, regardless of the\n * data models.\n *\n *\n *\n *  Main\n *  (incoming argv)\n *  |\n * \\|/\n * SelectVersion\n * (selects the JRE version, note: not data model)\n *  |\n * \\|/\n * CreateExecutionEnvironment\n * (determines desired data model)\n *  |\n *  |\n * \\|/\n *  Have Desired Model ? --> NO --> Is Dual-Mode ? --> NO --> Exit(with error)\n *  |                                          |\n *  |                                          |\n *  |                                         \\|/\n *  |                                         YES\n *  |                                          |\n *  |                                          |\n *  |                                         \\|/\n *  |                                CheckJvmType\n *  |                               (removes -client, -server etc.)\n *  |                                          |\n *  |                                          |\n * \\|/                                        \\|/\n * YES                             Find the desired executable/library\n *  |                                          |\n *  |                                          |\n * \\|/                                        \\|/\n * CheckJvmType                             POINT A\n * (removes -client, -server, etc.)\n *  |\n *  |\n * \\|/\n * TranslateDashJArgs...\n * (Prepare to pass args to vm)\n *  |\n *  |\n * \\|/\n * ParseArguments\n * (removes -d32 and -d64 if any,\n *  processes version options,\n *  creates argument list for vm,\n *  etc.)\n *   |\n *   |\n *  \\|/\n * POINT A\n *   |\n *   |\n *  \\|/\n * Path is desired JRE ? YES --> Have Desired Model ? NO --> Re-exec --> Main\n *  NO                               YES --> Continue\n *   |\n *   |\n *  \\|/\n * Paths have well known\n * jvm paths ?       --> NO --> Have Desired Model ? NO --> Re-exec --> Main\n *  YES                              YES --> Continue\n *   |\n *   |\n *  \\|/\n *  Does libjvm.so exist\n *  in any of them ? --> NO --> Have Desired Model ? NO --> Re-exec --> Main\n *   YES                             YES --> Continue\n *   |\n *   |\n *  \\|/\n * Re-exec / Spawn\n *   |\n *   |\n *  \\|/\n * Main\n */\n\n#define GetArch() GetArchPath(CURRENT_DATA_MODEL)\n\n/* Store the name of the executable once computed */\nstatic char *execname = NULL;\n\n/*\n * execname accessor from other parts of platform dependent logic\n */\nconst char *\nGetExecName() {\n    return execname;\n}\n\nconst char *\nGetArchPath(int nbits)\n{\n    switch(nbits) {\n        default:\n            return LIBARCHNAME;\n    }\n}\n\n\n/*\n * Exports the JNI interface from libjli\n *\n * This allows client code to link against the .jre/.jdk bundles,\n * and not worry about trying to pick a HotSpot to link against.\n *\n * Switching architectures is unsupported, since client code has\n * made that choice before the JVM was requested.\n */\n\nstatic InvocationFunctions *sExportedJNIFunctions = NULL;\nstatic char *sPreferredJVMType = NULL;\n\nstatic InvocationFunctions *GetExportedJNIFunctions() {\n    if (sExportedJNIFunctions != NULL) return sExportedJNIFunctions;\n\n    char jrePath[PATH_MAX];\n    jboolean gotJREPath = GetJREPath(jrePath, sizeof(jrePath), GetArch(), JNI_FALSE);\n    if (!gotJREPath) {\n        JLI_ReportErrorMessage(\"Failed to GetJREPath()\");\n        return NULL;\n    }\n\n    char *preferredJVM = sPreferredJVMType;\n    if (preferredJVM == NULL) {\n#if defined(__i386__)\n        preferredJVM = \"client\";\n#elif defined(__x86_64__)\n        preferredJVM = \"server\";\n#else\n#error \"Unknown architecture - needs definition\"\n#endif\n    }\n\n    char jvmPath[PATH_MAX];\n    jboolean gotJVMPath = GetJVMPath(jrePath, preferredJVM, jvmPath, sizeof(jvmPath), GetArch(), CURRENT_DATA_MODEL);\n    if (!gotJVMPath) {\n        JLI_ReportErrorMessage(\"Failed to GetJVMPath()\");\n        return NULL;\n    }\n\n    InvocationFunctions *fxns = malloc(sizeof(InvocationFunctions));\n    jboolean vmLoaded = LoadJavaVM(jvmPath, fxns);\n    if (!vmLoaded) {\n        JLI_ReportErrorMessage(\"Failed to LoadJavaVM()\");\n        return NULL;\n    }\n\n    return sExportedJNIFunctions = fxns;\n}\n\nJNIEXPORT jint JNICALL\nJNI_GetDefaultJavaVMInitArgs(void *args) {\n    InvocationFunctions *ifn = GetExportedJNIFunctions();\n    if (ifn == NULL) return JNI_ERR;\n    return ifn->GetDefaultJavaVMInitArgs(args);\n}\n\nJNIEXPORT jint JNICALL\nJNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args) {\n    InvocationFunctions *ifn = GetExportedJNIFunctions();\n    if (ifn == NULL) return JNI_ERR;\n    return ifn->CreateJavaVM(pvm, penv, args);\n}\n\nJNIEXPORT jint JNICALL\nJNI_GetCreatedJavaVMs(JavaVM **vmBuf, jsize bufLen, jsize *nVMs) {\n    InvocationFunctions *ifn = GetExportedJNIFunctions();\n    if (ifn == NULL) return JNI_ERR;\n    return ifn->GetCreatedJavaVMs(vmBuf, bufLen, nVMs);\n}\n\n/*\n * Allow JLI-aware launchers to specify a client/server preference\n */\nJNIEXPORT void JNICALL\nJLI_SetPreferredJVM(const char *prefJVM) {\n    if (sPreferredJVMType != NULL) {\n        free(sPreferredJVMType);\n        sPreferredJVMType = NULL;\n    }\n\n    if (prefJVM == NULL) return;\n    sPreferredJVMType = strdup(prefJVM);\n}\n\nstatic BOOL awtLoaded = NO;\nstatic pthread_mutex_t awtLoaded_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t  awtLoaded_cv = PTHREAD_COND_INITIALIZER;\n\nJNIEXPORT void JNICALL\nJLI_NotifyAWTLoaded()\n{\n    pthread_mutex_lock(&awtLoaded_mutex);\n    awtLoaded = YES;\n    pthread_cond_signal(&awtLoaded_cv);\n    pthread_mutex_unlock(&awtLoaded_mutex);\n}\n\nstatic int (*main_fptr)(int argc, char **argv) = NULL;\n\n/*\n * Unwrap the arguments and re-run main()\n */\nstatic void *apple_main (void *arg)\n{\n    objc_registerThreadWithCollector();\n\n    if (main_fptr == NULL) {\n        main_fptr = (int (*)())dlsym(RTLD_DEFAULT, \"main\");\n        if (main_fptr == NULL) {\n            JLI_ReportErrorMessageSys(\"error locating main entrypoint\\n\");\n            exit(1);\n        }\n    }\n\n    struct NSAppArgs *args = (struct NSAppArgs *) arg;\n    exit(main_fptr(args->argc, args->argv));\n}\n\nstatic void dummyTimer(CFRunLoopTimerRef timer, void *info) {}\n\nstatic void ParkEventLoop() {\n    // RunLoop needs at least one source, and 1e20 is pretty far into the future\n    CFRunLoopTimerRef t = CFRunLoopTimerCreate(kCFAllocatorDefault, 1.0e20, 0.0, 0, 0, dummyTimer, NULL);\n    CFRunLoopAddTimer(CFRunLoopGetCurrent(), t, kCFRunLoopDefaultMode);\n    CFRelease(t);\n\n    // Park this thread in the main run loop.\n    int32_t result;\n    do {\n        result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e20, false);\n    } while (result != kCFRunLoopRunFinished);\n}\n\n/*\n * Mac OS X mandates that the GUI event loop run on very first thread of\n * an application. This requires that we re-call Java's main() on a new\n * thread, reserving the 'main' thread for Cocoa.\n */\nstatic void MacOSXStartup(int argc, char *argv[]) {\n    // Thread already started?\n    static jboolean started = false;\n    if (started) {\n        return;\n    }\n    started = true;\n\n    // Hand off arguments\n    struct NSAppArgs args;\n    args.argc = argc;\n    args.argv = argv;\n\n    // Fire up the main thread\n    pthread_t main_thr;\n    if (pthread_create(&main_thr, NULL, &apple_main, &args) != 0) {\n        JLI_ReportErrorMessageSys(\"Could not create main thread: %s\\n\", strerror(errno));\n        exit(1);\n    }\n    if (pthread_detach(main_thr)) {\n        JLI_ReportErrorMessageSys(\"pthread_detach() failed: %s\\n\", strerror(errno));\n        exit(1);\n    }\n\n    ParkEventLoop();\n}\n\nvoid\nCreateExecutionEnvironment(int *pargc, char ***pargv,\n                           char jrepath[], jint so_jrepath,\n                           char jvmpath[], jint so_jvmpath,\n                           char jvmcfg[],  jint so_jvmcfg) {\n  /*\n   * First, determine if we are running the desired data model.  If we\n   * are running the desired data model, all the error messages\n   * associated with calling GetJREPath, ReadKnownVMs, etc. should be\n   * output.  However, if we are not running the desired data model,\n   * some of the errors should be suppressed since it is more\n   * informative to issue an error message based on whether or not the\n   * os/processor combination has dual mode capabilities.\n   */\n    jboolean jvmpathExists;\n\n    /* Compute/set the name of the executable */\n    SetExecname(*pargv);\n\n    /* Check data model flags, and exec process, if needed */\n    {\n      char *arch        = (char *)GetArch(); /* like sparc or sparcv9 */\n      char * jvmtype    = NULL;\n      int  argc         = *pargc;\n      char **argv       = *pargv;\n      int running       = CURRENT_DATA_MODEL;\n\n      int wanted        = running;      /* What data mode is being\n                                           asked for? Current model is\n                                           fine unless another model\n                                           is asked for */\n\n      char** newargv    = NULL;\n      int    newargc    = 0;\n\n      /*\n       * Starting in 1.5, all unix platforms accept the -d32 and -d64\n       * options.  On platforms where only one data-model is supported\n       * (e.g. ia-64 Linux), using the flag for the other data model is\n       * an error and will terminate the program.\n       */\n\n      { /* open new scope to declare local variables */\n        int i;\n\n        newargv = (char **)JLI_MemAlloc((argc+1) * sizeof(char*));\n        newargv[newargc++] = argv[0];\n\n        /* scan for data model arguments and remove from argument list;\n           last occurrence determines desired data model */\n        for (i=1; i < argc; i++) {\n\n          if (JLI_StrCmp(argv[i], \"-J-d64\") == 0 || JLI_StrCmp(argv[i], \"-d64\") == 0) {\n            wanted = 64;\n            continue;\n          }\n          if (JLI_StrCmp(argv[i], \"-J-d32\") == 0 || JLI_StrCmp(argv[i], \"-d32\") == 0) {\n            wanted = 32;\n            continue;\n          }\n          newargv[newargc++] = argv[i];\n\n          if (IsJavaArgs()) {\n            if (argv[i][0] != '-') continue;\n          } else {\n            if (JLI_StrCmp(argv[i], \"-classpath\") == 0 || JLI_StrCmp(argv[i], \"-cp\") == 0) {\n              i++;\n              if (i >= argc) break;\n              newargv[newargc++] = argv[i];\n              continue;\n            }\n            if (argv[i][0] != '-') { i++; break; }\n          }\n        }\n\n        /* copy rest of args [i .. argc) */\n        while (i < argc) {\n          newargv[newargc++] = argv[i++];\n        }\n        newargv[newargc] = NULL;\n\n        /*\n         * newargv has all proper arguments here\n         */\n\n        argc = newargc;\n        argv = newargv;\n      }\n\n      /* If the data model is not changing, it is an error if the\n         jvmpath does not exist */\n      if (wanted == running) {\n        /* Find out where the JRE is that we will be using. */\n        if (!GetJREPath(jrepath, so_jrepath, arch, JNI_FALSE) ) {\n          JLI_ReportErrorMessage(JRE_ERROR1);\n          exit(2);\n        }\n        JLI_Snprintf(jvmcfg, so_jvmcfg, \"%s%slib%s%s%sjvm.cfg\",\n          jrepath, FILESEP, FILESEP,  \"\", \"\");\n        /* Find the specified JVM type */\n        if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {\n          JLI_ReportErrorMessage(CFG_ERROR7);\n          exit(1);\n        }\n\n        jvmpath[0] = '\\0';\n        jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);\n        if (JLI_StrCmp(jvmtype, \"ERROR\") == 0) {\n            JLI_ReportErrorMessage(CFG_ERROR9);\n            exit(4);\n        }\n\n        if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath, arch, wanted)) {\n          JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);\n          exit(4);\n        }\n\n        /*\n         * Mac OS X requires the Cocoa event loop to be run on the \"main\"\n         * thread. Spawn off a new thread to run main() and pass\n         * this thread off to the Cocoa event loop.\n         */\n        MacOSXStartup(argc, argv);\n\n        /*\n         * we seem to have everything we need, so without further ado\n         * we return back, otherwise proceed to set the environment.\n         */\n        return;\n      } else {  /* do the same speculatively or exit */\n#if defined(DUAL_MODE)\n        if (running != wanted) {\n          /* Find out where the JRE is that we will be using. */\n          if (!GetJREPath(jrepath, so_jrepath, GetArchPath(wanted), JNI_TRUE)) {\n            /* give up and let other code report error message */\n            JLI_ReportErrorMessage(JRE_ERROR2, wanted);\n            exit(1);\n          }\n          JLI_Snprintf(jvmcfg, so_jvmcfg, \"%s%slib%s%s%sjvm.cfg\",\n            jrepath, FILESEP, FILESEP,  \"\", \"\");\n          /*\n           * Read in jvm.cfg for target data model and process vm\n           * selection options.\n           */\n          if (ReadKnownVMs(jvmcfg, JNI_TRUE) < 1) {\n            /* give up and let other code report error message */\n            JLI_ReportErrorMessage(JRE_ERROR2, wanted);\n            exit(1);\n          }\n          jvmpath[0] = '\\0';\n          jvmtype = CheckJvmType(pargc, pargv, JNI_TRUE);\n          if (JLI_StrCmp(jvmtype, \"ERROR\") == 0) {\n            JLI_ReportErrorMessage(CFG_ERROR9);\n            exit(4);\n          }\n\n          /* exec child can do error checking on the existence of the path */\n          jvmpathExists = GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath, GetArchPath(wanted), wanted);\n        }\n#else /* ! DUAL_MODE */\n        JLI_ReportErrorMessage(JRE_ERROR2, wanted);\n        exit(1);\n#endif /* DUAL_MODE */\n        }\n        {\n            char *newexec = execname;\n            JLI_TraceLauncher(\"TRACER_MARKER:About to EXEC\\n\");\n            (void) fflush(stdout);\n            (void) fflush(stderr);\n            /*\n            * Use posix_spawn() instead of execv() on Mac OS X.\n            * This allows us to choose which architecture the child process\n            * should run as.\n            */\n            {\n                posix_spawnattr_t attr;\n                size_t unused_size;\n                pid_t  unused_pid;\n\n#if defined(__i386__) || defined(__x86_64__)\n                cpu_type_t cpu_type[] = { (wanted == 64) ? CPU_TYPE_X86_64 : CPU_TYPE_X86,\n                                    (running== 64) ? CPU_TYPE_X86_64 : CPU_TYPE_X86 };\n#else\n                cpu_type_t cpu_type[] = { CPU_TYPE_ANY };\n#endif /* __i386 .. */\n\n                posix_spawnattr_init(&attr);\n                posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETEXEC);\n                posix_spawnattr_setbinpref_np(&attr, sizeof(cpu_type) / sizeof(cpu_type_t),\n                                            cpu_type, &unused_size);\n\n                posix_spawn(&unused_pid, newexec, NULL, &attr, argv, environ);\n            }\n            JLI_ReportErrorMessageSys(JRE_ERROR4, newexec);\n\n#if defined(DUAL_MODE)\n            if (running != wanted) {\n                JLI_ReportErrorMessage(JRE_ERROR5, wanted, running);\n            }\n#endif /* DUAL_MODE */\n        }\n        exit(1);\n    }\n}\n\n/*\n * VM choosing is done by the launcher (java.c).\n */\nstatic jboolean\nGetJVMPath(const char *jrepath, const char *jvmtype,\n           char *jvmpath, jint jvmpathsize, const char * arch, int bitsWanted)\n{\n    struct stat s;\n\n    if (JLI_StrChr(jvmtype, '/')) {\n        JLI_Snprintf(jvmpath, jvmpathsize, \"%s/\" JVM_DLL, jvmtype);\n    } else {\n        /*\n         * macosx client library is built thin, i386 only.\n         * 64 bit client requests must load server library\n         */\n        const char *jvmtypeUsed = ((bitsWanted == 64) && (strcmp(jvmtype, \"client\") == 0)) ? \"server\" : jvmtype;\n        JLI_Snprintf(jvmpath, jvmpathsize, \"%s/lib/%s/\" JVM_DLL, jrepath, jvmtypeUsed);\n    }\n\n    JLI_TraceLauncher(\"Does `%s' exist ... \", jvmpath);\n\n    if (stat(jvmpath, &s) == 0) {\n        JLI_TraceLauncher(\"yes.\\n\");\n        return JNI_TRUE;\n    } else {\n        JLI_TraceLauncher(\"no.\\n\");\n        return JNI_FALSE;\n    }\n}\n\n/*\n * Find path to JRE based on .exe's location or registry settings.\n */\nstatic jboolean\nGetJREPath(char *path, jint pathsize, const char * arch, jboolean speculative)\n{\n    char libjava[MAXPATHLEN];\n\n    if (GetApplicationHome(path, pathsize)) {\n        /* Is JRE co-located with the application? */\n        JLI_Snprintf(libjava, sizeof(libjava), \"%s/lib/\" JAVA_DLL, path);\n        if (access(libjava, F_OK) == 0) {\n            return JNI_TRUE;\n        }\n        /* ensure storage for path + /jre + NULL */\n        if ((JLI_StrLen(path) + 4 + 1) > pathsize) {\n            JLI_TraceLauncher(\"Insufficient space to store JRE path\\n\");\n            return JNI_FALSE;\n        }\n        /* Does the app ship a private JRE in <apphome>/jre directory? */\n        JLI_Snprintf(libjava, sizeof(libjava), \"%s/jre/lib/\" JAVA_DLL, path);\n        if (access(libjava, F_OK) == 0) {\n            JLI_StrCat(path, \"/jre\");\n            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n            return JNI_TRUE;\n        }\n    }\n\n    /* try to find ourselves instead */\n    Dl_info selfInfo;\n    dladdr(&GetJREPath, &selfInfo);\n\n    char *realPathToSelf = realpath(selfInfo.dli_fname, path);\n    if (realPathToSelf != path) {\n        return JNI_FALSE;\n    }\n\n    size_t pathLen = strlen(realPathToSelf);\n    if (pathLen == 0) {\n        return JNI_FALSE;\n    }\n\n    const char lastPathComponent[] = \"/lib/jli/libjli.dylib\";\n    size_t sizeOfLastPathComponent = sizeof(lastPathComponent) - 1;\n    if (pathLen < sizeOfLastPathComponent) {\n        return JNI_FALSE;\n    }\n\n    size_t indexOfLastPathComponent = pathLen - sizeOfLastPathComponent;\n    if (0 == strncmp(realPathToSelf + indexOfLastPathComponent, lastPathComponent, sizeOfLastPathComponent - 1)) {\n        realPathToSelf[indexOfLastPathComponent + 1] = '\\0';\n        return JNI_TRUE;\n    }\n\n    if (!speculative)\n      JLI_ReportErrorMessage(JRE_ERROR8 JAVA_DLL);\n    return JNI_FALSE;\n}\n\njboolean\nLoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)\n{\n    Dl_info dlinfo;\n    void *libjvm;\n\n    JLI_TraceLauncher(\"JVM path is %s\\n\", jvmpath);\n\n    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n    if (libjvm == NULL) {\n        JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);\n        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n        return JNI_FALSE;\n    }\n\n    ifn->CreateJavaVM = (CreateJavaVM_t)\n        dlsym(libjvm, \"JNI_CreateJavaVM\");\n    if (ifn->CreateJavaVM == NULL) {\n        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n        return JNI_FALSE;\n    }\n\n    ifn->GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t)\n        dlsym(libjvm, \"JNI_GetDefaultJavaVMInitArgs\");\n    if (ifn->GetDefaultJavaVMInitArgs == NULL) {\n        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n        return JNI_FALSE;\n    }\n\n    ifn->GetCreatedJavaVMs = (GetCreatedJavaVMs_t)\n    dlsym(libjvm, \"JNI_GetCreatedJavaVMs\");\n    if (ifn->GetCreatedJavaVMs == NULL) {\n        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n        return JNI_FALSE;\n    }\n\n    return JNI_TRUE;\n}\n\n/*\n * Compute the name of the executable\n *\n * In order to re-exec securely we need the absolute path of the\n * executable. On Solaris getexecname(3c) may not return an absolute\n * path so we use dladdr to get the filename of the executable and\n * then use realpath to derive an absolute path. From Solaris 9\n * onwards the filename returned in DL_info structure from dladdr is\n * an absolute pathname so technically realpath isn't required.\n * On Linux we read the executable name from /proc/self/exe.\n * As a fallback, and for platforms other than Solaris and Linux,\n * we use FindExecName to compute the executable name.\n */\nconst char*\nSetExecname(char **argv)\n{\n    char* exec_path = NULL;\n    {\n        Dl_info dlinfo;\n        int (*fptr)();\n\n        fptr = (int (*)())dlsym(RTLD_DEFAULT, \"main\");\n        if (fptr == NULL) {\n            JLI_ReportErrorMessage(DLL_ERROR3, dlerror());\n            return JNI_FALSE;\n        }\n\n        if (dladdr((void*)fptr, &dlinfo)) {\n            char *resolved = (char*)JLI_MemAlloc(PATH_MAX+1);\n            if (resolved != NULL) {\n                exec_path = realpath(dlinfo.dli_fname, resolved);\n                if (exec_path == NULL) {\n                    JLI_MemFree(resolved);\n                }\n            }\n        }\n    }\n    if (exec_path == NULL) {\n        exec_path = FindExecName(argv[0]);\n    }\n    execname = exec_path;\n    return exec_path;\n}\n\n/*\n * BSD's implementation of CounterGet()\n */\nint64_t\nCounterGet()\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (tv.tv_sec * 1000) + tv.tv_usec;\n}\n\n\n/* --- Splash Screen shared library support --- */\n\nstatic JavaVM* SetJavaVMValue()\n{\n    JavaVM * jvm = NULL;\n\n    // The handle is good for both the launcher and the libosxapp.dylib\n    void * handle = dlopen(NULL, RTLD_LAZY | RTLD_GLOBAL);\n    if (handle) {\n        typedef JavaVM* (*JLI_GetJavaVMInstance_t)();\n\n        JLI_GetJavaVMInstance_t JLI_GetJavaVMInstance =\n            (JLI_GetJavaVMInstance_t)dlsym(handle,\n                    \"JLI_GetJavaVMInstance\");\n        if (JLI_GetJavaVMInstance) {\n            jvm = JLI_GetJavaVMInstance();\n        }\n\n        if (jvm) {\n            typedef void (*OSXAPP_SetJavaVM_t)(JavaVM*);\n\n            OSXAPP_SetJavaVM_t OSXAPP_SetJavaVM =\n                (OSXAPP_SetJavaVM_t)dlsym(handle, \"OSXAPP_SetJavaVM\");\n            if (OSXAPP_SetJavaVM) {\n                OSXAPP_SetJavaVM(jvm);\n            } else {\n                jvm = NULL;\n            }\n        }\n\n        dlclose(handle);\n    }\n\n    return jvm;\n}\n\nstatic const char* SPLASHSCREEN_SO = JNI_LIB_NAME(\"splashscreen\");\n\nstatic void* hSplashLib = NULL;\n\nvoid* SplashProcAddress(const char* name) {\n    if (!hSplashLib) {\n        char jrePath[PATH_MAX];\n        if (!GetJREPath(jrePath, sizeof(jrePath), GetArch(), JNI_FALSE)) {\n            JLI_ReportErrorMessage(JRE_ERROR1);\n            return NULL;\n        }\n\n        char splashPath[PATH_MAX];\n        const int ret = JLI_Snprintf(splashPath, sizeof(splashPath),\n                \"%s/lib/%s\", jrePath, SPLASHSCREEN_SO);\n        if (ret >= (int)sizeof(splashPath)) {\n            JLI_ReportErrorMessage(JRE_ERROR11);\n            return NULL;\n        }\n        if (ret < 0) {\n            JLI_ReportErrorMessage(JRE_ERROR13);\n            return NULL;\n        }\n\n        hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);\n        // It's OK if dlopen() fails. The splash screen library binary file\n        // might have been stripped out from the JRE image to reduce its size\n        // (e.g. on embedded platforms).\n\n        if (hSplashLib) {\n            if (!SetJavaVMValue()) {\n                dlclose(hSplashLib);\n                hSplashLib = NULL;\n            }\n        }\n    }\n    if (hSplashLib) {\n        void* sym = dlsym(hSplashLib, name);\n        return sym;\n    } else {\n        return NULL;\n    }\n}\n\nvoid SplashFreeLibrary() {\n    if (hSplashLib) {\n        dlclose(hSplashLib);\n        hSplashLib = NULL;\n    }\n}\n\n/*\n * Block current thread and continue execution in a new thread\n */\nint\nContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {\n    int rslt;\n    pthread_t tid;\n    pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    if (stack_size > 0) {\n      pthread_attr_setstacksize(&attr, stack_size);\n    }\n\n    if (pthread_create(&tid, &attr, (void *(*)(void*))continuation, (void*)args) == 0) {\n      void * tmp;\n      pthread_join(tid, &tmp);\n      rslt = (int)tmp;\n    } else {\n     /*\n      * Continue execution in current thread if for some reason (e.g. out of\n      * memory/LWP)  a new thread can't be created. This will likely fail\n      * later in continuation as JNI_CreateJavaVM needs to create quite a\n      * few new threads, anyway, just give it a try..\n      */\n      rslt = continuation(args);\n    }\n\n    pthread_attr_destroy(&attr);\n    return rslt;\n}\n\nvoid SetJavaLauncherPlatformProps() {\n   /* Linux only */\n}\n\njboolean\nServerClassMachine(void) {\n    return JNI_TRUE;\n}\n\nstatic JavaVM* jvmInstance = NULL;\nstatic jboolean sameThread = JNI_FALSE; /* start VM in current thread */\n\n/*\n * Note there is a callback on this function from the splashscreen logic,\n * this as well SetJavaVMValue() needs to be simplified.\n */\nJavaVM*\nJLI_GetJavaVMInstance()\n{\n    return jvmInstance;\n}\n\nvoid\nRegisterThread()\n{\n    objc_registerThreadWithCollector();\n}\n\nstatic void\nSetXDockArgForAWT(const char *arg)\n{\n    char envVar[80];\n    if (strstr(arg, \"-Xdock:name=\") == arg) {\n        /*\n         * The APP_NAME_<pid> environment variable is used to pass\n         * an application name as specified with the -Xdock:name command\n         * line option from Java launcher code to the AWT code in order\n         * to assign this name to the app's dock tile on the Mac.\n         * The _<pid> part is added to avoid collisions with child processes.\n         *\n         * WARNING: This environment variable is an implementation detail and\n         * isn't meant for use outside of the core platform. The mechanism for\n         * passing this information from Java launcher to other modules may\n         * change drastically between update release, and it may even be\n         * removed or replaced with another mechanism.\n         *\n         * NOTE: It is used by SWT, and JavaFX.\n         */\n        snprintf(envVar, sizeof(envVar), \"APP_NAME_%d\", getpid());\n        setenv(envVar, (arg + 12), 1);\n    }\n\n    if (strstr(arg, \"-Xdock:icon=\") == arg) {\n        /*\n         * The APP_ICON_<pid> environment variable is used to pass\n         * an application icon as specified with the -Xdock:icon command\n         * line option from Java launcher code to the AWT code in order\n         * to assign this icon to the app's dock tile on the Mac.\n         * The _<pid> part is added to avoid collisions with child processes.\n         *\n         * WARNING: This environment variable is an implementation detail and\n         * isn't meant for use outside of the core platform. The mechanism for\n         * passing this information from Java launcher to other modules may\n         * change drastically between update release, and it may even be\n         * removed or replaced with another mechanism.\n         *\n         * NOTE: It is used by SWT, and JavaFX.\n         */\n        snprintf(envVar, sizeof(envVar), \"APP_ICON_%d\", getpid());\n        setenv(envVar, (arg + 12), 1);\n    }\n}\n\nstatic void\nSetMainClassForAWT(JNIEnv *env, jclass mainClass) {\n    jclass classClass = NULL;\n    NULL_CHECK(classClass = FindBootStrapClass(env, \"java/lang/Class\"));\n\n    jmethodID getCanonicalNameMID = NULL;\n    NULL_CHECK(getCanonicalNameMID = (*env)->GetMethodID(env, classClass, \"getCanonicalName\", \"()Ljava/lang/String;\"));\n\n    jstring mainClassString = NULL;\n    NULL_CHECK(mainClassString = (*env)->CallObjectMethod(env, mainClass, getCanonicalNameMID));\n\n    const char *mainClassName = NULL;\n    NULL_CHECK(mainClassName = (*env)->GetStringUTFChars(env, mainClassString, NULL));\n\n    char envVar[80];\n    /*\n     * The JAVA_MAIN_CLASS_<pid> environment variable is used to pass\n     * the name of a Java class whose main() method is invoked by\n     * the Java launcher code to start the application, to the AWT code\n     * in order to assign the name to the Apple menu bar when the app\n     * is active on the Mac.\n     * The _<pid> part is added to avoid collisions with child processes.\n     *\n     * WARNING: This environment variable is an implementation detail and\n     * isn't meant for use outside of the core platform. The mechanism for\n     * passing this information from Java launcher to other modules may\n     * change drastically between update release, and it may even be\n     * removed or replaced with another mechanism.\n     *\n     * NOTE: It is used by SWT, and JavaFX.\n     */\n    snprintf(envVar, sizeof(envVar), \"JAVA_MAIN_CLASS_%d\", getpid());\n    setenv(envVar, mainClassName, 1);\n\n    (*env)->ReleaseStringUTFChars(env, mainClassString, mainClassName);\n}\n\nvoid\nSetXStartOnFirstThreadArg()\n{\n    // XXX: BEGIN HACK\n    // short circuit hack for <https://bugs.eclipse.org/bugs/show_bug.cgi?id=211625>\n    // need a way to get AWT/Swing apps launched when spawned from Eclipse,\n    // which currently has no UI to not pass the -XstartOnFirstThread option\n    if (getenv(\"HACK_IGNORE_START_ON_FIRST_THREAD\") != NULL) return;\n    // XXX: END HACK\n\n    sameThread = JNI_TRUE;\n    // Set a variable that tells us we started on the main thread.\n    // This is used by the AWT during startup. (See awt.m)\n    char envVar[80];\n    snprintf(envVar, sizeof(envVar), \"JAVA_STARTED_ON_FIRST_THREAD_%d\", getpid());\n    setenv(envVar, \"1\", 1);\n}\n\n/* This class is made for performSelectorOnMainThread when java main\n * should be launched on main thread.\n * We cannot use dispatch_sync here, because it blocks the main dispatch queue\n * which is used inside Cocoa\n */\n@interface JavaLaunchHelper : NSObject {\n    int _returnValue;\n}\n- (void) launchJava:(NSValue*)argsValue;\n- (int) getReturnValue;\n@end\n\n@implementation JavaLaunchHelper\n\n- (void) launchJava:(NSValue*)argsValue\n{\n    _returnValue = JavaMain([argsValue pointerValue]);\n}\n\n- (int) getReturnValue\n{\n    return _returnValue;\n}\n\n@end\n\n// MacOSX we may continue in the same thread\nint\nJVMInit(InvocationFunctions* ifn, jlong threadStackSize,\n                 int argc, char **argv,\n                 int mode, char *what, int ret) {\n    if (sameThread) {\n        JLI_TraceLauncher(\"In same thread\\n\");\n        // need to block this thread against the main thread\n        // so signals get caught correctly\n        JavaMainArgs args;\n        args.argc = argc;\n        args.argv = argv;\n        args.mode = mode;\n        args.what = what;\n        args.ifn  = *ifn;\n        int rslt;\n        NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n        {\n            JavaLaunchHelper* launcher = [[[JavaLaunchHelper alloc] init] autorelease];\n            [launcher performSelectorOnMainThread:@selector(launchJava:)\n                                       withObject:[NSValue valueWithPointer:(void*)&args]\n                                    waitUntilDone:YES];\n            rslt = [launcher getReturnValue];\n        }\n        [pool drain];\n        return rslt;\n    } else {\n        return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);\n    }\n}\n\n/*\n * Note the jvmInstance must be initialized first before entering into\n * ShowSplashScreen, as there is a callback into the JLI_GetJavaVMInstance.\n */\nvoid PostJVMInit(JNIEnv *env, jstring mainClass, JavaVM *vm) {\n    jvmInstance = vm;\n    SetMainClassForAWT(env, mainClass);\n    CHECK_EXCEPTION_RETURN();\n    ShowSplashScreen();\n}\n\njboolean\nProcessPlatformOption(const char* arg)\n{\n    if (JLI_StrCmp(arg, \"-XstartOnFirstThread\") == 0) {\n       SetXStartOnFirstThreadArg();\n       return JNI_TRUE;\n    } else if (JLI_StrCCmp(arg, \"-Xdock:\") == 0) {\n       SetXDockArgForAWT(arg);\n       return JNI_TRUE;\n    }\n    // arguments we know not\n    return JNI_FALSE;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/macosx/native/sun/java2d/opengl/OGLFuncs_md.h": "/*\n * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#ifndef OGLFuncs_md_h_Included\n#define OGLFuncs_md_h_Included\n\n#include <dlfcn.h>\n#include \"J2D_GL/cglext.h\"\n#include \"OGLFuncMacros.h\"\n\n#define OGL_LIB_HANDLE pLibGL\n#define OGL_DECLARE_LIB_HANDLE() \\\n    static void *OGL_LIB_HANDLE = NULL\n#define OGL_LIB_IS_UNINITIALIZED() \\\n    (OGL_LIB_HANDLE == NULL)\n#define OGL_OPEN_LIB() \\\n    OGL_LIB_HANDLE = dlopen(\"/System/Library/Frameworks/OpenGL.framework/Versions/Current/Libraries/libGL.dylib\", RTLD_LAZY | RTLD_GLOBAL)\n#define OGL_CLOSE_LIB() \\\n    dlclose(OGL_LIB_HANDLE)\n#define OGL_GET_PROC_ADDRESS(f) \\\n    dlsym(OGL_LIB_HANDLE, #f)\n#define OGL_GET_EXT_PROC_ADDRESS(f) \\\n    OGL_GET_PROC_ADDRESS(f)\n\n#define OGL_EXPRESS_PLATFORM_FUNCS(action)\n#define OGL_EXPRESS_PLATFORM_EXT_FUNCS(action)\n\n#endif /* OGLFuncs_md_h_Included */\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/macosx/native/sun/awt/JavaComponentAccessibility.m": "/*\n * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n// External Java Accessibility links:\n//\n// <http://java.sun.com/j2se/1.4.2/docs/guide/access/index.html>\n// <http://www-106.ibm.com/developerworks/library/j-access/?n-j-10172>\n// <http://archives.java.sun.com/archives/java-access.html> (Sun's mailing list for Java accessibility)\n\n#import \"JavaComponentAccessibility.h\"\n\n#import \"sun_lwawt_macosx_CAccessibility.h\"\n\n#import <AppKit/AppKit.h>\n\n#import <JavaNativeFoundation/JavaNativeFoundation.h>\n#import <JavaRuntimeSupport/JavaRuntimeSupport.h>\n\n#import <dlfcn.h>\n\n#import \"JavaAccessibilityAction.h\"\n#import \"JavaAccessibilityUtilities.h\"\n#import \"JavaTextAccessibility.h\"\n#import \"ThreadUtilities.h\"\n#import \"AWTView.h\"\n\n\n// these constants are duplicated in CAccessibility.java\n#define JAVA_AX_ALL_CHILDREN (-1)\n#define JAVA_AX_SELECTED_CHILDREN (-2)\n#define JAVA_AX_VISIBLE_CHILDREN (-3)\n// If the value is >=0, it's an index\n\nstatic JNF_STATIC_MEMBER_CACHE(jm_getChildrenAndRoles, sjc_CAccessibility, \"getChildrenAndRoles\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;IZ)[Ljava/lang/Object;\");\nstatic JNF_STATIC_MEMBER_CACHE(sjm_getAccessibleComponent, sjc_CAccessibility, \"getAccessibleComponent\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Ljavax/accessibility/AccessibleComponent;\");\nstatic JNF_STATIC_MEMBER_CACHE(sjm_getAccessibleValue, sjc_CAccessibility, \"getAccessibleValue\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Ljavax/accessibility/AccessibleValue;\");\nstatic JNF_STATIC_MEMBER_CACHE(sjm_getAccessibleName, sjc_CAccessibility, \"getAccessibleName\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Ljava/lang/String;\");\nstatic JNF_STATIC_MEMBER_CACHE(sjm_getAccessibleDescription, sjc_CAccessibility, \"getAccessibleDescription\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Ljava/lang/String;\");\nstatic JNF_STATIC_MEMBER_CACHE(sjm_isFocusTraversable, sjc_CAccessibility, \"isFocusTraversable\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Z\");\nstatic JNF_STATIC_MEMBER_CACHE(sjm_getAccessibleIndexInParent, sjc_CAccessibility, \"getAccessibleIndexInParent\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)I\");\n\nstatic JNF_CLASS_CACHE(sjc_CAccessible, \"sun/lwawt/macosx/CAccessible\");\n\nstatic JNF_MEMBER_CACHE(jf_ptr, sjc_CAccessible, \"ptr\", \"J\");\nstatic JNF_STATIC_MEMBER_CACHE(sjm_getCAccessible, sjc_CAccessible, \"getCAccessible\", \"(Ljavax/accessibility/Accessible;)Lsun/lwawt/macosx/CAccessible;\");\n\n\nstatic jobject sAccessibilityClass = NULL;\n\n// sAttributeNamesForRoleCache holds the names of the attributes to which each java\n// AccessibleRole responds (see AccessibleRole.java).\n// This cache is queried before attempting to access a given attribute for a particular role.\nstatic NSMutableDictionary *sAttributeNamesForRoleCache = nil;\nstatic NSObject *sAttributeNamesLOCK = nil;\n\n@interface TabGroupAccessibility : JavaComponentAccessibility {\n    NSInteger _numTabs;\n}\n\n- (id)currentTabWithEnv:(JNIEnv *)env withAxContext:(jobject)axContext;\n- (NSArray *)tabControlsWithEnv:(JNIEnv *)env withTabGroupAxContext:(jobject)axContext withTabCode:(NSInteger)whichTabs allowIgnored:(BOOL)allowIgnored;\n- (NSArray *)contentsWithEnv:(JNIEnv *)env withTabGroupAxContext:(jobject)axContext withTabCode:(NSInteger)whichTabs allowIgnored:(BOOL)allowIgnored;\n- (NSArray *)initializeAttributeNamesWithEnv:(JNIEnv *)env;\n\n- (NSArray *)accessibilityArrayAttributeValues:(NSString *)attribute index:(NSUInteger)index maxCount:(NSUInteger)maxCount;\n- (NSArray *)accessibilityChildrenAttribute;\n- (id) accessibilityTabsAttribute;\n- (BOOL)accessibilityIsTabsAttributeSettable;\n- (NSArray *)accessibilityContentsAttribute;\n- (BOOL)accessibilityIsContentsAttributeSettable;\n- (id) accessibilityValueAttribute;\n\n@end\n\n\n@interface TabGroupControlAccessibility : JavaComponentAccessibility {\n    jobject fTabGroupAxContext;\n}\n- (id)initWithParent:(NSObject *)parent withEnv:(JNIEnv *)env withAccessible:(jobject)accessible withIndex:(jint)index withTabGroup:(jobject)tabGroup withView:(NSView *)view withJavaRole:(NSString *)javaRole;\n- (jobject)tabGroup;\n- (void)getActionsWithEnv:(JNIEnv *)env;\n\n- (id)accessibilityValueAttribute;\n@end\n\n\n@interface ScrollAreaAccessibility : JavaComponentAccessibility {\n\n}\n- (NSArray *)initializeAttributeNamesWithEnv:(JNIEnv *)env;\n- (NSArray *)accessibilityContentsAttribute;\n- (BOOL)accessibilityIsContentsAttributeSettable;\n- (id)accessibilityVerticalScrollBarAttribute;\n- (BOOL)accessibilityIsVerticalScrollBarAttributeSettable;\n- (id)accessibilityHorizontalScrollBarAttribute;\n- (BOOL)accessibilityIsHorizontalScrollBarAttributeSettable;\n@end\n\n\n@implementation JavaComponentAccessibility\n\n- (NSString *)description\n{\n    return [NSString stringWithFormat:@\"%@(title:'%@', desc:'%@', value:'%@')\", [self accessibilityRoleAttribute],\n        [self accessibilityTitleAttribute], [self accessibilityRoleDescriptionAttribute], [self accessibilityValueAttribute]];\n}\n\n- (id)initWithParent:(NSObject *)parent withEnv:(JNIEnv *)env withAccessible:(jobject)accessible withIndex:(jint)index withView:(NSView *)view withJavaRole:(NSString *)javaRole\n{\n    self = [super init];\n    if (self)\n    {\n        fParent = [parent retain];\n        fView = [view retain];\n        fJavaRole = [javaRole retain];\n\n        fAccessible = (*env)->NewWeakGlobalRef(env, accessible);\n        \n        jobject jcomponent = [(AWTView *)fView awtComponent:env];\n        fComponent = (*env)->NewWeakGlobalRef(env, jcomponent);\n        (*env)->DeleteLocalRef(env, jcomponent);\n\n        fIndex = index;\n\n        fActions = nil;\n        fActionsLOCK = [[NSObject alloc] init];\n    }\n    return self;\n}\n\n- (void)unregisterFromCocoaAXSystem\n{\n    AWT_ASSERT_APPKIT_THREAD;\n    static dispatch_once_t initialize_unregisterUniqueId_once;\n    static void (*unregisterUniqueId)(id);\n    dispatch_once(&initialize_unregisterUniqueId_once, ^{\n        void *jrsFwk = dlopen(\"/System/Library/Frameworks/JavaVM.framework/Frameworks/JavaRuntimeSupport.framework/JavaRuntimeSupport\", RTLD_LAZY | RTLD_LOCAL);\n        unregisterUniqueId = dlsym(jrsFwk, \"JRSAccessibilityUnregisterUniqueIdForUIElement\");\n    });\n    if (unregisterUniqueId) unregisterUniqueId(self);\n}\n\n- (void)dealloc\n{\n    [self unregisterFromCocoaAXSystem];\n\n    JNIEnv *env = [ThreadUtilities getJNIEnvUncached];\n\n    (*env)->DeleteWeakGlobalRef(env, fAccessible);\n    fAccessible = NULL;\n\n    (*env)->DeleteWeakGlobalRef(env, fComponent);\n    fComponent = NULL;\n\n    [fParent release];\n    fParent = nil;\n\n    [fNSRole release];\n    fNSRole = nil;\n\n    [fJavaRole release];\n    fJavaRole = nil;\n\n    [fView release];\n    fView = nil;\n\n    [fActions release];\n    fActions = nil;\n\n    [fActionsLOCK release];\n    fActionsLOCK = nil;\n\n    [super dealloc];\n}\n\n- (void)postValueChanged\n{\n    AWT_ASSERT_APPKIT_THREAD;\n    NSAccessibilityPostNotification(self, NSAccessibilityValueChangedNotification);\n}\n\n- (void)postSelectionChanged\n{\n    AWT_ASSERT_APPKIT_THREAD;\n    NSAccessibilityPostNotification(self, NSAccessibilitySelectedTextChangedNotification);\n}\n\n- (BOOL)isEqual:(id)anObject\n{\n    if (![anObject isKindOfClass:[self class]]) return NO;\n    JavaComponentAccessibility *accessibility = (JavaComponentAccessibility *)anObject;\n\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n    return (*env)->IsSameObject(env, accessibility->fAccessible, fAccessible);\n}\n\n- (BOOL)isAccessibleWithEnv:(JNIEnv *)env forAccessible:(jobject)accessible\n{\n    return (*env)->IsSameObject(env, fAccessible, accessible);\n}\n\n+ (void)initialize\n{\n    if (sAttributeNamesForRoleCache == nil) {\n        sAttributeNamesLOCK = [[NSObject alloc] init];\n        sAttributeNamesForRoleCache = [[NSMutableDictionary alloc] initWithCapacity:10];\n    }\n\n    if (sRoles == nil) {\n        initializeRoles();\n    }\n\n    if (sAccessibilityClass == NULL) {\n        JNF_STATIC_MEMBER_CACHE(jm_getAccessibility, sjc_CAccessibility, \"getAccessibility\", \"([Ljava/lang/String;)Lsun/lwawt/macosx/CAccessibility;\");\n\n#ifdef JAVA_AX_NO_IGNORES\n        NSArray *ignoredKeys = [NSArray array];\n#else\n        NSArray *ignoredKeys = [sRoles allKeysForObject:JavaAccessibilityIgnore];\n#endif\n        jobjectArray result = NULL;\n        jsize count = [ignoredKeys count];\n\n        JNIEnv *env = [ThreadUtilities getJNIEnv];\n\n        static JNF_CLASS_CACHE(jc_String, \"java/lang/String\");\n        result = JNFNewObjectArray(env, &jc_String, count);\n        if (!result) {\n            NSLog(@\"In %s, can't create Java array of String objects\", __FUNCTION__);\n            return;\n        }\n\n        NSInteger i;\n        for (i = 0; i < count; i++) {\n            jstring jString = JNFNSToJavaString(env, [ignoredKeys objectAtIndex:i]);\n            (*env)->SetObjectArrayElement(env, result, i, jString);\n            (*env)->DeleteLocalRef(env, jString);\n        }\n\n        sAccessibilityClass = JNFCallStaticObjectMethod(env, jm_getAccessibility, result); // AWT_THREADING Safe (known object)\n    }\n}\n\n+ (void)postFocusChanged:(id)message\n{\n    AWT_ASSERT_APPKIT_THREAD;\n    NSAccessibilityPostNotification([NSApp accessibilityFocusedUIElement], NSAccessibilityFocusedUIElementChangedNotification);\n}\n\n+ (jobject) getCAccessible:(jobject)jaccessible withEnv:(JNIEnv *)env {\n    if (JNFIsInstanceOf(env, jaccessible, &sjc_CAccessible)) {\n        return jaccessible;\n    }\n    else if (JNFIsInstanceOf(env, jaccessible, &sjc_Accessible)) {\n        return JNFCallStaticObjectMethod(env, sjm_getCAccessible, jaccessible);\n    }\n    return NULL;\n}\n\n+ (NSArray *)childrenOfParent:(JavaComponentAccessibility *)parent withEnv:(JNIEnv *)env withChildrenCode:(NSInteger)whichChildren allowIgnored:(BOOL)allowIgnored\n{\n    jobjectArray jchildrenAndRoles = (jobjectArray)JNFCallStaticObjectMethod(env, jm_getChildrenAndRoles, parent->fAccessible, parent->fComponent, whichChildren, allowIgnored); // AWT_THREADING Safe (AWTRunLoop)\n    if (jchildrenAndRoles == NULL) return nil;\n\n    jsize arrayLen = (*env)->GetArrayLength(env, jchildrenAndRoles);\n    NSMutableArray *children = [NSMutableArray arrayWithCapacity:arrayLen/2]; //childrenAndRoles array contains two elements (child, role) for each child\n\n    NSInteger i;\n    NSUInteger childIndex = (whichChildren >= 0) ? whichChildren : 0; // if we're getting one particular child, make sure to set its index correctly\n    for(i = 0; i < arrayLen; i+=2)\n    {\n        jobject /* Accessible */ jchild = (*env)->GetObjectArrayElement(env, jchildrenAndRoles, i);\n        jobject /* String */ jchildJavaRole = (*env)->GetObjectArrayElement(env, jchildrenAndRoles, i+1);\n\n        NSString *childJavaRole = nil;\n        if (jchildJavaRole != NULL) {\n            jobject jkey = JNFGetObjectField(env, jchildJavaRole, sjf_key);\n            childJavaRole = JNFJavaToNSString(env, jkey);\n            (*env)->DeleteLocalRef(env, jkey);\n        }\n\n        JavaComponentAccessibility *child = [self createWithParent:parent accessible:jchild role:childJavaRole index:childIndex withEnv:env withView:parent->fView];\n        \n        (*env)->DeleteLocalRef(env, jchild);\n        (*env)->DeleteLocalRef(env, jchildJavaRole);\n        \n        [children addObject:child];\n        childIndex++;\n    }\n    (*env)->DeleteLocalRef(env, jchildrenAndRoles);\n    \n    return children;\n}\n\n+ (JavaComponentAccessibility *)createWithAccessible:(jobject)jaccessible withEnv:(JNIEnv *)env withView:(NSView *)view\n{\n    jobject jcomponent = [(AWTView *)view awtComponent:env];\n    jint index = JNFCallStaticIntMethod(env, sjm_getAccessibleIndexInParent, jaccessible, jcomponent);\n    NSString *javaRole = getJavaRole(env, jaccessible, jcomponent);\n    (*env)->DeleteLocalRef(env, jcomponent);\n    return [self createWithAccessible:jaccessible role:javaRole index:index withEnv:env withView:view];\n}\n\n+ (JavaComponentAccessibility *) createWithAccessible:(jobject)jaccessible role:(NSString *)javaRole index:(jint)index withEnv:(JNIEnv *)env withView:(NSView *)view\n{\n    return [self createWithParent:nil accessible:jaccessible role:javaRole index:index withEnv:env withView:view];\n}\n\n+ (JavaComponentAccessibility *) createWithParent:(JavaComponentAccessibility *)parent accessible:(jobject)jaccessible role:(NSString *)javaRole index:(jint)index withEnv:(JNIEnv *)env withView:(NSView *)view\n{\n    // try to fetch the jCAX from Java, and return autoreleased\n    jobject jCAX = [JavaComponentAccessibility getCAccessible:jaccessible withEnv:env];\n    if (jCAX == NULL) return nil;\n    JavaComponentAccessibility *value = (JavaComponentAccessibility *) jlong_to_ptr(JNFGetLongField(env, jCAX, jf_ptr));\n    if (value != nil) {\n        (*env)->DeleteLocalRef(env, jCAX);\n        return [[value retain] autorelease];\n    }\n\n    // otherwise, create a new instance\n    JavaComponentAccessibility *newChild = nil;\n    if ([javaRole isEqualToString:@\"pagetablist\"]) {\n        newChild = [TabGroupAccessibility alloc];\n    } else if ([javaRole isEqualToString:@\"scrollpane\"]) {\n        newChild = [ScrollAreaAccessibility alloc];\n    } else {\n        NSString *nsRole = [sRoles objectForKey:javaRole];\n        if ([nsRole isEqualToString:NSAccessibilityStaticTextRole] || [nsRole isEqualToString:NSAccessibilityTextAreaRole] || [nsRole isEqualToString:NSAccessibilityTextFieldRole]) {\n            newChild = [JavaTextAccessibility alloc];\n        } else {\n            newChild = [JavaComponentAccessibility alloc];\n        }\n    }\n\n    // must init freshly -alloc'd object\n    [newChild initWithParent:parent withEnv:env withAccessible:jCAX withIndex:index withView:view withJavaRole:javaRole]; // must init new instance\n\n    // must hard retain pointer poked into Java object\n    [newChild retain];\n    JNFSetLongField(env, jCAX, jf_ptr, ptr_to_jlong(newChild));\n    (*env)->DeleteLocalRef(env, jCAX);\n\n    // return autoreleased instance\n    return [newChild autorelease];\n}\n\n- (NSArray *)initializeAttributeNamesWithEnv:(JNIEnv *)env\n{\n    static JNF_STATIC_MEMBER_CACHE(jm_getInitialAttributeStates, sjc_CAccessibility, \"getInitialAttributeStates\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)[Z\");\n\n    NSMutableArray *attributeNames = [NSMutableArray arrayWithCapacity:10];\n    [attributeNames retain];\n\n    // all elements respond to parent, role, role description, window, topLevelUIElement, help\n    [attributeNames addObject:NSAccessibilityParentAttribute];\n    [attributeNames addObject:NSAccessibilityRoleAttribute];\n    [attributeNames addObject:NSAccessibilityRoleDescriptionAttribute];\n    [attributeNames addObject:NSAccessibilityHelpAttribute];\n\n    // cmcnote: AXMenu usually doesn't respond to window / topLevelUIElement. But menus within a Java app's window\n    // probably should. Should we use some role other than AXMenu / AXMenuBar for Java menus?\n    [attributeNames addObject:NSAccessibilityWindowAttribute];\n    [attributeNames addObject:NSAccessibilityTopLevelUIElementAttribute];\n\n    // set accessible subrole\n    NSString *javaRole = [self javaRole];\n    if (javaRole != nil && [javaRole isEqualToString:@\"passwordtext\"]) {\n        //cmcnote: should turn this into a constant\n        [attributeNames addObject:NSAccessibilitySubroleAttribute];\n    }\n\n    // Get all the other accessibility attributes states we need in one swell foop.\n    // javaRole isn't pulled in because we need protected access to AccessibleRole.key\n    jbooleanArray attributeStates = (jbooleanArray)JNFCallStaticObjectMethod(env, jm_getInitialAttributeStates, fAccessible, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n    if (attributeStates == NULL) return nil;\n    jboolean *attributeStatesArray = (*env)->GetBooleanArrayElements(env, attributeStates, 0);\n    if (attributeStatesArray == NULL) {\n        // Note: Java will not be on the stack here so a java exception can't happen and no need to call ExceptionCheck.\n        NSLog(@\"%s failed calling GetBooleanArrayElements\", __FUNCTION__);\n        return nil;\n    }\n\n    // if there's a component, it can be enabled and it has a size/position\n    if (attributeStatesArray[0]) {\n        [attributeNames addObject:NSAccessibilityEnabledAttribute];\n        [attributeNames addObject:NSAccessibilitySizeAttribute];\n        [attributeNames addObject:NSAccessibilityPositionAttribute];\n    }\n\n    // According to javadoc, a component that is focusable will return true from isFocusTraversable,\n    // as well as having AccessibleState.FOCUSABLE in it's AccessibleStateSet.\n    // We use the former heuristic; if the component focus-traversable, add a focused attribute\n    // See also: accessibilityIsFocusedAttributeSettable\n    if (attributeStatesArray[1])\n    {\n        [attributeNames addObject:NSAccessibilityFocusedAttribute];\n    }\n\n    // if it's a pagetab / radiobutton, it has a value but no min/max value.\n    BOOL hasAxValue = attributeStatesArray[2];\n    if ([javaRole isEqualToString:@\"pagetab\"] || [javaRole isEqualToString:@\"radiobutton\"]) {\n        [attributeNames addObject:NSAccessibilityValueAttribute];\n    } else {\n        // if not a pagetab/radio button, and it has a value, it has a min/max/current value.\n        if (hasAxValue) {\n            // er, it has a min/max/current value if it's not a button.\n            // See AppKit/NSButtonCellAccessibility.m\n            if (![javaRole isEqualToString:@\"pushbutton\"]) {\n                //cmcnote: make this (and \"passwordtext\") constants instead of magic strings\n                [attributeNames addObject:NSAccessibilityMinValueAttribute];\n                [attributeNames addObject:NSAccessibilityMaxValueAttribute];\n                [attributeNames addObject:NSAccessibilityValueAttribute];\n            }\n        }\n    }\n\n    // does it have an orientation?\n    if (attributeStatesArray[4]) {\n        [attributeNames addObject:NSAccessibilityOrientationAttribute];\n    }\n\n    // name\n    if (attributeStatesArray[5]) {\n        [attributeNames addObject:NSAccessibilityTitleAttribute];\n    }\n\n    // children\n    if (attributeStatesArray[6]) {\n        [attributeNames addObject:NSAccessibilityChildrenAttribute];\n//        [attributeNames addObject:NSAccessibilitySelectedChildrenAttribute];\n//        [attributeNames addObject:NSAccessibilityVisibleChildrenAttribute];\n                //According to AXRoles.txt:\n                //VisibleChildren: radio group, list, row, table row subrole\n                //SelectedChildren: list\n    }\n\n    // Cleanup\n    (*env)->ReleaseBooleanArrayElements(env, attributeStates, attributeStatesArray, JNI_ABORT);\n\n    return attributeNames;\n}\n\n- (NSDictionary *)getActions:(JNIEnv *)env\n{\n    @synchronized(fActionsLOCK) {\n        if (fActions == nil) {\n            fActions = [[NSMutableDictionary alloc] initWithCapacity:3];\n            [self getActionsWithEnv:env];\n        }\n    }\n\n    return fActions;\n}\n\n- (void)getActionsWithEnv:(JNIEnv *)env\n{\n    static JNF_STATIC_MEMBER_CACHE(jm_getAccessibleAction, sjc_CAccessibility, \"getAccessibleAction\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Ljavax/accessibility/AccessibleAction;\");\n\n    // On MacOSX, text doesn't have actions, in java it does.\n    // cmcnote: NOT TRUE - Editable text has AXShowMenu. Textfields have AXConfirm. Static text has no actions.\n    jobject axAction = JNFCallStaticObjectMethod(env, jm_getAccessibleAction, fAccessible, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n    if (axAction != NULL) {\n        //+++gdb NOTE: In MacOSX, there is just a single Action, not multiple. In java,\n        //  the first one seems to be the most basic, so this will be used.\n        // cmcnote: NOT TRUE - Sometimes there are multiple actions, eg sliders have AXDecrement AND AXIncrement (radr://3893192)\n        JavaAxAction *action = [[JavaAxAction alloc] initWithEnv:env withAccessibleAction:axAction withIndex:0 withComponent:fComponent];\n        [fActions setObject:action forKey:[self isMenu] ? NSAccessibilityPickAction : NSAccessibilityPressAction];\n        [action release];\n        (*env)->DeleteLocalRef(env, axAction);\n    }\n}\n\n- (jobject)axContextWithEnv:(JNIEnv *)env\n{\n    return getAxContext(env, fAccessible, fComponent);\n}\n\n- (id)parent\n{\n    static JNF_CLASS_CACHE(sjc_Window, \"java/awt/Window\");\n    static JNF_STATIC_MEMBER_CACHE(sjm_getAccessibleParent, sjc_CAccessibility, \"getAccessibleParent\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Ljavax/accessibility/Accessible;\");\n    static JNF_STATIC_MEMBER_CACHE(sjm_getSwingAccessible, sjc_CAccessible, \"getSwingAccessible\", \"(Ljavax/accessibility/Accessible;)Ljavax/accessibility/Accessible;\");\n\n    if(fParent == nil) {\n        JNIEnv* env = [ThreadUtilities getJNIEnv];\n\n        jobject jparent = JNFCallStaticObjectMethod(env, sjm_getAccessibleParent, fAccessible, fComponent);\n\n        if (jparent == NULL) {\n            fParent = fView;\n        } else {\n            AWTView *view = fView;\n            jobject jax = JNFCallStaticObjectMethod(env, sjm_getSwingAccessible, fAccessible);\n\n            if (JNFIsInstanceOf(env, jax, &sjc_Window)) {\n                // In this case jparent is an owner toplevel and we should retrieve its own view\n                view = [AWTView awtView:env ofAccessible:jparent];\n            }\n            if (view != nil) {\n                fParent = [JavaComponentAccessibility createWithAccessible:jparent withEnv:env withView:view];\n            }\n            if (fParent == nil) {\n                fParent = fView;\n            }\n            (*env)->DeleteLocalRef(env, jparent);\n            (*env)->DeleteLocalRef(env, jax );\n        }\n        [fParent retain];\n    }\n    return fParent;\n}\n\n- (NSView *)view\n{\n    return fView;\n}\n\n- (NSWindow *)window\n{\n    return [[self view] window];\n}\n\n- (NSString *)javaRole\n{\n    if(fJavaRole == nil) {\n        JNIEnv* env = [ThreadUtilities getJNIEnv];\n        fJavaRole = getJavaRole(env, fAccessible, fComponent);\n        [fJavaRole retain];\n    }\n    return fJavaRole;\n}\n\n- (BOOL)isMenu\n{\n    id role = [self accessibilityRoleAttribute];\n    return [role isEqualToString:NSAccessibilityMenuBarRole] || [role isEqualToString:NSAccessibilityMenuRole] || [role isEqualToString:NSAccessibilityMenuItemRole];\n}\n\n- (BOOL)isSelected:(JNIEnv *)env\n{\n    if (fIndex == -1) {\n        return NO;\n    }\n\n    return isChildSelected(env, ((JavaComponentAccessibility *)[self parent])->fAccessible, fIndex, fComponent);\n}\n\n- (BOOL)isVisible:(JNIEnv *)env\n{\n    if (fIndex == -1) {\n        return NO;\n    }\n\n    jobject axContext = [self axContextWithEnv:env];\n    BOOL showing = isShowing(env, axContext, fComponent);\n    (*env)->DeleteLocalRef(env, axContext);\n    return showing;\n}\n\n// the array of names for each role is cached in the sAttributeNamesForRoleCache\n- (NSArray *)accessibilityAttributeNames\n{\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n\n    @synchronized(sAttributeNamesLOCK) {\n        NSString *javaRole = [self javaRole];\n        NSArray *names = (NSArray *)[sAttributeNamesForRoleCache objectForKey:javaRole];\n        if (names != nil) return names;\n\n        names = [self initializeAttributeNamesWithEnv:env];\n        if (names != nil) {\n#ifdef JAVA_AX_DEBUG\n            NSLog(@\"Initializing: %s for %@: %@\", __FUNCTION__, javaRole, names);\n#endif\n            [sAttributeNamesForRoleCache setObject:names forKey:javaRole];\n            return names;\n        }\n    }\n\n#ifdef JAVA_AX_DEBUG\n    NSLog(@\"Warning in %s: could not find attribute names for role: %@\", __FUNCTION__, [self javaRole]);\n#endif\n\n    return nil;\n}\n\n// -- accessibility attributes --\n\n- (BOOL)accessibilityShouldUseUniqueId {\n    return YES;\n}\n\n- (BOOL)accessibilitySupportsOverriddenAttributes {\n    return YES;\n}\n\n\n// generic getters & setters\n// cmcnote: it would make more sense if these generic getters/setters were in JavaAccessibilityUtilities\n- (id)accessibilityAttributeValue:(NSString *)attribute\n{\n    AWT_ASSERT_APPKIT_THREAD;\n\n    // turns attribute \"NSAccessibilityEnabledAttribute\" into getter \"accessibilityEnabledAttribute\",\n    // calls getter on self\n    return JavaAccessibilityAttributeValue(self, attribute);\n}\n\n- (BOOL)accessibilityIsAttributeSettable:(NSString *)attribute\n{\n    AWT_ASSERT_APPKIT_THREAD;\n\n    // turns attribute \"NSAccessibilityParentAttribute\" into selector \"accessibilityIsParentAttributeSettable\",\n    // calls selector on self\n    return JavaAccessibilityIsAttributeSettable(self, attribute);\n}\n\n- (void)accessibilitySetValue:(id)value forAttribute:(NSString *)attribute\n{\n    AWT_ASSERT_APPKIT_THREAD;\n\n    if ([self accessibilityIsAttributeSettable:attribute]) {\n        // turns attribute \"NSAccessibilityFocusAttribute\" into setter \"accessibilitySetFocusAttribute\",\n        // calls setter on self\n        JavaAccessibilitySetAttributeValue(self, attribute, value);\n    }\n}\n\n\n// specific attributes, in alphabetical order a la\n// http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/ObjC_classic/Protocols/NSAccessibility.html\n\n// Elements that current element contains (NSArray)\n- (NSArray *)accessibilityChildrenAttribute\n{\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n    NSArray *children = [JavaComponentAccessibility childrenOfParent:self withEnv:env withChildrenCode:JAVA_AX_VISIBLE_CHILDREN allowIgnored:NO];\n\n    NSArray *value = nil;\n    if ([children count] > 0) {\n        value = children;\n    }\n\n    return value;\n}\n- (BOOL)accessibilityIsChildrenAttributeSettable\n{\n    return NO;\n}\n\n- (NSUInteger)accessibilityIndexOfChild:(id)child\n{\n    // Only special-casing for Lists, for now. This allows lists to be accessible, fixing radr://3856139 \"JLists are broken\".\n    // Will probably want to special-case for Tables when we implement them (radr://3096643 \"Accessibility: Table\").\n    // In AppKit, NSMatrixAccessibility (which uses NSAccessibilityListRole), NSTableRowAccessibility, and NSTableViewAccessibility are the\n    // only ones that override the default implementation in NSAccessibility\n    if (![[self accessibilityRoleAttribute] isEqualToString:NSAccessibilityListRole]) {\n        return [super accessibilityIndexOfChild:child];\n    }\n\n    return JNFCallStaticIntMethod([ThreadUtilities getJNIEnv], sjm_getAccessibleIndexInParent, ((JavaComponentAccessibility *)child)->fAccessible, ((JavaComponentAccessibility *)child)->fComponent);\n}\n\n// Without this optimization accessibilityChildrenAttribute is called in order to get the entire array of children.\n- (NSArray *)accessibilityArrayAttributeValues:(NSString *)attribute index:(NSUInteger)index maxCount:(NSUInteger)maxCount {\n    if ( (maxCount == 1) && [attribute isEqualToString:NSAccessibilityChildrenAttribute]) {\n        // Children codes for ALL, SELECTED, VISIBLE are <0. If the code is >=0, we treat it as an index to a single child\n        NSArray *child = [JavaComponentAccessibility childrenOfParent:self withEnv:[ThreadUtilities getJNIEnv] withChildrenCode:(NSInteger)index allowIgnored:NO];\n        if ([child count] > 0) {\n            return child;\n        }\n    }\n    return [super accessibilityArrayAttributeValues:attribute index:index maxCount:maxCount];\n}\n\n// Flag indicating enabled state of element (NSNumber)\n- (NSNumber *)accessibilityEnabledAttribute\n{\n    static JNF_STATIC_MEMBER_CACHE(jm_isEnabled, sjc_CAccessibility, \"isEnabled\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Z\");\n\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n    NSNumber *value = [NSNumber numberWithBool:JNFCallStaticBooleanMethod(env, jm_isEnabled, fAccessible, fComponent)]; // AWT_THREADING Safe (AWTRunLoop)\n    if (value == nil) {\n        NSLog(@\"WARNING: %s called on component that has no accessible component: %@\", __FUNCTION__, self);\n    }\n    return value;\n}\n\n- (BOOL)accessibilityIsEnabledAttributeSettable\n{\n    return NO;\n}\n\n// Flag indicating presence of keyboard focus (NSNumber)\n- (NSNumber *)accessibilityFocusedAttribute\n{\n    if ([self accessibilityIsFocusedAttributeSettable]) {\n        return [NSNumber numberWithBool:[self isEqual:[NSApp accessibilityFocusedUIElement]]];\n    }\n    return [NSNumber numberWithBool:NO];\n}\n\n- (BOOL)accessibilityIsFocusedAttributeSettable\n{\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n    // According to javadoc, a component that is focusable will return true from isFocusTraversable,\n    // as well as having AccessibleState.FOCUSABLE in its AccessibleStateSet.\n    // We use the former heuristic; if the component focus-traversable, add a focused attribute\n    // See also initializeAttributeNamesWithEnv:\n    if (JNFCallStaticBooleanMethod(env, sjm_isFocusTraversable, fAccessible, fComponent)) { // AWT_THREADING Safe (AWTRunLoop)\n        return YES;\n    }\n\n    return NO;\n}\n\n- (void)accessibilitySetFocusedAttribute:(id)value\n{\n    static JNF_STATIC_MEMBER_CACHE(jm_requestFocus, sjc_CAccessibility, \"requestFocus\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)V\");\n\n    if ([(NSNumber*)value boolValue])\n    {\n        JNIEnv* env = [ThreadUtilities getJNIEnv];\n        JNFCallStaticVoidMethod(env, jm_requestFocus, fAccessible, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n    }\n}\n\n// Instance description, such as a help tag string (NSString)\n- (NSString *)accessibilityHelpAttribute\n{\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n\n    jobject val = JNFCallStaticObjectMethod(env, sjm_getAccessibleDescription, fAccessible, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n    if (val == NULL) {\n        return @\"unknown\";\n    }\n    NSString* str = JNFJavaToNSString(env, val);\n    (*env)->DeleteLocalRef(env, val);\n    return str;\n}\n\n- (BOOL)accessibilityIsHelpAttributeSettable\n{\n    return NO;\n}\n\n// Element's maximum value (id)\n- (id)accessibilityMaxValueAttribute\n{\n    static JNF_STATIC_MEMBER_CACHE(jm_getMaximumAccessibleValue, sjc_CAccessibility, \"getMaximumAccessibleValue\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Ljava/lang/Number;\");\n\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n\n    jobject axValue = JNFCallStaticObjectMethod(env, jm_getMaximumAccessibleValue, fAccessible, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n    if (axValue == NULL) {\n        return [NSNumber numberWithInt:0];\n    }\n    NSNumber* num = JNFJavaToNSNumber(env, axValue);\n    (*env)->DeleteLocalRef(env, axValue);\n    return num;\n}\n\n- (BOOL)accessibilityIsMaxValueAttributeSettable\n{\n    return NO;\n}\n\n// Element's minimum value (id)\n- (id)accessibilityMinValueAttribute\n{\n    static JNF_STATIC_MEMBER_CACHE(jm_getMinimumAccessibleValue, sjc_CAccessibility, \"getMinimumAccessibleValue\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Ljava/lang/Number;\");\n\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n\n    jobject axValue = JNFCallStaticObjectMethod(env, jm_getMinimumAccessibleValue, fAccessible, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n    if (axValue == NULL) {\n        return [NSNumber numberWithInt:0];\n    }\n    NSNumber* num = JNFJavaToNSNumber(env, axValue);\n    (*env)->DeleteLocalRef(env, axValue);\n    return num;\n}\n\n- (BOOL)accessibilityIsMinValueAttributeSettable\n{\n    return NO;\n}\n\n- (id)accessibilityOrientationAttribute\n{\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n    jobject axContext = [self axContextWithEnv:env];\n\n    // cmcnote - should batch these two calls into one that returns an array of two bools, one for vertical and one for horiz\n    if (isVertical(env, axContext, fComponent)) {\n        (*env)->DeleteLocalRef(env, axContext);\n        return NSAccessibilityVerticalOrientationValue;\n    }\n\n    if (isHorizontal(env, axContext, fComponent)) {\n        (*env)->DeleteLocalRef(env, axContext);\n        return NSAccessibilityHorizontalOrientationValue;\n    }\n\n    (*env)->DeleteLocalRef(env, axContext);\n    return nil;\n}\n\n- (BOOL)accessibilityIsOrientationAttributeSettable\n{\n    return NO;\n}\n\n// Element containing current element (id)\n- (id)accessibilityParentAttribute\n{\n    return NSAccessibilityUnignoredAncestor([self parent]);\n}\n\n- (BOOL)accessibilityIsParentAttributeSettable\n{\n    return NO;\n}\n\n// Screen position of element's lower-left corner in lower-left relative screen coordinates (NSValue)\n- (NSValue *)accessibilityPositionAttribute\n{\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n    jobject axComponent = JNFCallStaticObjectMethod(env, sjm_getAccessibleComponent, fAccessible, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n\n    // NSAccessibility wants the bottom left point of the object in\n    // bottom left based screen coords\n\n    // Get the java screen coords, and make a NSPoint of the bottom left of the AxComponent.\n    NSSize size = getAxComponentSize(env, axComponent, fComponent);\n    NSPoint point = getAxComponentLocationOnScreen(env, axComponent, fComponent);\n    (*env)->DeleteLocalRef(env, axComponent);\n\n    point.y += size.height;\n\n    // Now make it into Cocoa screen coords.\n    point.y = [[[[self view] window] screen] frame].size.height - point.y;\n\n    return [NSValue valueWithPoint:point];\n}\n\n- (BOOL)accessibilityIsPositionAttributeSettable\n{\n    // In AppKit, position is only settable for a window (NSAccessibilityWindowRole). Our windows are taken care of natively, so we don't need to deal with this here\n    // We *could* make use of Java's AccessibleComponent.setLocation() method. Investigate. radr://3953869\n    return NO;\n}\n\n// Element type, such as NSAccessibilityRadioButtonRole (NSString). See the role table\n// at http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/ObjC_classic/Protocols/NSAccessibility.html\n- (NSString *)accessibilityRoleAttribute\n{\n    if (fNSRole == nil) {\n        NSString *javaRole = [self javaRole];\n        fNSRole = [sRoles objectForKey:javaRole];\n        if (fNSRole == nil) {\n            // this component has assigned itself a custom AccessibleRole not in the sRoles array\n            fNSRole = javaRole;\n        }\n        [fNSRole retain];\n    }\n    return fNSRole;\n}\n- (BOOL)accessibilityIsRoleAttributeSettable\n{\n    return NO;\n}\n\n// Localized, user-readable description of role, such as radio button (NSString)\n- (NSString *)accessibilityRoleDescriptionAttribute\n{\n    // first ask AppKit for its accessible role description for a given AXRole\n    NSString *value = NSAccessibilityRoleDescription([self accessibilityRoleAttribute], nil);\n\n    if (value == nil) {\n        // query java if necessary\n        static JNF_STATIC_MEMBER_CACHE(jm_getAccessibleRoleDisplayString, sjc_CAccessibility, \"getAccessibleRoleDisplayString\", \"(Ljavax/accessibility/Accessible;Ljava/awt/Component;)Ljava/lang/String;\");\n\n        JNIEnv* env = [ThreadUtilities getJNIEnv];\n\n        jobject axRole = JNFCallStaticObjectMethod(env, jm_getAccessibleRoleDisplayString, fAccessible, fComponent);\n        if (axRole != NULL) {\n            value = JNFJavaToNSString(env, axRole);\n            (*env)->DeleteLocalRef(env, axRole);\n        } else {\n            value = @\"unknown\";\n        }\n    }\n\n    return value;\n}\n\n- (BOOL)accessibilityIsRoleDescriptionAttributeSettable\n{\n    return NO;\n}\n\n// Currently selected children (NSArray)\n- (NSArray *)accessibilitySelectedChildrenAttribute\n{\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n    NSArray *selectedChildren = [JavaComponentAccessibility childrenOfParent:self withEnv:env withChildrenCode:JAVA_AX_SELECTED_CHILDREN allowIgnored:NO];\n    if ([selectedChildren count] > 0) {\n        return selectedChildren;\n    }\n\n    return nil;\n}\n\n- (BOOL)accessibilityIsSelectedChildrenAttributeSettable\n{\n    return NO; // cmcnote: actually it should be. so need to write accessibilitySetSelectedChildrenAttribute also\n}\n\n// Element size (NSValue)\n- (NSValue *)accessibilitySizeAttribute {\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n    jobject axComponent = JNFCallStaticObjectMethod(env, sjm_getAccessibleComponent, fAccessible, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n    NSValue* size = [NSValue valueWithSize:getAxComponentSize(env, axComponent, fComponent)];\n    (*env)->DeleteLocalRef(env, axComponent);\n    return size;\n}\n\n- (BOOL)accessibilityIsSizeAttributeSettable\n{\n    // SIZE is settable in windows if [self styleMask] & NSResizableWindowMask - but windows are heavyweight so we're ok here\n    // SIZE is settable in columns if [[self tableValue] allowsColumnResizing - haven't dealt with columns yet\n    return NO;\n}\n\n// Element subrole type, such as NSAccessibilityTableRowSubrole (NSString). See the subrole attribute table at\n// http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/ObjC_classic/Protocols/NSAccessibility.html\n- (NSString *)accessibilitySubroleAttribute\n{\n    NSString *value = nil;\n    if ([[self javaRole] isEqualToString:@\"passwordtext\"])\n    {\n        value = NSAccessibilitySecureTextFieldSubrole;\n    }\n    /*\n    // other subroles. TableRow and OutlineRow may be relevant to us\n     NSAccessibilityCloseButtonSubrole // no, heavyweight window takes care of this\n     NSAccessibilityMinimizeButtonSubrole // \"\n     NSAccessibilityOutlineRowSubrole    // maybe?\n     NSAccessibilitySecureTextFieldSubrole // currently used\n     NSAccessibilityTableRowSubrole        // maybe?\n     NSAccessibilityToolbarButtonSubrole // maybe?\n     NSAccessibilityUnknownSubrole\n     NSAccessibilityZoomButtonSubrole    // no, heavyweight window takes care of this\n     NSAccessibilityStandardWindowSubrole// no, heavyweight window takes care of this\n     NSAccessibilityDialogSubrole        // maybe?\n     NSAccessibilitySystemDialogSubrole    // no\n     NSAccessibilityFloatingWindowSubrole // in 1.5 if we implement these, heavyweight will take care of them anyway\n     NSAccessibilitySystemFloatingWindowSubrole\n     NSAccessibilityIncrementArrowSubrole  // no\n     NSAccessibilityDecrementArrowSubrole  // no\n     NSAccessibilityIncrementPageSubrole   // no\n     NSAccessibilityDecrementPageSubrole   // no\n     NSAccessibilitySearchFieldSubrole    //no\n     */\n    return value;\n}\n\n- (BOOL)accessibilityIsSubroleAttributeSettable\n{\n    return NO;\n}\n\n// Title of element, such as button text (NSString)\n- (NSString *)accessibilityTitleAttribute\n{\n    // Return empty string for labels, since their value and tile end up being the same thing and this leads to repeated text.\n    if ([[self accessibilityRoleAttribute] isEqualToString:NSAccessibilityStaticTextRole]) {\n        return @\"\";\n    }\n\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n\n    jobject val = JNFCallStaticObjectMethod(env, sjm_getAccessibleName, fAccessible, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n    if (val == NULL) {\n        return @\"unknown\";\n    }\n    NSString* str = JNFJavaToNSString(env, val);\n    (*env)->DeleteLocalRef(env, val);\n    return str;\n}\n\n- (BOOL)accessibilityIsTitleAttributeSettable\n{\n    return NO;\n}\n\n- (NSWindow *)accessibilityTopLevelUIElementAttribute\n{\n    return [self window];\n}\n\n- (BOOL)accessibilityIsTopLevelUIElementAttributeSettable\n{\n    return NO;\n}\n\n// Element's value (id)\n// note that the appKit meaning of \"accessibilityValue\" is different from the java\n// meaning of \"accessibleValue\", which is specific to numerical values\n// (http://java.sun.com/j2se/1.3/docs/api/javax/accessibility/AccessibleValue.html#setCurrentAccessibleValue(java.lang.Number))\n- (id)accessibilityValueAttribute\n{\n    static JNF_STATIC_MEMBER_CACHE(jm_getCurrentAccessibleValue, sjc_CAccessibility, \"getCurrentAccessibleValue\", \"(Ljavax/accessibility/AccessibleValue;Ljava/awt/Component;)Ljava/lang/Number;\");\n\n    JNIEnv* env = [ThreadUtilities getJNIEnv];\n\n    // ask Java for the component's accessibleValue. In java, the \"accessibleValue\" just means a numerical value\n    // a text value is taken care of in JavaTextAccessibility\n\n    // cmcnote should coalesce these calls into one java call\n    NSNumber *num = nil;\n    jobject axValue = JNFCallStaticObjectMethod(env, sjm_getAccessibleValue, fAccessible, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n    if (axValue != NULL) {\n        jobject str = JNFCallStaticObjectMethod(env, jm_getCurrentAccessibleValue, axValue, fComponent);\n        if (str != NULL) {\n            num = JNFJavaToNSNumber(env, str); // AWT_THREADING Safe (AWTRunLoop)\n            (*env)->DeleteLocalRef(env, str);\n        }\n        (*env)->DeleteLocalRef(env, axValue);\n    }\n    if (num == nil) {\n        num = [NSNumber numberWithInt:0];\n    }\n    return num;\n}\n\n- (BOOL)accessibilityIsValueAttributeSettable\n{\n    // according ot AppKit sources, in general the value attribute is not settable, except in the cases\n    // of an NSScroller, an NSSplitView, and text that's both enabled & editable\n    BOOL isSettable = NO;\n    NSString *role = [self accessibilityRoleAttribute];\n\n    if ([role isEqualToString:NSAccessibilityScrollBarRole] || // according to NSScrollerAccessibility\n        [role isEqualToString:NSAccessibilitySplitGroupRole] ) // according to NSSplitViewAccessibility\n    {\n        isSettable = YES;\n    }\n    return isSettable;\n}\n\n- (void)accessibilitySetValueAttribute:(id)value\n{\n#ifdef JAVA_AX_DEBUG\n    NSLog(@\"Not yet implemented: %s\\n\", __FUNCTION__); // radr://3954018\n#endif\n}\n\n\n// Child elements that are visible (NSArray)\n- (NSArray *)accessibilityVisibleChildrenAttribute\n{\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    NSArray *visibleChildren = [JavaComponentAccessibility childrenOfParent:self withEnv:env withChildrenCode:JAVA_AX_VISIBLE_CHILDREN allowIgnored:NO];\n    if ([visibleChildren count] <= 0) return nil;\n    return visibleChildren;\n}\n\n- (BOOL)accessibilityIsVisibleChildrenAttributeSettable\n{\n    return NO;\n}\n\n// Window containing current element (id)\n- (id)accessibilityWindowAttribute\n{\n    return [self window];\n}\n\n- (BOOL)accessibilityIsWindowAttributeSettable\n{\n    return NO;\n}\n\n\n// -- accessibility actions --\n- (NSArray *)accessibilityActionNames\n{\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    return [[self getActions:env] allKeys];\n}\n\n- (NSString *)accessibilityActionDescription:(NSString *)action\n{\n    AWT_ASSERT_APPKIT_THREAD;\n\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    return [(id <JavaAccessibilityAction>)[[self getActions:env] objectForKey:action] getDescription];\n}\n\n- (void)accessibilityPerformAction:(NSString *)action\n{\n    AWT_ASSERT_APPKIT_THREAD;\n\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    [(id <JavaAccessibilityAction>)[[self getActions:env] objectForKey:action] perform];\n}\n\n\n// -- misc accessibility --\n- (BOOL)accessibilityIsIgnored\n{\n#ifdef JAVA_AX_NO_IGNORES\n    return NO;\n#else\n    return [[self accessibilityRoleAttribute] isEqualToString:JavaAccessibilityIgnore];\n#endif /* JAVA_AX_NO_IGNORES */\n}\n\n- (id)accessibilityHitTest:(NSPoint)point withEnv:(JNIEnv *)env\n{\n    static JNF_CLASS_CACHE(jc_Container, \"java/awt/Container\");\n    static JNF_STATIC_MEMBER_CACHE(jm_accessibilityHitTest, sjc_CAccessibility, \"accessibilityHitTest\", \"(Ljava/awt/Container;FF)Ljavax/accessibility/Accessible;\");\n\n    // Make it into java screen coords\n    point.y = [[[[self view] window] screen] frame].size.height - point.y;\n\n    jobject jparent = fComponent;\n\n    id value = nil;\n    if (JNFIsInstanceOf(env, jparent, &jc_Container)) {\n        jobject jaccessible = JNFCallStaticObjectMethod(env, jm_accessibilityHitTest, jparent, (jfloat)point.x, (jfloat)point.y); // AWT_THREADING Safe (AWTRunLoop)\n        if (jaccessible != NULL) {\n            value = [JavaComponentAccessibility createWithAccessible:jaccessible withEnv:env withView:fView];\n            (*env)->DeleteLocalRef(env, jaccessible);\n        }\n    }\n\n    if (value == nil) {\n        value = self;\n    }\n\n    if ([value accessibilityIsIgnored]) {\n        value = NSAccessibilityUnignoredAncestor(value);\n    }\n\n#ifdef JAVA_AX_DEBUG\n    NSLog(@\"%s: %@\", __FUNCTION__, value);\n#endif\n    return value;\n}\n\n- (id)accessibilityFocusedUIElement\n{\n    static JNF_STATIC_MEMBER_CACHE(jm_getFocusOwner, sjc_CAccessibility, \"getFocusOwner\", \"(Ljava/awt/Component;)Ljavax/accessibility/Accessible;\");\n\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    id value = nil;\n\n    NSWindow* hostWindow = [[self->fView window] retain];\n    jobject focused = JNFCallStaticObjectMethod(env, jm_getFocusOwner, fComponent); // AWT_THREADING Safe (AWTRunLoop)\n    [hostWindow release];\n    \n    if (focused != NULL) {\n        if (JNFIsInstanceOf(env, focused, &sjc_Accessible)) {\n            value = [JavaComponentAccessibility createWithAccessible:focused withEnv:env withView:fView];\n        }\n        (*env)->DeleteLocalRef(env, focused);\n    }\n\n    if (value == nil) {\n        value = self;\n    }\n#ifdef JAVA_AX_DEBUG\n    NSLog(@\"%s: %@\", __FUNCTION__, value);\n#endif\n    return value;\n}\n\n@end\n\n/*\n * Class:     sun_lwawt_macosx_CAccessibility\n * Method:    focusChanged\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_sun_lwawt_macosx_CAccessibility_focusChanged\n(JNIEnv *env, jobject jthis)\n{\n\nJNF_COCOA_ENTER(env);\n    [ThreadUtilities performOnMainThread:@selector(postFocusChanged:) on:[JavaComponentAccessibility class] withObject:nil waitUntilDone:NO];\nJNF_COCOA_EXIT(env);\n}\n\n\n\n/*\n * Class:     sun_lwawt_macosx_CAccessible\n * Method:    valueChanged\n * Signature: (I)V\n */\nJNIEXPORT void JNICALL Java_sun_lwawt_macosx_CAccessible_valueChanged\n(JNIEnv *env, jclass jklass, jlong element)\n{\nJNF_COCOA_ENTER(env);\n    [ThreadUtilities performOnMainThread:@selector(postValueChanged) on:(JavaComponentAccessibility *)jlong_to_ptr(element) withObject:nil waitUntilDone:NO];\nJNF_COCOA_EXIT(env);\n}\n\n/*\n * Class:     sun_lwawt_macosx_CAccessible\n * Method:    selectionChanged\n * Signature: (I)V\n */\nJNIEXPORT void JNICALL Java_sun_lwawt_macosx_CAccessible_selectionChanged\n(JNIEnv *env, jclass jklass, jlong element)\n{\nJNF_COCOA_ENTER(env);\n    [ThreadUtilities performOnMainThread:@selector(postSelectionChanged) on:(JavaComponentAccessibility *)jlong_to_ptr(element) withObject:nil waitUntilDone:NO];\nJNF_COCOA_EXIT(env);\n}\n\n\n/*\n * Class:     sun_lwawt_macosx_CAccessible\n * Method:    unregisterFromCocoaAXSystem\n * Signature: (I)V\n */\nJNIEXPORT void JNICALL Java_sun_lwawt_macosx_CAccessible_unregisterFromCocoaAXSystem\n(JNIEnv *env, jclass jklass, jlong element)\n{\nJNF_COCOA_ENTER(env);\n    [ThreadUtilities performOnMainThread:@selector(unregisterFromCocoaAXSystem) on:(JavaComponentAccessibility *)jlong_to_ptr(element) withObject:nil waitUntilDone:NO];\nJNF_COCOA_EXIT(env);\n}\n\n@implementation TabGroupAccessibility\n\n- (id)initWithParent:(NSObject *)parent withEnv:(JNIEnv *)env withAccessible:(jobject)accessible withIndex:(jint)index withView:(NSView *)view withJavaRole:(NSString *)javaRole\n{\n    self = [super initWithParent:parent withEnv:env withAccessible:accessible withIndex:index withView:view withJavaRole:javaRole];\n    if (self) {\n        _numTabs = -1; //flag for uninitialized numTabs\n    }\n    return self;\n}\n\n- (NSArray *)initializeAttributeNamesWithEnv:(JNIEnv *)env\n{\n    NSMutableArray *names = (NSMutableArray *)[super initializeAttributeNamesWithEnv:env];\n\n    [names addObject:NSAccessibilityTabsAttribute];\n    [names addObject:NSAccessibilityContentsAttribute];\n    [names addObject:NSAccessibilityValueAttribute];\n\n    return names;\n}\n\n- (id)currentTabWithEnv:(JNIEnv *)env withAxContext:(jobject)axContext\n{\n    NSArray *tabs = [self tabControlsWithEnv:env withTabGroupAxContext:axContext withTabCode:JAVA_AX_ALL_CHILDREN allowIgnored:NO];\n\n    // Looking at the JTabbedPane sources, there is always one AccessibleSelection.\n    jobject selAccessible = getAxContextSelection(env, axContext, 0, fComponent);\n    if (selAccessible == NULL) return nil;\n\n    // Go through the tabs and find selAccessible\n    _numTabs = [tabs count];\n    JavaComponentAccessibility *aTab;\n    NSInteger i;\n    for (i = 0; i < _numTabs; i++) {\n        aTab = (JavaComponentAccessibility *)[tabs objectAtIndex:i];\n        if ([aTab isAccessibleWithEnv:env forAccessible:selAccessible]) {\n            (*env)->DeleteLocalRef(env, selAccessible);\n            return aTab;\n        }\n    }\n    (*env)->DeleteLocalRef(env, selAccessible);\n    return nil;\n}\n\n- (NSArray *)tabControlsWithEnv:(JNIEnv *)env withTabGroupAxContext:(jobject)axContext withTabCode:(NSInteger)whichTabs allowIgnored:(BOOL)allowIgnored\n{\n    jobjectArray jtabsAndRoles = (jobjectArray)JNFCallStaticObjectMethod(env, jm_getChildrenAndRoles, fAccessible, fComponent, whichTabs, allowIgnored); // AWT_THREADING Safe (AWTRunLoop)\n    if(jtabsAndRoles == NULL) return nil;\n\n    jsize arrayLen = (*env)->GetArrayLength(env, jtabsAndRoles);\n    if (arrayLen == 0) {\n        (*env)->DeleteLocalRef(env, jtabsAndRoles);\n        return nil;\n    }\n    NSMutableArray *tabs = [NSMutableArray arrayWithCapacity:(arrayLen/2)];\n\n    // all of the tabs have the same role, so we can just find out what that is here and use it for all the tabs\n    jobject jtabJavaRole = (*env)->GetObjectArrayElement(env, jtabsAndRoles, 1); // the array entries alternate between tab/role, starting with tab. so the first role is entry 1.\n    if (jtabJavaRole == NULL) {\n        (*env)->DeleteLocalRef(env, jtabsAndRoles);\n        return nil;\n    }\n    jobject jkey = JNFGetObjectField(env, jtabJavaRole, sjf_key);\n    NSString *tabJavaRole = JNFJavaToNSString(env, jkey);\n    (*env)->DeleteLocalRef(env, jkey);\n\n    NSInteger i;\n    NSUInteger tabIndex = (whichTabs >= 0) ? whichTabs : 0; // if we're getting one particular child, make sure to set its index correctly\n    for(i = 0; i < arrayLen; i+=2) {\n        jobject jtab = (*env)->GetObjectArrayElement(env, jtabsAndRoles, i);\n        JavaComponentAccessibility *tab = [[[TabGroupControlAccessibility alloc] initWithParent:self withEnv:env withAccessible:jtab withIndex:tabIndex withTabGroup:axContext withView:[self view] withJavaRole:tabJavaRole] autorelease];\n        (*env)->DeleteLocalRef(env, jtab);\n        [tabs addObject:tab];\n        tabIndex++;\n    }\n    (*env)->DeleteLocalRef(env, jtabsAndRoles);\n    return tabs;\n}\n\n- (NSArray *)contentsWithEnv:(JNIEnv *)env withTabGroupAxContext:(jobject)axContext withTabCode:(NSInteger)whichTabs allowIgnored:(BOOL)allowIgnored\n{\n    // Contents are the children of the selected tab.\n    id currentTab = [self currentTabWithEnv:env withAxContext:axContext];\n    if (currentTab == nil) return nil;\n\n    NSArray *contents = [JavaComponentAccessibility childrenOfParent:currentTab withEnv:env withChildrenCode:whichTabs allowIgnored:allowIgnored];\n    if ([contents count] <= 0) return nil;\n    return contents;\n}\n\n- (id) accessibilityTabsAttribute\n{\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    jobject axContext = [self axContextWithEnv:env];\n    id tabs = [self tabControlsWithEnv:env withTabGroupAxContext:axContext withTabCode:JAVA_AX_ALL_CHILDREN allowIgnored:NO];\n    (*env)->DeleteLocalRef(env, axContext);\n    return tabs;\n}\n\n- (BOOL)accessibilityIsTabsAttributeSettable\n{\n    return NO; //cmcnote: not sure.\n}\n\n- (NSInteger)numTabs\n{\n    if (_numTabs == -1) {\n        _numTabs = [[self accessibilityTabsAttribute] count];\n    }\n    return _numTabs;\n}\n\n- (NSArray *) accessibilityContentsAttribute\n{\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    jobject axContext = [self axContextWithEnv:env];\n    NSArray* cont = [self contentsWithEnv:env withTabGroupAxContext:axContext withTabCode:JAVA_AX_ALL_CHILDREN allowIgnored:NO];\n    (*env)->DeleteLocalRef(env, axContext);\n    return cont;\n}\n\n- (BOOL)accessibilityIsContentsAttributeSettable\n{\n    return NO;\n}\n\n// axValue is the currently selected tab\n-(id) accessibilityValueAttribute\n{\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    jobject axContext = [self axContextWithEnv:env];\n    id val = [self currentTabWithEnv:env withAxContext:axContext];\n    (*env)->DeleteLocalRef(env, axContext);\n    return val;\n}\n\n- (BOOL)accessibilityIsValueAttributeSettable\n{\n    return YES;\n}\n\n- (void)accessibilitySetValueAttribute:(id)value //cmcnote: not certain this is ever actually called. investigate.\n{\n    // set the current tab\n    NSNumber *number = (NSNumber *)value;\n    if (![number boolValue]) return;\n\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    jobject axContext = [self axContextWithEnv:env];\n    setAxContextSelection(env, axContext, fIndex, fComponent);\n    (*env)->DeleteLocalRef(env, axContext);\n}\n\n- (NSArray *)accessibilityChildrenAttribute\n{\n    //children = AXTabs + AXContents\n    NSArray *tabs = [self accessibilityTabsAttribute];\n    NSArray *contents = [self accessibilityContentsAttribute];\n\n    NSMutableArray *children = [NSMutableArray arrayWithCapacity:[tabs count] + [contents count]];\n    [children addObjectsFromArray:tabs];\n    [children addObjectsFromArray:contents];\n\n    return (NSArray *)children;\n}\n\n// Without this optimization accessibilityChildrenAttribute is called in order to get the entire array of children.\n// See similar optimization in JavaComponentAccessibility. We have to extend the base implementation here, since\n// children of tabs are AXTabs + AXContents\n- (NSArray *)accessibilityArrayAttributeValues:(NSString *)attribute index:(NSUInteger)index maxCount:(NSUInteger)maxCount {\n    NSArray *result = nil;\n    if ( (maxCount == 1) && [attribute isEqualToString:NSAccessibilityChildrenAttribute]) {\n        // Children codes for ALL, SELECTED, VISIBLE are <0. If the code is >=0, we treat it as an index to a single child\n        JNIEnv *env = [ThreadUtilities getJNIEnv];\n        jobject axContext = [self axContextWithEnv:env];\n\n        //children = AXTabs + AXContents\n        NSArray *children = [self tabControlsWithEnv:env withTabGroupAxContext:axContext withTabCode:index allowIgnored:NO]; // first look at the tabs\n        if ([children count] > 0) {\n            result = children;\n         } else {\n            children= [self contentsWithEnv:env withTabGroupAxContext:axContext withTabCode:(index-[self numTabs]) allowIgnored:NO];\n            if ([children count] > 0) {\n                result = children;\n            }\n        }\n        (*env)->DeleteLocalRef(env, axContext);\n    } else {\n        result = [super accessibilityArrayAttributeValues:attribute index:index maxCount:maxCount];\n    }\n    return result;\n}\n\n@end\n\n\nstatic BOOL ObjectEquals(JNIEnv *env, jobject a, jobject b, jobject component);\n\n@implementation TabGroupControlAccessibility\n\n- (id)initWithParent:(NSObject *)parent withEnv:(JNIEnv *)env withAccessible:(jobject)accessible withIndex:(jint)index withTabGroup:(jobject)tabGroup withView:(NSView *)view withJavaRole:(NSString *)javaRole\n{\n    self = [super initWithParent:parent withEnv:env withAccessible:accessible withIndex:index withView:view withJavaRole:javaRole];\n    if (self) {\n        if (tabGroup != NULL) {\n            fTabGroupAxContext = JNFNewWeakGlobalRef(env, tabGroup);\n        } else {\n            fTabGroupAxContext = NULL;\n        }\n    }\n    return self;\n}\n\n- (void)dealloc\n{\n    JNIEnv *env = [ThreadUtilities getJNIEnvUncached];\n\n    if (fTabGroupAxContext != NULL) {\n        JNFDeleteWeakGlobalRef(env, fTabGroupAxContext);\n        fTabGroupAxContext = NULL;\n    }\n\n    [super dealloc];\n}\n\n- (id)accessibilityValueAttribute\n{\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    jobject axContext = [self axContextWithEnv:env];\n    jobject selAccessible = getAxContextSelection(env, [self tabGroup], fIndex, fComponent);\n\n    // Returns the current selection of the page tab list\n    id val = [NSNumber numberWithBool:ObjectEquals(env, axContext, selAccessible, fComponent)];\n\n    (*env)->DeleteLocalRef(env, selAccessible);\n    (*env)->DeleteLocalRef(env, axContext);\n    return val;\n}\n\n- (void)getActionsWithEnv:(JNIEnv *)env\n{\n    TabGroupAction *action = [[TabGroupAction alloc] initWithEnv:env withTabGroup:[self tabGroup] withIndex:fIndex withComponent:fComponent];\n    [fActions setObject:action forKey:NSAccessibilityPressAction];\n    [action release];\n}\n\n- (jobject)tabGroup\n{\n    if (fTabGroupAxContext == NULL) {\n        JNIEnv* env = [ThreadUtilities getJNIEnv];\n        jobject tabGroupAxContext = [(JavaComponentAccessibility *)[self parent] axContextWithEnv:env];\n        fTabGroupAxContext = JNFNewWeakGlobalRef(env, tabGroupAxContext);\n        (*env)->DeleteLocalRef(env, tabGroupAxContext);\n    }\n    return fTabGroupAxContext;\n}\n\n@end\n\n\n@implementation ScrollAreaAccessibility\n\n- (NSArray *)initializeAttributeNamesWithEnv:(JNIEnv *)env\n{\n    NSMutableArray *names = (NSMutableArray *)[super initializeAttributeNamesWithEnv:env];\n\n    [names addObject:NSAccessibilityHorizontalScrollBarAttribute];\n    [names addObject:NSAccessibilityVerticalScrollBarAttribute];\n    [names addObject:NSAccessibilityContentsAttribute];\n\n    return names;\n}\n\n- (id)accessibilityHorizontalScrollBarAttribute\n{\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n\n    NSArray *children = [JavaComponentAccessibility childrenOfParent:self withEnv:env withChildrenCode:JAVA_AX_ALL_CHILDREN allowIgnored:YES];\n    if ([children count] <= 0) return nil;\n\n    // The scroll bars are in the children.\n    JavaComponentAccessibility *aElement;\n    NSEnumerator *enumerator = [children objectEnumerator];\n    while ((aElement = (JavaComponentAccessibility *)[enumerator nextObject])) {\n        if ([[aElement accessibilityRoleAttribute] isEqualToString:NSAccessibilityScrollBarRole]) {\n            jobject elementAxContext = [aElement axContextWithEnv:env];\n            if (isHorizontal(env, elementAxContext, fComponent)) {\n                (*env)->DeleteLocalRef(env, elementAxContext);\n                return aElement;\n            }\n            (*env)->DeleteLocalRef(env, elementAxContext);\n        }\n    }\n\n    return nil;\n}\n\n- (BOOL)accessibilityIsHorizontalScrollBarAttributeSettable\n{\n    return NO;\n}\n\n- (id)accessibilityVerticalScrollBarAttribute\n{\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n\n    NSArray *children = [JavaComponentAccessibility childrenOfParent:self withEnv:env withChildrenCode:JAVA_AX_ALL_CHILDREN allowIgnored:YES];\n    if ([children count] <= 0) return nil;\n\n    // The scroll bars are in the children.\n    NSEnumerator *enumerator = [children objectEnumerator];\n    JavaComponentAccessibility *aElement;\n    while ((aElement = (JavaComponentAccessibility *)[enumerator nextObject])) {\n        if ([[aElement accessibilityRoleAttribute] isEqualToString:NSAccessibilityScrollBarRole]) {\n            jobject elementAxContext = [aElement axContextWithEnv:env];\n            if (isVertical(env, elementAxContext, fComponent)) {\n                (*env)->DeleteLocalRef(env, elementAxContext);\n                return aElement;\n            }\n            (*env)->DeleteLocalRef(env, elementAxContext);\n        }\n    }\n\n    return nil;\n}\n\n- (BOOL)accessibilityIsVerticalScrollBarAttributeSettable\n{\n    return NO;\n}\n\n- (NSArray *)accessibilityContentsAttribute\n{\n    JNIEnv *env = [ThreadUtilities getJNIEnv];\n    NSArray *children = [JavaComponentAccessibility childrenOfParent:self withEnv:env withChildrenCode:JAVA_AX_ALL_CHILDREN allowIgnored:YES];\n\n    if ([children count] <= 0) return nil;\n    NSArray *contents = [NSMutableArray arrayWithCapacity:[children count]];\n\n    // The scroll bars are in the children. children less the scroll bars is the contents\n    NSEnumerator *enumerator = [children objectEnumerator];\n    JavaComponentAccessibility *aElement;\n    while ((aElement = (JavaComponentAccessibility *)[enumerator nextObject])) {\n        if (![[aElement accessibilityRoleAttribute] isEqualToString:NSAccessibilityScrollBarRole]) {\n            // no scroll bars in contents\n            [(NSMutableArray *)contents addObject:aElement];\n        }\n    }\n\n    return contents;\n}\n\n- (BOOL)accessibilityIsContentsAttributeSettable\n{\n    return NO;\n}\n\n@end\n\n/*\n * Returns Object.equals for the two items\n * This may use LWCToolkit.invokeAndWait(); don't call while holding fLock\n * and try to pass a component so the event happens on the correct thread.\n */\nstatic JNF_CLASS_CACHE(sjc_Object, \"java/lang/Object\");\nstatic BOOL ObjectEquals(JNIEnv *env, jobject a, jobject b, jobject component)\n{\n    static JNF_MEMBER_CACHE(jm_equals, sjc_Object, \"equals\", \"(Ljava/lang/Object;)Z\");\n\n    if ((a == NULL) && (b == NULL)) return YES;\n    if ((a == NULL) || (b == NULL)) return NO;\n\n    if (pthread_main_np() != 0) {\n        // If we are on the AppKit thread\n        static JNF_CLASS_CACHE(sjc_LWCToolkit, \"sun/lwawt/macosx/LWCToolkit\");\n        static JNF_STATIC_MEMBER_CACHE(jm_doEquals, sjc_LWCToolkit, \"doEquals\", \"(Ljava/lang/Object;Ljava/lang/Object;Ljava/awt/Component;)Z\");\n        return JNFCallStaticBooleanMethod(env, jm_doEquals, a, b, component); // AWT_THREADING Safe (AWTRunLoopMode)\n    }\n\n    return JNFCallBooleanMethod(env, a, jm_equals, b); // AWT_THREADING Safe (!appKit)\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/macosx/native/sun/awt/LWCToolkit.m": "/*\n * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#import <dlfcn.h>\n#import <JavaNativeFoundation/JavaNativeFoundation.h>\n\n#include \"jni_util.h\"\n#import \"CMenuBar.h\"\n#import \"InitIDs.h\"\n#import \"LWCToolkit.h\"\n#import \"ThreadUtilities.h\"\n#import \"AWT_debug.h\"\n#import \"CSystemColors.h\"\n#import  \"NSApplicationAWT.h\"\n\n#import \"sun_lwawt_macosx_LWCToolkit.h\"\n\n#import \"sizecalc.h\"\n\n// SCROLL PHASE STATE\n#define SCROLL_PHASE_UNSUPPORTED 1\n#define SCROLL_PHASE_BEGAN 2\n#define SCROLL_PHASE_CONTINUED 3\n#define SCROLL_PHASE_CANCELLED 4\n#define SCROLL_PHASE_ENDED 5\n\nint gNumberOfButtons;\njint* gButtonDownMasks;\n\n@implementation AWTToolkit\n\nstatic long eventCount;\n\n+ (long) getEventCount{\n    return eventCount;\n}\n\n+ (void) eventCountPlusPlus{    \n    eventCount++;\n}\n\n+ (jint) scrollStateWithEvent: (NSEvent*) event {\n\n    if ([event type] != NSScrollWheel) {\n        return 0;\n    }\n\n    NSEventPhase phase = [event phase];\n    NSEventPhase momentumPhase = [event momentumPhase];\n\n    if (!phase && !momentumPhase) return SCROLL_PHASE_UNSUPPORTED;\n    switch (phase) {\n        case NSEventPhaseBegan: return SCROLL_PHASE_BEGAN;\n        case NSEventPhaseCancelled: return SCROLL_PHASE_CANCELLED;\n        case NSEventPhaseEnded: return SCROLL_PHASE_ENDED;\n    }\n    return SCROLL_PHASE_CONTINUED;\n}\n@end\n\n\n@interface AWTRunLoopObject : NSObject {\n    BOOL _shouldEndRunLoop;\n}\n@end\n\n@implementation AWTRunLoopObject\n\n- (id) init {\n    self = [super init];\n    if (self != nil) {\n        _shouldEndRunLoop = NO;\n    }\n    return self;\n}\n\n- (BOOL) shouldEndRunLoop {\n    return _shouldEndRunLoop;\n}\n\n- (void) endRunLoop {\n    _shouldEndRunLoop = YES;\n}\n\n@end\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    nativeSyncQueue\n * Signature: (J)Z\n */\nJNIEXPORT jboolean JNICALL Java_sun_lwawt_macosx_LWCToolkit_nativeSyncQueue\n(JNIEnv *env, jobject self, jlong timeout)\n{\n    int currentEventNum = [AWTToolkit getEventCount];\n\n    NSApplication* sharedApp = [NSApplication sharedApplication];\n    if ([sharedApp isKindOfClass:[NSApplicationAWT class]]) {\n        NSApplicationAWT* theApp = (NSApplicationAWT*)sharedApp;\n        [theApp postDummyEvent];\n        [theApp waitForDummyEvent];\n    } else {\n        // could happen if we are embedded inside SWT application,\n        // in this case just spin a single empty block through \n        // the event loop to give it a chance to process pending events\n        [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){}];\n    }\n    \n    if (([AWTToolkit getEventCount] - currentEventNum) != 0) {\n        return JNI_TRUE;\n    }\n        \n    return JNI_FALSE;\n}\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    flushNativeSelectors\n * Signature: ()J\n */\nJNIEXPORT void JNICALL Java_sun_lwawt_macosx_LWCToolkit_flushNativeSelectors\n(JNIEnv *env, jclass clz)\n{\nJNF_COCOA_ENTER(env);\n        [ThreadUtilities performOnMainThreadWaiting:YES block:^(){}];\nJNF_COCOA_EXIT(env);\n}\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    beep\n * Signature: ()V\n */\nJNIEXPORT void JNICALL\nJava_sun_lwawt_macosx_LWCToolkit_beep\n(JNIEnv *env, jobject self)\n{\n    NSBeep(); // produces both sound and visual flash, if configured in System Preferences\n}\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    initIDs\n * Signature: ()V\n */\nJNIEXPORT void JNICALL\nJava_sun_lwawt_macosx_LWCToolkit_initIDs\n(JNIEnv *env, jclass klass) {\n    // set thread names\n    if (![ThreadUtilities isAWTEmbedded]) {\n        dispatch_async(dispatch_get_main_queue(), ^(void){\n            [[NSThread currentThread] setName:@\"AppKit Thread\"];\n            JNIEnv *env = [ThreadUtilities getJNIEnv];\n            static JNF_CLASS_CACHE(jc_LWCToolkit, \"sun/lwawt/macosx/LWCToolkit\");\n            static JNF_STATIC_MEMBER_CACHE(jsm_installToolkitThreadInJava, jc_LWCToolkit, \"installToolkitThreadInJava\", \"()V\");\n            JNFCallStaticVoidMethod(env, jsm_installToolkitThreadInJava);\n        });\n    }\n    \n    gNumberOfButtons = sun_lwawt_macosx_LWCToolkit_BUTTONS;\n\n    jclass inputEventClazz = (*env)->FindClass(env, \"java/awt/event/InputEvent\");\n    CHECK_NULL(inputEventClazz);\n    jmethodID getButtonDownMasksID = (*env)->GetStaticMethodID(env, inputEventClazz, \"getButtonDownMasks\", \"()[I\");\n    CHECK_NULL(getButtonDownMasksID);\n    jintArray obj = (jintArray)(*env)->CallStaticObjectMethod(env, inputEventClazz, getButtonDownMasksID);\n    jint * tmp = (*env)->GetIntArrayElements(env, obj, JNI_FALSE);\n    CHECK_NULL(tmp);\n\n    gButtonDownMasks = (jint*)SAFE_SIZE_ARRAY_ALLOC(malloc, sizeof(jint), gNumberOfButtons);\n    if (gButtonDownMasks == NULL) {\n        gNumberOfButtons = 0;\n        (*env)->ReleaseIntArrayElements(env, obj, tmp, JNI_ABORT);\n        JNU_ThrowOutOfMemoryError(env, NULL);\n        return;\n    }\n\n    int i;\n    for (i = 0; i < gNumberOfButtons; i++) {\n        gButtonDownMasks[i] = tmp[i];\n    }\n\n    (*env)->ReleaseIntArrayElements(env, obj, tmp, 0);\n    (*env)->DeleteLocalRef(env, obj);\n}\n\nstatic UInt32 RGB(NSColor *c) {\n    c = [c colorUsingColorSpaceName:NSCalibratedRGBColorSpace];\n    if (c == nil)\n    {\n        return -1; // opaque white\n    }\n\n    CGFloat r, g, b, a;\n    [c getRed:&r green:&g blue:&b alpha:&a];\n\n    UInt32 ir = (UInt32) (r*255+0.5),\n    ig = (UInt32) (g*255+0.5),\n    ib = (UInt32) (b*255+0.5),\n    ia = (UInt32) (a*255+0.5);\n\n    //    NSLog(@\"%@ %d, %d, %d\", c, ir, ig, ib);\n\n    return ((ia & 0xFF) << 24) | ((ir & 0xFF) << 16) | ((ig & 0xFF) << 8) | ((ib & 0xFF) << 0);\n}\n\nBOOL doLoadNativeColors(JNIEnv *env, jintArray jColors, BOOL useAppleColors) {\n    jint len = (*env)->GetArrayLength(env, jColors);\n\n    UInt32 colorsArray[len];\n    UInt32 *colors = colorsArray;\n\n    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n        NSUInteger i;\n        for (i = 0; i < len; i++) {\n            colors[i] = RGB([CSystemColors getColor:i useAppleColor:useAppleColors]);\n        }\n    }];\n\n    jint *_colors = (*env)->GetPrimitiveArrayCritical(env, jColors, 0);\n    if (_colors == NULL) {\n        return NO;\n    }\n    memcpy(_colors, colors, len * sizeof(UInt32));\n    (*env)->ReleasePrimitiveArrayCritical(env, jColors, _colors, 0);\n    return YES;\n}\n\n/**\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    loadNativeColors\n * Signature: ([I[I)V\n */\nJNIEXPORT void JNICALL Java_sun_lwawt_macosx_LWCToolkit_loadNativeColors\n(JNIEnv *env, jobject peer, jintArray jSystemColors, jintArray jAppleColors)\n{\nJNF_COCOA_ENTER(env);\n    if (doLoadNativeColors(env, jSystemColors, NO)) {\n        doLoadNativeColors(env, jAppleColors, YES);\n    }\nJNF_COCOA_EXIT(env);\n}\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    createAWTRunLoopMediator\n * Signature: ()J\n */\nJNIEXPORT jlong JNICALL Java_sun_lwawt_macosx_LWCToolkit_createAWTRunLoopMediator\n(JNIEnv *env, jclass clz)\n{\nAWT_ASSERT_APPKIT_THREAD;\n\n    jlong result;\n\nJNF_COCOA_ENTER(env);\n    // We double retain because this object is owned by both main thread and \"other\" thread\n    // We release in both doAWTRunLoop and stopAWTRunLoop\n    result = ptr_to_jlong([[[AWTRunLoopObject alloc] init] retain]);\nJNF_COCOA_EXIT(env);\n\n    return result;\n}\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    doAWTRunLoopImpl\n * Signature: (JZZ)V\n */\nJNIEXPORT void JNICALL Java_sun_lwawt_macosx_LWCToolkit_doAWTRunLoopImpl\n(JNIEnv *env, jclass clz, jlong mediator, jboolean processEvents, jboolean inAWT)\n{\nAWT_ASSERT_APPKIT_THREAD;\nJNF_COCOA_ENTER(env);\n\n    AWTRunLoopObject* mediatorObject = (AWTRunLoopObject*)jlong_to_ptr(mediator);\n\n    if (mediatorObject == nil) return;\n\n    // Don't use acceptInputForMode because that doesn't setup autorelease pools properly\n    BOOL isRunning = true;\n    while (![mediatorObject shouldEndRunLoop] && isRunning) {\n        isRunning = [[NSRunLoop currentRunLoop] runMode:(inAWT ? [JNFRunLoop javaRunLoopMode] : NSDefaultRunLoopMode)\n                                             beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.010]];\n        if (processEvents) {\n            //We do not spin a runloop here as date is nil, so does not matter which mode to use\n            // Processing all events excluding NSApplicationDefined which need to be processed \n            // on the main loop only (those events are intended for disposing resources)\n            NSEvent *event;\n            if ((event = [NSApp nextEventMatchingMask:(NSAnyEventMask & ~NSApplicationDefinedMask)\n                                           untilDate:nil\n                                              inMode:NSDefaultRunLoopMode\n                                             dequeue:YES]) != nil) {\n                [NSApp sendEvent:event];\n            }\n\n        }\n    }\n    [mediatorObject release];\nJNF_COCOA_EXIT(env);\n}\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    stopAWTRunLoop\n * Signature: (J)V\n */\nJNIEXPORT void JNICALL Java_sun_lwawt_macosx_LWCToolkit_stopAWTRunLoop\n(JNIEnv *env, jclass clz, jlong mediator)\n{\nJNF_COCOA_ENTER(env);\n\n    AWTRunLoopObject* mediatorObject = (AWTRunLoopObject*)jlong_to_ptr(mediator);\n\n    [ThreadUtilities performOnMainThread:@selector(endRunLoop) on:mediatorObject withObject:nil waitUntilDone:NO];\n\n    [mediatorObject release];\n\nJNF_COCOA_EXIT(env);\n}\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    isCapsLockOn\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL Java_sun_lwawt_macosx_LWCToolkit_isCapsLockOn\n(JNIEnv *env, jobject self)\n{\n    __block jboolean isOn = JNI_FALSE;\n    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n        NSUInteger modifiers = [NSEvent modifierFlags];\n        isOn = (modifiers & NSAlphaShiftKeyMask) != 0;\n    }];\n\n    return isOn;\n}\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    isApplicationActive\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL Java_sun_lwawt_macosx_LWCToolkit_isApplicationActive\n(JNIEnv *env, jclass clazz)\n{\n    __block jboolean active = JNI_FALSE;\n\nJNF_COCOA_ENTER(env);\n\n    [ThreadUtilities performOnMainThreadWaiting:YES block:^() {\n        active = (jboolean)[NSRunningApplication currentApplication].active;\n    }];\n\nJNF_COCOA_EXIT(env);\n\n    return active;\n}\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    activateApplicationIgnoringOtherApps\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_sun_lwawt_macosx_LWCToolkit_activateApplicationIgnoringOtherApps\n(JNIEnv *env, jclass clazz)\n{\n    JNF_COCOA_ENTER(env);\n    [ThreadUtilities performOnMainThreadWaiting:NO block:^(){\n        if(![NSApp isActive]){\n            [NSApp activateIgnoringOtherApps:YES];\n        }\n    }];\n    JNF_COCOA_EXIT(env);\n}\n\n\n/*\n * Class:     sun_awt_SunToolkit\n * Method:    closeSplashScreen\n * Signature: ()V\n */\nJNIEXPORT void JNICALL\nJava_sun_awt_SunToolkit_closeSplashScreen(JNIEnv *env, jclass cls)\n{\n    void *hSplashLib = dlopen(0, RTLD_LAZY);\n    if (!hSplashLib) return;\n\n    void (*splashClose)() = dlsym(hSplashLib, \"SplashClose\");\n    if (splashClose) {\n        splashClose();\n    }\n    dlclose(hSplashLib);\n}\n\n\n// TODO: definitely doesn't belong here (copied from fontpath.c in the\n// solaris tree)...\n\nJNIEXPORT jstring JNICALL\nJava_sun_font_FontManager_getFontPath\n(JNIEnv *env, jclass obj, jboolean noType1)\n{\n    return JNFNSToJavaString(env, @\"/Library/Fonts\");\n}\n\n// This isn't yet used on unix, the implementation is added since shared\n// code calls this method in preparation for future use.\nJNIEXPORT void JNICALL\nJava_sun_font_FontManager_populateFontFileNameMap\n(JNIEnv *env, jclass obj, jobject fontToFileMap, jobject fontToFamilyMap, jobject familyToFontListMap, jobject locale)\n{\n\n}\n\n/*\n * Class:     sun_lwawt_macosx_LWCToolkit\n * Method:    isEmbedded\n * Signature: ()Z\n */\nJNIEXPORT jboolean JNICALL\nJava_sun_lwawt_macosx_LWCToolkit_isEmbedded\n(JNIEnv *env, jclass klass) {\n    return [ThreadUtilities isAWTEmbedded] ? JNI_TRUE : JNI_FALSE;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/macosx/native/jobjc/src/core/native/Function.m": "/*\n * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"com_apple_jobjc_Function.h\"\n\n#define MACOSX\n#include <dlfcn.h>\n#include <JavaNativeFoundation/JavaNativeFoundation.h>\n\nJNIEXPORT jlong JNICALL Java_com_apple_jobjc_Function_getFxnPtrForFunctionName\n(JNIEnv *env, jclass clazz, jstring fxnName)\n{\n    const char *functionName = (*env)->GetStringUTFChars(env, fxnName, NULL);\n    void *fxnPtr = dlsym(RTLD_SELF, functionName);\n    (*env)->ReleaseStringUTFChars(env, fxnName, functionName);\n    return ptr_to_jlong(fxnPtr);\n}\n\nJNIEXPORT jlong JNICALL Java_com_apple_jobjc_Function_getFxnPtrForFunctionNameAndLib\n(JNIEnv *env, jclass clazz, jlong frameworkPtr, jstring fxnName)\n{\n    void *frameworkHandle = jlong_to_ptr(frameworkPtr);\n\n    const char *functionName = (*env)->GetStringUTFChars(env, fxnName, NULL);\n    void *fxnPtr = dlsym(frameworkHandle, functionName);\n    (*env)->ReleaseStringUTFChars(env, fxnName, functionName);\n\n    return ptr_to_jlong(fxnPtr);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/macosx/native/jobjc/src/core/native/MacOSXFramework.m": "/*\n * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n#include \"com_apple_jobjc_MacOSXFramework.h\"\n\n#include <dlfcn.h>\n#include <JavaNativeFoundation/JavaNativeFoundation.h>\n\n/*\n * Class:     com_apple_jobjc_MacOSXFramework\n * Method:    retainFramework\n * Signature: (Ljava/lang/String;)J\n */\nJNIEXPORT jlong JNICALL Java_com_apple_jobjc_MacOSXFramework_retainFramework\n(JNIEnv *env, jclass clazz, jstring frameworkName)\n{\n    if (frameworkName == NULL) return ptr_to_jlong(NULL);\n    const char *frameworkNameCStr = (*env)->GetStringUTFChars(env, frameworkName, JNI_FALSE);\n    const void *library = dlopen(frameworkNameCStr, RTLD_LOCAL);\n    (*env)->ReleaseStringUTFChars(env, frameworkName, frameworkNameCStr);\n    return ptr_to_jlong(library);\n}\n\n/*\n * Class:     com_apple_jobjc_MacOSXFramework\n * Method:    releaseFramework\n * Signature: (J)V\n */\nJNIEXPORT void JNICALL Java_com_apple_jobjc_MacOSXFramework_releaseFramework\n(JNIEnv *env, jclass clazz, jlong frameworkPtr)\n{\n    dlclose(jlong_to_ptr(frameworkPtr));\n}\n\nJNIEXPORT void JNICALL Java_com_apple_jobjc_MacOSXFramework_getConstant\n(JNIEnv *env, jclass clazz, jlong frameworkPtr, jstring constSymbol, jlong retBuffer, jint size)\n{\n    const char *symbol = (*env)->GetStringUTFChars(env, constSymbol, JNI_FALSE);\n    void *handle = frameworkPtr ? jlong_to_ptr(frameworkPtr) : RTLD_DEFAULT;\n    void *data = dlsym(handle, symbol);\n    (*env)->ReleaseStringUTFChars(env, constSymbol, symbol);\n\n    if(!data)\n        (*env)->ThrowNew(env, (*env)->FindClass(env, \"java/lang/RuntimeException\"), dlerror());\n    else\n        memcpy(jlong_to_ptr(retBuffer), data, (size_t) size);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/management/jmxremote/bootstrap/launcher.c": "/*\n * Copyright (c) 2006, 2007, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * A minature launcher for use by CustomLauncherTest.sh.  It sets\n * up the absolute minimal execution environment.\n */\n#include <stdlib.h>\n#include <strings.h>\n#include <dlfcn.h>\n\n#include \"jni.h\"\n\ntypedef jint (*create_vm_func)(JavaVM **, void**, void*);\n\nvoid *JNU_FindCreateJavaVM(char *vmlibpath) {\n    void *libVM = dlopen(vmlibpath, RTLD_LAZY);\n    if (libVM == NULL) {\n        return NULL;\n    }\n    return dlsym(libVM, \"JNI_CreateJavaVM\");\n}\n\n#define CP_PROP  \"-Djava.class.path=\"\n\nint main(int argc, char**argv) {\n     JNIEnv *env;\n     JavaVM *jvm;\n     jint res;\n     jclass cls;\n     jmethodID mid;\n     jstring jstr;\n     jclass stringClass;\n     jobjectArray args;\n     create_vm_func create_vm;\n     JavaVMInitArgs vm_args;\n     char* cp_prop;\n     JavaVMOption options[1];\n\n     if (argc < 4) {\n        fprintf(stderr, \"Usage: %s jvm-path classpath class\\n\", argv[0]);\n        return -1;\n     }\n     cp_prop = (char*)malloc(strlen(CP_PROP)+strlen(argv[2]) +1);\n     sprintf(cp_prop, \"%s%s\", CP_PROP, argv[2]);\n\n     options[0].optionString = cp_prop;\n     vm_args.version = 0x00010002;\n     vm_args.options = options;\n     vm_args.nOptions = 1;\n     vm_args.ignoreUnrecognized = JNI_TRUE;\n\n     create_vm = (create_vm_func)JNU_FindCreateJavaVM(argv[1]);\n     if (create_vm == NULL) {\n        fprintf(stderr, \"can't get address of JNI_CreateJavaVM\\n\");\n        return -1;\n     }\n\n     res = (*create_vm)(&jvm, (void**)&env, &vm_args);\n     if (res < 0) {\n         fprintf(stderr, \"Can't create Java VM\\n\");\n         return -1;\n     }\n     cls = (*env)->FindClass(env, argv[3]);\n     if (cls == NULL) {\n         goto destroy;\n     }\n\n     mid = (*env)->GetStaticMethodID(env, cls, \"main\",\n                                     \"([Ljava/lang/String;)V\");\n     if (mid == NULL) {\n         goto destroy;\n     }\n     jstr = (*env)->NewStringUTF(env, \" from C!\");\n     if (jstr == NULL) {\n         goto destroy;\n     }\n     stringClass = (*env)->FindClass(env, \"java/lang/String\");\n     args = (*env)->NewObjectArray(env, 1, stringClass, jstr);\n     if (args == NULL) {\n         goto destroy;\n     }\n     (*env)->CallStaticVoidMethod(env, cls, mid, args);\n\n destroy:\n     if ((*env)->ExceptionOccurred(env)) {\n         (*env)->ExceptionDescribe(env);\n     }\n     (*jvm)->DestroyJavaVM(jvm);\n\n     return 0;\n }\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os_cpu/solaris_x86/vm/os_solaris_x86.cpp": "/*\n * Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n// no precompiled headers\n#include \"asm/macroAssembler.hpp\"\n#include \"classfile/classLoader.hpp\"\n#include \"classfile/systemDictionary.hpp\"\n#include \"classfile/vmSymbols.hpp\"\n#include \"code/icBuffer.hpp\"\n#include \"code/vtableStubs.hpp\"\n#include \"interpreter/interpreter.hpp\"\n#include \"jvm_solaris.h\"\n#include \"memory/allocation.inline.hpp\"\n#include \"mutex_solaris.inline.hpp\"\n#include \"os_share_solaris.hpp\"\n#include \"prims/jniFastGetField.hpp\"\n#include \"prims/jvm.h\"\n#include \"prims/jvm_misc.hpp\"\n#include \"runtime/arguments.hpp\"\n#include \"runtime/extendedPC.hpp\"\n#include \"runtime/frame.inline.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/java.hpp\"\n#include \"runtime/javaCalls.hpp\"\n#include \"runtime/mutexLocker.hpp\"\n#include \"runtime/osThread.hpp\"\n#include \"runtime/sharedRuntime.hpp\"\n#include \"runtime/stubRoutines.hpp\"\n#include \"runtime/thread.inline.hpp\"\n#include \"runtime/timer.hpp\"\n#include \"utilities/events.hpp\"\n#include \"utilities/vmError.hpp\"\n\n// put OS-includes here\n# include <sys/types.h>\n# include <sys/mman.h>\n# include <pthread.h>\n# include <signal.h>\n# include <setjmp.h>\n# include <errno.h>\n# include <dlfcn.h>\n# include <stdio.h>\n# include <unistd.h>\n# include <sys/resource.h>\n# include <thread.h>\n# include <sys/stat.h>\n# include <sys/time.h>\n# include <sys/filio.h>\n# include <sys/utsname.h>\n# include <sys/systeminfo.h>\n# include <sys/socket.h>\n# include <sys/trap.h>\n# include <sys/lwp.h>\n# include <pwd.h>\n# include <poll.h>\n# include <sys/lwp.h>\n# include <procfs.h>     //  see comment in <sys/procfs.h>\n\n#ifndef AMD64\n// QQQ seems useless at this point\n# define _STRUCTURED_PROC 1  //  this gets us the new structured proc interfaces of 5.6 & later\n#endif // AMD64\n# include <sys/procfs.h>     //  see comment in <sys/procfs.h>\n\n\n#define MAX_PATH (2 * K)\n\n// Minimum stack size for the VM.  It's easier to document a constant value\n// but it's different for x86 and sparc because the page sizes are different.\n#ifdef AMD64\nsize_t os::Solaris::min_stack_allowed = 224*K;\n#define REG_SP REG_RSP\n#define REG_PC REG_RIP\n#define REG_FP REG_RBP\n#else\nsize_t os::Solaris::min_stack_allowed = 64*K;\n#define REG_SP UESP\n#define REG_PC EIP\n#define REG_FP EBP\n// 4900493 counter to prevent runaway LDTR refresh attempt\n\nstatic volatile int ldtr_refresh = 0;\n// the libthread instruction that faults because of the stale LDTR\n\nstatic const unsigned char movlfs[] = { 0x8e, 0xe0    // movl %eax,%fs\n                       };\n#endif // AMD64\n\nchar* os::non_memory_address_word() {\n  // Must never look like an address returned by reserve_memory,\n  // even in its subfields (as defined by the CPU immediate fields,\n  // if the CPU splits constants across multiple instructions).\n  return (char*) -1;\n}\n\n//\n// Validate a ucontext retrieved from walking a uc_link of a ucontext.\n// There are issues with libthread giving out uc_links for different threads\n// on the same uc_link chain and bad or circular links.\n//\nbool os::Solaris::valid_ucontext(Thread* thread, ucontext_t* valid, ucontext_t* suspect) {\n  if (valid >= suspect ||\n      valid->uc_stack.ss_flags != suspect->uc_stack.ss_flags ||\n      valid->uc_stack.ss_sp    != suspect->uc_stack.ss_sp    ||\n      valid->uc_stack.ss_size  != suspect->uc_stack.ss_size) {\n    DEBUG_ONLY(tty->print_cr(\"valid_ucontext: failed test 1\");)\n    return false;\n  }\n\n  if (thread->is_Java_thread()) {\n    if (!valid_stack_address(thread, (address)suspect)) {\n      DEBUG_ONLY(tty->print_cr(\"valid_ucontext: uc_link not in thread stack\");)\n      return false;\n    }\n    if (!valid_stack_address(thread,  (address) suspect->uc_mcontext.gregs[REG_SP])) {\n      DEBUG_ONLY(tty->print_cr(\"valid_ucontext: stackpointer not in thread stack\");)\n      return false;\n    }\n  }\n  return true;\n}\n\n// We will only follow one level of uc_link since there are libthread\n// issues with ucontext linking and it is better to be safe and just\n// let caller retry later.\nucontext_t* os::Solaris::get_valid_uc_in_signal_handler(Thread *thread,\n  ucontext_t *uc) {\n\n  ucontext_t *retuc = NULL;\n\n  if (uc != NULL) {\n    if (uc->uc_link == NULL) {\n      // cannot validate without uc_link so accept current ucontext\n      retuc = uc;\n    } else if (os::Solaris::valid_ucontext(thread, uc, uc->uc_link)) {\n      // first ucontext is valid so try the next one\n      uc = uc->uc_link;\n      if (uc->uc_link == NULL) {\n        // cannot validate without uc_link so accept current ucontext\n        retuc = uc;\n      } else if (os::Solaris::valid_ucontext(thread, uc, uc->uc_link)) {\n        // the ucontext one level down is also valid so return it\n        retuc = uc;\n      }\n    }\n  }\n  return retuc;\n}\n\n// Assumes ucontext is valid\nExtendedPC os::Solaris::ucontext_get_ExtendedPC(ucontext_t *uc) {\n  return ExtendedPC((address)uc->uc_mcontext.gregs[REG_PC]);\n}\n\n// Assumes ucontext is valid\nintptr_t* os::Solaris::ucontext_get_sp(ucontext_t *uc) {\n  return (intptr_t*)uc->uc_mcontext.gregs[REG_SP];\n}\n\n// Assumes ucontext is valid\nintptr_t* os::Solaris::ucontext_get_fp(ucontext_t *uc) {\n  return (intptr_t*)uc->uc_mcontext.gregs[REG_FP];\n}\n\naddress os::Solaris::ucontext_get_pc(ucontext_t *uc) {\n  return (address) uc->uc_mcontext.gregs[REG_PC];\n}\n\n// For Forte Analyzer AsyncGetCallTrace profiling support - thread\n// is currently interrupted by SIGPROF.\n//\n// The difference between this and os::fetch_frame_from_context() is that\n// here we try to skip nested signal frames.\nExtendedPC os::Solaris::fetch_frame_from_ucontext(Thread* thread,\n  ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {\n\n  assert(thread != NULL, \"just checking\");\n  assert(ret_sp != NULL, \"just checking\");\n  assert(ret_fp != NULL, \"just checking\");\n\n  ucontext_t *luc = os::Solaris::get_valid_uc_in_signal_handler(thread, uc);\n  return os::fetch_frame_from_context(luc, ret_sp, ret_fp);\n}\n\nExtendedPC os::fetch_frame_from_context(void* ucVoid,\n                    intptr_t** ret_sp, intptr_t** ret_fp) {\n\n  ExtendedPC  epc;\n  ucontext_t *uc = (ucontext_t*)ucVoid;\n\n  if (uc != NULL) {\n    epc = os::Solaris::ucontext_get_ExtendedPC(uc);\n    if (ret_sp) *ret_sp = os::Solaris::ucontext_get_sp(uc);\n    if (ret_fp) *ret_fp = os::Solaris::ucontext_get_fp(uc);\n  } else {\n    // construct empty ExtendedPC for return value checking\n    epc = ExtendedPC(NULL);\n    if (ret_sp) *ret_sp = (intptr_t *)NULL;\n    if (ret_fp) *ret_fp = (intptr_t *)NULL;\n  }\n\n  return epc;\n}\n\nframe os::fetch_frame_from_context(void* ucVoid) {\n  intptr_t* sp;\n  intptr_t* fp;\n  ExtendedPC epc = fetch_frame_from_context(ucVoid, &sp, &fp);\n  return frame(sp, fp, epc.pc());\n}\n\nframe os::get_sender_for_C_frame(frame* fr) {\n  return frame(fr->sender_sp(), fr->link(), fr->sender_pc());\n}\n\nextern \"C\" intptr_t *_get_current_sp();  // in .il file\n\naddress os::current_stack_pointer() {\n  return (address)_get_current_sp();\n}\n\nextern \"C\" intptr_t *_get_current_fp();  // in .il file\n\nframe os::current_frame() {\n  intptr_t* fp = _get_current_fp();  // it's inlined so want current fp\n  frame myframe((intptr_t*)os::current_stack_pointer(),\n                (intptr_t*)fp,\n                CAST_FROM_FN_PTR(address, os::current_frame));\n  if (os::is_first_C_frame(&myframe)) {\n    // stack is not walkable\n    frame ret; // This will be a null useless frame\n    return ret;\n  } else {\n    return os::get_sender_for_C_frame(&myframe);\n  }\n}\n\nstatic int threadgetstate(thread_t tid, int *flags, lwpid_t *lwp, stack_t *ss, gregset_t rs, lwpstatus_t *lwpstatus) {\n  char lwpstatusfile[PROCFILE_LENGTH];\n  int lwpfd, err;\n\n  if (err = os::Solaris::thr_getstate(tid, flags, lwp, ss, rs))\n    return (err);\n  if (*flags == TRS_LWPID) {\n    sprintf(lwpstatusfile, \"/proc/%d/lwp/%d/lwpstatus\", getpid(),\n            *lwp);\n    if ((lwpfd = open(lwpstatusfile, O_RDONLY)) < 0) {\n      perror(\"thr_mutator_status: open lwpstatus\");\n      return (EINVAL);\n    }\n    if (pread(lwpfd, lwpstatus, sizeof (lwpstatus_t), (off_t)0) !=\n        sizeof (lwpstatus_t)) {\n      perror(\"thr_mutator_status: read lwpstatus\");\n      (void) close(lwpfd);\n      return (EINVAL);\n    }\n    (void) close(lwpfd);\n  }\n  return (0);\n}\n\n#ifndef AMD64\n\n// Detecting SSE support by OS\n// From solaris_i486.s\nextern \"C\" bool sse_check();\nextern \"C\" bool sse_unavailable();\n\nenum { SSE_UNKNOWN, SSE_NOT_SUPPORTED, SSE_SUPPORTED};\nstatic int sse_status = SSE_UNKNOWN;\n\n\nstatic void  check_for_sse_support() {\n  if (!VM_Version::supports_sse()) {\n    sse_status = SSE_NOT_SUPPORTED;\n    return;\n  }\n  // looking for _sse_hw in libc.so, if it does not exist or\n  // the value (int) is 0, OS has no support for SSE\n  int *sse_hwp;\n  void *h;\n\n  if ((h=dlopen(\"/usr/lib/libc.so\", RTLD_LAZY)) == NULL) {\n    //open failed, presume no support for SSE\n    sse_status = SSE_NOT_SUPPORTED;\n    return;\n  }\n  if ((sse_hwp = (int *)dlsym(h, \"_sse_hw\")) == NULL) {\n    sse_status = SSE_NOT_SUPPORTED;\n  } else if (*sse_hwp == 0) {\n    sse_status = SSE_NOT_SUPPORTED;\n  }\n  dlclose(h);\n\n  if (sse_status == SSE_UNKNOWN) {\n    bool (*try_sse)() = (bool (*)())sse_check;\n    sse_status = (*try_sse)() ? SSE_SUPPORTED : SSE_NOT_SUPPORTED;\n  }\n\n}\n\n#endif // AMD64\n\nbool os::supports_sse() {\n#ifdef AMD64\n  return true;\n#else\n  if (sse_status == SSE_UNKNOWN)\n    check_for_sse_support();\n  return sse_status == SSE_SUPPORTED;\n#endif // AMD64\n}\n\nbool os::is_allocatable(size_t bytes) {\n#ifdef AMD64\n  return true;\n#else\n\n  if (bytes < 2 * G) {\n    return true;\n  }\n\n  char* addr = reserve_memory(bytes, NULL);\n\n  if (addr != NULL) {\n    release_memory(addr, bytes);\n  }\n\n  return addr != NULL;\n#endif // AMD64\n\n}\n\nextern \"C\" JNIEXPORT int\nJVM_handle_solaris_signal(int sig, siginfo_t* info, void* ucVoid,\n                          int abort_if_unrecognized) {\n  ucontext_t* uc = (ucontext_t*) ucVoid;\n\n#ifndef AMD64\n  if (sig == SIGILL && info->si_addr == (caddr_t)sse_check) {\n    // the SSE instruction faulted. supports_sse() need return false.\n    uc->uc_mcontext.gregs[EIP] = (greg_t)sse_unavailable;\n    return true;\n  }\n#endif // !AMD64\n\n  Thread* t = ThreadLocalStorage::get_thread_slow();  // slow & steady\n\n  // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away\n  // (no destructors can be run)\n  os::WatcherThreadCrashProtection::check_crash_protection(sig, t);\n\n  SignalHandlerMark shm(t);\n\n  if(sig == SIGPIPE || sig == SIGXFSZ) {\n    if (os::Solaris::chained_handler(sig, info, ucVoid)) {\n      return true;\n    } else {\n      if (PrintMiscellaneous && (WizardMode || Verbose)) {\n        char buf[64];\n        warning(\"Ignoring %s - see 4229104 or 6499219\",\n                os::exception_name(sig, buf, sizeof(buf)));\n\n      }\n      return true;\n    }\n  }\n\n  JavaThread* thread = NULL;\n  VMThread* vmthread = NULL;\n\n  if (os::Solaris::signal_handlers_are_installed) {\n    if (t != NULL ){\n      if(t->is_Java_thread()) {\n        thread = (JavaThread*)t;\n      }\n      else if(t->is_VM_thread()){\n        vmthread = (VMThread *)t;\n      }\n    }\n  }\n\n  guarantee(sig != os::Solaris::SIGinterrupt(), \"Can not chain VM interrupt signal, try -XX:+UseAltSigs\");\n\n  if (sig == os::Solaris::SIGasync()) {\n    if(thread || vmthread){\n      OSThread::SR_handler(t, uc);\n      return true;\n    } else if (os::Solaris::chained_handler(sig, info, ucVoid)) {\n      return true;\n    } else {\n      // If os::Solaris::SIGasync not chained, and this is a non-vm and\n      // non-java thread\n      return true;\n    }\n  }\n\n  if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {\n    // can't decode this kind of signal\n    info = NULL;\n  } else {\n    assert(sig == info->si_signo, \"bad siginfo\");\n  }\n\n  // decide if this trap can be handled by a stub\n  address stub = NULL;\n\n  address pc          = NULL;\n\n  //%note os_trap_1\n  if (info != NULL && uc != NULL && thread != NULL) {\n    // factor me: getPCfromContext\n    pc = (address) uc->uc_mcontext.gregs[REG_PC];\n\n    if (StubRoutines::is_safefetch_fault(pc)) {\n      uc->uc_mcontext.gregs[REG_PC] = intptr_t(StubRoutines::continuation_for_safefetch_fault(pc));\n      return true;\n    }\n\n    // Handle ALL stack overflow variations here\n    if (sig == SIGSEGV && info->si_code == SEGV_ACCERR) {\n      address addr = (address) info->si_addr;\n      if (thread->in_stack_yellow_zone(addr)) {\n        thread->disable_stack_yellow_zone();\n        if (thread->thread_state() == _thread_in_Java) {\n          // Throw a stack overflow exception.  Guard pages will be reenabled\n          // while unwinding the stack.\n          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n        } else {\n          // Thread was in the vm or native code.  Return and try to finish.\n          return true;\n        }\n      } else if (thread->in_stack_red_zone(addr)) {\n        // Fatal red zone violation.  Disable the guard pages and fall through\n        // to handle_unexpected_exception way down below.\n        thread->disable_stack_red_zone();\n        tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n      }\n    }\n\n    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n      // Verify that OS save/restore AVX registers.\n      stub = VM_Version::cpuinfo_cont_addr();\n    }\n\n    if (thread->thread_state() == _thread_in_vm) {\n      if (sig == SIGBUS && info->si_code == BUS_OBJERR && thread->doing_unsafe_access()) {\n        stub = StubRoutines::handler_for_unsafe_access();\n      }\n    }\n\n    if (thread->thread_state() == _thread_in_Java) {\n      // Support Safepoint Polling\n      if ( sig == SIGSEGV && os::is_poll_address((address)info->si_addr)) {\n        stub = SharedRuntime::get_poll_stub(pc);\n      }\n      else if (sig == SIGBUS && info->si_code == BUS_OBJERR) {\n        // BugId 4454115: A read from a MappedByteBuffer can fault\n        // here if the underlying file has been truncated.\n        // Do not crash the VM in such a case.\n        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);\n        if (cb != NULL) {\n          nmethod* nm = cb->is_nmethod() ? (nmethod*)cb : NULL;\n          if (nm != NULL && nm->has_unsafe_access()) {\n            stub = StubRoutines::handler_for_unsafe_access();\n          }\n        }\n      }\n      else\n      if (sig == SIGFPE && info->si_code == FPE_INTDIV) {\n        // integer divide by zero\n        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);\n      }\n#ifndef AMD64\n      else if (sig == SIGFPE && info->si_code == FPE_FLTDIV) {\n        // floating-point divide by zero\n        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);\n      }\n      else if (sig == SIGFPE && info->si_code == FPE_FLTINV) {\n        // The encoding of D2I in i486.ad can cause an exception prior\n        // to the fist instruction if there was an invalid operation\n        // pending. We want to dismiss that exception. From the win_32\n        // side it also seems that if it really was the fist causing\n        // the exception that we do the d2i by hand with different\n        // rounding. Seems kind of weird. QQQ TODO\n        // Note that we take the exception at the NEXT floating point instruction.\n        if (pc[0] == 0xDB) {\n            assert(pc[0] == 0xDB, \"not a FIST opcode\");\n            assert(pc[1] == 0x14, \"not a FIST opcode\");\n            assert(pc[2] == 0x24, \"not a FIST opcode\");\n            return true;\n        } else {\n            assert(pc[-3] == 0xDB, \"not an flt invalid opcode\");\n            assert(pc[-2] == 0x14, \"not an flt invalid opcode\");\n            assert(pc[-1] == 0x24, \"not an flt invalid opcode\");\n        }\n      }\n      else if (sig == SIGFPE ) {\n        tty->print_cr(\"caught SIGFPE, info 0x%x.\", info->si_code);\n      }\n#endif // !AMD64\n\n        // QQQ It doesn't seem that we need to do this on x86 because we should be able\n        // to return properly from the handler without this extra stuff on the back side.\n\n      else if (sig == SIGSEGV && info->si_code > 0 && !MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {\n        // Determination of interpreter/vtable stub/compiled code null exception\n        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);\n      }\n    }\n\n    // jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in\n    // and the heap gets shrunk before the field access.\n    if ((sig == SIGSEGV) || (sig == SIGBUS)) {\n      address addr = JNI_FastGetField::find_slowcase_pc(pc);\n      if (addr != (address)-1) {\n        stub = addr;\n      }\n    }\n\n    // Check to see if we caught the safepoint code in the\n    // process of write protecting the memory serialization page.\n    // It write enables the page immediately after protecting it\n    // so we can just return to retry the write.\n    if ((sig == SIGSEGV) &&\n        os::is_memory_serialize_page(thread, (address)info->si_addr)) {\n      // Block current thread until the memory serialize page permission restored.\n      os::block_on_serialize_page_trap();\n      return true;\n    }\n  }\n\n  // Execution protection violation\n  //\n  // Preventative code for future versions of Solaris which may\n  // enable execution protection when running the 32-bit VM on AMD64.\n  //\n  // This should be kept as the last step in the triage.  We don't\n  // have a dedicated trap number for a no-execute fault, so be\n  // conservative and allow other handlers the first shot.\n  //\n  // Note: We don't test that info->si_code == SEGV_ACCERR here.\n  // this si_code is so generic that it is almost meaningless; and\n  // the si_code for this condition may change in the future.\n  // Furthermore, a false-positive should be harmless.\n  if (UnguardOnExecutionViolation > 0 &&\n      (sig == SIGSEGV || sig == SIGBUS) &&\n      uc->uc_mcontext.gregs[TRAPNO] == T_PGFLT) {  // page fault\n    int page_size = os::vm_page_size();\n    address addr = (address) info->si_addr;\n    address pc = (address) uc->uc_mcontext.gregs[REG_PC];\n    // Make sure the pc and the faulting address are sane.\n    //\n    // If an instruction spans a page boundary, and the page containing\n    // the beginning of the instruction is executable but the following\n    // page is not, the pc and the faulting address might be slightly\n    // different - we still want to unguard the 2nd page in this case.\n    //\n    // 15 bytes seems to be a (very) safe value for max instruction size.\n    bool pc_is_near_addr =\n      (pointer_delta((void*) addr, (void*) pc, sizeof(char)) < 15);\n    bool instr_spans_page_boundary =\n      (align_size_down((intptr_t) pc ^ (intptr_t) addr,\n                       (intptr_t) page_size) > 0);\n\n    if (pc == addr || (pc_is_near_addr && instr_spans_page_boundary)) {\n      static volatile address last_addr =\n        (address) os::non_memory_address_word();\n\n      // In conservative mode, don't unguard unless the address is in the VM\n      if (addr != last_addr &&\n          (UnguardOnExecutionViolation > 1 || os::address_is_in_vm(addr))) {\n\n        // Make memory rwx and retry\n        address page_start =\n          (address) align_size_down((intptr_t) addr, (intptr_t) page_size);\n        bool res = os::protect_memory((char*) page_start, page_size,\n                                      os::MEM_PROT_RWX);\n\n        if (PrintMiscellaneous && Verbose) {\n          char buf[256];\n          jio_snprintf(buf, sizeof(buf), \"Execution protection violation \"\n                       \"at \" INTPTR_FORMAT\n                       \", unguarding \" INTPTR_FORMAT \": %s, errno=%d\", addr,\n                       page_start, (res ? \"success\" : \"failed\"), errno);\n          tty->print_raw_cr(buf);\n        }\n        stub = pc;\n\n        // Set last_addr so if we fault again at the same address, we don't end\n        // up in an endless loop.\n        //\n        // There are two potential complications here.  Two threads trapping at\n        // the same address at the same time could cause one of the threads to\n        // think it already unguarded, and abort the VM.  Likely very rare.\n        //\n        // The other race involves two threads alternately trapping at\n        // different addresses and failing to unguard the page, resulting in\n        // an endless loop.  This condition is probably even more unlikely than\n        // the first.\n        //\n        // Although both cases could be avoided by using locks or thread local\n        // last_addr, these solutions are unnecessary complication: this\n        // handler is a best-effort safety net, not a complete solution.  It is\n        // disabled by default and should only be used as a workaround in case\n        // we missed any no-execute-unsafe VM code.\n\n        last_addr = addr;\n      }\n    }\n  }\n\n  if (stub != NULL) {\n    // save all thread context in case we need to restore it\n\n    if (thread != NULL) thread->set_saved_exception_pc(pc);\n    // 12/02/99: On Sparc it appears that the full context is also saved\n    // but as yet, no one looks at or restores that saved context\n    // factor me: setPC\n    uc->uc_mcontext.gregs[REG_PC] = (greg_t)stub;\n    return true;\n  }\n\n  // signal-chaining\n  if (os::Solaris::chained_handler(sig, info, ucVoid)) {\n    return true;\n  }\n\n#ifndef AMD64\n  // Workaround (bug 4900493) for Solaris kernel bug 4966651.\n  // Handle an undefined selector caused by an attempt to assign\n  // fs in libthread getipriptr(). With the current libthread design every 512\n  // thread creations the LDT for a private thread data structure is extended\n  // and thre is a hazard that and another thread attempting a thread creation\n  // will use a stale LDTR that doesn't reflect the structure's growth,\n  // causing a GP fault.\n  // Enforce the probable limit of passes through here to guard against an\n  // infinite loop if some other move to fs caused the GP fault. Note that\n  // this loop counter is ultimately a heuristic as it is possible for\n  // more than one thread to generate this fault at a time in an MP system.\n  // In the case of the loop count being exceeded or if the poll fails\n  // just fall through to a fatal error.\n  // If there is some other source of T_GPFLT traps and the text at EIP is\n  // unreadable this code will loop infinitely until the stack is exausted.\n  // The key to diagnosis in this case is to look for the bottom signal handler\n  // frame.\n\n  if(! IgnoreLibthreadGPFault) {\n    if (sig == SIGSEGV && uc->uc_mcontext.gregs[TRAPNO] == T_GPFLT) {\n      const unsigned char *p =\n                        (unsigned const char *) uc->uc_mcontext.gregs[EIP];\n\n      // Expected instruction?\n\n      if(p[0] == movlfs[0] && p[1] == movlfs[1]) {\n\n        Atomic::inc(&ldtr_refresh);\n\n        // Infinite loop?\n\n        if(ldtr_refresh < ((2 << 16) / PAGESIZE)) {\n\n          // No, force scheduling to get a fresh view of the LDTR\n\n          if(poll(NULL, 0, 10) == 0) {\n\n            // Retry the move\n\n            return false;\n          }\n        }\n      }\n    }\n  }\n#endif // !AMD64\n\n  if (!abort_if_unrecognized) {\n    // caller wants another chance, so give it to him\n    return false;\n  }\n\n  if (!os::Solaris::libjsig_is_loaded) {\n    struct sigaction oldAct;\n    sigaction(sig, (struct sigaction *)0, &oldAct);\n    if (oldAct.sa_sigaction != signalHandler) {\n      void* sighand = oldAct.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n                                          : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n      warning(\"Unexpected Signal %d occurred under user-defined signal handler %#lx\", sig, (long)sighand);\n    }\n  }\n\n  if (pc == NULL && uc != NULL) {\n    pc = (address) uc->uc_mcontext.gregs[REG_PC];\n  }\n\n  // unmask current signal\n  sigset_t newset;\n  sigemptyset(&newset);\n  sigaddset(&newset, sig);\n  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n\n  // Determine which sort of error to throw.  Out of swap may signal\n  // on the thread stack, which could get a mapping error when touched.\n  address addr = (address) info->si_addr;\n  if (sig == SIGBUS && info->si_code == BUS_OBJERR && info->si_errno == ENOMEM) {\n    vm_exit_out_of_memory(0, OOM_MMAP_ERROR, \"Out of swap space to map in thread stack.\");\n  }\n\n  VMError err(t, sig, pc, info, ucVoid);\n  err.report_and_die();\n\n  ShouldNotReachHere();\n  return false;\n}\n\nvoid os::print_context(outputStream *st, void *context) {\n  if (context == NULL) return;\n\n  ucontext_t *uc = (ucontext_t*)context;\n  st->print_cr(\"Registers:\");\n#ifdef AMD64\n  st->print(  \"RAX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RAX]);\n  st->print(\", RBX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBX]);\n  st->print(\", RCX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RCX]);\n  st->print(\", RDX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDX]);\n  st->cr();\n  st->print(  \"RSP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSP]);\n  st->print(\", RBP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBP]);\n  st->print(\", RSI=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSI]);\n  st->print(\", RDI=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDI]);\n  st->cr();\n  st->print(  \"R8 =\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R8]);\n  st->print(\", R9 =\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R9]);\n  st->print(\", R10=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R10]);\n  st->print(\", R11=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R11]);\n  st->cr();\n  st->print(  \"R12=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R12]);\n  st->print(\", R13=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R13]);\n  st->print(\", R14=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R14]);\n  st->print(\", R15=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R15]);\n  st->cr();\n  st->print(  \"RIP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RIP]);\n  st->print(\", RFLAGS=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RFL]);\n#else\n  st->print(  \"EAX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EAX]);\n  st->print(\", EBX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EBX]);\n  st->print(\", ECX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[ECX]);\n  st->print(\", EDX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EDX]);\n  st->cr();\n  st->print(  \"ESP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[UESP]);\n  st->print(\", EBP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EBP]);\n  st->print(\", ESI=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[ESI]);\n  st->print(\", EDI=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EDI]);\n  st->cr();\n  st->print(  \"EIP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EIP]);\n  st->print(\", EFLAGS=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EFL]);\n#endif // AMD64\n  st->cr();\n  st->cr();\n\n  intptr_t *sp = (intptr_t *)os::Solaris::ucontext_get_sp(uc);\n  st->print_cr(\"Top of Stack: (sp=\" PTR_FORMAT \")\", sp);\n  print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));\n  st->cr();\n\n  // Note: it may be unsafe to inspect memory near pc. For example, pc may\n  // point to garbage if entry point in an nmethod is corrupted. Leave\n  // this at the end, and hope for the best.\n  ExtendedPC epc = os::Solaris::ucontext_get_ExtendedPC(uc);\n  address pc = epc.pc();\n  st->print_cr(\"Instructions: (pc=\" PTR_FORMAT \")\", pc);\n  print_hex_dump(st, pc - 32, pc + 32, sizeof(char));\n}\n\nvoid os::print_register_info(outputStream *st, void *context) {\n  if (context == NULL) return;\n\n  ucontext_t *uc = (ucontext_t*)context;\n\n  st->print_cr(\"Register to memory mapping:\");\n  st->cr();\n\n  // this is horrendously verbose but the layout of the registers in the\n  // context does not match how we defined our abstract Register set, so\n  // we can't just iterate through the gregs area\n\n  // this is only for the \"general purpose\" registers\n\n#ifdef AMD64\n  st->print(\"RAX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RAX]);\n  st->print(\"RBX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RBX]);\n  st->print(\"RCX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RCX]);\n  st->print(\"RDX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RDX]);\n  st->print(\"RSP=\"); print_location(st, uc->uc_mcontext.gregs[REG_RSP]);\n  st->print(\"RBP=\"); print_location(st, uc->uc_mcontext.gregs[REG_RBP]);\n  st->print(\"RSI=\"); print_location(st, uc->uc_mcontext.gregs[REG_RSI]);\n  st->print(\"RDI=\"); print_location(st, uc->uc_mcontext.gregs[REG_RDI]);\n  st->print(\"R8 =\"); print_location(st, uc->uc_mcontext.gregs[REG_R8]);\n  st->print(\"R9 =\"); print_location(st, uc->uc_mcontext.gregs[REG_R9]);\n  st->print(\"R10=\"); print_location(st, uc->uc_mcontext.gregs[REG_R10]);\n  st->print(\"R11=\"); print_location(st, uc->uc_mcontext.gregs[REG_R11]);\n  st->print(\"R12=\"); print_location(st, uc->uc_mcontext.gregs[REG_R12]);\n  st->print(\"R13=\"); print_location(st, uc->uc_mcontext.gregs[REG_R13]);\n  st->print(\"R14=\"); print_location(st, uc->uc_mcontext.gregs[REG_R14]);\n  st->print(\"R15=\"); print_location(st, uc->uc_mcontext.gregs[REG_R15]);\n#else\n  st->print(\"EAX=\"); print_location(st, uc->uc_mcontext.gregs[EAX]);\n  st->print(\"EBX=\"); print_location(st, uc->uc_mcontext.gregs[EBX]);\n  st->print(\"ECX=\"); print_location(st, uc->uc_mcontext.gregs[ECX]);\n  st->print(\"EDX=\"); print_location(st, uc->uc_mcontext.gregs[EDX]);\n  st->print(\"ESP=\"); print_location(st, uc->uc_mcontext.gregs[UESP]);\n  st->print(\"EBP=\"); print_location(st, uc->uc_mcontext.gregs[EBP]);\n  st->print(\"ESI=\"); print_location(st, uc->uc_mcontext.gregs[ESI]);\n  st->print(\"EDI=\"); print_location(st, uc->uc_mcontext.gregs[EDI]);\n#endif\n\n  st->cr();\n}\n\n\n#ifdef AMD64\nvoid os::Solaris::init_thread_fpu_state(void) {\n  // Nothing to do\n}\n#else\n// From solaris_i486.s\nextern \"C\" void fixcw();\n\nvoid os::Solaris::init_thread_fpu_state(void) {\n  // Set fpu to 53 bit precision. This happens too early to use a stub.\n  fixcw();\n}\n\n// These routines are the initial value of atomic_xchg_entry(),\n// atomic_cmpxchg_entry(), atomic_inc_entry() and fence_entry()\n// until initialization is complete.\n// TODO - replace with .il implementation when compiler supports it.\n\ntypedef jint  xchg_func_t        (jint,  volatile jint*);\ntypedef jint  cmpxchg_func_t     (jint,  volatile jint*,  jint);\ntypedef jlong cmpxchg_long_func_t(jlong, volatile jlong*, jlong);\ntypedef jint  add_func_t         (jint,  volatile jint*);\n\njint os::atomic_xchg_bootstrap(jint exchange_value, volatile jint* dest) {\n  // try to use the stub:\n  xchg_func_t* func = CAST_TO_FN_PTR(xchg_func_t*, StubRoutines::atomic_xchg_entry());\n\n  if (func != NULL) {\n    os::atomic_xchg_func = func;\n    return (*func)(exchange_value, dest);\n  }\n  assert(Threads::number_of_threads() == 0, \"for bootstrap only\");\n\n  jint old_value = *dest;\n  *dest = exchange_value;\n  return old_value;\n}\n\njint os::atomic_cmpxchg_bootstrap(jint exchange_value, volatile jint* dest, jint compare_value) {\n  // try to use the stub:\n  cmpxchg_func_t* func = CAST_TO_FN_PTR(cmpxchg_func_t*, StubRoutines::atomic_cmpxchg_entry());\n\n  if (func != NULL) {\n    os::atomic_cmpxchg_func = func;\n    return (*func)(exchange_value, dest, compare_value);\n  }\n  assert(Threads::number_of_threads() == 0, \"for bootstrap only\");\n\n  jint old_value = *dest;\n  if (old_value == compare_value)\n    *dest = exchange_value;\n  return old_value;\n}\n\njlong os::atomic_cmpxchg_long_bootstrap(jlong exchange_value, volatile jlong* dest, jlong compare_value) {\n  // try to use the stub:\n  cmpxchg_long_func_t* func = CAST_TO_FN_PTR(cmpxchg_long_func_t*, StubRoutines::atomic_cmpxchg_long_entry());\n\n  if (func != NULL) {\n    os::atomic_cmpxchg_long_func = func;\n    return (*func)(exchange_value, dest, compare_value);\n  }\n  assert(Threads::number_of_threads() == 0, \"for bootstrap only\");\n\n  jlong old_value = *dest;\n  if (old_value == compare_value)\n    *dest = exchange_value;\n  return old_value;\n}\n\njint os::atomic_add_bootstrap(jint add_value, volatile jint* dest) {\n  // try to use the stub:\n  add_func_t* func = CAST_TO_FN_PTR(add_func_t*, StubRoutines::atomic_add_entry());\n\n  if (func != NULL) {\n    os::atomic_add_func = func;\n    return (*func)(add_value, dest);\n  }\n  assert(Threads::number_of_threads() == 0, \"for bootstrap only\");\n\n  return (*dest) += add_value;\n}\n\nxchg_func_t*         os::atomic_xchg_func         = os::atomic_xchg_bootstrap;\ncmpxchg_func_t*      os::atomic_cmpxchg_func      = os::atomic_cmpxchg_bootstrap;\ncmpxchg_long_func_t* os::atomic_cmpxchg_long_func = os::atomic_cmpxchg_long_bootstrap;\nadd_func_t*          os::atomic_add_func          = os::atomic_add_bootstrap;\n\nextern \"C\" void _solaris_raw_setup_fpu(address ptr);\nvoid os::setup_fpu() {\n  address fpu_cntrl = StubRoutines::addr_fpu_cntrl_wrd_std();\n  _solaris_raw_setup_fpu(fpu_cntrl);\n}\n#endif // AMD64\n\n#ifndef PRODUCT\nvoid os::verify_stack_alignment() {\n#ifdef AMD64\n  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n#endif\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os_cpu/solaris_sparc/vm/vm_version_solaris_sparc.cpp": "/*\n * Copyright (c) 2006, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include \"precompiled.hpp\"\n#include \"runtime/os.hpp\"\n#include \"vm_version_sparc.hpp\"\n\n#include <sys/auxv.h>\n#include <sys/auxv_SPARC.h>\n#include <sys/systeminfo.h>\n#include <kstat.h>\n#include <picl.h>\n#include <dlfcn.h>\n#include <link.h>\n\nextern \"C\" static int PICL_visit_cpu_helper(picl_nodehdl_t nodeh, void *result);\n\n// Functions from the library we need (signatures should match those in picl.h)\nextern \"C\" {\n  typedef int (*picl_initialize_func_t)(void);\n  typedef int (*picl_shutdown_func_t)(void);\n  typedef int (*picl_get_root_func_t)(picl_nodehdl_t *nodehandle);\n  typedef int (*picl_walk_tree_by_class_func_t)(picl_nodehdl_t rooth,\n      const char *classname, void *c_args,\n      int (*callback_fn)(picl_nodehdl_t hdl, void *args));\n  typedef int (*picl_get_prop_by_name_func_t)(picl_nodehdl_t nodeh, const char *nm,\n      picl_prophdl_t *ph);\n  typedef int (*picl_get_propval_func_t)(picl_prophdl_t proph, void *valbuf, size_t sz);\n  typedef int (*picl_get_propinfo_func_t)(picl_prophdl_t proph, picl_propinfo_t *pi);\n}\n\nclass PICL {\n  // Pointers to functions in the library\n  picl_initialize_func_t _picl_initialize;\n  picl_shutdown_func_t _picl_shutdown;\n  picl_get_root_func_t _picl_get_root;\n  picl_walk_tree_by_class_func_t _picl_walk_tree_by_class;\n  picl_get_prop_by_name_func_t _picl_get_prop_by_name;\n  picl_get_propval_func_t _picl_get_propval;\n  picl_get_propinfo_func_t _picl_get_propinfo;\n  // Handle to the library that is returned by dlopen\n  void *_dl_handle;\n\n  bool open_library();\n  void close_library();\n\n  template<typename FuncType> bool bind(FuncType& func, const char* name);\n  bool bind_library_functions();\n\n  // Get a value of the integer property. The value in the tree can be either 32 or 64 bit\n  // depending on the platform. The result is converted to int.\n  int get_int_property(picl_nodehdl_t nodeh, const char* name, int* result) {\n    picl_propinfo_t pinfo;\n    picl_prophdl_t proph;\n    if (_picl_get_prop_by_name(nodeh, name, &proph) != PICL_SUCCESS ||\n        _picl_get_propinfo(proph, &pinfo) != PICL_SUCCESS) {\n      return PICL_FAILURE;\n    }\n\n    if (pinfo.type != PICL_PTYPE_INT && pinfo.type != PICL_PTYPE_UNSIGNED_INT) {\n      assert(false, \"Invalid property type\");\n      return PICL_FAILURE;\n    }\n    if (pinfo.size == sizeof(int64_t)) {\n      int64_t val;\n      if (_picl_get_propval(proph, &val, sizeof(int64_t)) != PICL_SUCCESS) {\n        return PICL_FAILURE;\n      }\n      *result = static_cast<int>(val);\n    } else if (pinfo.size == sizeof(int32_t)) {\n      int32_t val;\n      if (_picl_get_propval(proph, &val, sizeof(int32_t)) != PICL_SUCCESS) {\n        return PICL_FAILURE;\n      }\n      *result = static_cast<int>(val);\n    } else {\n      assert(false, \"Unexpected integer property size\");\n      return PICL_FAILURE;\n    }\n    return PICL_SUCCESS;\n  }\n\n  // Visitor and a state machine that visits integer properties and verifies that the\n  // values are the same. Stores the unique value observed.\n  class UniqueValueVisitor {\n    PICL *_picl;\n    enum {\n      INITIAL,        // Start state, no assignments happened\n      ASSIGNED,       // Assigned a value\n      INCONSISTENT    // Inconsistent value seen\n    } _state;\n    int _value;\n  public:\n    UniqueValueVisitor(PICL* picl) : _picl(picl), _state(INITIAL) { }\n    int value() {\n      assert(_state == ASSIGNED, \"Precondition\");\n      return _value;\n    }\n    void set_value(int value) {\n      assert(_state == INITIAL, \"Precondition\");\n      _value = value;\n      _state = ASSIGNED;\n    }\n    bool is_initial()       { return _state == INITIAL;      }\n    bool is_assigned()      { return _state == ASSIGNED;     }\n    bool is_inconsistent()  { return _state == INCONSISTENT; }\n    void set_inconsistent() { _state = INCONSISTENT;         }\n\n    bool visit(picl_nodehdl_t nodeh, const char* name) {\n      assert(!is_inconsistent(), \"Precondition\");\n      int curr;\n      if (_picl->get_int_property(nodeh, name, &curr) == PICL_SUCCESS) {\n        if (!is_assigned()) { // first iteration\n          set_value(curr);\n        } else if (curr != value()) { // following iterations\n          set_inconsistent();\n        }\n        return true;\n      }\n      return false;\n    }\n  };\n\n  class CPUVisitor {\n    UniqueValueVisitor _l1_visitor;\n    UniqueValueVisitor _l2_visitor;\n    int _limit; // number of times visit() can be run\n  public:\n    CPUVisitor(PICL *picl, int limit) : _l1_visitor(picl), _l2_visitor(picl), _limit(limit) {}\n    static int visit(picl_nodehdl_t nodeh, void *arg) {\n      CPUVisitor *cpu_visitor = static_cast<CPUVisitor*>(arg);\n      UniqueValueVisitor* l1_visitor = cpu_visitor->l1_visitor();\n      UniqueValueVisitor* l2_visitor = cpu_visitor->l2_visitor();\n      if (!l1_visitor->is_inconsistent()) {\n        l1_visitor->visit(nodeh, \"l1-dcache-line-size\");\n      }\n      static const char* l2_data_cache_line_property_name = NULL;\n      // On the first visit determine the name of the l2 cache line size property and memoize it.\n      if (l2_data_cache_line_property_name == NULL) {\n        assert(!l2_visitor->is_inconsistent(), \"First iteration cannot be inconsistent\");\n        l2_data_cache_line_property_name = \"l2-cache-line-size\";\n        if (!l2_visitor->visit(nodeh, l2_data_cache_line_property_name)) {\n          l2_data_cache_line_property_name = \"l2-dcache-line-size\";\n          l2_visitor->visit(nodeh, l2_data_cache_line_property_name);\n        }\n      } else {\n        if (!l2_visitor->is_inconsistent()) {\n          l2_visitor->visit(nodeh, l2_data_cache_line_property_name);\n        }\n      }\n\n      if (l1_visitor->is_inconsistent() && l2_visitor->is_inconsistent()) {\n        return PICL_WALK_TERMINATE;\n      }\n      cpu_visitor->_limit--;\n      if (cpu_visitor->_limit <= 0) {\n        return PICL_WALK_TERMINATE;\n      }\n      return PICL_WALK_CONTINUE;\n    }\n    UniqueValueVisitor* l1_visitor() { return &_l1_visitor; }\n    UniqueValueVisitor* l2_visitor() { return &_l2_visitor; }\n  };\n  int _L1_data_cache_line_size;\n  int _L2_data_cache_line_size;\npublic:\n  static int visit_cpu(picl_nodehdl_t nodeh, void *state) {\n    return CPUVisitor::visit(nodeh, state);\n  }\n\n  PICL(bool is_fujitsu, bool is_sun4v) : _L1_data_cache_line_size(0), _L2_data_cache_line_size(0), _dl_handle(NULL) {\n    if (!open_library()) {\n      return;\n    }\n    if (_picl_initialize() == PICL_SUCCESS) {\n      picl_nodehdl_t rooth;\n      if (_picl_get_root(&rooth) == PICL_SUCCESS) {\n        const char* cpu_class = \"cpu\";\n        // If it's a Fujitsu machine, it's a \"core\"\n        if (is_fujitsu) {\n          cpu_class = \"core\";\n        }\n        CPUVisitor cpu_visitor(this, (is_sun4v && !is_fujitsu) ? 1 : os::processor_count());\n        _picl_walk_tree_by_class(rooth, cpu_class, &cpu_visitor, PICL_visit_cpu_helper);\n        if (cpu_visitor.l1_visitor()->is_assigned()) { // Is there a value?\n          _L1_data_cache_line_size = cpu_visitor.l1_visitor()->value();\n        }\n        if (cpu_visitor.l2_visitor()->is_assigned()) {\n          _L2_data_cache_line_size = cpu_visitor.l2_visitor()->value();\n        }\n      }\n      _picl_shutdown();\n    }\n    close_library();\n  }\n\n  unsigned int L1_data_cache_line_size() const { return _L1_data_cache_line_size; }\n  unsigned int L2_data_cache_line_size() const { return _L2_data_cache_line_size; }\n};\n\n\nextern \"C\" static int PICL_visit_cpu_helper(picl_nodehdl_t nodeh, void *result) {\n  return PICL::visit_cpu(nodeh, result);\n}\n\ntemplate<typename FuncType>\nbool PICL::bind(FuncType& func, const char* name) {\n  func = reinterpret_cast<FuncType>(dlsym(_dl_handle, name));\n  return func != NULL;\n}\n\nbool PICL::bind_library_functions() {\n  assert(_dl_handle != NULL, \"library should be open\");\n  return bind(_picl_initialize,         \"picl_initialize\"        ) &&\n         bind(_picl_shutdown,           \"picl_shutdown\"          ) &&\n         bind(_picl_get_root,           \"picl_get_root\"          ) &&\n         bind(_picl_walk_tree_by_class, \"picl_walk_tree_by_class\") &&\n         bind(_picl_get_prop_by_name,   \"picl_get_prop_by_name\"  ) &&\n         bind(_picl_get_propval,        \"picl_get_propval\"       ) &&\n         bind(_picl_get_propinfo,       \"picl_get_propinfo\"      );\n}\n\nbool PICL::open_library() {\n  _dl_handle = dlopen(\"libpicl.so.1\", RTLD_LAZY);\n  if (_dl_handle == NULL) {\n    return false;\n  }\n  if (!bind_library_functions()) {\n    assert(false, \"unexpected PICL API change\");\n    close_library();\n    return false;\n  }\n  return true;\n}\n\nvoid PICL::close_library() {\n  assert(_dl_handle != NULL, \"library should be open\");\n  dlclose(_dl_handle);\n  _dl_handle = NULL;\n}\n\n// We need to keep these here as long as we have to build on Solaris\n// versions before 10.\n#ifndef SI_ARCHITECTURE_32\n#define SI_ARCHITECTURE_32      516     /* basic 32-bit SI_ARCHITECTURE */\n#endif\n\n#ifndef SI_ARCHITECTURE_64\n#define SI_ARCHITECTURE_64      517     /* basic 64-bit SI_ARCHITECTURE */\n#endif\n\nstatic void do_sysinfo(int si, const char* string, int* features, int mask) {\n  char   tmp;\n  size_t bufsize = sysinfo(si, &tmp, 1);\n\n  // All SI defines used below must be supported.\n  guarantee(bufsize != -1, \"must be supported\");\n\n  char* buf = (char*) malloc(bufsize);\n\n  if (buf == NULL)\n    return;\n\n  if (sysinfo(si, buf, bufsize) == bufsize) {\n    // Compare the string.\n    if (strcmp(buf, string) == 0) {\n      *features |= mask;\n    }\n  }\n\n  free(buf);\n}\n\nint VM_Version::platform_features(int features) {\n  // getisax(2), SI_ARCHITECTURE_32, and SI_ARCHITECTURE_64 are\n  // supported on Solaris 10 and later.\n  if (os::Solaris::supports_getisax()) {\n\n    // Check 32-bit architecture.\n    do_sysinfo(SI_ARCHITECTURE_32, \"sparc\", &features, v8_instructions_m);\n\n    // Check 64-bit architecture.\n    do_sysinfo(SI_ARCHITECTURE_64, \"sparcv9\", &features, generic_v9_m);\n\n    // Extract valid instruction set extensions.\n    uint_t avs[2];\n    uint_t avn = os::Solaris::getisax(avs, 2);\n    assert(avn <= 2, \"should return two or less av's\");\n    uint_t av = avs[0];\n\n#ifndef PRODUCT\n    if (PrintMiscellaneous && Verbose) {\n      tty->print(\"getisax(2) returned: \" PTR32_FORMAT, av);\n      if (avn > 1) {\n        tty->print(\", \" PTR32_FORMAT, avs[1]);\n      }\n      tty->cr();\n    }\n#endif\n\n    if (av & AV_SPARC_MUL32)  features |= hardware_mul32_m;\n    if (av & AV_SPARC_DIV32)  features |= hardware_div32_m;\n    if (av & AV_SPARC_FSMULD) features |= hardware_fsmuld_m;\n    if (av & AV_SPARC_V8PLUS) features |= v9_instructions_m;\n    if (av & AV_SPARC_POPC)   features |= hardware_popc_m;\n    if (av & AV_SPARC_VIS)    features |= vis1_instructions_m;\n    if (av & AV_SPARC_VIS2)   features |= vis2_instructions_m;\n    if (avn > 1) {\n      uint_t av2 = avs[1];\n#ifndef AV2_SPARC_SPARC5\n#define AV2_SPARC_SPARC5 0x00000008 /* The 29 new fp and sub instructions */\n#endif\n      if (av2 & AV2_SPARC_SPARC5)       features |= sparc5_instructions_m;\n    }\n\n    // Next values are not defined before Solaris 10\n    // but Solaris 8 is used for jdk6 update builds.\n#ifndef AV_SPARC_ASI_BLK_INIT\n#define AV_SPARC_ASI_BLK_INIT 0x0080  /* ASI_BLK_INIT_xxx ASI */\n#endif\n    if (av & AV_SPARC_ASI_BLK_INIT) features |= blk_init_instructions_m;\n\n#ifndef AV_SPARC_FMAF\n#define AV_SPARC_FMAF 0x0100        /* Fused Multiply-Add */\n#endif\n    if (av & AV_SPARC_FMAF)         features |= fmaf_instructions_m;\n\n#ifndef AV_SPARC_FMAU\n#define    AV_SPARC_FMAU    0x0200  /* Unfused Multiply-Add */\n#endif\n    if (av & AV_SPARC_FMAU)         features |= fmau_instructions_m;\n\n#ifndef AV_SPARC_VIS3\n#define    AV_SPARC_VIS3    0x0400  /* VIS3 instruction set extensions */\n#endif\n    if (av & AV_SPARC_VIS3)         features |= vis3_instructions_m;\n\n#ifndef AV_SPARC_CBCOND\n#define AV_SPARC_CBCOND 0x10000000  /* compare and branch instrs supported */\n#endif\n    if (av & AV_SPARC_CBCOND)       features |= cbcond_instructions_m;\n\n#ifndef AV_SPARC_AES\n#define AV_SPARC_AES 0x00020000  /* aes instrs supported */\n#endif\n    if (av & AV_SPARC_AES)       features |= aes_instructions_m;\n\n#ifndef AV_SPARC_SHA1\n#define AV_SPARC_SHA1   0x00400000  /* sha1 instruction supported */\n#endif\n    if (av & AV_SPARC_SHA1)         features |= sha1_instruction_m;\n\n#ifndef AV_SPARC_SHA256\n#define AV_SPARC_SHA256 0x00800000  /* sha256 instruction supported */\n#endif\n    if (av & AV_SPARC_SHA256)       features |= sha256_instruction_m;\n\n#ifndef AV_SPARC_SHA512\n#define AV_SPARC_SHA512 0x01000000  /* sha512 instruction supported */\n#endif\n    if (av & AV_SPARC_SHA512)       features |= sha512_instruction_m;\n\n  } else {\n    // getisax(2) failed, use the old legacy code.\n#ifndef PRODUCT\n    if (PrintMiscellaneous && Verbose)\n      tty->print_cr(\"getisax(2) is not supported.\");\n#endif\n\n    char   tmp;\n    size_t bufsize = sysinfo(SI_ISALIST, &tmp, 1);\n    char*  buf     = (char*) malloc(bufsize);\n\n    if (buf != NULL) {\n      if (sysinfo(SI_ISALIST, buf, bufsize) == bufsize) {\n        // Figure out what kind of sparc we have\n        char *sparc_string = strstr(buf, \"sparc\");\n        if (sparc_string != NULL) {              features |= v8_instructions_m;\n          if (sparc_string[5] == 'v') {\n            if (sparc_string[6] == '8') {\n              if (sparc_string[7] == '-') {      features |= hardware_mul32_m;\n                                                 features |= hardware_div32_m;\n              } else if (sparc_string[7] == 'p') features |= generic_v9_m;\n              else                               features |= generic_v8_m;\n            } else if (sparc_string[6] == '9')   features |= generic_v9_m;\n          }\n        }\n\n        // Check for visualization instructions\n        char *vis = strstr(buf, \"vis\");\n        if (vis != NULL) {                       features |= vis1_instructions_m;\n          if (vis[3] == '2')                     features |= vis2_instructions_m;\n        }\n      }\n      free(buf);\n    }\n  }\n\n  // Determine the machine type.\n  do_sysinfo(SI_MACHINE, \"sun4v\", &features, sun4v_m);\n\n  {\n    // Using kstat to determine the machine type.\n    kstat_ctl_t* kc = kstat_open();\n    kstat_t* ksp = kstat_lookup(kc, (char*)\"cpu_info\", -1, NULL);\n    const char* implementation = \"UNKNOWN\";\n    if (ksp != NULL) {\n      if (kstat_read(kc, ksp, NULL) != -1 && ksp->ks_data != NULL) {\n        kstat_named_t* knm = (kstat_named_t *)ksp->ks_data;\n        for (int i = 0; i < ksp->ks_ndata; i++) {\n          if (strcmp((const char*)&(knm[i].name),\"implementation\") == 0) {\n#ifndef KSTAT_DATA_STRING\n#define KSTAT_DATA_STRING   9\n#endif\n            if (knm[i].data_type == KSTAT_DATA_CHAR) {\n              // VM is running on Solaris 8 which does not have value.str.\n              implementation = &(knm[i].value.c[0]);\n            } else if (knm[i].data_type == KSTAT_DATA_STRING) {\n              // VM is running on Solaris 10.\n#ifndef KSTAT_NAMED_STR_PTR\n              // Solaris 8 was used to build VM, define the structure it misses.\n              struct str_t {\n                union {\n                  char *ptr;     /* NULL-term string */\n                  char __pad[8]; /* 64-bit padding */\n                } addr;\n                uint32_t len;    /* # bytes for strlen + '\\0' */\n              };\n#define KSTAT_NAMED_STR_PTR(knptr) (( (str_t*)&((knptr)->value) )->addr.ptr)\n#endif\n              implementation = KSTAT_NAMED_STR_PTR(&knm[i]);\n            }\n#ifndef PRODUCT\n            if (PrintMiscellaneous && Verbose) {\n              tty->print_cr(\"cpu_info.implementation: %s\", implementation);\n            }\n#endif\n            // Convert to UPPER case before compare.\n            char* impl = strdup(implementation);\n\n            for (int i = 0; impl[i] != 0; i++)\n              impl[i] = (char)toupper((uint)impl[i]);\n            if (strstr(impl, \"SPARC64\") != NULL) {\n              features |= sparc64_family_m;\n            } else if (strstr(impl, \"SPARC-M\") != NULL) {\n              // M-series SPARC is based on T-series.\n              features |= (M_family_m | T_family_m);\n            } else if (strstr(impl, \"SPARC-T\") != NULL) {\n              features |= T_family_m;\n              if (strstr(impl, \"SPARC-T1\") != NULL) {\n                features |= T1_model_m;\n              }\n            } else {\n              if (strstr(impl, \"SPARC\") == NULL) {\n#ifndef PRODUCT\n                // kstat on Solaris 8 virtual machines (branded zones)\n                // returns \"(unsupported)\" implementation.\n                warning(\"kstat cpu_info implementation = '%s', should contain SPARC\", impl);\n#endif\n                implementation = \"SPARC\";\n              }\n            }\n            free((void*)impl);\n            break;\n          }\n        } // for(\n      }\n    }\n    assert(strcmp(implementation, \"UNKNOWN\") != 0,\n           \"unknown cpu info (changed kstat interface?)\");\n    kstat_close(kc);\n  }\n\n  // Figure out cache line sizes using PICL\n  PICL picl((features & sparc64_family_m) != 0, (features & sun4v_m) != 0);\n  _L2_data_cache_line_size = picl.L2_data_cache_line_size();\n\n  return features;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/hsdis/hsdis-demo.c": "/*\n * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n/* hsdis-demo.c -- dump a range of addresses as native instructions\n   This demonstrates the protocol required by the HotSpot PrintAssembly option.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n\n#include \"hsdis.h\"\n\n\nvoid greet(const char*);\nvoid disassemble(uintptr_t, uintptr_t);\nvoid end_of_file();\n\nconst char* options = NULL;\nint         raw     = 0;\nint         xml     = 0;\n\nint main(int ac, char** av) {\n  int greeted = 0;\n  int i;\n  for (i = 1; i < ac; i++) {\n    const char* arg = av[i];\n    if (arg[0] == '-') {\n      if (!strcmp(arg, \"-xml\"))\n        xml ^= 1;\n      else if (!strcmp(arg, \"-raw\"))\n        raw ^= 1;\n      else if (!strncmp(arg, \"-options=\", 9))\n        options = arg+9;\n      else\n        { printf(\"Usage: %s [-xml] [name...]\\n\", av[0]); exit(2); }\n      continue;\n    }\n    greet(arg);\n    greeted = 1;\n  }\n  if (!greeted)\n    greet(\"world\");\n  printf(\"...And now for something completely different:\\n\");\n  void *start = (void*) &main;\n  void *end = (void*) &end_of_file;\n#if defined(__ia64) || defined(__powerpc__)\n  /* On IA64 and PPC function pointers are pointers to function descriptors */\n  start = *((void**)start);\n  end = *((void**)end);\n#endif\n  disassemble(start, (end > start) ? end : start + 64);\n  printf(\"Cheers!\\n\");\n}\n\nvoid greet(const char* whom) {\n  printf(\"Hello, %s!\\n\", whom);\n}\n\nvoid end_of_file() { }\n\n/* don't disassemble after this point... */\n\n#include \"dlfcn.h\"\n\n#define DECODE_INSTRUCTIONS_VIRTUAL_NAME \"decode_instructions_virtual\"\n#define DECODE_INSTRUCTIONS_NAME \"decode_instructions\"\n#define HSDIS_NAME               \"hsdis\"\nstatic void* decode_instructions_pv = 0;\nstatic void* decode_instructions_sv = 0;\nstatic const char* hsdis_path[] = {\n  HSDIS_NAME\"-\"LIBARCH LIB_EXT,\n  \"./\" HSDIS_NAME\"-\"LIBARCH LIB_EXT,\n#ifdef TARGET_DIR\n  TARGET_DIR\"/\"HSDIS_NAME\"-\"LIBARCH LIB_EXT,\n#endif\n  NULL\n};\n\nstatic const char* load_decode_instructions() {\n  void* dllib = NULL;\n  const char* *next_in_path = hsdis_path;\n  while (1) {\n    decode_instructions_pv = dlsym(dllib, DECODE_INSTRUCTIONS_VIRTUAL_NAME);\n    decode_instructions_sv = dlsym(dllib, DECODE_INSTRUCTIONS_NAME);\n    if (decode_instructions_pv != NULL || decode_instructions_sv != NULL)\n      return NULL;\n    if (dllib != NULL)\n      return \"plugin does not defined \"DECODE_INSTRUCTIONS_VIRTUAL_NAME\" and \"DECODE_INSTRUCTIONS_NAME;\n    for (dllib = NULL; dllib == NULL; ) {\n      const char* next_lib = (*next_in_path++);\n      if (next_lib == NULL)\n        return \"cannot find plugin \"HSDIS_NAME LIB_EXT;\n      dllib = dlopen(next_lib, RTLD_LAZY);\n    }\n  }\n}\n\n\nstatic const char* lookup(void* addr) {\n#if defined(__ia64) || defined(__powerpc__)\n  /* On IA64 and PPC function pointers are pointers to function descriptors */\n#define CHECK_NAME(fn) \\\n  if (addr == *((void**) &fn))  return #fn;\n#else\n#define CHECK_NAME(fn) \\\n  if (addr == (void*) &fn)  return #fn;\n#endif\n\n  CHECK_NAME(main);\n  CHECK_NAME(greet);\n  return NULL;\n}\n\n/* does the event match the tag, followed by a null, space, or slash? */\n#define MATCH(event, tag) \\\n  (!strncmp(event, tag, sizeof(tag)-1) && \\\n   (!event[sizeof(tag)-1] || strchr(\" /\", event[sizeof(tag)-1])))\n\n\nstatic const char event_cookie[] = \"event_cookie\"; /* demo placeholder */\nstatic void* simple_handle_event(void* cookie, const char* event, void* arg) {\n  if (MATCH(event, \"/insn\")) {\n    // follow each complete insn by a nice newline\n    printf(\"\\n\");\n  }\n  return NULL;\n}\n\nstatic void* handle_event(void* cookie, const char* event, void* arg) {\n#define NS_DEMO \"demo:\"\n  if (cookie != event_cookie)\n    printf(\"*** bad event cookie %p != %p\\n\", cookie, event_cookie);\n\n  if (xml) {\n    /* We could almost do a printf(event, arg),\n       but for the sake of a better demo,\n       we dress the result up as valid XML.\n    */\n    const char* fmt = strchr(event, ' ');\n    int evlen = (fmt ? fmt - event : strlen(event));\n    if (!fmt) {\n      if (event[0] != '/') {\n        printf(\"<\"NS_DEMO\"%.*s>\", evlen, event);\n      } else {\n        printf(\"</\"NS_DEMO\"%.*s>\", evlen-1, event+1);\n      }\n    } else {\n      if (event[0] != '/') {\n        printf(\"<\"NS_DEMO\"%.*s\", evlen, event);\n        printf(fmt, arg);\n        printf(\">\");\n      } else {\n        printf(\"<\"NS_DEMO\"%.*s_done\", evlen-1, event+1);\n        printf(fmt, arg);\n        printf(\"/></\"NS_DEMO\"%.*s>\", evlen-1, event+1);\n      }\n    }\n  }\n\n  if (MATCH(event, \"insn\")) {\n    const char* name = lookup(arg);\n    if (name)  printf(\"%s:\\n\", name);\n\n    /* basic action for <insn>: */\n    printf(\" %p\\t\", arg);\n\n  } else if (MATCH(event, \"/insn\")) {\n    // follow each complete insn by a nice newline\n    printf(\"\\n\");\n  } else if (MATCH(event, \"mach\")) {\n    printf(\"Decoding for CPU '%s'\\n\", (char*) arg);\n\n  } else if (MATCH(event, \"addr\")) {\n    /* basic action for <addr/>: */\n    const char* name = lookup(arg);\n    if (name) {\n      printf(\"&%s (%p)\", name, arg);\n      /* return non-null to notify hsdis not to print the addr */\n      return arg;\n    }\n  }\n\n  /* null return is always safe; can mean \"I ignored it\" */\n  return NULL;\n}\n\n#define fprintf_callback \\\n  (decode_instructions_printf_callback_ftype)&fprintf\n\nvoid disassemble(uintptr_t from, uintptr_t to) {\n  const char* err = load_decode_instructions();\n  if (err != NULL) {\n    printf(\"%s: %s\\n\", err, dlerror());\n    exit(1);\n  }\n  decode_func_vtype decode_instructions_v\n    = (decode_func_vtype) decode_instructions_pv;\n  decode_func_stype decode_instructions_s\n    = (decode_func_stype) decode_instructions_sv;\n  void* res;\n  if (decode_instructions_pv != NULL) {\n    printf(\"\\nDecoding from %p to %p...with %s\\n\", from, to, DECODE_INSTRUCTIONS_VIRTUAL_NAME);\n    if (raw) {\n      res = (*decode_instructions_v)(from, to,\n                                     (unsigned char*)from, to - from,\n                                     simple_handle_event, stdout,\n                                     NULL, stdout,\n                                     options, 0);\n    } else {\n      res = (*decode_instructions_v)(from, to,\n                                    (unsigned char*)from, to - from,\n                                     handle_event, (void*) event_cookie,\n                                     fprintf_callback, stdout,\n                                     options, 0);\n    }\n    if (res != (void*)to)\n      printf(\"*** Result was %p!\\n\", res);\n  }\n  void* sres;\n  if (decode_instructions_sv != NULL) {\n    printf(\"\\nDecoding from %p to %p...with old decode_instructions\\n\", from, to, DECODE_INSTRUCTIONS_NAME);\n    if (raw) {\n      sres = (*decode_instructions_s)(from, to,\n                                      simple_handle_event, stdout,\n                                      NULL, stdout,\n                                      options);\n    } else {\n      sres = (*decode_instructions_s)(from, to,\n                                      handle_event, (void*) event_cookie,\n                                      fprintf_callback, stdout,\n                                      options);\n    }\n    if (sres != (void *)to)\n      printf(\"*** Result of decode_instructions %p!\\n\", sres);\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os/linux/vm/os_linux.hpp": "/*\n * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#ifndef OS_LINUX_VM_OS_LINUX_HPP\n#define OS_LINUX_VM_OS_LINUX_HPP\n\n// Linux_OS defines the interface to Linux operating systems\n\n/* pthread_getattr_np comes with LinuxThreads-0.9-7 on RedHat 7.1 */\ntypedef int (*pthread_getattr_func_type) (pthread_t, pthread_attr_t *);\n\n// Information about the protection of the page at address '0' on this os.\nstatic bool zero_page_read_protected() { return true; }\n\nclass Linux {\n  friend class os;\n  friend class TestReserveMemorySpecial;\n\n  // For signal-chaining\n#define MAXSIGNUM 32\n  static struct sigaction sigact[MAXSIGNUM]; // saved preinstalled sigactions\n  static unsigned int sigs;             // mask of signals that have\n                                        // preinstalled signal handlers\n  static bool libjsig_is_loaded;        // libjsig that interposes sigaction(),\n                                        // __sigaction(), signal() is loaded\n  static struct sigaction *(*get_signal_action)(int);\n  static struct sigaction *get_preinstalled_handler(int);\n  static void save_preinstalled_handler(int, struct sigaction&);\n\n  static void check_signal_handler(int sig);\n\n  // For signal flags diagnostics\n  static int sigflags[MAXSIGNUM];\n\n  static int (*_clock_gettime)(clockid_t, struct timespec *);\n  static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);\n\n  static address   _initial_thread_stack_bottom;\n  static uintptr_t _initial_thread_stack_size;\n\n  static const char *_glibc_version;\n  static const char *_libpthread_version;\n\n  static bool _is_floating_stack;\n  static bool _is_NPTL;\n  static bool _supports_fast_thread_cpu_time;\n\n  static GrowableArray<int>* _cpu_to_node;\n\n protected:\n\n  static julong _physical_memory;\n  static pthread_t _main_thread;\n  static Mutex* _createThread_lock;\n  static int _page_size;\n  static const int _vm_default_page_size;\n\n  static julong available_memory();\n  static julong physical_memory() { return _physical_memory; }\n  static void initialize_system_info();\n\n  static int commit_memory_impl(char* addr, size_t bytes, bool exec);\n  static int commit_memory_impl(char* addr, size_t bytes,\n                                size_t alignment_hint, bool exec);\n\n  static void set_glibc_version(const char *s)      { _glibc_version = s; }\n  static void set_libpthread_version(const char *s) { _libpthread_version = s; }\n\n  static bool supports_variable_stack_size();\n\n  static void set_is_NPTL()                   { _is_NPTL = true;  }\n  static void set_is_LinuxThreads()           { _is_NPTL = false; }\n  static void set_is_floating_stack()         { _is_floating_stack = true; }\n\n  static void rebuild_cpu_to_node_map();\n  static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }\n\n  static size_t find_large_page_size();\n  static size_t setup_large_page_size();\n\n  static bool setup_large_page_type(size_t page_size);\n  static bool transparent_huge_pages_sanity_check(bool warn, size_t pages_size);\n  static bool hugetlbfs_sanity_check(bool warn, size_t page_size);\n\n  static char* reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec);\n  static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, char* req_addr, bool exec);\n  static char* reserve_memory_special_huge_tlbfs_only(size_t bytes, char* req_addr, bool exec);\n  static char* reserve_memory_special_huge_tlbfs_mixed(size_t bytes, size_t alignment, char* req_addr, bool exec);\n\n  static bool release_memory_special_impl(char* base, size_t bytes);\n  static bool release_memory_special_shm(char* base, size_t bytes);\n  static bool release_memory_special_huge_tlbfs(char* base, size_t bytes);\n\n  static void print_full_memory_info(outputStream* st);\n  static void print_distro_info(outputStream* st);\n  static void print_libversion_info(outputStream* st);\n\n public:\n  static bool _stack_is_executable;\n  static void *dlopen_helper(const char *name, char *ebuf, int ebuflen);\n  static void *dll_load_in_vmthread(const char *name, char *ebuf, int ebuflen);\n\n  static void init_thread_fpu_state();\n  static int  get_fpu_control_word();\n  static void set_fpu_control_word(int fpu_control);\n  static pthread_t main_thread(void)                                { return _main_thread; }\n  // returns kernel thread id (similar to LWP id on Solaris), which can be\n  // used to access /proc\n  static pid_t gettid();\n  static void set_createThread_lock(Mutex* lk)                      { _createThread_lock = lk; }\n  static Mutex* createThread_lock(void)                             { return _createThread_lock; }\n  static void hotspot_sigmask(Thread* thread);\n\n  static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }\n  static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }\n  static bool is_initial_thread(void);\n\n  static int page_size(void)                                        { return _page_size; }\n  static void set_page_size(int val)                                { _page_size = val; }\n\n  static int vm_default_page_size(void)                             { return _vm_default_page_size; }\n\n  static address   ucontext_get_pc(ucontext_t* uc);\n  static intptr_t* ucontext_get_sp(ucontext_t* uc);\n  static intptr_t* ucontext_get_fp(ucontext_t* uc);\n\n  // For Analyzer Forte AsyncGetCallTrace profiling support:\n  //\n  // This interface should be declared in os_linux_i486.hpp, but\n  // that file provides extensions to the os class and not the\n  // Linux class.\n  static ExtendedPC fetch_frame_from_ucontext(Thread* thread, ucontext_t* uc,\n    intptr_t** ret_sp, intptr_t** ret_fp);\n\n  // This boolean allows users to forward their own non-matching signals\n  // to JVM_handle_linux_signal, harmlessly.\n  static bool signal_handlers_are_installed;\n\n  static int get_our_sigflags(int);\n  static void set_our_sigflags(int, int);\n  static void signal_sets_init();\n  static void install_signal_handlers();\n  static void set_signal_handler(int, bool);\n  static bool is_sig_ignored(int sig);\n\n  static sigset_t* unblocked_signals();\n  static sigset_t* vm_signals();\n  static sigset_t* allowdebug_blocked_signals();\n\n  // For signal-chaining\n  static struct sigaction *get_chained_signal_action(int sig);\n  static bool chained_handler(int sig, siginfo_t* siginfo, void* context);\n\n  // GNU libc and libpthread version strings\n  static const char *glibc_version()          { return _glibc_version; }\n  static const char *libpthread_version()     { return _libpthread_version; }\n\n  // NPTL or LinuxThreads?\n  static bool is_LinuxThreads()               { return !_is_NPTL; }\n  static bool is_NPTL()                       { return _is_NPTL;  }\n\n  // NPTL is always floating stack. LinuxThreads could be using floating\n  // stack or fixed stack.\n  static bool is_floating_stack()             { return _is_floating_stack; }\n\n  static void libpthread_init();\n  static bool libnuma_init();\n  static void* libnuma_dlsym(void* handle, const char* name);\n  // Minimum stack size a thread can be created with (allowing\n  // the VM to completely create the thread and enter user code)\n  static size_t min_stack_allowed;\n\n  // Return default stack size or guard size for the specified thread type\n  static size_t default_stack_size(os::ThreadType thr_type);\n  static size_t default_guard_size(os::ThreadType thr_type);\n\n  static void capture_initial_stack(size_t max_size);\n\n  // Stack overflow handling\n  static bool manually_expand_stack(JavaThread * t, address addr);\n  static int max_register_window_saves_before_flushing();\n\n  // Real-time clock functions\n  static void clock_init(void);\n\n  // fast POSIX clocks support\n  static void fast_thread_clock_init(void);\n\n  static inline bool supports_monotonic_clock() {\n    return _clock_gettime != NULL;\n  }\n\n  static int clock_gettime(clockid_t clock_id, struct timespec *tp) {\n    return _clock_gettime ? _clock_gettime(clock_id, tp) : -1;\n  }\n\n  static int pthread_getcpuclockid(pthread_t tid, clockid_t *clock_id) {\n    return _pthread_getcpuclockid ? _pthread_getcpuclockid(tid, clock_id) : -1;\n  }\n\n  static bool supports_fast_thread_cpu_time() {\n    return _supports_fast_thread_cpu_time;\n  }\n\n  static jlong fast_thread_cpu_time(clockid_t clockid);\n\n  // pthread_cond clock suppport\n  private:\n  static pthread_condattr_t _condattr[1];\n\n  public:\n  static pthread_condattr_t* condAttr() { return _condattr; }\n\n  // Stack repair handling\n\n  // none present\n\n  // LinuxThreads work-around for 6292965\n  static int safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime);\n\nprivate:\n  typedef int (*sched_getcpu_func_t)(void);\n  typedef int (*numa_node_to_cpus_func_t)(int node, unsigned long *buffer, int bufferlen);\n  typedef int (*numa_max_node_func_t)(void);\n  typedef int (*numa_available_func_t)(void);\n  typedef int (*numa_tonode_memory_func_t)(void *start, size_t size, int node);\n  typedef void (*numa_interleave_memory_func_t)(void *start, size_t size, unsigned long *nodemask);\n  typedef void (*numa_set_bind_policy_func_t)(int policy);\n\n  static sched_getcpu_func_t _sched_getcpu;\n  static numa_node_to_cpus_func_t _numa_node_to_cpus;\n  static numa_max_node_func_t _numa_max_node;\n  static numa_available_func_t _numa_available;\n  static numa_tonode_memory_func_t _numa_tonode_memory;\n  static numa_interleave_memory_func_t _numa_interleave_memory;\n  static numa_set_bind_policy_func_t _numa_set_bind_policy;\n  static unsigned long* _numa_all_nodes;\n\n  static void set_sched_getcpu(sched_getcpu_func_t func) { _sched_getcpu = func; }\n  static void set_numa_node_to_cpus(numa_node_to_cpus_func_t func) { _numa_node_to_cpus = func; }\n  static void set_numa_max_node(numa_max_node_func_t func) { _numa_max_node = func; }\n  static void set_numa_available(numa_available_func_t func) { _numa_available = func; }\n  static void set_numa_tonode_memory(numa_tonode_memory_func_t func) { _numa_tonode_memory = func; }\n  static void set_numa_interleave_memory(numa_interleave_memory_func_t func) { _numa_interleave_memory = func; }\n  static void set_numa_set_bind_policy(numa_set_bind_policy_func_t func) { _numa_set_bind_policy = func; }\n  static void set_numa_all_nodes(unsigned long* ptr) { _numa_all_nodes = ptr; }\n  static int sched_getcpu_syscall(void);\npublic:\n  static int sched_getcpu()  { return _sched_getcpu != NULL ? _sched_getcpu() : -1; }\n  static int numa_node_to_cpus(int node, unsigned long *buffer, int bufferlen) {\n    return _numa_node_to_cpus != NULL ? _numa_node_to_cpus(node, buffer, bufferlen) : -1;\n  }\n  static int numa_max_node() { return _numa_max_node != NULL ? _numa_max_node() : -1; }\n  static int numa_available() { return _numa_available != NULL ? _numa_available() : -1; }\n  static int numa_tonode_memory(void *start, size_t size, int node) {\n    return _numa_tonode_memory != NULL ? _numa_tonode_memory(start, size, node) : -1;\n  }\n  static void numa_interleave_memory(void *start, size_t size) {\n    if (_numa_interleave_memory != NULL && _numa_all_nodes != NULL) {\n      _numa_interleave_memory(start, size, _numa_all_nodes);\n    }\n  }\n  static void numa_set_bind_policy(int policy) {\n    if (_numa_set_bind_policy != NULL) {\n      _numa_set_bind_policy(policy);\n    }\n  }\n  static int get_node_by_cpu(int cpu_id);\n};\n\n\nclass PlatformEvent : public CHeapObj<mtInternal> {\n  private:\n    double CachePad [4] ;   // increase odds that _mutex is sole occupant of cache line\n    volatile int _Event ;\n    volatile int _nParked ;\n    pthread_mutex_t _mutex  [1] ;\n    pthread_cond_t  _cond   [1] ;\n    double PostPad  [2] ;\n    Thread * _Assoc ;\n\n  public:       // TODO-FIXME: make dtor private\n    ~PlatformEvent() { guarantee (0, \"invariant\") ; }\n\n  public:\n    PlatformEvent() {\n      int status;\n      status = pthread_cond_init (_cond, os::Linux::condAttr());\n      assert_status(status == 0, status, \"cond_init\");\n      status = pthread_mutex_init (_mutex, NULL);\n      assert_status(status == 0, status, \"mutex_init\");\n      _Event   = 0 ;\n      _nParked = 0 ;\n      _Assoc   = NULL ;\n    }\n\n    // Use caution with reset() and fired() -- they may require MEMBARs\n    void reset() { _Event = 0 ; }\n    int  fired() { return _Event; }\n    void park () ;\n    void unpark () ;\n    int  TryPark () ;\n    int  park (jlong millis) ; // relative timed-wait only\n    void SetAssociation (Thread * a) { _Assoc = a ; }\n} ;\n\nclass PlatformParker : public CHeapObj<mtInternal> {\n  protected:\n    enum {\n        REL_INDEX = 0,\n        ABS_INDEX = 1\n    };\n    int _cur_index;  // which cond is in use: -1, 0, 1\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [2] ; // one for relative times and one for abs.\n\n  public:       // TODO-FIXME: make dtor private\n    ~PlatformParker() { guarantee (0, \"invariant\") ; }\n\n  public:\n    PlatformParker() {\n      int status;\n      status = pthread_cond_init (&_cond[REL_INDEX], os::Linux::condAttr());\n      assert_status(status == 0, status, \"cond_init rel\");\n      status = pthread_cond_init (&_cond[ABS_INDEX], NULL);\n      assert_status(status == 0, status, \"cond_init abs\");\n      status = pthread_mutex_init (_mutex, NULL);\n      assert_status(status == 0, status, \"mutex_init\");\n      _cur_index = -1; // mark as unused\n    }\n};\n\n#endif // OS_LINUX_VM_OS_LINUX_HPP\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os/linux/vm/os_linux.cpp": "/*\n * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n// no precompiled headers\n#include \"classfile/classLoader.hpp\"\n#include \"classfile/systemDictionary.hpp\"\n#include \"classfile/vmSymbols.hpp\"\n#include \"code/icBuffer.hpp\"\n#include \"code/vtableStubs.hpp\"\n#include \"compiler/compileBroker.hpp\"\n#include \"compiler/disassembler.hpp\"\n#include \"interpreter/interpreter.hpp\"\n#include \"jvm_linux.h\"\n#include \"memory/allocation.inline.hpp\"\n#include \"memory/filemap.hpp\"\n#include \"mutex_linux.inline.hpp\"\n#include \"oops/oop.inline.hpp\"\n#include \"os_share_linux.hpp\"\n#include \"prims/jniFastGetField.hpp\"\n#include \"prims/jvm.h\"\n#include \"prims/jvm_misc.hpp\"\n#include \"runtime/arguments.hpp\"\n#include \"runtime/extendedPC.hpp\"\n#include \"runtime/globals.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/init.hpp\"\n#include \"runtime/java.hpp\"\n#include \"runtime/javaCalls.hpp\"\n#include \"runtime/mutexLocker.hpp\"\n#include \"runtime/objectMonitor.hpp\"\n#include \"runtime/orderAccess.inline.hpp\"\n#include \"runtime/osThread.hpp\"\n#include \"runtime/perfMemory.hpp\"\n#include \"runtime/sharedRuntime.hpp\"\n#include \"runtime/statSampler.hpp\"\n#include \"runtime/stubRoutines.hpp\"\n#include \"runtime/thread.inline.hpp\"\n#include \"runtime/threadCritical.hpp\"\n#include \"runtime/timer.hpp\"\n#include \"services/attachListener.hpp\"\n#include \"services/memTracker.hpp\"\n#include \"services/runtimeService.hpp\"\n#include \"utilities/decoder.hpp\"\n#include \"utilities/defaultStream.hpp\"\n#include \"utilities/events.hpp\"\n#include \"utilities/elfFile.hpp\"\n#include \"utilities/growableArray.hpp\"\n#include \"utilities/vmError.hpp\"\n\n// put OS-includes here\n# include <sys/types.h>\n# include <sys/mman.h>\n# include <sys/stat.h>\n# include <sys/select.h>\n# include <pthread.h>\n# include <signal.h>\n# include <errno.h>\n# include <dlfcn.h>\n# include <stdio.h>\n# include <unistd.h>\n# include <sys/resource.h>\n# include <pthread.h>\n# include <sys/stat.h>\n# include <sys/time.h>\n# include <sys/times.h>\n# include <sys/utsname.h>\n# include <sys/socket.h>\n# include <sys/wait.h>\n# include <pwd.h>\n# include <poll.h>\n# include <semaphore.h>\n# include <fcntl.h>\n# include <string.h>\n# include <syscall.h>\n# include <sys/sysinfo.h>\n# include <gnu/libc-version.h>\n# include <sys/ipc.h>\n# include <sys/shm.h>\n# include <link.h>\n# include <stdint.h>\n# include <inttypes.h>\n# include <sys/ioctl.h>\n\nPRAGMA_FORMAT_MUTE_WARNINGS_FOR_GCC\n\n// if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling\n// getrusage() is prepared to handle the associated failure.\n#ifndef RUSAGE_THREAD\n#define RUSAGE_THREAD   (1)               /* only the calling thread */\n#endif\n\n#define MAX_PATH    (2 * K)\n\n#define MAX_SECS 100000000\n\n// for timer info max values which include all bits\n#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n\n#define LARGEPAGES_BIT (1 << 6)\n////////////////////////////////////////////////////////////////////////////////\n// global variables\njulong os::Linux::_physical_memory = 0;\n\naddress   os::Linux::_initial_thread_stack_bottom = NULL;\nuintptr_t os::Linux::_initial_thread_stack_size   = 0;\n\nint (*os::Linux::_clock_gettime)(clockid_t, struct timespec *) = NULL;\nint (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;\nMutex* os::Linux::_createThread_lock = NULL;\npthread_t os::Linux::_main_thread;\nint os::Linux::_page_size = -1;\nconst int os::Linux::_vm_default_page_size = (8 * K);\nbool os::Linux::_is_floating_stack = false;\nbool os::Linux::_is_NPTL = false;\nbool os::Linux::_supports_fast_thread_cpu_time = false;\nconst char * os::Linux::_glibc_version = NULL;\nconst char * os::Linux::_libpthread_version = NULL;\npthread_condattr_t os::Linux::_condattr[1];\n\nstatic jlong initial_time_count=0;\n\nstatic int clock_tics_per_sec = 100;\n\n// For diagnostics to print a message once. see run_periodic_checks\nstatic sigset_t check_signal_done;\nstatic bool check_signals = true;\n\nstatic pid_t _initial_pid = 0;\n\n/* Signal number used to suspend/resume a thread */\n\n/* do not use any signal number less than SIGSEGV, see 4355769 */\nstatic int SR_signum = SIGUSR2;\nsigset_t SR_sigset;\n\n/* Used to protect dlsym() calls */\nstatic pthread_mutex_t dl_mutex;\n\n// Declarations\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time);\n\n// utility functions\n\nstatic int SR_initialize();\n\njulong os::available_memory() {\n  return Linux::available_memory();\n}\n\njulong os::Linux::available_memory() {\n  // values in struct sysinfo are \"unsigned long\"\n  struct sysinfo si;\n  sysinfo(&si);\n\n  return (julong)si.freeram * si.mem_unit;\n}\n\njulong os::physical_memory() {\n  return Linux::physical_memory();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// environment support\n\nbool os::getenv(const char* name, char* buf, int len) {\n  const char* val = ::getenv(name);\n  if (val != NULL && strlen(val) < (size_t)len) {\n    strcpy(buf, val);\n    return true;\n  }\n  if (len > 0) buf[0] = 0;  // return a null string\n  return false;\n}\n\n\n// Return true if user is running as root.\n\nbool os::have_special_privileges() {\n  static bool init = false;\n  static bool privileges = false;\n  if (!init) {\n    privileges = (getuid() != geteuid()) || (getgid() != getegid());\n    init = true;\n  }\n  return privileges;\n}\n\n\n#ifndef SYS_gettid\n// i386: 224, ia64: 1105, amd64: 186, sparc 143\n  #ifdef __ia64__\n    #define SYS_gettid 1105\n  #else\n    #ifdef __i386__\n      #define SYS_gettid 224\n    #else\n      #ifdef __amd64__\n        #define SYS_gettid 186\n      #else\n        #ifdef __sparc__\n          #define SYS_gettid 143\n        #else\n          #error define gettid for the arch\n        #endif\n      #endif\n    #endif\n  #endif\n#endif\n\n// Cpu architecture string\nstatic char cpu_arch[] = HOTSPOT_LIB_ARCH;\n\n// pid_t gettid()\n//\n// Returns the kernel thread id of the currently running thread. Kernel\n// thread id is used to access /proc.\n//\n// (Note that getpid() on LinuxThreads returns kernel thread id too; but\n// on NPTL, it returns the same pid for all threads, as required by POSIX.)\n//\npid_t os::Linux::gettid() {\n  int rslt = syscall(SYS_gettid);\n  if (rslt == -1) {\n     // old kernel, no NPTL support\n     return getpid();\n  } else {\n     return (pid_t)rslt;\n  }\n}\n\n// Most versions of linux have a bug where the number of processors are\n// determined by looking at the /proc file system.  In a chroot environment,\n// the system call returns 1.  This causes the VM to act as if it is\n// a single processor and elide locking (see is_MP() call).\nstatic bool unsafe_chroot_detected = false;\nstatic const char *unstable_chroot_error = \"/proc file system not found.\\n\"\n                     \"Java may be unstable running multithreaded in a chroot \"\n                     \"environment on Linux when /proc filesystem is not mounted.\";\n\nvoid os::Linux::initialize_system_info() {\n  set_processor_count(sysconf(_SC_NPROCESSORS_CONF));\n  if (processor_count() == 1) {\n    pid_t pid = os::Linux::gettid();\n    char fname[32];\n    jio_snprintf(fname, sizeof(fname), \"/proc/%d\", pid);\n    FILE *fp = fopen(fname, \"r\");\n    if (fp == NULL) {\n      unsafe_chroot_detected = true;\n    } else {\n      fclose(fp);\n    }\n  }\n  _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);\n  assert(processor_count() > 0, \"linux error\");\n}\n\nvoid os::init_system_properties_values() {\n  // The next steps are taken in the product version:\n  //\n  // Obtain the JAVA_HOME value from the location of libjvm.so.\n  // This library should be located at:\n  // <JAVA_HOME>/jre/lib/<arch>/{client|server}/libjvm.so.\n  //\n  // If \"/jre/lib/\" appears at the right place in the path, then we\n  // assume libjvm.so is installed in a JDK and we use this path.\n  //\n  // Otherwise exit with message: \"Could not create the Java virtual machine.\"\n  //\n  // The following extra steps are taken in the debugging version:\n  //\n  // If \"/jre/lib/\" does NOT appear at the right place in the path\n  // instead of exit check for $JAVA_HOME environment variable.\n  //\n  // If it is defined and we are able to locate $JAVA_HOME/jre/lib/<arch>,\n  // then we append a fake suffix \"hotspot/libjvm.so\" to this path so\n  // it looks like libjvm.so is installed there\n  // <JAVA_HOME>/jre/lib/<arch>/hotspot/libjvm.so.\n  //\n  // Otherwise exit.\n  //\n  // Important note: if the location of libjvm.so changes this\n  // code needs to be changed accordingly.\n\n// See ld(1):\n//      The linker uses the following search paths to locate required\n//      shared libraries:\n//        1: ...\n//        ...\n//        7: The default directories, normally /lib and /usr/lib.\n#if defined(AMD64) || defined(_LP64) && (defined(SPARC) || defined(PPC) || defined(S390)) || defined(BUILTIN_SIM)\n#define DEFAULT_LIBPATH \"/usr/lib64:/lib64:/lib:/usr/lib\"\n#else\n#define DEFAULT_LIBPATH \"/lib:/usr/lib\"\n#endif\n\n// Base path of extensions installed on the system.\n#define SYS_EXT_DIR     \"/usr/java/packages\"\n#define EXTENSIONS_DIR  \"/lib/ext\"\n#define ENDORSED_DIR    \"/lib/endorsed\"\n\n  // Buffer that fits several sprintfs.\n  // Note that the space for the colon and the trailing null are provided\n  // by the nulls included by the sizeof operator.\n  const size_t bufsize =\n    MAX3((size_t)MAXPATHLEN,  // For dll_dir & friends.\n         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR), // extensions dir\n         (size_t)MAXPATHLEN + sizeof(ENDORSED_DIR)); // endorsed dir\n  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n\n  // sysclasspath, java_home, dll_dir\n  {\n    char *pslash;\n    os::jvm_path(buf, bufsize);\n\n    // Found the full path to libjvm.so.\n    // Now cut the path to <java_home>/jre if we can.\n    *(strrchr(buf, '/')) = '\\0'; // Get rid of /libjvm.so.\n    pslash = strrchr(buf, '/');\n    if (pslash != NULL) {\n      *pslash = '\\0';            // Get rid of /{client|server|hotspot}.\n    }\n    Arguments::set_dll_dir(buf);\n\n    if (pslash != NULL) {\n      pslash = strrchr(buf, '/');\n      if (pslash != NULL) {\n        *pslash = '\\0';          // Get rid of /<arch>.\n        pslash = strrchr(buf, '/');\n        if (pslash != NULL) {\n          *pslash = '\\0';        // Get rid of /lib.\n        }\n      }\n    }\n    Arguments::set_java_home(buf);\n    set_boot_path('/', ':');\n  }\n\n  // Where to look for native libraries.\n  //\n  // Note: Due to a legacy implementation, most of the library path\n  // is set in the launcher. This was to accomodate linking restrictions\n  // on legacy Linux implementations (which are no longer supported).\n  // Eventually, all the library path setting will be done here.\n  //\n  // However, to prevent the proliferation of improperly built native\n  // libraries, the new path component /usr/java/packages is added here.\n  // Eventually, all the library path setting will be done here.\n  {\n    // Get the user setting of LD_LIBRARY_PATH, and prepended it. It\n    // should always exist (until the legacy problem cited above is\n    // addressed).\n    const char *v = ::getenv(\"LD_LIBRARY_PATH\");\n    const char *v_colon = \":\";\n    if (v == NULL) { v = \"\"; v_colon = \"\"; }\n    // That's +1 for the colon and +1 for the trailing '\\0'.\n    char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,\n                                                     strlen(v) + 1 +\n                                                     sizeof(SYS_EXT_DIR) + sizeof(\"/lib/\") + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,\n                                                     mtInternal);\n    sprintf(ld_library_path, \"%s%s\" SYS_EXT_DIR \"/lib/%s:\" DEFAULT_LIBPATH, v, v_colon, cpu_arch);\n    Arguments::set_library_path(ld_library_path);\n    FREE_C_HEAP_ARRAY(char, ld_library_path, mtInternal);\n  }\n\n  // Extensions directories.\n  sprintf(buf, \"%s\" EXTENSIONS_DIR \":\" SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());\n  Arguments::set_ext_dirs(buf);\n\n  // Endorsed standards default directory.\n  sprintf(buf, \"%s\" ENDORSED_DIR, Arguments::get_java_home());\n  Arguments::set_endorsed_dirs(buf);\n\n  FREE_C_HEAP_ARRAY(char, buf, mtInternal);\n\n#undef DEFAULT_LIBPATH\n#undef SYS_EXT_DIR\n#undef EXTENSIONS_DIR\n#undef ENDORSED_DIR\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// breakpoint support\n\nvoid os::breakpoint() {\n  BREAKPOINT;\n}\n\nextern \"C\" void breakpoint() {\n  // use debugger to set breakpoint here\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// signal support\n\ndebug_only(static bool signal_sets_initialized = false);\nstatic sigset_t unblocked_sigs, vm_sigs, allowdebug_blocked_sigs;\n\nbool os::Linux::is_sig_ignored(int sig) {\n      struct sigaction oact;\n      sigaction(sig, (struct sigaction*)NULL, &oact);\n      void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oact.sa_sigaction)\n                                     : CAST_FROM_FN_PTR(void*,  oact.sa_handler);\n      if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN))\n           return true;\n      else\n           return false;\n}\n\nvoid os::Linux::signal_sets_init() {\n  // Should also have an assertion stating we are still single-threaded.\n  assert(!signal_sets_initialized, \"Already initialized\");\n  // Fill in signals that are necessarily unblocked for all threads in\n  // the VM. Currently, we unblock the following signals:\n  // SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n  //                         by -Xrs (=ReduceSignalUsage));\n  // BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n  // other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n  // the dispositions or masks wrt these signals.\n  // Programs embedding the VM that want to use the above signals for their\n  // own purposes must, at this time, use the \"-Xrs\" option to prevent\n  // interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n  // (See bug 4345157, and other related bugs).\n  // In reality, though, unblocking these signals is really a nop, since\n  // these signals are not blocked by default.\n  sigemptyset(&unblocked_sigs);\n  sigemptyset(&allowdebug_blocked_sigs);\n  sigaddset(&unblocked_sigs, SIGILL);\n  sigaddset(&unblocked_sigs, SIGSEGV);\n  sigaddset(&unblocked_sigs, SIGBUS);\n  sigaddset(&unblocked_sigs, SIGFPE);\n#if defined(PPC64)\n  sigaddset(&unblocked_sigs, SIGTRAP);\n#endif\n  sigaddset(&unblocked_sigs, SR_signum);\n\n  if (!ReduceSignalUsage) {\n   if (!os::Linux::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN1_SIGNAL);\n   }\n   if (!os::Linux::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN2_SIGNAL);\n   }\n   if (!os::Linux::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN3_SIGNAL);\n   }\n  }\n  // Fill in signals that are blocked by all but the VM thread.\n  sigemptyset(&vm_sigs);\n  if (!ReduceSignalUsage)\n    sigaddset(&vm_sigs, BREAK_SIGNAL);\n  debug_only(signal_sets_initialized = true);\n\n}\n\n// These are signals that are unblocked while a thread is running Java.\n// (For some reason, they get blocked by default.)\nsigset_t* os::Linux::unblocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &unblocked_sigs;\n}\n\n// These are the signals that are blocked while a (non-VM) thread is\n// running Java. Only the VM thread handles these signals.\nsigset_t* os::Linux::vm_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &vm_sigs;\n}\n\n// These are signals that are blocked during cond_wait to allow debugger in\nsigset_t* os::Linux::allowdebug_blocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &allowdebug_blocked_sigs;\n}\n\nvoid os::Linux::hotspot_sigmask(Thread* thread) {\n\n  //Save caller's signal mask before setting VM signal mask\n  sigset_t caller_sigmask;\n  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n\n  OSThread* osthread = thread->osthread();\n  osthread->set_caller_sigmask(caller_sigmask);\n\n  pthread_sigmask(SIG_UNBLOCK, os::Linux::unblocked_signals(), NULL);\n\n  if (!ReduceSignalUsage) {\n    if (thread->is_VM_thread()) {\n      // Only the VM thread handles BREAK_SIGNAL ...\n      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n    } else {\n      // ... all other threads block BREAK_SIGNAL\n      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n    }\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// detecting pthread library\n\nvoid os::Linux::libpthread_init() {\n  // Save glibc and pthread version strings. Note that _CS_GNU_LIBC_VERSION\n  // and _CS_GNU_LIBPTHREAD_VERSION are supported in glibc >= 2.3.2. Use a\n  // generic name for earlier versions.\n  // Define macros here so we can build HotSpot on old systems.\n# ifndef _CS_GNU_LIBC_VERSION\n# define _CS_GNU_LIBC_VERSION 2\n# endif\n# ifndef _CS_GNU_LIBPTHREAD_VERSION\n# define _CS_GNU_LIBPTHREAD_VERSION 3\n# endif\n\n  size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);\n  if (n > 0) {\n     char *str = (char *)malloc(n, mtInternal);\n     confstr(_CS_GNU_LIBC_VERSION, str, n);\n     os::Linux::set_glibc_version(str);\n  } else {\n     // _CS_GNU_LIBC_VERSION is not supported, try gnu_get_libc_version()\n     static char _gnu_libc_version[32];\n     jio_snprintf(_gnu_libc_version, sizeof(_gnu_libc_version),\n              \"glibc %s %s\", gnu_get_libc_version(), gnu_get_libc_release());\n     os::Linux::set_glibc_version(_gnu_libc_version);\n  }\n\n  n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);\n  if (n > 0) {\n     char *str = (char *)malloc(n, mtInternal);\n     confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);\n     // Vanilla RH-9 (glibc 2.3.2) has a bug that confstr() always tells\n     // us \"NPTL-0.29\" even we are running with LinuxThreads. Check if this\n     // is the case. LinuxThreads has a hard limit on max number of threads.\n     // So sysconf(_SC_THREAD_THREADS_MAX) will return a positive value.\n     // On the other hand, NPTL does not have such a limit, sysconf()\n     // will return -1 and errno is not changed. Check if it is really NPTL.\n     if (strcmp(os::Linux::glibc_version(), \"glibc 2.3.2\") == 0 &&\n         strstr(str, \"NPTL\") &&\n         sysconf(_SC_THREAD_THREADS_MAX) > 0) {\n       free(str);\n       os::Linux::set_libpthread_version(\"linuxthreads\");\n     } else {\n       os::Linux::set_libpthread_version(str);\n     }\n  } else {\n    // glibc before 2.3.2 only has LinuxThreads.\n    os::Linux::set_libpthread_version(\"linuxthreads\");\n  }\n\n  if (strstr(libpthread_version(), \"NPTL\")) {\n     os::Linux::set_is_NPTL();\n  } else {\n     os::Linux::set_is_LinuxThreads();\n  }\n\n  // LinuxThreads have two flavors: floating-stack mode, which allows variable\n  // stack size; and fixed-stack mode. NPTL is always floating-stack.\n  if (os::Linux::is_NPTL() || os::Linux::supports_variable_stack_size()) {\n     os::Linux::set_is_floating_stack();\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// thread stack\n\n// Force Linux kernel to expand current thread stack. If \"bottom\" is close\n// to the stack guard, caller should block all signals.\n//\n// MAP_GROWSDOWN:\n//   A special mmap() flag that is used to implement thread stacks. It tells\n//   kernel that the memory region should extend downwards when needed. This\n//   allows early versions of LinuxThreads to only mmap the first few pages\n//   when creating a new thread. Linux kernel will automatically expand thread\n//   stack as needed (on page faults).\n//\n//   However, because the memory region of a MAP_GROWSDOWN stack can grow on\n//   demand, if a page fault happens outside an already mapped MAP_GROWSDOWN\n//   region, it's hard to tell if the fault is due to a legitimate stack\n//   access or because of reading/writing non-exist memory (e.g. buffer\n//   overrun). As a rule, if the fault happens below current stack pointer,\n//   Linux kernel does not expand stack, instead a SIGSEGV is sent to the\n//   application (see Linux kernel fault.c).\n//\n//   This Linux feature can cause SIGSEGV when VM bangs thread stack for\n//   stack overflow detection.\n//\n//   Newer version of LinuxThreads (since glibc-2.2, or, RH-7.x) and NPTL do\n//   not use this flag. However, the stack of initial thread is not created\n//   by pthread, it is still MAP_GROWSDOWN. Also it's possible (though\n//   unlikely) that user code can create a thread with MAP_GROWSDOWN stack\n//   and then attach the thread to JVM.\n//\n// To get around the problem and allow stack banging on Linux, we need to\n// manually expand thread stack after receiving the SIGSEGV.\n//\n// There are two ways to expand thread stack to address \"bottom\", we used\n// both of them in JVM before 1.5:\n//   1. adjust stack pointer first so that it is below \"bottom\", and then\n//      touch \"bottom\"\n//   2. mmap() the page in question\n//\n// Now alternate signal stack is gone, it's harder to use 2. For instance,\n// if current sp is already near the lower end of page 101, and we need to\n// call mmap() to map page 100, it is possible that part of the mmap() frame\n// will be placed in page 100. When page 100 is mapped, it is zero-filled.\n// That will destroy the mmap() frame and cause VM to crash.\n//\n// The following code works by adjusting sp first, then accessing the \"bottom\"\n// page to force a page fault. Linux kernel will then automatically expand the\n// stack mapping.\n//\n// _expand_stack_to() assumes its frame size is less than page size, which\n// should always be true if the function is not inlined.\n\n#if __GNUC__ < 3    // gcc 2.x does not support noinline attribute\n#define NOINLINE\n#else\n#define NOINLINE __attribute__ ((noinline))\n#endif\n\nstatic void _expand_stack_to(address bottom) NOINLINE;\n\nstatic void _expand_stack_to(address bottom) {\n  address sp;\n  size_t size;\n  volatile char *p;\n\n  // Adjust bottom to point to the largest address within the same page, it\n  // gives us a one-page buffer if alloca() allocates slightly more memory.\n  bottom = (address)align_size_down((uintptr_t)bottom, os::Linux::page_size());\n  bottom += os::Linux::page_size() - 1;\n\n  // sp might be slightly above current stack pointer; if that's the case, we\n  // will alloca() a little more space than necessary, which is OK. Don't use\n  // os::current_stack_pointer(), as its result can be slightly below current\n  // stack pointer, causing us to not alloca enough to reach \"bottom\".\n  sp = (address)&sp;\n\n  if (sp > bottom) {\n    size = sp - bottom;\n    p = (volatile char *)alloca(size);\n    assert(p != NULL && p <= (volatile char *)bottom, \"alloca problem?\");\n    p[0] = '\\0';\n  }\n}\n\nbool os::Linux::manually_expand_stack(JavaThread * t, address addr) {\n  assert(t!=NULL, \"just checking\");\n  assert(t->osthread()->expanding_stack(), \"expand should be set\");\n  assert(t->stack_base() != NULL, \"stack_base was not initialized\");\n\n  if (addr <  t->stack_base() && addr >= t->stack_yellow_zone_base()) {\n    sigset_t mask_all, old_sigset;\n    sigfillset(&mask_all);\n    pthread_sigmask(SIG_SETMASK, &mask_all, &old_sigset);\n    _expand_stack_to(addr);\n    pthread_sigmask(SIG_SETMASK, &old_sigset, NULL);\n    return true;\n  }\n  return false;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// create new thread\n\nstatic address highest_vm_reserved_address();\n\n// check if it's safe to start a new thread\nstatic bool _thread_safety_check(Thread* thread) {\n  if (os::Linux::is_LinuxThreads() && !os::Linux::is_floating_stack()) {\n    // Fixed stack LinuxThreads (SuSE Linux/x86, and some versions of Redhat)\n    //   Heap is mmap'ed at lower end of memory space. Thread stacks are\n    //   allocated (MAP_FIXED) from high address space. Every thread stack\n    //   occupies a fixed size slot (usually 2Mbytes, but user can change\n    //   it to other values if they rebuild LinuxThreads).\n    //\n    // Problem with MAP_FIXED is that mmap() can still succeed even part of\n    // the memory region has already been mmap'ed. That means if we have too\n    // many threads and/or very large heap, eventually thread stack will\n    // collide with heap.\n    //\n    // Here we try to prevent heap/stack collision by comparing current\n    // stack bottom with the highest address that has been mmap'ed by JVM\n    // plus a safety margin for memory maps created by native code.\n    //\n    // This feature can be disabled by setting ThreadSafetyMargin to 0\n    //\n    if (ThreadSafetyMargin > 0) {\n      address stack_bottom = os::current_stack_base() - os::current_stack_size();\n\n      // not safe if our stack extends below the safety margin\n      return stack_bottom - ThreadSafetyMargin >= highest_vm_reserved_address();\n    } else {\n      return true;\n    }\n  } else {\n    // Floating stack LinuxThreads or NPTL:\n    //   Unlike fixed stack LinuxThreads, thread stacks are not MAP_FIXED. When\n    //   there's not enough space left, pthread_create() will fail. If we come\n    //   here, that means enough space has been reserved for stack.\n    return true;\n  }\n}\n\n// Thread start routine for all newly created threads\nstatic void *java_start(Thread *thread) {\n  // Try to randomize the cache line index of hot stack frames.\n  // This helps when threads of the same stack traces evict each other's\n  // cache lines. The threads can be either from the same JVM instance, or\n  // from different JVM instances. The benefit is especially true for\n  // processors with hyperthreading technology.\n  static int counter = 0;\n  int pid = os::current_process_id();\n  alloca(((pid ^ counter++) & 7) * 128);\n\n  ThreadLocalStorage::set_thread(thread);\n\n  OSThread* osthread = thread->osthread();\n  Monitor* sync = osthread->startThread_lock();\n\n  // non floating stack LinuxThreads needs extra check, see above\n  if (!_thread_safety_check(thread)) {\n    // notify parent thread\n    MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);\n    osthread->set_state(ZOMBIE);\n    sync->notify_all();\n    return NULL;\n  }\n\n  // thread_id is kernel thread id (similar to Solaris LWP id)\n  osthread->set_thread_id(os::Linux::gettid());\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n  // initialize signal mask for this thread\n  os::Linux::hotspot_sigmask(thread);\n\n  // initialize floating point control register\n  os::Linux::init_thread_fpu_state();\n\n  // handshaking with parent thread\n  {\n    MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);\n\n    // notify parent thread\n    osthread->set_state(INITIALIZED);\n    sync->notify_all();\n\n    // wait until os::start_thread()\n    while (osthread->get_state() == INITIALIZED) {\n      sync->wait(Mutex::_no_safepoint_check_flag);\n    }\n  }\n\n  // call one more level start routine\n  thread->run();\n\n  return 0;\n}\n\nbool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) {\n  assert(thread->osthread() == NULL, \"caller responsible\");\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // set the correct thread state\n  osthread->set_thread_type(thr_type);\n\n  // Initial state is ALLOCATED but not INITIALIZED\n  osthread->set_state(ALLOCATED);\n\n  thread->set_osthread(osthread);\n\n  // init thread attributes\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n  // stack size\n  if (os::Linux::supports_variable_stack_size()) {\n    // calculate stack size if it's not specified by caller\n    if (stack_size == 0) {\n      stack_size = os::Linux::default_stack_size(thr_type);\n\n      switch (thr_type) {\n      case os::java_thread:\n        // Java threads use ThreadStackSize which default value can be\n        // changed with the flag -Xss\n        assert (JavaThread::stack_size_at_create() > 0, \"this should be set\");\n        stack_size = JavaThread::stack_size_at_create();\n        break;\n      case os::compiler_thread:\n        if (CompilerThreadStackSize > 0) {\n          stack_size = (size_t)(CompilerThreadStackSize * K);\n          break;\n        } // else fall through:\n          // use VMThreadStackSize if CompilerThreadStackSize is not defined\n      case os::vm_thread:\n      case os::pgc_thread:\n      case os::cgc_thread:\n      case os::watcher_thread:\n        if (VMThreadStackSize > 0) stack_size = (size_t)(VMThreadStackSize * K);\n        break;\n      }\n    }\n\n    stack_size = MAX2(stack_size, os::Linux::min_stack_allowed);\n    pthread_attr_setstacksize(&attr, stack_size);\n  } else {\n    // let pthread_create() pick the default value.\n  }\n\n  // glibc guard page\n  pthread_attr_setguardsize(&attr, os::Linux::default_guard_size(thr_type));\n\n  ThreadState state;\n\n  {\n    // Serialize thread creation if we are running with fixed stack LinuxThreads\n    bool lock = os::Linux::is_LinuxThreads() && !os::Linux::is_floating_stack();\n    if (lock) {\n      os::Linux::createThread_lock()->lock_without_safepoint_check();\n    }\n\n    pthread_t tid;\n    int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);\n\n    pthread_attr_destroy(&attr);\n\n    if (ret != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode)) {\n        perror(\"pthread_create()\");\n      }\n      // Need to clean up stuff we've allocated so far\n      thread->set_osthread(NULL);\n      delete osthread;\n      if (lock) os::Linux::createThread_lock()->unlock();\n      return false;\n    }\n\n    // Store pthread info into the OSThread\n    osthread->set_pthread_id(tid);\n\n    // Wait until child thread is either initialized or aborted\n    {\n      Monitor* sync_with_child = osthread->startThread_lock();\n      MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);\n      while ((state = osthread->get_state()) == ALLOCATED) {\n        sync_with_child->wait(Mutex::_no_safepoint_check_flag);\n      }\n    }\n\n    if (lock) {\n      os::Linux::createThread_lock()->unlock();\n    }\n  }\n\n  // Aborted due to thread limit being reached\n  if (state == ZOMBIE) {\n      thread->set_osthread(NULL);\n      delete osthread;\n      return false;\n  }\n\n  // The thread is returned suspended (in state INITIALIZED),\n  // and is started higher up in the call chain\n  assert(state == INITIALIZED, \"race condition\");\n  return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// attach existing thread\n\n// bootstrap the main thread\nbool os::create_main_thread(JavaThread* thread) {\n  assert(os::Linux::_main_thread == pthread_self(), \"should be called inside main thread\");\n  return create_attached_thread(thread);\n}\n\nbool os::create_attached_thread(JavaThread* thread) {\n#ifdef ASSERT\n    thread->verify_not_published();\n#endif\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // Store pthread info into the OSThread\n  osthread->set_thread_id(os::Linux::gettid());\n  osthread->set_pthread_id(::pthread_self());\n\n  // initialize floating point control register\n  os::Linux::init_thread_fpu_state();\n\n  // Initial thread state is RUNNABLE\n  osthread->set_state(RUNNABLE);\n\n  thread->set_osthread(osthread);\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n\n  if (os::Linux::is_initial_thread()) {\n    // If current thread is initial thread, its stack is mapped on demand,\n    // see notes about MAP_GROWSDOWN. Here we try to force kernel to map\n    // the entire stack region to avoid SEGV in stack banging.\n    // It is also useful to get around the heap-stack-gap problem on SuSE\n    // kernel (see 4821821 for details). We first expand stack to the top\n    // of yellow zone, then enable stack yellow zone (order is significant,\n    // enabling yellow zone first will crash JVM on SuSE Linux), so there\n    // is no gap between the last two virtual memory regions.\n\n    JavaThread *jt = (JavaThread *)thread;\n    address addr = jt->stack_yellow_zone_base();\n    assert(addr != NULL, \"initialization problem?\");\n    assert(jt->stack_available(addr) > 0, \"stack guard should not be enabled\");\n\n    osthread->set_expanding_stack();\n    os::Linux::manually_expand_stack(jt, addr);\n    osthread->clear_expanding_stack();\n  }\n\n  // initialize signal mask for this thread\n  // and save the caller's signal mask\n  os::Linux::hotspot_sigmask(thread);\n\n  return true;\n}\n\nvoid os::pd_start_thread(Thread* thread) {\n  OSThread * osthread = thread->osthread();\n  assert(osthread->get_state() != INITIALIZED, \"just checking\");\n  Monitor* sync_with_child = osthread->startThread_lock();\n  MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);\n  sync_with_child->notify();\n}\n\n// Free Linux resources related to the OSThread\nvoid os::free_thread(OSThread* osthread) {\n  assert(osthread != NULL, \"osthread not set\");\n\n  if (Thread::current()->osthread() == osthread) {\n    // Restore caller's signal mask\n    sigset_t sigmask = osthread->caller_sigmask();\n    pthread_sigmask(SIG_SETMASK, &sigmask, NULL);\n   }\n\n  delete osthread;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// thread local storage\n\n// Restore the thread pointer if the destructor is called. This is in case\n// someone from JNI code sets up a destructor with pthread_key_create to run\n// detachCurrentThread on thread death. Unless we restore the thread pointer we\n// will hang or crash. When detachCurrentThread is called the key will be set\n// to null and we will not be called again. If detachCurrentThread is never\n// called we could loop forever depending on the pthread implementation.\nstatic void restore_thread_pointer(void* p) {\n  Thread* thread = (Thread*) p;\n  os::thread_local_storage_at_put(ThreadLocalStorage::thread_index(), thread);\n}\n\nint os::allocate_thread_local_storage() {\n  pthread_key_t key;\n  int rslt = pthread_key_create(&key, restore_thread_pointer);\n  assert(rslt == 0, \"cannot allocate thread local storage\");\n  return (int)key;\n}\n\n// Note: This is currently not used by VM, as we don't destroy TLS key\n// on VM exit.\nvoid os::free_thread_local_storage(int index) {\n  int rslt = pthread_key_delete((pthread_key_t)index);\n  assert(rslt == 0, \"invalid index\");\n}\n\nvoid os::thread_local_storage_at_put(int index, void* value) {\n  int rslt = pthread_setspecific((pthread_key_t)index, value);\n  assert(rslt == 0, \"pthread_setspecific failed\");\n}\n\nextern \"C\" Thread* get_thread() {\n  return ThreadLocalStorage::thread();\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// initial thread\n\n// Check if current thread is the initial thread, similar to Solaris thr_main.\nbool os::Linux::is_initial_thread(void) {\n  char dummy;\n  // If called before init complete, thread stack bottom will be null.\n  // Can be called if fatal error occurs before initialization.\n  if (initial_thread_stack_bottom() == NULL) return false;\n  assert(initial_thread_stack_bottom() != NULL &&\n         initial_thread_stack_size()   != 0,\n         \"os::init did not locate initial thread's stack region\");\n  if ((address)&dummy >= initial_thread_stack_bottom() &&\n      (address)&dummy < initial_thread_stack_bottom() + initial_thread_stack_size())\n       return true;\n  else return false;\n}\n\n// Find the virtual memory area that contains addr\nstatic bool find_vma(address addr, address* vma_low, address* vma_high) {\n  FILE *fp = fopen(\"/proc/self/maps\", \"r\");\n  if (fp) {\n    address low, high;\n    while (!feof(fp)) {\n      if (fscanf(fp, \"%p-%p\", &low, &high) == 2) {\n        if (low <= addr && addr < high) {\n           if (vma_low)  *vma_low  = low;\n           if (vma_high) *vma_high = high;\n           fclose (fp);\n           return true;\n        }\n      }\n      for (;;) {\n        int ch = fgetc(fp);\n        if (ch == EOF || ch == (int)'\\n') break;\n      }\n    }\n    fclose(fp);\n  }\n  return false;\n}\n\n// Locate initial thread stack. This special handling of initial thread stack\n// is needed because pthread_getattr_np() on most (all?) Linux distros returns\n// bogus value for the primordial process thread. While the launcher has created\n// the VM in a new thread since JDK 6, we still have to allow for the use of the\n// JNI invocation API from a primordial thread.\nvoid os::Linux::capture_initial_stack(size_t max_size) {\n\n  // max_size is either 0 (which means accept OS default for thread stacks) or\n  // a user-specified value known to be at least the minimum needed. If we\n  // are actually on the primordial thread we can make it appear that we have a\n  // smaller max_size stack by inserting the guard pages at that location. But we\n  // cannot do anything to emulate a larger stack than what has been provided by\n  // the OS or threading library. In fact if we try to use a stack greater than\n  // what is set by rlimit then we will crash the hosting process.\n\n  // Maximum stack size is the easy part, get it from RLIMIT_STACK.\n  // If this is \"unlimited\" then it will be a huge value.\n  struct rlimit rlim;\n  getrlimit(RLIMIT_STACK, &rlim);\n  size_t stack_size = rlim.rlim_cur;\n\n  // 6308388: a bug in ld.so will relocate its own .data section to the\n  //   lower end of primordial stack; reduce ulimit -s value a little bit\n  //   so we won't install guard page on ld.so's data section.\n  stack_size -= 2 * page_size();\n\n  // Try to figure out where the stack base (top) is. This is harder.\n  //\n  // When an application is started, glibc saves the initial stack pointer in\n  // a global variable \"__libc_stack_end\", which is then used by system\n  // libraries. __libc_stack_end should be pretty close to stack top. The\n  // variable is available since the very early days. However, because it is\n  // a private interface, it could disappear in the future.\n  //\n  // Linux kernel saves start_stack information in /proc/<pid>/stat. Similar\n  // to __libc_stack_end, it is very close to stack top, but isn't the real\n  // stack top. Note that /proc may not exist if VM is running as a chroot\n  // program, so reading /proc/<pid>/stat could fail. Also the contents of\n  // /proc/<pid>/stat could change in the future (though unlikely).\n  //\n  // We try __libc_stack_end first. If that doesn't work, look for\n  // /proc/<pid>/stat. If neither of them works, we use current stack pointer\n  // as a hint, which should work well in most cases.\n\n  uintptr_t stack_start;\n\n  // try __libc_stack_end first\n  uintptr_t *p = (uintptr_t *)dlsym(RTLD_DEFAULT, \"__libc_stack_end\");\n  if (p && *p) {\n    stack_start = *p;\n  } else {\n    // see if we can get the start_stack field from /proc/self/stat\n    FILE *fp;\n    int pid;\n    char state;\n    int ppid;\n    int pgrp;\n    int session;\n    int nr;\n    int tpgrp;\n    unsigned long flags;\n    unsigned long minflt;\n    unsigned long cminflt;\n    unsigned long majflt;\n    unsigned long cmajflt;\n    unsigned long utime;\n    unsigned long stime;\n    long cutime;\n    long cstime;\n    long prio;\n    long nice;\n    long junk;\n    long it_real;\n    uintptr_t start;\n    uintptr_t vsize;\n    intptr_t rss;\n    uintptr_t rsslim;\n    uintptr_t scodes;\n    uintptr_t ecode;\n    int i;\n\n    // Figure what the primordial thread stack base is. Code is inspired\n    // by email from Hans Boehm. /proc/self/stat begins with current pid,\n    // followed by command name surrounded by parentheses, state, etc.\n    char stat[2048];\n    int statlen;\n\n    fp = fopen(\"/proc/self/stat\", \"r\");\n    if (fp) {\n      statlen = fread(stat, 1, 2047, fp);\n      stat[statlen] = '\\0';\n      fclose(fp);\n\n      // Skip pid and the command string. Note that we could be dealing with\n      // weird command names, e.g. user could decide to rename java launcher\n      // to \"java 1.4.2 :)\", then the stat file would look like\n      //                1234 (java 1.4.2 :)) R ... ...\n      // We don't really need to know the command string, just find the last\n      // occurrence of \")\" and then start parsing from there. See bug 4726580.\n      char * s = strrchr(stat, ')');\n\n      i = 0;\n      if (s) {\n        // Skip blank chars\n        do s++; while (isspace(*s));\n\n#define _UFM UINTX_FORMAT\n#define _DFM INTX_FORMAT\n\n        /*                                     1   1   1   1   1   1   1   1   1   1   2   2    2    2    2    2    2    2    2 */\n        /*              3  4  5  6  7  8   9   0   1   2   3   4   5   6   7   8   9   0   1    2    3    4    5    6    7    8 */\n        i = sscanf(s, \"%c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld \" _UFM _UFM _DFM _UFM _UFM _UFM _UFM,\n             &state,          /* 3  %c  */\n             &ppid,           /* 4  %d  */\n             &pgrp,           /* 5  %d  */\n             &session,        /* 6  %d  */\n             &nr,             /* 7  %d  */\n             &tpgrp,          /* 8  %d  */\n             &flags,          /* 9  %lu  */\n             &minflt,         /* 10 %lu  */\n             &cminflt,        /* 11 %lu  */\n             &majflt,         /* 12 %lu  */\n             &cmajflt,        /* 13 %lu  */\n             &utime,          /* 14 %lu  */\n             &stime,          /* 15 %lu  */\n             &cutime,         /* 16 %ld  */\n             &cstime,         /* 17 %ld  */\n             &prio,           /* 18 %ld  */\n             &nice,           /* 19 %ld  */\n             &junk,           /* 20 %ld  */\n             &it_real,        /* 21 %ld  */\n             &start,          /* 22 UINTX_FORMAT */\n             &vsize,          /* 23 UINTX_FORMAT */\n             &rss,            /* 24 INTX_FORMAT  */\n             &rsslim,         /* 25 UINTX_FORMAT */\n             &scodes,         /* 26 UINTX_FORMAT */\n             &ecode,          /* 27 UINTX_FORMAT */\n             &stack_start);   /* 28 UINTX_FORMAT */\n      }\n\n#undef _UFM\n#undef _DFM\n\n      if (i != 28 - 2) {\n         assert(false, \"Bad conversion from /proc/self/stat\");\n         // product mode - assume we are the initial thread, good luck in the\n         // embedded case.\n         warning(\"Can't detect initial thread stack location - bad conversion\");\n         stack_start = (uintptr_t) &rlim;\n      }\n    } else {\n      // For some reason we can't open /proc/self/stat (for example, running on\n      // FreeBSD with a Linux emulator, or inside chroot), this should work for\n      // most cases, so don't abort:\n      warning(\"Can't detect initial thread stack location - no /proc/self/stat\");\n      stack_start = (uintptr_t) &rlim;\n    }\n  }\n\n  // Now we have a pointer (stack_start) very close to the stack top, the\n  // next thing to do is to figure out the exact location of stack top. We\n  // can find out the virtual memory area that contains stack_start by\n  // reading /proc/self/maps, it should be the last vma in /proc/self/maps,\n  // and its upper limit is the real stack top. (again, this would fail if\n  // running inside chroot, because /proc may not exist.)\n\n  uintptr_t stack_top;\n  address low, high;\n  if (find_vma((address)stack_start, &low, &high)) {\n    // success, \"high\" is the true stack top. (ignore \"low\", because initial\n    // thread stack grows on demand, its real bottom is high - RLIMIT_STACK.)\n    stack_top = (uintptr_t)high;\n  } else {\n    // failed, likely because /proc/self/maps does not exist\n    warning(\"Can't detect initial thread stack location - find_vma failed\");\n    // best effort: stack_start is normally within a few pages below the real\n    // stack top, use it as stack top, and reduce stack size so we won't put\n    // guard page outside stack.\n    stack_top = stack_start;\n    stack_size -= 16 * page_size();\n  }\n\n  // stack_top could be partially down the page so align it\n  stack_top = align_size_up(stack_top, page_size());\n\n  // Allowed stack value is minimum of max_size and what we derived from rlimit\n  if (max_size > 0) {\n    _initial_thread_stack_size = MIN2(max_size, stack_size);\n  } else {\n    // Accept the rlimit max, but if stack is unlimited then it will be huge, so\n    // clamp it at 8MB as we do on Solaris\n    _initial_thread_stack_size = MIN2(stack_size, 8*M);\n  }\n\n  _initial_thread_stack_size = align_size_down(_initial_thread_stack_size, page_size());\n  _initial_thread_stack_bottom = (address)stack_top - _initial_thread_stack_size;\n  assert(_initial_thread_stack_bottom < (address)stack_top, \"overflow!\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// time support\n\n// Time since start-up in seconds to a fine granularity.\n// Used by VMSelfDestructTimer and the MemProfiler.\ndouble os::elapsedTime() {\n\n  return ((double)os::elapsed_counter()) / os::elapsed_frequency(); // nanosecond resolution\n}\n\njlong os::elapsed_counter() {\n  return javaTimeNanos() - initial_time_count;\n}\n\njlong os::elapsed_frequency() {\n  return NANOSECS_PER_SEC; // nanosecond resolution\n}\n\nbool os::supports_vtime() { return true; }\nbool os::enable_vtime()   { return false; }\nbool os::vtime_enabled()  { return false; }\n\ndouble os::elapsedVTime() {\n  struct rusage usage;\n  int retval = getrusage(RUSAGE_THREAD, &usage);\n  if (retval == 0) {\n    return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000 * 1000);\n  } else {\n    // better than nothing, but not much\n    return elapsedTime();\n  }\n}\n\njlong os::javaTimeMillis() {\n  timeval time;\n  int status = gettimeofday(&time, NULL);\n  assert(status != -1, \"linux error\");\n  return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);\n}\n\n#ifndef CLOCK_MONOTONIC\n#define CLOCK_MONOTONIC (1)\n#endif\n\nvoid os::Linux::clock_init() {\n  // we do dlopen's in this particular order due to bug in linux\n  // dynamical loader (see 6348968) leading to crash on exit\n  void* handle = dlopen(\"librt.so.1\", RTLD_LAZY);\n  if (handle == NULL) {\n    handle = dlopen(\"librt.so\", RTLD_LAZY);\n  }\n\n  if (handle) {\n    int (*clock_getres_func)(clockid_t, struct timespec*) =\n           (int(*)(clockid_t, struct timespec*))dlsym(handle, \"clock_getres\");\n    int (*clock_gettime_func)(clockid_t, struct timespec*) =\n           (int(*)(clockid_t, struct timespec*))dlsym(handle, \"clock_gettime\");\n    if (clock_getres_func && clock_gettime_func) {\n      // See if monotonic clock is supported by the kernel. Note that some\n      // early implementations simply return kernel jiffies (updated every\n      // 1/100 or 1/1000 second). It would be bad to use such a low res clock\n      // for nano time (though the monotonic property is still nice to have).\n      // It's fixed in newer kernels, however clock_getres() still returns\n      // 1/HZ. We check if clock_getres() works, but will ignore its reported\n      // resolution for now. Hopefully as people move to new kernels, this\n      // won't be a problem.\n      struct timespec res;\n      struct timespec tp;\n      if (clock_getres_func (CLOCK_MONOTONIC, &res) == 0 &&\n          clock_gettime_func(CLOCK_MONOTONIC, &tp)  == 0) {\n        // yes, monotonic clock is supported\n        _clock_gettime = clock_gettime_func;\n        return;\n      } else {\n        // close librt if there is no monotonic clock\n        dlclose(handle);\n      }\n    }\n  }\n  warning(\"No monotonic clock was available - timed services may \" \\\n          \"be adversely affected if the time-of-day clock changes\");\n}\n\n#ifndef SYS_clock_getres\n\n#if defined(IA32) || defined(AMD64) || defined(AARCH64)\n#ifdef BUILTIN_SIM\n#define SYS_clock_getres 229\n#else\n#define SYS_clock_getres IA32_ONLY(266)  AMD64_ONLY(229) AARCH64_ONLY(114)\n#endif\n#define sys_clock_getres(x,y)  ::syscall(SYS_clock_getres, x, y)\n#else\n#warning \"SYS_clock_getres not defined for this platform, disabling fast_thread_cpu_time\"\n#define sys_clock_getres(x,y)  -1\n#endif\n\n#else\n#define sys_clock_getres(x,y)  ::syscall(SYS_clock_getres, x, y)\n#endif\n\nvoid os::Linux::fast_thread_clock_init() {\n  if (!UseLinuxPosixThreadCPUClocks) {\n    return;\n  }\n  clockid_t clockid;\n  struct timespec tp;\n  int (*pthread_getcpuclockid_func)(pthread_t, clockid_t *) =\n      (int(*)(pthread_t, clockid_t *)) dlsym(RTLD_DEFAULT, \"pthread_getcpuclockid\");\n\n  // Switch to using fast clocks for thread cpu time if\n  // the sys_clock_getres() returns 0 error code.\n  // Note, that some kernels may support the current thread\n  // clock (CLOCK_THREAD_CPUTIME_ID) but not the clocks\n  // returned by the pthread_getcpuclockid().\n  // If the fast Posix clocks are supported then the sys_clock_getres()\n  // must return at least tp.tv_sec == 0 which means a resolution\n  // better than 1 sec. This is extra check for reliability.\n\n  if(pthread_getcpuclockid_func &&\n     pthread_getcpuclockid_func(_main_thread, &clockid) == 0 &&\n     sys_clock_getres(clockid, &tp) == 0 && tp.tv_sec == 0) {\n\n    _supports_fast_thread_cpu_time = true;\n    _pthread_getcpuclockid = pthread_getcpuclockid_func;\n  }\n}\n\njlong os::javaTimeNanos() {\n  if (Linux::supports_monotonic_clock()) {\n    struct timespec tp;\n    int status = Linux::clock_gettime(CLOCK_MONOTONIC, &tp);\n    assert(status == 0, \"gettime error\");\n    jlong result = jlong(tp.tv_sec) * (1000 * 1000 * 1000) + jlong(tp.tv_nsec);\n    return result;\n  } else {\n    timeval time;\n    int status = gettimeofday(&time, NULL);\n    assert(status != -1, \"linux error\");\n    jlong usecs = jlong(time.tv_sec) * (1000 * 1000) + jlong(time.tv_usec);\n    return 1000 * usecs;\n  }\n}\n\nvoid os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n  if (Linux::supports_monotonic_clock()) {\n    info_ptr->max_value = ALL_64_BITS;\n\n    // CLOCK_MONOTONIC - amount of time since some arbitrary point in the past\n    info_ptr->may_skip_backward = false;      // not subject to resetting or drifting\n    info_ptr->may_skip_forward = false;       // not subject to resetting or drifting\n  } else {\n    // gettimeofday - based on time in seconds since the Epoch thus does not wrap\n    info_ptr->max_value = ALL_64_BITS;\n\n    // gettimeofday is a real time clock so it skips\n    info_ptr->may_skip_backward = true;\n    info_ptr->may_skip_forward = true;\n  }\n\n  info_ptr->kind = JVMTI_TIMER_ELAPSED;                // elapsed not CPU time\n}\n\n// Return the real, user, and system times in seconds from an\n// arbitrary fixed point in the past.\nbool os::getTimesSecs(double* process_real_time,\n                      double* process_user_time,\n                      double* process_system_time) {\n  struct tms ticks;\n  clock_t real_ticks = times(&ticks);\n\n  if (real_ticks == (clock_t) (-1)) {\n    return false;\n  } else {\n    double ticks_per_second = (double) clock_tics_per_sec;\n    *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;\n    *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;\n    *process_real_time = ((double) real_ticks) / ticks_per_second;\n\n    return true;\n  }\n}\n\n\nchar * os::local_time_string(char *buf, size_t buflen) {\n  struct tm t;\n  time_t long_time;\n  time(&long_time);\n  localtime_r(&long_time, &t);\n  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n               t.tm_hour, t.tm_min, t.tm_sec);\n  return buf;\n}\n\nstruct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {\n  return localtime_r(clock, res);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// runtime exit support\n\n// Note: os::shutdown() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::shutdown(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::shutdown() {\n\n  // allow PerfMemory to attempt cleanup of any persistent resources\n  perfMemory_exit();\n\n  // needs to remove object in file system\n  AttachListener::abort();\n\n  // flush buffered output, finish log files\n  ostream_abort();\n\n  // Check for abort hook\n  abort_hook_t abort_hook = Arguments::abort_hook();\n  if (abort_hook != NULL) {\n    abort_hook();\n  }\n\n}\n\n// Note: os::abort() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::abort(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::abort(bool dump_core) {\n  os::shutdown();\n  if (dump_core) {\n#ifndef PRODUCT\n    fdStream out(defaultStream::output_fd());\n    out.print_raw(\"Current thread is \");\n    char buf[16];\n    jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());\n    out.print_raw_cr(buf);\n    out.print_raw_cr(\"Dumping core ...\");\n#endif\n    ::abort(); // dump core\n  }\n\n  ::exit(1);\n}\n\n// Die immediately, no exit hook, no abort hook, no cleanup.\nvoid os::die() {\n  // _exit() on LinuxThreads only kills current thread\n  ::abort();\n}\n\n\n// This method is a copy of JDK's sysGetLastErrorString\n// from src/solaris/hpi/src/system_md.c\n\nsize_t os::lasterror(char *buf, size_t len) {\n\n  if (errno == 0)  return 0;\n\n  const char *s = ::strerror(errno);\n  size_t n = ::strlen(s);\n  if (n >= len) {\n    n = len - 1;\n  }\n  ::strncpy(buf, s, n);\n  buf[n] = '\\0';\n  return n;\n}\n\nintx os::current_thread_id() { return (intx)pthread_self(); }\nint os::current_process_id() {\n\n  // Under the old linux thread library, linux gives each thread\n  // its own process id. Because of this each thread will return\n  // a different pid if this method were to return the result\n  // of getpid(2). Linux provides no api that returns the pid\n  // of the launcher thread for the vm. This implementation\n  // returns a unique pid, the pid of the launcher thread\n  // that starts the vm 'process'.\n\n  // Under the NPTL, getpid() returns the same pid as the\n  // launcher thread rather than a unique pid per thread.\n  // Use gettid() if you want the old pre NPTL behaviour.\n\n  // if you are looking for the result of a call to getpid() that\n  // returns a unique pid for the calling thread, then look at the\n  // OSThread::thread_id() method in osThread_linux.hpp file\n\n  return (int)(_initial_pid ? _initial_pid : getpid());\n}\n\n// DLL functions\n\nconst char* os::dll_file_extension() { return \".so\"; }\n\n// This must be hard coded because it's the system's temporary\n// directory not the java application's temp directory, ala java.io.tmpdir.\nconst char* os::get_temp_directory() { return \"/tmp\"; }\n\nstatic bool file_exists(const char* filename) {\n  struct stat statbuf;\n  if (filename == NULL || strlen(filename) == 0) {\n    return false;\n  }\n  return os::stat(filename, &statbuf) == 0;\n}\n\nbool os::dll_build_name(char* buffer, size_t buflen,\n                        const char* pname, const char* fname) {\n  bool retval = false;\n  // Copied from libhpi\n  const size_t pnamelen = pname ? strlen(pname) : 0;\n\n  // Return error on buffer overflow.\n  if (pnamelen + strlen(fname) + 10 > (size_t) buflen) {\n    return retval;\n  }\n\n  if (pnamelen == 0) {\n    snprintf(buffer, buflen, \"lib%s.so\", fname);\n    retval = true;\n  } else if (strchr(pname, *os::path_separator()) != NULL) {\n    int n;\n    char** pelements = split_path(pname, &n);\n    if (pelements == NULL) {\n      return false;\n    }\n    for (int i = 0 ; i < n ; i++) {\n      // Really shouldn't be NULL, but check can't hurt\n      if (pelements[i] == NULL || strlen(pelements[i]) == 0) {\n        continue; // skip the empty path values\n      }\n      snprintf(buffer, buflen, \"%s/lib%s.so\", pelements[i], fname);\n      if (file_exists(buffer)) {\n        retval = true;\n        break;\n      }\n    }\n    // release the storage\n    for (int i = 0 ; i < n ; i++) {\n      if (pelements[i] != NULL) {\n        FREE_C_HEAP_ARRAY(char, pelements[i], mtInternal);\n      }\n    }\n    if (pelements != NULL) {\n      FREE_C_HEAP_ARRAY(char*, pelements, mtInternal);\n    }\n  } else {\n    snprintf(buffer, buflen, \"%s/lib%s.so\", pname, fname);\n    retval = true;\n  }\n  return retval;\n}\n\n// check if addr is inside libjvm.so\nbool os::address_is_in_vm(address addr) {\n  static address libjvm_base_addr;\n  Dl_info dlinfo;\n\n  if (libjvm_base_addr == NULL) {\n    if (dladdr(CAST_FROM_FN_PTR(void *, os::address_is_in_vm), &dlinfo) != 0) {\n      libjvm_base_addr = (address)dlinfo.dli_fbase;\n    }\n    assert(libjvm_base_addr !=NULL, \"Cannot obtain base address for libjvm\");\n  }\n\n  if (dladdr((void *)addr, &dlinfo) != 0) {\n    if (libjvm_base_addr == (address)dlinfo.dli_fbase) return true;\n  }\n\n  return false;\n}\n\nbool os::dll_address_to_function_name(address addr, char *buf,\n                                      int buflen, int *offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n\n  if (dladdr((void*)addr, &dlinfo) != 0) {\n    // see if we have a matching symbol\n    if (dlinfo.dli_saddr != NULL && dlinfo.dli_sname != NULL) {\n      if (!Decoder::demangle(dlinfo.dli_sname, buf, buflen)) {\n        jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_sname);\n      }\n      if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;\n      return true;\n    }\n    // no matching symbol so try for just file info\n    if (dlinfo.dli_fname != NULL && dlinfo.dli_fbase != NULL) {\n      if (Decoder::decode((address)(addr - (address)dlinfo.dli_fbase),\n                          buf, buflen, offset, dlinfo.dli_fname)) {\n        return true;\n      }\n    }\n  }\n\n  buf[0] = '\\0';\n  if (offset != NULL) *offset = -1;\n  return false;\n}\n\nstruct _address_to_library_name {\n  address addr;          // input : memory address\n  size_t  buflen;        //         size of fname\n  char*   fname;         // output: library name\n  address base;          //         library base addr\n};\n\nstatic int address_to_library_name_callback(struct dl_phdr_info *info,\n                                            size_t size, void *data) {\n  int i;\n  bool found = false;\n  address libbase = NULL;\n  struct _address_to_library_name * d = (struct _address_to_library_name *)data;\n\n  // iterate through all loadable segments\n  for (i = 0; i < info->dlpi_phnum; i++) {\n    address segbase = (address)(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);\n    if (info->dlpi_phdr[i].p_type == PT_LOAD) {\n      // base address of a library is the lowest address of its loaded\n      // segments.\n      if (libbase == NULL || libbase > segbase) {\n        libbase = segbase;\n      }\n      // see if 'addr' is within current segment\n      if (segbase <= d->addr &&\n          d->addr < segbase + info->dlpi_phdr[i].p_memsz) {\n        found = true;\n      }\n    }\n  }\n\n  // dlpi_name is NULL or empty if the ELF file is executable, return 0\n  // so dll_address_to_library_name() can fall through to use dladdr() which\n  // can figure out executable name from argv[0].\n  if (found && info->dlpi_name && info->dlpi_name[0]) {\n    d->base = libbase;\n    if (d->fname) {\n      jio_snprintf(d->fname, d->buflen, \"%s\", info->dlpi_name);\n    }\n    return 1;\n  }\n  return 0;\n}\n\nbool os::dll_address_to_library_name(address addr, char* buf,\n                                     int buflen, int* offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n  struct _address_to_library_name data;\n\n  // There is a bug in old glibc dladdr() implementation that it could resolve\n  // to wrong library name if the .so file has a base address != NULL. Here\n  // we iterate through the program headers of all loaded libraries to find\n  // out which library 'addr' really belongs to. This workaround can be\n  // removed once the minimum requirement for glibc is moved to 2.3.x.\n  data.addr = addr;\n  data.fname = buf;\n  data.buflen = buflen;\n  data.base = NULL;\n  int rslt = dl_iterate_phdr(address_to_library_name_callback, (void *)&data);\n\n  if (rslt) {\n     // buf already contains library name\n     if (offset) *offset = addr - data.base;\n     return true;\n  }\n  if (dladdr((void*)addr, &dlinfo) != 0) {\n    if (dlinfo.dli_fname != NULL) {\n      jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL && offset != NULL) {\n      *offset = addr - (address)dlinfo.dli_fbase;\n    }\n    return true;\n  }\n\n  buf[0] = '\\0';\n  if (offset) *offset = -1;\n  return false;\n}\n\n  // Loads .dll/.so and\n  // in case of error it checks if .dll/.so was built for the\n  // same architecture as Hotspot is running on\n\n\n// Remember the stack's state. The Linux dynamic linker will change\n// the stack to 'executable' at most once, so we must safepoint only once.\nbool os::Linux::_stack_is_executable = false;\n\n// VM operation that loads a library.  This is necessary if stack protection\n// of the Java stacks can be lost during loading the library.  If we\n// do not stop the Java threads, they can stack overflow before the stacks\n// are protected again.\nclass VM_LinuxDllLoad: public VM_Operation {\n private:\n  const char *_filename;\n  char *_ebuf;\n  int _ebuflen;\n  void *_lib;\n public:\n  VM_LinuxDllLoad(const char *fn, char *ebuf, int ebuflen) :\n    _filename(fn), _ebuf(ebuf), _ebuflen(ebuflen), _lib(NULL) {}\n  VMOp_Type type() const { return VMOp_LinuxDllLoad; }\n  void doit() {\n    _lib = os::Linux::dll_load_in_vmthread(_filename, _ebuf, _ebuflen);\n    os::Linux::_stack_is_executable = true;\n  }\n  void* loaded_library() { return _lib; }\n};\n\nvoid * os::dll_load(const char *filename, char *ebuf, int ebuflen)\n{\n  void * result = NULL;\n  bool load_attempted = false;\n\n  // Check whether the library to load might change execution rights\n  // of the stack. If they are changed, the protection of the stack\n  // guard pages will be lost. We need a safepoint to fix this.\n  //\n  // See Linux man page execstack(8) for more info.\n  if (os::uses_stack_guard_pages() && !os::Linux::_stack_is_executable) {\n    ElfFile ef(filename);\n    if (!ef.specifies_noexecstack()) {\n      if (!is_init_completed()) {\n        os::Linux::_stack_is_executable = true;\n        // This is OK - No Java threads have been created yet, and hence no\n        // stack guard pages to fix.\n        //\n        // This should happen only when you are building JDK7 using a very\n        // old version of JDK6 (e.g., with JPRT) and running test_gamma.\n        //\n        // Dynamic loader will make all stacks executable after\n        // this function returns, and will not do that again.\n        assert(Threads::first() == NULL, \"no Java threads should exist yet.\");\n      } else {\n        warning(\"You have loaded library %s which might have disabled stack guard. \"\n                \"The VM will try to fix the stack guard now.\\n\"\n                \"It's highly recommended that you fix the library with \"\n                \"'execstack -c <libfile>', or link it with '-z noexecstack'.\",\n                filename);\n\n        assert(Thread::current()->is_Java_thread(), \"must be Java thread\");\n        JavaThread *jt = JavaThread::current();\n        if (jt->thread_state() != _thread_in_native) {\n          // This happens when a compiler thread tries to load a hsdis-<arch>.so file\n          // that requires ExecStack. Cannot enter safe point. Let's give up.\n          warning(\"Unable to fix stack guard. Giving up.\");\n        } else {\n          if (!LoadExecStackDllInVMThread) {\n            // This is for the case where the DLL has an static\n            // constructor function that executes JNI code. We cannot\n            // load such DLLs in the VMThread.\n            result = os::Linux::dlopen_helper(filename, ebuf, ebuflen);\n          }\n\n          ThreadInVMfromNative tiv(jt);\n          debug_only(VMNativeEntryWrapper vew;)\n\n          VM_LinuxDllLoad op(filename, ebuf, ebuflen);\n          VMThread::execute(&op);\n          if (LoadExecStackDllInVMThread) {\n            result = op.loaded_library();\n          }\n          load_attempted = true;\n        }\n      }\n    }\n  }\n\n  if (!load_attempted) {\n    result = os::Linux::dlopen_helper(filename, ebuf, ebuflen);\n  }\n\n  if (result != NULL) {\n    // Successful loading\n    return result;\n  }\n\n  Elf32_Ehdr elf_head;\n  int diag_msg_max_length=ebuflen-strlen(ebuf);\n  char* diag_msg_buf=ebuf+strlen(ebuf);\n\n  if (diag_msg_max_length==0) {\n    // No more space in ebuf for additional diagnostics message\n    return NULL;\n  }\n\n\n  int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);\n\n  if (file_descriptor < 0) {\n    // Can't open library, report dlerror() message\n    return NULL;\n  }\n\n  bool failed_to_read_elf_head=\n    (sizeof(elf_head)!=\n        (::read(file_descriptor, &elf_head,sizeof(elf_head)))) ;\n\n  ::close(file_descriptor);\n  if (failed_to_read_elf_head) {\n    // file i/o error - report dlerror() msg\n    return NULL;\n  }\n\n  typedef struct {\n    Elf32_Half  code;         // Actual value as defined in elf.h\n    Elf32_Half  compat_class; // Compatibility of archs at VM's sense\n    char        elf_class;    // 32 or 64 bit\n    char        endianess;    // MSB or LSB\n    char*       name;         // String representation\n  } arch_t;\n\n  #ifndef EM_486\n  #define EM_486          6               /* Intel 80486 */\n  #endif\n\n  #ifndef EM_AARCH64\n  #define EM_AARCH64\t183\n  #endif\n\n  static const arch_t arch_array[]={\n    {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)\"IA 64\"},\n    {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)\"AMD 64\"},\n    {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)\"Sparc v9 64\"},\n    {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)\"Power PC 32\"},\n#if defined(VM_LITTLE_ENDIAN)\n    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2LSB, (char*)\"Power PC 64\"},\n#else\n    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)\"Power PC 64\"},\n#endif\n    {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)\"ARM\"},\n    {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)\"IBM System/390\"},\n    {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)\"Alpha\"},\n    {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)\"MIPSel\"},\n    {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)\"MIPS\"},\n    {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)\"PARISC\"},\n    {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)\"M68k\"},\n    {EM_AARCH64,     EM_AARCH64, ELFCLASS64, ELFDATA2LSB, (char*)\"AARCH64\"},\n  };\n\n  #if  (defined IA32)\n    static  Elf32_Half running_arch_code=EM_386;\n  #elif   (defined AMD64)\n    static  Elf32_Half running_arch_code=EM_X86_64;\n  #elif  (defined IA64)\n    static  Elf32_Half running_arch_code=EM_IA_64;\n  #elif  (defined __sparc) && (defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARCV9;\n  #elif  (defined __sparc) && (!defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARC;\n  #elif  (defined __powerpc64__)\n    static  Elf32_Half running_arch_code=EM_PPC64;\n  #elif  (defined __powerpc__)\n    static  Elf32_Half running_arch_code=EM_PPC;\n  #elif  (defined ARM)\n    static  Elf32_Half running_arch_code=EM_ARM;\n  #elif  (defined S390)\n    static  Elf32_Half running_arch_code=EM_S390;\n  #elif  (defined ALPHA)\n    static  Elf32_Half running_arch_code=EM_ALPHA;\n  #elif  (defined MIPSEL)\n    static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;\n  #elif  (defined PARISC)\n    static  Elf32_Half running_arch_code=EM_PARISC;\n  #elif  (defined MIPS)\n    static  Elf32_Half running_arch_code=EM_MIPS;\n  #elif  (defined M68K)\n    static  Elf32_Half running_arch_code=EM_68K;\n  #elif  (defined AARCH64)\n    static  Elf32_Half running_arch_code=EM_AARCH64;\n  #else\n    #error Method os::dll_load requires that one of following is defined:\\\n      IA32, AMD64, IA64, __sparc, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K, AARCH64\n  #endif\n\n  // Identify compatability class for VM's architecture and library's architecture\n  // Obtain string descriptions for architectures\n\n  arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};\n  int running_arch_index=-1;\n\n  for (unsigned int i=0 ; i < ARRAY_SIZE(arch_array) ; i++ ) {\n    if (running_arch_code == arch_array[i].code) {\n      running_arch_index    = i;\n    }\n    if (lib_arch.code == arch_array[i].code) {\n      lib_arch.compat_class = arch_array[i].compat_class;\n      lib_arch.name         = arch_array[i].name;\n    }\n  }\n\n  assert(running_arch_index != -1,\n    \"Didn't find running architecture code (running_arch_code) in arch_array\");\n  if (running_arch_index == -1) {\n    // Even though running architecture detection failed\n    // we may still continue with reporting dlerror() message\n    return NULL;\n  }\n\n  if (lib_arch.endianess != arch_array[running_arch_index].endianess) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n    return NULL;\n  }\n\n#ifndef S390\n  if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n    return NULL;\n  }\n#endif // !S390\n\n  if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {\n    if ( lib_arch.name!=NULL ) {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n        \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n        lib_arch.name, arch_array[running_arch_index].name);\n    } else {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n      \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n        lib_arch.code,\n        arch_array[running_arch_index].name);\n    }\n  }\n\n  return NULL;\n}\n\nvoid * os::Linux::dlopen_helper(const char *filename, char *ebuf, int ebuflen) {\n  void * result = ::dlopen(filename, RTLD_LAZY);\n  if (result == NULL) {\n    ::strncpy(ebuf, ::dlerror(), ebuflen - 1);\n    ebuf[ebuflen-1] = '\\0';\n  }\n  return result;\n}\n\nvoid * os::Linux::dll_load_in_vmthread(const char *filename, char *ebuf, int ebuflen) {\n  void * result = NULL;\n  if (LoadExecStackDllInVMThread) {\n    result = dlopen_helper(filename, ebuf, ebuflen);\n  }\n\n  // Since 7019808, libjvm.so is linked with -noexecstack. If the VM loads a\n  // library that requires an executable stack, or which does not have this\n  // stack attribute set, dlopen changes the stack attribute to executable. The\n  // read protection of the guard pages gets lost.\n  //\n  // Need to check _stack_is_executable again as multiple VM_LinuxDllLoad\n  // may have been queued at the same time.\n\n  if (!_stack_is_executable) {\n    JavaThread *jt = Threads::first();\n\n    while (jt) {\n      if (!jt->stack_guard_zone_unused() &&        // Stack not yet fully initialized\n          jt->stack_yellow_zone_enabled()) {       // No pending stack overflow exceptions\n        if (!os::guard_memory((char *) jt->stack_red_zone_base() - jt->stack_red_zone_size(),\n                              jt->stack_yellow_zone_size() + jt->stack_red_zone_size())) {\n          warning(\"Attempt to reguard stack yellow zone failed.\");\n        }\n      }\n      jt = jt->next();\n    }\n  }\n\n  return result;\n}\n\n/*\n * glibc-2.0 libdl is not MT safe.  If you are building with any glibc,\n * chances are you might want to run the generated bits against glibc-2.0\n * libdl.so, so always use locking for any version of glibc.\n */\nvoid* os::dll_lookup(void* handle, const char* name) {\n  pthread_mutex_lock(&dl_mutex);\n  void* res = dlsym(handle, name);\n  pthread_mutex_unlock(&dl_mutex);\n  return res;\n}\n\nvoid* os::get_default_process_handle() {\n  return (void*)::dlopen(NULL, RTLD_LAZY);\n}\n\nstatic bool _print_ascii_file(const char* filename, outputStream* st) {\n  int fd = ::open(filename, O_RDONLY);\n  if (fd == -1) {\n     return false;\n  }\n\n  char buf[32];\n  int bytes;\n  while ((bytes = ::read(fd, buf, sizeof(buf))) > 0) {\n    st->print_raw(buf, bytes);\n  }\n\n  ::close(fd);\n\n  return true;\n}\n\nvoid os::print_dll_info(outputStream *st) {\n   st->print_cr(\"Dynamic libraries:\");\n\n   char fname[32];\n   pid_t pid = os::Linux::gettid();\n\n   jio_snprintf(fname, sizeof(fname), \"/proc/%d/maps\", pid);\n\n   if (!_print_ascii_file(fname, st)) {\n     st->print(\"Can not get library information for pid = %d\\n\", pid);\n   }\n}\n\nvoid os::print_os_info_brief(outputStream* st) {\n  os::Linux::print_distro_info(st);\n\n  os::Posix::print_uname_info(st);\n\n  os::Linux::print_libversion_info(st);\n\n}\n\nvoid os::print_os_info(outputStream* st) {\n  st->print(\"OS:\");\n\n  os::Linux::print_distro_info(st);\n\n  os::Posix::print_uname_info(st);\n\n  // Print warning if unsafe chroot environment detected\n  if (unsafe_chroot_detected) {\n    st->print(\"WARNING!! \");\n    st->print_cr(\"%s\", unstable_chroot_error);\n  }\n\n  os::Linux::print_libversion_info(st);\n\n  os::Posix::print_rlimit_info(st);\n\n  os::Posix::print_load_average(st);\n\n  os::Linux::print_full_memory_info(st);\n}\n\n// Try to identify popular distros.\n// Most Linux distributions have a /etc/XXX-release file, which contains\n// the OS version string. Newer Linux distributions have a /etc/lsb-release\n// file that also contains the OS version string. Some have more than one\n// /etc/XXX-release file (e.g. Mandrake has both /etc/mandrake-release and\n// /etc/redhat-release.), so the order is important.\n// Any Linux that is based on Redhat (i.e. Oracle, Mandrake, Sun JDS...) have\n// their own specific XXX-release file as well as a redhat-release file.\n// Because of this the XXX-release file needs to be searched for before the\n// redhat-release file.\n// Since Red Hat has a lsb-release file that is not very descriptive the\n// search for redhat-release needs to be before lsb-release.\n// Since the lsb-release file is the new standard it needs to be searched\n// before the older style release files.\n// Searching system-release (Red Hat) and os-release (other Linuxes) are a\n// next to last resort.  The os-release file is a new standard that contains\n// distribution information and the system-release file seems to be an old\n// standard that has been replaced by the lsb-release and os-release files.\n// Searching for the debian_version file is the last resort.  It contains\n// an informative string like \"6.0.6\" or \"wheezy/sid\". Because of this\n// \"Debian \" is printed before the contents of the debian_version file.\nvoid os::Linux::print_distro_info(outputStream* st) {\n   if (!_print_ascii_file(\"/etc/oracle-release\", st) &&\n       !_print_ascii_file(\"/etc/mandriva-release\", st) &&\n       !_print_ascii_file(\"/etc/mandrake-release\", st) &&\n       !_print_ascii_file(\"/etc/sun-release\", st) &&\n       !_print_ascii_file(\"/etc/redhat-release\", st) &&\n       !_print_ascii_file(\"/etc/lsb-release\", st) &&\n       !_print_ascii_file(\"/etc/SuSE-release\", st) &&\n       !_print_ascii_file(\"/etc/turbolinux-release\", st) &&\n       !_print_ascii_file(\"/etc/gentoo-release\", st) &&\n       !_print_ascii_file(\"/etc/ltib-release\", st) &&\n       !_print_ascii_file(\"/etc/angstrom-version\", st) &&\n       !_print_ascii_file(\"/etc/system-release\", st) &&\n       !_print_ascii_file(\"/etc/os-release\", st)) {\n\n       if (file_exists(\"/etc/debian_version\")) {\n         st->print(\"Debian \");\n         _print_ascii_file(\"/etc/debian_version\", st);\n       } else {\n         st->print(\"Linux\");\n       }\n   }\n   st->cr();\n}\n\nvoid os::Linux::print_libversion_info(outputStream* st) {\n  // libc, pthread\n  st->print(\"libc:\");\n  st->print(\"%s \", os::Linux::glibc_version());\n  st->print(\"%s \", os::Linux::libpthread_version());\n  if (os::Linux::is_LinuxThreads()) {\n     st->print(\"(%s stack)\", os::Linux::is_floating_stack() ? \"floating\" : \"fixed\");\n  }\n  st->cr();\n}\n\nvoid os::Linux::print_full_memory_info(outputStream* st) {\n   st->print(\"\\n/proc/meminfo:\\n\");\n   _print_ascii_file(\"/proc/meminfo\", st);\n   st->cr();\n}\n\nvoid os::print_memory_info(outputStream* st) {\n\n  st->print(\"Memory:\");\n  st->print(\" %dk page\", os::vm_page_size()>>10);\n\n  // values in struct sysinfo are \"unsigned long\"\n  struct sysinfo si;\n  sysinfo(&si);\n\n  st->print(\", physical \" UINT64_FORMAT \"k\",\n            os::physical_memory() >> 10);\n  st->print(\"(\" UINT64_FORMAT \"k free)\",\n            os::available_memory() >> 10);\n  st->print(\", swap \" UINT64_FORMAT \"k\",\n            ((jlong)si.totalswap * si.mem_unit) >> 10);\n  st->print(\"(\" UINT64_FORMAT \"k free)\",\n            ((jlong)si.freeswap * si.mem_unit) >> 10);\n  st->cr();\n}\n\nvoid os::pd_print_cpu_info(outputStream* st) {\n  st->print(\"\\n/proc/cpuinfo:\\n\");\n  if (!_print_ascii_file(\"/proc/cpuinfo\", st)) {\n    st->print(\"  <Not Available>\");\n  }\n  st->cr();\n}\n\nvoid os::print_siginfo(outputStream* st, void* siginfo) {\n  const siginfo_t* si = (const siginfo_t*)siginfo;\n\n  os::Posix::print_siginfo_brief(st, si);\n#if INCLUDE_CDS\n  if (si && (si->si_signo == SIGBUS || si->si_signo == SIGSEGV) &&\n      UseSharedSpaces) {\n    FileMapInfo* mapinfo = FileMapInfo::current_info();\n    if (mapinfo->is_in_shared_space(si->si_addr)) {\n      st->print(\"\\n\\nError accessing class data sharing archive.\"   \\\n                \" Mapped file inaccessible during execution, \"      \\\n                \" possible disk/network problem.\");\n    }\n  }\n#endif\n  st->cr();\n}\n\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen);\n\nvoid os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n  st->print_cr(\"Signal Handlers:\");\n  print_signal_handler(st, SIGSEGV, buf, buflen);\n  print_signal_handler(st, SIGBUS , buf, buflen);\n  print_signal_handler(st, SIGFPE , buf, buflen);\n  print_signal_handler(st, SIGPIPE, buf, buflen);\n  print_signal_handler(st, SIGXFSZ, buf, buflen);\n  print_signal_handler(st, SIGILL , buf, buflen);\n  print_signal_handler(st, INTERRUPT_SIGNAL, buf, buflen);\n  print_signal_handler(st, SR_signum, buf, buflen);\n  print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n  print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n#if defined(PPC64)\n  print_signal_handler(st, SIGTRAP, buf, buflen);\n#endif\n}\n\nstatic char saved_jvm_path[MAXPATHLEN] = {0};\n\n// Find the full path to the current module, libjvm.so\nvoid os::jvm_path(char *buf, jint buflen) {\n  // Error checking.\n  if (buflen < MAXPATHLEN) {\n    assert(false, \"must use a large-enough buffer\");\n    buf[0] = '\\0';\n    return;\n  }\n  // Lazy resolve the path to current module.\n  if (saved_jvm_path[0] != 0) {\n    strcpy(buf, saved_jvm_path);\n    return;\n  }\n\n  char dli_fname[MAXPATHLEN];\n  bool ret = dll_address_to_library_name(\n                CAST_FROM_FN_PTR(address, os::jvm_path),\n                dli_fname, sizeof(dli_fname), NULL);\n  assert(ret, \"cannot locate libjvm\");\n  char *rp = NULL;\n  if (ret && dli_fname[0] != '\\0') {\n    rp = realpath(dli_fname, buf);\n  }\n  if (rp == NULL)\n    return;\n\n  if (Arguments::created_by_gamma_launcher()) {\n    // Support for the gamma launcher.  Typical value for buf is\n    // \"<JAVA_HOME>/jre/lib/<arch>/<vmtype>/libjvm.so\".  If \"/jre/lib/\" appears at\n    // the right place in the string, then assume we are installed in a JDK and\n    // we're done.  Otherwise, check for a JAVA_HOME environment variable and fix\n    // up the path so it looks like libjvm.so is installed there (append a\n    // fake suffix hotspot/libjvm.so).\n    const char *p = buf + strlen(buf) - 1;\n    for (int count = 0; p > buf && count < 5; ++count) {\n      for (--p; p > buf && *p != '/'; --p)\n        /* empty */ ;\n    }\n\n    if (strncmp(p, \"/jre/lib/\", 9) != 0) {\n      // Look for JAVA_HOME in the environment.\n      char* java_home_var = ::getenv(\"JAVA_HOME\");\n      if (java_home_var != NULL && java_home_var[0] != 0) {\n        char* jrelib_p;\n        int len;\n\n        // Check the current module name \"libjvm.so\".\n        p = strrchr(buf, '/');\n        assert(strstr(p, \"/libjvm\") == p, \"invalid library name\");\n\n        rp = realpath(java_home_var, buf);\n        if (rp == NULL)\n          return;\n\n        // determine if this is a legacy image or modules image\n        // modules image doesn't have \"jre\" subdirectory\n        len = strlen(buf);\n        assert(len < buflen, \"Ran out of buffer room\");\n        jrelib_p = buf + len;\n        snprintf(jrelib_p, buflen-len, \"/jre/lib/%s\", cpu_arch);\n        if (0 != access(buf, F_OK)) {\n          snprintf(jrelib_p, buflen-len, \"/lib/%s\", cpu_arch);\n        }\n\n        if (0 == access(buf, F_OK)) {\n          // Use current module name \"libjvm.so\"\n          len = strlen(buf);\n          snprintf(buf + len, buflen-len, \"/hotspot/libjvm.so\");\n        } else {\n          // Go back to path of .so\n          rp = realpath(dli_fname, buf);\n          if (rp == NULL)\n            return;\n        }\n      }\n    }\n  }\n\n  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n}\n\nvoid os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n  // no prefix required, not even \"_\"\n}\n\nvoid os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n  // no suffix required\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// sun.misc.Signal support\n\nstatic volatile jint sigint_count = 0;\n\nstatic void\nUserHandler(int sig, void *siginfo, void *context) {\n  // 4511530 - sem_post is serialized and handled by the manager thread. When\n  // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We\n  // don't want to flood the manager thread with sem_post requests.\n  if (sig == SIGINT && Atomic::add(1, &sigint_count) > 1)\n      return;\n\n  // Ctrl-C is pressed during error reporting, likely because the error\n  // handler fails to abort. Let VM die immediately.\n  if (sig == SIGINT && is_error_reported()) {\n     os::die();\n  }\n\n  os::signal_notify(sig);\n}\n\nvoid* os::user_handler() {\n  return CAST_FROM_FN_PTR(void*, UserHandler);\n}\n\nclass Semaphore : public StackObj {\n  public:\n    Semaphore();\n    ~Semaphore();\n    void signal();\n    void wait();\n    bool trywait();\n    bool timedwait(unsigned int sec, int nsec);\n  private:\n    sem_t _semaphore;\n};\n\nSemaphore::Semaphore() {\n  sem_init(&_semaphore, 0, 0);\n}\n\nSemaphore::~Semaphore() {\n  sem_destroy(&_semaphore);\n}\n\nvoid Semaphore::signal() {\n  sem_post(&_semaphore);\n}\n\nvoid Semaphore::wait() {\n  sem_wait(&_semaphore);\n}\n\nbool Semaphore::trywait() {\n  return sem_trywait(&_semaphore) == 0;\n}\n\nbool Semaphore::timedwait(unsigned int sec, int nsec) {\n\n  struct timespec ts;\n  // Semaphore's are always associated with CLOCK_REALTIME\n  os::Linux::clock_gettime(CLOCK_REALTIME, &ts);\n  // see unpackTime for discussion on overflow checking\n  if (sec >= MAX_SECS) {\n    ts.tv_sec += MAX_SECS;\n    ts.tv_nsec = 0;\n  } else {\n    ts.tv_sec += sec;\n    ts.tv_nsec += nsec;\n    if (ts.tv_nsec >= NANOSECS_PER_SEC) {\n      ts.tv_nsec -= NANOSECS_PER_SEC;\n      ++ts.tv_sec; // note: this must be <= max_secs\n    }\n  }\n\n  while (1) {\n    int result = sem_timedwait(&_semaphore, &ts);\n    if (result == 0) {\n      return true;\n    } else if (errno == EINTR) {\n      continue;\n    } else if (errno == ETIMEDOUT) {\n      return false;\n    } else {\n      return false;\n    }\n  }\n}\n\nextern \"C\" {\n  typedef void (*sa_handler_t)(int);\n  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n}\n\nvoid* os::signal(int signal_number, void* handler) {\n  struct sigaction sigAct, oldSigAct;\n\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n\n  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n    // -1 means registration failed\n    return (void *)-1;\n  }\n\n  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n}\n\nvoid os::signal_raise(int signal_number) {\n  ::raise(signal_number);\n}\n\n/*\n * The following code is moved from os.cpp for making this\n * code platform specific, which it is by its very nature.\n */\n\n// Will be modified when max signal is changed to be dynamic\nint os::sigexitnum_pd() {\n  return NSIG;\n}\n\n// a counter for each possible signal value\nstatic volatile jint pending_signals[NSIG+1] = { 0 };\n\n// Linux(POSIX) specific hand shaking semaphore.\nstatic sem_t sig_sem;\nstatic Semaphore sr_semaphore;\n\nvoid os::signal_init_pd() {\n  // Initialize signal structures\n  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n\n  // Initialize signal semaphore\n  ::sem_init(&sig_sem, 0, 0);\n}\n\nvoid os::signal_notify(int sig) {\n  Atomic::inc(&pending_signals[sig]);\n  ::sem_post(&sig_sem);\n}\n\nstatic int check_pending_signals(bool wait) {\n  Atomic::store(0, &sigint_count);\n  for (;;) {\n    for (int i = 0; i < NSIG + 1; i++) {\n      jint n = pending_signals[i];\n      if (n > 0 && n == Atomic::cmpxchg(n - 1, &pending_signals[i], n)) {\n        return i;\n      }\n    }\n    if (!wait) {\n      return -1;\n    }\n    JavaThread *thread = JavaThread::current();\n    ThreadBlockInVM tbivm(thread);\n\n    bool threadIsSuspended;\n    do {\n      thread->set_suspend_equivalent();\n      // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n      ::sem_wait(&sig_sem);\n\n      // were we externally suspended while we were waiting?\n      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n      if (threadIsSuspended) {\n        //\n        // The semaphore has been incremented, but while we were waiting\n        // another thread suspended us. We don't want to continue running\n        // while suspended because that would surprise the thread that\n        // suspended us.\n        //\n        ::sem_post(&sig_sem);\n\n        thread->java_suspend_self();\n      }\n    } while (threadIsSuspended);\n  }\n}\n\nint os::signal_lookup() {\n  return check_pending_signals(false);\n}\n\nint os::signal_wait() {\n  return check_pending_signals(true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Virtual Memory\n\nint os::vm_page_size() {\n  // Seems redundant as all get out\n  assert(os::Linux::page_size() != -1, \"must call os::init\");\n  return os::Linux::page_size();\n}\n\n// Solaris allocates memory by pages.\nint os::vm_allocation_granularity() {\n  assert(os::Linux::page_size() != -1, \"must call os::init\");\n  return os::Linux::page_size();\n}\n\n// Rationale behind this function:\n//  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable\n//  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get\n//  samples for JITted code. Here we create private executable mapping over the code cache\n//  and then we can use standard (well, almost, as mapping can change) way to provide\n//  info for the reporting script by storing timestamp and location of symbol\nvoid linux_wrap_code(char* base, size_t size) {\n  static volatile jint cnt = 0;\n\n  if (!UseOprofile) {\n    return;\n  }\n\n  char buf[PATH_MAX+1];\n  int num = Atomic::add(1, &cnt);\n\n  snprintf(buf, sizeof(buf), \"%s/hs-vm-%d-%d\",\n           os::get_temp_directory(), os::current_process_id(), num);\n  unlink(buf);\n\n  int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);\n\n  if (fd != -1) {\n    off_t rv = ::lseek(fd, size-2, SEEK_SET);\n    if (rv != (off_t)-1) {\n      if (::write(fd, \"\", 1) == 1) {\n        mmap(base, size,\n             PROT_READ|PROT_WRITE|PROT_EXEC,\n             MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);\n      }\n    }\n    ::close(fd);\n    unlink(buf);\n  }\n}\n\nstatic bool recoverable_mmap_error(int err) {\n  // See if the error is one we can let the caller handle. This\n  // list of errno values comes from JBS-6843484. I can't find a\n  // Linux man page that documents this specific set of errno\n  // values so while this list currently matches Solaris, it may\n  // change as we gain experience with this failure mode.\n  switch (err) {\n  case EBADF:\n  case EINVAL:\n  case ENOTSUP:\n    // let the caller deal with these errors\n    return true;\n\n  default:\n    // Any remaining errors on this OS can cause our reserved mapping\n    // to be lost. That can cause confusion where different data\n    // structures think they have the same memory mapped. The worst\n    // scenario is if both the VM and a library think they have the\n    // same memory mapped.\n    return false;\n  }\n}\n\nstatic void warn_fail_commit_memory(char* addr, size_t size, bool exec,\n                                    int err) {\n  warning(\"INFO: os::commit_memory(\" PTR_FORMAT \", \" SIZE_FORMAT\n          \", %d) failed; error='%s' (errno=%d)\", addr, size, exec,\n          strerror(err), err);\n}\n\nstatic void warn_fail_commit_memory(char* addr, size_t size,\n                                    size_t alignment_hint, bool exec,\n                                    int err) {\n  warning(\"INFO: os::commit_memory(\" PTR_FORMAT \", \" SIZE_FORMAT\n          \", \" SIZE_FORMAT \", %d) failed; error='%s' (errno=%d)\", addr, size,\n          alignment_hint, exec, strerror(err), err);\n}\n\n// NOTE: Linux kernel does not really reserve the pages for us.\n//       All it does is to check if there are enough free pages\n//       left at the time of mmap(). This could be a potential\n//       problem.\nint os::Linux::commit_memory_impl(char* addr, size_t size, bool exec) {\n  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n  uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,\n                                   MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n  if (res != (uintptr_t) MAP_FAILED) {\n    if (UseNUMAInterleaving) {\n      numa_make_global(addr, size);\n    }\n    return 0;\n  }\n\n  int err = errno;  // save errno from mmap() call above\n\n  if (!recoverable_mmap_error(err)) {\n    warn_fail_commit_memory(addr, size, exec, err);\n    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"committing reserved memory.\");\n  }\n\n  return err;\n}\n\nbool os::pd_commit_memory(char* addr, size_t size, bool exec) {\n  return os::Linux::commit_memory_impl(addr, size, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  int err = os::Linux::commit_memory_impl(addr, size, exec);\n  if (err != 0) {\n    // the caller wants all commit errors to exit with the specified mesg:\n    warn_fail_commit_memory(addr, size, exec, err);\n    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, mesg);\n  }\n}\n\n// Define MAP_HUGETLB here so we can build HotSpot on old systems.\n#ifndef MAP_HUGETLB\n#define MAP_HUGETLB 0x40000\n#endif\n\n// Define MADV_HUGEPAGE here so we can build HotSpot on old systems.\n#ifndef MADV_HUGEPAGE\n#define MADV_HUGEPAGE 14\n#endif\n\nint os::Linux::commit_memory_impl(char* addr, size_t size,\n                                  size_t alignment_hint, bool exec) {\n  int err = os::Linux::commit_memory_impl(addr, size, exec);\n  if (err == 0) {\n    realign_memory(addr, size, alignment_hint);\n  }\n  return err;\n}\n\nbool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,\n                          bool exec) {\n  return os::Linux::commit_memory_impl(addr, size, alignment_hint, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size,\n                                  size_t alignment_hint, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  int err = os::Linux::commit_memory_impl(addr, size, alignment_hint, exec);\n  if (err != 0) {\n    // the caller wants all commit errors to exit with the specified mesg:\n    warn_fail_commit_memory(addr, size, alignment_hint, exec, err);\n    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, mesg);\n  }\n}\n\nvoid os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {\n  if (UseTransparentHugePages && alignment_hint > (size_t)vm_page_size()) {\n    // We don't check the return value: madvise(MADV_HUGEPAGE) may not\n    // be supported or the memory may already be backed by huge pages.\n    ::madvise(addr, bytes, MADV_HUGEPAGE);\n  }\n}\n\nvoid os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n  // This method works by doing an mmap over an existing mmaping and effectively discarding\n  // the existing pages. However it won't work for SHM-based large pages that cannot be\n  // uncommitted at all. We don't do anything in this case to avoid creating a segment with\n  // small pages on top of the SHM segment. This method always works for small pages, so we\n  // allow that in any case.\n  if (alignment_hint <= (size_t)os::vm_page_size() || can_commit_large_page_memory()) {\n    commit_memory(addr, bytes, alignment_hint, !ExecMem);\n  }\n}\n\nvoid os::numa_make_global(char *addr, size_t bytes) {\n  Linux::numa_interleave_memory(addr, bytes);\n}\n\n// Define for numa_set_bind_policy(int). Setting the argument to 0 will set the\n// bind policy to MPOL_PREFERRED for the current thread.\n#define USE_MPOL_PREFERRED 0\n\nvoid os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {\n  // To make NUMA and large pages more robust when both enabled, we need to ease\n  // the requirements on where the memory should be allocated. MPOL_BIND is the\n  // default policy and it will force memory to be allocated on the specified\n  // node. Changing this to MPOL_PREFERRED will prefer to allocate the memory on\n  // the specified node, but will not force it. Using this policy will prevent\n  // getting SIGBUS when trying to allocate large pages on NUMA nodes with no\n  // free large pages.\n  Linux::numa_set_bind_policy(USE_MPOL_PREFERRED);\n  Linux::numa_tonode_memory(addr, bytes, lgrp_hint);\n}\n\nbool os::numa_topology_changed()   { return false; }\n\nsize_t os::numa_get_groups_num() {\n  int max_node = Linux::numa_max_node();\n  return max_node > 0 ? max_node + 1 : 1;\n}\n\nint os::numa_get_group_id() {\n  int cpu_id = Linux::sched_getcpu();\n  if (cpu_id != -1) {\n    int lgrp_id = Linux::get_node_by_cpu(cpu_id);\n    if (lgrp_id != -1) {\n      return lgrp_id;\n    }\n  }\n  return 0;\n}\n\nsize_t os::numa_get_leaf_groups(int *ids, size_t size) {\n  for (size_t i = 0; i < size; i++) {\n    ids[i] = i;\n  }\n  return size;\n}\n\nbool os::get_page_info(char *start, page_info* info) {\n  return false;\n}\n\nchar *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {\n  return end;\n}\n\n\nint os::Linux::sched_getcpu_syscall(void) {\n  unsigned int cpu = 0;\n  int retval = -1;\n\n#if defined(AMD64) || defined(BUILTIN_SIM)\n// Unfortunately we have to bring all these macros here from vsyscall.h\n// to be able to compile on old linuxes.\n# define __NR_vgetcpu 2\n# define VSYSCALL_START (-10UL << 20)\n# define VSYSCALL_SIZE 1024\n# define VSYSCALL_ADDR(vsyscall_nr) (VSYSCALL_START+VSYSCALL_SIZE*(vsyscall_nr))\n  typedef long (*vgetcpu_t)(unsigned int *cpu, unsigned int *node, unsigned long *tcache);\n  vgetcpu_t vgetcpu = (vgetcpu_t)VSYSCALL_ADDR(__NR_vgetcpu);\n  retval = vgetcpu(&cpu, NULL, NULL);\n#elif defined(IA32) || defined(AARCH64)\n# ifndef SYS_getcpu\n#  define SYS_getcpu AARCH64_ONLY(168) NOT_AARCH64(318)\n# endif\n  retval = syscall(SYS_getcpu, &cpu, NULL, NULL);\n#endif\n\n  return (retval == -1) ? retval : cpu;\n}\n\n// Something to do with the numa-aware allocator needs these symbols\nextern \"C\" JNIEXPORT void numa_warn(int number, char *where, ...) { }\nextern \"C\" JNIEXPORT void numa_error(char *where) { }\nextern \"C\" JNIEXPORT int fork1() { return fork(); }\n\n\n// If we are running with libnuma version > 2, then we should\n// be trying to use symbols with versions 1.1\n// If we are running with earlier version, which did not have symbol versions,\n// we should use the base version.\nvoid* os::Linux::libnuma_dlsym(void* handle, const char *name) {\n  void *f = dlvsym(handle, name, \"libnuma_1.1\");\n  if (f == NULL) {\n    f = dlsym(handle, name);\n  }\n  return f;\n}\n\nbool os::Linux::libnuma_init() {\n  // sched_getcpu() should be in libc.\n  set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,\n                                  dlsym(RTLD_DEFAULT, \"sched_getcpu\")));\n\n  // If it's not, try a direct syscall.\n  if (sched_getcpu() == -1)\n    set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t, (void*)&sched_getcpu_syscall));\n\n  if (sched_getcpu() != -1) { // Does it work?\n    void *handle = dlopen(\"libnuma.so.1\", RTLD_LAZY);\n    if (handle != NULL) {\n      set_numa_node_to_cpus(CAST_TO_FN_PTR(numa_node_to_cpus_func_t,\n                                           libnuma_dlsym(handle, \"numa_node_to_cpus\")));\n      set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,\n                                       libnuma_dlsym(handle, \"numa_max_node\")));\n      set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,\n                                        libnuma_dlsym(handle, \"numa_available\")));\n      set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,\n                                            libnuma_dlsym(handle, \"numa_tonode_memory\")));\n      set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,\n                                            libnuma_dlsym(handle, \"numa_interleave_memory\")));\n      set_numa_set_bind_policy(CAST_TO_FN_PTR(numa_set_bind_policy_func_t,\n                                            libnuma_dlsym(handle, \"numa_set_bind_policy\")));\n\n\n      if (numa_available() != -1) {\n        set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, \"numa_all_nodes\"));\n        // Create a cpu -> node mapping\n        _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, true);\n        rebuild_cpu_to_node_map();\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// rebuild_cpu_to_node_map() constructs a table mapping cpud id to node id.\n// The table is later used in get_node_by_cpu().\nvoid os::Linux::rebuild_cpu_to_node_map() {\n  const size_t NCPUS = 32768; // Since the buffer size computation is very obscure\n                              // in libnuma (possible values are starting from 16,\n                              // and continuing up with every other power of 2, but less\n                              // than the maximum number of CPUs supported by kernel), and\n                              // is a subject to change (in libnuma version 2 the requirements\n                              // are more reasonable) we'll just hardcode the number they use\n                              // in the library.\n  const size_t BitsPerCLong = sizeof(long) * CHAR_BIT;\n\n  size_t cpu_num = os::active_processor_count();\n  size_t cpu_map_size = NCPUS / BitsPerCLong;\n  size_t cpu_map_valid_size =\n    MIN2((cpu_num + BitsPerCLong - 1) / BitsPerCLong, cpu_map_size);\n\n  cpu_to_node()->clear();\n  cpu_to_node()->at_grow(cpu_num - 1);\n  size_t node_num = numa_get_groups_num();\n\n  unsigned long *cpu_map = NEW_C_HEAP_ARRAY(unsigned long, cpu_map_size, mtInternal);\n  for (size_t i = 0; i < node_num; i++) {\n    if (numa_node_to_cpus(i, cpu_map, cpu_map_size * sizeof(unsigned long)) != -1) {\n      for (size_t j = 0; j < cpu_map_valid_size; j++) {\n        if (cpu_map[j] != 0) {\n          for (size_t k = 0; k < BitsPerCLong; k++) {\n            if (cpu_map[j] & (1UL << k)) {\n              cpu_to_node()->at_put(j * BitsPerCLong + k, i);\n            }\n          }\n        }\n      }\n    }\n  }\n  FREE_C_HEAP_ARRAY(unsigned long, cpu_map, mtInternal);\n}\n\nint os::Linux::get_node_by_cpu(int cpu_id) {\n  if (cpu_to_node() != NULL && cpu_id >= 0 && cpu_id < cpu_to_node()->length()) {\n    return cpu_to_node()->at(cpu_id);\n  }\n  return -1;\n}\n\nGrowableArray<int>* os::Linux::_cpu_to_node;\nos::Linux::sched_getcpu_func_t os::Linux::_sched_getcpu;\nos::Linux::numa_node_to_cpus_func_t os::Linux::_numa_node_to_cpus;\nos::Linux::numa_max_node_func_t os::Linux::_numa_max_node;\nos::Linux::numa_available_func_t os::Linux::_numa_available;\nos::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;\nos::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;\nos::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;\nunsigned long* os::Linux::_numa_all_nodes;\n\nbool os::pd_uncommit_memory(char* addr, size_t size) {\n  uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,\n                MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n  return res  != (uintptr_t) MAP_FAILED;\n}\n\nstatic\naddress get_stack_commited_bottom(address bottom, size_t size) {\n  address nbot = bottom;\n  address ntop = bottom + size;\n\n  size_t page_sz = os::vm_page_size();\n  unsigned pages = size / page_sz;\n\n  unsigned char vec[1];\n  unsigned imin = 1, imax = pages + 1, imid;\n  int mincore_return_value = 0;\n\n  assert(imin <= imax, \"Unexpected page size\");\n\n  while (imin < imax) {\n    imid = (imax + imin) / 2;\n    nbot = ntop - (imid * page_sz);\n\n    // Use a trick with mincore to check whether the page is mapped or not.\n    // mincore sets vec to 1 if page resides in memory and to 0 if page\n    // is swapped output but if page we are asking for is unmapped\n    // it returns -1,ENOMEM\n    mincore_return_value = mincore(nbot, page_sz, vec);\n\n    if (mincore_return_value == -1) {\n      // Page is not mapped go up\n      // to find first mapped page\n      if (errno != EAGAIN) {\n        assert(errno == ENOMEM, \"Unexpected mincore errno\");\n        imax = imid;\n      }\n    } else {\n      // Page is mapped go down\n      // to find first not mapped page\n      imin = imid + 1;\n    }\n  }\n\n  nbot = nbot + page_sz;\n\n  // Adjust stack bottom one page up if last checked page is not mapped\n  if (mincore_return_value == -1) {\n    nbot = nbot + page_sz;\n  }\n\n  return nbot;\n}\n\n\n// Linux uses a growable mapping for the stack, and if the mapping for\n// the stack guard pages is not removed when we detach a thread the\n// stack cannot grow beyond the pages where the stack guard was\n// mapped.  If at some point later in the process the stack expands to\n// that point, the Linux kernel cannot expand the stack any further\n// because the guard pages are in the way, and a segfault occurs.\n//\n// However, it's essential not to split the stack region by unmapping\n// a region (leaving a hole) that's already part of the stack mapping,\n// so if the stack mapping has already grown beyond the guard pages at\n// the time we create them, we have to truncate the stack mapping.\n// So, we need to know the extent of the stack mapping when\n// create_stack_guard_pages() is called.\n\n// We only need this for stacks that are growable: at the time of\n// writing thread stacks don't use growable mappings (i.e. those\n// creeated with MAP_GROWSDOWN), and aren't marked \"[stack]\", so this\n// only applies to the main thread.\n\n// If the (growable) stack mapping already extends beyond the point\n// where we're going to put our guard pages, truncate the mapping at\n// that point by munmap()ping it.  This ensures that when we later\n// munmap() the guard pages we don't leave a hole in the stack\n// mapping. This only affects the main/initial thread\n\nbool os::pd_create_stack_guard_pages(char* addr, size_t size) {\n\n  if (os::Linux::is_initial_thread()) {\n    // As we manually grow stack up to bottom inside create_attached_thread(),\n    // it's likely that os::Linux::initial_thread_stack_bottom is mapped and\n    // we don't need to do anything special.\n    // Check it first, before calling heavy function.\n    uintptr_t stack_extent = (uintptr_t) os::Linux::initial_thread_stack_bottom();\n    unsigned char vec[1];\n\n    if (mincore((address)stack_extent, os::vm_page_size(), vec) == -1) {\n      // Fallback to slow path on all errors, including EAGAIN\n      stack_extent = (uintptr_t) get_stack_commited_bottom(\n                                    os::Linux::initial_thread_stack_bottom(),\n                                    (size_t)addr - stack_extent);\n    }\n\n    if (stack_extent < (uintptr_t)addr) {\n      ::munmap((void*)stack_extent, (uintptr_t)(addr - stack_extent));\n    }\n  }\n\n  return os::commit_memory(addr, size, !ExecMem);\n}\n\n// If this is a growable mapping, remove the guard pages entirely by\n// munmap()ping them.  If not, just call uncommit_memory(). This only\n// affects the main/initial thread, but guard against future OS changes\n// It's safe to always unmap guard pages for initial thread because we\n// always place it right after end of the mapped region\n\nbool os::remove_stack_guard_pages(char* addr, size_t size) {\n  uintptr_t stack_extent, stack_base;\n\n  if (os::Linux::is_initial_thread()) {\n    return ::munmap(addr, size) == 0;\n  }\n\n  return os::uncommit_memory(addr, size);\n}\n\nstatic address _highest_vm_reserved_address = NULL;\n\n// If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory\n// at 'requested_addr'. If there are existing memory mappings at the same\n// location, however, they will be overwritten. If 'fixed' is false,\n// 'requested_addr' is only treated as a hint, the return value may or\n// may not start from the requested address. Unlike Linux mmap(), this\n// function returns NULL to indicate failure.\nstatic char* anon_mmap(char* requested_addr, size_t bytes, bool fixed) {\n  char * addr;\n  int flags;\n\n  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n  if (fixed) {\n    assert((uintptr_t)requested_addr % os::Linux::page_size() == 0, \"unaligned address\");\n    flags |= MAP_FIXED;\n  }\n\n  // Map reserved/uncommitted pages PROT_NONE so we fail early if we\n  // touch an uncommitted page. Otherwise, the read/write might\n  // succeed if we have enough swap space to back the physical page.\n  addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,\n                       flags, -1, 0);\n\n  if (addr != MAP_FAILED) {\n    // anon_mmap() should only get called during VM initialization,\n    // don't need lock (actually we can skip locking even it can be called\n    // from multiple threads, because _highest_vm_reserved_address is just a\n    // hint about the upper limit of non-stack memory regions.)\n    if ((address)addr + bytes > _highest_vm_reserved_address) {\n      _highest_vm_reserved_address = (address)addr + bytes;\n    }\n  }\n\n  return addr == MAP_FAILED ? NULL : addr;\n}\n\n// Allocate (using mmap, NO_RESERVE, with small pages) at either a given request address\n//   (req_addr != NULL) or with a given alignment.\n//  - bytes shall be a multiple of alignment.\n//  - req_addr can be NULL. If not NULL, it must be a multiple of alignment.\n//  - alignment sets the alignment at which memory shall be allocated.\n//     It must be a multiple of allocation granularity.\n// Returns address of memory or NULL. If req_addr was not NULL, will only return\n//  req_addr or NULL.\nstatic char* anon_mmap_aligned(size_t bytes, size_t alignment, char* req_addr) {\n\n  size_t extra_size = bytes;\n  if (req_addr == NULL && alignment > 0) {\n    extra_size += alignment;\n  }\n\n  char* start = (char*) ::mmap(req_addr, extra_size, PROT_NONE,\n    MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n    -1, 0);\n  if (start == MAP_FAILED) {\n    start = NULL;\n  } else {\n    if (req_addr != NULL) {\n      if (start != req_addr) {\n        ::munmap(start, extra_size);\n        start = NULL;\n      }\n    } else {\n      char* const start_aligned = (char*) align_ptr_up(start, alignment);\n      char* const end_aligned = start_aligned + bytes;\n      char* const end = start + extra_size;\n      if (start_aligned > start) {\n        ::munmap(start, start_aligned - start);\n      }\n      if (end_aligned < end) {\n        ::munmap(end_aligned, end - end_aligned);\n      }\n      start = start_aligned;\n    }\n  }\n  return start;\n}\n\n// Don't update _highest_vm_reserved_address, because there might be memory\n// regions above addr + size. If so, releasing a memory region only creates\n// a hole in the address space, it doesn't help prevent heap-stack collision.\n//\nstatic int anon_munmap(char * addr, size_t size) {\n  return ::munmap(addr, size) == 0;\n}\n\nchar* os::pd_reserve_memory(size_t bytes, char* requested_addr,\n                         size_t alignment_hint) {\n  return anon_mmap(requested_addr, bytes, (requested_addr != NULL));\n}\n\nbool os::pd_release_memory(char* addr, size_t size) {\n  return anon_munmap(addr, size);\n}\n\nstatic address highest_vm_reserved_address() {\n  return _highest_vm_reserved_address;\n}\n\nstatic bool linux_mprotect(char* addr, size_t size, int prot) {\n  // Linux wants the mprotect address argument to be page aligned.\n  char* bottom = (char*)align_size_down((intptr_t)addr, os::Linux::page_size());\n\n  // According to SUSv3, mprotect() should only be used with mappings\n  // established by mmap(), and mmap() always maps whole pages. Unaligned\n  // 'addr' likely indicates problem in the VM (e.g. trying to change\n  // protection of malloc'ed or statically allocated memory). Check the\n  // caller if you hit this assert.\n  assert(addr == bottom, \"sanity check\");\n\n  size = align_size_up(pointer_delta(addr, bottom, 1) + size, os::Linux::page_size());\n  return ::mprotect(bottom, size, prot) == 0;\n}\n\n// Set protections specified\nbool os::protect_memory(char* addr, size_t bytes, ProtType prot,\n                        bool is_committed) {\n  unsigned int p = 0;\n  switch (prot) {\n  case MEM_PROT_NONE: p = PROT_NONE; break;\n  case MEM_PROT_READ: p = PROT_READ; break;\n  case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;\n  case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;\n  default:\n    ShouldNotReachHere();\n  }\n  // is_committed is unused.\n  return linux_mprotect(addr, bytes, p);\n}\n\nbool os::guard_memory(char* addr, size_t size) {\n  return linux_mprotect(addr, size, PROT_NONE);\n}\n\nbool os::unguard_memory(char* addr, size_t size) {\n  return linux_mprotect(addr, size, PROT_READ|PROT_WRITE);\n}\n\nbool os::Linux::transparent_huge_pages_sanity_check(bool warn, size_t page_size) {\n  bool result = false;\n  void *p = mmap(NULL, page_size * 2, PROT_READ|PROT_WRITE,\n                 MAP_ANONYMOUS|MAP_PRIVATE,\n                 -1, 0);\n  if (p != MAP_FAILED) {\n    void *aligned_p = align_ptr_up(p, page_size);\n\n    result = madvise(aligned_p, page_size, MADV_HUGEPAGE) == 0;\n\n    munmap(p, page_size * 2);\n  }\n\n  if (warn && !result) {\n    warning(\"TransparentHugePages is not supported by the operating system.\");\n  }\n\n  return result;\n}\n\nbool os::Linux::hugetlbfs_sanity_check(bool warn, size_t page_size) {\n  bool result = false;\n  void *p = mmap(NULL, page_size, PROT_READ|PROT_WRITE,\n                 MAP_ANONYMOUS|MAP_PRIVATE|MAP_HUGETLB,\n                 -1, 0);\n\n  if (p != MAP_FAILED) {\n    // We don't know if this really is a huge page or not.\n    FILE *fp = fopen(\"/proc/self/maps\", \"r\");\n    if (fp) {\n      while (!feof(fp)) {\n        char chars[257];\n        long x = 0;\n        if (fgets(chars, sizeof(chars), fp)) {\n          if (sscanf(chars, \"%lx-%*x\", &x) == 1\n              && x == (long)p) {\n            if (strstr (chars, \"hugepage\")) {\n              result = true;\n              break;\n            }\n          }\n        }\n      }\n      fclose(fp);\n    }\n    munmap(p, page_size);\n  }\n\n  if (warn && !result) {\n    warning(\"HugeTLBFS is not supported by the operating system.\");\n  }\n\n  return result;\n}\n\n/*\n* Set the coredump_filter bits to include largepages in core dump (bit 6)\n*\n* From the coredump_filter documentation:\n*\n* - (bit 0) anonymous private memory\n* - (bit 1) anonymous shared memory\n* - (bit 2) file-backed private memory\n* - (bit 3) file-backed shared memory\n* - (bit 4) ELF header pages in file-backed private memory areas (it is\n*           effective only if the bit 2 is cleared)\n* - (bit 5) hugetlb private memory\n* - (bit 6) hugetlb shared memory\n*/\nstatic void set_coredump_filter(void) {\n  FILE *f;\n  long cdm;\n\n  if ((f = fopen(\"/proc/self/coredump_filter\", \"r+\")) == NULL) {\n    return;\n  }\n\n  if (fscanf(f, \"%lx\", &cdm) != 1) {\n    fclose(f);\n    return;\n  }\n\n  rewind(f);\n\n  if ((cdm & LARGEPAGES_BIT) == 0) {\n    cdm |= LARGEPAGES_BIT;\n    fprintf(f, \"%#lx\", cdm);\n  }\n\n  fclose(f);\n}\n\n// Large page support\n\nstatic size_t _large_page_size = 0;\n\nsize_t os::Linux::find_large_page_size() {\n  size_t large_page_size = 0;\n\n  // large_page_size on Linux is used to round up heap size. x86 uses either\n  // 2M or 4M page, depending on whether PAE (Physical Address Extensions)\n  // mode is enabled. AMD64/EM64T uses 2M page in 64bit mode. IA64 can use\n  // page as large as 256M.\n  //\n  // Here we try to figure out page size by parsing /proc/meminfo and looking\n  // for a line with the following format:\n  //    Hugepagesize:     2048 kB\n  //\n  // If we can't determine the value (e.g. /proc is not mounted, or the text\n  // format has been changed), we'll use the largest page size supported by\n  // the processor.\n\n#ifndef ZERO\n  large_page_size = IA32_ONLY(4 * M) AMD64_ONLY(2 * M) IA64_ONLY(256 * M) SPARC_ONLY(4 * M)\n                     ARM_ONLY(2 * M) PPC_ONLY(4 * M) AARCH64_ONLY(2 * M);\n#endif // ZERO\n\n  FILE *fp = fopen(\"/proc/meminfo\", \"r\");\n  if (fp) {\n    while (!feof(fp)) {\n      int x = 0;\n      char buf[16];\n      if (fscanf(fp, \"Hugepagesize: %d\", &x) == 1) {\n        if (x && fgets(buf, sizeof(buf), fp) && strcmp(buf, \" kB\\n\") == 0) {\n          large_page_size = x * K;\n          break;\n        }\n      } else {\n        // skip to next line\n        for (;;) {\n          int ch = fgetc(fp);\n          if (ch == EOF || ch == (int)'\\n') break;\n        }\n      }\n    }\n    fclose(fp);\n  }\n\n  if (!FLAG_IS_DEFAULT(LargePageSizeInBytes) && LargePageSizeInBytes != large_page_size) {\n    warning(\"Setting LargePageSizeInBytes has no effect on this OS. Large page size is \"\n        SIZE_FORMAT \"%s.\", byte_size_in_proper_unit(large_page_size),\n        proper_unit_for_byte_size(large_page_size));\n  }\n\n  return large_page_size;\n}\n\nsize_t os::Linux::setup_large_page_size() {\n  _large_page_size = Linux::find_large_page_size();\n  const size_t default_page_size = (size_t)Linux::page_size();\n  if (_large_page_size > default_page_size) {\n    _page_sizes[0] = _large_page_size;\n    _page_sizes[1] = default_page_size;\n    _page_sizes[2] = 0;\n  }\n\n  return _large_page_size;\n}\n\nbool os::Linux::setup_large_page_type(size_t page_size) {\n  if (FLAG_IS_DEFAULT(UseHugeTLBFS) &&\n      FLAG_IS_DEFAULT(UseSHM) &&\n      FLAG_IS_DEFAULT(UseTransparentHugePages)) {\n\n    // The type of large pages has not been specified by the user.\n\n    // Try UseHugeTLBFS and then UseSHM.\n    UseHugeTLBFS = UseSHM = true;\n\n    // Don't try UseTransparentHugePages since there are known\n    // performance issues with it turned on. This might change in the future.\n    UseTransparentHugePages = false;\n  }\n\n  if (UseTransparentHugePages) {\n    bool warn_on_failure = !FLAG_IS_DEFAULT(UseTransparentHugePages);\n    if (transparent_huge_pages_sanity_check(warn_on_failure, page_size)) {\n      UseHugeTLBFS = false;\n      UseSHM = false;\n      return true;\n    }\n    UseTransparentHugePages = false;\n  }\n\n  if (UseHugeTLBFS) {\n    bool warn_on_failure = !FLAG_IS_DEFAULT(UseHugeTLBFS);\n    if (hugetlbfs_sanity_check(warn_on_failure, page_size)) {\n      UseSHM = false;\n      return true;\n    }\n    UseHugeTLBFS = false;\n  }\n\n  return UseSHM;\n}\n\nvoid os::large_page_init() {\n  if (!UseLargePages &&\n      !UseTransparentHugePages &&\n      !UseHugeTLBFS &&\n      !UseSHM) {\n    // Not using large pages.\n    return;\n  }\n\n  if (!FLAG_IS_DEFAULT(UseLargePages) && !UseLargePages) {\n    // The user explicitly turned off large pages.\n    // Ignore the rest of the large pages flags.\n    UseTransparentHugePages = false;\n    UseHugeTLBFS = false;\n    UseSHM = false;\n    return;\n  }\n\n  size_t large_page_size = Linux::setup_large_page_size();\n  UseLargePages          = Linux::setup_large_page_type(large_page_size);\n\n  set_coredump_filter();\n}\n\n#ifndef SHM_HUGETLB\n#define SHM_HUGETLB 04000\n#endif\n\n#define shm_warning_format(format, ...)              \\\n  do {                                               \\\n    if (UseLargePages &&                             \\\n        (!FLAG_IS_DEFAULT(UseLargePages) ||          \\\n         !FLAG_IS_DEFAULT(UseSHM) ||                 \\\n         !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {  \\\n      warning(format, __VA_ARGS__);                  \\\n    }                                                \\\n  } while (0)\n\n#define shm_warning(str) shm_warning_format(\"%s\", str)\n\n#define shm_warning_with_errno(str)                \\\n  do {                                             \\\n    int err = errno;                               \\\n    shm_warning_format(str \" (error = %d)\", err);  \\\n  } while (0)\n\nstatic char* shmat_with_alignment(int shmid, size_t bytes, size_t alignment) {\n  assert(is_size_aligned(bytes, alignment), \"Must be divisible by the alignment\");\n\n  if (!is_size_aligned(alignment, SHMLBA)) {\n    assert(false, \"Code below assumes that alignment is at least SHMLBA aligned\");\n    return NULL;\n  }\n\n  // To ensure that we get 'alignment' aligned memory from shmat,\n  // we pre-reserve aligned virtual memory and then attach to that.\n\n  char* pre_reserved_addr = anon_mmap_aligned(bytes, alignment, NULL);\n  if (pre_reserved_addr == NULL) {\n    // Couldn't pre-reserve aligned memory.\n    shm_warning(\"Failed to pre-reserve aligned memory for shmat.\");\n    return NULL;\n  }\n\n  // SHM_REMAP is needed to allow shmat to map over an existing mapping.\n  char* addr = (char*)shmat(shmid, pre_reserved_addr, SHM_REMAP);\n\n  if ((intptr_t)addr == -1) {\n    int err = errno;\n    shm_warning_with_errno(\"Failed to attach shared memory.\");\n\n    assert(err != EACCES, \"Unexpected error\");\n    assert(err != EIDRM,  \"Unexpected error\");\n    assert(err != EINVAL, \"Unexpected error\");\n\n    // Since we don't know if the kernel unmapped the pre-reserved memory area\n    // we can't unmap it, since that would potentially unmap memory that was\n    // mapped from other threads.\n    return NULL;\n  }\n\n  return addr;\n}\n\nstatic char* shmat_at_address(int shmid, char* req_addr) {\n  if (!is_ptr_aligned(req_addr, SHMLBA)) {\n    assert(false, \"Requested address needs to be SHMLBA aligned\");\n    return NULL;\n  }\n\n  char* addr = (char*)shmat(shmid, req_addr, 0);\n\n  if ((intptr_t)addr == -1) {\n    shm_warning_with_errno(\"Failed to attach shared memory.\");\n    return NULL;\n  }\n\n  return addr;\n}\n\nstatic char* shmat_large_pages(int shmid, size_t bytes, size_t alignment, char* req_addr) {\n  // If a req_addr has been provided, we assume that the caller has already aligned the address.\n  if (req_addr != NULL) {\n    assert(is_ptr_aligned(req_addr, os::large_page_size()), \"Must be divisible by the large page size\");\n    assert(is_ptr_aligned(req_addr, alignment), \"Must be divisible by given alignment\");\n    return shmat_at_address(shmid, req_addr);\n  }\n\n  // Since shmid has been setup with SHM_HUGETLB, shmat will automatically\n  // return large page size aligned memory addresses when req_addr == NULL.\n  // However, if the alignment is larger than the large page size, we have\n  // to manually ensure that the memory returned is 'alignment' aligned.\n  if (alignment > os::large_page_size()) {\n    assert(is_size_aligned(alignment, os::large_page_size()), \"Must be divisible by the large page size\");\n    return shmat_with_alignment(shmid, bytes, alignment);\n  } else {\n    return shmat_at_address(shmid, NULL);\n  }\n}\n\nchar* os::Linux::reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  // \"exec\" is passed in but not used.  Creating the shared image for\n  // the code cache doesn't have an SHM_X executable permission to check.\n  assert(UseLargePages && UseSHM, \"only for SHM large pages\");\n  assert(is_ptr_aligned(req_addr, os::large_page_size()), \"Unaligned address\");\n  assert(is_ptr_aligned(req_addr, alignment), \"Unaligned address\");\n\n  if (!is_size_aligned(bytes, os::large_page_size())) {\n    return NULL; // Fallback to small pages.\n  }\n\n  // Create a large shared memory region to attach to based on size.\n  // Currently, size is the total size of the heap.\n  int shmid = shmget(IPC_PRIVATE, bytes, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W);\n  if (shmid == -1) {\n    // Possible reasons for shmget failure:\n    // 1. shmmax is too small for Java heap.\n    //    > check shmmax value: cat /proc/sys/kernel/shmmax\n    //    > increase shmmax value: echo \"0xffffffff\" > /proc/sys/kernel/shmmax\n    // 2. not enough large page memory.\n    //    > check available large pages: cat /proc/meminfo\n    //    > increase amount of large pages:\n    //          echo new_value > /proc/sys/vm/nr_hugepages\n    //      Note 1: different Linux may use different name for this property,\n    //            e.g. on Redhat AS-3 it is \"hugetlb_pool\".\n    //      Note 2: it's possible there's enough physical memory available but\n    //            they are so fragmented after a long run that they can't\n    //            coalesce into large pages. Try to reserve large pages when\n    //            the system is still \"fresh\".\n    shm_warning_with_errno(\"Failed to reserve shared memory.\");\n    return NULL;\n  }\n\n  // Attach to the region.\n  char* addr = shmat_large_pages(shmid, bytes, alignment, req_addr);\n\n  // Remove shmid. If shmat() is successful, the actual shared memory segment\n  // will be deleted when it's detached by shmdt() or when the process\n  // terminates. If shmat() is not successful this will remove the shared\n  // segment immediately.\n  shmctl(shmid, IPC_RMID, NULL);\n\n  return addr;\n}\n\nstatic void warn_on_large_pages_failure(char* req_addr, size_t bytes, int error) {\n  assert(error == ENOMEM, \"Only expect to fail if no memory is available\");\n\n  bool warn_on_failure = UseLargePages &&\n      (!FLAG_IS_DEFAULT(UseLargePages) ||\n       !FLAG_IS_DEFAULT(UseHugeTLBFS) ||\n       !FLAG_IS_DEFAULT(LargePageSizeInBytes));\n\n  if (warn_on_failure) {\n    char msg[128];\n    jio_snprintf(msg, sizeof(msg), \"Failed to reserve large pages memory req_addr: \"\n        PTR_FORMAT \" bytes: \" SIZE_FORMAT \" (errno = %d).\", req_addr, bytes, error);\n    warning(\"%s\", msg);\n  }\n}\n\nchar* os::Linux::reserve_memory_special_huge_tlbfs_only(size_t bytes, char* req_addr, bool exec) {\n  assert(UseLargePages && UseHugeTLBFS, \"only for Huge TLBFS large pages\");\n  assert(is_size_aligned(bytes, os::large_page_size()), \"Unaligned size\");\n  assert(is_ptr_aligned(req_addr, os::large_page_size()), \"Unaligned address\");\n\n  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n  char* addr = (char*)::mmap(req_addr, bytes, prot,\n                             MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB,\n                             -1, 0);\n\n  if (addr == MAP_FAILED) {\n    warn_on_large_pages_failure(req_addr, bytes, errno);\n    return NULL;\n  }\n\n  assert(is_ptr_aligned(addr, os::large_page_size()), \"Must be\");\n\n  return addr;\n}\n\n// Reserve memory using mmap(MAP_HUGETLB).\n//  - bytes shall be a multiple of alignment.\n//  - req_addr can be NULL. If not NULL, it must be a multiple of alignment.\n//  - alignment sets the alignment at which memory shall be allocated.\n//     It must be a multiple of allocation granularity.\n// Returns address of memory or NULL. If req_addr was not NULL, will only return\n//  req_addr or NULL.\nchar* os::Linux::reserve_memory_special_huge_tlbfs_mixed(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  size_t large_page_size = os::large_page_size();\n  assert(bytes >= large_page_size, \"Shouldn't allocate large pages for small sizes\");\n\n  assert(is_ptr_aligned(req_addr, alignment), \"Must be\");\n  assert(is_size_aligned(bytes, alignment), \"Must be\");\n\n  // First reserve - but not commit - the address range in small pages.\n  char* const start = anon_mmap_aligned(bytes, alignment, req_addr);\n\n  if (start == NULL) {\n    return NULL;\n  }\n\n  assert(is_ptr_aligned(start, alignment), \"Must be\");\n\n  char* end = start + bytes;\n\n  // Find the regions of the allocated chunk that can be promoted to large pages.\n  char* lp_start = (char*)align_ptr_up(start, large_page_size);\n  char* lp_end   = (char*)align_ptr_down(end, large_page_size);\n\n  size_t lp_bytes = lp_end - lp_start;\n\n  assert(is_size_aligned(lp_bytes, large_page_size), \"Must be\");\n\n  if (lp_bytes == 0) {\n    // The mapped region doesn't even span the start and the end of a large page.\n    // Fall back to allocate a non-special area.\n    ::munmap(start, end - start);\n    return NULL;\n  }\n\n  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n\n  void* result;\n\n  // Commit small-paged leading area.\n  if (start != lp_start) {\n    result = ::mmap(start, lp_start - start, prot,\n                    MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,\n                    -1, 0);\n    if (result == MAP_FAILED) {\n      ::munmap(lp_start, end - lp_start);\n      return NULL;\n    }\n  }\n\n  // Commit large-paged area.\n  result = ::mmap(lp_start, lp_bytes, prot,\n                  MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED|MAP_HUGETLB,\n                  -1, 0);\n  if (result == MAP_FAILED) {\n    warn_on_large_pages_failure(lp_start, lp_bytes, errno);\n    // If the mmap above fails, the large pages region will be unmapped and we\n    // have regions before and after with small pages. Release these regions.\n    //\n    // |  mapped  |  unmapped  |  mapped  |\n    // ^          ^            ^          ^\n    // start      lp_start     lp_end     end\n    //\n    ::munmap(start, lp_start - start);\n    ::munmap(lp_end, end - lp_end);\n    return NULL;\n  }\n\n  // Commit small-paged trailing area.\n  if (lp_end != end) {\n      result = ::mmap(lp_end, end - lp_end, prot,\n                      MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,\n                      -1, 0);\n    if (result == MAP_FAILED) {\n      ::munmap(start, lp_end - start);\n      return NULL;\n    }\n  }\n\n  return start;\n}\n\nchar* os::Linux::reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  assert(UseLargePages && UseHugeTLBFS, \"only for Huge TLBFS large pages\");\n  assert(is_ptr_aligned(req_addr, alignment), \"Must be\");\n  assert(is_size_aligned(alignment, os::vm_allocation_granularity()), \"Must be\");\n  assert(is_power_of_2(os::large_page_size()), \"Must be\");\n  assert(bytes >= os::large_page_size(), \"Shouldn't allocate large pages for small sizes\");\n\n  if (is_size_aligned(bytes, os::large_page_size()) && alignment <= os::large_page_size()) {\n    return reserve_memory_special_huge_tlbfs_only(bytes, req_addr, exec);\n  } else {\n    return reserve_memory_special_huge_tlbfs_mixed(bytes, alignment, req_addr, exec);\n  }\n}\n\nchar* os::reserve_memory_special(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  assert(UseLargePages, \"only for large pages\");\n\n  char* addr;\n  if (UseSHM) {\n    addr = os::Linux::reserve_memory_special_shm(bytes, alignment, req_addr, exec);\n  } else {\n    assert(UseHugeTLBFS, \"must be\");\n    addr = os::Linux::reserve_memory_special_huge_tlbfs(bytes, alignment, req_addr, exec);\n  }\n\n  if (addr != NULL) {\n    if (UseNUMAInterleaving) {\n      numa_make_global(addr, bytes);\n    }\n\n    // The memory is committed\n    MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);\n  }\n\n  return addr;\n}\n\nbool os::Linux::release_memory_special_shm(char* base, size_t bytes) {\n  // detaching the SHM segment will also delete it, see reserve_memory_special_shm()\n  return shmdt(base) == 0;\n}\n\nbool os::Linux::release_memory_special_huge_tlbfs(char* base, size_t bytes) {\n  return pd_release_memory(base, bytes);\n}\n\nbool os::release_memory_special(char* base, size_t bytes) {\n  bool res;\n  if (MemTracker::tracking_level() > NMT_minimal) {\n    Tracker tkr = MemTracker::get_virtual_memory_release_tracker();\n    res = os::Linux::release_memory_special_impl(base, bytes);\n    if (res) {\n      tkr.record((address)base, bytes);\n    }\n\n  } else {\n    res = os::Linux::release_memory_special_impl(base, bytes);\n  }\n  return res;\n}\n\nbool os::Linux::release_memory_special_impl(char* base, size_t bytes) {\n  assert(UseLargePages, \"only for large pages\");\n  bool res;\n\n  if (UseSHM) {\n    res = os::Linux::release_memory_special_shm(base, bytes);\n  } else {\n    assert(UseHugeTLBFS, \"must be\");\n    res = os::Linux::release_memory_special_huge_tlbfs(base, bytes);\n  }\n  return res;\n}\n\nsize_t os::large_page_size() {\n  return _large_page_size;\n}\n\n// With SysV SHM the entire memory region must be allocated as shared\n// memory.\n// HugeTLBFS allows application to commit large page memory on demand.\n// However, when committing memory with HugeTLBFS fails, the region\n// that was supposed to be committed will lose the old reservation\n// and allow other threads to steal that memory region. Because of this\n// behavior we can't commit HugeTLBFS memory.\nbool os::can_commit_large_page_memory() {\n  return UseTransparentHugePages;\n}\n\nbool os::can_execute_large_page_memory() {\n  return UseTransparentHugePages || UseHugeTLBFS;\n}\n\n// Reserve memory at an arbitrary address, only if that area is\n// available (and not reserved for something else).\n\nchar* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {\n  const int max_tries = 10;\n  char* base[max_tries];\n  size_t size[max_tries];\n  const size_t gap = 0x000000;\n\n  // Assert only that the size is a multiple of the page size, since\n  // that's all that mmap requires, and since that's all we really know\n  // about at this low abstraction level.  If we need higher alignment,\n  // we can either pass an alignment to this method or verify alignment\n  // in one of the methods further up the call chain.  See bug 5044738.\n  assert(bytes % os::vm_page_size() == 0, \"reserving unexpected size block\");\n\n  // Repeatedly allocate blocks until the block is allocated at the\n  // right spot. Give up after max_tries. Note that reserve_memory() will\n  // automatically update _highest_vm_reserved_address if the call is\n  // successful. The variable tracks the highest memory address every reserved\n  // by JVM. It is used to detect heap-stack collision if running with\n  // fixed-stack LinuxThreads. Because here we may attempt to reserve more\n  // space than needed, it could confuse the collision detecting code. To\n  // solve the problem, save current _highest_vm_reserved_address and\n  // calculate the correct value before return.\n  address old_highest = _highest_vm_reserved_address;\n\n  // Linux mmap allows caller to pass an address as hint; give it a try first,\n  // if kernel honors the hint then we can return immediately.\n  char * addr = anon_mmap(requested_addr, bytes, false);\n  if (addr == requested_addr) {\n     return requested_addr;\n  }\n\n  if (addr != NULL) {\n     // mmap() is successful but it fails to reserve at the requested address\n     anon_munmap(addr, bytes);\n  }\n\n  int i;\n  for (i = 0; i < max_tries; ++i) {\n    base[i] = reserve_memory(bytes);\n\n    if (base[i] != NULL) {\n      // Is this the block we wanted?\n      if (base[i] == requested_addr) {\n        size[i] = bytes;\n        break;\n      }\n\n      // Does this overlap the block we wanted? Give back the overlapped\n      // parts and try again.\n\n      size_t top_overlap = requested_addr + (bytes + gap) - base[i];\n      if (top_overlap >= 0 && top_overlap < bytes) {\n        unmap_memory(base[i], top_overlap);\n        base[i] += top_overlap;\n        size[i] = bytes - top_overlap;\n      } else {\n        size_t bottom_overlap = base[i] + bytes - requested_addr;\n        if (bottom_overlap >= 0 && bottom_overlap < bytes) {\n          unmap_memory(requested_addr, bottom_overlap);\n          size[i] = bytes - bottom_overlap;\n        } else {\n          size[i] = bytes;\n        }\n      }\n    }\n  }\n\n  // Give back the unused reserved pieces.\n\n  for (int j = 0; j < i; ++j) {\n    if (base[j] != NULL) {\n      unmap_memory(base[j], size[j]);\n    }\n  }\n\n  if (i < max_tries) {\n    _highest_vm_reserved_address = MAX2(old_highest, (address)requested_addr + bytes);\n    return requested_addr;\n  } else {\n    _highest_vm_reserved_address = old_highest;\n    return NULL;\n  }\n}\n\nsize_t os::read(int fd, void *buf, unsigned int nBytes) {\n  return ::read(fd, buf, nBytes);\n}\n\n// TODO-FIXME: reconcile Solaris' os::sleep with the linux variation.\n// Solaris uses poll(), linux uses park().\n// Poll() is likely a better choice, assuming that Thread.interrupt()\n// generates a SIGUSRx signal. Note that SIGUSR1 can interfere with\n// SIGSEGV, see 4355769.\n\nint os::sleep(Thread* thread, jlong millis, bool interruptible) {\n  assert(thread == Thread::current(),  \"thread consistency check\");\n\n  ParkEvent * const slp = thread->_SleepEvent ;\n  slp->reset() ;\n  OrderAccess::fence() ;\n\n  if (interruptible) {\n    jlong prevtime = javaTimeNanos();\n\n    for (;;) {\n      if (os::is_interrupted(thread, true)) {\n        return OS_INTRPT;\n      }\n\n      jlong newtime = javaTimeNanos();\n\n      if (newtime - prevtime < 0) {\n        // time moving backwards, should only happen if no monotonic clock\n        // not a guarantee() because JVM should not abort on kernel/glibc bugs\n        assert(!Linux::supports_monotonic_clock(), \"time moving backwards\");\n      } else {\n        millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n      }\n\n      if(millis <= 0) {\n        return OS_OK;\n      }\n\n      prevtime = newtime;\n\n      {\n        assert(thread->is_Java_thread(), \"sanity check\");\n        JavaThread *jt = (JavaThread *) thread;\n        ThreadBlockInVM tbivm(jt);\n        OSThreadWaitState osts(jt->osthread(), false /* not Object.wait() */);\n\n        jt->set_suspend_equivalent();\n        // cleared by handle_special_suspend_equivalent_condition() or\n        // java_suspend_self() via check_and_wait_while_suspended()\n\n        slp->park(millis);\n\n        // were we externally suspended while we were waiting?\n        jt->check_and_wait_while_suspended();\n      }\n    }\n  } else {\n    OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n    jlong prevtime = javaTimeNanos();\n\n    for (;;) {\n      // It'd be nice to avoid the back-to-back javaTimeNanos() calls on\n      // the 1st iteration ...\n      jlong newtime = javaTimeNanos();\n\n      if (newtime - prevtime < 0) {\n        // time moving backwards, should only happen if no monotonic clock\n        // not a guarantee() because JVM should not abort on kernel/glibc bugs\n        assert(!Linux::supports_monotonic_clock(), \"time moving backwards\");\n      } else {\n        millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n      }\n\n      if(millis <= 0) break ;\n\n      prevtime = newtime;\n      slp->park(millis);\n    }\n    return OS_OK ;\n  }\n}\n\n//\n// Short sleep, direct OS call.\n//\n// Note: certain versions of Linux CFS scheduler (since 2.6.23) do not guarantee\n// sched_yield(2) will actually give up the CPU:\n//\n//   * Alone on this pariticular CPU, keeps running.\n//   * Before the introduction of \"skip_buddy\" with \"compat_yield\" disabled\n//     (pre 2.6.39).\n//\n// So calling this with 0 is an alternative.\n//\nvoid os::naked_short_sleep(jlong ms) {\n  struct timespec req;\n\n  assert(ms < 1000, \"Un-interruptable sleep, short time use only\");\n  req.tv_sec = 0;\n  if (ms > 0) {\n    req.tv_nsec = (ms % 1000) * 1000000;\n  }\n  else {\n    req.tv_nsec = 1;\n  }\n\n  nanosleep(&req, NULL);\n\n  return;\n}\n\n// Sleep forever; naked call to OS-specific sleep; use with CAUTION\nvoid os::infinite_sleep() {\n  while (true) {    // sleep forever ...\n    ::sleep(100);   // ... 100 seconds at a time\n  }\n}\n\n// Used to convert frequent JVM_Yield() to nops\nbool os::dont_yield() {\n  return DontYieldALot;\n}\n\nvoid os::yield() {\n  sched_yield();\n}\n\nos::YieldResult os::NakedYield() { sched_yield(); return os::YIELD_UNKNOWN ;}\n\nvoid os::yield_all(int attempts) {\n  // Yields to all threads, including threads with lower priorities\n  // Threads on Linux are all with same priority. The Solaris style\n  // os::yield_all() with nanosleep(1ms) is not necessary.\n  sched_yield();\n}\n\n// Called from the tight loops to possibly influence time-sharing heuristics\nvoid os::loop_breaker(int attempts) {\n  os::yield_all(attempts);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// thread priority support\n\n// Note: Normal Linux applications are run with SCHED_OTHER policy. SCHED_OTHER\n// only supports dynamic priority, static priority must be zero. For real-time\n// applications, Linux supports SCHED_RR which allows static priority (1-99).\n// However, for large multi-threaded applications, SCHED_RR is not only slower\n// than SCHED_OTHER, but also very unstable (my volano tests hang hard 4 out\n// of 5 runs - Sep 2005).\n//\n// The following code actually changes the niceness of kernel-thread/LWP. It\n// has an assumption that setpriority() only modifies one kernel-thread/LWP,\n// not the entire user process, and user level threads are 1:1 mapped to kernel\n// threads. It has always been the case, but could change in the future. For\n// this reason, the code should not be used as default (ThreadPriorityPolicy=0).\n// It is only used when ThreadPriorityPolicy=1 and requires root privilege.\n\nint os::java_to_os_priority[CriticalPriority + 1] = {\n  19,              // 0 Entry should never be used\n\n   4,              // 1 MinPriority\n   3,              // 2\n   2,              // 3\n\n   1,              // 4\n   0,              // 5 NormPriority\n  -1,              // 6\n\n  -2,              // 7\n  -3,              // 8\n  -4,              // 9 NearMaxPriority\n\n  -5,              // 10 MaxPriority\n\n  -5               // 11 CriticalPriority\n};\n\nstatic int prio_init() {\n  if (ThreadPriorityPolicy == 1) {\n    // Only root can raise thread priority. Don't allow ThreadPriorityPolicy=1\n    // if effective uid is not root. Perhaps, a more elegant way of doing\n    // this is to test CAP_SYS_NICE capability, but that will require libcap.so\n    if (geteuid() != 0) {\n      if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {\n        warning(\"-XX:ThreadPriorityPolicy requires root privilege on Linux\");\n      }\n      ThreadPriorityPolicy = 0;\n    }\n  }\n  if (UseCriticalJavaThreadPriority) {\n    os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];\n  }\n  return 0;\n}\n\nOSReturn os::set_native_priority(Thread* thread, int newpri) {\n  if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) return OS_OK;\n\n  int ret = setpriority(PRIO_PROCESS, thread->osthread()->thread_id(), newpri);\n  return (ret == 0) ? OS_OK : OS_ERR;\n}\n\nOSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {\n  if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) {\n    *priority_ptr = java_to_os_priority[NormPriority];\n    return OS_OK;\n  }\n\n  errno = 0;\n  *priority_ptr = getpriority(PRIO_PROCESS, thread->osthread()->thread_id());\n  return (*priority_ptr != -1 || errno == 0 ? OS_OK : OS_ERR);\n}\n\n// Hint to the underlying OS that a task switch would not be good.\n// Void return because it's a hint and can fail.\nvoid os::hint_no_preempt() {}\n\n////////////////////////////////////////////////////////////////////////////////\n// suspend/resume support\n\n//  the low-level signal-based suspend/resume support is a remnant from the\n//  old VM-suspension that used to be for java-suspension, safepoints etc,\n//  within hotspot. Now there is a single use-case for this:\n//    - calling get_thread_pc() on the VMThread by the flat-profiler task\n//      that runs in the watcher thread.\n//  The remaining code is greatly simplified from the more general suspension\n//  code that used to be used.\n//\n//  The protocol is quite simple:\n//  - suspend:\n//      - sends a signal to the target thread\n//      - polls the suspend state of the osthread using a yield loop\n//      - target thread signal handler (SR_handler) sets suspend state\n//        and blocks in sigsuspend until continued\n//  - resume:\n//      - sets target osthread state to continue\n//      - sends signal to end the sigsuspend loop in the SR_handler\n//\n//  Note that the SR_lock plays no role in this suspend/resume protocol.\n//\n\nstatic void resume_clear_context(OSThread *osthread) {\n  osthread->set_ucontext(NULL);\n  osthread->set_siginfo(NULL);\n}\n\nstatic void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n  osthread->set_ucontext(context);\n  osthread->set_siginfo(siginfo);\n}\n\n//\n// Handler function invoked when a thread's execution is suspended or\n// resumed. We have to be careful that only async-safe functions are\n// called here (Note: most pthread functions are not async safe and\n// should be avoided.)\n//\n// Note: sigwait() is a more natural fit than sigsuspend() from an\n// interface point of view, but sigwait() prevents the signal hander\n// from being run. libpthread would get very confused by not having\n// its signal handlers run and prevents sigwait()'s use with the\n// mutex granting granting signal.\n//\n// Currently only ever called on the VMThread and JavaThreads (PC sampling)\n//\nstatic void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n  // Save and restore errno to avoid confusing native code with EINTR\n  // after sigsuspend.\n  int old_errno = errno;\n\n  Thread* thread = Thread::current();\n  OSThread* osthread = thread->osthread();\n  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n\n  os::SuspendResume::State current = osthread->sr.state();\n  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n    suspend_save_context(osthread, siginfo, context);\n\n    // attempt to switch the state, we assume we had a SUSPEND_REQUEST\n    os::SuspendResume::State state = osthread->sr.suspended();\n    if (state == os::SuspendResume::SR_SUSPENDED) {\n      sigset_t suspend_set;  // signals for sigsuspend()\n\n      // get current set of blocked signals and unblock resume signal\n      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n      sigdelset(&suspend_set, SR_signum);\n\n      sr_semaphore.signal();\n      // wait here until we are resumed\n      while (1) {\n        sigsuspend(&suspend_set);\n\n        os::SuspendResume::State result = osthread->sr.running();\n        if (result == os::SuspendResume::SR_RUNNING) {\n          sr_semaphore.signal();\n          break;\n        }\n      }\n\n    } else if (state == os::SuspendResume::SR_RUNNING) {\n      // request was cancelled, continue\n    } else {\n      ShouldNotReachHere();\n    }\n\n    resume_clear_context(osthread);\n  } else if (current == os::SuspendResume::SR_RUNNING) {\n    // request was cancelled, continue\n  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // ignore\n  } else {\n    // ignore\n  }\n\n  errno = old_errno;\n}\n\n\nstatic int SR_initialize() {\n  struct sigaction act;\n  char *s;\n  /* Get signal number to use for suspend/resume */\n  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n    int sig = ::strtol(s, 0, 10);\n    if (sig > 0 || sig < _NSIG) {\n        SR_signum = sig;\n    }\n  }\n\n  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n        \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n\n  sigemptyset(&SR_sigset);\n  sigaddset(&SR_sigset, SR_signum);\n\n  /* Set up signal handler for suspend/resume */\n  act.sa_flags = SA_RESTART|SA_SIGINFO;\n  act.sa_handler = (void (*)(int)) SR_handler;\n\n  // SR_signum is blocked by default.\n  // 4528190 - We also need to block pthread restart signal (32 on all\n  // supported Linux platforms). Note that LinuxThreads need to block\n  // this signal for all threads to work properly. So we don't have\n  // to use hard-coded signal number when setting up the mask.\n  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n\n  if (sigaction(SR_signum, &act, 0) == -1) {\n    return -1;\n  }\n\n  // Save signal flag\n  os::Linux::set_our_sigflags(SR_signum, act.sa_flags);\n  return 0;\n}\n\nstatic int sr_notify(OSThread* osthread) {\n  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n  assert_status(status == 0, status, \"pthread_kill\");\n  return status;\n}\n\n// \"Randomly\" selected value for how long we want to spin\n// before bailing out on suspending a thread, also how often\n// we send a signal to a thread we want to resume\nstatic const int RANDOMLY_LARGE_INTEGER = 1000000;\nstatic const int RANDOMLY_LARGE_INTEGER2 = 100;\n\n// returns true on success and false on error - really an error is fatal\n// but this seems the normal response to library errors\nstatic bool do_suspend(OSThread* osthread) {\n  assert(osthread->sr.is_running(), \"thread should be running\");\n  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n\n  // mark as suspended and send signal\n  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n    // failed to switch, state wasn't running?\n    ShouldNotReachHere();\n    return false;\n  }\n\n  if (sr_notify(osthread) != 0) {\n    ShouldNotReachHere();\n  }\n\n  // managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n  while (true) {\n    if (sr_semaphore.timedwait(0, 2 * NANOSECS_PER_MILLISEC)) {\n      break;\n    } else {\n      // timeout\n      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n      if (cancelled == os::SuspendResume::SR_RUNNING) {\n        return false;\n      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n        // make sure that we consume the signal on the semaphore as well\n        sr_semaphore.wait();\n        break;\n      } else {\n        ShouldNotReachHere();\n        return false;\n      }\n    }\n  }\n\n  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n  return true;\n}\n\nstatic void do_resume(OSThread* osthread) {\n  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n\n  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // failed to switch to WAKEUP_REQUEST\n    ShouldNotReachHere();\n    return;\n  }\n\n  while (true) {\n    if (sr_notify(osthread) == 0) {\n      if (sr_semaphore.timedwait(0, 2 * NANOSECS_PER_MILLISEC)) {\n        if (osthread->sr.is_running()) {\n          return;\n        }\n      }\n    } else {\n      ShouldNotReachHere();\n    }\n  }\n\n  guarantee(osthread->sr.is_running(), \"Must be running!\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// interrupt support\n\nvoid os::interrupt(Thread* thread) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  if (!osthread->interrupted()) {\n    osthread->set_interrupted(true);\n    // More than one thread can get here with the same value of osthread,\n    // resulting in multiple notifications.  We do, however, want the store\n    // to interrupted() to be visible to other threads before we execute unpark().\n    OrderAccess::fence();\n    ParkEvent * const slp = thread->_SleepEvent ;\n    if (slp != NULL) slp->unpark() ;\n  }\n\n  // For JSR166. Unpark even if interrupt status already was set\n  if (thread->is_Java_thread())\n    ((JavaThread*)thread)->parker()->unpark();\n\n  ParkEvent * ev = thread->_ParkEvent ;\n  if (ev != NULL) ev->unpark() ;\n\n}\n\nbool os::is_interrupted(Thread* thread, bool clear_interrupted) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  bool interrupted = osthread->interrupted();\n\n  if (interrupted && clear_interrupted) {\n    osthread->set_interrupted(false);\n    // consider thread->_SleepEvent->reset() ... optional optimization\n  }\n\n  return interrupted;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// signal handling (except suspend/resume)\n\n// This routine may be used by user applications as a \"hook\" to catch signals.\n// The user-defined signal handler must pass unrecognized signals to this\n// routine, and if it returns true (non-zero), then the signal handler must\n// return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n// routine will never retun false (zero), but instead will execute a VM panic\n// routine kill the process.\n//\n// If this routine returns false, it is OK to call it again.  This allows\n// the user-defined signal handler to perform checks either before or after\n// the VM performs its own checks.  Naturally, the user code would be making\n// a serious error if it tried to handle an exception (such as a null check\n// or breakpoint) that the VM was generating for its own correct operation.\n//\n// This routine may recognize any of the following kinds of signals:\n//    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n// It should be consulted by handlers for any of those signals.\n//\n// The caller of this routine must pass in the three arguments supplied\n// to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n// field of the structure passed to sigaction().  This routine assumes that\n// the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n//\n// Note that the VM will print warnings if it detects conflicting signal\n// handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n//\nextern \"C\" JNIEXPORT int\nJVM_handle_linux_signal(int signo, siginfo_t* siginfo,\n                        void* ucontext, int abort_if_unrecognized);\n\nvoid signalHandler(int sig, siginfo_t* info, void* uc) {\n  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n  int orig_errno = errno;  // Preserve errno value over signal handler.\n  JVM_handle_linux_signal(sig, info, uc, true);\n  errno = orig_errno;\n}\n\n\n// This boolean allows users to forward their own non-matching signals\n// to JVM_handle_linux_signal, harmlessly.\nbool os::Linux::signal_handlers_are_installed = false;\n\n// For signal-chaining\nstruct sigaction os::Linux::sigact[MAXSIGNUM];\nunsigned int os::Linux::sigs = 0;\nbool os::Linux::libjsig_is_loaded = false;\ntypedef struct sigaction *(*get_signal_t)(int);\nget_signal_t os::Linux::get_signal_action = NULL;\n\nstruct sigaction* os::Linux::get_chained_signal_action(int sig) {\n  struct sigaction *actp = NULL;\n\n  if (libjsig_is_loaded) {\n    // Retrieve the old signal handler from libjsig\n    actp = (*get_signal_action)(sig);\n  }\n  if (actp == NULL) {\n    // Retrieve the preinstalled signal handler from jvm\n    actp = get_preinstalled_handler(sig);\n  }\n\n  return actp;\n}\n\nstatic bool call_chained_handler(struct sigaction *actp, int sig,\n                                 siginfo_t *siginfo, void *context) {\n  // Call the old signal handler\n  if (actp->sa_handler == SIG_DFL) {\n    // It's more reasonable to let jvm treat it as an unexpected exception\n    // instead of taking the default action.\n    return false;\n  } else if (actp->sa_handler != SIG_IGN) {\n    if ((actp->sa_flags & SA_NODEFER) == 0) {\n      // automaticlly block the signal\n      sigaddset(&(actp->sa_mask), sig);\n    }\n\n    sa_handler_t hand = NULL;\n    sa_sigaction_t sa = NULL;\n    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n    // retrieve the chained handler\n    if (siginfo_flag_set) {\n      sa = actp->sa_sigaction;\n    } else {\n      hand = actp->sa_handler;\n    }\n\n    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n      actp->sa_handler = SIG_DFL;\n    }\n\n    // try to honor the signal mask\n    sigset_t oset;\n    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n\n    // call into the chained handler\n    if (siginfo_flag_set) {\n      (*sa)(sig, siginfo, context);\n    } else {\n      (*hand)(sig);\n    }\n\n    // restore the signal mask\n    pthread_sigmask(SIG_SETMASK, &oset, 0);\n  }\n  // Tell jvm's signal handler the signal is taken care of.\n  return true;\n}\n\nbool os::Linux::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n  bool chained = false;\n  // signal-chaining\n  if (UseSignalChaining) {\n    struct sigaction *actp = get_chained_signal_action(sig);\n    if (actp != NULL) {\n      chained = call_chained_handler(actp, sig, siginfo, context);\n    }\n  }\n  return chained;\n}\n\nstruct sigaction* os::Linux::get_preinstalled_handler(int sig) {\n  if ((( (unsigned int)1 << sig ) & sigs) != 0) {\n    return &sigact[sig];\n  }\n  return NULL;\n}\n\nvoid os::Linux::save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigact[sig] = oldAct;\n  sigs |= (unsigned int)1 << sig;\n}\n\n// for diagnostic\nint os::Linux::sigflags[MAXSIGNUM];\n\nint os::Linux::get_our_sigflags(int sig) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  return sigflags[sig];\n}\n\nvoid os::Linux::set_our_sigflags(int sig, int flags) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = flags;\n}\n\nvoid os::Linux::set_signal_handler(int sig, bool set_installed) {\n  // Check for overwrite.\n  struct sigaction oldAct;\n  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n\n  void* oldhand = oldAct.sa_sigaction\n                ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n                : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)signalHandler)) {\n    if (AllowUserSignalHandlers || !set_installed) {\n      // Do not overwrite; user takes responsibility to forward to us.\n      return;\n    } else if (UseSignalChaining) {\n      // save the old handler in jvm\n      save_preinstalled_handler(sig, oldAct);\n      // libjsig also interposes the sigaction() call below and saves the\n      // old sigaction on it own.\n    } else {\n      fatal(err_msg(\"Encountered unexpected pre-existing sigaction handler \"\n                    \"%#lx for signal %d.\", (long)oldhand, sig));\n    }\n  }\n\n  struct sigaction sigAct;\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_handler = SIG_DFL;\n  if (!set_installed) {\n    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n  } else {\n    sigAct.sa_sigaction = signalHandler;\n    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n  }\n  // Save flags, which are set by ours\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = sigAct.sa_flags;\n\n  int ret = sigaction(sig, &sigAct, &oldAct);\n  assert(ret == 0, \"check\");\n\n  void* oldhand2  = oldAct.sa_sigaction\n                  ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n                  : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n}\n\n// install signal handlers for signals that HotSpot needs to\n// handle in order to support Java-level exception handling.\n\nvoid os::Linux::install_signal_handlers() {\n  if (!signal_handlers_are_installed) {\n    signal_handlers_are_installed = true;\n\n    // signal-chaining\n    typedef void (*signal_setting_t)();\n    signal_setting_t begin_signal_setting = NULL;\n    signal_setting_t end_signal_setting = NULL;\n    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n    if (begin_signal_setting != NULL) {\n      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n                            dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n      libjsig_is_loaded = true;\n      assert(UseSignalChaining, \"should enable signal-chaining\");\n    }\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm is setting signal handlers\n      (*begin_signal_setting)();\n    }\n\n    set_signal_handler(SIGSEGV, true);\n    set_signal_handler(SIGPIPE, true);\n    set_signal_handler(SIGBUS, true);\n    set_signal_handler(SIGILL, true);\n    set_signal_handler(SIGFPE, true);\n#if defined(PPC64)\n    set_signal_handler(SIGTRAP, true);\n#endif\n    set_signal_handler(SIGXFSZ, true);\n\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm finishes setting signal handlers\n      (*end_signal_setting)();\n    }\n\n    // We don't activate signal checker if libjsig is in place, we trust ourselves\n    // and if UserSignalHandler is installed all bets are off.\n    // Log that signal checking is off only if -verbose:jni is specified.\n    if (CheckJNICalls) {\n      if (libjsig_is_loaded) {\n        if (PrintJNIResolving) {\n          tty->print_cr(\"Info: libjsig is activated, all active signal checking is disabled\");\n        }\n        check_signals = false;\n      }\n      if (AllowUserSignalHandlers) {\n        if (PrintJNIResolving) {\n          tty->print_cr(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n        }\n        check_signals = false;\n      }\n    }\n  }\n}\n\n// This is the fastest way to get thread cpu time on Linux.\n// Returns cpu time (user+sys) for any thread, not only for current.\n// POSIX compliant clocks are implemented in the kernels 2.6.16+.\n// It might work on 2.6.10+ with a special kernel/glibc patch.\n// For reference, please, see IEEE Std 1003.1-2004:\n//   http://www.unix.org/single_unix_specification\n\njlong os::Linux::fast_thread_cpu_time(clockid_t clockid) {\n  struct timespec tp;\n  int rc = os::Linux::clock_gettime(clockid, &tp);\n  assert(rc == 0, \"clock_gettime is expected to return 0 code\");\n\n  return (tp.tv_sec * NANOSECS_PER_SEC) + tp.tv_nsec;\n}\n\n/////\n// glibc on Linux platform uses non-documented flag\n// to indicate, that some special sort of signal\n// trampoline is used.\n// We will never set this flag, and we should\n// ignore this flag in our diagnostic\n#ifdef SIGNIFICANT_SIGNAL_MASK\n#undef SIGNIFICANT_SIGNAL_MASK\n#endif\n#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)\n\nstatic const char* get_signal_handler_name(address handler,\n                                           char* buf, int buflen) {\n  int offset = 0;\n  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n  if (found) {\n    // skip directory names\n    const char *p1, *p2;\n    p1 = buf;\n    size_t len = strlen(os::file_separator());\n    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n  } else {\n    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n  }\n  return buf;\n}\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen) {\n  struct sigaction sa;\n\n  sigaction(sig, NULL, &sa);\n\n  // See comment for SIGNIFICANT_SIGNAL_MASK define\n  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n\n  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n\n  address handler = (sa.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n\n  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n    st->print(\"SIG_DFL\");\n  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n    st->print(\"SIG_IGN\");\n  } else {\n    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n  }\n\n  st->print(\", sa_mask[0]=\");\n  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n\n  address rh = VMError::get_resetted_sighandler(sig);\n  // May be, handler was resetted by VMError?\n  if(rh != NULL) {\n    handler = rh;\n    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;\n  }\n\n  st->print(\", sa_flags=\");\n  os::Posix::print_sa_flags(st, sa.sa_flags);\n\n  // Check: is it our handler?\n  if(handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler) ||\n     handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n    // It is our signal handler\n    // check for flags, reset system-used one!\n    if((int)sa.sa_flags != os::Linux::get_our_sigflags(sig)) {\n      st->print(\n                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n                os::Linux::get_our_sigflags(sig));\n    }\n  }\n  st->cr();\n}\n\n\n#define DO_SIGNAL_CHECK(sig) \\\n  if (!sigismember(&check_signal_done, sig)) \\\n    os::Linux::check_signal_handler(sig)\n\n// This method is a periodic task to check for misbehaving JNI applications\n// under CheckJNI, we can add any periodic checks here\n\nvoid os::run_periodic_checks() {\n\n  if (check_signals == false) return;\n\n  // SEGV and BUS if overridden could potentially prevent\n  // generation of hs*.log in the event of a crash, debugging\n  // such a case can be very challenging, so we absolutely\n  // check the following for a good measure:\n  DO_SIGNAL_CHECK(SIGSEGV);\n  DO_SIGNAL_CHECK(SIGILL);\n  DO_SIGNAL_CHECK(SIGFPE);\n  DO_SIGNAL_CHECK(SIGBUS);\n  DO_SIGNAL_CHECK(SIGPIPE);\n  DO_SIGNAL_CHECK(SIGXFSZ);\n#if defined(PPC64)\n  DO_SIGNAL_CHECK(SIGTRAP);\n#endif\n\n  // ReduceSignalUsage allows the user to override these handlers\n  // see comments at the very top and jvm_solaris.h\n  if (!ReduceSignalUsage) {\n    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n  }\n\n  DO_SIGNAL_CHECK(SR_signum);\n  DO_SIGNAL_CHECK(INTERRUPT_SIGNAL);\n}\n\ntypedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic os_sigaction_t os_sigaction = NULL;\n\nvoid os::Linux::check_signal_handler(int sig) {\n  char buf[O_BUFLEN];\n  address jvmHandler = NULL;\n\n\n  struct sigaction act;\n  if (os_sigaction == NULL) {\n    // only trust the default sigaction, in case it has been interposed\n    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n    if (os_sigaction == NULL) return;\n  }\n\n  os_sigaction(sig, (struct sigaction*)NULL, &act);\n\n\n  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n\n  address thisHandler = (act.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, act.sa_handler) ;\n\n\n  switch(sig) {\n  case SIGSEGV:\n  case SIGBUS:\n  case SIGFPE:\n  case SIGPIPE:\n  case SIGILL:\n  case SIGXFSZ:\n    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler);\n    break;\n\n  case SHUTDOWN1_SIGNAL:\n  case SHUTDOWN2_SIGNAL:\n  case SHUTDOWN3_SIGNAL:\n  case BREAK_SIGNAL:\n    jvmHandler = (address)user_handler();\n    break;\n\n  case INTERRUPT_SIGNAL:\n    jvmHandler = CAST_FROM_FN_PTR(address, SIG_DFL);\n    break;\n\n  default:\n    if (sig == SR_signum) {\n      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n    } else {\n      return;\n    }\n    break;\n  }\n\n  if (thisHandler != jvmHandler) {\n    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n    // Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n                    exception_name(sig, buf, O_BUFLEN));\n    }\n  } else if(os::Linux::get_our_sigflags(sig) != 0 && (int)act.sa_flags != os::Linux::get_our_sigflags(sig)) {\n    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:\" PTR32_FORMAT, os::Linux::get_our_sigflags(sig));\n    tty->print_cr(\"  found:\" PTR32_FORMAT, act.sa_flags);\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n  }\n\n  // Dump all the signal\n  if (sigismember(&check_signal_done, sig)) {\n    print_signal_handlers(tty, buf, O_BUFLEN);\n  }\n}\n\nextern void report_error(char* file_name, int line_no, char* title, char* format, ...);\n\nextern bool signal_name(int signo, char* buf, size_t len);\n\nconst char* os::exception_name(int exception_code, char* buf, size_t size) {\n  if (0 < exception_code && exception_code <= SIGRTMAX) {\n    // signal\n    if (!signal_name(exception_code, buf, size)) {\n      jio_snprintf(buf, size, \"SIG%d\", exception_code);\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\n// this is called _before_ the most of global arguments have been parsed\nvoid os::init(void) {\n  char dummy;   /* used to get a guess on initial stack address */\n//  first_hrtime = gethrtime();\n\n  // With LinuxThreads the JavaMain thread pid (primordial thread)\n  // is different than the pid of the java launcher thread.\n  // So, on Linux, the launcher thread pid is passed to the VM\n  // via the sun.java.launcher.pid property.\n  // Use this property instead of getpid() if it was correctly passed.\n  // See bug 6351349.\n  pid_t java_launcher_pid = (pid_t) Arguments::sun_java_launcher_pid();\n\n  _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();\n\n  clock_tics_per_sec = sysconf(_SC_CLK_TCK);\n\n  init_random(1234567);\n\n  ThreadCritical::initialize();\n\n  Linux::set_page_size(sysconf(_SC_PAGESIZE));\n  if (Linux::page_size() == -1) {\n    fatal(err_msg(\"os_linux.cpp: os::init: sysconf failed (%s)\",\n                  strerror(errno)));\n  }\n  init_page_sizes((size_t) Linux::page_size());\n\n  Linux::initialize_system_info();\n\n  // main_thread points to the aboriginal thread\n  Linux::_main_thread = pthread_self();\n\n  Linux::clock_init();\n  initial_time_count = javaTimeNanos();\n\n  // pthread_condattr initialization for monotonic clock\n  int status;\n  pthread_condattr_t* _condattr = os::Linux::condAttr();\n  if ((status = pthread_condattr_init(_condattr)) != 0) {\n    fatal(err_msg(\"pthread_condattr_init: %s\", strerror(status)));\n  }\n  // Only set the clock if CLOCK_MONOTONIC is available\n  if (Linux::supports_monotonic_clock()) {\n    if ((status = pthread_condattr_setclock(_condattr, CLOCK_MONOTONIC)) != 0) {\n      if (status == EINVAL) {\n        warning(\"Unable to use monotonic clock with relative timed-waits\" \\\n                \" - changes to the time-of-day clock may have adverse affects\");\n      } else {\n        fatal(err_msg(\"pthread_condattr_setclock: %s\", strerror(status)));\n      }\n    }\n  }\n  // else it defaults to CLOCK_REALTIME\n\n  pthread_mutex_init(&dl_mutex, NULL);\n\n  // If the pagesize of the VM is greater than 8K determine the appropriate\n  // number of initial guard pages.  The user can change this with the\n  // command line arguments, if needed.\n  if (vm_page_size() > (int)Linux::vm_default_page_size()) {\n    StackYellowPages = 1;\n    StackRedPages = 1;\n    StackShadowPages = round_to((StackShadowPages*Linux::vm_default_page_size()), vm_page_size()) / vm_page_size();\n  }\n}\n\n// To install functions for atexit system call\nextern \"C\" {\n  static void perfMemory_exit_helper() {\n    perfMemory_exit();\n  }\n}\n\n// this is called _after_ the global arguments have been parsed\njint os::init_2(void)\n{\n  Linux::fast_thread_clock_init();\n\n  // Allocate a single page and mark it as readable for safepoint polling\n  address polling_page = (address) ::mmap(NULL, Linux::page_size(), PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n  guarantee( polling_page != MAP_FAILED, \"os::init_2: failed to allocate polling page\" );\n\n  os::set_polling_page( polling_page );\n\n#ifndef PRODUCT\n  if(Verbose && PrintMiscellaneous)\n    tty->print(\"[SafePoint Polling address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)polling_page);\n#endif\n\n  if (!UseMembar) {\n    address mem_serialize_page = (address) ::mmap(NULL, Linux::page_size(), PROT_READ | PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    guarantee( mem_serialize_page != MAP_FAILED, \"mmap Failed for memory serialize page\");\n    os::set_memory_serialize_page( mem_serialize_page );\n\n#ifndef PRODUCT\n    if(Verbose && PrintMiscellaneous)\n      tty->print(\"[Memory Serialize  Page address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)mem_serialize_page);\n#endif\n  }\n\n  // initialize suspend/resume support - must do this before signal_sets_init()\n  if (SR_initialize() != 0) {\n    perror(\"SR_initialize failed\");\n    return JNI_ERR;\n  }\n\n  Linux::signal_sets_init();\n  Linux::install_signal_handlers();\n\n  // Check minimum allowable stack size for thread creation and to initialize\n  // the java system classes, including StackOverflowError - depends on page\n  // size.  Add a page for compiler2 recursion in main thread.\n  // Add in 2*BytesPerWord times page size to account for VM stack during\n  // class initialization depending on 32 or 64 bit VM.\n  os::Linux::min_stack_allowed = MAX2(os::Linux::min_stack_allowed,\n            (size_t)(StackYellowPages+StackRedPages+StackShadowPages) * Linux::page_size() +\n                    (2*BytesPerWord COMPILER2_PRESENT(+1)) * Linux::vm_default_page_size());\n\n  size_t threadStackSizeInBytes = ThreadStackSize * K;\n  if (threadStackSizeInBytes != 0 &&\n      threadStackSizeInBytes < os::Linux::min_stack_allowed) {\n        tty->print_cr(\"\\nThe stack size specified is too small, \"\n                      \"Specify at least %dk\",\n                      os::Linux::min_stack_allowed/ K);\n        return JNI_ERR;\n  }\n\n  // Make the stack size a multiple of the page size so that\n  // the yellow/red zones can be guarded.\n  JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,\n        vm_page_size()));\n\n  Linux::capture_initial_stack(JavaThread::stack_size_at_create());\n\n#if defined(IA32)\n  workaround_expand_exec_shield_cs_limit();\n#endif\n\n  Linux::libpthread_init();\n  if (PrintMiscellaneous && (Verbose || WizardMode)) {\n     tty->print_cr(\"[HotSpot is running with %s, %s(%s)]\\n\",\n          Linux::glibc_version(), Linux::libpthread_version(),\n          Linux::is_floating_stack() ? \"floating stack\" : \"fixed stack\");\n  }\n\n  if (UseNUMA) {\n    if (!Linux::libnuma_init()) {\n      UseNUMA = false;\n    } else {\n      if ((Linux::numa_max_node() < 1)) {\n        // There's only one node(they start from 0), disable NUMA.\n        UseNUMA = false;\n      }\n    }\n    // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there's no way\n    // we can make the adaptive lgrp chunk resizing work. If the user specified\n    // both UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn and\n    // disable adaptive resizing.\n    if (UseNUMA && UseLargePages && !can_commit_large_page_memory()) {\n      if (FLAG_IS_DEFAULT(UseNUMA)) {\n        UseNUMA = false;\n      } else {\n        if (FLAG_IS_DEFAULT(UseLargePages) &&\n            FLAG_IS_DEFAULT(UseSHM) &&\n            FLAG_IS_DEFAULT(UseHugeTLBFS)) {\n          UseLargePages = false;\n        } else {\n          warning(\"UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, disabling adaptive resizing\");\n          UseAdaptiveSizePolicy = false;\n          UseAdaptiveNUMAChunkSizing = false;\n        }\n      }\n    }\n    if (!UseNUMA && ForceNUMA) {\n      UseNUMA = true;\n    }\n  }\n\n  if (MaxFDLimit) {\n    // set the number of file descriptors to max. print out error\n    // if getrlimit/setrlimit fails but continue regardless.\n    struct rlimit nbr_files;\n    int status = getrlimit(RLIMIT_NOFILE, &nbr_files);\n    if (status != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode))\n        perror(\"os::init_2 getrlimit failed\");\n    } else {\n      nbr_files.rlim_cur = nbr_files.rlim_max;\n      status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n      if (status != 0) {\n        if (PrintMiscellaneous && (Verbose || WizardMode))\n          perror(\"os::init_2 setrlimit failed\");\n      }\n    }\n  }\n\n  // Initialize lock used to serialize thread creation (see os::create_thread)\n  Linux::set_createThread_lock(new Mutex(Mutex::leaf, \"createThread_lock\", false));\n\n  // at-exit methods are called in the reverse order of their registration.\n  // atexit functions are called on return from main or as a result of a\n  // call to exit(3C). There can be only 32 of these functions registered\n  // and atexit() does not set errno.\n\n  if (PerfAllowAtExitRegistration) {\n    // only register atexit functions if PerfAllowAtExitRegistration is set.\n    // atexit functions can be delayed until process exit time, which\n    // can be problematic for embedded VM situations. Embedded VMs should\n    // call DestroyJavaVM() to assure that VM resources are released.\n\n    // note: perfMemory_exit_helper atexit function may be removed in\n    // the future if the appropriate cleanup code can be added to the\n    // VM_Exit VMOperation's doit method.\n    if (atexit(perfMemory_exit_helper) != 0) {\n      warning(\"os::init_2 atexit(perfMemory_exit_helper) failed\");\n    }\n  }\n\n  // initialize thread priority policy\n  prio_init();\n\n  return JNI_OK;\n}\n\n// Mark the polling page as unreadable\nvoid os::make_polling_page_unreadable(void) {\n  if( !guard_memory((char*)_polling_page, Linux::page_size()) )\n    fatal(\"Could not disable polling page\");\n};\n\n// Mark the polling page as readable\nvoid os::make_polling_page_readable(void) {\n  if( !linux_mprotect((char *)_polling_page, Linux::page_size(), PROT_READ)) {\n    fatal(\"Could not enable polling page\");\n  }\n};\n\nint os::active_processor_count() {\n  // Linux doesn't yet have a (official) notion of processor sets,\n  // so just return the number of online processors.\n  int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);\n  assert(online_cpus > 0 && online_cpus <= processor_count(), \"sanity check\");\n  return online_cpus;\n}\n\nvoid os::set_native_thread_name(const char *name) {\n  // Not yet implemented.\n  return;\n}\n\nbool os::distribute_processes(uint length, uint* distribution) {\n  // Not yet implemented.\n  return false;\n}\n\nbool os::bind_to_processor(uint processor_id) {\n  // Not yet implemented.\n  return false;\n}\n\n///\n\nvoid os::SuspendedThreadTask::internal_do_task() {\n  if (do_suspend(_thread->osthread())) {\n    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n    do_task(context);\n    do_resume(_thread->osthread());\n  }\n}\n\nclass PcFetcher : public os::SuspendedThreadTask {\npublic:\n  PcFetcher(Thread* thread) : os::SuspendedThreadTask(thread) {}\n  ExtendedPC result();\nprotected:\n  void do_task(const os::SuspendedThreadTaskContext& context);\nprivate:\n  ExtendedPC _epc;\n};\n\nExtendedPC PcFetcher::result() {\n  guarantee(is_done(), \"task is not done yet.\");\n  return _epc;\n}\n\nvoid PcFetcher::do_task(const os::SuspendedThreadTaskContext& context) {\n  Thread* thread = context.thread();\n  OSThread* osthread = thread->osthread();\n  if (osthread->ucontext() != NULL) {\n    _epc = os::Linux::ucontext_get_pc((ucontext_t *) context.ucontext());\n  } else {\n    // NULL context is unexpected, double-check this is the VMThread\n    guarantee(thread->is_VM_thread(), \"can only be called for VMThread\");\n  }\n}\n\n// Suspends the target using the signal mechanism and then grabs the PC before\n// resuming the target. Used by the flat-profiler only\nExtendedPC os::get_thread_pc(Thread* thread) {\n  // Make sure that it is called by the watcher for the VMThread\n  assert(Thread::current()->is_Watcher_thread(), \"Must be watcher\");\n  assert(thread->is_VM_thread(), \"Can only be called for VMThread\");\n\n  PcFetcher fetcher(thread);\n  fetcher.run();\n  return fetcher.result();\n}\n\nint os::Linux::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime)\n{\n   if (is_NPTL()) {\n      return pthread_cond_timedwait(_cond, _mutex, _abstime);\n   } else {\n      // 6292965: LinuxThreads pthread_cond_timedwait() resets FPU control\n      // word back to default 64bit precision if condvar is signaled. Java\n      // wants 53bit precision.  Save and restore current value.\n      int fpu = get_fpu_control_word();\n      int status = pthread_cond_timedwait(_cond, _mutex, _abstime);\n      set_fpu_control_word(fpu);\n      return status;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// debug support\n\nbool os::find(address addr, outputStream* st) {\n  Dl_info dlinfo;\n  memset(&dlinfo, 0, sizeof(dlinfo));\n  if (dladdr(addr, &dlinfo) != 0) {\n    st->print(PTR_FORMAT \": \", addr);\n    if (dlinfo.dli_sname != NULL && dlinfo.dli_saddr != NULL) {\n      st->print(\"%s+%#x\", dlinfo.dli_sname,\n                 addr - (intptr_t)dlinfo.dli_saddr);\n    } else if (dlinfo.dli_fbase != NULL) {\n      st->print(\"<offset %#x>\", addr - (intptr_t)dlinfo.dli_fbase);\n    } else {\n      st->print(\"<absolute address>\");\n    }\n    if (dlinfo.dli_fname != NULL) {\n      st->print(\" in %s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL) {\n      st->print(\" at \" PTR_FORMAT, dlinfo.dli_fbase);\n    }\n    st->cr();\n\n    if (Verbose) {\n      // decode some bytes around the PC\n      address begin = clamp_address_in_page(addr-40, addr, os::vm_page_size());\n      address end   = clamp_address_in_page(addr+40, addr, os::vm_page_size());\n      address       lowest = (address) dlinfo.dli_sname;\n      if (!lowest)  lowest = (address) dlinfo.dli_fbase;\n      if (begin < lowest)  begin = lowest;\n      Dl_info dlinfo2;\n      if (dladdr(end, &dlinfo2) != 0 && dlinfo2.dli_saddr != dlinfo.dli_saddr\n          && end > dlinfo2.dli_saddr && dlinfo2.dli_saddr > begin)\n        end = (address) dlinfo2.dli_saddr;\n      Disassembler::decode(begin, end, st);\n    }\n    return true;\n  }\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// misc\n\n// This does not do anything on Linux. This is basically a hook for being\n// able to use structured exception handling (thread-local exception filters)\n// on, e.g., Win32.\nvoid\nos::os_exception_wrapper(java_call_t f, JavaValue* value, methodHandle* method,\n                         JavaCallArguments* args, Thread* thread) {\n  f(value, method, args, thread);\n}\n\nvoid os::print_statistics() {\n}\n\nint os::message_box(const char* title, const char* message) {\n  int i;\n  fdStream err(defaultStream::error_fd());\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n  err.print_raw_cr(title);\n  for (i = 0; i < 78; i++) err.print_raw(\"-\");\n  err.cr();\n  err.print_raw_cr(message);\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n\n  char buf[16];\n  // Prevent process from exiting upon \"read error\" without consuming all CPU\n  while (::read(0, buf, sizeof(buf)) <= 0) { ::sleep(100); }\n\n  return buf[0] == 'y' || buf[0] == 'Y';\n}\n\nint os::stat(const char *path, struct stat *sbuf) {\n  char pathbuf[MAX_PATH];\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  os::native_path(strcpy(pathbuf, path));\n  return ::stat(pathbuf, sbuf);\n}\n\nbool os::check_heap(bool force) {\n  return true;\n}\n\nint local_vsnprintf(char* buf, size_t count, const char* format, va_list args) {\n  return ::vsnprintf(buf, count, format, args);\n}\n\n// Is a (classpath) directory empty?\nbool os::dir_is_empty(const char* path) {\n  DIR *dir = NULL;\n  struct dirent *ptr;\n\n  dir = opendir(path);\n  if (dir == NULL) return true;\n\n  /* Scan the directory */\n  bool result = true;\n  char buf[sizeof(struct dirent) + MAX_PATH];\n  while (result && (ptr = ::readdir(dir)) != NULL) {\n    if (strcmp(ptr->d_name, \".\") != 0 && strcmp(ptr->d_name, \"..\") != 0) {\n      result = false;\n    }\n  }\n  closedir(dir);\n  return result;\n}\n\n// This code originates from JDK's sysOpen and open64_w\n// from src/solaris/hpi/src/system_md.c\n\n#ifndef O_DELETE\n#define O_DELETE 0x10000\n#endif\n\n// Open a file. Unlink the file immediately after open returns\n// if the specified oflag has the O_DELETE flag set.\n// O_DELETE is used only in j2se/src/share/native/java/util/zip/ZipFile.c\n\nint os::open(const char *path, int oflag, int mode) {\n\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  int fd;\n  int o_delete = (oflag & O_DELETE);\n  oflag = oflag & ~O_DELETE;\n\n  fd = ::open64(path, oflag, mode);\n  if (fd == -1) return -1;\n\n  //If the open succeeded, the file might still be a directory\n  {\n    struct stat64 buf64;\n    int ret = ::fstat64(fd, &buf64);\n    int st_mode = buf64.st_mode;\n\n    if (ret != -1) {\n      if ((st_mode & S_IFMT) == S_IFDIR) {\n        errno = EISDIR;\n        ::close(fd);\n        return -1;\n      }\n    } else {\n      ::close(fd);\n      return -1;\n    }\n  }\n\n    /*\n     * All file descriptors that are opened in the JVM and not\n     * specifically destined for a subprocess should have the\n     * close-on-exec flag set.  If we don't set it, then careless 3rd\n     * party native code might fork and exec without closing all\n     * appropriate file descriptors (e.g. as we do in closeDescriptors in\n     * UNIXProcess.c), and this in turn might:\n     *\n     * - cause end-of-file to fail to be detected on some file\n     *   descriptors, resulting in mysterious hangs, or\n     *\n     * - might cause an fopen in the subprocess to fail on a system\n     *   suffering from bug 1085341.\n     *\n     * (Yes, the default setting of the close-on-exec flag is a Unix\n     * design flaw)\n     *\n     * See:\n     * 1085341: 32-bit stdio routines should support file descriptors >255\n     * 4843136: (process) pipe file descriptor from Runtime.exec not being closed\n     * 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9\n     */\n#ifdef FD_CLOEXEC\n    {\n        int flags = ::fcntl(fd, F_GETFD);\n        if (flags != -1)\n            ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n    }\n#endif\n\n  if (o_delete != 0) {\n    ::unlink(path);\n  }\n  return fd;\n}\n\n\n// create binary file, rewriting existing file if required\nint os::create_binary_file(const char* path, bool rewrite_existing) {\n  int oflags = O_WRONLY | O_CREAT;\n  if (!rewrite_existing) {\n    oflags |= O_EXCL;\n  }\n  return ::open64(path, oflags, S_IREAD | S_IWRITE);\n}\n\n// return current position of file pointer\njlong os::current_file_offset(int fd) {\n  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);\n}\n\n// move file pointer to the specified offset\njlong os::seek_to_file_offset(int fd, jlong offset) {\n  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);\n}\n\n// This code originates from JDK's sysAvailable\n// from src/solaris/hpi/src/native_threads/src/sys_api_td.c\n\nint os::available(int fd, jlong *bytes) {\n  jlong cur, end;\n  int mode;\n  struct stat64 buf64;\n\n  if (::fstat64(fd, &buf64) >= 0) {\n    mode = buf64.st_mode;\n    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n      /*\n      * XXX: is the following call interruptible? If so, this might\n      * need to go through the INTERRUPT_IO() wrapper as for other\n      * blocking, interruptible calls in this file.\n      */\n      int n;\n      if (::ioctl(fd, FIONREAD, &n) >= 0) {\n        *bytes = n;\n        return 1;\n      }\n    }\n  }\n  if ((cur = ::lseek64(fd, 0L, SEEK_CUR)) == -1) {\n    return 0;\n  } else if ((end = ::lseek64(fd, 0L, SEEK_END)) == -1) {\n    return 0;\n  } else if (::lseek64(fd, cur, SEEK_SET) == -1) {\n    return 0;\n  }\n  *bytes = end - cur;\n  return 1;\n}\n\nint os::socket_available(int fd, jint *pbytes) {\n  // Linux doc says EINTR not returned, unlike Solaris\n  int ret = ::ioctl(fd, FIONREAD, pbytes);\n\n  //%% note ioctl can return 0 when successful, JVM_SocketAvailable\n  // is expected to return 0 on failure and 1 on success to the jdk.\n  return (ret < 0) ? 0 : 1;\n}\n\n// Map a block of memory.\nchar* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,\n                     char *addr, size_t bytes, bool read_only,\n                     bool allow_exec) {\n  int prot;\n  int flags = MAP_PRIVATE;\n\n  if (read_only) {\n    prot = PROT_READ;\n  } else {\n    prot = PROT_READ | PROT_WRITE;\n  }\n\n  if (allow_exec) {\n    prot |= PROT_EXEC;\n  }\n\n  if (addr != NULL) {\n    flags |= MAP_FIXED;\n  }\n\n  char* mapped_address = (char*)mmap(addr, (size_t)bytes, prot, flags,\n                                     fd, file_offset);\n  if (mapped_address == MAP_FAILED) {\n    return NULL;\n  }\n  return mapped_address;\n}\n\n\n// Remap a block of memory.\nchar* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,\n                       char *addr, size_t bytes, bool read_only,\n                       bool allow_exec) {\n  // same as map_memory() on this OS\n  return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,\n                        allow_exec);\n}\n\n\n// Unmap a block of memory.\nbool os::pd_unmap_memory(char* addr, size_t bytes) {\n  return munmap(addr, bytes) == 0;\n}\n\nstatic jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time);\n\nstatic clockid_t thread_cpu_clockid(Thread* thread) {\n  pthread_t tid = thread->osthread()->pthread_id();\n  clockid_t clockid;\n\n  // Get thread clockid\n  int rc = os::Linux::pthread_getcpuclockid(tid, &clockid);\n  assert(rc == 0, \"pthread_getcpuclockid is expected to return 0 code\");\n  return clockid;\n}\n\n// current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)\n// are used by JVM M&M and JVMTI to get user+sys or user CPU time\n// of a thread.\n//\n// current_thread_cpu_time() and thread_cpu_time(Thread*) returns\n// the fast estimate available on the platform.\n\njlong os::current_thread_cpu_time() {\n  if (os::Linux::supports_fast_thread_cpu_time()) {\n    return os::Linux::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);\n  } else {\n    // return user + sys since the cost is the same\n    return slow_thread_cpu_time(Thread::current(), true /* user + sys */);\n  }\n}\n\njlong os::thread_cpu_time(Thread* thread) {\n  // consistent with what current_thread_cpu_time() returns\n  if (os::Linux::supports_fast_thread_cpu_time()) {\n    return os::Linux::fast_thread_cpu_time(thread_cpu_clockid(thread));\n  } else {\n    return slow_thread_cpu_time(thread, true /* user + sys */);\n  }\n}\n\njlong os::current_thread_cpu_time(bool user_sys_cpu_time) {\n  if (user_sys_cpu_time && os::Linux::supports_fast_thread_cpu_time()) {\n    return os::Linux::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);\n  } else {\n    return slow_thread_cpu_time(Thread::current(), user_sys_cpu_time);\n  }\n}\n\njlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {\n  if (user_sys_cpu_time && os::Linux::supports_fast_thread_cpu_time()) {\n    return os::Linux::fast_thread_cpu_time(thread_cpu_clockid(thread));\n  } else {\n    return slow_thread_cpu_time(thread, user_sys_cpu_time);\n  }\n}\n\n//\n//  -1 on error.\n//\n\nPRAGMA_DIAG_PUSH\nPRAGMA_FORMAT_NONLITERAL_IGNORED\nstatic jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {\n  static bool proc_task_unchecked = true;\n  static const char *proc_stat_path = \"/proc/%d/stat\";\n  pid_t  tid = thread->osthread()->thread_id();\n  char *s;\n  char stat[2048];\n  int statlen;\n  char proc_name[64];\n  int count;\n  long sys_time, user_time;\n  char cdummy;\n  int idummy;\n  long ldummy;\n  FILE *fp;\n\n  // The /proc/<tid>/stat aggregates per-process usage on\n  // new Linux kernels 2.6+ where NPTL is supported.\n  // The /proc/self/task/<tid>/stat still has the per-thread usage.\n  // See bug 6328462.\n  // There possibly can be cases where there is no directory\n  // /proc/self/task, so we check its availability.\n  if (proc_task_unchecked && os::Linux::is_NPTL()) {\n    // This is executed only once\n    proc_task_unchecked = false;\n    fp = fopen(\"/proc/self/task\", \"r\");\n    if (fp != NULL) {\n      proc_stat_path = \"/proc/self/task/%d/stat\";\n      fclose(fp);\n    }\n  }\n\n  sprintf(proc_name, proc_stat_path, tid);\n  fp = fopen(proc_name, \"r\");\n  if ( fp == NULL ) return -1;\n  statlen = fread(stat, 1, 2047, fp);\n  stat[statlen] = '\\0';\n  fclose(fp);\n\n  // Skip pid and the command string. Note that we could be dealing with\n  // weird command names, e.g. user could decide to rename java launcher\n  // to \"java 1.4.2 :)\", then the stat file would look like\n  //                1234 (java 1.4.2 :)) R ... ...\n  // We don't really need to know the command string, just find the last\n  // occurrence of \")\" and then start parsing from there. See bug 4726580.\n  s = strrchr(stat, ')');\n  if (s == NULL ) return -1;\n\n  // Skip blank chars\n  do s++; while (isspace(*s));\n\n  count = sscanf(s,\"%c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu\",\n                 &cdummy, &idummy, &idummy, &idummy, &idummy, &idummy,\n                 &ldummy, &ldummy, &ldummy, &ldummy, &ldummy,\n                 &user_time, &sys_time);\n  if ( count != 13 ) return -1;\n  if (user_sys_cpu_time) {\n    return ((jlong)sys_time + (jlong)user_time) * (1000000000 / clock_tics_per_sec);\n  } else {\n    return (jlong)user_time * (1000000000 / clock_tics_per_sec);\n  }\n}\nPRAGMA_DIAG_POP\n\nvoid os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nvoid os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nbool os::is_thread_cpu_time_supported() {\n  return true;\n}\n\n// System loadavg support.  Returns -1 if load average cannot be obtained.\n// Linux doesn't yet have a (official) notion of processor sets,\n// so just return the system wide load average.\nint os::loadavg(double loadavg[], int nelem) {\n  return ::getloadavg(loadavg, nelem);\n}\n\nvoid os::pause() {\n  char filename[MAX_PATH];\n  if (PauseAtStartupFile && PauseAtStartupFile[0]) {\n    jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);\n  } else {\n    jio_snprintf(filename, MAX_PATH, \"./vm.paused.%d\", current_process_id());\n  }\n\n  int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n  if (fd != -1) {\n    struct stat buf;\n    ::close(fd);\n    while (::stat(filename, &buf) == 0) {\n      (void)::poll(NULL, 0, 100);\n    }\n  } else {\n    jio_fprintf(stderr,\n      \"Could not open pause file '%s', continuing immediately.\\n\", filename);\n  }\n}\n\n\n// Refer to the comments in os_solaris.cpp park-unpark.\n//\n// Beware -- Some versions of NPTL embody a flaw where pthread_cond_timedwait() can\n// hang indefinitely.  For instance NPTL 0.60 on 2.4.21-4ELsmp is vulnerable.\n// For specifics regarding the bug see GLIBC BUGID 261237 :\n//    http://www.mail-archive.com/debian-glibc@lists.debian.org/msg10837.html.\n// Briefly, pthread_cond_timedwait() calls with an expiry time that's not in the future\n// will either hang or corrupt the condvar, resulting in subsequent hangs if the condvar\n// is used.  (The simple C test-case provided in the GLIBC bug report manifests the\n// hang).  The JVM is vulernable via sleep(), Object.wait(timo), LockSupport.parkNanos()\n// and monitorenter when we're using 1-0 locking.  All those operations may result in\n// calls to pthread_cond_timedwait().  Using LD_ASSUME_KERNEL to use an older version\n// of libpthread avoids the problem, but isn't practical.\n//\n// Possible remedies:\n//\n// 1.   Establish a minimum relative wait time.  50 to 100 msecs seems to work.\n//      This is palliative and probabilistic, however.  If the thread is preempted\n//      between the call to compute_abstime() and pthread_cond_timedwait(), more\n//      than the minimum period may have passed, and the abstime may be stale (in the\n//      past) resultin in a hang.   Using this technique reduces the odds of a hang\n//      but the JVM is still vulnerable, particularly on heavily loaded systems.\n//\n// 2.   Modify park-unpark to use per-thread (per ParkEvent) pipe-pairs instead\n//      of the usual flag-condvar-mutex idiom.  The write side of the pipe is set\n//      NDELAY. unpark() reduces to write(), park() reduces to read() and park(timo)\n//      reduces to poll()+read().  This works well, but consumes 2 FDs per extant\n//      thread.\n//\n// 3.   Embargo pthread_cond_timedwait() and implement a native \"chron\" thread\n//      that manages timeouts.  We'd emulate pthread_cond_timedwait() by enqueuing\n//      a timeout request to the chron thread and then blocking via pthread_cond_wait().\n//      This also works well.  In fact it avoids kernel-level scalability impediments\n//      on certain platforms that don't handle lots of active pthread_cond_timedwait()\n//      timers in a graceful fashion.\n//\n// 4.   When the abstime value is in the past it appears that control returns\n//      correctly from pthread_cond_timedwait(), but the condvar is left corrupt.\n//      Subsequent timedwait/wait calls may hang indefinitely.  Given that, we\n//      can avoid the problem by reinitializing the condvar -- by cond_destroy()\n//      followed by cond_init() -- after all calls to pthread_cond_timedwait().\n//      It may be possible to avoid reinitialization by checking the return\n//      value from pthread_cond_timedwait().  In addition to reinitializing the\n//      condvar we must establish the invariant that cond_signal() is only called\n//      within critical sections protected by the adjunct mutex.  This prevents\n//      cond_signal() from \"seeing\" a condvar that's in the midst of being\n//      reinitialized or that is corrupt.  Sadly, this invariant obviates the\n//      desirable signal-after-unlock optimization that avoids futile context switching.\n//\n//      I'm also concerned that some versions of NTPL might allocate an auxilliary\n//      structure when a condvar is used or initialized.  cond_destroy()  would\n//      release the helper structure.  Our reinitialize-after-timedwait fix\n//      put excessive stress on malloc/free and locks protecting the c-heap.\n//\n// We currently use (4).  See the WorkAroundNTPLTimedWaitHang flag.\n// It may be possible to refine (4) by checking the kernel and NTPL verisons\n// and only enabling the work-around for vulnerable environments.\n\n// utility to compute the abstime argument to timedwait:\n// millis is the relative timeout time\n// abstime will be the absolute timeout time\n// TODO: replace compute_abstime() with unpackTime()\n\nstatic struct timespec* compute_abstime(timespec* abstime, jlong millis) {\n  if (millis < 0)  millis = 0;\n\n  jlong seconds = millis / 1000;\n  millis %= 1000;\n  if (seconds > 50000000) { // see man cond_timedwait(3T)\n    seconds = 50000000;\n  }\n\n  if (os::Linux::supports_monotonic_clock()) {\n    struct timespec now;\n    int status = os::Linux::clock_gettime(CLOCK_MONOTONIC, &now);\n    assert_status(status == 0, status, \"clock_gettime\");\n    abstime->tv_sec = now.tv_sec  + seconds;\n    long nanos = now.tv_nsec + millis * NANOSECS_PER_MILLISEC;\n    if (nanos >= NANOSECS_PER_SEC) {\n      abstime->tv_sec += 1;\n      nanos -= NANOSECS_PER_SEC;\n    }\n    abstime->tv_nsec = nanos;\n  } else {\n    struct timeval now;\n    int status = gettimeofday(&now, NULL);\n    assert(status == 0, \"gettimeofday\");\n    abstime->tv_sec = now.tv_sec  + seconds;\n    long usec = now.tv_usec + millis * 1000;\n    if (usec >= 1000000) {\n      abstime->tv_sec += 1;\n      usec -= 1000000;\n    }\n    abstime->tv_nsec = usec * 1000;\n  }\n  return abstime;\n}\n\n\n// Test-and-clear _Event, always leaves _Event set to 0, returns immediately.\n// Conceptually TryPark() should be equivalent to park(0).\n\nint os::PlatformEvent::TryPark() {\n  for (;;) {\n    const int v = _Event ;\n    guarantee ((v == 0) || (v == 1), \"invariant\") ;\n    if (Atomic::cmpxchg (0, &_Event, v) == v) return v  ;\n  }\n}\n\nvoid os::PlatformEvent::park() {       // AKA \"down()\"\n  // Invariant: Only the thread associated with the Event/PlatformEvent\n  // may call park().\n  // TODO: assert that _Assoc != NULL or _Assoc == Self\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v == 0) {\n     // Do this the hard way by blocking ...\n     int status = pthread_mutex_lock(_mutex);\n     assert_status(status == 0, status, \"mutex_lock\");\n     guarantee (_nParked == 0, \"invariant\") ;\n     ++ _nParked ;\n     while (_Event < 0) {\n        status = pthread_cond_wait(_cond, _mutex);\n        // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...\n        // Treat this the same as if the wait was interrupted\n        if (status == ETIME) { status = EINTR; }\n        assert_status(status == 0 || status == EINTR, status, \"cond_wait\");\n     }\n     -- _nParked ;\n\n    _Event = 0 ;\n     status = pthread_mutex_unlock(_mutex);\n     assert_status(status == 0, status, \"mutex_unlock\");\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other.\n    OrderAccess::fence();\n  }\n  guarantee (_Event >= 0, \"invariant\") ;\n}\n\nint os::PlatformEvent::park(jlong millis) {\n  guarantee (_nParked == 0, \"invariant\") ;\n\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v != 0) return OS_OK ;\n\n  // We do this the hard way, by blocking the thread.\n  // Consider enforcing a minimum timeout value.\n  struct timespec abst;\n  compute_abstime(&abst, millis);\n\n  int ret = OS_TIMEOUT;\n  int status = pthread_mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  guarantee (_nParked == 0, \"invariant\") ;\n  ++_nParked ;\n\n  // Object.wait(timo) will return because of\n  // (a) notification\n  // (b) timeout\n  // (c) thread.interrupt\n  //\n  // Thread.interrupt and object.notify{All} both call Event::set.\n  // That is, we treat thread.interrupt as a special case of notification.\n  // The underlying Solaris implementation, cond_timedwait, admits\n  // spurious/premature wakeups, but the JLS/JVM spec prevents the\n  // JVM from making those visible to Java code.  As such, we must\n  // filter out spurious wakeups.  We assume all ETIME returns are valid.\n  //\n  // TODO: properly differentiate simultaneous notify+interrupt.\n  // In that case, we should propagate the notify to another waiter.\n\n  while (_Event < 0) {\n    status = os::Linux::safe_cond_timedwait(_cond, _mutex, &abst);\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (_cond);\n      pthread_cond_init (_cond, os::Linux::condAttr()) ;\n    }\n    assert_status(status == 0 || status == EINTR ||\n                  status == ETIME || status == ETIMEDOUT,\n                  status, \"cond_timedwait\");\n    if (!FilterSpuriousWakeups) break ;                 // previous semantics\n    if (status == ETIME || status == ETIMEDOUT) break ;\n    // We consume and ignore EINTR and spurious wakeups.\n  }\n  --_nParked ;\n  if (_Event >= 0) {\n     ret = OS_OK;\n  }\n  _Event = 0 ;\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  assert (_nParked == 0, \"invariant\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other.\n  OrderAccess::fence();\n  return ret;\n}\n\nvoid os::PlatformEvent::unpark() {\n  // Transitions for _Event:\n  //    0 :=> 1\n  //    1 :=> 1\n  //   -1 :=> either 0 or 1; must signal target thread\n  //          That is, we can safely transition _Event from -1 to either\n  //          0 or 1. Forcing 1 is slightly more efficient for back-to-back\n  //          unpark() calls.\n  // See also: \"Semaphores in Plan 9\" by Mullender & Cox\n  //\n  // Note: Forcing a transition from \"-1\" to \"1\" on an unpark() means\n  // that it will take two back-to-back park() calls for the owning\n  // thread to block. This has the benefit of forcing a spurious return\n  // from the first park() call after an unpark() call which will help\n  // shake out uses of park() and unpark() without condition variables.\n\n  if (Atomic::xchg(1, &_Event) >= 0) return;\n\n  // Wait for the thread associated with the event to vacate\n  int status = pthread_mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  int AnyWaiters = _nParked;\n  assert(AnyWaiters == 0 || AnyWaiters == 1, \"invariant\");\n  if (AnyWaiters != 0 && WorkAroundNPTLTimedWaitHang) {\n    AnyWaiters = 0;\n    pthread_cond_signal(_cond);\n  }\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  if (AnyWaiters != 0) {\n    status = pthread_cond_signal(_cond);\n    assert_status(status == 0, status, \"cond_signal\");\n  }\n\n  // Note that we signal() _after dropping the lock for \"immortal\" Events.\n  // This is safe and avoids a common class of  futile wakeups.  In rare\n  // circumstances this can cause a thread to return prematurely from\n  // cond_{timed}wait() but the spurious wakeup is benign and the victim will\n  // simply re-test the condition and re-park itself.\n}\n\n\n// JSR166\n// -------------------------------------------------------\n\n/*\n * The solaris and linux implementations of park/unpark are fairly\n * conservative for now, but can be improved. They currently use a\n * mutex/condvar pair, plus a a count.\n * Park decrements count if > 0, else does a condvar wait.  Unpark\n * sets count to 1 and signals condvar.  Only one thread ever waits\n * on the condvar. Contention seen when trying to park implies that someone\n * is unparking you, so don't wait. And spurious returns are fine, so there\n * is no need to track notifications.\n */\n\n/*\n * This code is common to linux and solaris and will be moved to a\n * common place in dolphin.\n *\n * The passed in time value is either a relative time in nanoseconds\n * or an absolute time in milliseconds. Either way it has to be unpacked\n * into suitable seconds and nanoseconds components and stored in the\n * given timespec structure.\n * Given time is a 64-bit value and the time_t used in the timespec is only\n * a signed-32-bit value (except on 64-bit Linux) we have to watch for\n * overflow if times way in the future are given. Further on Solaris versions\n * prior to 10 there is a restriction (see cond_timedwait) that the specified\n * number of seconds, in abstime, is less than current_time  + 100,000,000.\n * As it will be 28 years before \"now + 100000000\" will overflow we can\n * ignore overflow and just impose a hard-limit on seconds using the value\n * of \"now + 100,000,000\". This places a limit on the timeout of about 3.17\n * years from \"now\".\n */\n\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {\n  assert (time > 0, \"convertTime\");\n  time_t max_secs = 0;\n\n  if (!os::Linux::supports_monotonic_clock() || isAbsolute) {\n    struct timeval now;\n    int status = gettimeofday(&now, NULL);\n    assert(status == 0, \"gettimeofday\");\n\n    max_secs = now.tv_sec + MAX_SECS;\n\n    if (isAbsolute) {\n      jlong secs = time / 1000;\n      if (secs > max_secs) {\n        absTime->tv_sec = max_secs;\n      } else {\n        absTime->tv_sec = secs;\n      }\n      absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;\n    } else {\n      jlong secs = time / NANOSECS_PER_SEC;\n      if (secs >= MAX_SECS) {\n        absTime->tv_sec = max_secs;\n        absTime->tv_nsec = 0;\n      } else {\n        absTime->tv_sec = now.tv_sec + secs;\n        absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;\n        if (absTime->tv_nsec >= NANOSECS_PER_SEC) {\n          absTime->tv_nsec -= NANOSECS_PER_SEC;\n          ++absTime->tv_sec; // note: this must be <= max_secs\n        }\n      }\n    }\n  } else {\n    // must be relative using monotonic clock\n    struct timespec now;\n    int status = os::Linux::clock_gettime(CLOCK_MONOTONIC, &now);\n    assert_status(status == 0, status, \"clock_gettime\");\n    max_secs = now.tv_sec + MAX_SECS;\n    jlong secs = time / NANOSECS_PER_SEC;\n    if (secs >= MAX_SECS) {\n      absTime->tv_sec = max_secs;\n      absTime->tv_nsec = 0;\n    } else {\n      absTime->tv_sec = now.tv_sec + secs;\n      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_nsec;\n      if (absTime->tv_nsec >= NANOSECS_PER_SEC) {\n        absTime->tv_nsec -= NANOSECS_PER_SEC;\n        ++absTime->tv_sec; // note: this must be <= max_secs\n      }\n    }\n  }\n  assert(absTime->tv_sec >= 0, \"tv_sec < 0\");\n  assert(absTime->tv_sec <= max_secs, \"tv_sec > max_secs\");\n  assert(absTime->tv_nsec >= 0, \"tv_nsec < 0\");\n  assert(absTime->tv_nsec < NANOSECS_PER_SEC, \"tv_nsec >= nanos_per_sec\");\n}\n\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n  JavaThread *jt = (JavaThread *)thread;\n\n  // Optional optimization -- avoid state transitions if there's an interrupt pending.\n  // Check interrupt before trying to wait\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n\n  // Next, demultiplex/decode time arguments\n  timespec absTime;\n  if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all\n    return;\n  }\n  if (time > 0) {\n    unpackTime(&absTime, isAbsolute, time);\n  }\n\n\n  // Enter safepoint region\n  // Beware of deadlocks such as 6317397.\n  // The per-thread Parker:: mutex is a classic leaf-lock.\n  // In particular a thread must never block on the Threads_lock while\n  // holding the Parker:: mutex.  If safepoints are pending both the\n  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.\n  ThreadBlockInVM tbivm(jt);\n\n  // Don't wait if cannot get lock since interference arises from\n  // unblocking.  Also. check interrupt before trying wait\n  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {\n    return;\n  }\n\n  int status ;\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other and Java-level accesses.\n    OrderAccess::fence();\n    return;\n  }\n\n#ifdef ASSERT\n  // Don't catch signals while blocked; let the running threads have the signals.\n  // (This allows a debugger to break into the running thread.)\n  sigset_t oldsigs;\n  sigset_t* allowdebug_blocked = os::Linux::allowdebug_blocked_signals();\n  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);\n#endif\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n  assert(_cur_index == -1, \"invariant\");\n  if (time == 0) {\n    _cur_index = REL_INDEX; // arbitrary choice when not timed\n    status = pthread_cond_wait (&_cond[_cur_index], _mutex) ;\n  } else {\n    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;\n    status = os::Linux::safe_cond_timedwait (&_cond[_cur_index], _mutex, &absTime) ;\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (&_cond[_cur_index]) ;\n      pthread_cond_init    (&_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());\n    }\n  }\n  _cur_index = -1;\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIME || status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other and Java-level accesses.\n  OrderAccess::fence();\n\n  // If externally suspended while waiting, re-suspend\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n}\n\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n    // thread might be parked\n    if (_cur_index != -1) {\n      // thread is definitely parked\n      if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (&_cond[_cur_index]);\n        assert (status == 0, \"invariant\");\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n      } else {\n        // must capture correct index before unlocking\n        int index = _cur_index;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n        status = pthread_cond_signal (&_cond[index]);\n        assert (status == 0, \"invariant\");\n      }\n    } else {\n      pthread_mutex_unlock(_mutex);\n      assert (status == 0, \"invariant\") ;\n    }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n\n\nextern char** environ;\n\n// Run the specified command in a separate process. Return its exit value,\n// or -1 on failure (e.g. can't fork a new process).\n// Unlike system(), this function can be called from signal handler. It\n// doesn't block SIGINT et al.\nint os::fork_and_exec(char* cmd) {\n  const char * argv[4] = {\"sh\", \"-c\", cmd, NULL};\n\n  pid_t pid = fork();\n\n  if (pid < 0) {\n    // fork failed\n    return -1;\n\n  } else if (pid == 0) {\n    // child process\n\n    execve(\"/bin/sh\", (char* const*)argv, environ);\n\n    // execve failed\n    _exit(-1);\n\n  } else  {\n    // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n    // care about the actual exit code, for now.\n\n    int status;\n\n    // Wait for the child process to exit.  This returns immediately if\n    // the child has already exited. */\n    while (waitpid(pid, &status, 0) < 0) {\n        switch (errno) {\n        case ECHILD: return 0;\n        case EINTR: break;\n        default: return -1;\n        }\n    }\n\n    if (WIFEXITED(status)) {\n       // The child exited normally; get its exit code.\n       return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n       // The child exited because of a signal\n       // The best value to return is 0x80 + signal number,\n       // because that is what all Unix shells do, and because\n       // it allows callers to distinguish between process exit and\n       // process death by signal.\n       return 0x80 + WTERMSIG(status);\n    } else {\n       // Unknown exit code; pass it through\n       return status;\n    }\n  }\n}\n\n// is_headless_jre()\n//\n// Test for the existence of xawt/libmawt.so or libawt_xawt.so\n// in order to report if we are running in a headless jre\n//\n// Since JDK8 xawt/libmawt.so was moved into the same directory\n// as libawt.so, and renamed libawt_xawt.so\n//\nbool os::is_headless_jre() {\n    struct stat statbuf;\n    char buf[MAXPATHLEN];\n    char libmawtpath[MAXPATHLEN];\n    const char *xawtstr  = \"/xawt/libmawt.so\";\n    const char *new_xawtstr = \"/libawt_xawt.so\";\n    char *p;\n\n    // Get path to libjvm.so\n    os::jvm_path(buf, sizeof(buf));\n\n    // Get rid of libjvm.so\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // Get rid of client or server\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // check xawt/libmawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    // check libawt_xawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, new_xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    return true;\n}\n\n// Get the default path to the core file\n// Returns the length of the string\nint os::get_core_path(char* buffer, size_t bufferSize) {\n  const char* p = get_current_directory(buffer, bufferSize);\n\n  if (p == NULL) {\n    assert(p != NULL, \"failed to get current directory\");\n    return 0;\n  }\n\n  return strlen(buffer);\n}\n\n/////////////// Unit tests ///////////////\n\n#ifndef PRODUCT\n\n#define test_log(...) \\\n  do {\\\n    if (VerboseInternalVMTests) { \\\n      tty->print_cr(__VA_ARGS__); \\\n      tty->flush(); \\\n    }\\\n  } while (false)\n\nclass TestReserveMemorySpecial : AllStatic {\n public:\n  static void small_page_write(void* addr, size_t size) {\n    size_t page_size = os::vm_page_size();\n\n    char* end = (char*)addr + size;\n    for (char* p = (char*)addr; p < end; p += page_size) {\n      *p = 1;\n    }\n  }\n\n  static void test_reserve_memory_special_huge_tlbfs_only(size_t size) {\n    if (!UseHugeTLBFS) {\n      return;\n    }\n\n    test_log(\"test_reserve_memory_special_huge_tlbfs_only(\" SIZE_FORMAT \")\", size);\n\n    char* addr = os::Linux::reserve_memory_special_huge_tlbfs_only(size, NULL, false);\n\n    if (addr != NULL) {\n      small_page_write(addr, size);\n\n      os::Linux::release_memory_special_huge_tlbfs(addr, size);\n    }\n  }\n\n  static void test_reserve_memory_special_huge_tlbfs_only() {\n    if (!UseHugeTLBFS) {\n      return;\n    }\n\n    size_t lp = os::large_page_size();\n\n    for (size_t size = lp; size <= lp * 10; size += lp) {\n      test_reserve_memory_special_huge_tlbfs_only(size);\n    }\n  }\n\n  static void test_reserve_memory_special_huge_tlbfs_mixed() {\n    size_t lp = os::large_page_size();\n    size_t ag = os::vm_allocation_granularity();\n\n    // sizes to test\n    const size_t sizes[] = {\n      lp, lp + ag, lp + lp / 2, lp * 2,\n      lp * 2 + ag, lp * 2 - ag, lp * 2 + lp / 2,\n      lp * 10, lp * 10 + lp / 2\n    };\n    const int num_sizes = sizeof(sizes) / sizeof(size_t);\n\n    // For each size/alignment combination, we test three scenarios:\n    // 1) with req_addr == NULL\n    // 2) with a non-null req_addr at which we expect to successfully allocate\n    // 3) with a non-null req_addr which contains a pre-existing mapping, at which we\n    //    expect the allocation to either fail or to ignore req_addr\n\n    // Pre-allocate two areas; they shall be as large as the largest allocation\n    //  and aligned to the largest alignment we will be testing.\n    const size_t mapping_size = sizes[num_sizes - 1] * 2;\n    char* const mapping1 = (char*) ::mmap(NULL, mapping_size,\n      PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n      -1, 0);\n    assert(mapping1 != MAP_FAILED, \"should work\");\n\n    char* const mapping2 = (char*) ::mmap(NULL, mapping_size,\n      PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n      -1, 0);\n    assert(mapping2 != MAP_FAILED, \"should work\");\n\n    // Unmap the first mapping, but leave the second mapping intact: the first\n    // mapping will serve as a value for a \"good\" req_addr (case 2). The second\n    // mapping, still intact, as \"bad\" req_addr (case 3).\n    ::munmap(mapping1, mapping_size);\n\n    // Case 1\n    test_log(\"%s, req_addr NULL:\", __FUNCTION__);\n    test_log(\"size            align           result\");\n\n    for (int i = 0; i < num_sizes; i++) {\n      const size_t size = sizes[i];\n      for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n        char* p = os::Linux::reserve_memory_special_huge_tlbfs_mixed(size, alignment, NULL, false);\n        test_log(SIZE_FORMAT_HEX \" \" SIZE_FORMAT_HEX \" ->  \" PTR_FORMAT \" %s\",\n            size, alignment, p, (p != NULL ? \"\" : \"(failed)\"));\n        if (p != NULL) {\n          assert(is_ptr_aligned(p, alignment), \"must be\");\n          small_page_write(p, size);\n          os::Linux::release_memory_special_huge_tlbfs(p, size);\n        }\n      }\n    }\n\n    // Case 2\n    test_log(\"%s, req_addr non-NULL:\", __FUNCTION__);\n    test_log(\"size            align           req_addr         result\");\n\n    for (int i = 0; i < num_sizes; i++) {\n      const size_t size = sizes[i];\n      for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n        char* const req_addr = (char*) align_ptr_up(mapping1, alignment);\n        char* p = os::Linux::reserve_memory_special_huge_tlbfs_mixed(size, alignment, req_addr, false);\n        test_log(SIZE_FORMAT_HEX \" \" SIZE_FORMAT_HEX \" \" PTR_FORMAT \" ->  \" PTR_FORMAT \" %s\",\n            size, alignment, req_addr, p,\n            ((p != NULL ? (p == req_addr ? \"(exact match)\" : \"\") : \"(failed)\")));\n        if (p != NULL) {\n          assert(p == req_addr, \"must be\");\n          small_page_write(p, size);\n          os::Linux::release_memory_special_huge_tlbfs(p, size);\n        }\n      }\n    }\n\n    // Case 3\n    test_log(\"%s, req_addr non-NULL with preexisting mapping:\", __FUNCTION__);\n    test_log(\"size            align           req_addr         result\");\n\n    for (int i = 0; i < num_sizes; i++) {\n      const size_t size = sizes[i];\n      for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n        char* const req_addr = (char*) align_ptr_up(mapping2, alignment);\n        char* p = os::Linux::reserve_memory_special_huge_tlbfs_mixed(size, alignment, req_addr, false);\n        test_log(SIZE_FORMAT_HEX \" \" SIZE_FORMAT_HEX \" \" PTR_FORMAT \" ->  \" PTR_FORMAT \" %s\",\n            size, alignment, req_addr, p,\n            ((p != NULL ? \"\" : \"(failed)\")));\n        // as the area around req_addr contains already existing mappings, the API should always\n        // return NULL (as per contract, it cannot return another address)\n        assert(p == NULL, \"must be\");\n      }\n    }\n\n    ::munmap(mapping2, mapping_size);\n\n  }\n\n  static void test_reserve_memory_special_huge_tlbfs() {\n    if (!UseHugeTLBFS) {\n      return;\n    }\n\n    test_reserve_memory_special_huge_tlbfs_only();\n    test_reserve_memory_special_huge_tlbfs_mixed();\n  }\n\n  static void test_reserve_memory_special_shm(size_t size, size_t alignment) {\n    if (!UseSHM) {\n      return;\n    }\n\n    test_log(\"test_reserve_memory_special_shm(\" SIZE_FORMAT \", \" SIZE_FORMAT \")\", size, alignment);\n\n    char* addr = os::Linux::reserve_memory_special_shm(size, alignment, NULL, false);\n\n    if (addr != NULL) {\n      assert(is_ptr_aligned(addr, alignment), \"Check\");\n      assert(is_ptr_aligned(addr, os::large_page_size()), \"Check\");\n\n      small_page_write(addr, size);\n\n      os::Linux::release_memory_special_shm(addr, size);\n    }\n  }\n\n  static void test_reserve_memory_special_shm() {\n    size_t lp = os::large_page_size();\n    size_t ag = os::vm_allocation_granularity();\n\n    for (size_t size = ag; size < lp * 3; size += ag) {\n      for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n        test_reserve_memory_special_shm(size, alignment);\n      }\n    }\n  }\n\n  static void test() {\n    test_reserve_memory_special_huge_tlbfs();\n    test_reserve_memory_special_shm();\n  }\n};\n\nvoid TestReserveMemorySpecial_test() {\n  TestReserveMemorySpecial::test();\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os/linux/vm/jsig.c": "/*\n * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n/* CopyrightVersion 1.2 */\n\n/* This is a special library that should be loaded before libc &\n * libthread to interpose the signal handler installation functions:\n * sigaction(), signal(), sigset().\n * Used for signal-chaining. See RFE 4381843.\n */\n\n#include <signal.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define bool int\n#define true 1\n#define false 0\n\n#define MAXSIGNUM 32\n#define MASK(sig) ((unsigned int)1 << sig)\n\nstatic struct sigaction sact[MAXSIGNUM]; /* saved signal handlers */\nstatic unsigned int jvmsigs = 0; /* signals used by jvm */\n\n/* used to synchronize the installation of signal handlers */\nstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t tid = 0;\n\ntypedef void (*sa_handler_t)(int);\ntypedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\ntypedef sa_handler_t (*signal_t)(int, sa_handler_t);\ntypedef int (*sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic signal_t os_signal = 0; /* os's version of signal()/sigset() */\nstatic sigaction_t os_sigaction = 0; /* os's version of sigaction() */\n\nstatic bool jvm_signal_installing = false;\nstatic bool jvm_signal_installed = false;\n\nstatic void signal_lock() {\n  pthread_mutex_lock(&mutex);\n  /* When the jvm is installing its set of signal handlers, threads\n   * other than the jvm thread should wait */\n  if (jvm_signal_installing) {\n    if (tid != pthread_self()) {\n      pthread_cond_wait(&cond, &mutex);\n    }\n  }\n}\n\nstatic void signal_unlock() {\n  pthread_mutex_unlock(&mutex);\n}\n\nstatic sa_handler_t call_os_signal(int sig, sa_handler_t disp,\n                                   bool is_sigset) {\n  if (os_signal == NULL) {\n    if (!is_sigset) {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"signal\");\n    } else {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"sigset\");\n    }\n    if (os_signal == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_signal)(sig, disp);\n}\n\nstatic void save_signal_handler(int sig, sa_handler_t disp) {\n  sigset_t set;\n  sact[sig].sa_handler = disp;\n  sigemptyset(&set);\n  sact[sig].sa_mask = set;\n  sact[sig].sa_flags = 0;\n}\n\nstatic sa_handler_t set_signal(int sig, sa_handler_t disp, bool is_sigset) {\n  sa_handler_t oldhandler;\n  bool sigused;\n\n  signal_lock();\n\n  sigused = (sig < MAXSIGNUM) && ((MASK(sig) & jvmsigs) != 0);\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    oldhandler = sact[sig].sa_handler;\n    save_signal_handler(sig, disp);\n\n    signal_unlock();\n    return oldhandler;\n  } else if (sig < MAXSIGNUM && jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. jvm uses sigaction().\n     * Leave the piece here just in case. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n    save_signal_handler(sig, oldhandler);\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return oldhandler;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n\n    signal_unlock();\n    return oldhandler;\n  }\n}\n\nsa_handler_t signal(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, false);\n}\n\nsa_handler_t sigset(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, true);\n }\n\nstatic int call_os_sigaction(int sig, const struct sigaction  *act,\n                             struct sigaction *oact) {\n  if (os_sigaction == NULL) {\n    os_sigaction = (sigaction_t)dlsym(RTLD_NEXT, \"sigaction\");\n    if (os_sigaction == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_sigaction)(sig, act, oact);\n}\n\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact) {\n  int res;\n  bool sigused;\n  struct sigaction oldAct;\n\n  signal_lock();\n\n  sigused = (sig < MAXSIGNUM) && ((MASK(sig) & jvmsigs) != 0);\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    if (oact != NULL) {\n      *oact = sact[sig];\n    }\n    if (act != NULL) {\n      sact[sig] = *act;\n    }\n\n    signal_unlock();\n    return 0;\n  } else if (sig < MAXSIGNUM && jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. */\n    res = call_os_sigaction(sig, act, &oldAct);\n    sact[sig] = oldAct;\n    if (oact != NULL) {\n      *oact = oldAct;\n    }\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return res;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    res = call_os_sigaction(sig, act, oact);\n\n    signal_unlock();\n    return res;\n  }\n}\n\n/* The three functions for the jvm to call into */\nvoid JVM_begin_signal_setting() {\n  signal_lock();\n  jvm_signal_installing = true;\n  tid = pthread_self();\n  signal_unlock();\n}\n\nvoid JVM_end_signal_setting() {\n  signal_lock();\n  jvm_signal_installed = true;\n  jvm_signal_installing = false;\n  pthread_cond_broadcast(&cond);\n  signal_unlock();\n}\n\nstruct sigaction *JVM_get_signal_action(int sig) {\n  /* Does race condition make sense here? */\n  if ((MASK(sig) & jvmsigs) != 0) {\n    return &sact[sig];\n  }\n  return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os/solaris/vm/jsig.c": "/*\n * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n/* CopyrightVersion 1.2 */\n\n/* This is a special library that should be loaded before libc &\n * libthread to interpose the signal handler installation functions:\n * sigaction(), signal(), sigset().\n * Used for signal-chaining. See RFE 4381843.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n#include <dlfcn.h>\n#include <thread.h>\n#include <synch.h>\n#include \"jvm_solaris.h\"\n\n#define bool int\n#define true 1\n#define false 0\n\nstatic struct sigaction *sact = (struct sigaction *)NULL; /* saved signal handlers */\nstatic sigset_t jvmsigs;\n\n/* used to synchronize the installation of signal handlers */\nstatic mutex_t mutex = DEFAULTMUTEX;\nstatic cond_t cond = DEFAULTCV;\nstatic thread_t tid = 0;\n\ntypedef void (*sa_handler_t)(int);\ntypedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\ntypedef sa_handler_t (*signal_t)(int, sa_handler_t);\ntypedef int (*sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic signal_t os_signal = 0; /* os's version of signal()/sigset() */\nstatic sigaction_t os_sigaction = 0; /* os's version of sigaction() */\n\nstatic bool jvm_signal_installing = false;\nstatic bool jvm_signal_installed = false;\n\n\n/* assume called within signal_lock */\nstatic void allocate_sact() {\n  size_t maxsignum;\n  maxsignum = SIGRTMAX;\n  if (sact == NULL) {\n    sact = (struct sigaction *)malloc((maxsignum+1) * (size_t)sizeof(struct sigaction));\n    memset(sact, 0, (maxsignum+1) * (size_t)sizeof(struct sigaction));\n  }\n\n  if (sact == NULL) {\n    printf(\"%s\\n\", \"libjsig.so unable to allocate memory\");\n    exit(0);\n  }\n\n  sigemptyset(&jvmsigs);\n}\n\nstatic void signal_lock() {\n  mutex_lock(&mutex);\n  /* When the jvm is installing its set of signal handlers, threads\n   * other than the jvm thread should wait */\n  if (jvm_signal_installing) {\n    if (tid != thr_self()) {\n      cond_wait(&cond, &mutex);\n    }\n  }\n}\n\nstatic void signal_unlock() {\n  mutex_unlock(&mutex);\n}\n\nstatic sa_handler_t call_os_signal(int sig, sa_handler_t disp,\n                                   bool is_sigset) {\n  if (os_signal == NULL) {\n    if (!is_sigset) {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"signal\");\n    } else {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"sigset\");\n    }\n    if (os_signal == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_signal)(sig, disp);\n}\n\nstatic void save_signal_handler(int sig, sa_handler_t disp, bool is_sigset) {\n  sigset_t set;\n  if (sact == NULL) {\n    allocate_sact();\n  }\n  sact[sig].sa_handler = disp;\n  sigemptyset(&set);\n  sact[sig].sa_mask = set;\n  if (!is_sigset) {\n    sact[sig].sa_flags = SA_NODEFER;\n    if (sig != SIGILL && sig != SIGTRAP && sig != SIGPWR) {\n      sact[sig].sa_flags |= SA_RESETHAND;\n    }\n  } else {\n    sact[sig].sa_flags = 0;\n  }\n}\n\nstatic sa_handler_t set_signal(int sig, sa_handler_t disp, bool is_sigset) {\n  sa_handler_t oldhandler;\n  bool sigblocked;\n\n  signal_lock();\n  if (sact == NULL) {\n    allocate_sact();\n  }\n\n  if (jvm_signal_installed && sigismember(&jvmsigs, sig)) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    if (is_sigset) {\n      /* We won't honor the SIG_HOLD request to change the signal mask */\n      sigblocked = sigismember(&(sact[sig].sa_mask), sig);\n    }\n    oldhandler = sact[sig].sa_handler;\n    save_signal_handler(sig, disp, is_sigset);\n\n    if (is_sigset && sigblocked) {\n      oldhandler = SIG_HOLD;\n    }\n\n    signal_unlock();\n    return oldhandler;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. jvm uses sigaction().\n     * Leave the piece here just in case. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n    save_signal_handler(sig, oldhandler, is_sigset);\n\n    /* Record the signals used by jvm */\n    sigaddset(&jvmsigs, sig);\n\n    signal_unlock();\n    return oldhandler;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n\n    signal_unlock();\n    return oldhandler;\n  }\n}\n\nsa_handler_t signal(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, false);\n}\n\nsa_handler_t sigset(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, true);\n}\n\nstatic int call_os_sigaction(int sig, const struct sigaction  *act,\n                             struct sigaction *oact) {\n  if (os_sigaction == NULL) {\n    os_sigaction = (sigaction_t)dlsym(RTLD_NEXT, \"sigaction\");\n    if (os_sigaction == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_sigaction)(sig, act, oact);\n}\n\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact) {\n  int res;\n  struct sigaction oldAct;\n\n  signal_lock();\n\n  if (sact == NULL ) {\n    allocate_sact();\n  }\n  if (jvm_signal_installed && sigismember(&jvmsigs, sig)) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    if (oact != NULL) {\n      *oact = sact[sig];\n    }\n    if (act != NULL) {\n      sact[sig] = *act;\n    }\n\n    signal_unlock();\n    return 0;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. */\n    res = call_os_sigaction(sig, act, &oldAct);\n    sact[sig] = oldAct;\n    if (oact != NULL) {\n      *oact = oldAct;\n    }\n\n    /* Record the signals used by jvm */\n    sigaddset(&jvmsigs, sig);\n\n    signal_unlock();\n    return res;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    res = call_os_sigaction(sig, act, oact);\n\n    signal_unlock();\n    return res;\n  }\n}\n\n/* The four functions for the jvm to call into */\nvoid JVM_begin_signal_setting() {\n  signal_lock();\n  jvm_signal_installing = true;\n  tid = thr_self();\n  signal_unlock();\n}\n\nvoid JVM_end_signal_setting() {\n  signal_lock();\n  jvm_signal_installed = true;\n  jvm_signal_installing = false;\n  cond_broadcast(&cond);\n  signal_unlock();\n}\n\nstruct sigaction *JVM_get_signal_action(int sig) {\n  if (sact == NULL) {\n    allocate_sact();\n  }\n  /* Does race condition make sense here? */\n  if (sigismember(&jvmsigs, sig)) {\n    return &sact[sig];\n  }\n  return NULL;\n}\n\nint JVM_get_libjsig_version() {\n  return JSIG_VERSION_1_4_1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os/solaris/vm/os_solaris.cpp": "/*\n * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n// no precompiled headers\n#include \"classfile/classLoader.hpp\"\n#include \"classfile/systemDictionary.hpp\"\n#include \"classfile/vmSymbols.hpp\"\n#include \"code/icBuffer.hpp\"\n#include \"code/vtableStubs.hpp\"\n#include \"compiler/compileBroker.hpp\"\n#include \"compiler/disassembler.hpp\"\n#include \"interpreter/interpreter.hpp\"\n#include \"jvm_solaris.h\"\n#include \"memory/allocation.inline.hpp\"\n#include \"memory/filemap.hpp\"\n#include \"mutex_solaris.inline.hpp\"\n#include \"oops/oop.inline.hpp\"\n#include \"os_share_solaris.hpp\"\n#include \"prims/jniFastGetField.hpp\"\n#include \"prims/jvm.h\"\n#include \"prims/jvm_misc.hpp\"\n#include \"runtime/arguments.hpp\"\n#include \"runtime/extendedPC.hpp\"\n#include \"runtime/globals.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/java.hpp\"\n#include \"runtime/javaCalls.hpp\"\n#include \"runtime/mutexLocker.hpp\"\n#include \"runtime/objectMonitor.hpp\"\n#include \"runtime/orderAccess.inline.hpp\"\n#include \"runtime/osThread.hpp\"\n#include \"runtime/perfMemory.hpp\"\n#include \"runtime/sharedRuntime.hpp\"\n#include \"runtime/statSampler.hpp\"\n#include \"runtime/stubRoutines.hpp\"\n#include \"runtime/thread.inline.hpp\"\n#include \"runtime/threadCritical.hpp\"\n#include \"runtime/timer.hpp\"\n#include \"services/attachListener.hpp\"\n#include \"services/memTracker.hpp\"\n#include \"services/runtimeService.hpp\"\n#include \"utilities/decoder.hpp\"\n#include \"utilities/defaultStream.hpp\"\n#include \"utilities/events.hpp\"\n#include \"utilities/growableArray.hpp\"\n#include \"utilities/vmError.hpp\"\n\n// put OS-includes here\n# include <dlfcn.h>\n# include <errno.h>\n# include <exception>\n# include <link.h>\n# include <poll.h>\n# include <pthread.h>\n# include <pwd.h>\n# include <schedctl.h>\n# include <setjmp.h>\n# include <signal.h>\n# include <stdio.h>\n# include <alloca.h>\n# include <sys/filio.h>\n# include <sys/ipc.h>\n# include <sys/lwp.h>\n# include <sys/machelf.h>     // for elf Sym structure used by dladdr1\n# include <sys/mman.h>\n# include <sys/processor.h>\n# include <sys/procset.h>\n# include <sys/pset.h>\n# include <sys/resource.h>\n# include <sys/shm.h>\n# include <sys/socket.h>\n# include <sys/stat.h>\n# include <sys/systeminfo.h>\n# include <sys/time.h>\n# include <sys/times.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <sys/utsname.h>\n# include <thread.h>\n# include <unistd.h>\n# include <sys/priocntl.h>\n# include <sys/rtpriocntl.h>\n# include <sys/tspriocntl.h>\n# include <sys/iapriocntl.h>\n# include <sys/fxpriocntl.h>\n# include <sys/loadavg.h>\n# include <string.h>\n# include <stdio.h>\n\n# define _STRUCTURED_PROC 1  //  this gets us the new structured proc interfaces of 5.6 & later\n# include <sys/procfs.h>     //  see comment in <sys/procfs.h>\n\n#define MAX_PATH (2 * K)\n\n// for timer info max values which include all bits\n#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n\n\n// Here are some liblgrp types from sys/lgrp_user.h to be able to\n// compile on older systems without this header file.\n\n#ifndef MADV_ACCESS_LWP\n# define  MADV_ACCESS_LWP         7       /* next LWP to access heavily */\n#endif\n#ifndef MADV_ACCESS_MANY\n# define  MADV_ACCESS_MANY        8       /* many processes to access heavily */\n#endif\n\n#ifndef LGRP_RSRC_CPU\n# define LGRP_RSRC_CPU           0       /* CPU resources */\n#endif\n#ifndef LGRP_RSRC_MEM\n# define LGRP_RSRC_MEM           1       /* memory resources */\n#endif\n\n// see thr_setprio(3T) for the basis of these numbers\n#define MinimumPriority 0\n#define NormalPriority  64\n#define MaximumPriority 127\n\n// Values for ThreadPriorityPolicy == 1\nint prio_policy1[CriticalPriority+1] = {\n  -99999,  0, 16,  32,  48,  64,\n          80, 96, 112, 124, 127, 127 };\n\n// System parameters used internally\nstatic clock_t clock_tics_per_sec = 100;\n\n// Track if we have called enable_extended_FILE_stdio (on Solaris 10u4+)\nstatic bool enabled_extended_FILE_stdio = false;\n\n// For diagnostics to print a message once. see run_periodic_checks\nstatic bool check_addr0_done = false;\nstatic sigset_t check_signal_done;\nstatic bool check_signals = true;\n\naddress os::Solaris::handler_start;  // start pc of thr_sighndlrinfo\naddress os::Solaris::handler_end;    // end pc of thr_sighndlrinfo\n\naddress os::Solaris::_main_stack_base = NULL;  // 4352906 workaround\n\n\n// \"default\" initializers for missing libc APIs\nextern \"C\" {\n  static int lwp_mutex_init(mutex_t *mx, int scope, void *arg) { memset(mx, 0, sizeof(mutex_t)); return 0; }\n  static int lwp_mutex_destroy(mutex_t *mx)                 { return 0; }\n\n  static int lwp_cond_init(cond_t *cv, int scope, void *arg){ memset(cv, 0, sizeof(cond_t)); return 0; }\n  static int lwp_cond_destroy(cond_t *cv)                   { return 0; }\n}\n\n// \"default\" initializers for pthread-based synchronization\nextern \"C\" {\n  static int pthread_mutex_default_init(mutex_t *mx, int scope, void *arg) { memset(mx, 0, sizeof(mutex_t)); return 0; }\n  static int pthread_cond_default_init(cond_t *cv, int scope, void *arg){ memset(cv, 0, sizeof(cond_t)); return 0; }\n}\n\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time);\n\nstatic inline size_t adjust_stack_size(address base, size_t size) {\n  if ((ssize_t)size < 0) {\n    // 4759953: Compensate for ridiculous stack size.\n    size = max_intx;\n  }\n  if (size > (size_t)base) {\n    // 4812466: Make sure size doesn't allow the stack to wrap the address space.\n    size = (size_t)base;\n  }\n  return size;\n}\n\nstatic inline stack_t get_stack_info() {\n  stack_t st;\n  int retval = thr_stksegment(&st);\n  st.ss_size = adjust_stack_size((address)st.ss_sp, st.ss_size);\n  assert(retval == 0, \"incorrect return value from thr_stksegment\");\n  assert((address)&st < (address)st.ss_sp, \"Invalid stack base returned\");\n  assert((address)&st > (address)st.ss_sp-st.ss_size, \"Invalid stack size returned\");\n  return st;\n}\n\naddress os::current_stack_base() {\n  int r = thr_main() ;\n  guarantee (r == 0 || r == 1, \"CR6501650 or CR6493689\") ;\n  bool is_primordial_thread = r;\n\n  // Workaround 4352906, avoid calls to thr_stksegment by\n  // thr_main after the first one (it looks like we trash\n  // some data, causing the value for ss_sp to be incorrect).\n  if (!is_primordial_thread || os::Solaris::_main_stack_base == NULL) {\n    stack_t st = get_stack_info();\n    if (is_primordial_thread) {\n      // cache initial value of stack base\n      os::Solaris::_main_stack_base = (address)st.ss_sp;\n    }\n    return (address)st.ss_sp;\n  } else {\n    guarantee(os::Solaris::_main_stack_base != NULL, \"Attempt to use null cached stack base\");\n    return os::Solaris::_main_stack_base;\n  }\n}\n\nsize_t os::current_stack_size() {\n  size_t size;\n\n  int r = thr_main() ;\n  guarantee (r == 0 || r == 1, \"CR6501650 or CR6493689\") ;\n  if(!r) {\n    size = get_stack_info().ss_size;\n  } else {\n    struct rlimit limits;\n    getrlimit(RLIMIT_STACK, &limits);\n    size = adjust_stack_size(os::Solaris::_main_stack_base, (size_t)limits.rlim_cur);\n  }\n  // base may not be page aligned\n  address base = current_stack_base();\n  address bottom = (address)align_size_up((intptr_t)(base - size), os::vm_page_size());;\n  return (size_t)(base - bottom);\n}\n\nstruct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {\n  return localtime_r(clock, res);\n}\n\n// interruptible infrastructure\n\n// setup_interruptible saves the thread state before going into an\n// interruptible system call.\n// The saved state is used to restore the thread to\n// its former state whether or not an interrupt is received.\n// Used by classloader os::read\n// os::restartable_read calls skip this layer and stay in _thread_in_native\n\nvoid os::Solaris::setup_interruptible(JavaThread* thread) {\n\n  JavaThreadState thread_state = thread->thread_state();\n\n  assert(thread_state != _thread_blocked, \"Coming from the wrong thread\");\n  assert(thread_state != _thread_in_native, \"Native threads skip setup_interruptible\");\n  OSThread* osthread = thread->osthread();\n  osthread->set_saved_interrupt_thread_state(thread_state);\n  thread->frame_anchor()->make_walkable(thread);\n  ThreadStateTransition::transition(thread, thread_state, _thread_blocked);\n}\n\n// Version of setup_interruptible() for threads that are already in\n// _thread_blocked. Used by os_sleep().\nvoid os::Solaris::setup_interruptible_already_blocked(JavaThread* thread) {\n  thread->frame_anchor()->make_walkable(thread);\n}\n\nJavaThread* os::Solaris::setup_interruptible() {\n  JavaThread* thread = (JavaThread*)ThreadLocalStorage::thread();\n  setup_interruptible(thread);\n  return thread;\n}\n\nvoid os::Solaris::try_enable_extended_io() {\n  typedef int (*enable_extended_FILE_stdio_t)(int, int);\n\n  if (!UseExtendedFileIO) {\n    return;\n  }\n\n  enable_extended_FILE_stdio_t enabler =\n    (enable_extended_FILE_stdio_t) dlsym(RTLD_DEFAULT,\n                                         \"enable_extended_FILE_stdio\");\n  if (enabler) {\n    enabler(-1, -1);\n  }\n}\n\n\n#ifdef ASSERT\n\nJavaThread* os::Solaris::setup_interruptible_native() {\n  JavaThread* thread = (JavaThread*)ThreadLocalStorage::thread();\n  JavaThreadState thread_state = thread->thread_state();\n  assert(thread_state == _thread_in_native, \"Assumed thread_in_native\");\n  return thread;\n}\n\nvoid os::Solaris::cleanup_interruptible_native(JavaThread* thread) {\n  JavaThreadState thread_state = thread->thread_state();\n  assert(thread_state == _thread_in_native, \"Assumed thread_in_native\");\n}\n#endif\n\n// cleanup_interruptible reverses the effects of setup_interruptible\n// setup_interruptible_already_blocked() does not need any cleanup.\n\nvoid os::Solaris::cleanup_interruptible(JavaThread* thread) {\n  OSThread* osthread = thread->osthread();\n\n  ThreadStateTransition::transition(thread, _thread_blocked, osthread->saved_interrupt_thread_state());\n}\n\n// I/O interruption related counters called in _INTERRUPTIBLE\n\nvoid os::Solaris::bump_interrupted_before_count() {\n  RuntimeService::record_interrupted_before_count();\n}\n\nvoid os::Solaris::bump_interrupted_during_count() {\n  RuntimeService::record_interrupted_during_count();\n}\n\nstatic int _processors_online = 0;\n\n         jint os::Solaris::_os_thread_limit = 0;\nvolatile jint os::Solaris::_os_thread_count = 0;\n\njulong os::available_memory() {\n  return Solaris::available_memory();\n}\n\njulong os::Solaris::available_memory() {\n  return (julong)sysconf(_SC_AVPHYS_PAGES) * os::vm_page_size();\n}\n\njulong os::Solaris::_physical_memory = 0;\n\njulong os::physical_memory() {\n   return Solaris::physical_memory();\n}\n\nstatic hrtime_t first_hrtime = 0;\nstatic const hrtime_t hrtime_hz = 1000*1000*1000;\nstatic volatile hrtime_t max_hrtime = 0;\n\n\nvoid os::Solaris::initialize_system_info() {\n  set_processor_count(sysconf(_SC_NPROCESSORS_CONF));\n  _processors_online = sysconf (_SC_NPROCESSORS_ONLN);\n  _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);\n}\n\nint os::active_processor_count() {\n  int online_cpus = sysconf(_SC_NPROCESSORS_ONLN);\n  pid_t pid = getpid();\n  psetid_t pset = PS_NONE;\n  // Are we running in a processor set or is there any processor set around?\n  if (pset_bind(PS_QUERY, P_PID, pid, &pset) == 0) {\n    uint_t pset_cpus;\n    // Query the number of cpus available to us.\n    if (pset_info(pset, NULL, &pset_cpus, NULL) == 0) {\n      assert(pset_cpus > 0 && pset_cpus <= online_cpus, \"sanity check\");\n      _processors_online = pset_cpus;\n      return pset_cpus;\n    }\n  }\n  // Otherwise return number of online cpus\n  return online_cpus;\n}\n\nstatic bool find_processors_in_pset(psetid_t        pset,\n                                    processorid_t** id_array,\n                                    uint_t*         id_length) {\n  bool result = false;\n  // Find the number of processors in the processor set.\n  if (pset_info(pset, NULL, id_length, NULL) == 0) {\n    // Make up an array to hold their ids.\n    *id_array = NEW_C_HEAP_ARRAY(processorid_t, *id_length, mtInternal);\n    // Fill in the array with their processor ids.\n    if (pset_info(pset, NULL, id_length, *id_array) == 0) {\n      result = true;\n    }\n  }\n  return result;\n}\n\n// Callers of find_processors_online() must tolerate imprecise results --\n// the system configuration can change asynchronously because of DR\n// or explicit psradm operations.\n//\n// We also need to take care that the loop (below) terminates as the\n// number of processors online can change between the _SC_NPROCESSORS_ONLN\n// request and the loop that builds the list of processor ids.   Unfortunately\n// there's no reliable way to determine the maximum valid processor id,\n// so we use a manifest constant, MAX_PROCESSOR_ID, instead.  See p_online\n// man pages, which claim the processor id set is \"sparse, but\n// not too sparse\".  MAX_PROCESSOR_ID is used to ensure that we eventually\n// exit the loop.\n//\n// In the future we'll be able to use sysconf(_SC_CPUID_MAX), but that's\n// not available on S8.0.\n\nstatic bool find_processors_online(processorid_t** id_array,\n                                   uint*           id_length) {\n  const processorid_t MAX_PROCESSOR_ID = 100000 ;\n  // Find the number of processors online.\n  *id_length = sysconf(_SC_NPROCESSORS_ONLN);\n  // Make up an array to hold their ids.\n  *id_array = NEW_C_HEAP_ARRAY(processorid_t, *id_length, mtInternal);\n  // Processors need not be numbered consecutively.\n  long found = 0;\n  processorid_t next = 0;\n  while (found < *id_length && next < MAX_PROCESSOR_ID) {\n    processor_info_t info;\n    if (processor_info(next, &info) == 0) {\n      // NB, PI_NOINTR processors are effectively online ...\n      if (info.pi_state == P_ONLINE || info.pi_state == P_NOINTR) {\n        (*id_array)[found] = next;\n        found += 1;\n      }\n    }\n    next += 1;\n  }\n  if (found < *id_length) {\n      // The loop above didn't identify the expected number of processors.\n      // We could always retry the operation, calling sysconf(_SC_NPROCESSORS_ONLN)\n      // and re-running the loop, above, but there's no guarantee of progress\n      // if the system configuration is in flux.  Instead, we just return what\n      // we've got.  Note that in the worst case find_processors_online() could\n      // return an empty set.  (As a fall-back in the case of the empty set we\n      // could just return the ID of the current processor).\n      *id_length = found ;\n  }\n\n  return true;\n}\n\nstatic bool assign_distribution(processorid_t* id_array,\n                                uint           id_length,\n                                uint*          distribution,\n                                uint           distribution_length) {\n  // We assume we can assign processorid_t's to uint's.\n  assert(sizeof(processorid_t) == sizeof(uint),\n         \"can't convert processorid_t to uint\");\n  // Quick check to see if we won't succeed.\n  if (id_length < distribution_length) {\n    return false;\n  }\n  // Assign processor ids to the distribution.\n  // Try to shuffle processors to distribute work across boards,\n  // assuming 4 processors per board.\n  const uint processors_per_board = ProcessDistributionStride;\n  // Find the maximum processor id.\n  processorid_t max_id = 0;\n  for (uint m = 0; m < id_length; m += 1) {\n    max_id = MAX2(max_id, id_array[m]);\n  }\n  // The next id, to limit loops.\n  const processorid_t limit_id = max_id + 1;\n  // Make up markers for available processors.\n  bool* available_id = NEW_C_HEAP_ARRAY(bool, limit_id, mtInternal);\n  for (uint c = 0; c < limit_id; c += 1) {\n    available_id[c] = false;\n  }\n  for (uint a = 0; a < id_length; a += 1) {\n    available_id[id_array[a]] = true;\n  }\n  // Step by \"boards\", then by \"slot\", copying to \"assigned\".\n  // NEEDS_CLEANUP: The assignment of processors should be stateful,\n  //                remembering which processors have been assigned by\n  //                previous calls, etc., so as to distribute several\n  //                independent calls of this method.  What we'd like is\n  //                It would be nice to have an API that let us ask\n  //                how many processes are bound to a processor,\n  //                but we don't have that, either.\n  //                In the short term, \"board\" is static so that\n  //                subsequent distributions don't all start at board 0.\n  static uint board = 0;\n  uint assigned = 0;\n  // Until we've found enough processors ....\n  while (assigned < distribution_length) {\n    // ... find the next available processor in the board.\n    for (uint slot = 0; slot < processors_per_board; slot += 1) {\n      uint try_id = board * processors_per_board + slot;\n      if ((try_id < limit_id) && (available_id[try_id] == true)) {\n        distribution[assigned] = try_id;\n        available_id[try_id] = false;\n        assigned += 1;\n        break;\n      }\n    }\n    board += 1;\n    if (board * processors_per_board + 0 >= limit_id) {\n      board = 0;\n    }\n  }\n  if (available_id != NULL) {\n    FREE_C_HEAP_ARRAY(bool, available_id, mtInternal);\n  }\n  return true;\n}\n\nvoid os::set_native_thread_name(const char *name) {\n  // Not yet implemented.\n  return;\n}\n\nbool os::distribute_processes(uint length, uint* distribution) {\n  bool result = false;\n  // Find the processor id's of all the available CPUs.\n  processorid_t* id_array  = NULL;\n  uint           id_length = 0;\n  // There are some races between querying information and using it,\n  // since processor sets can change dynamically.\n  psetid_t pset = PS_NONE;\n  // Are we running in a processor set?\n  if ((pset_bind(PS_QUERY, P_PID, P_MYID, &pset) == 0) && pset != PS_NONE) {\n    result = find_processors_in_pset(pset, &id_array, &id_length);\n  } else {\n    result = find_processors_online(&id_array, &id_length);\n  }\n  if (result == true) {\n    if (id_length >= length) {\n      result = assign_distribution(id_array, id_length, distribution, length);\n    } else {\n      result = false;\n    }\n  }\n  if (id_array != NULL) {\n    FREE_C_HEAP_ARRAY(processorid_t, id_array, mtInternal);\n  }\n  return result;\n}\n\nbool os::bind_to_processor(uint processor_id) {\n  // We assume that a processorid_t can be stored in a uint.\n  assert(sizeof(uint) == sizeof(processorid_t),\n         \"can't convert uint to processorid_t\");\n  int bind_result =\n    processor_bind(P_LWPID,                       // bind LWP.\n                   P_MYID,                        // bind current LWP.\n                   (processorid_t) processor_id,  // id.\n                   NULL);                         // don't return old binding.\n  return (bind_result == 0);\n}\n\nbool os::getenv(const char* name, char* buffer, int len) {\n  char* val = ::getenv( name );\n  if ( val == NULL\n  ||   strlen(val) + 1  >  len ) {\n    if (len > 0)  buffer[0] = 0; // return a null string\n    return false;\n  }\n  strcpy( buffer, val );\n  return true;\n}\n\n\n// Return true if user is running as root.\n\nbool os::have_special_privileges() {\n  static bool init = false;\n  static bool privileges = false;\n  if (!init) {\n    privileges = (getuid() != geteuid()) || (getgid() != getegid());\n    init = true;\n  }\n  return privileges;\n}\n\n\nvoid os::init_system_properties_values() {\n  // The next steps are taken in the product version:\n  //\n  // Obtain the JAVA_HOME value from the location of libjvm.so.\n  // This library should be located at:\n  // <JAVA_HOME>/jre/lib/<arch>/{client|server}/libjvm.so.\n  //\n  // If \"/jre/lib/\" appears at the right place in the path, then we\n  // assume libjvm.so is installed in a JDK and we use this path.\n  //\n  // Otherwise exit with message: \"Could not create the Java virtual machine.\"\n  //\n  // The following extra steps are taken in the debugging version:\n  //\n  // If \"/jre/lib/\" does NOT appear at the right place in the path\n  // instead of exit check for $JAVA_HOME environment variable.\n  //\n  // If it is defined and we are able to locate $JAVA_HOME/jre/lib/<arch>,\n  // then we append a fake suffix \"hotspot/libjvm.so\" to this path so\n  // it looks like libjvm.so is installed there\n  // <JAVA_HOME>/jre/lib/<arch>/hotspot/libjvm.so.\n  //\n  // Otherwise exit.\n  //\n  // Important note: if the location of libjvm.so changes this\n  // code needs to be changed accordingly.\n\n// Base path of extensions installed on the system.\n#define SYS_EXT_DIR     \"/usr/jdk/packages\"\n#define EXTENSIONS_DIR  \"/lib/ext\"\n#define ENDORSED_DIR    \"/lib/endorsed\"\n\n  char cpu_arch[12];\n  // Buffer that fits several sprintfs.\n  // Note that the space for the colon and the trailing null are provided\n  // by the nulls included by the sizeof operator.\n  const size_t bufsize =\n    MAX4((size_t)MAXPATHLEN,  // For dll_dir & friends.\n         sizeof(SYS_EXT_DIR) + sizeof(\"/lib/\") + strlen(cpu_arch), // invariant ld_library_path\n         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR), // extensions dir\n         (size_t)MAXPATHLEN + sizeof(ENDORSED_DIR)); // endorsed dir\n  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n\n  // sysclasspath, java_home, dll_dir\n  {\n    char *pslash;\n    os::jvm_path(buf, bufsize);\n\n    // Found the full path to libjvm.so.\n    // Now cut the path to <java_home>/jre if we can.\n    *(strrchr(buf, '/')) = '\\0'; // Get rid of /libjvm.so.\n    pslash = strrchr(buf, '/');\n    if (pslash != NULL) {\n      *pslash = '\\0';            // Get rid of /{client|server|hotspot}.\n    }\n    Arguments::set_dll_dir(buf);\n\n    if (pslash != NULL) {\n      pslash = strrchr(buf, '/');\n      if (pslash != NULL) {\n        *pslash = '\\0';          // Get rid of /<arch>.\n        pslash = strrchr(buf, '/');\n        if (pslash != NULL) {\n          *pslash = '\\0';        // Get rid of /lib.\n        }\n      }\n    }\n    Arguments::set_java_home(buf);\n    set_boot_path('/', ':');\n  }\n\n  // Where to look for native libraries.\n  {\n    // Use dlinfo() to determine the correct java.library.path.\n    //\n    // If we're launched by the Java launcher, and the user\n    // does not set java.library.path explicitly on the commandline,\n    // the Java launcher sets LD_LIBRARY_PATH for us and unsets\n    // LD_LIBRARY_PATH_32 and LD_LIBRARY_PATH_64.  In this case\n    // dlinfo returns LD_LIBRARY_PATH + crle settings (including\n    // /usr/lib), which is exactly what we want.\n    //\n    // If the user does set java.library.path, it completely\n    // overwrites this setting, and always has.\n    //\n    // If we're not launched by the Java launcher, we may\n    // get here with any/all of the LD_LIBRARY_PATH[_32|64]\n    // settings.  Again, dlinfo does exactly what we want.\n\n    Dl_serinfo     info_sz, *info = &info_sz;\n    Dl_serpath     *path;\n    char           *library_path;\n    char           *common_path = buf;\n\n    // Determine search path count and required buffer size.\n    if (dlinfo(RTLD_SELF, RTLD_DI_SERINFOSIZE, (void *)info) == -1) {\n      FREE_C_HEAP_ARRAY(char, buf,  mtInternal);\n      vm_exit_during_initialization(\"dlinfo SERINFOSIZE request\", dlerror());\n    }\n\n    // Allocate new buffer and initialize.\n    info = (Dl_serinfo*)NEW_C_HEAP_ARRAY(char, info_sz.dls_size, mtInternal);\n    info->dls_size = info_sz.dls_size;\n    info->dls_cnt = info_sz.dls_cnt;\n\n    // Obtain search path information.\n    if (dlinfo(RTLD_SELF, RTLD_DI_SERINFO, (void *)info) == -1) {\n      FREE_C_HEAP_ARRAY(char, buf,  mtInternal);\n      FREE_C_HEAP_ARRAY(char, info, mtInternal);\n      vm_exit_during_initialization(\"dlinfo SERINFO request\", dlerror());\n    }\n\n    path = &info->dls_serpath[0];\n\n    // Note: Due to a legacy implementation, most of the library path\n    // is set in the launcher. This was to accomodate linking restrictions\n    // on legacy Solaris implementations (which are no longer supported).\n    // Eventually, all the library path setting will be done here.\n    //\n    // However, to prevent the proliferation of improperly built native\n    // libraries, the new path component /usr/jdk/packages is added here.\n\n    // Determine the actual CPU architecture.\n    sysinfo(SI_ARCHITECTURE, cpu_arch, sizeof(cpu_arch));\n#ifdef _LP64\n    // If we are a 64-bit vm, perform the following translations:\n    //   sparc   -> sparcv9\n    //   i386    -> amd64\n    if (strcmp(cpu_arch, \"sparc\") == 0) {\n      strcat(cpu_arch, \"v9\");\n    } else if (strcmp(cpu_arch, \"i386\") == 0) {\n      strcpy(cpu_arch, \"amd64\");\n    }\n#endif\n\n    // Construct the invariant part of ld_library_path.\n    sprintf(common_path, SYS_EXT_DIR \"/lib/%s\", cpu_arch);\n\n    // Struct size is more than sufficient for the path components obtained\n    // through the dlinfo() call, so only add additional space for the path\n    // components explicitly added here.\n    size_t library_path_size = info->dls_size + strlen(common_path);\n    library_path = (char *)NEW_C_HEAP_ARRAY(char, library_path_size, mtInternal);\n    library_path[0] = '\\0';\n\n    // Construct the desired Java library path from the linker's library\n    // search path.\n    //\n    // For compatibility, it is optimal that we insert the additional path\n    // components specific to the Java VM after those components specified\n    // in LD_LIBRARY_PATH (if any) but before those added by the ld.so\n    // infrastructure.\n    if (info->dls_cnt == 0) { // Not sure this can happen, but allow for it.\n      strcpy(library_path, common_path);\n    } else {\n      int inserted = 0;\n      int i;\n      for (i = 0; i < info->dls_cnt; i++, path++) {\n        uint_t flags = path->dls_flags & LA_SER_MASK;\n        if (((flags & LA_SER_LIBPATH) == 0) && !inserted) {\n          strcat(library_path, common_path);\n          strcat(library_path, os::path_separator());\n          inserted = 1;\n        }\n        strcat(library_path, path->dls_name);\n        strcat(library_path, os::path_separator());\n      }\n      // Eliminate trailing path separator.\n      library_path[strlen(library_path)-1] = '\\0';\n    }\n\n    // happens before argument parsing - can't use a trace flag\n    // tty->print_raw(\"init_system_properties_values: native lib path: \");\n    // tty->print_raw_cr(library_path);\n\n    // Callee copies into its own buffer.\n    Arguments::set_library_path(library_path);\n\n    FREE_C_HEAP_ARRAY(char, library_path, mtInternal);\n    FREE_C_HEAP_ARRAY(char, info, mtInternal);\n  }\n\n  // Extensions directories.\n  sprintf(buf, \"%s\" EXTENSIONS_DIR \":\" SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());\n  Arguments::set_ext_dirs(buf);\n\n  // Endorsed standards default directory.\n  sprintf(buf, \"%s\" ENDORSED_DIR, Arguments::get_java_home());\n  Arguments::set_endorsed_dirs(buf);\n\n  FREE_C_HEAP_ARRAY(char, buf, mtInternal);\n\n#undef SYS_EXT_DIR\n#undef EXTENSIONS_DIR\n#undef ENDORSED_DIR\n}\n\nvoid os::breakpoint() {\n  BREAKPOINT;\n}\n\nbool os::obsolete_option(const JavaVMOption *option)\n{\n  if (!strncmp(option->optionString, \"-Xt\", 3)) {\n    return true;\n  } else if (!strncmp(option->optionString, \"-Xtm\", 4)) {\n    return true;\n  } else if (!strncmp(option->optionString, \"-Xverifyheap\", 12)) {\n    return true;\n  } else if (!strncmp(option->optionString, \"-Xmaxjitcodesize\", 16)) {\n    return true;\n  }\n  return false;\n}\n\nbool os::Solaris::valid_stack_address(Thread* thread, address sp) {\n  address  stackStart  = (address)thread->stack_base();\n  address  stackEnd    = (address)(stackStart - (address)thread->stack_size());\n  if (sp < stackStart && sp >= stackEnd ) return true;\n  return false;\n}\n\nextern \"C\" void breakpoint() {\n  // use debugger to set breakpoint here\n}\n\nstatic thread_t main_thread;\n\n// Thread start routine for all new Java threads\nextern \"C\" void* java_start(void* thread_addr) {\n  // Try to randomize the cache line index of hot stack frames.\n  // This helps when threads of the same stack traces evict each other's\n  // cache lines. The threads can be either from the same JVM instance, or\n  // from different JVM instances. The benefit is especially true for\n  // processors with hyperthreading technology.\n  static int counter = 0;\n  int pid = os::current_process_id();\n  alloca(((pid ^ counter++) & 7) * 128);\n\n  int prio;\n  Thread* thread = (Thread*)thread_addr;\n  OSThread* osthr = thread->osthread();\n\n  osthr->set_lwp_id( _lwp_self() );  // Store lwp in case we are bound\n  thread->_schedctl = (void *) schedctl_init () ;\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n\n  // If the creator called set priority before we started,\n  // we need to call set_native_priority now that we have an lwp.\n  // We used to get the priority from thr_getprio (we called\n  // thr_setprio way back in create_thread) and pass it to\n  // set_native_priority, but Solaris scales the priority\n  // in java_to_os_priority, so when we read it back here,\n  // we pass trash to set_native_priority instead of what's\n  // in java_to_os_priority. So we save the native priority\n  // in the osThread and recall it here.\n\n  if ( osthr->thread_id() != -1 ) {\n    if ( UseThreadPriorities ) {\n      int prio = osthr->native_priority();\n      if (ThreadPriorityVerbose) {\n        tty->print_cr(\"Starting Thread \" INTPTR_FORMAT \", LWP is \"\n                      INTPTR_FORMAT \", setting priority: %d\\n\",\n                      osthr->thread_id(), osthr->lwp_id(), prio);\n      }\n      os::set_native_priority(thread, prio);\n    }\n  } else if (ThreadPriorityVerbose) {\n    warning(\"Can't set priority in _start routine, thread id hasn't been set\\n\");\n  }\n\n  assert(osthr->get_state() == RUNNABLE, \"invalid os thread state\");\n\n  // initialize signal mask for this thread\n  os::Solaris::hotspot_sigmask(thread);\n\n  thread->run();\n\n  // One less thread is executing\n  // When the VMThread gets here, the main thread may have already exited\n  // which frees the CodeHeap containing the Atomic::dec code\n  if (thread != VMThread::vm_thread() && VMThread::vm_thread() != NULL) {\n    Atomic::dec(&os::Solaris::_os_thread_count);\n  }\n\n  if (UseDetachedThreads) {\n    thr_exit(NULL);\n    ShouldNotReachHere();\n  }\n  return NULL;\n}\n\nstatic OSThread* create_os_thread(Thread* thread, thread_t thread_id) {\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) return NULL;\n\n  // Store info on the Solaris thread into the OSThread\n  osthread->set_thread_id(thread_id);\n  osthread->set_lwp_id(_lwp_self());\n  thread->_schedctl = (void *) schedctl_init () ;\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n\n  if ( ThreadPriorityVerbose ) {\n    tty->print_cr(\"In create_os_thread, Thread \" INTPTR_FORMAT \", LWP is \" INTPTR_FORMAT \"\\n\",\n                  osthread->thread_id(), osthread->lwp_id() );\n  }\n\n  // Initial thread state is INITIALIZED, not SUSPENDED\n  osthread->set_state(INITIALIZED);\n\n  return osthread;\n}\n\nvoid os::Solaris::hotspot_sigmask(Thread* thread) {\n\n  //Save caller's signal mask\n  sigset_t sigmask;\n  thr_sigsetmask(SIG_SETMASK, NULL, &sigmask);\n  OSThread *osthread = thread->osthread();\n  osthread->set_caller_sigmask(sigmask);\n\n  thr_sigsetmask(SIG_UNBLOCK, os::Solaris::unblocked_signals(), NULL);\n  if (!ReduceSignalUsage) {\n    if (thread->is_VM_thread()) {\n      // Only the VM thread handles BREAK_SIGNAL ...\n      thr_sigsetmask(SIG_UNBLOCK, vm_signals(), NULL);\n    } else {\n      // ... all other threads block BREAK_SIGNAL\n      assert(!sigismember(vm_signals(), SIGINT), \"SIGINT should not be blocked\");\n      thr_sigsetmask(SIG_BLOCK, vm_signals(), NULL);\n    }\n  }\n}\n\nbool os::create_attached_thread(JavaThread* thread) {\n#ifdef ASSERT\n  thread->verify_not_published();\n#endif\n  OSThread* osthread = create_os_thread(thread, thr_self());\n  if (osthread == NULL) {\n     return false;\n  }\n\n  // Initial thread state is RUNNABLE\n  osthread->set_state(RUNNABLE);\n  thread->set_osthread(osthread);\n\n  // initialize signal mask for this thread\n  // and save the caller's signal mask\n  os::Solaris::hotspot_sigmask(thread);\n\n  return true;\n}\n\nbool os::create_main_thread(JavaThread* thread) {\n#ifdef ASSERT\n  thread->verify_not_published();\n#endif\n  if (_starting_thread == NULL) {\n    _starting_thread = create_os_thread(thread, main_thread);\n     if (_starting_thread == NULL) {\n        return false;\n     }\n  }\n\n  // The primodial thread is runnable from the start\n  _starting_thread->set_state(RUNNABLE);\n\n  thread->set_osthread(_starting_thread);\n\n  // initialize signal mask for this thread\n  // and save the caller's signal mask\n  os::Solaris::hotspot_sigmask(thread);\n\n  return true;\n}\n\n// _T2_libthread is true if we believe we are running with the newer\n// SunSoft lwp/libthread.so (2.8 patch, 2.9 default)\nbool os::Solaris::_T2_libthread = false;\n\nbool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) {\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) {\n    return false;\n  }\n\n  if ( ThreadPriorityVerbose ) {\n    char *thrtyp;\n    switch ( thr_type ) {\n      case vm_thread:\n        thrtyp = (char *)\"vm\";\n        break;\n      case cgc_thread:\n        thrtyp = (char *)\"cgc\";\n        break;\n      case pgc_thread:\n        thrtyp = (char *)\"pgc\";\n        break;\n      case java_thread:\n        thrtyp = (char *)\"java\";\n        break;\n      case compiler_thread:\n        thrtyp = (char *)\"compiler\";\n        break;\n      case watcher_thread:\n        thrtyp = (char *)\"watcher\";\n        break;\n      default:\n        thrtyp = (char *)\"unknown\";\n        break;\n    }\n    tty->print_cr(\"In create_thread, creating a %s thread\\n\", thrtyp);\n  }\n\n  // Calculate stack size if it's not specified by caller.\n  if (stack_size == 0) {\n    // The default stack size 1M (2M for LP64).\n    stack_size = (BytesPerWord >> 2) * K * K;\n\n    switch (thr_type) {\n    case os::java_thread:\n      // Java threads use ThreadStackSize which default value can be changed with the flag -Xss\n      if (JavaThread::stack_size_at_create() > 0) stack_size = JavaThread::stack_size_at_create();\n      break;\n    case os::compiler_thread:\n      if (CompilerThreadStackSize > 0) {\n        stack_size = (size_t)(CompilerThreadStackSize * K);\n        break;\n      } // else fall through:\n        // use VMThreadStackSize if CompilerThreadStackSize is not defined\n    case os::vm_thread:\n    case os::pgc_thread:\n    case os::cgc_thread:\n    case os::watcher_thread:\n      if (VMThreadStackSize > 0) stack_size = (size_t)(VMThreadStackSize * K);\n      break;\n    }\n  }\n  stack_size = MAX2(stack_size, os::Solaris::min_stack_allowed);\n\n  // Initial state is ALLOCATED but not INITIALIZED\n  osthread->set_state(ALLOCATED);\n\n  if (os::Solaris::_os_thread_count > os::Solaris::_os_thread_limit) {\n    // We got lots of threads. Check if we still have some address space left.\n    // Need to be at least 5Mb of unreserved address space. We do check by\n    // trying to reserve some.\n    const size_t VirtualMemoryBangSize = 20*K*K;\n    char* mem = os::reserve_memory(VirtualMemoryBangSize);\n    if (mem == NULL) {\n      delete osthread;\n      return false;\n    } else {\n      // Release the memory again\n      os::release_memory(mem, VirtualMemoryBangSize);\n    }\n  }\n\n  // Setup osthread because the child thread may need it.\n  thread->set_osthread(osthread);\n\n  // Create the Solaris thread\n  // explicit THR_BOUND for T2_libthread case in case\n  // that assumption is not accurate, but our alternate signal stack\n  // handling is based on it which must have bound threads\n  thread_t tid = 0;\n  long     flags = (UseDetachedThreads ? THR_DETACHED : 0) | THR_SUSPENDED\n                   | ((UseBoundThreads || os::Solaris::T2_libthread() ||\n                       (thr_type == vm_thread) ||\n                       (thr_type == cgc_thread) ||\n                       (thr_type == pgc_thread) ||\n                       (thr_type == compiler_thread && BackgroundCompilation)) ?\n                      THR_BOUND : 0);\n  int      status;\n\n  // 4376845 -- libthread/kernel don't provide enough LWPs to utilize all CPUs.\n  //\n  // On multiprocessors systems, libthread sometimes under-provisions our\n  // process with LWPs.  On a 30-way systems, for instance, we could have\n  // 50 user-level threads in ready state and only 2 or 3 LWPs assigned\n  // to our process.  This can result in under utilization of PEs.\n  // I suspect the problem is related to libthread's LWP\n  // pool management and to the kernel's SIGBLOCKING \"last LWP parked\"\n  // upcall policy.\n  //\n  // The following code is palliative -- it attempts to ensure that our\n  // process has sufficient LWPs to take advantage of multiple PEs.\n  // Proper long-term cures include using user-level threads bound to LWPs\n  // (THR_BOUND) or using LWP-based synchronization.  Note that there is a\n  // slight timing window with respect to sampling _os_thread_count, but\n  // the race is benign.  Also, we should periodically recompute\n  // _processors_online as the min of SC_NPROCESSORS_ONLN and the\n  // the number of PEs in our partition.  You might be tempted to use\n  // THR_NEW_LWP here, but I'd recommend against it as that could\n  // result in undesirable growth of the libthread's LWP pool.\n  // The fix below isn't sufficient; for instance, it doesn't take into count\n  // LWPs parked on IO.  It does, however, help certain CPU-bound benchmarks.\n  //\n  // Some pathologies this scheme doesn't handle:\n  // *  Threads can block, releasing the LWPs.  The LWPs can age out.\n  //    When a large number of threads become ready again there aren't\n  //    enough LWPs available to service them.  This can occur when the\n  //    number of ready threads oscillates.\n  // *  LWPs/Threads park on IO, thus taking the LWP out of circulation.\n  //\n  // Finally, we should call thr_setconcurrency() periodically to refresh\n  // the LWP pool and thwart the LWP age-out mechanism.\n  // The \"+3\" term provides a little slop -- we want to slightly overprovision.\n\n  if (AdjustConcurrency && os::Solaris::_os_thread_count < (_processors_online+3)) {\n    if (!(flags & THR_BOUND)) {\n      thr_setconcurrency (os::Solaris::_os_thread_count);       // avoid starvation\n    }\n  }\n  // Although this doesn't hurt, we should warn of undefined behavior\n  // when using unbound T1 threads with schedctl().  This should never\n  // happen, as the compiler and VM threads are always created bound\n  DEBUG_ONLY(\n      if ((VMThreadHintNoPreempt || CompilerThreadHintNoPreempt) &&\n          (!os::Solaris::T2_libthread() && (!(flags & THR_BOUND))) &&\n          ((thr_type == vm_thread) || (thr_type == cgc_thread) ||\n           (thr_type == pgc_thread) || (thr_type == compiler_thread && BackgroundCompilation))) {\n         warning(\"schedctl behavior undefined when Compiler/VM/GC Threads are Unbound\");\n      }\n  );\n\n\n  // Mark that we don't have an lwp or thread id yet.\n  // In case we attempt to set the priority before the thread starts.\n  osthread->set_lwp_id(-1);\n  osthread->set_thread_id(-1);\n\n  status = thr_create(NULL, stack_size, java_start, thread, flags, &tid);\n  if (status != 0) {\n    if (PrintMiscellaneous && (Verbose || WizardMode)) {\n      perror(\"os::create_thread\");\n    }\n    thread->set_osthread(NULL);\n    // Need to clean up stuff we've allocated so far\n    delete osthread;\n    return false;\n  }\n\n  Atomic::inc(&os::Solaris::_os_thread_count);\n\n  // Store info on the Solaris thread into the OSThread\n  osthread->set_thread_id(tid);\n\n  // Remember that we created this thread so we can set priority on it\n  osthread->set_vm_created();\n\n  // Set the default thread priority.  If using bound threads, setting\n  // lwp priority will be delayed until thread start.\n  set_native_priority(thread,\n                      DefaultThreadPriority == -1 ?\n                        java_to_os_priority[NormPriority] :\n                        DefaultThreadPriority);\n\n  // Initial thread state is INITIALIZED, not SUSPENDED\n  osthread->set_state(INITIALIZED);\n\n  // The thread is returned suspended (in state INITIALIZED), and is started higher up in the call chain\n  return true;\n}\n\n/* defined for >= Solaris 10. This allows builds on earlier versions\n *  of Solaris to take advantage of the newly reserved Solaris JVM signals\n *  With SIGJVM1, SIGJVM2, INTERRUPT_SIGNAL is SIGJVM1, ASYNC_SIGNAL is SIGJVM2\n *  and -XX:+UseAltSigs does nothing since these should have no conflict\n */\n#if !defined(SIGJVM1)\n#define SIGJVM1 39\n#define SIGJVM2 40\n#endif\n\ndebug_only(static bool signal_sets_initialized = false);\nstatic sigset_t unblocked_sigs, vm_sigs, allowdebug_blocked_sigs;\nint os::Solaris::_SIGinterrupt = INTERRUPT_SIGNAL;\nint os::Solaris::_SIGasync = ASYNC_SIGNAL;\n\nbool os::Solaris::is_sig_ignored(int sig) {\n      struct sigaction oact;\n      sigaction(sig, (struct sigaction*)NULL, &oact);\n      void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oact.sa_sigaction)\n                                     : CAST_FROM_FN_PTR(void*,  oact.sa_handler);\n      if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN))\n           return true;\n      else\n           return false;\n}\n\n// Note: SIGRTMIN is a macro that calls sysconf() so it will\n// dynamically detect SIGRTMIN value for the system at runtime, not buildtime\nstatic bool isJVM1available() {\n  return SIGJVM1 < SIGRTMIN;\n}\n\nvoid os::Solaris::signal_sets_init() {\n  // Should also have an assertion stating we are still single-threaded.\n  assert(!signal_sets_initialized, \"Already initialized\");\n  // Fill in signals that are necessarily unblocked for all threads in\n  // the VM. Currently, we unblock the following signals:\n  // SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n  //                         by -Xrs (=ReduceSignalUsage));\n  // BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n  // other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n  // the dispositions or masks wrt these signals.\n  // Programs embedding the VM that want to use the above signals for their\n  // own purposes must, at this time, use the \"-Xrs\" option to prevent\n  // interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n  // (See bug 4345157, and other related bugs).\n  // In reality, though, unblocking these signals is really a nop, since\n  // these signals are not blocked by default.\n  sigemptyset(&unblocked_sigs);\n  sigemptyset(&allowdebug_blocked_sigs);\n  sigaddset(&unblocked_sigs, SIGILL);\n  sigaddset(&unblocked_sigs, SIGSEGV);\n  sigaddset(&unblocked_sigs, SIGBUS);\n  sigaddset(&unblocked_sigs, SIGFPE);\n\n  if (isJVM1available) {\n    os::Solaris::set_SIGinterrupt(SIGJVM1);\n    os::Solaris::set_SIGasync(SIGJVM2);\n  } else if (UseAltSigs) {\n    os::Solaris::set_SIGinterrupt(ALT_INTERRUPT_SIGNAL);\n    os::Solaris::set_SIGasync(ALT_ASYNC_SIGNAL);\n  } else {\n    os::Solaris::set_SIGinterrupt(INTERRUPT_SIGNAL);\n    os::Solaris::set_SIGasync(ASYNC_SIGNAL);\n  }\n\n  sigaddset(&unblocked_sigs, os::Solaris::SIGinterrupt());\n  sigaddset(&unblocked_sigs, os::Solaris::SIGasync());\n\n  if (!ReduceSignalUsage) {\n   if (!os::Solaris::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN1_SIGNAL);\n   }\n   if (!os::Solaris::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN2_SIGNAL);\n   }\n   if (!os::Solaris::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN3_SIGNAL);\n   }\n  }\n  // Fill in signals that are blocked by all but the VM thread.\n  sigemptyset(&vm_sigs);\n  if (!ReduceSignalUsage)\n    sigaddset(&vm_sigs, BREAK_SIGNAL);\n  debug_only(signal_sets_initialized = true);\n\n  // For diagnostics only used in run_periodic_checks\n  sigemptyset(&check_signal_done);\n}\n\n// These are signals that are unblocked while a thread is running Java.\n// (For some reason, they get blocked by default.)\nsigset_t* os::Solaris::unblocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &unblocked_sigs;\n}\n\n// These are the signals that are blocked while a (non-VM) thread is\n// running Java. Only the VM thread handles these signals.\nsigset_t* os::Solaris::vm_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &vm_sigs;\n}\n\n// These are signals that are blocked during cond_wait to allow debugger in\nsigset_t* os::Solaris::allowdebug_blocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &allowdebug_blocked_sigs;\n}\n\n\nvoid _handle_uncaught_cxx_exception() {\n  VMError err(\"An uncaught C++ exception\");\n  err.report_and_die();\n}\n\n\n// First crack at OS-specific initialization, from inside the new thread.\nvoid os::initialize_thread(Thread* thr) {\n  int r = thr_main() ;\n  guarantee (r == 0 || r == 1, \"CR6501650 or CR6493689\") ;\n  if (r) {\n    JavaThread* jt = (JavaThread *)thr;\n    assert(jt != NULL,\"Sanity check\");\n    size_t stack_size;\n    address base = jt->stack_base();\n    if (Arguments::created_by_java_launcher()) {\n      // Use 2MB to allow for Solaris 7 64 bit mode.\n      stack_size = JavaThread::stack_size_at_create() == 0\n        ? 2048*K : JavaThread::stack_size_at_create();\n\n      // There are rare cases when we may have already used more than\n      // the basic stack size allotment before this method is invoked.\n      // Attempt to allow for a normally sized java_stack.\n      size_t current_stack_offset = (size_t)(base - (address)&stack_size);\n      stack_size += ReservedSpace::page_align_size_down(current_stack_offset);\n    } else {\n      // 6269555: If we were not created by a Java launcher, i.e. if we are\n      // running embedded in a native application, treat the primordial thread\n      // as much like a native attached thread as possible.  This means using\n      // the current stack size from thr_stksegment(), unless it is too large\n      // to reliably setup guard pages.  A reasonable max size is 8MB.\n      size_t current_size = current_stack_size();\n      // This should never happen, but just in case....\n      if (current_size == 0) current_size = 2 * K * K;\n      stack_size = current_size > (8 * K * K) ? (8 * K * K) : current_size;\n    }\n    address bottom = (address)align_size_up((intptr_t)(base - stack_size), os::vm_page_size());;\n    stack_size = (size_t)(base - bottom);\n\n    assert(stack_size > 0, \"Stack size calculation problem\");\n\n    if (stack_size > jt->stack_size()) {\n      NOT_PRODUCT(\n        struct rlimit limits;\n        getrlimit(RLIMIT_STACK, &limits);\n        size_t size = adjust_stack_size(base, (size_t)limits.rlim_cur);\n        assert(size >= jt->stack_size(), \"Stack size problem in main thread\");\n      )\n      tty->print_cr(\n        \"Stack size of %d Kb exceeds current limit of %d Kb.\\n\"\n        \"(Stack sizes are rounded up to a multiple of the system page size.)\\n\"\n        \"See limit(1) to increase the stack size limit.\",\n        stack_size / K, jt->stack_size() / K);\n      vm_exit(1);\n    }\n    assert(jt->stack_size() >= stack_size,\n          \"Attempt to map more stack than was allocated\");\n    jt->set_stack_size(stack_size);\n  }\n\n   // 5/22/01: Right now alternate signal stacks do not handle\n   // throwing stack overflow exceptions, see bug 4463178\n   // Until a fix is found for this, T2 will NOT imply alternate signal\n   // stacks.\n   // If using T2 libthread threads, install an alternate signal stack.\n   // Because alternate stacks associate with LWPs on Solaris,\n   // see sigaltstack(2), if using UNBOUND threads, or if UseBoundThreads\n   // we prefer to explicitly stack bang.\n   // If not using T2 libthread, but using UseBoundThreads any threads\n   // (primordial thread, jni_attachCurrentThread) we do not create,\n   // probably are not bound, therefore they can not have an alternate\n   // signal stack. Since our stack banging code is generated and\n   // is shared across threads, all threads must be bound to allow\n   // using alternate signal stacks.  The alternative is to interpose\n   // on _lwp_create to associate an alt sig stack with each LWP,\n   // and this could be a problem when the JVM is embedded.\n   // We would prefer to use alternate signal stacks with T2\n   // Since there is currently no accurate way to detect T2\n   // we do not. Assuming T2 when running T1 causes sig 11s or assertions\n   // on installing alternate signal stacks\n\n\n   // 05/09/03: removed alternate signal stack support for Solaris\n   // The alternate signal stack mechanism is no longer needed to\n   // handle stack overflow. This is now handled by allocating\n   // guard pages (red zone) and stackbanging.\n   // Initially the alternate signal stack mechanism was removed because\n   // it did not work with T1 llibthread. Alternate\n   // signal stacks MUST have all threads bound to lwps. Applications\n   // can create their own threads and attach them without their being\n   // bound under T1. This is frequently the case for the primordial thread.\n   // If we were ever to reenable this mechanism we would need to\n   // use the dynamic check for T2 libthread.\n\n  os::Solaris::init_thread_fpu_state();\n  std::set_terminate(_handle_uncaught_cxx_exception);\n}\n\n\n\n// Free Solaris resources related to the OSThread\nvoid os::free_thread(OSThread* osthread) {\n  assert(osthread != NULL, \"os::free_thread but osthread not set\");\n\n\n  // We are told to free resources of the argument thread,\n  // but we can only really operate on the current thread.\n  // The main thread must take the VMThread down synchronously\n  // before the main thread exits and frees up CodeHeap\n  guarantee((Thread::current()->osthread() == osthread\n     || (osthread == VMThread::vm_thread()->osthread())), \"os::free_thread but not current thread\");\n  if (Thread::current()->osthread() == osthread) {\n    // Restore caller's signal mask\n    sigset_t sigmask = osthread->caller_sigmask();\n    thr_sigsetmask(SIG_SETMASK, &sigmask, NULL);\n  }\n  delete osthread;\n}\n\nvoid os::pd_start_thread(Thread* thread) {\n  int status = thr_continue(thread->osthread()->thread_id());\n  assert_status(status == 0, status, \"thr_continue failed\");\n}\n\n\nintx os::current_thread_id() {\n  return (intx)thr_self();\n}\n\nstatic pid_t _initial_pid = 0;\n\nint os::current_process_id() {\n  return (int)(_initial_pid ? _initial_pid : getpid());\n}\n\n// gethrtime() should be monotonic according to the documentation,\n// but some virtualized platforms are known to break this guarantee.\n// getTimeNanos() must be guaranteed not to move backwards, so we\n// are forced to add a check here.\ninline hrtime_t getTimeNanos() {\n  const hrtime_t now = gethrtime();\n  const hrtime_t prev = max_hrtime;\n  if (now <= prev) {\n    return prev;   // same or retrograde time;\n  }\n  const hrtime_t obsv = Atomic::cmpxchg(now, (volatile jlong*)&max_hrtime, prev);\n  assert(obsv >= prev, \"invariant\");   // Monotonicity\n  // If the CAS succeeded then we're done and return \"now\".\n  // If the CAS failed and the observed value \"obsv\" is >= now then\n  // we should return \"obsv\".  If the CAS failed and now > obsv > prv then\n  // some other thread raced this thread and installed a new value, in which case\n  // we could either (a) retry the entire operation, (b) retry trying to install now\n  // or (c) just return obsv.  We use (c).   No loop is required although in some cases\n  // we might discard a higher \"now\" value in deference to a slightly lower but freshly\n  // installed obsv value.   That's entirely benign -- it admits no new orderings compared\n  // to (a) or (b) -- and greatly reduces coherence traffic.\n  // We might also condition (c) on the magnitude of the delta between obsv and now.\n  // Avoiding excessive CAS operations to hot RW locations is critical.\n  // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate\n  return (prev == obsv) ? now : obsv;\n}\n\n// Time since start-up in seconds to a fine granularity.\n// Used by VMSelfDestructTimer and the MemProfiler.\ndouble os::elapsedTime() {\n  return (double)(getTimeNanos() - first_hrtime) / (double)hrtime_hz;\n}\n\njlong os::elapsed_counter() {\n  return (jlong)(getTimeNanos() - first_hrtime);\n}\n\njlong os::elapsed_frequency() {\n   return hrtime_hz;\n}\n\n// Return the real, user, and system times in seconds from an\n// arbitrary fixed point in the past.\nbool os::getTimesSecs(double* process_real_time,\n                  double* process_user_time,\n                  double* process_system_time) {\n  struct tms ticks;\n  clock_t real_ticks = times(&ticks);\n\n  if (real_ticks == (clock_t) (-1)) {\n    return false;\n  } else {\n    double ticks_per_second = (double) clock_tics_per_sec;\n    *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;\n    *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;\n    // For consistency return the real time from getTimeNanos()\n    // converted to seconds.\n    *process_real_time = ((double) getTimeNanos()) / ((double) NANOUNITS);\n\n    return true;\n  }\n}\n\nbool os::supports_vtime() { return true; }\n\nbool os::enable_vtime() {\n  int fd = ::open(\"/proc/self/ctl\", O_WRONLY);\n  if (fd == -1)\n    return false;\n\n  long cmd[] = { PCSET, PR_MSACCT };\n  int res = ::write(fd, cmd, sizeof(long) * 2);\n  ::close(fd);\n  if (res != sizeof(long) * 2)\n    return false;\n\n  return true;\n}\n\nbool os::vtime_enabled() {\n  int fd = ::open(\"/proc/self/status\", O_RDONLY);\n  if (fd == -1)\n    return false;\n\n  pstatus_t status;\n  int res = os::read(fd, (void*) &status, sizeof(pstatus_t));\n  ::close(fd);\n  if (res != sizeof(pstatus_t))\n    return false;\n\n  return status.pr_flags & PR_MSACCT;\n}\n\ndouble os::elapsedVTime() {\n  return (double)gethrvtime() / (double)hrtime_hz;\n}\n\n// Used internally for comparisons only\n// getTimeMillis guaranteed to not move backwards on Solaris\njlong getTimeMillis() {\n  jlong nanotime = getTimeNanos();\n  return (jlong)(nanotime / NANOSECS_PER_MILLISEC);\n}\n\n// Must return millis since Jan 1 1970 for JVM_CurrentTimeMillis\njlong os::javaTimeMillis() {\n  timeval t;\n  if (gettimeofday( &t, NULL) == -1)\n    fatal(err_msg(\"os::javaTimeMillis: gettimeofday (%s)\", strerror(errno)));\n  return jlong(t.tv_sec) * 1000  +  jlong(t.tv_usec) / 1000;\n}\n\njlong os::javaTimeNanos() {\n  return (jlong)getTimeNanos();\n}\n\nvoid os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;      // gethrtime() uses all 64 bits\n  info_ptr->may_skip_backward = false;    // not subject to resetting or drifting\n  info_ptr->may_skip_forward = false;     // not subject to resetting or drifting\n  info_ptr->kind = JVMTI_TIMER_ELAPSED;   // elapsed not CPU time\n}\n\nchar * os::local_time_string(char *buf, size_t buflen) {\n  struct tm t;\n  time_t long_time;\n  time(&long_time);\n  localtime_r(&long_time, &t);\n  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n               t.tm_hour, t.tm_min, t.tm_sec);\n  return buf;\n}\n\n// Note: os::shutdown() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::shutdown(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::shutdown() {\n\n  // allow PerfMemory to attempt cleanup of any persistent resources\n  perfMemory_exit();\n\n  // needs to remove object in file system\n  AttachListener::abort();\n\n  // flush buffered output, finish log files\n  ostream_abort();\n\n  // Check for abort hook\n  abort_hook_t abort_hook = Arguments::abort_hook();\n  if (abort_hook != NULL) {\n    abort_hook();\n  }\n}\n\n// Note: os::abort() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::abort(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::abort(bool dump_core) {\n  os::shutdown();\n  if (dump_core) {\n#ifndef PRODUCT\n    fdStream out(defaultStream::output_fd());\n    out.print_raw(\"Current thread is \");\n    char buf[16];\n    jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());\n    out.print_raw_cr(buf);\n    out.print_raw_cr(\"Dumping core ...\");\n#endif\n    ::abort(); // dump core (for debugging)\n  }\n\n  ::exit(1);\n}\n\n// Die immediately, no exit hook, no abort hook, no cleanup.\nvoid os::die() {\n  ::abort(); // dump core (for debugging)\n}\n\n// DLL functions\n\nconst char* os::dll_file_extension() { return \".so\"; }\n\n// This must be hard coded because it's the system's temporary\n// directory not the java application's temp directory, ala java.io.tmpdir.\nconst char* os::get_temp_directory() { return \"/tmp\"; }\n\nstatic bool file_exists(const char* filename) {\n  struct stat statbuf;\n  if (filename == NULL || strlen(filename) == 0) {\n    return false;\n  }\n  return os::stat(filename, &statbuf) == 0;\n}\n\nbool os::dll_build_name(char* buffer, size_t buflen,\n                        const char* pname, const char* fname) {\n  bool retval = false;\n  const size_t pnamelen = pname ? strlen(pname) : 0;\n\n  // Return error on buffer overflow.\n  if (pnamelen + strlen(fname) + 10 > (size_t) buflen) {\n    return retval;\n  }\n\n  if (pnamelen == 0) {\n    snprintf(buffer, buflen, \"lib%s.so\", fname);\n    retval = true;\n  } else if (strchr(pname, *os::path_separator()) != NULL) {\n    int n;\n    char** pelements = split_path(pname, &n);\n    if (pelements == NULL) {\n      return false;\n    }\n    for (int i = 0 ; i < n ; i++) {\n      // really shouldn't be NULL but what the heck, check can't hurt\n      if (pelements[i] == NULL || strlen(pelements[i]) == 0) {\n        continue; // skip the empty path values\n      }\n      snprintf(buffer, buflen, \"%s/lib%s.so\", pelements[i], fname);\n      if (file_exists(buffer)) {\n        retval = true;\n        break;\n      }\n    }\n    // release the storage\n    for (int i = 0 ; i < n ; i++) {\n      if (pelements[i] != NULL) {\n        FREE_C_HEAP_ARRAY(char, pelements[i], mtInternal);\n      }\n    }\n    if (pelements != NULL) {\n      FREE_C_HEAP_ARRAY(char*, pelements, mtInternal);\n    }\n  } else {\n    snprintf(buffer, buflen, \"%s/lib%s.so\", pname, fname);\n    retval = true;\n  }\n  return retval;\n}\n\n// check if addr is inside libjvm.so\nbool os::address_is_in_vm(address addr) {\n  static address libjvm_base_addr;\n  Dl_info dlinfo;\n\n  if (libjvm_base_addr == NULL) {\n    if (dladdr(CAST_FROM_FN_PTR(void *, os::address_is_in_vm), &dlinfo) != 0) {\n      libjvm_base_addr = (address)dlinfo.dli_fbase;\n    }\n    assert(libjvm_base_addr !=NULL, \"Cannot obtain base address for libjvm\");\n  }\n\n  if (dladdr((void *)addr, &dlinfo) != 0) {\n    if (libjvm_base_addr == (address)dlinfo.dli_fbase) return true;\n  }\n\n  return false;\n}\n\ntypedef int (*dladdr1_func_type) (void *, Dl_info *, void **, int);\nstatic dladdr1_func_type dladdr1_func = NULL;\n\nbool os::dll_address_to_function_name(address addr, char *buf,\n                                      int buflen, int * offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n\n  // dladdr1_func was initialized in os::init()\n  if (dladdr1_func != NULL) {\n    // yes, we have dladdr1\n\n    // Support for dladdr1 is checked at runtime; it may be\n    // available even if the vm is built on a machine that does\n    // not have dladdr1 support.  Make sure there is a value for\n    // RTLD_DL_SYMENT.\n    #ifndef RTLD_DL_SYMENT\n    #define RTLD_DL_SYMENT 1\n    #endif\n#ifdef _LP64\n    Elf64_Sym * info;\n#else\n    Elf32_Sym * info;\n#endif\n    if (dladdr1_func((void *)addr, &dlinfo, (void **)&info,\n                     RTLD_DL_SYMENT) != 0) {\n      // see if we have a matching symbol that covers our address\n      if (dlinfo.dli_saddr != NULL &&\n          (char *)dlinfo.dli_saddr + info->st_size > (char *)addr) {\n        if (dlinfo.dli_sname != NULL) {\n          if (!Decoder::demangle(dlinfo.dli_sname, buf, buflen)) {\n            jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_sname);\n          }\n          if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;\n          return true;\n        }\n      }\n      // no matching symbol so try for just file info\n      if (dlinfo.dli_fname != NULL && dlinfo.dli_fbase != NULL) {\n        if (Decoder::decode((address)(addr - (address)dlinfo.dli_fbase),\n                            buf, buflen, offset, dlinfo.dli_fname)) {\n          return true;\n        }\n      }\n    }\n    buf[0] = '\\0';\n    if (offset != NULL) *offset  = -1;\n    return false;\n  }\n\n  // no, only dladdr is available\n  if (dladdr((void *)addr, &dlinfo) != 0) {\n    // see if we have a matching symbol\n    if (dlinfo.dli_saddr != NULL && dlinfo.dli_sname != NULL) {\n      if (!Decoder::demangle(dlinfo.dli_sname, buf, buflen)) {\n        jio_snprintf(buf, buflen, dlinfo.dli_sname);\n      }\n      if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;\n      return true;\n    }\n    // no matching symbol so try for just file info\n    if (dlinfo.dli_fname != NULL && dlinfo.dli_fbase != NULL) {\n      if (Decoder::decode((address)(addr - (address)dlinfo.dli_fbase),\n                          buf, buflen, offset, dlinfo.dli_fname)) {\n        return true;\n      }\n    }\n  }\n  buf[0] = '\\0';\n  if (offset != NULL) *offset  = -1;\n  return false;\n}\n\nbool os::dll_address_to_library_name(address addr, char* buf,\n                                     int buflen, int* offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n\n  if (dladdr((void*)addr, &dlinfo) != 0) {\n    if (dlinfo.dli_fname != NULL) {\n      jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL && offset != NULL) {\n      *offset = addr - (address)dlinfo.dli_fbase;\n    }\n    return true;\n  }\n\n  buf[0] = '\\0';\n  if (offset) *offset = -1;\n  return false;\n}\n\n// Prints the names and full paths of all opened dynamic libraries\n// for current process\nvoid os::print_dll_info(outputStream * st) {\n  Dl_info dli;\n  void *handle;\n  Link_map *map;\n  Link_map *p;\n\n  st->print_cr(\"Dynamic libraries:\"); st->flush();\n\n  if (dladdr(CAST_FROM_FN_PTR(void *, os::print_dll_info), &dli) == 0 ||\n      dli.dli_fname == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n  handle = dlopen(dli.dli_fname, RTLD_LAZY);\n  if (handle == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n  dlinfo(handle, RTLD_DI_LINKMAP, &map);\n  if (map == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n\n  while (map->l_prev != NULL)\n    map = map->l_prev;\n\n  while (map != NULL) {\n    st->print_cr(PTR_FORMAT \" \\t%s\", map->l_addr, map->l_name);\n    map = map->l_next;\n  }\n\n  dlclose(handle);\n}\n\n  // Loads .dll/.so and\n  // in case of error it checks if .dll/.so was built for the\n  // same architecture as Hotspot is running on\n\nvoid * os::dll_load(const char *filename, char *ebuf, int ebuflen)\n{\n  void * result= ::dlopen(filename, RTLD_LAZY);\n  if (result != NULL) {\n    // Successful loading\n    return result;\n  }\n\n  Elf32_Ehdr elf_head;\n\n  // Read system error message into ebuf\n  // It may or may not be overwritten below\n  ::strncpy(ebuf, ::dlerror(), ebuflen-1);\n  ebuf[ebuflen-1]='\\0';\n  int diag_msg_max_length=ebuflen-strlen(ebuf);\n  char* diag_msg_buf=ebuf+strlen(ebuf);\n\n  if (diag_msg_max_length==0) {\n    // No more space in ebuf for additional diagnostics message\n    return NULL;\n  }\n\n\n  int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);\n\n  if (file_descriptor < 0) {\n    // Can't open library, report dlerror() message\n    return NULL;\n  }\n\n  bool failed_to_read_elf_head=\n    (sizeof(elf_head)!=\n        (::read(file_descriptor, &elf_head,sizeof(elf_head)))) ;\n\n  ::close(file_descriptor);\n  if (failed_to_read_elf_head) {\n    // file i/o error - report dlerror() msg\n    return NULL;\n  }\n\n  typedef struct {\n    Elf32_Half  code;         // Actual value as defined in elf.h\n    Elf32_Half  compat_class; // Compatibility of archs at VM's sense\n    char        elf_class;    // 32 or 64 bit\n    char        endianess;    // MSB or LSB\n    char*       name;         // String representation\n  } arch_t;\n\n  static const arch_t arch_array[]={\n    {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)\"IA 64\"},\n    {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)\"AMD 64\"},\n    {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)\"Sparc v9 64\"},\n    {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)\"Power PC 32\"},\n    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)\"Power PC 64\"},\n    {EM_ARM,         EM_ARM,     ELFCLASS32, ELFDATA2LSB, (char*)\"ARM 32\"}\n  };\n\n  #if  (defined IA32)\n    static  Elf32_Half running_arch_code=EM_386;\n  #elif   (defined AMD64)\n    static  Elf32_Half running_arch_code=EM_X86_64;\n  #elif  (defined IA64)\n    static  Elf32_Half running_arch_code=EM_IA_64;\n  #elif  (defined __sparc) && (defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARCV9;\n  #elif  (defined __sparc) && (!defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARC;\n  #elif  (defined __powerpc64__)\n    static  Elf32_Half running_arch_code=EM_PPC64;\n  #elif  (defined __powerpc__)\n    static  Elf32_Half running_arch_code=EM_PPC;\n  #elif (defined ARM)\n    static  Elf32_Half running_arch_code=EM_ARM;\n  #else\n    #error Method os::dll_load requires that one of following is defined:\\\n         IA32, AMD64, IA64, __sparc, __powerpc__, ARM, ARM\n  #endif\n\n  // Identify compatability class for VM's architecture and library's architecture\n  // Obtain string descriptions for architectures\n\n  arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};\n  int running_arch_index=-1;\n\n  for (unsigned int i=0 ; i < ARRAY_SIZE(arch_array) ; i++ ) {\n    if (running_arch_code == arch_array[i].code) {\n      running_arch_index    = i;\n    }\n    if (lib_arch.code == arch_array[i].code) {\n      lib_arch.compat_class = arch_array[i].compat_class;\n      lib_arch.name         = arch_array[i].name;\n    }\n  }\n\n  assert(running_arch_index != -1,\n    \"Didn't find running architecture code (running_arch_code) in arch_array\");\n  if (running_arch_index == -1) {\n    // Even though running architecture detection failed\n    // we may still continue with reporting dlerror() message\n    return NULL;\n  }\n\n  if (lib_arch.endianess != arch_array[running_arch_index].endianess) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n    return NULL;\n  }\n\n  if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n    return NULL;\n  }\n\n  if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {\n    if ( lib_arch.name!=NULL ) {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n        \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n        lib_arch.name, arch_array[running_arch_index].name);\n    } else {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n      \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n        lib_arch.code,\n        arch_array[running_arch_index].name);\n    }\n  }\n\n  return NULL;\n}\n\nvoid* os::dll_lookup(void* handle, const char* name) {\n  return dlsym(handle, name);\n}\n\nvoid* os::get_default_process_handle() {\n  return (void*)::dlopen(NULL, RTLD_LAZY);\n}\n\nint os::stat(const char *path, struct stat *sbuf) {\n  char pathbuf[MAX_PATH];\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  os::native_path(strcpy(pathbuf, path));\n  return ::stat(pathbuf, sbuf);\n}\n\nstatic bool _print_ascii_file(const char* filename, outputStream* st) {\n  int fd = ::open(filename, O_RDONLY);\n  if (fd == -1) {\n     return false;\n  }\n\n  char buf[32];\n  int bytes;\n  while ((bytes = ::read(fd, buf, sizeof(buf))) > 0) {\n    st->print_raw(buf, bytes);\n  }\n\n  ::close(fd);\n\n  return true;\n}\n\nvoid os::print_os_info_brief(outputStream* st) {\n  os::Solaris::print_distro_info(st);\n\n  os::Posix::print_uname_info(st);\n\n  os::Solaris::print_libversion_info(st);\n}\n\nvoid os::print_os_info(outputStream* st) {\n  st->print(\"OS:\");\n\n  os::Solaris::print_distro_info(st);\n\n  os::Posix::print_uname_info(st);\n\n  os::Solaris::print_libversion_info(st);\n\n  os::Posix::print_rlimit_info(st);\n\n  os::Posix::print_load_average(st);\n}\n\nvoid os::Solaris::print_distro_info(outputStream* st) {\n  if (!_print_ascii_file(\"/etc/release\", st)) {\n      st->print(\"Solaris\");\n    }\n    st->cr();\n}\n\nvoid os::Solaris::print_libversion_info(outputStream* st) {\n  if (os::Solaris::T2_libthread()) {\n    st->print(\"  (T2 libthread)\");\n  }\n  else {\n    st->print(\"  (T1 libthread)\");\n  }\n  st->cr();\n}\n\nstatic bool check_addr0(outputStream* st) {\n  jboolean status = false;\n  int fd = ::open(\"/proc/self/map\",O_RDONLY);\n  if (fd >= 0) {\n    prmap_t p;\n    while(::read(fd, &p, sizeof(p)) > 0) {\n      if (p.pr_vaddr == 0x0) {\n        st->print(\"Warning: Address: 0x%x, Size: %dK, \",p.pr_vaddr, p.pr_size/1024, p.pr_mapname);\n        st->print(\"Mapped file: %s, \", p.pr_mapname[0] == '\\0' ? \"None\" : p.pr_mapname);\n        st->print(\"Access:\");\n        st->print(\"%s\",(p.pr_mflags & MA_READ)  ? \"r\" : \"-\");\n        st->print(\"%s\",(p.pr_mflags & MA_WRITE) ? \"w\" : \"-\");\n        st->print(\"%s\",(p.pr_mflags & MA_EXEC)  ? \"x\" : \"-\");\n        st->cr();\n        status = true;\n      }\n    }\n    ::close(fd);\n  }\n  return status;\n}\n\nvoid os::pd_print_cpu_info(outputStream* st) {\n  // Nothing to do for now.\n}\n\nvoid os::print_memory_info(outputStream* st) {\n  st->print(\"Memory:\");\n  st->print(\" %dk page\", os::vm_page_size()>>10);\n  st->print(\", physical \" UINT64_FORMAT \"k\", os::physical_memory()>>10);\n  st->print(\"(\" UINT64_FORMAT \"k free)\", os::available_memory() >> 10);\n  st->cr();\n  if (VMError::fatal_error_in_progress()) {\n     (void) check_addr0(st);\n  }\n}\n\nvoid os::print_siginfo(outputStream* st, void* siginfo) {\n  const siginfo_t* si = (const siginfo_t*)siginfo;\n\n  os::Posix::print_siginfo_brief(st, si);\n\n  if (si && (si->si_signo == SIGBUS || si->si_signo == SIGSEGV) &&\n      UseSharedSpaces) {\n    FileMapInfo* mapinfo = FileMapInfo::current_info();\n    if (mapinfo->is_in_shared_space(si->si_addr)) {\n      st->print(\"\\n\\nError accessing class data sharing archive.\"   \\\n                \" Mapped file inaccessible during execution, \"      \\\n                \" possible disk/network problem.\");\n    }\n  }\n  st->cr();\n}\n\n// Moved from whole group, because we need them here for diagnostic\n// prints.\n#define OLDMAXSIGNUM 32\nstatic int Maxsignum = 0;\nstatic int *ourSigFlags = NULL;\n\nextern \"C\" void sigINTRHandler(int, siginfo_t*, void*);\n\nint os::Solaris::get_our_sigflags(int sig) {\n  assert(ourSigFlags!=NULL, \"signal data structure not initialized\");\n  assert(sig > 0 && sig < Maxsignum, \"vm signal out of expected range\");\n  return ourSigFlags[sig];\n}\n\nvoid os::Solaris::set_our_sigflags(int sig, int flags) {\n  assert(ourSigFlags!=NULL, \"signal data structure not initialized\");\n  assert(sig > 0 && sig < Maxsignum, \"vm signal out of expected range\");\n  ourSigFlags[sig] = flags;\n}\n\n\nstatic const char* get_signal_handler_name(address handler,\n                                           char* buf, int buflen) {\n  int offset;\n  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n  if (found) {\n    // skip directory names\n    const char *p1, *p2;\n    p1 = buf;\n    size_t len = strlen(os::file_separator());\n    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n  } else {\n    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n  }\n  return buf;\n}\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                  char* buf, size_t buflen) {\n  struct sigaction sa;\n\n  sigaction(sig, NULL, &sa);\n\n  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n\n  address handler = (sa.sa_flags & SA_SIGINFO)\n                  ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n                  : CAST_FROM_FN_PTR(address, sa.sa_handler);\n\n  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n    st->print(\"SIG_DFL\");\n  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n    st->print(\"SIG_IGN\");\n  } else {\n    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n  }\n\n  st->print(\", sa_mask[0]=\");\n  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n\n  address rh = VMError::get_resetted_sighandler(sig);\n  // May be, handler was resetted by VMError?\n  if(rh != NULL) {\n    handler = rh;\n    sa.sa_flags = VMError::get_resetted_sigflags(sig);\n  }\n\n  st->print(\", sa_flags=\");\n  os::Posix::print_sa_flags(st, sa.sa_flags);\n\n  // Check: is it our handler?\n  if(handler == CAST_FROM_FN_PTR(address, signalHandler) ||\n     handler == CAST_FROM_FN_PTR(address, sigINTRHandler)) {\n    // It is our signal handler\n    // check for flags\n    if(sa.sa_flags != os::Solaris::get_our_sigflags(sig)) {\n      st->print(\n        \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n        os::Solaris::get_our_sigflags(sig));\n    }\n  }\n  st->cr();\n}\n\nvoid os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n  st->print_cr(\"Signal Handlers:\");\n  print_signal_handler(st, SIGSEGV, buf, buflen);\n  print_signal_handler(st, SIGBUS , buf, buflen);\n  print_signal_handler(st, SIGFPE , buf, buflen);\n  print_signal_handler(st, SIGPIPE, buf, buflen);\n  print_signal_handler(st, SIGXFSZ, buf, buflen);\n  print_signal_handler(st, SIGILL , buf, buflen);\n  print_signal_handler(st, INTERRUPT_SIGNAL, buf, buflen);\n  print_signal_handler(st, ASYNC_SIGNAL, buf, buflen);\n  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n  print_signal_handler(st, SHUTDOWN1_SIGNAL , buf, buflen);\n  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n  print_signal_handler(st, SHUTDOWN3_SIGNAL, buf, buflen);\n  print_signal_handler(st, os::Solaris::SIGinterrupt(), buf, buflen);\n  print_signal_handler(st, os::Solaris::SIGasync(), buf, buflen);\n}\n\nstatic char saved_jvm_path[MAXPATHLEN] = { 0 };\n\n// Find the full path to the current module, libjvm.so\nvoid os::jvm_path(char *buf, jint buflen) {\n  // Error checking.\n  if (buflen < MAXPATHLEN) {\n    assert(false, \"must use a large-enough buffer\");\n    buf[0] = '\\0';\n    return;\n  }\n  // Lazy resolve the path to current module.\n  if (saved_jvm_path[0] != 0) {\n    strcpy(buf, saved_jvm_path);\n    return;\n  }\n\n  Dl_info dlinfo;\n  int ret = dladdr(CAST_FROM_FN_PTR(void *, os::jvm_path), &dlinfo);\n  assert(ret != 0, \"cannot locate libjvm\");\n  if (ret != 0 && dlinfo.dli_fname != NULL) {\n    realpath((char *)dlinfo.dli_fname, buf);\n  } else {\n    buf[0] = '\\0';\n    return;\n  }\n\n  if (Arguments::created_by_gamma_launcher()) {\n    // Support for the gamma launcher.  Typical value for buf is\n    // \"<JAVA_HOME>/jre/lib/<arch>/<vmtype>/libjvm.so\".  If \"/jre/lib/\" appears at\n    // the right place in the string, then assume we are installed in a JDK and\n    // we're done.  Otherwise, check for a JAVA_HOME environment variable and fix\n    // up the path so it looks like libjvm.so is installed there (append a\n    // fake suffix hotspot/libjvm.so).\n    const char *p = buf + strlen(buf) - 1;\n    for (int count = 0; p > buf && count < 5; ++count) {\n      for (--p; p > buf && *p != '/'; --p)\n        /* empty */ ;\n    }\n\n    if (strncmp(p, \"/jre/lib/\", 9) != 0) {\n      // Look for JAVA_HOME in the environment.\n      char* java_home_var = ::getenv(\"JAVA_HOME\");\n      if (java_home_var != NULL && java_home_var[0] != 0) {\n        char cpu_arch[12];\n        char* jrelib_p;\n        int   len;\n        sysinfo(SI_ARCHITECTURE, cpu_arch, sizeof(cpu_arch));\n#ifdef _LP64\n        // If we are on sparc running a 64-bit vm, look in jre/lib/sparcv9.\n        if (strcmp(cpu_arch, \"sparc\") == 0) {\n          strcat(cpu_arch, \"v9\");\n        } else if (strcmp(cpu_arch, \"i386\") == 0) {\n          strcpy(cpu_arch, \"amd64\");\n        }\n#endif\n        // Check the current module name \"libjvm.so\".\n        p = strrchr(buf, '/');\n        assert(strstr(p, \"/libjvm\") == p, \"invalid library name\");\n\n        realpath(java_home_var, buf);\n        // determine if this is a legacy image or modules image\n        // modules image doesn't have \"jre\" subdirectory\n        len = strlen(buf);\n        assert(len < buflen, \"Ran out of buffer space\");\n        jrelib_p = buf + len;\n        snprintf(jrelib_p, buflen-len, \"/jre/lib/%s\", cpu_arch);\n        if (0 != access(buf, F_OK)) {\n          snprintf(jrelib_p, buflen-len, \"/lib/%s\", cpu_arch);\n        }\n\n        if (0 == access(buf, F_OK)) {\n          // Use current module name \"libjvm.so\"\n          len = strlen(buf);\n          snprintf(buf + len, buflen-len, \"/hotspot/libjvm.so\");\n        } else {\n          // Go back to path of .so\n          realpath((char *)dlinfo.dli_fname, buf);\n        }\n      }\n    }\n  }\n\n  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n}\n\n\nvoid os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n  // no prefix required, not even \"_\"\n}\n\n\nvoid os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n  // no suffix required\n}\n\n// This method is a copy of JDK's sysGetLastErrorString\n// from src/solaris/hpi/src/system_md.c\n\nsize_t os::lasterror(char *buf, size_t len) {\n\n  if (errno == 0)  return 0;\n\n  const char *s = ::strerror(errno);\n  size_t n = ::strlen(s);\n  if (n >= len) {\n    n = len - 1;\n  }\n  ::strncpy(buf, s, n);\n  buf[n] = '\\0';\n  return n;\n}\n\n\n// sun.misc.Signal\n\nextern \"C\" {\n  static void UserHandler(int sig, void *siginfo, void *context) {\n    // Ctrl-C is pressed during error reporting, likely because the error\n    // handler fails to abort. Let VM die immediately.\n    if (sig == SIGINT && is_error_reported()) {\n       os::die();\n    }\n\n    os::signal_notify(sig);\n    // We do not need to reinstate the signal handler each time...\n  }\n}\n\nvoid* os::user_handler() {\n  return CAST_FROM_FN_PTR(void*, UserHandler);\n}\n\nclass Semaphore : public StackObj {\n  public:\n    Semaphore();\n    ~Semaphore();\n    void signal();\n    void wait();\n    bool trywait();\n    bool timedwait(unsigned int sec, int nsec);\n  private:\n    sema_t _semaphore;\n};\n\n\nSemaphore::Semaphore() {\n  sema_init(&_semaphore, 0, NULL, NULL);\n}\n\nSemaphore::~Semaphore() {\n  sema_destroy(&_semaphore);\n}\n\nvoid Semaphore::signal() {\n  sema_post(&_semaphore);\n}\n\nvoid Semaphore::wait() {\n  sema_wait(&_semaphore);\n}\n\nbool Semaphore::trywait() {\n  return sema_trywait(&_semaphore) == 0;\n}\n\nbool Semaphore::timedwait(unsigned int sec, int nsec) {\n  struct timespec ts;\n  unpackTime(&ts, false, (sec * NANOSECS_PER_SEC) + nsec);\n\n  while (1) {\n    int result = sema_timedwait(&_semaphore, &ts);\n    if (result == 0) {\n      return true;\n    } else if (errno == EINTR) {\n      continue;\n    } else if (errno == ETIME) {\n      return false;\n    } else {\n      return false;\n    }\n  }\n}\n\nextern \"C\" {\n  typedef void (*sa_handler_t)(int);\n  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n}\n\nvoid* os::signal(int signal_number, void* handler) {\n  struct sigaction sigAct, oldSigAct;\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_flags = SA_RESTART & ~SA_RESETHAND;\n  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n\n  if (sigaction(signal_number, &sigAct, &oldSigAct))\n    // -1 means registration failed\n    return (void *)-1;\n\n  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n}\n\nvoid os::signal_raise(int signal_number) {\n  raise(signal_number);\n}\n\n/*\n * The following code is moved from os.cpp for making this\n * code platform specific, which it is by its very nature.\n */\n\n// a counter for each possible signal value\nstatic int Sigexit = 0;\nstatic int Maxlibjsigsigs;\nstatic jint *pending_signals = NULL;\nstatic int *preinstalled_sigs = NULL;\nstatic struct sigaction *chainedsigactions = NULL;\nstatic sema_t sig_sem;\ntypedef int (*version_getting_t)();\nversion_getting_t os::Solaris::get_libjsig_version = NULL;\nstatic int libjsigversion = NULL;\n\nint os::sigexitnum_pd() {\n  assert(Sigexit > 0, \"signal memory not yet initialized\");\n  return Sigexit;\n}\n\nvoid os::Solaris::init_signal_mem() {\n  // Initialize signal structures\n  Maxsignum = SIGRTMAX;\n  Sigexit = Maxsignum+1;\n  assert(Maxsignum >0, \"Unable to obtain max signal number\");\n\n  Maxlibjsigsigs = Maxsignum;\n\n  // pending_signals has one int per signal\n  // The additional signal is for SIGEXIT - exit signal to signal_thread\n  pending_signals = (jint *)os::malloc(sizeof(jint) * (Sigexit+1), mtInternal);\n  memset(pending_signals, 0, (sizeof(jint) * (Sigexit+1)));\n\n  if (UseSignalChaining) {\n     chainedsigactions = (struct sigaction *)malloc(sizeof(struct sigaction)\n       * (Maxsignum + 1), mtInternal);\n     memset(chainedsigactions, 0, (sizeof(struct sigaction) * (Maxsignum + 1)));\n     preinstalled_sigs = (int *)os::malloc(sizeof(int) * (Maxsignum + 1), mtInternal);\n     memset(preinstalled_sigs, 0, (sizeof(int) * (Maxsignum + 1)));\n  }\n  ourSigFlags = (int*)malloc(sizeof(int) * (Maxsignum + 1 ), mtInternal);\n  memset(ourSigFlags, 0, sizeof(int) * (Maxsignum + 1));\n}\n\nvoid os::signal_init_pd() {\n  int ret;\n\n  ret = ::sema_init(&sig_sem, 0, NULL, NULL);\n  assert(ret == 0, \"sema_init() failed\");\n}\n\nvoid os::signal_notify(int signal_number) {\n  int ret;\n\n  Atomic::inc(&pending_signals[signal_number]);\n  ret = ::sema_post(&sig_sem);\n  assert(ret == 0, \"sema_post() failed\");\n}\n\nstatic int check_pending_signals(bool wait_for_signal) {\n  int ret;\n  while (true) {\n    for (int i = 0; i < Sigexit + 1; i++) {\n      jint n = pending_signals[i];\n      if (n > 0 && n == Atomic::cmpxchg(n - 1, &pending_signals[i], n)) {\n        return i;\n      }\n    }\n    if (!wait_for_signal) {\n      return -1;\n    }\n    JavaThread *thread = JavaThread::current();\n    ThreadBlockInVM tbivm(thread);\n\n    bool threadIsSuspended;\n    do {\n      thread->set_suspend_equivalent();\n      // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n      while((ret = ::sema_wait(&sig_sem)) == EINTR)\n          ;\n      assert(ret == 0, \"sema_wait() failed\");\n\n      // were we externally suspended while we were waiting?\n      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n      if (threadIsSuspended) {\n        //\n        // The semaphore has been incremented, but while we were waiting\n        // another thread suspended us. We don't want to continue running\n        // while suspended because that would surprise the thread that\n        // suspended us.\n        //\n        ret = ::sema_post(&sig_sem);\n        assert(ret == 0, \"sema_post() failed\");\n\n        thread->java_suspend_self();\n      }\n    } while (threadIsSuspended);\n  }\n}\n\nint os::signal_lookup() {\n  return check_pending_signals(false);\n}\n\nint os::signal_wait() {\n  return check_pending_signals(true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Virtual Memory\n\nstatic int page_size = -1;\n\n// The mmap MAP_ALIGN flag is supported on Solaris 9 and later.  init_2() will\n// clear this var if support is not available.\nstatic bool has_map_align = true;\n\nint os::vm_page_size() {\n  assert(page_size != -1, \"must call os::init\");\n  return page_size;\n}\n\n// Solaris allocates memory by pages.\nint os::vm_allocation_granularity() {\n  assert(page_size != -1, \"must call os::init\");\n  return page_size;\n}\n\nstatic bool recoverable_mmap_error(int err) {\n  // See if the error is one we can let the caller handle. This\n  // list of errno values comes from the Solaris mmap(2) man page.\n  switch (err) {\n  case EBADF:\n  case EINVAL:\n  case ENOTSUP:\n    // let the caller deal with these errors\n    return true;\n\n  default:\n    // Any remaining errors on this OS can cause our reserved mapping\n    // to be lost. That can cause confusion where different data\n    // structures think they have the same memory mapped. The worst\n    // scenario is if both the VM and a library think they have the\n    // same memory mapped.\n    return false;\n  }\n}\n\nstatic void warn_fail_commit_memory(char* addr, size_t bytes, bool exec,\n                                    int err) {\n  warning(\"INFO: os::commit_memory(\" PTR_FORMAT \", \" SIZE_FORMAT\n          \", %d) failed; error='%s' (errno=%d)\", addr, bytes, exec,\n          strerror(err), err);\n}\n\nstatic void warn_fail_commit_memory(char* addr, size_t bytes,\n                                    size_t alignment_hint, bool exec,\n                                    int err) {\n  warning(\"INFO: os::commit_memory(\" PTR_FORMAT \", \" SIZE_FORMAT\n          \", \" SIZE_FORMAT \", %d) failed; error='%s' (errno=%d)\", addr, bytes,\n          alignment_hint, exec, strerror(err), err);\n}\n\nint os::Solaris::commit_memory_impl(char* addr, size_t bytes, bool exec) {\n  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n  size_t size = bytes;\n  char *res = Solaris::mmap_chunk(addr, size, MAP_PRIVATE|MAP_FIXED, prot);\n  if (res != NULL) {\n    if (UseNUMAInterleaving) {\n      numa_make_global(addr, bytes);\n    }\n    return 0;\n  }\n\n  int err = errno;  // save errno from mmap() call in mmap_chunk()\n\n  if (!recoverable_mmap_error(err)) {\n    warn_fail_commit_memory(addr, bytes, exec, err);\n    vm_exit_out_of_memory(bytes, OOM_MMAP_ERROR, \"committing reserved memory.\");\n  }\n\n  return err;\n}\n\nbool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {\n  return Solaris::commit_memory_impl(addr, bytes, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t bytes, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  int err = os::Solaris::commit_memory_impl(addr, bytes, exec);\n  if (err != 0) {\n    // the caller wants all commit errors to exit with the specified mesg:\n    warn_fail_commit_memory(addr, bytes, exec, err);\n    vm_exit_out_of_memory(bytes, OOM_MMAP_ERROR, mesg);\n  }\n}\n\nsize_t os::Solaris::page_size_for_alignment(size_t alignment) {\n  assert(is_size_aligned(alignment, (size_t) vm_page_size()),\n         err_msg(SIZE_FORMAT \" is not aligned to \" SIZE_FORMAT,\n                 alignment, (size_t) vm_page_size()));\n\n  for (int i = 0; _page_sizes[i] != 0; i++) {\n    if (is_size_aligned(alignment, _page_sizes[i])) {\n      return _page_sizes[i];\n    }\n  }\n\n  return (size_t) vm_page_size();\n}\n\nint os::Solaris::commit_memory_impl(char* addr, size_t bytes,\n                                    size_t alignment_hint, bool exec) {\n  int err = Solaris::commit_memory_impl(addr, bytes, exec);\n  if (err == 0 && UseLargePages && alignment_hint > 0) {\n    assert(is_size_aligned(bytes, alignment_hint),\n           err_msg(SIZE_FORMAT \" is not aligned to \" SIZE_FORMAT, bytes, alignment_hint));\n\n    // The syscall memcntl requires an exact page size (see man memcntl for details).\n    size_t page_size = page_size_for_alignment(alignment_hint);\n    if (page_size > (size_t) vm_page_size()) {\n      (void)Solaris::setup_large_pages(addr, bytes, page_size);\n    }\n  }\n  return err;\n}\n\nbool os::pd_commit_memory(char* addr, size_t bytes, size_t alignment_hint,\n                          bool exec) {\n  return Solaris::commit_memory_impl(addr, bytes, alignment_hint, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t bytes,\n                                  size_t alignment_hint, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  int err = os::Solaris::commit_memory_impl(addr, bytes, alignment_hint, exec);\n  if (err != 0) {\n    // the caller wants all commit errors to exit with the specified mesg:\n    warn_fail_commit_memory(addr, bytes, alignment_hint, exec, err);\n    vm_exit_out_of_memory(bytes, OOM_MMAP_ERROR, mesg);\n  }\n}\n\n// Uncommit the pages in a specified region.\nvoid os::pd_free_memory(char* addr, size_t bytes, size_t alignment_hint) {\n  if (madvise(addr, bytes, MADV_FREE) < 0) {\n    debug_only(warning(\"MADV_FREE failed.\"));\n    return;\n  }\n}\n\nbool os::pd_create_stack_guard_pages(char* addr, size_t size) {\n  return os::commit_memory(addr, size, !ExecMem);\n}\n\nbool os::remove_stack_guard_pages(char* addr, size_t size) {\n  return os::uncommit_memory(addr, size);\n}\n\n// Change the page size in a given range.\nvoid os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {\n  assert((intptr_t)addr % alignment_hint == 0, \"Address should be aligned.\");\n  assert((intptr_t)(addr + bytes) % alignment_hint == 0, \"End should be aligned.\");\n  if (UseLargePages) {\n    Solaris::setup_large_pages(addr, bytes, alignment_hint);\n  }\n}\n\n// Tell the OS to make the range local to the first-touching LWP\nvoid os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {\n  assert((intptr_t)addr % os::vm_page_size() == 0, \"Address should be page-aligned.\");\n  if (madvise(addr, bytes, MADV_ACCESS_LWP) < 0) {\n    debug_only(warning(\"MADV_ACCESS_LWP failed.\"));\n  }\n}\n\n// Tell the OS that this range would be accessed from different LWPs.\nvoid os::numa_make_global(char *addr, size_t bytes) {\n  assert((intptr_t)addr % os::vm_page_size() == 0, \"Address should be page-aligned.\");\n  if (madvise(addr, bytes, MADV_ACCESS_MANY) < 0) {\n    debug_only(warning(\"MADV_ACCESS_MANY failed.\"));\n  }\n}\n\n// Get the number of the locality groups.\nsize_t os::numa_get_groups_num() {\n  size_t n = Solaris::lgrp_nlgrps(Solaris::lgrp_cookie());\n  return n != -1 ? n : 1;\n}\n\n// Get a list of leaf locality groups. A leaf lgroup is group that\n// doesn't have any children. Typical leaf group is a CPU or a CPU/memory\n// board. An LWP is assigned to one of these groups upon creation.\nsize_t os::numa_get_leaf_groups(int *ids, size_t size) {\n   if ((ids[0] = Solaris::lgrp_root(Solaris::lgrp_cookie())) == -1) {\n     ids[0] = 0;\n     return 1;\n   }\n   int result_size = 0, top = 1, bottom = 0, cur = 0;\n   for (int k = 0; k < size; k++) {\n     int r = Solaris::lgrp_children(Solaris::lgrp_cookie(), ids[cur],\n                                    (Solaris::lgrp_id_t*)&ids[top], size - top);\n     if (r == -1) {\n       ids[0] = 0;\n       return 1;\n     }\n     if (!r) {\n       // That's a leaf node.\n       assert (bottom <= cur, \"Sanity check\");\n       // Check if the node has memory\n       if (Solaris::lgrp_resources(Solaris::lgrp_cookie(), ids[cur],\n                                   NULL, 0, LGRP_RSRC_MEM) > 0) {\n         ids[bottom++] = ids[cur];\n       }\n     }\n     top += r;\n     cur++;\n   }\n   if (bottom == 0) {\n     // Handle a situation, when the OS reports no memory available.\n     // Assume UMA architecture.\n     ids[0] = 0;\n     return 1;\n   }\n   return bottom;\n}\n\n// Detect the topology change. Typically happens during CPU plugging-unplugging.\nbool os::numa_topology_changed() {\n  int is_stale = Solaris::lgrp_cookie_stale(Solaris::lgrp_cookie());\n  if (is_stale != -1 && is_stale) {\n    Solaris::lgrp_fini(Solaris::lgrp_cookie());\n    Solaris::lgrp_cookie_t c = Solaris::lgrp_init(Solaris::LGRP_VIEW_CALLER);\n    assert(c != 0, \"Failure to initialize LGRP API\");\n    Solaris::set_lgrp_cookie(c);\n    return true;\n  }\n  return false;\n}\n\n// Get the group id of the current LWP.\nint os::numa_get_group_id() {\n  int lgrp_id = Solaris::lgrp_home(P_LWPID, P_MYID);\n  if (lgrp_id == -1) {\n    return 0;\n  }\n  const int size = os::numa_get_groups_num();\n  int *ids = (int*)alloca(size * sizeof(int));\n\n  // Get the ids of all lgroups with memory; r is the count.\n  int r = Solaris::lgrp_resources(Solaris::lgrp_cookie(), lgrp_id,\n                                  (Solaris::lgrp_id_t*)ids, size, LGRP_RSRC_MEM);\n  if (r <= 0) {\n    return 0;\n  }\n  return ids[os::random() % r];\n}\n\n// Request information about the page.\nbool os::get_page_info(char *start, page_info* info) {\n  const uint_t info_types[] = { MEMINFO_VLGRP, MEMINFO_VPAGESIZE };\n  uint64_t addr = (uintptr_t)start;\n  uint64_t outdata[2];\n  uint_t validity = 0;\n\n  if (os::Solaris::meminfo(&addr, 1, info_types, 2, outdata, &validity) < 0) {\n    return false;\n  }\n\n  info->size = 0;\n  info->lgrp_id = -1;\n\n  if ((validity & 1) != 0) {\n    if ((validity & 2) != 0) {\n      info->lgrp_id = outdata[0];\n    }\n    if ((validity & 4) != 0) {\n      info->size = outdata[1];\n    }\n    return true;\n  }\n  return false;\n}\n\n// Scan the pages from start to end until a page different than\n// the one described in the info parameter is encountered.\nchar *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {\n  const uint_t info_types[] = { MEMINFO_VLGRP, MEMINFO_VPAGESIZE };\n  const size_t types = sizeof(info_types) / sizeof(info_types[0]);\n  uint64_t addrs[MAX_MEMINFO_CNT], outdata[types * MAX_MEMINFO_CNT + 1];\n  uint_t validity[MAX_MEMINFO_CNT];\n\n  size_t page_size = MAX2((size_t)os::vm_page_size(), page_expected->size);\n  uint64_t p = (uint64_t)start;\n  while (p < (uint64_t)end) {\n    addrs[0] = p;\n    size_t addrs_count = 1;\n    while (addrs_count < MAX_MEMINFO_CNT && addrs[addrs_count - 1] + page_size < (uint64_t)end) {\n      addrs[addrs_count] = addrs[addrs_count - 1] + page_size;\n      addrs_count++;\n    }\n\n    if (os::Solaris::meminfo(addrs, addrs_count, info_types, types, outdata, validity) < 0) {\n      return NULL;\n    }\n\n    size_t i = 0;\n    for (; i < addrs_count; i++) {\n      if ((validity[i] & 1) != 0) {\n        if ((validity[i] & 4) != 0) {\n          if (outdata[types * i + 1] != page_expected->size) {\n            break;\n          }\n        } else\n          if (page_expected->size != 0) {\n            break;\n          }\n\n        if ((validity[i] & 2) != 0 && page_expected->lgrp_id > 0) {\n          if (outdata[types * i] != page_expected->lgrp_id) {\n            break;\n          }\n        }\n      } else {\n        return NULL;\n      }\n    }\n\n    if (i < addrs_count) {\n      if ((validity[i] & 2) != 0) {\n        page_found->lgrp_id = outdata[types * i];\n      } else {\n        page_found->lgrp_id = -1;\n      }\n      if ((validity[i] & 4) != 0) {\n        page_found->size = outdata[types * i + 1];\n      } else {\n        page_found->size = 0;\n      }\n      return (char*)addrs[i];\n    }\n\n    p = addrs[addrs_count - 1] + page_size;\n  }\n  return end;\n}\n\nbool os::pd_uncommit_memory(char* addr, size_t bytes) {\n  size_t size = bytes;\n  // Map uncommitted pages PROT_NONE so we fail early if we touch an\n  // uncommitted page. Otherwise, the read/write might succeed if we\n  // have enough swap space to back the physical page.\n  return\n    NULL != Solaris::mmap_chunk(addr, size,\n                                MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE,\n                                PROT_NONE);\n}\n\nchar* os::Solaris::mmap_chunk(char *addr, size_t size, int flags, int prot) {\n  char *b = (char *)mmap(addr, size, prot, flags, os::Solaris::_dev_zero_fd, 0);\n\n  if (b == MAP_FAILED) {\n    return NULL;\n  }\n  return b;\n}\n\nchar* os::Solaris::anon_mmap(char* requested_addr, size_t bytes, size_t alignment_hint, bool fixed) {\n  char* addr = requested_addr;\n  int flags = MAP_PRIVATE | MAP_NORESERVE;\n\n  assert(!(fixed && (alignment_hint > 0)), \"alignment hint meaningless with fixed mmap\");\n\n  if (fixed) {\n    flags |= MAP_FIXED;\n  } else if (has_map_align && (alignment_hint > (size_t) vm_page_size())) {\n    flags |= MAP_ALIGN;\n    addr = (char*) alignment_hint;\n  }\n\n  // Map uncommitted pages PROT_NONE so we fail early if we touch an\n  // uncommitted page. Otherwise, the read/write might succeed if we\n  // have enough swap space to back the physical page.\n  return mmap_chunk(addr, bytes, flags, PROT_NONE);\n}\n\nchar* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {\n  char* addr = Solaris::anon_mmap(requested_addr, bytes, alignment_hint, (requested_addr != NULL));\n\n  guarantee(requested_addr == NULL || requested_addr == addr,\n            \"OS failed to return requested mmap address.\");\n  return addr;\n}\n\n// Reserve memory at an arbitrary address, only if that area is\n// available (and not reserved for something else).\n\nchar* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {\n  const int max_tries = 10;\n  char* base[max_tries];\n  size_t size[max_tries];\n\n  // Solaris adds a gap between mmap'ed regions.  The size of the gap\n  // is dependent on the requested size and the MMU.  Our initial gap\n  // value here is just a guess and will be corrected later.\n  bool had_top_overlap = false;\n  bool have_adjusted_gap = false;\n  size_t gap = 0x400000;\n\n  // Assert only that the size is a multiple of the page size, since\n  // that's all that mmap requires, and since that's all we really know\n  // about at this low abstraction level.  If we need higher alignment,\n  // we can either pass an alignment to this method or verify alignment\n  // in one of the methods further up the call chain.  See bug 5044738.\n  assert(bytes % os::vm_page_size() == 0, \"reserving unexpected size block\");\n\n  // Since snv_84, Solaris attempts to honor the address hint - see 5003415.\n  // Give it a try, if the kernel honors the hint we can return immediately.\n  char* addr = Solaris::anon_mmap(requested_addr, bytes, 0, false);\n\n  volatile int err = errno;\n  if (addr == requested_addr) {\n    return addr;\n  } else if (addr != NULL) {\n    pd_unmap_memory(addr, bytes);\n  }\n\n  if (PrintMiscellaneous && Verbose) {\n    char buf[256];\n    buf[0] = '\\0';\n    if (addr == NULL) {\n      jio_snprintf(buf, sizeof(buf), \": %s\", strerror(err));\n    }\n    warning(\"attempt_reserve_memory_at: couldn't reserve \" SIZE_FORMAT \" bytes at \"\n            PTR_FORMAT \": reserve_memory_helper returned \" PTR_FORMAT\n            \"%s\", bytes, requested_addr, addr, buf);\n  }\n\n  // Address hint method didn't work.  Fall back to the old method.\n  // In theory, once SNV becomes our oldest supported platform, this\n  // code will no longer be needed.\n  //\n  // Repeatedly allocate blocks until the block is allocated at the\n  // right spot. Give up after max_tries.\n  int i;\n  for (i = 0; i < max_tries; ++i) {\n    base[i] = reserve_memory(bytes);\n\n    if (base[i] != NULL) {\n      // Is this the block we wanted?\n      if (base[i] == requested_addr) {\n        size[i] = bytes;\n        break;\n      }\n\n      // check that the gap value is right\n      if (had_top_overlap && !have_adjusted_gap) {\n        size_t actual_gap = base[i-1] - base[i] - bytes;\n        if (gap != actual_gap) {\n          // adjust the gap value and retry the last 2 allocations\n          assert(i > 0, \"gap adjustment code problem\");\n          have_adjusted_gap = true;  // adjust the gap only once, just in case\n          gap = actual_gap;\n          if (PrintMiscellaneous && Verbose) {\n            warning(\"attempt_reserve_memory_at: adjusted gap to 0x%lx\", gap);\n          }\n          unmap_memory(base[i], bytes);\n          unmap_memory(base[i-1], size[i-1]);\n          i-=2;\n          continue;\n        }\n      }\n\n      // Does this overlap the block we wanted? Give back the overlapped\n      // parts and try again.\n      //\n      // There is still a bug in this code: if top_overlap == bytes,\n      // the overlap is offset from requested region by the value of gap.\n      // In this case giving back the overlapped part will not work,\n      // because we'll give back the entire block at base[i] and\n      // therefore the subsequent allocation will not generate a new gap.\n      // This could be fixed with a new algorithm that used larger\n      // or variable size chunks to find the requested region -\n      // but such a change would introduce additional complications.\n      // It's rare enough that the planets align for this bug,\n      // so we'll just wait for a fix for 6204603/5003415 which\n      // will provide a mmap flag to allow us to avoid this business.\n\n      size_t top_overlap = requested_addr + (bytes + gap) - base[i];\n      if (top_overlap >= 0 && top_overlap < bytes) {\n        had_top_overlap = true;\n        unmap_memory(base[i], top_overlap);\n        base[i] += top_overlap;\n        size[i] = bytes - top_overlap;\n      } else {\n        size_t bottom_overlap = base[i] + bytes - requested_addr;\n        if (bottom_overlap >= 0 && bottom_overlap < bytes) {\n          if (PrintMiscellaneous && Verbose && bottom_overlap == 0) {\n            warning(\"attempt_reserve_memory_at: possible alignment bug\");\n          }\n          unmap_memory(requested_addr, bottom_overlap);\n          size[i] = bytes - bottom_overlap;\n        } else {\n          size[i] = bytes;\n        }\n      }\n    }\n  }\n\n  // Give back the unused reserved pieces.\n\n  for (int j = 0; j < i; ++j) {\n    if (base[j] != NULL) {\n      unmap_memory(base[j], size[j]);\n    }\n  }\n\n  return (i < max_tries) ? requested_addr : NULL;\n}\n\nbool os::pd_release_memory(char* addr, size_t bytes) {\n  size_t size = bytes;\n  return munmap(addr, size) == 0;\n}\n\nstatic bool solaris_mprotect(char* addr, size_t bytes, int prot) {\n  assert(addr == (char*)align_size_down((uintptr_t)addr, os::vm_page_size()),\n         \"addr must be page aligned\");\n  int retVal = mprotect(addr, bytes, prot);\n  return retVal == 0;\n}\n\n// Protect memory (Used to pass readonly pages through\n// JNI GetArray<type>Elements with empty arrays.)\n// Also, used for serialization page and for compressed oops null pointer\n// checking.\nbool os::protect_memory(char* addr, size_t bytes, ProtType prot,\n                        bool is_committed) {\n  unsigned int p = 0;\n  switch (prot) {\n  case MEM_PROT_NONE: p = PROT_NONE; break;\n  case MEM_PROT_READ: p = PROT_READ; break;\n  case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;\n  case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;\n  default:\n    ShouldNotReachHere();\n  }\n  // is_committed is unused.\n  return solaris_mprotect(addr, bytes, p);\n}\n\n// guard_memory and unguard_memory only happens within stack guard pages.\n// Since ISM pertains only to the heap, guard and unguard memory should not\n/// happen with an ISM region.\nbool os::guard_memory(char* addr, size_t bytes) {\n  return solaris_mprotect(addr, bytes, PROT_NONE);\n}\n\nbool os::unguard_memory(char* addr, size_t bytes) {\n  return solaris_mprotect(addr, bytes, PROT_READ|PROT_WRITE);\n}\n\n// Large page support\nstatic size_t _large_page_size = 0;\n\n// Insertion sort for small arrays (descending order).\nstatic void insertion_sort_descending(size_t* array, int len) {\n  for (int i = 0; i < len; i++) {\n    size_t val = array[i];\n    for (size_t key = i; key > 0 && array[key - 1] < val; --key) {\n      size_t tmp = array[key];\n      array[key] = array[key - 1];\n      array[key - 1] = tmp;\n    }\n  }\n}\n\nbool os::Solaris::mpss_sanity_check(bool warn, size_t* page_size) {\n  const unsigned int usable_count = VM_Version::page_size_count();\n  if (usable_count == 1) {\n    return false;\n  }\n\n  // Find the right getpagesizes interface.  When solaris 11 is the minimum\n  // build platform, getpagesizes() (without the '2') can be called directly.\n  typedef int (*gps_t)(size_t[], int);\n  gps_t gps_func = CAST_TO_FN_PTR(gps_t, dlsym(RTLD_DEFAULT, \"getpagesizes2\"));\n  if (gps_func == NULL) {\n    gps_func = CAST_TO_FN_PTR(gps_t, dlsym(RTLD_DEFAULT, \"getpagesizes\"));\n    if (gps_func == NULL) {\n      if (warn) {\n        warning(\"MPSS is not supported by the operating system.\");\n      }\n      return false;\n    }\n  }\n\n  // Fill the array of page sizes.\n  int n = (*gps_func)(_page_sizes, page_sizes_max);\n  assert(n > 0, \"Solaris bug?\");\n\n  if (n == page_sizes_max) {\n    // Add a sentinel value (necessary only if the array was completely filled\n    // since it is static (zeroed at initialization)).\n    _page_sizes[--n] = 0;\n    DEBUG_ONLY(warning(\"increase the size of the os::_page_sizes array.\");)\n  }\n  assert(_page_sizes[n] == 0, \"missing sentinel\");\n  trace_page_sizes(\"available page sizes\", _page_sizes, n);\n\n  if (n == 1) return false;     // Only one page size available.\n\n  // Skip sizes larger than 4M (or LargePageSizeInBytes if it was set) and\n  // select up to usable_count elements.  First sort the array, find the first\n  // acceptable value, then copy the usable sizes to the top of the array and\n  // trim the rest.  Make sure to include the default page size :-).\n  //\n  // A better policy could get rid of the 4M limit by taking the sizes of the\n  // important VM memory regions (java heap and possibly the code cache) into\n  // account.\n  insertion_sort_descending(_page_sizes, n);\n  const size_t size_limit =\n    FLAG_IS_DEFAULT(LargePageSizeInBytes) ? 4 * M : LargePageSizeInBytes;\n  int beg;\n  for (beg = 0; beg < n && _page_sizes[beg] > size_limit; ++beg) /* empty */ ;\n  const int end = MIN2((int)usable_count, n) - 1;\n  for (int cur = 0; cur < end; ++cur, ++beg) {\n    _page_sizes[cur] = _page_sizes[beg];\n  }\n  _page_sizes[end] = vm_page_size();\n  _page_sizes[end + 1] = 0;\n\n  if (_page_sizes[end] > _page_sizes[end - 1]) {\n    // Default page size is not the smallest; sort again.\n    insertion_sort_descending(_page_sizes, end + 1);\n  }\n  *page_size = _page_sizes[0];\n\n  trace_page_sizes(\"usable page sizes\", _page_sizes, end + 1);\n  return true;\n}\n\nvoid os::large_page_init() {\n  if (UseLargePages) {\n    // print a warning if any large page related flag is specified on command line\n    bool warn_on_failure = !FLAG_IS_DEFAULT(UseLargePages)        ||\n                           !FLAG_IS_DEFAULT(LargePageSizeInBytes);\n\n    UseLargePages = Solaris::mpss_sanity_check(warn_on_failure, &_large_page_size);\n  }\n}\n\nbool os::Solaris::is_valid_page_size(size_t bytes) {\n  for (int i = 0; _page_sizes[i] != 0; i++) {\n    if (_page_sizes[i] == bytes) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool os::Solaris::setup_large_pages(caddr_t start, size_t bytes, size_t align) {\n  assert(is_valid_page_size(align), err_msg(SIZE_FORMAT \" is not a valid page size\", align));\n  assert(is_ptr_aligned((void*) start, align),\n         err_msg(PTR_FORMAT \" is not aligned to \" SIZE_FORMAT, p2i((void*) start), align));\n  assert(is_size_aligned(bytes, align),\n         err_msg(SIZE_FORMAT \" is not aligned to \" SIZE_FORMAT, bytes, align));\n\n  // Signal to OS that we want large pages for addresses\n  // from addr, addr + bytes\n  struct memcntl_mha mpss_struct;\n  mpss_struct.mha_cmd = MHA_MAPSIZE_VA;\n  mpss_struct.mha_pagesize = align;\n  mpss_struct.mha_flags = 0;\n  // Upon successful completion, memcntl() returns 0\n  if (memcntl(start, bytes, MC_HAT_ADVISE, (caddr_t) &mpss_struct, 0, 0)) {\n    debug_only(warning(\"Attempt to use MPSS failed.\"));\n    return false;\n  }\n  return true;\n}\n\nchar* os::reserve_memory_special(size_t size, size_t alignment, char* addr, bool exec) {\n  fatal(\"os::reserve_memory_special should not be called on Solaris.\");\n  return NULL;\n}\n\nbool os::release_memory_special(char* base, size_t bytes) {\n  fatal(\"os::release_memory_special should not be called on Solaris.\");\n  return false;\n}\n\nsize_t os::large_page_size() {\n  return _large_page_size;\n}\n\n// MPSS allows application to commit large page memory on demand; with ISM\n// the entire memory region must be allocated as shared memory.\nbool os::can_commit_large_page_memory() {\n  return true;\n}\n\nbool os::can_execute_large_page_memory() {\n  return true;\n}\n\nstatic int os_sleep(jlong millis, bool interruptible) {\n  const jlong limit = INT_MAX;\n  jlong prevtime;\n  int res;\n\n  while (millis > limit) {\n    if ((res = os_sleep(limit, interruptible)) != OS_OK)\n      return res;\n    millis -= limit;\n  }\n\n  // Restart interrupted polls with new parameters until the proper delay\n  // has been completed.\n\n  prevtime = getTimeMillis();\n\n  while (millis > 0) {\n    jlong newtime;\n\n    if (!interruptible) {\n      // Following assert fails for os::yield_all:\n      // assert(!thread->is_Java_thread(), \"must not be java thread\");\n      res = poll(NULL, 0, millis);\n    } else {\n      JavaThread *jt = JavaThread::current();\n\n      INTERRUPTIBLE_NORESTART_VM_ALWAYS(poll(NULL, 0, millis), res, jt,\n        os::Solaris::clear_interrupted);\n    }\n\n    // INTERRUPTIBLE_NORESTART_VM_ALWAYS returns res == OS_INTRPT for\n    // thread.Interrupt.\n\n    // See c/r 6751923. Poll can return 0 before time\n    // has elapsed if time is set via clock_settime (as NTP does).\n    // res == 0 if poll timed out (see man poll RETURN VALUES)\n    // using the logic below checks that we really did\n    // sleep at least \"millis\" if not we'll sleep again.\n    if( ( res == 0 ) || ((res == OS_ERR) && (errno == EINTR))) {\n      newtime = getTimeMillis();\n      assert(newtime >= prevtime, \"time moving backwards\");\n    /* Doing prevtime and newtime in microseconds doesn't help precision,\n       and trying to round up to avoid lost milliseconds can result in a\n       too-short delay. */\n      millis -= newtime - prevtime;\n      if(millis <= 0)\n        return OS_OK;\n      prevtime = newtime;\n    } else\n      return res;\n  }\n\n  return OS_OK;\n}\n\n// Read calls from inside the vm need to perform state transitions\nsize_t os::read(int fd, void *buf, unsigned int nBytes) {\n  INTERRUPTIBLE_RETURN_INT_VM(::read(fd, buf, nBytes), os::Solaris::clear_interrupted);\n}\n\nsize_t os::restartable_read(int fd, void *buf, unsigned int nBytes) {\n  INTERRUPTIBLE_RETURN_INT(::read(fd, buf, nBytes), os::Solaris::clear_interrupted);\n}\n\nint os::sleep(Thread* thread, jlong millis, bool interruptible) {\n  assert(thread == Thread::current(),  \"thread consistency check\");\n\n  // TODO-FIXME: this should be removed.\n  // On Solaris machines (especially 2.5.1) we found that sometimes the VM gets into a live lock\n  // situation with a JavaThread being starved out of a lwp. The kernel doesn't seem to generate\n  // a SIGWAITING signal which would enable the threads library to create a new lwp for the starving\n  // thread. We suspect that because the Watcher thread keeps waking up at periodic intervals the kernel\n  // is fooled into believing that the system is making progress. In the code below we block the\n  // the watcher thread while safepoint is in progress so that it would not appear as though the\n  // system is making progress.\n  if (!Solaris::T2_libthread() &&\n      thread->is_Watcher_thread() && SafepointSynchronize::is_synchronizing() && !Arguments::has_profile()) {\n    // We now try to acquire the threads lock. Since this lock is held by the VM thread during\n    // the entire safepoint, the watcher thread will  line up here during the safepoint.\n    Threads_lock->lock_without_safepoint_check();\n    Threads_lock->unlock();\n  }\n\n  if (thread->is_Java_thread()) {\n    // This is a JavaThread so we honor the _thread_blocked protocol\n    // even for sleeps of 0 milliseconds. This was originally done\n    // as a workaround for bug 4338139. However, now we also do it\n    // to honor the suspend-equivalent protocol.\n\n    JavaThread *jt = (JavaThread *) thread;\n    ThreadBlockInVM tbivm(jt);\n\n    jt->set_suspend_equivalent();\n    // cleared by handle_special_suspend_equivalent_condition() or\n    // java_suspend_self() via check_and_wait_while_suspended()\n\n    int ret_code;\n    if (millis <= 0) {\n      thr_yield();\n      ret_code = 0;\n    } else {\n      // The original sleep() implementation did not create an\n      // OSThreadWaitState helper for sleeps of 0 milliseconds.\n      // I'm preserving that decision for now.\n      OSThreadWaitState osts(jt->osthread(), false /* not Object.wait() */);\n\n      ret_code = os_sleep(millis, interruptible);\n    }\n\n    // were we externally suspended while we were waiting?\n    jt->check_and_wait_while_suspended();\n\n    return ret_code;\n  }\n\n  // non-JavaThread from this point on:\n\n  if (millis <= 0) {\n    thr_yield();\n    return 0;\n  }\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n\n  return os_sleep(millis, interruptible);\n}\n\nvoid os::naked_short_sleep(jlong ms) {\n  assert(ms < 1000, \"Un-interruptable sleep, short time use only\");\n\n  // usleep is deprecated and removed from POSIX, in favour of nanosleep, but\n  // Solaris requires -lrt for this.\n  usleep((ms * 1000));\n\n  return;\n}\n\n// Sleep forever; naked call to OS-specific sleep; use with CAUTION\nvoid os::infinite_sleep() {\n  while (true) {    // sleep forever ...\n    ::sleep(100);   // ... 100 seconds at a time\n  }\n}\n\n// Used to convert frequent JVM_Yield() to nops\nbool os::dont_yield() {\n  if (DontYieldALot) {\n    static hrtime_t last_time = 0;\n    hrtime_t diff = getTimeNanos() - last_time;\n\n    if (diff < DontYieldALotInterval * 1000000)\n      return true;\n\n    last_time += diff;\n\n    return false;\n  }\n  else {\n    return false;\n  }\n}\n\n// Caveat: Solaris os::yield() causes a thread-state transition whereas\n// the linux and win32 implementations do not.  This should be checked.\n\nvoid os::yield() {\n  // Yields to all threads with same or greater priority\n  os::sleep(Thread::current(), 0, false);\n}\n\n// Note that yield semantics are defined by the scheduling class to which\n// the thread currently belongs.  Typically, yield will _not yield to\n// other equal or higher priority threads that reside on the dispatch queues\n// of other CPUs.\n\nos::YieldResult os::NakedYield() { thr_yield(); return os::YIELD_UNKNOWN; }\n\n\n// On Solaris we found that yield_all doesn't always yield to all other threads.\n// There have been cases where there is a thread ready to execute but it doesn't\n// get an lwp as the VM thread continues to spin with sleeps of 1 millisecond.\n// The 1 millisecond wait doesn't seem long enough for the kernel to issue a\n// SIGWAITING signal which will cause a new lwp to be created. So we count the\n// number of times yield_all is called in the one loop and increase the sleep\n// time after 8 attempts. If this fails too we increase the concurrency level\n// so that the starving thread would get an lwp\n\nvoid os::yield_all(int attempts) {\n  // Yields to all threads, including threads with lower priorities\n  if (attempts == 0) {\n    os::sleep(Thread::current(), 1, false);\n  } else {\n    int iterations = attempts % 30;\n    if (iterations == 0 && !os::Solaris::T2_libthread()) {\n      // thr_setconcurrency and _getconcurrency make sense only under T1.\n      int noofLWPS = thr_getconcurrency();\n      if (noofLWPS < (Threads::number_of_threads() + 2)) {\n        thr_setconcurrency(thr_getconcurrency() + 1);\n      }\n    } else if (iterations < 25) {\n      os::sleep(Thread::current(), 1, false);\n    } else {\n      os::sleep(Thread::current(), 10, false);\n    }\n  }\n}\n\n// Called from the tight loops to possibly influence time-sharing heuristics\nvoid os::loop_breaker(int attempts) {\n  os::yield_all(attempts);\n}\n\n\n// Interface for setting lwp priorities.  If we are using T2 libthread,\n// which forces the use of BoundThreads or we manually set UseBoundThreads,\n// all of our threads will be assigned to real lwp's.  Using the thr_setprio\n// function is meaningless in this mode so we must adjust the real lwp's priority\n// The routines below implement the getting and setting of lwp priorities.\n//\n// Note: There are three priority scales used on Solaris.  Java priotities\n//       which range from 1 to 10, libthread \"thr_setprio\" scale which range\n//       from 0 to 127, and the current scheduling class of the process we\n//       are running in.  This is typically from -60 to +60.\n//       The setting of the lwp priorities in done after a call to thr_setprio\n//       so Java priorities are mapped to libthread priorities and we map from\n//       the latter to lwp priorities.  We don't keep priorities stored in\n//       Java priorities since some of our worker threads want to set priorities\n//       higher than all Java threads.\n//\n// For related information:\n// (1)  man -s 2 priocntl\n// (2)  man -s 4 priocntl\n// (3)  man dispadmin\n// =    librt.so\n// =    libthread/common/rtsched.c - thrp_setlwpprio().\n// =    ps -cL <pid> ... to validate priority.\n// =    sched_get_priority_min and _max\n//              pthread_create\n//              sched_setparam\n//              pthread_setschedparam\n//\n// Assumptions:\n// +    We assume that all threads in the process belong to the same\n//              scheduling class.   IE. an homogenous process.\n// +    Must be root or in IA group to change change \"interactive\" attribute.\n//              Priocntl() will fail silently.  The only indication of failure is when\n//              we read-back the value and notice that it hasn't changed.\n// +    Interactive threads enter the runq at the head, non-interactive at the tail.\n// +    For RT, change timeslice as well.  Invariant:\n//              constant \"priority integral\"\n//              Konst == TimeSlice * (60-Priority)\n//              Given a priority, compute appropriate timeslice.\n// +    Higher numerical values have higher priority.\n\n// sched class attributes\ntypedef struct {\n        int   schedPolicy;              // classID\n        int   maxPrio;\n        int   minPrio;\n} SchedInfo;\n\n\nstatic SchedInfo tsLimits, iaLimits, rtLimits, fxLimits;\n\n#ifdef ASSERT\nstatic int  ReadBackValidate = 1;\n#endif\nstatic int  myClass     = 0;\nstatic int  myMin       = 0;\nstatic int  myMax       = 0;\nstatic int  myCur       = 0;\nstatic bool priocntl_enable = false;\n\nstatic const int criticalPrio = 60; // FX/60 is critical thread class/priority on T4\nstatic int java_MaxPriority_to_os_priority = 0; // Saved mapping\n\n\n// lwp_priocntl_init\n//\n// Try to determine the priority scale for our process.\n//\n// Return errno or 0 if OK.\n//\nstatic int lwp_priocntl_init () {\n  int rslt;\n  pcinfo_t ClassInfo;\n  pcparms_t ParmInfo;\n  int i;\n\n  if (!UseThreadPriorities) return 0;\n\n  // We are using Bound threads, we need to determine our priority ranges\n  if (os::Solaris::T2_libthread() || UseBoundThreads) {\n    // If ThreadPriorityPolicy is 1, switch tables\n    if (ThreadPriorityPolicy == 1) {\n      for (i = 0 ; i < CriticalPriority+1; i++)\n        os::java_to_os_priority[i] = prio_policy1[i];\n    }\n    if (UseCriticalJavaThreadPriority) {\n      // MaxPriority always maps to the FX scheduling class and criticalPrio.\n      // See set_native_priority() and set_lwp_class_and_priority().\n      // Save original MaxPriority mapping in case attempt to\n      // use critical priority fails.\n      java_MaxPriority_to_os_priority = os::java_to_os_priority[MaxPriority];\n      // Set negative to distinguish from other priorities\n      os::java_to_os_priority[MaxPriority] = -criticalPrio;\n    }\n  }\n  // Not using Bound Threads, set to ThreadPolicy 1\n  else {\n    for ( i = 0 ; i < CriticalPriority+1; i++ ) {\n      os::java_to_os_priority[i] = prio_policy1[i];\n    }\n    return 0;\n  }\n\n  // Get IDs for a set of well-known scheduling classes.\n  // TODO-FIXME: GETCLINFO returns the current # of classes in the\n  // the system.  We should have a loop that iterates over the\n  // classID values, which are known to be \"small\" integers.\n\n  strcpy(ClassInfo.pc_clname, \"TS\");\n  ClassInfo.pc_cid = -1;\n  rslt = priocntl(P_ALL, 0, PC_GETCID, (caddr_t)&ClassInfo);\n  if (rslt < 0) return errno;\n  assert(ClassInfo.pc_cid != -1, \"cid for TS class is -1\");\n  tsLimits.schedPolicy = ClassInfo.pc_cid;\n  tsLimits.maxPrio = ((tsinfo_t*)ClassInfo.pc_clinfo)->ts_maxupri;\n  tsLimits.minPrio = -tsLimits.maxPrio;\n\n  strcpy(ClassInfo.pc_clname, \"IA\");\n  ClassInfo.pc_cid = -1;\n  rslt = priocntl(P_ALL, 0, PC_GETCID, (caddr_t)&ClassInfo);\n  if (rslt < 0) return errno;\n  assert(ClassInfo.pc_cid != -1, \"cid for IA class is -1\");\n  iaLimits.schedPolicy = ClassInfo.pc_cid;\n  iaLimits.maxPrio = ((iainfo_t*)ClassInfo.pc_clinfo)->ia_maxupri;\n  iaLimits.minPrio = -iaLimits.maxPrio;\n\n  strcpy(ClassInfo.pc_clname, \"RT\");\n  ClassInfo.pc_cid = -1;\n  rslt = priocntl(P_ALL, 0, PC_GETCID, (caddr_t)&ClassInfo);\n  if (rslt < 0) return errno;\n  assert(ClassInfo.pc_cid != -1, \"cid for RT class is -1\");\n  rtLimits.schedPolicy = ClassInfo.pc_cid;\n  rtLimits.maxPrio = ((rtinfo_t*)ClassInfo.pc_clinfo)->rt_maxpri;\n  rtLimits.minPrio = 0;\n\n  strcpy(ClassInfo.pc_clname, \"FX\");\n  ClassInfo.pc_cid = -1;\n  rslt = priocntl(P_ALL, 0, PC_GETCID, (caddr_t)&ClassInfo);\n  if (rslt < 0) return errno;\n  assert(ClassInfo.pc_cid != -1, \"cid for FX class is -1\");\n  fxLimits.schedPolicy = ClassInfo.pc_cid;\n  fxLimits.maxPrio = ((fxinfo_t*)ClassInfo.pc_clinfo)->fx_maxupri;\n  fxLimits.minPrio = 0;\n\n  // Query our \"current\" scheduling class.\n  // This will normally be IA, TS or, rarely, FX or RT.\n  memset(&ParmInfo, 0, sizeof(ParmInfo));\n  ParmInfo.pc_cid = PC_CLNULL;\n  rslt = priocntl(P_PID, P_MYID, PC_GETPARMS, (caddr_t)&ParmInfo);\n  if (rslt < 0) return errno;\n  myClass = ParmInfo.pc_cid;\n\n  // We now know our scheduling classId, get specific information\n  // about the class.\n  ClassInfo.pc_cid = myClass;\n  ClassInfo.pc_clname[0] = 0;\n  rslt = priocntl((idtype)0, 0, PC_GETCLINFO, (caddr_t)&ClassInfo);\n  if (rslt < 0) return errno;\n\n  if (ThreadPriorityVerbose) {\n    tty->print_cr(\"lwp_priocntl_init: Class=%d(%s)...\", myClass, ClassInfo.pc_clname);\n  }\n\n  memset(&ParmInfo, 0, sizeof(pcparms_t));\n  ParmInfo.pc_cid = PC_CLNULL;\n  rslt = priocntl(P_PID, P_MYID, PC_GETPARMS, (caddr_t)&ParmInfo);\n  if (rslt < 0) return errno;\n\n  if (ParmInfo.pc_cid == rtLimits.schedPolicy) {\n    myMin = rtLimits.minPrio;\n    myMax = rtLimits.maxPrio;\n  } else if (ParmInfo.pc_cid == iaLimits.schedPolicy) {\n    iaparms_t *iaInfo  = (iaparms_t*)ParmInfo.pc_clparms;\n    myMin = iaLimits.minPrio;\n    myMax = iaLimits.maxPrio;\n    myMax = MIN2(myMax, (int)iaInfo->ia_uprilim);       // clamp - restrict\n  } else if (ParmInfo.pc_cid == tsLimits.schedPolicy) {\n    tsparms_t *tsInfo  = (tsparms_t*)ParmInfo.pc_clparms;\n    myMin = tsLimits.minPrio;\n    myMax = tsLimits.maxPrio;\n    myMax = MIN2(myMax, (int)tsInfo->ts_uprilim);       // clamp - restrict\n  } else if (ParmInfo.pc_cid == fxLimits.schedPolicy) {\n    fxparms_t *fxInfo = (fxparms_t*)ParmInfo.pc_clparms;\n    myMin = fxLimits.minPrio;\n    myMax = fxLimits.maxPrio;\n    myMax = MIN2(myMax, (int)fxInfo->fx_uprilim);       // clamp - restrict\n  } else {\n    // No clue - punt\n    if (ThreadPriorityVerbose)\n      tty->print_cr (\"Unknown scheduling class: %s ... \\n\", ClassInfo.pc_clname);\n    return EINVAL;      // no clue, punt\n  }\n\n  if (ThreadPriorityVerbose) {\n    tty->print_cr (\"Thread priority Range: [%d..%d]\\n\", myMin, myMax);\n  }\n\n  priocntl_enable = true;  // Enable changing priorities\n  return 0;\n}\n\n#define IAPRI(x)        ((iaparms_t *)((x).pc_clparms))\n#define RTPRI(x)        ((rtparms_t *)((x).pc_clparms))\n#define TSPRI(x)        ((tsparms_t *)((x).pc_clparms))\n#define FXPRI(x)        ((fxparms_t *)((x).pc_clparms))\n\n\n// scale_to_lwp_priority\n//\n// Convert from the libthread \"thr_setprio\" scale to our current\n// lwp scheduling class scale.\n//\nstatic\nint     scale_to_lwp_priority (int rMin, int rMax, int x)\n{\n  int v;\n\n  if (x == 127) return rMax;            // avoid round-down\n    v = (((x*(rMax-rMin)))/128)+rMin;\n  return v;\n}\n\n\n// set_lwp_class_and_priority\n//\n// Set the class and priority of the lwp.  This call should only\n// be made when using bound threads (T2 threads are bound by default).\n//\nint set_lwp_class_and_priority(int ThreadID, int lwpid,\n                               int newPrio, int new_class, bool scale) {\n  int rslt;\n  int Actual, Expected, prv;\n  pcparms_t ParmInfo;                   // for GET-SET\n#ifdef ASSERT\n  pcparms_t ReadBack;                   // for readback\n#endif\n\n  // Set priority via PC_GETPARMS, update, PC_SETPARMS\n  // Query current values.\n  // TODO: accelerate this by eliminating the PC_GETPARMS call.\n  // Cache \"pcparms_t\" in global ParmCache.\n  // TODO: elide set-to-same-value\n\n  // If something went wrong on init, don't change priorities.\n  if ( !priocntl_enable ) {\n    if (ThreadPriorityVerbose)\n      tty->print_cr(\"Trying to set priority but init failed, ignoring\");\n    return EINVAL;\n  }\n\n  // If lwp hasn't started yet, just return\n  // the _start routine will call us again.\n  if ( lwpid <= 0 ) {\n    if (ThreadPriorityVerbose) {\n      tty->print_cr (\"deferring the set_lwp_class_and_priority of thread \"\n                     INTPTR_FORMAT \" to %d, lwpid not set\",\n                     ThreadID, newPrio);\n    }\n    return 0;\n  }\n\n  if (ThreadPriorityVerbose) {\n    tty->print_cr (\"set_lwp_class_and_priority(\"\n                   INTPTR_FORMAT \"@\" INTPTR_FORMAT \" %d) \",\n                   ThreadID, lwpid, newPrio);\n  }\n\n  memset(&ParmInfo, 0, sizeof(pcparms_t));\n  ParmInfo.pc_cid = PC_CLNULL;\n  rslt = priocntl(P_LWPID, lwpid, PC_GETPARMS, (caddr_t)&ParmInfo);\n  if (rslt < 0) return errno;\n\n  int cur_class = ParmInfo.pc_cid;\n  ParmInfo.pc_cid = (id_t)new_class;\n\n  if (new_class == rtLimits.schedPolicy) {\n    rtparms_t *rtInfo  = (rtparms_t*)ParmInfo.pc_clparms;\n    rtInfo->rt_pri     = scale ? scale_to_lwp_priority(rtLimits.minPrio,\n                                                       rtLimits.maxPrio, newPrio)\n                               : newPrio;\n    rtInfo->rt_tqsecs  = RT_NOCHANGE;\n    rtInfo->rt_tqnsecs = RT_NOCHANGE;\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"RT: %d->%d\\n\", newPrio, rtInfo->rt_pri);\n    }\n  } else if (new_class == iaLimits.schedPolicy) {\n    iaparms_t* iaInfo  = (iaparms_t*)ParmInfo.pc_clparms;\n    int maxClamped     = MIN2(iaLimits.maxPrio,\n                              cur_class == new_class\n                                ? (int)iaInfo->ia_uprilim : iaLimits.maxPrio);\n    iaInfo->ia_upri    = scale ? scale_to_lwp_priority(iaLimits.minPrio,\n                                                       maxClamped, newPrio)\n                               : newPrio;\n    iaInfo->ia_uprilim = cur_class == new_class\n                           ? IA_NOCHANGE : (pri_t)iaLimits.maxPrio;\n    iaInfo->ia_mode    = IA_NOCHANGE;\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"IA: [%d...%d] %d->%d\\n\",\n                    iaLimits.minPrio, maxClamped, newPrio, iaInfo->ia_upri);\n    }\n  } else if (new_class == tsLimits.schedPolicy) {\n    tsparms_t* tsInfo  = (tsparms_t*)ParmInfo.pc_clparms;\n    int maxClamped     = MIN2(tsLimits.maxPrio,\n                              cur_class == new_class\n                                ? (int)tsInfo->ts_uprilim : tsLimits.maxPrio);\n    tsInfo->ts_upri    = scale ? scale_to_lwp_priority(tsLimits.minPrio,\n                                                       maxClamped, newPrio)\n                               : newPrio;\n    tsInfo->ts_uprilim = cur_class == new_class\n                           ? TS_NOCHANGE : (pri_t)tsLimits.maxPrio;\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"TS: [%d...%d] %d->%d\\n\",\n                    tsLimits.minPrio, maxClamped, newPrio, tsInfo->ts_upri);\n    }\n  } else if (new_class == fxLimits.schedPolicy) {\n    fxparms_t* fxInfo  = (fxparms_t*)ParmInfo.pc_clparms;\n    int maxClamped     = MIN2(fxLimits.maxPrio,\n                              cur_class == new_class\n                                ? (int)fxInfo->fx_uprilim : fxLimits.maxPrio);\n    fxInfo->fx_upri    = scale ? scale_to_lwp_priority(fxLimits.minPrio,\n                                                       maxClamped, newPrio)\n                               : newPrio;\n    fxInfo->fx_uprilim = cur_class == new_class\n                           ? FX_NOCHANGE : (pri_t)fxLimits.maxPrio;\n    fxInfo->fx_tqsecs  = FX_NOCHANGE;\n    fxInfo->fx_tqnsecs = FX_NOCHANGE;\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"FX: [%d...%d] %d->%d\\n\",\n                    fxLimits.minPrio, maxClamped, newPrio, fxInfo->fx_upri);\n    }\n  } else {\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"Unknown new scheduling class %d\\n\", new_class);\n    }\n    return EINVAL;    // no clue, punt\n  }\n\n  rslt = priocntl(P_LWPID, lwpid, PC_SETPARMS, (caddr_t)&ParmInfo);\n  if (ThreadPriorityVerbose && rslt) {\n    tty->print_cr (\"PC_SETPARMS ->%d %d\\n\", rslt, errno);\n  }\n  if (rslt < 0) return errno;\n\n#ifdef ASSERT\n  // Sanity check: read back what we just attempted to set.\n  // In theory it could have changed in the interim ...\n  //\n  // The priocntl system call is tricky.\n  // Sometimes it'll validate the priority value argument and\n  // return EINVAL if unhappy.  At other times it fails silently.\n  // Readbacks are prudent.\n\n  if (!ReadBackValidate) return 0;\n\n  memset(&ReadBack, 0, sizeof(pcparms_t));\n  ReadBack.pc_cid = PC_CLNULL;\n  rslt = priocntl(P_LWPID, lwpid, PC_GETPARMS, (caddr_t)&ReadBack);\n  assert(rslt >= 0, \"priocntl failed\");\n  Actual = Expected = 0xBAD;\n  assert(ParmInfo.pc_cid == ReadBack.pc_cid, \"cid's don't match\");\n  if (ParmInfo.pc_cid == rtLimits.schedPolicy) {\n    Actual   = RTPRI(ReadBack)->rt_pri;\n    Expected = RTPRI(ParmInfo)->rt_pri;\n  } else if (ParmInfo.pc_cid == iaLimits.schedPolicy) {\n    Actual   = IAPRI(ReadBack)->ia_upri;\n    Expected = IAPRI(ParmInfo)->ia_upri;\n  } else if (ParmInfo.pc_cid == tsLimits.schedPolicy) {\n    Actual   = TSPRI(ReadBack)->ts_upri;\n    Expected = TSPRI(ParmInfo)->ts_upri;\n  } else if (ParmInfo.pc_cid == fxLimits.schedPolicy) {\n    Actual   = FXPRI(ReadBack)->fx_upri;\n    Expected = FXPRI(ParmInfo)->fx_upri;\n  } else {\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"set_lwp_class_and_priority: unexpected class in readback: %d\\n\",\n                    ParmInfo.pc_cid);\n    }\n  }\n\n  if (Actual != Expected) {\n    if (ThreadPriorityVerbose) {\n      tty->print_cr (\"set_lwp_class_and_priority(%d %d) Class=%d: actual=%d vs expected=%d\\n\",\n                     lwpid, newPrio, ReadBack.pc_cid, Actual, Expected);\n    }\n  }\n#endif\n\n  return 0;\n}\n\n// Solaris only gives access to 128 real priorities at a time,\n// so we expand Java's ten to fill this range.  This would be better\n// if we dynamically adjusted relative priorities.\n//\n// The ThreadPriorityPolicy option allows us to select 2 different\n// priority scales.\n//\n// ThreadPriorityPolicy=0\n// Since the Solaris' default priority is MaximumPriority, we do not\n// set a priority lower than Max unless a priority lower than\n// NormPriority is requested.\n//\n// ThreadPriorityPolicy=1\n// This mode causes the priority table to get filled with\n// linear values.  NormPriority get's mapped to 50% of the\n// Maximum priority an so on.  This will cause VM threads\n// to get unfair treatment against other Solaris processes\n// which do not explicitly alter their thread priorities.\n//\n\nint os::java_to_os_priority[CriticalPriority + 1] = {\n  -99999,         // 0 Entry should never be used\n\n  0,              // 1 MinPriority\n  32,             // 2\n  64,             // 3\n\n  96,             // 4\n  127,            // 5 NormPriority\n  127,            // 6\n\n  127,            // 7\n  127,            // 8\n  127,            // 9 NearMaxPriority\n\n  127,            // 10 MaxPriority\n\n  -criticalPrio   // 11 CriticalPriority\n};\n\nOSReturn os::set_native_priority(Thread* thread, int newpri) {\n  OSThread* osthread = thread->osthread();\n\n  // Save requested priority in case the thread hasn't been started\n  osthread->set_native_priority(newpri);\n\n  // Check for critical priority request\n  bool fxcritical = false;\n  if (newpri == -criticalPrio) {\n    fxcritical = true;\n    newpri = criticalPrio;\n  }\n\n  assert(newpri >= MinimumPriority && newpri <= MaximumPriority, \"bad priority mapping\");\n  if (!UseThreadPriorities) return OS_OK;\n\n  int status = 0;\n\n  if (!fxcritical) {\n    // Use thr_setprio only if we have a priority that thr_setprio understands\n    status = thr_setprio(thread->osthread()->thread_id(), newpri);\n  }\n\n  if (os::Solaris::T2_libthread() ||\n      (UseBoundThreads && osthread->is_vm_created())) {\n    int lwp_status =\n      set_lwp_class_and_priority(osthread->thread_id(),\n                                 osthread->lwp_id(),\n                                 newpri,\n                                 fxcritical ? fxLimits.schedPolicy : myClass,\n                                 !fxcritical);\n    if (lwp_status != 0 && fxcritical) {\n      // Try again, this time without changing the scheduling class\n      newpri = java_MaxPriority_to_os_priority;\n      lwp_status = set_lwp_class_and_priority(osthread->thread_id(),\n                                              osthread->lwp_id(),\n                                              newpri, myClass, false);\n    }\n    status |= lwp_status;\n  }\n  return (status == 0) ? OS_OK : OS_ERR;\n}\n\n\nOSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {\n  int p;\n  if ( !UseThreadPriorities ) {\n    *priority_ptr = NormalPriority;\n    return OS_OK;\n  }\n  int status = thr_getprio(thread->osthread()->thread_id(), &p);\n  if (status != 0) {\n    return OS_ERR;\n  }\n  *priority_ptr = p;\n  return OS_OK;\n}\n\n\n// Hint to the underlying OS that a task switch would not be good.\n// Void return because it's a hint and can fail.\nvoid os::hint_no_preempt() {\n  schedctl_start(schedctl_init());\n}\n\nstatic void resume_clear_context(OSThread *osthread) {\n  osthread->set_ucontext(NULL);\n}\n\nstatic void suspend_save_context(OSThread *osthread, ucontext_t* context) {\n  osthread->set_ucontext(context);\n}\n\nstatic Semaphore sr_semaphore;\n\nvoid os::Solaris::SR_handler(Thread* thread, ucontext_t* uc) {\n  // Save and restore errno to avoid confusing native code with EINTR\n  // after sigsuspend.\n  int old_errno = errno;\n\n  OSThread* osthread = thread->osthread();\n  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n\n  os::SuspendResume::State current = osthread->sr.state();\n  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n    suspend_save_context(osthread, uc);\n\n    // attempt to switch the state, we assume we had a SUSPEND_REQUEST\n    os::SuspendResume::State state = osthread->sr.suspended();\n    if (state == os::SuspendResume::SR_SUSPENDED) {\n      sigset_t suspend_set;  // signals for sigsuspend()\n\n      // get current set of blocked signals and unblock resume signal\n      thr_sigsetmask(SIG_BLOCK, NULL, &suspend_set);\n      sigdelset(&suspend_set, os::Solaris::SIGasync());\n\n      sr_semaphore.signal();\n      // wait here until we are resumed\n      while (1) {\n        sigsuspend(&suspend_set);\n\n        os::SuspendResume::State result = osthread->sr.running();\n        if (result == os::SuspendResume::SR_RUNNING) {\n          sr_semaphore.signal();\n          break;\n        }\n      }\n\n    } else if (state == os::SuspendResume::SR_RUNNING) {\n      // request was cancelled, continue\n    } else {\n      ShouldNotReachHere();\n    }\n\n    resume_clear_context(osthread);\n  } else if (current == os::SuspendResume::SR_RUNNING) {\n    // request was cancelled, continue\n  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // ignore\n  } else {\n    // ignore\n  }\n\n  errno = old_errno;\n}\n\n\nvoid os::interrupt(Thread* thread) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(), \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  int isInterrupted = osthread->interrupted();\n  if (!isInterrupted) {\n      osthread->set_interrupted(true);\n      OrderAccess::fence();\n      // os::sleep() is implemented with either poll (NULL,0,timeout) or\n      // by parking on _SleepEvent.  If the former, thr_kill will unwedge\n      // the sleeper by SIGINTR, otherwise the unpark() will wake the sleeper.\n      ParkEvent * const slp = thread->_SleepEvent ;\n      if (slp != NULL) slp->unpark() ;\n  }\n\n  // For JSR166:  unpark after setting status but before thr_kill -dl\n  if (thread->is_Java_thread()) {\n    ((JavaThread*)thread)->parker()->unpark();\n  }\n\n  // Handle interruptible wait() ...\n  ParkEvent * const ev = thread->_ParkEvent ;\n  if (ev != NULL) ev->unpark() ;\n\n  // When events are used everywhere for os::sleep, then this thr_kill\n  // will only be needed if UseVMInterruptibleIO is true.\n\n  if (!isInterrupted) {\n    int status = thr_kill(osthread->thread_id(), os::Solaris::SIGinterrupt());\n    assert_status(status == 0, status, \"thr_kill\");\n\n    // Bump thread interruption counter\n    RuntimeService::record_thread_interrupt_signaled_count();\n  }\n}\n\n\nbool os::is_interrupted(Thread* thread, bool clear_interrupted) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(), \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  bool res = osthread->interrupted();\n\n  // NOTE that since there is no \"lock\" around these two operations,\n  // there is the possibility that the interrupted flag will be\n  // \"false\" but that the interrupt event will be set. This is\n  // intentional. The effect of this is that Object.wait() will appear\n  // to have a spurious wakeup, which is not harmful, and the\n  // possibility is so rare that it is not worth the added complexity\n  // to add yet another lock. It has also been recommended not to put\n  // the interrupted flag into the os::Solaris::Event structure,\n  // because it hides the issue.\n  if (res && clear_interrupted) {\n    osthread->set_interrupted(false);\n  }\n  return res;\n}\n\n\nvoid os::print_statistics() {\n}\n\nint os::message_box(const char* title, const char* message) {\n  int i;\n  fdStream err(defaultStream::error_fd());\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n  err.print_raw_cr(title);\n  for (i = 0; i < 78; i++) err.print_raw(\"-\");\n  err.cr();\n  err.print_raw_cr(message);\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n\n  char buf[16];\n  // Prevent process from exiting upon \"read error\" without consuming all CPU\n  while (::read(0, buf, sizeof(buf)) <= 0) { ::sleep(100); }\n\n  return buf[0] == 'y' || buf[0] == 'Y';\n}\n\nstatic int sr_notify(OSThread* osthread) {\n  int status = thr_kill(osthread->thread_id(), os::Solaris::SIGasync());\n  assert_status(status == 0, status, \"thr_kill\");\n  return status;\n}\n\n// \"Randomly\" selected value for how long we want to spin\n// before bailing out on suspending a thread, also how often\n// we send a signal to a thread we want to resume\nstatic const int RANDOMLY_LARGE_INTEGER = 1000000;\nstatic const int RANDOMLY_LARGE_INTEGER2 = 100;\n\nstatic bool do_suspend(OSThread* osthread) {\n  assert(osthread->sr.is_running(), \"thread should be running\");\n  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n\n  // mark as suspended and send signal\n  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n    // failed to switch, state wasn't running?\n    ShouldNotReachHere();\n    return false;\n  }\n\n  if (sr_notify(osthread) != 0) {\n    ShouldNotReachHere();\n  }\n\n  // managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n  while (true) {\n    if (sr_semaphore.timedwait(0, 2000 * NANOSECS_PER_MILLISEC)) {\n      break;\n    } else {\n      // timeout\n      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n      if (cancelled == os::SuspendResume::SR_RUNNING) {\n        return false;\n      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n        // make sure that we consume the signal on the semaphore as well\n        sr_semaphore.wait();\n        break;\n      } else {\n        ShouldNotReachHere();\n        return false;\n      }\n    }\n  }\n\n  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n  return true;\n}\n\nstatic void do_resume(OSThread* osthread) {\n  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n\n  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // failed to switch to WAKEUP_REQUEST\n    ShouldNotReachHere();\n    return;\n  }\n\n  while (true) {\n    if (sr_notify(osthread) == 0) {\n      if (sr_semaphore.timedwait(0, 2 * NANOSECS_PER_MILLISEC)) {\n        if (osthread->sr.is_running()) {\n          return;\n        }\n      }\n    } else {\n      ShouldNotReachHere();\n    }\n  }\n\n  guarantee(osthread->sr.is_running(), \"Must be running!\");\n}\n\nvoid os::SuspendedThreadTask::internal_do_task() {\n  if (do_suspend(_thread->osthread())) {\n    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n    do_task(context);\n    do_resume(_thread->osthread());\n  }\n}\n\nclass PcFetcher : public os::SuspendedThreadTask {\npublic:\n  PcFetcher(Thread* thread) : os::SuspendedThreadTask(thread) {}\n  ExtendedPC result();\nprotected:\n  void do_task(const os::SuspendedThreadTaskContext& context);\nprivate:\n  ExtendedPC _epc;\n};\n\nExtendedPC PcFetcher::result() {\n  guarantee(is_done(), \"task is not done yet.\");\n  return _epc;\n}\n\nvoid PcFetcher::do_task(const os::SuspendedThreadTaskContext& context) {\n  Thread* thread = context.thread();\n  OSThread* osthread = thread->osthread();\n  if (osthread->ucontext() != NULL) {\n    _epc = os::Solaris::ucontext_get_pc((ucontext_t *) context.ucontext());\n  } else {\n    // NULL context is unexpected, double-check this is the VMThread\n    guarantee(thread->is_VM_thread(), \"can only be called for VMThread\");\n  }\n}\n\n// A lightweight implementation that does not suspend the target thread and\n// thus returns only a hint. Used for profiling only!\nExtendedPC os::get_thread_pc(Thread* thread) {\n  // Make sure that it is called by the watcher and the Threads lock is owned.\n  assert(Thread::current()->is_Watcher_thread(), \"Must be watcher and own Threads_lock\");\n  // For now, is only used to profile the VM Thread\n  assert(thread->is_VM_thread(), \"Can only be called for VMThread\");\n  PcFetcher fetcher(thread);\n  fetcher.run();\n  return fetcher.result();\n}\n\n\n// This does not do anything on Solaris. This is basically a hook for being\n// able to use structured exception handling (thread-local exception filters) on, e.g., Win32.\nvoid os::os_exception_wrapper(java_call_t f, JavaValue* value, methodHandle* method, JavaCallArguments* args, Thread* thread) {\n  f(value, method, args, thread);\n}\n\n// This routine may be used by user applications as a \"hook\" to catch signals.\n// The user-defined signal handler must pass unrecognized signals to this\n// routine, and if it returns true (non-zero), then the signal handler must\n// return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n// routine will never retun false (zero), but instead will execute a VM panic\n// routine kill the process.\n//\n// If this routine returns false, it is OK to call it again.  This allows\n// the user-defined signal handler to perform checks either before or after\n// the VM performs its own checks.  Naturally, the user code would be making\n// a serious error if it tried to handle an exception (such as a null check\n// or breakpoint) that the VM was generating for its own correct operation.\n//\n// This routine may recognize any of the following kinds of signals:\n// SIGBUS, SIGSEGV, SIGILL, SIGFPE, BREAK_SIGNAL, SIGPIPE, SIGXFSZ,\n// os::Solaris::SIGasync\n// It should be consulted by handlers for any of those signals.\n// It explicitly does not recognize os::Solaris::SIGinterrupt\n//\n// The caller of this routine must pass in the three arguments supplied\n// to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n// field of the structure passed to sigaction().  This routine assumes that\n// the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n//\n// Note that the VM will print warnings if it detects conflicting signal\n// handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n//\nextern \"C\" JNIEXPORT int\nJVM_handle_solaris_signal(int signo, siginfo_t* siginfo, void* ucontext,\n                          int abort_if_unrecognized);\n\n\nvoid signalHandler(int sig, siginfo_t* info, void* ucVoid) {\n  int orig_errno = errno;  // Preserve errno value over signal handler.\n  JVM_handle_solaris_signal(sig, info, ucVoid, true);\n  errno = orig_errno;\n}\n\n/* Do not delete - if guarantee is ever removed,  a signal handler (even empty)\n   is needed to provoke threads blocked on IO to return an EINTR\n   Note: this explicitly does NOT call JVM_handle_solaris_signal and\n   does NOT participate in signal chaining due to requirement for\n   NOT setting SA_RESTART to make EINTR work. */\nextern \"C\" void sigINTRHandler(int sig, siginfo_t* info, void* ucVoid) {\n   if (UseSignalChaining) {\n      struct sigaction *actp = os::Solaris::get_chained_signal_action(sig);\n      if (actp && actp->sa_handler) {\n        vm_exit_during_initialization(\"Signal chaining detected for VM interrupt signal, try -XX:+UseAltSigs\");\n      }\n   }\n}\n\n// This boolean allows users to forward their own non-matching signals\n// to JVM_handle_solaris_signal, harmlessly.\nbool os::Solaris::signal_handlers_are_installed = false;\n\n// For signal-chaining\nbool os::Solaris::libjsig_is_loaded = false;\ntypedef struct sigaction *(*get_signal_t)(int);\nget_signal_t os::Solaris::get_signal_action = NULL;\n\nstruct sigaction* os::Solaris::get_chained_signal_action(int sig) {\n  struct sigaction *actp = NULL;\n\n  if ((libjsig_is_loaded)  && (sig <= Maxlibjsigsigs)) {\n    // Retrieve the old signal handler from libjsig\n    actp = (*get_signal_action)(sig);\n  }\n  if (actp == NULL) {\n    // Retrieve the preinstalled signal handler from jvm\n    actp = get_preinstalled_handler(sig);\n  }\n\n  return actp;\n}\n\nstatic bool call_chained_handler(struct sigaction *actp, int sig,\n                                 siginfo_t *siginfo, void *context) {\n  // Call the old signal handler\n  if (actp->sa_handler == SIG_DFL) {\n    // It's more reasonable to let jvm treat it as an unexpected exception\n    // instead of taking the default action.\n    return false;\n  } else if (actp->sa_handler != SIG_IGN) {\n    if ((actp->sa_flags & SA_NODEFER) == 0) {\n      // automaticlly block the signal\n      sigaddset(&(actp->sa_mask), sig);\n    }\n\n    sa_handler_t hand;\n    sa_sigaction_t sa;\n    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n    // retrieve the chained handler\n    if (siginfo_flag_set) {\n      sa = actp->sa_sigaction;\n    } else {\n      hand = actp->sa_handler;\n    }\n\n    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n      actp->sa_handler = SIG_DFL;\n    }\n\n    // try to honor the signal mask\n    sigset_t oset;\n    thr_sigsetmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n\n    // call into the chained handler\n    if (siginfo_flag_set) {\n      (*sa)(sig, siginfo, context);\n    } else {\n      (*hand)(sig);\n    }\n\n    // restore the signal mask\n    thr_sigsetmask(SIG_SETMASK, &oset, 0);\n  }\n  // Tell jvm's signal handler the signal is taken care of.\n  return true;\n}\n\nbool os::Solaris::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n  bool chained = false;\n  // signal-chaining\n  if (UseSignalChaining) {\n    struct sigaction *actp = get_chained_signal_action(sig);\n    if (actp != NULL) {\n      chained = call_chained_handler(actp, sig, siginfo, context);\n    }\n  }\n  return chained;\n}\n\nstruct sigaction* os::Solaris::get_preinstalled_handler(int sig) {\n  assert((chainedsigactions != (struct sigaction *)NULL) && (preinstalled_sigs != (int *)NULL) , \"signals not yet initialized\");\n  if (preinstalled_sigs[sig] != 0) {\n    return &chainedsigactions[sig];\n  }\n  return NULL;\n}\n\nvoid os::Solaris::save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n\n  assert(sig > 0 && sig <= Maxsignum, \"vm signal out of expected range\");\n  assert((chainedsigactions != (struct sigaction *)NULL) && (preinstalled_sigs != (int *)NULL) , \"signals not yet initialized\");\n  chainedsigactions[sig] = oldAct;\n  preinstalled_sigs[sig] = 1;\n}\n\nvoid os::Solaris::set_signal_handler(int sig, bool set_installed, bool oktochain) {\n  // Check for overwrite.\n  struct sigaction oldAct;\n  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n  void* oldhand = oldAct.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n                                      : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n      oldhand != CAST_FROM_FN_PTR(void*, signalHandler)) {\n    if (AllowUserSignalHandlers || !set_installed) {\n      // Do not overwrite; user takes responsibility to forward to us.\n      return;\n    } else if (UseSignalChaining) {\n      if (oktochain) {\n        // save the old handler in jvm\n        save_preinstalled_handler(sig, oldAct);\n      } else {\n        vm_exit_during_initialization(\"Signal chaining not allowed for VM interrupt signal, try -XX:+UseAltSigs.\");\n      }\n      // libjsig also interposes the sigaction() call below and saves the\n      // old sigaction on it own.\n    } else {\n      fatal(err_msg(\"Encountered unexpected pre-existing sigaction handler \"\n                    \"%#lx for signal %d.\", (long)oldhand, sig));\n    }\n  }\n\n  struct sigaction sigAct;\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_handler = SIG_DFL;\n\n  sigAct.sa_sigaction = signalHandler;\n  // Handle SIGSEGV on alternate signal stack if\n  // not using stack banging\n  if (!UseStackBanging && sig == SIGSEGV) {\n    sigAct.sa_flags = SA_SIGINFO | SA_RESTART | SA_ONSTACK;\n  // Interruptible i/o requires SA_RESTART cleared so EINTR\n  // is returned instead of restarting system calls\n  } else if (sig == os::Solaris::SIGinterrupt()) {\n    sigemptyset(&sigAct.sa_mask);\n    sigAct.sa_handler = NULL;\n    sigAct.sa_flags = SA_SIGINFO;\n    sigAct.sa_sigaction = sigINTRHandler;\n  } else {\n    sigAct.sa_flags = SA_SIGINFO | SA_RESTART;\n  }\n  os::Solaris::set_our_sigflags(sig, sigAct.sa_flags);\n\n  sigaction(sig, &sigAct, &oldAct);\n\n  void* oldhand2 = oldAct.sa_sigaction ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n                                       : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n}\n\n\n#define DO_SIGNAL_CHECK(sig) \\\n  if (!sigismember(&check_signal_done, sig)) \\\n    os::Solaris::check_signal_handler(sig)\n\n// This method is a periodic task to check for misbehaving JNI applications\n// under CheckJNI, we can add any periodic checks here\n\nvoid os::run_periodic_checks() {\n  // A big source of grief is hijacking virt. addr 0x0 on Solaris,\n  // thereby preventing a NULL checks.\n  if(!check_addr0_done) check_addr0_done = check_addr0(tty);\n\n  if (check_signals == false) return;\n\n  // SEGV and BUS if overridden could potentially prevent\n  // generation of hs*.log in the event of a crash, debugging\n  // such a case can be very challenging, so we absolutely\n  // check for the following for a good measure:\n  DO_SIGNAL_CHECK(SIGSEGV);\n  DO_SIGNAL_CHECK(SIGILL);\n  DO_SIGNAL_CHECK(SIGFPE);\n  DO_SIGNAL_CHECK(SIGBUS);\n  DO_SIGNAL_CHECK(SIGPIPE);\n  DO_SIGNAL_CHECK(SIGXFSZ);\n\n  // ReduceSignalUsage allows the user to override these handlers\n  // see comments at the very top and jvm_solaris.h\n  if (!ReduceSignalUsage) {\n    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n  }\n\n  // See comments above for using JVM1/JVM2 and UseAltSigs\n  DO_SIGNAL_CHECK(os::Solaris::SIGinterrupt());\n  DO_SIGNAL_CHECK(os::Solaris::SIGasync());\n\n}\n\ntypedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic os_sigaction_t os_sigaction = NULL;\n\nvoid os::Solaris::check_signal_handler(int sig) {\n  char buf[O_BUFLEN];\n  address jvmHandler = NULL;\n\n  struct sigaction act;\n  if (os_sigaction == NULL) {\n    // only trust the default sigaction, in case it has been interposed\n    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n    if (os_sigaction == NULL) return;\n  }\n\n  os_sigaction(sig, (struct sigaction*)NULL, &act);\n\n  address thisHandler = (act.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, act.sa_handler) ;\n\n\n  switch(sig) {\n    case SIGSEGV:\n    case SIGBUS:\n    case SIGFPE:\n    case SIGPIPE:\n    case SIGXFSZ:\n    case SIGILL:\n      jvmHandler = CAST_FROM_FN_PTR(address, signalHandler);\n      break;\n\n    case SHUTDOWN1_SIGNAL:\n    case SHUTDOWN2_SIGNAL:\n    case SHUTDOWN3_SIGNAL:\n    case BREAK_SIGNAL:\n      jvmHandler = (address)user_handler();\n      break;\n\n    default:\n      int intrsig = os::Solaris::SIGinterrupt();\n      int asynsig = os::Solaris::SIGasync();\n\n      if (sig == intrsig) {\n        jvmHandler = CAST_FROM_FN_PTR(address, sigINTRHandler);\n      } else if (sig == asynsig) {\n        jvmHandler = CAST_FROM_FN_PTR(address, signalHandler);\n      } else {\n        return;\n      }\n      break;\n  }\n\n\n  if (thisHandler != jvmHandler) {\n    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n    // Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n                    exception_name(sig, buf, O_BUFLEN));\n    }\n  } else if(os::Solaris::get_our_sigflags(sig) != 0 && act.sa_flags != os::Solaris::get_our_sigflags(sig)) {\n    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:\" PTR32_FORMAT, os::Solaris::get_our_sigflags(sig));\n    tty->print_cr(\"  found:\" PTR32_FORMAT, act.sa_flags);\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n  }\n\n  // Print all the signal handler state\n  if (sigismember(&check_signal_done, sig)) {\n    print_signal_handlers(tty, buf, O_BUFLEN);\n  }\n\n}\n\nvoid os::Solaris::install_signal_handlers() {\n  bool libjsigdone = false;\n  signal_handlers_are_installed = true;\n\n  // signal-chaining\n  typedef void (*signal_setting_t)();\n  signal_setting_t begin_signal_setting = NULL;\n  signal_setting_t end_signal_setting = NULL;\n  begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                                        dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n  if (begin_signal_setting != NULL) {\n    end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                                        dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n    get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n                                       dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n    get_libjsig_version = CAST_TO_FN_PTR(version_getting_t,\n                                         dlsym(RTLD_DEFAULT, \"JVM_get_libjsig_version\"));\n    libjsig_is_loaded = true;\n    if (os::Solaris::get_libjsig_version != NULL) {\n      libjsigversion =  (*os::Solaris::get_libjsig_version)();\n    }\n    assert(UseSignalChaining, \"should enable signal-chaining\");\n  }\n  if (libjsig_is_loaded) {\n    // Tell libjsig jvm is setting signal handlers\n    (*begin_signal_setting)();\n  }\n\n  set_signal_handler(SIGSEGV, true, true);\n  set_signal_handler(SIGPIPE, true, true);\n  set_signal_handler(SIGXFSZ, true, true);\n  set_signal_handler(SIGBUS, true, true);\n  set_signal_handler(SIGILL, true, true);\n  set_signal_handler(SIGFPE, true, true);\n\n\n  if (os::Solaris::SIGinterrupt() > OLDMAXSIGNUM || os::Solaris::SIGasync() > OLDMAXSIGNUM) {\n\n    // Pre-1.4.1 Libjsig limited to signal chaining signals <= 32 so\n    // can not register overridable signals which might be > 32\n    if (libjsig_is_loaded && libjsigversion <= JSIG_VERSION_1_4_1) {\n    // Tell libjsig jvm has finished setting signal handlers\n      (*end_signal_setting)();\n      libjsigdone = true;\n    }\n  }\n\n  // Never ok to chain our SIGinterrupt\n  set_signal_handler(os::Solaris::SIGinterrupt(), true, false);\n  set_signal_handler(os::Solaris::SIGasync(), true, true);\n\n  if (libjsig_is_loaded && !libjsigdone) {\n    // Tell libjsig jvm finishes setting signal handlers\n    (*end_signal_setting)();\n  }\n\n  // We don't activate signal checker if libjsig is in place, we trust ourselves\n  // and if UserSignalHandler is installed all bets are off.\n  // Log that signal checking is off only if -verbose:jni is specified.\n  if (CheckJNICalls) {\n    if (libjsig_is_loaded) {\n      if (PrintJNIResolving) {\n        tty->print_cr(\"Info: libjsig is activated, all active signal checking is disabled\");\n      }\n      check_signals = false;\n    }\n    if (AllowUserSignalHandlers) {\n      if (PrintJNIResolving) {\n        tty->print_cr(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n      }\n      check_signals = false;\n    }\n  }\n}\n\n\nvoid report_error(const char* file_name, int line_no, const char* title, const char* format, ...);\n\nconst char * signames[] = {\n  \"SIG0\",\n  \"SIGHUP\", \"SIGINT\", \"SIGQUIT\", \"SIGILL\", \"SIGTRAP\",\n  \"SIGABRT\", \"SIGEMT\", \"SIGFPE\", \"SIGKILL\", \"SIGBUS\",\n  \"SIGSEGV\", \"SIGSYS\", \"SIGPIPE\", \"SIGALRM\", \"SIGTERM\",\n  \"SIGUSR1\", \"SIGUSR2\", \"SIGCLD\", \"SIGPWR\", \"SIGWINCH\",\n  \"SIGURG\", \"SIGPOLL\", \"SIGSTOP\", \"SIGTSTP\", \"SIGCONT\",\n  \"SIGTTIN\", \"SIGTTOU\", \"SIGVTALRM\", \"SIGPROF\", \"SIGXCPU\",\n  \"SIGXFSZ\", \"SIGWAITING\", \"SIGLWP\", \"SIGFREEZE\", \"SIGTHAW\",\n  \"SIGCANCEL\", \"SIGLOST\"\n};\n\nconst char* os::exception_name(int exception_code, char* buf, size_t size) {\n  if (0 < exception_code && exception_code <= SIGRTMAX) {\n    // signal\n    if (exception_code < sizeof(signames)/sizeof(const char*)) {\n       jio_snprintf(buf, size, \"%s\", signames[exception_code]);\n    } else {\n       jio_snprintf(buf, size, \"SIG%d\", exception_code);\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\n// (Static) wrappers for the new libthread API\nint_fnP_thread_t_iP_uP_stack_tP_gregset_t os::Solaris::_thr_getstate;\nint_fnP_thread_t_i_gregset_t os::Solaris::_thr_setstate;\nint_fnP_thread_t_i os::Solaris::_thr_setmutator;\nint_fnP_thread_t os::Solaris::_thr_suspend_mutator;\nint_fnP_thread_t os::Solaris::_thr_continue_mutator;\n\n// (Static) wrapper for getisax(2) call.\nos::Solaris::getisax_func_t os::Solaris::_getisax = 0;\n\n// (Static) wrappers for the liblgrp API\nos::Solaris::lgrp_home_func_t os::Solaris::_lgrp_home;\nos::Solaris::lgrp_init_func_t os::Solaris::_lgrp_init;\nos::Solaris::lgrp_fini_func_t os::Solaris::_lgrp_fini;\nos::Solaris::lgrp_root_func_t os::Solaris::_lgrp_root;\nos::Solaris::lgrp_children_func_t os::Solaris::_lgrp_children;\nos::Solaris::lgrp_resources_func_t os::Solaris::_lgrp_resources;\nos::Solaris::lgrp_nlgrps_func_t os::Solaris::_lgrp_nlgrps;\nos::Solaris::lgrp_cookie_stale_func_t os::Solaris::_lgrp_cookie_stale;\nos::Solaris::lgrp_cookie_t os::Solaris::_lgrp_cookie = 0;\n\n// (Static) wrapper for meminfo() call.\nos::Solaris::meminfo_func_t os::Solaris::_meminfo = 0;\n\nstatic address resolve_symbol_lazy(const char* name) {\n  address addr = (address) dlsym(RTLD_DEFAULT, name);\n  if(addr == NULL) {\n    // RTLD_DEFAULT was not defined on some early versions of 2.5.1\n    addr = (address) dlsym(RTLD_NEXT, name);\n  }\n  return addr;\n}\n\nstatic address resolve_symbol(const char* name) {\n  address addr = resolve_symbol_lazy(name);\n  if(addr == NULL) {\n    fatal(dlerror());\n  }\n  return addr;\n}\n\n\n\n// isT2_libthread()\n//\n// Routine to determine if we are currently using the new T2 libthread.\n//\n// We determine if we are using T2 by reading /proc/self/lstatus and\n// looking for a thread with the ASLWP bit set.  If we find this status\n// bit set, we must assume that we are NOT using T2.  The T2 team\n// has approved this algorithm.\n//\n// We need to determine if we are running with the new T2 libthread\n// since setting native thread priorities is handled differently\n// when using this library.  All threads created using T2 are bound\n// threads. Calling thr_setprio is meaningless in this case.\n//\nbool isT2_libthread() {\n  static prheader_t * lwpArray = NULL;\n  static int lwpSize = 0;\n  static int lwpFile = -1;\n  lwpstatus_t * that;\n  char lwpName [128];\n  bool isT2 = false;\n\n#define ADR(x)  ((uintptr_t)(x))\n#define LWPINDEX(ary,ix)   ((lwpstatus_t *)(((ary)->pr_entsize * (ix)) + (ADR((ary) + 1))))\n\n  lwpFile = ::open(\"/proc/self/lstatus\", O_RDONLY, 0);\n  if (lwpFile < 0) {\n      if (ThreadPriorityVerbose) warning (\"Couldn't open /proc/self/lstatus\\n\");\n      return false;\n  }\n  lwpSize = 16*1024;\n  for (;;) {\n    ::lseek64 (lwpFile, 0, SEEK_SET);\n    lwpArray = (prheader_t *)NEW_C_HEAP_ARRAY(char, lwpSize, mtInternal);\n    if (::read(lwpFile, lwpArray, lwpSize) < 0) {\n      if (ThreadPriorityVerbose) warning(\"Error reading /proc/self/lstatus\\n\");\n      break;\n    }\n    if ((lwpArray->pr_nent * lwpArray->pr_entsize) <= lwpSize) {\n       // We got a good snapshot - now iterate over the list.\n      int aslwpcount = 0;\n      for (int i = 0; i < lwpArray->pr_nent; i++ ) {\n        that = LWPINDEX(lwpArray,i);\n        if (that->pr_flags & PR_ASLWP) {\n          aslwpcount++;\n        }\n      }\n      if (aslwpcount == 0) isT2 = true;\n      break;\n    }\n    lwpSize = lwpArray->pr_nent * lwpArray->pr_entsize;\n    FREE_C_HEAP_ARRAY(char, lwpArray, mtInternal);  // retry.\n  }\n\n  FREE_C_HEAP_ARRAY(char, lwpArray, mtInternal);\n  ::close (lwpFile);\n  if (ThreadPriorityVerbose) {\n    if (isT2) tty->print_cr(\"We are running with a T2 libthread\\n\");\n    else tty->print_cr(\"We are not running with a T2 libthread\\n\");\n  }\n  return isT2;\n}\n\n\nvoid os::Solaris::libthread_init() {\n  address func = (address)dlsym(RTLD_DEFAULT, \"_thr_suspend_allmutators\");\n\n  // Determine if we are running with the new T2 libthread\n  os::Solaris::set_T2_libthread(isT2_libthread());\n\n  lwp_priocntl_init();\n\n  // RTLD_DEFAULT was not defined on some early versions of 5.5.1\n  if(func == NULL) {\n    func = (address) dlsym(RTLD_NEXT, \"_thr_suspend_allmutators\");\n    // Guarantee that this VM is running on an new enough OS (5.6 or\n    // later) that it will have a new enough libthread.so.\n    guarantee(func != NULL, \"libthread.so is too old.\");\n  }\n\n  // Initialize the new libthread getstate API wrappers\n  func = resolve_symbol(\"thr_getstate\");\n  os::Solaris::set_thr_getstate(CAST_TO_FN_PTR(int_fnP_thread_t_iP_uP_stack_tP_gregset_t, func));\n\n  func = resolve_symbol(\"thr_setstate\");\n  os::Solaris::set_thr_setstate(CAST_TO_FN_PTR(int_fnP_thread_t_i_gregset_t, func));\n\n  func = resolve_symbol(\"thr_setmutator\");\n  os::Solaris::set_thr_setmutator(CAST_TO_FN_PTR(int_fnP_thread_t_i, func));\n\n  func = resolve_symbol(\"thr_suspend_mutator\");\n  os::Solaris::set_thr_suspend_mutator(CAST_TO_FN_PTR(int_fnP_thread_t, func));\n\n  func = resolve_symbol(\"thr_continue_mutator\");\n  os::Solaris::set_thr_continue_mutator(CAST_TO_FN_PTR(int_fnP_thread_t, func));\n\n  int size;\n  void (*handler_info_func)(address *, int *);\n  handler_info_func = CAST_TO_FN_PTR(void (*)(address *, int *), resolve_symbol(\"thr_sighndlrinfo\"));\n  handler_info_func(&handler_start, &size);\n  handler_end = handler_start + size;\n}\n\n\nint_fnP_mutex_tP os::Solaris::_mutex_lock;\nint_fnP_mutex_tP os::Solaris::_mutex_trylock;\nint_fnP_mutex_tP os::Solaris::_mutex_unlock;\nint_fnP_mutex_tP_i_vP os::Solaris::_mutex_init;\nint_fnP_mutex_tP os::Solaris::_mutex_destroy;\nint os::Solaris::_mutex_scope = USYNC_THREAD;\n\nint_fnP_cond_tP_mutex_tP_timestruc_tP os::Solaris::_cond_timedwait;\nint_fnP_cond_tP_mutex_tP os::Solaris::_cond_wait;\nint_fnP_cond_tP os::Solaris::_cond_signal;\nint_fnP_cond_tP os::Solaris::_cond_broadcast;\nint_fnP_cond_tP_i_vP os::Solaris::_cond_init;\nint_fnP_cond_tP os::Solaris::_cond_destroy;\nint os::Solaris::_cond_scope = USYNC_THREAD;\n\nvoid os::Solaris::synchronization_init() {\n  if(UseLWPSynchronization) {\n    os::Solaris::set_mutex_lock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"_lwp_mutex_lock\")));\n    os::Solaris::set_mutex_trylock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"_lwp_mutex_trylock\")));\n    os::Solaris::set_mutex_unlock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"_lwp_mutex_unlock\")));\n    os::Solaris::set_mutex_init(lwp_mutex_init);\n    os::Solaris::set_mutex_destroy(lwp_mutex_destroy);\n    os::Solaris::set_mutex_scope(USYNC_THREAD);\n\n    os::Solaris::set_cond_timedwait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP_timestruc_tP, resolve_symbol(\"_lwp_cond_timedwait\")));\n    os::Solaris::set_cond_wait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP, resolve_symbol(\"_lwp_cond_wait\")));\n    os::Solaris::set_cond_signal(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"_lwp_cond_signal\")));\n    os::Solaris::set_cond_broadcast(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"_lwp_cond_broadcast\")));\n    os::Solaris::set_cond_init(lwp_cond_init);\n    os::Solaris::set_cond_destroy(lwp_cond_destroy);\n    os::Solaris::set_cond_scope(USYNC_THREAD);\n  }\n  else {\n    os::Solaris::set_mutex_scope(USYNC_THREAD);\n    os::Solaris::set_cond_scope(USYNC_THREAD);\n\n    if(UsePthreads) {\n      os::Solaris::set_mutex_lock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"pthread_mutex_lock\")));\n      os::Solaris::set_mutex_trylock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"pthread_mutex_trylock\")));\n      os::Solaris::set_mutex_unlock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"pthread_mutex_unlock\")));\n      os::Solaris::set_mutex_init(pthread_mutex_default_init);\n      os::Solaris::set_mutex_destroy(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"pthread_mutex_destroy\")));\n\n      os::Solaris::set_cond_timedwait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP_timestruc_tP, resolve_symbol(\"pthread_cond_timedwait\")));\n      os::Solaris::set_cond_wait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP, resolve_symbol(\"pthread_cond_wait\")));\n      os::Solaris::set_cond_signal(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"pthread_cond_signal\")));\n      os::Solaris::set_cond_broadcast(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"pthread_cond_broadcast\")));\n      os::Solaris::set_cond_init(pthread_cond_default_init);\n      os::Solaris::set_cond_destroy(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"pthread_cond_destroy\")));\n    }\n    else {\n      os::Solaris::set_mutex_lock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"mutex_lock\")));\n      os::Solaris::set_mutex_trylock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"mutex_trylock\")));\n      os::Solaris::set_mutex_unlock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"mutex_unlock\")));\n      os::Solaris::set_mutex_init(::mutex_init);\n      os::Solaris::set_mutex_destroy(::mutex_destroy);\n\n      os::Solaris::set_cond_timedwait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP_timestruc_tP, resolve_symbol(\"cond_timedwait\")));\n      os::Solaris::set_cond_wait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP, resolve_symbol(\"cond_wait\")));\n      os::Solaris::set_cond_signal(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"cond_signal\")));\n      os::Solaris::set_cond_broadcast(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"cond_broadcast\")));\n      os::Solaris::set_cond_init(::cond_init);\n      os::Solaris::set_cond_destroy(::cond_destroy);\n    }\n  }\n}\n\nbool os::Solaris::liblgrp_init() {\n  void *handle = dlopen(\"liblgrp.so.1\", RTLD_LAZY);\n  if (handle != NULL) {\n    os::Solaris::set_lgrp_home(CAST_TO_FN_PTR(lgrp_home_func_t, dlsym(handle, \"lgrp_home\")));\n    os::Solaris::set_lgrp_init(CAST_TO_FN_PTR(lgrp_init_func_t, dlsym(handle, \"lgrp_init\")));\n    os::Solaris::set_lgrp_fini(CAST_TO_FN_PTR(lgrp_fini_func_t, dlsym(handle, \"lgrp_fini\")));\n    os::Solaris::set_lgrp_root(CAST_TO_FN_PTR(lgrp_root_func_t, dlsym(handle, \"lgrp_root\")));\n    os::Solaris::set_lgrp_children(CAST_TO_FN_PTR(lgrp_children_func_t, dlsym(handle, \"lgrp_children\")));\n    os::Solaris::set_lgrp_resources(CAST_TO_FN_PTR(lgrp_resources_func_t, dlsym(handle, \"lgrp_resources\")));\n    os::Solaris::set_lgrp_nlgrps(CAST_TO_FN_PTR(lgrp_nlgrps_func_t, dlsym(handle, \"lgrp_nlgrps\")));\n    os::Solaris::set_lgrp_cookie_stale(CAST_TO_FN_PTR(lgrp_cookie_stale_func_t,\n                                       dlsym(handle, \"lgrp_cookie_stale\")));\n\n    lgrp_cookie_t c = lgrp_init(LGRP_VIEW_CALLER);\n    set_lgrp_cookie(c);\n    return true;\n  }\n  return false;\n}\n\nvoid os::Solaris::misc_sym_init() {\n  address func;\n\n  // getisax\n  func = resolve_symbol_lazy(\"getisax\");\n  if (func != NULL) {\n    os::Solaris::_getisax = CAST_TO_FN_PTR(getisax_func_t, func);\n  }\n\n  // meminfo\n  func = resolve_symbol_lazy(\"meminfo\");\n  if (func != NULL) {\n    os::Solaris::set_meminfo(CAST_TO_FN_PTR(meminfo_func_t, func));\n  }\n}\n\nuint_t os::Solaris::getisax(uint32_t* array, uint_t n) {\n  assert(_getisax != NULL, \"_getisax not set\");\n  return _getisax(array, n);\n}\n\n// int pset_getloadavg(psetid_t pset, double loadavg[], int nelem);\ntypedef long (*pset_getloadavg_type)(psetid_t pset, double loadavg[], int nelem);\nstatic pset_getloadavg_type pset_getloadavg_ptr = NULL;\n\nvoid init_pset_getloadavg_ptr(void) {\n  pset_getloadavg_ptr =\n    (pset_getloadavg_type)dlsym(RTLD_DEFAULT, \"pset_getloadavg\");\n  if (PrintMiscellaneous && Verbose && pset_getloadavg_ptr == NULL) {\n    warning(\"pset_getloadavg function not found\");\n  }\n}\n\nint os::Solaris::_dev_zero_fd = -1;\n\n// this is called _before_ the global arguments have been parsed\nvoid os::init(void) {\n  _initial_pid = getpid();\n\n  max_hrtime = first_hrtime = gethrtime();\n\n  init_random(1234567);\n\n  page_size = sysconf(_SC_PAGESIZE);\n  if (page_size == -1)\n    fatal(err_msg(\"os_solaris.cpp: os::init: sysconf failed (%s)\",\n                  strerror(errno)));\n  init_page_sizes((size_t) page_size);\n\n  Solaris::initialize_system_info();\n\n  // Initialize misc. symbols as soon as possible, so we can use them\n  // if we need them.\n  Solaris::misc_sym_init();\n\n  int fd = ::open(\"/dev/zero\", O_RDWR);\n  if (fd < 0) {\n    fatal(err_msg(\"os::init: cannot open /dev/zero (%s)\", strerror(errno)));\n  } else {\n    Solaris::set_dev_zero_fd(fd);\n\n    // Close on exec, child won't inherit.\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n  }\n\n  clock_tics_per_sec = CLK_TCK;\n\n  // check if dladdr1() exists; dladdr1 can provide more information than\n  // dladdr for os::dll_address_to_function_name. It comes with SunOS 5.9\n  // and is available on linker patches for 5.7 and 5.8.\n  // libdl.so must have been loaded, this call is just an entry lookup\n  void * hdl = dlopen(\"libdl.so\", RTLD_NOW);\n  if (hdl)\n    dladdr1_func = CAST_TO_FN_PTR(dladdr1_func_type, dlsym(hdl, \"dladdr1\"));\n\n  // (Solaris only) this switches to calls that actually do locking.\n  ThreadCritical::initialize();\n\n  main_thread = thr_self();\n\n  // Constant minimum stack size allowed. It must be at least\n  // the minimum of what the OS supports (thr_min_stack()), and\n  // enough to allow the thread to get to user bytecode execution.\n  Solaris::min_stack_allowed = MAX2(thr_min_stack(), Solaris::min_stack_allowed);\n  // If the pagesize of the VM is greater than 8K determine the appropriate\n  // number of initial guard pages.  The user can change this with the\n  // command line arguments, if needed.\n  if (vm_page_size() > 8*K) {\n    StackYellowPages = 1;\n    StackRedPages = 1;\n    StackShadowPages = round_to((StackShadowPages*8*K), vm_page_size()) / vm_page_size();\n  }\n}\n\n// To install functions for atexit system call\nextern \"C\" {\n  static void perfMemory_exit_helper() {\n    perfMemory_exit();\n  }\n}\n\n// this is called _after_ the global arguments have been parsed\njint os::init_2(void) {\n  // try to enable extended file IO ASAP, see 6431278\n  os::Solaris::try_enable_extended_io();\n\n  // Allocate a single page and mark it as readable for safepoint polling.  Also\n  // use this first mmap call to check support for MAP_ALIGN.\n  address polling_page = (address)Solaris::mmap_chunk((char*)page_size,\n                                                      page_size,\n                                                      MAP_PRIVATE | MAP_ALIGN,\n                                                      PROT_READ);\n  if (polling_page == NULL) {\n    has_map_align = false;\n    polling_page = (address)Solaris::mmap_chunk(NULL, page_size, MAP_PRIVATE,\n                                                PROT_READ);\n  }\n\n  os::set_polling_page(polling_page);\n\n#ifndef PRODUCT\n  if( Verbose && PrintMiscellaneous )\n    tty->print(\"[SafePoint Polling address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)polling_page);\n#endif\n\n  if (!UseMembar) {\n    address mem_serialize_page = (address)Solaris::mmap_chunk( NULL, page_size, MAP_PRIVATE, PROT_READ | PROT_WRITE );\n    guarantee( mem_serialize_page != NULL, \"mmap Failed for memory serialize page\");\n    os::set_memory_serialize_page( mem_serialize_page );\n\n#ifndef PRODUCT\n    if(Verbose && PrintMiscellaneous)\n      tty->print(\"[Memory Serialize  Page address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)mem_serialize_page);\n#endif\n  }\n\n  // Check minimum allowable stack size for thread creation and to initialize\n  // the java system classes, including StackOverflowError - depends on page\n  // size.  Add a page for compiler2 recursion in main thread.\n  // Add in 2*BytesPerWord times page size to account for VM stack during\n  // class initialization depending on 32 or 64 bit VM.\n  os::Solaris::min_stack_allowed = MAX2(os::Solaris::min_stack_allowed,\n            (size_t)(StackYellowPages+StackRedPages+StackShadowPages+\n                    2*BytesPerWord COMPILER2_PRESENT(+1)) * page_size);\n\n  size_t threadStackSizeInBytes = ThreadStackSize * K;\n  if (threadStackSizeInBytes != 0 &&\n    threadStackSizeInBytes < os::Solaris::min_stack_allowed) {\n    tty->print_cr(\"\\nThe stack size specified is too small, Specify at least %dk\",\n                  os::Solaris::min_stack_allowed/K);\n    return JNI_ERR;\n  }\n\n  // For 64kbps there will be a 64kb page size, which makes\n  // the usable default stack size quite a bit less.  Increase the\n  // stack for 64kb (or any > than 8kb) pages, this increases\n  // virtual memory fragmentation (since we're not creating the\n  // stack on a power of 2 boundary.  The real fix for this\n  // should be to fix the guard page mechanism.\n\n  if (vm_page_size() > 8*K) {\n      threadStackSizeInBytes = (threadStackSizeInBytes != 0)\n         ? threadStackSizeInBytes +\n           ((StackYellowPages + StackRedPages) * vm_page_size())\n         : 0;\n      ThreadStackSize = threadStackSizeInBytes/K;\n  }\n\n  // Make the stack size a multiple of the page size so that\n  // the yellow/red zones can be guarded.\n  JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,\n        vm_page_size()));\n\n  Solaris::libthread_init();\n\n  if (UseNUMA) {\n    if (!Solaris::liblgrp_init()) {\n      UseNUMA = false;\n    } else {\n      size_t lgrp_limit = os::numa_get_groups_num();\n      int *lgrp_ids = NEW_C_HEAP_ARRAY(int, lgrp_limit, mtInternal);\n      size_t lgrp_num = os::numa_get_leaf_groups(lgrp_ids, lgrp_limit);\n      FREE_C_HEAP_ARRAY(int, lgrp_ids, mtInternal);\n      if (lgrp_num < 2) {\n        // There's only one locality group, disable NUMA.\n        UseNUMA = false;\n      }\n    }\n    if (!UseNUMA && ForceNUMA) {\n      UseNUMA = true;\n    }\n  }\n\n  Solaris::signal_sets_init();\n  Solaris::init_signal_mem();\n  Solaris::install_signal_handlers();\n\n  if (libjsigversion < JSIG_VERSION_1_4_1) {\n    Maxlibjsigsigs = OLDMAXSIGNUM;\n  }\n\n  // initialize synchronization primitives to use either thread or\n  // lwp synchronization (controlled by UseLWPSynchronization)\n  Solaris::synchronization_init();\n\n  if (MaxFDLimit) {\n    // set the number of file descriptors to max. print out error\n    // if getrlimit/setrlimit fails but continue regardless.\n    struct rlimit nbr_files;\n    int status = getrlimit(RLIMIT_NOFILE, &nbr_files);\n    if (status != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode))\n        perror(\"os::init_2 getrlimit failed\");\n    } else {\n      nbr_files.rlim_cur = nbr_files.rlim_max;\n      status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n      if (status != 0) {\n        if (PrintMiscellaneous && (Verbose || WizardMode))\n          perror(\"os::init_2 setrlimit failed\");\n      }\n    }\n  }\n\n  // Calculate theoretical max. size of Threads to guard gainst\n  // artifical out-of-memory situations, where all available address-\n  // space has been reserved by thread stacks. Default stack size is 1Mb.\n  size_t pre_thread_stack_size = (JavaThread::stack_size_at_create()) ?\n    JavaThread::stack_size_at_create() : (1*K*K);\n  assert(pre_thread_stack_size != 0, \"Must have a stack\");\n  // Solaris has a maximum of 4Gb of user programs. Calculate the thread limit when\n  // we should start doing Virtual Memory banging. Currently when the threads will\n  // have used all but 200Mb of space.\n  size_t max_address_space = ((unsigned int)4 * K * K * K) - (200 * K * K);\n  Solaris::_os_thread_limit = max_address_space / pre_thread_stack_size;\n\n  // at-exit methods are called in the reverse order of their registration.\n  // In Solaris 7 and earlier, atexit functions are called on return from\n  // main or as a result of a call to exit(3C). There can be only 32 of\n  // these functions registered and atexit() does not set errno. In Solaris\n  // 8 and later, there is no limit to the number of functions registered\n  // and atexit() sets errno. In addition, in Solaris 8 and later, atexit\n  // functions are called upon dlclose(3DL) in addition to return from main\n  // and exit(3C).\n\n  if (PerfAllowAtExitRegistration) {\n    // only register atexit functions if PerfAllowAtExitRegistration is set.\n    // atexit functions can be delayed until process exit time, which\n    // can be problematic for embedded VM situations. Embedded VMs should\n    // call DestroyJavaVM() to assure that VM resources are released.\n\n    // note: perfMemory_exit_helper atexit function may be removed in\n    // the future if the appropriate cleanup code can be added to the\n    // VM_Exit VMOperation's doit method.\n    if (atexit(perfMemory_exit_helper) != 0) {\n      warning(\"os::init2 atexit(perfMemory_exit_helper) failed\");\n    }\n  }\n\n  // Init pset_loadavg function pointer\n  init_pset_getloadavg_ptr();\n\n  return JNI_OK;\n}\n\n// Mark the polling page as unreadable\nvoid os::make_polling_page_unreadable(void) {\n  if( mprotect((char *)_polling_page, page_size, PROT_NONE) != 0 )\n    fatal(\"Could not disable polling page\");\n};\n\n// Mark the polling page as readable\nvoid os::make_polling_page_readable(void) {\n  if( mprotect((char *)_polling_page, page_size, PROT_READ) != 0 )\n    fatal(\"Could not enable polling page\");\n};\n\n// OS interface.\n\nbool os::check_heap(bool force) { return true; }\n\ntypedef int (*vsnprintf_t)(char* buf, size_t count, const char* fmt, va_list argptr);\nstatic vsnprintf_t sol_vsnprintf = NULL;\n\nint local_vsnprintf(char* buf, size_t count, const char* fmt, va_list argptr) {\n  if (!sol_vsnprintf) {\n    //search  for the named symbol in the objects that were loaded after libjvm\n    void* where = RTLD_NEXT;\n    if ((sol_vsnprintf = CAST_TO_FN_PTR(vsnprintf_t, dlsym(where, \"__vsnprintf\"))) == NULL)\n        sol_vsnprintf = CAST_TO_FN_PTR(vsnprintf_t, dlsym(where, \"vsnprintf\"));\n    if (!sol_vsnprintf){\n      //search  for the named symbol in the objects that were loaded before libjvm\n      where = RTLD_DEFAULT;\n      if ((sol_vsnprintf = CAST_TO_FN_PTR(vsnprintf_t, dlsym(where, \"__vsnprintf\"))) == NULL)\n        sol_vsnprintf = CAST_TO_FN_PTR(vsnprintf_t, dlsym(where, \"vsnprintf\"));\n      assert(sol_vsnprintf != NULL, \"vsnprintf not found\");\n    }\n  }\n  return (*sol_vsnprintf)(buf, count, fmt, argptr);\n}\n\n\n// Is a (classpath) directory empty?\nbool os::dir_is_empty(const char* path) {\n  DIR *dir = NULL;\n  struct dirent *ptr;\n\n  dir = opendir(path);\n  if (dir == NULL) return true;\n\n  /* Scan the directory */\n  bool result = true;\n  char buf[sizeof(struct dirent) + MAX_PATH];\n  struct dirent *dbuf = (struct dirent *) buf;\n  while (result && (ptr = readdir(dir, dbuf)) != NULL) {\n    if (strcmp(ptr->d_name, \".\") != 0 && strcmp(ptr->d_name, \"..\") != 0) {\n      result = false;\n    }\n  }\n  closedir(dir);\n  return result;\n}\n\n// This code originates from JDK's sysOpen and open64_w\n// from src/solaris/hpi/src/system_md.c\n\n#ifndef O_DELETE\n#define O_DELETE 0x10000\n#endif\n\n// Open a file. Unlink the file immediately after open returns\n// if the specified oflag has the O_DELETE flag set.\n// O_DELETE is used only in j2se/src/share/native/java/util/zip/ZipFile.c\n\nint os::open(const char *path, int oflag, int mode) {\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  int fd;\n  int o_delete = (oflag & O_DELETE);\n  oflag = oflag & ~O_DELETE;\n\n  fd = ::open64(path, oflag, mode);\n  if (fd == -1) return -1;\n\n  //If the open succeeded, the file might still be a directory\n  {\n    struct stat64 buf64;\n    int ret = ::fstat64(fd, &buf64);\n    int st_mode = buf64.st_mode;\n\n    if (ret != -1) {\n      if ((st_mode & S_IFMT) == S_IFDIR) {\n        errno = EISDIR;\n        ::close(fd);\n        return -1;\n      }\n    } else {\n      ::close(fd);\n      return -1;\n    }\n  }\n    /*\n     * 32-bit Solaris systems suffer from:\n     *\n     * - an historical default soft limit of 256 per-process file\n     *   descriptors that is too low for many Java programs.\n     *\n     * - a design flaw where file descriptors created using stdio\n     *   fopen must be less than 256, _even_ when the first limit above\n     *   has been raised.  This can cause calls to fopen (but not calls to\n     *   open, for example) to fail mysteriously, perhaps in 3rd party\n     *   native code (although the JDK itself uses fopen).  One can hardly\n     *   criticize them for using this most standard of all functions.\n     *\n     * We attempt to make everything work anyways by:\n     *\n     * - raising the soft limit on per-process file descriptors beyond\n     *   256\n     *\n     * - As of Solaris 10u4, we can request that Solaris raise the 256\n     *   stdio fopen limit by calling function enable_extended_FILE_stdio.\n     *   This is done in init_2 and recorded in enabled_extended_FILE_stdio\n     *\n     * - If we are stuck on an old (pre 10u4) Solaris system, we can\n     *   workaround the bug by remapping non-stdio file descriptors below\n     *   256 to ones beyond 256, which is done below.\n     *\n     * See:\n     * 1085341: 32-bit stdio routines should support file descriptors >255\n     * 6533291: Work around 32-bit Solaris stdio limit of 256 open files\n     * 6431278: Netbeans crash on 32 bit Solaris: need to call\n     *          enable_extended_FILE_stdio() in VM initialisation\n     * Giri Mandalika's blog\n     * http://technopark02.blogspot.com/2005_05_01_archive.html\n     */\n#ifndef  _LP64\n     if ((!enabled_extended_FILE_stdio) && fd < 256) {\n         int newfd = ::fcntl(fd, F_DUPFD, 256);\n         if (newfd != -1) {\n             ::close(fd);\n             fd = newfd;\n         }\n     }\n#endif // 32-bit Solaris\n    /*\n     * All file descriptors that are opened in the JVM and not\n     * specifically destined for a subprocess should have the\n     * close-on-exec flag set.  If we don't set it, then careless 3rd\n     * party native code might fork and exec without closing all\n     * appropriate file descriptors (e.g. as we do in closeDescriptors in\n     * UNIXProcess.c), and this in turn might:\n     *\n     * - cause end-of-file to fail to be detected on some file\n     *   descriptors, resulting in mysterious hangs, or\n     *\n     * - might cause an fopen in the subprocess to fail on a system\n     *   suffering from bug 1085341.\n     *\n     * (Yes, the default setting of the close-on-exec flag is a Unix\n     * design flaw)\n     *\n     * See:\n     * 1085341: 32-bit stdio routines should support file descriptors >255\n     * 4843136: (process) pipe file descriptor from Runtime.exec not being closed\n     * 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9\n     */\n#ifdef FD_CLOEXEC\n    {\n        int flags = ::fcntl(fd, F_GETFD);\n        if (flags != -1)\n            ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n    }\n#endif\n\n  if (o_delete != 0) {\n    ::unlink(path);\n  }\n  return fd;\n}\n\n// create binary file, rewriting existing file if required\nint os::create_binary_file(const char* path, bool rewrite_existing) {\n  int oflags = O_WRONLY | O_CREAT;\n  if (!rewrite_existing) {\n    oflags |= O_EXCL;\n  }\n  return ::open64(path, oflags, S_IREAD | S_IWRITE);\n}\n\n// return current position of file pointer\njlong os::current_file_offset(int fd) {\n  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);\n}\n\n// move file pointer to the specified offset\njlong os::seek_to_file_offset(int fd, jlong offset) {\n  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);\n}\n\njlong os::lseek(int fd, jlong offset, int whence) {\n  return (jlong) ::lseek64(fd, offset, whence);\n}\n\nchar * os::native_path(char *path) {\n  return path;\n}\n\nint os::ftruncate(int fd, jlong length) {\n  return ::ftruncate64(fd, length);\n}\n\nint os::fsync(int fd)  {\n  RESTARTABLE_RETURN_INT(::fsync(fd));\n}\n\nint os::available(int fd, jlong *bytes) {\n  jlong cur, end;\n  int mode;\n  struct stat64 buf64;\n\n  if (::fstat64(fd, &buf64) >= 0) {\n    mode = buf64.st_mode;\n    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n      /*\n      * XXX: is the following call interruptible? If so, this might\n      * need to go through the INTERRUPT_IO() wrapper as for other\n      * blocking, interruptible calls in this file.\n      */\n      int n,ioctl_return;\n\n      INTERRUPTIBLE(::ioctl(fd, FIONREAD, &n),ioctl_return,os::Solaris::clear_interrupted);\n      if (ioctl_return>= 0) {\n          *bytes = n;\n        return 1;\n      }\n    }\n  }\n  if ((cur = ::lseek64(fd, 0L, SEEK_CUR)) == -1) {\n    return 0;\n  } else if ((end = ::lseek64(fd, 0L, SEEK_END)) == -1) {\n    return 0;\n  } else if (::lseek64(fd, cur, SEEK_SET) == -1) {\n    return 0;\n  }\n  *bytes = end - cur;\n  return 1;\n}\n\n// Map a block of memory.\nchar* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,\n                     char *addr, size_t bytes, bool read_only,\n                     bool allow_exec) {\n  int prot;\n  int flags;\n\n  if (read_only) {\n    prot = PROT_READ;\n    flags = MAP_SHARED;\n  } else {\n    prot = PROT_READ | PROT_WRITE;\n    flags = MAP_PRIVATE;\n  }\n\n  if (allow_exec) {\n    prot |= PROT_EXEC;\n  }\n\n  if (addr != NULL) {\n    flags |= MAP_FIXED;\n  }\n\n  char* mapped_address = (char*)mmap(addr, (size_t)bytes, prot, flags,\n                                     fd, file_offset);\n  if (mapped_address == MAP_FAILED) {\n    return NULL;\n  }\n  return mapped_address;\n}\n\n\n// Remap a block of memory.\nchar* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,\n                       char *addr, size_t bytes, bool read_only,\n                       bool allow_exec) {\n  // same as map_memory() on this OS\n  return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,\n                        allow_exec);\n}\n\n\n// Unmap a block of memory.\nbool os::pd_unmap_memory(char* addr, size_t bytes) {\n  return munmap(addr, bytes) == 0;\n}\n\nvoid os::pause() {\n  char filename[MAX_PATH];\n  if (PauseAtStartupFile && PauseAtStartupFile[0]) {\n    jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);\n  } else {\n    jio_snprintf(filename, MAX_PATH, \"./vm.paused.%d\", current_process_id());\n  }\n\n  int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n  if (fd != -1) {\n    struct stat buf;\n    ::close(fd);\n    while (::stat(filename, &buf) == 0) {\n      (void)::poll(NULL, 0, 100);\n    }\n  } else {\n    jio_fprintf(stderr,\n      \"Could not open pause file '%s', continuing immediately.\\n\", filename);\n  }\n}\n\n#ifndef PRODUCT\n#ifdef INTERPOSE_ON_SYSTEM_SYNCH_FUNCTIONS\n// Turn this on if you need to trace synch operations.\n// Set RECORD_SYNCH_LIMIT to a large-enough value,\n// and call record_synch_enable and record_synch_disable\n// around the computation of interest.\n\nvoid record_synch(char* name, bool returning);  // defined below\n\nclass RecordSynch {\n  char* _name;\n public:\n  RecordSynch(char* name) :_name(name)\n                 { record_synch(_name, false); }\n  ~RecordSynch() { record_synch(_name,   true);  }\n};\n\n#define CHECK_SYNCH_OP(ret, name, params, args, inner)          \\\nextern \"C\" ret name params {                                    \\\n  typedef ret name##_t params;                                  \\\n  static name##_t* implem = NULL;                               \\\n  static int callcount = 0;                                     \\\n  if (implem == NULL) {                                         \\\n    implem = (name##_t*) dlsym(RTLD_NEXT, #name);               \\\n    if (implem == NULL)  fatal(dlerror());                      \\\n  }                                                             \\\n  ++callcount;                                                  \\\n  RecordSynch _rs(#name);                                       \\\n  inner;                                                        \\\n  return implem args;                                           \\\n}\n// in dbx, examine callcounts this way:\n// for n in $(eval whereis callcount | awk '{print $2}'); do print $n; done\n\n#define CHECK_POINTER_OK(p) \\\n  (!Universe::is_fully_initialized() || !Universe::is_reserved_heap((oop)(p)))\n#define CHECK_MU \\\n  if (!CHECK_POINTER_OK(mu)) fatal(\"Mutex must be in C heap only.\");\n#define CHECK_CV \\\n  if (!CHECK_POINTER_OK(cv)) fatal(\"Condvar must be in C heap only.\");\n#define CHECK_P(p) \\\n  if (!CHECK_POINTER_OK(p))  fatal(false,  \"Pointer must be in C heap only.\");\n\n#define CHECK_MUTEX(mutex_op) \\\nCHECK_SYNCH_OP(int, mutex_op, (mutex_t *mu), (mu), CHECK_MU);\n\nCHECK_MUTEX(   mutex_lock)\nCHECK_MUTEX(  _mutex_lock)\nCHECK_MUTEX( mutex_unlock)\nCHECK_MUTEX(_mutex_unlock)\nCHECK_MUTEX( mutex_trylock)\nCHECK_MUTEX(_mutex_trylock)\n\n#define CHECK_COND(cond_op) \\\nCHECK_SYNCH_OP(int, cond_op, (cond_t *cv, mutex_t *mu), (cv, mu), CHECK_MU;CHECK_CV);\n\nCHECK_COND( cond_wait);\nCHECK_COND(_cond_wait);\nCHECK_COND(_cond_wait_cancel);\n\n#define CHECK_COND2(cond_op) \\\nCHECK_SYNCH_OP(int, cond_op, (cond_t *cv, mutex_t *mu, timestruc_t* ts), (cv, mu, ts), CHECK_MU;CHECK_CV);\n\nCHECK_COND2( cond_timedwait);\nCHECK_COND2(_cond_timedwait);\nCHECK_COND2(_cond_timedwait_cancel);\n\n// do the _lwp_* versions too\n#define mutex_t lwp_mutex_t\n#define cond_t  lwp_cond_t\nCHECK_MUTEX(  _lwp_mutex_lock)\nCHECK_MUTEX(  _lwp_mutex_unlock)\nCHECK_MUTEX(  _lwp_mutex_trylock)\nCHECK_MUTEX( __lwp_mutex_lock)\nCHECK_MUTEX( __lwp_mutex_unlock)\nCHECK_MUTEX( __lwp_mutex_trylock)\nCHECK_MUTEX(___lwp_mutex_lock)\nCHECK_MUTEX(___lwp_mutex_unlock)\n\nCHECK_COND(  _lwp_cond_wait);\nCHECK_COND( __lwp_cond_wait);\nCHECK_COND(___lwp_cond_wait);\n\nCHECK_COND2(  _lwp_cond_timedwait);\nCHECK_COND2( __lwp_cond_timedwait);\n#undef mutex_t\n#undef cond_t\n\nCHECK_SYNCH_OP(int, _lwp_suspend2,       (int lwp, int *n), (lwp, n), 0);\nCHECK_SYNCH_OP(int,__lwp_suspend2,       (int lwp, int *n), (lwp, n), 0);\nCHECK_SYNCH_OP(int, _lwp_kill,           (int lwp, int n),  (lwp, n), 0);\nCHECK_SYNCH_OP(int,__lwp_kill,           (int lwp, int n),  (lwp, n), 0);\nCHECK_SYNCH_OP(int, _lwp_sema_wait,      (lwp_sema_t* p),   (p),  CHECK_P(p));\nCHECK_SYNCH_OP(int,__lwp_sema_wait,      (lwp_sema_t* p),   (p),  CHECK_P(p));\nCHECK_SYNCH_OP(int, _lwp_cond_broadcast, (lwp_cond_t* cv),  (cv), CHECK_CV);\nCHECK_SYNCH_OP(int,__lwp_cond_broadcast, (lwp_cond_t* cv),  (cv), CHECK_CV);\n\n\n// recording machinery:\n\nenum { RECORD_SYNCH_LIMIT = 200 };\nchar* record_synch_name[RECORD_SYNCH_LIMIT];\nvoid* record_synch_arg0ptr[RECORD_SYNCH_LIMIT];\nbool record_synch_returning[RECORD_SYNCH_LIMIT];\nthread_t record_synch_thread[RECORD_SYNCH_LIMIT];\nint record_synch_count = 0;\nbool record_synch_enabled = false;\n\n// in dbx, examine recorded data this way:\n// for n in name arg0ptr returning thread; do print record_synch_$n[0..record_synch_count-1]; done\n\nvoid record_synch(char* name, bool returning) {\n  if (record_synch_enabled) {\n    if (record_synch_count < RECORD_SYNCH_LIMIT) {\n      record_synch_name[record_synch_count] = name;\n      record_synch_returning[record_synch_count] = returning;\n      record_synch_thread[record_synch_count] = thr_self();\n      record_synch_arg0ptr[record_synch_count] = &name;\n      record_synch_count++;\n    }\n    // put more checking code here:\n    // ...\n  }\n}\n\nvoid record_synch_enable() {\n  // start collecting trace data, if not already doing so\n  if (!record_synch_enabled)  record_synch_count = 0;\n  record_synch_enabled = true;\n}\n\nvoid record_synch_disable() {\n  // stop collecting trace data\n  record_synch_enabled = false;\n}\n\n#endif // INTERPOSE_ON_SYSTEM_SYNCH_FUNCTIONS\n#endif // PRODUCT\n\nconst intptr_t thr_time_off  = (intptr_t)(&((prusage_t *)(NULL))->pr_utime);\nconst intptr_t thr_time_size = (intptr_t)(&((prusage_t *)(NULL))->pr_ttime) -\n                               (intptr_t)(&((prusage_t *)(NULL))->pr_utime);\n\n\n// JVMTI & JVM monitoring and management support\n// The thread_cpu_time() and current_thread_cpu_time() are only\n// supported if is_thread_cpu_time_supported() returns true.\n// They are not supported on Solaris T1.\n\n// current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)\n// are used by JVM M&M and JVMTI to get user+sys or user CPU time\n// of a thread.\n//\n// current_thread_cpu_time() and thread_cpu_time(Thread *)\n// returns the fast estimate available on the platform.\n\n// hrtime_t gethrvtime() return value includes\n// user time but does not include system time\njlong os::current_thread_cpu_time() {\n  return (jlong) gethrvtime();\n}\n\njlong os::thread_cpu_time(Thread *thread) {\n  // return user level CPU time only to be consistent with\n  // what current_thread_cpu_time returns.\n  // thread_cpu_time_info() must be changed if this changes\n  return os::thread_cpu_time(thread, false /* user time only */);\n}\n\njlong os::current_thread_cpu_time(bool user_sys_cpu_time) {\n  if (user_sys_cpu_time) {\n    return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);\n  } else {\n    return os::current_thread_cpu_time();\n  }\n}\n\njlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {\n  char proc_name[64];\n  int count;\n  prusage_t prusage;\n  jlong lwp_time;\n  int fd;\n\n  sprintf(proc_name, \"/proc/%d/lwp/%d/lwpusage\",\n                     getpid(),\n                     thread->osthread()->lwp_id());\n  fd = ::open(proc_name, O_RDONLY);\n  if ( fd == -1 ) return -1;\n\n  do {\n    count = ::pread(fd,\n                  (void *)&prusage.pr_utime,\n                  thr_time_size,\n                  thr_time_off);\n  } while (count < 0 && errno == EINTR);\n  ::close(fd);\n  if ( count < 0 ) return -1;\n\n  if (user_sys_cpu_time) {\n    // user + system CPU time\n    lwp_time = (((jlong)prusage.pr_stime.tv_sec +\n                 (jlong)prusage.pr_utime.tv_sec) * (jlong)1000000000) +\n                 (jlong)prusage.pr_stime.tv_nsec +\n                 (jlong)prusage.pr_utime.tv_nsec;\n  } else {\n    // user level CPU time only\n    lwp_time = ((jlong)prusage.pr_utime.tv_sec * (jlong)1000000000) +\n                (jlong)prusage.pr_utime.tv_nsec;\n  }\n\n  return(lwp_time);\n}\n\nvoid os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;      // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;    // elapsed time not wall time\n  info_ptr->may_skip_forward = false;     // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_USER_CPU;  // only user time is returned\n}\n\nvoid os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;      // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;    // elapsed time not wall time\n  info_ptr->may_skip_forward = false;     // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_USER_CPU;  // only user time is returned\n}\n\nbool os::is_thread_cpu_time_supported() {\n  if ( os::Solaris::T2_libthread() || UseBoundThreads ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// System loadavg support.  Returns -1 if load average cannot be obtained.\n// Return the load average for our processor set if the primitive exists\n// (Solaris 9 and later).  Otherwise just return system wide loadavg.\nint os::loadavg(double loadavg[], int nelem) {\n  if (pset_getloadavg_ptr != NULL) {\n    return (*pset_getloadavg_ptr)(PS_MYID, loadavg, nelem);\n  } else {\n    return ::getloadavg(loadavg, nelem);\n  }\n}\n\n//---------------------------------------------------------------------------------\n\nbool os::find(address addr, outputStream* st) {\n  Dl_info dlinfo;\n  memset(&dlinfo, 0, sizeof(dlinfo));\n  if (dladdr(addr, &dlinfo) != 0) {\n    st->print(PTR_FORMAT \": \", addr);\n    if (dlinfo.dli_sname != NULL && dlinfo.dli_saddr != NULL) {\n      st->print(\"%s+%#lx\", dlinfo.dli_sname, addr-(intptr_t)dlinfo.dli_saddr);\n    } else if (dlinfo.dli_fbase != NULL)\n      st->print(\"<offset %#lx>\", addr-(intptr_t)dlinfo.dli_fbase);\n    else\n      st->print(\"<absolute address>\");\n    if (dlinfo.dli_fname != NULL) {\n      st->print(\" in %s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL) {\n      st->print(\" at \" PTR_FORMAT, dlinfo.dli_fbase);\n    }\n    st->cr();\n\n    if (Verbose) {\n      // decode some bytes around the PC\n      address begin = clamp_address_in_page(addr-40, addr, os::vm_page_size());\n      address end   = clamp_address_in_page(addr+40, addr, os::vm_page_size());\n      address       lowest = (address) dlinfo.dli_sname;\n      if (!lowest)  lowest = (address) dlinfo.dli_fbase;\n      if (begin < lowest)  begin = lowest;\n      Dl_info dlinfo2;\n      if (dladdr(end, &dlinfo2) != 0 && dlinfo2.dli_saddr != dlinfo.dli_saddr\n          && end > dlinfo2.dli_saddr && dlinfo2.dli_saddr > begin)\n        end = (address) dlinfo2.dli_saddr;\n      Disassembler::decode(begin, end, st);\n    }\n    return true;\n  }\n  return false;\n}\n\n// Following function has been added to support HotSparc's libjvm.so running\n// under Solaris production JDK 1.2.2 / 1.3.0.  These came from\n// src/solaris/hpi/native_threads in the EVM codebase.\n//\n// NOTE: This is no longer needed in the 1.3.1 and 1.4 production release\n// libraries and should thus be removed. We will leave it behind for a while\n// until we no longer want to able to run on top of 1.3.0 Solaris production\n// JDK. See 4341971.\n\n#define STACK_SLACK 0x800\n\nextern \"C\" {\n  intptr_t sysThreadAvailableStackWithSlack() {\n    stack_t st;\n    intptr_t retval, stack_top;\n    retval = thr_stksegment(&st);\n    assert(retval == 0, \"incorrect return value from thr_stksegment\");\n    assert((address)&st < (address)st.ss_sp, \"Invalid stack base returned\");\n    assert((address)&st > (address)st.ss_sp-st.ss_size, \"Invalid stack size returned\");\n    stack_top=(intptr_t)st.ss_sp-st.ss_size;\n    return ((intptr_t)&stack_top - stack_top - STACK_SLACK);\n  }\n}\n\n// ObjectMonitor park-unpark infrastructure ...\n//\n// We implement Solaris and Linux PlatformEvents with the\n// obvious condvar-mutex-flag triple.\n// Another alternative that works quite well is pipes:\n// Each PlatformEvent consists of a pipe-pair.\n// The thread associated with the PlatformEvent\n// calls park(), which reads from the input end of the pipe.\n// Unpark() writes into the other end of the pipe.\n// The write-side of the pipe must be set NDELAY.\n// Unfortunately pipes consume a large # of handles.\n// Native solaris lwp_park() and lwp_unpark() work nicely, too.\n// Using pipes for the 1st few threads might be workable, however.\n//\n// park() is permitted to return spuriously.\n// Callers of park() should wrap the call to park() in\n// an appropriate loop.  A litmus test for the correct\n// usage of park is the following: if park() were modified\n// to immediately return 0 your code should still work,\n// albeit degenerating to a spin loop.\n//\n// An interesting optimization for park() is to use a trylock()\n// to attempt to acquire the mutex.  If the trylock() fails\n// then we know that a concurrent unpark() operation is in-progress.\n// in that case the park() code could simply set _count to 0\n// and return immediately.  The subsequent park() operation *might*\n// return immediately.  That's harmless as the caller of park() is\n// expected to loop.  By using trylock() we will have avoided a\n// avoided a context switch caused by contention on the per-thread mutex.\n//\n// TODO-FIXME:\n// 1.  Reconcile Doug's JSR166 j.u.c park-unpark with the\n//     objectmonitor implementation.\n// 2.  Collapse the JSR166 parker event, and the\n//     objectmonitor ParkEvent into a single \"Event\" construct.\n// 3.  In park() and unpark() add:\n//     assert (Thread::current() == AssociatedWith).\n// 4.  add spurious wakeup injection on a -XX:EarlyParkReturn=N switch.\n//     1-out-of-N park() operations will return immediately.\n//\n// _Event transitions in park()\n//   -1 => -1 : illegal\n//    1 =>  0 : pass - return immediately\n//    0 => -1 : block\n//\n// _Event serves as a restricted-range semaphore.\n//\n// Another possible encoding of _Event would be with\n// explicit \"PARKED\" == 01b and \"SIGNALED\" == 10b bits.\n//\n// TODO-FIXME: add DTRACE probes for:\n// 1.   Tx parks\n// 2.   Ty unparks Tx\n// 3.   Tx resumes from park\n\n\n// value determined through experimentation\n#define ROUNDINGFIX 11\n\n// utility to compute the abstime argument to timedwait.\n// TODO-FIXME: switch from compute_abstime() to unpackTime().\n\nstatic timestruc_t* compute_abstime(timestruc_t* abstime, jlong millis) {\n  // millis is the relative timeout time\n  // abstime will be the absolute timeout time\n  if (millis < 0)  millis = 0;\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n  jlong seconds = millis / 1000;\n  jlong max_wait_period;\n\n  if (UseLWPSynchronization) {\n    // forward port of fix for 4275818 (not sleeping long enough)\n    // There was a bug in Solaris 6, 7 and pre-patch 5 of 8 where\n    // _lwp_cond_timedwait() used a round_down algorithm rather\n    // than a round_up. For millis less than our roundfactor\n    // it rounded down to 0 which doesn't meet the spec.\n    // For millis > roundfactor we may return a bit sooner, but\n    // since we can not accurately identify the patch level and\n    // this has already been fixed in Solaris 9 and 8 we will\n    // leave it alone rather than always rounding down.\n\n    if (millis > 0 && millis < ROUNDINGFIX) millis = ROUNDINGFIX;\n       // It appears that when we go directly through Solaris _lwp_cond_timedwait()\n           // the acceptable max time threshold is smaller than for libthread on 2.5.1 and 2.6\n           max_wait_period = 21000000;\n  } else {\n    max_wait_period = 50000000;\n  }\n  millis %= 1000;\n  if (seconds > max_wait_period) {      // see man cond_timedwait(3T)\n     seconds = max_wait_period;\n  }\n  abstime->tv_sec = now.tv_sec  + seconds;\n  long       usec = now.tv_usec + millis * 1000;\n  if (usec >= 1000000) {\n    abstime->tv_sec += 1;\n    usec -= 1000000;\n  }\n  abstime->tv_nsec = usec * 1000;\n  return abstime;\n}\n\n// Test-and-clear _Event, always leaves _Event set to 0, returns immediately.\n// Conceptually TryPark() should be equivalent to park(0).\n\nint os::PlatformEvent::TryPark() {\n  for (;;) {\n    const int v = _Event ;\n    guarantee ((v == 0) || (v == 1), \"invariant\") ;\n    if (Atomic::cmpxchg (0, &_Event, v) == v) return v  ;\n  }\n}\n\nvoid os::PlatformEvent::park() {           // AKA: down()\n  // Invariant: Only the thread associated with the Event/PlatformEvent\n  // may call park().\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v == 0) {\n     // Do this the hard way by blocking ...\n     // See http://monaco.sfbay/detail.jsf?cr=5094058.\n     // TODO-FIXME: for Solaris SPARC set fprs.FEF=0 prior to parking.\n     // Only for SPARC >= V8PlusA\n#if defined(__sparc) && defined(COMPILER2)\n     if (ClearFPUAtPark) { _mark_fpu_nosave() ; }\n#endif\n     int status = os::Solaris::mutex_lock(_mutex);\n     assert_status(status == 0, status,  \"mutex_lock\");\n     guarantee (_nParked == 0, \"invariant\") ;\n     ++ _nParked ;\n     while (_Event < 0) {\n        // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...\n        // Treat this the same as if the wait was interrupted\n        // With usr/lib/lwp going to kernel, always handle ETIME\n        status = os::Solaris::cond_wait(_cond, _mutex);\n        if (status == ETIME) status = EINTR ;\n        assert_status(status == 0 || status == EINTR, status, \"cond_wait\");\n     }\n     -- _nParked ;\n     _Event = 0 ;\n     status = os::Solaris::mutex_unlock(_mutex);\n     assert_status(status == 0, status, \"mutex_unlock\");\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other.\n    OrderAccess::fence();\n  }\n}\n\nint os::PlatformEvent::park(jlong millis) {\n  guarantee (_nParked == 0, \"invariant\") ;\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v != 0) return OS_OK ;\n\n  int ret = OS_TIMEOUT;\n  timestruc_t abst;\n  compute_abstime (&abst, millis);\n\n  // See http://monaco.sfbay/detail.jsf?cr=5094058.\n  // For Solaris SPARC set fprs.FEF=0 prior to parking.\n  // Only for SPARC >= V8PlusA\n#if defined(__sparc) && defined(COMPILER2)\n if (ClearFPUAtPark) { _mark_fpu_nosave() ; }\n#endif\n  int status = os::Solaris::mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  guarantee (_nParked == 0, \"invariant\") ;\n  ++ _nParked ;\n  while (_Event < 0) {\n     int status = os::Solaris::cond_timedwait(_cond, _mutex, &abst);\n     assert_status(status == 0 || status == EINTR ||\n                   status == ETIME || status == ETIMEDOUT,\n                   status, \"cond_timedwait\");\n     if (!FilterSpuriousWakeups) break ;                // previous semantics\n     if (status == ETIME || status == ETIMEDOUT) break ;\n     // We consume and ignore EINTR and spurious wakeups.\n  }\n  -- _nParked ;\n  if (_Event >= 0) ret = OS_OK ;\n  _Event = 0 ;\n  status = os::Solaris::mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other.\n  OrderAccess::fence();\n  return ret;\n}\n\nvoid os::PlatformEvent::unpark() {\n  // Transitions for _Event:\n  //    0 :=> 1\n  //    1 :=> 1\n  //   -1 :=> either 0 or 1; must signal target thread\n  //          That is, we can safely transition _Event from -1 to either\n  //          0 or 1. Forcing 1 is slightly more efficient for back-to-back\n  //          unpark() calls.\n  // See also: \"Semaphores in Plan 9\" by Mullender & Cox\n  //\n  // Note: Forcing a transition from \"-1\" to \"1\" on an unpark() means\n  // that it will take two back-to-back park() calls for the owning\n  // thread to block. This has the benefit of forcing a spurious return\n  // from the first park() call after an unpark() call which will help\n  // shake out uses of park() and unpark() without condition variables.\n\n  if (Atomic::xchg(1, &_Event) >= 0) return;\n\n  // If the thread associated with the event was parked, wake it.\n  // Wait for the thread assoc with the PlatformEvent to vacate.\n  int status = os::Solaris::mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  int AnyWaiters = _nParked;\n  status = os::Solaris::mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  guarantee(AnyWaiters == 0 || AnyWaiters == 1, \"invariant\");\n  if (AnyWaiters != 0) {\n    // We intentional signal *after* dropping the lock\n    // to avoid a common class of futile wakeups.\n    status = os::Solaris::cond_signal(_cond);\n    assert_status(status == 0, status, \"cond_signal\");\n  }\n}\n\n// JSR166\n// -------------------------------------------------------\n\n/*\n * The solaris and linux implementations of park/unpark are fairly\n * conservative for now, but can be improved. They currently use a\n * mutex/condvar pair, plus _counter.\n * Park decrements _counter if > 0, else does a condvar wait.  Unpark\n * sets count to 1 and signals condvar.  Only one thread ever waits\n * on the condvar. Contention seen when trying to park implies that someone\n * is unparking you, so don't wait. And spurious returns are fine, so there\n * is no need to track notifications.\n */\n\n#define MAX_SECS 100000000\n/*\n * This code is common to linux and solaris and will be moved to a\n * common place in dolphin.\n *\n * The passed in time value is either a relative time in nanoseconds\n * or an absolute time in milliseconds. Either way it has to be unpacked\n * into suitable seconds and nanoseconds components and stored in the\n * given timespec structure.\n * Given time is a 64-bit value and the time_t used in the timespec is only\n * a signed-32-bit value (except on 64-bit Linux) we have to watch for\n * overflow if times way in the future are given. Further on Solaris versions\n * prior to 10 there is a restriction (see cond_timedwait) that the specified\n * number of seconds, in abstime, is less than current_time  + 100,000,000.\n * As it will be 28 years before \"now + 100000000\" will overflow we can\n * ignore overflow and just impose a hard-limit on seconds using the value\n * of \"now + 100,000,000\". This places a limit on the timeout of about 3.17\n * years from \"now\".\n */\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {\n  assert (time > 0, \"convertTime\");\n\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n\n  time_t max_secs = now.tv_sec + MAX_SECS;\n\n  if (isAbsolute) {\n    jlong secs = time / 1000;\n    if (secs > max_secs) {\n      absTime->tv_sec = max_secs;\n    }\n    else {\n      absTime->tv_sec = secs;\n    }\n    absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;\n  }\n  else {\n    jlong secs = time / NANOSECS_PER_SEC;\n    if (secs >= MAX_SECS) {\n      absTime->tv_sec = max_secs;\n      absTime->tv_nsec = 0;\n    }\n    else {\n      absTime->tv_sec = now.tv_sec + secs;\n      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;\n      if (absTime->tv_nsec >= NANOSECS_PER_SEC) {\n        absTime->tv_nsec -= NANOSECS_PER_SEC;\n        ++absTime->tv_sec; // note: this must be <= max_secs\n      }\n    }\n  }\n  assert(absTime->tv_sec >= 0, \"tv_sec < 0\");\n  assert(absTime->tv_sec <= max_secs, \"tv_sec > max_secs\");\n  assert(absTime->tv_nsec >= 0, \"tv_nsec < 0\");\n  assert(absTime->tv_nsec < NANOSECS_PER_SEC, \"tv_nsec >= nanos_per_sec\");\n}\n\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n\n  // Optional fast-exit: Check interrupt before trying to wait\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n  JavaThread *jt = (JavaThread *)thread;\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n\n  // First, demultiplex/decode time arguments\n  timespec absTime;\n  if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all\n    return;\n  }\n  if (time > 0) {\n    // Warning: this code might be exposed to the old Solaris time\n    // round-down bugs.  Grep \"roundingFix\" for details.\n    unpackTime(&absTime, isAbsolute, time);\n  }\n\n  // Enter safepoint region\n  // Beware of deadlocks such as 6317397.\n  // The per-thread Parker:: _mutex is a classic leaf-lock.\n  // In particular a thread must never block on the Threads_lock while\n  // holding the Parker:: mutex.  If safepoints are pending both the\n  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.\n  ThreadBlockInVM tbivm(jt);\n\n  // Don't wait if cannot get lock since interference arises from\n  // unblocking.  Also. check interrupt before trying wait\n  if (Thread::is_interrupted(thread, false) ||\n      os::Solaris::mutex_trylock(_mutex) != 0) {\n    return;\n  }\n\n  int status ;\n\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = os::Solaris::mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other and Java-level accesses.\n    OrderAccess::fence();\n    return;\n  }\n\n#ifdef ASSERT\n  // Don't catch signals while blocked; let the running threads have the signals.\n  // (This allows a debugger to break into the running thread.)\n  sigset_t oldsigs;\n  sigset_t* allowdebug_blocked = os::Solaris::allowdebug_blocked_signals();\n  thr_sigsetmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);\n#endif\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n  // Do this the hard way by blocking ...\n  // See http://monaco.sfbay/detail.jsf?cr=5094058.\n  // TODO-FIXME: for Solaris SPARC set fprs.FEF=0 prior to parking.\n  // Only for SPARC >= V8PlusA\n#if defined(__sparc) && defined(COMPILER2)\n  if (ClearFPUAtPark) { _mark_fpu_nosave() ; }\n#endif\n\n  if (time == 0) {\n    status = os::Solaris::cond_wait (_cond, _mutex) ;\n  } else {\n    status = os::Solaris::cond_timedwait (_cond, _mutex, &absTime);\n  }\n  // Note that an untimed cond_wait() can sometimes return ETIME on older\n  // versions of the Solaris.\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIME || status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  thr_sigsetmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n  _counter = 0 ;\n  status = os::Solaris::mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other and Java-level accesses.\n  OrderAccess::fence();\n\n  // If externally suspended while waiting, re-suspend\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n}\n\nvoid Parker::unpark() {\n  int s, status ;\n  status = os::Solaris::mutex_lock (_mutex) ;\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  status = os::Solaris::mutex_unlock (_mutex) ;\n  assert (status == 0, \"invariant\") ;\n\n  if (s < 1) {\n    status = os::Solaris::cond_signal (_cond) ;\n    assert (status == 0, \"invariant\") ;\n  }\n}\n\nextern char** environ;\n\n// Run the specified command in a separate process. Return its exit value,\n// or -1 on failure (e.g. can't fork a new process).\n// Unlike system(), this function can be called from signal handler. It\n// doesn't block SIGINT et al.\nint os::fork_and_exec(char* cmd) {\n  char * argv[4];\n  argv[0] = (char *)\"sh\";\n  argv[1] = (char *)\"-c\";\n  argv[2] = cmd;\n  argv[3] = NULL;\n\n  // fork is async-safe, fork1 is not so can't use in signal handler\n  pid_t pid;\n  Thread* t = ThreadLocalStorage::get_thread_slow();\n  if (t != NULL && t->is_inside_signal_handler()) {\n    pid = fork();\n  } else {\n    pid = fork1();\n  }\n\n  if (pid < 0) {\n    // fork failed\n    warning(\"fork failed: %s\", strerror(errno));\n    return -1;\n\n  } else if (pid == 0) {\n    // child process\n\n    // try to be consistent with system(), which uses \"/usr/bin/sh\" on Solaris\n    execve(\"/usr/bin/sh\", argv, environ);\n\n    // execve failed\n    _exit(-1);\n\n  } else  {\n    // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n    // care about the actual exit code, for now.\n\n    int status;\n\n    // Wait for the child process to exit.  This returns immediately if\n    // the child has already exited. */\n    while (waitpid(pid, &status, 0) < 0) {\n        switch (errno) {\n        case ECHILD: return 0;\n        case EINTR: break;\n        default: return -1;\n        }\n    }\n\n    if (WIFEXITED(status)) {\n       // The child exited normally; get its exit code.\n       return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n       // The child exited because of a signal\n       // The best value to return is 0x80 + signal number,\n       // because that is what all Unix shells do, and because\n       // it allows callers to distinguish between process exit and\n       // process death by signal.\n       return 0x80 + WTERMSIG(status);\n    } else {\n       // Unknown exit code; pass it through\n       return status;\n    }\n  }\n}\n\n// is_headless_jre()\n//\n// Test for the existence of xawt/libmawt.so or libawt_xawt.so\n// in order to report if we are running in a headless jre\n//\n// Since JDK8 xawt/libmawt.so was moved into the same directory\n// as libawt.so, and renamed libawt_xawt.so\n//\nbool os::is_headless_jre() {\n    struct stat statbuf;\n    char buf[MAXPATHLEN];\n    char libmawtpath[MAXPATHLEN];\n    const char *xawtstr  = \"/xawt/libmawt.so\";\n    const char *new_xawtstr = \"/libawt_xawt.so\";\n    char *p;\n\n    // Get path to libjvm.so\n    os::jvm_path(buf, sizeof(buf));\n\n    // Get rid of libjvm.so\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // Get rid of client or server\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // check xawt/libmawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    // check libawt_xawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, new_xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    return true;\n}\n\nsize_t os::write(int fd, const void *buf, unsigned int nBytes) {\n  INTERRUPTIBLE_RETURN_INT(::write(fd, buf, nBytes), os::Solaris::clear_interrupted);\n}\n\nint os::close(int fd) {\n  return ::close(fd);\n}\n\nint os::socket_close(int fd) {\n  return ::close(fd);\n}\n\nint os::recv(int fd, char* buf, size_t nBytes, uint flags) {\n  INTERRUPTIBLE_RETURN_INT((int)::recv(fd, buf, nBytes, flags), os::Solaris::clear_interrupted);\n}\n\nint os::send(int fd, char* buf, size_t nBytes, uint flags) {\n  INTERRUPTIBLE_RETURN_INT((int)::send(fd, buf, nBytes, flags), os::Solaris::clear_interrupted);\n}\n\nint os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {\n  RESTARTABLE_RETURN_INT((int)::send(fd, buf, nBytes, flags));\n}\n\n// As both poll and select can be interrupted by signals, we have to be\n// prepared to restart the system call after updating the timeout, unless\n// a poll() is done with timeout == -1, in which case we repeat with this\n// \"wait forever\" value.\n\nint os::timeout(int fd, long timeout) {\n  int res;\n  struct timeval t;\n  julong prevtime, newtime;\n  static const char* aNull = 0;\n  struct pollfd pfd;\n  pfd.fd = fd;\n  pfd.events = POLLIN;\n\n  gettimeofday(&t, &aNull);\n  prevtime = ((julong)t.tv_sec * 1000)  +  t.tv_usec / 1000;\n\n  for(;;) {\n    INTERRUPTIBLE_NORESTART(::poll(&pfd, 1, timeout), res, os::Solaris::clear_interrupted);\n    if(res == OS_ERR && errno == EINTR) {\n        if(timeout != -1) {\n          gettimeofday(&t, &aNull);\n          newtime = ((julong)t.tv_sec * 1000)  +  t.tv_usec /1000;\n          timeout -= newtime - prevtime;\n          if(timeout <= 0)\n            return OS_OK;\n          prevtime = newtime;\n        }\n    } else return res;\n  }\n}\n\nint os::connect(int fd, struct sockaddr *him, socklen_t len) {\n  int _result;\n  INTERRUPTIBLE_NORESTART(::connect(fd, him, len), _result,\\\n                          os::Solaris::clear_interrupted);\n\n  // Depending on when thread interruption is reset, _result could be\n  // one of two values when errno == EINTR\n\n  if (((_result == OS_INTRPT) || (_result == OS_ERR))\n      && (errno == EINTR)) {\n     /* restarting a connect() changes its errno semantics */\n     INTERRUPTIBLE(::connect(fd, him, len), _result,\\\n                   os::Solaris::clear_interrupted);\n     /* undo these changes */\n     if (_result == OS_ERR) {\n       if (errno == EALREADY) {\n         errno = EINPROGRESS; /* fall through */\n       } else if (errno == EISCONN) {\n         errno = 0;\n         return OS_OK;\n       }\n     }\n   }\n   return _result;\n }\n\nint os::accept(int fd, struct sockaddr* him, socklen_t* len) {\n  if (fd < 0) {\n    return OS_ERR;\n  }\n  INTERRUPTIBLE_RETURN_INT((int)::accept(fd, him, len),\\\n                           os::Solaris::clear_interrupted);\n}\n\nint os::recvfrom(int fd, char* buf, size_t nBytes, uint flags,\n                 sockaddr* from, socklen_t* fromlen) {\n  INTERRUPTIBLE_RETURN_INT((int)::recvfrom(fd, buf, nBytes, flags, from, fromlen),\\\n                           os::Solaris::clear_interrupted);\n}\n\nint os::sendto(int fd, char* buf, size_t len, uint flags,\n               struct sockaddr* to, socklen_t tolen) {\n  INTERRUPTIBLE_RETURN_INT((int)::sendto(fd, buf, len, flags, to, tolen),\\\n                           os::Solaris::clear_interrupted);\n}\n\nint os::socket_available(int fd, jint *pbytes) {\n  if (fd < 0) {\n    return OS_OK;\n  }\n  int ret;\n  RESTARTABLE(::ioctl(fd, FIONREAD, pbytes), ret);\n  // note: ioctl can return 0 when successful, JVM_SocketAvailable\n  // is expected to return 0 on failure and 1 on success to the jdk.\n  return (ret == OS_ERR) ? 0 : 1;\n}\n\nint os::bind(int fd, struct sockaddr* him, socklen_t len) {\n   INTERRUPTIBLE_RETURN_INT_NORESTART(::bind(fd, him, len),\\\n                                      os::Solaris::clear_interrupted);\n}\n\n// Get the default path to the core file\n// Returns the length of the string\nint os::get_core_path(char* buffer, size_t bufferSize) {\n  const char* p = get_current_directory(buffer, bufferSize);\n\n  if (p == NULL) {\n    assert(p != NULL, \"failed to get current directory\");\n    return 0;\n  }\n\n  return strlen(buffer);\n}\n\n#ifndef PRODUCT\nvoid TestReserveMemorySpecial_test() {\n  // No tests available for this platform\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os/bsd/vm/jsig.c": "/*\n * Copyright (c) 2001, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n/* CopyrightVersion 1.2 */\n\n/* This is a special library that should be loaded before libc &\n * libthread to interpose the signal handler installation functions:\n * sigaction(), signal(), sigset().\n * Used for signal-chaining. See RFE 4381843.\n */\n\n#include <signal.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAXSIGNUM 32\n#define MASK(sig) ((unsigned int)1 << sig)\n\nstatic struct sigaction sact[MAXSIGNUM]; /* saved signal handlers */\nstatic unsigned int jvmsigs = 0; /* signals used by jvm */\n\nstatic pthread_key_t reentry_flag_key;\nstatic pthread_once_t reentry_key_init_once = PTHREAD_ONCE_INIT;\n\n/* used to synchronize the installation of signal handlers */\nstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t tid = 0;\n\ntypedef void (*sa_handler_t)(int);\ntypedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\ntypedef sa_handler_t (*signal_t)(int, sa_handler_t);\ntypedef int (*sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic signal_t os_signal = 0; /* os's version of signal()/sigset() */\nstatic sigaction_t os_sigaction = 0; /* os's version of sigaction() */\n\nstatic bool jvm_signal_installing = false;\nstatic bool jvm_signal_installed = false;\n\n#define check_status(cmd) \\\n  do { \\\n    int status = (cmd); \\\n    if (status != 0) { \\\n      printf(\"error %s (%d) in \" #cmd \"\\n\", strerror(status), status); \\\n      exit(1); \\\n    } \\\n  } while (0)\n\nstatic void signal_lock() {\n  pthread_mutex_lock(&mutex);\n  /* When the jvm is installing its set of signal handlers, threads\n   * other than the jvm thread should wait */\n  if (jvm_signal_installing) {\n    if (tid != pthread_self()) {\n      pthread_cond_wait(&cond, &mutex);\n    }\n  }\n}\n\nstatic void signal_unlock() {\n  pthread_mutex_unlock(&mutex);\n}\n\nstatic void reentry_tls_init() {\n    // value for reentry_flag_key will default to NULL (false)\n    check_status(pthread_key_create(&reentry_flag_key, NULL));\n}\n\nstatic sa_handler_t call_os_signal(int sig, sa_handler_t disp,\n                                   bool is_sigset) {\n  sa_handler_t res;\n\n  if (os_signal == NULL) {\n    if (!is_sigset) {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"signal\");\n    } else {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"sigset\");\n    }\n    if (os_signal == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  check_status(pthread_once(&reentry_key_init_once, reentry_tls_init));\n  // set reentry_flag_key to non-NULL to show reentry\n  check_status(pthread_setspecific(reentry_flag_key, &res));\n  res = (*os_signal)(sig, disp);\n  check_status(pthread_setspecific(reentry_flag_key, NULL));\n  return res;\n}\n\nstatic void save_signal_handler(int sig, sa_handler_t disp) {\n  sigset_t set;\n  sact[sig].sa_handler = disp;\n  sigemptyset(&set);\n  sact[sig].sa_mask = set;\n  sact[sig].sa_flags = 0;\n}\n\nstatic sa_handler_t set_signal(int sig, sa_handler_t disp, bool is_sigset) {\n  sa_handler_t oldhandler;\n  bool sigused;\n\n  signal_lock();\n\n  sigused = (MASK(sig) & jvmsigs) != 0;\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    oldhandler = sact[sig].sa_handler;\n    save_signal_handler(sig, disp);\n\n    signal_unlock();\n    return oldhandler;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. jvm uses sigaction().\n     * Leave the piece here just in case. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n    save_signal_handler(sig, oldhandler);\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return oldhandler;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n\n    signal_unlock();\n    return oldhandler;\n  }\n}\n\nsa_handler_t signal(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, false);\n}\n\nsa_handler_t sigset(int sig, sa_handler_t disp) {\n  printf(\"sigset() is not supported by BSD\");\n  exit(0);\n }\n\nstatic int call_os_sigaction(int sig, const struct sigaction  *act,\n                             struct sigaction *oact) {\n  if (os_sigaction == NULL) {\n    os_sigaction = (sigaction_t)dlsym(RTLD_NEXT, \"sigaction\");\n    if (os_sigaction == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_sigaction)(sig, act, oact);\n}\n\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact) {\n  int res;\n  bool sigused;\n  struct sigaction oldAct;\n\n  check_status(pthread_once(&reentry_key_init_once, reentry_tls_init));\n  if (pthread_getspecific(reentry_flag_key) != NULL) {\n    return call_os_sigaction(sig, act, oact);\n  }\n\n  signal_lock();\n\n  sigused = (MASK(sig) & jvmsigs) != 0;\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    if (oact != NULL) {\n      *oact = sact[sig];\n    }\n    if (act != NULL) {\n      sact[sig] = *act;\n    }\n\n    signal_unlock();\n    return 0;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. */\n    res = call_os_sigaction(sig, act, &oldAct);\n    sact[sig] = oldAct;\n    if (oact != NULL) {\n      *oact = oldAct;\n    }\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return res;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    res = call_os_sigaction(sig, act, oact);\n\n    signal_unlock();\n    return res;\n  }\n}\n\n/* The three functions for the jvm to call into */\nvoid JVM_begin_signal_setting() {\n  signal_lock();\n  jvm_signal_installing = true;\n  tid = pthread_self();\n  signal_unlock();\n}\n\nvoid JVM_end_signal_setting() {\n  signal_lock();\n  jvm_signal_installed = true;\n  jvm_signal_installing = false;\n  pthread_cond_broadcast(&cond);\n  signal_unlock();\n}\n\nstruct sigaction *JVM_get_signal_action(int sig) {\n  /* Does race condition make sense here? */\n  if ((MASK(sig) & jvmsigs) != 0) {\n    return &sact[sig];\n  }\n  return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os/bsd/vm/os_bsd.cpp": "/*\n * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n// no precompiled headers\n#include \"classfile/classLoader.hpp\"\n#include \"classfile/systemDictionary.hpp\"\n#include \"classfile/vmSymbols.hpp\"\n#include \"code/icBuffer.hpp\"\n#include \"code/vtableStubs.hpp\"\n#include \"compiler/compileBroker.hpp\"\n#include \"compiler/disassembler.hpp\"\n#include \"interpreter/interpreter.hpp\"\n#include \"jvm_bsd.h\"\n#include \"memory/allocation.inline.hpp\"\n#include \"memory/filemap.hpp\"\n#include \"mutex_bsd.inline.hpp\"\n#include \"oops/oop.inline.hpp\"\n#include \"os_share_bsd.hpp\"\n#include \"prims/jniFastGetField.hpp\"\n#include \"prims/jvm.h\"\n#include \"prims/jvm_misc.hpp\"\n#include \"runtime/arguments.hpp\"\n#include \"runtime/extendedPC.hpp\"\n#include \"runtime/globals.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/java.hpp\"\n#include \"runtime/javaCalls.hpp\"\n#include \"runtime/mutexLocker.hpp\"\n#include \"runtime/objectMonitor.hpp\"\n#include \"runtime/orderAccess.inline.hpp\"\n#include \"runtime/osThread.hpp\"\n#include \"runtime/perfMemory.hpp\"\n#include \"runtime/sharedRuntime.hpp\"\n#include \"runtime/statSampler.hpp\"\n#include \"runtime/stubRoutines.hpp\"\n#include \"runtime/thread.inline.hpp\"\n#include \"runtime/threadCritical.hpp\"\n#include \"runtime/timer.hpp\"\n#include \"services/attachListener.hpp\"\n#include \"services/memTracker.hpp\"\n#include \"services/runtimeService.hpp\"\n#include \"utilities/decoder.hpp\"\n#include \"utilities/defaultStream.hpp\"\n#include \"utilities/events.hpp\"\n#include \"utilities/growableArray.hpp\"\n#include \"utilities/vmError.hpp\"\n\n// put OS-includes here\n# include <sys/types.h>\n# include <sys/mman.h>\n# include <sys/stat.h>\n# include <sys/select.h>\n# include <pthread.h>\n# include <signal.h>\n# include <errno.h>\n# include <dlfcn.h>\n# include <stdio.h>\n# include <unistd.h>\n# include <sys/resource.h>\n# include <pthread.h>\n# include <sys/stat.h>\n# include <sys/time.h>\n# include <sys/times.h>\n# include <sys/utsname.h>\n# include <sys/socket.h>\n# include <sys/wait.h>\n# include <time.h>\n# include <pwd.h>\n# include <poll.h>\n# include <semaphore.h>\n# include <fcntl.h>\n# include <string.h>\n# include <sys/param.h>\n# include <sys/sysctl.h>\n# include <sys/ipc.h>\n# include <sys/shm.h>\n#ifndef __APPLE__\n# include <link.h>\n#endif\n# include <stdint.h>\n# include <inttypes.h>\n# include <sys/ioctl.h>\n# include <sys/syscall.h>\n\n#if defined(__FreeBSD__) || defined(__NetBSD__)\n# include <elf.h>\n#endif\n\n#ifdef __APPLE__\n# include <mach/mach.h> // semaphore_* API\n# include <mach-o/dyld.h>\n# include <sys/proc_info.h>\n# include <objc/objc-auto.h>\n#endif\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#define MAX_PATH    (2 * K)\n\n// for timer info max values which include all bits\n#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n\n#define LARGEPAGES_BIT (1 << 6)\n\nPRAGMA_FORMAT_MUTE_WARNINGS_FOR_GCC\n\n////////////////////////////////////////////////////////////////////////////////\n// global variables\njulong os::Bsd::_physical_memory = 0;\n\n#ifdef __APPLE__\nmach_timebase_info_data_t os::Bsd::_timebase_info = {0, 0};\nvolatile uint64_t         os::Bsd::_max_abstime   = 0;\n#else\nint (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;\n#endif\npthread_t os::Bsd::_main_thread;\nint os::Bsd::_page_size = -1;\n\nstatic jlong initial_time_count=0;\n\nstatic int clock_tics_per_sec = 100;\n\n// For diagnostics to print a message once. see run_periodic_checks\nstatic sigset_t check_signal_done;\nstatic bool check_signals = true;\n\nstatic pid_t _initial_pid = 0;\n\n/* Signal number used to suspend/resume a thread */\n\n/* do not use any signal number less than SIGSEGV, see 4355769 */\nstatic int SR_signum = SIGUSR2;\nsigset_t SR_sigset;\n\n\n////////////////////////////////////////////////////////////////////////////////\n// utility functions\n\nstatic int SR_initialize();\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time);\n\njulong os::available_memory() {\n  return Bsd::available_memory();\n}\n\n// available here means free\njulong os::Bsd::available_memory() {\n  uint64_t available = physical_memory() >> 2;\n#ifdef __APPLE__\n  mach_msg_type_number_t count = HOST_VM_INFO64_COUNT;\n  vm_statistics64_data_t vmstat;\n  kern_return_t kerr = host_statistics64(mach_host_self(), HOST_VM_INFO64,\n                                         (host_info64_t)&vmstat, &count);\n  assert(kerr == KERN_SUCCESS,\n         \"host_statistics64 failed - check mach_host_self() and count\");\n  if (kerr == KERN_SUCCESS) {\n    available = vmstat.free_count * os::vm_page_size();\n  }\n#endif\n  return available;\n}\n\njulong os::physical_memory() {\n  return Bsd::physical_memory();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// environment support\n\nbool os::getenv(const char* name, char* buf, int len) {\n  const char* val = ::getenv(name);\n  if (val != NULL && strlen(val) < (size_t)len) {\n    strcpy(buf, val);\n    return true;\n  }\n  if (len > 0) buf[0] = 0;  // return a null string\n  return false;\n}\n\n\n// Return true if user is running as root.\n\nbool os::have_special_privileges() {\n  static bool init = false;\n  static bool privileges = false;\n  if (!init) {\n    privileges = (getuid() != geteuid()) || (getgid() != getegid());\n    init = true;\n  }\n  return privileges;\n}\n\n\n\n// Cpu architecture string\n#if   defined(ZERO)\nstatic char cpu_arch[] = ZERO_LIBARCH;\n#elif defined(IA64)\nstatic char cpu_arch[] = \"ia64\";\n#elif defined(IA32)\nstatic char cpu_arch[] = \"i386\";\n#elif defined(AMD64)\nstatic char cpu_arch[] = \"amd64\";\n#elif defined(ARM)\nstatic char cpu_arch[] = \"arm\";\n#elif defined(PPC32)\nstatic char cpu_arch[] = \"ppc\";\n#elif defined(SPARC)\n#  ifdef _LP64\nstatic char cpu_arch[] = \"sparcv9\";\n#  else\nstatic char cpu_arch[] = \"sparc\";\n#  endif\n#else\n#error Add appropriate cpu_arch setting\n#endif\n\n// Compiler variant\n#ifdef COMPILER2\n#define COMPILER_VARIANT \"server\"\n#else\n#define COMPILER_VARIANT \"client\"\n#endif\n\n\nvoid os::Bsd::initialize_system_info() {\n  int mib[2];\n  size_t len;\n  int cpu_val;\n  julong mem_val;\n\n  /* get processors count via hw.ncpus sysctl */\n  mib[0] = CTL_HW;\n  mib[1] = HW_NCPU;\n  len = sizeof(cpu_val);\n  if (sysctl(mib, 2, &cpu_val, &len, NULL, 0) != -1 && cpu_val >= 1) {\n       assert(len == sizeof(cpu_val), \"unexpected data size\");\n       set_processor_count(cpu_val);\n  }\n  else {\n       set_processor_count(1);   // fallback\n  }\n\n  /* get physical memory via hw.memsize sysctl (hw.memsize is used\n   * since it returns a 64 bit value)\n   */\n  mib[0] = CTL_HW;\n\n#if defined (HW_MEMSIZE) // Apple\n  mib[1] = HW_MEMSIZE;\n#elif defined(HW_PHYSMEM) // Most of BSD\n  mib[1] = HW_PHYSMEM;\n#elif defined(HW_REALMEM) // Old FreeBSD\n  mib[1] = HW_REALMEM;\n#else\n  #error No ways to get physmem\n#endif\n\n  len = sizeof(mem_val);\n  if (sysctl(mib, 2, &mem_val, &len, NULL, 0) != -1) {\n       assert(len == sizeof(mem_val), \"unexpected data size\");\n       _physical_memory = mem_val;\n  } else {\n       _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)\n  }\n\n#ifdef __OpenBSD__\n  {\n       // limit _physical_memory memory view on OpenBSD since\n       // datasize rlimit restricts us anyway.\n       struct rlimit limits;\n       getrlimit(RLIMIT_DATA, &limits);\n       _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);\n  }\n#endif\n}\n\n#ifdef __APPLE__\nstatic const char *get_home() {\n  const char *home_dir = ::getenv(\"HOME\");\n  if ((home_dir == NULL) || (*home_dir == '\\0')) {\n    struct passwd *passwd_info = getpwuid(geteuid());\n    if (passwd_info != NULL) {\n      home_dir = passwd_info->pw_dir;\n    }\n  }\n\n  return home_dir;\n}\n#endif\n\nvoid os::init_system_properties_values() {\n  // The next steps are taken in the product version:\n  //\n  // Obtain the JAVA_HOME value from the location of libjvm.so.\n  // This library should be located at:\n  // <JAVA_HOME>/jre/lib/<arch>/{client|server}/libjvm.so.\n  //\n  // If \"/jre/lib/\" appears at the right place in the path, then we\n  // assume libjvm.so is installed in a JDK and we use this path.\n  //\n  // Otherwise exit with message: \"Could not create the Java virtual machine.\"\n  //\n  // The following extra steps are taken in the debugging version:\n  //\n  // If \"/jre/lib/\" does NOT appear at the right place in the path\n  // instead of exit check for $JAVA_HOME environment variable.\n  //\n  // If it is defined and we are able to locate $JAVA_HOME/jre/lib/<arch>,\n  // then we append a fake suffix \"hotspot/libjvm.so\" to this path so\n  // it looks like libjvm.so is installed there\n  // <JAVA_HOME>/jre/lib/<arch>/hotspot/libjvm.so.\n  //\n  // Otherwise exit.\n  //\n  // Important note: if the location of libjvm.so changes this\n  // code needs to be changed accordingly.\n\n// See ld(1):\n//      The linker uses the following search paths to locate required\n//      shared libraries:\n//        1: ...\n//        ...\n//        7: The default directories, normally /lib and /usr/lib.\n#ifndef DEFAULT_LIBPATH\n#define DEFAULT_LIBPATH \"/lib:/usr/lib\"\n#endif\n\n// Base path of extensions installed on the system.\n#define SYS_EXT_DIR     \"/usr/java/packages\"\n#define EXTENSIONS_DIR  \"/lib/ext\"\n#define ENDORSED_DIR    \"/lib/endorsed\"\n\n#ifndef __APPLE__\n\n  // Buffer that fits several sprintfs.\n  // Note that the space for the colon and the trailing null are provided\n  // by the nulls included by the sizeof operator.\n  const size_t bufsize =\n    MAX3((size_t)MAXPATHLEN,  // For dll_dir & friends.\n         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR), // extensions dir\n         (size_t)MAXPATHLEN + sizeof(ENDORSED_DIR)); // endorsed dir\n  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n\n  // sysclasspath, java_home, dll_dir\n  {\n    char *pslash;\n    os::jvm_path(buf, bufsize);\n\n    // Found the full path to libjvm.so.\n    // Now cut the path to <java_home>/jre if we can.\n    *(strrchr(buf, '/')) = '\\0'; // Get rid of /libjvm.so.\n    pslash = strrchr(buf, '/');\n    if (pslash != NULL) {\n      *pslash = '\\0';            // Get rid of /{client|server|hotspot}.\n    }\n    Arguments::set_dll_dir(buf);\n\n    if (pslash != NULL) {\n      pslash = strrchr(buf, '/');\n      if (pslash != NULL) {\n        *pslash = '\\0';          // Get rid of /<arch>.\n        pslash = strrchr(buf, '/');\n        if (pslash != NULL) {\n          *pslash = '\\0';        // Get rid of /lib.\n        }\n      }\n    }\n    Arguments::set_java_home(buf);\n    set_boot_path('/', ':');\n  }\n\n  // Where to look for native libraries.\n  //\n  // Note: Due to a legacy implementation, most of the library path\n  // is set in the launcher. This was to accomodate linking restrictions\n  // on legacy Bsd implementations (which are no longer supported).\n  // Eventually, all the library path setting will be done here.\n  //\n  // However, to prevent the proliferation of improperly built native\n  // libraries, the new path component /usr/java/packages is added here.\n  // Eventually, all the library path setting will be done here.\n  {\n    // Get the user setting of LD_LIBRARY_PATH, and prepended it. It\n    // should always exist (until the legacy problem cited above is\n    // addressed).\n    const char *v = ::getenv(\"LD_LIBRARY_PATH\");\n    const char *v_colon = \":\";\n    if (v == NULL) { v = \"\"; v_colon = \"\"; }\n    // That's +1 for the colon and +1 for the trailing '\\0'.\n    char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,\n                                                     strlen(v) + 1 +\n                                                     sizeof(SYS_EXT_DIR) + sizeof(\"/lib/\") + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,\n                                                     mtInternal);\n    sprintf(ld_library_path, \"%s%s\" SYS_EXT_DIR \"/lib/%s:\" DEFAULT_LIBPATH, v, v_colon, cpu_arch);\n    Arguments::set_library_path(ld_library_path);\n    FREE_C_HEAP_ARRAY(char, ld_library_path, mtInternal);\n  }\n\n  // Extensions directories.\n  sprintf(buf, \"%s\" EXTENSIONS_DIR \":\" SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());\n  Arguments::set_ext_dirs(buf);\n\n  // Endorsed standards default directory.\n  sprintf(buf, \"%s\" ENDORSED_DIR, Arguments::get_java_home());\n  Arguments::set_endorsed_dirs(buf);\n\n  FREE_C_HEAP_ARRAY(char, buf, mtInternal);\n\n#else // __APPLE__\n\n#define SYS_EXTENSIONS_DIR   \"/Library/Java/Extensions\"\n#define SYS_EXTENSIONS_DIRS  SYS_EXTENSIONS_DIR \":/Network\" SYS_EXTENSIONS_DIR \":/System\" SYS_EXTENSIONS_DIR \":/usr/lib/java\"\n\n  const char *user_home_dir = get_home();\n  // The null in SYS_EXTENSIONS_DIRS counts for the size of the colon after user_home_dir.\n  size_t system_ext_size = strlen(user_home_dir) + sizeof(SYS_EXTENSIONS_DIR) +\n    sizeof(SYS_EXTENSIONS_DIRS);\n\n  // Buffer that fits several sprintfs.\n  // Note that the space for the colon and the trailing null are provided\n  // by the nulls included by the sizeof operator.\n  const size_t bufsize =\n    MAX3((size_t)MAXPATHLEN,  // for dll_dir & friends.\n         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + system_ext_size, // extensions dir\n         (size_t)MAXPATHLEN + sizeof(ENDORSED_DIR)); // endorsed dir\n  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n\n  // sysclasspath, java_home, dll_dir\n  {\n    char *pslash;\n    os::jvm_path(buf, bufsize);\n\n    // Found the full path to libjvm.so.\n    // Now cut the path to <java_home>/jre if we can.\n    *(strrchr(buf, '/')) = '\\0'; // Get rid of /libjvm.so.\n    pslash = strrchr(buf, '/');\n    if (pslash != NULL) {\n      *pslash = '\\0';            // Get rid of /{client|server|hotspot}.\n    }\n    Arguments::set_dll_dir(buf);\n\n    if (pslash != NULL) {\n      pslash = strrchr(buf, '/');\n      if (pslash != NULL) {\n        *pslash = '\\0';          // Get rid of /lib.\n      }\n    }\n    Arguments::set_java_home(buf);\n    set_boot_path('/', ':');\n  }\n\n  // Where to look for native libraries.\n  //\n  // Note: Due to a legacy implementation, most of the library path\n  // is set in the launcher. This was to accomodate linking restrictions\n  // on legacy Bsd implementations (which are no longer supported).\n  // Eventually, all the library path setting will be done here.\n  //\n  // However, to prevent the proliferation of improperly built native\n  // libraries, the new path component /usr/java/packages is added here.\n  // Eventually, all the library path setting will be done here.\n  {\n    // Get the user setting of LD_LIBRARY_PATH, and prepended it. It\n    // should always exist (until the legacy problem cited above is\n    // addressed).\n    // Prepend the default path with the JAVA_LIBRARY_PATH so that the app launcher code\n    // can specify a directory inside an app wrapper\n    const char *l = ::getenv(\"JAVA_LIBRARY_PATH\");\n    const char *l_colon = \":\";\n    if (l == NULL) { l = \"\"; l_colon = \"\"; }\n\n    const char *v = ::getenv(\"DYLD_LIBRARY_PATH\");\n    const char *v_colon = \":\";\n    if (v == NULL) { v = \"\"; v_colon = \"\"; }\n\n    // Apple's Java6 has \".\" at the beginning of java.library.path.\n    // OpenJDK on Windows has \".\" at the end of java.library.path.\n    // OpenJDK on Linux and Solaris don't have \".\" in java.library.path\n    // at all. To ease the transition from Apple's Java6 to OpenJDK7,\n    // \".\" is appended to the end of java.library.path. Yes, this\n    // could cause a change in behavior, but Apple's Java6 behavior\n    // can be achieved by putting \".\" at the beginning of the\n    // JAVA_LIBRARY_PATH environment variable.\n    char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,\n                                                     strlen(v) + 1 + strlen(l) + 1 +\n                                                     system_ext_size + 3,\n                                                     mtInternal);\n    sprintf(ld_library_path, \"%s%s%s%s%s\" SYS_EXTENSIONS_DIR \":\" SYS_EXTENSIONS_DIRS \":.\",\n            v, v_colon, l, l_colon, user_home_dir);\n    Arguments::set_library_path(ld_library_path);\n    FREE_C_HEAP_ARRAY(char, ld_library_path, mtInternal);\n  }\n\n  // Extensions directories.\n  //\n  // Note that the space for the colon and the trailing null are provided\n  // by the nulls included by the sizeof operator (so actually one byte more\n  // than necessary is allocated).\n  sprintf(buf, \"%s\" SYS_EXTENSIONS_DIR \":%s\" EXTENSIONS_DIR \":\" SYS_EXTENSIONS_DIRS,\n          user_home_dir, Arguments::get_java_home());\n  Arguments::set_ext_dirs(buf);\n\n  // Endorsed standards default directory.\n  sprintf(buf, \"%s\" ENDORSED_DIR, Arguments::get_java_home());\n  Arguments::set_endorsed_dirs(buf);\n\n  FREE_C_HEAP_ARRAY(char, buf, mtInternal);\n\n#undef SYS_EXTENSIONS_DIR\n#undef SYS_EXTENSIONS_DIRS\n\n#endif // __APPLE__\n\n#undef SYS_EXT_DIR\n#undef EXTENSIONS_DIR\n#undef ENDORSED_DIR\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// breakpoint support\n\nvoid os::breakpoint() {\n  BREAKPOINT;\n}\n\nextern \"C\" void breakpoint() {\n  // use debugger to set breakpoint here\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// signal support\n\ndebug_only(static bool signal_sets_initialized = false);\nstatic sigset_t unblocked_sigs, vm_sigs, allowdebug_blocked_sigs;\n\nbool os::Bsd::is_sig_ignored(int sig) {\n      struct sigaction oact;\n      sigaction(sig, (struct sigaction*)NULL, &oact);\n      void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oact.sa_sigaction)\n                                     : CAST_FROM_FN_PTR(void*,  oact.sa_handler);\n      if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN))\n           return true;\n      else\n           return false;\n}\n\nvoid os::Bsd::signal_sets_init() {\n  // Should also have an assertion stating we are still single-threaded.\n  assert(!signal_sets_initialized, \"Already initialized\");\n  // Fill in signals that are necessarily unblocked for all threads in\n  // the VM. Currently, we unblock the following signals:\n  // SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n  //                         by -Xrs (=ReduceSignalUsage));\n  // BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n  // other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n  // the dispositions or masks wrt these signals.\n  // Programs embedding the VM that want to use the above signals for their\n  // own purposes must, at this time, use the \"-Xrs\" option to prevent\n  // interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n  // (See bug 4345157, and other related bugs).\n  // In reality, though, unblocking these signals is really a nop, since\n  // these signals are not blocked by default.\n  sigemptyset(&unblocked_sigs);\n  sigemptyset(&allowdebug_blocked_sigs);\n  sigaddset(&unblocked_sigs, SIGILL);\n  sigaddset(&unblocked_sigs, SIGSEGV);\n  sigaddset(&unblocked_sigs, SIGBUS);\n  sigaddset(&unblocked_sigs, SIGFPE);\n  sigaddset(&unblocked_sigs, SR_signum);\n\n  if (!ReduceSignalUsage) {\n   if (!os::Bsd::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN1_SIGNAL);\n   }\n   if (!os::Bsd::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN2_SIGNAL);\n   }\n   if (!os::Bsd::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN3_SIGNAL);\n   }\n  }\n  // Fill in signals that are blocked by all but the VM thread.\n  sigemptyset(&vm_sigs);\n  if (!ReduceSignalUsage)\n    sigaddset(&vm_sigs, BREAK_SIGNAL);\n  debug_only(signal_sets_initialized = true);\n\n}\n\n// These are signals that are unblocked while a thread is running Java.\n// (For some reason, they get blocked by default.)\nsigset_t* os::Bsd::unblocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &unblocked_sigs;\n}\n\n// These are the signals that are blocked while a (non-VM) thread is\n// running Java. Only the VM thread handles these signals.\nsigset_t* os::Bsd::vm_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &vm_sigs;\n}\n\n// These are signals that are blocked during cond_wait to allow debugger in\nsigset_t* os::Bsd::allowdebug_blocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &allowdebug_blocked_sigs;\n}\n\nvoid os::Bsd::hotspot_sigmask(Thread* thread) {\n\n  //Save caller's signal mask before setting VM signal mask\n  sigset_t caller_sigmask;\n  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n\n  OSThread* osthread = thread->osthread();\n  osthread->set_caller_sigmask(caller_sigmask);\n\n  pthread_sigmask(SIG_UNBLOCK, os::Bsd::unblocked_signals(), NULL);\n\n  if (!ReduceSignalUsage) {\n    if (thread->is_VM_thread()) {\n      // Only the VM thread handles BREAK_SIGNAL ...\n      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n    } else {\n      // ... all other threads block BREAK_SIGNAL\n      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n    }\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n// create new thread\n\n// check if it's safe to start a new thread\nstatic bool _thread_safety_check(Thread* thread) {\n  return true;\n}\n\n#ifdef __APPLE__\n// library handle for calling objc_registerThreadWithCollector()\n// without static linking to the libobjc library\n#define OBJC_LIB \"/usr/lib/libobjc.dylib\"\n#define OBJC_GCREGISTER \"objc_registerThreadWithCollector\"\ntypedef void (*objc_registerThreadWithCollector_t)();\nextern \"C\" objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction;\nobjc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction = NULL;\n#endif\n\n#ifdef __APPLE__\nstatic uint64_t locate_unique_thread_id(mach_port_t mach_thread_port) {\n  // Additional thread_id used to correlate threads in SA\n  thread_identifier_info_data_t     m_ident_info;\n  mach_msg_type_number_t            count = THREAD_IDENTIFIER_INFO_COUNT;\n\n  thread_info(mach_thread_port, THREAD_IDENTIFIER_INFO,\n              (thread_info_t) &m_ident_info, &count);\n\n  return m_ident_info.thread_id;\n}\n#endif\n\n// Thread start routine for all newly created threads\nstatic void *java_start(Thread *thread) {\n  // Try to randomize the cache line index of hot stack frames.\n  // This helps when threads of the same stack traces evict each other's\n  // cache lines. The threads can be either from the same JVM instance, or\n  // from different JVM instances. The benefit is especially true for\n  // processors with hyperthreading technology.\n  static int counter = 0;\n  int pid = os::current_process_id();\n  alloca(((pid ^ counter++) & 7) * 128);\n\n  ThreadLocalStorage::set_thread(thread);\n\n  OSThread* osthread = thread->osthread();\n  Monitor* sync = osthread->startThread_lock();\n\n  // non floating stack BsdThreads needs extra check, see above\n  if (!_thread_safety_check(thread)) {\n    // notify parent thread\n    MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);\n    osthread->set_state(ZOMBIE);\n    sync->notify_all();\n    return NULL;\n  }\n\n  osthread->set_thread_id(os::Bsd::gettid());\n\n#ifdef __APPLE__\n  uint64_t unique_thread_id = locate_unique_thread_id(osthread->thread_id());\n  guarantee(unique_thread_id != 0, \"unique thread id was not found\");\n  osthread->set_unique_thread_id(unique_thread_id);\n#endif\n  // initialize signal mask for this thread\n  os::Bsd::hotspot_sigmask(thread);\n\n  // initialize floating point control register\n  os::Bsd::init_thread_fpu_state();\n\n#ifdef __APPLE__\n  // register thread with objc gc\n  if (objc_registerThreadWithCollectorFunction != NULL) {\n    objc_registerThreadWithCollectorFunction();\n  }\n#endif\n\n  // handshaking with parent thread\n  {\n    MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);\n\n    // notify parent thread\n    osthread->set_state(INITIALIZED);\n    sync->notify_all();\n\n    // wait until os::start_thread()\n    while (osthread->get_state() == INITIALIZED) {\n      sync->wait(Mutex::_no_safepoint_check_flag);\n    }\n  }\n\n  // call one more level start routine\n  thread->run();\n\n  return 0;\n}\n\nbool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) {\n  assert(thread->osthread() == NULL, \"caller responsible\");\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // set the correct thread state\n  osthread->set_thread_type(thr_type);\n\n  // Initial state is ALLOCATED but not INITIALIZED\n  osthread->set_state(ALLOCATED);\n\n  thread->set_osthread(osthread);\n\n  // init thread attributes\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n  // stack size\n  if (os::Bsd::supports_variable_stack_size()) {\n    // calculate stack size if it's not specified by caller\n    if (stack_size == 0) {\n      stack_size = os::Bsd::default_stack_size(thr_type);\n\n      switch (thr_type) {\n      case os::java_thread:\n        // Java threads use ThreadStackSize which default value can be\n        // changed with the flag -Xss\n        assert (JavaThread::stack_size_at_create() > 0, \"this should be set\");\n        stack_size = JavaThread::stack_size_at_create();\n        break;\n      case os::compiler_thread:\n        if (CompilerThreadStackSize > 0) {\n          stack_size = (size_t)(CompilerThreadStackSize * K);\n          break;\n        } // else fall through:\n          // use VMThreadStackSize if CompilerThreadStackSize is not defined\n      case os::vm_thread:\n      case os::pgc_thread:\n      case os::cgc_thread:\n      case os::watcher_thread:\n        if (VMThreadStackSize > 0) stack_size = (size_t)(VMThreadStackSize * K);\n        break;\n      }\n    }\n\n    stack_size = MAX2(stack_size, os::Bsd::min_stack_allowed);\n    pthread_attr_setstacksize(&attr, stack_size);\n  } else {\n    // let pthread_create() pick the default value.\n  }\n\n  ThreadState state;\n\n  {\n    pthread_t tid;\n    int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);\n\n    pthread_attr_destroy(&attr);\n\n    if (ret != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode)) {\n        perror(\"pthread_create()\");\n      }\n      // Need to clean up stuff we've allocated so far\n      thread->set_osthread(NULL);\n      delete osthread;\n      return false;\n    }\n\n    // Store pthread info into the OSThread\n    osthread->set_pthread_id(tid);\n\n    // Wait until child thread is either initialized or aborted\n    {\n      Monitor* sync_with_child = osthread->startThread_lock();\n      MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);\n      while ((state = osthread->get_state()) == ALLOCATED) {\n        sync_with_child->wait(Mutex::_no_safepoint_check_flag);\n      }\n    }\n\n  }\n\n  // Aborted due to thread limit being reached\n  if (state == ZOMBIE) {\n      thread->set_osthread(NULL);\n      delete osthread;\n      return false;\n  }\n\n  // The thread is returned suspended (in state INITIALIZED),\n  // and is started higher up in the call chain\n  assert(state == INITIALIZED, \"race condition\");\n  return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// attach existing thread\n\n// bootstrap the main thread\nbool os::create_main_thread(JavaThread* thread) {\n  assert(os::Bsd::_main_thread == pthread_self(), \"should be called inside main thread\");\n  return create_attached_thread(thread);\n}\n\nbool os::create_attached_thread(JavaThread* thread) {\n#ifdef ASSERT\n    thread->verify_not_published();\n#endif\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n\n  if (osthread == NULL) {\n    return false;\n  }\n\n  osthread->set_thread_id(os::Bsd::gettid());\n\n  // Store pthread info into the OSThread\n#ifdef __APPLE__\n  uint64_t unique_thread_id = locate_unique_thread_id(osthread->thread_id());\n  guarantee(unique_thread_id != 0, \"just checking\");\n  osthread->set_unique_thread_id(unique_thread_id);\n#endif\n  osthread->set_pthread_id(::pthread_self());\n\n  // initialize floating point control register\n  os::Bsd::init_thread_fpu_state();\n\n  // Initial thread state is RUNNABLE\n  osthread->set_state(RUNNABLE);\n\n  thread->set_osthread(osthread);\n\n  // initialize signal mask for this thread\n  // and save the caller's signal mask\n  os::Bsd::hotspot_sigmask(thread);\n\n  return true;\n}\n\nvoid os::pd_start_thread(Thread* thread) {\n  OSThread * osthread = thread->osthread();\n  assert(osthread->get_state() != INITIALIZED, \"just checking\");\n  Monitor* sync_with_child = osthread->startThread_lock();\n  MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);\n  sync_with_child->notify();\n}\n\n// Free Bsd resources related to the OSThread\nvoid os::free_thread(OSThread* osthread) {\n  assert(osthread != NULL, \"osthread not set\");\n\n  if (Thread::current()->osthread() == osthread) {\n    // Restore caller's signal mask\n    sigset_t sigmask = osthread->caller_sigmask();\n    pthread_sigmask(SIG_SETMASK, &sigmask, NULL);\n   }\n\n  delete osthread;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// thread local storage\n\n// Restore the thread pointer if the destructor is called. This is in case\n// someone from JNI code sets up a destructor with pthread_key_create to run\n// detachCurrentThread on thread death. Unless we restore the thread pointer we\n// will hang or crash. When detachCurrentThread is called the key will be set\n// to null and we will not be called again. If detachCurrentThread is never\n// called we could loop forever depending on the pthread implementation.\nstatic void restore_thread_pointer(void* p) {\n  Thread* thread = (Thread*) p;\n  os::thread_local_storage_at_put(ThreadLocalStorage::thread_index(), thread);\n}\n\nint os::allocate_thread_local_storage() {\n  pthread_key_t key;\n  int rslt = pthread_key_create(&key, restore_thread_pointer);\n  assert(rslt == 0, \"cannot allocate thread local storage\");\n  return (int)key;\n}\n\n// Note: This is currently not used by VM, as we don't destroy TLS key\n// on VM exit.\nvoid os::free_thread_local_storage(int index) {\n  int rslt = pthread_key_delete((pthread_key_t)index);\n  assert(rslt == 0, \"invalid index\");\n}\n\nvoid os::thread_local_storage_at_put(int index, void* value) {\n  int rslt = pthread_setspecific((pthread_key_t)index, value);\n  assert(rslt == 0, \"pthread_setspecific failed\");\n}\n\nextern \"C\" Thread* get_thread() {\n  return ThreadLocalStorage::thread();\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n// time support\n\n// Time since start-up in seconds to a fine granularity.\n// Used by VMSelfDestructTimer and the MemProfiler.\ndouble os::elapsedTime() {\n\n  return ((double)os::elapsed_counter()) / os::elapsed_frequency();\n}\n\njlong os::elapsed_counter() {\n  return javaTimeNanos() - initial_time_count;\n}\n\njlong os::elapsed_frequency() {\n  return NANOSECS_PER_SEC; // nanosecond resolution\n}\n\nbool os::supports_vtime() { return true; }\nbool os::enable_vtime()   { return false; }\nbool os::vtime_enabled()  { return false; }\n\ndouble os::elapsedVTime() {\n  // better than nothing, but not much\n  return elapsedTime();\n}\n\njlong os::javaTimeMillis() {\n  timeval time;\n  int status = gettimeofday(&time, NULL);\n  assert(status != -1, \"bsd error\");\n  return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);\n}\n\n#ifndef __APPLE__\n#ifndef CLOCK_MONOTONIC\n#define CLOCK_MONOTONIC (1)\n#endif\n#endif\n\n#ifdef __APPLE__\nvoid os::Bsd::clock_init() {\n  mach_timebase_info(&_timebase_info);\n}\n#else\nvoid os::Bsd::clock_init() {\n  struct timespec res;\n  struct timespec tp;\n  if (::clock_getres(CLOCK_MONOTONIC, &res) == 0 &&\n      ::clock_gettime(CLOCK_MONOTONIC, &tp)  == 0) {\n    // yes, monotonic clock is supported\n    _clock_gettime = ::clock_gettime;\n  }\n}\n#endif\n\n\n#ifdef __APPLE__\n\njlong os::javaTimeNanos() {\n    const uint64_t tm = mach_absolute_time();\n    const uint64_t now = (tm * Bsd::_timebase_info.numer) / Bsd::_timebase_info.denom;\n    const uint64_t prev = Bsd::_max_abstime;\n    if (now <= prev) {\n      return prev;   // same or retrograde time;\n    }\n    const uint64_t obsv = Atomic::cmpxchg(now, (volatile jlong*)&Bsd::_max_abstime, prev);\n    assert(obsv >= prev, \"invariant\");   // Monotonicity\n    // If the CAS succeeded then we're done and return \"now\".\n    // If the CAS failed and the observed value \"obsv\" is >= now then\n    // we should return \"obsv\".  If the CAS failed and now > obsv > prv then\n    // some other thread raced this thread and installed a new value, in which case\n    // we could either (a) retry the entire operation, (b) retry trying to install now\n    // or (c) just return obsv.  We use (c).   No loop is required although in some cases\n    // we might discard a higher \"now\" value in deference to a slightly lower but freshly\n    // installed obsv value.   That's entirely benign -- it admits no new orderings compared\n    // to (a) or (b) -- and greatly reduces coherence traffic.\n    // We might also condition (c) on the magnitude of the delta between obsv and now.\n    // Avoiding excessive CAS operations to hot RW locations is critical.\n    // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate\n    return (prev == obsv) ? now : obsv;\n}\n\n#else // __APPLE__\n\njlong os::javaTimeNanos() {\n  if (Bsd::supports_monotonic_clock()) {\n    struct timespec tp;\n    int status = Bsd::_clock_gettime(CLOCK_MONOTONIC, &tp);\n    assert(status == 0, \"gettime error\");\n    jlong result = jlong(tp.tv_sec) * (1000 * 1000 * 1000) + jlong(tp.tv_nsec);\n    return result;\n  } else {\n    timeval time;\n    int status = gettimeofday(&time, NULL);\n    assert(status != -1, \"bsd error\");\n    jlong usecs = jlong(time.tv_sec) * (1000 * 1000) + jlong(time.tv_usec);\n    return 1000 * usecs;\n  }\n}\n\n#endif // __APPLE__\n\nvoid os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n  if (Bsd::supports_monotonic_clock()) {\n    info_ptr->max_value = ALL_64_BITS;\n\n    // CLOCK_MONOTONIC - amount of time since some arbitrary point in the past\n    info_ptr->may_skip_backward = false;      // not subject to resetting or drifting\n    info_ptr->may_skip_forward = false;       // not subject to resetting or drifting\n  } else {\n    // gettimeofday - based on time in seconds since the Epoch thus does not wrap\n    info_ptr->max_value = ALL_64_BITS;\n\n    // gettimeofday is a real time clock so it skips\n    info_ptr->may_skip_backward = true;\n    info_ptr->may_skip_forward = true;\n  }\n\n  info_ptr->kind = JVMTI_TIMER_ELAPSED;                // elapsed not CPU time\n}\n\n// Return the real, user, and system times in seconds from an\n// arbitrary fixed point in the past.\nbool os::getTimesSecs(double* process_real_time,\n                      double* process_user_time,\n                      double* process_system_time) {\n  struct tms ticks;\n  clock_t real_ticks = times(&ticks);\n\n  if (real_ticks == (clock_t) (-1)) {\n    return false;\n  } else {\n    double ticks_per_second = (double) clock_tics_per_sec;\n    *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;\n    *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;\n    *process_real_time = ((double) real_ticks) / ticks_per_second;\n\n    return true;\n  }\n}\n\n\nchar * os::local_time_string(char *buf, size_t buflen) {\n  struct tm t;\n  time_t long_time;\n  time(&long_time);\n  localtime_r(&long_time, &t);\n  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n               t.tm_hour, t.tm_min, t.tm_sec);\n  return buf;\n}\n\nstruct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {\n  return localtime_r(clock, res);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// runtime exit support\n\n// Note: os::shutdown() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::shutdown(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::shutdown() {\n\n  // allow PerfMemory to attempt cleanup of any persistent resources\n  perfMemory_exit();\n\n  // needs to remove object in file system\n  AttachListener::abort();\n\n  // flush buffered output, finish log files\n  ostream_abort();\n\n  // Check for abort hook\n  abort_hook_t abort_hook = Arguments::abort_hook();\n  if (abort_hook != NULL) {\n    abort_hook();\n  }\n\n}\n\n// Note: os::abort() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::abort(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::abort(bool dump_core) {\n  os::shutdown();\n  if (dump_core) {\n#ifndef PRODUCT\n    fdStream out(defaultStream::output_fd());\n    out.print_raw(\"Current thread is \");\n    char buf[16];\n    jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());\n    out.print_raw_cr(buf);\n    out.print_raw_cr(\"Dumping core ...\");\n#endif\n    ::abort(); // dump core\n  }\n\n  ::exit(1);\n}\n\n// Die immediately, no exit hook, no abort hook, no cleanup.\nvoid os::die() {\n  // _exit() on BsdThreads only kills current thread\n  ::abort();\n}\n\n// This method is a copy of JDK's sysGetLastErrorString\n// from src/solaris/hpi/src/system_md.c\n\nsize_t os::lasterror(char *buf, size_t len) {\n\n  if (errno == 0)  return 0;\n\n  const char *s = ::strerror(errno);\n  size_t n = ::strlen(s);\n  if (n >= len) {\n    n = len - 1;\n  }\n  ::strncpy(buf, s, n);\n  buf[n] = '\\0';\n  return n;\n}\n\n// Information of current thread in variety of formats\npid_t os::Bsd::gettid() {\n  int retval = -1;\n\n#ifdef __APPLE__ //XNU kernel\n  // despite the fact mach port is actually not a thread id use it\n  // instead of syscall(SYS_thread_selfid) as it certainly fits to u4\n  retval = ::pthread_mach_thread_np(::pthread_self());\n  guarantee(retval != 0, \"just checking\");\n  return retval;\n\n#else\n  #ifdef __FreeBSD__\n  retval = syscall(SYS_thr_self);\n  #else\n    #ifdef __OpenBSD__\n  retval = syscall(SYS_getthrid);\n    #else\n      #ifdef __NetBSD__\n  retval = (pid_t) syscall(SYS__lwp_self);\n      #endif\n    #endif\n  #endif\n#endif\n\n  if (retval == -1) {\n    return getpid();\n  }\n}\n\nintx os::current_thread_id() {\n#ifdef __APPLE__\n  return (intx)::pthread_mach_thread_np(::pthread_self());\n#else\n  return (intx)::pthread_self();\n#endif\n}\n\nint os::current_process_id() {\n\n  // Under the old bsd thread library, bsd gives each thread\n  // its own process id. Because of this each thread will return\n  // a different pid if this method were to return the result\n  // of getpid(2). Bsd provides no api that returns the pid\n  // of the launcher thread for the vm. This implementation\n  // returns a unique pid, the pid of the launcher thread\n  // that starts the vm 'process'.\n\n  // Under the NPTL, getpid() returns the same pid as the\n  // launcher thread rather than a unique pid per thread.\n  // Use gettid() if you want the old pre NPTL behaviour.\n\n  // if you are looking for the result of a call to getpid() that\n  // returns a unique pid for the calling thread, then look at the\n  // OSThread::thread_id() method in osThread_bsd.hpp file\n\n  return (int)(_initial_pid ? _initial_pid : getpid());\n}\n\n// DLL functions\n\n#define JNI_LIB_PREFIX \"lib\"\n#ifdef __APPLE__\n#define JNI_LIB_SUFFIX \".dylib\"\n#else\n#define JNI_LIB_SUFFIX \".so\"\n#endif\n\nconst char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }\n\n// This must be hard coded because it's the system's temporary\n// directory not the java application's temp directory, ala java.io.tmpdir.\n#ifdef __APPLE__\n// macosx has a secure per-user temporary directory\nchar temp_path_storage[PATH_MAX];\nconst char* os::get_temp_directory() {\n  static char *temp_path = NULL;\n  if (temp_path == NULL) {\n    int pathSize = confstr(_CS_DARWIN_USER_TEMP_DIR, temp_path_storage, PATH_MAX);\n    if (pathSize == 0 || pathSize > PATH_MAX) {\n      strlcpy(temp_path_storage, \"/tmp/\", sizeof(temp_path_storage));\n    }\n    temp_path = temp_path_storage;\n  }\n  return temp_path;\n}\n#else /* __APPLE__ */\nconst char* os::get_temp_directory() { return \"/tmp\"; }\n#endif /* __APPLE__ */\n\nstatic bool file_exists(const char* filename) {\n  struct stat statbuf;\n  if (filename == NULL || strlen(filename) == 0) {\n    return false;\n  }\n  return os::stat(filename, &statbuf) == 0;\n}\n\nbool os::dll_build_name(char* buffer, size_t buflen,\n                        const char* pname, const char* fname) {\n  bool retval = false;\n  // Copied from libhpi\n  const size_t pnamelen = pname ? strlen(pname) : 0;\n\n  // Return error on buffer overflow.\n  if (pnamelen + strlen(fname) + strlen(JNI_LIB_PREFIX) + strlen(JNI_LIB_SUFFIX) + 2 > buflen) {\n    return retval;\n  }\n\n  if (pnamelen == 0) {\n    snprintf(buffer, buflen, JNI_LIB_PREFIX \"%s\" JNI_LIB_SUFFIX, fname);\n    retval = true;\n  } else if (strchr(pname, *os::path_separator()) != NULL) {\n    int n;\n    char** pelements = split_path(pname, &n);\n    if (pelements == NULL) {\n      return false;\n    }\n    for (int i = 0 ; i < n ; i++) {\n      // Really shouldn't be NULL, but check can't hurt\n      if (pelements[i] == NULL || strlen(pelements[i]) == 0) {\n        continue; // skip the empty path values\n      }\n      snprintf(buffer, buflen, \"%s/\" JNI_LIB_PREFIX \"%s\" JNI_LIB_SUFFIX,\n          pelements[i], fname);\n      if (file_exists(buffer)) {\n        retval = true;\n        break;\n      }\n    }\n    // release the storage\n    for (int i = 0 ; i < n ; i++) {\n      if (pelements[i] != NULL) {\n        FREE_C_HEAP_ARRAY(char, pelements[i], mtInternal);\n      }\n    }\n    if (pelements != NULL) {\n      FREE_C_HEAP_ARRAY(char*, pelements, mtInternal);\n    }\n  } else {\n    snprintf(buffer, buflen, \"%s/\" JNI_LIB_PREFIX \"%s\" JNI_LIB_SUFFIX, pname, fname);\n    retval = true;\n  }\n  return retval;\n}\n\n// check if addr is inside libjvm.so\nbool os::address_is_in_vm(address addr) {\n  static address libjvm_base_addr;\n  Dl_info dlinfo;\n\n  if (libjvm_base_addr == NULL) {\n    if (dladdr(CAST_FROM_FN_PTR(void *, os::address_is_in_vm), &dlinfo) != 0) {\n      libjvm_base_addr = (address)dlinfo.dli_fbase;\n    }\n    assert(libjvm_base_addr !=NULL, \"Cannot obtain base address for libjvm\");\n  }\n\n  if (dladdr((void *)addr, &dlinfo) != 0) {\n    if (libjvm_base_addr == (address)dlinfo.dli_fbase) return true;\n  }\n\n  return false;\n}\n\n\n#define MACH_MAXSYMLEN 256\n\nbool os::dll_address_to_function_name(address addr, char *buf,\n                                      int buflen, int *offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n  char localbuf[MACH_MAXSYMLEN];\n\n  if (dladdr((void*)addr, &dlinfo) != 0) {\n    // see if we have a matching symbol\n    if (dlinfo.dli_saddr != NULL && dlinfo.dli_sname != NULL) {\n      if (!Decoder::demangle(dlinfo.dli_sname, buf, buflen)) {\n        jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_sname);\n      }\n      if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;\n      return true;\n    }\n    // no matching symbol so try for just file info\n    if (dlinfo.dli_fname != NULL && dlinfo.dli_fbase != NULL) {\n      if (Decoder::decode((address)(addr - (address)dlinfo.dli_fbase),\n                          buf, buflen, offset, dlinfo.dli_fname)) {\n         return true;\n      }\n    }\n\n    // Handle non-dynamic manually:\n    if (dlinfo.dli_fbase != NULL &&\n        Decoder::decode(addr, localbuf, MACH_MAXSYMLEN, offset,\n                        dlinfo.dli_fbase)) {\n      if (!Decoder::demangle(localbuf, buf, buflen)) {\n        jio_snprintf(buf, buflen, \"%s\", localbuf);\n      }\n      return true;\n    }\n  }\n  buf[0] = '\\0';\n  if (offset != NULL) *offset = -1;\n  return false;\n}\n\n// ported from solaris version\nbool os::dll_address_to_library_name(address addr, char* buf,\n                                     int buflen, int* offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n\n  if (dladdr((void*)addr, &dlinfo) != 0) {\n    if (dlinfo.dli_fname != NULL) {\n      jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL && offset != NULL) {\n      *offset = addr - (address)dlinfo.dli_fbase;\n    }\n    return true;\n  }\n\n  buf[0] = '\\0';\n  if (offset) *offset = -1;\n  return false;\n}\n\n// Loads .dll/.so and\n// in case of error it checks if .dll/.so was built for the\n// same architecture as Hotspot is running on\n\n#ifdef __APPLE__\nvoid * os::dll_load(const char *filename, char *ebuf, int ebuflen) {\n  void * result= ::dlopen(filename, RTLD_LAZY);\n  if (result != NULL) {\n    // Successful loading\n    return result;\n  }\n\n  // Read system error message into ebuf\n  ::strncpy(ebuf, ::dlerror(), ebuflen-1);\n  ebuf[ebuflen-1]='\\0';\n\n  return NULL;\n}\n#else\nvoid * os::dll_load(const char *filename, char *ebuf, int ebuflen)\n{\n  void * result= ::dlopen(filename, RTLD_LAZY);\n  if (result != NULL) {\n    // Successful loading\n    return result;\n  }\n\n  Elf32_Ehdr elf_head;\n\n  // Read system error message into ebuf\n  // It may or may not be overwritten below\n  ::strncpy(ebuf, ::dlerror(), ebuflen-1);\n  ebuf[ebuflen-1]='\\0';\n  int diag_msg_max_length=ebuflen-strlen(ebuf);\n  char* diag_msg_buf=ebuf+strlen(ebuf);\n\n  if (diag_msg_max_length==0) {\n    // No more space in ebuf for additional diagnostics message\n    return NULL;\n  }\n\n\n  int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);\n\n  if (file_descriptor < 0) {\n    // Can't open library, report dlerror() message\n    return NULL;\n  }\n\n  bool failed_to_read_elf_head=\n    (sizeof(elf_head)!=\n        (::read(file_descriptor, &elf_head,sizeof(elf_head)))) ;\n\n  ::close(file_descriptor);\n  if (failed_to_read_elf_head) {\n    // file i/o error - report dlerror() msg\n    return NULL;\n  }\n\n  typedef struct {\n    Elf32_Half  code;         // Actual value as defined in elf.h\n    Elf32_Half  compat_class; // Compatibility of archs at VM's sense\n    char        elf_class;    // 32 or 64 bit\n    char        endianess;    // MSB or LSB\n    char*       name;         // String representation\n  } arch_t;\n\n  #ifndef EM_486\n  #define EM_486          6               /* Intel 80486 */\n  #endif\n\n  #ifndef EM_MIPS_RS3_LE\n  #define EM_MIPS_RS3_LE  10              /* MIPS */\n  #endif\n\n  #ifndef EM_PPC64\n  #define EM_PPC64        21              /* PowerPC64 */\n  #endif\n\n  #ifndef EM_S390\n  #define EM_S390         22              /* IBM System/390 */\n  #endif\n\n  #ifndef EM_IA_64\n  #define EM_IA_64        50              /* HP/Intel IA-64 */\n  #endif\n\n  #ifndef EM_X86_64\n  #define EM_X86_64       62              /* AMD x86-64 */\n  #endif\n\n  static const arch_t arch_array[]={\n    {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)\"IA 64\"},\n    {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)\"AMD 64\"},\n    {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)\"Sparc v9 64\"},\n    {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)\"Power PC 32\"},\n    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)\"Power PC 64\"},\n    {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)\"ARM\"},\n    {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)\"IBM System/390\"},\n    {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)\"Alpha\"},\n    {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)\"MIPSel\"},\n    {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)\"MIPS\"},\n    {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)\"PARISC\"},\n    {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)\"M68k\"}\n  };\n\n  #if  (defined IA32)\n    static  Elf32_Half running_arch_code=EM_386;\n  #elif   (defined AMD64)\n    static  Elf32_Half running_arch_code=EM_X86_64;\n  #elif  (defined IA64)\n    static  Elf32_Half running_arch_code=EM_IA_64;\n  #elif  (defined __sparc) && (defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARCV9;\n  #elif  (defined __sparc) && (!defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARC;\n  #elif  (defined __powerpc64__)\n    static  Elf32_Half running_arch_code=EM_PPC64;\n  #elif  (defined __powerpc__)\n    static  Elf32_Half running_arch_code=EM_PPC;\n  #elif  (defined ARM)\n    static  Elf32_Half running_arch_code=EM_ARM;\n  #elif  (defined S390)\n    static  Elf32_Half running_arch_code=EM_S390;\n  #elif  (defined ALPHA)\n    static  Elf32_Half running_arch_code=EM_ALPHA;\n  #elif  (defined MIPSEL)\n    static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;\n  #elif  (defined PARISC)\n    static  Elf32_Half running_arch_code=EM_PARISC;\n  #elif  (defined MIPS)\n    static  Elf32_Half running_arch_code=EM_MIPS;\n  #elif  (defined M68K)\n    static  Elf32_Half running_arch_code=EM_68K;\n  #else\n    #error Method os::dll_load requires that one of following is defined:\\\n         IA32, AMD64, IA64, __sparc, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K\n  #endif\n\n  // Identify compatability class for VM's architecture and library's architecture\n  // Obtain string descriptions for architectures\n\n  arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};\n  int running_arch_index=-1;\n\n  for (unsigned int i=0 ; i < ARRAY_SIZE(arch_array) ; i++ ) {\n    if (running_arch_code == arch_array[i].code) {\n      running_arch_index    = i;\n    }\n    if (lib_arch.code == arch_array[i].code) {\n      lib_arch.compat_class = arch_array[i].compat_class;\n      lib_arch.name         = arch_array[i].name;\n    }\n  }\n\n  assert(running_arch_index != -1,\n    \"Didn't find running architecture code (running_arch_code) in arch_array\");\n  if (running_arch_index == -1) {\n    // Even though running architecture detection failed\n    // we may still continue with reporting dlerror() message\n    return NULL;\n  }\n\n  if (lib_arch.endianess != arch_array[running_arch_index].endianess) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n    return NULL;\n  }\n\n#ifndef S390\n  if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n    return NULL;\n  }\n#endif // !S390\n\n  if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {\n    if ( lib_arch.name!=NULL ) {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n        \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n        lib_arch.name, arch_array[running_arch_index].name);\n    } else {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n      \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n        lib_arch.code,\n        arch_array[running_arch_index].name);\n    }\n  }\n\n  return NULL;\n}\n#endif /* !__APPLE__ */\n\nvoid* os::get_default_process_handle() {\n#ifdef __APPLE__\n  // MacOS X needs to use RTLD_FIRST instead of RTLD_LAZY\n  // to avoid finding unexpected symbols on second (or later)\n  // loads of a library.\n  return (void*)::dlopen(NULL, RTLD_FIRST);\n#else\n  return (void*)::dlopen(NULL, RTLD_LAZY);\n#endif\n}\n\n// XXX: Do we need a lock around this as per Linux?\nvoid* os::dll_lookup(void* handle, const char* name) {\n  return dlsym(handle, name);\n}\n\n\nstatic bool _print_ascii_file(const char* filename, outputStream* st) {\n  int fd = ::open(filename, O_RDONLY);\n  if (fd == -1) {\n     return false;\n  }\n\n  char buf[32];\n  int bytes;\n  while ((bytes = ::read(fd, buf, sizeof(buf))) > 0) {\n    st->print_raw(buf, bytes);\n  }\n\n  ::close(fd);\n\n  return true;\n}\n\nvoid os::print_dll_info(outputStream *st) {\n  st->print_cr(\"Dynamic libraries:\");\n#ifdef RTLD_DI_LINKMAP\n  Dl_info dli;\n  void *handle;\n  Link_map *map;\n  Link_map *p;\n\n  if (dladdr(CAST_FROM_FN_PTR(void *, os::print_dll_info), &dli) == 0 ||\n      dli.dli_fname == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n  handle = dlopen(dli.dli_fname, RTLD_LAZY);\n  if (handle == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n  dlinfo(handle, RTLD_DI_LINKMAP, &map);\n  if (map == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n\n  while (map->l_prev != NULL)\n    map = map->l_prev;\n\n  while (map != NULL) {\n    st->print_cr(PTR_FORMAT \" \\t%s\", map->l_addr, map->l_name);\n    map = map->l_next;\n  }\n\n  dlclose(handle);\n#elif defined(__APPLE__)\n  uint32_t count;\n  uint32_t i;\n\n  count = _dyld_image_count();\n  for (i = 1; i < count; i++) {\n    const char *name = _dyld_get_image_name(i);\n    intptr_t slide = _dyld_get_image_vmaddr_slide(i);\n    st->print_cr(PTR_FORMAT \" \\t%s\", slide, name);\n  }\n#else\n  st->print_cr(\"Error: Cannot print dynamic libraries.\");\n#endif\n}\n\nvoid os::print_os_info_brief(outputStream* st) {\n  st->print(\"Bsd\");\n\n  os::Posix::print_uname_info(st);\n}\n\nvoid os::print_os_info(outputStream* st) {\n  st->print(\"OS:\");\n  st->print(\"Bsd\");\n\n  os::Posix::print_uname_info(st);\n\n  os::Posix::print_rlimit_info(st);\n\n  os::Posix::print_load_average(st);\n}\n\nvoid os::pd_print_cpu_info(outputStream* st) {\n  // Nothing to do for now.\n}\n\nvoid os::print_memory_info(outputStream* st) {\n\n  st->print(\"Memory:\");\n  st->print(\" %dk page\", os::vm_page_size()>>10);\n\n  st->print(\", physical \" UINT64_FORMAT \"k\",\n            os::physical_memory() >> 10);\n  st->print(\"(\" UINT64_FORMAT \"k free)\",\n            os::available_memory() >> 10);\n  st->cr();\n\n  // meminfo\n  st->print(\"\\n/proc/meminfo:\\n\");\n  _print_ascii_file(\"/proc/meminfo\", st);\n  st->cr();\n}\n\nvoid os::print_siginfo(outputStream* st, void* siginfo) {\n  const siginfo_t* si = (const siginfo_t*)siginfo;\n\n  os::Posix::print_siginfo_brief(st, si);\n\n  if (si && (si->si_signo == SIGBUS || si->si_signo == SIGSEGV) &&\n      UseSharedSpaces) {\n    FileMapInfo* mapinfo = FileMapInfo::current_info();\n    if (mapinfo->is_in_shared_space(si->si_addr)) {\n      st->print(\"\\n\\nError accessing class data sharing archive.\"   \\\n                \" Mapped file inaccessible during execution, \"      \\\n                \" possible disk/network problem.\");\n    }\n  }\n  st->cr();\n}\n\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen);\n\nvoid os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n  st->print_cr(\"Signal Handlers:\");\n  print_signal_handler(st, SIGSEGV, buf, buflen);\n  print_signal_handler(st, SIGBUS , buf, buflen);\n  print_signal_handler(st, SIGFPE , buf, buflen);\n  print_signal_handler(st, SIGPIPE, buf, buflen);\n  print_signal_handler(st, SIGXFSZ, buf, buflen);\n  print_signal_handler(st, SIGILL , buf, buflen);\n  print_signal_handler(st, INTERRUPT_SIGNAL, buf, buflen);\n  print_signal_handler(st, SR_signum, buf, buflen);\n  print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n  print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n}\n\nstatic char saved_jvm_path[MAXPATHLEN] = {0};\n\n// Find the full path to the current module, libjvm\nvoid os::jvm_path(char *buf, jint buflen) {\n  // Error checking.\n  if (buflen < MAXPATHLEN) {\n    assert(false, \"must use a large-enough buffer\");\n    buf[0] = '\\0';\n    return;\n  }\n  // Lazy resolve the path to current module.\n  if (saved_jvm_path[0] != 0) {\n    strcpy(buf, saved_jvm_path);\n    return;\n  }\n\n  char dli_fname[MAXPATHLEN];\n  bool ret = dll_address_to_library_name(\n                CAST_FROM_FN_PTR(address, os::jvm_path),\n                dli_fname, sizeof(dli_fname), NULL);\n  assert(ret, \"cannot locate libjvm\");\n  char *rp = NULL;\n  if (ret && dli_fname[0] != '\\0') {\n    rp = realpath(dli_fname, buf);\n  }\n  if (rp == NULL)\n    return;\n\n  if (Arguments::created_by_gamma_launcher()) {\n    // Support for the gamma launcher.  Typical value for buf is\n    // \"<JAVA_HOME>/jre/lib/<arch>/<vmtype>/libjvm\".  If \"/jre/lib/\" appears at\n    // the right place in the string, then assume we are installed in a JDK and\n    // we're done.  Otherwise, check for a JAVA_HOME environment variable and\n    // construct a path to the JVM being overridden.\n\n    const char *p = buf + strlen(buf) - 1;\n    for (int count = 0; p > buf && count < 5; ++count) {\n      for (--p; p > buf && *p != '/'; --p)\n        /* empty */ ;\n    }\n\n    if (strncmp(p, \"/jre/lib/\", 9) != 0) {\n      // Look for JAVA_HOME in the environment.\n      char* java_home_var = ::getenv(\"JAVA_HOME\");\n      if (java_home_var != NULL && java_home_var[0] != 0) {\n        char* jrelib_p;\n        int len;\n\n        // Check the current module name \"libjvm\"\n        p = strrchr(buf, '/');\n        assert(strstr(p, \"/libjvm\") == p, \"invalid library name\");\n\n        rp = realpath(java_home_var, buf);\n        if (rp == NULL)\n          return;\n\n        // determine if this is a legacy image or modules image\n        // modules image doesn't have \"jre\" subdirectory\n        len = strlen(buf);\n        assert(len < buflen, \"Ran out of buffer space\");\n        jrelib_p = buf + len;\n\n        // Add the appropriate library subdir\n        snprintf(jrelib_p, buflen-len, \"/jre/lib\");\n        if (0 != access(buf, F_OK)) {\n          snprintf(jrelib_p, buflen-len, \"/lib\");\n        }\n\n        // Add the appropriate client or server subdir\n        len = strlen(buf);\n        jrelib_p = buf + len;\n        snprintf(jrelib_p, buflen-len, \"/%s\", COMPILER_VARIANT);\n        if (0 != access(buf, F_OK)) {\n          snprintf(jrelib_p, buflen-len, \"\");\n        }\n\n        // If the path exists within JAVA_HOME, add the JVM library name\n        // to complete the path to JVM being overridden.  Otherwise fallback\n        // to the path to the current library.\n        if (0 == access(buf, F_OK)) {\n          // Use current module name \"libjvm\"\n          len = strlen(buf);\n          snprintf(buf + len, buflen-len, \"/libjvm%s\", JNI_LIB_SUFFIX);\n        } else {\n          // Fall back to path of current library\n          rp = realpath(dli_fname, buf);\n          if (rp == NULL)\n            return;\n        }\n      }\n    }\n  }\n\n  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n}\n\nvoid os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n  // no prefix required, not even \"_\"\n}\n\nvoid os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n  // no suffix required\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// sun.misc.Signal support\n\nstatic volatile jint sigint_count = 0;\n\nstatic void\nUserHandler(int sig, void *siginfo, void *context) {\n  // 4511530 - sem_post is serialized and handled by the manager thread. When\n  // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We\n  // don't want to flood the manager thread with sem_post requests.\n  if (sig == SIGINT && Atomic::add(1, &sigint_count) > 1)\n      return;\n\n  // Ctrl-C is pressed during error reporting, likely because the error\n  // handler fails to abort. Let VM die immediately.\n  if (sig == SIGINT && is_error_reported()) {\n     os::die();\n  }\n\n  os::signal_notify(sig);\n}\n\nvoid* os::user_handler() {\n  return CAST_FROM_FN_PTR(void*, UserHandler);\n}\n\nextern \"C\" {\n  typedef void (*sa_handler_t)(int);\n  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n}\n\nvoid* os::signal(int signal_number, void* handler) {\n  struct sigaction sigAct, oldSigAct;\n\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n\n  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n    // -1 means registration failed\n    return (void *)-1;\n  }\n\n  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n}\n\nvoid os::signal_raise(int signal_number) {\n  ::raise(signal_number);\n}\n\n/*\n * The following code is moved from os.cpp for making this\n * code platform specific, which it is by its very nature.\n */\n\n// Will be modified when max signal is changed to be dynamic\nint os::sigexitnum_pd() {\n  return NSIG;\n}\n\n// a counter for each possible signal value\nstatic volatile jint pending_signals[NSIG+1] = { 0 };\n\n// Bsd(POSIX) specific hand shaking semaphore.\n#ifdef __APPLE__\ntypedef semaphore_t os_semaphore_t;\n#define SEM_INIT(sem, value)    semaphore_create(mach_task_self(), &sem, SYNC_POLICY_FIFO, value)\n#define SEM_WAIT(sem)           semaphore_wait(sem)\n#define SEM_POST(sem)           semaphore_signal(sem)\n#define SEM_DESTROY(sem)        semaphore_destroy(mach_task_self(), sem)\n#else\ntypedef sem_t os_semaphore_t;\n#define SEM_INIT(sem, value)    sem_init(&sem, 0, value)\n#define SEM_WAIT(sem)           sem_wait(&sem)\n#define SEM_POST(sem)           sem_post(&sem)\n#define SEM_DESTROY(sem)        sem_destroy(&sem)\n#endif\n\nclass Semaphore : public StackObj {\n  public:\n    Semaphore();\n    ~Semaphore();\n    void signal();\n    void wait();\n    bool trywait();\n    bool timedwait(unsigned int sec, int nsec);\n  private:\n    jlong currenttime() const;\n    os_semaphore_t _semaphore;\n};\n\nSemaphore::Semaphore() : _semaphore(0) {\n  SEM_INIT(_semaphore, 0);\n}\n\nSemaphore::~Semaphore() {\n  SEM_DESTROY(_semaphore);\n}\n\nvoid Semaphore::signal() {\n  SEM_POST(_semaphore);\n}\n\nvoid Semaphore::wait() {\n  SEM_WAIT(_semaphore);\n}\n\njlong Semaphore::currenttime() const {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (tv.tv_sec * NANOSECS_PER_SEC) + (tv.tv_usec * 1000);\n}\n\n#ifdef __APPLE__\nbool Semaphore::trywait() {\n  return timedwait(0, 0);\n}\n\nbool Semaphore::timedwait(unsigned int sec, int nsec) {\n  kern_return_t kr = KERN_ABORTED;\n  mach_timespec_t waitspec;\n  waitspec.tv_sec = sec;\n  waitspec.tv_nsec = nsec;\n\n  jlong starttime = currenttime();\n\n  kr = semaphore_timedwait(_semaphore, waitspec);\n  while (kr == KERN_ABORTED) {\n    jlong totalwait = (sec * NANOSECS_PER_SEC) + nsec;\n\n    jlong current = currenttime();\n    jlong passedtime = current - starttime;\n\n    if (passedtime >= totalwait) {\n      waitspec.tv_sec = 0;\n      waitspec.tv_nsec = 0;\n    } else {\n      jlong waittime = totalwait - (current - starttime);\n      waitspec.tv_sec = waittime / NANOSECS_PER_SEC;\n      waitspec.tv_nsec = waittime % NANOSECS_PER_SEC;\n    }\n\n    kr = semaphore_timedwait(_semaphore, waitspec);\n  }\n\n  return kr == KERN_SUCCESS;\n}\n\n#else\n\nbool Semaphore::trywait() {\n  return sem_trywait(&_semaphore) == 0;\n}\n\nbool Semaphore::timedwait(unsigned int sec, int nsec) {\n  struct timespec ts;\n  unpackTime(&ts, false, (sec * NANOSECS_PER_SEC) + nsec);\n\n  while (1) {\n    int result = sem_timedwait(&_semaphore, &ts);\n    if (result == 0) {\n      return true;\n    } else if (errno == EINTR) {\n      continue;\n    } else if (errno == ETIMEDOUT) {\n      return false;\n    } else {\n      return false;\n    }\n  }\n}\n\n#endif // __APPLE__\n\nstatic os_semaphore_t sig_sem;\nstatic Semaphore sr_semaphore;\n\nvoid os::signal_init_pd() {\n  // Initialize signal structures\n  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n\n  // Initialize signal semaphore\n  ::SEM_INIT(sig_sem, 0);\n}\n\nvoid os::signal_notify(int sig) {\n  Atomic::inc(&pending_signals[sig]);\n  ::SEM_POST(sig_sem);\n}\n\nstatic int check_pending_signals(bool wait) {\n  Atomic::store(0, &sigint_count);\n  for (;;) {\n    for (int i = 0; i < NSIG + 1; i++) {\n      jint n = pending_signals[i];\n      if (n > 0 && n == Atomic::cmpxchg(n - 1, &pending_signals[i], n)) {\n        return i;\n      }\n    }\n    if (!wait) {\n      return -1;\n    }\n    JavaThread *thread = JavaThread::current();\n    ThreadBlockInVM tbivm(thread);\n\n    bool threadIsSuspended;\n    do {\n      thread->set_suspend_equivalent();\n      // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n      ::SEM_WAIT(sig_sem);\n\n      // were we externally suspended while we were waiting?\n      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n      if (threadIsSuspended) {\n        //\n        // The semaphore has been incremented, but while we were waiting\n        // another thread suspended us. We don't want to continue running\n        // while suspended because that would surprise the thread that\n        // suspended us.\n        //\n        ::SEM_POST(sig_sem);\n\n        thread->java_suspend_self();\n      }\n    } while (threadIsSuspended);\n  }\n}\n\nint os::signal_lookup() {\n  return check_pending_signals(false);\n}\n\nint os::signal_wait() {\n  return check_pending_signals(true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Virtual Memory\n\nint os::vm_page_size() {\n  // Seems redundant as all get out\n  assert(os::Bsd::page_size() != -1, \"must call os::init\");\n  return os::Bsd::page_size();\n}\n\n// Solaris allocates memory by pages.\nint os::vm_allocation_granularity() {\n  assert(os::Bsd::page_size() != -1, \"must call os::init\");\n  return os::Bsd::page_size();\n}\n\n// Rationale behind this function:\n//  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable\n//  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get\n//  samples for JITted code. Here we create private executable mapping over the code cache\n//  and then we can use standard (well, almost, as mapping can change) way to provide\n//  info for the reporting script by storing timestamp and location of symbol\nvoid bsd_wrap_code(char* base, size_t size) {\n  static volatile jint cnt = 0;\n\n  if (!UseOprofile) {\n    return;\n  }\n\n  char buf[PATH_MAX + 1];\n  int num = Atomic::add(1, &cnt);\n\n  snprintf(buf, PATH_MAX + 1, \"%s/hs-vm-%d-%d\",\n           os::get_temp_directory(), os::current_process_id(), num);\n  unlink(buf);\n\n  int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);\n\n  if (fd != -1) {\n    off_t rv = ::lseek(fd, size-2, SEEK_SET);\n    if (rv != (off_t)-1) {\n      if (::write(fd, \"\", 1) == 1) {\n        mmap(base, size,\n             PROT_READ|PROT_WRITE|PROT_EXEC,\n             MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);\n      }\n    }\n    ::close(fd);\n    unlink(buf);\n  }\n}\n\nstatic void warn_fail_commit_memory(char* addr, size_t size, bool exec,\n                                    int err) {\n  warning(\"INFO: os::commit_memory(\" PTR_FORMAT \", \" SIZE_FORMAT\n          \", %d) failed; error='%s' (errno=%d)\", addr, size, exec,\n          strerror(err), err);\n}\n\n// NOTE: Bsd kernel does not really reserve the pages for us.\n//       All it does is to check if there are enough free pages\n//       left at the time of mmap(). This could be a potential\n//       problem.\nbool os::pd_commit_memory(char* addr, size_t size, bool exec) {\n  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n#ifdef __OpenBSD__\n  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD\n  if (::mprotect(addr, size, prot) == 0) {\n    return true;\n  }\n#else\n  uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,\n                                   MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n  if (res != (uintptr_t) MAP_FAILED) {\n    return true;\n  }\n#endif\n\n  // Warn about any commit errors we see in non-product builds just\n  // in case mmap() doesn't work as described on the man page.\n  NOT_PRODUCT(warn_fail_commit_memory(addr, size, exec, errno);)\n\n  return false;\n}\n\nbool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,\n                       bool exec) {\n  // alignment_hint is ignored on this OS\n  return pd_commit_memory(addr, size, exec);\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  if (!pd_commit_memory(addr, size, exec)) {\n    // add extra info in product mode for vm_exit_out_of_memory():\n    PRODUCT_ONLY(warn_fail_commit_memory(addr, size, exec, errno);)\n    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, mesg);\n  }\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size,\n                                  size_t alignment_hint, bool exec,\n                                  const char* mesg) {\n  // alignment_hint is ignored on this OS\n  pd_commit_memory_or_exit(addr, size, exec, mesg);\n}\n\nvoid os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {\n}\n\nvoid os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n  ::madvise(addr, bytes, MADV_DONTNEED);\n}\n\nvoid os::numa_make_global(char *addr, size_t bytes) {\n}\n\nvoid os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {\n}\n\nbool os::numa_topology_changed()   { return false; }\n\nsize_t os::numa_get_groups_num() {\n  return 1;\n}\n\nint os::numa_get_group_id() {\n  return 0;\n}\n\nsize_t os::numa_get_leaf_groups(int *ids, size_t size) {\n  if (size > 0) {\n    ids[0] = 0;\n    return 1;\n  }\n  return 0;\n}\n\nbool os::get_page_info(char *start, page_info* info) {\n  return false;\n}\n\nchar *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {\n  return end;\n}\n\n\nbool os::pd_uncommit_memory(char* addr, size_t size) {\n#ifdef __OpenBSD__\n  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD\n  return ::mprotect(addr, size, PROT_NONE) == 0;\n#else\n  uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,\n                MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n  return res  != (uintptr_t) MAP_FAILED;\n#endif\n}\n\nbool os::pd_create_stack_guard_pages(char* addr, size_t size) {\n  return os::commit_memory(addr, size, !ExecMem);\n}\n\n// If this is a growable mapping, remove the guard pages entirely by\n// munmap()ping them.  If not, just call uncommit_memory().\nbool os::remove_stack_guard_pages(char* addr, size_t size) {\n  return os::uncommit_memory(addr, size);\n}\n\nstatic address _highest_vm_reserved_address = NULL;\n\n// If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory\n// at 'requested_addr'. If there are existing memory mappings at the same\n// location, however, they will be overwritten. If 'fixed' is false,\n// 'requested_addr' is only treated as a hint, the return value may or\n// may not start from the requested address. Unlike Bsd mmap(), this\n// function returns NULL to indicate failure.\nstatic char* anon_mmap(char* requested_addr, size_t bytes, bool fixed) {\n  char * addr;\n  int flags;\n\n  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n  if (fixed) {\n    assert((uintptr_t)requested_addr % os::Bsd::page_size() == 0, \"unaligned address\");\n    flags |= MAP_FIXED;\n  }\n\n  // Map reserved/uncommitted pages PROT_NONE so we fail early if we\n  // touch an uncommitted page. Otherwise, the read/write might\n  // succeed if we have enough swap space to back the physical page.\n  addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,\n                       flags, -1, 0);\n\n  if (addr != MAP_FAILED) {\n    // anon_mmap() should only get called during VM initialization,\n    // don't need lock (actually we can skip locking even it can be called\n    // from multiple threads, because _highest_vm_reserved_address is just a\n    // hint about the upper limit of non-stack memory regions.)\n    if ((address)addr + bytes > _highest_vm_reserved_address) {\n      _highest_vm_reserved_address = (address)addr + bytes;\n    }\n  }\n\n  return addr == MAP_FAILED ? NULL : addr;\n}\n\n// Don't update _highest_vm_reserved_address, because there might be memory\n// regions above addr + size. If so, releasing a memory region only creates\n// a hole in the address space, it doesn't help prevent heap-stack collision.\n//\nstatic int anon_munmap(char * addr, size_t size) {\n  return ::munmap(addr, size) == 0;\n}\n\nchar* os::pd_reserve_memory(size_t bytes, char* requested_addr,\n                         size_t alignment_hint) {\n  return anon_mmap(requested_addr, bytes, (requested_addr != NULL));\n}\n\nbool os::pd_release_memory(char* addr, size_t size) {\n  return anon_munmap(addr, size);\n}\n\nstatic bool bsd_mprotect(char* addr, size_t size, int prot) {\n  // Bsd wants the mprotect address argument to be page aligned.\n  char* bottom = (char*)align_size_down((intptr_t)addr, os::Bsd::page_size());\n\n  // According to SUSv3, mprotect() should only be used with mappings\n  // established by mmap(), and mmap() always maps whole pages. Unaligned\n  // 'addr' likely indicates problem in the VM (e.g. trying to change\n  // protection of malloc'ed or statically allocated memory). Check the\n  // caller if you hit this assert.\n  assert(addr == bottom, \"sanity check\");\n\n  size = align_size_up(pointer_delta(addr, bottom, 1) + size, os::Bsd::page_size());\n  return ::mprotect(bottom, size, prot) == 0;\n}\n\n// Set protections specified\nbool os::protect_memory(char* addr, size_t bytes, ProtType prot,\n                        bool is_committed) {\n  unsigned int p = 0;\n  switch (prot) {\n  case MEM_PROT_NONE: p = PROT_NONE; break;\n  case MEM_PROT_READ: p = PROT_READ; break;\n  case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;\n  case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;\n  default:\n    ShouldNotReachHere();\n  }\n  // is_committed is unused.\n  return bsd_mprotect(addr, bytes, p);\n}\n\nbool os::guard_memory(char* addr, size_t size) {\n  return bsd_mprotect(addr, size, PROT_NONE);\n}\n\nbool os::unguard_memory(char* addr, size_t size) {\n  return bsd_mprotect(addr, size, PROT_READ|PROT_WRITE);\n}\n\nbool os::Bsd::hugetlbfs_sanity_check(bool warn, size_t page_size) {\n  return false;\n}\n\n// Large page support\n\nstatic size_t _large_page_size = 0;\n\nvoid os::large_page_init() {\n}\n\n\nchar* os::reserve_memory_special(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  fatal(\"This code is not used or maintained.\");\n\n  // \"exec\" is passed in but not used.  Creating the shared image for\n  // the code cache doesn't have an SHM_X executable permission to check.\n  assert(UseLargePages && UseSHM, \"only for SHM large pages\");\n\n  key_t key = IPC_PRIVATE;\n  char *addr;\n\n  bool warn_on_failure = UseLargePages &&\n                        (!FLAG_IS_DEFAULT(UseLargePages) ||\n                         !FLAG_IS_DEFAULT(LargePageSizeInBytes)\n                        );\n\n  // Create a large shared memory region to attach to based on size.\n  // Currently, size is the total size of the heap\n  int shmid = shmget(key, bytes, IPC_CREAT|SHM_R|SHM_W);\n  if (shmid == -1) {\n     // Possible reasons for shmget failure:\n     // 1. shmmax is too small for Java heap.\n     //    > check shmmax value: cat /proc/sys/kernel/shmmax\n     //    > increase shmmax value: echo \"0xffffffff\" > /proc/sys/kernel/shmmax\n     // 2. not enough large page memory.\n     //    > check available large pages: cat /proc/meminfo\n     //    > increase amount of large pages:\n     //          echo new_value > /proc/sys/vm/nr_hugepages\n     //      Note 1: different Bsd may use different name for this property,\n     //            e.g. on Redhat AS-3 it is \"hugetlb_pool\".\n     //      Note 2: it's possible there's enough physical memory available but\n     //            they are so fragmented after a long run that they can't\n     //            coalesce into large pages. Try to reserve large pages when\n     //            the system is still \"fresh\".\n     if (warn_on_failure) {\n       warning(\"Failed to reserve shared memory (errno = %d).\", errno);\n     }\n     return NULL;\n  }\n\n  // attach to the region\n  addr = (char*)shmat(shmid, req_addr, 0);\n  int err = errno;\n\n  // Remove shmid. If shmat() is successful, the actual shared memory segment\n  // will be deleted when it's detached by shmdt() or when the process\n  // terminates. If shmat() is not successful this will remove the shared\n  // segment immediately.\n  shmctl(shmid, IPC_RMID, NULL);\n\n  if ((intptr_t)addr == -1) {\n     if (warn_on_failure) {\n       warning(\"Failed to attach shared memory (errno = %d).\", err);\n     }\n     return NULL;\n  }\n\n  // The memory is committed\n  MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);\n\n  return addr;\n}\n\nbool os::release_memory_special(char* base, size_t bytes) {\n  if (MemTracker::tracking_level() > NMT_minimal) {\n    Tracker tkr = MemTracker::get_virtual_memory_release_tracker();\n    // detaching the SHM segment will also delete it, see reserve_memory_special()\n    int rslt = shmdt(base);\n    if (rslt == 0) {\n      tkr.record((address)base, bytes);\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return shmdt(base) == 0;\n  }\n}\n\nsize_t os::large_page_size() {\n  return _large_page_size;\n}\n\n// HugeTLBFS allows application to commit large page memory on demand;\n// with SysV SHM the entire memory region must be allocated as shared\n// memory.\nbool os::can_commit_large_page_memory() {\n  return UseHugeTLBFS;\n}\n\nbool os::can_execute_large_page_memory() {\n  return UseHugeTLBFS;\n}\n\n// Reserve memory at an arbitrary address, only if that area is\n// available (and not reserved for something else).\n\nchar* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {\n  const int max_tries = 10;\n  char* base[max_tries];\n  size_t size[max_tries];\n  const size_t gap = 0x000000;\n\n  // Assert only that the size is a multiple of the page size, since\n  // that's all that mmap requires, and since that's all we really know\n  // about at this low abstraction level.  If we need higher alignment,\n  // we can either pass an alignment to this method or verify alignment\n  // in one of the methods further up the call chain.  See bug 5044738.\n  assert(bytes % os::vm_page_size() == 0, \"reserving unexpected size block\");\n\n  // Repeatedly allocate blocks until the block is allocated at the\n  // right spot. Give up after max_tries. Note that reserve_memory() will\n  // automatically update _highest_vm_reserved_address if the call is\n  // successful. The variable tracks the highest memory address every reserved\n  // by JVM. It is used to detect heap-stack collision if running with\n  // fixed-stack BsdThreads. Because here we may attempt to reserve more\n  // space than needed, it could confuse the collision detecting code. To\n  // solve the problem, save current _highest_vm_reserved_address and\n  // calculate the correct value before return.\n  address old_highest = _highest_vm_reserved_address;\n\n  // Bsd mmap allows caller to pass an address as hint; give it a try first,\n  // if kernel honors the hint then we can return immediately.\n  char * addr = anon_mmap(requested_addr, bytes, false);\n  if (addr == requested_addr) {\n     return requested_addr;\n  }\n\n  if (addr != NULL) {\n     // mmap() is successful but it fails to reserve at the requested address\n     anon_munmap(addr, bytes);\n  }\n\n  int i;\n  for (i = 0; i < max_tries; ++i) {\n    base[i] = reserve_memory(bytes);\n\n    if (base[i] != NULL) {\n      // Is this the block we wanted?\n      if (base[i] == requested_addr) {\n        size[i] = bytes;\n        break;\n      }\n\n      // Does this overlap the block we wanted? Give back the overlapped\n      // parts and try again.\n\n      size_t top_overlap = requested_addr + (bytes + gap) - base[i];\n      if (top_overlap >= 0 && top_overlap < bytes) {\n        unmap_memory(base[i], top_overlap);\n        base[i] += top_overlap;\n        size[i] = bytes - top_overlap;\n      } else {\n        size_t bottom_overlap = base[i] + bytes - requested_addr;\n        if (bottom_overlap >= 0 && bottom_overlap < bytes) {\n          unmap_memory(requested_addr, bottom_overlap);\n          size[i] = bytes - bottom_overlap;\n        } else {\n          size[i] = bytes;\n        }\n      }\n    }\n  }\n\n  // Give back the unused reserved pieces.\n\n  for (int j = 0; j < i; ++j) {\n    if (base[j] != NULL) {\n      unmap_memory(base[j], size[j]);\n    }\n  }\n\n  if (i < max_tries) {\n    _highest_vm_reserved_address = MAX2(old_highest, (address)requested_addr + bytes);\n    return requested_addr;\n  } else {\n    _highest_vm_reserved_address = old_highest;\n    return NULL;\n  }\n}\n\nsize_t os::read(int fd, void *buf, unsigned int nBytes) {\n  RESTARTABLE_RETURN_INT(::read(fd, buf, nBytes));\n}\n\n// TODO-FIXME: reconcile Solaris' os::sleep with the bsd variation.\n// Solaris uses poll(), bsd uses park().\n// Poll() is likely a better choice, assuming that Thread.interrupt()\n// generates a SIGUSRx signal. Note that SIGUSR1 can interfere with\n// SIGSEGV, see 4355769.\n\nint os::sleep(Thread* thread, jlong millis, bool interruptible) {\n  assert(thread == Thread::current(),  \"thread consistency check\");\n\n  ParkEvent * const slp = thread->_SleepEvent ;\n  slp->reset() ;\n  OrderAccess::fence() ;\n\n  if (interruptible) {\n    jlong prevtime = javaTimeNanos();\n\n    for (;;) {\n      if (os::is_interrupted(thread, true)) {\n        return OS_INTRPT;\n      }\n\n      jlong newtime = javaTimeNanos();\n\n      if (newtime - prevtime < 0) {\n        // time moving backwards, should only happen if no monotonic clock\n        // not a guarantee() because JVM should not abort on kernel/glibc bugs\n        assert(!Bsd::supports_monotonic_clock(), \"time moving backwards\");\n      } else {\n        millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n      }\n\n      if(millis <= 0) {\n        return OS_OK;\n      }\n\n      prevtime = newtime;\n\n      {\n        assert(thread->is_Java_thread(), \"sanity check\");\n        JavaThread *jt = (JavaThread *) thread;\n        ThreadBlockInVM tbivm(jt);\n        OSThreadWaitState osts(jt->osthread(), false /* not Object.wait() */);\n\n        jt->set_suspend_equivalent();\n        // cleared by handle_special_suspend_equivalent_condition() or\n        // java_suspend_self() via check_and_wait_while_suspended()\n\n        slp->park(millis);\n\n        // were we externally suspended while we were waiting?\n        jt->check_and_wait_while_suspended();\n      }\n    }\n  } else {\n    OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n    jlong prevtime = javaTimeNanos();\n\n    for (;;) {\n      // It'd be nice to avoid the back-to-back javaTimeNanos() calls on\n      // the 1st iteration ...\n      jlong newtime = javaTimeNanos();\n\n      if (newtime - prevtime < 0) {\n        // time moving backwards, should only happen if no monotonic clock\n        // not a guarantee() because JVM should not abort on kernel/glibc bugs\n        assert(!Bsd::supports_monotonic_clock(), \"time moving backwards\");\n      } else {\n        millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n      }\n\n      if(millis <= 0) break ;\n\n      prevtime = newtime;\n      slp->park(millis);\n    }\n    return OS_OK ;\n  }\n}\n\nvoid os::naked_short_sleep(jlong ms) {\n  struct timespec req;\n\n  assert(ms < 1000, \"Un-interruptable sleep, short time use only\");\n  req.tv_sec = 0;\n  if (ms > 0) {\n    req.tv_nsec = (ms % 1000) * 1000000;\n  }\n  else {\n    req.tv_nsec = 1;\n  }\n\n  nanosleep(&req, NULL);\n\n  return;\n}\n\n// Sleep forever; naked call to OS-specific sleep; use with CAUTION\nvoid os::infinite_sleep() {\n  while (true) {    // sleep forever ...\n    ::sleep(100);   // ... 100 seconds at a time\n  }\n}\n\n// Used to convert frequent JVM_Yield() to nops\nbool os::dont_yield() {\n  return DontYieldALot;\n}\n\nvoid os::yield() {\n  sched_yield();\n}\n\nos::YieldResult os::NakedYield() { sched_yield(); return os::YIELD_UNKNOWN ;}\n\nvoid os::yield_all(int attempts) {\n  // Yields to all threads, including threads with lower priorities\n  // Threads on Bsd are all with same priority. The Solaris style\n  // os::yield_all() with nanosleep(1ms) is not necessary.\n  sched_yield();\n}\n\n// Called from the tight loops to possibly influence time-sharing heuristics\nvoid os::loop_breaker(int attempts) {\n  os::yield_all(attempts);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// thread priority support\n\n// Note: Normal Bsd applications are run with SCHED_OTHER policy. SCHED_OTHER\n// only supports dynamic priority, static priority must be zero. For real-time\n// applications, Bsd supports SCHED_RR which allows static priority (1-99).\n// However, for large multi-threaded applications, SCHED_RR is not only slower\n// than SCHED_OTHER, but also very unstable (my volano tests hang hard 4 out\n// of 5 runs - Sep 2005).\n//\n// The following code actually changes the niceness of kernel-thread/LWP. It\n// has an assumption that setpriority() only modifies one kernel-thread/LWP,\n// not the entire user process, and user level threads are 1:1 mapped to kernel\n// threads. It has always been the case, but could change in the future. For\n// this reason, the code should not be used as default (ThreadPriorityPolicy=0).\n// It is only used when ThreadPriorityPolicy=1 and requires root privilege.\n\n#if !defined(__APPLE__)\nint os::java_to_os_priority[CriticalPriority + 1] = {\n  19,              // 0 Entry should never be used\n\n   0,              // 1 MinPriority\n   3,              // 2\n   6,              // 3\n\n  10,              // 4\n  15,              // 5 NormPriority\n  18,              // 6\n\n  21,              // 7\n  25,              // 8\n  28,              // 9 NearMaxPriority\n\n  31,              // 10 MaxPriority\n\n  31               // 11 CriticalPriority\n};\n#else\n/* Using Mach high-level priority assignments */\nint os::java_to_os_priority[CriticalPriority + 1] = {\n   0,              // 0 Entry should never be used (MINPRI_USER)\n\n  27,              // 1 MinPriority\n  28,              // 2\n  29,              // 3\n\n  30,              // 4\n  31,              // 5 NormPriority (BASEPRI_DEFAULT)\n  32,              // 6\n\n  33,              // 7\n  34,              // 8\n  35,              // 9 NearMaxPriority\n\n  36,              // 10 MaxPriority\n\n  36               // 11 CriticalPriority\n};\n#endif\n\nstatic int prio_init() {\n  if (ThreadPriorityPolicy == 1) {\n    // Only root can raise thread priority. Don't allow ThreadPriorityPolicy=1\n    // if effective uid is not root. Perhaps, a more elegant way of doing\n    // this is to test CAP_SYS_NICE capability, but that will require libcap.so\n    if (geteuid() != 0) {\n      if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {\n        warning(\"-XX:ThreadPriorityPolicy requires root privilege on Bsd\");\n      }\n      ThreadPriorityPolicy = 0;\n    }\n  }\n  if (UseCriticalJavaThreadPriority) {\n    os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];\n  }\n  return 0;\n}\n\nOSReturn os::set_native_priority(Thread* thread, int newpri) {\n  if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) return OS_OK;\n\n#ifdef __OpenBSD__\n  // OpenBSD pthread_setprio starves low priority threads\n  return OS_OK;\n#elif defined(__FreeBSD__)\n  int ret = pthread_setprio(thread->osthread()->pthread_id(), newpri);\n#elif defined(__APPLE__) || defined(__NetBSD__)\n  struct sched_param sp;\n  int policy;\n  pthread_t self = pthread_self();\n\n  if (pthread_getschedparam(self, &policy, &sp) != 0)\n    return OS_ERR;\n\n  sp.sched_priority = newpri;\n  if (pthread_setschedparam(self, policy, &sp) != 0)\n    return OS_ERR;\n\n  return OS_OK;\n#else\n  int ret = setpriority(PRIO_PROCESS, thread->osthread()->thread_id(), newpri);\n  return (ret == 0) ? OS_OK : OS_ERR;\n#endif\n}\n\nOSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {\n  if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) {\n    *priority_ptr = java_to_os_priority[NormPriority];\n    return OS_OK;\n  }\n\n  errno = 0;\n#if defined(__OpenBSD__) || defined(__FreeBSD__)\n  *priority_ptr = pthread_getprio(thread->osthread()->pthread_id());\n#elif defined(__APPLE__) || defined(__NetBSD__)\n  int policy;\n  struct sched_param sp;\n\n  pthread_getschedparam(pthread_self(), &policy, &sp);\n  *priority_ptr = sp.sched_priority;\n#else\n  *priority_ptr = getpriority(PRIO_PROCESS, thread->osthread()->thread_id());\n#endif\n  return (*priority_ptr != -1 || errno == 0 ? OS_OK : OS_ERR);\n}\n\n// Hint to the underlying OS that a task switch would not be good.\n// Void return because it's a hint and can fail.\nvoid os::hint_no_preempt() {}\n\n////////////////////////////////////////////////////////////////////////////////\n// suspend/resume support\n\n//  the low-level signal-based suspend/resume support is a remnant from the\n//  old VM-suspension that used to be for java-suspension, safepoints etc,\n//  within hotspot. Now there is a single use-case for this:\n//    - calling get_thread_pc() on the VMThread by the flat-profiler task\n//      that runs in the watcher thread.\n//  The remaining code is greatly simplified from the more general suspension\n//  code that used to be used.\n//\n//  The protocol is quite simple:\n//  - suspend:\n//      - sends a signal to the target thread\n//      - polls the suspend state of the osthread using a yield loop\n//      - target thread signal handler (SR_handler) sets suspend state\n//        and blocks in sigsuspend until continued\n//  - resume:\n//      - sets target osthread state to continue\n//      - sends signal to end the sigsuspend loop in the SR_handler\n//\n//  Note that the SR_lock plays no role in this suspend/resume protocol.\n//\n\nstatic void resume_clear_context(OSThread *osthread) {\n  osthread->set_ucontext(NULL);\n  osthread->set_siginfo(NULL);\n}\n\nstatic void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n  osthread->set_ucontext(context);\n  osthread->set_siginfo(siginfo);\n}\n\n//\n// Handler function invoked when a thread's execution is suspended or\n// resumed. We have to be careful that only async-safe functions are\n// called here (Note: most pthread functions are not async safe and\n// should be avoided.)\n//\n// Note: sigwait() is a more natural fit than sigsuspend() from an\n// interface point of view, but sigwait() prevents the signal hander\n// from being run. libpthread would get very confused by not having\n// its signal handlers run and prevents sigwait()'s use with the\n// mutex granting granting signal.\n//\n// Currently only ever called on the VMThread or JavaThread\n//\nstatic void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n  // Save and restore errno to avoid confusing native code with EINTR\n  // after sigsuspend.\n  int old_errno = errno;\n\n  Thread* thread = Thread::current();\n  OSThread* osthread = thread->osthread();\n  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n\n  os::SuspendResume::State current = osthread->sr.state();\n  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n    suspend_save_context(osthread, siginfo, context);\n\n    // attempt to switch the state, we assume we had a SUSPEND_REQUEST\n    os::SuspendResume::State state = osthread->sr.suspended();\n    if (state == os::SuspendResume::SR_SUSPENDED) {\n      sigset_t suspend_set;  // signals for sigsuspend()\n\n      // get current set of blocked signals and unblock resume signal\n      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n      sigdelset(&suspend_set, SR_signum);\n\n      sr_semaphore.signal();\n      // wait here until we are resumed\n      while (1) {\n        sigsuspend(&suspend_set);\n\n        os::SuspendResume::State result = osthread->sr.running();\n        if (result == os::SuspendResume::SR_RUNNING) {\n          sr_semaphore.signal();\n          break;\n        } else if (result != os::SuspendResume::SR_SUSPENDED) {\n          ShouldNotReachHere();\n        }\n      }\n\n    } else if (state == os::SuspendResume::SR_RUNNING) {\n      // request was cancelled, continue\n    } else {\n      ShouldNotReachHere();\n    }\n\n    resume_clear_context(osthread);\n  } else if (current == os::SuspendResume::SR_RUNNING) {\n    // request was cancelled, continue\n  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // ignore\n  } else {\n    // ignore\n  }\n\n  errno = old_errno;\n}\n\n\nstatic int SR_initialize() {\n  struct sigaction act;\n  char *s;\n  /* Get signal number to use for suspend/resume */\n  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n    int sig = ::strtol(s, 0, 10);\n    if (sig > 0 || sig < NSIG) {\n        SR_signum = sig;\n    }\n  }\n\n  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n        \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n\n  sigemptyset(&SR_sigset);\n  sigaddset(&SR_sigset, SR_signum);\n\n  /* Set up signal handler for suspend/resume */\n  act.sa_flags = SA_RESTART|SA_SIGINFO;\n  act.sa_handler = (void (*)(int)) SR_handler;\n\n  // SR_signum is blocked by default.\n  // 4528190 - We also need to block pthread restart signal (32 on all\n  // supported Bsd platforms). Note that BsdThreads need to block\n  // this signal for all threads to work properly. So we don't have\n  // to use hard-coded signal number when setting up the mask.\n  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n\n  if (sigaction(SR_signum, &act, 0) == -1) {\n    return -1;\n  }\n\n  // Save signal flag\n  os::Bsd::set_our_sigflags(SR_signum, act.sa_flags);\n  return 0;\n}\n\nstatic int sr_notify(OSThread* osthread) {\n  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n  assert_status(status == 0, status, \"pthread_kill\");\n  return status;\n}\n\n// \"Randomly\" selected value for how long we want to spin\n// before bailing out on suspending a thread, also how often\n// we send a signal to a thread we want to resume\nstatic const int RANDOMLY_LARGE_INTEGER = 1000000;\nstatic const int RANDOMLY_LARGE_INTEGER2 = 100;\n\n// returns true on success and false on error - really an error is fatal\n// but this seems the normal response to library errors\nstatic bool do_suspend(OSThread* osthread) {\n  assert(osthread->sr.is_running(), \"thread should be running\");\n  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n\n  // mark as suspended and send signal\n  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n    // failed to switch, state wasn't running?\n    ShouldNotReachHere();\n    return false;\n  }\n\n  if (sr_notify(osthread) != 0) {\n    ShouldNotReachHere();\n  }\n\n  // managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n  while (true) {\n    if (sr_semaphore.timedwait(0, 2 * NANOSECS_PER_MILLISEC)) {\n      break;\n    } else {\n      // timeout\n      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n      if (cancelled == os::SuspendResume::SR_RUNNING) {\n        return false;\n      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n        // make sure that we consume the signal on the semaphore as well\n        sr_semaphore.wait();\n        break;\n      } else {\n        ShouldNotReachHere();\n        return false;\n      }\n    }\n  }\n\n  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n  return true;\n}\n\nstatic void do_resume(OSThread* osthread) {\n  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n\n  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // failed to switch to WAKEUP_REQUEST\n    ShouldNotReachHere();\n    return;\n  }\n\n  while (true) {\n    if (sr_notify(osthread) == 0) {\n      if (sr_semaphore.timedwait(0, 2 * NANOSECS_PER_MILLISEC)) {\n        if (osthread->sr.is_running()) {\n          return;\n        }\n      }\n    } else {\n      ShouldNotReachHere();\n    }\n  }\n\n  guarantee(osthread->sr.is_running(), \"Must be running!\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// interrupt support\n\nvoid os::interrupt(Thread* thread) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  if (!osthread->interrupted()) {\n    osthread->set_interrupted(true);\n    // More than one thread can get here with the same value of osthread,\n    // resulting in multiple notifications.  We do, however, want the store\n    // to interrupted() to be visible to other threads before we execute unpark().\n    OrderAccess::fence();\n    ParkEvent * const slp = thread->_SleepEvent ;\n    if (slp != NULL) slp->unpark() ;\n  }\n\n  // For JSR166. Unpark even if interrupt status already was set\n  if (thread->is_Java_thread())\n    ((JavaThread*)thread)->parker()->unpark();\n\n  ParkEvent * ev = thread->_ParkEvent ;\n  if (ev != NULL) ev->unpark() ;\n\n}\n\nbool os::is_interrupted(Thread* thread, bool clear_interrupted) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  bool interrupted = osthread->interrupted();\n\n  if (interrupted && clear_interrupted) {\n    osthread->set_interrupted(false);\n    // consider thread->_SleepEvent->reset() ... optional optimization\n  }\n\n  return interrupted;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// signal handling (except suspend/resume)\n\n// This routine may be used by user applications as a \"hook\" to catch signals.\n// The user-defined signal handler must pass unrecognized signals to this\n// routine, and if it returns true (non-zero), then the signal handler must\n// return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n// routine will never retun false (zero), but instead will execute a VM panic\n// routine kill the process.\n//\n// If this routine returns false, it is OK to call it again.  This allows\n// the user-defined signal handler to perform checks either before or after\n// the VM performs its own checks.  Naturally, the user code would be making\n// a serious error if it tried to handle an exception (such as a null check\n// or breakpoint) that the VM was generating for its own correct operation.\n//\n// This routine may recognize any of the following kinds of signals:\n//    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n// It should be consulted by handlers for any of those signals.\n//\n// The caller of this routine must pass in the three arguments supplied\n// to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n// field of the structure passed to sigaction().  This routine assumes that\n// the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n//\n// Note that the VM will print warnings if it detects conflicting signal\n// handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n//\nextern \"C\" JNIEXPORT int\nJVM_handle_bsd_signal(int signo, siginfo_t* siginfo,\n                        void* ucontext, int abort_if_unrecognized);\n\nvoid signalHandler(int sig, siginfo_t* info, void* uc) {\n  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n  int orig_errno = errno;  // Preserve errno value over signal handler.\n  JVM_handle_bsd_signal(sig, info, uc, true);\n  errno = orig_errno;\n}\n\n\n// This boolean allows users to forward their own non-matching signals\n// to JVM_handle_bsd_signal, harmlessly.\nbool os::Bsd::signal_handlers_are_installed = false;\n\n// For signal-chaining\nstruct sigaction os::Bsd::sigact[MAXSIGNUM];\nunsigned int os::Bsd::sigs = 0;\nbool os::Bsd::libjsig_is_loaded = false;\ntypedef struct sigaction *(*get_signal_t)(int);\nget_signal_t os::Bsd::get_signal_action = NULL;\n\nstruct sigaction* os::Bsd::get_chained_signal_action(int sig) {\n  struct sigaction *actp = NULL;\n\n  if (libjsig_is_loaded) {\n    // Retrieve the old signal handler from libjsig\n    actp = (*get_signal_action)(sig);\n  }\n  if (actp == NULL) {\n    // Retrieve the preinstalled signal handler from jvm\n    actp = get_preinstalled_handler(sig);\n  }\n\n  return actp;\n}\n\nstatic bool call_chained_handler(struct sigaction *actp, int sig,\n                                 siginfo_t *siginfo, void *context) {\n  // Call the old signal handler\n  if (actp->sa_handler == SIG_DFL) {\n    // It's more reasonable to let jvm treat it as an unexpected exception\n    // instead of taking the default action.\n    return false;\n  } else if (actp->sa_handler != SIG_IGN) {\n    if ((actp->sa_flags & SA_NODEFER) == 0) {\n      // automaticlly block the signal\n      sigaddset(&(actp->sa_mask), sig);\n    }\n\n    sa_handler_t hand;\n    sa_sigaction_t sa;\n    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n    // retrieve the chained handler\n    if (siginfo_flag_set) {\n      sa = actp->sa_sigaction;\n    } else {\n      hand = actp->sa_handler;\n    }\n\n    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n      actp->sa_handler = SIG_DFL;\n    }\n\n    // try to honor the signal mask\n    sigset_t oset;\n    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n\n    // call into the chained handler\n    if (siginfo_flag_set) {\n      (*sa)(sig, siginfo, context);\n    } else {\n      (*hand)(sig);\n    }\n\n    // restore the signal mask\n    pthread_sigmask(SIG_SETMASK, &oset, 0);\n  }\n  // Tell jvm's signal handler the signal is taken care of.\n  return true;\n}\n\nbool os::Bsd::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n  bool chained = false;\n  // signal-chaining\n  if (UseSignalChaining) {\n    struct sigaction *actp = get_chained_signal_action(sig);\n    if (actp != NULL) {\n      chained = call_chained_handler(actp, sig, siginfo, context);\n    }\n  }\n  return chained;\n}\n\nstruct sigaction* os::Bsd::get_preinstalled_handler(int sig) {\n  if ((( (unsigned int)1 << sig ) & sigs) != 0) {\n    return &sigact[sig];\n  }\n  return NULL;\n}\n\nvoid os::Bsd::save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigact[sig] = oldAct;\n  sigs |= (unsigned int)1 << sig;\n}\n\n// for diagnostic\nint os::Bsd::sigflags[MAXSIGNUM];\n\nint os::Bsd::get_our_sigflags(int sig) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  return sigflags[sig];\n}\n\nvoid os::Bsd::set_our_sigflags(int sig, int flags) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = flags;\n}\n\nvoid os::Bsd::set_signal_handler(int sig, bool set_installed) {\n  // Check for overwrite.\n  struct sigaction oldAct;\n  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n\n  void* oldhand = oldAct.sa_sigaction\n                ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n                : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)signalHandler)) {\n    if (AllowUserSignalHandlers || !set_installed) {\n      // Do not overwrite; user takes responsibility to forward to us.\n      return;\n    } else if (UseSignalChaining) {\n      // save the old handler in jvm\n      save_preinstalled_handler(sig, oldAct);\n      // libjsig also interposes the sigaction() call below and saves the\n      // old sigaction on it own.\n    } else {\n      fatal(err_msg(\"Encountered unexpected pre-existing sigaction handler \"\n                    \"%#lx for signal %d.\", (long)oldhand, sig));\n    }\n  }\n\n  struct sigaction sigAct;\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_handler = SIG_DFL;\n  if (!set_installed) {\n    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n  } else {\n    sigAct.sa_sigaction = signalHandler;\n    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n  }\n#ifdef __APPLE__\n  // Needed for main thread as XNU (Mac OS X kernel) will only deliver SIGSEGV\n  // (which starts as SIGBUS) on main thread with faulting address inside \"stack+guard pages\"\n  // if the signal handler declares it will handle it on alternate stack.\n  // Notice we only declare we will handle it on alt stack, but we are not\n  // actually going to use real alt stack - this is just a workaround.\n  // Please see ux_exception.c, method catch_mach_exception_raise for details\n  // link http://www.opensource.apple.com/source/xnu/xnu-2050.18.24/bsd/uxkern/ux_exception.c\n  if (sig == SIGSEGV) {\n    sigAct.sa_flags |= SA_ONSTACK;\n  }\n#endif\n\n  // Save flags, which are set by ours\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = sigAct.sa_flags;\n\n  int ret = sigaction(sig, &sigAct, &oldAct);\n  assert(ret == 0, \"check\");\n\n  void* oldhand2  = oldAct.sa_sigaction\n                  ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n                  : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n}\n\n// install signal handlers for signals that HotSpot needs to\n// handle in order to support Java-level exception handling.\n\nvoid os::Bsd::install_signal_handlers() {\n  if (!signal_handlers_are_installed) {\n    signal_handlers_are_installed = true;\n\n    // signal-chaining\n    typedef void (*signal_setting_t)();\n    signal_setting_t begin_signal_setting = NULL;\n    signal_setting_t end_signal_setting = NULL;\n    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n    if (begin_signal_setting != NULL) {\n      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n                            dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n      libjsig_is_loaded = true;\n      assert(UseSignalChaining, \"should enable signal-chaining\");\n    }\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm is setting signal handlers\n      (*begin_signal_setting)();\n    }\n\n    set_signal_handler(SIGSEGV, true);\n    set_signal_handler(SIGPIPE, true);\n    set_signal_handler(SIGBUS, true);\n    set_signal_handler(SIGILL, true);\n    set_signal_handler(SIGFPE, true);\n    set_signal_handler(SIGXFSZ, true);\n\n#if defined(__APPLE__)\n    // In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including\n    // signals caught and handled by the JVM. To work around this, we reset the mach task\n    // signal handler that's placed on our process by CrashReporter. This disables\n    // CrashReporter-based reporting.\n    //\n    // This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes\n    // on caught fatal signals.\n    //\n    // Additionally, gdb installs both standard BSD signal handlers, and mach exception\n    // handlers. By replacing the existing task exception handler, we disable gdb's mach\n    // exception handling, while leaving the standard BSD signal handlers functional.\n    kern_return_t kr;\n    kr = task_set_exception_ports(mach_task_self(),\n        EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n        MACH_PORT_NULL,\n        EXCEPTION_STATE_IDENTITY,\n        MACHINE_THREAD_STATE);\n\n    assert(kr == KERN_SUCCESS, \"could not set mach task signal handler\");\n#endif\n\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm finishes setting signal handlers\n      (*end_signal_setting)();\n    }\n\n    // We don't activate signal checker if libjsig is in place, we trust ourselves\n    // and if UserSignalHandler is installed all bets are off\n    if (CheckJNICalls) {\n      if (libjsig_is_loaded) {\n        if (PrintJNIResolving) {\n          tty->print_cr(\"Info: libjsig is activated, all active signal checking is disabled\");\n        }\n        check_signals = false;\n      }\n      if (AllowUserSignalHandlers) {\n        if (PrintJNIResolving) {\n          tty->print_cr(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n        }\n        check_signals = false;\n      }\n    }\n  }\n}\n\n\n/////\n// glibc on Bsd platform uses non-documented flag\n// to indicate, that some special sort of signal\n// trampoline is used.\n// We will never set this flag, and we should\n// ignore this flag in our diagnostic\n#ifdef SIGNIFICANT_SIGNAL_MASK\n#undef SIGNIFICANT_SIGNAL_MASK\n#endif\n#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)\n\nstatic const char* get_signal_handler_name(address handler,\n                                           char* buf, int buflen) {\n  int offset;\n  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n  if (found) {\n    // skip directory names\n    const char *p1, *p2;\n    p1 = buf;\n    size_t len = strlen(os::file_separator());\n    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n  } else {\n    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n  }\n  return buf;\n}\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen) {\n  struct sigaction sa;\n\n  sigaction(sig, NULL, &sa);\n\n  // See comment for SIGNIFICANT_SIGNAL_MASK define\n  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n\n  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n\n  address handler = (sa.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n\n  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n    st->print(\"SIG_DFL\");\n  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n    st->print(\"SIG_IGN\");\n  } else {\n    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n  }\n\n  st->print(\", sa_mask[0]=\");\n  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n\n  address rh = VMError::get_resetted_sighandler(sig);\n  // May be, handler was resetted by VMError?\n  if(rh != NULL) {\n    handler = rh;\n    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;\n  }\n\n  st->print(\", sa_flags=\");\n  os::Posix::print_sa_flags(st, sa.sa_flags);\n\n  // Check: is it our handler?\n  if(handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler) ||\n     handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n    // It is our signal handler\n    // check for flags, reset system-used one!\n    if((int)sa.sa_flags != os::Bsd::get_our_sigflags(sig)) {\n      st->print(\n                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n                os::Bsd::get_our_sigflags(sig));\n    }\n  }\n  st->cr();\n}\n\n\n#define DO_SIGNAL_CHECK(sig) \\\n  if (!sigismember(&check_signal_done, sig)) \\\n    os::Bsd::check_signal_handler(sig)\n\n// This method is a periodic task to check for misbehaving JNI applications\n// under CheckJNI, we can add any periodic checks here\n\nvoid os::run_periodic_checks() {\n\n  if (check_signals == false) return;\n\n  // SEGV and BUS if overridden could potentially prevent\n  // generation of hs*.log in the event of a crash, debugging\n  // such a case can be very challenging, so we absolutely\n  // check the following for a good measure:\n  DO_SIGNAL_CHECK(SIGSEGV);\n  DO_SIGNAL_CHECK(SIGILL);\n  DO_SIGNAL_CHECK(SIGFPE);\n  DO_SIGNAL_CHECK(SIGBUS);\n  DO_SIGNAL_CHECK(SIGPIPE);\n  DO_SIGNAL_CHECK(SIGXFSZ);\n\n\n  // ReduceSignalUsage allows the user to override these handlers\n  // see comments at the very top and jvm_solaris.h\n  if (!ReduceSignalUsage) {\n    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n  }\n\n  DO_SIGNAL_CHECK(SR_signum);\n  DO_SIGNAL_CHECK(INTERRUPT_SIGNAL);\n}\n\ntypedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic os_sigaction_t os_sigaction = NULL;\n\nvoid os::Bsd::check_signal_handler(int sig) {\n  char buf[O_BUFLEN];\n  address jvmHandler = NULL;\n\n\n  struct sigaction act;\n  if (os_sigaction == NULL) {\n    // only trust the default sigaction, in case it has been interposed\n    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n    if (os_sigaction == NULL) return;\n  }\n\n  os_sigaction(sig, (struct sigaction*)NULL, &act);\n\n\n  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n\n  address thisHandler = (act.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, act.sa_handler) ;\n\n\n  switch(sig) {\n  case SIGSEGV:\n  case SIGBUS:\n  case SIGFPE:\n  case SIGPIPE:\n  case SIGILL:\n  case SIGXFSZ:\n    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler);\n    break;\n\n  case SHUTDOWN1_SIGNAL:\n  case SHUTDOWN2_SIGNAL:\n  case SHUTDOWN3_SIGNAL:\n  case BREAK_SIGNAL:\n    jvmHandler = (address)user_handler();\n    break;\n\n  case INTERRUPT_SIGNAL:\n    jvmHandler = CAST_FROM_FN_PTR(address, SIG_DFL);\n    break;\n\n  default:\n    if (sig == SR_signum) {\n      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n    } else {\n      return;\n    }\n    break;\n  }\n\n  if (thisHandler != jvmHandler) {\n    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n    // Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n                    exception_name(sig, buf, O_BUFLEN));\n    }\n  } else if(os::Bsd::get_our_sigflags(sig) != 0 && (int)act.sa_flags != os::Bsd::get_our_sigflags(sig)) {\n    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:\" PTR32_FORMAT, os::Bsd::get_our_sigflags(sig));\n    tty->print_cr(\"  found:\" PTR32_FORMAT, act.sa_flags);\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n  }\n\n  // Dump all the signal\n  if (sigismember(&check_signal_done, sig)) {\n    print_signal_handlers(tty, buf, O_BUFLEN);\n  }\n}\n\nextern void report_error(char* file_name, int line_no, char* title, char* format, ...);\n\nextern bool signal_name(int signo, char* buf, size_t len);\n\nconst char* os::exception_name(int exception_code, char* buf, size_t size) {\n  if (0 < exception_code && exception_code <= SIGRTMAX) {\n    // signal\n    if (!signal_name(exception_code, buf, size)) {\n      jio_snprintf(buf, size, \"SIG%d\", exception_code);\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\n// this is called _before_ the most of global arguments have been parsed\nvoid os::init(void) {\n  char dummy;   /* used to get a guess on initial stack address */\n//  first_hrtime = gethrtime();\n\n  // With BsdThreads the JavaMain thread pid (primordial thread)\n  // is different than the pid of the java launcher thread.\n  // So, on Bsd, the launcher thread pid is passed to the VM\n  // via the sun.java.launcher.pid property.\n  // Use this property instead of getpid() if it was correctly passed.\n  // See bug 6351349.\n  pid_t java_launcher_pid = (pid_t) Arguments::sun_java_launcher_pid();\n\n  _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();\n\n  clock_tics_per_sec = CLK_TCK;\n\n  init_random(1234567);\n\n  ThreadCritical::initialize();\n\n  Bsd::set_page_size(getpagesize());\n  if (Bsd::page_size() == -1) {\n    fatal(err_msg(\"os_bsd.cpp: os::init: sysconf failed (%s)\",\n                  strerror(errno)));\n  }\n  init_page_sizes((size_t) Bsd::page_size());\n\n  Bsd::initialize_system_info();\n\n  // main_thread points to the aboriginal thread\n  Bsd::_main_thread = pthread_self();\n\n  Bsd::clock_init();\n  initial_time_count = javaTimeNanos();\n\n#ifdef __APPLE__\n  // XXXDARWIN\n  // Work around the unaligned VM callbacks in hotspot's\n  // sharedRuntime. The callbacks don't use SSE2 instructions, and work on\n  // Linux, Solaris, and FreeBSD. On Mac OS X, dyld (rightly so) enforces\n  // alignment when doing symbol lookup. To work around this, we force early\n  // binding of all symbols now, thus binding when alignment is known-good.\n  _dyld_bind_fully_image_containing_address((const void *) &os::init);\n#endif\n}\n\n// To install functions for atexit system call\nextern \"C\" {\n  static void perfMemory_exit_helper() {\n    perfMemory_exit();\n  }\n}\n\n// this is called _after_ the global arguments have been parsed\njint os::init_2(void)\n{\n  // Allocate a single page and mark it as readable for safepoint polling\n  address polling_page = (address) ::mmap(NULL, Bsd::page_size(), PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n  guarantee( polling_page != MAP_FAILED, \"os::init_2: failed to allocate polling page\" );\n\n  os::set_polling_page( polling_page );\n\n#ifndef PRODUCT\n  if(Verbose && PrintMiscellaneous)\n    tty->print(\"[SafePoint Polling address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)polling_page);\n#endif\n\n  if (!UseMembar) {\n    address mem_serialize_page = (address) ::mmap(NULL, Bsd::page_size(), PROT_READ | PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    guarantee( mem_serialize_page != MAP_FAILED, \"mmap Failed for memory serialize page\");\n    os::set_memory_serialize_page( mem_serialize_page );\n\n#ifndef PRODUCT\n    if(Verbose && PrintMiscellaneous)\n      tty->print(\"[Memory Serialize  Page address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)mem_serialize_page);\n#endif\n  }\n\n  // initialize suspend/resume support - must do this before signal_sets_init()\n  if (SR_initialize() != 0) {\n    perror(\"SR_initialize failed\");\n    return JNI_ERR;\n  }\n\n  Bsd::signal_sets_init();\n  Bsd::install_signal_handlers();\n\n  // Check minimum allowable stack size for thread creation and to initialize\n  // the java system classes, including StackOverflowError - depends on page\n  // size.  Add a page for compiler2 recursion in main thread.\n  // Add in 2*BytesPerWord times page size to account for VM stack during\n  // class initialization depending on 32 or 64 bit VM.\n  os::Bsd::min_stack_allowed = MAX2(os::Bsd::min_stack_allowed,\n            (size_t)(StackYellowPages+StackRedPages+StackShadowPages+\n                    2*BytesPerWord COMPILER2_PRESENT(+1)) * Bsd::page_size());\n\n  size_t threadStackSizeInBytes = ThreadStackSize * K;\n  if (threadStackSizeInBytes != 0 &&\n      threadStackSizeInBytes < os::Bsd::min_stack_allowed) {\n        tty->print_cr(\"\\nThe stack size specified is too small, \"\n                      \"Specify at least %dk\",\n                      os::Bsd::min_stack_allowed/ K);\n        return JNI_ERR;\n  }\n\n  // Make the stack size a multiple of the page size so that\n  // the yellow/red zones can be guarded.\n  JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,\n        vm_page_size()));\n\n  if (MaxFDLimit) {\n    // set the number of file descriptors to max. print out error\n    // if getrlimit/setrlimit fails but continue regardless.\n    struct rlimit nbr_files;\n    int status = getrlimit(RLIMIT_NOFILE, &nbr_files);\n    if (status != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode))\n        perror(\"os::init_2 getrlimit failed\");\n    } else {\n      nbr_files.rlim_cur = nbr_files.rlim_max;\n\n#ifdef __APPLE__\n      // Darwin returns RLIM_INFINITY for rlim_max, but fails with EINVAL if\n      // you attempt to use RLIM_INFINITY. As per setrlimit(2), OPEN_MAX must\n      // be used instead\n      nbr_files.rlim_cur = MIN(OPEN_MAX, nbr_files.rlim_cur);\n#endif\n\n      status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n      if (status != 0) {\n        if (PrintMiscellaneous && (Verbose || WizardMode))\n          perror(\"os::init_2 setrlimit failed\");\n      }\n    }\n  }\n\n  // at-exit methods are called in the reverse order of their registration.\n  // atexit functions are called on return from main or as a result of a\n  // call to exit(3C). There can be only 32 of these functions registered\n  // and atexit() does not set errno.\n\n  if (PerfAllowAtExitRegistration) {\n    // only register atexit functions if PerfAllowAtExitRegistration is set.\n    // atexit functions can be delayed until process exit time, which\n    // can be problematic for embedded VM situations. Embedded VMs should\n    // call DestroyJavaVM() to assure that VM resources are released.\n\n    // note: perfMemory_exit_helper atexit function may be removed in\n    // the future if the appropriate cleanup code can be added to the\n    // VM_Exit VMOperation's doit method.\n    if (atexit(perfMemory_exit_helper) != 0) {\n      warning(\"os::init2 atexit(perfMemory_exit_helper) failed\");\n    }\n  }\n\n  // initialize thread priority policy\n  prio_init();\n\n#ifdef __APPLE__\n  // dynamically link to objective c gc registration\n  void *handleLibObjc = dlopen(OBJC_LIB, RTLD_LAZY);\n  if (handleLibObjc != NULL) {\n    objc_registerThreadWithCollectorFunction = (objc_registerThreadWithCollector_t) dlsym(handleLibObjc, OBJC_GCREGISTER);\n  }\n#endif\n\n  return JNI_OK;\n}\n\n// Mark the polling page as unreadable\nvoid os::make_polling_page_unreadable(void) {\n  if( !guard_memory((char*)_polling_page, Bsd::page_size()) )\n    fatal(\"Could not disable polling page\");\n};\n\n// Mark the polling page as readable\nvoid os::make_polling_page_readable(void) {\n  if( !bsd_mprotect((char *)_polling_page, Bsd::page_size(), PROT_READ)) {\n    fatal(\"Could not enable polling page\");\n  }\n};\n\nint os::active_processor_count() {\n  return _processor_count;\n}\n\nvoid os::set_native_thread_name(const char *name) {\n#if defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_5\n  // This is only supported in Snow Leopard and beyond\n  if (name != NULL) {\n    // Add a \"Java: \" prefix to the name\n    char buf[MAXTHREADNAMESIZE];\n    snprintf(buf, sizeof(buf), \"Java: %s\", name);\n    pthread_setname_np(buf);\n  }\n#endif\n}\n\nbool os::distribute_processes(uint length, uint* distribution) {\n  // Not yet implemented.\n  return false;\n}\n\nbool os::bind_to_processor(uint processor_id) {\n  // Not yet implemented.\n  return false;\n}\n\nvoid os::SuspendedThreadTask::internal_do_task() {\n  if (do_suspend(_thread->osthread())) {\n    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n    do_task(context);\n    do_resume(_thread->osthread());\n  }\n}\n\n///\nclass PcFetcher : public os::SuspendedThreadTask {\npublic:\n  PcFetcher(Thread* thread) : os::SuspendedThreadTask(thread) {}\n  ExtendedPC result();\nprotected:\n  void do_task(const os::SuspendedThreadTaskContext& context);\nprivate:\n  ExtendedPC _epc;\n};\n\nExtendedPC PcFetcher::result() {\n  guarantee(is_done(), \"task is not done yet.\");\n  return _epc;\n}\n\nvoid PcFetcher::do_task(const os::SuspendedThreadTaskContext& context) {\n  Thread* thread = context.thread();\n  OSThread* osthread = thread->osthread();\n  if (osthread->ucontext() != NULL) {\n    _epc = os::Bsd::ucontext_get_pc((ucontext_t *) context.ucontext());\n  } else {\n    // NULL context is unexpected, double-check this is the VMThread\n    guarantee(thread->is_VM_thread(), \"can only be called for VMThread\");\n  }\n}\n\n// Suspends the target using the signal mechanism and then grabs the PC before\n// resuming the target. Used by the flat-profiler only\nExtendedPC os::get_thread_pc(Thread* thread) {\n  // Make sure that it is called by the watcher for the VMThread\n  assert(Thread::current()->is_Watcher_thread(), \"Must be watcher\");\n  assert(thread->is_VM_thread(), \"Can only be called for VMThread\");\n\n  PcFetcher fetcher(thread);\n  fetcher.run();\n  return fetcher.result();\n}\n\nint os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime)\n{\n  return pthread_cond_timedwait(_cond, _mutex, _abstime);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// debug support\n\nbool os::find(address addr, outputStream* st) {\n  Dl_info dlinfo;\n  memset(&dlinfo, 0, sizeof(dlinfo));\n  if (dladdr(addr, &dlinfo) != 0) {\n    st->print(PTR_FORMAT \": \", addr);\n    if (dlinfo.dli_sname != NULL && dlinfo.dli_saddr != NULL) {\n      st->print(\"%s+%#x\", dlinfo.dli_sname,\n                 addr - (intptr_t)dlinfo.dli_saddr);\n    } else if (dlinfo.dli_fbase != NULL) {\n      st->print(\"<offset %#x>\", addr - (intptr_t)dlinfo.dli_fbase);\n    } else {\n      st->print(\"<absolute address>\");\n    }\n    if (dlinfo.dli_fname != NULL) {\n      st->print(\" in %s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL) {\n      st->print(\" at \" PTR_FORMAT, dlinfo.dli_fbase);\n    }\n    st->cr();\n\n    if (Verbose) {\n      // decode some bytes around the PC\n      address begin = clamp_address_in_page(addr-40, addr, os::vm_page_size());\n      address end   = clamp_address_in_page(addr+40, addr, os::vm_page_size());\n      address       lowest = (address) dlinfo.dli_sname;\n      if (!lowest)  lowest = (address) dlinfo.dli_fbase;\n      if (begin < lowest)  begin = lowest;\n      Dl_info dlinfo2;\n      if (dladdr(end, &dlinfo2) != 0 && dlinfo2.dli_saddr != dlinfo.dli_saddr\n          && end > dlinfo2.dli_saddr && dlinfo2.dli_saddr > begin)\n        end = (address) dlinfo2.dli_saddr;\n      Disassembler::decode(begin, end, st);\n    }\n    return true;\n  }\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// misc\n\n// This does not do anything on Bsd. This is basically a hook for being\n// able to use structured exception handling (thread-local exception filters)\n// on, e.g., Win32.\nvoid\nos::os_exception_wrapper(java_call_t f, JavaValue* value, methodHandle* method,\n                         JavaCallArguments* args, Thread* thread) {\n  f(value, method, args, thread);\n}\n\nvoid os::print_statistics() {\n}\n\nint os::message_box(const char* title, const char* message) {\n  int i;\n  fdStream err(defaultStream::error_fd());\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n  err.print_raw_cr(title);\n  for (i = 0; i < 78; i++) err.print_raw(\"-\");\n  err.cr();\n  err.print_raw_cr(message);\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n\n  char buf[16];\n  // Prevent process from exiting upon \"read error\" without consuming all CPU\n  while (::read(0, buf, sizeof(buf)) <= 0) { ::sleep(100); }\n\n  return buf[0] == 'y' || buf[0] == 'Y';\n}\n\nint os::stat(const char *path, struct stat *sbuf) {\n  char pathbuf[MAX_PATH];\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  os::native_path(strcpy(pathbuf, path));\n  return ::stat(pathbuf, sbuf);\n}\n\nbool os::check_heap(bool force) {\n  return true;\n}\n\nATTRIBUTE_PRINTF(3, 0)\nint local_vsnprintf(char* buf, size_t count, const char* format, va_list args) {\n  return ::vsnprintf(buf, count, format, args);\n}\n\n// Is a (classpath) directory empty?\nbool os::dir_is_empty(const char* path) {\n  DIR *dir = NULL;\n  struct dirent *ptr;\n\n  dir = opendir(path);\n  if (dir == NULL) return true;\n\n  /* Scan the directory */\n  bool result = true;\n  char buf[sizeof(struct dirent) + MAX_PATH];\n  while (result && (ptr = ::readdir(dir)) != NULL) {\n    if (strcmp(ptr->d_name, \".\") != 0 && strcmp(ptr->d_name, \"..\") != 0) {\n      result = false;\n    }\n  }\n  closedir(dir);\n  return result;\n}\n\n// This code originates from JDK's sysOpen and open64_w\n// from src/solaris/hpi/src/system_md.c\n\n#ifndef O_DELETE\n#define O_DELETE 0x10000\n#endif\n\n// Open a file. Unlink the file immediately after open returns\n// if the specified oflag has the O_DELETE flag set.\n// O_DELETE is used only in j2se/src/share/native/java/util/zip/ZipFile.c\n\nint os::open(const char *path, int oflag, int mode) {\n\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  int fd;\n  int o_delete = (oflag & O_DELETE);\n  oflag = oflag & ~O_DELETE;\n\n  fd = ::open(path, oflag, mode);\n  if (fd == -1) return -1;\n\n  //If the open succeeded, the file might still be a directory\n  {\n    struct stat buf;\n    int ret = ::fstat(fd, &buf);\n    int st_mode = buf.st_mode;\n\n    if (ret != -1) {\n      if ((st_mode & S_IFMT) == S_IFDIR) {\n        errno = EISDIR;\n        ::close(fd);\n        return -1;\n      }\n    } else {\n      ::close(fd);\n      return -1;\n    }\n  }\n\n    /*\n     * All file descriptors that are opened in the JVM and not\n     * specifically destined for a subprocess should have the\n     * close-on-exec flag set.  If we don't set it, then careless 3rd\n     * party native code might fork and exec without closing all\n     * appropriate file descriptors (e.g. as we do in closeDescriptors in\n     * UNIXProcess.c), and this in turn might:\n     *\n     * - cause end-of-file to fail to be detected on some file\n     *   descriptors, resulting in mysterious hangs, or\n     *\n     * - might cause an fopen in the subprocess to fail on a system\n     *   suffering from bug 1085341.\n     *\n     * (Yes, the default setting of the close-on-exec flag is a Unix\n     * design flaw)\n     *\n     * See:\n     * 1085341: 32-bit stdio routines should support file descriptors >255\n     * 4843136: (process) pipe file descriptor from Runtime.exec not being closed\n     * 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9\n     */\n#ifdef FD_CLOEXEC\n    {\n        int flags = ::fcntl(fd, F_GETFD);\n        if (flags != -1)\n            ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n    }\n#endif\n\n  if (o_delete != 0) {\n    ::unlink(path);\n  }\n  return fd;\n}\n\n\n// create binary file, rewriting existing file if required\nint os::create_binary_file(const char* path, bool rewrite_existing) {\n  int oflags = O_WRONLY | O_CREAT;\n  if (!rewrite_existing) {\n    oflags |= O_EXCL;\n  }\n  return ::open(path, oflags, S_IREAD | S_IWRITE);\n}\n\n// return current position of file pointer\njlong os::current_file_offset(int fd) {\n  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);\n}\n\n// move file pointer to the specified offset\njlong os::seek_to_file_offset(int fd, jlong offset) {\n  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);\n}\n\n// This code originates from JDK's sysAvailable\n// from src/solaris/hpi/src/native_threads/src/sys_api_td.c\n\nint os::available(int fd, jlong *bytes) {\n  jlong cur, end;\n  int mode;\n  struct stat buf;\n\n  if (::fstat(fd, &buf) >= 0) {\n    mode = buf.st_mode;\n    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n      /*\n      * XXX: is the following call interruptible? If so, this might\n      * need to go through the INTERRUPT_IO() wrapper as for other\n      * blocking, interruptible calls in this file.\n      */\n      int n;\n      if (::ioctl(fd, FIONREAD, &n) >= 0) {\n        *bytes = n;\n        return 1;\n      }\n    }\n  }\n  if ((cur = ::lseek(fd, 0L, SEEK_CUR)) == -1) {\n    return 0;\n  } else if ((end = ::lseek(fd, 0L, SEEK_END)) == -1) {\n    return 0;\n  } else if (::lseek(fd, cur, SEEK_SET) == -1) {\n    return 0;\n  }\n  *bytes = end - cur;\n  return 1;\n}\n\nint os::socket_available(int fd, jint *pbytes) {\n   if (fd < 0)\n     return OS_OK;\n\n   int ret;\n\n   RESTARTABLE(::ioctl(fd, FIONREAD, pbytes), ret);\n\n   //%% note ioctl can return 0 when successful, JVM_SocketAvailable\n   // is expected to return 0 on failure and 1 on success to the jdk.\n\n   return (ret == OS_ERR) ? 0 : 1;\n}\n\n// Map a block of memory.\nchar* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,\n                     char *addr, size_t bytes, bool read_only,\n                     bool allow_exec) {\n  int prot;\n  int flags;\n\n  if (read_only) {\n    prot = PROT_READ;\n    flags = MAP_SHARED;\n  } else {\n    prot = PROT_READ | PROT_WRITE;\n    flags = MAP_PRIVATE;\n  }\n\n  if (allow_exec) {\n    prot |= PROT_EXEC;\n  }\n\n  if (addr != NULL) {\n    flags |= MAP_FIXED;\n  }\n\n  char* mapped_address = (char*)mmap(addr, (size_t)bytes, prot, flags,\n                                     fd, file_offset);\n  if (mapped_address == MAP_FAILED) {\n    return NULL;\n  }\n  return mapped_address;\n}\n\n\n// Remap a block of memory.\nchar* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,\n                       char *addr, size_t bytes, bool read_only,\n                       bool allow_exec) {\n  // same as map_memory() on this OS\n  return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,\n                        allow_exec);\n}\n\n\n// Unmap a block of memory.\nbool os::pd_unmap_memory(char* addr, size_t bytes) {\n  return munmap(addr, bytes) == 0;\n}\n\n// current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)\n// are used by JVM M&M and JVMTI to get user+sys or user CPU time\n// of a thread.\n//\n// current_thread_cpu_time() and thread_cpu_time(Thread*) returns\n// the fast estimate available on the platform.\n\njlong os::current_thread_cpu_time() {\n#ifdef __APPLE__\n  return os::thread_cpu_time(Thread::current(), true /* user + sys */);\n#else\n  Unimplemented();\n  return 0;\n#endif\n}\n\njlong os::thread_cpu_time(Thread* thread) {\n#ifdef __APPLE__\n  return os::thread_cpu_time(thread, true /* user + sys */);\n#else\n  Unimplemented();\n  return 0;\n#endif\n}\n\njlong os::current_thread_cpu_time(bool user_sys_cpu_time) {\n#ifdef __APPLE__\n  return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);\n#else\n  Unimplemented();\n  return 0;\n#endif\n}\n\njlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {\n#ifdef __APPLE__\n  struct thread_basic_info tinfo;\n  mach_msg_type_number_t tcount = THREAD_INFO_MAX;\n  kern_return_t kr;\n  thread_t mach_thread;\n\n  mach_thread = thread->osthread()->thread_id();\n  kr = thread_info(mach_thread, THREAD_BASIC_INFO, (thread_info_t)&tinfo, &tcount);\n  if (kr != KERN_SUCCESS)\n    return -1;\n\n  if (user_sys_cpu_time) {\n    jlong nanos;\n    nanos = ((jlong) tinfo.system_time.seconds + tinfo.user_time.seconds) * (jlong)1000000000;\n    nanos += ((jlong) tinfo.system_time.microseconds + (jlong) tinfo.user_time.microseconds) * (jlong)1000;\n    return nanos;\n  } else {\n    return ((jlong)tinfo.user_time.seconds * 1000000000) + ((jlong)tinfo.user_time.microseconds * (jlong)1000);\n  }\n#else\n  Unimplemented();\n  return 0;\n#endif\n}\n\n\nvoid os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nvoid os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nbool os::is_thread_cpu_time_supported() {\n#ifdef __APPLE__\n  return true;\n#else\n  return false;\n#endif\n}\n\n// System loadavg support.  Returns -1 if load average cannot be obtained.\n// Bsd doesn't yet have a (official) notion of processor sets,\n// so just return the system wide load average.\nint os::loadavg(double loadavg[], int nelem) {\n  return ::getloadavg(loadavg, nelem);\n}\n\nvoid os::pause() {\n  char filename[MAX_PATH];\n  if (PauseAtStartupFile && PauseAtStartupFile[0]) {\n    jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);\n  } else {\n    jio_snprintf(filename, MAX_PATH, \"./vm.paused.%d\", current_process_id());\n  }\n\n  int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n  if (fd != -1) {\n    struct stat buf;\n    ::close(fd);\n    while (::stat(filename, &buf) == 0) {\n      (void)::poll(NULL, 0, 100);\n    }\n  } else {\n    jio_fprintf(stderr,\n      \"Could not open pause file '%s', continuing immediately.\\n\", filename);\n  }\n}\n\n\n// Refer to the comments in os_solaris.cpp park-unpark.\n//\n// Beware -- Some versions of NPTL embody a flaw where pthread_cond_timedwait() can\n// hang indefinitely.  For instance NPTL 0.60 on 2.4.21-4ELsmp is vulnerable.\n// For specifics regarding the bug see GLIBC BUGID 261237 :\n//    http://www.mail-archive.com/debian-glibc@lists.debian.org/msg10837.html.\n// Briefly, pthread_cond_timedwait() calls with an expiry time that's not in the future\n// will either hang or corrupt the condvar, resulting in subsequent hangs if the condvar\n// is used.  (The simple C test-case provided in the GLIBC bug report manifests the\n// hang).  The JVM is vulernable via sleep(), Object.wait(timo), LockSupport.parkNanos()\n// and monitorenter when we're using 1-0 locking.  All those operations may result in\n// calls to pthread_cond_timedwait().  Using LD_ASSUME_KERNEL to use an older version\n// of libpthread avoids the problem, but isn't practical.\n//\n// Possible remedies:\n//\n// 1.   Establish a minimum relative wait time.  50 to 100 msecs seems to work.\n//      This is palliative and probabilistic, however.  If the thread is preempted\n//      between the call to compute_abstime() and pthread_cond_timedwait(), more\n//      than the minimum period may have passed, and the abstime may be stale (in the\n//      past) resultin in a hang.   Using this technique reduces the odds of a hang\n//      but the JVM is still vulnerable, particularly on heavily loaded systems.\n//\n// 2.   Modify park-unpark to use per-thread (per ParkEvent) pipe-pairs instead\n//      of the usual flag-condvar-mutex idiom.  The write side of the pipe is set\n//      NDELAY. unpark() reduces to write(), park() reduces to read() and park(timo)\n//      reduces to poll()+read().  This works well, but consumes 2 FDs per extant\n//      thread.\n//\n// 3.   Embargo pthread_cond_timedwait() and implement a native \"chron\" thread\n//      that manages timeouts.  We'd emulate pthread_cond_timedwait() by enqueuing\n//      a timeout request to the chron thread and then blocking via pthread_cond_wait().\n//      This also works well.  In fact it avoids kernel-level scalability impediments\n//      on certain platforms that don't handle lots of active pthread_cond_timedwait()\n//      timers in a graceful fashion.\n//\n// 4.   When the abstime value is in the past it appears that control returns\n//      correctly from pthread_cond_timedwait(), but the condvar is left corrupt.\n//      Subsequent timedwait/wait calls may hang indefinitely.  Given that, we\n//      can avoid the problem by reinitializing the condvar -- by cond_destroy()\n//      followed by cond_init() -- after all calls to pthread_cond_timedwait().\n//      It may be possible to avoid reinitialization by checking the return\n//      value from pthread_cond_timedwait().  In addition to reinitializing the\n//      condvar we must establish the invariant that cond_signal() is only called\n//      within critical sections protected by the adjunct mutex.  This prevents\n//      cond_signal() from \"seeing\" a condvar that's in the midst of being\n//      reinitialized or that is corrupt.  Sadly, this invariant obviates the\n//      desirable signal-after-unlock optimization that avoids futile context switching.\n//\n//      I'm also concerned that some versions of NTPL might allocate an auxilliary\n//      structure when a condvar is used or initialized.  cond_destroy()  would\n//      release the helper structure.  Our reinitialize-after-timedwait fix\n//      put excessive stress on malloc/free and locks protecting the c-heap.\n//\n// We currently use (4).  See the WorkAroundNTPLTimedWaitHang flag.\n// It may be possible to refine (4) by checking the kernel and NTPL verisons\n// and only enabling the work-around for vulnerable environments.\n\n// utility to compute the abstime argument to timedwait:\n// millis is the relative timeout time\n// abstime will be the absolute timeout time\n// TODO: replace compute_abstime() with unpackTime()\n\nstatic struct timespec* compute_abstime(struct timespec* abstime, jlong millis) {\n  if (millis < 0)  millis = 0;\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n  jlong seconds = millis / 1000;\n  millis %= 1000;\n  if (seconds > 50000000) { // see man cond_timedwait(3T)\n    seconds = 50000000;\n  }\n  abstime->tv_sec = now.tv_sec  + seconds;\n  long       usec = now.tv_usec + millis * 1000;\n  if (usec >= 1000000) {\n    abstime->tv_sec += 1;\n    usec -= 1000000;\n  }\n  abstime->tv_nsec = usec * 1000;\n  return abstime;\n}\n\n\n// Test-and-clear _Event, always leaves _Event set to 0, returns immediately.\n// Conceptually TryPark() should be equivalent to park(0).\n\nint os::PlatformEvent::TryPark() {\n  for (;;) {\n    const int v = _Event ;\n    guarantee ((v == 0) || (v == 1), \"invariant\") ;\n    if (Atomic::cmpxchg (0, &_Event, v) == v) return v  ;\n  }\n}\n\nvoid os::PlatformEvent::park() {       // AKA \"down()\"\n  // Invariant: Only the thread associated with the Event/PlatformEvent\n  // may call park().\n  // TODO: assert that _Assoc != NULL or _Assoc == Self\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v == 0) {\n     // Do this the hard way by blocking ...\n     int status = pthread_mutex_lock(_mutex);\n     assert_status(status == 0, status, \"mutex_lock\");\n     guarantee (_nParked == 0, \"invariant\") ;\n     ++ _nParked ;\n     while (_Event < 0) {\n        status = pthread_cond_wait(_cond, _mutex);\n        // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...\n        // Treat this the same as if the wait was interrupted\n        if (status == ETIMEDOUT) { status = EINTR; }\n        assert_status(status == 0 || status == EINTR, status, \"cond_wait\");\n     }\n     -- _nParked ;\n\n    _Event = 0 ;\n     status = pthread_mutex_unlock(_mutex);\n     assert_status(status == 0, status, \"mutex_unlock\");\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other.\n    OrderAccess::fence();\n  }\n  guarantee (_Event >= 0, \"invariant\") ;\n}\n\nint os::PlatformEvent::park(jlong millis) {\n  guarantee (_nParked == 0, \"invariant\") ;\n\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v != 0) return OS_OK ;\n\n  // We do this the hard way, by blocking the thread.\n  // Consider enforcing a minimum timeout value.\n  struct timespec abst;\n  compute_abstime(&abst, millis);\n\n  int ret = OS_TIMEOUT;\n  int status = pthread_mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  guarantee (_nParked == 0, \"invariant\") ;\n  ++_nParked ;\n\n  // Object.wait(timo) will return because of\n  // (a) notification\n  // (b) timeout\n  // (c) thread.interrupt\n  //\n  // Thread.interrupt and object.notify{All} both call Event::set.\n  // That is, we treat thread.interrupt as a special case of notification.\n  // The underlying Solaris implementation, cond_timedwait, admits\n  // spurious/premature wakeups, but the JLS/JVM spec prevents the\n  // JVM from making those visible to Java code.  As such, we must\n  // filter out spurious wakeups.  We assume all ETIME returns are valid.\n  //\n  // TODO: properly differentiate simultaneous notify+interrupt.\n  // In that case, we should propagate the notify to another waiter.\n\n  while (_Event < 0) {\n    status = os::Bsd::safe_cond_timedwait(_cond, _mutex, &abst);\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (_cond);\n      pthread_cond_init (_cond, NULL) ;\n    }\n    assert_status(status == 0 || status == EINTR ||\n                  status == ETIMEDOUT,\n                  status, \"cond_timedwait\");\n    if (!FilterSpuriousWakeups) break ;                 // previous semantics\n    if (status == ETIMEDOUT) break ;\n    // We consume and ignore EINTR and spurious wakeups.\n  }\n  --_nParked ;\n  if (_Event >= 0) {\n     ret = OS_OK;\n  }\n  _Event = 0 ;\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  assert (_nParked == 0, \"invariant\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other.\n  OrderAccess::fence();\n  return ret;\n}\n\nvoid os::PlatformEvent::unpark() {\n  // Transitions for _Event:\n  //    0 :=> 1\n  //    1 :=> 1\n  //   -1 :=> either 0 or 1; must signal target thread\n  //          That is, we can safely transition _Event from -1 to either\n  //          0 or 1. Forcing 1 is slightly more efficient for back-to-back\n  //          unpark() calls.\n  // See also: \"Semaphores in Plan 9\" by Mullender & Cox\n  //\n  // Note: Forcing a transition from \"-1\" to \"1\" on an unpark() means\n  // that it will take two back-to-back park() calls for the owning\n  // thread to block. This has the benefit of forcing a spurious return\n  // from the first park() call after an unpark() call which will help\n  // shake out uses of park() and unpark() without condition variables.\n\n  if (Atomic::xchg(1, &_Event) >= 0) return;\n\n  // Wait for the thread associated with the event to vacate\n  int status = pthread_mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  int AnyWaiters = _nParked;\n  assert(AnyWaiters == 0 || AnyWaiters == 1, \"invariant\");\n  if (AnyWaiters != 0 && WorkAroundNPTLTimedWaitHang) {\n    AnyWaiters = 0;\n    pthread_cond_signal(_cond);\n  }\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  if (AnyWaiters != 0) {\n    status = pthread_cond_signal(_cond);\n    assert_status(status == 0, status, \"cond_signal\");\n  }\n\n  // Note that we signal() _after dropping the lock for \"immortal\" Events.\n  // This is safe and avoids a common class of  futile wakeups.  In rare\n  // circumstances this can cause a thread to return prematurely from\n  // cond_{timed}wait() but the spurious wakeup is benign and the victim will\n  // simply re-test the condition and re-park itself.\n}\n\n\n// JSR166\n// -------------------------------------------------------\n\n/*\n * The solaris and bsd implementations of park/unpark are fairly\n * conservative for now, but can be improved. They currently use a\n * mutex/condvar pair, plus a a count.\n * Park decrements count if > 0, else does a condvar wait.  Unpark\n * sets count to 1 and signals condvar.  Only one thread ever waits\n * on the condvar. Contention seen when trying to park implies that someone\n * is unparking you, so don't wait. And spurious returns are fine, so there\n * is no need to track notifications.\n */\n\n#define MAX_SECS 100000000\n/*\n * This code is common to bsd and solaris and will be moved to a\n * common place in dolphin.\n *\n * The passed in time value is either a relative time in nanoseconds\n * or an absolute time in milliseconds. Either way it has to be unpacked\n * into suitable seconds and nanoseconds components and stored in the\n * given timespec structure.\n * Given time is a 64-bit value and the time_t used in the timespec is only\n * a signed-32-bit value (except on 64-bit Bsd) we have to watch for\n * overflow if times way in the future are given. Further on Solaris versions\n * prior to 10 there is a restriction (see cond_timedwait) that the specified\n * number of seconds, in abstime, is less than current_time  + 100,000,000.\n * As it will be 28 years before \"now + 100000000\" will overflow we can\n * ignore overflow and just impose a hard-limit on seconds using the value\n * of \"now + 100,000,000\". This places a limit on the timeout of about 3.17\n * years from \"now\".\n */\n\nstatic void unpackTime(struct timespec* absTime, bool isAbsolute, jlong time) {\n  assert (time > 0, \"convertTime\");\n\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n\n  time_t max_secs = now.tv_sec + MAX_SECS;\n\n  if (isAbsolute) {\n    jlong secs = time / 1000;\n    if (secs > max_secs) {\n      absTime->tv_sec = max_secs;\n    }\n    else {\n      absTime->tv_sec = secs;\n    }\n    absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;\n  }\n  else {\n    jlong secs = time / NANOSECS_PER_SEC;\n    if (secs >= MAX_SECS) {\n      absTime->tv_sec = max_secs;\n      absTime->tv_nsec = 0;\n    }\n    else {\n      absTime->tv_sec = now.tv_sec + secs;\n      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;\n      if (absTime->tv_nsec >= NANOSECS_PER_SEC) {\n        absTime->tv_nsec -= NANOSECS_PER_SEC;\n        ++absTime->tv_sec; // note: this must be <= max_secs\n      }\n    }\n  }\n  assert(absTime->tv_sec >= 0, \"tv_sec < 0\");\n  assert(absTime->tv_sec <= max_secs, \"tv_sec > max_secs\");\n  assert(absTime->tv_nsec >= 0, \"tv_nsec < 0\");\n  assert(absTime->tv_nsec < NANOSECS_PER_SEC, \"tv_nsec >= nanos_per_sec\");\n}\n\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n  JavaThread *jt = (JavaThread *)thread;\n\n  // Optional optimization -- avoid state transitions if there's an interrupt pending.\n  // Check interrupt before trying to wait\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n\n  // Next, demultiplex/decode time arguments\n  struct timespec absTime;\n  if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all\n    return;\n  }\n  if (time > 0) {\n    unpackTime(&absTime, isAbsolute, time);\n  }\n\n\n  // Enter safepoint region\n  // Beware of deadlocks such as 6317397.\n  // The per-thread Parker:: mutex is a classic leaf-lock.\n  // In particular a thread must never block on the Threads_lock while\n  // holding the Parker:: mutex.  If safepoints are pending both the\n  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.\n  ThreadBlockInVM tbivm(jt);\n\n  // Don't wait if cannot get lock since interference arises from\n  // unblocking.  Also. check interrupt before trying wait\n  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {\n    return;\n  }\n\n  int status ;\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other and Java-level accesses.\n    OrderAccess::fence();\n    return;\n  }\n\n#ifdef ASSERT\n  // Don't catch signals while blocked; let the running threads have the signals.\n  // (This allows a debugger to break into the running thread.)\n  sigset_t oldsigs;\n  sigset_t* allowdebug_blocked = os::Bsd::allowdebug_blocked_signals();\n  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);\n#endif\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  } else {\n    status = os::Bsd::safe_cond_timedwait (_cond, _mutex, &absTime) ;\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (_cond) ;\n      pthread_cond_init    (_cond, NULL);\n    }\n  }\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other and Java-level accesses.\n  OrderAccess::fence();\n\n  // If externally suspended while waiting, re-suspend\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n}\n\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") ;\n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n\n\n/* Darwin has no \"environ\" in a dynamic library. */\n#ifdef __APPLE__\n#include <crt_externs.h>\n#define environ (*_NSGetEnviron())\n#else\nextern char** environ;\n#endif\n\n// Run the specified command in a separate process. Return its exit value,\n// or -1 on failure (e.g. can't fork a new process).\n// Unlike system(), this function can be called from signal handler. It\n// doesn't block SIGINT et al.\nint os::fork_and_exec(char* cmd) {\n  const char * argv[4] = {\"sh\", \"-c\", cmd, NULL};\n\n  // fork() in BsdThreads/NPTL is not async-safe. It needs to run\n  // pthread_atfork handlers and reset pthread library. All we need is a\n  // separate process to execve. Make a direct syscall to fork process.\n  // On IA64 there's no fork syscall, we have to use fork() and hope for\n  // the best...\n  pid_t pid = fork();\n\n  if (pid < 0) {\n    // fork failed\n    return -1;\n\n  } else if (pid == 0) {\n    // child process\n\n    // execve() in BsdThreads will call pthread_kill_other_threads_np()\n    // first to kill every thread on the thread list. Because this list is\n    // not reset by fork() (see notes above), execve() will instead kill\n    // every thread in the parent process. We know this is the only thread\n    // in the new process, so make a system call directly.\n    // IA64 should use normal execve() from glibc to match the glibc fork()\n    // above.\n    execve(\"/bin/sh\", (char* const*)argv, environ);\n\n    // execve failed\n    _exit(-1);\n\n  } else  {\n    // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n    // care about the actual exit code, for now.\n\n    int status;\n\n    // Wait for the child process to exit.  This returns immediately if\n    // the child has already exited. */\n    while (waitpid(pid, &status, 0) < 0) {\n        switch (errno) {\n        case ECHILD: return 0;\n        case EINTR: break;\n        default: return -1;\n        }\n    }\n\n    if (WIFEXITED(status)) {\n       // The child exited normally; get its exit code.\n       return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n       // The child exited because of a signal\n       // The best value to return is 0x80 + signal number,\n       // because that is what all Unix shells do, and because\n       // it allows callers to distinguish between process exit and\n       // process death by signal.\n       return 0x80 + WTERMSIG(status);\n    } else {\n       // Unknown exit code; pass it through\n       return status;\n    }\n  }\n}\n\n// is_headless_jre()\n//\n// Test for the existence of xawt/libmawt.so or libawt_xawt.so\n// in order to report if we are running in a headless jre\n//\n// Since JDK8 xawt/libmawt.so was moved into the same directory\n// as libawt.so, and renamed libawt_xawt.so\n//\nbool os::is_headless_jre() {\n#ifdef __APPLE__\n    // We no longer build headless-only on Mac OS X\n    return false;\n#else\n    struct stat statbuf;\n    char buf[MAXPATHLEN];\n    char libmawtpath[MAXPATHLEN];\n    const char *xawtstr  = \"/xawt/libmawt\" JNI_LIB_SUFFIX;\n    const char *new_xawtstr = \"/libawt_xawt\" JNI_LIB_SUFFIX;\n    char *p;\n\n    // Get path to libjvm.so\n    os::jvm_path(buf, sizeof(buf));\n\n    // Get rid of libjvm.so\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // Get rid of client or server\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // check xawt/libmawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    // check libawt_xawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, new_xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    return true;\n#endif\n}\n\n// Get the default path to the core file\n// Returns the length of the string\nint os::get_core_path(char* buffer, size_t bufferSize) {\n  int n = jio_snprintf(buffer, bufferSize, \"/cores\");\n\n  // Truncate if theoretical string was longer than bufferSize\n  n = MIN2(n, (int)bufferSize);\n\n  return n;\n}\n\n#ifndef PRODUCT\nvoid TestReserveMemorySpecial_test() {\n  // No tests available for this platform\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os/aix/vm/os_aix.cpp": "/*\n * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.\n * Copyright 2012, 2014 SAP AG. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n// According to the AIX OS doc #pragma alloca must be used\n// with C++ compiler before referencing the function alloca()\n#pragma alloca\n\n// no precompiled headers\n#include \"classfile/classLoader.hpp\"\n#include \"classfile/systemDictionary.hpp\"\n#include \"classfile/vmSymbols.hpp\"\n#include \"code/icBuffer.hpp\"\n#include \"code/vtableStubs.hpp\"\n#include \"compiler/compileBroker.hpp\"\n#include \"interpreter/interpreter.hpp\"\n#include \"jvm_aix.h\"\n#include \"libperfstat_aix.hpp\"\n#include \"loadlib_aix.hpp\"\n#include \"memory/allocation.inline.hpp\"\n#include \"memory/filemap.hpp\"\n#include \"mutex_aix.inline.hpp\"\n#include \"oops/oop.inline.hpp\"\n#include \"os_share_aix.hpp\"\n#include \"porting_aix.hpp\"\n#include \"prims/jniFastGetField.hpp\"\n#include \"prims/jvm.h\"\n#include \"prims/jvm_misc.hpp\"\n#include \"runtime/arguments.hpp\"\n#include \"runtime/extendedPC.hpp\"\n#include \"runtime/globals.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/java.hpp\"\n#include \"runtime/javaCalls.hpp\"\n#include \"runtime/mutexLocker.hpp\"\n#include \"runtime/objectMonitor.hpp\"\n#include \"runtime/orderAccess.inline.hpp\"\n#include \"runtime/osThread.hpp\"\n#include \"runtime/perfMemory.hpp\"\n#include \"runtime/sharedRuntime.hpp\"\n#include \"runtime/statSampler.hpp\"\n#include \"runtime/stubRoutines.hpp\"\n#include \"runtime/thread.inline.hpp\"\n#include \"runtime/threadCritical.hpp\"\n#include \"runtime/timer.hpp\"\n#include \"services/attachListener.hpp\"\n#include \"services/runtimeService.hpp\"\n#include \"utilities/decoder.hpp\"\n#include \"utilities/defaultStream.hpp\"\n#include \"utilities/events.hpp\"\n#include \"utilities/growableArray.hpp\"\n#include \"utilities/vmError.hpp\"\n\n// put OS-includes here (sorted alphabetically)\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <poll.h>\n#include <procinfo.h>\n#include <pthread.h>\n#include <pwd.h>\n#include <semaphore.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <sys/ipc.h>\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <sys/select.h>\n#include <sys/shm.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/sysinfo.h>\n#include <sys/systemcfg.h>\n#include <sys/time.h>\n#include <sys/times.h>\n#include <sys/types.h>\n#include <sys/utsname.h>\n#include <sys/vminfo.h>\n#include <sys/wait.h>\n\n// Add missing declarations (should be in procinfo.h but isn't until AIX 6.1).\n#if !defined(_AIXVERSION_610)\nextern \"C\" {\n  int getthrds64(pid_t ProcessIdentifier,\n                 struct thrdentry64* ThreadBuffer,\n                 int ThreadSize,\n                 tid64_t* IndexPointer,\n                 int Count);\n}\n#endif\n\n#define MAX_PATH (2 * K)\n\n// for timer info max values which include all bits\n#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n// for multipage initialization error analysis (in 'g_multipage_error')\n#define ERROR_MP_OS_TOO_OLD                          100\n#define ERROR_MP_EXTSHM_ACTIVE                       101\n#define ERROR_MP_VMGETINFO_FAILED                    102\n#define ERROR_MP_VMGETINFO_CLAIMS_NO_SUPPORT_FOR_64K 103\n\n// The semantics in this file are thus that codeptr_t is a *real code ptr*.\n// This means that any function taking codeptr_t as arguments will assume\n// a real codeptr and won't handle function descriptors (eg getFuncName),\n// whereas functions taking address as args will deal with function\n// descriptors (eg os::dll_address_to_library_name).\ntypedef unsigned int* codeptr_t;\n\n// Typedefs for stackslots, stack pointers, pointers to op codes.\ntypedef unsigned long stackslot_t;\ntypedef stackslot_t* stackptr_t;\n\n// Excerpts from systemcfg.h definitions newer than AIX 5.3.\n#ifndef PV_7\n#define PV_7 0x200000          /* Power PC 7 */\n#define PV_7_Compat 0x208000   /* Power PC 7 */\n#endif\n#ifndef PV_8\n#define PV_8 0x300000          /* Power PC 8 */\n#define PV_8_Compat 0x308000   /* Power PC 8 */\n#endif\n\n#define trcVerbose(fmt, ...) { /* PPC port */  \\\n  if (Verbose) { \\\n    fprintf(stderr, fmt, ##__VA_ARGS__); \\\n    fputc('\\n', stderr); fflush(stderr); \\\n  } \\\n}\n#define trc(fmt, ...)        /* PPC port */\n\n#define ERRBYE(s) { \\\n    trcVerbose(s); \\\n    return -1; \\\n}\n\n// query dimensions of the stack of the calling thread\nstatic void query_stack_dimensions(address* p_stack_base, size_t* p_stack_size);\n\n// function to check a given stack pointer against given stack limits\ninline bool is_valid_stackpointer(stackptr_t sp, stackptr_t stack_base, size_t stack_size) {\n  if (((uintptr_t)sp) & 0x7) {\n    return false;\n  }\n  if (sp > stack_base) {\n    return false;\n  }\n  if (sp < (stackptr_t) ((address)stack_base - stack_size)) {\n    return false;\n  }\n  return true;\n}\n\n// returns true if function is a valid codepointer\ninline bool is_valid_codepointer(codeptr_t p) {\n  if (!p) {\n    return false;\n  }\n  if (((uintptr_t)p) & 0x3) {\n    return false;\n  }\n  if (LoadedLibraries::find_for_text_address((address)p) == NULL) {\n    return false;\n  }\n  return true;\n}\n\n// Macro to check a given stack pointer against given stack limits and to die if test fails.\n#define CHECK_STACK_PTR(sp, stack_base, stack_size) { \\\n    guarantee(is_valid_stackpointer((stackptr_t)(sp), (stackptr_t)(stack_base), stack_size), \"Stack Pointer Invalid\"); \\\n}\n\n// Macro to check the current stack pointer against given stacklimits.\n#define CHECK_CURRENT_STACK_PTR(stack_base, stack_size) { \\\n  address sp; \\\n  sp = os::current_stack_pointer(); \\\n  CHECK_STACK_PTR(sp, stack_base, stack_size); \\\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// global variables (for a description see os_aix.hpp)\n\njulong    os::Aix::_physical_memory = 0;\npthread_t os::Aix::_main_thread = ((pthread_t)0);\nint       os::Aix::_page_size = -1;\nint       os::Aix::_on_pase = -1;\nint       os::Aix::_os_version = -1;\nint       os::Aix::_stack_page_size = -1;\nsize_t    os::Aix::_shm_default_page_size = -1;\nint       os::Aix::_can_use_64K_pages = -1;\nint       os::Aix::_can_use_16M_pages = -1;\nint       os::Aix::_xpg_sus_mode = -1;\nint       os::Aix::_extshm = -1;\nint       os::Aix::_logical_cpus = -1;\n\n////////////////////////////////////////////////////////////////////////////////\n// local variables\n\nstatic int      g_multipage_error  = -1;   // error analysis for multipage initialization\nstatic jlong    initial_time_count = 0;\nstatic int      clock_tics_per_sec = 100;\nstatic sigset_t check_signal_done;         // For diagnostics to print a message once (see run_periodic_checks)\nstatic bool     check_signals      = true;\nstatic pid_t    _initial_pid       = 0;\nstatic int      SR_signum          = SIGUSR2; // Signal used to suspend/resume a thread (must be > SIGSEGV, see 4355769)\nstatic sigset_t SR_sigset;\nstatic pthread_mutex_t dl_mutex;              // Used to protect dlsym() calls.\n\njulong os::available_memory() {\n  return Aix::available_memory();\n}\n\njulong os::Aix::available_memory() {\n  os::Aix::meminfo_t mi;\n  if (os::Aix::get_meminfo(&mi)) {\n    return mi.real_free;\n  } else {\n    return 0xFFFFFFFFFFFFFFFFLL;\n  }\n}\n\njulong os::physical_memory() {\n  return Aix::physical_memory();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// environment support\n\nbool os::getenv(const char* name, char* buf, int len) {\n  const char* val = ::getenv(name);\n  if (val != NULL && strlen(val) < (size_t)len) {\n    strcpy(buf, val);\n    return true;\n  }\n  if (len > 0) buf[0] = 0;  // return a null string\n  return false;\n}\n\n// Return true if user is running as root.\n\nbool os::have_special_privileges() {\n  static bool init = false;\n  static bool privileges = false;\n  if (!init) {\n    privileges = (getuid() != geteuid()) || (getgid() != getegid());\n    init = true;\n  }\n  return privileges;\n}\n\n// Helper function, emulates disclaim64 using multiple 32bit disclaims\n// because we cannot use disclaim64() on AS/400 and old AIX releases.\nstatic bool my_disclaim64(char* addr, size_t size) {\n\n  if (size == 0) {\n    return true;\n  }\n\n  // Maximum size 32bit disclaim() accepts. (Theoretically 4GB, but I just do not trust that.)\n  const unsigned int maxDisclaimSize = 0x80000000;\n\n  const unsigned int numFullDisclaimsNeeded = (size / maxDisclaimSize);\n  const unsigned int lastDisclaimSize = (size % maxDisclaimSize);\n\n  char* p = addr;\n\n  for (int i = 0; i < numFullDisclaimsNeeded; i ++) {\n    if (::disclaim(p, maxDisclaimSize, DISCLAIM_ZEROMEM) != 0) {\n      trc(\"Cannot disclaim %p - %p (errno %d)\\n\", p, p + maxDisclaimSize, errno);\n      return false;\n    }\n    p += maxDisclaimSize;\n  }\n\n  if (lastDisclaimSize > 0) {\n    if (::disclaim(p, lastDisclaimSize, DISCLAIM_ZEROMEM) != 0) {\n      trc(\"Cannot disclaim %p - %p (errno %d)\\n\", p, p + lastDisclaimSize, errno);\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Cpu architecture string\n#if defined(PPC32)\nstatic char cpu_arch[] = \"ppc\";\n#elif defined(PPC64)\nstatic char cpu_arch[] = \"ppc64\";\n#else\n#error Add appropriate cpu_arch setting\n#endif\n\n\n// Given an address, returns the size of the page backing that address.\nsize_t os::Aix::query_pagesize(void* addr) {\n\n  vm_page_info pi;\n  pi.addr = (uint64_t)addr;\n  if (::vmgetinfo(&pi, VM_PAGE_INFO, sizeof(pi)) == 0) {\n    return pi.pagesize;\n  } else {\n    fprintf(stderr, \"vmgetinfo failed to retrieve page size for address %p (errno %d).\\n\", addr, errno);\n    assert(false, \"vmgetinfo failed to retrieve page size\");\n    return SIZE_4K;\n  }\n\n}\n\n// Returns the kernel thread id of the currently running thread.\npid_t os::Aix::gettid() {\n  return (pid_t) thread_self();\n}\n\nvoid os::Aix::initialize_system_info() {\n\n  // Get the number of online(logical) cpus instead of configured.\n  os::_processor_count = sysconf(_SC_NPROCESSORS_ONLN);\n  assert(_processor_count > 0, \"_processor_count must be > 0\");\n\n  // Retrieve total physical storage.\n  os::Aix::meminfo_t mi;\n  if (!os::Aix::get_meminfo(&mi)) {\n    fprintf(stderr, \"os::Aix::get_meminfo failed.\\n\"); fflush(stderr);\n    assert(false, \"os::Aix::get_meminfo failed.\");\n  }\n  _physical_memory = (julong) mi.real_total;\n}\n\n// Helper function for tracing page sizes.\nstatic const char* describe_pagesize(size_t pagesize) {\n  switch (pagesize) {\n    case SIZE_4K : return \"4K\";\n    case SIZE_64K: return \"64K\";\n    case SIZE_16M: return \"16M\";\n    case SIZE_16G: return \"16G\";\n    default:\n      assert(false, \"surprise\");\n      return \"??\";\n  }\n}\n\n// Retrieve information about multipage size support. Will initialize\n// Aix::_page_size, Aix::_stack_page_size, Aix::_can_use_64K_pages,\n// Aix::_can_use_16M_pages.\n// Must be called before calling os::large_page_init().\nvoid os::Aix::query_multipage_support() {\n\n  guarantee(_page_size == -1 &&\n            _stack_page_size == -1 &&\n            _can_use_64K_pages == -1 &&\n            _can_use_16M_pages == -1 &&\n            g_multipage_error == -1,\n            \"do not call twice\");\n\n  _page_size = ::sysconf(_SC_PAGESIZE);\n\n  // This really would surprise me.\n  assert(_page_size == SIZE_4K, \"surprise!\");\n\n\n  // Query default data page size (default page size for C-Heap, pthread stacks and .bss).\n  // Default data page size is influenced either by linker options (-bdatapsize)\n  // or by environment variable LDR_CNTRL (suboption DATAPSIZE). If none is given,\n  // default should be 4K.\n  size_t data_page_size = SIZE_4K;\n  {\n    void* p = ::malloc(SIZE_16M);\n    guarantee(p != NULL, \"malloc failed\");\n    data_page_size = os::Aix::query_pagesize(p);\n    ::free(p);\n  }\n\n  // query default shm page size (LDR_CNTRL SHMPSIZE)\n  {\n    const int shmid = ::shmget(IPC_PRIVATE, 1, IPC_CREAT | S_IRUSR | S_IWUSR);\n    guarantee(shmid != -1, \"shmget failed\");\n    void* p = ::shmat(shmid, NULL, 0);\n    ::shmctl(shmid, IPC_RMID, NULL);\n    guarantee(p != (void*) -1, \"shmat failed\");\n    _shm_default_page_size = os::Aix::query_pagesize(p);\n    ::shmdt(p);\n  }\n\n  // before querying the stack page size, make sure we are not running as primordial\n  // thread (because primordial thread's stack may have different page size than\n  // pthread thread stacks). Running a VM on the primordial thread won't work for a\n  // number of reasons so we may just as well guarantee it here\n  guarantee(!os::Aix::is_primordial_thread(), \"Must not be called for primordial thread\");\n\n  // query stack page size\n  {\n    int dummy = 0;\n    _stack_page_size = os::Aix::query_pagesize(&dummy);\n    // everything else would surprise me and should be looked into\n    guarantee(_stack_page_size == SIZE_4K || _stack_page_size == SIZE_64K, \"Wrong page size\");\n    // also, just for completeness: pthread stacks are allocated from C heap, so\n    // stack page size should be the same as data page size\n    guarantee(_stack_page_size == data_page_size, \"stack page size should be the same as data page size\");\n  }\n\n  // EXTSHM is bad: among other things, it prevents setting pagesize dynamically\n  // for system V shm.\n  if (Aix::extshm()) {\n    if (Verbose) {\n      fprintf(stderr, \"EXTSHM is active - will disable large page support.\\n\"\n                      \"Please make sure EXTSHM is OFF for large page support.\\n\");\n    }\n    g_multipage_error = ERROR_MP_EXTSHM_ACTIVE;\n    _can_use_64K_pages = _can_use_16M_pages = 0;\n    goto query_multipage_support_end;\n  }\n\n  // now check which page sizes the OS claims it supports, and of those, which actually can be used.\n  {\n    const int MAX_PAGE_SIZES = 4;\n    psize_t sizes[MAX_PAGE_SIZES];\n    const int num_psizes = ::vmgetinfo(sizes, VMINFO_GETPSIZES, MAX_PAGE_SIZES);\n    if (num_psizes == -1) {\n      if (Verbose) {\n        fprintf(stderr, \"vmgetinfo(VMINFO_GETPSIZES) failed (errno: %d)\\n\", errno);\n        fprintf(stderr, \"disabling multipage support.\\n\");\n      }\n      g_multipage_error = ERROR_MP_VMGETINFO_FAILED;\n      _can_use_64K_pages = _can_use_16M_pages = 0;\n      goto query_multipage_support_end;\n    }\n    guarantee(num_psizes > 0, \"vmgetinfo(.., VMINFO_GETPSIZES, ...) failed.\");\n    assert(num_psizes <= MAX_PAGE_SIZES, \"Surprise! more than 4 page sizes?\");\n    if (Verbose) {\n      fprintf(stderr, \"vmgetinfo(.., VMINFO_GETPSIZES, ...) returns %d supported page sizes: \", num_psizes);\n      for (int i = 0; i < num_psizes; i ++) {\n        fprintf(stderr, \" %s \", describe_pagesize(sizes[i]));\n      }\n      fprintf(stderr, \" .\\n\");\n    }\n\n    // Can we use 64K, 16M pages?\n    _can_use_64K_pages = 0;\n    _can_use_16M_pages = 0;\n    for (int i = 0; i < num_psizes; i ++) {\n      if (sizes[i] == SIZE_64K) {\n        _can_use_64K_pages = 1;\n      } else if (sizes[i] == SIZE_16M) {\n        _can_use_16M_pages = 1;\n      }\n    }\n\n    if (!_can_use_64K_pages) {\n      g_multipage_error = ERROR_MP_VMGETINFO_CLAIMS_NO_SUPPORT_FOR_64K;\n    }\n\n    // Double-check for 16M pages: Even if AIX claims to be able to use 16M pages,\n    // there must be an actual 16M page pool, and we must run with enough rights.\n    if (_can_use_16M_pages) {\n      const int shmid = ::shmget(IPC_PRIVATE, SIZE_16M, IPC_CREAT | S_IRUSR | S_IWUSR);\n      guarantee(shmid != -1, \"shmget failed\");\n      struct shmid_ds shm_buf = { 0 };\n      shm_buf.shm_pagesize = SIZE_16M;\n      const bool can_set_pagesize = ::shmctl(shmid, SHM_PAGESIZE, &shm_buf) == 0 ? true : false;\n      const int en = errno;\n      ::shmctl(shmid, IPC_RMID, NULL);\n      if (!can_set_pagesize) {\n        if (Verbose) {\n          fprintf(stderr, \"Failed to allocate even one misely 16M page. shmctl failed with %d (%s).\\n\"\n                          \"Will deactivate 16M support.\\n\", en, strerror(en));\n        }\n        _can_use_16M_pages = 0;\n      }\n    }\n\n  } // end: check which pages can be used for shared memory\n\nquery_multipage_support_end:\n\n  guarantee(_page_size != -1 &&\n            _stack_page_size != -1 &&\n            _can_use_64K_pages != -1 &&\n            _can_use_16M_pages != -1, \"Page sizes not properly initialized\");\n\n  if (_can_use_64K_pages) {\n    g_multipage_error = 0;\n  }\n\n  if (Verbose) {\n    fprintf(stderr, \"Data page size (C-Heap, bss, etc): %s\\n\", describe_pagesize(data_page_size));\n    fprintf(stderr, \"Thread stack page size (pthread): %s\\n\", describe_pagesize(_stack_page_size));\n    fprintf(stderr, \"Default shared memory page size: %s\\n\", describe_pagesize(_shm_default_page_size));\n    fprintf(stderr, \"Can use 64K pages dynamically with shared meory: %s\\n\", (_can_use_64K_pages ? \"yes\" :\"no\"));\n    fprintf(stderr, \"Can use 16M pages dynamically with shared memory: %s\\n\", (_can_use_16M_pages ? \"yes\" :\"no\"));\n    fprintf(stderr, \"Multipage error details: %d\\n\", g_multipage_error);\n  }\n\n} // end os::Aix::query_multipage_support()\n\nvoid os::init_system_properties_values() {\n\n#define DEFAULT_LIBPATH \"/usr/lib:/lib\"\n#define EXTENSIONS_DIR  \"/lib/ext\"\n#define ENDORSED_DIR    \"/lib/endorsed\"\n\n  // Buffer that fits several sprintfs.\n  // Note that the space for the trailing null is provided\n  // by the nulls included by the sizeof operator.\n  const size_t bufsize =\n    MAX3((size_t)MAXPATHLEN,  // For dll_dir & friends.\n         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR), // extensions dir\n         (size_t)MAXPATHLEN + sizeof(ENDORSED_DIR)); // endorsed dir\n  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n\n  // sysclasspath, java_home, dll_dir\n  {\n    char *pslash;\n    os::jvm_path(buf, bufsize);\n\n    // Found the full path to libjvm.so.\n    // Now cut the path to <java_home>/jre if we can.\n    *(strrchr(buf, '/')) = '\\0'; // Get rid of /libjvm.so.\n    pslash = strrchr(buf, '/');\n    if (pslash != NULL) {\n      *pslash = '\\0';            // Get rid of /{client|server|hotspot}.\n    }\n    Arguments::set_dll_dir(buf);\n\n    if (pslash != NULL) {\n      pslash = strrchr(buf, '/');\n      if (pslash != NULL) {\n        *pslash = '\\0';          // Get rid of /<arch>.\n        pslash = strrchr(buf, '/');\n        if (pslash != NULL) {\n          *pslash = '\\0';        // Get rid of /lib.\n        }\n      }\n    }\n    Arguments::set_java_home(buf);\n    set_boot_path('/', ':');\n  }\n\n  // Where to look for native libraries.\n\n  // On Aix we get the user setting of LIBPATH.\n  // Eventually, all the library path setting will be done here.\n  // Get the user setting of LIBPATH.\n  const char *v = ::getenv(\"LIBPATH\");\n  const char *v_colon = \":\";\n  if (v == NULL) { v = \"\"; v_colon = \"\"; }\n\n  // Concatenate user and invariant part of ld_library_path.\n  // That's +1 for the colon and +1 for the trailing '\\0'.\n  char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char, strlen(v) + 1 + sizeof(DEFAULT_LIBPATH) + 1, mtInternal);\n  sprintf(ld_library_path, \"%s%s\" DEFAULT_LIBPATH, v, v_colon);\n  Arguments::set_library_path(ld_library_path);\n  FREE_C_HEAP_ARRAY(char, ld_library_path, mtInternal);\n\n  // Extensions directories.\n  sprintf(buf, \"%s\" EXTENSIONS_DIR, Arguments::get_java_home());\n  Arguments::set_ext_dirs(buf);\n\n  // Endorsed standards default directory.\n  sprintf(buf, \"%s\" ENDORSED_DIR, Arguments::get_java_home());\n  Arguments::set_endorsed_dirs(buf);\n\n  FREE_C_HEAP_ARRAY(char, buf, mtInternal);\n\n#undef DEFAULT_LIBPATH\n#undef EXTENSIONS_DIR\n#undef ENDORSED_DIR\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// breakpoint support\n\nvoid os::breakpoint() {\n  BREAKPOINT;\n}\n\nextern \"C\" void breakpoint() {\n  // use debugger to set breakpoint here\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// signal support\n\ndebug_only(static bool signal_sets_initialized = false);\nstatic sigset_t unblocked_sigs, vm_sigs, allowdebug_blocked_sigs;\n\nbool os::Aix::is_sig_ignored(int sig) {\n  struct sigaction oact;\n  sigaction(sig, (struct sigaction*)NULL, &oact);\n  void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*, oact.sa_sigaction)\n    : CAST_FROM_FN_PTR(void*, oact.sa_handler);\n  if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid os::Aix::signal_sets_init() {\n  // Should also have an assertion stating we are still single-threaded.\n  assert(!signal_sets_initialized, \"Already initialized\");\n  // Fill in signals that are necessarily unblocked for all threads in\n  // the VM. Currently, we unblock the following signals:\n  // SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n  //                         by -Xrs (=ReduceSignalUsage));\n  // BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n  // other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n  // the dispositions or masks wrt these signals.\n  // Programs embedding the VM that want to use the above signals for their\n  // own purposes must, at this time, use the \"-Xrs\" option to prevent\n  // interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n  // (See bug 4345157, and other related bugs).\n  // In reality, though, unblocking these signals is really a nop, since\n  // these signals are not blocked by default.\n  sigemptyset(&unblocked_sigs);\n  sigemptyset(&allowdebug_blocked_sigs);\n  sigaddset(&unblocked_sigs, SIGILL);\n  sigaddset(&unblocked_sigs, SIGSEGV);\n  sigaddset(&unblocked_sigs, SIGBUS);\n  sigaddset(&unblocked_sigs, SIGFPE);\n  sigaddset(&unblocked_sigs, SIGTRAP);\n  sigaddset(&unblocked_sigs, SIGDANGER);\n  sigaddset(&unblocked_sigs, SR_signum);\n\n  if (!ReduceSignalUsage) {\n   if (!os::Aix::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n     sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n     sigaddset(&allowdebug_blocked_sigs, SHUTDOWN1_SIGNAL);\n   }\n   if (!os::Aix::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n     sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n     sigaddset(&allowdebug_blocked_sigs, SHUTDOWN2_SIGNAL);\n   }\n   if (!os::Aix::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n     sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n     sigaddset(&allowdebug_blocked_sigs, SHUTDOWN3_SIGNAL);\n   }\n  }\n  // Fill in signals that are blocked by all but the VM thread.\n  sigemptyset(&vm_sigs);\n  if (!ReduceSignalUsage)\n    sigaddset(&vm_sigs, BREAK_SIGNAL);\n  debug_only(signal_sets_initialized = true);\n}\n\n// These are signals that are unblocked while a thread is running Java.\n// (For some reason, they get blocked by default.)\nsigset_t* os::Aix::unblocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &unblocked_sigs;\n}\n\n// These are the signals that are blocked while a (non-VM) thread is\n// running Java. Only the VM thread handles these signals.\nsigset_t* os::Aix::vm_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &vm_sigs;\n}\n\n// These are signals that are blocked during cond_wait to allow debugger in\nsigset_t* os::Aix::allowdebug_blocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &allowdebug_blocked_sigs;\n}\n\nvoid os::Aix::hotspot_sigmask(Thread* thread) {\n\n  //Save caller's signal mask before setting VM signal mask\n  sigset_t caller_sigmask;\n  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n\n  OSThread* osthread = thread->osthread();\n  osthread->set_caller_sigmask(caller_sigmask);\n\n  pthread_sigmask(SIG_UNBLOCK, os::Aix::unblocked_signals(), NULL);\n\n  if (!ReduceSignalUsage) {\n    if (thread->is_VM_thread()) {\n      // Only the VM thread handles BREAK_SIGNAL ...\n      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n    } else {\n      // ... all other threads block BREAK_SIGNAL\n      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n    }\n  }\n}\n\n// retrieve memory information.\n// Returns false if something went wrong;\n// content of pmi undefined in this case.\nbool os::Aix::get_meminfo(meminfo_t* pmi) {\n\n  assert(pmi, \"get_meminfo: invalid parameter\");\n\n  memset(pmi, 0, sizeof(meminfo_t));\n\n  if (os::Aix::on_pase()) {\n\n    Unimplemented();\n    return false;\n\n  } else {\n\n    // On AIX, I use the (dynamically loaded) perfstat library to retrieve memory statistics\n    // See:\n    // http://publib.boulder.ibm.com/infocenter/systems/index.jsp\n    //        ?topic=/com.ibm.aix.basetechref/doc/basetrf1/perfstat_memtot.htm\n    // http://publib.boulder.ibm.com/infocenter/systems/index.jsp\n    //        ?topic=/com.ibm.aix.files/doc/aixfiles/libperfstat.h.htm\n\n    perfstat_memory_total_t psmt;\n    memset (&psmt, '\\0', sizeof(psmt));\n    const int rc = libperfstat::perfstat_memory_total(NULL, &psmt, sizeof(psmt), 1);\n    if (rc == -1) {\n      fprintf(stderr, \"perfstat_memory_total() failed (errno=%d)\\n\", errno);\n      assert(0, \"perfstat_memory_total() failed\");\n      return false;\n    }\n\n    assert(rc == 1, \"perfstat_memory_total() - weird return code\");\n\n    // excerpt from\n    // http://publib.boulder.ibm.com/infocenter/systems/index.jsp\n    //        ?topic=/com.ibm.aix.files/doc/aixfiles/libperfstat.h.htm\n    // The fields of perfstat_memory_total_t:\n    // u_longlong_t virt_total         Total virtual memory (in 4 KB pages).\n    // u_longlong_t real_total         Total real memory (in 4 KB pages).\n    // u_longlong_t real_free          Free real memory (in 4 KB pages).\n    // u_longlong_t pgsp_total         Total paging space (in 4 KB pages).\n    // u_longlong_t pgsp_free          Free paging space (in 4 KB pages).\n\n    pmi->virt_total = psmt.virt_total * 4096;\n    pmi->real_total = psmt.real_total * 4096;\n    pmi->real_free = psmt.real_free * 4096;\n    pmi->pgsp_total = psmt.pgsp_total * 4096;\n    pmi->pgsp_free = psmt.pgsp_free * 4096;\n\n    return true;\n\n  }\n} // end os::Aix::get_meminfo\n\n// Retrieve global cpu information.\n// Returns false if something went wrong;\n// the content of pci is undefined in this case.\nbool os::Aix::get_cpuinfo(cpuinfo_t* pci) {\n  assert(pci, \"get_cpuinfo: invalid parameter\");\n  memset(pci, 0, sizeof(cpuinfo_t));\n\n  perfstat_cpu_total_t psct;\n  memset (&psct, '\\0', sizeof(psct));\n\n  if (-1 == libperfstat::perfstat_cpu_total(NULL, &psct, sizeof(perfstat_cpu_total_t), 1)) {\n    fprintf(stderr, \"perfstat_cpu_total() failed (errno=%d)\\n\", errno);\n    assert(0, \"perfstat_cpu_total() failed\");\n    return false;\n  }\n\n  // global cpu information\n  strcpy (pci->description, psct.description);\n  pci->processorHZ = psct.processorHZ;\n  pci->ncpus = psct.ncpus;\n  os::Aix::_logical_cpus = psct.ncpus;\n  for (int i = 0; i < 3; i++) {\n    pci->loadavg[i] = (double) psct.loadavg[i] / (1 << SBITS);\n  }\n\n  // get the processor version from _system_configuration\n  switch (_system_configuration.version) {\n  case PV_8:\n    strcpy(pci->version, \"Power PC 8\");\n    break;\n  case PV_7:\n    strcpy(pci->version, \"Power PC 7\");\n    break;\n  case PV_6_1:\n    strcpy(pci->version, \"Power PC 6 DD1.x\");\n    break;\n  case PV_6:\n    strcpy(pci->version, \"Power PC 6\");\n    break;\n  case PV_5:\n    strcpy(pci->version, \"Power PC 5\");\n    break;\n  case PV_5_2:\n    strcpy(pci->version, \"Power PC 5_2\");\n    break;\n  case PV_5_3:\n    strcpy(pci->version, \"Power PC 5_3\");\n    break;\n  case PV_5_Compat:\n    strcpy(pci->version, \"PV_5_Compat\");\n    break;\n  case PV_6_Compat:\n    strcpy(pci->version, \"PV_6_Compat\");\n    break;\n  case PV_7_Compat:\n    strcpy(pci->version, \"PV_7_Compat\");\n    break;\n  case PV_8_Compat:\n    strcpy(pci->version, \"PV_8_Compat\");\n    break;\n  default:\n    strcpy(pci->version, \"unknown\");\n  }\n\n  return true;\n\n} //end os::Aix::get_cpuinfo\n\n//////////////////////////////////////////////////////////////////////////////\n// detecting pthread library\n\nvoid os::Aix::libpthread_init() {\n  return;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// create new thread\n\n// Thread start routine for all newly created threads\nstatic void *java_start(Thread *thread) {\n\n  // find out my own stack dimensions\n  {\n    // actually, this should do exactly the same as thread->record_stack_base_and_size...\n    address base = 0;\n    size_t size = 0;\n    query_stack_dimensions(&base, &size);\n    thread->set_stack_base(base);\n    thread->set_stack_size(size);\n  }\n\n  // Do some sanity checks.\n  CHECK_CURRENT_STACK_PTR(thread->stack_base(), thread->stack_size());\n\n  // Try to randomize the cache line index of hot stack frames.\n  // This helps when threads of the same stack traces evict each other's\n  // cache lines. The threads can be either from the same JVM instance, or\n  // from different JVM instances. The benefit is especially true for\n  // processors with hyperthreading technology.\n\n  static int counter = 0;\n  int pid = os::current_process_id();\n  alloca(((pid ^ counter++) & 7) * 128);\n\n  ThreadLocalStorage::set_thread(thread);\n\n  OSThread* osthread = thread->osthread();\n\n  // thread_id is kernel thread id (similar to Solaris LWP id)\n  osthread->set_thread_id(os::Aix::gettid());\n\n  // initialize signal mask for this thread\n  os::Aix::hotspot_sigmask(thread);\n\n  // initialize floating point control register\n  os::Aix::init_thread_fpu_state();\n\n  assert(osthread->get_state() == RUNNABLE, \"invalid os thread state\");\n\n  // call one more level start routine\n  thread->run();\n\n  return 0;\n}\n\nbool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) {\n\n  // We want the whole function to be synchronized.\n  ThreadCritical cs;\n\n  assert(thread->osthread() == NULL, \"caller responsible\");\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // set the correct thread state\n  osthread->set_thread_type(thr_type);\n\n  // Initial state is ALLOCATED but not INITIALIZED\n  osthread->set_state(ALLOCATED);\n\n  thread->set_osthread(osthread);\n\n  // init thread attributes\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  guarantee(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) == 0, \"???\");\n\n  // Make sure we run in 1:1 kernel-user-thread mode.\n  if (os::Aix::on_aix()) {\n    guarantee(pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM) == 0, \"???\");\n    guarantee(pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED) == 0, \"???\");\n  } // end: aix\n\n  // Start in suspended state, and in os::thread_start, wake the thread up.\n  guarantee(pthread_attr_setsuspendstate_np(&attr, PTHREAD_CREATE_SUSPENDED_NP) == 0, \"???\");\n\n  // calculate stack size if it's not specified by caller\n  if (os::Aix::supports_variable_stack_size()) {\n    if (stack_size == 0) {\n      stack_size = os::Aix::default_stack_size(thr_type);\n\n      switch (thr_type) {\n      case os::java_thread:\n        // Java threads use ThreadStackSize whose default value can be changed with the flag -Xss.\n        assert(JavaThread::stack_size_at_create() > 0, \"this should be set\");\n        stack_size = JavaThread::stack_size_at_create();\n        break;\n      case os::compiler_thread:\n        if (CompilerThreadStackSize > 0) {\n          stack_size = (size_t)(CompilerThreadStackSize * K);\n          break;\n        } // else fall through:\n          // use VMThreadStackSize if CompilerThreadStackSize is not defined\n      case os::vm_thread:\n      case os::pgc_thread:\n      case os::cgc_thread:\n      case os::watcher_thread:\n        if (VMThreadStackSize > 0) stack_size = (size_t)(VMThreadStackSize * K);\n        break;\n      }\n    }\n\n    stack_size = MAX2(stack_size, os::Aix::min_stack_allowed);\n    pthread_attr_setstacksize(&attr, stack_size);\n  } //else let thread_create() pick the default value (96 K on AIX)\n\n  pthread_t tid;\n  int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);\n\n  pthread_attr_destroy(&attr);\n\n  if (ret == 0) {\n    // PPC port traceOsMisc((\"Created New Thread : pthread-id %u\", tid));\n  } else {\n    if (PrintMiscellaneous && (Verbose || WizardMode)) {\n      perror(\"pthread_create()\");\n    }\n    // Need to clean up stuff we've allocated so far\n    thread->set_osthread(NULL);\n    delete osthread;\n    return false;\n  }\n\n  // Store pthread info into the OSThread\n  osthread->set_pthread_id(tid);\n\n  return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// attach existing thread\n\n// bootstrap the main thread\nbool os::create_main_thread(JavaThread* thread) {\n  assert(os::Aix::_main_thread == pthread_self(), \"should be called inside main thread\");\n  return create_attached_thread(thread);\n}\n\nbool os::create_attached_thread(JavaThread* thread) {\n#ifdef ASSERT\n    thread->verify_not_published();\n#endif\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // Store pthread info into the OSThread\n  osthread->set_thread_id(os::Aix::gettid());\n  osthread->set_pthread_id(::pthread_self());\n\n  // initialize floating point control register\n  os::Aix::init_thread_fpu_state();\n\n  // some sanity checks\n  CHECK_CURRENT_STACK_PTR(thread->stack_base(), thread->stack_size());\n\n  // Initial thread state is RUNNABLE\n  osthread->set_state(RUNNABLE);\n\n  thread->set_osthread(osthread);\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n\n  // initialize signal mask for this thread\n  // and save the caller's signal mask\n  os::Aix::hotspot_sigmask(thread);\n\n  return true;\n}\n\nvoid os::pd_start_thread(Thread* thread) {\n  int status = pthread_continue_np(thread->osthread()->pthread_id());\n  assert(status == 0, \"thr_continue failed\");\n}\n\n// Free OS resources related to the OSThread\nvoid os::free_thread(OSThread* osthread) {\n  assert(osthread != NULL, \"osthread not set\");\n\n  if (Thread::current()->osthread() == osthread) {\n    // Restore caller's signal mask\n    sigset_t sigmask = osthread->caller_sigmask();\n    pthread_sigmask(SIG_SETMASK, &sigmask, NULL);\n   }\n\n  delete osthread;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// thread local storage\n\nint os::allocate_thread_local_storage() {\n  pthread_key_t key;\n  int rslt = pthread_key_create(&key, NULL);\n  assert(rslt == 0, \"cannot allocate thread local storage\");\n  return (int)key;\n}\n\n// Note: This is currently not used by VM, as we don't destroy TLS key\n// on VM exit.\nvoid os::free_thread_local_storage(int index) {\n  int rslt = pthread_key_delete((pthread_key_t)index);\n  assert(rslt == 0, \"invalid index\");\n}\n\nvoid os::thread_local_storage_at_put(int index, void* value) {\n  int rslt = pthread_setspecific((pthread_key_t)index, value);\n  assert(rslt == 0, \"pthread_setspecific failed\");\n}\n\nextern \"C\" Thread* get_thread() {\n  return ThreadLocalStorage::thread();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// time support\n\n// Time since start-up in seconds to a fine granularity.\n// Used by VMSelfDestructTimer and the MemProfiler.\ndouble os::elapsedTime() {\n  return (double)(os::elapsed_counter()) * 0.000001;\n}\n\njlong os::elapsed_counter() {\n  timeval time;\n  int status = gettimeofday(&time, NULL);\n  return jlong(time.tv_sec) * 1000 * 1000 + jlong(time.tv_usec) - initial_time_count;\n}\n\njlong os::elapsed_frequency() {\n  return (1000 * 1000);\n}\n\n// For now, we say that linux does not support vtime. I have no idea\n// whether it can actually be made to (DLD, 9/13/05).\n\nbool os::supports_vtime() { return false; }\nbool os::enable_vtime()   { return false; }\nbool os::vtime_enabled()  { return false; }\ndouble os::elapsedVTime() {\n  // better than nothing, but not much\n  return elapsedTime();\n}\n\njlong os::javaTimeMillis() {\n  timeval time;\n  int status = gettimeofday(&time, NULL);\n  assert(status != -1, \"aix error at gettimeofday()\");\n  return jlong(time.tv_sec) * 1000 + jlong(time.tv_usec / 1000);\n}\n\n// We need to manually declare mread_real_time,\n// because IBM didn't provide a prototype in time.h.\n// (they probably only ever tested in C, not C++)\nextern \"C\"\nint mread_real_time(timebasestruct_t *t, size_t size_of_timebasestruct_t);\n\njlong os::javaTimeNanos() {\n  if (os::Aix::on_pase()) {\n    Unimplemented();\n    return 0;\n  } else {\n    // On AIX use the precision of processors real time clock\n    // or time base registers.\n    timebasestruct_t time;\n    int rc;\n\n    // If the CPU has a time register, it will be used and\n    // we have to convert to real time first. After convertion we have following data:\n    // time.tb_high [seconds since 00:00:00 UTC on 1.1.1970]\n    // time.tb_low  [nanoseconds after the last full second above]\n    // We better use mread_real_time here instead of read_real_time\n    // to ensure that we will get a monotonic increasing time.\n    if (mread_real_time(&time, TIMEBASE_SZ) != RTC_POWER) {\n      rc = time_base_to_time(&time, TIMEBASE_SZ);\n      assert(rc != -1, \"aix error at time_base_to_time()\");\n    }\n    return jlong(time.tb_high) * (1000 * 1000 * 1000) + jlong(time.tb_low);\n  }\n}\n\nvoid os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n  {\n    // gettimeofday - based on time in seconds since the Epoch thus does not wrap\n    info_ptr->max_value = ALL_64_BITS;\n\n    // gettimeofday is a real time clock so it skips\n    info_ptr->may_skip_backward = true;\n    info_ptr->may_skip_forward = true;\n  }\n\n  info_ptr->kind = JVMTI_TIMER_ELAPSED;    // elapsed not CPU time\n}\n\n// Return the real, user, and system times in seconds from an\n// arbitrary fixed point in the past.\nbool os::getTimesSecs(double* process_real_time,\n                      double* process_user_time,\n                      double* process_system_time) {\n  struct tms ticks;\n  clock_t real_ticks = times(&ticks);\n\n  if (real_ticks == (clock_t) (-1)) {\n    return false;\n  } else {\n    double ticks_per_second = (double) clock_tics_per_sec;\n    *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;\n    *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;\n    *process_real_time = ((double) real_ticks) / ticks_per_second;\n\n    return true;\n  }\n}\n\nchar * os::local_time_string(char *buf, size_t buflen) {\n  struct tm t;\n  time_t long_time;\n  time(&long_time);\n  localtime_r(&long_time, &t);\n  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n               t.tm_hour, t.tm_min, t.tm_sec);\n  return buf;\n}\n\nstruct tm* os::localtime_pd(const time_t* clock, struct tm* res) {\n  return localtime_r(clock, res);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// runtime exit support\n\n// Note: os::shutdown() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::shutdown(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::shutdown() {\n\n  // allow PerfMemory to attempt cleanup of any persistent resources\n  perfMemory_exit();\n\n  // needs to remove object in file system\n  AttachListener::abort();\n\n  // flush buffered output, finish log files\n  ostream_abort();\n\n  // Check for abort hook\n  abort_hook_t abort_hook = Arguments::abort_hook();\n  if (abort_hook != NULL) {\n    abort_hook();\n  }\n}\n\n// Note: os::abort() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::abort(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::abort(bool dump_core) {\n  os::shutdown();\n  if (dump_core) {\n#ifndef PRODUCT\n    fdStream out(defaultStream::output_fd());\n    out.print_raw(\"Current thread is \");\n    char buf[16];\n    jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());\n    out.print_raw_cr(buf);\n    out.print_raw_cr(\"Dumping core ...\");\n#endif\n    ::abort(); // dump core\n  }\n\n  ::exit(1);\n}\n\n// Die immediately, no exit hook, no abort hook, no cleanup.\nvoid os::die() {\n  ::abort();\n}\n\n// This method is a copy of JDK's sysGetLastErrorString\n// from src/solaris/hpi/src/system_md.c\n\nsize_t os::lasterror(char *buf, size_t len) {\n  if (errno == 0) return 0;\n\n  const char *s = ::strerror(errno);\n  size_t n = ::strlen(s);\n  if (n >= len) {\n    n = len - 1;\n  }\n  ::strncpy(buf, s, n);\n  buf[n] = '\\0';\n  return n;\n}\n\nintx os::current_thread_id() { return (intx)pthread_self(); }\n\nint os::current_process_id() {\n\n  // This implementation returns a unique pid, the pid of the\n  // launcher thread that starts the vm 'process'.\n\n  // Under POSIX, getpid() returns the same pid as the\n  // launcher thread rather than a unique pid per thread.\n  // Use gettid() if you want the old pre NPTL behaviour.\n\n  // if you are looking for the result of a call to getpid() that\n  // returns a unique pid for the calling thread, then look at the\n  // OSThread::thread_id() method in osThread_linux.hpp file\n\n  return (int)(_initial_pid ? _initial_pid : getpid());\n}\n\n// DLL functions\n\nconst char* os::dll_file_extension() { return \".so\"; }\n\n// This must be hard coded because it's the system's temporary\n// directory not the java application's temp directory, ala java.io.tmpdir.\nconst char* os::get_temp_directory() { return \"/tmp\"; }\n\nstatic bool file_exists(const char* filename) {\n  struct stat statbuf;\n  if (filename == NULL || strlen(filename) == 0) {\n    return false;\n  }\n  return os::stat(filename, &statbuf) == 0;\n}\n\nbool os::dll_build_name(char* buffer, size_t buflen,\n                        const char* pname, const char* fname) {\n  bool retval = false;\n  // Copied from libhpi\n  const size_t pnamelen = pname ? strlen(pname) : 0;\n\n  // Return error on buffer overflow.\n  if (pnamelen + strlen(fname) + 10 > (size_t) buflen) {\n    *buffer = '\\0';\n    return retval;\n  }\n\n  if (pnamelen == 0) {\n    snprintf(buffer, buflen, \"lib%s.so\", fname);\n    retval = true;\n  } else if (strchr(pname, *os::path_separator()) != NULL) {\n    int n;\n    char** pelements = split_path(pname, &n);\n    for (int i = 0; i < n; i++) {\n      // Really shouldn't be NULL, but check can't hurt\n      if (pelements[i] == NULL || strlen(pelements[i]) == 0) {\n        continue; // skip the empty path values\n      }\n      snprintf(buffer, buflen, \"%s/lib%s.so\", pelements[i], fname);\n      if (file_exists(buffer)) {\n        retval = true;\n        break;\n      }\n    }\n    // release the storage\n    for (int i = 0; i < n; i++) {\n      if (pelements[i] != NULL) {\n        FREE_C_HEAP_ARRAY(char, pelements[i], mtInternal);\n      }\n    }\n    if (pelements != NULL) {\n      FREE_C_HEAP_ARRAY(char*, pelements, mtInternal);\n    }\n  } else {\n    snprintf(buffer, buflen, \"%s/lib%s.so\", pname, fname);\n    retval = true;\n  }\n  return retval;\n}\n\n// Check if addr is inside libjvm.so.\nbool os::address_is_in_vm(address addr) {\n\n  // Input could be a real pc or a function pointer literal. The latter\n  // would be a function descriptor residing in the data segment of a module.\n\n  const LoadedLibraryModule* lib = LoadedLibraries::find_for_text_address(addr);\n  if (lib) {\n    if (strcmp(lib->get_shortname(), \"libjvm.so\") == 0) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    lib = LoadedLibraries::find_for_data_address(addr);\n    if (lib) {\n      if (strcmp(lib->get_shortname(), \"libjvm.so\") == 0) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n}\n\n// Resolve an AIX function descriptor literal to a code pointer.\n// If the input is a valid code pointer to a text segment of a loaded module,\n//   it is returned unchanged.\n// If the input is a valid AIX function descriptor, it is resolved to the\n//   code entry point.\n// If the input is neither a valid function descriptor nor a valid code pointer,\n//   NULL is returned.\nstatic address resolve_function_descriptor_to_code_pointer(address p) {\n\n  const LoadedLibraryModule* lib = LoadedLibraries::find_for_text_address(p);\n  if (lib) {\n    // its a real code pointer\n    return p;\n  } else {\n    lib = LoadedLibraries::find_for_data_address(p);\n    if (lib) {\n      // pointer to data segment, potential function descriptor\n      address code_entry = (address)(((FunctionDescriptor*)p)->entry());\n      if (LoadedLibraries::find_for_text_address(code_entry)) {\n        // Its a function descriptor\n        return code_entry;\n      }\n    }\n  }\n  return NULL;\n}\n\nbool os::dll_address_to_function_name(address addr, char *buf,\n                                      int buflen, int *offset) {\n  if (offset) {\n    *offset = -1;\n  }\n  // Buf is not optional, but offset is optional.\n  assert(buf != NULL, \"sanity check\");\n  buf[0] = '\\0';\n\n  // Resolve function ptr literals first.\n  addr = resolve_function_descriptor_to_code_pointer(addr);\n  if (!addr) {\n    return false;\n  }\n\n  // Go through Decoder::decode to call getFuncName which reads the name from the traceback table.\n  return Decoder::decode(addr, buf, buflen, offset);\n}\n\nstatic int getModuleName(codeptr_t pc,                    // [in] program counter\n                         char* p_name, size_t namelen,    // [out] optional: function name\n                         char* p_errmsg, size_t errmsglen // [out] optional: user provided buffer for error messages\n                         ) {\n\n  // initialize output parameters\n  if (p_name && namelen > 0) {\n    *p_name = '\\0';\n  }\n  if (p_errmsg && errmsglen > 0) {\n    *p_errmsg = '\\0';\n  }\n\n  const LoadedLibraryModule* const lib = LoadedLibraries::find_for_text_address((address)pc);\n  if (lib) {\n    if (p_name && namelen > 0) {\n      sprintf(p_name, \"%.*s\", namelen, lib->get_shortname());\n    }\n    return 0;\n  }\n\n  trcVerbose(\"pc outside any module\");\n\n  return -1;\n}\n\nbool os::dll_address_to_library_name(address addr, char* buf,\n                                     int buflen, int* offset) {\n  if (offset) {\n    *offset = -1;\n  }\n  // Buf is not optional, but offset is optional.\n  assert(buf != NULL, \"sanity check\");\n  buf[0] = '\\0';\n\n  // Resolve function ptr literals first.\n  addr = resolve_function_descriptor_to_code_pointer(addr);\n  if (!addr) {\n    return false;\n  }\n\n  if (::getModuleName((codeptr_t) addr, buf, buflen, 0, 0) == 0) {\n    return true;\n  }\n  return false;\n}\n\n// Loads .dll/.so and in case of error it checks if .dll/.so was built\n// for the same architecture as Hotspot is running on.\nvoid *os::dll_load(const char *filename, char *ebuf, int ebuflen) {\n\n  if (ebuf && ebuflen > 0) {\n    ebuf[0] = '\\0';\n    ebuf[ebuflen - 1] = '\\0';\n  }\n\n  if (!filename || strlen(filename) == 0) {\n    ::strncpy(ebuf, \"dll_load: empty filename specified\", ebuflen - 1);\n    return NULL;\n  }\n\n  // RTLD_LAZY is currently not implemented. The dl is loaded immediately with all its dependants.\n  void * result= ::dlopen(filename, RTLD_LAZY);\n  if (result != NULL) {\n    // Reload dll cache. Don't do this in signal handling.\n    LoadedLibraries::reload();\n    return result;\n  } else {\n    // error analysis when dlopen fails\n    const char* const error_report = ::dlerror();\n    if (error_report && ebuf && ebuflen > 0) {\n      snprintf(ebuf, ebuflen - 1, \"%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s\",\n               filename, ::getenv(\"LIBPATH\"), ::getenv(\"LD_LIBRARY_PATH\"), error_report);\n    }\n  }\n  return NULL;\n}\n\n// Glibc-2.0 libdl is not MT safe. If you are building with any glibc,\n// chances are you might want to run the generated bits against glibc-2.0\n// libdl.so, so always use locking for any version of glibc.\nvoid* os::dll_lookup(void* handle, const char* name) {\n  pthread_mutex_lock(&dl_mutex);\n  void* res = dlsym(handle, name);\n  pthread_mutex_unlock(&dl_mutex);\n  return res;\n}\n\nvoid* os::get_default_process_handle() {\n  return (void*)::dlopen(NULL, RTLD_LAZY);\n}\n\nvoid os::print_dll_info(outputStream *st) {\n  st->print_cr(\"Dynamic libraries:\");\n  LoadedLibraries::print(st);\n}\n\nvoid os::print_os_info(outputStream* st) {\n  st->print(\"OS:\");\n\n  st->print(\"uname:\");\n  struct utsname name;\n  uname(&name);\n  st->print(name.sysname); st->print(\" \");\n  st->print(name.nodename); st->print(\" \");\n  st->print(name.release); st->print(\" \");\n  st->print(name.version); st->print(\" \");\n  st->print(name.machine);\n  st->cr();\n\n  // rlimit\n  st->print(\"rlimit:\");\n  struct rlimit rlim;\n\n  st->print(\" STACK \");\n  getrlimit(RLIMIT_STACK, &rlim);\n  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n  else st->print(\"%uk\", rlim.rlim_cur >> 10);\n\n  st->print(\", CORE \");\n  getrlimit(RLIMIT_CORE, &rlim);\n  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n  else st->print(\"%uk\", rlim.rlim_cur >> 10);\n\n  st->print(\", NPROC \");\n  st->print(\"%d\", sysconf(_SC_CHILD_MAX));\n\n  st->print(\", NOFILE \");\n  getrlimit(RLIMIT_NOFILE, &rlim);\n  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n  else st->print(\"%d\", rlim.rlim_cur);\n\n  st->print(\", AS \");\n  getrlimit(RLIMIT_AS, &rlim);\n  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n  else st->print(\"%uk\", rlim.rlim_cur >> 10);\n\n  // Print limits on DATA, because it limits the C-heap.\n  st->print(\", DATA \");\n  getrlimit(RLIMIT_DATA, &rlim);\n  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n  else st->print(\"%uk\", rlim.rlim_cur >> 10);\n  st->cr();\n\n  // load average\n  st->print(\"load average:\");\n  double loadavg[3] = {-1.L, -1.L, -1.L};\n  os::loadavg(loadavg, 3);\n  st->print(\"%0.02f %0.02f %0.02f\", loadavg[0], loadavg[1], loadavg[2]);\n  st->cr();\n}\n\nvoid os::print_memory_info(outputStream* st) {\n\n  st->print_cr(\"Memory:\");\n\n  st->print_cr(\"  default page size: %s\", describe_pagesize(os::vm_page_size()));\n  st->print_cr(\"  default stack page size: %s\", describe_pagesize(os::vm_page_size()));\n  st->print_cr(\"  default shm page size: %s\", describe_pagesize(os::Aix::shm_default_page_size()));\n  st->print_cr(\"  can use 64K pages dynamically: %s\", (os::Aix::can_use_64K_pages() ? \"yes\" :\"no\"));\n  st->print_cr(\"  can use 16M pages dynamically: %s\", (os::Aix::can_use_16M_pages() ? \"yes\" :\"no\"));\n  if (g_multipage_error != 0) {\n    st->print_cr(\"  multipage error: %d\", g_multipage_error);\n  }\n\n  // print out LDR_CNTRL because it affects the default page sizes\n  const char* const ldr_cntrl = ::getenv(\"LDR_CNTRL\");\n  st->print_cr(\"  LDR_CNTRL=%s.\", ldr_cntrl ? ldr_cntrl : \"<unset>\");\n\n  const char* const extshm = ::getenv(\"EXTSHM\");\n  st->print_cr(\"  EXTSHM=%s.\", extshm ? extshm : \"<unset>\");\n\n  // Call os::Aix::get_meminfo() to retrieve memory statistics.\n  os::Aix::meminfo_t mi;\n  if (os::Aix::get_meminfo(&mi)) {\n    char buffer[256];\n    if (os::Aix::on_aix()) {\n      jio_snprintf(buffer, sizeof(buffer),\n                   \"  physical total : %llu\\n\"\n                   \"  physical free  : %llu\\n\"\n                   \"  swap total     : %llu\\n\"\n                   \"  swap free      : %llu\\n\",\n                   mi.real_total,\n                   mi.real_free,\n                   mi.pgsp_total,\n                   mi.pgsp_free);\n    } else {\n      Unimplemented();\n    }\n    st->print_raw(buffer);\n  } else {\n    st->print_cr(\"  (no more information available)\");\n  }\n}\n\nvoid os::pd_print_cpu_info(outputStream* st) {\n  // cpu\n  st->print(\"CPU:\");\n  st->print(\"total %d\", os::processor_count());\n  // It's not safe to query number of active processors after crash\n  // st->print(\"(active %d)\", os::active_processor_count());\n  st->print(\" %s\", VM_Version::cpu_features());\n  st->cr();\n}\n\nvoid os::print_siginfo(outputStream* st, void* siginfo) {\n  // Use common posix version.\n  os::Posix::print_siginfo_brief(st, (const siginfo_t*) siginfo);\n  st->cr();\n}\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen);\n\nvoid os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n  st->print_cr(\"Signal Handlers:\");\n  print_signal_handler(st, SIGSEGV, buf, buflen);\n  print_signal_handler(st, SIGBUS , buf, buflen);\n  print_signal_handler(st, SIGFPE , buf, buflen);\n  print_signal_handler(st, SIGPIPE, buf, buflen);\n  print_signal_handler(st, SIGXFSZ, buf, buflen);\n  print_signal_handler(st, SIGILL , buf, buflen);\n  print_signal_handler(st, INTERRUPT_SIGNAL, buf, buflen);\n  print_signal_handler(st, SR_signum, buf, buflen);\n  print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n  print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n  print_signal_handler(st, SIGTRAP, buf, buflen);\n  print_signal_handler(st, SIGDANGER, buf, buflen);\n}\n\nstatic char saved_jvm_path[MAXPATHLEN] = {0};\n\n// Find the full path to the current module, libjvm.so.\nvoid os::jvm_path(char *buf, jint buflen) {\n  // Error checking.\n  if (buflen < MAXPATHLEN) {\n    assert(false, \"must use a large-enough buffer\");\n    buf[0] = '\\0';\n    return;\n  }\n  // Lazy resolve the path to current module.\n  if (saved_jvm_path[0] != 0) {\n    strcpy(buf, saved_jvm_path);\n    return;\n  }\n\n  Dl_info dlinfo;\n  int ret = dladdr(CAST_FROM_FN_PTR(void *, os::jvm_path), &dlinfo);\n  assert(ret != 0, \"cannot locate libjvm\");\n  char* rp = realpath((char *)dlinfo.dli_fname, buf);\n  assert(rp != NULL, \"error in realpath(): maybe the 'path' argument is too long?\");\n\n  strcpy(saved_jvm_path, buf);\n}\n\nvoid os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n  // no prefix required, not even \"_\"\n}\n\nvoid os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n  // no suffix required\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// sun.misc.Signal support\n\nstatic volatile jint sigint_count = 0;\n\nstatic void\nUserHandler(int sig, void *siginfo, void *context) {\n  // 4511530 - sem_post is serialized and handled by the manager thread. When\n  // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We\n  // don't want to flood the manager thread with sem_post requests.\n  if (sig == SIGINT && Atomic::add(1, &sigint_count) > 1)\n    return;\n\n  // Ctrl-C is pressed during error reporting, likely because the error\n  // handler fails to abort. Let VM die immediately.\n  if (sig == SIGINT && is_error_reported()) {\n    os::die();\n  }\n\n  os::signal_notify(sig);\n}\n\nvoid* os::user_handler() {\n  return CAST_FROM_FN_PTR(void*, UserHandler);\n}\n\nextern \"C\" {\n  typedef void (*sa_handler_t)(int);\n  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n}\n\nvoid* os::signal(int signal_number, void* handler) {\n  struct sigaction sigAct, oldSigAct;\n\n  sigfillset(&(sigAct.sa_mask));\n\n  // Do not block out synchronous signals in the signal handler.\n  // Blocking synchronous signals only makes sense if you can really\n  // be sure that those signals won't happen during signal handling,\n  // when the blocking applies. Normal signal handlers are lean and\n  // do not cause signals. But our signal handlers tend to be \"risky\"\n  // - secondary SIGSEGV, SIGILL, SIGBUS' may and do happen.\n  // On AIX, PASE there was a case where a SIGSEGV happened, followed\n  // by a SIGILL, which was blocked due to the signal mask. The process\n  // just hung forever. Better to crash from a secondary signal than to hang.\n  sigdelset(&(sigAct.sa_mask), SIGSEGV);\n  sigdelset(&(sigAct.sa_mask), SIGBUS);\n  sigdelset(&(sigAct.sa_mask), SIGILL);\n  sigdelset(&(sigAct.sa_mask), SIGFPE);\n  sigdelset(&(sigAct.sa_mask), SIGTRAP);\n\n  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n\n  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n\n  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n    // -1 means registration failed\n    return (void *)-1;\n  }\n\n  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n}\n\nvoid os::signal_raise(int signal_number) {\n  ::raise(signal_number);\n}\n\n//\n// The following code is moved from os.cpp for making this\n// code platform specific, which it is by its very nature.\n//\n\n// Will be modified when max signal is changed to be dynamic\nint os::sigexitnum_pd() {\n  return NSIG;\n}\n\n// a counter for each possible signal value\nstatic volatile jint pending_signals[NSIG+1] = { 0 };\n\n// Linux(POSIX) specific hand shaking semaphore.\nstatic sem_t sig_sem;\n\nvoid os::signal_init_pd() {\n  // Initialize signal structures\n  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n\n  // Initialize signal semaphore\n  int rc = ::sem_init(&sig_sem, 0, 0);\n  guarantee(rc != -1, \"sem_init failed\");\n}\n\nvoid os::signal_notify(int sig) {\n  Atomic::inc(&pending_signals[sig]);\n  ::sem_post(&sig_sem);\n}\n\nstatic int check_pending_signals(bool wait) {\n  Atomic::store(0, &sigint_count);\n  for (;;) {\n    for (int i = 0; i < NSIG + 1; i++) {\n      jint n = pending_signals[i];\n      if (n > 0 && n == Atomic::cmpxchg(n - 1, &pending_signals[i], n)) {\n        return i;\n      }\n    }\n    if (!wait) {\n      return -1;\n    }\n    JavaThread *thread = JavaThread::current();\n    ThreadBlockInVM tbivm(thread);\n\n    bool threadIsSuspended;\n    do {\n      thread->set_suspend_equivalent();\n      // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n      ::sem_wait(&sig_sem);\n\n      // were we externally suspended while we were waiting?\n      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n      if (threadIsSuspended) {\n        //\n        // The semaphore has been incremented, but while we were waiting\n        // another thread suspended us. We don't want to continue running\n        // while suspended because that would surprise the thread that\n        // suspended us.\n        //\n        ::sem_post(&sig_sem);\n\n        thread->java_suspend_self();\n      }\n    } while (threadIsSuspended);\n  }\n}\n\nint os::signal_lookup() {\n  return check_pending_signals(false);\n}\n\nint os::signal_wait() {\n  return check_pending_signals(true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Virtual Memory\n\n// AddrRange describes an immutable address range\n//\n// This is a helper class for the 'shared memory bookkeeping' below.\nclass AddrRange {\n  friend class ShmBkBlock;\n\n  char* _start;\n  size_t _size;\n\npublic:\n\n  AddrRange(char* start, size_t size)\n    : _start(start), _size(size)\n  {}\n\n  AddrRange(const AddrRange& r)\n    : _start(r.start()), _size(r.size())\n  {}\n\n  char* start() const { return _start; }\n  size_t size() const { return _size; }\n  char* end() const { return _start + _size; }\n  bool is_empty() const { return _size == 0 ? true : false; }\n\n  static AddrRange empty_range() { return AddrRange(NULL, 0); }\n\n  bool contains(const char* p) const {\n    return start() <= p && end() > p;\n  }\n\n  bool contains(const AddrRange& range) const {\n    return start() <= range.start() && end() >= range.end();\n  }\n\n  bool intersects(const AddrRange& range) const {\n    return (range.start() <= start() && range.end() > start()) ||\n           (range.start() < end() && range.end() >= end()) ||\n           contains(range);\n  }\n\n  bool is_same_range(const AddrRange& range) const {\n    return start() == range.start() && size() == range.size();\n  }\n\n  // return the closest inside range consisting of whole pages\n  AddrRange find_closest_aligned_range(size_t pagesize) const {\n    if (pagesize == 0 || is_empty()) {\n      return empty_range();\n    }\n    char* const from = (char*)align_size_up((intptr_t)_start, pagesize);\n    char* const to = (char*)align_size_down((intptr_t)end(), pagesize);\n    if (from > to) {\n      return empty_range();\n    }\n    return AddrRange(from, to - from);\n  }\n};\n\n////////////////////////////////////////////////////////////////////////////\n// shared memory bookkeeping\n//\n// the os::reserve_memory() API and friends hand out different kind of memory, depending\n// on need and circumstances. Memory may be allocated with mmap() or with shmget/shmat.\n//\n// But these memory types have to be treated differently. For example, to uncommit\n// mmap-based memory, msync(MS_INVALIDATE) is needed, to uncommit shmat-based memory,\n// disclaim64() is needed.\n//\n// Therefore we need to keep track of the allocated memory segments and their\n// properties.\n\n// ShmBkBlock: base class for all blocks in the shared memory bookkeeping\nclass ShmBkBlock {\n\n  ShmBkBlock* _next;\n\nprotected:\n\n  AddrRange _range;\n  const size_t _pagesize;\n  const bool _pinned;\n\npublic:\n\n  ShmBkBlock(AddrRange range, size_t pagesize, bool pinned)\n    : _range(range), _pagesize(pagesize), _pinned(pinned) , _next(NULL) {\n\n    assert(_pagesize == SIZE_4K || _pagesize == SIZE_64K || _pagesize == SIZE_16M, \"invalid page size\");\n    assert(!_range.is_empty(), \"invalid range\");\n  }\n\n  virtual void print(outputStream* st) const {\n    st->print(\"0x%p ... 0x%p (%llu) - %d %s pages - %s\",\n              _range.start(), _range.end(), _range.size(),\n              _range.size() / _pagesize, describe_pagesize(_pagesize),\n              _pinned ? \"pinned\" : \"\");\n  }\n\n  enum Type { MMAP, SHMAT };\n  virtual Type getType() = 0;\n\n  char* base() const { return _range.start(); }\n  size_t size() const { return _range.size(); }\n\n  void setAddrRange(AddrRange range) {\n    _range = range;\n  }\n\n  bool containsAddress(const char* p) const {\n    return _range.contains(p);\n  }\n\n  bool containsRange(const char* p, size_t size) const {\n    return _range.contains(AddrRange((char*)p, size));\n  }\n\n  bool isSameRange(const char* p, size_t size) const {\n    return _range.is_same_range(AddrRange((char*)p, size));\n  }\n\n  virtual bool disclaim(char* p, size_t size) = 0;\n  virtual bool release() = 0;\n\n  // blocks live in a list.\n  ShmBkBlock* next() const { return _next; }\n  void set_next(ShmBkBlock* blk) { _next = blk; }\n\n}; // end: ShmBkBlock\n\n\n// ShmBkMappedBlock: describes an block allocated with mmap()\nclass ShmBkMappedBlock : public ShmBkBlock {\npublic:\n\n  ShmBkMappedBlock(AddrRange range)\n    : ShmBkBlock(range, SIZE_4K, false) {} // mmap: always 4K, never pinned\n\n  void print(outputStream* st) const {\n    ShmBkBlock::print(st);\n    st->print_cr(\" - mmap'ed\");\n  }\n\n  Type getType() {\n    return MMAP;\n  }\n\n  bool disclaim(char* p, size_t size) {\n\n    AddrRange r(p, size);\n\n    guarantee(_range.contains(r), \"invalid disclaim\");\n\n    // only disclaim whole ranges.\n    const AddrRange r2 = r.find_closest_aligned_range(_pagesize);\n    if (r2.is_empty()) {\n      return true;\n    }\n\n    const int rc = ::msync(r2.start(), r2.size(), MS_INVALIDATE);\n\n    if (rc != 0) {\n      warning(\"msync(0x%p, %llu, MS_INVALIDATE) failed (%d)\\n\", r2.start(), r2.size(), errno);\n    }\n\n    return rc == 0 ? true : false;\n  }\n\n  bool release() {\n    // mmap'ed blocks are released using munmap\n    if (::munmap(_range.start(), _range.size()) != 0) {\n      warning(\"munmap(0x%p, %llu) failed (%d)\\n\", _range.start(), _range.size(), errno);\n      return false;\n    }\n    return true;\n  }\n}; // end: ShmBkMappedBlock\n\n// ShmBkShmatedBlock: describes an block allocated with shmget/shmat()\nclass ShmBkShmatedBlock : public ShmBkBlock {\npublic:\n\n  ShmBkShmatedBlock(AddrRange range, size_t pagesize, bool pinned)\n    : ShmBkBlock(range, pagesize, pinned) {}\n\n  void print(outputStream* st) const {\n    ShmBkBlock::print(st);\n    st->print_cr(\" - shmat'ed\");\n  }\n\n  Type getType() {\n    return SHMAT;\n  }\n\n  bool disclaim(char* p, size_t size) {\n\n    AddrRange r(p, size);\n\n    if (_pinned) {\n      return true;\n    }\n\n    // shmat'ed blocks are disclaimed using disclaim64\n    guarantee(_range.contains(r), \"invalid disclaim\");\n\n    // only disclaim whole ranges.\n    const AddrRange r2 = r.find_closest_aligned_range(_pagesize);\n    if (r2.is_empty()) {\n      return true;\n    }\n\n    const bool rc = my_disclaim64(r2.start(), r2.size());\n\n    if (Verbose && !rc) {\n      warning(\"failed to disclaim shm %p-%p\\n\", r2.start(), r2.end());\n    }\n\n    return rc;\n  }\n\n  bool release() {\n    bool rc = false;\n    if (::shmdt(_range.start()) != 0) {\n      warning(\"shmdt(0x%p) failed (%d)\\n\", _range.start(), errno);\n    } else {\n      rc = true;\n    }\n    return rc;\n  }\n\n}; // end: ShmBkShmatedBlock\n\nstatic ShmBkBlock* g_shmbk_list = NULL;\nstatic volatile jint g_shmbk_table_lock = 0;\n\n// keep some usage statistics\nstatic struct {\n  int nodes;    // number of nodes in list\n  size_t bytes; // reserved - not committed - bytes.\n  int reserves; // how often reserve was called\n  int lookups;  // how often a lookup was made\n} g_shmbk_stats = { 0, 0, 0, 0 };\n\n// add information about a shared memory segment to the bookkeeping\nstatic void shmbk_register(ShmBkBlock* p_block) {\n  guarantee(p_block, \"logic error\");\n  p_block->set_next(g_shmbk_list);\n  g_shmbk_list = p_block;\n  g_shmbk_stats.reserves ++;\n  g_shmbk_stats.bytes += p_block->size();\n  g_shmbk_stats.nodes ++;\n}\n\n// remove information about a shared memory segment by its starting address\nstatic void shmbk_unregister(ShmBkBlock* p_block) {\n  ShmBkBlock* p = g_shmbk_list;\n  ShmBkBlock* prev = NULL;\n  while (p) {\n    if (p == p_block) {\n      if (prev) {\n        prev->set_next(p->next());\n      } else {\n        g_shmbk_list = p->next();\n      }\n      g_shmbk_stats.nodes --;\n      g_shmbk_stats.bytes -= p->size();\n      return;\n    }\n    prev = p;\n    p = p->next();\n  }\n  assert(false, \"should not happen\");\n}\n\n// given a pointer, return shared memory bookkeeping record for the segment it points into\n// using the returned block info must happen under lock protection\nstatic ShmBkBlock* shmbk_find_by_containing_address(const char* addr) {\n  g_shmbk_stats.lookups ++;\n  ShmBkBlock* p = g_shmbk_list;\n  while (p) {\n    if (p->containsAddress(addr)) {\n      return p;\n    }\n    p = p->next();\n  }\n  return NULL;\n}\n\n// dump all information about all memory segments allocated with os::reserve_memory()\nvoid shmbk_dump_info() {\n  tty->print_cr(\"-- shared mem bookkeeping (alive: %d segments, %llu bytes, \"\n    \"total reserves: %d total lookups: %d)\",\n    g_shmbk_stats.nodes, g_shmbk_stats.bytes, g_shmbk_stats.reserves, g_shmbk_stats.lookups);\n  const ShmBkBlock* p = g_shmbk_list;\n  int i = 0;\n  while (p) {\n    p->print(tty);\n    p = p->next();\n    i ++;\n  }\n}\n\n#define LOCK_SHMBK     { ThreadCritical _LOCK_SHMBK;\n#define UNLOCK_SHMBK   }\n\n// End: shared memory bookkeeping\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint os::vm_page_size() {\n  // Seems redundant as all get out\n  assert(os::Aix::page_size() != -1, \"must call os::init\");\n  return os::Aix::page_size();\n}\n\n// Aix allocates memory by pages.\nint os::vm_allocation_granularity() {\n  assert(os::Aix::page_size() != -1, \"must call os::init\");\n  return os::Aix::page_size();\n}\n\nint os::Aix::commit_memory_impl(char* addr, size_t size, bool exec) {\n\n  // Commit is a noop. There is no explicit commit\n  // needed on AIX. Memory is committed when touched.\n  //\n  // Debug : check address range for validity\n#ifdef ASSERT\n  LOCK_SHMBK\n    ShmBkBlock* const block = shmbk_find_by_containing_address(addr);\n    if (!block) {\n      fprintf(stderr, \"invalid pointer: \" INTPTR_FORMAT \"\\n\", addr);\n      shmbk_dump_info();\n      assert(false, \"invalid pointer\");\n      return false;\n    } else if (!block->containsRange(addr, size)) {\n      fprintf(stderr, \"invalid range: \" INTPTR_FORMAT \" .. \" INTPTR_FORMAT \"\\n\", addr, addr + size);\n      shmbk_dump_info();\n      assert(false, \"invalid range\");\n      return false;\n    }\n  UNLOCK_SHMBK\n#endif // ASSERT\n\n  return 0;\n}\n\nbool os::pd_commit_memory(char* addr, size_t size, bool exec) {\n  return os::Aix::commit_memory_impl(addr, size, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  os::Aix::commit_memory_impl(addr, size, exec);\n}\n\nint os::Aix::commit_memory_impl(char* addr, size_t size,\n                                size_t alignment_hint, bool exec) {\n  return os::Aix::commit_memory_impl(addr, size, exec);\n}\n\nbool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,\n                          bool exec) {\n  return os::Aix::commit_memory_impl(addr, size, alignment_hint, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size,\n                                  size_t alignment_hint, bool exec,\n                                  const char* mesg) {\n  os::Aix::commit_memory_impl(addr, size, alignment_hint, exec);\n}\n\nbool os::pd_uncommit_memory(char* addr, size_t size) {\n\n  // Delegate to ShmBkBlock class which knows how to uncommit its memory.\n\n  bool rc = false;\n  LOCK_SHMBK\n    ShmBkBlock* const block = shmbk_find_by_containing_address(addr);\n    if (!block) {\n      fprintf(stderr, \"invalid pointer: 0x%p.\\n\", addr);\n      shmbk_dump_info();\n      assert(false, \"invalid pointer\");\n      return false;\n    } else if (!block->containsRange(addr, size)) {\n      fprintf(stderr, \"invalid range: 0x%p .. 0x%p.\\n\", addr, addr + size);\n      shmbk_dump_info();\n      assert(false, \"invalid range\");\n      return false;\n    }\n    rc = block->disclaim(addr, size);\n  UNLOCK_SHMBK\n\n  if (Verbose && !rc) {\n    warning(\"failed to disclaim 0x%p .. 0x%p (0x%llX bytes).\", addr, addr + size, size);\n  }\n  return rc;\n}\n\nbool os::pd_create_stack_guard_pages(char* addr, size_t size) {\n  return os::guard_memory(addr, size);\n}\n\nbool os::remove_stack_guard_pages(char* addr, size_t size) {\n  return os::unguard_memory(addr, size);\n}\n\nvoid os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {\n}\n\nvoid os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n}\n\nvoid os::numa_make_global(char *addr, size_t bytes) {\n}\n\nvoid os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {\n}\n\nbool os::numa_topology_changed() {\n  return false;\n}\n\nsize_t os::numa_get_groups_num() {\n  return 1;\n}\n\nint os::numa_get_group_id() {\n  return 0;\n}\n\nsize_t os::numa_get_leaf_groups(int *ids, size_t size) {\n  if (size > 0) {\n    ids[0] = 0;\n    return 1;\n  }\n  return 0;\n}\n\nbool os::get_page_info(char *start, page_info* info) {\n  return false;\n}\n\nchar *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {\n  return end;\n}\n\n// Flags for reserve_shmatted_memory:\n#define RESSHM_WISHADDR_OR_FAIL                     1\n#define RESSHM_TRY_16M_PAGES                        2\n#define RESSHM_16M_PAGES_OR_FAIL                    4\n\n// Result of reserve_shmatted_memory:\nstruct shmatted_memory_info_t {\n  char* addr;\n  size_t pagesize;\n  bool pinned;\n};\n\n// Reserve a section of shmatted memory.\n// params:\n// bytes [in]: size of memory, in bytes\n// requested_addr [in]: wish address.\n//                      NULL = no wish.\n//                      If RESSHM_WISHADDR_OR_FAIL is set in flags and wish address cannot\n//                      be obtained, function will fail. Otherwise wish address is treated as hint and\n//                      another pointer is returned.\n// flags [in]:          some flags. Valid flags are:\n//                      RESSHM_WISHADDR_OR_FAIL - fail if wish address is given and cannot be obtained.\n//                      RESSHM_TRY_16M_PAGES - try to allocate from 16M page pool\n//                          (requires UseLargePages and Use16MPages)\n//                      RESSHM_16M_PAGES_OR_FAIL - if you cannot allocate from 16M page pool, fail.\n//                          Otherwise any other page size will do.\n// p_info [out] :       holds information about the created shared memory segment.\nstatic bool reserve_shmatted_memory(size_t bytes, char* requested_addr, int flags, shmatted_memory_info_t* p_info) {\n\n  assert(p_info, \"parameter error\");\n\n  // init output struct.\n  p_info->addr = NULL;\n\n  // neither should we be here for EXTSHM=ON.\n  if (os::Aix::extshm()) {\n    ShouldNotReachHere();\n  }\n\n  // extract flags. sanity checks.\n  const bool wishaddr_or_fail =\n    flags & RESSHM_WISHADDR_OR_FAIL;\n  const bool try_16M_pages =\n    flags & RESSHM_TRY_16M_PAGES;\n  const bool f16M_pages_or_fail =\n    flags & RESSHM_16M_PAGES_OR_FAIL;\n\n  // first check: if a wish address is given and it is mandatory, but not aligned to segment boundary,\n  // shmat will fail anyway, so save some cycles by failing right away\n  if (requested_addr && ((uintptr_t)requested_addr % SIZE_256M == 0)) {\n    if (wishaddr_or_fail) {\n      return false;\n    } else {\n      requested_addr = NULL;\n    }\n  }\n\n  char* addr = NULL;\n\n  // Align size of shm up to the largest possible page size, to avoid errors later on when we try to change\n  // pagesize dynamically.\n  const size_t size = align_size_up(bytes, SIZE_16M);\n\n  // reserve the shared segment\n  int shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | S_IRUSR | S_IWUSR);\n  if (shmid == -1) {\n    warning(\"shmget(.., %lld, ..) failed (errno: %d).\", size, errno);\n    return false;\n  }\n\n  // Important note:\n  // It is very important that we, upon leaving this function, do not leave a shm segment alive.\n  // We must right after attaching it remove it from the system. System V shm segments are global and\n  // survive the process.\n  // So, from here on: Do not assert. Do not return. Always do a \"goto cleanup_shm\".\n\n  // try forcing the page size\n  size_t pagesize = -1; // unknown so far\n\n  if (UseLargePages) {\n\n    struct shmid_ds shmbuf;\n    memset(&shmbuf, 0, sizeof(shmbuf));\n\n    // First, try to take from 16M page pool if...\n    if (os::Aix::can_use_16M_pages()  // we can ...\n        && Use16MPages                // we are not explicitly forbidden to do so (-XX:-Use16MPages)..\n        && try_16M_pages) {           // caller wants us to.\n      shmbuf.shm_pagesize = SIZE_16M;\n      if (shmctl(shmid, SHM_PAGESIZE, &shmbuf) == 0) {\n        pagesize = SIZE_16M;\n      } else {\n        warning(\"Failed to allocate %d 16M pages. 16M page pool might be exhausted. (shmctl failed with %d)\",\n                size / SIZE_16M, errno);\n        if (f16M_pages_or_fail) {\n          goto cleanup_shm;\n        }\n      }\n    }\n\n    // Nothing yet? Try setting 64K pages. Note that I never saw this fail, but in theory it might,\n    // because the 64K page pool may also be exhausted.\n    if (pagesize == -1) {\n      shmbuf.shm_pagesize = SIZE_64K;\n      if (shmctl(shmid, SHM_PAGESIZE, &shmbuf) == 0) {\n        pagesize = SIZE_64K;\n      } else {\n        warning(\"Failed to allocate %d 64K pages. (shmctl failed with %d)\",\n                size / SIZE_64K, errno);\n        // here I give up. leave page_size -1 - later, after attaching, we will query the\n        // real page size of the attached memory. (in theory, it may be something different\n        // from 4K if LDR_CNTRL SHM_PSIZE is set)\n      }\n    }\n  }\n\n  // sanity point\n  assert(pagesize == -1 || pagesize == SIZE_16M || pagesize == SIZE_64K, \"wrong page size\");\n\n  // Now attach the shared segment.\n  addr = (char*) shmat(shmid, requested_addr, 0);\n  if (addr == (char*)-1) {\n    // How to handle attach failure:\n    // If it failed for a specific wish address, tolerate this: in that case, if wish address was\n    // mandatory, fail, if not, retry anywhere.\n    // If it failed for any other reason, treat that as fatal error.\n    addr = NULL;\n    if (requested_addr) {\n      if (wishaddr_or_fail) {\n        goto cleanup_shm;\n      } else {\n        addr = (char*) shmat(shmid, NULL, 0);\n        if (addr == (char*)-1) { // fatal\n          addr = NULL;\n          warning(\"shmat failed (errno: %d)\", errno);\n          goto cleanup_shm;\n        }\n      }\n    } else { // fatal\n      addr = NULL;\n      warning(\"shmat failed (errno: %d)\", errno);\n      goto cleanup_shm;\n    }\n  }\n\n  // sanity point\n  assert(addr && addr != (char*) -1, \"wrong address\");\n\n  // after successful Attach remove the segment - right away.\n  if (::shmctl(shmid, IPC_RMID, NULL) == -1) {\n    warning(\"shmctl(%u, IPC_RMID) failed (%d)\\n\", shmid, errno);\n    guarantee(false, \"failed to remove shared memory segment!\");\n  }\n  shmid = -1;\n\n  // query the real page size. In case setting the page size did not work (see above), the system\n  // may have given us something other then 4K (LDR_CNTRL)\n  {\n    const size_t real_pagesize = os::Aix::query_pagesize(addr);\n    if (pagesize != -1) {\n      assert(pagesize == real_pagesize, \"unexpected pagesize after shmat\");\n    } else {\n      pagesize = real_pagesize;\n    }\n  }\n\n  // Now register the reserved block with internal book keeping.\n  LOCK_SHMBK\n    const bool pinned = pagesize >= SIZE_16M ? true : false;\n    ShmBkShmatedBlock* const p_block = new ShmBkShmatedBlock(AddrRange(addr, size), pagesize, pinned);\n    assert(p_block, \"\");\n    shmbk_register(p_block);\n  UNLOCK_SHMBK\n\ncleanup_shm:\n\n  // if we have not done so yet, remove the shared memory segment. This is very important.\n  if (shmid != -1) {\n    if (::shmctl(shmid, IPC_RMID, NULL) == -1) {\n      warning(\"shmctl(%u, IPC_RMID) failed (%d)\\n\", shmid, errno);\n      guarantee(false, \"failed to remove shared memory segment!\");\n    }\n    shmid = -1;\n  }\n\n  // trace\n  if (Verbose && !addr) {\n    if (requested_addr != NULL) {\n      warning(\"failed to shm-allocate 0x%llX bytes at wish address 0x%p.\", size, requested_addr);\n    } else {\n      warning(\"failed to shm-allocate 0x%llX bytes at any address.\", size);\n    }\n  }\n\n  // hand info to caller\n  if (addr) {\n    p_info->addr = addr;\n    p_info->pagesize = pagesize;\n    p_info->pinned = pagesize == SIZE_16M ? true : false;\n  }\n\n  // sanity test:\n  if (requested_addr && addr && wishaddr_or_fail) {\n    guarantee(addr == requested_addr, \"shmat error\");\n  }\n\n  // just one more test to really make sure we have no dangling shm segments.\n  guarantee(shmid == -1, \"dangling shm segments\");\n\n  return addr ? true : false;\n\n} // end: reserve_shmatted_memory\n\n// Reserve memory using mmap. Behaves the same as reserve_shmatted_memory():\n// will return NULL in case of an error.\nstatic char* reserve_mmaped_memory(size_t bytes, char* requested_addr) {\n\n  // if a wish address is given, but not aligned to 4K page boundary, mmap will fail.\n  if (requested_addr && ((uintptr_t)requested_addr % os::vm_page_size() != 0)) {\n    warning(\"Wish address 0x%p not aligned to page boundary.\", requested_addr);\n    return NULL;\n  }\n\n  const size_t size = align_size_up(bytes, SIZE_4K);\n\n  // Note: MAP_SHARED (instead of MAP_PRIVATE) needed to be able to\n  // msync(MS_INVALIDATE) (see os::uncommit_memory)\n  int flags = MAP_ANONYMOUS | MAP_SHARED;\n\n  // MAP_FIXED is needed to enforce requested_addr - manpage is vague about what\n  // it means if wishaddress is given but MAP_FIXED is not set.\n  //\n  // Note however that this changes semantics in SPEC1170 mode insofar as MAP_FIXED\n  // clobbers the address range, which is probably not what the caller wants. That's\n  // why I assert here (again) that the SPEC1170 compat mode is off.\n  // If we want to be able to run under SPEC1170, we have to do some porting and\n  // testing.\n  if (requested_addr != NULL) {\n    assert(!os::Aix::xpg_sus_mode(), \"SPEC1170 mode not allowed.\");\n    flags |= MAP_FIXED;\n  }\n\n  char* addr = (char*)::mmap(requested_addr, size, PROT_READ|PROT_WRITE|PROT_EXEC, flags, -1, 0);\n\n  if (addr == MAP_FAILED) {\n    // attach failed: tolerate for specific wish addresses. Not being able to attach\n    // anywhere is a fatal error.\n    if (requested_addr == NULL) {\n      // It's ok to fail here if the machine has not enough memory.\n      warning(\"mmap(NULL, 0x%llX, ..) failed (%d)\", size, errno);\n    }\n    addr = NULL;\n    goto cleanup_mmap;\n  }\n\n  // If we did request a specific address and that address was not available, fail.\n  if (addr && requested_addr) {\n    guarantee(addr == requested_addr, \"unexpected\");\n  }\n\n  // register this mmap'ed segment with book keeping\n  LOCK_SHMBK\n    ShmBkMappedBlock* const p_block = new ShmBkMappedBlock(AddrRange(addr, size));\n    assert(p_block, \"\");\n    shmbk_register(p_block);\n  UNLOCK_SHMBK\n\ncleanup_mmap:\n\n  // trace\n  if (Verbose) {\n    if (addr) {\n      fprintf(stderr, \"mmap-allocated 0x%p .. 0x%p (0x%llX bytes)\\n\", addr, addr + bytes, bytes);\n    }\n    else {\n      if (requested_addr != NULL) {\n        warning(\"failed to mmap-allocate 0x%llX bytes at wish address 0x%p.\", bytes, requested_addr);\n      } else {\n        warning(\"failed to mmap-allocate 0x%llX bytes at any address.\", bytes);\n      }\n    }\n  }\n\n  return addr;\n\n} // end: reserve_mmaped_memory\n\n// Reserves and attaches a shared memory segment.\n// Will assert if a wish address is given and could not be obtained.\nchar* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {\n  return os::attempt_reserve_memory_at(bytes, requested_addr);\n}\n\nbool os::pd_release_memory(char* addr, size_t size) {\n\n  // delegate to ShmBkBlock class which knows how to uncommit its memory.\n\n  bool rc = false;\n  LOCK_SHMBK\n    ShmBkBlock* const block = shmbk_find_by_containing_address(addr);\n    if (!block) {\n      fprintf(stderr, \"invalid pointer: 0x%p.\\n\", addr);\n      shmbk_dump_info();\n      assert(false, \"invalid pointer\");\n      return false;\n    }\n    else if (!block->isSameRange(addr, size)) {\n      if (block->getType() == ShmBkBlock::MMAP) {\n        // Release only the same range or a the beginning or the end of a range.\n        if (block->base() == addr && size < block->size()) {\n          ShmBkMappedBlock* const b = new ShmBkMappedBlock(AddrRange(block->base() + size, block->size() - size));\n          assert(b, \"\");\n          shmbk_register(b);\n          block->setAddrRange(AddrRange(addr, size));\n        }\n        else if (addr > block->base() && addr + size == block->base() + block->size()) {\n          ShmBkMappedBlock* const b = new ShmBkMappedBlock(AddrRange(block->base(), block->size() - size));\n          assert(b, \"\");\n          shmbk_register(b);\n          block->setAddrRange(AddrRange(addr, size));\n        }\n        else {\n          fprintf(stderr, \"invalid mmap range: 0x%p .. 0x%p.\\n\", addr, addr + size);\n          shmbk_dump_info();\n          assert(false, \"invalid mmap range\");\n          return false;\n        }\n      }\n      else {\n        // Release only the same range. No partial release allowed.\n        // Soften the requirement a bit, because the user may think he owns a smaller size\n        // than the block is due to alignment etc.\n        if (block->base() != addr || block->size() < size) {\n          fprintf(stderr, \"invalid shmget range: 0x%p .. 0x%p.\\n\", addr, addr + size);\n          shmbk_dump_info();\n          assert(false, \"invalid shmget range\");\n          return false;\n        }\n      }\n    }\n    rc = block->release();\n    assert(rc, \"release failed\");\n    // remove block from bookkeeping\n    shmbk_unregister(block);\n    delete block;\n  UNLOCK_SHMBK\n\n  if (!rc) {\n    warning(\"failed to released %lu bytes at 0x%p\", size, addr);\n  }\n\n  return rc;\n}\n\nstatic bool checked_mprotect(char* addr, size_t size, int prot) {\n\n  // Little problem here: if SPEC1170 behaviour is off, mprotect() on AIX will\n  // not tell me if protection failed when trying to protect an un-protectable range.\n  //\n  // This means if the memory was allocated using shmget/shmat, protection wont work\n  // but mprotect will still return 0:\n  //\n  // See http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/mprotect.htm\n\n  bool rc = ::mprotect(addr, size, prot) == 0 ? true : false;\n\n  if (!rc) {\n    const char* const s_errno = strerror(errno);\n    warning(\"mprotect(\" PTR_FORMAT \"-\" PTR_FORMAT \", 0x%X) failed (%s).\", addr, addr + size, prot, s_errno);\n    return false;\n  }\n\n  // mprotect success check\n  //\n  // Mprotect said it changed the protection but can I believe it?\n  //\n  // To be sure I need to check the protection afterwards. Try to\n  // read from protected memory and check whether that causes a segfault.\n  //\n  if (!os::Aix::xpg_sus_mode()) {\n\n    if (StubRoutines::SafeFetch32_stub()) {\n\n      const bool read_protected =\n        (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &&\n         SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;\n\n      if (prot & PROT_READ) {\n        rc = !read_protected;\n      } else {\n        rc = read_protected;\n      }\n    }\n  }\n  if (!rc) {\n    assert(false, \"mprotect failed.\");\n  }\n  return rc;\n}\n\n// Set protections specified\nbool os::protect_memory(char* addr, size_t size, ProtType prot, bool is_committed) {\n  unsigned int p = 0;\n  switch (prot) {\n  case MEM_PROT_NONE: p = PROT_NONE; break;\n  case MEM_PROT_READ: p = PROT_READ; break;\n  case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;\n  case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;\n  default:\n    ShouldNotReachHere();\n  }\n  // is_committed is unused.\n  return checked_mprotect(addr, size, p);\n}\n\nbool os::guard_memory(char* addr, size_t size) {\n  return checked_mprotect(addr, size, PROT_NONE);\n}\n\nbool os::unguard_memory(char* addr, size_t size) {\n  return checked_mprotect(addr, size, PROT_READ|PROT_WRITE|PROT_EXEC);\n}\n\n// Large page support\n\nstatic size_t _large_page_size = 0;\n\n// Enable large page support if OS allows that.\nvoid os::large_page_init() {\n\n  // Note: os::Aix::query_multipage_support must run first.\n\n  if (!UseLargePages) {\n    return;\n  }\n\n  if (!Aix::can_use_64K_pages()) {\n    assert(!Aix::can_use_16M_pages(), \"64K is a precondition for 16M.\");\n    UseLargePages = false;\n    return;\n  }\n\n  if (!Aix::can_use_16M_pages() && Use16MPages) {\n    fprintf(stderr, \"Cannot use 16M pages. Please ensure that there is a 16M page pool \"\n            \" and that the VM runs with CAP_BYPASS_RAC_VMM and CAP_PROPAGATE capabilities.\\n\");\n  }\n\n  // Do not report 16M page alignment as part of os::_page_sizes if we are\n  // explicitly forbidden from using 16M pages. Doing so would increase the\n  // alignment the garbage collector calculates with, slightly increasing\n  // heap usage. We should only pay for 16M alignment if we really want to\n  // use 16M pages.\n  if (Use16MPages && Aix::can_use_16M_pages()) {\n    _large_page_size = SIZE_16M;\n    _page_sizes[0] = SIZE_16M;\n    _page_sizes[1] = SIZE_64K;\n    _page_sizes[2] = SIZE_4K;\n    _page_sizes[3] = 0;\n  } else if (Aix::can_use_64K_pages()) {\n    _large_page_size = SIZE_64K;\n    _page_sizes[0] = SIZE_64K;\n    _page_sizes[1] = SIZE_4K;\n    _page_sizes[2] = 0;\n  }\n\n  if (Verbose) {\n    (\"Default large page size is 0x%llX.\", _large_page_size);\n  }\n} // end: os::large_page_init()\n\nchar* os::reserve_memory_special(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  // \"exec\" is passed in but not used. Creating the shared image for\n  // the code cache doesn't have an SHM_X executable permission to check.\n  Unimplemented();\n  return 0;\n}\n\nbool os::release_memory_special(char* base, size_t bytes) {\n  // detaching the SHM segment will also delete it, see reserve_memory_special()\n  Unimplemented();\n  return false;\n}\n\nsize_t os::large_page_size() {\n  return _large_page_size;\n}\n\nbool os::can_commit_large_page_memory() {\n  // Well, sadly we cannot commit anything at all (see comment in\n  // os::commit_memory) but we claim to so we can make use of large pages\n  return true;\n}\n\nbool os::can_execute_large_page_memory() {\n  // We can do that\n  return true;\n}\n\n// Reserve memory at an arbitrary address, only if that area is\n// available (and not reserved for something else).\nchar* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {\n\n  bool use_mmap = false;\n\n  // mmap: smaller graining, no large page support\n  // shm: large graining (256M), large page support, limited number of shm segments\n  //\n  // Prefer mmap wherever we either do not need large page support or have OS limits\n\n  if (!UseLargePages || bytes < SIZE_16M) {\n    use_mmap = true;\n  }\n\n  char* addr = NULL;\n  if (use_mmap) {\n    addr = reserve_mmaped_memory(bytes, requested_addr);\n  } else {\n    // shmat: wish address is mandatory, and do not try 16M pages here.\n    shmatted_memory_info_t info;\n    const int flags = RESSHM_WISHADDR_OR_FAIL;\n    if (reserve_shmatted_memory(bytes, requested_addr, flags, &info)) {\n      addr = info.addr;\n    }\n  }\n\n  return addr;\n}\n\nsize_t os::read(int fd, void *buf, unsigned int nBytes) {\n  return ::read(fd, buf, nBytes);\n}\n\n#define NANOSECS_PER_MILLISEC 1000000\n\nint os::sleep(Thread* thread, jlong millis, bool interruptible) {\n  assert(thread == Thread::current(), \"thread consistency check\");\n\n  // Prevent nasty overflow in deadline calculation\n  // by handling long sleeps similar to solaris or windows.\n  const jlong limit = INT_MAX;\n  int result;\n  while (millis > limit) {\n    if ((result = os::sleep(thread, limit, interruptible)) != OS_OK) {\n      return result;\n    }\n    millis -= limit;\n  }\n\n  ParkEvent * const slp = thread->_SleepEvent;\n  slp->reset();\n  OrderAccess::fence();\n\n  if (interruptible) {\n    jlong prevtime = javaTimeNanos();\n\n    // Prevent precision loss and too long sleeps\n    jlong deadline = prevtime + millis * NANOSECS_PER_MILLISEC;\n\n    for (;;) {\n      if (os::is_interrupted(thread, true)) {\n        return OS_INTRPT;\n      }\n\n      jlong newtime = javaTimeNanos();\n\n      assert(newtime >= prevtime, \"time moving backwards\");\n      // Doing prevtime and newtime in microseconds doesn't help precision,\n      // and trying to round up to avoid lost milliseconds can result in a\n      // too-short delay.\n      millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n\n      if (millis <= 0) {\n        return OS_OK;\n      }\n\n      // Stop sleeping if we passed the deadline\n      if (newtime >= deadline) {\n        return OS_OK;\n      }\n\n      prevtime = newtime;\n\n      {\n        assert(thread->is_Java_thread(), \"sanity check\");\n        JavaThread *jt = (JavaThread *) thread;\n        ThreadBlockInVM tbivm(jt);\n        OSThreadWaitState osts(jt->osthread(), false /* not Object.wait() */);\n\n        jt->set_suspend_equivalent();\n\n        slp->park(millis);\n\n        // were we externally suspended while we were waiting?\n        jt->check_and_wait_while_suspended();\n      }\n    }\n  } else {\n    OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n    jlong prevtime = javaTimeNanos();\n\n    // Prevent precision loss and too long sleeps\n    jlong deadline = prevtime + millis * NANOSECS_PER_MILLISEC;\n\n    for (;;) {\n      // It'd be nice to avoid the back-to-back javaTimeNanos() calls on\n      // the 1st iteration ...\n      jlong newtime = javaTimeNanos();\n\n      if (newtime - prevtime < 0) {\n        // time moving backwards, should only happen if no monotonic clock\n        // not a guarantee() because JVM should not abort on kernel/glibc bugs\n        // - HS14 Commented out as not implemented.\n        // - TODO Maybe we should implement it?\n        //assert(!Aix::supports_monotonic_clock(), \"time moving backwards\");\n      } else {\n        millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n      }\n\n      if (millis <= 0) break;\n\n      if (newtime >= deadline) {\n        break;\n      }\n\n      prevtime = newtime;\n      slp->park(millis);\n    }\n    return OS_OK;\n  }\n}\n\nvoid os::naked_short_sleep(jlong ms) {\n  struct timespec req;\n\n  assert(ms < 1000, \"Un-interruptable sleep, short time use only\");\n  req.tv_sec = 0;\n  if (ms > 0) {\n    req.tv_nsec = (ms % 1000) * 1000000;\n  }\n  else {\n    req.tv_nsec = 1;\n  }\n\n  nanosleep(&req, NULL);\n\n  return;\n}\n\n// Sleep forever; naked call to OS-specific sleep; use with CAUTION\nvoid os::infinite_sleep() {\n  while (true) {    // sleep forever ...\n    ::sleep(100);   // ... 100 seconds at a time\n  }\n}\n\n// Used to convert frequent JVM_Yield() to nops\nbool os::dont_yield() {\n  return DontYieldALot;\n}\n\nvoid os::yield() {\n  sched_yield();\n}\n\nos::YieldResult os::NakedYield() { sched_yield(); return os::YIELD_UNKNOWN; }\n\nvoid os::yield_all(int attempts) {\n  // Yields to all threads, including threads with lower priorities\n  // Threads on Linux are all with same priority. The Solaris style\n  // os::yield_all() with nanosleep(1ms) is not necessary.\n  sched_yield();\n}\n\n// Called from the tight loops to possibly influence time-sharing heuristics\nvoid os::loop_breaker(int attempts) {\n  os::yield_all(attempts);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// thread priority support\n\n// From AIX manpage to pthread_setschedparam\n// (see: http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?\n//    topic=/com.ibm.aix.basetechref/doc/basetrf1/pthread_setschedparam.htm):\n//\n// \"If schedpolicy is SCHED_OTHER, then sched_priority must be in the\n// range from 40 to 80, where 40 is the least favored priority and 80\n// is the most favored.\"\n//\n// (Actually, I doubt this even has an impact on AIX, as we do kernel\n// scheduling there; however, this still leaves iSeries.)\n//\n// We use the same values for AIX and PASE.\nint os::java_to_os_priority[CriticalPriority + 1] = {\n  54,             // 0 Entry should never be used\n\n  55,             // 1 MinPriority\n  55,             // 2\n  56,             // 3\n\n  56,             // 4\n  57,             // 5 NormPriority\n  57,             // 6\n\n  58,             // 7\n  58,             // 8\n  59,             // 9 NearMaxPriority\n\n  60,             // 10 MaxPriority\n\n  60              // 11 CriticalPriority\n};\n\nOSReturn os::set_native_priority(Thread* thread, int newpri) {\n  if (!UseThreadPriorities) return OS_OK;\n  pthread_t thr = thread->osthread()->pthread_id();\n  int policy = SCHED_OTHER;\n  struct sched_param param;\n  param.sched_priority = newpri;\n  int ret = pthread_setschedparam(thr, policy, &param);\n\n  if (ret != 0) {\n    trcVerbose(\"Could not change priority for thread %d to %d (error %d, %s)\",\n        (int)thr, newpri, ret, strerror(ret));\n  }\n  return (ret == 0) ? OS_OK : OS_ERR;\n}\n\nOSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {\n  if (!UseThreadPriorities) {\n    *priority_ptr = java_to_os_priority[NormPriority];\n    return OS_OK;\n  }\n  pthread_t thr = thread->osthread()->pthread_id();\n  int policy = SCHED_OTHER;\n  struct sched_param param;\n  int ret = pthread_getschedparam(thr, &policy, &param);\n  *priority_ptr = param.sched_priority;\n\n  return (ret == 0) ? OS_OK : OS_ERR;\n}\n\n// Hint to the underlying OS that a task switch would not be good.\n// Void return because it's a hint and can fail.\nvoid os::hint_no_preempt() {}\n\n////////////////////////////////////////////////////////////////////////////////\n// suspend/resume support\n\n//  the low-level signal-based suspend/resume support is a remnant from the\n//  old VM-suspension that used to be for java-suspension, safepoints etc,\n//  within hotspot. Now there is a single use-case for this:\n//    - calling get_thread_pc() on the VMThread by the flat-profiler task\n//      that runs in the watcher thread.\n//  The remaining code is greatly simplified from the more general suspension\n//  code that used to be used.\n//\n//  The protocol is quite simple:\n//  - suspend:\n//      - sends a signal to the target thread\n//      - polls the suspend state of the osthread using a yield loop\n//      - target thread signal handler (SR_handler) sets suspend state\n//        and blocks in sigsuspend until continued\n//  - resume:\n//      - sets target osthread state to continue\n//      - sends signal to end the sigsuspend loop in the SR_handler\n//\n//  Note that the SR_lock plays no role in this suspend/resume protocol.\n//\n\nstatic void resume_clear_context(OSThread *osthread) {\n  osthread->set_ucontext(NULL);\n  osthread->set_siginfo(NULL);\n}\n\nstatic void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n  osthread->set_ucontext(context);\n  osthread->set_siginfo(siginfo);\n}\n\n//\n// Handler function invoked when a thread's execution is suspended or\n// resumed. We have to be careful that only async-safe functions are\n// called here (Note: most pthread functions are not async safe and\n// should be avoided.)\n//\n// Note: sigwait() is a more natural fit than sigsuspend() from an\n// interface point of view, but sigwait() prevents the signal hander\n// from being run. libpthread would get very confused by not having\n// its signal handlers run and prevents sigwait()'s use with the\n// mutex granting granting signal.\n//\n// Currently only ever called on the VMThread and JavaThreads (PC sampling).\n//\nstatic void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n  // Save and restore errno to avoid confusing native code with EINTR\n  // after sigsuspend.\n  int old_errno = errno;\n\n  Thread* thread = Thread::current();\n  OSThread* osthread = thread->osthread();\n  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n\n  os::SuspendResume::State current = osthread->sr.state();\n  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n    suspend_save_context(osthread, siginfo, context);\n\n    // attempt to switch the state, we assume we had a SUSPEND_REQUEST\n    os::SuspendResume::State state = osthread->sr.suspended();\n    if (state == os::SuspendResume::SR_SUSPENDED) {\n      sigset_t suspend_set;  // signals for sigsuspend()\n\n      // get current set of blocked signals and unblock resume signal\n      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n      sigdelset(&suspend_set, SR_signum);\n\n      // wait here until we are resumed\n      while (1) {\n        sigsuspend(&suspend_set);\n\n        os::SuspendResume::State result = osthread->sr.running();\n        if (result == os::SuspendResume::SR_RUNNING) {\n          break;\n        }\n      }\n\n    } else if (state == os::SuspendResume::SR_RUNNING) {\n      // request was cancelled, continue\n    } else {\n      ShouldNotReachHere();\n    }\n\n    resume_clear_context(osthread);\n  } else if (current == os::SuspendResume::SR_RUNNING) {\n    // request was cancelled, continue\n  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // ignore\n  } else {\n    ShouldNotReachHere();\n  }\n\n  errno = old_errno;\n}\n\nstatic int SR_initialize() {\n  struct sigaction act;\n  char *s;\n  // Get signal number to use for suspend/resume\n  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n    int sig = ::strtol(s, 0, 10);\n    if (sig > 0 || sig < NSIG) {\n      SR_signum = sig;\n    }\n  }\n\n  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n        \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n\n  sigemptyset(&SR_sigset);\n  sigaddset(&SR_sigset, SR_signum);\n\n  // Set up signal handler for suspend/resume.\n  act.sa_flags = SA_RESTART|SA_SIGINFO;\n  act.sa_handler = (void (*)(int)) SR_handler;\n\n  // SR_signum is blocked by default.\n  // 4528190 - We also need to block pthread restart signal (32 on all\n  // supported Linux platforms). Note that LinuxThreads need to block\n  // this signal for all threads to work properly. So we don't have\n  // to use hard-coded signal number when setting up the mask.\n  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n\n  if (sigaction(SR_signum, &act, 0) == -1) {\n    return -1;\n  }\n\n  // Save signal flag\n  os::Aix::set_our_sigflags(SR_signum, act.sa_flags);\n  return 0;\n}\n\nstatic int SR_finalize() {\n  return 0;\n}\n\nstatic int sr_notify(OSThread* osthread) {\n  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n  assert_status(status == 0, status, \"pthread_kill\");\n  return status;\n}\n\n// \"Randomly\" selected value for how long we want to spin\n// before bailing out on suspending a thread, also how often\n// we send a signal to a thread we want to resume\nstatic const int RANDOMLY_LARGE_INTEGER = 1000000;\nstatic const int RANDOMLY_LARGE_INTEGER2 = 100;\n\n// returns true on success and false on error - really an error is fatal\n// but this seems the normal response to library errors\nstatic bool do_suspend(OSThread* osthread) {\n  assert(osthread->sr.is_running(), \"thread should be running\");\n  // mark as suspended and send signal\n\n  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n    // failed to switch, state wasn't running?\n    ShouldNotReachHere();\n    return false;\n  }\n\n  if (sr_notify(osthread) != 0) {\n    // try to cancel, switch to running\n\n    os::SuspendResume::State result = osthread->sr.cancel_suspend();\n    if (result == os::SuspendResume::SR_RUNNING) {\n      // cancelled\n      return false;\n    } else if (result == os::SuspendResume::SR_SUSPENDED) {\n      // somehow managed to suspend\n      return true;\n    } else {\n      ShouldNotReachHere();\n      return false;\n    }\n  }\n\n  // managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n\n  for (int n = 0; !osthread->sr.is_suspended(); n++) {\n    for (int i = 0; i < RANDOMLY_LARGE_INTEGER2 && !osthread->sr.is_suspended(); i++) {\n      os::yield_all(i);\n    }\n\n    // timeout, try to cancel the request\n    if (n >= RANDOMLY_LARGE_INTEGER) {\n      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n      if (cancelled == os::SuspendResume::SR_RUNNING) {\n        return false;\n      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n        return true;\n      } else {\n        ShouldNotReachHere();\n        return false;\n      }\n    }\n  }\n\n  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n  return true;\n}\n\nstatic void do_resume(OSThread* osthread) {\n  //assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n\n  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // failed to switch to WAKEUP_REQUEST\n    ShouldNotReachHere();\n    return;\n  }\n\n  while (!osthread->sr.is_running()) {\n    if (sr_notify(osthread) == 0) {\n      for (int n = 0; n < RANDOMLY_LARGE_INTEGER && !osthread->sr.is_running(); n++) {\n        for (int i = 0; i < 100 && !osthread->sr.is_running(); i++) {\n          os::yield_all(i);\n        }\n      }\n    } else {\n      ShouldNotReachHere();\n    }\n  }\n\n  guarantee(osthread->sr.is_running(), \"Must be running!\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// interrupt support\n\nvoid os::interrupt(Thread* thread) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  if (!osthread->interrupted()) {\n    osthread->set_interrupted(true);\n    // More than one thread can get here with the same value of osthread,\n    // resulting in multiple notifications.  We do, however, want the store\n    // to interrupted() to be visible to other threads before we execute unpark().\n    OrderAccess::fence();\n    ParkEvent * const slp = thread->_SleepEvent;\n    if (slp != NULL) slp->unpark();\n  }\n\n  // For JSR166. Unpark even if interrupt status already was set\n  if (thread->is_Java_thread())\n    ((JavaThread*)thread)->parker()->unpark();\n\n  ParkEvent * ev = thread->_ParkEvent;\n  if (ev != NULL) ev->unpark();\n\n}\n\nbool os::is_interrupted(Thread* thread, bool clear_interrupted) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  bool interrupted = osthread->interrupted();\n\n  if (interrupted && clear_interrupted) {\n    osthread->set_interrupted(false);\n    // consider thread->_SleepEvent->reset() ... optional optimization\n  }\n\n  return interrupted;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// signal handling (except suspend/resume)\n\n// This routine may be used by user applications as a \"hook\" to catch signals.\n// The user-defined signal handler must pass unrecognized signals to this\n// routine, and if it returns true (non-zero), then the signal handler must\n// return immediately. If the flag \"abort_if_unrecognized\" is true, then this\n// routine will never retun false (zero), but instead will execute a VM panic\n// routine kill the process.\n//\n// If this routine returns false, it is OK to call it again. This allows\n// the user-defined signal handler to perform checks either before or after\n// the VM performs its own checks. Naturally, the user code would be making\n// a serious error if it tried to handle an exception (such as a null check\n// or breakpoint) that the VM was generating for its own correct operation.\n//\n// This routine may recognize any of the following kinds of signals:\n//   SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n// It should be consulted by handlers for any of those signals.\n//\n// The caller of this routine must pass in the three arguments supplied\n// to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n// field of the structure passed to sigaction(). This routine assumes that\n// the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n//\n// Note that the VM will print warnings if it detects conflicting signal\n// handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n//\nextern \"C\" JNIEXPORT int\nJVM_handle_aix_signal(int signo, siginfo_t* siginfo, void* ucontext, int abort_if_unrecognized);\n\n// Set thread signal mask (for some reason on AIX sigthreadmask() seems\n// to be the thing to call; documentation is not terribly clear about whether\n// pthread_sigmask also works, and if it does, whether it does the same.\nbool set_thread_signal_mask(int how, const sigset_t* set, sigset_t* oset) {\n  const int rc = ::pthread_sigmask(how, set, oset);\n  // return value semantics differ slightly for error case:\n  // pthread_sigmask returns error number, sigthreadmask -1 and sets global errno\n  // (so, pthread_sigmask is more theadsafe for error handling)\n  // But success is always 0.\n  return rc == 0 ? true : false;\n}\n\n// Function to unblock all signals which are, according\n// to POSIX, typical program error signals. If they happen while being blocked,\n// they typically will bring down the process immediately.\nbool unblock_program_error_signals() {\n  sigset_t set;\n  ::sigemptyset(&set);\n  ::sigaddset(&set, SIGILL);\n  ::sigaddset(&set, SIGBUS);\n  ::sigaddset(&set, SIGFPE);\n  ::sigaddset(&set, SIGSEGV);\n  return set_thread_signal_mask(SIG_UNBLOCK, &set, NULL);\n}\n\n// Renamed from 'signalHandler' to avoid collision with other shared libs.\nvoid javaSignalHandler(int sig, siginfo_t* info, void* uc) {\n  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n\n  // Never leave program error signals blocked;\n  // on all our platforms they would bring down the process immediately when\n  // getting raised while being blocked.\n  unblock_program_error_signals();\n\n  JVM_handle_aix_signal(sig, info, uc, true);\n}\n\n// This boolean allows users to forward their own non-matching signals\n// to JVM_handle_aix_signal, harmlessly.\nbool os::Aix::signal_handlers_are_installed = false;\n\n// For signal-chaining\nstruct sigaction os::Aix::sigact[MAXSIGNUM];\nunsigned int os::Aix::sigs = 0;\nbool os::Aix::libjsig_is_loaded = false;\ntypedef struct sigaction *(*get_signal_t)(int);\nget_signal_t os::Aix::get_signal_action = NULL;\n\nstruct sigaction* os::Aix::get_chained_signal_action(int sig) {\n  struct sigaction *actp = NULL;\n\n  if (libjsig_is_loaded) {\n    // Retrieve the old signal handler from libjsig\n    actp = (*get_signal_action)(sig);\n  }\n  if (actp == NULL) {\n    // Retrieve the preinstalled signal handler from jvm\n    actp = get_preinstalled_handler(sig);\n  }\n\n  return actp;\n}\n\nstatic bool call_chained_handler(struct sigaction *actp, int sig,\n                                 siginfo_t *siginfo, void *context) {\n  // Call the old signal handler\n  if (actp->sa_handler == SIG_DFL) {\n    // It's more reasonable to let jvm treat it as an unexpected exception\n    // instead of taking the default action.\n    return false;\n  } else if (actp->sa_handler != SIG_IGN) {\n    if ((actp->sa_flags & SA_NODEFER) == 0) {\n      // automaticlly block the signal\n      sigaddset(&(actp->sa_mask), sig);\n    }\n\n    sa_handler_t hand = NULL;\n    sa_sigaction_t sa = NULL;\n    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n    // retrieve the chained handler\n    if (siginfo_flag_set) {\n      sa = actp->sa_sigaction;\n    } else {\n      hand = actp->sa_handler;\n    }\n\n    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n      actp->sa_handler = SIG_DFL;\n    }\n\n    // try to honor the signal mask\n    sigset_t oset;\n    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n\n    // call into the chained handler\n    if (siginfo_flag_set) {\n      (*sa)(sig, siginfo, context);\n    } else {\n      (*hand)(sig);\n    }\n\n    // restore the signal mask\n    pthread_sigmask(SIG_SETMASK, &oset, 0);\n  }\n  // Tell jvm's signal handler the signal is taken care of.\n  return true;\n}\n\nbool os::Aix::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n  bool chained = false;\n  // signal-chaining\n  if (UseSignalChaining) {\n    struct sigaction *actp = get_chained_signal_action(sig);\n    if (actp != NULL) {\n      chained = call_chained_handler(actp, sig, siginfo, context);\n    }\n  }\n  return chained;\n}\n\nstruct sigaction* os::Aix::get_preinstalled_handler(int sig) {\n  if ((((unsigned int)1 << sig) & sigs) != 0) {\n    return &sigact[sig];\n  }\n  return NULL;\n}\n\nvoid os::Aix::save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigact[sig] = oldAct;\n  sigs |= (unsigned int)1 << sig;\n}\n\n// for diagnostic\nint os::Aix::sigflags[MAXSIGNUM];\n\nint os::Aix::get_our_sigflags(int sig) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  return sigflags[sig];\n}\n\nvoid os::Aix::set_our_sigflags(int sig, int flags) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = flags;\n}\n\nvoid os::Aix::set_signal_handler(int sig, bool set_installed) {\n  // Check for overwrite.\n  struct sigaction oldAct;\n  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n\n  void* oldhand = oldAct.sa_sigaction\n    ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n    : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n  // Renamed 'signalHandler' to avoid collision with other shared libs.\n  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)javaSignalHandler)) {\n    if (AllowUserSignalHandlers || !set_installed) {\n      // Do not overwrite; user takes responsibility to forward to us.\n      return;\n    } else if (UseSignalChaining) {\n      // save the old handler in jvm\n      save_preinstalled_handler(sig, oldAct);\n      // libjsig also interposes the sigaction() call below and saves the\n      // old sigaction on it own.\n    } else {\n      fatal(err_msg(\"Encountered unexpected pre-existing sigaction handler \"\n                    \"%#lx for signal %d.\", (long)oldhand, sig));\n    }\n  }\n\n  struct sigaction sigAct;\n  sigfillset(&(sigAct.sa_mask));\n  if (!set_installed) {\n    sigAct.sa_handler = SIG_DFL;\n    sigAct.sa_flags = SA_RESTART;\n  } else {\n    // Renamed 'signalHandler' to avoid collision with other shared libs.\n    sigAct.sa_sigaction = javaSignalHandler;\n    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n  }\n  // Save flags, which are set by ours\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = sigAct.sa_flags;\n\n  int ret = sigaction(sig, &sigAct, &oldAct);\n  assert(ret == 0, \"check\");\n\n  void* oldhand2 = oldAct.sa_sigaction\n                 ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n                 : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n}\n\n// install signal handlers for signals that HotSpot needs to\n// handle in order to support Java-level exception handling.\nvoid os::Aix::install_signal_handlers() {\n  if (!signal_handlers_are_installed) {\n    signal_handlers_are_installed = true;\n\n    // signal-chaining\n    typedef void (*signal_setting_t)();\n    signal_setting_t begin_signal_setting = NULL;\n    signal_setting_t end_signal_setting = NULL;\n    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n    if (begin_signal_setting != NULL) {\n      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n                            dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n      libjsig_is_loaded = true;\n      assert(UseSignalChaining, \"should enable signal-chaining\");\n    }\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm is setting signal handlers\n      (*begin_signal_setting)();\n    }\n\n    set_signal_handler(SIGSEGV, true);\n    set_signal_handler(SIGPIPE, true);\n    set_signal_handler(SIGBUS, true);\n    set_signal_handler(SIGILL, true);\n    set_signal_handler(SIGFPE, true);\n    set_signal_handler(SIGTRAP, true);\n    set_signal_handler(SIGXFSZ, true);\n    set_signal_handler(SIGDANGER, true);\n\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm finishes setting signal handlers.\n      (*end_signal_setting)();\n    }\n\n    // We don't activate signal checker if libjsig is in place, we trust ourselves\n    // and if UserSignalHandler is installed all bets are off.\n    // Log that signal checking is off only if -verbose:jni is specified.\n    if (CheckJNICalls) {\n      if (libjsig_is_loaded) {\n        tty->print_cr(\"Info: libjsig is activated, all active signal checking is disabled\");\n        check_signals = false;\n      }\n      if (AllowUserSignalHandlers) {\n        tty->print_cr(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n        check_signals = false;\n      }\n      // Need to initialize check_signal_done.\n      ::sigemptyset(&check_signal_done);\n    }\n  }\n}\n\nstatic const char* get_signal_handler_name(address handler,\n                                           char* buf, int buflen) {\n  int offset;\n  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n  if (found) {\n    // skip directory names\n    const char *p1, *p2;\n    p1 = buf;\n    size_t len = strlen(os::file_separator());\n    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n    // The way os::dll_address_to_library_name is implemented on Aix\n    // right now, it always returns -1 for the offset which is not\n    // terribly informative.\n    // Will fix that. For now, omit the offset.\n    jio_snprintf(buf, buflen, \"%s\", p1);\n  } else {\n    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n  }\n  return buf;\n}\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen) {\n  struct sigaction sa;\n  sigaction(sig, NULL, &sa);\n\n  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n\n  address handler = (sa.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n\n  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n    st->print(\"SIG_DFL\");\n  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n    st->print(\"SIG_IGN\");\n  } else {\n    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n  }\n\n  // Print readable mask.\n  st->print(\", sa_mask[0]=\");\n  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n\n  address rh = VMError::get_resetted_sighandler(sig);\n  // May be, handler was resetted by VMError?\n  if (rh != NULL) {\n    handler = rh;\n    sa.sa_flags = VMError::get_resetted_sigflags(sig);\n  }\n\n  // Print textual representation of sa_flags.\n  st->print(\", sa_flags=\");\n  os::Posix::print_sa_flags(st, sa.sa_flags);\n\n  // Check: is it our handler?\n  if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler) ||\n      handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n    // It is our signal handler.\n    // Check for flags, reset system-used one!\n    if ((int)sa.sa_flags != os::Aix::get_our_sigflags(sig)) {\n      st->print(\", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n                os::Aix::get_our_sigflags(sig));\n    }\n  }\n  st->cr();\n}\n\n#define DO_SIGNAL_CHECK(sig) \\\n  if (!sigismember(&check_signal_done, sig)) \\\n    os::Aix::check_signal_handler(sig)\n\n// This method is a periodic task to check for misbehaving JNI applications\n// under CheckJNI, we can add any periodic checks here\n\nvoid os::run_periodic_checks() {\n\n  if (check_signals == false) return;\n\n  // SEGV and BUS if overridden could potentially prevent\n  // generation of hs*.log in the event of a crash, debugging\n  // such a case can be very challenging, so we absolutely\n  // check the following for a good measure:\n  DO_SIGNAL_CHECK(SIGSEGV);\n  DO_SIGNAL_CHECK(SIGILL);\n  DO_SIGNAL_CHECK(SIGFPE);\n  DO_SIGNAL_CHECK(SIGBUS);\n  DO_SIGNAL_CHECK(SIGPIPE);\n  DO_SIGNAL_CHECK(SIGXFSZ);\n  if (UseSIGTRAP) {\n    DO_SIGNAL_CHECK(SIGTRAP);\n  }\n  DO_SIGNAL_CHECK(SIGDANGER);\n\n  // ReduceSignalUsage allows the user to override these handlers\n  // see comments at the very top and jvm_solaris.h\n  if (!ReduceSignalUsage) {\n    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n  }\n\n  DO_SIGNAL_CHECK(SR_signum);\n  DO_SIGNAL_CHECK(INTERRUPT_SIGNAL);\n}\n\ntypedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic os_sigaction_t os_sigaction = NULL;\n\nvoid os::Aix::check_signal_handler(int sig) {\n  char buf[O_BUFLEN];\n  address jvmHandler = NULL;\n\n  struct sigaction act;\n  if (os_sigaction == NULL) {\n    // only trust the default sigaction, in case it has been interposed\n    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n    if (os_sigaction == NULL) return;\n  }\n\n  os_sigaction(sig, (struct sigaction*)NULL, &act);\n\n  address thisHandler = (act.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, act.sa_handler);\n\n  switch(sig) {\n  case SIGSEGV:\n  case SIGBUS:\n  case SIGFPE:\n  case SIGPIPE:\n  case SIGILL:\n  case SIGXFSZ:\n    // Renamed 'signalHandler' to avoid collision with other shared libs.\n    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler);\n    break;\n\n  case SHUTDOWN1_SIGNAL:\n  case SHUTDOWN2_SIGNAL:\n  case SHUTDOWN3_SIGNAL:\n  case BREAK_SIGNAL:\n    jvmHandler = (address)user_handler();\n    break;\n\n  case INTERRUPT_SIGNAL:\n    jvmHandler = CAST_FROM_FN_PTR(address, SIG_DFL);\n    break;\n\n  default:\n    if (sig == SR_signum) {\n      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n    } else {\n      return;\n    }\n    break;\n  }\n\n  if (thisHandler != jvmHandler) {\n    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n    // Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n                    exception_name(sig, buf, O_BUFLEN));\n    }\n  } else if (os::Aix::get_our_sigflags(sig) != 0 && (int)act.sa_flags != os::Aix::get_our_sigflags(sig)) {\n    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:\" PTR32_FORMAT, os::Aix::get_our_sigflags(sig));\n    tty->print_cr(\"  found:\" PTR32_FORMAT, act.sa_flags);\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n  }\n\n  // Dump all the signal\n  if (sigismember(&check_signal_done, sig)) {\n    print_signal_handlers(tty, buf, O_BUFLEN);\n  }\n}\n\nextern bool signal_name(int signo, char* buf, size_t len);\n\nconst char* os::exception_name(int exception_code, char* buf, size_t size) {\n  if (0 < exception_code && exception_code <= SIGRTMAX) {\n    // signal\n    if (!signal_name(exception_code, buf, size)) {\n      jio_snprintf(buf, size, \"SIG%d\", exception_code);\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\n// To install functions for atexit system call\nextern \"C\" {\n  static void perfMemory_exit_helper() {\n    perfMemory_exit();\n  }\n}\n\n// This is called _before_ the most of global arguments have been parsed.\nvoid os::init(void) {\n  // This is basic, we want to know if that ever changes.\n  // (shared memory boundary is supposed to be a 256M aligned)\n  assert(SHMLBA == ((uint64_t)0x10000000ULL)/*256M*/, \"unexpected\");\n\n  // First off, we need to know whether we run on AIX or PASE, and\n  // the OS level we run on.\n  os::Aix::initialize_os_info();\n\n  // Scan environment (SPEC1170 behaviour, etc)\n  os::Aix::scan_environment();\n\n  // Check which pages are supported by AIX.\n  os::Aix::query_multipage_support();\n\n  // Next, we need to initialize libo4 and libperfstat libraries.\n  if (os::Aix::on_pase()) {\n    os::Aix::initialize_libo4();\n  } else {\n    os::Aix::initialize_libperfstat();\n  }\n\n  // Reset the perfstat information provided by ODM.\n  if (os::Aix::on_aix()) {\n    libperfstat::perfstat_reset();\n  }\n\n  // Now initialze basic system properties. Note that for some of the values we\n  // need libperfstat etc.\n  os::Aix::initialize_system_info();\n\n  // Initialize large page support.\n  if (UseLargePages) {\n    os::large_page_init();\n    if (!UseLargePages) {\n      // initialize os::_page_sizes\n      _page_sizes[0] = Aix::page_size();\n      _page_sizes[1] = 0;\n      if (Verbose) {\n        fprintf(stderr, \"Large Page initialization failed: setting UseLargePages=0.\\n\");\n      }\n    }\n  } else {\n    // initialize os::_page_sizes\n    _page_sizes[0] = Aix::page_size();\n    _page_sizes[1] = 0;\n  }\n\n  // debug trace\n  if (Verbose) {\n    fprintf(stderr, \"os::vm_page_size 0x%llX\\n\", os::vm_page_size());\n    fprintf(stderr, \"os::large_page_size 0x%llX\\n\", os::large_page_size());\n    fprintf(stderr, \"os::_page_sizes = ( \");\n    for (int i = 0; _page_sizes[i]; i ++) {\n      fprintf(stderr, \" %s \", describe_pagesize(_page_sizes[i]));\n    }\n    fprintf(stderr, \")\\n\");\n  }\n\n  _initial_pid = getpid();\n\n  clock_tics_per_sec = sysconf(_SC_CLK_TCK);\n\n  init_random(1234567);\n\n  ThreadCritical::initialize();\n\n  // Main_thread points to the aboriginal thread.\n  Aix::_main_thread = pthread_self();\n\n  initial_time_count = os::elapsed_counter();\n  pthread_mutex_init(&dl_mutex, NULL);\n}\n\n// This is called _after_ the global arguments have been parsed.\njint os::init_2(void) {\n\n  trcVerbose(\"processor count: %d\", os::_processor_count);\n  trcVerbose(\"physical memory: %lu\", Aix::_physical_memory);\n\n  // Initially build up the loaded dll map.\n  LoadedLibraries::reload();\n\n  const int page_size = Aix::page_size();\n  const int map_size = page_size;\n\n  address map_address = (address) MAP_FAILED;\n  const int prot  = PROT_READ;\n  const int flags = MAP_PRIVATE|MAP_ANONYMOUS;\n\n  // use optimized addresses for the polling page,\n  // e.g. map it to a special 32-bit address.\n  if (OptimizePollingPageLocation) {\n    // architecture-specific list of address wishes:\n    address address_wishes[] = {\n      // AIX: addresses lower than 0x30000000 don't seem to work on AIX.\n      // PPC64: all address wishes are non-negative 32 bit values where\n      // the lower 16 bits are all zero. we can load these addresses\n      // with a single ppc_lis instruction.\n      (address) 0x30000000, (address) 0x31000000,\n      (address) 0x32000000, (address) 0x33000000,\n      (address) 0x40000000, (address) 0x41000000,\n      (address) 0x42000000, (address) 0x43000000,\n      (address) 0x50000000, (address) 0x51000000,\n      (address) 0x52000000, (address) 0x53000000,\n      (address) 0x60000000, (address) 0x61000000,\n      (address) 0x62000000, (address) 0x63000000\n    };\n    int address_wishes_length = sizeof(address_wishes)/sizeof(address);\n\n    // iterate over the list of address wishes:\n    for (int i=0; i<address_wishes_length; i++) {\n      // try to map with current address wish.\n      // AIX: AIX needs MAP_FIXED if we provide an address and mmap will\n      // fail if the address is already mapped.\n      map_address = (address) ::mmap(address_wishes[i] - (ssize_t)page_size,\n                                     map_size, prot,\n                                     flags | MAP_FIXED,\n                                     -1, 0);\n      if (Verbose) {\n        fprintf(stderr, \"SafePoint Polling Page address: %p (wish) => %p\\n\",\n                address_wishes[i], map_address + (ssize_t)page_size);\n      }\n\n      if (map_address + (ssize_t)page_size == address_wishes[i]) {\n        // map succeeded and map_address is at wished address, exit loop.\n        break;\n      }\n\n      if (map_address != (address) MAP_FAILED) {\n        // Map succeeded, but polling_page is not at wished address, unmap and continue.\n        ::munmap(map_address, map_size);\n        map_address = (address) MAP_FAILED;\n      }\n      // map failed, continue loop.\n    }\n  } // end OptimizePollingPageLocation\n\n  if (map_address == (address) MAP_FAILED) {\n    map_address = (address) ::mmap(NULL, map_size, prot, flags, -1, 0);\n  }\n  guarantee(map_address != MAP_FAILED, \"os::init_2: failed to allocate polling page\");\n  os::set_polling_page(map_address);\n\n  if (!UseMembar) {\n    address mem_serialize_page = (address) ::mmap(NULL, Aix::page_size(), PROT_READ | PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    guarantee(mem_serialize_page != NULL, \"mmap Failed for memory serialize page\");\n    os::set_memory_serialize_page(mem_serialize_page);\n\n#ifndef PRODUCT\n    if (Verbose && PrintMiscellaneous)\n      tty->print(\"[Memory Serialize Page address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)mem_serialize_page);\n#endif\n  }\n\n  // initialize suspend/resume support - must do this before signal_sets_init()\n  if (SR_initialize() != 0) {\n    perror(\"SR_initialize failed\");\n    return JNI_ERR;\n  }\n\n  Aix::signal_sets_init();\n  Aix::install_signal_handlers();\n\n  // Check minimum allowable stack size for thread creation and to initialize\n  // the java system classes, including StackOverflowError - depends on page\n  // size. Add a page for compiler2 recursion in main thread.\n  // Add in 2*BytesPerWord times page size to account for VM stack during\n  // class initialization depending on 32 or 64 bit VM.\n  os::Aix::min_stack_allowed = MAX2(os::Aix::min_stack_allowed,\n            (size_t)(StackYellowPages+StackRedPages+StackShadowPages +\n                     2*BytesPerWord COMPILER2_PRESENT(+1)) * Aix::page_size());\n\n  size_t threadStackSizeInBytes = ThreadStackSize * K;\n  if (threadStackSizeInBytes != 0 &&\n      threadStackSizeInBytes < os::Aix::min_stack_allowed) {\n        tty->print_cr(\"\\nThe stack size specified is too small, \"\n                      \"Specify at least %dk\",\n                      os::Aix::min_stack_allowed / K);\n        return JNI_ERR;\n  }\n\n  // Make the stack size a multiple of the page size so that\n  // the yellow/red zones can be guarded.\n  // Note that this can be 0, if no default stacksize was set.\n  JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes, vm_page_size()));\n\n  Aix::libpthread_init();\n\n  if (MaxFDLimit) {\n    // set the number of file descriptors to max. print out error\n    // if getrlimit/setrlimit fails but continue regardless.\n    struct rlimit nbr_files;\n    int status = getrlimit(RLIMIT_NOFILE, &nbr_files);\n    if (status != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode))\n        perror(\"os::init_2 getrlimit failed\");\n    } else {\n      nbr_files.rlim_cur = nbr_files.rlim_max;\n      status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n      if (status != 0) {\n        if (PrintMiscellaneous && (Verbose || WizardMode))\n          perror(\"os::init_2 setrlimit failed\");\n      }\n    }\n  }\n\n  if (PerfAllowAtExitRegistration) {\n    // only register atexit functions if PerfAllowAtExitRegistration is set.\n    // atexit functions can be delayed until process exit time, which\n    // can be problematic for embedded VM situations. Embedded VMs should\n    // call DestroyJavaVM() to assure that VM resources are released.\n\n    // note: perfMemory_exit_helper atexit function may be removed in\n    // the future if the appropriate cleanup code can be added to the\n    // VM_Exit VMOperation's doit method.\n    if (atexit(perfMemory_exit_helper) != 0) {\n      warning(\"os::init_2 atexit(perfMemory_exit_helper) failed\");\n    }\n  }\n\n  return JNI_OK;\n}\n\n// Mark the polling page as unreadable\nvoid os::make_polling_page_unreadable(void) {\n  if (!guard_memory((char*)_polling_page, Aix::page_size())) {\n    fatal(\"Could not disable polling page\");\n  }\n};\n\n// Mark the polling page as readable\nvoid os::make_polling_page_readable(void) {\n  // Changed according to os_linux.cpp.\n  if (!checked_mprotect((char *)_polling_page, Aix::page_size(), PROT_READ)) {\n    fatal(err_msg(\"Could not enable polling page at \" PTR_FORMAT, _polling_page));\n  }\n};\n\nint os::active_processor_count() {\n  int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);\n  assert(online_cpus > 0 && online_cpus <= processor_count(), \"sanity check\");\n  return online_cpus;\n}\n\nvoid os::set_native_thread_name(const char *name) {\n  // Not yet implemented.\n  return;\n}\n\nbool os::distribute_processes(uint length, uint* distribution) {\n  // Not yet implemented.\n  return false;\n}\n\nbool os::bind_to_processor(uint processor_id) {\n  // Not yet implemented.\n  return false;\n}\n\nvoid os::SuspendedThreadTask::internal_do_task() {\n  if (do_suspend(_thread->osthread())) {\n    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n    do_task(context);\n    do_resume(_thread->osthread());\n  }\n}\n\nclass PcFetcher : public os::SuspendedThreadTask {\npublic:\n  PcFetcher(Thread* thread) : os::SuspendedThreadTask(thread) {}\n  ExtendedPC result();\nprotected:\n  void do_task(const os::SuspendedThreadTaskContext& context);\nprivate:\n  ExtendedPC _epc;\n};\n\nExtendedPC PcFetcher::result() {\n  guarantee(is_done(), \"task is not done yet.\");\n  return _epc;\n}\n\nvoid PcFetcher::do_task(const os::SuspendedThreadTaskContext& context) {\n  Thread* thread = context.thread();\n  OSThread* osthread = thread->osthread();\n  if (osthread->ucontext() != NULL) {\n    _epc = os::Aix::ucontext_get_pc((ucontext_t *) context.ucontext());\n  } else {\n    // NULL context is unexpected, double-check this is the VMThread.\n    guarantee(thread->is_VM_thread(), \"can only be called for VMThread\");\n  }\n}\n\n// Suspends the target using the signal mechanism and then grabs the PC before\n// resuming the target. Used by the flat-profiler only\nExtendedPC os::get_thread_pc(Thread* thread) {\n  // Make sure that it is called by the watcher for the VMThread.\n  assert(Thread::current()->is_Watcher_thread(), \"Must be watcher\");\n  assert(thread->is_VM_thread(), \"Can only be called for VMThread\");\n\n  PcFetcher fetcher(thread);\n  fetcher.run();\n  return fetcher.result();\n}\n\n// Not neede on Aix.\n// int os::Aix::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime) {\n// }\n\n////////////////////////////////////////////////////////////////////////////////\n// debug support\n\nstatic address same_page(address x, address y) {\n  intptr_t page_bits = -os::vm_page_size();\n  if ((intptr_t(x) & page_bits) == (intptr_t(y) & page_bits))\n    return x;\n  else if (x > y)\n    return (address)(intptr_t(y) | ~page_bits) + 1;\n  else\n    return (address)(intptr_t(y) & page_bits);\n}\n\nbool os::find(address addr, outputStream* st) {\n\n  st->print(PTR_FORMAT \": \", addr);\n\n  const LoadedLibraryModule* lib = LoadedLibraries::find_for_text_address(addr);\n  if (lib) {\n    lib->print(st);\n    return true;\n  } else {\n    lib = LoadedLibraries::find_for_data_address(addr);\n    if (lib) {\n      lib->print(st);\n      return true;\n    } else {\n      st->print_cr(\"(outside any module)\");\n    }\n  }\n\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// misc\n\n// This does not do anything on Aix. This is basically a hook for being\n// able to use structured exception handling (thread-local exception filters)\n// on, e.g., Win32.\nvoid\nos::os_exception_wrapper(java_call_t f, JavaValue* value, methodHandle* method,\n                         JavaCallArguments* args, Thread* thread) {\n  f(value, method, args, thread);\n}\n\nvoid os::print_statistics() {\n}\n\nint os::message_box(const char* title, const char* message) {\n  int i;\n  fdStream err(defaultStream::error_fd());\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n  err.print_raw_cr(title);\n  for (i = 0; i < 78; i++) err.print_raw(\"-\");\n  err.cr();\n  err.print_raw_cr(message);\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n\n  char buf[16];\n  // Prevent process from exiting upon \"read error\" without consuming all CPU\n  while (::read(0, buf, sizeof(buf)) <= 0) { ::sleep(100); }\n\n  return buf[0] == 'y' || buf[0] == 'Y';\n}\n\nint os::stat(const char *path, struct stat *sbuf) {\n  char pathbuf[MAX_PATH];\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  os::native_path(strcpy(pathbuf, path));\n  return ::stat(pathbuf, sbuf);\n}\n\nbool os::check_heap(bool force) {\n  return true;\n}\n\n// int local_vsnprintf(char* buf, size_t count, const char* format, va_list args) {\n//   return ::vsnprintf(buf, count, format, args);\n// }\n\n// Is a (classpath) directory empty?\nbool os::dir_is_empty(const char* path) {\n  DIR *dir = NULL;\n  struct dirent *ptr;\n\n  dir = opendir(path);\n  if (dir == NULL) return true;\n\n  /* Scan the directory */\n  bool result = true;\n  char buf[sizeof(struct dirent) + MAX_PATH];\n  while (result && (ptr = ::readdir(dir)) != NULL) {\n    if (strcmp(ptr->d_name, \".\") != 0 && strcmp(ptr->d_name, \"..\") != 0) {\n      result = false;\n    }\n  }\n  closedir(dir);\n  return result;\n}\n\n// This code originates from JDK's sysOpen and open64_w\n// from src/solaris/hpi/src/system_md.c\n\n#ifndef O_DELETE\n#define O_DELETE 0x10000\n#endif\n\n// Open a file. Unlink the file immediately after open returns\n// if the specified oflag has the O_DELETE flag set.\n// O_DELETE is used only in j2se/src/share/native/java/util/zip/ZipFile.c\n\nint os::open(const char *path, int oflag, int mode) {\n\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  int fd;\n  int o_delete = (oflag & O_DELETE);\n  oflag = oflag & ~O_DELETE;\n\n  fd = ::open64(path, oflag, mode);\n  if (fd == -1) return -1;\n\n  // If the open succeeded, the file might still be a directory.\n  {\n    struct stat64 buf64;\n    int ret = ::fstat64(fd, &buf64);\n    int st_mode = buf64.st_mode;\n\n    if (ret != -1) {\n      if ((st_mode & S_IFMT) == S_IFDIR) {\n        errno = EISDIR;\n        ::close(fd);\n        return -1;\n      }\n    } else {\n      ::close(fd);\n      return -1;\n    }\n  }\n\n  // All file descriptors that are opened in the JVM and not\n  // specifically destined for a subprocess should have the\n  // close-on-exec flag set. If we don't set it, then careless 3rd\n  // party native code might fork and exec without closing all\n  // appropriate file descriptors (e.g. as we do in closeDescriptors in\n  // UNIXProcess.c), and this in turn might:\n  //\n  // - cause end-of-file to fail to be detected on some file\n  //   descriptors, resulting in mysterious hangs, or\n  //\n  // - might cause an fopen in the subprocess to fail on a system\n  //   suffering from bug 1085341.\n  //\n  // (Yes, the default setting of the close-on-exec flag is a Unix\n  // design flaw.)\n  //\n  // See:\n  // 1085341: 32-bit stdio routines should support file descriptors >255\n  // 4843136: (process) pipe file descriptor from Runtime.exec not being closed\n  // 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9\n#ifdef FD_CLOEXEC\n  {\n    int flags = ::fcntl(fd, F_GETFD);\n    if (flags != -1)\n      ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n  }\n#endif\n\n  if (o_delete != 0) {\n    ::unlink(path);\n  }\n  return fd;\n}\n\n// create binary file, rewriting existing file if required\nint os::create_binary_file(const char* path, bool rewrite_existing) {\n  int oflags = O_WRONLY | O_CREAT;\n  if (!rewrite_existing) {\n    oflags |= O_EXCL;\n  }\n  return ::open64(path, oflags, S_IREAD | S_IWRITE);\n}\n\n// return current position of file pointer\njlong os::current_file_offset(int fd) {\n  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);\n}\n\n// move file pointer to the specified offset\njlong os::seek_to_file_offset(int fd, jlong offset) {\n  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);\n}\n\n// This code originates from JDK's sysAvailable\n// from src/solaris/hpi/src/native_threads/src/sys_api_td.c\n\nint os::available(int fd, jlong *bytes) {\n  jlong cur, end;\n  int mode;\n  struct stat64 buf64;\n\n  if (::fstat64(fd, &buf64) >= 0) {\n    mode = buf64.st_mode;\n    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n      // XXX: is the following call interruptible? If so, this might\n      // need to go through the INTERRUPT_IO() wrapper as for other\n      // blocking, interruptible calls in this file.\n      int n;\n      if (::ioctl(fd, FIONREAD, &n) >= 0) {\n        *bytes = n;\n        return 1;\n      }\n    }\n  }\n  if ((cur = ::lseek64(fd, 0L, SEEK_CUR)) == -1) {\n    return 0;\n  } else if ((end = ::lseek64(fd, 0L, SEEK_END)) == -1) {\n    return 0;\n  } else if (::lseek64(fd, cur, SEEK_SET) == -1) {\n    return 0;\n  }\n  *bytes = end - cur;\n  return 1;\n}\n\nint os::socket_available(int fd, jint *pbytes) {\n  // Linux doc says EINTR not returned, unlike Solaris\n  int ret = ::ioctl(fd, FIONREAD, pbytes);\n\n  //%% note ioctl can return 0 when successful, JVM_SocketAvailable\n  // is expected to return 0 on failure and 1 on success to the jdk.\n  return (ret < 0) ? 0 : 1;\n}\n\n// Map a block of memory.\nchar* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,\n                        char *addr, size_t bytes, bool read_only,\n                        bool allow_exec) {\n  Unimplemented();\n  return NULL;\n}\n\n// Remap a block of memory.\nchar* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,\n                          char *addr, size_t bytes, bool read_only,\n                          bool allow_exec) {\n  // same as map_memory() on this OS\n  return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,\n                        allow_exec);\n}\n\n// Unmap a block of memory.\nbool os::pd_unmap_memory(char* addr, size_t bytes) {\n  return munmap(addr, bytes) == 0;\n}\n\n// current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)\n// are used by JVM M&M and JVMTI to get user+sys or user CPU time\n// of a thread.\n//\n// current_thread_cpu_time() and thread_cpu_time(Thread*) returns\n// the fast estimate available on the platform.\n\njlong os::current_thread_cpu_time() {\n  // return user + sys since the cost is the same\n  const jlong n = os::thread_cpu_time(Thread::current(), true /* user + sys */);\n  assert(n >= 0, \"negative CPU time\");\n  return n;\n}\n\njlong os::thread_cpu_time(Thread* thread) {\n  // consistent with what current_thread_cpu_time() returns\n  const jlong n = os::thread_cpu_time(thread, true /* user + sys */);\n  assert(n >= 0, \"negative CPU time\");\n  return n;\n}\n\njlong os::current_thread_cpu_time(bool user_sys_cpu_time) {\n  const jlong n = os::thread_cpu_time(Thread::current(), user_sys_cpu_time);\n  assert(n >= 0, \"negative CPU time\");\n  return n;\n}\n\nstatic bool thread_cpu_time_unchecked(Thread* thread, jlong* p_sys_time, jlong* p_user_time) {\n  bool error = false;\n\n  jlong sys_time = 0;\n  jlong user_time = 0;\n\n  // Reimplemented using getthrds64().\n  //\n  // Works like this:\n  // For the thread in question, get the kernel thread id. Then get the\n  // kernel thread statistics using that id.\n  //\n  // This only works of course when no pthread scheduling is used,\n  // i.e. there is a 1:1 relationship to kernel threads.\n  // On AIX, see AIXTHREAD_SCOPE variable.\n\n  pthread_t pthtid = thread->osthread()->pthread_id();\n\n  // retrieve kernel thread id for the pthread:\n  tid64_t tid = 0;\n  struct __pthrdsinfo pinfo;\n  // I just love those otherworldly IBM APIs which force me to hand down\n  // dummy buffers for stuff I dont care for...\n  char dummy[1];\n  int dummy_size = sizeof(dummy);\n  if (pthread_getthrds_np(&pthtid, PTHRDSINFO_QUERY_TID, &pinfo, sizeof(pinfo),\n                          dummy, &dummy_size) == 0) {\n    tid = pinfo.__pi_tid;\n  } else {\n    tty->print_cr(\"pthread_getthrds_np failed.\");\n    error = true;\n  }\n\n  // retrieve kernel timing info for that kernel thread\n  if (!error) {\n    struct thrdentry64 thrdentry;\n    if (getthrds64(getpid(), &thrdentry, sizeof(thrdentry), &tid, 1) == 1) {\n      sys_time = thrdentry.ti_ru.ru_stime.tv_sec * 1000000000LL + thrdentry.ti_ru.ru_stime.tv_usec * 1000LL;\n      user_time = thrdentry.ti_ru.ru_utime.tv_sec * 1000000000LL + thrdentry.ti_ru.ru_utime.tv_usec * 1000LL;\n    } else {\n      tty->print_cr(\"pthread_getthrds_np failed.\");\n      error = true;\n    }\n  }\n\n  if (p_sys_time) {\n    *p_sys_time = sys_time;\n  }\n\n  if (p_user_time) {\n    *p_user_time = user_time;\n  }\n\n  if (error) {\n    return false;\n  }\n\n  return true;\n}\n\njlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {\n  jlong sys_time;\n  jlong user_time;\n\n  if (!thread_cpu_time_unchecked(thread, &sys_time, &user_time)) {\n    return -1;\n  }\n\n  return user_sys_cpu_time ? sys_time + user_time : user_time;\n}\n\nvoid os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nvoid os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nbool os::is_thread_cpu_time_supported() {\n  return true;\n}\n\n// System loadavg support. Returns -1 if load average cannot be obtained.\n// For now just return the system wide load average (no processor sets).\nint os::loadavg(double values[], int nelem) {\n\n  // Implemented using libperfstat on AIX.\n\n  guarantee(nelem >= 0 && nelem <= 3, \"argument error\");\n  guarantee(values, \"argument error\");\n\n  if (os::Aix::on_pase()) {\n    Unimplemented();\n    return -1;\n  } else {\n    // AIX: use libperfstat\n    //\n    // See also:\n    // http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/perfstat_cputot.htm\n    // /usr/include/libperfstat.h:\n\n    // Use the already AIX version independent get_cpuinfo.\n    os::Aix::cpuinfo_t ci;\n    if (os::Aix::get_cpuinfo(&ci)) {\n      for (int i = 0; i < nelem; i++) {\n        values[i] = ci.loadavg[i];\n      }\n    } else {\n      return -1;\n    }\n    return nelem;\n  }\n}\n\nvoid os::pause() {\n  char filename[MAX_PATH];\n  if (PauseAtStartupFile && PauseAtStartupFile[0]) {\n    jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);\n  } else {\n    jio_snprintf(filename, MAX_PATH, \"./vm.paused.%d\", current_process_id());\n  }\n\n  int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n  if (fd != -1) {\n    struct stat buf;\n    ::close(fd);\n    while (::stat(filename, &buf) == 0) {\n      (void)::poll(NULL, 0, 100);\n    }\n  } else {\n    jio_fprintf(stderr,\n      \"Could not open pause file '%s', continuing immediately.\\n\", filename);\n  }\n}\n\nbool os::Aix::is_primordial_thread() {\n  if (pthread_self() == (pthread_t)1) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// OS recognitions (PASE/AIX, OS level) call this before calling any\n// one of Aix::on_pase(), Aix::os_version() static\nvoid os::Aix::initialize_os_info() {\n\n  assert(_on_pase == -1 && _os_version == -1, \"already called.\");\n\n  struct utsname uts;\n  memset(&uts, 0, sizeof(uts));\n  strcpy(uts.sysname, \"?\");\n  if (::uname(&uts) == -1) {\n    trc(\"uname failed (%d)\", errno);\n    guarantee(0, \"Could not determine whether we run on AIX or PASE\");\n  } else {\n    trcVerbose(\"uname says: sysname \\\"%s\\\" version \\\"%s\\\" release \\\"%s\\\" \"\n               \"node \\\"%s\\\" machine \\\"%s\\\"\\n\",\n               uts.sysname, uts.version, uts.release, uts.nodename, uts.machine);\n    const int major = atoi(uts.version);\n    assert(major > 0, \"invalid OS version\");\n    const int minor = atoi(uts.release);\n    assert(minor > 0, \"invalid OS release\");\n    _os_version = (major << 8) | minor;\n    if (strcmp(uts.sysname, \"OS400\") == 0) {\n      Unimplemented();\n    } else if (strcmp(uts.sysname, \"AIX\") == 0) {\n      // We run on AIX. We do not support versions older than AIX 5.3.\n      _on_pase = 0;\n      if (_os_version < 0x0503) {\n        trc(\"AIX release older than AIX 5.3 not supported.\");\n        assert(false, \"AIX release too old.\");\n      } else {\n        trcVerbose(\"We run on AIX %d.%d\\n\", major, minor);\n      }\n    } else {\n      assert(false, \"unknown OS\");\n    }\n  }\n\n  guarantee(_on_pase != -1 && _os_version, \"Could not determine AIX/OS400 release\");\n} // end: os::Aix::initialize_os_info()\n\n// Scan environment for important settings which might effect the VM.\n// Trace out settings. Warn about invalid settings and/or correct them.\n//\n// Must run after os::Aix::initialue_os_info().\nvoid os::Aix::scan_environment() {\n\n  char* p;\n  int rc;\n\n  // Warn explicity if EXTSHM=ON is used. That switch changes how\n  // System V shared memory behaves. One effect is that page size of\n  // shared memory cannot be change dynamically, effectivly preventing\n  // large pages from working.\n  // This switch was needed on AIX 32bit, but on AIX 64bit the general\n  // recommendation is (in OSS notes) to switch it off.\n  p = ::getenv(\"EXTSHM\");\n  if (Verbose) {\n    fprintf(stderr, \"EXTSHM=%s.\\n\", p ? p : \"<unset>\");\n  }\n  if (p && strcmp(p, \"ON\") == 0) {\n    fprintf(stderr, \"Unsupported setting: EXTSHM=ON. Large Page support will be disabled.\\n\");\n    _extshm = 1;\n  } else {\n    _extshm = 0;\n  }\n\n  // SPEC1170 behaviour: will change the behaviour of a number of POSIX APIs.\n  // Not tested, not supported.\n  //\n  // Note that it might be worth the trouble to test and to require it, if only to\n  // get useful return codes for mprotect.\n  //\n  // Note: Setting XPG_SUS_ENV in the process is too late. Must be set earlier (before\n  // exec() ? before loading the libjvm ? ....)\n  p = ::getenv(\"XPG_SUS_ENV\");\n  trcVerbose(\"XPG_SUS_ENV=%s.\", p ? p : \"<unset>\");\n  if (p && strcmp(p, \"ON\") == 0) {\n    _xpg_sus_mode = 1;\n    trc(\"Unsupported setting: XPG_SUS_ENV=ON\");\n    // This is not supported. Worst of all, it changes behaviour of mmap MAP_FIXED to\n    // clobber address ranges. If we ever want to support that, we have to do some\n    // testing first.\n    guarantee(false, \"XPG_SUS_ENV=ON not supported\");\n  } else {\n    _xpg_sus_mode = 0;\n  }\n\n  // Switch off AIX internal (pthread) guard pages. This has\n  // immediate effect for any pthread_create calls which follow.\n  p = ::getenv(\"AIXTHREAD_GUARDPAGES\");\n  trcVerbose(\"AIXTHREAD_GUARDPAGES=%s.\", p ? p : \"<unset>\");\n  rc = ::putenv(\"AIXTHREAD_GUARDPAGES=0\");\n  guarantee(rc == 0, \"\");\n\n} // end: os::Aix::scan_environment()\n\n// PASE: initialize the libo4 library (AS400 PASE porting library).\nvoid os::Aix::initialize_libo4() {\n  Unimplemented();\n}\n\n// AIX: initialize the libperfstat library (we load this dynamically\n// because it is only available on AIX.\nvoid os::Aix::initialize_libperfstat() {\n\n  assert(os::Aix::on_aix(), \"AIX only\");\n\n  if (!libperfstat::init()) {\n    trc(\"libperfstat initialization failed.\");\n    assert(false, \"libperfstat initialization failed\");\n  } else {\n    if (Verbose) {\n      fprintf(stderr, \"libperfstat initialized.\\n\");\n    }\n  }\n} // end: os::Aix::initialize_libperfstat\n\n/////////////////////////////////////////////////////////////////////////////\n// thread stack\n\n// function to query the current stack size using pthread_getthrds_np\n//\n// ! do not change anything here unless you know what you are doing !\nstatic void query_stack_dimensions(address* p_stack_base, size_t* p_stack_size) {\n\n  // This only works when invoked on a pthread. As we agreed not to use\n  // primordial threads anyway, I assert here\n  guarantee(!os::Aix::is_primordial_thread(), \"not allowed on the primordial thread\");\n\n  // information about this api can be found (a) in the pthread.h header and\n  // (b) in http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/pthread_getthrds_np.htm\n  //\n  // The use of this API to find out the current stack is kind of undefined.\n  // But after a lot of tries and asking IBM about it, I concluded that it is safe\n  // enough for cases where I let the pthread library create its stacks. For cases\n  // where I create an own stack and pass this to pthread_create, it seems not to\n  // work (the returned stack size in that case is 0).\n\n  pthread_t tid = pthread_self();\n  struct __pthrdsinfo pinfo;\n  char dummy[1]; // we only need this to satisfy the api and to not get E\n  int dummy_size = sizeof(dummy);\n\n  memset(&pinfo, 0, sizeof(pinfo));\n\n  const int rc = pthread_getthrds_np (&tid, PTHRDSINFO_QUERY_ALL, &pinfo,\n                                      sizeof(pinfo), dummy, &dummy_size);\n\n  if (rc != 0) {\n    fprintf(stderr, \"pthread_getthrds_np failed (%d)\\n\", rc);\n    guarantee(0, \"pthread_getthrds_np failed\");\n  }\n\n  guarantee(pinfo.__pi_stackend, \"returned stack base invalid\");\n\n  // the following can happen when invoking pthread_getthrds_np on a pthread running on a user provided stack\n  // (when handing down a stack to pthread create, see pthread_attr_setstackaddr).\n  // Not sure what to do here - I feel inclined to forbid this use case completely.\n  guarantee(pinfo.__pi_stacksize, \"returned stack size invalid\");\n\n  // On AIX, stacks are not necessarily page aligned so round the base and size accordingly\n  if (p_stack_base) {\n    (*p_stack_base) = (address) align_size_up((intptr_t)pinfo.__pi_stackend, os::Aix::stack_page_size());\n  }\n\n  if (p_stack_size) {\n    (*p_stack_size) = pinfo.__pi_stacksize - os::Aix::stack_page_size();\n  }\n\n#ifndef PRODUCT\n  if (Verbose) {\n    fprintf(stderr,\n            \"query_stack_dimensions() -> real stack_base=\" INTPTR_FORMAT \", real stack_addr=\" INTPTR_FORMAT\n            \", real stack_size=\" INTPTR_FORMAT\n            \", stack_base=\" INTPTR_FORMAT \", stack_size=\" INTPTR_FORMAT \"\\n\",\n            (intptr_t)pinfo.__pi_stackend, (intptr_t)pinfo.__pi_stackaddr, pinfo.__pi_stacksize,\n            (intptr_t)align_size_up((intptr_t)pinfo.__pi_stackend, os::Aix::stack_page_size()),\n            pinfo.__pi_stacksize - os::Aix::stack_page_size());\n  }\n#endif\n\n} // end query_stack_dimensions\n\n// get the current stack base from the OS (actually, the pthread library)\naddress os::current_stack_base() {\n  address p;\n  query_stack_dimensions(&p, 0);\n  return p;\n}\n\n// get the current stack size from the OS (actually, the pthread library)\nsize_t os::current_stack_size() {\n  size_t s;\n  query_stack_dimensions(0, &s);\n  return s;\n}\n\n// Refer to the comments in os_solaris.cpp park-unpark.\n//\n// Beware -- Some versions of NPTL embody a flaw where pthread_cond_timedwait() can\n// hang indefinitely. For instance NPTL 0.60 on 2.4.21-4ELsmp is vulnerable.\n// For specifics regarding the bug see GLIBC BUGID 261237 :\n//    http://www.mail-archive.com/debian-glibc@lists.debian.org/msg10837.html.\n// Briefly, pthread_cond_timedwait() calls with an expiry time that's not in the future\n// will either hang or corrupt the condvar, resulting in subsequent hangs if the condvar\n// is used. (The simple C test-case provided in the GLIBC bug report manifests the\n// hang). The JVM is vulernable via sleep(), Object.wait(timo), LockSupport.parkNanos()\n// and monitorenter when we're using 1-0 locking. All those operations may result in\n// calls to pthread_cond_timedwait(). Using LD_ASSUME_KERNEL to use an older version\n// of libpthread avoids the problem, but isn't practical.\n//\n// Possible remedies:\n//\n// 1.   Establish a minimum relative wait time. 50 to 100 msecs seems to work.\n//      This is palliative and probabilistic, however. If the thread is preempted\n//      between the call to compute_abstime() and pthread_cond_timedwait(), more\n//      than the minimum period may have passed, and the abstime may be stale (in the\n//      past) resultin in a hang. Using this technique reduces the odds of a hang\n//      but the JVM is still vulnerable, particularly on heavily loaded systems.\n//\n// 2.   Modify park-unpark to use per-thread (per ParkEvent) pipe-pairs instead\n//      of the usual flag-condvar-mutex idiom. The write side of the pipe is set\n//      NDELAY. unpark() reduces to write(), park() reduces to read() and park(timo)\n//      reduces to poll()+read(). This works well, but consumes 2 FDs per extant\n//      thread.\n//\n// 3.   Embargo pthread_cond_timedwait() and implement a native \"chron\" thread\n//      that manages timeouts. We'd emulate pthread_cond_timedwait() by enqueuing\n//      a timeout request to the chron thread and then blocking via pthread_cond_wait().\n//      This also works well. In fact it avoids kernel-level scalability impediments\n//      on certain platforms that don't handle lots of active pthread_cond_timedwait()\n//      timers in a graceful fashion.\n//\n// 4.   When the abstime value is in the past it appears that control returns\n//      correctly from pthread_cond_timedwait(), but the condvar is left corrupt.\n//      Subsequent timedwait/wait calls may hang indefinitely. Given that, we\n//      can avoid the problem by reinitializing the condvar -- by cond_destroy()\n//      followed by cond_init() -- after all calls to pthread_cond_timedwait().\n//      It may be possible to avoid reinitialization by checking the return\n//      value from pthread_cond_timedwait(). In addition to reinitializing the\n//      condvar we must establish the invariant that cond_signal() is only called\n//      within critical sections protected by the adjunct mutex. This prevents\n//      cond_signal() from \"seeing\" a condvar that's in the midst of being\n//      reinitialized or that is corrupt. Sadly, this invariant obviates the\n//      desirable signal-after-unlock optimization that avoids futile context switching.\n//\n//      I'm also concerned that some versions of NTPL might allocate an auxilliary\n//      structure when a condvar is used or initialized. cond_destroy() would\n//      release the helper structure. Our reinitialize-after-timedwait fix\n//      put excessive stress on malloc/free and locks protecting the c-heap.\n//\n// We currently use (4). See the WorkAroundNTPLTimedWaitHang flag.\n// It may be possible to refine (4) by checking the kernel and NTPL verisons\n// and only enabling the work-around for vulnerable environments.\n\n// utility to compute the abstime argument to timedwait:\n// millis is the relative timeout time\n// abstime will be the absolute timeout time\n// TODO: replace compute_abstime() with unpackTime()\n\nstatic struct timespec* compute_abstime(timespec* abstime, jlong millis) {\n  if (millis < 0) millis = 0;\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n  jlong seconds = millis / 1000;\n  millis %= 1000;\n  if (seconds > 50000000) { // see man cond_timedwait(3T)\n    seconds = 50000000;\n  }\n  abstime->tv_sec = now.tv_sec  + seconds;\n  long       usec = now.tv_usec + millis * 1000;\n  if (usec >= 1000000) {\n    abstime->tv_sec += 1;\n    usec -= 1000000;\n  }\n  abstime->tv_nsec = usec * 1000;\n  return abstime;\n}\n\n// Test-and-clear _Event, always leaves _Event set to 0, returns immediately.\n// Conceptually TryPark() should be equivalent to park(0).\n\nint os::PlatformEvent::TryPark() {\n  for (;;) {\n    const int v = _Event;\n    guarantee ((v == 0) || (v == 1), \"invariant\");\n    if (Atomic::cmpxchg (0, &_Event, v) == v) return v;\n  }\n}\n\nvoid os::PlatformEvent::park() {       // AKA \"down()\"\n  // Invariant: Only the thread associated with the Event/PlatformEvent\n  // may call park().\n  // TODO: assert that _Assoc != NULL or _Assoc == Self\n  int v;\n  for (;;) {\n    v = _Event;\n    if (Atomic::cmpxchg (v-1, &_Event, v) == v) break;\n  }\n  guarantee (v >= 0, \"invariant\");\n  if (v == 0) {\n    // Do this the hard way by blocking ...\n    int status = pthread_mutex_lock(_mutex);\n    assert_status(status == 0, status, \"mutex_lock\");\n    guarantee (_nParked == 0, \"invariant\");\n    ++ _nParked;\n    while (_Event < 0) {\n      status = pthread_cond_wait(_cond, _mutex);\n      assert_status(status == 0 || status == ETIMEDOUT, status, \"cond_timedwait\");\n    }\n    -- _nParked;\n\n    // In theory we could move the ST of 0 into _Event past the unlock(),\n    // but then we'd need a MEMBAR after the ST.\n    _Event = 0;\n    status = pthread_mutex_unlock(_mutex);\n    assert_status(status == 0, status, \"mutex_unlock\");\n  }\n  guarantee (_Event >= 0, \"invariant\");\n}\n\nint os::PlatformEvent::park(jlong millis) {\n  guarantee (_nParked == 0, \"invariant\");\n\n  int v;\n  for (;;) {\n    v = _Event;\n    if (Atomic::cmpxchg (v-1, &_Event, v) == v) break;\n  }\n  guarantee (v >= 0, \"invariant\");\n  if (v != 0) return OS_OK;\n\n  // We do this the hard way, by blocking the thread.\n  // Consider enforcing a minimum timeout value.\n  struct timespec abst;\n  compute_abstime(&abst, millis);\n\n  int ret = OS_TIMEOUT;\n  int status = pthread_mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  guarantee (_nParked == 0, \"invariant\");\n  ++_nParked;\n\n  // Object.wait(timo) will return because of\n  // (a) notification\n  // (b) timeout\n  // (c) thread.interrupt\n  //\n  // Thread.interrupt and object.notify{All} both call Event::set.\n  // That is, we treat thread.interrupt as a special case of notification.\n  // The underlying Solaris implementation, cond_timedwait, admits\n  // spurious/premature wakeups, but the JLS/JVM spec prevents the\n  // JVM from making those visible to Java code. As such, we must\n  // filter out spurious wakeups. We assume all ETIME returns are valid.\n  //\n  // TODO: properly differentiate simultaneous notify+interrupt.\n  // In that case, we should propagate the notify to another waiter.\n\n  while (_Event < 0) {\n    status = pthread_cond_timedwait(_cond, _mutex, &abst);\n    assert_status(status == 0 || status == ETIMEDOUT,\n                  status, \"cond_timedwait\");\n    if (!FilterSpuriousWakeups) break;         // previous semantics\n    if (status == ETIMEDOUT) break;\n    // We consume and ignore EINTR and spurious wakeups.\n  }\n  --_nParked;\n  if (_Event >= 0) {\n     ret = OS_OK;\n  }\n  _Event = 0;\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  assert (_nParked == 0, \"invariant\");\n  return ret;\n}\n\nvoid os::PlatformEvent::unpark() {\n  int v, AnyWaiters;\n  for (;;) {\n    v = _Event;\n    if (v > 0) {\n      // The LD of _Event could have reordered or be satisfied\n      // by a read-aside from this processor's write buffer.\n      // To avoid problems execute a barrier and then\n      // ratify the value.\n      OrderAccess::fence();\n      if (_Event == v) return;\n      continue;\n    }\n    if (Atomic::cmpxchg (v+1, &_Event, v) == v) break;\n  }\n  if (v < 0) {\n    // Wait for the thread associated with the event to vacate\n    int status = pthread_mutex_lock(_mutex);\n    assert_status(status == 0, status, \"mutex_lock\");\n    AnyWaiters = _nParked;\n\n    if (AnyWaiters != 0) {\n      // We intentional signal *after* dropping the lock\n      // to avoid a common class of futile wakeups.\n      status = pthread_cond_signal(_cond);\n      assert_status(status == 0, status, \"cond_signal\");\n    }\n    // Mutex should be locked for pthread_cond_signal(_cond).\n    status = pthread_mutex_unlock(_mutex);\n    assert_status(status == 0, status, \"mutex_unlock\");\n  }\n\n  // Note that we signal() _after dropping the lock for \"immortal\" Events.\n  // This is safe and avoids a common class of futile wakeups. In rare\n  // circumstances this can cause a thread to return prematurely from\n  // cond_{timed}wait() but the spurious wakeup is benign and the victim will\n  // simply re-test the condition and re-park itself.\n}\n\n\n// JSR166\n// -------------------------------------------------------\n\n//\n// The solaris and linux implementations of park/unpark are fairly\n// conservative for now, but can be improved. They currently use a\n// mutex/condvar pair, plus a a count.\n// Park decrements count if > 0, else does a condvar wait. Unpark\n// sets count to 1 and signals condvar. Only one thread ever waits\n// on the condvar. Contention seen when trying to park implies that someone\n// is unparking you, so don't wait. And spurious returns are fine, so there\n// is no need to track notifications.\n//\n\n#define MAX_SECS 100000000\n//\n// This code is common to linux and solaris and will be moved to a\n// common place in dolphin.\n//\n// The passed in time value is either a relative time in nanoseconds\n// or an absolute time in milliseconds. Either way it has to be unpacked\n// into suitable seconds and nanoseconds components and stored in the\n// given timespec structure.\n// Given time is a 64-bit value and the time_t used in the timespec is only\n// a signed-32-bit value (except on 64-bit Linux) we have to watch for\n// overflow if times way in the future are given. Further on Solaris versions\n// prior to 10 there is a restriction (see cond_timedwait) that the specified\n// number of seconds, in abstime, is less than current_time + 100,000,000.\n// As it will be 28 years before \"now + 100000000\" will overflow we can\n// ignore overflow and just impose a hard-limit on seconds using the value\n// of \"now + 100,000,000\". This places a limit on the timeout of about 3.17\n// years from \"now\".\n//\n\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {\n  assert (time > 0, \"convertTime\");\n\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n\n  time_t max_secs = now.tv_sec + MAX_SECS;\n\n  if (isAbsolute) {\n    jlong secs = time / 1000;\n    if (secs > max_secs) {\n      absTime->tv_sec = max_secs;\n    }\n    else {\n      absTime->tv_sec = secs;\n    }\n    absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;\n  }\n  else {\n    jlong secs = time / NANOSECS_PER_SEC;\n    if (secs >= MAX_SECS) {\n      absTime->tv_sec = max_secs;\n      absTime->tv_nsec = 0;\n    }\n    else {\n      absTime->tv_sec = now.tv_sec + secs;\n      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;\n      if (absTime->tv_nsec >= NANOSECS_PER_SEC) {\n        absTime->tv_nsec -= NANOSECS_PER_SEC;\n        ++absTime->tv_sec; // note: this must be <= max_secs\n      }\n    }\n  }\n  assert(absTime->tv_sec >= 0, \"tv_sec < 0\");\n  assert(absTime->tv_sec <= max_secs, \"tv_sec > max_secs\");\n  assert(absTime->tv_nsec >= 0, \"tv_nsec < 0\");\n  assert(absTime->tv_nsec < NANOSECS_PER_SEC, \"tv_nsec >= nanos_per_sec\");\n}\n\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  if (_counter > 0) {\n    _counter = 0;\n    OrderAccess::fence();\n    return;\n  }\n\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n  JavaThread *jt = (JavaThread *)thread;\n\n  // Optional optimization -- avoid state transitions if there's an interrupt pending.\n  // Check interrupt before trying to wait\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n\n  // Next, demultiplex/decode time arguments\n  timespec absTime;\n  if (time < 0 || (isAbsolute && time == 0)) { // don't wait at all\n    return;\n  }\n  if (time > 0) {\n    unpackTime(&absTime, isAbsolute, time);\n  }\n\n  // Enter safepoint region\n  // Beware of deadlocks such as 6317397.\n  // The per-thread Parker:: mutex is a classic leaf-lock.\n  // In particular a thread must never block on the Threads_lock while\n  // holding the Parker:: mutex. If safepoints are pending both the\n  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.\n  ThreadBlockInVM tbivm(jt);\n\n  // Don't wait if cannot get lock since interference arises from\n  // unblocking. Also. check interrupt before trying wait\n  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {\n    return;\n  }\n\n  int status;\n  if (_counter > 0) { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\");\n    OrderAccess::fence();\n    return;\n  }\n\n#ifdef ASSERT\n  // Don't catch signals while blocked; let the running threads have the signals.\n  // (This allows a debugger to break into the running thread.)\n  sigset_t oldsigs;\n  sigset_t* allowdebug_blocked = os::Aix::allowdebug_blocked_signals();\n  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);\n#endif\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex);\n  } else {\n    status = pthread_cond_timedwait (_cond, _mutex, &absTime);\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (_cond);\n      pthread_cond_init    (_cond, NULL);\n    }\n  }\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIME || status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n\n  _counter = 0;\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"invariant\");\n  // If externally suspended while waiting, re-suspend\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n\n  OrderAccess::fence();\n}\n\nvoid Parker::unpark() {\n  int s, status;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\");\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n    if (WorkAroundNPTLTimedWaitHang) {\n      status = pthread_cond_signal (_cond);\n      assert (status == 0, \"invariant\");\n      status = pthread_mutex_unlock(_mutex);\n      assert (status == 0, \"invariant\");\n    } else {\n      status = pthread_mutex_unlock(_mutex);\n      assert (status == 0, \"invariant\");\n      status = pthread_cond_signal (_cond);\n      assert (status == 0, \"invariant\");\n    }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\");\n  }\n}\n\nextern char** environ;\n\n// Run the specified command in a separate process. Return its exit value,\n// or -1 on failure (e.g. can't fork a new process).\n// Unlike system(), this function can be called from signal handler. It\n// doesn't block SIGINT et al.\nint os::fork_and_exec(char* cmd) {\n  char * argv[4] = {\"sh\", \"-c\", cmd, NULL};\n\n  pid_t pid = fork();\n\n  if (pid < 0) {\n    // fork failed\n    return -1;\n\n  } else if (pid == 0) {\n    // child process\n\n    // Try to be consistent with system(), which uses \"/usr/bin/sh\" on AIX.\n    execve(\"/usr/bin/sh\", argv, environ);\n\n    // execve failed\n    _exit(-1);\n\n  } else {\n    // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n    // care about the actual exit code, for now.\n\n    int status;\n\n    // Wait for the child process to exit. This returns immediately if\n    // the child has already exited. */\n    while (waitpid(pid, &status, 0) < 0) {\n      switch (errno) {\n        case ECHILD: return 0;\n        case EINTR: break;\n        default: return -1;\n      }\n    }\n\n    if (WIFEXITED(status)) {\n      // The child exited normally; get its exit code.\n      return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n      // The child exited because of a signal.\n      // The best value to return is 0x80 + signal number,\n      // because that is what all Unix shells do, and because\n      // it allows callers to distinguish between process exit and\n      // process death by signal.\n      return 0x80 + WTERMSIG(status);\n    } else {\n      // Unknown exit code; pass it through.\n      return status;\n    }\n  }\n  return -1;\n}\n\n// is_headless_jre()\n//\n// Test for the existence of xawt/libmawt.so or libawt_xawt.so\n// in order to report if we are running in a headless jre.\n//\n// Since JDK8 xawt/libmawt.so is moved into the same directory\n// as libawt.so, and renamed libawt_xawt.so\nbool os::is_headless_jre() {\n  struct stat statbuf;\n  char buf[MAXPATHLEN];\n  char libmawtpath[MAXPATHLEN];\n  const char *xawtstr = \"/xawt/libmawt.so\";\n  const char *new_xawtstr = \"/libawt_xawt.so\";\n\n  char *p;\n\n  // Get path to libjvm.so\n  os::jvm_path(buf, sizeof(buf));\n\n  // Get rid of libjvm.so\n  p = strrchr(buf, '/');\n  if (p == NULL) return false;\n  else *p = '\\0';\n\n  // Get rid of client or server\n  p = strrchr(buf, '/');\n  if (p == NULL) return false;\n  else *p = '\\0';\n\n  // check xawt/libmawt.so\n  strcpy(libmawtpath, buf);\n  strcat(libmawtpath, xawtstr);\n  if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n  // check libawt_xawt.so\n  strcpy(libmawtpath, buf);\n  strcat(libmawtpath, new_xawtstr);\n  if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n  return true;\n}\n\n// Get the default path to the core file\n// Returns the length of the string\nint os::get_core_path(char* buffer, size_t bufferSize) {\n  const char* p = get_current_directory(buffer, bufferSize);\n\n  if (p == NULL) {\n    assert(p != NULL, \"failed to get current directory\");\n    return 0;\n  }\n\n  return strlen(buffer);\n}\n\n#ifndef PRODUCT\nvoid TestReserveMemorySpecial_test() {\n  // No tests available for this platform\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os/aix/vm/jsig.c": "/*\n * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.\n * Copyright 2012, 2013 SAP AG. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n/* CopyrightVersion 1.2 */\n\n/* This is a special library that should be loaded before libc &\n * libthread to interpose the signal handler installation functions:\n * sigaction(), signal(), sigset().\n * Used for signal-chaining. See RFE 4381843.\n */\n\n#include <signal.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define bool int\n#define true 1\n#define false 0\n\n// Highest so far on AIX 5.2 is SIGSAK (63)\n#define MAXSIGNUM 63\n#define MASK(sig) ((unsigned int)1 << sig)\n\nstatic struct sigaction sact[MAXSIGNUM]; /* saved signal handlers */\nstatic unsigned int jvmsigs = 0; /* signals used by jvm */\n\n/* used to synchronize the installation of signal handlers */\nstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t tid = 0;\n\ntypedef void (*sa_handler_t)(int);\ntypedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n// signal_t is already defined on AIX\ntypedef sa_handler_t (*signal_like_function_t)(int, sa_handler_t);\ntypedef int (*sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic signal_like_function_t os_signal = 0; /* os's version of signal()/sigset() */\nstatic sigaction_t os_sigaction = 0; /* os's version of sigaction() */\n\nstatic bool jvm_signal_installing = false;\nstatic bool jvm_signal_installed = false;\n\nstatic void signal_lock() {\n  pthread_mutex_lock(&mutex);\n  /* When the jvm is installing its set of signal handlers, threads\n   * other than the jvm thread should wait */\n  if (jvm_signal_installing) {\n    if (tid != pthread_self()) {\n      pthread_cond_wait(&cond, &mutex);\n    }\n  }\n}\n\nstatic void signal_unlock() {\n  pthread_mutex_unlock(&mutex);\n}\n\nstatic sa_handler_t call_os_signal(int sig, sa_handler_t disp,\n                                   bool is_sigset) {\n  if (os_signal == NULL) {\n    if (!is_sigset) {\n      // Aix: call functions directly instead of dlsym'ing them\n      os_signal = signal;\n    } else {\n      // Aix: call functions directly instead of dlsym'ing them\n      os_signal = sigset;\n    }\n    if (os_signal == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_signal)(sig, disp);\n}\n\nstatic void save_signal_handler(int sig, sa_handler_t disp) {\n  sigset_t set;\n  sact[sig].sa_handler = disp;\n  sigemptyset(&set);\n  sact[sig].sa_mask = set;\n  sact[sig].sa_flags = 0;\n}\n\nstatic sa_handler_t set_signal(int sig, sa_handler_t disp, bool is_sigset) {\n  sa_handler_t oldhandler;\n  bool sigused;\n\n  signal_lock();\n\n  sigused = (MASK(sig) & jvmsigs) != 0;\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    oldhandler = sact[sig].sa_handler;\n    save_signal_handler(sig, disp);\n\n    signal_unlock();\n    return oldhandler;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. jvm uses sigaction().\n     * Leave the piece here just in case. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n    save_signal_handler(sig, oldhandler);\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return oldhandler;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n\n    signal_unlock();\n    return oldhandler;\n  }\n}\n\nsa_handler_t signal(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, false);\n}\n\nsa_handler_t sigset(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, true);\n }\n\nstatic int call_os_sigaction(int sig, const struct sigaction  *act,\n                             struct sigaction *oact) {\n  if (os_sigaction == NULL) {\n    // Aix: call functions directly instead of dlsym'ing them\n    os_sigaction = sigaction;\n    if (os_sigaction == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_sigaction)(sig, act, oact);\n}\n\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact) {\n  int res;\n  bool sigused;\n  struct sigaction oldAct;\n\n  signal_lock();\n\n  sigused = (MASK(sig) & jvmsigs) != 0;\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    if (oact != NULL) {\n      *oact = sact[sig];\n    }\n    if (act != NULL) {\n      sact[sig] = *act;\n    }\n\n    signal_unlock();\n    return 0;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. */\n    res = call_os_sigaction(sig, act, &oldAct);\n    sact[sig] = oldAct;\n    if (oact != NULL) {\n      *oact = oldAct;\n    }\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return res;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    res = call_os_sigaction(sig, act, oact);\n\n    signal_unlock();\n    return res;\n  }\n}\n\n/* The three functions for the jvm to call into */\nvoid JVM_begin_signal_setting() {\n  signal_lock();\n  jvm_signal_installing = true;\n  tid = pthread_self();\n  signal_unlock();\n}\n\nvoid JVM_end_signal_setting() {\n  signal_lock();\n  jvm_signal_installed = true;\n  jvm_signal_installing = false;\n  pthread_cond_broadcast(&cond);\n  signal_unlock();\n}\n\nstruct sigaction *JVM_get_signal_action(int sig) {\n  /* Does race condition make sense here? */\n  if ((MASK(sig) & jvmsigs) != 0) {\n    return &sact[sig];\n  }\n  return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/os/aix/vm/libperfstat_aix.cpp": "/*\n * Copyright 2012, 2013 SAP AG. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include \"runtime/arguments.hpp\"\n#include \"libperfstat_aix.hpp\"\n\n// For dlopen and friends\n#include <fcntl.h>\n\n// handle to the libperfstat\nstatic void* g_libhandle = NULL;\n\n// whether initialization worked\nstatic bool g_initialized = false;\n\n\ntypedef int (*fun_perfstat_cpu_total_t) (perfstat_id_t *name, perfstat_cpu_total_t* userbuff,\n                                         int sizeof_userbuff, int desired_number);\n\ntypedef int (*fun_perfstat_memory_total_t) (perfstat_id_t *name, perfstat_memory_total_t* userbuff,\n                                            int sizeof_userbuff, int desired_number);\n\ntypedef void (*fun_perfstat_reset_t) ();\n\nstatic fun_perfstat_cpu_total_t     g_fun_perfstat_cpu_total = NULL;\nstatic fun_perfstat_memory_total_t  g_fun_perfstat_memory_total = NULL;\nstatic fun_perfstat_reset_t         g_fun_perfstat_reset = NULL;\n\nbool libperfstat::init() {\n\n  if (g_initialized) {\n    return true;\n  }\n\n  g_initialized = false;\n\n  // dynamically load the libperfstat porting library.\n  g_libhandle = dlopen(\"/usr/lib/libperfstat.a(shr_64.o)\", RTLD_MEMBER | RTLD_NOW);\n  if (!g_libhandle) {\n    if (Verbose) {\n      fprintf(stderr, \"Cannot load libperfstat.a (dlerror: %s)\", dlerror());\n    }\n    return false;\n  }\n\n  // resolve function pointers\n\n#define RESOLVE_FUN_NO_ERROR(name) \\\n  g_fun_##name = (fun_##name##_t) dlsym(g_libhandle, #name);\n\n#define RESOLVE_FUN(name) \\\n  RESOLVE_FUN_NO_ERROR(name) \\\n  if (!g_fun_##name) { \\\n    if (Verbose) { \\\n      fprintf(stderr, \"Cannot resolve \" #name \"() from libperfstat.a\\n\" \\\n                      \"   (dlerror: %s)\", dlerror()); \\\n      } \\\n    return false; \\\n  }\n\n  RESOLVE_FUN(perfstat_cpu_total);\n  RESOLVE_FUN(perfstat_memory_total);\n  RESOLVE_FUN(perfstat_reset);\n\n  g_initialized = true;\n\n  return true;\n}\n\nvoid libperfstat::cleanup() {\n\n  g_initialized = false;\n\n  if (g_libhandle) {\n    dlclose(g_libhandle);\n    g_libhandle = NULL;\n  }\n\n  g_fun_perfstat_cpu_total = NULL;\n  g_fun_perfstat_memory_total = NULL;\n  g_fun_perfstat_reset = NULL;\n}\n\nint libperfstat::perfstat_memory_total(perfstat_id_t *name,\n                                       perfstat_memory_total_t* userbuff,\n                                       int sizeof_userbuff, int desired_number) {\n  assert(g_initialized, \"libperfstat not initialized\");\n  assert(g_fun_perfstat_memory_total, \"\");\n  return g_fun_perfstat_memory_total(name, userbuff, sizeof_userbuff, desired_number);\n}\n\nint libperfstat::perfstat_cpu_total(perfstat_id_t *name, perfstat_cpu_total_t* userbuff,\n                                    int sizeof_userbuff, int desired_number) {\n  assert(g_initialized, \"libperfstat not initialized\");\n  assert(g_fun_perfstat_cpu_total, \"\");\n  return g_fun_perfstat_cpu_total(name, userbuff, sizeof_userbuff, desired_number);\n}\n\nvoid libperfstat::perfstat_reset() {\n  assert(g_initialized, \"libperfstat not initialized\");\n  assert(g_fun_perfstat_reset, \"\");\n  g_fun_perfstat_reset();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/native/sadis.c": "/*\n * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include \"sun_jvm_hotspot_asm_Disassembler.h\"\n\n/*\n *  This file implements a binding between Java and the hsdis\n *  dissasembler.  It should compile on Linux/Solaris and Windows.\n *  The only platform dependent pieces of the code for doing\n *  dlopen/dlsym to find the entry point in hsdis.  All the rest is\n *  standard JNI code.\n */\n\n#ifdef _WINDOWS\n\n#define snprintf  _snprintf\n#define vsnprintf _vsnprintf\n\n#include <windows.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#ifdef _DEBUG\n#include <crtdbg.h>\n#endif\n\n#else\n\n#include <string.h>\n#include <dlfcn.h>\n\n#ifndef __APPLE__\n#include <link.h>\n#endif\n\n#endif\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#ifdef _WINDOWS\nstatic int getLastErrorString(char *buf, size_t len)\n{\n    long errval;\n\n    if ((errval = GetLastError()) != 0)\n    {\n      /* DOS error */\n      size_t n = (size_t)FormatMessage(\n            FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,\n            NULL,\n            errval,\n            0,\n            buf,\n            (DWORD)len,\n            NULL);\n      if (n > 3) {\n        /* Drop final '.', CR, LF */\n        if (buf[n - 1] == '\\n') n--;\n        if (buf[n - 1] == '\\r') n--;\n        if (buf[n - 1] == '.') n--;\n        buf[n] = '\\0';\n      }\n      return (int)n;\n    }\n\n    if (errno != 0)\n    {\n      /* C runtime error that has no corresponding DOS error code */\n      const char *s = strerror(errno);\n      size_t n = strlen(s);\n      if (n >= len) n = len - 1;\n      strncpy(buf, s, n);\n      buf[n] = '\\0';\n      return (int)n;\n    }\n    return 0;\n}\n#endif /* _WINDOWS */\n\n/*\n * Class:     sun_jvm_hotspot_asm_Disassembler\n * Method:    load_library\n * Signature: (Ljava/lang/String;)L\n */\nJNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_asm_Disassembler_load_1library(JNIEnv * env,\n                                                                           jclass disclass,\n                                                                           jstring jrepath_s,\n                                                                           jstring libname_s) {\n  uintptr_t func = 0;\n  const char* error_message = NULL;\n  jboolean isCopy;\n\n  const char * jrepath = (*env)->GetStringUTFChars(env, jrepath_s, &isCopy); // like $JAVA_HOME/jre/lib/sparc/\n  const char * libname = (*env)->GetStringUTFChars(env, libname_s, &isCopy);\n  char buffer[128];\n\n  /* Load the hsdis library */\n#ifdef _WINDOWS\n  HINSTANCE hsdis_handle;\n  hsdis_handle = LoadLibrary(libname);\n  if (hsdis_handle == NULL) {\n    snprintf(buffer, sizeof(buffer), \"%s%s\", jrepath, libname);\n    hsdis_handle = LoadLibrary(buffer);\n  }\n  if (hsdis_handle != NULL) {\n    func = (uintptr_t)GetProcAddress(hsdis_handle, \"decode_instructions_virtual\");\n  }\n  if (func == 0) {\n    getLastErrorString(buffer, sizeof(buffer));\n    error_message = buffer;\n  }\n#else\n  void* hsdis_handle;\n  hsdis_handle = dlopen(libname, RTLD_LAZY | RTLD_GLOBAL);\n  if (hsdis_handle == NULL) {\n    snprintf(buffer, sizeof(buffer), \"%s%s\", jrepath, libname);\n    hsdis_handle = dlopen(buffer, RTLD_LAZY | RTLD_GLOBAL);\n  }\n  if (hsdis_handle != NULL) {\n    func = (uintptr_t)dlsym(hsdis_handle, \"decode_instructions_virtual\");\n  }\n  if (func == 0) {\n    error_message = dlerror();\n  }\n#endif\n\n  (*env)->ReleaseStringUTFChars(env, libname_s, libname);\n  (*env)->ReleaseStringUTFChars(env, jrepath_s, jrepath);\n\n  if (func == 0) {\n    /* Couldn't find entry point.  error_message should contain some\n     * platform dependent error message.\n     */\n    jclass eclass = (*env)->FindClass(env, \"sun/jvm/hotspot/debugger/DebuggerException\");\n    (*env)->ThrowNew(env, eclass, error_message);\n  }\n  return (jlong)func;\n}\n\n/* signature of decode_instructions_virtual from hsdis.h */\ntypedef void* (*decode_func)(uintptr_t start_va, uintptr_t end_va,\n                             unsigned char* start, uintptr_t length,\n                             void* (*event_callback)(void*, const char*, void*),\n                             void* event_stream,\n                             int (*printf_callback)(void*, const char*, ...),\n                             void* printf_stream,\n                             const char* options,\n                             int newline);\n\n/* container for call back state when decoding instructions */\ntypedef struct {\n  JNIEnv* env;\n  jobject dis;\n  jobject visitor;\n  jmethodID handle_event;\n  jmethodID raw_print;\n  char buffer[4096];\n} decode_env;\n\n\n/* event callback binding to Disassembler.handleEvent */\nstatic void* event_to_env(void* env_pv, const char* event, void* arg) {\n  decode_env* denv = (decode_env*)env_pv;\n  JNIEnv* env = denv->env;\n  jstring event_string = (*env)->NewStringUTF(env, event);\n  jlong result = (*env)->CallLongMethod(env, denv->dis, denv->handle_event, denv->visitor,\n                                        event_string, (jlong) (uintptr_t)arg);\n  if ((*env)->ExceptionOccurred(env) != NULL) {\n    /* ignore exceptions for now */\n    (*env)->ExceptionClear(env);\n    result = 0;\n  }\n  return (void*)(uintptr_t)result;\n}\n\n/* printing callback binding to Disassembler.rawPrint */\nstatic int printf_to_env(void* env_pv, const char* format, ...) {\n  jstring output;\n  va_list ap;\n  int cnt;\n  decode_env* denv = (decode_env*)env_pv;\n  JNIEnv* env = denv->env;\n  size_t flen = strlen(format);\n  const char* raw = NULL;\n\n  if (flen == 0)  return 0;\n  if (flen < 2 ||\n      strchr(format, '%') == NULL) {\n    raw = format;\n  } else if (format[0] == '%' && format[1] == '%' &&\n             strchr(format+2, '%') == NULL) {\n    // happens a lot on machines with names like %foo\n    flen--;\n    raw = format+1;\n  }\n  if (raw != NULL) {\n    jstring output = (*env)->NewStringUTF(env, raw);\n    (*env)->CallVoidMethod(env, denv->dis, denv->raw_print, denv->visitor, output);\n    if ((*env)->ExceptionOccurred(env) != NULL) {\n      /* ignore exceptions for now */\n      (*env)->ExceptionClear(env);\n    }\n    return (int) flen;\n  }\n  va_start(ap, format);\n  cnt = vsnprintf(denv->buffer, sizeof(denv->buffer), format, ap);\n  va_end(ap);\n\n  output = (*env)->NewStringUTF(env, denv->buffer);\n  (*env)->CallVoidMethod(env, denv->dis, denv->raw_print, denv->visitor, output);\n  if ((*env)->ExceptionOccurred(env) != NULL) {\n    /* ignore exceptions for now */\n    (*env)->ExceptionClear(env);\n  }\n  return cnt;\n}\n\n/*\n * Class:     sun_jvm_hotspot_asm_Disassembler\n * Method:    decode\n * Signature: (Lsun/jvm/hotspot/asm/InstructionVisitor;J[BLjava/lang/String;J)V\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_asm_Disassembler_decode(JNIEnv * env,\n                                                                    jobject dis,\n                                                                    jobject visitor,\n                                                                    jlong startPc,\n                                                                    jbyteArray code,\n                                                                    jstring options_s,\n                                                                    jlong decode_instructions_virtual) {\n  jboolean isCopy;\n  jbyte* start = (*env)->GetByteArrayElements(env, code, &isCopy);\n  jbyte* end = start + (*env)->GetArrayLength(env, code);\n  const char * options = (*env)->GetStringUTFChars(env, options_s, &isCopy);\n  jclass disclass = (*env)->GetObjectClass(env, dis);\n\n  decode_env denv;\n  denv.env = env;\n  denv.dis = dis;\n  denv.visitor = visitor;\n\n  /* find Disassembler.handleEvent callback */\n  denv.handle_event = (*env)->GetMethodID(env, disclass, \"handleEvent\",\n                                          \"(Lsun/jvm/hotspot/asm/InstructionVisitor;Ljava/lang/String;J)J\");\n  if ((*env)->ExceptionOccurred(env)) {\n    return;\n  }\n\n  /* find Disassembler.rawPrint callback */\n  denv.raw_print = (*env)->GetMethodID(env, disclass, \"rawPrint\",\n                                       \"(Lsun/jvm/hotspot/asm/InstructionVisitor;Ljava/lang/String;)V\");\n  if ((*env)->ExceptionOccurred(env)) {\n    return;\n  }\n\n  /* decode the buffer */\n  (*(decode_func)(uintptr_t)decode_instructions_virtual)(startPc,\n                                                         startPc + end - start,\n                                                         (unsigned char*)start,\n                                                         end - start,\n                                                         &event_to_env,  (void*) &denv,\n                                                         &printf_to_env, (void*) &denv,\n                                                         options, 0 /* newline */);\n\n  /* cleanup */\n  (*env)->ReleaseByteArrayElements(env, code, start, JNI_ABORT);\n  (*env)->ReleaseStringUTFChars(env, options_s, options);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/os/solaris/proc/saproc.cpp": "/*\n * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include \"salibproc.h\"\n#include \"sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal.h\"\n#ifndef SOLARIS_11_B159_OR_LATER\n#include <sys/utsname.h>\n#endif\n#include <thread_db.h>\n#include <strings.h>\n#include <limits.h>\n#include <demangle.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#define CHECK_EXCEPTION_(value) if(env->ExceptionOccurred()) { return value; }\n#define CHECK_EXCEPTION if(env->ExceptionOccurred()) { return;}\n#define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { throwNewDebuggerException(env, str); return value; }\n#define THROW_NEW_DEBUGGER_EXCEPTION(str) { throwNewDebuggerException(env, str); return;}\n\n#define SYMBOL_BUF_SIZE  256\n#define ERR_MSG_SIZE     (PATH_MAX + 256)\n\n// debug modes\nstatic int _libsaproc_debug = 0;\n#ifndef SOLARIS_11_B159_OR_LATER\nstatic bool _Pstack_iter_debug = false;\n\nstatic void dprintf_2(const char* format,...) {\n  if (_Pstack_iter_debug) {\n    va_list alist;\n\n    va_start(alist, format);\n    fputs(\"Pstack_iter DEBUG: \", stderr);\n    vfprintf(stderr, format, alist);\n    va_end(alist);\n  }\n}\n#endif // !SOLARIS_11_B159_OR_LATER\n\nstatic void print_debug(const char* format,...) {\n  if (_libsaproc_debug) {\n    va_list alist;\n\n    va_start(alist, format);\n    fputs(\"libsaproc DEBUG: \", stderr);\n    vfprintf(stderr, format, alist);\n    va_end(alist);\n  }\n}\n\nstruct Debugger {\n    JNIEnv* env;\n    jobject this_obj;\n};\n\nstruct DebuggerWithObject : Debugger {\n    jobject obj;\n};\n\nstruct DebuggerWith2Objects : DebuggerWithObject {\n    jobject obj2;\n};\n\n/*\n* Portions of user thread level detail gathering code is from pstack source\n* code. See pstack.c in Solaris 2.8 user commands source code.\n*/\n\nstatic void throwNewDebuggerException(JNIEnv* env, const char* errMsg) {\n  env->ThrowNew(env->FindClass(\"sun/jvm/hotspot/debugger/DebuggerException\"), errMsg);\n}\n\n// JNI ids for some fields, methods\n\n// libproc handler pointer\nstatic jfieldID p_ps_prochandle_ID = 0;\n\n// libthread.so dlopen handle, thread agent ptr and function pointers\nstatic jfieldID libthread_db_handle_ID   = 0;\nstatic jfieldID p_td_thragent_t_ID       = 0;\nstatic jfieldID p_td_init_ID             = 0;\nstatic jfieldID p_td_ta_new_ID           = 0;\nstatic jfieldID p_td_ta_delete_ID        = 0;\nstatic jfieldID p_td_ta_thr_iter_ID      = 0;\nstatic jfieldID p_td_thr_get_info_ID     = 0;\nstatic jfieldID p_td_ta_map_id2thr_ID    = 0;\nstatic jfieldID p_td_thr_getgregs_ID     = 0;\n\n// reg index fields\nstatic jfieldID pcRegIndex_ID            = 0;\nstatic jfieldID fpRegIndex_ID            = 0;\n\n// part of the class sharing workaround\nstatic jfieldID classes_jsa_fd_ID        = 0;\nstatic jfieldID p_file_map_header_ID     = 0;\n\n// method ids\n\nstatic jmethodID getThreadForThreadId_ID = 0;\nstatic jmethodID createSenderFrame_ID    = 0;\nstatic jmethodID createLoadObject_ID     = 0;\nstatic jmethodID createClosestSymbol_ID  = 0;\nstatic jmethodID listAdd_ID              = 0;\n\n/*\n * Functions we need from libthread_db\n */\ntypedef td_err_e\n        (*p_td_init_t)(void);\ntypedef td_err_e\n        (*p_td_ta_new_t)(void *, td_thragent_t **);\ntypedef td_err_e\n        (*p_td_ta_delete_t)(td_thragent_t *);\ntypedef td_err_e\n        (*p_td_ta_thr_iter_t)(const td_thragent_t *, td_thr_iter_f *, void *,\n                td_thr_state_e, int, sigset_t *, unsigned);\ntypedef td_err_e\n        (*p_td_thr_get_info_t)(const td_thrhandle_t *, td_thrinfo_t *);\ntypedef td_err_e\n        (*p_td_ta_map_id2thr_t)(const td_thragent_t *, thread_t,  td_thrhandle_t *);\ntypedef td_err_e\n        (*p_td_thr_getgregs_t)(const td_thrhandle_t *, prgregset_t);\n\nstatic void\nclear_libthread_db_ptrs(JNIEnv* env, jobject this_obj) {\n  // release libthread_db agent, if we had created\n  p_td_ta_delete_t p_td_ta_delete = 0;\n  p_td_ta_delete = (p_td_ta_delete_t) env->GetLongField(this_obj, p_td_ta_delete_ID);\n\n  td_thragent_t *p_td_thragent_t = 0;\n  p_td_thragent_t = (td_thragent_t*) env->GetLongField(this_obj, p_td_thragent_t_ID);\n  if (p_td_thragent_t != 0 && p_td_ta_delete != 0) {\n     p_td_ta_delete(p_td_thragent_t);\n  }\n\n  // dlclose libthread_db.so\n  void* libthread_db_handle = (void*) env->GetLongField(this_obj, libthread_db_handle_ID);\n  if (libthread_db_handle != 0) {\n    dlclose(libthread_db_handle);\n  }\n\n  env->SetLongField(this_obj, libthread_db_handle_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_init_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_ta_new_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_ta_delete_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_ta_thr_iter_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_thr_get_info_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_ta_map_id2thr_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_thr_getgregs_ID, (jlong)0);\n}\n\n\nstatic void detach_internal(JNIEnv* env, jobject this_obj) {\n  // clear libthread_db stuff\n  clear_libthread_db_ptrs(env, this_obj);\n\n  // release ptr to ps_prochandle\n  jlong p_ps_prochandle;\n  p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  if (p_ps_prochandle != 0L) {\n    Prelease((struct ps_prochandle*) p_ps_prochandle, PRELEASE_CLEAR);\n  }\n\n  // part of the class sharing workaround\n  int classes_jsa_fd = env->GetIntField(this_obj, classes_jsa_fd_ID);\n  if (classes_jsa_fd != -1) {\n    close(classes_jsa_fd);\n    struct FileMapHeader* pheader = (struct FileMapHeader*) env->GetLongField(this_obj, p_file_map_header_ID);\n    if (pheader != NULL) {\n      free(pheader);\n    }\n  }\n}\n\n// Is it okay to ignore libthread_db failure? Set env var to ignore\n// libthread_db failure. You can still debug, but will miss threads\n// related functionality.\nstatic bool sa_ignore_threaddb = (getenv(\"SA_IGNORE_THREADDB\") != 0);\n\n#define HANDLE_THREADDB_FAILURE(msg)          \\\n  if (sa_ignore_threaddb) {                   \\\n     printf(\"libsaproc WARNING: %s\\n\", msg);  \\\n     return;                                  \\\n  } else {                                    \\\n     THROW_NEW_DEBUGGER_EXCEPTION(msg);       \\\n  }\n\n#define HANDLE_THREADDB_FAILURE_(msg, ret)    \\\n  if (sa_ignore_threaddb) {                   \\\n     printf(\"libsaproc WARNING: %s\\n\", msg);  \\\n     return ret;                              \\\n  } else {                                    \\\n     THROW_NEW_DEBUGGER_EXCEPTION_(msg, ret); \\\n  }\n\nstatic const char * alt_root = NULL;\nstatic int alt_root_len = -1;\n\n#define SA_ALTROOT \"SA_ALTROOT\"\n\nstatic void init_alt_root() {\n  if (alt_root_len == -1) {\n    alt_root = getenv(SA_ALTROOT);\n    if (alt_root)\n      alt_root_len = strlen(alt_root);\n    else\n      alt_root_len = 0;\n  }\n}\n\n// This function is a complete substitute for the open system call\n// since it's also used to override open calls from libproc to\n// implement as a pathmap style facility for the SA.  If libproc\n// starts using other interfaces then this might have to extended to\n// cover other calls.\nextern \"C\" int libsaproc_open(const char * name, int oflag, ...) {\n  if (oflag == O_RDONLY) {\n    init_alt_root();\n\n    if (_libsaproc_debug) {\n      printf(\"libsaproc DEBUG: libsaproc_open %s\\n\", name);\n    }\n\n    if (alt_root_len > 0) {\n      int fd = -1;\n      char alt_path[PATH_MAX+1];\n\n      strcpy(alt_path, alt_root);\n      strcat(alt_path, name);\n      fd = open(alt_path, O_RDONLY);\n      if (fd >= 0) {\n        if (_libsaproc_debug) {\n          printf(\"libsaproc DEBUG: libsaproc_open substituted %s\\n\", alt_path);\n        }\n        return fd;\n      }\n\n      if (strrchr(name, '/')) {\n        strcpy(alt_path, alt_root);\n        strcat(alt_path, strrchr(name, '/'));\n        fd = open(alt_path, O_RDONLY);\n        if (fd >= 0) {\n          if (_libsaproc_debug) {\n            printf(\"libsaproc DEBUG: libsaproc_open substituted %s\\n\", alt_path);\n          }\n          return fd;\n        }\n      }\n    }\n  }\n\n  {\n    mode_t mode;\n    va_list ap;\n    va_start(ap, oflag);\n    mode = va_arg(ap, mode_t);\n    va_end(ap);\n\n    return open(name, oflag, mode);\n  }\n}\n\n\nstatic void * pathmap_dlopen(const char * name, int mode) {\n  init_alt_root();\n\n  if (_libsaproc_debug) {\n    printf(\"libsaproc DEBUG: pathmap_dlopen %s\\n\", name);\n  }\n\n  void * handle = NULL;\n  if (alt_root_len > 0) {\n    char alt_path[PATH_MAX+1];\n    strcpy(alt_path, alt_root);\n    strcat(alt_path, name);\n    handle = dlopen(alt_path, mode);\n    if (_libsaproc_debug && handle) {\n      printf(\"libsaproc DEBUG: pathmap_dlopen substituted %s\\n\", alt_path);\n    }\n\n    if (handle == NULL && strrchr(name, '/')) {\n      strcpy(alt_path, alt_root);\n      strcat(alt_path, strrchr(name, '/'));\n      handle = dlopen(alt_path, mode);\n      if (_libsaproc_debug && handle) {\n        printf(\"libsaproc DEBUG: pathmap_dlopen substituted %s\\n\", alt_path);\n      }\n    }\n  }\n  if (handle == NULL) {\n    handle = dlopen(name, mode);\n  }\n  if (_libsaproc_debug) {\n    printf(\"libsaproc DEBUG: pathmap_dlopen %s return 0x%lx\\n\", name, (unsigned long) handle);\n  }\n  return handle;\n}\n\n// libproc and libthread_db callback functions\n\nextern \"C\" {\n\nstatic int\ninit_libthread_db_ptrs(void *cd, const prmap_t *pmp, const char *object_name) {\n  Debugger* dbg = (Debugger*) cd;\n  JNIEnv* env = dbg->env;\n  jobject this_obj = dbg->this_obj;\n  struct ps_prochandle* ph = (struct ps_prochandle*) env->GetLongField(this_obj, p_ps_prochandle_ID);\n\n  char *s1 = 0, *s2 = 0;\n  char libthread_db[PATH_MAX];\n\n  if (strstr(object_name, \"/libthread.so.\") == NULL)\n     return (0);\n\n  /*\n   * We found a libthread.\n   * dlopen() the matching libthread_db and get the thread agent handle.\n   */\n  if (Pstatus(ph)->pr_dmodel == PR_MODEL_NATIVE) {\n     (void) strcpy(libthread_db, object_name);\n     s1 = (char*) strstr(object_name, \".so.\");\n     s2 = (char*) strstr(libthread_db, \".so.\");\n     (void) strcpy(s2, \"_db\");\n     s2 += 3;\n     (void) strcpy(s2, s1);\n  } else {\n#ifdef _LP64\n     /*\n      * The victim process is 32-bit, we are 64-bit.\n      * We have to find the 64-bit version of libthread_db\n      * that matches the victim's 32-bit version of libthread.\n      */\n     (void) strcpy(libthread_db, object_name);\n     s1 = (char*) strstr(object_name, \"/libthread.so.\");\n     s2 = (char*) strstr(libthread_db, \"/libthread.so.\");\n     (void) strcpy(s2, \"/64\");\n     s2 += 3;\n     (void) strcpy(s2, s1);\n     s1 = (char*) strstr(s1, \".so.\");\n     s2 = (char*) strstr(s2, \".so.\");\n     (void) strcpy(s2, \"_db\");\n     s2 += 3;\n     (void) strcpy(s2, s1);\n#else\n     return (0);\n#endif  /* _LP64 */\n  }\n\n  void* libthread_db_handle = 0;\n  if ((libthread_db_handle = pathmap_dlopen(libthread_db, RTLD_LAZY|RTLD_LOCAL)) == NULL) {\n     char errMsg[PATH_MAX + 256];\n     sprintf(errMsg, \"Can't load %s!\", libthread_db);\n     HANDLE_THREADDB_FAILURE_(errMsg, 0);\n  }\n  env->SetLongField(this_obj, libthread_db_handle_ID, (jlong)(uintptr_t)libthread_db_handle);\n\n  void* tmpPtr = 0;\n  tmpPtr = dlsym(libthread_db_handle, \"td_init\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_init!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_init_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr =dlsym(libthread_db_handle, \"td_ta_new\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_ta_new!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_ta_new_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr = dlsym(libthread_db_handle, \"td_ta_delete\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_ta_delete!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_ta_delete_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr = dlsym(libthread_db_handle, \"td_ta_thr_iter\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_ta_thr_iter!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_ta_thr_iter_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr = dlsym(libthread_db_handle, \"td_thr_get_info\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_thr_get_info!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_thr_get_info_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr = dlsym(libthread_db_handle, \"td_ta_map_id2thr\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_ta_map_id2thr!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_ta_map_id2thr_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr = dlsym(libthread_db_handle, \"td_thr_getgregs\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_thr_getgregs!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_thr_getgregs_ID, (jlong)(uintptr_t) tmpPtr);\n\n  return 1;\n}\n\nstatic int\nfill_thread_list(const td_thrhandle_t *p_td_thragent_t, void* cd) {\n  DebuggerWithObject* dbgo = (DebuggerWithObject*) cd;\n  JNIEnv* env = dbgo->env;\n  jobject this_obj = dbgo->this_obj;\n  jobject list = dbgo->obj;\n\n  td_thrinfo_t thrinfo;\n  p_td_thr_get_info_t p_td_thr_get_info = (p_td_thr_get_info_t) env->GetLongField(this_obj, p_td_thr_get_info_ID);\n\n  if (p_td_thr_get_info(p_td_thragent_t, &thrinfo) != TD_OK)\n    return (0);\n\n  jobject threadProxy = env->CallObjectMethod(this_obj, getThreadForThreadId_ID, (jlong)(uintptr_t) thrinfo.ti_tid);\n  CHECK_EXCEPTION_(1);\n  env->CallBooleanMethod(list, listAdd_ID, threadProxy);\n  CHECK_EXCEPTION_(1);\n  return 0;\n}\n\nstatic int\nfill_load_object_list(void *cd, const prmap_t* pmp, const char* obj_name) {\n\n  if (obj_name) {\n     DebuggerWithObject* dbgo = (DebuggerWithObject*) cd;\n     JNIEnv* env = dbgo->env;\n     jobject this_obj = dbgo->this_obj;\n     jobject list = dbgo->obj;\n\n     jstring objectName = env->NewStringUTF(obj_name);\n     CHECK_EXCEPTION_(1);\n\n     jlong mapSize = (jlong) pmp->pr_size;\n     jobject sharedObject = env->CallObjectMethod(this_obj, createLoadObject_ID,\n                                  objectName, mapSize, (jlong)(uintptr_t)pmp->pr_vaddr);\n     CHECK_EXCEPTION_(1);\n     env->CallBooleanMethod(list, listAdd_ID, sharedObject);\n     CHECK_EXCEPTION_(1);\n  }\n\n  return 0;\n}\n\n// Pstack_iter() proc_stack_f callback prior to Nevada-B159\nstatic int\nfill_cframe_list(void *cd, const prgregset_t regs, uint_t argc, const long *argv) {\n  DebuggerWith2Objects* dbgo2 = (DebuggerWith2Objects*) cd;\n  JNIEnv* env = dbgo2->env;\n  jobject this_obj = dbgo2->this_obj;\n  jobject curFrame = dbgo2->obj2;\n\n  jint pcRegIndex = env->GetIntField(this_obj, pcRegIndex_ID);\n  jint fpRegIndex = env->GetIntField(this_obj, fpRegIndex_ID);\n\n  jlong pc = (jlong) (uintptr_t) regs[pcRegIndex];\n  jlong fp = (jlong) (uintptr_t) regs[fpRegIndex];\n\n  dbgo2->obj2 = env->CallObjectMethod(this_obj, createSenderFrame_ID,\n                                    curFrame, pc, fp);\n  CHECK_EXCEPTION_(1);\n  if (dbgo2->obj == 0) {\n     dbgo2->obj = dbgo2->obj2;\n  }\n  return 0;\n}\n\n// Pstack_iter() proc_stack_f callback in Nevada-B159 or later\n/*ARGSUSED*/\nstatic int\nwrapper_fill_cframe_list(void *cd, const prgregset_t regs, uint_t argc,\n                         const long *argv, int frame_flags, int sig) {\n  return(fill_cframe_list(cd, regs, argc, argv));\n}\n\n// part of the class sharing workaround\n\n// FIXME: !!HACK ALERT!!\n\n// The format of sharing achive file header is needed to read shared heap\n// file mappings. For now, I am hard coding portion of FileMapHeader here.\n// Refer to filemap.hpp.\n\n// FileMapHeader describes the shared space data in the file to be\n// mapped.  This structure gets written to a file.  It is not a class, so\n// that the compilers don't add any compiler-private data to it.\n\nconst int NUM_SHARED_MAPS = 4;\n\n// Refer to FileMapInfo::_current_version in filemap.hpp\nconst int CURRENT_ARCHIVE_VERSION = 1;\n\nstruct FileMapHeader {\n int   _magic;              // identify file type.\n int   _version;            // (from enum, above.)\n size_t _alignment;         // how shared archive should be aligned\n\n\n struct space_info {\n   int    _file_offset;     // sizeof(this) rounded to vm page size\n   char*  _base;            // copy-on-write base address\n   size_t _capacity;        // for validity checking\n   size_t _used;            // for setting space top on read\n\n   bool   _read_only;       // read only space?\n   bool   _allow_exec;      // executable code in space?\n\n } _space[NUM_SHARED_MAPS];\n\n // Ignore the rest of the FileMapHeader. We don't need those fields here.\n};\n\nstatic bool\nread_jboolean(struct ps_prochandle* ph, psaddr_t addr, jboolean* pvalue) {\n  jboolean i;\n  if (ps_pread(ph, addr, &i, sizeof(i)) == PS_OK) {\n    *pvalue = i;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstatic bool\nread_pointer(struct ps_prochandle* ph, psaddr_t addr, uintptr_t* pvalue) {\n  uintptr_t uip;\n  if (ps_pread(ph, addr, &uip, sizeof(uip)) == PS_OK) {\n    *pvalue = uip;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstatic bool\nread_string(struct ps_prochandle* ph, psaddr_t addr, char* buf, size_t size) {\n  char ch = ' ';\n  size_t i = 0;\n\n  while (ch != '\\0') {\n    if (ps_pread(ph, addr, &ch, sizeof(ch)) != PS_OK)\n      return false;\n\n    if (i < size - 1) {\n      buf[i] = ch;\n    } else { // smaller buffer\n      return false;\n    }\n\n    i++; addr++;\n  }\n\n  buf[i] = '\\0';\n  return true;\n}\n\n#define USE_SHARED_SPACES_SYM   \"UseSharedSpaces\"\n// mangled symbol name for Arguments::SharedArchivePath\n#define SHARED_ARCHIVE_PATH_SYM \"__1cJArgumentsRSharedArchivePath_\"\n\nstatic int\ninit_classsharing_workaround(void *cd, const prmap_t* pmap, const char* obj_name) {\n  Debugger* dbg = (Debugger*) cd;\n  JNIEnv*   env = dbg->env;\n  jobject this_obj = dbg->this_obj;\n  const char* jvm_name = 0;\n  if ((jvm_name = strstr(obj_name, \"libjvm.so\")) != NULL) {\n    jvm_name = obj_name;\n  } else {\n    return 0;\n  }\n\n  struct ps_prochandle* ph = (struct ps_prochandle*) env->GetLongField(this_obj, p_ps_prochandle_ID);\n\n  // initialize classes.jsa file descriptor field.\n  dbg->env->SetIntField(this_obj, classes_jsa_fd_ID, -1);\n\n  // check whether class sharing is on by reading variable \"UseSharedSpaces\"\n  psaddr_t useSharedSpacesAddr = 0;\n  ps_pglobal_lookup(ph, jvm_name, USE_SHARED_SPACES_SYM, &useSharedSpacesAddr);\n  if (useSharedSpacesAddr == 0) {\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't find 'UseSharedSpaces' flag\\n\", 1);\n  }\n\n  // read the value of the flag \"UseSharedSpaces\"\n  // Since hotspot types are not available to build this library. So\n  // equivalent type \"jboolean\" is used to read the value of \"UseSharedSpaces\"\n  // which is same as hotspot type \"bool\".\n  jboolean value = 0;\n  if (read_jboolean(ph, useSharedSpacesAddr, &value) != true) {\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't read 'UseSharedSpaces' flag\", 1);\n  } else if ((int)value == 0) {\n    print_debug(\"UseSharedSpaces is false, assuming -Xshare:off!\\n\");\n    return 1;\n  }\n\n  char classes_jsa[PATH_MAX];\n  psaddr_t sharedArchivePathAddrAddr = 0;\n  ps_pglobal_lookup(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM, &sharedArchivePathAddrAddr);\n  if (sharedArchivePathAddrAddr == 0) {\n    print_debug(\"can't find symbol 'Arguments::SharedArchivePath'\\n\");\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't get shared archive path from debuggee\", 1);\n  }\n\n  uintptr_t sharedArchivePathAddr = 0;\n  if (read_pointer(ph, sharedArchivePathAddrAddr, &sharedArchivePathAddr) != true) {\n    print_debug(\"can't find read pointer 'Arguments::SharedArchivePath'\\n\");\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't get shared archive path from debuggee\", 1);\n  }\n\n  if (read_string(ph, (psaddr_t)sharedArchivePathAddr, classes_jsa, sizeof(classes_jsa)) != true) {\n    print_debug(\"can't find read 'Arguments::SharedArchivePath' value\\n\");\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't get shared archive path from debuggee\", 1);\n  }\n\n  print_debug(\"looking for %s\\n\", classes_jsa);\n\n  // open the classes.jsa\n  int fd = libsaproc_open(classes_jsa, O_RDONLY);\n  if (fd < 0) {\n    char errMsg[ERR_MSG_SIZE];\n    sprintf(errMsg, \"can't open shared archive file %s\", classes_jsa);\n    THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);\n  } else {\n    print_debug(\"opened shared archive file %s\\n\", classes_jsa);\n  }\n\n  // parse classes.jsa\n  struct FileMapHeader* pheader = (struct FileMapHeader*) malloc(sizeof(struct FileMapHeader));\n  if (pheader == NULL) {\n    close(fd);\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't allocate memory for shared file map header\", 1);\n  }\n\n  memset(pheader, 0, sizeof(struct FileMapHeader));\n  // read FileMapHeader\n  size_t n = read(fd, pheader, sizeof(struct FileMapHeader));\n  if (n != sizeof(struct FileMapHeader)) {\n    char errMsg[ERR_MSG_SIZE];\n    sprintf(errMsg, \"unable to read shared archive file map header from %s\", classes_jsa);\n    close(fd);\n    free(pheader);\n    THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);\n  }\n\n  // check file magic\n  if (pheader->_magic != 0xf00baba2) {\n    char errMsg[ERR_MSG_SIZE];\n    sprintf(errMsg, \"%s has bad shared archive magic 0x%x, expecting 0xf00baba2\",\n                   classes_jsa, pheader->_magic);\n    close(fd);\n    free(pheader);\n    THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);\n  }\n\n  // check version\n  if (pheader->_version != CURRENT_ARCHIVE_VERSION) {\n    char errMsg[ERR_MSG_SIZE];\n    sprintf(errMsg, \"%s has wrong shared archive version %d, expecting %d\",\n                   classes_jsa, pheader->_version, CURRENT_ARCHIVE_VERSION);\n    close(fd);\n    free(pheader);\n    THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);\n  }\n\n  if (_libsaproc_debug) {\n    for (int m = 0; m < NUM_SHARED_MAPS; m++) {\n       print_debug(\"shared file offset %d mapped at 0x%lx, size = %ld, read only? = %d\\n\",\n          pheader->_space[m]._file_offset, pheader->_space[m]._base,\n          pheader->_space[m]._used, pheader->_space[m]._read_only);\n    }\n  }\n\n  // FIXME: For now, omitting other checks such as VM version etc.\n\n  // store class archive file fd and map header in debugger object fields\n  dbg->env->SetIntField(this_obj, classes_jsa_fd_ID, fd);\n  dbg->env->SetLongField(this_obj, p_file_map_header_ID, (jlong)(uintptr_t) pheader);\n  return 1;\n}\n\n} // extern \"C\"\n\n// error messages for proc_arg_grab failure codes. The messages are\n// modified versions of comments against corresponding #defines in\n// libproc.h.\nstatic const char* proc_arg_grab_errmsgs[] = {\n                      \"\",\n /* G_NOPROC */       \"No such process\",\n /* G_NOCORE */       \"No such core file\",\n /* G_NOPROCORCORE */ \"No such process or core\",\n /* G_NOEXEC */       \"Cannot locate executable file\",\n /* G_ZOMB   */       \"Zombie processs\",\n /* G_PERM   */       \"No permission to attach\",\n /* G_BUSY   */       \"Another process has already attached\",\n /* G_SYS    */       \"System process - can not attach\",\n /* G_SELF   */       \"Process is self - can't debug myself!\",\n /* G_INTR   */       \"Interrupt received while grabbing\",\n /* G_LP64   */       \"debuggee is 64 bit, use java -d64 for debugger\",\n /* G_FORMAT */       \"File is not an ELF format core file - corrupted core?\",\n /* G_ELF    */       \"Libelf error while parsing an ELF file\",\n /* G_NOTE   */       \"Required PT_NOTE Phdr not present - corrupted core?\",\n};\n\nstatic void attach_internal(JNIEnv* env, jobject this_obj, jstring cmdLine, jboolean isProcess) {\n  jboolean isCopy;\n  int gcode;\n  const char* cmdLine_cstr = env->GetStringUTFChars(cmdLine, &isCopy);\n  CHECK_EXCEPTION;\n\n  // some older versions of libproc.so crash when trying to attach 32 bit\n  // debugger to 64 bit core file. check and throw error.\n#ifndef _LP64\n  atoi(cmdLine_cstr);\n  if (errno) {\n     // core file\n     int core_fd;\n     if ((core_fd = open64(cmdLine_cstr, O_RDONLY)) >= 0) {\n        Elf32_Ehdr e32;\n        if (pread64(core_fd, &e32, sizeof (e32), 0) == sizeof (e32) &&\n            memcmp(&e32.e_ident[EI_MAG0], ELFMAG, SELFMAG) == 0 &&\n            e32.e_type == ET_CORE && e32.e_ident[EI_CLASS] == ELFCLASS64) {\n              close(core_fd);\n              THROW_NEW_DEBUGGER_EXCEPTION(\"debuggee is 64 bit, use java -d64 for debugger\");\n        }\n        close(core_fd);\n     }\n     // all other conditions are handled by libproc.so.\n  }\n#endif\n\n  // connect to process/core\n  struct ps_prochandle* ph = proc_arg_grab(cmdLine_cstr, (isProcess? PR_ARG_PIDS : PR_ARG_CORES), PGRAB_FORCE, &gcode);\n  env->ReleaseStringUTFChars(cmdLine, cmdLine_cstr);\n  if (! ph) {\n     if (gcode > 0 && gcode < sizeof(proc_arg_grab_errmsgs)/sizeof(const char*)) {\n        char errMsg[ERR_MSG_SIZE];\n        sprintf(errMsg, \"Attach failed : %s\", proc_arg_grab_errmsgs[gcode]);\n        THROW_NEW_DEBUGGER_EXCEPTION(errMsg);\n    } else {\n        if (_libsaproc_debug && gcode == G_STRANGE) {\n           perror(\"libsaproc DEBUG: \");\n        }\n        if (isProcess) {\n           THROW_NEW_DEBUGGER_EXCEPTION(\"Not able to attach to process!\");\n        } else {\n           THROW_NEW_DEBUGGER_EXCEPTION(\"Not able to attach to core file!\");\n        }\n     }\n  }\n\n  // even though libproc.so supports 64 bit debugger and 32 bit debuggee, we don't\n  // support such cross-bit-debugging. check for that combination and throw error.\n#ifdef _LP64\n  int data_model;\n  if (ps_pdmodel(ph, &data_model) != PS_OK) {\n     Prelease(ph, PRELEASE_CLEAR);\n     THROW_NEW_DEBUGGER_EXCEPTION(\"can't determine debuggee data model (ILP32? or LP64?)\");\n  }\n  if (data_model == PR_MODEL_ILP32) {\n     Prelease(ph, PRELEASE_CLEAR);\n     THROW_NEW_DEBUGGER_EXCEPTION(\"debuggee is 32 bit, use 32 bit java for debugger\");\n  }\n#endif\n\n  env->SetLongField(this_obj, p_ps_prochandle_ID, (jlong)(uintptr_t)ph);\n\n  Debugger dbg;\n  dbg.env = env;\n  dbg.this_obj = this_obj;\n  jthrowable exception = 0;\n  if (! isProcess) {\n    /*\n     * With class sharing, shared perm. gen heap is allocated in with MAP_SHARED|PROT_READ.\n     * These pages are mapped from the file \"classes.jsa\". MAP_SHARED pages are not dumped\n     * in Solaris core.To read shared heap pages, we have to read classes.jsa file.\n     */\n    Pobject_iter(ph, init_classsharing_workaround, &dbg);\n    exception = env->ExceptionOccurred();\n    if (exception) {\n      env->ExceptionClear();\n      detach_internal(env, this_obj);\n      env->Throw(exception);\n      return;\n    }\n  }\n\n  /*\n   * Iterate over the process mappings looking\n   * for libthread and then dlopen the appropriate\n   * libthread_db and get function pointers.\n   */\n  Pobject_iter(ph, init_libthread_db_ptrs, &dbg);\n  exception = env->ExceptionOccurred();\n  if (exception) {\n    env->ExceptionClear();\n    if (!sa_ignore_threaddb) {\n      detach_internal(env, this_obj);\n      env->Throw(exception);\n    }\n    return;\n  }\n\n  // init libthread_db and create thread_db agent\n  p_td_init_t p_td_init = (p_td_init_t) env->GetLongField(this_obj, p_td_init_ID);\n  if (p_td_init == 0) {\n    if (!sa_ignore_threaddb) {\n      detach_internal(env, this_obj);\n    }\n    HANDLE_THREADDB_FAILURE(\"Did not find libthread in target process/core!\");\n  }\n\n  if (p_td_init() != TD_OK) {\n    if (!sa_ignore_threaddb) {\n      detach_internal(env, this_obj);\n    }\n    HANDLE_THREADDB_FAILURE(\"Can't initialize thread_db!\");\n  }\n\n  p_td_ta_new_t p_td_ta_new = (p_td_ta_new_t) env->GetLongField(this_obj, p_td_ta_new_ID);\n\n  td_thragent_t *p_td_thragent_t = 0;\n  if (p_td_ta_new(ph, &p_td_thragent_t) != TD_OK) {\n    if (!sa_ignore_threaddb) {\n      detach_internal(env, this_obj);\n    }\n    HANDLE_THREADDB_FAILURE(\"Can't create thread_db agent!\");\n  }\n  env->SetLongField(this_obj, p_td_thragent_t_ID, (jlong)(uintptr_t) p_td_thragent_t);\n\n}\n\n/*\n * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:    attach0\n * Signature: (Ljava/lang/String;)V\n * Description: process detach\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_attach0__Ljava_lang_String_2\n  (JNIEnv *env, jobject this_obj, jstring pid) {\n  attach_internal(env, this_obj, pid, JNI_TRUE);\n}\n\n/*\n * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:    attach0\n * Signature: (Ljava/lang/String;Ljava/lang/String;)V\n * Description: core file detach\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2\n  (JNIEnv *env, jobject this_obj, jstring executable, jstring corefile) {\n  // ignore executable file name, libproc.so can detect a.out name anyway.\n  attach_internal(env, this_obj, corefile, JNI_FALSE);\n}\n\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      detach0\n * Signature:   ()V\n * Description: process/core file detach\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_detach0\n  (JNIEnv *env, jobject this_obj) {\n  detach_internal(env, this_obj);\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      getRemoteProcessAddressSize0\n * Signature:   ()I\n * Description: get process/core address size\n */\nJNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_getRemoteProcessAddressSize0\n  (JNIEnv *env, jobject this_obj) {\n  jlong p_ps_prochandle;\n  p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  int data_model = PR_MODEL_ILP32;\n  ps_pdmodel((struct ps_prochandle*) p_ps_prochandle, &data_model);\n  print_debug(\"debuggee is %d bit\\n\", data_model == PR_MODEL_ILP32? 32 : 64);\n  return (jint) data_model == PR_MODEL_ILP32? 32 : 64;\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      getPageSize0\n * Signature:   ()I\n * Description: get process/core page size\n */\nJNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_getPageSize0\n  (JNIEnv *env, jobject this_obj) {\n\n/*\n  We are not yet attached to a java process or core file. getPageSize is called from\n  the constructor of ProcDebuggerLocal. The following won't work!\n\n    jlong p_ps_prochandle;\n    p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n    CHECK_EXCEPTION_(-1);\n    struct ps_prochandle* prochandle = (struct ps_prochandle*) p_ps_prochandle;\n    return (Pstate(prochandle) == PS_DEAD) ? Pgetauxval(prochandle, AT_PAGESZ)\n                                           : getpagesize();\n\n  So even though core may have been generated with a different page size settings, for now\n  call getpagesize.\n*/\n\n  return getpagesize();\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      getThreadIntegerRegisterSet0\n * Signature:   (J)[J\n * Description: get gregset for a given thread specified by thread id\n */\nJNIEXPORT jlongArray JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_getThreadIntegerRegisterSet0\n  (JNIEnv *env, jobject this_obj, jlong tid) {\n  // map the thread id to thread handle\n  p_td_ta_map_id2thr_t p_td_ta_map_id2thr = (p_td_ta_map_id2thr_t) env->GetLongField(this_obj, p_td_ta_map_id2thr_ID);\n\n  td_thragent_t* p_td_thragent_t = (td_thragent_t*) env->GetLongField(this_obj, p_td_thragent_t_ID);\n  if (p_td_thragent_t == 0) {\n     return 0;\n  }\n\n  td_thrhandle_t thr_handle;\n  if (p_td_ta_map_id2thr(p_td_thragent_t, (thread_t) tid, &thr_handle) != TD_OK) {\n     THROW_NEW_DEBUGGER_EXCEPTION_(\"can't map thread id to thread handle!\", 0);\n  }\n\n  p_td_thr_getgregs_t p_td_thr_getgregs = (p_td_thr_getgregs_t) env->GetLongField(this_obj, p_td_thr_getgregs_ID);\n  prgregset_t gregs;\n  p_td_thr_getgregs(&thr_handle, gregs);\n\n  jlongArray res = env->NewLongArray(NPRGREG);\n  CHECK_EXCEPTION_(0);\n  jboolean isCopy;\n  jlong* ptr = env->GetLongArrayElements(res, &isCopy);\n  for (int i = 0; i < NPRGREG; i++) {\n    ptr[i] = (jlong) (uintptr_t) gregs[i];\n  }\n  env->ReleaseLongArrayElements(res, ptr, JNI_COMMIT);\n  return res;\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      fillThreadList0\n * Signature:   (Ljava/util/List;)V\n * Description: fills thread list of the debuggee process/core\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_fillThreadList0\n  (JNIEnv *env, jobject this_obj, jobject list) {\n\n  td_thragent_t* p_td_thragent_t = (td_thragent_t*) env->GetLongField(this_obj, p_td_thragent_t_ID);\n  if (p_td_thragent_t == 0) {\n     return;\n  }\n\n  p_td_ta_thr_iter_t p_td_ta_thr_iter = (p_td_ta_thr_iter_t) env->GetLongField(this_obj, p_td_ta_thr_iter_ID);\n\n  DebuggerWithObject dbgo;\n  dbgo.env = env;\n  dbgo.this_obj = this_obj;\n  dbgo.obj = list;\n\n  p_td_ta_thr_iter(p_td_thragent_t, fill_thread_list, &dbgo,\n                   TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY, TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS);\n}\n\n#ifndef SOLARIS_11_B159_OR_LATER\n// building on Nevada-B158 or earlier so more hoops to jump through\nstatic bool has_newer_Pstack_iter = false;  // older version by default\n#endif\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      fillCFrameList0\n * Signature:   ([J)Lsun/jvm/hotspot/debugger/proc/ProcCFrame;\n * Description: fills CFrame list for a given thread\n */\nJNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_fillCFrameList0\n  (JNIEnv *env, jobject this_obj, jlongArray regsArray) {\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n\n  DebuggerWith2Objects dbgo2;\n  dbgo2.env  = env;\n  dbgo2.this_obj = this_obj;\n  dbgo2.obj  = NULL;\n  dbgo2.obj2 = NULL;\n\n  jboolean isCopy;\n  jlong* ptr = env->GetLongArrayElements(regsArray, &isCopy);\n  CHECK_EXCEPTION_(0);\n\n  prgregset_t gregs;\n  for (int i = 0; i < NPRGREG; i++) {\n     gregs[i] = (uintptr_t) ptr[i];\n  }\n\n  env->ReleaseLongArrayElements(regsArray, ptr, JNI_ABORT);\n  CHECK_EXCEPTION_(0);\n\n#ifdef SOLARIS_11_B159_OR_LATER\n  // building on Nevada-B159 or later so use the new callback\n  Pstack_iter((struct ps_prochandle*) p_ps_prochandle, gregs,\n              wrapper_fill_cframe_list, &dbgo2);\n#else\n  // building on Nevada-B158 or earlier so figure out which callback to use\n\n  if (has_newer_Pstack_iter) {\n    // Since we're building on Nevada-B158 or earlier, we have to\n    // cast wrapper_fill_cframe_list to make the compiler happy.\n    Pstack_iter((struct ps_prochandle*) p_ps_prochandle, gregs,\n                (proc_stack_f *)wrapper_fill_cframe_list, &dbgo2);\n  } else {\n    Pstack_iter((struct ps_prochandle*) p_ps_prochandle, gregs,\n                fill_cframe_list, &dbgo2);\n  }\n#endif // SOLARIS_11_B159_OR_LATER\n  return dbgo2.obj;\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      fillLoadObjectList0\n * Signature:   (Ljava/util/List;)V\n * Description: fills shared objects of the debuggee process/core\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_fillLoadObjectList0\n  (JNIEnv *env, jobject this_obj, jobject list) {\n  DebuggerWithObject dbgo;\n  dbgo.env = env;\n  dbgo.this_obj = this_obj;\n  dbgo.obj = list;\n\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  Pobject_iter((struct ps_prochandle*) p_ps_prochandle, fill_load_object_list, &dbgo);\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      readBytesFromProcess0\n * Signature:   (JJ)[B\n * Description: read bytes from debuggee process/core\n */\nJNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_readBytesFromProcess0\n  (JNIEnv *env, jobject this_obj, jlong address, jlong numBytes) {\n\n  jbyteArray array = env->NewByteArray(numBytes);\n  CHECK_EXCEPTION_(0);\n  jboolean isCopy;\n  jbyte* bufPtr = env->GetByteArrayElements(array, &isCopy);\n  CHECK_EXCEPTION_(0);\n\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  ps_err_e ret = ps_pread((struct ps_prochandle*) p_ps_prochandle,\n                       (psaddr_t)address, bufPtr, (size_t)numBytes);\n\n  if (ret != PS_OK) {\n    // part of the class sharing workaround. try shared heap area\n    int classes_jsa_fd = env->GetIntField(this_obj, classes_jsa_fd_ID);\n    if (classes_jsa_fd != -1 && address != (jlong)0) {\n      print_debug(\"read failed at 0x%lx, attempting shared heap area\\n\", (long) address);\n\n      struct FileMapHeader* pheader = (struct FileMapHeader*) env->GetLongField(this_obj, p_file_map_header_ID);\n      // walk through the shared mappings -- we just have 4 of them.\n      // so, linear walking is okay.\n      for (int m = 0; m < NUM_SHARED_MAPS; m++) {\n\n        // We can skip the non-read-only maps. These are mapped as MAP_PRIVATE\n        // and hence will be read by libproc. Besides, the file copy may be\n        // stale because the process might have modified those pages.\n        if (pheader->_space[m]._read_only) {\n          jlong baseAddress = (jlong) (uintptr_t) pheader->_space[m]._base;\n          size_t usedSize = pheader->_space[m]._used;\n          if (address >= baseAddress && address < (baseAddress + usedSize)) {\n            // the given address falls in this shared heap area\n            print_debug(\"found shared map at 0x%lx\\n\", (long) baseAddress);\n\n\n            // If more data is asked than actually mapped from file, we need to zero fill\n            // till the end-of-page boundary. But, java array new does that for us. we just\n            // need to read as much as data available.\n\n#define MIN2(x, y) (((x) < (y))? (x) : (y))\n\n            jlong diff = address - baseAddress;\n            jlong bytesToRead = MIN2(numBytes, usedSize - diff);\n            off_t offset = pheader->_space[m]._file_offset  + off_t(diff);\n            ssize_t bytesRead = pread(classes_jsa_fd, bufPtr, bytesToRead, offset);\n            if (bytesRead != bytesToRead) {\n              env->ReleaseByteArrayElements(array, bufPtr, JNI_ABORT);\n              print_debug(\"shared map read failed\\n\");\n              return jbyteArray(0);\n            } else {\n              print_debug(\"shared map read succeeded\\n\");\n              env->ReleaseByteArrayElements(array, bufPtr, 0);\n              return array;\n            }\n          } // is in current map\n        } // is read only map\n      } // for shared maps\n    } // classes_jsa_fd != -1\n    env->ReleaseByteArrayElements(array, bufPtr, JNI_ABORT);\n    return jbyteArray(0);\n  } else {\n    env->ReleaseByteArrayElements(array, bufPtr, 0);\n    return array;\n  }\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      writeBytesToProcess0\n * Signature:   (JJ[B)V\n * Description: write bytes into debugger process\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_writeBytesToProcess0\n  (JNIEnv *env, jobject this_obj, jlong address, jlong numBytes, jbyteArray data) {\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  jboolean isCopy;\n  jbyte* ptr = env->GetByteArrayElements(data, &isCopy);\n  CHECK_EXCEPTION;\n\n  if (ps_pwrite((struct ps_prochandle*) p_ps_prochandle, address, ptr, numBytes) != PS_OK) {\n     env->ReleaseByteArrayElements(data, ptr, JNI_ABORT);\n     THROW_NEW_DEBUGGER_EXCEPTION(\"Process write failed!\");\n  }\n\n  env->ReleaseByteArrayElements(data, ptr, JNI_ABORT);\n}\n\n/*\n * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:    suspend0\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_suspend0\n  (JNIEnv *env, jobject this_obj) {\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  // for now don't check return value. revisit this again.\n  Pstop((struct ps_prochandle*) p_ps_prochandle, 1000);\n}\n\n/*\n * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:    resume0\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_resume0\n  (JNIEnv *env, jobject this_obj) {\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  // for now don't check return value. revisit this again.\n  Psetrun((struct ps_prochandle*) p_ps_prochandle, 0, PRCFAULT|PRSTOP);\n}\n\n/*\n  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n  * Method:      lookupByName0\n  * Signature:   (Ljava/lang/String;Ljava/lang/String;)J\n  * Description: symbol lookup by name\n*/\nJNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_lookupByName0\n   (JNIEnv *env, jobject this_obj, jstring objectName, jstring symbolName) {\n   jlong p_ps_prochandle;\n   p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n\n   jboolean isCopy;\n   const char* objectName_cstr = NULL;\n   if (objectName != NULL) {\n     objectName_cstr = env->GetStringUTFChars(objectName, &isCopy);\n     CHECK_EXCEPTION_(0);\n   } else {\n     objectName_cstr = PR_OBJ_EVERY;\n   }\n\n   const char* symbolName_cstr = env->GetStringUTFChars(symbolName, &isCopy);\n   CHECK_EXCEPTION_(0);\n\n   psaddr_t symbol_addr = (psaddr_t) 0;\n   ps_pglobal_lookup((struct ps_prochandle*) p_ps_prochandle,  objectName_cstr,\n                    symbolName_cstr, &symbol_addr);\n\n   if (symbol_addr == 0) {\n      print_debug(\"lookup for %s in %s failed\\n\", symbolName_cstr, objectName_cstr);\n   }\n\n   if (objectName_cstr != PR_OBJ_EVERY) {\n     env->ReleaseStringUTFChars(objectName, objectName_cstr);\n   }\n   env->ReleaseStringUTFChars(symbolName, symbolName_cstr);\n   return (jlong) (uintptr_t) symbol_addr;\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      lookupByAddress0\n * Signature:   (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;\n * Description: lookup symbol name for a given address\n */\nJNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_lookupByAddress0\n   (JNIEnv *env, jobject this_obj, jlong address) {\n   jlong p_ps_prochandle;\n   p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n\n   char nameBuf[SYMBOL_BUF_SIZE + 1];\n   GElf_Sym sym;\n   int res = Plookup_by_addr((struct ps_prochandle*) p_ps_prochandle, (uintptr_t) address,\n                                 nameBuf, sizeof(nameBuf), &sym);\n   if (res != 0) { // failed\n      return 0;\n   }\n\n   jstring resSym = env->NewStringUTF(nameBuf);\n   CHECK_EXCEPTION_(0);\n\n   return env->CallObjectMethod(this_obj, createClosestSymbol_ID, resSym, (address - sym.st_value));\n}\n\n/*\n * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:    demangle0\n * Signature: (Ljava/lang/String;)Ljava/lang/String;\n */\nJNIEXPORT jstring JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_demangle0\n  (JNIEnv *env, jobject this_object, jstring name) {\n  jboolean isCopy;\n  const char* ptr = env->GetStringUTFChars(name, &isCopy);\n  char  buf[2*SYMBOL_BUF_SIZE + 1];\n  jstring res = 0;\n  if (cplus_demangle((char*) ptr, buf, sizeof(buf)) != DEMANGLE_ESPACE) {\n    res = env->NewStringUTF(buf);\n  } else {\n    res = name;\n  }\n  env->ReleaseStringUTFChars(name, ptr);\n  return res;\n}\n\n#ifndef SOLARIS_11_B159_OR_LATER\n// Determine if the OS we're running on has the newer version\n// of libproc's Pstack_iter.\n//\n// Set env var PSTACK_ITER_DEBUG=true to debug this logic.\n// Set env var PSTACK_ITER_DEBUG_RELEASE to simulate a 'release' value.\n// Set env var PSTACK_ITER_DEBUG_VERSION to simulate a 'version' value.\n//\n// frankenputer 'uname -r -v': 5.10 Generic_141445-09\n// jurassic 'uname -r -v':     5.11 snv_164\n// lonepeak 'uname -r -v':     5.11 snv_127\n//\nstatic void set_has_newer_Pstack_iter(JNIEnv *env) {\n  static bool done_set = false;\n\n  if (done_set) {\n    // already set has_newer_Pstack_iter\n    return;\n  }\n\n  struct utsname name;\n  if (uname(&name) == -1) {\n    THROW_NEW_DEBUGGER_EXCEPTION(\"uname() failed!\");\n  }\n  dprintf_2(\"release='%s'  version='%s'\\n\", name.release, name.version);\n\n  if (_Pstack_iter_debug) {\n    char *override = getenv(\"PSTACK_ITER_DEBUG_RELEASE\");\n    if (override != NULL) {\n      strncpy(name.release, override, SYS_NMLN - 1);\n      name.release[SYS_NMLN - 2] = '\\0';\n      dprintf_2(\"overriding with release='%s'\\n\", name.release);\n    }\n    override = getenv(\"PSTACK_ITER_DEBUG_VERSION\");\n    if (override != NULL) {\n      strncpy(name.version, override, SYS_NMLN - 1);\n      name.version[SYS_NMLN - 2] = '\\0';\n      dprintf_2(\"overriding with version='%s'\\n\", name.version);\n    }\n  }\n\n  // the major number corresponds to the old SunOS major number\n  int major = atoi(name.release);\n  if (major >= 6) {\n    dprintf_2(\"release is SunOS 6 or later\\n\");\n    has_newer_Pstack_iter = true;\n    done_set = true;\n    return;\n  }\n  if (major < 5) {\n    dprintf_2(\"release is SunOS 4 or earlier\\n\");\n    done_set = true;\n    return;\n  }\n\n  // some SunOS 5.* build so now check for Solaris versions\n  char *dot = strchr(name.release, '.');\n  int minor = 0;\n  if (dot != NULL) {\n    // release is major.minor format\n    *dot = NULL;\n    minor = atoi(dot + 1);\n  }\n\n  if (minor <= 10) {\n    dprintf_2(\"release is Solaris 10 or earlier\\n\");\n    done_set = true;\n    return;\n  } else if (minor >= 12) {\n    dprintf_2(\"release is Solaris 12 or later\\n\");\n    has_newer_Pstack_iter = true;\n    done_set = true;\n    return;\n  }\n\n  // some Solaris 11 build so now check for internal build numbers\n  if (strncmp(name.version, \"snv_\", 4) != 0) {\n    dprintf_2(\"release is Solaris 11 post-GA or later\\n\");\n    has_newer_Pstack_iter = true;\n    done_set = true;\n    return;\n  }\n\n  // version begins with \"snv_\" so a pre-GA build of Solaris 11\n  int build = atoi(&name.version[4]);\n  if (build >= 159) {\n    dprintf_2(\"release is Nevada-B159 or later\\n\");\n    has_newer_Pstack_iter = true;\n  } else {\n    dprintf_2(\"release is Nevada-B158 or earlier\\n\");\n  }\n\n  done_set = true;\n}\n#endif // !SOLARIS_11_B159_OR_LATER\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      initIDs\n * Signature:   ()V\n * Description: get JNI ids for fields and methods of ProcDebuggerLocal class\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_initIDs\n  (JNIEnv *env, jclass clazz) {\n  _libsaproc_debug = getenv(\"LIBSAPROC_DEBUG\") != NULL;\n  if (_libsaproc_debug) {\n     // propagate debug mode to libproc.so\n     static const char* var = \"LIBPROC_DEBUG=1\";\n     putenv((char*)var);\n  }\n\n  void* libproc_handle = dlopen(\"libproc.so\", RTLD_LAZY | RTLD_GLOBAL);\n  if (libproc_handle == 0)\n     THROW_NEW_DEBUGGER_EXCEPTION(\"can't load libproc.so, if you are using Solaris 5.7 or below, copy libproc.so from 5.8!\");\n\n#ifndef SOLARIS_11_B159_OR_LATER\n  _Pstack_iter_debug = getenv(\"PSTACK_ITER_DEBUG\") != NULL;\n\n  set_has_newer_Pstack_iter(env);\n  CHECK_EXCEPTION;\n  dprintf_2(\"has_newer_Pstack_iter=%d\\n\", has_newer_Pstack_iter);\n#endif\n\n  p_ps_prochandle_ID = env->GetFieldID(clazz, \"p_ps_prochandle\", \"J\");\n  CHECK_EXCEPTION;\n\n  libthread_db_handle_ID = env->GetFieldID(clazz, \"libthread_db_handle\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_thragent_t_ID = env->GetFieldID(clazz, \"p_td_thragent_t\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_init_ID = env->GetFieldID(clazz, \"p_td_init\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_ta_new_ID = env->GetFieldID(clazz, \"p_td_ta_new\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_ta_delete_ID = env->GetFieldID(clazz, \"p_td_ta_delete\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_ta_thr_iter_ID = env->GetFieldID(clazz, \"p_td_ta_thr_iter\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_thr_get_info_ID = env->GetFieldID(clazz, \"p_td_thr_get_info\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_ta_map_id2thr_ID = env->GetFieldID(clazz, \"p_td_ta_map_id2thr\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_thr_getgregs_ID = env->GetFieldID(clazz, \"p_td_thr_getgregs\", \"J\");\n  CHECK_EXCEPTION;\n\n  getThreadForThreadId_ID = env->GetMethodID(clazz,\n                            \"getThreadForThreadId\", \"(J)Lsun/jvm/hotspot/debugger/ThreadProxy;\");\n  CHECK_EXCEPTION;\n\n  pcRegIndex_ID = env->GetFieldID(clazz, \"pcRegIndex\", \"I\");\n  CHECK_EXCEPTION;\n\n  fpRegIndex_ID = env->GetFieldID(clazz, \"fpRegIndex\", \"I\");\n  CHECK_EXCEPTION;\n\n  createSenderFrame_ID = env->GetMethodID(clazz,\n                            \"createSenderFrame\", \"(Lsun/jvm/hotspot/debugger/proc/ProcCFrame;JJ)Lsun/jvm/hotspot/debugger/proc/ProcCFrame;\");\n  CHECK_EXCEPTION;\n\n  createLoadObject_ID = env->GetMethodID(clazz,\n                            \"createLoadObject\", \"(Ljava/lang/String;JJ)Lsun/jvm/hotspot/debugger/cdbg/LoadObject;\");\n  CHECK_EXCEPTION;\n\n  createClosestSymbol_ID = env->GetMethodID(clazz,\n                            \"createClosestSymbol\", \"(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;\");\n  CHECK_EXCEPTION;\n\n  listAdd_ID = env->GetMethodID(env->FindClass(\"java/util/List\"), \"add\", \"(Ljava/lang/Object;)Z\");\n  CHECK_EXCEPTION;\n\n  // part of the class sharing workaround\n  classes_jsa_fd_ID = env->GetFieldID(clazz, \"classes_jsa_fd\", \"I\");\n  CHECK_EXCEPTION;\n  p_file_map_header_ID = env->GetFieldID(clazz, \"p_file_map_header\", \"J\");\n  CHECK_EXCEPTION;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/os/solaris/proc/saproc_audit.cpp": "/*\n * Copyright (c) 2009, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include <link.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <varargs.h>\n\n// This class sets up an interposer on open calls from libproc.so to\n// support a pathmap facility in the SA.\n\nstatic uintptr_t* libproc_cookie;\nstatic uintptr_t* libc_cookie;\nstatic uintptr_t* libsaproc_cookie;\n\n\nuint_t\nla_version(uint_t version)\n{\n  return (LAV_CURRENT);\n}\n\n\nuint_t\nla_objopen(Link_map * lmp, Lmid_t lmid, uintptr_t * cookie)\n{\n  if (strstr(lmp->l_name, \"/libproc.so\") != NULL) {\n    libproc_cookie = cookie;\n    return LA_FLG_BINDFROM;\n  }\n  if (strstr(lmp->l_name, \"/libc.so\") != NULL) {\n    libc_cookie = cookie;\n    return LA_FLG_BINDTO;\n  }\n  if (strstr(lmp->l_name, \"/libsaproc.so\") != NULL) {\n    libsaproc_cookie = cookie;\n    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n  }\n  return 0;\n}\n\n\n#if     defined(_LP64)\nuintptr_t\nla_symbind64(Elf64_Sym *symp, uint_t symndx, uintptr_t *refcook,\n             uintptr_t *defcook, uint_t *sb_flags, const char *sym_name)\n#else\nuintptr_t\nla_symbind32(Elf32_Sym *symp, uint_t symndx, uintptr_t *refcook,\n             uintptr_t *defcook, uint_t *sb_flags)\n#endif\n{\n#if     !defined(_LP64)\n  const char      *sym_name = (const char *)symp->st_name;\n#endif\n  if (strcmp(sym_name, \"open\") == 0 && refcook == libproc_cookie) {\n    // redirect all open calls from libproc.so through libsaproc_open which will\n    // try the alternate library locations first.\n    void* handle = dlmopen(LM_ID_BASE, \"libsaproc.so\", RTLD_NOLOAD);\n    if (handle == NULL) {\n      fprintf(stderr, \"libsaproc_audit.so: didn't find libsaproc.so during linking\\n\");\n    } else {\n      uintptr_t libsaproc_open = (uintptr_t)dlsym(handle, \"libsaproc_open\");\n      if (libsaproc_open == 0) {\n        fprintf(stderr, \"libsaproc_audit.so: didn't find libsaproc_open during linking\\n\");\n      } else {\n        return libsaproc_open;\n      }\n    }\n  }\n  return symp->st_value;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os_cpu/solaris_x86/vm/os_solaris_x86.cpp": "/*\n * Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n// no precompiled headers\n#include \"asm/macroAssembler.hpp\"\n#include \"classfile/classLoader.hpp\"\n#include \"classfile/systemDictionary.hpp\"\n#include \"classfile/vmSymbols.hpp\"\n#include \"code/icBuffer.hpp\"\n#include \"code/vtableStubs.hpp\"\n#include \"interpreter/interpreter.hpp\"\n#include \"jvm_solaris.h\"\n#include \"memory/allocation.inline.hpp\"\n#include \"mutex_solaris.inline.hpp\"\n#include \"os_share_solaris.hpp\"\n#include \"prims/jniFastGetField.hpp\"\n#include \"prims/jvm.h\"\n#include \"prims/jvm_misc.hpp\"\n#include \"runtime/arguments.hpp\"\n#include \"runtime/extendedPC.hpp\"\n#include \"runtime/frame.inline.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/java.hpp\"\n#include \"runtime/javaCalls.hpp\"\n#include \"runtime/mutexLocker.hpp\"\n#include \"runtime/osThread.hpp\"\n#include \"runtime/sharedRuntime.hpp\"\n#include \"runtime/stubRoutines.hpp\"\n#include \"runtime/thread.inline.hpp\"\n#include \"runtime/timer.hpp\"\n#include \"utilities/events.hpp\"\n#include \"utilities/vmError.hpp\"\n\n// put OS-includes here\n# include <sys/types.h>\n# include <sys/mman.h>\n# include <pthread.h>\n# include <signal.h>\n# include <setjmp.h>\n# include <errno.h>\n# include <dlfcn.h>\n# include <stdio.h>\n# include <unistd.h>\n# include <sys/resource.h>\n# include <thread.h>\n# include <sys/stat.h>\n# include <sys/time.h>\n# include <sys/filio.h>\n# include <sys/utsname.h>\n# include <sys/systeminfo.h>\n# include <sys/socket.h>\n# include <sys/trap.h>\n# include <sys/lwp.h>\n# include <pwd.h>\n# include <poll.h>\n# include <sys/lwp.h>\n# include <procfs.h>     //  see comment in <sys/procfs.h>\n\n#ifndef AMD64\n// QQQ seems useless at this point\n# define _STRUCTURED_PROC 1  //  this gets us the new structured proc interfaces of 5.6 & later\n#endif // AMD64\n# include <sys/procfs.h>     //  see comment in <sys/procfs.h>\n\n\n#define MAX_PATH (2 * K)\n\n// Minimum stack size for the VM.  It's easier to document a constant value\n// but it's different for x86 and sparc because the page sizes are different.\n#ifdef AMD64\nsize_t os::Solaris::min_stack_allowed = 224*K;\n#define REG_SP REG_RSP\n#define REG_PC REG_RIP\n#define REG_FP REG_RBP\n#else\nsize_t os::Solaris::min_stack_allowed = 64*K;\n#define REG_SP UESP\n#define REG_PC EIP\n#define REG_FP EBP\n// 4900493 counter to prevent runaway LDTR refresh attempt\n\nstatic volatile int ldtr_refresh = 0;\n// the libthread instruction that faults because of the stale LDTR\n\nstatic const unsigned char movlfs[] = { 0x8e, 0xe0    // movl %eax,%fs\n                       };\n#endif // AMD64\n\nchar* os::non_memory_address_word() {\n  // Must never look like an address returned by reserve_memory,\n  // even in its subfields (as defined by the CPU immediate fields,\n  // if the CPU splits constants across multiple instructions).\n  return (char*) -1;\n}\n\n//\n// Validate a ucontext retrieved from walking a uc_link of a ucontext.\n// There are issues with libthread giving out uc_links for different threads\n// on the same uc_link chain and bad or circular links.\n//\nbool os::Solaris::valid_ucontext(Thread* thread, ucontext_t* valid, ucontext_t* suspect) {\n  if (valid >= suspect ||\n      valid->uc_stack.ss_flags != suspect->uc_stack.ss_flags ||\n      valid->uc_stack.ss_sp    != suspect->uc_stack.ss_sp    ||\n      valid->uc_stack.ss_size  != suspect->uc_stack.ss_size) {\n    DEBUG_ONLY(tty->print_cr(\"valid_ucontext: failed test 1\");)\n    return false;\n  }\n\n  if (thread->is_Java_thread()) {\n    if (!valid_stack_address(thread, (address)suspect)) {\n      DEBUG_ONLY(tty->print_cr(\"valid_ucontext: uc_link not in thread stack\");)\n      return false;\n    }\n    if (!valid_stack_address(thread,  (address) suspect->uc_mcontext.gregs[REG_SP])) {\n      DEBUG_ONLY(tty->print_cr(\"valid_ucontext: stackpointer not in thread stack\");)\n      return false;\n    }\n  }\n  return true;\n}\n\n// We will only follow one level of uc_link since there are libthread\n// issues with ucontext linking and it is better to be safe and just\n// let caller retry later.\nucontext_t* os::Solaris::get_valid_uc_in_signal_handler(Thread *thread,\n  ucontext_t *uc) {\n\n  ucontext_t *retuc = NULL;\n\n  if (uc != NULL) {\n    if (uc->uc_link == NULL) {\n      // cannot validate without uc_link so accept current ucontext\n      retuc = uc;\n    } else if (os::Solaris::valid_ucontext(thread, uc, uc->uc_link)) {\n      // first ucontext is valid so try the next one\n      uc = uc->uc_link;\n      if (uc->uc_link == NULL) {\n        // cannot validate without uc_link so accept current ucontext\n        retuc = uc;\n      } else if (os::Solaris::valid_ucontext(thread, uc, uc->uc_link)) {\n        // the ucontext one level down is also valid so return it\n        retuc = uc;\n      }\n    }\n  }\n  return retuc;\n}\n\n// Assumes ucontext is valid\nExtendedPC os::Solaris::ucontext_get_ExtendedPC(ucontext_t *uc) {\n  return ExtendedPC((address)uc->uc_mcontext.gregs[REG_PC]);\n}\n\n// Assumes ucontext is valid\nintptr_t* os::Solaris::ucontext_get_sp(ucontext_t *uc) {\n  return (intptr_t*)uc->uc_mcontext.gregs[REG_SP];\n}\n\n// Assumes ucontext is valid\nintptr_t* os::Solaris::ucontext_get_fp(ucontext_t *uc) {\n  return (intptr_t*)uc->uc_mcontext.gregs[REG_FP];\n}\n\naddress os::Solaris::ucontext_get_pc(ucontext_t *uc) {\n  return (address) uc->uc_mcontext.gregs[REG_PC];\n}\n\n// For Forte Analyzer AsyncGetCallTrace profiling support - thread\n// is currently interrupted by SIGPROF.\n//\n// The difference between this and os::fetch_frame_from_context() is that\n// here we try to skip nested signal frames.\nExtendedPC os::Solaris::fetch_frame_from_ucontext(Thread* thread,\n  ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {\n\n  assert(thread != NULL, \"just checking\");\n  assert(ret_sp != NULL, \"just checking\");\n  assert(ret_fp != NULL, \"just checking\");\n\n  ucontext_t *luc = os::Solaris::get_valid_uc_in_signal_handler(thread, uc);\n  return os::fetch_frame_from_context(luc, ret_sp, ret_fp);\n}\n\nExtendedPC os::fetch_frame_from_context(void* ucVoid,\n                    intptr_t** ret_sp, intptr_t** ret_fp) {\n\n  ExtendedPC  epc;\n  ucontext_t *uc = (ucontext_t*)ucVoid;\n\n  if (uc != NULL) {\n    epc = os::Solaris::ucontext_get_ExtendedPC(uc);\n    if (ret_sp) *ret_sp = os::Solaris::ucontext_get_sp(uc);\n    if (ret_fp) *ret_fp = os::Solaris::ucontext_get_fp(uc);\n  } else {\n    // construct empty ExtendedPC for return value checking\n    epc = ExtendedPC(NULL);\n    if (ret_sp) *ret_sp = (intptr_t *)NULL;\n    if (ret_fp) *ret_fp = (intptr_t *)NULL;\n  }\n\n  return epc;\n}\n\nframe os::fetch_frame_from_context(void* ucVoid) {\n  intptr_t* sp;\n  intptr_t* fp;\n  ExtendedPC epc = fetch_frame_from_context(ucVoid, &sp, &fp);\n  return frame(sp, fp, epc.pc());\n}\n\nframe os::get_sender_for_C_frame(frame* fr) {\n  return frame(fr->sender_sp(), fr->link(), fr->sender_pc());\n}\n\nextern \"C\" intptr_t *_get_current_sp();  // in .il file\n\naddress os::current_stack_pointer() {\n  return (address)_get_current_sp();\n}\n\nextern \"C\" intptr_t *_get_current_fp();  // in .il file\n\nframe os::current_frame() {\n  intptr_t* fp = _get_current_fp();  // it's inlined so want current fp\n  frame myframe((intptr_t*)os::current_stack_pointer(),\n                (intptr_t*)fp,\n                CAST_FROM_FN_PTR(address, os::current_frame));\n  if (os::is_first_C_frame(&myframe)) {\n    // stack is not walkable\n    frame ret; // This will be a null useless frame\n    return ret;\n  } else {\n    return os::get_sender_for_C_frame(&myframe);\n  }\n}\n\nstatic int threadgetstate(thread_t tid, int *flags, lwpid_t *lwp, stack_t *ss, gregset_t rs, lwpstatus_t *lwpstatus) {\n  char lwpstatusfile[PROCFILE_LENGTH];\n  int lwpfd, err;\n\n  if (err = os::Solaris::thr_getstate(tid, flags, lwp, ss, rs))\n    return (err);\n  if (*flags == TRS_LWPID) {\n    sprintf(lwpstatusfile, \"/proc/%d/lwp/%d/lwpstatus\", getpid(),\n            *lwp);\n    if ((lwpfd = open(lwpstatusfile, O_RDONLY)) < 0) {\n      perror(\"thr_mutator_status: open lwpstatus\");\n      return (EINVAL);\n    }\n    if (pread(lwpfd, lwpstatus, sizeof (lwpstatus_t), (off_t)0) !=\n        sizeof (lwpstatus_t)) {\n      perror(\"thr_mutator_status: read lwpstatus\");\n      (void) close(lwpfd);\n      return (EINVAL);\n    }\n    (void) close(lwpfd);\n  }\n  return (0);\n}\n\n#ifndef AMD64\n\n// Detecting SSE support by OS\n// From solaris_i486.s\nextern \"C\" bool sse_check();\nextern \"C\" bool sse_unavailable();\n\nenum { SSE_UNKNOWN, SSE_NOT_SUPPORTED, SSE_SUPPORTED};\nstatic int sse_status = SSE_UNKNOWN;\n\n\nstatic void  check_for_sse_support() {\n  if (!VM_Version::supports_sse()) {\n    sse_status = SSE_NOT_SUPPORTED;\n    return;\n  }\n  // looking for _sse_hw in libc.so, if it does not exist or\n  // the value (int) is 0, OS has no support for SSE\n  int *sse_hwp;\n  void *h;\n\n  if ((h=dlopen(\"/usr/lib/libc.so\", RTLD_LAZY)) == NULL) {\n    //open failed, presume no support for SSE\n    sse_status = SSE_NOT_SUPPORTED;\n    return;\n  }\n  if ((sse_hwp = (int *)dlsym(h, \"_sse_hw\")) == NULL) {\n    sse_status = SSE_NOT_SUPPORTED;\n  } else if (*sse_hwp == 0) {\n    sse_status = SSE_NOT_SUPPORTED;\n  }\n  dlclose(h);\n\n  if (sse_status == SSE_UNKNOWN) {\n    bool (*try_sse)() = (bool (*)())sse_check;\n    sse_status = (*try_sse)() ? SSE_SUPPORTED : SSE_NOT_SUPPORTED;\n  }\n\n}\n\n#endif // AMD64\n\nbool os::supports_sse() {\n#ifdef AMD64\n  return true;\n#else\n  if (sse_status == SSE_UNKNOWN)\n    check_for_sse_support();\n  return sse_status == SSE_SUPPORTED;\n#endif // AMD64\n}\n\nbool os::is_allocatable(size_t bytes) {\n#ifdef AMD64\n  return true;\n#else\n\n  if (bytes < 2 * G) {\n    return true;\n  }\n\n  char* addr = reserve_memory(bytes, NULL);\n\n  if (addr != NULL) {\n    release_memory(addr, bytes);\n  }\n\n  return addr != NULL;\n#endif // AMD64\n\n}\n\nextern \"C\" JNIEXPORT int\nJVM_handle_solaris_signal(int sig, siginfo_t* info, void* ucVoid,\n                          int abort_if_unrecognized) {\n  ucontext_t* uc = (ucontext_t*) ucVoid;\n\n#ifndef AMD64\n  if (sig == SIGILL && info->si_addr == (caddr_t)sse_check) {\n    // the SSE instruction faulted. supports_sse() need return false.\n    uc->uc_mcontext.gregs[EIP] = (greg_t)sse_unavailable;\n    return true;\n  }\n#endif // !AMD64\n\n  Thread* t = ThreadLocalStorage::get_thread_slow();  // slow & steady\n\n  // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away\n  // (no destructors can be run)\n  os::WatcherThreadCrashProtection::check_crash_protection(sig, t);\n\n  SignalHandlerMark shm(t);\n\n  if(sig == SIGPIPE || sig == SIGXFSZ) {\n    if (os::Solaris::chained_handler(sig, info, ucVoid)) {\n      return true;\n    } else {\n      if (PrintMiscellaneous && (WizardMode || Verbose)) {\n        char buf[64];\n        warning(\"Ignoring %s - see 4229104 or 6499219\",\n                os::exception_name(sig, buf, sizeof(buf)));\n\n      }\n      return true;\n    }\n  }\n\n  JavaThread* thread = NULL;\n  VMThread* vmthread = NULL;\n\n  if (os::Solaris::signal_handlers_are_installed) {\n    if (t != NULL ){\n      if(t->is_Java_thread()) {\n        thread = (JavaThread*)t;\n      }\n      else if(t->is_VM_thread()){\n        vmthread = (VMThread *)t;\n      }\n    }\n  }\n\n  guarantee(sig != os::Solaris::SIGinterrupt(), \"Can not chain VM interrupt signal, try -XX:+UseAltSigs\");\n\n  if (sig == os::Solaris::SIGasync()) {\n    if(thread || vmthread){\n      OSThread::SR_handler(t, uc);\n      return true;\n    } else if (os::Solaris::chained_handler(sig, info, ucVoid)) {\n      return true;\n    } else {\n      // If os::Solaris::SIGasync not chained, and this is a non-vm and\n      // non-java thread\n      return true;\n    }\n  }\n\n  if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {\n    // can't decode this kind of signal\n    info = NULL;\n  } else {\n    assert(sig == info->si_signo, \"bad siginfo\");\n  }\n\n  // decide if this trap can be handled by a stub\n  address stub = NULL;\n\n  address pc          = NULL;\n\n  //%note os_trap_1\n  if (info != NULL && uc != NULL && thread != NULL) {\n    // factor me: getPCfromContext\n    pc = (address) uc->uc_mcontext.gregs[REG_PC];\n\n    if (StubRoutines::is_safefetch_fault(pc)) {\n      uc->uc_mcontext.gregs[REG_PC] = intptr_t(StubRoutines::continuation_for_safefetch_fault(pc));\n      return true;\n    }\n\n    // Handle ALL stack overflow variations here\n    if (sig == SIGSEGV && info->si_code == SEGV_ACCERR) {\n      address addr = (address) info->si_addr;\n      if (thread->in_stack_yellow_zone(addr)) {\n        thread->disable_stack_yellow_zone();\n        if (thread->thread_state() == _thread_in_Java) {\n          // Throw a stack overflow exception.  Guard pages will be reenabled\n          // while unwinding the stack.\n          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n        } else {\n          // Thread was in the vm or native code.  Return and try to finish.\n          return true;\n        }\n      } else if (thread->in_stack_red_zone(addr)) {\n        // Fatal red zone violation.  Disable the guard pages and fall through\n        // to handle_unexpected_exception way down below.\n        thread->disable_stack_red_zone();\n        tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n      }\n    }\n\n    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n      // Verify that OS save/restore AVX registers.\n      stub = VM_Version::cpuinfo_cont_addr();\n    }\n\n    if (thread->thread_state() == _thread_in_vm) {\n      if (sig == SIGBUS && info->si_code == BUS_OBJERR && thread->doing_unsafe_access()) {\n        stub = StubRoutines::handler_for_unsafe_access();\n      }\n    }\n\n    if (thread->thread_state() == _thread_in_Java) {\n      // Support Safepoint Polling\n      if ( sig == SIGSEGV && os::is_poll_address((address)info->si_addr)) {\n        stub = SharedRuntime::get_poll_stub(pc);\n      }\n      else if (sig == SIGBUS && info->si_code == BUS_OBJERR) {\n        // BugId 4454115: A read from a MappedByteBuffer can fault\n        // here if the underlying file has been truncated.\n        // Do not crash the VM in such a case.\n        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);\n        if (cb != NULL) {\n          nmethod* nm = cb->is_nmethod() ? (nmethod*)cb : NULL;\n          if (nm != NULL && nm->has_unsafe_access()) {\n            stub = StubRoutines::handler_for_unsafe_access();\n          }\n        }\n      }\n      else\n      if (sig == SIGFPE && info->si_code == FPE_INTDIV) {\n        // integer divide by zero\n        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);\n      }\n#ifndef AMD64\n      else if (sig == SIGFPE && info->si_code == FPE_FLTDIV) {\n        // floating-point divide by zero\n        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);\n      }\n      else if (sig == SIGFPE && info->si_code == FPE_FLTINV) {\n        // The encoding of D2I in i486.ad can cause an exception prior\n        // to the fist instruction if there was an invalid operation\n        // pending. We want to dismiss that exception. From the win_32\n        // side it also seems that if it really was the fist causing\n        // the exception that we do the d2i by hand with different\n        // rounding. Seems kind of weird. QQQ TODO\n        // Note that we take the exception at the NEXT floating point instruction.\n        if (pc[0] == 0xDB) {\n            assert(pc[0] == 0xDB, \"not a FIST opcode\");\n            assert(pc[1] == 0x14, \"not a FIST opcode\");\n            assert(pc[2] == 0x24, \"not a FIST opcode\");\n            return true;\n        } else {\n            assert(pc[-3] == 0xDB, \"not an flt invalid opcode\");\n            assert(pc[-2] == 0x14, \"not an flt invalid opcode\");\n            assert(pc[-1] == 0x24, \"not an flt invalid opcode\");\n        }\n      }\n      else if (sig == SIGFPE ) {\n        tty->print_cr(\"caught SIGFPE, info 0x%x.\", info->si_code);\n      }\n#endif // !AMD64\n\n        // QQQ It doesn't seem that we need to do this on x86 because we should be able\n        // to return properly from the handler without this extra stuff on the back side.\n\n      else if (sig == SIGSEGV && info->si_code > 0 && !MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {\n        // Determination of interpreter/vtable stub/compiled code null exception\n        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);\n      }\n    }\n\n    // jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in\n    // and the heap gets shrunk before the field access.\n    if ((sig == SIGSEGV) || (sig == SIGBUS)) {\n      address addr = JNI_FastGetField::find_slowcase_pc(pc);\n      if (addr != (address)-1) {\n        stub = addr;\n      }\n    }\n\n    // Check to see if we caught the safepoint code in the\n    // process of write protecting the memory serialization page.\n    // It write enables the page immediately after protecting it\n    // so we can just return to retry the write.\n    if ((sig == SIGSEGV) &&\n        os::is_memory_serialize_page(thread, (address)info->si_addr)) {\n      // Block current thread until the memory serialize page permission restored.\n      os::block_on_serialize_page_trap();\n      return true;\n    }\n  }\n\n  // Execution protection violation\n  //\n  // Preventative code for future versions of Solaris which may\n  // enable execution protection when running the 32-bit VM on AMD64.\n  //\n  // This should be kept as the last step in the triage.  We don't\n  // have a dedicated trap number for a no-execute fault, so be\n  // conservative and allow other handlers the first shot.\n  //\n  // Note: We don't test that info->si_code == SEGV_ACCERR here.\n  // this si_code is so generic that it is almost meaningless; and\n  // the si_code for this condition may change in the future.\n  // Furthermore, a false-positive should be harmless.\n  if (UnguardOnExecutionViolation > 0 &&\n      (sig == SIGSEGV || sig == SIGBUS) &&\n      uc->uc_mcontext.gregs[TRAPNO] == T_PGFLT) {  // page fault\n    int page_size = os::vm_page_size();\n    address addr = (address) info->si_addr;\n    address pc = (address) uc->uc_mcontext.gregs[REG_PC];\n    // Make sure the pc and the faulting address are sane.\n    //\n    // If an instruction spans a page boundary, and the page containing\n    // the beginning of the instruction is executable but the following\n    // page is not, the pc and the faulting address might be slightly\n    // different - we still want to unguard the 2nd page in this case.\n    //\n    // 15 bytes seems to be a (very) safe value for max instruction size.\n    bool pc_is_near_addr =\n      (pointer_delta((void*) addr, (void*) pc, sizeof(char)) < 15);\n    bool instr_spans_page_boundary =\n      (align_size_down((intptr_t) pc ^ (intptr_t) addr,\n                       (intptr_t) page_size) > 0);\n\n    if (pc == addr || (pc_is_near_addr && instr_spans_page_boundary)) {\n      static volatile address last_addr =\n        (address) os::non_memory_address_word();\n\n      // In conservative mode, don't unguard unless the address is in the VM\n      if (addr != last_addr &&\n          (UnguardOnExecutionViolation > 1 || os::address_is_in_vm(addr))) {\n\n        // Make memory rwx and retry\n        address page_start =\n          (address) align_size_down((intptr_t) addr, (intptr_t) page_size);\n        bool res = os::protect_memory((char*) page_start, page_size,\n                                      os::MEM_PROT_RWX);\n\n        if (PrintMiscellaneous && Verbose) {\n          char buf[256];\n          jio_snprintf(buf, sizeof(buf), \"Execution protection violation \"\n                       \"at \" INTPTR_FORMAT\n                       \", unguarding \" INTPTR_FORMAT \": %s, errno=%d\", addr,\n                       page_start, (res ? \"success\" : \"failed\"), errno);\n          tty->print_raw_cr(buf);\n        }\n        stub = pc;\n\n        // Set last_addr so if we fault again at the same address, we don't end\n        // up in an endless loop.\n        //\n        // There are two potential complications here.  Two threads trapping at\n        // the same address at the same time could cause one of the threads to\n        // think it already unguarded, and abort the VM.  Likely very rare.\n        //\n        // The other race involves two threads alternately trapping at\n        // different addresses and failing to unguard the page, resulting in\n        // an endless loop.  This condition is probably even more unlikely than\n        // the first.\n        //\n        // Although both cases could be avoided by using locks or thread local\n        // last_addr, these solutions are unnecessary complication: this\n        // handler is a best-effort safety net, not a complete solution.  It is\n        // disabled by default and should only be used as a workaround in case\n        // we missed any no-execute-unsafe VM code.\n\n        last_addr = addr;\n      }\n    }\n  }\n\n  if (stub != NULL) {\n    // save all thread context in case we need to restore it\n\n    if (thread != NULL) thread->set_saved_exception_pc(pc);\n    // 12/02/99: On Sparc it appears that the full context is also saved\n    // but as yet, no one looks at or restores that saved context\n    // factor me: setPC\n    uc->uc_mcontext.gregs[REG_PC] = (greg_t)stub;\n    return true;\n  }\n\n  // signal-chaining\n  if (os::Solaris::chained_handler(sig, info, ucVoid)) {\n    return true;\n  }\n\n#ifndef AMD64\n  // Workaround (bug 4900493) for Solaris kernel bug 4966651.\n  // Handle an undefined selector caused by an attempt to assign\n  // fs in libthread getipriptr(). With the current libthread design every 512\n  // thread creations the LDT for a private thread data structure is extended\n  // and thre is a hazard that and another thread attempting a thread creation\n  // will use a stale LDTR that doesn't reflect the structure's growth,\n  // causing a GP fault.\n  // Enforce the probable limit of passes through here to guard against an\n  // infinite loop if some other move to fs caused the GP fault. Note that\n  // this loop counter is ultimately a heuristic as it is possible for\n  // more than one thread to generate this fault at a time in an MP system.\n  // In the case of the loop count being exceeded or if the poll fails\n  // just fall through to a fatal error.\n  // If there is some other source of T_GPFLT traps and the text at EIP is\n  // unreadable this code will loop infinitely until the stack is exausted.\n  // The key to diagnosis in this case is to look for the bottom signal handler\n  // frame.\n\n  if(! IgnoreLibthreadGPFault) {\n    if (sig == SIGSEGV && uc->uc_mcontext.gregs[TRAPNO] == T_GPFLT) {\n      const unsigned char *p =\n                        (unsigned const char *) uc->uc_mcontext.gregs[EIP];\n\n      // Expected instruction?\n\n      if(p[0] == movlfs[0] && p[1] == movlfs[1]) {\n\n        Atomic::inc(&ldtr_refresh);\n\n        // Infinite loop?\n\n        if(ldtr_refresh < ((2 << 16) / PAGESIZE)) {\n\n          // No, force scheduling to get a fresh view of the LDTR\n\n          if(poll(NULL, 0, 10) == 0) {\n\n            // Retry the move\n\n            return false;\n          }\n        }\n      }\n    }\n  }\n#endif // !AMD64\n\n  if (!abort_if_unrecognized) {\n    // caller wants another chance, so give it to him\n    return false;\n  }\n\n  if (!os::Solaris::libjsig_is_loaded) {\n    struct sigaction oldAct;\n    sigaction(sig, (struct sigaction *)0, &oldAct);\n    if (oldAct.sa_sigaction != signalHandler) {\n      void* sighand = oldAct.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n                                          : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n      warning(\"Unexpected Signal %d occurred under user-defined signal handler %#lx\", sig, (long)sighand);\n    }\n  }\n\n  if (pc == NULL && uc != NULL) {\n    pc = (address) uc->uc_mcontext.gregs[REG_PC];\n  }\n\n  // unmask current signal\n  sigset_t newset;\n  sigemptyset(&newset);\n  sigaddset(&newset, sig);\n  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n\n  // Determine which sort of error to throw.  Out of swap may signal\n  // on the thread stack, which could get a mapping error when touched.\n  address addr = (address) info->si_addr;\n  if (sig == SIGBUS && info->si_code == BUS_OBJERR && info->si_errno == ENOMEM) {\n    vm_exit_out_of_memory(0, OOM_MMAP_ERROR, \"Out of swap space to map in thread stack.\");\n  }\n\n  VMError err(t, sig, pc, info, ucVoid);\n  err.report_and_die();\n\n  ShouldNotReachHere();\n  return false;\n}\n\nvoid os::print_context(outputStream *st, void *context) {\n  if (context == NULL) return;\n\n  ucontext_t *uc = (ucontext_t*)context;\n  st->print_cr(\"Registers:\");\n#ifdef AMD64\n  st->print(  \"RAX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RAX]);\n  st->print(\", RBX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBX]);\n  st->print(\", RCX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RCX]);\n  st->print(\", RDX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDX]);\n  st->cr();\n  st->print(  \"RSP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSP]);\n  st->print(\", RBP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBP]);\n  st->print(\", RSI=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSI]);\n  st->print(\", RDI=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDI]);\n  st->cr();\n  st->print(  \"R8 =\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R8]);\n  st->print(\", R9 =\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R9]);\n  st->print(\", R10=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R10]);\n  st->print(\", R11=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R11]);\n  st->cr();\n  st->print(  \"R12=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R12]);\n  st->print(\", R13=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R13]);\n  st->print(\", R14=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R14]);\n  st->print(\", R15=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R15]);\n  st->cr();\n  st->print(  \"RIP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RIP]);\n  st->print(\", RFLAGS=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RFL]);\n#else\n  st->print(  \"EAX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EAX]);\n  st->print(\", EBX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EBX]);\n  st->print(\", ECX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[ECX]);\n  st->print(\", EDX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EDX]);\n  st->cr();\n  st->print(  \"ESP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[UESP]);\n  st->print(\", EBP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EBP]);\n  st->print(\", ESI=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[ESI]);\n  st->print(\", EDI=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EDI]);\n  st->cr();\n  st->print(  \"EIP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EIP]);\n  st->print(\", EFLAGS=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[EFL]);\n#endif // AMD64\n  st->cr();\n  st->cr();\n\n  intptr_t *sp = (intptr_t *)os::Solaris::ucontext_get_sp(uc);\n  st->print_cr(\"Top of Stack: (sp=\" PTR_FORMAT \")\", sp);\n  print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));\n  st->cr();\n\n  // Note: it may be unsafe to inspect memory near pc. For example, pc may\n  // point to garbage if entry point in an nmethod is corrupted. Leave\n  // this at the end, and hope for the best.\n  ExtendedPC epc = os::Solaris::ucontext_get_ExtendedPC(uc);\n  address pc = epc.pc();\n  st->print_cr(\"Instructions: (pc=\" PTR_FORMAT \")\", pc);\n  print_hex_dump(st, pc - 32, pc + 32, sizeof(char));\n}\n\nvoid os::print_register_info(outputStream *st, void *context) {\n  if (context == NULL) return;\n\n  ucontext_t *uc = (ucontext_t*)context;\n\n  st->print_cr(\"Register to memory mapping:\");\n  st->cr();\n\n  // this is horrendously verbose but the layout of the registers in the\n  // context does not match how we defined our abstract Register set, so\n  // we can't just iterate through the gregs area\n\n  // this is only for the \"general purpose\" registers\n\n#ifdef AMD64\n  st->print(\"RAX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RAX]);\n  st->print(\"RBX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RBX]);\n  st->print(\"RCX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RCX]);\n  st->print(\"RDX=\"); print_location(st, uc->uc_mcontext.gregs[REG_RDX]);\n  st->print(\"RSP=\"); print_location(st, uc->uc_mcontext.gregs[REG_RSP]);\n  st->print(\"RBP=\"); print_location(st, uc->uc_mcontext.gregs[REG_RBP]);\n  st->print(\"RSI=\"); print_location(st, uc->uc_mcontext.gregs[REG_RSI]);\n  st->print(\"RDI=\"); print_location(st, uc->uc_mcontext.gregs[REG_RDI]);\n  st->print(\"R8 =\"); print_location(st, uc->uc_mcontext.gregs[REG_R8]);\n  st->print(\"R9 =\"); print_location(st, uc->uc_mcontext.gregs[REG_R9]);\n  st->print(\"R10=\"); print_location(st, uc->uc_mcontext.gregs[REG_R10]);\n  st->print(\"R11=\"); print_location(st, uc->uc_mcontext.gregs[REG_R11]);\n  st->print(\"R12=\"); print_location(st, uc->uc_mcontext.gregs[REG_R12]);\n  st->print(\"R13=\"); print_location(st, uc->uc_mcontext.gregs[REG_R13]);\n  st->print(\"R14=\"); print_location(st, uc->uc_mcontext.gregs[REG_R14]);\n  st->print(\"R15=\"); print_location(st, uc->uc_mcontext.gregs[REG_R15]);\n#else\n  st->print(\"EAX=\"); print_location(st, uc->uc_mcontext.gregs[EAX]);\n  st->print(\"EBX=\"); print_location(st, uc->uc_mcontext.gregs[EBX]);\n  st->print(\"ECX=\"); print_location(st, uc->uc_mcontext.gregs[ECX]);\n  st->print(\"EDX=\"); print_location(st, uc->uc_mcontext.gregs[EDX]);\n  st->print(\"ESP=\"); print_location(st, uc->uc_mcontext.gregs[UESP]);\n  st->print(\"EBP=\"); print_location(st, uc->uc_mcontext.gregs[EBP]);\n  st->print(\"ESI=\"); print_location(st, uc->uc_mcontext.gregs[ESI]);\n  st->print(\"EDI=\"); print_location(st, uc->uc_mcontext.gregs[EDI]);\n#endif\n\n  st->cr();\n}\n\n\n#ifdef AMD64\nvoid os::Solaris::init_thread_fpu_state(void) {\n  // Nothing to do\n}\n#else\n// From solaris_i486.s\nextern \"C\" void fixcw();\n\nvoid os::Solaris::init_thread_fpu_state(void) {\n  // Set fpu to 53 bit precision. This happens too early to use a stub.\n  fixcw();\n}\n\n// These routines are the initial value of atomic_xchg_entry(),\n// atomic_cmpxchg_entry(), atomic_inc_entry() and fence_entry()\n// until initialization is complete.\n// TODO - replace with .il implementation when compiler supports it.\n\ntypedef jint  xchg_func_t        (jint,  volatile jint*);\ntypedef jint  cmpxchg_func_t     (jint,  volatile jint*,  jint);\ntypedef jlong cmpxchg_long_func_t(jlong, volatile jlong*, jlong);\ntypedef jint  add_func_t         (jint,  volatile jint*);\n\njint os::atomic_xchg_bootstrap(jint exchange_value, volatile jint* dest) {\n  // try to use the stub:\n  xchg_func_t* func = CAST_TO_FN_PTR(xchg_func_t*, StubRoutines::atomic_xchg_entry());\n\n  if (func != NULL) {\n    os::atomic_xchg_func = func;\n    return (*func)(exchange_value, dest);\n  }\n  assert(Threads::number_of_threads() == 0, \"for bootstrap only\");\n\n  jint old_value = *dest;\n  *dest = exchange_value;\n  return old_value;\n}\n\njint os::atomic_cmpxchg_bootstrap(jint exchange_value, volatile jint* dest, jint compare_value) {\n  // try to use the stub:\n  cmpxchg_func_t* func = CAST_TO_FN_PTR(cmpxchg_func_t*, StubRoutines::atomic_cmpxchg_entry());\n\n  if (func != NULL) {\n    os::atomic_cmpxchg_func = func;\n    return (*func)(exchange_value, dest, compare_value);\n  }\n  assert(Threads::number_of_threads() == 0, \"for bootstrap only\");\n\n  jint old_value = *dest;\n  if (old_value == compare_value)\n    *dest = exchange_value;\n  return old_value;\n}\n\njlong os::atomic_cmpxchg_long_bootstrap(jlong exchange_value, volatile jlong* dest, jlong compare_value) {\n  // try to use the stub:\n  cmpxchg_long_func_t* func = CAST_TO_FN_PTR(cmpxchg_long_func_t*, StubRoutines::atomic_cmpxchg_long_entry());\n\n  if (func != NULL) {\n    os::atomic_cmpxchg_long_func = func;\n    return (*func)(exchange_value, dest, compare_value);\n  }\n  assert(Threads::number_of_threads() == 0, \"for bootstrap only\");\n\n  jlong old_value = *dest;\n  if (old_value == compare_value)\n    *dest = exchange_value;\n  return old_value;\n}\n\njint os::atomic_add_bootstrap(jint add_value, volatile jint* dest) {\n  // try to use the stub:\n  add_func_t* func = CAST_TO_FN_PTR(add_func_t*, StubRoutines::atomic_add_entry());\n\n  if (func != NULL) {\n    os::atomic_add_func = func;\n    return (*func)(add_value, dest);\n  }\n  assert(Threads::number_of_threads() == 0, \"for bootstrap only\");\n\n  return (*dest) += add_value;\n}\n\nxchg_func_t*         os::atomic_xchg_func         = os::atomic_xchg_bootstrap;\ncmpxchg_func_t*      os::atomic_cmpxchg_func      = os::atomic_cmpxchg_bootstrap;\ncmpxchg_long_func_t* os::atomic_cmpxchg_long_func = os::atomic_cmpxchg_long_bootstrap;\nadd_func_t*          os::atomic_add_func          = os::atomic_add_bootstrap;\n\nextern \"C\" void _solaris_raw_setup_fpu(address ptr);\nvoid os::setup_fpu() {\n  address fpu_cntrl = StubRoutines::addr_fpu_cntrl_wrd_std();\n  _solaris_raw_setup_fpu(fpu_cntrl);\n}\n#endif // AMD64\n\n#ifndef PRODUCT\nvoid os::verify_stack_alignment() {\n#ifdef AMD64\n  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n#endif\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os_cpu/solaris_sparc/vm/vm_version_solaris_sparc.cpp": "/*\n * Copyright (c) 2006, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include \"precompiled.hpp\"\n#include \"runtime/os.hpp\"\n#include \"vm_version_sparc.hpp\"\n\n#include <sys/auxv.h>\n#include <sys/auxv_SPARC.h>\n#include <sys/systeminfo.h>\n#include <kstat.h>\n#include <picl.h>\n#include <dlfcn.h>\n#include <link.h>\n\nextern \"C\" static int PICL_visit_cpu_helper(picl_nodehdl_t nodeh, void *result);\n\n// Functions from the library we need (signatures should match those in picl.h)\nextern \"C\" {\n  typedef int (*picl_initialize_func_t)(void);\n  typedef int (*picl_shutdown_func_t)(void);\n  typedef int (*picl_get_root_func_t)(picl_nodehdl_t *nodehandle);\n  typedef int (*picl_walk_tree_by_class_func_t)(picl_nodehdl_t rooth,\n      const char *classname, void *c_args,\n      int (*callback_fn)(picl_nodehdl_t hdl, void *args));\n  typedef int (*picl_get_prop_by_name_func_t)(picl_nodehdl_t nodeh, const char *nm,\n      picl_prophdl_t *ph);\n  typedef int (*picl_get_propval_func_t)(picl_prophdl_t proph, void *valbuf, size_t sz);\n  typedef int (*picl_get_propinfo_func_t)(picl_prophdl_t proph, picl_propinfo_t *pi);\n}\n\nclass PICL {\n  // Pointers to functions in the library\n  picl_initialize_func_t _picl_initialize;\n  picl_shutdown_func_t _picl_shutdown;\n  picl_get_root_func_t _picl_get_root;\n  picl_walk_tree_by_class_func_t _picl_walk_tree_by_class;\n  picl_get_prop_by_name_func_t _picl_get_prop_by_name;\n  picl_get_propval_func_t _picl_get_propval;\n  picl_get_propinfo_func_t _picl_get_propinfo;\n  // Handle to the library that is returned by dlopen\n  void *_dl_handle;\n\n  bool open_library();\n  void close_library();\n\n  template<typename FuncType> bool bind(FuncType& func, const char* name);\n  bool bind_library_functions();\n\n  // Get a value of the integer property. The value in the tree can be either 32 or 64 bit\n  // depending on the platform. The result is converted to int.\n  int get_int_property(picl_nodehdl_t nodeh, const char* name, int* result) {\n    picl_propinfo_t pinfo;\n    picl_prophdl_t proph;\n    if (_picl_get_prop_by_name(nodeh, name, &proph) != PICL_SUCCESS ||\n        _picl_get_propinfo(proph, &pinfo) != PICL_SUCCESS) {\n      return PICL_FAILURE;\n    }\n\n    if (pinfo.type != PICL_PTYPE_INT && pinfo.type != PICL_PTYPE_UNSIGNED_INT) {\n      assert(false, \"Invalid property type\");\n      return PICL_FAILURE;\n    }\n    if (pinfo.size == sizeof(int64_t)) {\n      int64_t val;\n      if (_picl_get_propval(proph, &val, sizeof(int64_t)) != PICL_SUCCESS) {\n        return PICL_FAILURE;\n      }\n      *result = static_cast<int>(val);\n    } else if (pinfo.size == sizeof(int32_t)) {\n      int32_t val;\n      if (_picl_get_propval(proph, &val, sizeof(int32_t)) != PICL_SUCCESS) {\n        return PICL_FAILURE;\n      }\n      *result = static_cast<int>(val);\n    } else {\n      assert(false, \"Unexpected integer property size\");\n      return PICL_FAILURE;\n    }\n    return PICL_SUCCESS;\n  }\n\n  // Visitor and a state machine that visits integer properties and verifies that the\n  // values are the same. Stores the unique value observed.\n  class UniqueValueVisitor {\n    PICL *_picl;\n    enum {\n      INITIAL,        // Start state, no assignments happened\n      ASSIGNED,       // Assigned a value\n      INCONSISTENT    // Inconsistent value seen\n    } _state;\n    int _value;\n  public:\n    UniqueValueVisitor(PICL* picl) : _picl(picl), _state(INITIAL) { }\n    int value() {\n      assert(_state == ASSIGNED, \"Precondition\");\n      return _value;\n    }\n    void set_value(int value) {\n      assert(_state == INITIAL, \"Precondition\");\n      _value = value;\n      _state = ASSIGNED;\n    }\n    bool is_initial()       { return _state == INITIAL;      }\n    bool is_assigned()      { return _state == ASSIGNED;     }\n    bool is_inconsistent()  { return _state == INCONSISTENT; }\n    void set_inconsistent() { _state = INCONSISTENT;         }\n\n    bool visit(picl_nodehdl_t nodeh, const char* name) {\n      assert(!is_inconsistent(), \"Precondition\");\n      int curr;\n      if (_picl->get_int_property(nodeh, name, &curr) == PICL_SUCCESS) {\n        if (!is_assigned()) { // first iteration\n          set_value(curr);\n        } else if (curr != value()) { // following iterations\n          set_inconsistent();\n        }\n        return true;\n      }\n      return false;\n    }\n  };\n\n  class CPUVisitor {\n    UniqueValueVisitor _l1_visitor;\n    UniqueValueVisitor _l2_visitor;\n    int _limit; // number of times visit() can be run\n  public:\n    CPUVisitor(PICL *picl, int limit) : _l1_visitor(picl), _l2_visitor(picl), _limit(limit) {}\n    static int visit(picl_nodehdl_t nodeh, void *arg) {\n      CPUVisitor *cpu_visitor = static_cast<CPUVisitor*>(arg);\n      UniqueValueVisitor* l1_visitor = cpu_visitor->l1_visitor();\n      UniqueValueVisitor* l2_visitor = cpu_visitor->l2_visitor();\n      if (!l1_visitor->is_inconsistent()) {\n        l1_visitor->visit(nodeh, \"l1-dcache-line-size\");\n      }\n      static const char* l2_data_cache_line_property_name = NULL;\n      // On the first visit determine the name of the l2 cache line size property and memoize it.\n      if (l2_data_cache_line_property_name == NULL) {\n        assert(!l2_visitor->is_inconsistent(), \"First iteration cannot be inconsistent\");\n        l2_data_cache_line_property_name = \"l2-cache-line-size\";\n        if (!l2_visitor->visit(nodeh, l2_data_cache_line_property_name)) {\n          l2_data_cache_line_property_name = \"l2-dcache-line-size\";\n          l2_visitor->visit(nodeh, l2_data_cache_line_property_name);\n        }\n      } else {\n        if (!l2_visitor->is_inconsistent()) {\n          l2_visitor->visit(nodeh, l2_data_cache_line_property_name);\n        }\n      }\n\n      if (l1_visitor->is_inconsistent() && l2_visitor->is_inconsistent()) {\n        return PICL_WALK_TERMINATE;\n      }\n      cpu_visitor->_limit--;\n      if (cpu_visitor->_limit <= 0) {\n        return PICL_WALK_TERMINATE;\n      }\n      return PICL_WALK_CONTINUE;\n    }\n    UniqueValueVisitor* l1_visitor() { return &_l1_visitor; }\n    UniqueValueVisitor* l2_visitor() { return &_l2_visitor; }\n  };\n  int _L1_data_cache_line_size;\n  int _L2_data_cache_line_size;\npublic:\n  static int visit_cpu(picl_nodehdl_t nodeh, void *state) {\n    return CPUVisitor::visit(nodeh, state);\n  }\n\n  PICL(bool is_fujitsu, bool is_sun4v) : _L1_data_cache_line_size(0), _L2_data_cache_line_size(0), _dl_handle(NULL) {\n    if (!open_library()) {\n      return;\n    }\n    if (_picl_initialize() == PICL_SUCCESS) {\n      picl_nodehdl_t rooth;\n      if (_picl_get_root(&rooth) == PICL_SUCCESS) {\n        const char* cpu_class = \"cpu\";\n        // If it's a Fujitsu machine, it's a \"core\"\n        if (is_fujitsu) {\n          cpu_class = \"core\";\n        }\n        CPUVisitor cpu_visitor(this, (is_sun4v && !is_fujitsu) ? 1 : os::processor_count());\n        _picl_walk_tree_by_class(rooth, cpu_class, &cpu_visitor, PICL_visit_cpu_helper);\n        if (cpu_visitor.l1_visitor()->is_assigned()) { // Is there a value?\n          _L1_data_cache_line_size = cpu_visitor.l1_visitor()->value();\n        }\n        if (cpu_visitor.l2_visitor()->is_assigned()) {\n          _L2_data_cache_line_size = cpu_visitor.l2_visitor()->value();\n        }\n      }\n      _picl_shutdown();\n    }\n    close_library();\n  }\n\n  unsigned int L1_data_cache_line_size() const { return _L1_data_cache_line_size; }\n  unsigned int L2_data_cache_line_size() const { return _L2_data_cache_line_size; }\n};\n\n\nextern \"C\" static int PICL_visit_cpu_helper(picl_nodehdl_t nodeh, void *result) {\n  return PICL::visit_cpu(nodeh, result);\n}\n\ntemplate<typename FuncType>\nbool PICL::bind(FuncType& func, const char* name) {\n  func = reinterpret_cast<FuncType>(dlsym(_dl_handle, name));\n  return func != NULL;\n}\n\nbool PICL::bind_library_functions() {\n  assert(_dl_handle != NULL, \"library should be open\");\n  return bind(_picl_initialize,         \"picl_initialize\"        ) &&\n         bind(_picl_shutdown,           \"picl_shutdown\"          ) &&\n         bind(_picl_get_root,           \"picl_get_root\"          ) &&\n         bind(_picl_walk_tree_by_class, \"picl_walk_tree_by_class\") &&\n         bind(_picl_get_prop_by_name,   \"picl_get_prop_by_name\"  ) &&\n         bind(_picl_get_propval,        \"picl_get_propval\"       ) &&\n         bind(_picl_get_propinfo,       \"picl_get_propinfo\"      );\n}\n\nbool PICL::open_library() {\n  _dl_handle = dlopen(\"libpicl.so.1\", RTLD_LAZY);\n  if (_dl_handle == NULL) {\n    return false;\n  }\n  if (!bind_library_functions()) {\n    assert(false, \"unexpected PICL API change\");\n    close_library();\n    return false;\n  }\n  return true;\n}\n\nvoid PICL::close_library() {\n  assert(_dl_handle != NULL, \"library should be open\");\n  dlclose(_dl_handle);\n  _dl_handle = NULL;\n}\n\n// We need to keep these here as long as we have to build on Solaris\n// versions before 10.\n#ifndef SI_ARCHITECTURE_32\n#define SI_ARCHITECTURE_32      516     /* basic 32-bit SI_ARCHITECTURE */\n#endif\n\n#ifndef SI_ARCHITECTURE_64\n#define SI_ARCHITECTURE_64      517     /* basic 64-bit SI_ARCHITECTURE */\n#endif\n\nstatic void do_sysinfo(int si, const char* string, int* features, int mask) {\n  char   tmp;\n  size_t bufsize = sysinfo(si, &tmp, 1);\n\n  // All SI defines used below must be supported.\n  guarantee(bufsize != -1, \"must be supported\");\n\n  char* buf = (char*) malloc(bufsize);\n\n  if (buf == NULL)\n    return;\n\n  if (sysinfo(si, buf, bufsize) == bufsize) {\n    // Compare the string.\n    if (strcmp(buf, string) == 0) {\n      *features |= mask;\n    }\n  }\n\n  free(buf);\n}\n\nint VM_Version::platform_features(int features) {\n  // getisax(2), SI_ARCHITECTURE_32, and SI_ARCHITECTURE_64 are\n  // supported on Solaris 10 and later.\n  if (os::Solaris::supports_getisax()) {\n\n    // Check 32-bit architecture.\n    do_sysinfo(SI_ARCHITECTURE_32, \"sparc\", &features, v8_instructions_m);\n\n    // Check 64-bit architecture.\n    do_sysinfo(SI_ARCHITECTURE_64, \"sparcv9\", &features, generic_v9_m);\n\n    // Extract valid instruction set extensions.\n    uint_t avs[2];\n    uint_t avn = os::Solaris::getisax(avs, 2);\n    assert(avn <= 2, \"should return two or less av's\");\n    uint_t av = avs[0];\n\n#ifndef PRODUCT\n    if (PrintMiscellaneous && Verbose) {\n      tty->print(\"getisax(2) returned: \" PTR32_FORMAT, av);\n      if (avn > 1) {\n        tty->print(\", \" PTR32_FORMAT, avs[1]);\n      }\n      tty->cr();\n    }\n#endif\n\n    if (av & AV_SPARC_MUL32)  features |= hardware_mul32_m;\n    if (av & AV_SPARC_DIV32)  features |= hardware_div32_m;\n    if (av & AV_SPARC_FSMULD) features |= hardware_fsmuld_m;\n    if (av & AV_SPARC_V8PLUS) features |= v9_instructions_m;\n    if (av & AV_SPARC_POPC)   features |= hardware_popc_m;\n    if (av & AV_SPARC_VIS)    features |= vis1_instructions_m;\n    if (av & AV_SPARC_VIS2)   features |= vis2_instructions_m;\n    if (avn > 1) {\n      uint_t av2 = avs[1];\n#ifndef AV2_SPARC_SPARC5\n#define AV2_SPARC_SPARC5 0x00000008 /* The 29 new fp and sub instructions */\n#endif\n      if (av2 & AV2_SPARC_SPARC5)       features |= sparc5_instructions_m;\n    }\n\n    // Next values are not defined before Solaris 10\n    // but Solaris 8 is used for jdk6 update builds.\n#ifndef AV_SPARC_ASI_BLK_INIT\n#define AV_SPARC_ASI_BLK_INIT 0x0080  /* ASI_BLK_INIT_xxx ASI */\n#endif\n    if (av & AV_SPARC_ASI_BLK_INIT) features |= blk_init_instructions_m;\n\n#ifndef AV_SPARC_FMAF\n#define AV_SPARC_FMAF 0x0100        /* Fused Multiply-Add */\n#endif\n    if (av & AV_SPARC_FMAF)         features |= fmaf_instructions_m;\n\n#ifndef AV_SPARC_FMAU\n#define    AV_SPARC_FMAU    0x0200  /* Unfused Multiply-Add */\n#endif\n    if (av & AV_SPARC_FMAU)         features |= fmau_instructions_m;\n\n#ifndef AV_SPARC_VIS3\n#define    AV_SPARC_VIS3    0x0400  /* VIS3 instruction set extensions */\n#endif\n    if (av & AV_SPARC_VIS3)         features |= vis3_instructions_m;\n\n#ifndef AV_SPARC_CBCOND\n#define AV_SPARC_CBCOND 0x10000000  /* compare and branch instrs supported */\n#endif\n    if (av & AV_SPARC_CBCOND)       features |= cbcond_instructions_m;\n\n#ifndef AV_SPARC_AES\n#define AV_SPARC_AES 0x00020000  /* aes instrs supported */\n#endif\n    if (av & AV_SPARC_AES)       features |= aes_instructions_m;\n\n#ifndef AV_SPARC_SHA1\n#define AV_SPARC_SHA1   0x00400000  /* sha1 instruction supported */\n#endif\n    if (av & AV_SPARC_SHA1)         features |= sha1_instruction_m;\n\n#ifndef AV_SPARC_SHA256\n#define AV_SPARC_SHA256 0x00800000  /* sha256 instruction supported */\n#endif\n    if (av & AV_SPARC_SHA256)       features |= sha256_instruction_m;\n\n#ifndef AV_SPARC_SHA512\n#define AV_SPARC_SHA512 0x01000000  /* sha512 instruction supported */\n#endif\n    if (av & AV_SPARC_SHA512)       features |= sha512_instruction_m;\n\n  } else {\n    // getisax(2) failed, use the old legacy code.\n#ifndef PRODUCT\n    if (PrintMiscellaneous && Verbose)\n      tty->print_cr(\"getisax(2) is not supported.\");\n#endif\n\n    char   tmp;\n    size_t bufsize = sysinfo(SI_ISALIST, &tmp, 1);\n    char*  buf     = (char*) malloc(bufsize);\n\n    if (buf != NULL) {\n      if (sysinfo(SI_ISALIST, buf, bufsize) == bufsize) {\n        // Figure out what kind of sparc we have\n        char *sparc_string = strstr(buf, \"sparc\");\n        if (sparc_string != NULL) {              features |= v8_instructions_m;\n          if (sparc_string[5] == 'v') {\n            if (sparc_string[6] == '8') {\n              if (sparc_string[7] == '-') {      features |= hardware_mul32_m;\n                                                 features |= hardware_div32_m;\n              } else if (sparc_string[7] == 'p') features |= generic_v9_m;\n              else                               features |= generic_v8_m;\n            } else if (sparc_string[6] == '9')   features |= generic_v9_m;\n          }\n        }\n\n        // Check for visualization instructions\n        char *vis = strstr(buf, \"vis\");\n        if (vis != NULL) {                       features |= vis1_instructions_m;\n          if (vis[3] == '2')                     features |= vis2_instructions_m;\n        }\n      }\n      free(buf);\n    }\n  }\n\n  // Determine the machine type.\n  do_sysinfo(SI_MACHINE, \"sun4v\", &features, sun4v_m);\n\n  {\n    // Using kstat to determine the machine type.\n    kstat_ctl_t* kc = kstat_open();\n    kstat_t* ksp = kstat_lookup(kc, (char*)\"cpu_info\", -1, NULL);\n    const char* implementation = \"UNKNOWN\";\n    if (ksp != NULL) {\n      if (kstat_read(kc, ksp, NULL) != -1 && ksp->ks_data != NULL) {\n        kstat_named_t* knm = (kstat_named_t *)ksp->ks_data;\n        for (int i = 0; i < ksp->ks_ndata; i++) {\n          if (strcmp((const char*)&(knm[i].name),\"implementation\") == 0) {\n#ifndef KSTAT_DATA_STRING\n#define KSTAT_DATA_STRING   9\n#endif\n            if (knm[i].data_type == KSTAT_DATA_CHAR) {\n              // VM is running on Solaris 8 which does not have value.str.\n              implementation = &(knm[i].value.c[0]);\n            } else if (knm[i].data_type == KSTAT_DATA_STRING) {\n              // VM is running on Solaris 10.\n#ifndef KSTAT_NAMED_STR_PTR\n              // Solaris 8 was used to build VM, define the structure it misses.\n              struct str_t {\n                union {\n                  char *ptr;     /* NULL-term string */\n                  char __pad[8]; /* 64-bit padding */\n                } addr;\n                uint32_t len;    /* # bytes for strlen + '\\0' */\n              };\n#define KSTAT_NAMED_STR_PTR(knptr) (( (str_t*)&((knptr)->value) )->addr.ptr)\n#endif\n              implementation = KSTAT_NAMED_STR_PTR(&knm[i]);\n            }\n#ifndef PRODUCT\n            if (PrintMiscellaneous && Verbose) {\n              tty->print_cr(\"cpu_info.implementation: %s\", implementation);\n            }\n#endif\n            // Convert to UPPER case before compare.\n            char* impl = strdup(implementation);\n\n            for (int i = 0; impl[i] != 0; i++)\n              impl[i] = (char)toupper((uint)impl[i]);\n            if (strstr(impl, \"SPARC64\") != NULL) {\n              features |= sparc64_family_m;\n            } else if (strstr(impl, \"SPARC-M\") != NULL) {\n              // M-series SPARC is based on T-series.\n              features |= (M_family_m | T_family_m);\n            } else if (strstr(impl, \"SPARC-T\") != NULL) {\n              features |= T_family_m;\n              if (strstr(impl, \"SPARC-T1\") != NULL) {\n                features |= T1_model_m;\n              }\n            } else {\n              if (strstr(impl, \"SPARC\") == NULL) {\n#ifndef PRODUCT\n                // kstat on Solaris 8 virtual machines (branded zones)\n                // returns \"(unsupported)\" implementation.\n                warning(\"kstat cpu_info implementation = '%s', should contain SPARC\", impl);\n#endif\n                implementation = \"SPARC\";\n              }\n            }\n            free((void*)impl);\n            break;\n          }\n        } // for(\n      }\n    }\n    assert(strcmp(implementation, \"UNKNOWN\") != 0,\n           \"unknown cpu info (changed kstat interface?)\");\n    kstat_close(kc);\n  }\n\n  // Figure out cache line sizes using PICL\n  PICL picl((features & sparc64_family_m) != 0, (features & sun4v_m) != 0);\n  _L2_data_cache_line_size = picl.L2_data_cache_line_size();\n\n  return features;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/hsdis/hsdis-demo.c": "/*\n * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n/* hsdis-demo.c -- dump a range of addresses as native instructions\n   This demonstrates the protocol required by the HotSpot PrintAssembly option.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n\n#include \"hsdis.h\"\n\n\nvoid greet(const char*);\nvoid disassemble(uintptr_t, uintptr_t);\nvoid end_of_file();\n\nconst char* options = NULL;\nint         raw     = 0;\nint         xml     = 0;\n\nint main(int ac, char** av) {\n  int greeted = 0;\n  int i;\n  for (i = 1; i < ac; i++) {\n    const char* arg = av[i];\n    if (arg[0] == '-') {\n      if (!strcmp(arg, \"-xml\"))\n        xml ^= 1;\n      else if (!strcmp(arg, \"-raw\"))\n        raw ^= 1;\n      else if (!strncmp(arg, \"-options=\", 9))\n        options = arg+9;\n      else\n        { printf(\"Usage: %s [-xml] [name...]\\n\", av[0]); exit(2); }\n      continue;\n    }\n    greet(arg);\n    greeted = 1;\n  }\n  if (!greeted)\n    greet(\"world\");\n  printf(\"...And now for something completely different:\\n\");\n  void *start = (void*) &main;\n  void *end = (void*) &end_of_file;\n#if defined(__ia64) || defined(__powerpc__)\n  /* On IA64 and PPC function pointers are pointers to function descriptors */\n  start = *((void**)start);\n  end = *((void**)end);\n#endif\n  disassemble(start, (end > start) ? end : start + 64);\n  printf(\"Cheers!\\n\");\n}\n\nvoid greet(const char* whom) {\n  printf(\"Hello, %s!\\n\", whom);\n}\n\nvoid end_of_file() { }\n\n/* don't disassemble after this point... */\n\n#include \"dlfcn.h\"\n\n#define DECODE_INSTRUCTIONS_VIRTUAL_NAME \"decode_instructions_virtual\"\n#define DECODE_INSTRUCTIONS_NAME \"decode_instructions\"\n#define HSDIS_NAME               \"hsdis\"\nstatic void* decode_instructions_pv = 0;\nstatic void* decode_instructions_sv = 0;\nstatic const char* hsdis_path[] = {\n  HSDIS_NAME\"-\"LIBARCH LIB_EXT,\n  \"./\" HSDIS_NAME\"-\"LIBARCH LIB_EXT,\n#ifdef TARGET_DIR\n  TARGET_DIR\"/\"HSDIS_NAME\"-\"LIBARCH LIB_EXT,\n#endif\n  NULL\n};\n\nstatic const char* load_decode_instructions() {\n  void* dllib = NULL;\n  const char* *next_in_path = hsdis_path;\n  while (1) {\n    decode_instructions_pv = dlsym(dllib, DECODE_INSTRUCTIONS_VIRTUAL_NAME);\n    decode_instructions_sv = dlsym(dllib, DECODE_INSTRUCTIONS_NAME);\n    if (decode_instructions_pv != NULL || decode_instructions_sv != NULL)\n      return NULL;\n    if (dllib != NULL)\n      return \"plugin does not defined \"DECODE_INSTRUCTIONS_VIRTUAL_NAME\" and \"DECODE_INSTRUCTIONS_NAME;\n    for (dllib = NULL; dllib == NULL; ) {\n      const char* next_lib = (*next_in_path++);\n      if (next_lib == NULL)\n        return \"cannot find plugin \"HSDIS_NAME LIB_EXT;\n      dllib = dlopen(next_lib, RTLD_LAZY);\n    }\n  }\n}\n\n\nstatic const char* lookup(void* addr) {\n#if defined(__ia64) || defined(__powerpc__)\n  /* On IA64 and PPC function pointers are pointers to function descriptors */\n#define CHECK_NAME(fn) \\\n  if (addr == *((void**) &fn))  return #fn;\n#else\n#define CHECK_NAME(fn) \\\n  if (addr == (void*) &fn)  return #fn;\n#endif\n\n  CHECK_NAME(main);\n  CHECK_NAME(greet);\n  return NULL;\n}\n\n/* does the event match the tag, followed by a null, space, or slash? */\n#define MATCH(event, tag) \\\n  (!strncmp(event, tag, sizeof(tag)-1) && \\\n   (!event[sizeof(tag)-1] || strchr(\" /\", event[sizeof(tag)-1])))\n\n\nstatic const char event_cookie[] = \"event_cookie\"; /* demo placeholder */\nstatic void* simple_handle_event(void* cookie, const char* event, void* arg) {\n  if (MATCH(event, \"/insn\")) {\n    // follow each complete insn by a nice newline\n    printf(\"\\n\");\n  }\n  return NULL;\n}\n\nstatic void* handle_event(void* cookie, const char* event, void* arg) {\n#define NS_DEMO \"demo:\"\n  if (cookie != event_cookie)\n    printf(\"*** bad event cookie %p != %p\\n\", cookie, event_cookie);\n\n  if (xml) {\n    /* We could almost do a printf(event, arg),\n       but for the sake of a better demo,\n       we dress the result up as valid XML.\n    */\n    const char* fmt = strchr(event, ' ');\n    int evlen = (fmt ? fmt - event : strlen(event));\n    if (!fmt) {\n      if (event[0] != '/') {\n        printf(\"<\"NS_DEMO\"%.*s>\", evlen, event);\n      } else {\n        printf(\"</\"NS_DEMO\"%.*s>\", evlen-1, event+1);\n      }\n    } else {\n      if (event[0] != '/') {\n        printf(\"<\"NS_DEMO\"%.*s\", evlen, event);\n        printf(fmt, arg);\n        printf(\">\");\n      } else {\n        printf(\"<\"NS_DEMO\"%.*s_done\", evlen-1, event+1);\n        printf(fmt, arg);\n        printf(\"/></\"NS_DEMO\"%.*s>\", evlen-1, event+1);\n      }\n    }\n  }\n\n  if (MATCH(event, \"insn\")) {\n    const char* name = lookup(arg);\n    if (name)  printf(\"%s:\\n\", name);\n\n    /* basic action for <insn>: */\n    printf(\" %p\\t\", arg);\n\n  } else if (MATCH(event, \"/insn\")) {\n    // follow each complete insn by a nice newline\n    printf(\"\\n\");\n  } else if (MATCH(event, \"mach\")) {\n    printf(\"Decoding for CPU '%s'\\n\", (char*) arg);\n\n  } else if (MATCH(event, \"addr\")) {\n    /* basic action for <addr/>: */\n    const char* name = lookup(arg);\n    if (name) {\n      printf(\"&%s (%p)\", name, arg);\n      /* return non-null to notify hsdis not to print the addr */\n      return arg;\n    }\n  }\n\n  /* null return is always safe; can mean \"I ignored it\" */\n  return NULL;\n}\n\n#define fprintf_callback \\\n  (decode_instructions_printf_callback_ftype)&fprintf\n\nvoid disassemble(uintptr_t from, uintptr_t to) {\n  const char* err = load_decode_instructions();\n  if (err != NULL) {\n    printf(\"%s: %s\\n\", err, dlerror());\n    exit(1);\n  }\n  decode_func_vtype decode_instructions_v\n    = (decode_func_vtype) decode_instructions_pv;\n  decode_func_stype decode_instructions_s\n    = (decode_func_stype) decode_instructions_sv;\n  void* res;\n  if (decode_instructions_pv != NULL) {\n    printf(\"\\nDecoding from %p to %p...with %s\\n\", from, to, DECODE_INSTRUCTIONS_VIRTUAL_NAME);\n    if (raw) {\n      res = (*decode_instructions_v)(from, to,\n                                     (unsigned char*)from, to - from,\n                                     simple_handle_event, stdout,\n                                     NULL, stdout,\n                                     options, 0);\n    } else {\n      res = (*decode_instructions_v)(from, to,\n                                    (unsigned char*)from, to - from,\n                                     handle_event, (void*) event_cookie,\n                                     fprintf_callback, stdout,\n                                     options, 0);\n    }\n    if (res != (void*)to)\n      printf(\"*** Result was %p!\\n\", res);\n  }\n  void* sres;\n  if (decode_instructions_sv != NULL) {\n    printf(\"\\nDecoding from %p to %p...with old decode_instructions\\n\", from, to, DECODE_INSTRUCTIONS_NAME);\n    if (raw) {\n      sres = (*decode_instructions_s)(from, to,\n                                      simple_handle_event, stdout,\n                                      NULL, stdout,\n                                      options);\n    } else {\n      sres = (*decode_instructions_s)(from, to,\n                                      handle_event, (void*) event_cookie,\n                                      fprintf_callback, stdout,\n                                      options);\n    }\n    if (sres != (void *)to)\n      printf(\"*** Result of decode_instructions %p!\\n\", sres);\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os/linux/vm/os_linux.hpp": "/*\n * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#ifndef OS_LINUX_VM_OS_LINUX_HPP\n#define OS_LINUX_VM_OS_LINUX_HPP\n\n// Linux_OS defines the interface to Linux operating systems\n\n/* pthread_getattr_np comes with LinuxThreads-0.9-7 on RedHat 7.1 */\ntypedef int (*pthread_getattr_func_type) (pthread_t, pthread_attr_t *);\n\n// Information about the protection of the page at address '0' on this os.\nstatic bool zero_page_read_protected() { return true; }\n\nclass Linux {\n  friend class os;\n  friend class TestReserveMemorySpecial;\n\n  // For signal-chaining\n#define MAXSIGNUM 32\n  static struct sigaction sigact[MAXSIGNUM]; // saved preinstalled sigactions\n  static unsigned int sigs;             // mask of signals that have\n                                        // preinstalled signal handlers\n  static bool libjsig_is_loaded;        // libjsig that interposes sigaction(),\n                                        // __sigaction(), signal() is loaded\n  static struct sigaction *(*get_signal_action)(int);\n  static struct sigaction *get_preinstalled_handler(int);\n  static void save_preinstalled_handler(int, struct sigaction&);\n\n  static void check_signal_handler(int sig);\n\n  // For signal flags diagnostics\n  static int sigflags[MAXSIGNUM];\n\n  static int (*_clock_gettime)(clockid_t, struct timespec *);\n  static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);\n\n  static address   _initial_thread_stack_bottom;\n  static uintptr_t _initial_thread_stack_size;\n\n  static const char *_glibc_version;\n  static const char *_libpthread_version;\n\n  static bool _is_floating_stack;\n  static bool _is_NPTL;\n  static bool _supports_fast_thread_cpu_time;\n\n  static GrowableArray<int>* _cpu_to_node;\n\n protected:\n\n  static julong _physical_memory;\n  static pthread_t _main_thread;\n  static Mutex* _createThread_lock;\n  static int _page_size;\n  static const int _vm_default_page_size;\n\n  static julong available_memory();\n  static julong physical_memory() { return _physical_memory; }\n  static void initialize_system_info();\n\n  static int commit_memory_impl(char* addr, size_t bytes, bool exec);\n  static int commit_memory_impl(char* addr, size_t bytes,\n                                size_t alignment_hint, bool exec);\n\n  static void set_glibc_version(const char *s)      { _glibc_version = s; }\n  static void set_libpthread_version(const char *s) { _libpthread_version = s; }\n\n  static bool supports_variable_stack_size();\n\n  static void set_is_NPTL()                   { _is_NPTL = true;  }\n  static void set_is_LinuxThreads()           { _is_NPTL = false; }\n  static void set_is_floating_stack()         { _is_floating_stack = true; }\n\n  static void rebuild_cpu_to_node_map();\n  static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }\n\n  static size_t find_large_page_size();\n  static size_t setup_large_page_size();\n\n  static bool setup_large_page_type(size_t page_size);\n  static bool transparent_huge_pages_sanity_check(bool warn, size_t pages_size);\n  static bool hugetlbfs_sanity_check(bool warn, size_t page_size);\n\n  static char* reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec);\n  static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, char* req_addr, bool exec);\n  static char* reserve_memory_special_huge_tlbfs_only(size_t bytes, char* req_addr, bool exec);\n  static char* reserve_memory_special_huge_tlbfs_mixed(size_t bytes, size_t alignment, char* req_addr, bool exec);\n\n  static bool release_memory_special_impl(char* base, size_t bytes);\n  static bool release_memory_special_shm(char* base, size_t bytes);\n  static bool release_memory_special_huge_tlbfs(char* base, size_t bytes);\n\n  static void print_full_memory_info(outputStream* st);\n  static void print_distro_info(outputStream* st);\n  static void print_libversion_info(outputStream* st);\n\n public:\n  static bool _stack_is_executable;\n  static void *dlopen_helper(const char *name, char *ebuf, int ebuflen);\n  static void *dll_load_in_vmthread(const char *name, char *ebuf, int ebuflen);\n\n  static void init_thread_fpu_state();\n  static int  get_fpu_control_word();\n  static void set_fpu_control_word(int fpu_control);\n  static pthread_t main_thread(void)                                { return _main_thread; }\n  // returns kernel thread id (similar to LWP id on Solaris), which can be\n  // used to access /proc\n  static pid_t gettid();\n  static void set_createThread_lock(Mutex* lk)                      { _createThread_lock = lk; }\n  static Mutex* createThread_lock(void)                             { return _createThread_lock; }\n  static void hotspot_sigmask(Thread* thread);\n\n  static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }\n  static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }\n  static bool is_initial_thread(void);\n\n  static int page_size(void)                                        { return _page_size; }\n  static void set_page_size(int val)                                { _page_size = val; }\n\n  static int vm_default_page_size(void)                             { return _vm_default_page_size; }\n\n  static address   ucontext_get_pc(ucontext_t* uc);\n  static intptr_t* ucontext_get_sp(ucontext_t* uc);\n  static intptr_t* ucontext_get_fp(ucontext_t* uc);\n\n  // For Analyzer Forte AsyncGetCallTrace profiling support:\n  //\n  // This interface should be declared in os_linux_i486.hpp, but\n  // that file provides extensions to the os class and not the\n  // Linux class.\n  static ExtendedPC fetch_frame_from_ucontext(Thread* thread, ucontext_t* uc,\n    intptr_t** ret_sp, intptr_t** ret_fp);\n\n  // This boolean allows users to forward their own non-matching signals\n  // to JVM_handle_linux_signal, harmlessly.\n  static bool signal_handlers_are_installed;\n\n  static int get_our_sigflags(int);\n  static void set_our_sigflags(int, int);\n  static void signal_sets_init();\n  static void install_signal_handlers();\n  static void set_signal_handler(int, bool);\n  static bool is_sig_ignored(int sig);\n\n  static sigset_t* unblocked_signals();\n  static sigset_t* vm_signals();\n  static sigset_t* allowdebug_blocked_signals();\n\n  // For signal-chaining\n  static struct sigaction *get_chained_signal_action(int sig);\n  static bool chained_handler(int sig, siginfo_t* siginfo, void* context);\n\n  // GNU libc and libpthread version strings\n  static const char *glibc_version()          { return _glibc_version; }\n  static const char *libpthread_version()     { return _libpthread_version; }\n\n  // NPTL or LinuxThreads?\n  static bool is_LinuxThreads()               { return !_is_NPTL; }\n  static bool is_NPTL()                       { return _is_NPTL;  }\n\n  // NPTL is always floating stack. LinuxThreads could be using floating\n  // stack or fixed stack.\n  static bool is_floating_stack()             { return _is_floating_stack; }\n\n  static void libpthread_init();\n  static bool libnuma_init();\n  static void* libnuma_dlsym(void* handle, const char* name);\n  // Minimum stack size a thread can be created with (allowing\n  // the VM to completely create the thread and enter user code)\n  static size_t min_stack_allowed;\n\n  // Return default stack size or guard size for the specified thread type\n  static size_t default_stack_size(os::ThreadType thr_type);\n  static size_t default_guard_size(os::ThreadType thr_type);\n\n  static void capture_initial_stack(size_t max_size);\n\n  // Stack overflow handling\n  static bool manually_expand_stack(JavaThread * t, address addr);\n  static int max_register_window_saves_before_flushing();\n\n  // Real-time clock functions\n  static void clock_init(void);\n\n  // fast POSIX clocks support\n  static void fast_thread_clock_init(void);\n\n  static inline bool supports_monotonic_clock() {\n    return _clock_gettime != NULL;\n  }\n\n  static int clock_gettime(clockid_t clock_id, struct timespec *tp) {\n    return _clock_gettime ? _clock_gettime(clock_id, tp) : -1;\n  }\n\n  static int pthread_getcpuclockid(pthread_t tid, clockid_t *clock_id) {\n    return _pthread_getcpuclockid ? _pthread_getcpuclockid(tid, clock_id) : -1;\n  }\n\n  static bool supports_fast_thread_cpu_time() {\n    return _supports_fast_thread_cpu_time;\n  }\n\n  static jlong fast_thread_cpu_time(clockid_t clockid);\n\n  // pthread_cond clock suppport\n  private:\n  static pthread_condattr_t _condattr[1];\n\n  public:\n  static pthread_condattr_t* condAttr() { return _condattr; }\n\n  // Stack repair handling\n\n  // none present\n\n  // LinuxThreads work-around for 6292965\n  static int safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime);\n\nprivate:\n  typedef int (*sched_getcpu_func_t)(void);\n  typedef int (*numa_node_to_cpus_func_t)(int node, unsigned long *buffer, int bufferlen);\n  typedef int (*numa_max_node_func_t)(void);\n  typedef int (*numa_available_func_t)(void);\n  typedef int (*numa_tonode_memory_func_t)(void *start, size_t size, int node);\n  typedef void (*numa_interleave_memory_func_t)(void *start, size_t size, unsigned long *nodemask);\n  typedef void (*numa_set_bind_policy_func_t)(int policy);\n\n  static sched_getcpu_func_t _sched_getcpu;\n  static numa_node_to_cpus_func_t _numa_node_to_cpus;\n  static numa_max_node_func_t _numa_max_node;\n  static numa_available_func_t _numa_available;\n  static numa_tonode_memory_func_t _numa_tonode_memory;\n  static numa_interleave_memory_func_t _numa_interleave_memory;\n  static numa_set_bind_policy_func_t _numa_set_bind_policy;\n  static unsigned long* _numa_all_nodes;\n\n  static void set_sched_getcpu(sched_getcpu_func_t func) { _sched_getcpu = func; }\n  static void set_numa_node_to_cpus(numa_node_to_cpus_func_t func) { _numa_node_to_cpus = func; }\n  static void set_numa_max_node(numa_max_node_func_t func) { _numa_max_node = func; }\n  static void set_numa_available(numa_available_func_t func) { _numa_available = func; }\n  static void set_numa_tonode_memory(numa_tonode_memory_func_t func) { _numa_tonode_memory = func; }\n  static void set_numa_interleave_memory(numa_interleave_memory_func_t func) { _numa_interleave_memory = func; }\n  static void set_numa_set_bind_policy(numa_set_bind_policy_func_t func) { _numa_set_bind_policy = func; }\n  static void set_numa_all_nodes(unsigned long* ptr) { _numa_all_nodes = ptr; }\n  static int sched_getcpu_syscall(void);\npublic:\n  static int sched_getcpu()  { return _sched_getcpu != NULL ? _sched_getcpu() : -1; }\n  static int numa_node_to_cpus(int node, unsigned long *buffer, int bufferlen) {\n    return _numa_node_to_cpus != NULL ? _numa_node_to_cpus(node, buffer, bufferlen) : -1;\n  }\n  static int numa_max_node() { return _numa_max_node != NULL ? _numa_max_node() : -1; }\n  static int numa_available() { return _numa_available != NULL ? _numa_available() : -1; }\n  static int numa_tonode_memory(void *start, size_t size, int node) {\n    return _numa_tonode_memory != NULL ? _numa_tonode_memory(start, size, node) : -1;\n  }\n  static void numa_interleave_memory(void *start, size_t size) {\n    if (_numa_interleave_memory != NULL && _numa_all_nodes != NULL) {\n      _numa_interleave_memory(start, size, _numa_all_nodes);\n    }\n  }\n  static void numa_set_bind_policy(int policy) {\n    if (_numa_set_bind_policy != NULL) {\n      _numa_set_bind_policy(policy);\n    }\n  }\n  static int get_node_by_cpu(int cpu_id);\n};\n\n\nclass PlatformEvent : public CHeapObj<mtInternal> {\n  private:\n    double CachePad [4] ;   // increase odds that _mutex is sole occupant of cache line\n    volatile int _Event ;\n    volatile int _nParked ;\n    pthread_mutex_t _mutex  [1] ;\n    pthread_cond_t  _cond   [1] ;\n    double PostPad  [2] ;\n    Thread * _Assoc ;\n\n  public:       // TODO-FIXME: make dtor private\n    ~PlatformEvent() { guarantee (0, \"invariant\") ; }\n\n  public:\n    PlatformEvent() {\n      int status;\n      status = pthread_cond_init (_cond, os::Linux::condAttr());\n      assert_status(status == 0, status, \"cond_init\");\n      status = pthread_mutex_init (_mutex, NULL);\n      assert_status(status == 0, status, \"mutex_init\");\n      _Event   = 0 ;\n      _nParked = 0 ;\n      _Assoc   = NULL ;\n    }\n\n    // Use caution with reset() and fired() -- they may require MEMBARs\n    void reset() { _Event = 0 ; }\n    int  fired() { return _Event; }\n    void park () ;\n    void unpark () ;\n    int  TryPark () ;\n    int  park (jlong millis) ; // relative timed-wait only\n    void SetAssociation (Thread * a) { _Assoc = a ; }\n} ;\n\nclass PlatformParker : public CHeapObj<mtInternal> {\n  protected:\n    enum {\n        REL_INDEX = 0,\n        ABS_INDEX = 1\n    };\n    int _cur_index;  // which cond is in use: -1, 0, 1\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [2] ; // one for relative times and one for abs.\n\n  public:       // TODO-FIXME: make dtor private\n    ~PlatformParker() { guarantee (0, \"invariant\") ; }\n\n  public:\n    PlatformParker() {\n      int status;\n      status = pthread_cond_init (&_cond[REL_INDEX], os::Linux::condAttr());\n      assert_status(status == 0, status, \"cond_init rel\");\n      status = pthread_cond_init (&_cond[ABS_INDEX], NULL);\n      assert_status(status == 0, status, \"cond_init abs\");\n      status = pthread_mutex_init (_mutex, NULL);\n      assert_status(status == 0, status, \"mutex_init\");\n      _cur_index = -1; // mark as unused\n    }\n};\n\n#endif // OS_LINUX_VM_OS_LINUX_HPP\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os/linux/vm/os_linux.cpp": "/*\n * Copyright (c) 1999, 2016, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n// no precompiled headers\n#include \"classfile/classLoader.hpp\"\n#include \"classfile/systemDictionary.hpp\"\n#include \"classfile/vmSymbols.hpp\"\n#include \"code/icBuffer.hpp\"\n#include \"code/vtableStubs.hpp\"\n#include \"compiler/compileBroker.hpp\"\n#include \"compiler/disassembler.hpp\"\n#include \"interpreter/interpreter.hpp\"\n#include \"jvm_linux.h\"\n#include \"memory/allocation.inline.hpp\"\n#include \"memory/filemap.hpp\"\n#include \"mutex_linux.inline.hpp\"\n#include \"oops/oop.inline.hpp\"\n#include \"os_share_linux.hpp\"\n#include \"prims/jniFastGetField.hpp\"\n#include \"prims/jvm.h\"\n#include \"prims/jvm_misc.hpp\"\n#include \"runtime/arguments.hpp\"\n#include \"runtime/extendedPC.hpp\"\n#include \"runtime/globals.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/init.hpp\"\n#include \"runtime/java.hpp\"\n#include \"runtime/javaCalls.hpp\"\n#include \"runtime/mutexLocker.hpp\"\n#include \"runtime/objectMonitor.hpp\"\n#include \"runtime/orderAccess.inline.hpp\"\n#include \"runtime/osThread.hpp\"\n#include \"runtime/perfMemory.hpp\"\n#include \"runtime/sharedRuntime.hpp\"\n#include \"runtime/statSampler.hpp\"\n#include \"runtime/stubRoutines.hpp\"\n#include \"runtime/thread.inline.hpp\"\n#include \"runtime/threadCritical.hpp\"\n#include \"runtime/timer.hpp\"\n#include \"services/attachListener.hpp\"\n#include \"services/memTracker.hpp\"\n#include \"services/runtimeService.hpp\"\n#include \"utilities/decoder.hpp\"\n#include \"utilities/defaultStream.hpp\"\n#include \"utilities/events.hpp\"\n#include \"utilities/elfFile.hpp\"\n#include \"utilities/growableArray.hpp\"\n#include \"utilities/vmError.hpp\"\n\n// put OS-includes here\n# include <sys/types.h>\n# include <sys/mman.h>\n# include <sys/stat.h>\n# include <sys/select.h>\n# include <pthread.h>\n# include <signal.h>\n# include <errno.h>\n# include <dlfcn.h>\n# include <stdio.h>\n# include <unistd.h>\n# include <sys/resource.h>\n# include <pthread.h>\n# include <sys/stat.h>\n# include <sys/time.h>\n# include <sys/times.h>\n# include <sys/utsname.h>\n# include <sys/socket.h>\n# include <sys/wait.h>\n# include <pwd.h>\n# include <poll.h>\n# include <semaphore.h>\n# include <fcntl.h>\n# include <string.h>\n# include <syscall.h>\n# include <sys/sysinfo.h>\n# include <gnu/libc-version.h>\n# include <sys/ipc.h>\n# include <sys/shm.h>\n# include <link.h>\n# include <stdint.h>\n# include <inttypes.h>\n# include <sys/ioctl.h>\n\nPRAGMA_FORMAT_MUTE_WARNINGS_FOR_GCC\n\n#ifndef _GNU_SOURCE\n  #define _GNU_SOURCE\n  #include <sched.h>\n  #undef _GNU_SOURCE\n#else\n  #include <sched.h>\n#endif\n\n// if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling\n// getrusage() is prepared to handle the associated failure.\n#ifndef RUSAGE_THREAD\n#define RUSAGE_THREAD   (1)               /* only the calling thread */\n#endif\n\n#define MAX_PATH    (2 * K)\n\n#define MAX_SECS 100000000\n\n// for timer info max values which include all bits\n#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n\n#define LARGEPAGES_BIT (1 << 6)\n////////////////////////////////////////////////////////////////////////////////\n// global variables\njulong os::Linux::_physical_memory = 0;\n\naddress   os::Linux::_initial_thread_stack_bottom = NULL;\nuintptr_t os::Linux::_initial_thread_stack_size   = 0;\n\nint (*os::Linux::_clock_gettime)(clockid_t, struct timespec *) = NULL;\nint (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;\nMutex* os::Linux::_createThread_lock = NULL;\npthread_t os::Linux::_main_thread;\nint os::Linux::_page_size = -1;\nconst int os::Linux::_vm_default_page_size = (8 * K);\nbool os::Linux::_is_floating_stack = false;\nbool os::Linux::_is_NPTL = false;\nbool os::Linux::_supports_fast_thread_cpu_time = false;\nconst char * os::Linux::_glibc_version = NULL;\nconst char * os::Linux::_libpthread_version = NULL;\npthread_condattr_t os::Linux::_condattr[1];\n\nstatic jlong initial_time_count=0;\n\nstatic int clock_tics_per_sec = 100;\n\n// For diagnostics to print a message once. see run_periodic_checks\nstatic sigset_t check_signal_done;\nstatic bool check_signals = true;\n\nstatic pid_t _initial_pid = 0;\n\n/* Signal number used to suspend/resume a thread */\n\n/* do not use any signal number less than SIGSEGV, see 4355769 */\nstatic int SR_signum = SIGUSR2;\nsigset_t SR_sigset;\n\n/* Used to protect dlsym() calls */\nstatic pthread_mutex_t dl_mutex;\n\n// Declarations\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time);\n\n// utility functions\n\nstatic int SR_initialize();\n\njulong os::available_memory() {\n  return Linux::available_memory();\n}\n\njulong os::Linux::available_memory() {\n  // values in struct sysinfo are \"unsigned long\"\n  struct sysinfo si;\n  sysinfo(&si);\n\n  return (julong)si.freeram * si.mem_unit;\n}\n\njulong os::physical_memory() {\n  return Linux::physical_memory();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// environment support\n\nbool os::getenv(const char* name, char* buf, int len) {\n  const char* val = ::getenv(name);\n  if (val != NULL && strlen(val) < (size_t)len) {\n    strcpy(buf, val);\n    return true;\n  }\n  if (len > 0) buf[0] = 0;  // return a null string\n  return false;\n}\n\n\n// Return true if user is running as root.\n\nbool os::have_special_privileges() {\n  static bool init = false;\n  static bool privileges = false;\n  if (!init) {\n    privileges = (getuid() != geteuid()) || (getgid() != getegid());\n    init = true;\n  }\n  return privileges;\n}\n\n\n#ifndef SYS_gettid\n// i386: 224, ia64: 1105, amd64: 186, sparc 143\n  #ifdef __ia64__\n    #define SYS_gettid 1105\n  #else\n    #ifdef __i386__\n      #define SYS_gettid 224\n    #else\n      #ifdef __amd64__\n        #define SYS_gettid 186\n      #else\n        #ifdef __sparc__\n          #define SYS_gettid 143\n        #else\n          #error define gettid for the arch\n        #endif\n      #endif\n    #endif\n  #endif\n#endif\n\n// Cpu architecture string\nstatic char cpu_arch[] = HOTSPOT_LIB_ARCH;\n\n// pid_t gettid()\n//\n// Returns the kernel thread id of the currently running thread. Kernel\n// thread id is used to access /proc.\n//\n// (Note that getpid() on LinuxThreads returns kernel thread id too; but\n// on NPTL, it returns the same pid for all threads, as required by POSIX.)\n//\npid_t os::Linux::gettid() {\n  int rslt = syscall(SYS_gettid);\n  if (rslt == -1) {\n     // old kernel, no NPTL support\n     return getpid();\n  } else {\n     return (pid_t)rslt;\n  }\n}\n\n// Most versions of linux have a bug where the number of processors are\n// determined by looking at the /proc file system.  In a chroot environment,\n// the system call returns 1.  This causes the VM to act as if it is\n// a single processor and elide locking (see is_MP() call).\nstatic bool unsafe_chroot_detected = false;\nstatic const char *unstable_chroot_error = \"/proc file system not found.\\n\"\n                     \"Java may be unstable running multithreaded in a chroot \"\n                     \"environment on Linux when /proc filesystem is not mounted.\";\n\nvoid os::Linux::initialize_system_info() {\n  set_processor_count(sysconf(_SC_NPROCESSORS_CONF));\n  if (processor_count() == 1) {\n    pid_t pid = os::Linux::gettid();\n    char fname[32];\n    jio_snprintf(fname, sizeof(fname), \"/proc/%d\", pid);\n    FILE *fp = fopen(fname, \"r\");\n    if (fp == NULL) {\n      unsafe_chroot_detected = true;\n    } else {\n      fclose(fp);\n    }\n  }\n  _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);\n  assert(processor_count() > 0, \"linux error\");\n}\n\nvoid os::init_system_properties_values() {\n  // The next steps are taken in the product version:\n  //\n  // Obtain the JAVA_HOME value from the location of libjvm.so.\n  // This library should be located at:\n  // <JAVA_HOME>/jre/lib/<arch>/{client|server}/libjvm.so.\n  //\n  // If \"/jre/lib/\" appears at the right place in the path, then we\n  // assume libjvm.so is installed in a JDK and we use this path.\n  //\n  // Otherwise exit with message: \"Could not create the Java virtual machine.\"\n  //\n  // The following extra steps are taken in the debugging version:\n  //\n  // If \"/jre/lib/\" does NOT appear at the right place in the path\n  // instead of exit check for $JAVA_HOME environment variable.\n  //\n  // If it is defined and we are able to locate $JAVA_HOME/jre/lib/<arch>,\n  // then we append a fake suffix \"hotspot/libjvm.so\" to this path so\n  // it looks like libjvm.so is installed there\n  // <JAVA_HOME>/jre/lib/<arch>/hotspot/libjvm.so.\n  //\n  // Otherwise exit.\n  //\n  // Important note: if the location of libjvm.so changes this\n  // code needs to be changed accordingly.\n\n// See ld(1):\n//      The linker uses the following search paths to locate required\n//      shared libraries:\n//        1: ...\n//        ...\n//        7: The default directories, normally /lib and /usr/lib.\n#if defined(AMD64) || defined(_LP64) && (defined(SPARC) || defined(PPC) || defined(S390)) || defined(BUILTIN_SIM)\n#define DEFAULT_LIBPATH \"/usr/lib64:/lib64:/lib:/usr/lib\"\n#else\n#define DEFAULT_LIBPATH \"/lib:/usr/lib\"\n#endif\n\n// Base path of extensions installed on the system.\n#define SYS_EXT_DIR     \"/usr/java/packages\"\n#define EXTENSIONS_DIR  \"/lib/ext\"\n#define ENDORSED_DIR    \"/lib/endorsed\"\n\n  // Buffer that fits several sprintfs.\n  // Note that the space for the colon and the trailing null are provided\n  // by the nulls included by the sizeof operator.\n  const size_t bufsize =\n    MAX3((size_t)MAXPATHLEN,  // For dll_dir & friends.\n         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR), // extensions dir\n         (size_t)MAXPATHLEN + sizeof(ENDORSED_DIR)); // endorsed dir\n  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n\n  // sysclasspath, java_home, dll_dir\n  {\n    char *pslash;\n    os::jvm_path(buf, bufsize);\n\n    // Found the full path to libjvm.so.\n    // Now cut the path to <java_home>/jre if we can.\n    *(strrchr(buf, '/')) = '\\0'; // Get rid of /libjvm.so.\n    pslash = strrchr(buf, '/');\n    if (pslash != NULL) {\n      *pslash = '\\0';            // Get rid of /{client|server|hotspot}.\n    }\n    Arguments::set_dll_dir(buf);\n\n    if (pslash != NULL) {\n      pslash = strrchr(buf, '/');\n      if (pslash != NULL) {\n        *pslash = '\\0';          // Get rid of /<arch>.\n        pslash = strrchr(buf, '/');\n        if (pslash != NULL) {\n          *pslash = '\\0';        // Get rid of /lib.\n        }\n      }\n    }\n    Arguments::set_java_home(buf);\n    set_boot_path('/', ':');\n  }\n\n  // Where to look for native libraries.\n  //\n  // Note: Due to a legacy implementation, most of the library path\n  // is set in the launcher. This was to accomodate linking restrictions\n  // on legacy Linux implementations (which are no longer supported).\n  // Eventually, all the library path setting will be done here.\n  //\n  // However, to prevent the proliferation of improperly built native\n  // libraries, the new path component /usr/java/packages is added here.\n  // Eventually, all the library path setting will be done here.\n  {\n    // Get the user setting of LD_LIBRARY_PATH, and prepended it. It\n    // should always exist (until the legacy problem cited above is\n    // addressed).\n    const char *v = ::getenv(\"LD_LIBRARY_PATH\");\n    const char *v_colon = \":\";\n    if (v == NULL) { v = \"\"; v_colon = \"\"; }\n    // That's +1 for the colon and +1 for the trailing '\\0'.\n    char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,\n                                                     strlen(v) + 1 +\n                                                     sizeof(SYS_EXT_DIR) + sizeof(\"/lib/\") + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,\n                                                     mtInternal);\n    sprintf(ld_library_path, \"%s%s\" SYS_EXT_DIR \"/lib/%s:\" DEFAULT_LIBPATH, v, v_colon, cpu_arch);\n    Arguments::set_library_path(ld_library_path);\n    FREE_C_HEAP_ARRAY(char, ld_library_path, mtInternal);\n  }\n\n  // Extensions directories.\n  sprintf(buf, \"%s\" EXTENSIONS_DIR \":\" SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());\n  Arguments::set_ext_dirs(buf);\n\n  // Endorsed standards default directory.\n  sprintf(buf, \"%s\" ENDORSED_DIR, Arguments::get_java_home());\n  Arguments::set_endorsed_dirs(buf);\n\n  FREE_C_HEAP_ARRAY(char, buf, mtInternal);\n\n#undef DEFAULT_LIBPATH\n#undef SYS_EXT_DIR\n#undef EXTENSIONS_DIR\n#undef ENDORSED_DIR\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// breakpoint support\n\nvoid os::breakpoint() {\n  BREAKPOINT;\n}\n\nextern \"C\" void breakpoint() {\n  // use debugger to set breakpoint here\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// signal support\n\ndebug_only(static bool signal_sets_initialized = false);\nstatic sigset_t unblocked_sigs, vm_sigs, allowdebug_blocked_sigs;\n\nbool os::Linux::is_sig_ignored(int sig) {\n      struct sigaction oact;\n      sigaction(sig, (struct sigaction*)NULL, &oact);\n      void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oact.sa_sigaction)\n                                     : CAST_FROM_FN_PTR(void*,  oact.sa_handler);\n      if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN))\n           return true;\n      else\n           return false;\n}\n\nvoid os::Linux::signal_sets_init() {\n  // Should also have an assertion stating we are still single-threaded.\n  assert(!signal_sets_initialized, \"Already initialized\");\n  // Fill in signals that are necessarily unblocked for all threads in\n  // the VM. Currently, we unblock the following signals:\n  // SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n  //                         by -Xrs (=ReduceSignalUsage));\n  // BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n  // other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n  // the dispositions or masks wrt these signals.\n  // Programs embedding the VM that want to use the above signals for their\n  // own purposes must, at this time, use the \"-Xrs\" option to prevent\n  // interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n  // (See bug 4345157, and other related bugs).\n  // In reality, though, unblocking these signals is really a nop, since\n  // these signals are not blocked by default.\n  sigemptyset(&unblocked_sigs);\n  sigemptyset(&allowdebug_blocked_sigs);\n  sigaddset(&unblocked_sigs, SIGILL);\n  sigaddset(&unblocked_sigs, SIGSEGV);\n  sigaddset(&unblocked_sigs, SIGBUS);\n  sigaddset(&unblocked_sigs, SIGFPE);\n#if defined(PPC64)\n  sigaddset(&unblocked_sigs, SIGTRAP);\n#endif\n  sigaddset(&unblocked_sigs, SR_signum);\n\n  if (!ReduceSignalUsage) {\n   if (!os::Linux::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN1_SIGNAL);\n   }\n   if (!os::Linux::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN2_SIGNAL);\n   }\n   if (!os::Linux::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN3_SIGNAL);\n   }\n  }\n  // Fill in signals that are blocked by all but the VM thread.\n  sigemptyset(&vm_sigs);\n  if (!ReduceSignalUsage)\n    sigaddset(&vm_sigs, BREAK_SIGNAL);\n  debug_only(signal_sets_initialized = true);\n\n}\n\n// These are signals that are unblocked while a thread is running Java.\n// (For some reason, they get blocked by default.)\nsigset_t* os::Linux::unblocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &unblocked_sigs;\n}\n\n// These are the signals that are blocked while a (non-VM) thread is\n// running Java. Only the VM thread handles these signals.\nsigset_t* os::Linux::vm_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &vm_sigs;\n}\n\n// These are signals that are blocked during cond_wait to allow debugger in\nsigset_t* os::Linux::allowdebug_blocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &allowdebug_blocked_sigs;\n}\n\nvoid os::Linux::hotspot_sigmask(Thread* thread) {\n\n  //Save caller's signal mask before setting VM signal mask\n  sigset_t caller_sigmask;\n  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n\n  OSThread* osthread = thread->osthread();\n  osthread->set_caller_sigmask(caller_sigmask);\n\n  pthread_sigmask(SIG_UNBLOCK, os::Linux::unblocked_signals(), NULL);\n\n  if (!ReduceSignalUsage) {\n    if (thread->is_VM_thread()) {\n      // Only the VM thread handles BREAK_SIGNAL ...\n      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n    } else {\n      // ... all other threads block BREAK_SIGNAL\n      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n    }\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// detecting pthread library\n\nvoid os::Linux::libpthread_init() {\n  // Save glibc and pthread version strings. Note that _CS_GNU_LIBC_VERSION\n  // and _CS_GNU_LIBPTHREAD_VERSION are supported in glibc >= 2.3.2. Use a\n  // generic name for earlier versions.\n  // Define macros here so we can build HotSpot on old systems.\n# ifndef _CS_GNU_LIBC_VERSION\n# define _CS_GNU_LIBC_VERSION 2\n# endif\n# ifndef _CS_GNU_LIBPTHREAD_VERSION\n# define _CS_GNU_LIBPTHREAD_VERSION 3\n# endif\n\n  size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);\n  if (n > 0) {\n     char *str = (char *)malloc(n, mtInternal);\n     confstr(_CS_GNU_LIBC_VERSION, str, n);\n     os::Linux::set_glibc_version(str);\n  } else {\n     // _CS_GNU_LIBC_VERSION is not supported, try gnu_get_libc_version()\n     static char _gnu_libc_version[32];\n     jio_snprintf(_gnu_libc_version, sizeof(_gnu_libc_version),\n              \"glibc %s %s\", gnu_get_libc_version(), gnu_get_libc_release());\n     os::Linux::set_glibc_version(_gnu_libc_version);\n  }\n\n  n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);\n  if (n > 0) {\n     char *str = (char *)malloc(n, mtInternal);\n     confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);\n     // Vanilla RH-9 (glibc 2.3.2) has a bug that confstr() always tells\n     // us \"NPTL-0.29\" even we are running with LinuxThreads. Check if this\n     // is the case. LinuxThreads has a hard limit on max number of threads.\n     // So sysconf(_SC_THREAD_THREADS_MAX) will return a positive value.\n     // On the other hand, NPTL does not have such a limit, sysconf()\n     // will return -1 and errno is not changed. Check if it is really NPTL.\n     if (strcmp(os::Linux::glibc_version(), \"glibc 2.3.2\") == 0 &&\n         strstr(str, \"NPTL\") &&\n         sysconf(_SC_THREAD_THREADS_MAX) > 0) {\n       free(str);\n       os::Linux::set_libpthread_version(\"linuxthreads\");\n     } else {\n       os::Linux::set_libpthread_version(str);\n     }\n  } else {\n    // glibc before 2.3.2 only has LinuxThreads.\n    os::Linux::set_libpthread_version(\"linuxthreads\");\n  }\n\n  if (strstr(libpthread_version(), \"NPTL\")) {\n     os::Linux::set_is_NPTL();\n  } else {\n     os::Linux::set_is_LinuxThreads();\n  }\n\n  // LinuxThreads have two flavors: floating-stack mode, which allows variable\n  // stack size; and fixed-stack mode. NPTL is always floating-stack.\n  if (os::Linux::is_NPTL() || os::Linux::supports_variable_stack_size()) {\n     os::Linux::set_is_floating_stack();\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// thread stack\n\n// Force Linux kernel to expand current thread stack. If \"bottom\" is close\n// to the stack guard, caller should block all signals.\n//\n// MAP_GROWSDOWN:\n//   A special mmap() flag that is used to implement thread stacks. It tells\n//   kernel that the memory region should extend downwards when needed. This\n//   allows early versions of LinuxThreads to only mmap the first few pages\n//   when creating a new thread. Linux kernel will automatically expand thread\n//   stack as needed (on page faults).\n//\n//   However, because the memory region of a MAP_GROWSDOWN stack can grow on\n//   demand, if a page fault happens outside an already mapped MAP_GROWSDOWN\n//   region, it's hard to tell if the fault is due to a legitimate stack\n//   access or because of reading/writing non-exist memory (e.g. buffer\n//   overrun). As a rule, if the fault happens below current stack pointer,\n//   Linux kernel does not expand stack, instead a SIGSEGV is sent to the\n//   application (see Linux kernel fault.c).\n//\n//   This Linux feature can cause SIGSEGV when VM bangs thread stack for\n//   stack overflow detection.\n//\n//   Newer version of LinuxThreads (since glibc-2.2, or, RH-7.x) and NPTL do\n//   not use this flag. However, the stack of initial thread is not created\n//   by pthread, it is still MAP_GROWSDOWN. Also it's possible (though\n//   unlikely) that user code can create a thread with MAP_GROWSDOWN stack\n//   and then attach the thread to JVM.\n//\n// To get around the problem and allow stack banging on Linux, we need to\n// manually expand thread stack after receiving the SIGSEGV.\n//\n// There are two ways to expand thread stack to address \"bottom\", we used\n// both of them in JVM before 1.5:\n//   1. adjust stack pointer first so that it is below \"bottom\", and then\n//      touch \"bottom\"\n//   2. mmap() the page in question\n//\n// Now alternate signal stack is gone, it's harder to use 2. For instance,\n// if current sp is already near the lower end of page 101, and we need to\n// call mmap() to map page 100, it is possible that part of the mmap() frame\n// will be placed in page 100. When page 100 is mapped, it is zero-filled.\n// That will destroy the mmap() frame and cause VM to crash.\n//\n// The following code works by adjusting sp first, then accessing the \"bottom\"\n// page to force a page fault. Linux kernel will then automatically expand the\n// stack mapping.\n//\n// _expand_stack_to() assumes its frame size is less than page size, which\n// should always be true if the function is not inlined.\n\n#if __GNUC__ < 3    // gcc 2.x does not support noinline attribute\n#define NOINLINE\n#else\n#define NOINLINE __attribute__ ((noinline))\n#endif\n\nstatic void _expand_stack_to(address bottom) NOINLINE;\n\nstatic void _expand_stack_to(address bottom) {\n  address sp;\n  size_t size;\n  volatile char *p;\n\n  // Adjust bottom to point to the largest address within the same page, it\n  // gives us a one-page buffer if alloca() allocates slightly more memory.\n  bottom = (address)align_size_down((uintptr_t)bottom, os::Linux::page_size());\n  bottom += os::Linux::page_size() - 1;\n\n  // sp might be slightly above current stack pointer; if that's the case, we\n  // will alloca() a little more space than necessary, which is OK. Don't use\n  // os::current_stack_pointer(), as its result can be slightly below current\n  // stack pointer, causing us to not alloca enough to reach \"bottom\".\n  sp = (address)&sp;\n\n  if (sp > bottom) {\n    size = sp - bottom;\n    p = (volatile char *)alloca(size);\n    assert(p != NULL && p <= (volatile char *)bottom, \"alloca problem?\");\n    p[0] = '\\0';\n  }\n}\n\nbool os::Linux::manually_expand_stack(JavaThread * t, address addr) {\n  assert(t!=NULL, \"just checking\");\n  assert(t->osthread()->expanding_stack(), \"expand should be set\");\n  assert(t->stack_base() != NULL, \"stack_base was not initialized\");\n\n  if (addr <  t->stack_base() && addr >= t->stack_yellow_zone_base()) {\n    sigset_t mask_all, old_sigset;\n    sigfillset(&mask_all);\n    pthread_sigmask(SIG_SETMASK, &mask_all, &old_sigset);\n    _expand_stack_to(addr);\n    pthread_sigmask(SIG_SETMASK, &old_sigset, NULL);\n    return true;\n  }\n  return false;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// create new thread\n\nstatic address highest_vm_reserved_address();\n\n// check if it's safe to start a new thread\nstatic bool _thread_safety_check(Thread* thread) {\n  if (os::Linux::is_LinuxThreads() && !os::Linux::is_floating_stack()) {\n    // Fixed stack LinuxThreads (SuSE Linux/x86, and some versions of Redhat)\n    //   Heap is mmap'ed at lower end of memory space. Thread stacks are\n    //   allocated (MAP_FIXED) from high address space. Every thread stack\n    //   occupies a fixed size slot (usually 2Mbytes, but user can change\n    //   it to other values if they rebuild LinuxThreads).\n    //\n    // Problem with MAP_FIXED is that mmap() can still succeed even part of\n    // the memory region has already been mmap'ed. That means if we have too\n    // many threads and/or very large heap, eventually thread stack will\n    // collide with heap.\n    //\n    // Here we try to prevent heap/stack collision by comparing current\n    // stack bottom with the highest address that has been mmap'ed by JVM\n    // plus a safety margin for memory maps created by native code.\n    //\n    // This feature can be disabled by setting ThreadSafetyMargin to 0\n    //\n    if (ThreadSafetyMargin > 0) {\n      address stack_bottom = os::current_stack_base() - os::current_stack_size();\n\n      // not safe if our stack extends below the safety margin\n      return stack_bottom - ThreadSafetyMargin >= highest_vm_reserved_address();\n    } else {\n      return true;\n    }\n  } else {\n    // Floating stack LinuxThreads or NPTL:\n    //   Unlike fixed stack LinuxThreads, thread stacks are not MAP_FIXED. When\n    //   there's not enough space left, pthread_create() will fail. If we come\n    //   here, that means enough space has been reserved for stack.\n    return true;\n  }\n}\n\n// Thread start routine for all newly created threads\nstatic void *java_start(Thread *thread) {\n  // Try to randomize the cache line index of hot stack frames.\n  // This helps when threads of the same stack traces evict each other's\n  // cache lines. The threads can be either from the same JVM instance, or\n  // from different JVM instances. The benefit is especially true for\n  // processors with hyperthreading technology.\n  static int counter = 0;\n  int pid = os::current_process_id();\n  alloca(((pid ^ counter++) & 7) * 128);\n\n  ThreadLocalStorage::set_thread(thread);\n\n  OSThread* osthread = thread->osthread();\n  Monitor* sync = osthread->startThread_lock();\n\n  // non floating stack LinuxThreads needs extra check, see above\n  if (!_thread_safety_check(thread)) {\n    // notify parent thread\n    MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);\n    osthread->set_state(ZOMBIE);\n    sync->notify_all();\n    return NULL;\n  }\n\n  // thread_id is kernel thread id (similar to Solaris LWP id)\n  osthread->set_thread_id(os::Linux::gettid());\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n  // initialize signal mask for this thread\n  os::Linux::hotspot_sigmask(thread);\n\n  // initialize floating point control register\n  os::Linux::init_thread_fpu_state();\n\n  // handshaking with parent thread\n  {\n    MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);\n\n    // notify parent thread\n    osthread->set_state(INITIALIZED);\n    sync->notify_all();\n\n    // wait until os::start_thread()\n    while (osthread->get_state() == INITIALIZED) {\n      sync->wait(Mutex::_no_safepoint_check_flag);\n    }\n  }\n\n  // call one more level start routine\n  thread->run();\n\n  return 0;\n}\n\nbool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) {\n  assert(thread->osthread() == NULL, \"caller responsible\");\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // set the correct thread state\n  osthread->set_thread_type(thr_type);\n\n  // Initial state is ALLOCATED but not INITIALIZED\n  osthread->set_state(ALLOCATED);\n\n  thread->set_osthread(osthread);\n\n  // init thread attributes\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n  // stack size\n  if (os::Linux::supports_variable_stack_size()) {\n    // calculate stack size if it's not specified by caller\n    if (stack_size == 0) {\n      stack_size = os::Linux::default_stack_size(thr_type);\n\n      switch (thr_type) {\n      case os::java_thread:\n        // Java threads use ThreadStackSize which default value can be\n        // changed with the flag -Xss\n        assert (JavaThread::stack_size_at_create() > 0, \"this should be set\");\n        stack_size = JavaThread::stack_size_at_create();\n        break;\n      case os::compiler_thread:\n        if (CompilerThreadStackSize > 0) {\n          stack_size = (size_t)(CompilerThreadStackSize * K);\n          break;\n        } // else fall through:\n          // use VMThreadStackSize if CompilerThreadStackSize is not defined\n      case os::vm_thread:\n      case os::pgc_thread:\n      case os::cgc_thread:\n      case os::watcher_thread:\n        if (VMThreadStackSize > 0) stack_size = (size_t)(VMThreadStackSize * K);\n        break;\n      }\n    }\n\n    stack_size = MAX2(stack_size, os::Linux::min_stack_allowed);\n    pthread_attr_setstacksize(&attr, stack_size);\n  } else {\n    // let pthread_create() pick the default value.\n  }\n\n  // glibc guard page\n  pthread_attr_setguardsize(&attr, os::Linux::default_guard_size(thr_type));\n\n  ThreadState state;\n\n  {\n    // Serialize thread creation if we are running with fixed stack LinuxThreads\n    bool lock = os::Linux::is_LinuxThreads() && !os::Linux::is_floating_stack();\n    if (lock) {\n      os::Linux::createThread_lock()->lock_without_safepoint_check();\n    }\n\n    pthread_t tid;\n    int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);\n\n    pthread_attr_destroy(&attr);\n\n    if (ret != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode)) {\n        perror(\"pthread_create()\");\n      }\n      // Need to clean up stuff we've allocated so far\n      thread->set_osthread(NULL);\n      delete osthread;\n      if (lock) os::Linux::createThread_lock()->unlock();\n      return false;\n    }\n\n    // Store pthread info into the OSThread\n    osthread->set_pthread_id(tid);\n\n    // Wait until child thread is either initialized or aborted\n    {\n      Monitor* sync_with_child = osthread->startThread_lock();\n      MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);\n      while ((state = osthread->get_state()) == ALLOCATED) {\n        sync_with_child->wait(Mutex::_no_safepoint_check_flag);\n      }\n    }\n\n    if (lock) {\n      os::Linux::createThread_lock()->unlock();\n    }\n  }\n\n  // Aborted due to thread limit being reached\n  if (state == ZOMBIE) {\n      thread->set_osthread(NULL);\n      delete osthread;\n      return false;\n  }\n\n  // The thread is returned suspended (in state INITIALIZED),\n  // and is started higher up in the call chain\n  assert(state == INITIALIZED, \"race condition\");\n  return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// attach existing thread\n\n// bootstrap the main thread\nbool os::create_main_thread(JavaThread* thread) {\n  assert(os::Linux::_main_thread == pthread_self(), \"should be called inside main thread\");\n  return create_attached_thread(thread);\n}\n\nbool os::create_attached_thread(JavaThread* thread) {\n#ifdef ASSERT\n    thread->verify_not_published();\n#endif\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // Store pthread info into the OSThread\n  osthread->set_thread_id(os::Linux::gettid());\n  osthread->set_pthread_id(::pthread_self());\n\n  // initialize floating point control register\n  os::Linux::init_thread_fpu_state();\n\n  // Initial thread state is RUNNABLE\n  osthread->set_state(RUNNABLE);\n\n  thread->set_osthread(osthread);\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n\n  if (os::Linux::is_initial_thread()) {\n    // If current thread is initial thread, its stack is mapped on demand,\n    // see notes about MAP_GROWSDOWN. Here we try to force kernel to map\n    // the entire stack region to avoid SEGV in stack banging.\n    // It is also useful to get around the heap-stack-gap problem on SuSE\n    // kernel (see 4821821 for details). We first expand stack to the top\n    // of yellow zone, then enable stack yellow zone (order is significant,\n    // enabling yellow zone first will crash JVM on SuSE Linux), so there\n    // is no gap between the last two virtual memory regions.\n\n    JavaThread *jt = (JavaThread *)thread;\n    address addr = jt->stack_yellow_zone_base();\n    assert(addr != NULL, \"initialization problem?\");\n    assert(jt->stack_available(addr) > 0, \"stack guard should not be enabled\");\n\n    osthread->set_expanding_stack();\n    os::Linux::manually_expand_stack(jt, addr);\n    osthread->clear_expanding_stack();\n  }\n\n  // initialize signal mask for this thread\n  // and save the caller's signal mask\n  os::Linux::hotspot_sigmask(thread);\n\n  return true;\n}\n\nvoid os::pd_start_thread(Thread* thread) {\n  OSThread * osthread = thread->osthread();\n  assert(osthread->get_state() != INITIALIZED, \"just checking\");\n  Monitor* sync_with_child = osthread->startThread_lock();\n  MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);\n  sync_with_child->notify();\n}\n\n// Free Linux resources related to the OSThread\nvoid os::free_thread(OSThread* osthread) {\n  assert(osthread != NULL, \"osthread not set\");\n\n  if (Thread::current()->osthread() == osthread) {\n    // Restore caller's signal mask\n    sigset_t sigmask = osthread->caller_sigmask();\n    pthread_sigmask(SIG_SETMASK, &sigmask, NULL);\n   }\n\n  delete osthread;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// thread local storage\n\n// Restore the thread pointer if the destructor is called. This is in case\n// someone from JNI code sets up a destructor with pthread_key_create to run\n// detachCurrentThread on thread death. Unless we restore the thread pointer we\n// will hang or crash. When detachCurrentThread is called the key will be set\n// to null and we will not be called again. If detachCurrentThread is never\n// called we could loop forever depending on the pthread implementation.\nstatic void restore_thread_pointer(void* p) {\n  Thread* thread = (Thread*) p;\n  os::thread_local_storage_at_put(ThreadLocalStorage::thread_index(), thread);\n}\n\nint os::allocate_thread_local_storage() {\n  pthread_key_t key;\n  int rslt = pthread_key_create(&key, restore_thread_pointer);\n  assert(rslt == 0, \"cannot allocate thread local storage\");\n  return (int)key;\n}\n\n// Note: This is currently not used by VM, as we don't destroy TLS key\n// on VM exit.\nvoid os::free_thread_local_storage(int index) {\n  int rslt = pthread_key_delete((pthread_key_t)index);\n  assert(rslt == 0, \"invalid index\");\n}\n\nvoid os::thread_local_storage_at_put(int index, void* value) {\n  int rslt = pthread_setspecific((pthread_key_t)index, value);\n  assert(rslt == 0, \"pthread_setspecific failed\");\n}\n\nextern \"C\" Thread* get_thread() {\n  return ThreadLocalStorage::thread();\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// initial thread\n\n// Check if current thread is the initial thread, similar to Solaris thr_main.\nbool os::Linux::is_initial_thread(void) {\n  char dummy;\n  // If called before init complete, thread stack bottom will be null.\n  // Can be called if fatal error occurs before initialization.\n  if (initial_thread_stack_bottom() == NULL) return false;\n  assert(initial_thread_stack_bottom() != NULL &&\n         initial_thread_stack_size()   != 0,\n         \"os::init did not locate initial thread's stack region\");\n  if ((address)&dummy >= initial_thread_stack_bottom() &&\n      (address)&dummy < initial_thread_stack_bottom() + initial_thread_stack_size())\n       return true;\n  else return false;\n}\n\n// Find the virtual memory area that contains addr\nstatic bool find_vma(address addr, address* vma_low, address* vma_high) {\n  FILE *fp = fopen(\"/proc/self/maps\", \"r\");\n  if (fp) {\n    address low, high;\n    while (!feof(fp)) {\n      if (fscanf(fp, \"%p-%p\", &low, &high) == 2) {\n        if (low <= addr && addr < high) {\n           if (vma_low)  *vma_low  = low;\n           if (vma_high) *vma_high = high;\n           fclose (fp);\n           return true;\n        }\n      }\n      for (;;) {\n        int ch = fgetc(fp);\n        if (ch == EOF || ch == (int)'\\n') break;\n      }\n    }\n    fclose(fp);\n  }\n  return false;\n}\n\n// Locate initial thread stack. This special handling of initial thread stack\n// is needed because pthread_getattr_np() on most (all?) Linux distros returns\n// bogus value for the primordial process thread. While the launcher has created\n// the VM in a new thread since JDK 6, we still have to allow for the use of the\n// JNI invocation API from a primordial thread.\nvoid os::Linux::capture_initial_stack(size_t max_size) {\n\n  // max_size is either 0 (which means accept OS default for thread stacks) or\n  // a user-specified value known to be at least the minimum needed. If we\n  // are actually on the primordial thread we can make it appear that we have a\n  // smaller max_size stack by inserting the guard pages at that location. But we\n  // cannot do anything to emulate a larger stack than what has been provided by\n  // the OS or threading library. In fact if we try to use a stack greater than\n  // what is set by rlimit then we will crash the hosting process.\n\n  // Maximum stack size is the easy part, get it from RLIMIT_STACK.\n  // If this is \"unlimited\" then it will be a huge value.\n  struct rlimit rlim;\n  getrlimit(RLIMIT_STACK, &rlim);\n  size_t stack_size = rlim.rlim_cur;\n\n  // 6308388: a bug in ld.so will relocate its own .data section to the\n  //   lower end of primordial stack; reduce ulimit -s value a little bit\n  //   so we won't install guard page on ld.so's data section.\n  stack_size -= 2 * page_size();\n\n  // Try to figure out where the stack base (top) is. This is harder.\n  //\n  // When an application is started, glibc saves the initial stack pointer in\n  // a global variable \"__libc_stack_end\", which is then used by system\n  // libraries. __libc_stack_end should be pretty close to stack top. The\n  // variable is available since the very early days. However, because it is\n  // a private interface, it could disappear in the future.\n  //\n  // Linux kernel saves start_stack information in /proc/<pid>/stat. Similar\n  // to __libc_stack_end, it is very close to stack top, but isn't the real\n  // stack top. Note that /proc may not exist if VM is running as a chroot\n  // program, so reading /proc/<pid>/stat could fail. Also the contents of\n  // /proc/<pid>/stat could change in the future (though unlikely).\n  //\n  // We try __libc_stack_end first. If that doesn't work, look for\n  // /proc/<pid>/stat. If neither of them works, we use current stack pointer\n  // as a hint, which should work well in most cases.\n\n  uintptr_t stack_start;\n\n  // try __libc_stack_end first\n  uintptr_t *p = (uintptr_t *)dlsym(RTLD_DEFAULT, \"__libc_stack_end\");\n  if (p && *p) {\n    stack_start = *p;\n  } else {\n    // see if we can get the start_stack field from /proc/self/stat\n    FILE *fp;\n    int pid;\n    char state;\n    int ppid;\n    int pgrp;\n    int session;\n    int nr;\n    int tpgrp;\n    unsigned long flags;\n    unsigned long minflt;\n    unsigned long cminflt;\n    unsigned long majflt;\n    unsigned long cmajflt;\n    unsigned long utime;\n    unsigned long stime;\n    long cutime;\n    long cstime;\n    long prio;\n    long nice;\n    long junk;\n    long it_real;\n    uintptr_t start;\n    uintptr_t vsize;\n    intptr_t rss;\n    uintptr_t rsslim;\n    uintptr_t scodes;\n    uintptr_t ecode;\n    int i;\n\n    // Figure what the primordial thread stack base is. Code is inspired\n    // by email from Hans Boehm. /proc/self/stat begins with current pid,\n    // followed by command name surrounded by parentheses, state, etc.\n    char stat[2048];\n    int statlen;\n\n    fp = fopen(\"/proc/self/stat\", \"r\");\n    if (fp) {\n      statlen = fread(stat, 1, 2047, fp);\n      stat[statlen] = '\\0';\n      fclose(fp);\n\n      // Skip pid and the command string. Note that we could be dealing with\n      // weird command names, e.g. user could decide to rename java launcher\n      // to \"java 1.4.2 :)\", then the stat file would look like\n      //                1234 (java 1.4.2 :)) R ... ...\n      // We don't really need to know the command string, just find the last\n      // occurrence of \")\" and then start parsing from there. See bug 4726580.\n      char * s = strrchr(stat, ')');\n\n      i = 0;\n      if (s) {\n        // Skip blank chars\n        do s++; while (isspace(*s));\n\n#define _UFM UINTX_FORMAT\n#define _DFM INTX_FORMAT\n\n        /*                                     1   1   1   1   1   1   1   1   1   1   2   2    2    2    2    2    2    2    2 */\n        /*              3  4  5  6  7  8   9   0   1   2   3   4   5   6   7   8   9   0   1    2    3    4    5    6    7    8 */\n        i = sscanf(s, \"%c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld \" _UFM _UFM _DFM _UFM _UFM _UFM _UFM,\n             &state,          /* 3  %c  */\n             &ppid,           /* 4  %d  */\n             &pgrp,           /* 5  %d  */\n             &session,        /* 6  %d  */\n             &nr,             /* 7  %d  */\n             &tpgrp,          /* 8  %d  */\n             &flags,          /* 9  %lu  */\n             &minflt,         /* 10 %lu  */\n             &cminflt,        /* 11 %lu  */\n             &majflt,         /* 12 %lu  */\n             &cmajflt,        /* 13 %lu  */\n             &utime,          /* 14 %lu  */\n             &stime,          /* 15 %lu  */\n             &cutime,         /* 16 %ld  */\n             &cstime,         /* 17 %ld  */\n             &prio,           /* 18 %ld  */\n             &nice,           /* 19 %ld  */\n             &junk,           /* 20 %ld  */\n             &it_real,        /* 21 %ld  */\n             &start,          /* 22 UINTX_FORMAT */\n             &vsize,          /* 23 UINTX_FORMAT */\n             &rss,            /* 24 INTX_FORMAT  */\n             &rsslim,         /* 25 UINTX_FORMAT */\n             &scodes,         /* 26 UINTX_FORMAT */\n             &ecode,          /* 27 UINTX_FORMAT */\n             &stack_start);   /* 28 UINTX_FORMAT */\n      }\n\n#undef _UFM\n#undef _DFM\n\n      if (i != 28 - 2) {\n         assert(false, \"Bad conversion from /proc/self/stat\");\n         // product mode - assume we are the initial thread, good luck in the\n         // embedded case.\n         warning(\"Can't detect initial thread stack location - bad conversion\");\n         stack_start = (uintptr_t) &rlim;\n      }\n    } else {\n      // For some reason we can't open /proc/self/stat (for example, running on\n      // FreeBSD with a Linux emulator, or inside chroot), this should work for\n      // most cases, so don't abort:\n      warning(\"Can't detect initial thread stack location - no /proc/self/stat\");\n      stack_start = (uintptr_t) &rlim;\n    }\n  }\n\n  // Now we have a pointer (stack_start) very close to the stack top, the\n  // next thing to do is to figure out the exact location of stack top. We\n  // can find out the virtual memory area that contains stack_start by\n  // reading /proc/self/maps, it should be the last vma in /proc/self/maps,\n  // and its upper limit is the real stack top. (again, this would fail if\n  // running inside chroot, because /proc may not exist.)\n\n  uintptr_t stack_top;\n  address low, high;\n  if (find_vma((address)stack_start, &low, &high)) {\n    // success, \"high\" is the true stack top. (ignore \"low\", because initial\n    // thread stack grows on demand, its real bottom is high - RLIMIT_STACK.)\n    stack_top = (uintptr_t)high;\n  } else {\n    // failed, likely because /proc/self/maps does not exist\n    warning(\"Can't detect initial thread stack location - find_vma failed\");\n    // best effort: stack_start is normally within a few pages below the real\n    // stack top, use it as stack top, and reduce stack size so we won't put\n    // guard page outside stack.\n    stack_top = stack_start;\n    stack_size -= 16 * page_size();\n  }\n\n  // stack_top could be partially down the page so align it\n  stack_top = align_size_up(stack_top, page_size());\n\n  // Allowed stack value is minimum of max_size and what we derived from rlimit\n  if (max_size > 0) {\n    _initial_thread_stack_size = MIN2(max_size, stack_size);\n  } else {\n    // Accept the rlimit max, but if stack is unlimited then it will be huge, so\n    // clamp it at 8MB as we do on Solaris\n    _initial_thread_stack_size = MIN2(stack_size, 8*M);\n  }\n\n  _initial_thread_stack_size = align_size_down(_initial_thread_stack_size, page_size());\n  _initial_thread_stack_bottom = (address)stack_top - _initial_thread_stack_size;\n  assert(_initial_thread_stack_bottom < (address)stack_top, \"overflow!\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// time support\n\n// Time since start-up in seconds to a fine granularity.\n// Used by VMSelfDestructTimer and the MemProfiler.\ndouble os::elapsedTime() {\n\n  return ((double)os::elapsed_counter()) / os::elapsed_frequency(); // nanosecond resolution\n}\n\njlong os::elapsed_counter() {\n  return javaTimeNanos() - initial_time_count;\n}\n\njlong os::elapsed_frequency() {\n  return NANOSECS_PER_SEC; // nanosecond resolution\n}\n\nbool os::supports_vtime() { return true; }\nbool os::enable_vtime()   { return false; }\nbool os::vtime_enabled()  { return false; }\n\ndouble os::elapsedVTime() {\n  struct rusage usage;\n  int retval = getrusage(RUSAGE_THREAD, &usage);\n  if (retval == 0) {\n    return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000 * 1000);\n  } else {\n    // better than nothing, but not much\n    return elapsedTime();\n  }\n}\n\njlong os::javaTimeMillis() {\n  timeval time;\n  int status = gettimeofday(&time, NULL);\n  assert(status != -1, \"linux error\");\n  return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);\n}\n\n#ifndef CLOCK_MONOTONIC\n#define CLOCK_MONOTONIC (1)\n#endif\n\nvoid os::Linux::clock_init() {\n  // we do dlopen's in this particular order due to bug in linux\n  // dynamical loader (see 6348968) leading to crash on exit\n  void* handle = dlopen(\"librt.so.1\", RTLD_LAZY);\n  if (handle == NULL) {\n    handle = dlopen(\"librt.so\", RTLD_LAZY);\n  }\n\n  if (handle) {\n    int (*clock_getres_func)(clockid_t, struct timespec*) =\n           (int(*)(clockid_t, struct timespec*))dlsym(handle, \"clock_getres\");\n    int (*clock_gettime_func)(clockid_t, struct timespec*) =\n           (int(*)(clockid_t, struct timespec*))dlsym(handle, \"clock_gettime\");\n    if (clock_getres_func && clock_gettime_func) {\n      // See if monotonic clock is supported by the kernel. Note that some\n      // early implementations simply return kernel jiffies (updated every\n      // 1/100 or 1/1000 second). It would be bad to use such a low res clock\n      // for nano time (though the monotonic property is still nice to have).\n      // It's fixed in newer kernels, however clock_getres() still returns\n      // 1/HZ. We check if clock_getres() works, but will ignore its reported\n      // resolution for now. Hopefully as people move to new kernels, this\n      // won't be a problem.\n      struct timespec res;\n      struct timespec tp;\n      if (clock_getres_func (CLOCK_MONOTONIC, &res) == 0 &&\n          clock_gettime_func(CLOCK_MONOTONIC, &tp)  == 0) {\n        // yes, monotonic clock is supported\n        _clock_gettime = clock_gettime_func;\n        return;\n      } else {\n        // close librt if there is no monotonic clock\n        dlclose(handle);\n      }\n    }\n  }\n  warning(\"No monotonic clock was available - timed services may \" \\\n          \"be adversely affected if the time-of-day clock changes\");\n}\n\n#ifndef SYS_clock_getres\n\n#if defined(IA32) || defined(AMD64) || defined(AARCH64)\n#ifdef BUILTIN_SIM\n#define SYS_clock_getres 229\n#else\n#define SYS_clock_getres IA32_ONLY(266)  AMD64_ONLY(229) AARCH64_ONLY(114)\n#endif\n#define sys_clock_getres(x,y)  ::syscall(SYS_clock_getres, x, y)\n#else\n#warning \"SYS_clock_getres not defined for this platform, disabling fast_thread_cpu_time\"\n#define sys_clock_getres(x,y)  -1\n#endif\n\n#else\n#define sys_clock_getres(x,y)  ::syscall(SYS_clock_getres, x, y)\n#endif\n\nvoid os::Linux::fast_thread_clock_init() {\n  if (!UseLinuxPosixThreadCPUClocks) {\n    return;\n  }\n  clockid_t clockid;\n  struct timespec tp;\n  int (*pthread_getcpuclockid_func)(pthread_t, clockid_t *) =\n      (int(*)(pthread_t, clockid_t *)) dlsym(RTLD_DEFAULT, \"pthread_getcpuclockid\");\n\n  // Switch to using fast clocks for thread cpu time if\n  // the sys_clock_getres() returns 0 error code.\n  // Note, that some kernels may support the current thread\n  // clock (CLOCK_THREAD_CPUTIME_ID) but not the clocks\n  // returned by the pthread_getcpuclockid().\n  // If the fast Posix clocks are supported then the sys_clock_getres()\n  // must return at least tp.tv_sec == 0 which means a resolution\n  // better than 1 sec. This is extra check for reliability.\n\n  if(pthread_getcpuclockid_func &&\n     pthread_getcpuclockid_func(_main_thread, &clockid) == 0 &&\n     sys_clock_getres(clockid, &tp) == 0 && tp.tv_sec == 0) {\n\n    _supports_fast_thread_cpu_time = true;\n    _pthread_getcpuclockid = pthread_getcpuclockid_func;\n  }\n}\n\njlong os::javaTimeNanos() {\n  if (Linux::supports_monotonic_clock()) {\n    struct timespec tp;\n    int status = Linux::clock_gettime(CLOCK_MONOTONIC, &tp);\n    assert(status == 0, \"gettime error\");\n    jlong result = jlong(tp.tv_sec) * (1000 * 1000 * 1000) + jlong(tp.tv_nsec);\n    return result;\n  } else {\n    timeval time;\n    int status = gettimeofday(&time, NULL);\n    assert(status != -1, \"linux error\");\n    jlong usecs = jlong(time.tv_sec) * (1000 * 1000) + jlong(time.tv_usec);\n    return 1000 * usecs;\n  }\n}\n\nvoid os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n  if (Linux::supports_monotonic_clock()) {\n    info_ptr->max_value = ALL_64_BITS;\n\n    // CLOCK_MONOTONIC - amount of time since some arbitrary point in the past\n    info_ptr->may_skip_backward = false;      // not subject to resetting or drifting\n    info_ptr->may_skip_forward = false;       // not subject to resetting or drifting\n  } else {\n    // gettimeofday - based on time in seconds since the Epoch thus does not wrap\n    info_ptr->max_value = ALL_64_BITS;\n\n    // gettimeofday is a real time clock so it skips\n    info_ptr->may_skip_backward = true;\n    info_ptr->may_skip_forward = true;\n  }\n\n  info_ptr->kind = JVMTI_TIMER_ELAPSED;                // elapsed not CPU time\n}\n\n// Return the real, user, and system times in seconds from an\n// arbitrary fixed point in the past.\nbool os::getTimesSecs(double* process_real_time,\n                      double* process_user_time,\n                      double* process_system_time) {\n  struct tms ticks;\n  clock_t real_ticks = times(&ticks);\n\n  if (real_ticks == (clock_t) (-1)) {\n    return false;\n  } else {\n    double ticks_per_second = (double) clock_tics_per_sec;\n    *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;\n    *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;\n    *process_real_time = ((double) real_ticks) / ticks_per_second;\n\n    return true;\n  }\n}\n\n\nchar * os::local_time_string(char *buf, size_t buflen) {\n  struct tm t;\n  time_t long_time;\n  time(&long_time);\n  localtime_r(&long_time, &t);\n  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n               t.tm_hour, t.tm_min, t.tm_sec);\n  return buf;\n}\n\nstruct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {\n  return localtime_r(clock, res);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// runtime exit support\n\n// Note: os::shutdown() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::shutdown(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::shutdown() {\n\n  // allow PerfMemory to attempt cleanup of any persistent resources\n  perfMemory_exit();\n\n  // needs to remove object in file system\n  AttachListener::abort();\n\n  // flush buffered output, finish log files\n  ostream_abort();\n\n  // Check for abort hook\n  abort_hook_t abort_hook = Arguments::abort_hook();\n  if (abort_hook != NULL) {\n    abort_hook();\n  }\n\n}\n\n// Note: os::abort() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::abort(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::abort(bool dump_core) {\n  os::shutdown();\n  if (dump_core) {\n#ifndef PRODUCT\n    fdStream out(defaultStream::output_fd());\n    out.print_raw(\"Current thread is \");\n    char buf[16];\n    jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());\n    out.print_raw_cr(buf);\n    out.print_raw_cr(\"Dumping core ...\");\n#endif\n    ::abort(); // dump core\n  }\n\n  ::exit(1);\n}\n\n// Die immediately, no exit hook, no abort hook, no cleanup.\nvoid os::die() {\n  // _exit() on LinuxThreads only kills current thread\n  ::abort();\n}\n\n\n// This method is a copy of JDK's sysGetLastErrorString\n// from src/solaris/hpi/src/system_md.c\n\nsize_t os::lasterror(char *buf, size_t len) {\n\n  if (errno == 0)  return 0;\n\n  const char *s = ::strerror(errno);\n  size_t n = ::strlen(s);\n  if (n >= len) {\n    n = len - 1;\n  }\n  ::strncpy(buf, s, n);\n  buf[n] = '\\0';\n  return n;\n}\n\nintx os::current_thread_id() { return (intx)pthread_self(); }\nint os::current_process_id() {\n\n  // Under the old linux thread library, linux gives each thread\n  // its own process id. Because of this each thread will return\n  // a different pid if this method were to return the result\n  // of getpid(2). Linux provides no api that returns the pid\n  // of the launcher thread for the vm. This implementation\n  // returns a unique pid, the pid of the launcher thread\n  // that starts the vm 'process'.\n\n  // Under the NPTL, getpid() returns the same pid as the\n  // launcher thread rather than a unique pid per thread.\n  // Use gettid() if you want the old pre NPTL behaviour.\n\n  // if you are looking for the result of a call to getpid() that\n  // returns a unique pid for the calling thread, then look at the\n  // OSThread::thread_id() method in osThread_linux.hpp file\n\n  return (int)(_initial_pid ? _initial_pid : getpid());\n}\n\n// DLL functions\n\nconst char* os::dll_file_extension() { return \".so\"; }\n\n// This must be hard coded because it's the system's temporary\n// directory not the java application's temp directory, ala java.io.tmpdir.\nconst char* os::get_temp_directory() { return \"/tmp\"; }\n\nstatic bool file_exists(const char* filename) {\n  struct stat statbuf;\n  if (filename == NULL || strlen(filename) == 0) {\n    return false;\n  }\n  return os::stat(filename, &statbuf) == 0;\n}\n\nbool os::dll_build_name(char* buffer, size_t buflen,\n                        const char* pname, const char* fname) {\n  bool retval = false;\n  // Copied from libhpi\n  const size_t pnamelen = pname ? strlen(pname) : 0;\n\n  // Return error on buffer overflow.\n  if (pnamelen + strlen(fname) + 10 > (size_t) buflen) {\n    return retval;\n  }\n\n  if (pnamelen == 0) {\n    snprintf(buffer, buflen, \"lib%s.so\", fname);\n    retval = true;\n  } else if (strchr(pname, *os::path_separator()) != NULL) {\n    int n;\n    char** pelements = split_path(pname, &n);\n    if (pelements == NULL) {\n      return false;\n    }\n    for (int i = 0 ; i < n ; i++) {\n      // Really shouldn't be NULL, but check can't hurt\n      if (pelements[i] == NULL || strlen(pelements[i]) == 0) {\n        continue; // skip the empty path values\n      }\n      snprintf(buffer, buflen, \"%s/lib%s.so\", pelements[i], fname);\n      if (file_exists(buffer)) {\n        retval = true;\n        break;\n      }\n    }\n    // release the storage\n    for (int i = 0 ; i < n ; i++) {\n      if (pelements[i] != NULL) {\n        FREE_C_HEAP_ARRAY(char, pelements[i], mtInternal);\n      }\n    }\n    if (pelements != NULL) {\n      FREE_C_HEAP_ARRAY(char*, pelements, mtInternal);\n    }\n  } else {\n    snprintf(buffer, buflen, \"%s/lib%s.so\", pname, fname);\n    retval = true;\n  }\n  return retval;\n}\n\n// check if addr is inside libjvm.so\nbool os::address_is_in_vm(address addr) {\n  static address libjvm_base_addr;\n  Dl_info dlinfo;\n\n  if (libjvm_base_addr == NULL) {\n    if (dladdr(CAST_FROM_FN_PTR(void *, os::address_is_in_vm), &dlinfo) != 0) {\n      libjvm_base_addr = (address)dlinfo.dli_fbase;\n    }\n    assert(libjvm_base_addr !=NULL, \"Cannot obtain base address for libjvm\");\n  }\n\n  if (dladdr((void *)addr, &dlinfo) != 0) {\n    if (libjvm_base_addr == (address)dlinfo.dli_fbase) return true;\n  }\n\n  return false;\n}\n\nbool os::dll_address_to_function_name(address addr, char *buf,\n                                      int buflen, int *offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n\n  if (dladdr((void*)addr, &dlinfo) != 0) {\n    // see if we have a matching symbol\n    if (dlinfo.dli_saddr != NULL && dlinfo.dli_sname != NULL) {\n      if (!Decoder::demangle(dlinfo.dli_sname, buf, buflen)) {\n        jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_sname);\n      }\n      if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;\n      return true;\n    }\n    // no matching symbol so try for just file info\n    if (dlinfo.dli_fname != NULL && dlinfo.dli_fbase != NULL) {\n      if (Decoder::decode((address)(addr - (address)dlinfo.dli_fbase),\n                          buf, buflen, offset, dlinfo.dli_fname)) {\n        return true;\n      }\n    }\n  }\n\n  buf[0] = '\\0';\n  if (offset != NULL) *offset = -1;\n  return false;\n}\n\nstruct _address_to_library_name {\n  address addr;          // input : memory address\n  size_t  buflen;        //         size of fname\n  char*   fname;         // output: library name\n  address base;          //         library base addr\n};\n\nstatic int address_to_library_name_callback(struct dl_phdr_info *info,\n                                            size_t size, void *data) {\n  int i;\n  bool found = false;\n  address libbase = NULL;\n  struct _address_to_library_name * d = (struct _address_to_library_name *)data;\n\n  // iterate through all loadable segments\n  for (i = 0; i < info->dlpi_phnum; i++) {\n    address segbase = (address)(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);\n    if (info->dlpi_phdr[i].p_type == PT_LOAD) {\n      // base address of a library is the lowest address of its loaded\n      // segments.\n      if (libbase == NULL || libbase > segbase) {\n        libbase = segbase;\n      }\n      // see if 'addr' is within current segment\n      if (segbase <= d->addr &&\n          d->addr < segbase + info->dlpi_phdr[i].p_memsz) {\n        found = true;\n      }\n    }\n  }\n\n  // dlpi_name is NULL or empty if the ELF file is executable, return 0\n  // so dll_address_to_library_name() can fall through to use dladdr() which\n  // can figure out executable name from argv[0].\n  if (found && info->dlpi_name && info->dlpi_name[0]) {\n    d->base = libbase;\n    if (d->fname) {\n      jio_snprintf(d->fname, d->buflen, \"%s\", info->dlpi_name);\n    }\n    return 1;\n  }\n  return 0;\n}\n\nbool os::dll_address_to_library_name(address addr, char* buf,\n                                     int buflen, int* offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n  struct _address_to_library_name data;\n\n  // There is a bug in old glibc dladdr() implementation that it could resolve\n  // to wrong library name if the .so file has a base address != NULL. Here\n  // we iterate through the program headers of all loaded libraries to find\n  // out which library 'addr' really belongs to. This workaround can be\n  // removed once the minimum requirement for glibc is moved to 2.3.x.\n  data.addr = addr;\n  data.fname = buf;\n  data.buflen = buflen;\n  data.base = NULL;\n  int rslt = dl_iterate_phdr(address_to_library_name_callback, (void *)&data);\n\n  if (rslt) {\n     // buf already contains library name\n     if (offset) *offset = addr - data.base;\n     return true;\n  }\n  if (dladdr((void*)addr, &dlinfo) != 0) {\n    if (dlinfo.dli_fname != NULL) {\n      jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL && offset != NULL) {\n      *offset = addr - (address)dlinfo.dli_fbase;\n    }\n    return true;\n  }\n\n  buf[0] = '\\0';\n  if (offset) *offset = -1;\n  return false;\n}\n\n  // Loads .dll/.so and\n  // in case of error it checks if .dll/.so was built for the\n  // same architecture as Hotspot is running on\n\n\n// Remember the stack's state. The Linux dynamic linker will change\n// the stack to 'executable' at most once, so we must safepoint only once.\nbool os::Linux::_stack_is_executable = false;\n\n// VM operation that loads a library.  This is necessary if stack protection\n// of the Java stacks can be lost during loading the library.  If we\n// do not stop the Java threads, they can stack overflow before the stacks\n// are protected again.\nclass VM_LinuxDllLoad: public VM_Operation {\n private:\n  const char *_filename;\n  char *_ebuf;\n  int _ebuflen;\n  void *_lib;\n public:\n  VM_LinuxDllLoad(const char *fn, char *ebuf, int ebuflen) :\n    _filename(fn), _ebuf(ebuf), _ebuflen(ebuflen), _lib(NULL) {}\n  VMOp_Type type() const { return VMOp_LinuxDllLoad; }\n  void doit() {\n    _lib = os::Linux::dll_load_in_vmthread(_filename, _ebuf, _ebuflen);\n    os::Linux::_stack_is_executable = true;\n  }\n  void* loaded_library() { return _lib; }\n};\n\nvoid * os::dll_load(const char *filename, char *ebuf, int ebuflen)\n{\n  void * result = NULL;\n  bool load_attempted = false;\n\n  // Check whether the library to load might change execution rights\n  // of the stack. If they are changed, the protection of the stack\n  // guard pages will be lost. We need a safepoint to fix this.\n  //\n  // See Linux man page execstack(8) for more info.\n  if (os::uses_stack_guard_pages() && !os::Linux::_stack_is_executable) {\n    ElfFile ef(filename);\n    if (!ef.specifies_noexecstack()) {\n      if (!is_init_completed()) {\n        os::Linux::_stack_is_executable = true;\n        // This is OK - No Java threads have been created yet, and hence no\n        // stack guard pages to fix.\n        //\n        // This should happen only when you are building JDK7 using a very\n        // old version of JDK6 (e.g., with JPRT) and running test_gamma.\n        //\n        // Dynamic loader will make all stacks executable after\n        // this function returns, and will not do that again.\n        assert(Threads::first() == NULL, \"no Java threads should exist yet.\");\n      } else {\n        warning(\"You have loaded library %s which might have disabled stack guard. \"\n                \"The VM will try to fix the stack guard now.\\n\"\n                \"It's highly recommended that you fix the library with \"\n                \"'execstack -c <libfile>', or link it with '-z noexecstack'.\",\n                filename);\n\n        assert(Thread::current()->is_Java_thread(), \"must be Java thread\");\n        JavaThread *jt = JavaThread::current();\n        if (jt->thread_state() != _thread_in_native) {\n          // This happens when a compiler thread tries to load a hsdis-<arch>.so file\n          // that requires ExecStack. Cannot enter safe point. Let's give up.\n          warning(\"Unable to fix stack guard. Giving up.\");\n        } else {\n          if (!LoadExecStackDllInVMThread) {\n            // This is for the case where the DLL has an static\n            // constructor function that executes JNI code. We cannot\n            // load such DLLs in the VMThread.\n            result = os::Linux::dlopen_helper(filename, ebuf, ebuflen);\n          }\n\n          ThreadInVMfromNative tiv(jt);\n          debug_only(VMNativeEntryWrapper vew;)\n\n          VM_LinuxDllLoad op(filename, ebuf, ebuflen);\n          VMThread::execute(&op);\n          if (LoadExecStackDllInVMThread) {\n            result = op.loaded_library();\n          }\n          load_attempted = true;\n        }\n      }\n    }\n  }\n\n  if (!load_attempted) {\n    result = os::Linux::dlopen_helper(filename, ebuf, ebuflen);\n  }\n\n  if (result != NULL) {\n    // Successful loading\n    return result;\n  }\n\n  Elf32_Ehdr elf_head;\n  int diag_msg_max_length=ebuflen-strlen(ebuf);\n  char* diag_msg_buf=ebuf+strlen(ebuf);\n\n  if (diag_msg_max_length==0) {\n    // No more space in ebuf for additional diagnostics message\n    return NULL;\n  }\n\n\n  int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);\n\n  if (file_descriptor < 0) {\n    // Can't open library, report dlerror() message\n    return NULL;\n  }\n\n  bool failed_to_read_elf_head=\n    (sizeof(elf_head)!=\n        (::read(file_descriptor, &elf_head,sizeof(elf_head)))) ;\n\n  ::close(file_descriptor);\n  if (failed_to_read_elf_head) {\n    // file i/o error - report dlerror() msg\n    return NULL;\n  }\n\n  typedef struct {\n    Elf32_Half  code;         // Actual value as defined in elf.h\n    Elf32_Half  compat_class; // Compatibility of archs at VM's sense\n    char        elf_class;    // 32 or 64 bit\n    char        endianess;    // MSB or LSB\n    char*       name;         // String representation\n  } arch_t;\n\n  #ifndef EM_486\n  #define EM_486          6               /* Intel 80486 */\n  #endif\n\n  #ifndef EM_AARCH64\n  #define EM_AARCH64\t183\n  #endif\n\n  static const arch_t arch_array[]={\n    {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)\"IA 64\"},\n    {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)\"AMD 64\"},\n    {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)\"Sparc v9 64\"},\n    {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)\"Power PC 32\"},\n#if defined(VM_LITTLE_ENDIAN)\n    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2LSB, (char*)\"Power PC 64\"},\n#else\n    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)\"Power PC 64\"},\n#endif\n    {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)\"ARM\"},\n    {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)\"IBM System/390\"},\n    {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)\"Alpha\"},\n    {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)\"MIPSel\"},\n    {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)\"MIPS\"},\n    {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)\"PARISC\"},\n    {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)\"M68k\"},\n    {EM_AARCH64,     EM_AARCH64, ELFCLASS64, ELFDATA2LSB, (char*)\"AARCH64\"},\n  };\n\n  #if  (defined IA32)\n    static  Elf32_Half running_arch_code=EM_386;\n  #elif   (defined AMD64)\n    static  Elf32_Half running_arch_code=EM_X86_64;\n  #elif  (defined IA64)\n    static  Elf32_Half running_arch_code=EM_IA_64;\n  #elif  (defined __sparc) && (defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARCV9;\n  #elif  (defined __sparc) && (!defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARC;\n  #elif  (defined __powerpc64__)\n    static  Elf32_Half running_arch_code=EM_PPC64;\n  #elif  (defined __powerpc__)\n    static  Elf32_Half running_arch_code=EM_PPC;\n  #elif  (defined ARM)\n    static  Elf32_Half running_arch_code=EM_ARM;\n  #elif  (defined S390)\n    static  Elf32_Half running_arch_code=EM_S390;\n  #elif  (defined ALPHA)\n    static  Elf32_Half running_arch_code=EM_ALPHA;\n  #elif  (defined MIPSEL)\n    static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;\n  #elif  (defined PARISC)\n    static  Elf32_Half running_arch_code=EM_PARISC;\n  #elif  (defined MIPS)\n    static  Elf32_Half running_arch_code=EM_MIPS;\n  #elif  (defined M68K)\n    static  Elf32_Half running_arch_code=EM_68K;\n  #elif  (defined AARCH64)\n    static  Elf32_Half running_arch_code=EM_AARCH64;\n  #else\n    #error Method os::dll_load requires that one of following is defined:\\\n      IA32, AMD64, IA64, __sparc, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K, AARCH64\n  #endif\n\n  // Identify compatability class for VM's architecture and library's architecture\n  // Obtain string descriptions for architectures\n\n  arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};\n  int running_arch_index=-1;\n\n  for (unsigned int i=0 ; i < ARRAY_SIZE(arch_array) ; i++ ) {\n    if (running_arch_code == arch_array[i].code) {\n      running_arch_index    = i;\n    }\n    if (lib_arch.code == arch_array[i].code) {\n      lib_arch.compat_class = arch_array[i].compat_class;\n      lib_arch.name         = arch_array[i].name;\n    }\n  }\n\n  assert(running_arch_index != -1,\n    \"Didn't find running architecture code (running_arch_code) in arch_array\");\n  if (running_arch_index == -1) {\n    // Even though running architecture detection failed\n    // we may still continue with reporting dlerror() message\n    return NULL;\n  }\n\n  if (lib_arch.endianess != arch_array[running_arch_index].endianess) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n    return NULL;\n  }\n\n#ifndef S390\n  if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n    return NULL;\n  }\n#endif // !S390\n\n  if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {\n    if ( lib_arch.name!=NULL ) {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n        \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n        lib_arch.name, arch_array[running_arch_index].name);\n    } else {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n      \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n        lib_arch.code,\n        arch_array[running_arch_index].name);\n    }\n  }\n\n  return NULL;\n}\n\nvoid * os::Linux::dlopen_helper(const char *filename, char *ebuf, int ebuflen) {\n  void * result = ::dlopen(filename, RTLD_LAZY);\n  if (result == NULL) {\n    ::strncpy(ebuf, ::dlerror(), ebuflen - 1);\n    ebuf[ebuflen-1] = '\\0';\n  }\n  return result;\n}\n\nvoid * os::Linux::dll_load_in_vmthread(const char *filename, char *ebuf, int ebuflen) {\n  void * result = NULL;\n  if (LoadExecStackDllInVMThread) {\n    result = dlopen_helper(filename, ebuf, ebuflen);\n  }\n\n  // Since 7019808, libjvm.so is linked with -noexecstack. If the VM loads a\n  // library that requires an executable stack, or which does not have this\n  // stack attribute set, dlopen changes the stack attribute to executable. The\n  // read protection of the guard pages gets lost.\n  //\n  // Need to check _stack_is_executable again as multiple VM_LinuxDllLoad\n  // may have been queued at the same time.\n\n  if (!_stack_is_executable) {\n    JavaThread *jt = Threads::first();\n\n    while (jt) {\n      if (!jt->stack_guard_zone_unused() &&        // Stack not yet fully initialized\n          jt->stack_yellow_zone_enabled()) {       // No pending stack overflow exceptions\n        if (!os::guard_memory((char *) jt->stack_red_zone_base() - jt->stack_red_zone_size(),\n                              jt->stack_yellow_zone_size() + jt->stack_red_zone_size())) {\n          warning(\"Attempt to reguard stack yellow zone failed.\");\n        }\n      }\n      jt = jt->next();\n    }\n  }\n\n  return result;\n}\n\n/*\n * glibc-2.0 libdl is not MT safe.  If you are building with any glibc,\n * chances are you might want to run the generated bits against glibc-2.0\n * libdl.so, so always use locking for any version of glibc.\n */\nvoid* os::dll_lookup(void* handle, const char* name) {\n  pthread_mutex_lock(&dl_mutex);\n  void* res = dlsym(handle, name);\n  pthread_mutex_unlock(&dl_mutex);\n  return res;\n}\n\nvoid* os::get_default_process_handle() {\n  return (void*)::dlopen(NULL, RTLD_LAZY);\n}\n\nstatic bool _print_ascii_file(const char* filename, outputStream* st) {\n  int fd = ::open(filename, O_RDONLY);\n  if (fd == -1) {\n     return false;\n  }\n\n  char buf[32];\n  int bytes;\n  while ((bytes = ::read(fd, buf, sizeof(buf))) > 0) {\n    st->print_raw(buf, bytes);\n  }\n\n  ::close(fd);\n\n  return true;\n}\n\nvoid os::print_dll_info(outputStream *st) {\n   st->print_cr(\"Dynamic libraries:\");\n\n   char fname[32];\n   pid_t pid = os::Linux::gettid();\n\n   jio_snprintf(fname, sizeof(fname), \"/proc/%d/maps\", pid);\n\n   if (!_print_ascii_file(fname, st)) {\n     st->print(\"Can not get library information for pid = %d\\n\", pid);\n   }\n}\n\nvoid os::print_os_info_brief(outputStream* st) {\n  os::Linux::print_distro_info(st);\n\n  os::Posix::print_uname_info(st);\n\n  os::Linux::print_libversion_info(st);\n\n}\n\nvoid os::print_os_info(outputStream* st) {\n  st->print(\"OS:\");\n\n  os::Linux::print_distro_info(st);\n\n  os::Posix::print_uname_info(st);\n\n  // Print warning if unsafe chroot environment detected\n  if (unsafe_chroot_detected) {\n    st->print(\"WARNING!! \");\n    st->print_cr(\"%s\", unstable_chroot_error);\n  }\n\n  os::Linux::print_libversion_info(st);\n\n  os::Posix::print_rlimit_info(st);\n\n  os::Posix::print_load_average(st);\n\n  os::Linux::print_full_memory_info(st);\n}\n\n// Try to identify popular distros.\n// Most Linux distributions have a /etc/XXX-release file, which contains\n// the OS version string. Newer Linux distributions have a /etc/lsb-release\n// file that also contains the OS version string. Some have more than one\n// /etc/XXX-release file (e.g. Mandrake has both /etc/mandrake-release and\n// /etc/redhat-release.), so the order is important.\n// Any Linux that is based on Redhat (i.e. Oracle, Mandrake, Sun JDS...) have\n// their own specific XXX-release file as well as a redhat-release file.\n// Because of this the XXX-release file needs to be searched for before the\n// redhat-release file.\n// Since Red Hat has a lsb-release file that is not very descriptive the\n// search for redhat-release needs to be before lsb-release.\n// Since the lsb-release file is the new standard it needs to be searched\n// before the older style release files.\n// Searching system-release (Red Hat) and os-release (other Linuxes) are a\n// next to last resort.  The os-release file is a new standard that contains\n// distribution information and the system-release file seems to be an old\n// standard that has been replaced by the lsb-release and os-release files.\n// Searching for the debian_version file is the last resort.  It contains\n// an informative string like \"6.0.6\" or \"wheezy/sid\". Because of this\n// \"Debian \" is printed before the contents of the debian_version file.\nvoid os::Linux::print_distro_info(outputStream* st) {\n   if (!_print_ascii_file(\"/etc/oracle-release\", st) &&\n       !_print_ascii_file(\"/etc/mandriva-release\", st) &&\n       !_print_ascii_file(\"/etc/mandrake-release\", st) &&\n       !_print_ascii_file(\"/etc/sun-release\", st) &&\n       !_print_ascii_file(\"/etc/redhat-release\", st) &&\n       !_print_ascii_file(\"/etc/lsb-release\", st) &&\n       !_print_ascii_file(\"/etc/SuSE-release\", st) &&\n       !_print_ascii_file(\"/etc/turbolinux-release\", st) &&\n       !_print_ascii_file(\"/etc/gentoo-release\", st) &&\n       !_print_ascii_file(\"/etc/ltib-release\", st) &&\n       !_print_ascii_file(\"/etc/angstrom-version\", st) &&\n       !_print_ascii_file(\"/etc/system-release\", st) &&\n       !_print_ascii_file(\"/etc/os-release\", st)) {\n\n       if (file_exists(\"/etc/debian_version\")) {\n         st->print(\"Debian \");\n         _print_ascii_file(\"/etc/debian_version\", st);\n       } else {\n         st->print(\"Linux\");\n       }\n   }\n   st->cr();\n}\n\nvoid os::Linux::print_libversion_info(outputStream* st) {\n  // libc, pthread\n  st->print(\"libc:\");\n  st->print(\"%s \", os::Linux::glibc_version());\n  st->print(\"%s \", os::Linux::libpthread_version());\n  if (os::Linux::is_LinuxThreads()) {\n     st->print(\"(%s stack)\", os::Linux::is_floating_stack() ? \"floating\" : \"fixed\");\n  }\n  st->cr();\n}\n\nvoid os::Linux::print_full_memory_info(outputStream* st) {\n   st->print(\"\\n/proc/meminfo:\\n\");\n   _print_ascii_file(\"/proc/meminfo\", st);\n   st->cr();\n}\n\nvoid os::print_memory_info(outputStream* st) {\n\n  st->print(\"Memory:\");\n  st->print(\" %dk page\", os::vm_page_size()>>10);\n\n  // values in struct sysinfo are \"unsigned long\"\n  struct sysinfo si;\n  sysinfo(&si);\n\n  st->print(\", physical \" UINT64_FORMAT \"k\",\n            os::physical_memory() >> 10);\n  st->print(\"(\" UINT64_FORMAT \"k free)\",\n            os::available_memory() >> 10);\n  st->print(\", swap \" UINT64_FORMAT \"k\",\n            ((jlong)si.totalswap * si.mem_unit) >> 10);\n  st->print(\"(\" UINT64_FORMAT \"k free)\",\n            ((jlong)si.freeswap * si.mem_unit) >> 10);\n  st->cr();\n}\n\nvoid os::pd_print_cpu_info(outputStream* st) {\n  st->print(\"\\n/proc/cpuinfo:\\n\");\n  if (!_print_ascii_file(\"/proc/cpuinfo\", st)) {\n    st->print(\"  <Not Available>\");\n  }\n  st->cr();\n}\n\nvoid os::print_siginfo(outputStream* st, void* siginfo) {\n  const siginfo_t* si = (const siginfo_t*)siginfo;\n\n  os::Posix::print_siginfo_brief(st, si);\n#if INCLUDE_CDS\n  if (si && (si->si_signo == SIGBUS || si->si_signo == SIGSEGV) &&\n      UseSharedSpaces) {\n    FileMapInfo* mapinfo = FileMapInfo::current_info();\n    if (mapinfo->is_in_shared_space(si->si_addr)) {\n      st->print(\"\\n\\nError accessing class data sharing archive.\"   \\\n                \" Mapped file inaccessible during execution, \"      \\\n                \" possible disk/network problem.\");\n    }\n  }\n#endif\n  st->cr();\n}\n\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen);\n\nvoid os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n  st->print_cr(\"Signal Handlers:\");\n  print_signal_handler(st, SIGSEGV, buf, buflen);\n  print_signal_handler(st, SIGBUS , buf, buflen);\n  print_signal_handler(st, SIGFPE , buf, buflen);\n  print_signal_handler(st, SIGPIPE, buf, buflen);\n  print_signal_handler(st, SIGXFSZ, buf, buflen);\n  print_signal_handler(st, SIGILL , buf, buflen);\n  print_signal_handler(st, INTERRUPT_SIGNAL, buf, buflen);\n  print_signal_handler(st, SR_signum, buf, buflen);\n  print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n  print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n#if defined(PPC64)\n  print_signal_handler(st, SIGTRAP, buf, buflen);\n#endif\n}\n\nstatic char saved_jvm_path[MAXPATHLEN] = {0};\n\n// Find the full path to the current module, libjvm.so\nvoid os::jvm_path(char *buf, jint buflen) {\n  // Error checking.\n  if (buflen < MAXPATHLEN) {\n    assert(false, \"must use a large-enough buffer\");\n    buf[0] = '\\0';\n    return;\n  }\n  // Lazy resolve the path to current module.\n  if (saved_jvm_path[0] != 0) {\n    strcpy(buf, saved_jvm_path);\n    return;\n  }\n\n  char dli_fname[MAXPATHLEN];\n  bool ret = dll_address_to_library_name(\n                CAST_FROM_FN_PTR(address, os::jvm_path),\n                dli_fname, sizeof(dli_fname), NULL);\n  assert(ret, \"cannot locate libjvm\");\n  char *rp = NULL;\n  if (ret && dli_fname[0] != '\\0') {\n    rp = realpath(dli_fname, buf);\n  }\n  if (rp == NULL)\n    return;\n\n  if (Arguments::created_by_gamma_launcher()) {\n    // Support for the gamma launcher.  Typical value for buf is\n    // \"<JAVA_HOME>/jre/lib/<arch>/<vmtype>/libjvm.so\".  If \"/jre/lib/\" appears at\n    // the right place in the string, then assume we are installed in a JDK and\n    // we're done.  Otherwise, check for a JAVA_HOME environment variable and fix\n    // up the path so it looks like libjvm.so is installed there (append a\n    // fake suffix hotspot/libjvm.so).\n    const char *p = buf + strlen(buf) - 1;\n    for (int count = 0; p > buf && count < 5; ++count) {\n      for (--p; p > buf && *p != '/'; --p)\n        /* empty */ ;\n    }\n\n    if (strncmp(p, \"/jre/lib/\", 9) != 0) {\n      // Look for JAVA_HOME in the environment.\n      char* java_home_var = ::getenv(\"JAVA_HOME\");\n      if (java_home_var != NULL && java_home_var[0] != 0) {\n        char* jrelib_p;\n        int len;\n\n        // Check the current module name \"libjvm.so\".\n        p = strrchr(buf, '/');\n        assert(strstr(p, \"/libjvm\") == p, \"invalid library name\");\n\n        rp = realpath(java_home_var, buf);\n        if (rp == NULL)\n          return;\n\n        // determine if this is a legacy image or modules image\n        // modules image doesn't have \"jre\" subdirectory\n        len = strlen(buf);\n        assert(len < buflen, \"Ran out of buffer room\");\n        jrelib_p = buf + len;\n        snprintf(jrelib_p, buflen-len, \"/jre/lib/%s\", cpu_arch);\n        if (0 != access(buf, F_OK)) {\n          snprintf(jrelib_p, buflen-len, \"/lib/%s\", cpu_arch);\n        }\n\n        if (0 == access(buf, F_OK)) {\n          // Use current module name \"libjvm.so\"\n          len = strlen(buf);\n          snprintf(buf + len, buflen-len, \"/hotspot/libjvm.so\");\n        } else {\n          // Go back to path of .so\n          rp = realpath(dli_fname, buf);\n          if (rp == NULL)\n            return;\n        }\n      }\n    }\n  }\n\n  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n}\n\nvoid os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n  // no prefix required, not even \"_\"\n}\n\nvoid os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n  // no suffix required\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// sun.misc.Signal support\n\nstatic volatile jint sigint_count = 0;\n\nstatic void\nUserHandler(int sig, void *siginfo, void *context) {\n  // 4511530 - sem_post is serialized and handled by the manager thread. When\n  // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We\n  // don't want to flood the manager thread with sem_post requests.\n  if (sig == SIGINT && Atomic::add(1, &sigint_count) > 1)\n      return;\n\n  // Ctrl-C is pressed during error reporting, likely because the error\n  // handler fails to abort. Let VM die immediately.\n  if (sig == SIGINT && is_error_reported()) {\n     os::die();\n  }\n\n  os::signal_notify(sig);\n}\n\nvoid* os::user_handler() {\n  return CAST_FROM_FN_PTR(void*, UserHandler);\n}\n\nclass Semaphore : public StackObj {\n  public:\n    Semaphore();\n    ~Semaphore();\n    void signal();\n    void wait();\n    bool trywait();\n    bool timedwait(unsigned int sec, int nsec);\n  private:\n    sem_t _semaphore;\n};\n\nSemaphore::Semaphore() {\n  sem_init(&_semaphore, 0, 0);\n}\n\nSemaphore::~Semaphore() {\n  sem_destroy(&_semaphore);\n}\n\nvoid Semaphore::signal() {\n  sem_post(&_semaphore);\n}\n\nvoid Semaphore::wait() {\n  sem_wait(&_semaphore);\n}\n\nbool Semaphore::trywait() {\n  return sem_trywait(&_semaphore) == 0;\n}\n\nbool Semaphore::timedwait(unsigned int sec, int nsec) {\n\n  struct timespec ts;\n  // Semaphore's are always associated with CLOCK_REALTIME\n  os::Linux::clock_gettime(CLOCK_REALTIME, &ts);\n  // see unpackTime for discussion on overflow checking\n  if (sec >= MAX_SECS) {\n    ts.tv_sec += MAX_SECS;\n    ts.tv_nsec = 0;\n  } else {\n    ts.tv_sec += sec;\n    ts.tv_nsec += nsec;\n    if (ts.tv_nsec >= NANOSECS_PER_SEC) {\n      ts.tv_nsec -= NANOSECS_PER_SEC;\n      ++ts.tv_sec; // note: this must be <= max_secs\n    }\n  }\n\n  while (1) {\n    int result = sem_timedwait(&_semaphore, &ts);\n    if (result == 0) {\n      return true;\n    } else if (errno == EINTR) {\n      continue;\n    } else if (errno == ETIMEDOUT) {\n      return false;\n    } else {\n      return false;\n    }\n  }\n}\n\nextern \"C\" {\n  typedef void (*sa_handler_t)(int);\n  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n}\n\nvoid* os::signal(int signal_number, void* handler) {\n  struct sigaction sigAct, oldSigAct;\n\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n\n  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n    // -1 means registration failed\n    return (void *)-1;\n  }\n\n  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n}\n\nvoid os::signal_raise(int signal_number) {\n  ::raise(signal_number);\n}\n\n/*\n * The following code is moved from os.cpp for making this\n * code platform specific, which it is by its very nature.\n */\n\n// Will be modified when max signal is changed to be dynamic\nint os::sigexitnum_pd() {\n  return NSIG;\n}\n\n// a counter for each possible signal value\nstatic volatile jint pending_signals[NSIG+1] = { 0 };\n\n// Linux(POSIX) specific hand shaking semaphore.\nstatic sem_t sig_sem;\nstatic Semaphore sr_semaphore;\n\nvoid os::signal_init_pd() {\n  // Initialize signal structures\n  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n\n  // Initialize signal semaphore\n  ::sem_init(&sig_sem, 0, 0);\n}\n\nvoid os::signal_notify(int sig) {\n  Atomic::inc(&pending_signals[sig]);\n  ::sem_post(&sig_sem);\n}\n\nstatic int check_pending_signals(bool wait) {\n  Atomic::store(0, &sigint_count);\n  for (;;) {\n    for (int i = 0; i < NSIG + 1; i++) {\n      jint n = pending_signals[i];\n      if (n > 0 && n == Atomic::cmpxchg(n - 1, &pending_signals[i], n)) {\n        return i;\n      }\n    }\n    if (!wait) {\n      return -1;\n    }\n    JavaThread *thread = JavaThread::current();\n    ThreadBlockInVM tbivm(thread);\n\n    bool threadIsSuspended;\n    do {\n      thread->set_suspend_equivalent();\n      // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n      ::sem_wait(&sig_sem);\n\n      // were we externally suspended while we were waiting?\n      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n      if (threadIsSuspended) {\n        //\n        // The semaphore has been incremented, but while we were waiting\n        // another thread suspended us. We don't want to continue running\n        // while suspended because that would surprise the thread that\n        // suspended us.\n        //\n        ::sem_post(&sig_sem);\n\n        thread->java_suspend_self();\n      }\n    } while (threadIsSuspended);\n  }\n}\n\nint os::signal_lookup() {\n  return check_pending_signals(false);\n}\n\nint os::signal_wait() {\n  return check_pending_signals(true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Virtual Memory\n\nint os::vm_page_size() {\n  // Seems redundant as all get out\n  assert(os::Linux::page_size() != -1, \"must call os::init\");\n  return os::Linux::page_size();\n}\n\n// Solaris allocates memory by pages.\nint os::vm_allocation_granularity() {\n  assert(os::Linux::page_size() != -1, \"must call os::init\");\n  return os::Linux::page_size();\n}\n\n// Rationale behind this function:\n//  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable\n//  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get\n//  samples for JITted code. Here we create private executable mapping over the code cache\n//  and then we can use standard (well, almost, as mapping can change) way to provide\n//  info for the reporting script by storing timestamp and location of symbol\nvoid linux_wrap_code(char* base, size_t size) {\n  static volatile jint cnt = 0;\n\n  if (!UseOprofile) {\n    return;\n  }\n\n  char buf[PATH_MAX+1];\n  int num = Atomic::add(1, &cnt);\n\n  snprintf(buf, sizeof(buf), \"%s/hs-vm-%d-%d\",\n           os::get_temp_directory(), os::current_process_id(), num);\n  unlink(buf);\n\n  int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);\n\n  if (fd != -1) {\n    off_t rv = ::lseek(fd, size-2, SEEK_SET);\n    if (rv != (off_t)-1) {\n      if (::write(fd, \"\", 1) == 1) {\n        mmap(base, size,\n             PROT_READ|PROT_WRITE|PROT_EXEC,\n             MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);\n      }\n    }\n    ::close(fd);\n    unlink(buf);\n  }\n}\n\nstatic bool recoverable_mmap_error(int err) {\n  // See if the error is one we can let the caller handle. This\n  // list of errno values comes from JBS-6843484. I can't find a\n  // Linux man page that documents this specific set of errno\n  // values so while this list currently matches Solaris, it may\n  // change as we gain experience with this failure mode.\n  switch (err) {\n  case EBADF:\n  case EINVAL:\n  case ENOTSUP:\n    // let the caller deal with these errors\n    return true;\n\n  default:\n    // Any remaining errors on this OS can cause our reserved mapping\n    // to be lost. That can cause confusion where different data\n    // structures think they have the same memory mapped. The worst\n    // scenario is if both the VM and a library think they have the\n    // same memory mapped.\n    return false;\n  }\n}\n\nstatic void warn_fail_commit_memory(char* addr, size_t size, bool exec,\n                                    int err) {\n  warning(\"INFO: os::commit_memory(\" PTR_FORMAT \", \" SIZE_FORMAT\n          \", %d) failed; error='%s' (errno=%d)\", addr, size, exec,\n          strerror(err), err);\n}\n\nstatic void warn_fail_commit_memory(char* addr, size_t size,\n                                    size_t alignment_hint, bool exec,\n                                    int err) {\n  warning(\"INFO: os::commit_memory(\" PTR_FORMAT \", \" SIZE_FORMAT\n          \", \" SIZE_FORMAT \", %d) failed; error='%s' (errno=%d)\", addr, size,\n          alignment_hint, exec, strerror(err), err);\n}\n\n// NOTE: Linux kernel does not really reserve the pages for us.\n//       All it does is to check if there are enough free pages\n//       left at the time of mmap(). This could be a potential\n//       problem.\nint os::Linux::commit_memory_impl(char* addr, size_t size, bool exec) {\n  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n  uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,\n                                   MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n  if (res != (uintptr_t) MAP_FAILED) {\n    if (UseNUMAInterleaving) {\n      numa_make_global(addr, size);\n    }\n    return 0;\n  }\n\n  int err = errno;  // save errno from mmap() call above\n\n  if (!recoverable_mmap_error(err)) {\n    warn_fail_commit_memory(addr, size, exec, err);\n    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"committing reserved memory.\");\n  }\n\n  return err;\n}\n\nbool os::pd_commit_memory(char* addr, size_t size, bool exec) {\n  return os::Linux::commit_memory_impl(addr, size, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  int err = os::Linux::commit_memory_impl(addr, size, exec);\n  if (err != 0) {\n    // the caller wants all commit errors to exit with the specified mesg:\n    warn_fail_commit_memory(addr, size, exec, err);\n    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, mesg);\n  }\n}\n\n// Define MAP_HUGETLB here so we can build HotSpot on old systems.\n#ifndef MAP_HUGETLB\n#define MAP_HUGETLB 0x40000\n#endif\n\n// Define MADV_HUGEPAGE here so we can build HotSpot on old systems.\n#ifndef MADV_HUGEPAGE\n#define MADV_HUGEPAGE 14\n#endif\n\nint os::Linux::commit_memory_impl(char* addr, size_t size,\n                                  size_t alignment_hint, bool exec) {\n  int err = os::Linux::commit_memory_impl(addr, size, exec);\n  if (err == 0) {\n    realign_memory(addr, size, alignment_hint);\n  }\n  return err;\n}\n\nbool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,\n                          bool exec) {\n  return os::Linux::commit_memory_impl(addr, size, alignment_hint, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size,\n                                  size_t alignment_hint, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  int err = os::Linux::commit_memory_impl(addr, size, alignment_hint, exec);\n  if (err != 0) {\n    // the caller wants all commit errors to exit with the specified mesg:\n    warn_fail_commit_memory(addr, size, alignment_hint, exec, err);\n    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, mesg);\n  }\n}\n\nvoid os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {\n  if (UseTransparentHugePages && alignment_hint > (size_t)vm_page_size()) {\n    // We don't check the return value: madvise(MADV_HUGEPAGE) may not\n    // be supported or the memory may already be backed by huge pages.\n    ::madvise(addr, bytes, MADV_HUGEPAGE);\n  }\n}\n\nvoid os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n  // This method works by doing an mmap over an existing mmaping and effectively discarding\n  // the existing pages. However it won't work for SHM-based large pages that cannot be\n  // uncommitted at all. We don't do anything in this case to avoid creating a segment with\n  // small pages on top of the SHM segment. This method always works for small pages, so we\n  // allow that in any case.\n  if (alignment_hint <= (size_t)os::vm_page_size() || can_commit_large_page_memory()) {\n    commit_memory(addr, bytes, alignment_hint, !ExecMem);\n  }\n}\n\nvoid os::numa_make_global(char *addr, size_t bytes) {\n  Linux::numa_interleave_memory(addr, bytes);\n}\n\n// Define for numa_set_bind_policy(int). Setting the argument to 0 will set the\n// bind policy to MPOL_PREFERRED for the current thread.\n#define USE_MPOL_PREFERRED 0\n\nvoid os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {\n  // To make NUMA and large pages more robust when both enabled, we need to ease\n  // the requirements on where the memory should be allocated. MPOL_BIND is the\n  // default policy and it will force memory to be allocated on the specified\n  // node. Changing this to MPOL_PREFERRED will prefer to allocate the memory on\n  // the specified node, but will not force it. Using this policy will prevent\n  // getting SIGBUS when trying to allocate large pages on NUMA nodes with no\n  // free large pages.\n  Linux::numa_set_bind_policy(USE_MPOL_PREFERRED);\n  Linux::numa_tonode_memory(addr, bytes, lgrp_hint);\n}\n\nbool os::numa_topology_changed()   { return false; }\n\nsize_t os::numa_get_groups_num() {\n  int max_node = Linux::numa_max_node();\n  return max_node > 0 ? max_node + 1 : 1;\n}\n\nint os::numa_get_group_id() {\n  int cpu_id = Linux::sched_getcpu();\n  if (cpu_id != -1) {\n    int lgrp_id = Linux::get_node_by_cpu(cpu_id);\n    if (lgrp_id != -1) {\n      return lgrp_id;\n    }\n  }\n  return 0;\n}\n\nsize_t os::numa_get_leaf_groups(int *ids, size_t size) {\n  for (size_t i = 0; i < size; i++) {\n    ids[i] = i;\n  }\n  return size;\n}\n\nbool os::get_page_info(char *start, page_info* info) {\n  return false;\n}\n\nchar *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {\n  return end;\n}\n\n\nint os::Linux::sched_getcpu_syscall(void) {\n  unsigned int cpu = 0;\n  int retval = -1;\n\n#if defined(AMD64) || defined(BUILTIN_SIM)\n// Unfortunately we have to bring all these macros here from vsyscall.h\n// to be able to compile on old linuxes.\n# define __NR_vgetcpu 2\n# define VSYSCALL_START (-10UL << 20)\n# define VSYSCALL_SIZE 1024\n# define VSYSCALL_ADDR(vsyscall_nr) (VSYSCALL_START+VSYSCALL_SIZE*(vsyscall_nr))\n  typedef long (*vgetcpu_t)(unsigned int *cpu, unsigned int *node, unsigned long *tcache);\n  vgetcpu_t vgetcpu = (vgetcpu_t)VSYSCALL_ADDR(__NR_vgetcpu);\n  retval = vgetcpu(&cpu, NULL, NULL);\n#elif defined(IA32) || defined(AARCH64)\n# ifndef SYS_getcpu\n#  define SYS_getcpu AARCH64_ONLY(168) NOT_AARCH64(318)\n# endif\n  retval = syscall(SYS_getcpu, &cpu, NULL, NULL);\n#endif\n\n  return (retval == -1) ? retval : cpu;\n}\n\n// Something to do with the numa-aware allocator needs these symbols\nextern \"C\" JNIEXPORT void numa_warn(int number, char *where, ...) { }\nextern \"C\" JNIEXPORT void numa_error(char *where) { }\nextern \"C\" JNIEXPORT int fork1() { return fork(); }\n\n\n// If we are running with libnuma version > 2, then we should\n// be trying to use symbols with versions 1.1\n// If we are running with earlier version, which did not have symbol versions,\n// we should use the base version.\nvoid* os::Linux::libnuma_dlsym(void* handle, const char *name) {\n  void *f = dlvsym(handle, name, \"libnuma_1.1\");\n  if (f == NULL) {\n    f = dlsym(handle, name);\n  }\n  return f;\n}\n\nbool os::Linux::libnuma_init() {\n  // sched_getcpu() should be in libc.\n  set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,\n                                  dlsym(RTLD_DEFAULT, \"sched_getcpu\")));\n\n  // If it's not, try a direct syscall.\n  if (sched_getcpu() == -1)\n    set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t, (void*)&sched_getcpu_syscall));\n\n  if (sched_getcpu() != -1) { // Does it work?\n    void *handle = dlopen(\"libnuma.so.1\", RTLD_LAZY);\n    if (handle != NULL) {\n      set_numa_node_to_cpus(CAST_TO_FN_PTR(numa_node_to_cpus_func_t,\n                                           libnuma_dlsym(handle, \"numa_node_to_cpus\")));\n      set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,\n                                       libnuma_dlsym(handle, \"numa_max_node\")));\n      set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,\n                                        libnuma_dlsym(handle, \"numa_available\")));\n      set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,\n                                            libnuma_dlsym(handle, \"numa_tonode_memory\")));\n      set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,\n                                            libnuma_dlsym(handle, \"numa_interleave_memory\")));\n      set_numa_set_bind_policy(CAST_TO_FN_PTR(numa_set_bind_policy_func_t,\n                                            libnuma_dlsym(handle, \"numa_set_bind_policy\")));\n\n\n      if (numa_available() != -1) {\n        set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, \"numa_all_nodes\"));\n        // Create a cpu -> node mapping\n        _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, true);\n        rebuild_cpu_to_node_map();\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// rebuild_cpu_to_node_map() constructs a table mapping cpud id to node id.\n// The table is later used in get_node_by_cpu().\nvoid os::Linux::rebuild_cpu_to_node_map() {\n  const size_t NCPUS = 32768; // Since the buffer size computation is very obscure\n                              // in libnuma (possible values are starting from 16,\n                              // and continuing up with every other power of 2, but less\n                              // than the maximum number of CPUs supported by kernel), and\n                              // is a subject to change (in libnuma version 2 the requirements\n                              // are more reasonable) we'll just hardcode the number they use\n                              // in the library.\n  const size_t BitsPerCLong = sizeof(long) * CHAR_BIT;\n\n  size_t cpu_num = os::active_processor_count();\n  size_t cpu_map_size = NCPUS / BitsPerCLong;\n  size_t cpu_map_valid_size =\n    MIN2((cpu_num + BitsPerCLong - 1) / BitsPerCLong, cpu_map_size);\n\n  cpu_to_node()->clear();\n  cpu_to_node()->at_grow(cpu_num - 1);\n  size_t node_num = numa_get_groups_num();\n\n  unsigned long *cpu_map = NEW_C_HEAP_ARRAY(unsigned long, cpu_map_size, mtInternal);\n  for (size_t i = 0; i < node_num; i++) {\n    if (numa_node_to_cpus(i, cpu_map, cpu_map_size * sizeof(unsigned long)) != -1) {\n      for (size_t j = 0; j < cpu_map_valid_size; j++) {\n        if (cpu_map[j] != 0) {\n          for (size_t k = 0; k < BitsPerCLong; k++) {\n            if (cpu_map[j] & (1UL << k)) {\n              cpu_to_node()->at_put(j * BitsPerCLong + k, i);\n            }\n          }\n        }\n      }\n    }\n  }\n  FREE_C_HEAP_ARRAY(unsigned long, cpu_map, mtInternal);\n}\n\nint os::Linux::get_node_by_cpu(int cpu_id) {\n  if (cpu_to_node() != NULL && cpu_id >= 0 && cpu_id < cpu_to_node()->length()) {\n    return cpu_to_node()->at(cpu_id);\n  }\n  return -1;\n}\n\nGrowableArray<int>* os::Linux::_cpu_to_node;\nos::Linux::sched_getcpu_func_t os::Linux::_sched_getcpu;\nos::Linux::numa_node_to_cpus_func_t os::Linux::_numa_node_to_cpus;\nos::Linux::numa_max_node_func_t os::Linux::_numa_max_node;\nos::Linux::numa_available_func_t os::Linux::_numa_available;\nos::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;\nos::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;\nos::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;\nunsigned long* os::Linux::_numa_all_nodes;\n\nbool os::pd_uncommit_memory(char* addr, size_t size) {\n  uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,\n                MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n  return res  != (uintptr_t) MAP_FAILED;\n}\n\nstatic\naddress get_stack_commited_bottom(address bottom, size_t size) {\n  address nbot = bottom;\n  address ntop = bottom + size;\n\n  size_t page_sz = os::vm_page_size();\n  unsigned pages = size / page_sz;\n\n  unsigned char vec[1];\n  unsigned imin = 1, imax = pages + 1, imid;\n  int mincore_return_value = 0;\n\n  assert(imin <= imax, \"Unexpected page size\");\n\n  while (imin < imax) {\n    imid = (imax + imin) / 2;\n    nbot = ntop - (imid * page_sz);\n\n    // Use a trick with mincore to check whether the page is mapped or not.\n    // mincore sets vec to 1 if page resides in memory and to 0 if page\n    // is swapped output but if page we are asking for is unmapped\n    // it returns -1,ENOMEM\n    mincore_return_value = mincore(nbot, page_sz, vec);\n\n    if (mincore_return_value == -1) {\n      // Page is not mapped go up\n      // to find first mapped page\n      if (errno != EAGAIN) {\n        assert(errno == ENOMEM, \"Unexpected mincore errno\");\n        imax = imid;\n      }\n    } else {\n      // Page is mapped go down\n      // to find first not mapped page\n      imin = imid + 1;\n    }\n  }\n\n  nbot = nbot + page_sz;\n\n  // Adjust stack bottom one page up if last checked page is not mapped\n  if (mincore_return_value == -1) {\n    nbot = nbot + page_sz;\n  }\n\n  return nbot;\n}\n\n\n// Linux uses a growable mapping for the stack, and if the mapping for\n// the stack guard pages is not removed when we detach a thread the\n// stack cannot grow beyond the pages where the stack guard was\n// mapped.  If at some point later in the process the stack expands to\n// that point, the Linux kernel cannot expand the stack any further\n// because the guard pages are in the way, and a segfault occurs.\n//\n// However, it's essential not to split the stack region by unmapping\n// a region (leaving a hole) that's already part of the stack mapping,\n// so if the stack mapping has already grown beyond the guard pages at\n// the time we create them, we have to truncate the stack mapping.\n// So, we need to know the extent of the stack mapping when\n// create_stack_guard_pages() is called.\n\n// We only need this for stacks that are growable: at the time of\n// writing thread stacks don't use growable mappings (i.e. those\n// creeated with MAP_GROWSDOWN), and aren't marked \"[stack]\", so this\n// only applies to the main thread.\n\n// If the (growable) stack mapping already extends beyond the point\n// where we're going to put our guard pages, truncate the mapping at\n// that point by munmap()ping it.  This ensures that when we later\n// munmap() the guard pages we don't leave a hole in the stack\n// mapping. This only affects the main/initial thread\n\nbool os::pd_create_stack_guard_pages(char* addr, size_t size) {\n\n  if (os::Linux::is_initial_thread()) {\n    // As we manually grow stack up to bottom inside create_attached_thread(),\n    // it's likely that os::Linux::initial_thread_stack_bottom is mapped and\n    // we don't need to do anything special.\n    // Check it first, before calling heavy function.\n    uintptr_t stack_extent = (uintptr_t) os::Linux::initial_thread_stack_bottom();\n    unsigned char vec[1];\n\n    if (mincore((address)stack_extent, os::vm_page_size(), vec) == -1) {\n      // Fallback to slow path on all errors, including EAGAIN\n      stack_extent = (uintptr_t) get_stack_commited_bottom(\n                                    os::Linux::initial_thread_stack_bottom(),\n                                    (size_t)addr - stack_extent);\n    }\n\n    if (stack_extent < (uintptr_t)addr) {\n      ::munmap((void*)stack_extent, (uintptr_t)(addr - stack_extent));\n    }\n  }\n\n  return os::commit_memory(addr, size, !ExecMem);\n}\n\n// If this is a growable mapping, remove the guard pages entirely by\n// munmap()ping them.  If not, just call uncommit_memory(). This only\n// affects the main/initial thread, but guard against future OS changes\n// It's safe to always unmap guard pages for initial thread because we\n// always place it right after end of the mapped region\n\nbool os::remove_stack_guard_pages(char* addr, size_t size) {\n  uintptr_t stack_extent, stack_base;\n\n  if (os::Linux::is_initial_thread()) {\n    return ::munmap(addr, size) == 0;\n  }\n\n  return os::uncommit_memory(addr, size);\n}\n\nstatic address _highest_vm_reserved_address = NULL;\n\n// If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory\n// at 'requested_addr'. If there are existing memory mappings at the same\n// location, however, they will be overwritten. If 'fixed' is false,\n// 'requested_addr' is only treated as a hint, the return value may or\n// may not start from the requested address. Unlike Linux mmap(), this\n// function returns NULL to indicate failure.\nstatic char* anon_mmap(char* requested_addr, size_t bytes, bool fixed) {\n  char * addr;\n  int flags;\n\n  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n  if (fixed) {\n    assert((uintptr_t)requested_addr % os::Linux::page_size() == 0, \"unaligned address\");\n    flags |= MAP_FIXED;\n  }\n\n  // Map reserved/uncommitted pages PROT_NONE so we fail early if we\n  // touch an uncommitted page. Otherwise, the read/write might\n  // succeed if we have enough swap space to back the physical page.\n  addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,\n                       flags, -1, 0);\n\n  if (addr != MAP_FAILED) {\n    // anon_mmap() should only get called during VM initialization,\n    // don't need lock (actually we can skip locking even it can be called\n    // from multiple threads, because _highest_vm_reserved_address is just a\n    // hint about the upper limit of non-stack memory regions.)\n    if ((address)addr + bytes > _highest_vm_reserved_address) {\n      _highest_vm_reserved_address = (address)addr + bytes;\n    }\n  }\n\n  return addr == MAP_FAILED ? NULL : addr;\n}\n\n// Allocate (using mmap, NO_RESERVE, with small pages) at either a given request address\n//   (req_addr != NULL) or with a given alignment.\n//  - bytes shall be a multiple of alignment.\n//  - req_addr can be NULL. If not NULL, it must be a multiple of alignment.\n//  - alignment sets the alignment at which memory shall be allocated.\n//     It must be a multiple of allocation granularity.\n// Returns address of memory or NULL. If req_addr was not NULL, will only return\n//  req_addr or NULL.\nstatic char* anon_mmap_aligned(size_t bytes, size_t alignment, char* req_addr) {\n\n  size_t extra_size = bytes;\n  if (req_addr == NULL && alignment > 0) {\n    extra_size += alignment;\n  }\n\n  char* start = (char*) ::mmap(req_addr, extra_size, PROT_NONE,\n    MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n    -1, 0);\n  if (start == MAP_FAILED) {\n    start = NULL;\n  } else {\n    if (req_addr != NULL) {\n      if (start != req_addr) {\n        ::munmap(start, extra_size);\n        start = NULL;\n      }\n    } else {\n      char* const start_aligned = (char*) align_ptr_up(start, alignment);\n      char* const end_aligned = start_aligned + bytes;\n      char* const end = start + extra_size;\n      if (start_aligned > start) {\n        ::munmap(start, start_aligned - start);\n      }\n      if (end_aligned < end) {\n        ::munmap(end_aligned, end - end_aligned);\n      }\n      start = start_aligned;\n    }\n  }\n  return start;\n}\n\n// Don't update _highest_vm_reserved_address, because there might be memory\n// regions above addr + size. If so, releasing a memory region only creates\n// a hole in the address space, it doesn't help prevent heap-stack collision.\n//\nstatic int anon_munmap(char * addr, size_t size) {\n  return ::munmap(addr, size) == 0;\n}\n\nchar* os::pd_reserve_memory(size_t bytes, char* requested_addr,\n                         size_t alignment_hint) {\n  return anon_mmap(requested_addr, bytes, (requested_addr != NULL));\n}\n\nbool os::pd_release_memory(char* addr, size_t size) {\n  return anon_munmap(addr, size);\n}\n\nstatic address highest_vm_reserved_address() {\n  return _highest_vm_reserved_address;\n}\n\nstatic bool linux_mprotect(char* addr, size_t size, int prot) {\n  // Linux wants the mprotect address argument to be page aligned.\n  char* bottom = (char*)align_size_down((intptr_t)addr, os::Linux::page_size());\n\n  // According to SUSv3, mprotect() should only be used with mappings\n  // established by mmap(), and mmap() always maps whole pages. Unaligned\n  // 'addr' likely indicates problem in the VM (e.g. trying to change\n  // protection of malloc'ed or statically allocated memory). Check the\n  // caller if you hit this assert.\n  assert(addr == bottom, \"sanity check\");\n\n  size = align_size_up(pointer_delta(addr, bottom, 1) + size, os::Linux::page_size());\n  return ::mprotect(bottom, size, prot) == 0;\n}\n\n// Set protections specified\nbool os::protect_memory(char* addr, size_t bytes, ProtType prot,\n                        bool is_committed) {\n  unsigned int p = 0;\n  switch (prot) {\n  case MEM_PROT_NONE: p = PROT_NONE; break;\n  case MEM_PROT_READ: p = PROT_READ; break;\n  case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;\n  case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;\n  default:\n    ShouldNotReachHere();\n  }\n  // is_committed is unused.\n  return linux_mprotect(addr, bytes, p);\n}\n\nbool os::guard_memory(char* addr, size_t size) {\n  return linux_mprotect(addr, size, PROT_NONE);\n}\n\nbool os::unguard_memory(char* addr, size_t size) {\n  return linux_mprotect(addr, size, PROT_READ|PROT_WRITE);\n}\n\nbool os::Linux::transparent_huge_pages_sanity_check(bool warn, size_t page_size) {\n  bool result = false;\n  void *p = mmap(NULL, page_size * 2, PROT_READ|PROT_WRITE,\n                 MAP_ANONYMOUS|MAP_PRIVATE,\n                 -1, 0);\n  if (p != MAP_FAILED) {\n    void *aligned_p = align_ptr_up(p, page_size);\n\n    result = madvise(aligned_p, page_size, MADV_HUGEPAGE) == 0;\n\n    munmap(p, page_size * 2);\n  }\n\n  if (warn && !result) {\n    warning(\"TransparentHugePages is not supported by the operating system.\");\n  }\n\n  return result;\n}\n\nbool os::Linux::hugetlbfs_sanity_check(bool warn, size_t page_size) {\n  bool result = false;\n  void *p = mmap(NULL, page_size, PROT_READ|PROT_WRITE,\n                 MAP_ANONYMOUS|MAP_PRIVATE|MAP_HUGETLB,\n                 -1, 0);\n\n  if (p != MAP_FAILED) {\n    // We don't know if this really is a huge page or not.\n    FILE *fp = fopen(\"/proc/self/maps\", \"r\");\n    if (fp) {\n      while (!feof(fp)) {\n        char chars[257];\n        long x = 0;\n        if (fgets(chars, sizeof(chars), fp)) {\n          if (sscanf(chars, \"%lx-%*x\", &x) == 1\n              && x == (long)p) {\n            if (strstr (chars, \"hugepage\")) {\n              result = true;\n              break;\n            }\n          }\n        }\n      }\n      fclose(fp);\n    }\n    munmap(p, page_size);\n  }\n\n  if (warn && !result) {\n    warning(\"HugeTLBFS is not supported by the operating system.\");\n  }\n\n  return result;\n}\n\n/*\n* Set the coredump_filter bits to include largepages in core dump (bit 6)\n*\n* From the coredump_filter documentation:\n*\n* - (bit 0) anonymous private memory\n* - (bit 1) anonymous shared memory\n* - (bit 2) file-backed private memory\n* - (bit 3) file-backed shared memory\n* - (bit 4) ELF header pages in file-backed private memory areas (it is\n*           effective only if the bit 2 is cleared)\n* - (bit 5) hugetlb private memory\n* - (bit 6) hugetlb shared memory\n*/\nstatic void set_coredump_filter(void) {\n  FILE *f;\n  long cdm;\n\n  if ((f = fopen(\"/proc/self/coredump_filter\", \"r+\")) == NULL) {\n    return;\n  }\n\n  if (fscanf(f, \"%lx\", &cdm) != 1) {\n    fclose(f);\n    return;\n  }\n\n  rewind(f);\n\n  if ((cdm & LARGEPAGES_BIT) == 0) {\n    cdm |= LARGEPAGES_BIT;\n    fprintf(f, \"%#lx\", cdm);\n  }\n\n  fclose(f);\n}\n\n// Large page support\n\nstatic size_t _large_page_size = 0;\n\nsize_t os::Linux::find_large_page_size() {\n  size_t large_page_size = 0;\n\n  // large_page_size on Linux is used to round up heap size. x86 uses either\n  // 2M or 4M page, depending on whether PAE (Physical Address Extensions)\n  // mode is enabled. AMD64/EM64T uses 2M page in 64bit mode. IA64 can use\n  // page as large as 256M.\n  //\n  // Here we try to figure out page size by parsing /proc/meminfo and looking\n  // for a line with the following format:\n  //    Hugepagesize:     2048 kB\n  //\n  // If we can't determine the value (e.g. /proc is not mounted, or the text\n  // format has been changed), we'll use the largest page size supported by\n  // the processor.\n\n#ifndef ZERO\n  large_page_size = IA32_ONLY(4 * M) AMD64_ONLY(2 * M) IA64_ONLY(256 * M) SPARC_ONLY(4 * M)\n                     ARM_ONLY(2 * M) PPC_ONLY(4 * M) AARCH64_ONLY(2 * M);\n#endif // ZERO\n\n  FILE *fp = fopen(\"/proc/meminfo\", \"r\");\n  if (fp) {\n    while (!feof(fp)) {\n      int x = 0;\n      char buf[16];\n      if (fscanf(fp, \"Hugepagesize: %d\", &x) == 1) {\n        if (x && fgets(buf, sizeof(buf), fp) && strcmp(buf, \" kB\\n\") == 0) {\n          large_page_size = x * K;\n          break;\n        }\n      } else {\n        // skip to next line\n        for (;;) {\n          int ch = fgetc(fp);\n          if (ch == EOF || ch == (int)'\\n') break;\n        }\n      }\n    }\n    fclose(fp);\n  }\n\n  if (!FLAG_IS_DEFAULT(LargePageSizeInBytes) && LargePageSizeInBytes != large_page_size) {\n    warning(\"Setting LargePageSizeInBytes has no effect on this OS. Large page size is \"\n        SIZE_FORMAT \"%s.\", byte_size_in_proper_unit(large_page_size),\n        proper_unit_for_byte_size(large_page_size));\n  }\n\n  return large_page_size;\n}\n\nsize_t os::Linux::setup_large_page_size() {\n  _large_page_size = Linux::find_large_page_size();\n  const size_t default_page_size = (size_t)Linux::page_size();\n  if (_large_page_size > default_page_size) {\n    _page_sizes[0] = _large_page_size;\n    _page_sizes[1] = default_page_size;\n    _page_sizes[2] = 0;\n  }\n\n  return _large_page_size;\n}\n\nbool os::Linux::setup_large_page_type(size_t page_size) {\n  if (FLAG_IS_DEFAULT(UseHugeTLBFS) &&\n      FLAG_IS_DEFAULT(UseSHM) &&\n      FLAG_IS_DEFAULT(UseTransparentHugePages)) {\n\n    // The type of large pages has not been specified by the user.\n\n    // Try UseHugeTLBFS and then UseSHM.\n    UseHugeTLBFS = UseSHM = true;\n\n    // Don't try UseTransparentHugePages since there are known\n    // performance issues with it turned on. This might change in the future.\n    UseTransparentHugePages = false;\n  }\n\n  if (UseTransparentHugePages) {\n    bool warn_on_failure = !FLAG_IS_DEFAULT(UseTransparentHugePages);\n    if (transparent_huge_pages_sanity_check(warn_on_failure, page_size)) {\n      UseHugeTLBFS = false;\n      UseSHM = false;\n      return true;\n    }\n    UseTransparentHugePages = false;\n  }\n\n  if (UseHugeTLBFS) {\n    bool warn_on_failure = !FLAG_IS_DEFAULT(UseHugeTLBFS);\n    if (hugetlbfs_sanity_check(warn_on_failure, page_size)) {\n      UseSHM = false;\n      return true;\n    }\n    UseHugeTLBFS = false;\n  }\n\n  return UseSHM;\n}\n\nvoid os::large_page_init() {\n  if (!UseLargePages &&\n      !UseTransparentHugePages &&\n      !UseHugeTLBFS &&\n      !UseSHM) {\n    // Not using large pages.\n    return;\n  }\n\n  if (!FLAG_IS_DEFAULT(UseLargePages) && !UseLargePages) {\n    // The user explicitly turned off large pages.\n    // Ignore the rest of the large pages flags.\n    UseTransparentHugePages = false;\n    UseHugeTLBFS = false;\n    UseSHM = false;\n    return;\n  }\n\n  size_t large_page_size = Linux::setup_large_page_size();\n  UseLargePages          = Linux::setup_large_page_type(large_page_size);\n\n  set_coredump_filter();\n}\n\n#ifndef SHM_HUGETLB\n#define SHM_HUGETLB 04000\n#endif\n\n#define shm_warning_format(format, ...)              \\\n  do {                                               \\\n    if (UseLargePages &&                             \\\n        (!FLAG_IS_DEFAULT(UseLargePages) ||          \\\n         !FLAG_IS_DEFAULT(UseSHM) ||                 \\\n         !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {  \\\n      warning(format, __VA_ARGS__);                  \\\n    }                                                \\\n  } while (0)\n\n#define shm_warning(str) shm_warning_format(\"%s\", str)\n\n#define shm_warning_with_errno(str)                \\\n  do {                                             \\\n    int err = errno;                               \\\n    shm_warning_format(str \" (error = %d)\", err);  \\\n  } while (0)\n\nstatic char* shmat_with_alignment(int shmid, size_t bytes, size_t alignment) {\n  assert(is_size_aligned(bytes, alignment), \"Must be divisible by the alignment\");\n\n  if (!is_size_aligned(alignment, SHMLBA)) {\n    assert(false, \"Code below assumes that alignment is at least SHMLBA aligned\");\n    return NULL;\n  }\n\n  // To ensure that we get 'alignment' aligned memory from shmat,\n  // we pre-reserve aligned virtual memory and then attach to that.\n\n  char* pre_reserved_addr = anon_mmap_aligned(bytes, alignment, NULL);\n  if (pre_reserved_addr == NULL) {\n    // Couldn't pre-reserve aligned memory.\n    shm_warning(\"Failed to pre-reserve aligned memory for shmat.\");\n    return NULL;\n  }\n\n  // SHM_REMAP is needed to allow shmat to map over an existing mapping.\n  char* addr = (char*)shmat(shmid, pre_reserved_addr, SHM_REMAP);\n\n  if ((intptr_t)addr == -1) {\n    int err = errno;\n    shm_warning_with_errno(\"Failed to attach shared memory.\");\n\n    assert(err != EACCES, \"Unexpected error\");\n    assert(err != EIDRM,  \"Unexpected error\");\n    assert(err != EINVAL, \"Unexpected error\");\n\n    // Since we don't know if the kernel unmapped the pre-reserved memory area\n    // we can't unmap it, since that would potentially unmap memory that was\n    // mapped from other threads.\n    return NULL;\n  }\n\n  return addr;\n}\n\nstatic char* shmat_at_address(int shmid, char* req_addr) {\n  if (!is_ptr_aligned(req_addr, SHMLBA)) {\n    assert(false, \"Requested address needs to be SHMLBA aligned\");\n    return NULL;\n  }\n\n  char* addr = (char*)shmat(shmid, req_addr, 0);\n\n  if ((intptr_t)addr == -1) {\n    shm_warning_with_errno(\"Failed to attach shared memory.\");\n    return NULL;\n  }\n\n  return addr;\n}\n\nstatic char* shmat_large_pages(int shmid, size_t bytes, size_t alignment, char* req_addr) {\n  // If a req_addr has been provided, we assume that the caller has already aligned the address.\n  if (req_addr != NULL) {\n    assert(is_ptr_aligned(req_addr, os::large_page_size()), \"Must be divisible by the large page size\");\n    assert(is_ptr_aligned(req_addr, alignment), \"Must be divisible by given alignment\");\n    return shmat_at_address(shmid, req_addr);\n  }\n\n  // Since shmid has been setup with SHM_HUGETLB, shmat will automatically\n  // return large page size aligned memory addresses when req_addr == NULL.\n  // However, if the alignment is larger than the large page size, we have\n  // to manually ensure that the memory returned is 'alignment' aligned.\n  if (alignment > os::large_page_size()) {\n    assert(is_size_aligned(alignment, os::large_page_size()), \"Must be divisible by the large page size\");\n    return shmat_with_alignment(shmid, bytes, alignment);\n  } else {\n    return shmat_at_address(shmid, NULL);\n  }\n}\n\nchar* os::Linux::reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  // \"exec\" is passed in but not used.  Creating the shared image for\n  // the code cache doesn't have an SHM_X executable permission to check.\n  assert(UseLargePages && UseSHM, \"only for SHM large pages\");\n  assert(is_ptr_aligned(req_addr, os::large_page_size()), \"Unaligned address\");\n  assert(is_ptr_aligned(req_addr, alignment), \"Unaligned address\");\n\n  if (!is_size_aligned(bytes, os::large_page_size())) {\n    return NULL; // Fallback to small pages.\n  }\n\n  // Create a large shared memory region to attach to based on size.\n  // Currently, size is the total size of the heap.\n  int shmid = shmget(IPC_PRIVATE, bytes, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W);\n  if (shmid == -1) {\n    // Possible reasons for shmget failure:\n    // 1. shmmax is too small for Java heap.\n    //    > check shmmax value: cat /proc/sys/kernel/shmmax\n    //    > increase shmmax value: echo \"0xffffffff\" > /proc/sys/kernel/shmmax\n    // 2. not enough large page memory.\n    //    > check available large pages: cat /proc/meminfo\n    //    > increase amount of large pages:\n    //          echo new_value > /proc/sys/vm/nr_hugepages\n    //      Note 1: different Linux may use different name for this property,\n    //            e.g. on Redhat AS-3 it is \"hugetlb_pool\".\n    //      Note 2: it's possible there's enough physical memory available but\n    //            they are so fragmented after a long run that they can't\n    //            coalesce into large pages. Try to reserve large pages when\n    //            the system is still \"fresh\".\n    shm_warning_with_errno(\"Failed to reserve shared memory.\");\n    return NULL;\n  }\n\n  // Attach to the region.\n  char* addr = shmat_large_pages(shmid, bytes, alignment, req_addr);\n\n  // Remove shmid. If shmat() is successful, the actual shared memory segment\n  // will be deleted when it's detached by shmdt() or when the process\n  // terminates. If shmat() is not successful this will remove the shared\n  // segment immediately.\n  shmctl(shmid, IPC_RMID, NULL);\n\n  return addr;\n}\n\nstatic void warn_on_large_pages_failure(char* req_addr, size_t bytes, int error) {\n  assert(error == ENOMEM, \"Only expect to fail if no memory is available\");\n\n  bool warn_on_failure = UseLargePages &&\n      (!FLAG_IS_DEFAULT(UseLargePages) ||\n       !FLAG_IS_DEFAULT(UseHugeTLBFS) ||\n       !FLAG_IS_DEFAULT(LargePageSizeInBytes));\n\n  if (warn_on_failure) {\n    char msg[128];\n    jio_snprintf(msg, sizeof(msg), \"Failed to reserve large pages memory req_addr: \"\n        PTR_FORMAT \" bytes: \" SIZE_FORMAT \" (errno = %d).\", req_addr, bytes, error);\n    warning(\"%s\", msg);\n  }\n}\n\nchar* os::Linux::reserve_memory_special_huge_tlbfs_only(size_t bytes, char* req_addr, bool exec) {\n  assert(UseLargePages && UseHugeTLBFS, \"only for Huge TLBFS large pages\");\n  assert(is_size_aligned(bytes, os::large_page_size()), \"Unaligned size\");\n  assert(is_ptr_aligned(req_addr, os::large_page_size()), \"Unaligned address\");\n\n  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n  char* addr = (char*)::mmap(req_addr, bytes, prot,\n                             MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB,\n                             -1, 0);\n\n  if (addr == MAP_FAILED) {\n    warn_on_large_pages_failure(req_addr, bytes, errno);\n    return NULL;\n  }\n\n  assert(is_ptr_aligned(addr, os::large_page_size()), \"Must be\");\n\n  return addr;\n}\n\n// Reserve memory using mmap(MAP_HUGETLB).\n//  - bytes shall be a multiple of alignment.\n//  - req_addr can be NULL. If not NULL, it must be a multiple of alignment.\n//  - alignment sets the alignment at which memory shall be allocated.\n//     It must be a multiple of allocation granularity.\n// Returns address of memory or NULL. If req_addr was not NULL, will only return\n//  req_addr or NULL.\nchar* os::Linux::reserve_memory_special_huge_tlbfs_mixed(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  size_t large_page_size = os::large_page_size();\n  assert(bytes >= large_page_size, \"Shouldn't allocate large pages for small sizes\");\n\n  assert(is_ptr_aligned(req_addr, alignment), \"Must be\");\n  assert(is_size_aligned(bytes, alignment), \"Must be\");\n\n  // First reserve - but not commit - the address range in small pages.\n  char* const start = anon_mmap_aligned(bytes, alignment, req_addr);\n\n  if (start == NULL) {\n    return NULL;\n  }\n\n  assert(is_ptr_aligned(start, alignment), \"Must be\");\n\n  char* end = start + bytes;\n\n  // Find the regions of the allocated chunk that can be promoted to large pages.\n  char* lp_start = (char*)align_ptr_up(start, large_page_size);\n  char* lp_end   = (char*)align_ptr_down(end, large_page_size);\n\n  size_t lp_bytes = lp_end - lp_start;\n\n  assert(is_size_aligned(lp_bytes, large_page_size), \"Must be\");\n\n  if (lp_bytes == 0) {\n    // The mapped region doesn't even span the start and the end of a large page.\n    // Fall back to allocate a non-special area.\n    ::munmap(start, end - start);\n    return NULL;\n  }\n\n  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n\n  void* result;\n\n  // Commit small-paged leading area.\n  if (start != lp_start) {\n    result = ::mmap(start, lp_start - start, prot,\n                    MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,\n                    -1, 0);\n    if (result == MAP_FAILED) {\n      ::munmap(lp_start, end - lp_start);\n      return NULL;\n    }\n  }\n\n  // Commit large-paged area.\n  result = ::mmap(lp_start, lp_bytes, prot,\n                  MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED|MAP_HUGETLB,\n                  -1, 0);\n  if (result == MAP_FAILED) {\n    warn_on_large_pages_failure(lp_start, lp_bytes, errno);\n    // If the mmap above fails, the large pages region will be unmapped and we\n    // have regions before and after with small pages. Release these regions.\n    //\n    // |  mapped  |  unmapped  |  mapped  |\n    // ^          ^            ^          ^\n    // start      lp_start     lp_end     end\n    //\n    ::munmap(start, lp_start - start);\n    ::munmap(lp_end, end - lp_end);\n    return NULL;\n  }\n\n  // Commit small-paged trailing area.\n  if (lp_end != end) {\n      result = ::mmap(lp_end, end - lp_end, prot,\n                      MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,\n                      -1, 0);\n    if (result == MAP_FAILED) {\n      ::munmap(start, lp_end - start);\n      return NULL;\n    }\n  }\n\n  return start;\n}\n\nchar* os::Linux::reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  assert(UseLargePages && UseHugeTLBFS, \"only for Huge TLBFS large pages\");\n  assert(is_ptr_aligned(req_addr, alignment), \"Must be\");\n  assert(is_size_aligned(alignment, os::vm_allocation_granularity()), \"Must be\");\n  assert(is_power_of_2(os::large_page_size()), \"Must be\");\n  assert(bytes >= os::large_page_size(), \"Shouldn't allocate large pages for small sizes\");\n\n  if (is_size_aligned(bytes, os::large_page_size()) && alignment <= os::large_page_size()) {\n    return reserve_memory_special_huge_tlbfs_only(bytes, req_addr, exec);\n  } else {\n    return reserve_memory_special_huge_tlbfs_mixed(bytes, alignment, req_addr, exec);\n  }\n}\n\nchar* os::reserve_memory_special(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  assert(UseLargePages, \"only for large pages\");\n\n  char* addr;\n  if (UseSHM) {\n    addr = os::Linux::reserve_memory_special_shm(bytes, alignment, req_addr, exec);\n  } else {\n    assert(UseHugeTLBFS, \"must be\");\n    addr = os::Linux::reserve_memory_special_huge_tlbfs(bytes, alignment, req_addr, exec);\n  }\n\n  if (addr != NULL) {\n    if (UseNUMAInterleaving) {\n      numa_make_global(addr, bytes);\n    }\n\n    // The memory is committed\n    MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);\n  }\n\n  return addr;\n}\n\nbool os::Linux::release_memory_special_shm(char* base, size_t bytes) {\n  // detaching the SHM segment will also delete it, see reserve_memory_special_shm()\n  return shmdt(base) == 0;\n}\n\nbool os::Linux::release_memory_special_huge_tlbfs(char* base, size_t bytes) {\n  return pd_release_memory(base, bytes);\n}\n\nbool os::release_memory_special(char* base, size_t bytes) {\n  bool res;\n  if (MemTracker::tracking_level() > NMT_minimal) {\n    Tracker tkr = MemTracker::get_virtual_memory_release_tracker();\n    res = os::Linux::release_memory_special_impl(base, bytes);\n    if (res) {\n      tkr.record((address)base, bytes);\n    }\n\n  } else {\n    res = os::Linux::release_memory_special_impl(base, bytes);\n  }\n  return res;\n}\n\nbool os::Linux::release_memory_special_impl(char* base, size_t bytes) {\n  assert(UseLargePages, \"only for large pages\");\n  bool res;\n\n  if (UseSHM) {\n    res = os::Linux::release_memory_special_shm(base, bytes);\n  } else {\n    assert(UseHugeTLBFS, \"must be\");\n    res = os::Linux::release_memory_special_huge_tlbfs(base, bytes);\n  }\n  return res;\n}\n\nsize_t os::large_page_size() {\n  return _large_page_size;\n}\n\n// With SysV SHM the entire memory region must be allocated as shared\n// memory.\n// HugeTLBFS allows application to commit large page memory on demand.\n// However, when committing memory with HugeTLBFS fails, the region\n// that was supposed to be committed will lose the old reservation\n// and allow other threads to steal that memory region. Because of this\n// behavior we can't commit HugeTLBFS memory.\nbool os::can_commit_large_page_memory() {\n  return UseTransparentHugePages;\n}\n\nbool os::can_execute_large_page_memory() {\n  return UseTransparentHugePages || UseHugeTLBFS;\n}\n\n// Reserve memory at an arbitrary address, only if that area is\n// available (and not reserved for something else).\n\nchar* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {\n  const int max_tries = 10;\n  char* base[max_tries];\n  size_t size[max_tries];\n  const size_t gap = 0x000000;\n\n  // Assert only that the size is a multiple of the page size, since\n  // that's all that mmap requires, and since that's all we really know\n  // about at this low abstraction level.  If we need higher alignment,\n  // we can either pass an alignment to this method or verify alignment\n  // in one of the methods further up the call chain.  See bug 5044738.\n  assert(bytes % os::vm_page_size() == 0, \"reserving unexpected size block\");\n\n  // Repeatedly allocate blocks until the block is allocated at the\n  // right spot. Give up after max_tries. Note that reserve_memory() will\n  // automatically update _highest_vm_reserved_address if the call is\n  // successful. The variable tracks the highest memory address every reserved\n  // by JVM. It is used to detect heap-stack collision if running with\n  // fixed-stack LinuxThreads. Because here we may attempt to reserve more\n  // space than needed, it could confuse the collision detecting code. To\n  // solve the problem, save current _highest_vm_reserved_address and\n  // calculate the correct value before return.\n  address old_highest = _highest_vm_reserved_address;\n\n  // Linux mmap allows caller to pass an address as hint; give it a try first,\n  // if kernel honors the hint then we can return immediately.\n  char * addr = anon_mmap(requested_addr, bytes, false);\n  if (addr == requested_addr) {\n     return requested_addr;\n  }\n\n  if (addr != NULL) {\n     // mmap() is successful but it fails to reserve at the requested address\n     anon_munmap(addr, bytes);\n  }\n\n  int i;\n  for (i = 0; i < max_tries; ++i) {\n    base[i] = reserve_memory(bytes);\n\n    if (base[i] != NULL) {\n      // Is this the block we wanted?\n      if (base[i] == requested_addr) {\n        size[i] = bytes;\n        break;\n      }\n\n      // Does this overlap the block we wanted? Give back the overlapped\n      // parts and try again.\n\n      size_t top_overlap = requested_addr + (bytes + gap) - base[i];\n      if (top_overlap >= 0 && top_overlap < bytes) {\n        unmap_memory(base[i], top_overlap);\n        base[i] += top_overlap;\n        size[i] = bytes - top_overlap;\n      } else {\n        size_t bottom_overlap = base[i] + bytes - requested_addr;\n        if (bottom_overlap >= 0 && bottom_overlap < bytes) {\n          unmap_memory(requested_addr, bottom_overlap);\n          size[i] = bytes - bottom_overlap;\n        } else {\n          size[i] = bytes;\n        }\n      }\n    }\n  }\n\n  // Give back the unused reserved pieces.\n\n  for (int j = 0; j < i; ++j) {\n    if (base[j] != NULL) {\n      unmap_memory(base[j], size[j]);\n    }\n  }\n\n  if (i < max_tries) {\n    _highest_vm_reserved_address = MAX2(old_highest, (address)requested_addr + bytes);\n    return requested_addr;\n  } else {\n    _highest_vm_reserved_address = old_highest;\n    return NULL;\n  }\n}\n\nsize_t os::read(int fd, void *buf, unsigned int nBytes) {\n  return ::read(fd, buf, nBytes);\n}\n\n// TODO-FIXME: reconcile Solaris' os::sleep with the linux variation.\n// Solaris uses poll(), linux uses park().\n// Poll() is likely a better choice, assuming that Thread.interrupt()\n// generates a SIGUSRx signal. Note that SIGUSR1 can interfere with\n// SIGSEGV, see 4355769.\n\nint os::sleep(Thread* thread, jlong millis, bool interruptible) {\n  assert(thread == Thread::current(),  \"thread consistency check\");\n\n  ParkEvent * const slp = thread->_SleepEvent ;\n  slp->reset() ;\n  OrderAccess::fence() ;\n\n  if (interruptible) {\n    jlong prevtime = javaTimeNanos();\n\n    for (;;) {\n      if (os::is_interrupted(thread, true)) {\n        return OS_INTRPT;\n      }\n\n      jlong newtime = javaTimeNanos();\n\n      if (newtime - prevtime < 0) {\n        // time moving backwards, should only happen if no monotonic clock\n        // not a guarantee() because JVM should not abort on kernel/glibc bugs\n        assert(!Linux::supports_monotonic_clock(), \"time moving backwards\");\n      } else {\n        millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n      }\n\n      if(millis <= 0) {\n        return OS_OK;\n      }\n\n      prevtime = newtime;\n\n      {\n        assert(thread->is_Java_thread(), \"sanity check\");\n        JavaThread *jt = (JavaThread *) thread;\n        ThreadBlockInVM tbivm(jt);\n        OSThreadWaitState osts(jt->osthread(), false /* not Object.wait() */);\n\n        jt->set_suspend_equivalent();\n        // cleared by handle_special_suspend_equivalent_condition() or\n        // java_suspend_self() via check_and_wait_while_suspended()\n\n        slp->park(millis);\n\n        // were we externally suspended while we were waiting?\n        jt->check_and_wait_while_suspended();\n      }\n    }\n  } else {\n    OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n    jlong prevtime = javaTimeNanos();\n\n    for (;;) {\n      // It'd be nice to avoid the back-to-back javaTimeNanos() calls on\n      // the 1st iteration ...\n      jlong newtime = javaTimeNanos();\n\n      if (newtime - prevtime < 0) {\n        // time moving backwards, should only happen if no monotonic clock\n        // not a guarantee() because JVM should not abort on kernel/glibc bugs\n        assert(!Linux::supports_monotonic_clock(), \"time moving backwards\");\n      } else {\n        millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n      }\n\n      if(millis <= 0) break ;\n\n      prevtime = newtime;\n      slp->park(millis);\n    }\n    return OS_OK ;\n  }\n}\n\n//\n// Short sleep, direct OS call.\n//\n// Note: certain versions of Linux CFS scheduler (since 2.6.23) do not guarantee\n// sched_yield(2) will actually give up the CPU:\n//\n//   * Alone on this pariticular CPU, keeps running.\n//   * Before the introduction of \"skip_buddy\" with \"compat_yield\" disabled\n//     (pre 2.6.39).\n//\n// So calling this with 0 is an alternative.\n//\nvoid os::naked_short_sleep(jlong ms) {\n  struct timespec req;\n\n  assert(ms < 1000, \"Un-interruptable sleep, short time use only\");\n  req.tv_sec = 0;\n  if (ms > 0) {\n    req.tv_nsec = (ms % 1000) * 1000000;\n  }\n  else {\n    req.tv_nsec = 1;\n  }\n\n  nanosleep(&req, NULL);\n\n  return;\n}\n\n// Sleep forever; naked call to OS-specific sleep; use with CAUTION\nvoid os::infinite_sleep() {\n  while (true) {    // sleep forever ...\n    ::sleep(100);   // ... 100 seconds at a time\n  }\n}\n\n// Used to convert frequent JVM_Yield() to nops\nbool os::dont_yield() {\n  return DontYieldALot;\n}\n\nvoid os::yield() {\n  sched_yield();\n}\n\nos::YieldResult os::NakedYield() { sched_yield(); return os::YIELD_UNKNOWN ;}\n\nvoid os::yield_all(int attempts) {\n  // Yields to all threads, including threads with lower priorities\n  // Threads on Linux are all with same priority. The Solaris style\n  // os::yield_all() with nanosleep(1ms) is not necessary.\n  sched_yield();\n}\n\n// Called from the tight loops to possibly influence time-sharing heuristics\nvoid os::loop_breaker(int attempts) {\n  os::yield_all(attempts);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// thread priority support\n\n// Note: Normal Linux applications are run with SCHED_OTHER policy. SCHED_OTHER\n// only supports dynamic priority, static priority must be zero. For real-time\n// applications, Linux supports SCHED_RR which allows static priority (1-99).\n// However, for large multi-threaded applications, SCHED_RR is not only slower\n// than SCHED_OTHER, but also very unstable (my volano tests hang hard 4 out\n// of 5 runs - Sep 2005).\n//\n// The following code actually changes the niceness of kernel-thread/LWP. It\n// has an assumption that setpriority() only modifies one kernel-thread/LWP,\n// not the entire user process, and user level threads are 1:1 mapped to kernel\n// threads. It has always been the case, but could change in the future. For\n// this reason, the code should not be used as default (ThreadPriorityPolicy=0).\n// It is only used when ThreadPriorityPolicy=1 and requires root privilege.\n\nint os::java_to_os_priority[CriticalPriority + 1] = {\n  19,              // 0 Entry should never be used\n\n   4,              // 1 MinPriority\n   3,              // 2\n   2,              // 3\n\n   1,              // 4\n   0,              // 5 NormPriority\n  -1,              // 6\n\n  -2,              // 7\n  -3,              // 8\n  -4,              // 9 NearMaxPriority\n\n  -5,              // 10 MaxPriority\n\n  -5               // 11 CriticalPriority\n};\n\nstatic int prio_init() {\n  if (ThreadPriorityPolicy == 1) {\n    // Only root can raise thread priority. Don't allow ThreadPriorityPolicy=1\n    // if effective uid is not root. Perhaps, a more elegant way of doing\n    // this is to test CAP_SYS_NICE capability, but that will require libcap.so\n    if (geteuid() != 0) {\n      if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {\n        warning(\"-XX:ThreadPriorityPolicy requires root privilege on Linux\");\n      }\n      ThreadPriorityPolicy = 0;\n    }\n  }\n  if (UseCriticalJavaThreadPriority) {\n    os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];\n  }\n  return 0;\n}\n\nOSReturn os::set_native_priority(Thread* thread, int newpri) {\n  if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) return OS_OK;\n\n  int ret = setpriority(PRIO_PROCESS, thread->osthread()->thread_id(), newpri);\n  return (ret == 0) ? OS_OK : OS_ERR;\n}\n\nOSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {\n  if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) {\n    *priority_ptr = java_to_os_priority[NormPriority];\n    return OS_OK;\n  }\n\n  errno = 0;\n  *priority_ptr = getpriority(PRIO_PROCESS, thread->osthread()->thread_id());\n  return (*priority_ptr != -1 || errno == 0 ? OS_OK : OS_ERR);\n}\n\n// Hint to the underlying OS that a task switch would not be good.\n// Void return because it's a hint and can fail.\nvoid os::hint_no_preempt() {}\n\n////////////////////////////////////////////////////////////////////////////////\n// suspend/resume support\n\n//  the low-level signal-based suspend/resume support is a remnant from the\n//  old VM-suspension that used to be for java-suspension, safepoints etc,\n//  within hotspot. Now there is a single use-case for this:\n//    - calling get_thread_pc() on the VMThread by the flat-profiler task\n//      that runs in the watcher thread.\n//  The remaining code is greatly simplified from the more general suspension\n//  code that used to be used.\n//\n//  The protocol is quite simple:\n//  - suspend:\n//      - sends a signal to the target thread\n//      - polls the suspend state of the osthread using a yield loop\n//      - target thread signal handler (SR_handler) sets suspend state\n//        and blocks in sigsuspend until continued\n//  - resume:\n//      - sets target osthread state to continue\n//      - sends signal to end the sigsuspend loop in the SR_handler\n//\n//  Note that the SR_lock plays no role in this suspend/resume protocol.\n//\n\nstatic void resume_clear_context(OSThread *osthread) {\n  osthread->set_ucontext(NULL);\n  osthread->set_siginfo(NULL);\n}\n\nstatic void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n  osthread->set_ucontext(context);\n  osthread->set_siginfo(siginfo);\n}\n\n//\n// Handler function invoked when a thread's execution is suspended or\n// resumed. We have to be careful that only async-safe functions are\n// called here (Note: most pthread functions are not async safe and\n// should be avoided.)\n//\n// Note: sigwait() is a more natural fit than sigsuspend() from an\n// interface point of view, but sigwait() prevents the signal hander\n// from being run. libpthread would get very confused by not having\n// its signal handlers run and prevents sigwait()'s use with the\n// mutex granting granting signal.\n//\n// Currently only ever called on the VMThread and JavaThreads (PC sampling)\n//\nstatic void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n  // Save and restore errno to avoid confusing native code with EINTR\n  // after sigsuspend.\n  int old_errno = errno;\n\n  Thread* thread = Thread::current();\n  OSThread* osthread = thread->osthread();\n  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n\n  os::SuspendResume::State current = osthread->sr.state();\n  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n    suspend_save_context(osthread, siginfo, context);\n\n    // attempt to switch the state, we assume we had a SUSPEND_REQUEST\n    os::SuspendResume::State state = osthread->sr.suspended();\n    if (state == os::SuspendResume::SR_SUSPENDED) {\n      sigset_t suspend_set;  // signals for sigsuspend()\n\n      // get current set of blocked signals and unblock resume signal\n      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n      sigdelset(&suspend_set, SR_signum);\n\n      sr_semaphore.signal();\n      // wait here until we are resumed\n      while (1) {\n        sigsuspend(&suspend_set);\n\n        os::SuspendResume::State result = osthread->sr.running();\n        if (result == os::SuspendResume::SR_RUNNING) {\n          sr_semaphore.signal();\n          break;\n        }\n      }\n\n    } else if (state == os::SuspendResume::SR_RUNNING) {\n      // request was cancelled, continue\n    } else {\n      ShouldNotReachHere();\n    }\n\n    resume_clear_context(osthread);\n  } else if (current == os::SuspendResume::SR_RUNNING) {\n    // request was cancelled, continue\n  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // ignore\n  } else {\n    // ignore\n  }\n\n  errno = old_errno;\n}\n\n\nstatic int SR_initialize() {\n  struct sigaction act;\n  char *s;\n  /* Get signal number to use for suspend/resume */\n  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n    int sig = ::strtol(s, 0, 10);\n    if (sig > 0 || sig < _NSIG) {\n        SR_signum = sig;\n    }\n  }\n\n  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n        \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n\n  sigemptyset(&SR_sigset);\n  sigaddset(&SR_sigset, SR_signum);\n\n  /* Set up signal handler for suspend/resume */\n  act.sa_flags = SA_RESTART|SA_SIGINFO;\n  act.sa_handler = (void (*)(int)) SR_handler;\n\n  // SR_signum is blocked by default.\n  // 4528190 - We also need to block pthread restart signal (32 on all\n  // supported Linux platforms). Note that LinuxThreads need to block\n  // this signal for all threads to work properly. So we don't have\n  // to use hard-coded signal number when setting up the mask.\n  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n\n  if (sigaction(SR_signum, &act, 0) == -1) {\n    return -1;\n  }\n\n  // Save signal flag\n  os::Linux::set_our_sigflags(SR_signum, act.sa_flags);\n  return 0;\n}\n\nstatic int sr_notify(OSThread* osthread) {\n  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n  assert_status(status == 0, status, \"pthread_kill\");\n  return status;\n}\n\n// \"Randomly\" selected value for how long we want to spin\n// before bailing out on suspending a thread, also how often\n// we send a signal to a thread we want to resume\nstatic const int RANDOMLY_LARGE_INTEGER = 1000000;\nstatic const int RANDOMLY_LARGE_INTEGER2 = 100;\n\n// returns true on success and false on error - really an error is fatal\n// but this seems the normal response to library errors\nstatic bool do_suspend(OSThread* osthread) {\n  assert(osthread->sr.is_running(), \"thread should be running\");\n  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n\n  // mark as suspended and send signal\n  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n    // failed to switch, state wasn't running?\n    ShouldNotReachHere();\n    return false;\n  }\n\n  if (sr_notify(osthread) != 0) {\n    ShouldNotReachHere();\n  }\n\n  // managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n  while (true) {\n    if (sr_semaphore.timedwait(0, 2 * NANOSECS_PER_MILLISEC)) {\n      break;\n    } else {\n      // timeout\n      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n      if (cancelled == os::SuspendResume::SR_RUNNING) {\n        return false;\n      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n        // make sure that we consume the signal on the semaphore as well\n        sr_semaphore.wait();\n        break;\n      } else {\n        ShouldNotReachHere();\n        return false;\n      }\n    }\n  }\n\n  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n  return true;\n}\n\nstatic void do_resume(OSThread* osthread) {\n  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n\n  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // failed to switch to WAKEUP_REQUEST\n    ShouldNotReachHere();\n    return;\n  }\n\n  while (true) {\n    if (sr_notify(osthread) == 0) {\n      if (sr_semaphore.timedwait(0, 2 * NANOSECS_PER_MILLISEC)) {\n        if (osthread->sr.is_running()) {\n          return;\n        }\n      }\n    } else {\n      ShouldNotReachHere();\n    }\n  }\n\n  guarantee(osthread->sr.is_running(), \"Must be running!\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// interrupt support\n\nvoid os::interrupt(Thread* thread) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  if (!osthread->interrupted()) {\n    osthread->set_interrupted(true);\n    // More than one thread can get here with the same value of osthread,\n    // resulting in multiple notifications.  We do, however, want the store\n    // to interrupted() to be visible to other threads before we execute unpark().\n    OrderAccess::fence();\n    ParkEvent * const slp = thread->_SleepEvent ;\n    if (slp != NULL) slp->unpark() ;\n  }\n\n  // For JSR166. Unpark even if interrupt status already was set\n  if (thread->is_Java_thread())\n    ((JavaThread*)thread)->parker()->unpark();\n\n  ParkEvent * ev = thread->_ParkEvent ;\n  if (ev != NULL) ev->unpark() ;\n\n}\n\nbool os::is_interrupted(Thread* thread, bool clear_interrupted) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  bool interrupted = osthread->interrupted();\n\n  if (interrupted && clear_interrupted) {\n    osthread->set_interrupted(false);\n    // consider thread->_SleepEvent->reset() ... optional optimization\n  }\n\n  return interrupted;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// signal handling (except suspend/resume)\n\n// This routine may be used by user applications as a \"hook\" to catch signals.\n// The user-defined signal handler must pass unrecognized signals to this\n// routine, and if it returns true (non-zero), then the signal handler must\n// return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n// routine will never retun false (zero), but instead will execute a VM panic\n// routine kill the process.\n//\n// If this routine returns false, it is OK to call it again.  This allows\n// the user-defined signal handler to perform checks either before or after\n// the VM performs its own checks.  Naturally, the user code would be making\n// a serious error if it tried to handle an exception (such as a null check\n// or breakpoint) that the VM was generating for its own correct operation.\n//\n// This routine may recognize any of the following kinds of signals:\n//    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n// It should be consulted by handlers for any of those signals.\n//\n// The caller of this routine must pass in the three arguments supplied\n// to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n// field of the structure passed to sigaction().  This routine assumes that\n// the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n//\n// Note that the VM will print warnings if it detects conflicting signal\n// handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n//\nextern \"C\" JNIEXPORT int\nJVM_handle_linux_signal(int signo, siginfo_t* siginfo,\n                        void* ucontext, int abort_if_unrecognized);\n\nvoid signalHandler(int sig, siginfo_t* info, void* uc) {\n  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n  int orig_errno = errno;  // Preserve errno value over signal handler.\n  JVM_handle_linux_signal(sig, info, uc, true);\n  errno = orig_errno;\n}\n\n\n// This boolean allows users to forward their own non-matching signals\n// to JVM_handle_linux_signal, harmlessly.\nbool os::Linux::signal_handlers_are_installed = false;\n\n// For signal-chaining\nstruct sigaction os::Linux::sigact[MAXSIGNUM];\nunsigned int os::Linux::sigs = 0;\nbool os::Linux::libjsig_is_loaded = false;\ntypedef struct sigaction *(*get_signal_t)(int);\nget_signal_t os::Linux::get_signal_action = NULL;\n\nstruct sigaction* os::Linux::get_chained_signal_action(int sig) {\n  struct sigaction *actp = NULL;\n\n  if (libjsig_is_loaded) {\n    // Retrieve the old signal handler from libjsig\n    actp = (*get_signal_action)(sig);\n  }\n  if (actp == NULL) {\n    // Retrieve the preinstalled signal handler from jvm\n    actp = get_preinstalled_handler(sig);\n  }\n\n  return actp;\n}\n\nstatic bool call_chained_handler(struct sigaction *actp, int sig,\n                                 siginfo_t *siginfo, void *context) {\n  // Call the old signal handler\n  if (actp->sa_handler == SIG_DFL) {\n    // It's more reasonable to let jvm treat it as an unexpected exception\n    // instead of taking the default action.\n    return false;\n  } else if (actp->sa_handler != SIG_IGN) {\n    if ((actp->sa_flags & SA_NODEFER) == 0) {\n      // automaticlly block the signal\n      sigaddset(&(actp->sa_mask), sig);\n    }\n\n    sa_handler_t hand = NULL;\n    sa_sigaction_t sa = NULL;\n    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n    // retrieve the chained handler\n    if (siginfo_flag_set) {\n      sa = actp->sa_sigaction;\n    } else {\n      hand = actp->sa_handler;\n    }\n\n    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n      actp->sa_handler = SIG_DFL;\n    }\n\n    // try to honor the signal mask\n    sigset_t oset;\n    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n\n    // call into the chained handler\n    if (siginfo_flag_set) {\n      (*sa)(sig, siginfo, context);\n    } else {\n      (*hand)(sig);\n    }\n\n    // restore the signal mask\n    pthread_sigmask(SIG_SETMASK, &oset, 0);\n  }\n  // Tell jvm's signal handler the signal is taken care of.\n  return true;\n}\n\nbool os::Linux::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n  bool chained = false;\n  // signal-chaining\n  if (UseSignalChaining) {\n    struct sigaction *actp = get_chained_signal_action(sig);\n    if (actp != NULL) {\n      chained = call_chained_handler(actp, sig, siginfo, context);\n    }\n  }\n  return chained;\n}\n\nstruct sigaction* os::Linux::get_preinstalled_handler(int sig) {\n  if ((( (unsigned int)1 << sig ) & sigs) != 0) {\n    return &sigact[sig];\n  }\n  return NULL;\n}\n\nvoid os::Linux::save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigact[sig] = oldAct;\n  sigs |= (unsigned int)1 << sig;\n}\n\n// for diagnostic\nint os::Linux::sigflags[MAXSIGNUM];\n\nint os::Linux::get_our_sigflags(int sig) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  return sigflags[sig];\n}\n\nvoid os::Linux::set_our_sigflags(int sig, int flags) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = flags;\n}\n\nvoid os::Linux::set_signal_handler(int sig, bool set_installed) {\n  // Check for overwrite.\n  struct sigaction oldAct;\n  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n\n  void* oldhand = oldAct.sa_sigaction\n                ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n                : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)signalHandler)) {\n    if (AllowUserSignalHandlers || !set_installed) {\n      // Do not overwrite; user takes responsibility to forward to us.\n      return;\n    } else if (UseSignalChaining) {\n      // save the old handler in jvm\n      save_preinstalled_handler(sig, oldAct);\n      // libjsig also interposes the sigaction() call below and saves the\n      // old sigaction on it own.\n    } else {\n      fatal(err_msg(\"Encountered unexpected pre-existing sigaction handler \"\n                    \"%#lx for signal %d.\", (long)oldhand, sig));\n    }\n  }\n\n  struct sigaction sigAct;\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_handler = SIG_DFL;\n  if (!set_installed) {\n    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n  } else {\n    sigAct.sa_sigaction = signalHandler;\n    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n  }\n  // Save flags, which are set by ours\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = sigAct.sa_flags;\n\n  int ret = sigaction(sig, &sigAct, &oldAct);\n  assert(ret == 0, \"check\");\n\n  void* oldhand2  = oldAct.sa_sigaction\n                  ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n                  : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n}\n\n// install signal handlers for signals that HotSpot needs to\n// handle in order to support Java-level exception handling.\n\nvoid os::Linux::install_signal_handlers() {\n  if (!signal_handlers_are_installed) {\n    signal_handlers_are_installed = true;\n\n    // signal-chaining\n    typedef void (*signal_setting_t)();\n    signal_setting_t begin_signal_setting = NULL;\n    signal_setting_t end_signal_setting = NULL;\n    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n    if (begin_signal_setting != NULL) {\n      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n                            dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n      libjsig_is_loaded = true;\n      assert(UseSignalChaining, \"should enable signal-chaining\");\n    }\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm is setting signal handlers\n      (*begin_signal_setting)();\n    }\n\n    set_signal_handler(SIGSEGV, true);\n    set_signal_handler(SIGPIPE, true);\n    set_signal_handler(SIGBUS, true);\n    set_signal_handler(SIGILL, true);\n    set_signal_handler(SIGFPE, true);\n#if defined(PPC64)\n    set_signal_handler(SIGTRAP, true);\n#endif\n    set_signal_handler(SIGXFSZ, true);\n\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm finishes setting signal handlers\n      (*end_signal_setting)();\n    }\n\n    // We don't activate signal checker if libjsig is in place, we trust ourselves\n    // and if UserSignalHandler is installed all bets are off.\n    // Log that signal checking is off only if -verbose:jni is specified.\n    if (CheckJNICalls) {\n      if (libjsig_is_loaded) {\n        if (PrintJNIResolving) {\n          tty->print_cr(\"Info: libjsig is activated, all active signal checking is disabled\");\n        }\n        check_signals = false;\n      }\n      if (AllowUserSignalHandlers) {\n        if (PrintJNIResolving) {\n          tty->print_cr(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n        }\n        check_signals = false;\n      }\n    }\n  }\n}\n\n// This is the fastest way to get thread cpu time on Linux.\n// Returns cpu time (user+sys) for any thread, not only for current.\n// POSIX compliant clocks are implemented in the kernels 2.6.16+.\n// It might work on 2.6.10+ with a special kernel/glibc patch.\n// For reference, please, see IEEE Std 1003.1-2004:\n//   http://www.unix.org/single_unix_specification\n\njlong os::Linux::fast_thread_cpu_time(clockid_t clockid) {\n  struct timespec tp;\n  int rc = os::Linux::clock_gettime(clockid, &tp);\n  assert(rc == 0, \"clock_gettime is expected to return 0 code\");\n\n  return (tp.tv_sec * NANOSECS_PER_SEC) + tp.tv_nsec;\n}\n\n/////\n// glibc on Linux platform uses non-documented flag\n// to indicate, that some special sort of signal\n// trampoline is used.\n// We will never set this flag, and we should\n// ignore this flag in our diagnostic\n#ifdef SIGNIFICANT_SIGNAL_MASK\n#undef SIGNIFICANT_SIGNAL_MASK\n#endif\n#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)\n\nstatic const char* get_signal_handler_name(address handler,\n                                           char* buf, int buflen) {\n  int offset = 0;\n  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n  if (found) {\n    // skip directory names\n    const char *p1, *p2;\n    p1 = buf;\n    size_t len = strlen(os::file_separator());\n    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n  } else {\n    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n  }\n  return buf;\n}\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen) {\n  struct sigaction sa;\n\n  sigaction(sig, NULL, &sa);\n\n  // See comment for SIGNIFICANT_SIGNAL_MASK define\n  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n\n  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n\n  address handler = (sa.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n\n  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n    st->print(\"SIG_DFL\");\n  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n    st->print(\"SIG_IGN\");\n  } else {\n    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n  }\n\n  st->print(\", sa_mask[0]=\");\n  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n\n  address rh = VMError::get_resetted_sighandler(sig);\n  // May be, handler was resetted by VMError?\n  if(rh != NULL) {\n    handler = rh;\n    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;\n  }\n\n  st->print(\", sa_flags=\");\n  os::Posix::print_sa_flags(st, sa.sa_flags);\n\n  // Check: is it our handler?\n  if(handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler) ||\n     handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n    // It is our signal handler\n    // check for flags, reset system-used one!\n    if((int)sa.sa_flags != os::Linux::get_our_sigflags(sig)) {\n      st->print(\n                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n                os::Linux::get_our_sigflags(sig));\n    }\n  }\n  st->cr();\n}\n\n\n#define DO_SIGNAL_CHECK(sig) \\\n  if (!sigismember(&check_signal_done, sig)) \\\n    os::Linux::check_signal_handler(sig)\n\n// This method is a periodic task to check for misbehaving JNI applications\n// under CheckJNI, we can add any periodic checks here\n\nvoid os::run_periodic_checks() {\n\n  if (check_signals == false) return;\n\n  // SEGV and BUS if overridden could potentially prevent\n  // generation of hs*.log in the event of a crash, debugging\n  // such a case can be very challenging, so we absolutely\n  // check the following for a good measure:\n  DO_SIGNAL_CHECK(SIGSEGV);\n  DO_SIGNAL_CHECK(SIGILL);\n  DO_SIGNAL_CHECK(SIGFPE);\n  DO_SIGNAL_CHECK(SIGBUS);\n  DO_SIGNAL_CHECK(SIGPIPE);\n  DO_SIGNAL_CHECK(SIGXFSZ);\n#if defined(PPC64)\n  DO_SIGNAL_CHECK(SIGTRAP);\n#endif\n\n  // ReduceSignalUsage allows the user to override these handlers\n  // see comments at the very top and jvm_solaris.h\n  if (!ReduceSignalUsage) {\n    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n  }\n\n  DO_SIGNAL_CHECK(SR_signum);\n  DO_SIGNAL_CHECK(INTERRUPT_SIGNAL);\n}\n\ntypedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic os_sigaction_t os_sigaction = NULL;\n\nvoid os::Linux::check_signal_handler(int sig) {\n  char buf[O_BUFLEN];\n  address jvmHandler = NULL;\n\n\n  struct sigaction act;\n  if (os_sigaction == NULL) {\n    // only trust the default sigaction, in case it has been interposed\n    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n    if (os_sigaction == NULL) return;\n  }\n\n  os_sigaction(sig, (struct sigaction*)NULL, &act);\n\n\n  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n\n  address thisHandler = (act.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, act.sa_handler) ;\n\n\n  switch(sig) {\n  case SIGSEGV:\n  case SIGBUS:\n  case SIGFPE:\n  case SIGPIPE:\n  case SIGILL:\n  case SIGXFSZ:\n    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler);\n    break;\n\n  case SHUTDOWN1_SIGNAL:\n  case SHUTDOWN2_SIGNAL:\n  case SHUTDOWN3_SIGNAL:\n  case BREAK_SIGNAL:\n    jvmHandler = (address)user_handler();\n    break;\n\n  case INTERRUPT_SIGNAL:\n    jvmHandler = CAST_FROM_FN_PTR(address, SIG_DFL);\n    break;\n\n  default:\n    if (sig == SR_signum) {\n      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n    } else {\n      return;\n    }\n    break;\n  }\n\n  if (thisHandler != jvmHandler) {\n    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n    // Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n                    exception_name(sig, buf, O_BUFLEN));\n    }\n  } else if(os::Linux::get_our_sigflags(sig) != 0 && (int)act.sa_flags != os::Linux::get_our_sigflags(sig)) {\n    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:\" PTR32_FORMAT, os::Linux::get_our_sigflags(sig));\n    tty->print_cr(\"  found:\" PTR32_FORMAT, act.sa_flags);\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n  }\n\n  // Dump all the signal\n  if (sigismember(&check_signal_done, sig)) {\n    print_signal_handlers(tty, buf, O_BUFLEN);\n  }\n}\n\nextern void report_error(char* file_name, int line_no, char* title, char* format, ...);\n\nextern bool signal_name(int signo, char* buf, size_t len);\n\nconst char* os::exception_name(int exception_code, char* buf, size_t size) {\n  if (0 < exception_code && exception_code <= SIGRTMAX) {\n    // signal\n    if (!signal_name(exception_code, buf, size)) {\n      jio_snprintf(buf, size, \"SIG%d\", exception_code);\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\n// this is called _before_ the most of global arguments have been parsed\nvoid os::init(void) {\n  char dummy;   /* used to get a guess on initial stack address */\n//  first_hrtime = gethrtime();\n\n  // With LinuxThreads the JavaMain thread pid (primordial thread)\n  // is different than the pid of the java launcher thread.\n  // So, on Linux, the launcher thread pid is passed to the VM\n  // via the sun.java.launcher.pid property.\n  // Use this property instead of getpid() if it was correctly passed.\n  // See bug 6351349.\n  pid_t java_launcher_pid = (pid_t) Arguments::sun_java_launcher_pid();\n\n  _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();\n\n  clock_tics_per_sec = sysconf(_SC_CLK_TCK);\n\n  init_random(1234567);\n\n  ThreadCritical::initialize();\n\n  Linux::set_page_size(sysconf(_SC_PAGESIZE));\n  if (Linux::page_size() == -1) {\n    fatal(err_msg(\"os_linux.cpp: os::init: sysconf failed (%s)\",\n                  strerror(errno)));\n  }\n  init_page_sizes((size_t) Linux::page_size());\n\n  Linux::initialize_system_info();\n\n  // main_thread points to the aboriginal thread\n  Linux::_main_thread = pthread_self();\n\n  Linux::clock_init();\n  initial_time_count = javaTimeNanos();\n\n  // pthread_condattr initialization for monotonic clock\n  int status;\n  pthread_condattr_t* _condattr = os::Linux::condAttr();\n  if ((status = pthread_condattr_init(_condattr)) != 0) {\n    fatal(err_msg(\"pthread_condattr_init: %s\", strerror(status)));\n  }\n  // Only set the clock if CLOCK_MONOTONIC is available\n  if (Linux::supports_monotonic_clock()) {\n    if ((status = pthread_condattr_setclock(_condattr, CLOCK_MONOTONIC)) != 0) {\n      if (status == EINVAL) {\n        warning(\"Unable to use monotonic clock with relative timed-waits\" \\\n                \" - changes to the time-of-day clock may have adverse affects\");\n      } else {\n        fatal(err_msg(\"pthread_condattr_setclock: %s\", strerror(status)));\n      }\n    }\n  }\n  // else it defaults to CLOCK_REALTIME\n\n  pthread_mutex_init(&dl_mutex, NULL);\n\n  // If the pagesize of the VM is greater than 8K determine the appropriate\n  // number of initial guard pages.  The user can change this with the\n  // command line arguments, if needed.\n  if (vm_page_size() > (int)Linux::vm_default_page_size()) {\n    StackYellowPages = 1;\n    StackRedPages = 1;\n    StackShadowPages = round_to((StackShadowPages*Linux::vm_default_page_size()), vm_page_size()) / vm_page_size();\n  }\n}\n\n// To install functions for atexit system call\nextern \"C\" {\n  static void perfMemory_exit_helper() {\n    perfMemory_exit();\n  }\n}\n\n// this is called _after_ the global arguments have been parsed\njint os::init_2(void)\n{\n  Linux::fast_thread_clock_init();\n\n  // Allocate a single page and mark it as readable for safepoint polling\n  address polling_page = (address) ::mmap(NULL, Linux::page_size(), PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n  guarantee( polling_page != MAP_FAILED, \"os::init_2: failed to allocate polling page\" );\n\n  os::set_polling_page( polling_page );\n\n#ifndef PRODUCT\n  if(Verbose && PrintMiscellaneous)\n    tty->print(\"[SafePoint Polling address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)polling_page);\n#endif\n\n  if (!UseMembar) {\n    address mem_serialize_page = (address) ::mmap(NULL, Linux::page_size(), PROT_READ | PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    guarantee( mem_serialize_page != MAP_FAILED, \"mmap Failed for memory serialize page\");\n    os::set_memory_serialize_page( mem_serialize_page );\n\n#ifndef PRODUCT\n    if(Verbose && PrintMiscellaneous)\n      tty->print(\"[Memory Serialize  Page address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)mem_serialize_page);\n#endif\n  }\n\n  // initialize suspend/resume support - must do this before signal_sets_init()\n  if (SR_initialize() != 0) {\n    perror(\"SR_initialize failed\");\n    return JNI_ERR;\n  }\n\n  Linux::signal_sets_init();\n  Linux::install_signal_handlers();\n\n  // Check minimum allowable stack size for thread creation and to initialize\n  // the java system classes, including StackOverflowError - depends on page\n  // size.  Add a page for compiler2 recursion in main thread.\n  // Add in 2*BytesPerWord times page size to account for VM stack during\n  // class initialization depending on 32 or 64 bit VM.\n  os::Linux::min_stack_allowed = MAX2(os::Linux::min_stack_allowed,\n            (size_t)(StackYellowPages+StackRedPages+StackShadowPages) * Linux::page_size() +\n                    (2*BytesPerWord COMPILER2_PRESENT(+1)) * Linux::vm_default_page_size());\n\n  size_t threadStackSizeInBytes = ThreadStackSize * K;\n  if (threadStackSizeInBytes != 0 &&\n      threadStackSizeInBytes < os::Linux::min_stack_allowed) {\n        tty->print_cr(\"\\nThe stack size specified is too small, \"\n                      \"Specify at least %dk\",\n                      os::Linux::min_stack_allowed/ K);\n        return JNI_ERR;\n  }\n\n  // Make the stack size a multiple of the page size so that\n  // the yellow/red zones can be guarded.\n  JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,\n        vm_page_size()));\n\n  Linux::capture_initial_stack(JavaThread::stack_size_at_create());\n\n#if defined(IA32) && !defined(ZERO)\n  workaround_expand_exec_shield_cs_limit();\n#endif\n\n  Linux::libpthread_init();\n  if (PrintMiscellaneous && (Verbose || WizardMode)) {\n     tty->print_cr(\"[HotSpot is running with %s, %s(%s)]\\n\",\n          Linux::glibc_version(), Linux::libpthread_version(),\n          Linux::is_floating_stack() ? \"floating stack\" : \"fixed stack\");\n  }\n\n  if (UseNUMA) {\n    if (!Linux::libnuma_init()) {\n      UseNUMA = false;\n    } else {\n      if ((Linux::numa_max_node() < 1)) {\n        // There's only one node(they start from 0), disable NUMA.\n        UseNUMA = false;\n      }\n    }\n    // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there's no way\n    // we can make the adaptive lgrp chunk resizing work. If the user specified\n    // both UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn and\n    // disable adaptive resizing.\n    if (UseNUMA && UseLargePages && !can_commit_large_page_memory()) {\n      if (FLAG_IS_DEFAULT(UseNUMA)) {\n        UseNUMA = false;\n      } else {\n        if (FLAG_IS_DEFAULT(UseLargePages) &&\n            FLAG_IS_DEFAULT(UseSHM) &&\n            FLAG_IS_DEFAULT(UseHugeTLBFS)) {\n          UseLargePages = false;\n        } else {\n          warning(\"UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, disabling adaptive resizing\");\n          UseAdaptiveSizePolicy = false;\n          UseAdaptiveNUMAChunkSizing = false;\n        }\n      }\n    }\n    if (!UseNUMA && ForceNUMA) {\n      UseNUMA = true;\n    }\n  }\n\n  if (MaxFDLimit) {\n    // set the number of file descriptors to max. print out error\n    // if getrlimit/setrlimit fails but continue regardless.\n    struct rlimit nbr_files;\n    int status = getrlimit(RLIMIT_NOFILE, &nbr_files);\n    if (status != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode))\n        perror(\"os::init_2 getrlimit failed\");\n    } else {\n      nbr_files.rlim_cur = nbr_files.rlim_max;\n      status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n      if (status != 0) {\n        if (PrintMiscellaneous && (Verbose || WizardMode))\n          perror(\"os::init_2 setrlimit failed\");\n      }\n    }\n  }\n\n  // Initialize lock used to serialize thread creation (see os::create_thread)\n  Linux::set_createThread_lock(new Mutex(Mutex::leaf, \"createThread_lock\", false));\n\n  // at-exit methods are called in the reverse order of their registration.\n  // atexit functions are called on return from main or as a result of a\n  // call to exit(3C). There can be only 32 of these functions registered\n  // and atexit() does not set errno.\n\n  if (PerfAllowAtExitRegistration) {\n    // only register atexit functions if PerfAllowAtExitRegistration is set.\n    // atexit functions can be delayed until process exit time, which\n    // can be problematic for embedded VM situations. Embedded VMs should\n    // call DestroyJavaVM() to assure that VM resources are released.\n\n    // note: perfMemory_exit_helper atexit function may be removed in\n    // the future if the appropriate cleanup code can be added to the\n    // VM_Exit VMOperation's doit method.\n    if (atexit(perfMemory_exit_helper) != 0) {\n      warning(\"os::init_2 atexit(perfMemory_exit_helper) failed\");\n    }\n  }\n\n  // initialize thread priority policy\n  prio_init();\n\n  return JNI_OK;\n}\n\n// Mark the polling page as unreadable\nvoid os::make_polling_page_unreadable(void) {\n  if( !guard_memory((char*)_polling_page, Linux::page_size()) )\n    fatal(\"Could not disable polling page\");\n};\n\n// Mark the polling page as readable\nvoid os::make_polling_page_readable(void) {\n  if( !linux_mprotect((char *)_polling_page, Linux::page_size(), PROT_READ)) {\n    fatal(\"Could not enable polling page\");\n  }\n};\n\nstatic int os_cpu_count(const cpu_set_t* cpus) {\n  int count = 0;\n  // only look up to the number of configured processors\n  for (int i = 0; i < os::processor_count(); i++) {\n    if (CPU_ISSET(i, cpus)) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// Get the current number of available processors for this process.\n// This value can change at any time during a process's lifetime.\n// sched_getaffinity gives an accurate answer as it accounts for cpusets.\n// If anything goes wrong we fallback to returning the number of online\n// processors - which can be greater than the number available to the process.\nint os::active_processor_count() {\n  cpu_set_t cpus;  // can represent at most 1024 (CPU_SETSIZE) processors\n  int cpus_size = sizeof(cpu_set_t);\n  int cpu_count = 0;\n\n  // pid 0 means the current thread - which we have to assume represents the process\n  if (sched_getaffinity(0, cpus_size, &cpus) == 0) {\n    cpu_count = os_cpu_count(&cpus);\n    if (PrintActiveCpus) {\n      tty->print_cr(\"active_processor_count: sched_getaffinity processor count: %d\", cpu_count);\n    }\n  }\n  else {\n    cpu_count = ::sysconf(_SC_NPROCESSORS_ONLN);\n    warning(\"sched_getaffinity failed (%s)- using online processor count (%d) \"\n            \"which may exceed available processors\", strerror(errno), cpu_count);\n  }\n\n  assert(cpu_count > 0 && cpu_count <= processor_count(), \"sanity check\");\n  return cpu_count;\n}\n\nvoid os::set_native_thread_name(const char *name) {\n  // Not yet implemented.\n  return;\n}\n\nbool os::distribute_processes(uint length, uint* distribution) {\n  // Not yet implemented.\n  return false;\n}\n\nbool os::bind_to_processor(uint processor_id) {\n  // Not yet implemented.\n  return false;\n}\n\n///\n\nvoid os::SuspendedThreadTask::internal_do_task() {\n  if (do_suspend(_thread->osthread())) {\n    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n    do_task(context);\n    do_resume(_thread->osthread());\n  }\n}\n\nclass PcFetcher : public os::SuspendedThreadTask {\npublic:\n  PcFetcher(Thread* thread) : os::SuspendedThreadTask(thread) {}\n  ExtendedPC result();\nprotected:\n  void do_task(const os::SuspendedThreadTaskContext& context);\nprivate:\n  ExtendedPC _epc;\n};\n\nExtendedPC PcFetcher::result() {\n  guarantee(is_done(), \"task is not done yet.\");\n  return _epc;\n}\n\nvoid PcFetcher::do_task(const os::SuspendedThreadTaskContext& context) {\n  Thread* thread = context.thread();\n  OSThread* osthread = thread->osthread();\n  if (osthread->ucontext() != NULL) {\n    _epc = os::Linux::ucontext_get_pc((ucontext_t *) context.ucontext());\n  } else {\n    // NULL context is unexpected, double-check this is the VMThread\n    guarantee(thread->is_VM_thread(), \"can only be called for VMThread\");\n  }\n}\n\n// Suspends the target using the signal mechanism and then grabs the PC before\n// resuming the target. Used by the flat-profiler only\nExtendedPC os::get_thread_pc(Thread* thread) {\n  // Make sure that it is called by the watcher for the VMThread\n  assert(Thread::current()->is_Watcher_thread(), \"Must be watcher\");\n  assert(thread->is_VM_thread(), \"Can only be called for VMThread\");\n\n  PcFetcher fetcher(thread);\n  fetcher.run();\n  return fetcher.result();\n}\n\nint os::Linux::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime)\n{\n   if (is_NPTL()) {\n      return pthread_cond_timedwait(_cond, _mutex, _abstime);\n   } else {\n      // 6292965: LinuxThreads pthread_cond_timedwait() resets FPU control\n      // word back to default 64bit precision if condvar is signaled. Java\n      // wants 53bit precision.  Save and restore current value.\n      int fpu = get_fpu_control_word();\n      int status = pthread_cond_timedwait(_cond, _mutex, _abstime);\n      set_fpu_control_word(fpu);\n      return status;\n   }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// debug support\n\nbool os::find(address addr, outputStream* st) {\n  Dl_info dlinfo;\n  memset(&dlinfo, 0, sizeof(dlinfo));\n  if (dladdr(addr, &dlinfo) != 0) {\n    st->print(PTR_FORMAT \": \", addr);\n    if (dlinfo.dli_sname != NULL && dlinfo.dli_saddr != NULL) {\n      st->print(\"%s+%#x\", dlinfo.dli_sname,\n                 addr - (intptr_t)dlinfo.dli_saddr);\n    } else if (dlinfo.dli_fbase != NULL) {\n      st->print(\"<offset %#x>\", addr - (intptr_t)dlinfo.dli_fbase);\n    } else {\n      st->print(\"<absolute address>\");\n    }\n    if (dlinfo.dli_fname != NULL) {\n      st->print(\" in %s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL) {\n      st->print(\" at \" PTR_FORMAT, dlinfo.dli_fbase);\n    }\n    st->cr();\n\n    if (Verbose) {\n      // decode some bytes around the PC\n      address begin = clamp_address_in_page(addr-40, addr, os::vm_page_size());\n      address end   = clamp_address_in_page(addr+40, addr, os::vm_page_size());\n      address       lowest = (address) dlinfo.dli_sname;\n      if (!lowest)  lowest = (address) dlinfo.dli_fbase;\n      if (begin < lowest)  begin = lowest;\n      Dl_info dlinfo2;\n      if (dladdr(end, &dlinfo2) != 0 && dlinfo2.dli_saddr != dlinfo.dli_saddr\n          && end > dlinfo2.dli_saddr && dlinfo2.dli_saddr > begin)\n        end = (address) dlinfo2.dli_saddr;\n      Disassembler::decode(begin, end, st);\n    }\n    return true;\n  }\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// misc\n\n// This does not do anything on Linux. This is basically a hook for being\n// able to use structured exception handling (thread-local exception filters)\n// on, e.g., Win32.\nvoid\nos::os_exception_wrapper(java_call_t f, JavaValue* value, methodHandle* method,\n                         JavaCallArguments* args, Thread* thread) {\n  f(value, method, args, thread);\n}\n\nvoid os::print_statistics() {\n}\n\nint os::message_box(const char* title, const char* message) {\n  int i;\n  fdStream err(defaultStream::error_fd());\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n  err.print_raw_cr(title);\n  for (i = 0; i < 78; i++) err.print_raw(\"-\");\n  err.cr();\n  err.print_raw_cr(message);\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n\n  char buf[16];\n  // Prevent process from exiting upon \"read error\" without consuming all CPU\n  while (::read(0, buf, sizeof(buf)) <= 0) { ::sleep(100); }\n\n  return buf[0] == 'y' || buf[0] == 'Y';\n}\n\nint os::stat(const char *path, struct stat *sbuf) {\n  char pathbuf[MAX_PATH];\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  os::native_path(strcpy(pathbuf, path));\n  return ::stat(pathbuf, sbuf);\n}\n\nbool os::check_heap(bool force) {\n  return true;\n}\n\nint local_vsnprintf(char* buf, size_t count, const char* format, va_list args) {\n  return ::vsnprintf(buf, count, format, args);\n}\n\n// Is a (classpath) directory empty?\nbool os::dir_is_empty(const char* path) {\n  DIR *dir = NULL;\n  struct dirent *ptr;\n\n  dir = opendir(path);\n  if (dir == NULL) return true;\n\n  /* Scan the directory */\n  bool result = true;\n  char buf[sizeof(struct dirent) + MAX_PATH];\n  while (result && (ptr = ::readdir(dir)) != NULL) {\n    if (strcmp(ptr->d_name, \".\") != 0 && strcmp(ptr->d_name, \"..\") != 0) {\n      result = false;\n    }\n  }\n  closedir(dir);\n  return result;\n}\n\n// This code originates from JDK's sysOpen and open64_w\n// from src/solaris/hpi/src/system_md.c\n\n#ifndef O_DELETE\n#define O_DELETE 0x10000\n#endif\n\n// Open a file. Unlink the file immediately after open returns\n// if the specified oflag has the O_DELETE flag set.\n// O_DELETE is used only in j2se/src/share/native/java/util/zip/ZipFile.c\n\nint os::open(const char *path, int oflag, int mode) {\n\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  int o_delete = (oflag & O_DELETE);\n  oflag = oflag & ~O_DELETE;\n\n\n    /* All file descriptors that are opened in the Java process and not\n     * specifically destined for a subprocess should have the close-on-exec\n     * flag set.  If we don't set it, then careless 3rd party native code\n     * might fork and exec without closing all appropriate file descriptors\n     * (e.g. as we do in closeDescriptors in UNIXProcess.c), and this in\n     * turn might:\n     *\n     * - cause end-of-file to fail to be detected on some file\n     *   descriptors, resulting in mysterious hangs, or\n     *\n     * - might cause an fopen in the subprocess to fail on a system\n     *   suffering from bug 1085341.\n     *\n     * (Yes, the default setting of the close-on-exec flag is a Unix\n     * design flaw)\n     *\n     * See:\n     * 1085341: 32-bit stdio routines should support file descriptors >255\n     * 4843136: (process) pipe file descriptor from Runtime.exec not being closed\n     * 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9\n     */\n  // Modern Linux kernels (after 2.6.23 2007) support O_CLOEXEC with open().\n  // O_CLOEXEC is preferable to using FD_CLOEXEC on an open file descriptor\n  // because it saves a system call and removes a small window where the flag\n  // is unset.  On ancient Linux kernels the O_CLOEXEC flag will be ignored\n  // and we fall back to using FD_CLOEXEC (see below).\n#ifdef O_CLOEXEC\n  oflag |= O_CLOEXEC;\n#endif\n\n  int fd = ::open64(path, oflag, mode);\n  if (fd == -1) return -1;\n\n  //If the open succeeded, the file might still be a directory\n  {\n    struct stat64 buf64;\n    int ret = ::fstat64(fd, &buf64);\n    int st_mode = buf64.st_mode;\n\n    if (ret != -1) {\n      if ((st_mode & S_IFMT) == S_IFDIR) {\n        errno = EISDIR;\n        ::close(fd);\n        return -1;\n      }\n    } else {\n      ::close(fd);\n      return -1;\n    }\n  }\n\n#ifdef FD_CLOEXEC\n  // Validate that the use of the O_CLOEXEC flag on open above worked.\n  // With recent kernels, we will perform this check exactly once.\n  static sig_atomic_t O_CLOEXEC_is_known_to_work = 0;\n  if (!O_CLOEXEC_is_known_to_work) {\n    int flags = ::fcntl(fd, F_GETFD);\n    if (flags != -1) {\n      if ((flags & FD_CLOEXEC) != 0)\n        O_CLOEXEC_is_known_to_work = 1;\n      else\n\t::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n    }\n  }\n#endif\n\n  if (o_delete != 0) {\n    ::unlink(path);\n  }\n  return fd;\n}\n\n\n// create binary file, rewriting existing file if required\nint os::create_binary_file(const char* path, bool rewrite_existing) {\n  int oflags = O_WRONLY | O_CREAT;\n  if (!rewrite_existing) {\n    oflags |= O_EXCL;\n  }\n  return ::open64(path, oflags, S_IREAD | S_IWRITE);\n}\n\n// return current position of file pointer\njlong os::current_file_offset(int fd) {\n  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);\n}\n\n// move file pointer to the specified offset\njlong os::seek_to_file_offset(int fd, jlong offset) {\n  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);\n}\n\n// This code originates from JDK's sysAvailable\n// from src/solaris/hpi/src/native_threads/src/sys_api_td.c\n\nint os::available(int fd, jlong *bytes) {\n  jlong cur, end;\n  int mode;\n  struct stat64 buf64;\n\n  if (::fstat64(fd, &buf64) >= 0) {\n    mode = buf64.st_mode;\n    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n      /*\n      * XXX: is the following call interruptible? If so, this might\n      * need to go through the INTERRUPT_IO() wrapper as for other\n      * blocking, interruptible calls in this file.\n      */\n      int n;\n      if (::ioctl(fd, FIONREAD, &n) >= 0) {\n        *bytes = n;\n        return 1;\n      }\n    }\n  }\n  if ((cur = ::lseek64(fd, 0L, SEEK_CUR)) == -1) {\n    return 0;\n  } else if ((end = ::lseek64(fd, 0L, SEEK_END)) == -1) {\n    return 0;\n  } else if (::lseek64(fd, cur, SEEK_SET) == -1) {\n    return 0;\n  }\n  *bytes = end - cur;\n  return 1;\n}\n\nint os::socket_available(int fd, jint *pbytes) {\n  // Linux doc says EINTR not returned, unlike Solaris\n  int ret = ::ioctl(fd, FIONREAD, pbytes);\n\n  //%% note ioctl can return 0 when successful, JVM_SocketAvailable\n  // is expected to return 0 on failure and 1 on success to the jdk.\n  return (ret < 0) ? 0 : 1;\n}\n\n// Map a block of memory.\nchar* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,\n                     char *addr, size_t bytes, bool read_only,\n                     bool allow_exec) {\n  int prot;\n  int flags = MAP_PRIVATE;\n\n  if (read_only) {\n    prot = PROT_READ;\n  } else {\n    prot = PROT_READ | PROT_WRITE;\n  }\n\n  if (allow_exec) {\n    prot |= PROT_EXEC;\n  }\n\n  if (addr != NULL) {\n    flags |= MAP_FIXED;\n  }\n\n  char* mapped_address = (char*)mmap(addr, (size_t)bytes, prot, flags,\n                                     fd, file_offset);\n  if (mapped_address == MAP_FAILED) {\n    return NULL;\n  }\n  return mapped_address;\n}\n\n\n// Remap a block of memory.\nchar* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,\n                       char *addr, size_t bytes, bool read_only,\n                       bool allow_exec) {\n  // same as map_memory() on this OS\n  return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,\n                        allow_exec);\n}\n\n\n// Unmap a block of memory.\nbool os::pd_unmap_memory(char* addr, size_t bytes) {\n  return munmap(addr, bytes) == 0;\n}\n\nstatic jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time);\n\nstatic clockid_t thread_cpu_clockid(Thread* thread) {\n  pthread_t tid = thread->osthread()->pthread_id();\n  clockid_t clockid;\n\n  // Get thread clockid\n  int rc = os::Linux::pthread_getcpuclockid(tid, &clockid);\n  assert(rc == 0, \"pthread_getcpuclockid is expected to return 0 code\");\n  return clockid;\n}\n\n// current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)\n// are used by JVM M&M and JVMTI to get user+sys or user CPU time\n// of a thread.\n//\n// current_thread_cpu_time() and thread_cpu_time(Thread*) returns\n// the fast estimate available on the platform.\n\njlong os::current_thread_cpu_time() {\n  if (os::Linux::supports_fast_thread_cpu_time()) {\n    return os::Linux::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);\n  } else {\n    // return user + sys since the cost is the same\n    return slow_thread_cpu_time(Thread::current(), true /* user + sys */);\n  }\n}\n\njlong os::thread_cpu_time(Thread* thread) {\n  // consistent with what current_thread_cpu_time() returns\n  if (os::Linux::supports_fast_thread_cpu_time()) {\n    return os::Linux::fast_thread_cpu_time(thread_cpu_clockid(thread));\n  } else {\n    return slow_thread_cpu_time(thread, true /* user + sys */);\n  }\n}\n\njlong os::current_thread_cpu_time(bool user_sys_cpu_time) {\n  if (user_sys_cpu_time && os::Linux::supports_fast_thread_cpu_time()) {\n    return os::Linux::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);\n  } else {\n    return slow_thread_cpu_time(Thread::current(), user_sys_cpu_time);\n  }\n}\n\njlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {\n  if (user_sys_cpu_time && os::Linux::supports_fast_thread_cpu_time()) {\n    return os::Linux::fast_thread_cpu_time(thread_cpu_clockid(thread));\n  } else {\n    return slow_thread_cpu_time(thread, user_sys_cpu_time);\n  }\n}\n\n//\n//  -1 on error.\n//\n\nPRAGMA_DIAG_PUSH\nPRAGMA_FORMAT_NONLITERAL_IGNORED\nstatic jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {\n  static bool proc_task_unchecked = true;\n  static const char *proc_stat_path = \"/proc/%d/stat\";\n  pid_t  tid = thread->osthread()->thread_id();\n  char *s;\n  char stat[2048];\n  int statlen;\n  char proc_name[64];\n  int count;\n  long sys_time, user_time;\n  char cdummy;\n  int idummy;\n  long ldummy;\n  FILE *fp;\n\n  // The /proc/<tid>/stat aggregates per-process usage on\n  // new Linux kernels 2.6+ where NPTL is supported.\n  // The /proc/self/task/<tid>/stat still has the per-thread usage.\n  // See bug 6328462.\n  // There possibly can be cases where there is no directory\n  // /proc/self/task, so we check its availability.\n  if (proc_task_unchecked && os::Linux::is_NPTL()) {\n    // This is executed only once\n    proc_task_unchecked = false;\n    fp = fopen(\"/proc/self/task\", \"r\");\n    if (fp != NULL) {\n      proc_stat_path = \"/proc/self/task/%d/stat\";\n      fclose(fp);\n    }\n  }\n\n  sprintf(proc_name, proc_stat_path, tid);\n  fp = fopen(proc_name, \"r\");\n  if ( fp == NULL ) return -1;\n  statlen = fread(stat, 1, 2047, fp);\n  stat[statlen] = '\\0';\n  fclose(fp);\n\n  // Skip pid and the command string. Note that we could be dealing with\n  // weird command names, e.g. user could decide to rename java launcher\n  // to \"java 1.4.2 :)\", then the stat file would look like\n  //                1234 (java 1.4.2 :)) R ... ...\n  // We don't really need to know the command string, just find the last\n  // occurrence of \")\" and then start parsing from there. See bug 4726580.\n  s = strrchr(stat, ')');\n  if (s == NULL ) return -1;\n\n  // Skip blank chars\n  do s++; while (isspace(*s));\n\n  count = sscanf(s,\"%c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu\",\n                 &cdummy, &idummy, &idummy, &idummy, &idummy, &idummy,\n                 &ldummy, &ldummy, &ldummy, &ldummy, &ldummy,\n                 &user_time, &sys_time);\n  if ( count != 13 ) return -1;\n  if (user_sys_cpu_time) {\n    return ((jlong)sys_time + (jlong)user_time) * (1000000000 / clock_tics_per_sec);\n  } else {\n    return (jlong)user_time * (1000000000 / clock_tics_per_sec);\n  }\n}\nPRAGMA_DIAG_POP\n\nvoid os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nvoid os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nbool os::is_thread_cpu_time_supported() {\n  return true;\n}\n\n// System loadavg support.  Returns -1 if load average cannot be obtained.\n// Linux doesn't yet have a (official) notion of processor sets,\n// so just return the system wide load average.\nint os::loadavg(double loadavg[], int nelem) {\n  return ::getloadavg(loadavg, nelem);\n}\n\nvoid os::pause() {\n  char filename[MAX_PATH];\n  if (PauseAtStartupFile && PauseAtStartupFile[0]) {\n    jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);\n  } else {\n    jio_snprintf(filename, MAX_PATH, \"./vm.paused.%d\", current_process_id());\n  }\n\n  int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n  if (fd != -1) {\n    struct stat buf;\n    ::close(fd);\n    while (::stat(filename, &buf) == 0) {\n      (void)::poll(NULL, 0, 100);\n    }\n  } else {\n    jio_fprintf(stderr,\n      \"Could not open pause file '%s', continuing immediately.\\n\", filename);\n  }\n}\n\n\n// Refer to the comments in os_solaris.cpp park-unpark.\n//\n// Beware -- Some versions of NPTL embody a flaw where pthread_cond_timedwait() can\n// hang indefinitely.  For instance NPTL 0.60 on 2.4.21-4ELsmp is vulnerable.\n// For specifics regarding the bug see GLIBC BUGID 261237 :\n//    http://www.mail-archive.com/debian-glibc@lists.debian.org/msg10837.html.\n// Briefly, pthread_cond_timedwait() calls with an expiry time that's not in the future\n// will either hang or corrupt the condvar, resulting in subsequent hangs if the condvar\n// is used.  (The simple C test-case provided in the GLIBC bug report manifests the\n// hang).  The JVM is vulernable via sleep(), Object.wait(timo), LockSupport.parkNanos()\n// and monitorenter when we're using 1-0 locking.  All those operations may result in\n// calls to pthread_cond_timedwait().  Using LD_ASSUME_KERNEL to use an older version\n// of libpthread avoids the problem, but isn't practical.\n//\n// Possible remedies:\n//\n// 1.   Establish a minimum relative wait time.  50 to 100 msecs seems to work.\n//      This is palliative and probabilistic, however.  If the thread is preempted\n//      between the call to compute_abstime() and pthread_cond_timedwait(), more\n//      than the minimum period may have passed, and the abstime may be stale (in the\n//      past) resultin in a hang.   Using this technique reduces the odds of a hang\n//      but the JVM is still vulnerable, particularly on heavily loaded systems.\n//\n// 2.   Modify park-unpark to use per-thread (per ParkEvent) pipe-pairs instead\n//      of the usual flag-condvar-mutex idiom.  The write side of the pipe is set\n//      NDELAY. unpark() reduces to write(), park() reduces to read() and park(timo)\n//      reduces to poll()+read().  This works well, but consumes 2 FDs per extant\n//      thread.\n//\n// 3.   Embargo pthread_cond_timedwait() and implement a native \"chron\" thread\n//      that manages timeouts.  We'd emulate pthread_cond_timedwait() by enqueuing\n//      a timeout request to the chron thread and then blocking via pthread_cond_wait().\n//      This also works well.  In fact it avoids kernel-level scalability impediments\n//      on certain platforms that don't handle lots of active pthread_cond_timedwait()\n//      timers in a graceful fashion.\n//\n// 4.   When the abstime value is in the past it appears that control returns\n//      correctly from pthread_cond_timedwait(), but the condvar is left corrupt.\n//      Subsequent timedwait/wait calls may hang indefinitely.  Given that, we\n//      can avoid the problem by reinitializing the condvar -- by cond_destroy()\n//      followed by cond_init() -- after all calls to pthread_cond_timedwait().\n//      It may be possible to avoid reinitialization by checking the return\n//      value from pthread_cond_timedwait().  In addition to reinitializing the\n//      condvar we must establish the invariant that cond_signal() is only called\n//      within critical sections protected by the adjunct mutex.  This prevents\n//      cond_signal() from \"seeing\" a condvar that's in the midst of being\n//      reinitialized or that is corrupt.  Sadly, this invariant obviates the\n//      desirable signal-after-unlock optimization that avoids futile context switching.\n//\n//      I'm also concerned that some versions of NTPL might allocate an auxilliary\n//      structure when a condvar is used or initialized.  cond_destroy()  would\n//      release the helper structure.  Our reinitialize-after-timedwait fix\n//      put excessive stress on malloc/free and locks protecting the c-heap.\n//\n// We currently use (4).  See the WorkAroundNTPLTimedWaitHang flag.\n// It may be possible to refine (4) by checking the kernel and NTPL verisons\n// and only enabling the work-around for vulnerable environments.\n\n// utility to compute the abstime argument to timedwait:\n// millis is the relative timeout time\n// abstime will be the absolute timeout time\n// TODO: replace compute_abstime() with unpackTime()\n\nstatic struct timespec* compute_abstime(timespec* abstime, jlong millis) {\n  if (millis < 0)  millis = 0;\n\n  jlong seconds = millis / 1000;\n  millis %= 1000;\n  if (seconds > 50000000) { // see man cond_timedwait(3T)\n    seconds = 50000000;\n  }\n\n  if (os::Linux::supports_monotonic_clock()) {\n    struct timespec now;\n    int status = os::Linux::clock_gettime(CLOCK_MONOTONIC, &now);\n    assert_status(status == 0, status, \"clock_gettime\");\n    abstime->tv_sec = now.tv_sec  + seconds;\n    long nanos = now.tv_nsec + millis * NANOSECS_PER_MILLISEC;\n    if (nanos >= NANOSECS_PER_SEC) {\n      abstime->tv_sec += 1;\n      nanos -= NANOSECS_PER_SEC;\n    }\n    abstime->tv_nsec = nanos;\n  } else {\n    struct timeval now;\n    int status = gettimeofday(&now, NULL);\n    assert(status == 0, \"gettimeofday\");\n    abstime->tv_sec = now.tv_sec  + seconds;\n    long usec = now.tv_usec + millis * 1000;\n    if (usec >= 1000000) {\n      abstime->tv_sec += 1;\n      usec -= 1000000;\n    }\n    abstime->tv_nsec = usec * 1000;\n  }\n  return abstime;\n}\n\n\n// Test-and-clear _Event, always leaves _Event set to 0, returns immediately.\n// Conceptually TryPark() should be equivalent to park(0).\n\nint os::PlatformEvent::TryPark() {\n  for (;;) {\n    const int v = _Event ;\n    guarantee ((v == 0) || (v == 1), \"invariant\") ;\n    if (Atomic::cmpxchg (0, &_Event, v) == v) return v  ;\n  }\n}\n\nvoid os::PlatformEvent::park() {       // AKA \"down()\"\n  // Invariant: Only the thread associated with the Event/PlatformEvent\n  // may call park().\n  // TODO: assert that _Assoc != NULL or _Assoc == Self\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v == 0) {\n     // Do this the hard way by blocking ...\n     int status = pthread_mutex_lock(_mutex);\n     assert_status(status == 0, status, \"mutex_lock\");\n     guarantee (_nParked == 0, \"invariant\") ;\n     ++ _nParked ;\n     while (_Event < 0) {\n        status = pthread_cond_wait(_cond, _mutex);\n        // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...\n        // Treat this the same as if the wait was interrupted\n        if (status == ETIME) { status = EINTR; }\n        assert_status(status == 0 || status == EINTR, status, \"cond_wait\");\n     }\n     -- _nParked ;\n\n    _Event = 0 ;\n     status = pthread_mutex_unlock(_mutex);\n     assert_status(status == 0, status, \"mutex_unlock\");\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other.\n    OrderAccess::fence();\n  }\n  guarantee (_Event >= 0, \"invariant\") ;\n}\n\nint os::PlatformEvent::park(jlong millis) {\n  guarantee (_nParked == 0, \"invariant\") ;\n\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v != 0) return OS_OK ;\n\n  // We do this the hard way, by blocking the thread.\n  // Consider enforcing a minimum timeout value.\n  struct timespec abst;\n  compute_abstime(&abst, millis);\n\n  int ret = OS_TIMEOUT;\n  int status = pthread_mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  guarantee (_nParked == 0, \"invariant\") ;\n  ++_nParked ;\n\n  // Object.wait(timo) will return because of\n  // (a) notification\n  // (b) timeout\n  // (c) thread.interrupt\n  //\n  // Thread.interrupt and object.notify{All} both call Event::set.\n  // That is, we treat thread.interrupt as a special case of notification.\n  // The underlying Solaris implementation, cond_timedwait, admits\n  // spurious/premature wakeups, but the JLS/JVM spec prevents the\n  // JVM from making those visible to Java code.  As such, we must\n  // filter out spurious wakeups.  We assume all ETIME returns are valid.\n  //\n  // TODO: properly differentiate simultaneous notify+interrupt.\n  // In that case, we should propagate the notify to another waiter.\n\n  while (_Event < 0) {\n    status = os::Linux::safe_cond_timedwait(_cond, _mutex, &abst);\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (_cond);\n      pthread_cond_init (_cond, os::Linux::condAttr()) ;\n    }\n    assert_status(status == 0 || status == EINTR ||\n                  status == ETIME || status == ETIMEDOUT,\n                  status, \"cond_timedwait\");\n    if (!FilterSpuriousWakeups) break ;                 // previous semantics\n    if (status == ETIME || status == ETIMEDOUT) break ;\n    // We consume and ignore EINTR and spurious wakeups.\n  }\n  --_nParked ;\n  if (_Event >= 0) {\n     ret = OS_OK;\n  }\n  _Event = 0 ;\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  assert (_nParked == 0, \"invariant\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other.\n  OrderAccess::fence();\n  return ret;\n}\n\nvoid os::PlatformEvent::unpark() {\n  // Transitions for _Event:\n  //    0 :=> 1\n  //    1 :=> 1\n  //   -1 :=> either 0 or 1; must signal target thread\n  //          That is, we can safely transition _Event from -1 to either\n  //          0 or 1. Forcing 1 is slightly more efficient for back-to-back\n  //          unpark() calls.\n  // See also: \"Semaphores in Plan 9\" by Mullender & Cox\n  //\n  // Note: Forcing a transition from \"-1\" to \"1\" on an unpark() means\n  // that it will take two back-to-back park() calls for the owning\n  // thread to block. This has the benefit of forcing a spurious return\n  // from the first park() call after an unpark() call which will help\n  // shake out uses of park() and unpark() without condition variables.\n\n  if (Atomic::xchg(1, &_Event) >= 0) return;\n\n  // Wait for the thread associated with the event to vacate\n  int status = pthread_mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  int AnyWaiters = _nParked;\n  assert(AnyWaiters == 0 || AnyWaiters == 1, \"invariant\");\n  if (AnyWaiters != 0 && WorkAroundNPTLTimedWaitHang) {\n    AnyWaiters = 0;\n    pthread_cond_signal(_cond);\n  }\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  if (AnyWaiters != 0) {\n    status = pthread_cond_signal(_cond);\n    assert_status(status == 0, status, \"cond_signal\");\n  }\n\n  // Note that we signal() _after dropping the lock for \"immortal\" Events.\n  // This is safe and avoids a common class of  futile wakeups.  In rare\n  // circumstances this can cause a thread to return prematurely from\n  // cond_{timed}wait() but the spurious wakeup is benign and the victim will\n  // simply re-test the condition and re-park itself.\n}\n\n\n// JSR166\n// -------------------------------------------------------\n\n/*\n * The solaris and linux implementations of park/unpark are fairly\n * conservative for now, but can be improved. They currently use a\n * mutex/condvar pair, plus a a count.\n * Park decrements count if > 0, else does a condvar wait.  Unpark\n * sets count to 1 and signals condvar.  Only one thread ever waits\n * on the condvar. Contention seen when trying to park implies that someone\n * is unparking you, so don't wait. And spurious returns are fine, so there\n * is no need to track notifications.\n */\n\n/*\n * This code is common to linux and solaris and will be moved to a\n * common place in dolphin.\n *\n * The passed in time value is either a relative time in nanoseconds\n * or an absolute time in milliseconds. Either way it has to be unpacked\n * into suitable seconds and nanoseconds components and stored in the\n * given timespec structure.\n * Given time is a 64-bit value and the time_t used in the timespec is only\n * a signed-32-bit value (except on 64-bit Linux) we have to watch for\n * overflow if times way in the future are given. Further on Solaris versions\n * prior to 10 there is a restriction (see cond_timedwait) that the specified\n * number of seconds, in abstime, is less than current_time  + 100,000,000.\n * As it will be 28 years before \"now + 100000000\" will overflow we can\n * ignore overflow and just impose a hard-limit on seconds using the value\n * of \"now + 100,000,000\". This places a limit on the timeout of about 3.17\n * years from \"now\".\n */\n\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {\n  assert (time > 0, \"convertTime\");\n  time_t max_secs = 0;\n\n  if (!os::Linux::supports_monotonic_clock() || isAbsolute) {\n    struct timeval now;\n    int status = gettimeofday(&now, NULL);\n    assert(status == 0, \"gettimeofday\");\n\n    max_secs = now.tv_sec + MAX_SECS;\n\n    if (isAbsolute) {\n      jlong secs = time / 1000;\n      if (secs > max_secs) {\n        absTime->tv_sec = max_secs;\n      } else {\n        absTime->tv_sec = secs;\n      }\n      absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;\n    } else {\n      jlong secs = time / NANOSECS_PER_SEC;\n      if (secs >= MAX_SECS) {\n        absTime->tv_sec = max_secs;\n        absTime->tv_nsec = 0;\n      } else {\n        absTime->tv_sec = now.tv_sec + secs;\n        absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;\n        if (absTime->tv_nsec >= NANOSECS_PER_SEC) {\n          absTime->tv_nsec -= NANOSECS_PER_SEC;\n          ++absTime->tv_sec; // note: this must be <= max_secs\n        }\n      }\n    }\n  } else {\n    // must be relative using monotonic clock\n    struct timespec now;\n    int status = os::Linux::clock_gettime(CLOCK_MONOTONIC, &now);\n    assert_status(status == 0, status, \"clock_gettime\");\n    max_secs = now.tv_sec + MAX_SECS;\n    jlong secs = time / NANOSECS_PER_SEC;\n    if (secs >= MAX_SECS) {\n      absTime->tv_sec = max_secs;\n      absTime->tv_nsec = 0;\n    } else {\n      absTime->tv_sec = now.tv_sec + secs;\n      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_nsec;\n      if (absTime->tv_nsec >= NANOSECS_PER_SEC) {\n        absTime->tv_nsec -= NANOSECS_PER_SEC;\n        ++absTime->tv_sec; // note: this must be <= max_secs\n      }\n    }\n  }\n  assert(absTime->tv_sec >= 0, \"tv_sec < 0\");\n  assert(absTime->tv_sec <= max_secs, \"tv_sec > max_secs\");\n  assert(absTime->tv_nsec >= 0, \"tv_nsec < 0\");\n  assert(absTime->tv_nsec < NANOSECS_PER_SEC, \"tv_nsec >= nanos_per_sec\");\n}\n\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n  JavaThread *jt = (JavaThread *)thread;\n\n  // Optional optimization -- avoid state transitions if there's an interrupt pending.\n  // Check interrupt before trying to wait\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n\n  // Next, demultiplex/decode time arguments\n  timespec absTime;\n  if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all\n    return;\n  }\n  if (time > 0) {\n    unpackTime(&absTime, isAbsolute, time);\n  }\n\n\n  // Enter safepoint region\n  // Beware of deadlocks such as 6317397.\n  // The per-thread Parker:: mutex is a classic leaf-lock.\n  // In particular a thread must never block on the Threads_lock while\n  // holding the Parker:: mutex.  If safepoints are pending both the\n  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.\n  ThreadBlockInVM tbivm(jt);\n\n  // Don't wait if cannot get lock since interference arises from\n  // unblocking.  Also. check interrupt before trying wait\n  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {\n    return;\n  }\n\n  int status ;\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other and Java-level accesses.\n    OrderAccess::fence();\n    return;\n  }\n\n#ifdef ASSERT\n  // Don't catch signals while blocked; let the running threads have the signals.\n  // (This allows a debugger to break into the running thread.)\n  sigset_t oldsigs;\n  sigset_t* allowdebug_blocked = os::Linux::allowdebug_blocked_signals();\n  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);\n#endif\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n  assert(_cur_index == -1, \"invariant\");\n  if (time == 0) {\n    _cur_index = REL_INDEX; // arbitrary choice when not timed\n    status = pthread_cond_wait (&_cond[_cur_index], _mutex) ;\n  } else {\n    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;\n    status = os::Linux::safe_cond_timedwait (&_cond[_cur_index], _mutex, &absTime) ;\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (&_cond[_cur_index]) ;\n      pthread_cond_init    (&_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());\n    }\n  }\n  _cur_index = -1;\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIME || status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other and Java-level accesses.\n  OrderAccess::fence();\n\n  // If externally suspended while waiting, re-suspend\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n}\n\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n    // thread might be parked\n    if (_cur_index != -1) {\n      // thread is definitely parked\n      if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (&_cond[_cur_index]);\n        assert (status == 0, \"invariant\");\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n      } else {\n        // must capture correct index before unlocking\n        int index = _cur_index;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n        status = pthread_cond_signal (&_cond[index]);\n        assert (status == 0, \"invariant\");\n      }\n    } else {\n      pthread_mutex_unlock(_mutex);\n      assert (status == 0, \"invariant\") ;\n    }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n\n\nextern char** environ;\n\n// Run the specified command in a separate process. Return its exit value,\n// or -1 on failure (e.g. can't fork a new process).\n// Unlike system(), this function can be called from signal handler. It\n// doesn't block SIGINT et al.\nint os::fork_and_exec(char* cmd) {\n  const char * argv[4] = {\"sh\", \"-c\", cmd, NULL};\n\n  pid_t pid = fork();\n\n  if (pid < 0) {\n    // fork failed\n    return -1;\n\n  } else if (pid == 0) {\n    // child process\n\n    execve(\"/bin/sh\", (char* const*)argv, environ);\n\n    // execve failed\n    _exit(-1);\n\n  } else  {\n    // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n    // care about the actual exit code, for now.\n\n    int status;\n\n    // Wait for the child process to exit.  This returns immediately if\n    // the child has already exited. */\n    while (waitpid(pid, &status, 0) < 0) {\n        switch (errno) {\n        case ECHILD: return 0;\n        case EINTR: break;\n        default: return -1;\n        }\n    }\n\n    if (WIFEXITED(status)) {\n       // The child exited normally; get its exit code.\n       return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n       // The child exited because of a signal\n       // The best value to return is 0x80 + signal number,\n       // because that is what all Unix shells do, and because\n       // it allows callers to distinguish between process exit and\n       // process death by signal.\n       return 0x80 + WTERMSIG(status);\n    } else {\n       // Unknown exit code; pass it through\n       return status;\n    }\n  }\n}\n\n// is_headless_jre()\n//\n// Test for the existence of xawt/libmawt.so or libawt_xawt.so\n// in order to report if we are running in a headless jre\n//\n// Since JDK8 xawt/libmawt.so was moved into the same directory\n// as libawt.so, and renamed libawt_xawt.so\n//\nbool os::is_headless_jre() {\n    struct stat statbuf;\n    char buf[MAXPATHLEN];\n    char libmawtpath[MAXPATHLEN];\n    const char *xawtstr  = \"/xawt/libmawt.so\";\n    const char *new_xawtstr = \"/libawt_xawt.so\";\n    char *p;\n\n    // Get path to libjvm.so\n    os::jvm_path(buf, sizeof(buf));\n\n    // Get rid of libjvm.so\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // Get rid of client or server\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // check xawt/libmawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    // check libawt_xawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, new_xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    return true;\n}\n\n// Get the default path to the core file\n// Returns the length of the string\nint os::get_core_path(char* buffer, size_t bufferSize) {\n  const char* p = get_current_directory(buffer, bufferSize);\n\n  if (p == NULL) {\n    assert(p != NULL, \"failed to get current directory\");\n    return 0;\n  }\n\n  return strlen(buffer);\n}\n\n/////////////// Unit tests ///////////////\n\n#ifndef PRODUCT\n\n#define test_log(...) \\\n  do {\\\n    if (VerboseInternalVMTests) { \\\n      tty->print_cr(__VA_ARGS__); \\\n      tty->flush(); \\\n    }\\\n  } while (false)\n\nclass TestReserveMemorySpecial : AllStatic {\n public:\n  static void small_page_write(void* addr, size_t size) {\n    size_t page_size = os::vm_page_size();\n\n    char* end = (char*)addr + size;\n    for (char* p = (char*)addr; p < end; p += page_size) {\n      *p = 1;\n    }\n  }\n\n  static void test_reserve_memory_special_huge_tlbfs_only(size_t size) {\n    if (!UseHugeTLBFS) {\n      return;\n    }\n\n    test_log(\"test_reserve_memory_special_huge_tlbfs_only(\" SIZE_FORMAT \")\", size);\n\n    char* addr = os::Linux::reserve_memory_special_huge_tlbfs_only(size, NULL, false);\n\n    if (addr != NULL) {\n      small_page_write(addr, size);\n\n      os::Linux::release_memory_special_huge_tlbfs(addr, size);\n    }\n  }\n\n  static void test_reserve_memory_special_huge_tlbfs_only() {\n    if (!UseHugeTLBFS) {\n      return;\n    }\n\n    size_t lp = os::large_page_size();\n\n    for (size_t size = lp; size <= lp * 10; size += lp) {\n      test_reserve_memory_special_huge_tlbfs_only(size);\n    }\n  }\n\n  static void test_reserve_memory_special_huge_tlbfs_mixed() {\n    size_t lp = os::large_page_size();\n    size_t ag = os::vm_allocation_granularity();\n\n    // sizes to test\n    const size_t sizes[] = {\n      lp, lp + ag, lp + lp / 2, lp * 2,\n      lp * 2 + ag, lp * 2 - ag, lp * 2 + lp / 2,\n      lp * 10, lp * 10 + lp / 2\n    };\n    const int num_sizes = sizeof(sizes) / sizeof(size_t);\n\n    // For each size/alignment combination, we test three scenarios:\n    // 1) with req_addr == NULL\n    // 2) with a non-null req_addr at which we expect to successfully allocate\n    // 3) with a non-null req_addr which contains a pre-existing mapping, at which we\n    //    expect the allocation to either fail or to ignore req_addr\n\n    // Pre-allocate two areas; they shall be as large as the largest allocation\n    //  and aligned to the largest alignment we will be testing.\n    const size_t mapping_size = sizes[num_sizes - 1] * 2;\n    char* const mapping1 = (char*) ::mmap(NULL, mapping_size,\n      PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n      -1, 0);\n    assert(mapping1 != MAP_FAILED, \"should work\");\n\n    char* const mapping2 = (char*) ::mmap(NULL, mapping_size,\n      PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n      -1, 0);\n    assert(mapping2 != MAP_FAILED, \"should work\");\n\n    // Unmap the first mapping, but leave the second mapping intact: the first\n    // mapping will serve as a value for a \"good\" req_addr (case 2). The second\n    // mapping, still intact, as \"bad\" req_addr (case 3).\n    ::munmap(mapping1, mapping_size);\n\n    // Case 1\n    test_log(\"%s, req_addr NULL:\", __FUNCTION__);\n    test_log(\"size            align           result\");\n\n    for (int i = 0; i < num_sizes; i++) {\n      const size_t size = sizes[i];\n      for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n        char* p = os::Linux::reserve_memory_special_huge_tlbfs_mixed(size, alignment, NULL, false);\n        test_log(SIZE_FORMAT_HEX \" \" SIZE_FORMAT_HEX \" ->  \" PTR_FORMAT \" %s\",\n            size, alignment, p, (p != NULL ? \"\" : \"(failed)\"));\n        if (p != NULL) {\n          assert(is_ptr_aligned(p, alignment), \"must be\");\n          small_page_write(p, size);\n          os::Linux::release_memory_special_huge_tlbfs(p, size);\n        }\n      }\n    }\n\n    // Case 2\n    test_log(\"%s, req_addr non-NULL:\", __FUNCTION__);\n    test_log(\"size            align           req_addr         result\");\n\n    for (int i = 0; i < num_sizes; i++) {\n      const size_t size = sizes[i];\n      for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n        char* const req_addr = (char*) align_ptr_up(mapping1, alignment);\n        char* p = os::Linux::reserve_memory_special_huge_tlbfs_mixed(size, alignment, req_addr, false);\n        test_log(SIZE_FORMAT_HEX \" \" SIZE_FORMAT_HEX \" \" PTR_FORMAT \" ->  \" PTR_FORMAT \" %s\",\n            size, alignment, req_addr, p,\n            ((p != NULL ? (p == req_addr ? \"(exact match)\" : \"\") : \"(failed)\")));\n        if (p != NULL) {\n          assert(p == req_addr, \"must be\");\n          small_page_write(p, size);\n          os::Linux::release_memory_special_huge_tlbfs(p, size);\n        }\n      }\n    }\n\n    // Case 3\n    test_log(\"%s, req_addr non-NULL with preexisting mapping:\", __FUNCTION__);\n    test_log(\"size            align           req_addr         result\");\n\n    for (int i = 0; i < num_sizes; i++) {\n      const size_t size = sizes[i];\n      for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n        char* const req_addr = (char*) align_ptr_up(mapping2, alignment);\n        char* p = os::Linux::reserve_memory_special_huge_tlbfs_mixed(size, alignment, req_addr, false);\n        test_log(SIZE_FORMAT_HEX \" \" SIZE_FORMAT_HEX \" \" PTR_FORMAT \" ->  \" PTR_FORMAT \" %s\",\n            size, alignment, req_addr, p,\n            ((p != NULL ? \"\" : \"(failed)\")));\n        // as the area around req_addr contains already existing mappings, the API should always\n        // return NULL (as per contract, it cannot return another address)\n        assert(p == NULL, \"must be\");\n      }\n    }\n\n    ::munmap(mapping2, mapping_size);\n\n  }\n\n  static void test_reserve_memory_special_huge_tlbfs() {\n    if (!UseHugeTLBFS) {\n      return;\n    }\n\n    test_reserve_memory_special_huge_tlbfs_only();\n    test_reserve_memory_special_huge_tlbfs_mixed();\n  }\n\n  static void test_reserve_memory_special_shm(size_t size, size_t alignment) {\n    if (!UseSHM) {\n      return;\n    }\n\n    test_log(\"test_reserve_memory_special_shm(\" SIZE_FORMAT \", \" SIZE_FORMAT \")\", size, alignment);\n\n    char* addr = os::Linux::reserve_memory_special_shm(size, alignment, NULL, false);\n\n    if (addr != NULL) {\n      assert(is_ptr_aligned(addr, alignment), \"Check\");\n      assert(is_ptr_aligned(addr, os::large_page_size()), \"Check\");\n\n      small_page_write(addr, size);\n\n      os::Linux::release_memory_special_shm(addr, size);\n    }\n  }\n\n  static void test_reserve_memory_special_shm() {\n    size_t lp = os::large_page_size();\n    size_t ag = os::vm_allocation_granularity();\n\n    for (size_t size = ag; size < lp * 3; size += ag) {\n      for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {\n        test_reserve_memory_special_shm(size, alignment);\n      }\n    }\n  }\n\n  static void test() {\n    test_reserve_memory_special_huge_tlbfs();\n    test_reserve_memory_special_shm();\n  }\n};\n\nvoid TestReserveMemorySpecial_test() {\n  TestReserveMemorySpecial::test();\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os/linux/vm/jsig.c": "/*\n * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n/* CopyrightVersion 1.2 */\n\n/* This is a special library that should be loaded before libc &\n * libthread to interpose the signal handler installation functions:\n * sigaction(), signal(), sigset().\n * Used for signal-chaining. See RFE 4381843.\n */\n\n#include <signal.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define bool int\n#define true 1\n#define false 0\n\n#define MAXSIGNUM 32\n#define MASK(sig) ((unsigned int)1 << sig)\n\nstatic struct sigaction sact[MAXSIGNUM]; /* saved signal handlers */\nstatic unsigned int jvmsigs = 0; /* signals used by jvm */\n\n/* used to synchronize the installation of signal handlers */\nstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t tid = 0;\n\ntypedef void (*sa_handler_t)(int);\ntypedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\ntypedef sa_handler_t (*signal_t)(int, sa_handler_t);\ntypedef int (*sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic signal_t os_signal = 0; /* os's version of signal()/sigset() */\nstatic sigaction_t os_sigaction = 0; /* os's version of sigaction() */\n\nstatic bool jvm_signal_installing = false;\nstatic bool jvm_signal_installed = false;\n\nstatic void signal_lock() {\n  pthread_mutex_lock(&mutex);\n  /* When the jvm is installing its set of signal handlers, threads\n   * other than the jvm thread should wait */\n  if (jvm_signal_installing) {\n    if (tid != pthread_self()) {\n      pthread_cond_wait(&cond, &mutex);\n    }\n  }\n}\n\nstatic void signal_unlock() {\n  pthread_mutex_unlock(&mutex);\n}\n\nstatic sa_handler_t call_os_signal(int sig, sa_handler_t disp,\n                                   bool is_sigset) {\n  if (os_signal == NULL) {\n    if (!is_sigset) {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"signal\");\n    } else {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"sigset\");\n    }\n    if (os_signal == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_signal)(sig, disp);\n}\n\nstatic void save_signal_handler(int sig, sa_handler_t disp) {\n  sigset_t set;\n  sact[sig].sa_handler = disp;\n  sigemptyset(&set);\n  sact[sig].sa_mask = set;\n  sact[sig].sa_flags = 0;\n}\n\nstatic sa_handler_t set_signal(int sig, sa_handler_t disp, bool is_sigset) {\n  sa_handler_t oldhandler;\n  bool sigused;\n\n  signal_lock();\n\n  sigused = (sig < MAXSIGNUM) && ((MASK(sig) & jvmsigs) != 0);\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    oldhandler = sact[sig].sa_handler;\n    save_signal_handler(sig, disp);\n\n    signal_unlock();\n    return oldhandler;\n  } else if (sig < MAXSIGNUM && jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. jvm uses sigaction().\n     * Leave the piece here just in case. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n    save_signal_handler(sig, oldhandler);\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return oldhandler;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n\n    signal_unlock();\n    return oldhandler;\n  }\n}\n\nsa_handler_t signal(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, false);\n}\n\nsa_handler_t sigset(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, true);\n }\n\nstatic int call_os_sigaction(int sig, const struct sigaction  *act,\n                             struct sigaction *oact) {\n  if (os_sigaction == NULL) {\n    os_sigaction = (sigaction_t)dlsym(RTLD_NEXT, \"sigaction\");\n    if (os_sigaction == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_sigaction)(sig, act, oact);\n}\n\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact) {\n  int res;\n  bool sigused;\n  struct sigaction oldAct;\n\n  signal_lock();\n\n  sigused = (sig < MAXSIGNUM) && ((MASK(sig) & jvmsigs) != 0);\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    if (oact != NULL) {\n      *oact = sact[sig];\n    }\n    if (act != NULL) {\n      sact[sig] = *act;\n    }\n\n    signal_unlock();\n    return 0;\n  } else if (sig < MAXSIGNUM && jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. */\n    res = call_os_sigaction(sig, act, &oldAct);\n    sact[sig] = oldAct;\n    if (oact != NULL) {\n      *oact = oldAct;\n    }\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return res;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    res = call_os_sigaction(sig, act, oact);\n\n    signal_unlock();\n    return res;\n  }\n}\n\n/* The three functions for the jvm to call into */\nvoid JVM_begin_signal_setting() {\n  signal_lock();\n  jvm_signal_installing = true;\n  tid = pthread_self();\n  signal_unlock();\n}\n\nvoid JVM_end_signal_setting() {\n  signal_lock();\n  jvm_signal_installed = true;\n  jvm_signal_installing = false;\n  pthread_cond_broadcast(&cond);\n  signal_unlock();\n}\n\nstruct sigaction *JVM_get_signal_action(int sig) {\n  /* Does race condition make sense here? */\n  if ((MASK(sig) & jvmsigs) != 0) {\n    return &sact[sig];\n  }\n  return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os/solaris/vm/jsig.c": "/*\n * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n/* CopyrightVersion 1.2 */\n\n/* This is a special library that should be loaded before libc &\n * libthread to interpose the signal handler installation functions:\n * sigaction(), signal(), sigset().\n * Used for signal-chaining. See RFE 4381843.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n#include <dlfcn.h>\n#include <thread.h>\n#include <synch.h>\n#include \"jvm_solaris.h\"\n\n#define bool int\n#define true 1\n#define false 0\n\nstatic struct sigaction *sact = (struct sigaction *)NULL; /* saved signal handlers */\nstatic sigset_t jvmsigs;\n\n/* used to synchronize the installation of signal handlers */\nstatic mutex_t mutex = DEFAULTMUTEX;\nstatic cond_t cond = DEFAULTCV;\nstatic thread_t tid = 0;\n\ntypedef void (*sa_handler_t)(int);\ntypedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\ntypedef sa_handler_t (*signal_t)(int, sa_handler_t);\ntypedef int (*sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic signal_t os_signal = 0; /* os's version of signal()/sigset() */\nstatic sigaction_t os_sigaction = 0; /* os's version of sigaction() */\n\nstatic bool jvm_signal_installing = false;\nstatic bool jvm_signal_installed = false;\n\n\n/* assume called within signal_lock */\nstatic void allocate_sact() {\n  size_t maxsignum;\n  maxsignum = SIGRTMAX;\n  if (sact == NULL) {\n    sact = (struct sigaction *)malloc((maxsignum+1) * (size_t)sizeof(struct sigaction));\n    memset(sact, 0, (maxsignum+1) * (size_t)sizeof(struct sigaction));\n  }\n\n  if (sact == NULL) {\n    printf(\"%s\\n\", \"libjsig.so unable to allocate memory\");\n    exit(0);\n  }\n\n  sigemptyset(&jvmsigs);\n}\n\nstatic void signal_lock() {\n  mutex_lock(&mutex);\n  /* When the jvm is installing its set of signal handlers, threads\n   * other than the jvm thread should wait */\n  if (jvm_signal_installing) {\n    if (tid != thr_self()) {\n      cond_wait(&cond, &mutex);\n    }\n  }\n}\n\nstatic void signal_unlock() {\n  mutex_unlock(&mutex);\n}\n\nstatic sa_handler_t call_os_signal(int sig, sa_handler_t disp,\n                                   bool is_sigset) {\n  if (os_signal == NULL) {\n    if (!is_sigset) {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"signal\");\n    } else {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"sigset\");\n    }\n    if (os_signal == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_signal)(sig, disp);\n}\n\nstatic void save_signal_handler(int sig, sa_handler_t disp, bool is_sigset) {\n  sigset_t set;\n  if (sact == NULL) {\n    allocate_sact();\n  }\n  sact[sig].sa_handler = disp;\n  sigemptyset(&set);\n  sact[sig].sa_mask = set;\n  if (!is_sigset) {\n    sact[sig].sa_flags = SA_NODEFER;\n    if (sig != SIGILL && sig != SIGTRAP && sig != SIGPWR) {\n      sact[sig].sa_flags |= SA_RESETHAND;\n    }\n  } else {\n    sact[sig].sa_flags = 0;\n  }\n}\n\nstatic sa_handler_t set_signal(int sig, sa_handler_t disp, bool is_sigset) {\n  sa_handler_t oldhandler;\n  bool sigblocked;\n\n  signal_lock();\n  if (sact == NULL) {\n    allocate_sact();\n  }\n\n  if (jvm_signal_installed && sigismember(&jvmsigs, sig)) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    if (is_sigset) {\n      /* We won't honor the SIG_HOLD request to change the signal mask */\n      sigblocked = sigismember(&(sact[sig].sa_mask), sig);\n    }\n    oldhandler = sact[sig].sa_handler;\n    save_signal_handler(sig, disp, is_sigset);\n\n    if (is_sigset && sigblocked) {\n      oldhandler = SIG_HOLD;\n    }\n\n    signal_unlock();\n    return oldhandler;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. jvm uses sigaction().\n     * Leave the piece here just in case. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n    save_signal_handler(sig, oldhandler, is_sigset);\n\n    /* Record the signals used by jvm */\n    sigaddset(&jvmsigs, sig);\n\n    signal_unlock();\n    return oldhandler;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n\n    signal_unlock();\n    return oldhandler;\n  }\n}\n\nsa_handler_t signal(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, false);\n}\n\nsa_handler_t sigset(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, true);\n}\n\nstatic int call_os_sigaction(int sig, const struct sigaction  *act,\n                             struct sigaction *oact) {\n  if (os_sigaction == NULL) {\n    os_sigaction = (sigaction_t)dlsym(RTLD_NEXT, \"sigaction\");\n    if (os_sigaction == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_sigaction)(sig, act, oact);\n}\n\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact) {\n  int res;\n  struct sigaction oldAct;\n\n  signal_lock();\n\n  if (sact == NULL ) {\n    allocate_sact();\n  }\n  if (jvm_signal_installed && sigismember(&jvmsigs, sig)) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    if (oact != NULL) {\n      *oact = sact[sig];\n    }\n    if (act != NULL) {\n      sact[sig] = *act;\n    }\n\n    signal_unlock();\n    return 0;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. */\n    res = call_os_sigaction(sig, act, &oldAct);\n    sact[sig] = oldAct;\n    if (oact != NULL) {\n      *oact = oldAct;\n    }\n\n    /* Record the signals used by jvm */\n    sigaddset(&jvmsigs, sig);\n\n    signal_unlock();\n    return res;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    res = call_os_sigaction(sig, act, oact);\n\n    signal_unlock();\n    return res;\n  }\n}\n\n/* The four functions for the jvm to call into */\nvoid JVM_begin_signal_setting() {\n  signal_lock();\n  jvm_signal_installing = true;\n  tid = thr_self();\n  signal_unlock();\n}\n\nvoid JVM_end_signal_setting() {\n  signal_lock();\n  jvm_signal_installed = true;\n  jvm_signal_installing = false;\n  cond_broadcast(&cond);\n  signal_unlock();\n}\n\nstruct sigaction *JVM_get_signal_action(int sig) {\n  if (sact == NULL) {\n    allocate_sact();\n  }\n  /* Does race condition make sense here? */\n  if (sigismember(&jvmsigs, sig)) {\n    return &sact[sig];\n  }\n  return NULL;\n}\n\nint JVM_get_libjsig_version() {\n  return JSIG_VERSION_1_4_1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os/solaris/vm/os_solaris.cpp": "/*\n * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n// no precompiled headers\n#include \"classfile/classLoader.hpp\"\n#include \"classfile/systemDictionary.hpp\"\n#include \"classfile/vmSymbols.hpp\"\n#include \"code/icBuffer.hpp\"\n#include \"code/vtableStubs.hpp\"\n#include \"compiler/compileBroker.hpp\"\n#include \"compiler/disassembler.hpp\"\n#include \"interpreter/interpreter.hpp\"\n#include \"jvm_solaris.h\"\n#include \"memory/allocation.inline.hpp\"\n#include \"memory/filemap.hpp\"\n#include \"mutex_solaris.inline.hpp\"\n#include \"oops/oop.inline.hpp\"\n#include \"os_share_solaris.hpp\"\n#include \"prims/jniFastGetField.hpp\"\n#include \"prims/jvm.h\"\n#include \"prims/jvm_misc.hpp\"\n#include \"runtime/arguments.hpp\"\n#include \"runtime/extendedPC.hpp\"\n#include \"runtime/globals.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/java.hpp\"\n#include \"runtime/javaCalls.hpp\"\n#include \"runtime/mutexLocker.hpp\"\n#include \"runtime/objectMonitor.hpp\"\n#include \"runtime/orderAccess.inline.hpp\"\n#include \"runtime/osThread.hpp\"\n#include \"runtime/perfMemory.hpp\"\n#include \"runtime/sharedRuntime.hpp\"\n#include \"runtime/statSampler.hpp\"\n#include \"runtime/stubRoutines.hpp\"\n#include \"runtime/thread.inline.hpp\"\n#include \"runtime/threadCritical.hpp\"\n#include \"runtime/timer.hpp\"\n#include \"services/attachListener.hpp\"\n#include \"services/memTracker.hpp\"\n#include \"services/runtimeService.hpp\"\n#include \"utilities/decoder.hpp\"\n#include \"utilities/defaultStream.hpp\"\n#include \"utilities/events.hpp\"\n#include \"utilities/growableArray.hpp\"\n#include \"utilities/vmError.hpp\"\n\n// put OS-includes here\n# include <dlfcn.h>\n# include <errno.h>\n# include <exception>\n# include <link.h>\n# include <poll.h>\n# include <pthread.h>\n# include <pwd.h>\n# include <schedctl.h>\n# include <setjmp.h>\n# include <signal.h>\n# include <stdio.h>\n# include <alloca.h>\n# include <sys/filio.h>\n# include <sys/ipc.h>\n# include <sys/lwp.h>\n# include <sys/machelf.h>     // for elf Sym structure used by dladdr1\n# include <sys/mman.h>\n# include <sys/processor.h>\n# include <sys/procset.h>\n# include <sys/pset.h>\n# include <sys/resource.h>\n# include <sys/shm.h>\n# include <sys/socket.h>\n# include <sys/stat.h>\n# include <sys/systeminfo.h>\n# include <sys/time.h>\n# include <sys/times.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <sys/utsname.h>\n# include <thread.h>\n# include <unistd.h>\n# include <sys/priocntl.h>\n# include <sys/rtpriocntl.h>\n# include <sys/tspriocntl.h>\n# include <sys/iapriocntl.h>\n# include <sys/fxpriocntl.h>\n# include <sys/loadavg.h>\n# include <string.h>\n# include <stdio.h>\n\n# define _STRUCTURED_PROC 1  //  this gets us the new structured proc interfaces of 5.6 & later\n# include <sys/procfs.h>     //  see comment in <sys/procfs.h>\n\n#define MAX_PATH (2 * K)\n\n// for timer info max values which include all bits\n#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n\n\n// Here are some liblgrp types from sys/lgrp_user.h to be able to\n// compile on older systems without this header file.\n\n#ifndef MADV_ACCESS_LWP\n# define  MADV_ACCESS_LWP         7       /* next LWP to access heavily */\n#endif\n#ifndef MADV_ACCESS_MANY\n# define  MADV_ACCESS_MANY        8       /* many processes to access heavily */\n#endif\n\n#ifndef LGRP_RSRC_CPU\n# define LGRP_RSRC_CPU           0       /* CPU resources */\n#endif\n#ifndef LGRP_RSRC_MEM\n# define LGRP_RSRC_MEM           1       /* memory resources */\n#endif\n\n// see thr_setprio(3T) for the basis of these numbers\n#define MinimumPriority 0\n#define NormalPriority  64\n#define MaximumPriority 127\n\n// Values for ThreadPriorityPolicy == 1\nint prio_policy1[CriticalPriority+1] = {\n  -99999,  0, 16,  32,  48,  64,\n          80, 96, 112, 124, 127, 127 };\n\n// System parameters used internally\nstatic clock_t clock_tics_per_sec = 100;\n\n// Track if we have called enable_extended_FILE_stdio (on Solaris 10u4+)\nstatic bool enabled_extended_FILE_stdio = false;\n\n// For diagnostics to print a message once. see run_periodic_checks\nstatic bool check_addr0_done = false;\nstatic sigset_t check_signal_done;\nstatic bool check_signals = true;\n\naddress os::Solaris::handler_start;  // start pc of thr_sighndlrinfo\naddress os::Solaris::handler_end;    // end pc of thr_sighndlrinfo\n\naddress os::Solaris::_main_stack_base = NULL;  // 4352906 workaround\n\n\n// \"default\" initializers for missing libc APIs\nextern \"C\" {\n  static int lwp_mutex_init(mutex_t *mx, int scope, void *arg) { memset(mx, 0, sizeof(mutex_t)); return 0; }\n  static int lwp_mutex_destroy(mutex_t *mx)                 { return 0; }\n\n  static int lwp_cond_init(cond_t *cv, int scope, void *arg){ memset(cv, 0, sizeof(cond_t)); return 0; }\n  static int lwp_cond_destroy(cond_t *cv)                   { return 0; }\n}\n\n// \"default\" initializers for pthread-based synchronization\nextern \"C\" {\n  static int pthread_mutex_default_init(mutex_t *mx, int scope, void *arg) { memset(mx, 0, sizeof(mutex_t)); return 0; }\n  static int pthread_cond_default_init(cond_t *cv, int scope, void *arg){ memset(cv, 0, sizeof(cond_t)); return 0; }\n}\n\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time);\n\nstatic inline size_t adjust_stack_size(address base, size_t size) {\n  if ((ssize_t)size < 0) {\n    // 4759953: Compensate for ridiculous stack size.\n    size = max_intx;\n  }\n  if (size > (size_t)base) {\n    // 4812466: Make sure size doesn't allow the stack to wrap the address space.\n    size = (size_t)base;\n  }\n  return size;\n}\n\nstatic inline stack_t get_stack_info() {\n  stack_t st;\n  int retval = thr_stksegment(&st);\n  st.ss_size = adjust_stack_size((address)st.ss_sp, st.ss_size);\n  assert(retval == 0, \"incorrect return value from thr_stksegment\");\n  assert((address)&st < (address)st.ss_sp, \"Invalid stack base returned\");\n  assert((address)&st > (address)st.ss_sp-st.ss_size, \"Invalid stack size returned\");\n  return st;\n}\n\naddress os::current_stack_base() {\n  int r = thr_main() ;\n  guarantee (r == 0 || r == 1, \"CR6501650 or CR6493689\") ;\n  bool is_primordial_thread = r;\n\n  // Workaround 4352906, avoid calls to thr_stksegment by\n  // thr_main after the first one (it looks like we trash\n  // some data, causing the value for ss_sp to be incorrect).\n  if (!is_primordial_thread || os::Solaris::_main_stack_base == NULL) {\n    stack_t st = get_stack_info();\n    if (is_primordial_thread) {\n      // cache initial value of stack base\n      os::Solaris::_main_stack_base = (address)st.ss_sp;\n    }\n    return (address)st.ss_sp;\n  } else {\n    guarantee(os::Solaris::_main_stack_base != NULL, \"Attempt to use null cached stack base\");\n    return os::Solaris::_main_stack_base;\n  }\n}\n\nsize_t os::current_stack_size() {\n  size_t size;\n\n  int r = thr_main() ;\n  guarantee (r == 0 || r == 1, \"CR6501650 or CR6493689\") ;\n  if(!r) {\n    size = get_stack_info().ss_size;\n  } else {\n    struct rlimit limits;\n    getrlimit(RLIMIT_STACK, &limits);\n    size = adjust_stack_size(os::Solaris::_main_stack_base, (size_t)limits.rlim_cur);\n  }\n  // base may not be page aligned\n  address base = current_stack_base();\n  address bottom = (address)align_size_up((intptr_t)(base - size), os::vm_page_size());;\n  return (size_t)(base - bottom);\n}\n\nstruct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {\n  return localtime_r(clock, res);\n}\n\n// interruptible infrastructure\n\n// setup_interruptible saves the thread state before going into an\n// interruptible system call.\n// The saved state is used to restore the thread to\n// its former state whether or not an interrupt is received.\n// Used by classloader os::read\n// os::restartable_read calls skip this layer and stay in _thread_in_native\n\nvoid os::Solaris::setup_interruptible(JavaThread* thread) {\n\n  JavaThreadState thread_state = thread->thread_state();\n\n  assert(thread_state != _thread_blocked, \"Coming from the wrong thread\");\n  assert(thread_state != _thread_in_native, \"Native threads skip setup_interruptible\");\n  OSThread* osthread = thread->osthread();\n  osthread->set_saved_interrupt_thread_state(thread_state);\n  thread->frame_anchor()->make_walkable(thread);\n  ThreadStateTransition::transition(thread, thread_state, _thread_blocked);\n}\n\n// Version of setup_interruptible() for threads that are already in\n// _thread_blocked. Used by os_sleep().\nvoid os::Solaris::setup_interruptible_already_blocked(JavaThread* thread) {\n  thread->frame_anchor()->make_walkable(thread);\n}\n\nJavaThread* os::Solaris::setup_interruptible() {\n  JavaThread* thread = (JavaThread*)ThreadLocalStorage::thread();\n  setup_interruptible(thread);\n  return thread;\n}\n\nvoid os::Solaris::try_enable_extended_io() {\n  typedef int (*enable_extended_FILE_stdio_t)(int, int);\n\n  if (!UseExtendedFileIO) {\n    return;\n  }\n\n  enable_extended_FILE_stdio_t enabler =\n    (enable_extended_FILE_stdio_t) dlsym(RTLD_DEFAULT,\n                                         \"enable_extended_FILE_stdio\");\n  if (enabler) {\n    enabler(-1, -1);\n  }\n}\n\n\n#ifdef ASSERT\n\nJavaThread* os::Solaris::setup_interruptible_native() {\n  JavaThread* thread = (JavaThread*)ThreadLocalStorage::thread();\n  JavaThreadState thread_state = thread->thread_state();\n  assert(thread_state == _thread_in_native, \"Assumed thread_in_native\");\n  return thread;\n}\n\nvoid os::Solaris::cleanup_interruptible_native(JavaThread* thread) {\n  JavaThreadState thread_state = thread->thread_state();\n  assert(thread_state == _thread_in_native, \"Assumed thread_in_native\");\n}\n#endif\n\n// cleanup_interruptible reverses the effects of setup_interruptible\n// setup_interruptible_already_blocked() does not need any cleanup.\n\nvoid os::Solaris::cleanup_interruptible(JavaThread* thread) {\n  OSThread* osthread = thread->osthread();\n\n  ThreadStateTransition::transition(thread, _thread_blocked, osthread->saved_interrupt_thread_state());\n}\n\n// I/O interruption related counters called in _INTERRUPTIBLE\n\nvoid os::Solaris::bump_interrupted_before_count() {\n  RuntimeService::record_interrupted_before_count();\n}\n\nvoid os::Solaris::bump_interrupted_during_count() {\n  RuntimeService::record_interrupted_during_count();\n}\n\nstatic int _processors_online = 0;\n\n         jint os::Solaris::_os_thread_limit = 0;\nvolatile jint os::Solaris::_os_thread_count = 0;\n\njulong os::available_memory() {\n  return Solaris::available_memory();\n}\n\njulong os::Solaris::available_memory() {\n  return (julong)sysconf(_SC_AVPHYS_PAGES) * os::vm_page_size();\n}\n\njulong os::Solaris::_physical_memory = 0;\n\njulong os::physical_memory() {\n   return Solaris::physical_memory();\n}\n\nstatic hrtime_t first_hrtime = 0;\nstatic const hrtime_t hrtime_hz = 1000*1000*1000;\nstatic volatile hrtime_t max_hrtime = 0;\n\n\nvoid os::Solaris::initialize_system_info() {\n  set_processor_count(sysconf(_SC_NPROCESSORS_CONF));\n  _processors_online = sysconf (_SC_NPROCESSORS_ONLN);\n  _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);\n}\n\nint os::active_processor_count() {\n  int online_cpus = sysconf(_SC_NPROCESSORS_ONLN);\n  pid_t pid = getpid();\n  psetid_t pset = PS_NONE;\n  // Are we running in a processor set or is there any processor set around?\n  if (pset_bind(PS_QUERY, P_PID, pid, &pset) == 0) {\n    uint_t pset_cpus;\n    // Query the number of cpus available to us.\n    if (pset_info(pset, NULL, &pset_cpus, NULL) == 0) {\n      assert(pset_cpus > 0 && pset_cpus <= online_cpus, \"sanity check\");\n      _processors_online = pset_cpus;\n      return pset_cpus;\n    }\n  }\n  // Otherwise return number of online cpus\n  return online_cpus;\n}\n\nstatic bool find_processors_in_pset(psetid_t        pset,\n                                    processorid_t** id_array,\n                                    uint_t*         id_length) {\n  bool result = false;\n  // Find the number of processors in the processor set.\n  if (pset_info(pset, NULL, id_length, NULL) == 0) {\n    // Make up an array to hold their ids.\n    *id_array = NEW_C_HEAP_ARRAY(processorid_t, *id_length, mtInternal);\n    // Fill in the array with their processor ids.\n    if (pset_info(pset, NULL, id_length, *id_array) == 0) {\n      result = true;\n    }\n  }\n  return result;\n}\n\n// Callers of find_processors_online() must tolerate imprecise results --\n// the system configuration can change asynchronously because of DR\n// or explicit psradm operations.\n//\n// We also need to take care that the loop (below) terminates as the\n// number of processors online can change between the _SC_NPROCESSORS_ONLN\n// request and the loop that builds the list of processor ids.   Unfortunately\n// there's no reliable way to determine the maximum valid processor id,\n// so we use a manifest constant, MAX_PROCESSOR_ID, instead.  See p_online\n// man pages, which claim the processor id set is \"sparse, but\n// not too sparse\".  MAX_PROCESSOR_ID is used to ensure that we eventually\n// exit the loop.\n//\n// In the future we'll be able to use sysconf(_SC_CPUID_MAX), but that's\n// not available on S8.0.\n\nstatic bool find_processors_online(processorid_t** id_array,\n                                   uint*           id_length) {\n  const processorid_t MAX_PROCESSOR_ID = 100000 ;\n  // Find the number of processors online.\n  *id_length = sysconf(_SC_NPROCESSORS_ONLN);\n  // Make up an array to hold their ids.\n  *id_array = NEW_C_HEAP_ARRAY(processorid_t, *id_length, mtInternal);\n  // Processors need not be numbered consecutively.\n  long found = 0;\n  processorid_t next = 0;\n  while (found < *id_length && next < MAX_PROCESSOR_ID) {\n    processor_info_t info;\n    if (processor_info(next, &info) == 0) {\n      // NB, PI_NOINTR processors are effectively online ...\n      if (info.pi_state == P_ONLINE || info.pi_state == P_NOINTR) {\n        (*id_array)[found] = next;\n        found += 1;\n      }\n    }\n    next += 1;\n  }\n  if (found < *id_length) {\n      // The loop above didn't identify the expected number of processors.\n      // We could always retry the operation, calling sysconf(_SC_NPROCESSORS_ONLN)\n      // and re-running the loop, above, but there's no guarantee of progress\n      // if the system configuration is in flux.  Instead, we just return what\n      // we've got.  Note that in the worst case find_processors_online() could\n      // return an empty set.  (As a fall-back in the case of the empty set we\n      // could just return the ID of the current processor).\n      *id_length = found ;\n  }\n\n  return true;\n}\n\nstatic bool assign_distribution(processorid_t* id_array,\n                                uint           id_length,\n                                uint*          distribution,\n                                uint           distribution_length) {\n  // We assume we can assign processorid_t's to uint's.\n  assert(sizeof(processorid_t) == sizeof(uint),\n         \"can't convert processorid_t to uint\");\n  // Quick check to see if we won't succeed.\n  if (id_length < distribution_length) {\n    return false;\n  }\n  // Assign processor ids to the distribution.\n  // Try to shuffle processors to distribute work across boards,\n  // assuming 4 processors per board.\n  const uint processors_per_board = ProcessDistributionStride;\n  // Find the maximum processor id.\n  processorid_t max_id = 0;\n  for (uint m = 0; m < id_length; m += 1) {\n    max_id = MAX2(max_id, id_array[m]);\n  }\n  // The next id, to limit loops.\n  const processorid_t limit_id = max_id + 1;\n  // Make up markers for available processors.\n  bool* available_id = NEW_C_HEAP_ARRAY(bool, limit_id, mtInternal);\n  for (uint c = 0; c < limit_id; c += 1) {\n    available_id[c] = false;\n  }\n  for (uint a = 0; a < id_length; a += 1) {\n    available_id[id_array[a]] = true;\n  }\n  // Step by \"boards\", then by \"slot\", copying to \"assigned\".\n  // NEEDS_CLEANUP: The assignment of processors should be stateful,\n  //                remembering which processors have been assigned by\n  //                previous calls, etc., so as to distribute several\n  //                independent calls of this method.  What we'd like is\n  //                It would be nice to have an API that let us ask\n  //                how many processes are bound to a processor,\n  //                but we don't have that, either.\n  //                In the short term, \"board\" is static so that\n  //                subsequent distributions don't all start at board 0.\n  static uint board = 0;\n  uint assigned = 0;\n  // Until we've found enough processors ....\n  while (assigned < distribution_length) {\n    // ... find the next available processor in the board.\n    for (uint slot = 0; slot < processors_per_board; slot += 1) {\n      uint try_id = board * processors_per_board + slot;\n      if ((try_id < limit_id) && (available_id[try_id] == true)) {\n        distribution[assigned] = try_id;\n        available_id[try_id] = false;\n        assigned += 1;\n        break;\n      }\n    }\n    board += 1;\n    if (board * processors_per_board + 0 >= limit_id) {\n      board = 0;\n    }\n  }\n  if (available_id != NULL) {\n    FREE_C_HEAP_ARRAY(bool, available_id, mtInternal);\n  }\n  return true;\n}\n\nvoid os::set_native_thread_name(const char *name) {\n  // Not yet implemented.\n  return;\n}\n\nbool os::distribute_processes(uint length, uint* distribution) {\n  bool result = false;\n  // Find the processor id's of all the available CPUs.\n  processorid_t* id_array  = NULL;\n  uint           id_length = 0;\n  // There are some races between querying information and using it,\n  // since processor sets can change dynamically.\n  psetid_t pset = PS_NONE;\n  // Are we running in a processor set?\n  if ((pset_bind(PS_QUERY, P_PID, P_MYID, &pset) == 0) && pset != PS_NONE) {\n    result = find_processors_in_pset(pset, &id_array, &id_length);\n  } else {\n    result = find_processors_online(&id_array, &id_length);\n  }\n  if (result == true) {\n    if (id_length >= length) {\n      result = assign_distribution(id_array, id_length, distribution, length);\n    } else {\n      result = false;\n    }\n  }\n  if (id_array != NULL) {\n    FREE_C_HEAP_ARRAY(processorid_t, id_array, mtInternal);\n  }\n  return result;\n}\n\nbool os::bind_to_processor(uint processor_id) {\n  // We assume that a processorid_t can be stored in a uint.\n  assert(sizeof(uint) == sizeof(processorid_t),\n         \"can't convert uint to processorid_t\");\n  int bind_result =\n    processor_bind(P_LWPID,                       // bind LWP.\n                   P_MYID,                        // bind current LWP.\n                   (processorid_t) processor_id,  // id.\n                   NULL);                         // don't return old binding.\n  return (bind_result == 0);\n}\n\nbool os::getenv(const char* name, char* buffer, int len) {\n  char* val = ::getenv( name );\n  if ( val == NULL\n  ||   strlen(val) + 1  >  len ) {\n    if (len > 0)  buffer[0] = 0; // return a null string\n    return false;\n  }\n  strcpy( buffer, val );\n  return true;\n}\n\n\n// Return true if user is running as root.\n\nbool os::have_special_privileges() {\n  static bool init = false;\n  static bool privileges = false;\n  if (!init) {\n    privileges = (getuid() != geteuid()) || (getgid() != getegid());\n    init = true;\n  }\n  return privileges;\n}\n\n\nvoid os::init_system_properties_values() {\n  // The next steps are taken in the product version:\n  //\n  // Obtain the JAVA_HOME value from the location of libjvm.so.\n  // This library should be located at:\n  // <JAVA_HOME>/jre/lib/<arch>/{client|server}/libjvm.so.\n  //\n  // If \"/jre/lib/\" appears at the right place in the path, then we\n  // assume libjvm.so is installed in a JDK and we use this path.\n  //\n  // Otherwise exit with message: \"Could not create the Java virtual machine.\"\n  //\n  // The following extra steps are taken in the debugging version:\n  //\n  // If \"/jre/lib/\" does NOT appear at the right place in the path\n  // instead of exit check for $JAVA_HOME environment variable.\n  //\n  // If it is defined and we are able to locate $JAVA_HOME/jre/lib/<arch>,\n  // then we append a fake suffix \"hotspot/libjvm.so\" to this path so\n  // it looks like libjvm.so is installed there\n  // <JAVA_HOME>/jre/lib/<arch>/hotspot/libjvm.so.\n  //\n  // Otherwise exit.\n  //\n  // Important note: if the location of libjvm.so changes this\n  // code needs to be changed accordingly.\n\n// Base path of extensions installed on the system.\n#define SYS_EXT_DIR     \"/usr/jdk/packages\"\n#define EXTENSIONS_DIR  \"/lib/ext\"\n#define ENDORSED_DIR    \"/lib/endorsed\"\n\n  char cpu_arch[12];\n  // Buffer that fits several sprintfs.\n  // Note that the space for the colon and the trailing null are provided\n  // by the nulls included by the sizeof operator.\n  const size_t bufsize =\n    MAX4((size_t)MAXPATHLEN,  // For dll_dir & friends.\n         sizeof(SYS_EXT_DIR) + sizeof(\"/lib/\") + strlen(cpu_arch), // invariant ld_library_path\n         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR), // extensions dir\n         (size_t)MAXPATHLEN + sizeof(ENDORSED_DIR)); // endorsed dir\n  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n\n  // sysclasspath, java_home, dll_dir\n  {\n    char *pslash;\n    os::jvm_path(buf, bufsize);\n\n    // Found the full path to libjvm.so.\n    // Now cut the path to <java_home>/jre if we can.\n    *(strrchr(buf, '/')) = '\\0'; // Get rid of /libjvm.so.\n    pslash = strrchr(buf, '/');\n    if (pslash != NULL) {\n      *pslash = '\\0';            // Get rid of /{client|server|hotspot}.\n    }\n    Arguments::set_dll_dir(buf);\n\n    if (pslash != NULL) {\n      pslash = strrchr(buf, '/');\n      if (pslash != NULL) {\n        *pslash = '\\0';          // Get rid of /<arch>.\n        pslash = strrchr(buf, '/');\n        if (pslash != NULL) {\n          *pslash = '\\0';        // Get rid of /lib.\n        }\n      }\n    }\n    Arguments::set_java_home(buf);\n    set_boot_path('/', ':');\n  }\n\n  // Where to look for native libraries.\n  {\n    // Use dlinfo() to determine the correct java.library.path.\n    //\n    // If we're launched by the Java launcher, and the user\n    // does not set java.library.path explicitly on the commandline,\n    // the Java launcher sets LD_LIBRARY_PATH for us and unsets\n    // LD_LIBRARY_PATH_32 and LD_LIBRARY_PATH_64.  In this case\n    // dlinfo returns LD_LIBRARY_PATH + crle settings (including\n    // /usr/lib), which is exactly what we want.\n    //\n    // If the user does set java.library.path, it completely\n    // overwrites this setting, and always has.\n    //\n    // If we're not launched by the Java launcher, we may\n    // get here with any/all of the LD_LIBRARY_PATH[_32|64]\n    // settings.  Again, dlinfo does exactly what we want.\n\n    Dl_serinfo     info_sz, *info = &info_sz;\n    Dl_serpath     *path;\n    char           *library_path;\n    char           *common_path = buf;\n\n    // Determine search path count and required buffer size.\n    if (dlinfo(RTLD_SELF, RTLD_DI_SERINFOSIZE, (void *)info) == -1) {\n      FREE_C_HEAP_ARRAY(char, buf,  mtInternal);\n      vm_exit_during_initialization(\"dlinfo SERINFOSIZE request\", dlerror());\n    }\n\n    // Allocate new buffer and initialize.\n    info = (Dl_serinfo*)NEW_C_HEAP_ARRAY(char, info_sz.dls_size, mtInternal);\n    info->dls_size = info_sz.dls_size;\n    info->dls_cnt = info_sz.dls_cnt;\n\n    // Obtain search path information.\n    if (dlinfo(RTLD_SELF, RTLD_DI_SERINFO, (void *)info) == -1) {\n      FREE_C_HEAP_ARRAY(char, buf,  mtInternal);\n      FREE_C_HEAP_ARRAY(char, info, mtInternal);\n      vm_exit_during_initialization(\"dlinfo SERINFO request\", dlerror());\n    }\n\n    path = &info->dls_serpath[0];\n\n    // Note: Due to a legacy implementation, most of the library path\n    // is set in the launcher. This was to accomodate linking restrictions\n    // on legacy Solaris implementations (which are no longer supported).\n    // Eventually, all the library path setting will be done here.\n    //\n    // However, to prevent the proliferation of improperly built native\n    // libraries, the new path component /usr/jdk/packages is added here.\n\n    // Determine the actual CPU architecture.\n    sysinfo(SI_ARCHITECTURE, cpu_arch, sizeof(cpu_arch));\n#ifdef _LP64\n    // If we are a 64-bit vm, perform the following translations:\n    //   sparc   -> sparcv9\n    //   i386    -> amd64\n    if (strcmp(cpu_arch, \"sparc\") == 0) {\n      strcat(cpu_arch, \"v9\");\n    } else if (strcmp(cpu_arch, \"i386\") == 0) {\n      strcpy(cpu_arch, \"amd64\");\n    }\n#endif\n\n    // Construct the invariant part of ld_library_path.\n    sprintf(common_path, SYS_EXT_DIR \"/lib/%s\", cpu_arch);\n\n    // Struct size is more than sufficient for the path components obtained\n    // through the dlinfo() call, so only add additional space for the path\n    // components explicitly added here.\n    size_t library_path_size = info->dls_size + strlen(common_path);\n    library_path = (char *)NEW_C_HEAP_ARRAY(char, library_path_size, mtInternal);\n    library_path[0] = '\\0';\n\n    // Construct the desired Java library path from the linker's library\n    // search path.\n    //\n    // For compatibility, it is optimal that we insert the additional path\n    // components specific to the Java VM after those components specified\n    // in LD_LIBRARY_PATH (if any) but before those added by the ld.so\n    // infrastructure.\n    if (info->dls_cnt == 0) { // Not sure this can happen, but allow for it.\n      strcpy(library_path, common_path);\n    } else {\n      int inserted = 0;\n      int i;\n      for (i = 0; i < info->dls_cnt; i++, path++) {\n        uint_t flags = path->dls_flags & LA_SER_MASK;\n        if (((flags & LA_SER_LIBPATH) == 0) && !inserted) {\n          strcat(library_path, common_path);\n          strcat(library_path, os::path_separator());\n          inserted = 1;\n        }\n        strcat(library_path, path->dls_name);\n        strcat(library_path, os::path_separator());\n      }\n      // Eliminate trailing path separator.\n      library_path[strlen(library_path)-1] = '\\0';\n    }\n\n    // happens before argument parsing - can't use a trace flag\n    // tty->print_raw(\"init_system_properties_values: native lib path: \");\n    // tty->print_raw_cr(library_path);\n\n    // Callee copies into its own buffer.\n    Arguments::set_library_path(library_path);\n\n    FREE_C_HEAP_ARRAY(char, library_path, mtInternal);\n    FREE_C_HEAP_ARRAY(char, info, mtInternal);\n  }\n\n  // Extensions directories.\n  sprintf(buf, \"%s\" EXTENSIONS_DIR \":\" SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());\n  Arguments::set_ext_dirs(buf);\n\n  // Endorsed standards default directory.\n  sprintf(buf, \"%s\" ENDORSED_DIR, Arguments::get_java_home());\n  Arguments::set_endorsed_dirs(buf);\n\n  FREE_C_HEAP_ARRAY(char, buf, mtInternal);\n\n#undef SYS_EXT_DIR\n#undef EXTENSIONS_DIR\n#undef ENDORSED_DIR\n}\n\nvoid os::breakpoint() {\n  BREAKPOINT;\n}\n\nbool os::obsolete_option(const JavaVMOption *option)\n{\n  if (!strncmp(option->optionString, \"-Xt\", 3)) {\n    return true;\n  } else if (!strncmp(option->optionString, \"-Xtm\", 4)) {\n    return true;\n  } else if (!strncmp(option->optionString, \"-Xverifyheap\", 12)) {\n    return true;\n  } else if (!strncmp(option->optionString, \"-Xmaxjitcodesize\", 16)) {\n    return true;\n  }\n  return false;\n}\n\nbool os::Solaris::valid_stack_address(Thread* thread, address sp) {\n  address  stackStart  = (address)thread->stack_base();\n  address  stackEnd    = (address)(stackStart - (address)thread->stack_size());\n  if (sp < stackStart && sp >= stackEnd ) return true;\n  return false;\n}\n\nextern \"C\" void breakpoint() {\n  // use debugger to set breakpoint here\n}\n\nstatic thread_t main_thread;\n\n// Thread start routine for all new Java threads\nextern \"C\" void* java_start(void* thread_addr) {\n  // Try to randomize the cache line index of hot stack frames.\n  // This helps when threads of the same stack traces evict each other's\n  // cache lines. The threads can be either from the same JVM instance, or\n  // from different JVM instances. The benefit is especially true for\n  // processors with hyperthreading technology.\n  static int counter = 0;\n  int pid = os::current_process_id();\n  alloca(((pid ^ counter++) & 7) * 128);\n\n  int prio;\n  Thread* thread = (Thread*)thread_addr;\n  OSThread* osthr = thread->osthread();\n\n  osthr->set_lwp_id( _lwp_self() );  // Store lwp in case we are bound\n  thread->_schedctl = (void *) schedctl_init () ;\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n\n  // If the creator called set priority before we started,\n  // we need to call set_native_priority now that we have an lwp.\n  // We used to get the priority from thr_getprio (we called\n  // thr_setprio way back in create_thread) and pass it to\n  // set_native_priority, but Solaris scales the priority\n  // in java_to_os_priority, so when we read it back here,\n  // we pass trash to set_native_priority instead of what's\n  // in java_to_os_priority. So we save the native priority\n  // in the osThread and recall it here.\n\n  if ( osthr->thread_id() != -1 ) {\n    if ( UseThreadPriorities ) {\n      int prio = osthr->native_priority();\n      if (ThreadPriorityVerbose) {\n        tty->print_cr(\"Starting Thread \" INTPTR_FORMAT \", LWP is \"\n                      INTPTR_FORMAT \", setting priority: %d\\n\",\n                      osthr->thread_id(), osthr->lwp_id(), prio);\n      }\n      os::set_native_priority(thread, prio);\n    }\n  } else if (ThreadPriorityVerbose) {\n    warning(\"Can't set priority in _start routine, thread id hasn't been set\\n\");\n  }\n\n  assert(osthr->get_state() == RUNNABLE, \"invalid os thread state\");\n\n  // initialize signal mask for this thread\n  os::Solaris::hotspot_sigmask(thread);\n\n  thread->run();\n\n  // One less thread is executing\n  // When the VMThread gets here, the main thread may have already exited\n  // which frees the CodeHeap containing the Atomic::dec code\n  if (thread != VMThread::vm_thread() && VMThread::vm_thread() != NULL) {\n    Atomic::dec(&os::Solaris::_os_thread_count);\n  }\n\n  if (UseDetachedThreads) {\n    thr_exit(NULL);\n    ShouldNotReachHere();\n  }\n  return NULL;\n}\n\nstatic OSThread* create_os_thread(Thread* thread, thread_t thread_id) {\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) return NULL;\n\n  // Store info on the Solaris thread into the OSThread\n  osthread->set_thread_id(thread_id);\n  osthread->set_lwp_id(_lwp_self());\n  thread->_schedctl = (void *) schedctl_init () ;\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n\n  if ( ThreadPriorityVerbose ) {\n    tty->print_cr(\"In create_os_thread, Thread \" INTPTR_FORMAT \", LWP is \" INTPTR_FORMAT \"\\n\",\n                  osthread->thread_id(), osthread->lwp_id() );\n  }\n\n  // Initial thread state is INITIALIZED, not SUSPENDED\n  osthread->set_state(INITIALIZED);\n\n  return osthread;\n}\n\nvoid os::Solaris::hotspot_sigmask(Thread* thread) {\n\n  //Save caller's signal mask\n  sigset_t sigmask;\n  thr_sigsetmask(SIG_SETMASK, NULL, &sigmask);\n  OSThread *osthread = thread->osthread();\n  osthread->set_caller_sigmask(sigmask);\n\n  thr_sigsetmask(SIG_UNBLOCK, os::Solaris::unblocked_signals(), NULL);\n  if (!ReduceSignalUsage) {\n    if (thread->is_VM_thread()) {\n      // Only the VM thread handles BREAK_SIGNAL ...\n      thr_sigsetmask(SIG_UNBLOCK, vm_signals(), NULL);\n    } else {\n      // ... all other threads block BREAK_SIGNAL\n      assert(!sigismember(vm_signals(), SIGINT), \"SIGINT should not be blocked\");\n      thr_sigsetmask(SIG_BLOCK, vm_signals(), NULL);\n    }\n  }\n}\n\nbool os::create_attached_thread(JavaThread* thread) {\n#ifdef ASSERT\n  thread->verify_not_published();\n#endif\n  OSThread* osthread = create_os_thread(thread, thr_self());\n  if (osthread == NULL) {\n     return false;\n  }\n\n  // Initial thread state is RUNNABLE\n  osthread->set_state(RUNNABLE);\n  thread->set_osthread(osthread);\n\n  // initialize signal mask for this thread\n  // and save the caller's signal mask\n  os::Solaris::hotspot_sigmask(thread);\n\n  return true;\n}\n\nbool os::create_main_thread(JavaThread* thread) {\n#ifdef ASSERT\n  thread->verify_not_published();\n#endif\n  if (_starting_thread == NULL) {\n    _starting_thread = create_os_thread(thread, main_thread);\n     if (_starting_thread == NULL) {\n        return false;\n     }\n  }\n\n  // The primodial thread is runnable from the start\n  _starting_thread->set_state(RUNNABLE);\n\n  thread->set_osthread(_starting_thread);\n\n  // initialize signal mask for this thread\n  // and save the caller's signal mask\n  os::Solaris::hotspot_sigmask(thread);\n\n  return true;\n}\n\n// _T2_libthread is true if we believe we are running with the newer\n// SunSoft lwp/libthread.so (2.8 patch, 2.9 default)\nbool os::Solaris::_T2_libthread = false;\n\nbool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) {\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) {\n    return false;\n  }\n\n  if ( ThreadPriorityVerbose ) {\n    char *thrtyp;\n    switch ( thr_type ) {\n      case vm_thread:\n        thrtyp = (char *)\"vm\";\n        break;\n      case cgc_thread:\n        thrtyp = (char *)\"cgc\";\n        break;\n      case pgc_thread:\n        thrtyp = (char *)\"pgc\";\n        break;\n      case java_thread:\n        thrtyp = (char *)\"java\";\n        break;\n      case compiler_thread:\n        thrtyp = (char *)\"compiler\";\n        break;\n      case watcher_thread:\n        thrtyp = (char *)\"watcher\";\n        break;\n      default:\n        thrtyp = (char *)\"unknown\";\n        break;\n    }\n    tty->print_cr(\"In create_thread, creating a %s thread\\n\", thrtyp);\n  }\n\n  // Calculate stack size if it's not specified by caller.\n  if (stack_size == 0) {\n    // The default stack size 1M (2M for LP64).\n    stack_size = (BytesPerWord >> 2) * K * K;\n\n    switch (thr_type) {\n    case os::java_thread:\n      // Java threads use ThreadStackSize which default value can be changed with the flag -Xss\n      if (JavaThread::stack_size_at_create() > 0) stack_size = JavaThread::stack_size_at_create();\n      break;\n    case os::compiler_thread:\n      if (CompilerThreadStackSize > 0) {\n        stack_size = (size_t)(CompilerThreadStackSize * K);\n        break;\n      } // else fall through:\n        // use VMThreadStackSize if CompilerThreadStackSize is not defined\n    case os::vm_thread:\n    case os::pgc_thread:\n    case os::cgc_thread:\n    case os::watcher_thread:\n      if (VMThreadStackSize > 0) stack_size = (size_t)(VMThreadStackSize * K);\n      break;\n    }\n  }\n  stack_size = MAX2(stack_size, os::Solaris::min_stack_allowed);\n\n  // Initial state is ALLOCATED but not INITIALIZED\n  osthread->set_state(ALLOCATED);\n\n  if (os::Solaris::_os_thread_count > os::Solaris::_os_thread_limit) {\n    // We got lots of threads. Check if we still have some address space left.\n    // Need to be at least 5Mb of unreserved address space. We do check by\n    // trying to reserve some.\n    const size_t VirtualMemoryBangSize = 20*K*K;\n    char* mem = os::reserve_memory(VirtualMemoryBangSize);\n    if (mem == NULL) {\n      delete osthread;\n      return false;\n    } else {\n      // Release the memory again\n      os::release_memory(mem, VirtualMemoryBangSize);\n    }\n  }\n\n  // Setup osthread because the child thread may need it.\n  thread->set_osthread(osthread);\n\n  // Create the Solaris thread\n  // explicit THR_BOUND for T2_libthread case in case\n  // that assumption is not accurate, but our alternate signal stack\n  // handling is based on it which must have bound threads\n  thread_t tid = 0;\n  long     flags = (UseDetachedThreads ? THR_DETACHED : 0) | THR_SUSPENDED\n                   | ((UseBoundThreads || os::Solaris::T2_libthread() ||\n                       (thr_type == vm_thread) ||\n                       (thr_type == cgc_thread) ||\n                       (thr_type == pgc_thread) ||\n                       (thr_type == compiler_thread && BackgroundCompilation)) ?\n                      THR_BOUND : 0);\n  int      status;\n\n  // 4376845 -- libthread/kernel don't provide enough LWPs to utilize all CPUs.\n  //\n  // On multiprocessors systems, libthread sometimes under-provisions our\n  // process with LWPs.  On a 30-way systems, for instance, we could have\n  // 50 user-level threads in ready state and only 2 or 3 LWPs assigned\n  // to our process.  This can result in under utilization of PEs.\n  // I suspect the problem is related to libthread's LWP\n  // pool management and to the kernel's SIGBLOCKING \"last LWP parked\"\n  // upcall policy.\n  //\n  // The following code is palliative -- it attempts to ensure that our\n  // process has sufficient LWPs to take advantage of multiple PEs.\n  // Proper long-term cures include using user-level threads bound to LWPs\n  // (THR_BOUND) or using LWP-based synchronization.  Note that there is a\n  // slight timing window with respect to sampling _os_thread_count, but\n  // the race is benign.  Also, we should periodically recompute\n  // _processors_online as the min of SC_NPROCESSORS_ONLN and the\n  // the number of PEs in our partition.  You might be tempted to use\n  // THR_NEW_LWP here, but I'd recommend against it as that could\n  // result in undesirable growth of the libthread's LWP pool.\n  // The fix below isn't sufficient; for instance, it doesn't take into count\n  // LWPs parked on IO.  It does, however, help certain CPU-bound benchmarks.\n  //\n  // Some pathologies this scheme doesn't handle:\n  // *  Threads can block, releasing the LWPs.  The LWPs can age out.\n  //    When a large number of threads become ready again there aren't\n  //    enough LWPs available to service them.  This can occur when the\n  //    number of ready threads oscillates.\n  // *  LWPs/Threads park on IO, thus taking the LWP out of circulation.\n  //\n  // Finally, we should call thr_setconcurrency() periodically to refresh\n  // the LWP pool and thwart the LWP age-out mechanism.\n  // The \"+3\" term provides a little slop -- we want to slightly overprovision.\n\n  if (AdjustConcurrency && os::Solaris::_os_thread_count < (_processors_online+3)) {\n    if (!(flags & THR_BOUND)) {\n      thr_setconcurrency (os::Solaris::_os_thread_count);       // avoid starvation\n    }\n  }\n  // Although this doesn't hurt, we should warn of undefined behavior\n  // when using unbound T1 threads with schedctl().  This should never\n  // happen, as the compiler and VM threads are always created bound\n  DEBUG_ONLY(\n      if ((VMThreadHintNoPreempt || CompilerThreadHintNoPreempt) &&\n          (!os::Solaris::T2_libthread() && (!(flags & THR_BOUND))) &&\n          ((thr_type == vm_thread) || (thr_type == cgc_thread) ||\n           (thr_type == pgc_thread) || (thr_type == compiler_thread && BackgroundCompilation))) {\n         warning(\"schedctl behavior undefined when Compiler/VM/GC Threads are Unbound\");\n      }\n  );\n\n\n  // Mark that we don't have an lwp or thread id yet.\n  // In case we attempt to set the priority before the thread starts.\n  osthread->set_lwp_id(-1);\n  osthread->set_thread_id(-1);\n\n  status = thr_create(NULL, stack_size, java_start, thread, flags, &tid);\n  if (status != 0) {\n    if (PrintMiscellaneous && (Verbose || WizardMode)) {\n      perror(\"os::create_thread\");\n    }\n    thread->set_osthread(NULL);\n    // Need to clean up stuff we've allocated so far\n    delete osthread;\n    return false;\n  }\n\n  Atomic::inc(&os::Solaris::_os_thread_count);\n\n  // Store info on the Solaris thread into the OSThread\n  osthread->set_thread_id(tid);\n\n  // Remember that we created this thread so we can set priority on it\n  osthread->set_vm_created();\n\n  // Set the default thread priority.  If using bound threads, setting\n  // lwp priority will be delayed until thread start.\n  set_native_priority(thread,\n                      DefaultThreadPriority == -1 ?\n                        java_to_os_priority[NormPriority] :\n                        DefaultThreadPriority);\n\n  // Initial thread state is INITIALIZED, not SUSPENDED\n  osthread->set_state(INITIALIZED);\n\n  // The thread is returned suspended (in state INITIALIZED), and is started higher up in the call chain\n  return true;\n}\n\n/* defined for >= Solaris 10. This allows builds on earlier versions\n *  of Solaris to take advantage of the newly reserved Solaris JVM signals\n *  With SIGJVM1, SIGJVM2, INTERRUPT_SIGNAL is SIGJVM1, ASYNC_SIGNAL is SIGJVM2\n *  and -XX:+UseAltSigs does nothing since these should have no conflict\n */\n#if !defined(SIGJVM1)\n#define SIGJVM1 39\n#define SIGJVM2 40\n#endif\n\ndebug_only(static bool signal_sets_initialized = false);\nstatic sigset_t unblocked_sigs, vm_sigs, allowdebug_blocked_sigs;\nint os::Solaris::_SIGinterrupt = INTERRUPT_SIGNAL;\nint os::Solaris::_SIGasync = ASYNC_SIGNAL;\n\nbool os::Solaris::is_sig_ignored(int sig) {\n      struct sigaction oact;\n      sigaction(sig, (struct sigaction*)NULL, &oact);\n      void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oact.sa_sigaction)\n                                     : CAST_FROM_FN_PTR(void*,  oact.sa_handler);\n      if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN))\n           return true;\n      else\n           return false;\n}\n\n// Note: SIGRTMIN is a macro that calls sysconf() so it will\n// dynamically detect SIGRTMIN value for the system at runtime, not buildtime\nstatic bool isJVM1available() {\n  return SIGJVM1 < SIGRTMIN;\n}\n\nvoid os::Solaris::signal_sets_init() {\n  // Should also have an assertion stating we are still single-threaded.\n  assert(!signal_sets_initialized, \"Already initialized\");\n  // Fill in signals that are necessarily unblocked for all threads in\n  // the VM. Currently, we unblock the following signals:\n  // SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n  //                         by -Xrs (=ReduceSignalUsage));\n  // BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n  // other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n  // the dispositions or masks wrt these signals.\n  // Programs embedding the VM that want to use the above signals for their\n  // own purposes must, at this time, use the \"-Xrs\" option to prevent\n  // interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n  // (See bug 4345157, and other related bugs).\n  // In reality, though, unblocking these signals is really a nop, since\n  // these signals are not blocked by default.\n  sigemptyset(&unblocked_sigs);\n  sigemptyset(&allowdebug_blocked_sigs);\n  sigaddset(&unblocked_sigs, SIGILL);\n  sigaddset(&unblocked_sigs, SIGSEGV);\n  sigaddset(&unblocked_sigs, SIGBUS);\n  sigaddset(&unblocked_sigs, SIGFPE);\n\n  if (isJVM1available) {\n    os::Solaris::set_SIGinterrupt(SIGJVM1);\n    os::Solaris::set_SIGasync(SIGJVM2);\n  } else if (UseAltSigs) {\n    os::Solaris::set_SIGinterrupt(ALT_INTERRUPT_SIGNAL);\n    os::Solaris::set_SIGasync(ALT_ASYNC_SIGNAL);\n  } else {\n    os::Solaris::set_SIGinterrupt(INTERRUPT_SIGNAL);\n    os::Solaris::set_SIGasync(ASYNC_SIGNAL);\n  }\n\n  sigaddset(&unblocked_sigs, os::Solaris::SIGinterrupt());\n  sigaddset(&unblocked_sigs, os::Solaris::SIGasync());\n\n  if (!ReduceSignalUsage) {\n   if (!os::Solaris::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN1_SIGNAL);\n   }\n   if (!os::Solaris::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN2_SIGNAL);\n   }\n   if (!os::Solaris::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN3_SIGNAL);\n   }\n  }\n  // Fill in signals that are blocked by all but the VM thread.\n  sigemptyset(&vm_sigs);\n  if (!ReduceSignalUsage)\n    sigaddset(&vm_sigs, BREAK_SIGNAL);\n  debug_only(signal_sets_initialized = true);\n\n  // For diagnostics only used in run_periodic_checks\n  sigemptyset(&check_signal_done);\n}\n\n// These are signals that are unblocked while a thread is running Java.\n// (For some reason, they get blocked by default.)\nsigset_t* os::Solaris::unblocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &unblocked_sigs;\n}\n\n// These are the signals that are blocked while a (non-VM) thread is\n// running Java. Only the VM thread handles these signals.\nsigset_t* os::Solaris::vm_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &vm_sigs;\n}\n\n// These are signals that are blocked during cond_wait to allow debugger in\nsigset_t* os::Solaris::allowdebug_blocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &allowdebug_blocked_sigs;\n}\n\n\nvoid _handle_uncaught_cxx_exception() {\n  VMError err(\"An uncaught C++ exception\");\n  err.report_and_die();\n}\n\n\n// First crack at OS-specific initialization, from inside the new thread.\nvoid os::initialize_thread(Thread* thr) {\n  int r = thr_main() ;\n  guarantee (r == 0 || r == 1, \"CR6501650 or CR6493689\") ;\n  if (r) {\n    JavaThread* jt = (JavaThread *)thr;\n    assert(jt != NULL,\"Sanity check\");\n    size_t stack_size;\n    address base = jt->stack_base();\n    if (Arguments::created_by_java_launcher()) {\n      // Use 2MB to allow for Solaris 7 64 bit mode.\n      stack_size = JavaThread::stack_size_at_create() == 0\n        ? 2048*K : JavaThread::stack_size_at_create();\n\n      // There are rare cases when we may have already used more than\n      // the basic stack size allotment before this method is invoked.\n      // Attempt to allow for a normally sized java_stack.\n      size_t current_stack_offset = (size_t)(base - (address)&stack_size);\n      stack_size += ReservedSpace::page_align_size_down(current_stack_offset);\n    } else {\n      // 6269555: If we were not created by a Java launcher, i.e. if we are\n      // running embedded in a native application, treat the primordial thread\n      // as much like a native attached thread as possible.  This means using\n      // the current stack size from thr_stksegment(), unless it is too large\n      // to reliably setup guard pages.  A reasonable max size is 8MB.\n      size_t current_size = current_stack_size();\n      // This should never happen, but just in case....\n      if (current_size == 0) current_size = 2 * K * K;\n      stack_size = current_size > (8 * K * K) ? (8 * K * K) : current_size;\n    }\n    address bottom = (address)align_size_up((intptr_t)(base - stack_size), os::vm_page_size());;\n    stack_size = (size_t)(base - bottom);\n\n    assert(stack_size > 0, \"Stack size calculation problem\");\n\n    if (stack_size > jt->stack_size()) {\n      NOT_PRODUCT(\n        struct rlimit limits;\n        getrlimit(RLIMIT_STACK, &limits);\n        size_t size = adjust_stack_size(base, (size_t)limits.rlim_cur);\n        assert(size >= jt->stack_size(), \"Stack size problem in main thread\");\n      )\n      tty->print_cr(\n        \"Stack size of %d Kb exceeds current limit of %d Kb.\\n\"\n        \"(Stack sizes are rounded up to a multiple of the system page size.)\\n\"\n        \"See limit(1) to increase the stack size limit.\",\n        stack_size / K, jt->stack_size() / K);\n      vm_exit(1);\n    }\n    assert(jt->stack_size() >= stack_size,\n          \"Attempt to map more stack than was allocated\");\n    jt->set_stack_size(stack_size);\n  }\n\n   // 5/22/01: Right now alternate signal stacks do not handle\n   // throwing stack overflow exceptions, see bug 4463178\n   // Until a fix is found for this, T2 will NOT imply alternate signal\n   // stacks.\n   // If using T2 libthread threads, install an alternate signal stack.\n   // Because alternate stacks associate with LWPs on Solaris,\n   // see sigaltstack(2), if using UNBOUND threads, or if UseBoundThreads\n   // we prefer to explicitly stack bang.\n   // If not using T2 libthread, but using UseBoundThreads any threads\n   // (primordial thread, jni_attachCurrentThread) we do not create,\n   // probably are not bound, therefore they can not have an alternate\n   // signal stack. Since our stack banging code is generated and\n   // is shared across threads, all threads must be bound to allow\n   // using alternate signal stacks.  The alternative is to interpose\n   // on _lwp_create to associate an alt sig stack with each LWP,\n   // and this could be a problem when the JVM is embedded.\n   // We would prefer to use alternate signal stacks with T2\n   // Since there is currently no accurate way to detect T2\n   // we do not. Assuming T2 when running T1 causes sig 11s or assertions\n   // on installing alternate signal stacks\n\n\n   // 05/09/03: removed alternate signal stack support for Solaris\n   // The alternate signal stack mechanism is no longer needed to\n   // handle stack overflow. This is now handled by allocating\n   // guard pages (red zone) and stackbanging.\n   // Initially the alternate signal stack mechanism was removed because\n   // it did not work with T1 llibthread. Alternate\n   // signal stacks MUST have all threads bound to lwps. Applications\n   // can create their own threads and attach them without their being\n   // bound under T1. This is frequently the case for the primordial thread.\n   // If we were ever to reenable this mechanism we would need to\n   // use the dynamic check for T2 libthread.\n\n  os::Solaris::init_thread_fpu_state();\n  std::set_terminate(_handle_uncaught_cxx_exception);\n}\n\n\n\n// Free Solaris resources related to the OSThread\nvoid os::free_thread(OSThread* osthread) {\n  assert(osthread != NULL, \"os::free_thread but osthread not set\");\n\n\n  // We are told to free resources of the argument thread,\n  // but we can only really operate on the current thread.\n  // The main thread must take the VMThread down synchronously\n  // before the main thread exits and frees up CodeHeap\n  guarantee((Thread::current()->osthread() == osthread\n     || (osthread == VMThread::vm_thread()->osthread())), \"os::free_thread but not current thread\");\n  if (Thread::current()->osthread() == osthread) {\n    // Restore caller's signal mask\n    sigset_t sigmask = osthread->caller_sigmask();\n    thr_sigsetmask(SIG_SETMASK, &sigmask, NULL);\n  }\n  delete osthread;\n}\n\nvoid os::pd_start_thread(Thread* thread) {\n  int status = thr_continue(thread->osthread()->thread_id());\n  assert_status(status == 0, status, \"thr_continue failed\");\n}\n\n\nintx os::current_thread_id() {\n  return (intx)thr_self();\n}\n\nstatic pid_t _initial_pid = 0;\n\nint os::current_process_id() {\n  return (int)(_initial_pid ? _initial_pid : getpid());\n}\n\n// gethrtime() should be monotonic according to the documentation,\n// but some virtualized platforms are known to break this guarantee.\n// getTimeNanos() must be guaranteed not to move backwards, so we\n// are forced to add a check here.\ninline hrtime_t getTimeNanos() {\n  const hrtime_t now = gethrtime();\n  const hrtime_t prev = max_hrtime;\n  if (now <= prev) {\n    return prev;   // same or retrograde time;\n  }\n  const hrtime_t obsv = Atomic::cmpxchg(now, (volatile jlong*)&max_hrtime, prev);\n  assert(obsv >= prev, \"invariant\");   // Monotonicity\n  // If the CAS succeeded then we're done and return \"now\".\n  // If the CAS failed and the observed value \"obsv\" is >= now then\n  // we should return \"obsv\".  If the CAS failed and now > obsv > prv then\n  // some other thread raced this thread and installed a new value, in which case\n  // we could either (a) retry the entire operation, (b) retry trying to install now\n  // or (c) just return obsv.  We use (c).   No loop is required although in some cases\n  // we might discard a higher \"now\" value in deference to a slightly lower but freshly\n  // installed obsv value.   That's entirely benign -- it admits no new orderings compared\n  // to (a) or (b) -- and greatly reduces coherence traffic.\n  // We might also condition (c) on the magnitude of the delta between obsv and now.\n  // Avoiding excessive CAS operations to hot RW locations is critical.\n  // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate\n  return (prev == obsv) ? now : obsv;\n}\n\n// Time since start-up in seconds to a fine granularity.\n// Used by VMSelfDestructTimer and the MemProfiler.\ndouble os::elapsedTime() {\n  return (double)(getTimeNanos() - first_hrtime) / (double)hrtime_hz;\n}\n\njlong os::elapsed_counter() {\n  return (jlong)(getTimeNanos() - first_hrtime);\n}\n\njlong os::elapsed_frequency() {\n   return hrtime_hz;\n}\n\n// Return the real, user, and system times in seconds from an\n// arbitrary fixed point in the past.\nbool os::getTimesSecs(double* process_real_time,\n                  double* process_user_time,\n                  double* process_system_time) {\n  struct tms ticks;\n  clock_t real_ticks = times(&ticks);\n\n  if (real_ticks == (clock_t) (-1)) {\n    return false;\n  } else {\n    double ticks_per_second = (double) clock_tics_per_sec;\n    *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;\n    *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;\n    // For consistency return the real time from getTimeNanos()\n    // converted to seconds.\n    *process_real_time = ((double) getTimeNanos()) / ((double) NANOUNITS);\n\n    return true;\n  }\n}\n\nbool os::supports_vtime() { return true; }\n\nbool os::enable_vtime() {\n  int fd = ::open(\"/proc/self/ctl\", O_WRONLY);\n  if (fd == -1)\n    return false;\n\n  long cmd[] = { PCSET, PR_MSACCT };\n  int res = ::write(fd, cmd, sizeof(long) * 2);\n  ::close(fd);\n  if (res != sizeof(long) * 2)\n    return false;\n\n  return true;\n}\n\nbool os::vtime_enabled() {\n  int fd = ::open(\"/proc/self/status\", O_RDONLY);\n  if (fd == -1)\n    return false;\n\n  pstatus_t status;\n  int res = os::read(fd, (void*) &status, sizeof(pstatus_t));\n  ::close(fd);\n  if (res != sizeof(pstatus_t))\n    return false;\n\n  return status.pr_flags & PR_MSACCT;\n}\n\ndouble os::elapsedVTime() {\n  return (double)gethrvtime() / (double)hrtime_hz;\n}\n\n// Used internally for comparisons only\n// getTimeMillis guaranteed to not move backwards on Solaris\njlong getTimeMillis() {\n  jlong nanotime = getTimeNanos();\n  return (jlong)(nanotime / NANOSECS_PER_MILLISEC);\n}\n\n// Must return millis since Jan 1 1970 for JVM_CurrentTimeMillis\njlong os::javaTimeMillis() {\n  timeval t;\n  if (gettimeofday( &t, NULL) == -1)\n    fatal(err_msg(\"os::javaTimeMillis: gettimeofday (%s)\", strerror(errno)));\n  return jlong(t.tv_sec) * 1000  +  jlong(t.tv_usec) / 1000;\n}\n\njlong os::javaTimeNanos() {\n  return (jlong)getTimeNanos();\n}\n\nvoid os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;      // gethrtime() uses all 64 bits\n  info_ptr->may_skip_backward = false;    // not subject to resetting or drifting\n  info_ptr->may_skip_forward = false;     // not subject to resetting or drifting\n  info_ptr->kind = JVMTI_TIMER_ELAPSED;   // elapsed not CPU time\n}\n\nchar * os::local_time_string(char *buf, size_t buflen) {\n  struct tm t;\n  time_t long_time;\n  time(&long_time);\n  localtime_r(&long_time, &t);\n  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n               t.tm_hour, t.tm_min, t.tm_sec);\n  return buf;\n}\n\n// Note: os::shutdown() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::shutdown(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::shutdown() {\n\n  // allow PerfMemory to attempt cleanup of any persistent resources\n  perfMemory_exit();\n\n  // needs to remove object in file system\n  AttachListener::abort();\n\n  // flush buffered output, finish log files\n  ostream_abort();\n\n  // Check for abort hook\n  abort_hook_t abort_hook = Arguments::abort_hook();\n  if (abort_hook != NULL) {\n    abort_hook();\n  }\n}\n\n// Note: os::abort() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::abort(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::abort(bool dump_core) {\n  os::shutdown();\n  if (dump_core) {\n#ifndef PRODUCT\n    fdStream out(defaultStream::output_fd());\n    out.print_raw(\"Current thread is \");\n    char buf[16];\n    jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());\n    out.print_raw_cr(buf);\n    out.print_raw_cr(\"Dumping core ...\");\n#endif\n    ::abort(); // dump core (for debugging)\n  }\n\n  ::exit(1);\n}\n\n// Die immediately, no exit hook, no abort hook, no cleanup.\nvoid os::die() {\n  ::abort(); // dump core (for debugging)\n}\n\n// DLL functions\n\nconst char* os::dll_file_extension() { return \".so\"; }\n\n// This must be hard coded because it's the system's temporary\n// directory not the java application's temp directory, ala java.io.tmpdir.\nconst char* os::get_temp_directory() { return \"/tmp\"; }\n\nstatic bool file_exists(const char* filename) {\n  struct stat statbuf;\n  if (filename == NULL || strlen(filename) == 0) {\n    return false;\n  }\n  return os::stat(filename, &statbuf) == 0;\n}\n\nbool os::dll_build_name(char* buffer, size_t buflen,\n                        const char* pname, const char* fname) {\n  bool retval = false;\n  const size_t pnamelen = pname ? strlen(pname) : 0;\n\n  // Return error on buffer overflow.\n  if (pnamelen + strlen(fname) + 10 > (size_t) buflen) {\n    return retval;\n  }\n\n  if (pnamelen == 0) {\n    snprintf(buffer, buflen, \"lib%s.so\", fname);\n    retval = true;\n  } else if (strchr(pname, *os::path_separator()) != NULL) {\n    int n;\n    char** pelements = split_path(pname, &n);\n    if (pelements == NULL) {\n      return false;\n    }\n    for (int i = 0 ; i < n ; i++) {\n      // really shouldn't be NULL but what the heck, check can't hurt\n      if (pelements[i] == NULL || strlen(pelements[i]) == 0) {\n        continue; // skip the empty path values\n      }\n      snprintf(buffer, buflen, \"%s/lib%s.so\", pelements[i], fname);\n      if (file_exists(buffer)) {\n        retval = true;\n        break;\n      }\n    }\n    // release the storage\n    for (int i = 0 ; i < n ; i++) {\n      if (pelements[i] != NULL) {\n        FREE_C_HEAP_ARRAY(char, pelements[i], mtInternal);\n      }\n    }\n    if (pelements != NULL) {\n      FREE_C_HEAP_ARRAY(char*, pelements, mtInternal);\n    }\n  } else {\n    snprintf(buffer, buflen, \"%s/lib%s.so\", pname, fname);\n    retval = true;\n  }\n  return retval;\n}\n\n// check if addr is inside libjvm.so\nbool os::address_is_in_vm(address addr) {\n  static address libjvm_base_addr;\n  Dl_info dlinfo;\n\n  if (libjvm_base_addr == NULL) {\n    if (dladdr(CAST_FROM_FN_PTR(void *, os::address_is_in_vm), &dlinfo) != 0) {\n      libjvm_base_addr = (address)dlinfo.dli_fbase;\n    }\n    assert(libjvm_base_addr !=NULL, \"Cannot obtain base address for libjvm\");\n  }\n\n  if (dladdr((void *)addr, &dlinfo) != 0) {\n    if (libjvm_base_addr == (address)dlinfo.dli_fbase) return true;\n  }\n\n  return false;\n}\n\ntypedef int (*dladdr1_func_type) (void *, Dl_info *, void **, int);\nstatic dladdr1_func_type dladdr1_func = NULL;\n\nbool os::dll_address_to_function_name(address addr, char *buf,\n                                      int buflen, int * offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n\n  // dladdr1_func was initialized in os::init()\n  if (dladdr1_func != NULL) {\n    // yes, we have dladdr1\n\n    // Support for dladdr1 is checked at runtime; it may be\n    // available even if the vm is built on a machine that does\n    // not have dladdr1 support.  Make sure there is a value for\n    // RTLD_DL_SYMENT.\n    #ifndef RTLD_DL_SYMENT\n    #define RTLD_DL_SYMENT 1\n    #endif\n#ifdef _LP64\n    Elf64_Sym * info;\n#else\n    Elf32_Sym * info;\n#endif\n    if (dladdr1_func((void *)addr, &dlinfo, (void **)&info,\n                     RTLD_DL_SYMENT) != 0) {\n      // see if we have a matching symbol that covers our address\n      if (dlinfo.dli_saddr != NULL &&\n          (char *)dlinfo.dli_saddr + info->st_size > (char *)addr) {\n        if (dlinfo.dli_sname != NULL) {\n          if (!Decoder::demangle(dlinfo.dli_sname, buf, buflen)) {\n            jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_sname);\n          }\n          if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;\n          return true;\n        }\n      }\n      // no matching symbol so try for just file info\n      if (dlinfo.dli_fname != NULL && dlinfo.dli_fbase != NULL) {\n        if (Decoder::decode((address)(addr - (address)dlinfo.dli_fbase),\n                            buf, buflen, offset, dlinfo.dli_fname)) {\n          return true;\n        }\n      }\n    }\n    buf[0] = '\\0';\n    if (offset != NULL) *offset  = -1;\n    return false;\n  }\n\n  // no, only dladdr is available\n  if (dladdr((void *)addr, &dlinfo) != 0) {\n    // see if we have a matching symbol\n    if (dlinfo.dli_saddr != NULL && dlinfo.dli_sname != NULL) {\n      if (!Decoder::demangle(dlinfo.dli_sname, buf, buflen)) {\n        jio_snprintf(buf, buflen, dlinfo.dli_sname);\n      }\n      if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;\n      return true;\n    }\n    // no matching symbol so try for just file info\n    if (dlinfo.dli_fname != NULL && dlinfo.dli_fbase != NULL) {\n      if (Decoder::decode((address)(addr - (address)dlinfo.dli_fbase),\n                          buf, buflen, offset, dlinfo.dli_fname)) {\n        return true;\n      }\n    }\n  }\n  buf[0] = '\\0';\n  if (offset != NULL) *offset  = -1;\n  return false;\n}\n\nbool os::dll_address_to_library_name(address addr, char* buf,\n                                     int buflen, int* offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n\n  if (dladdr((void*)addr, &dlinfo) != 0) {\n    if (dlinfo.dli_fname != NULL) {\n      jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL && offset != NULL) {\n      *offset = addr - (address)dlinfo.dli_fbase;\n    }\n    return true;\n  }\n\n  buf[0] = '\\0';\n  if (offset) *offset = -1;\n  return false;\n}\n\n// Prints the names and full paths of all opened dynamic libraries\n// for current process\nvoid os::print_dll_info(outputStream * st) {\n  Dl_info dli;\n  void *handle;\n  Link_map *map;\n  Link_map *p;\n\n  st->print_cr(\"Dynamic libraries:\"); st->flush();\n\n  if (dladdr(CAST_FROM_FN_PTR(void *, os::print_dll_info), &dli) == 0 ||\n      dli.dli_fname == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n  handle = dlopen(dli.dli_fname, RTLD_LAZY);\n  if (handle == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n  dlinfo(handle, RTLD_DI_LINKMAP, &map);\n  if (map == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n\n  while (map->l_prev != NULL)\n    map = map->l_prev;\n\n  while (map != NULL) {\n    st->print_cr(PTR_FORMAT \" \\t%s\", map->l_addr, map->l_name);\n    map = map->l_next;\n  }\n\n  dlclose(handle);\n}\n\n  // Loads .dll/.so and\n  // in case of error it checks if .dll/.so was built for the\n  // same architecture as Hotspot is running on\n\nvoid * os::dll_load(const char *filename, char *ebuf, int ebuflen)\n{\n  void * result= ::dlopen(filename, RTLD_LAZY);\n  if (result != NULL) {\n    // Successful loading\n    return result;\n  }\n\n  Elf32_Ehdr elf_head;\n\n  // Read system error message into ebuf\n  // It may or may not be overwritten below\n  ::strncpy(ebuf, ::dlerror(), ebuflen-1);\n  ebuf[ebuflen-1]='\\0';\n  int diag_msg_max_length=ebuflen-strlen(ebuf);\n  char* diag_msg_buf=ebuf+strlen(ebuf);\n\n  if (diag_msg_max_length==0) {\n    // No more space in ebuf for additional diagnostics message\n    return NULL;\n  }\n\n\n  int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);\n\n  if (file_descriptor < 0) {\n    // Can't open library, report dlerror() message\n    return NULL;\n  }\n\n  bool failed_to_read_elf_head=\n    (sizeof(elf_head)!=\n        (::read(file_descriptor, &elf_head,sizeof(elf_head)))) ;\n\n  ::close(file_descriptor);\n  if (failed_to_read_elf_head) {\n    // file i/o error - report dlerror() msg\n    return NULL;\n  }\n\n  typedef struct {\n    Elf32_Half  code;         // Actual value as defined in elf.h\n    Elf32_Half  compat_class; // Compatibility of archs at VM's sense\n    char        elf_class;    // 32 or 64 bit\n    char        endianess;    // MSB or LSB\n    char*       name;         // String representation\n  } arch_t;\n\n  static const arch_t arch_array[]={\n    {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)\"IA 64\"},\n    {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)\"AMD 64\"},\n    {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)\"Sparc v9 64\"},\n    {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)\"Power PC 32\"},\n    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)\"Power PC 64\"},\n    {EM_ARM,         EM_ARM,     ELFCLASS32, ELFDATA2LSB, (char*)\"ARM 32\"}\n  };\n\n  #if  (defined IA32)\n    static  Elf32_Half running_arch_code=EM_386;\n  #elif   (defined AMD64)\n    static  Elf32_Half running_arch_code=EM_X86_64;\n  #elif  (defined IA64)\n    static  Elf32_Half running_arch_code=EM_IA_64;\n  #elif  (defined __sparc) && (defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARCV9;\n  #elif  (defined __sparc) && (!defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARC;\n  #elif  (defined __powerpc64__)\n    static  Elf32_Half running_arch_code=EM_PPC64;\n  #elif  (defined __powerpc__)\n    static  Elf32_Half running_arch_code=EM_PPC;\n  #elif (defined ARM)\n    static  Elf32_Half running_arch_code=EM_ARM;\n  #else\n    #error Method os::dll_load requires that one of following is defined:\\\n         IA32, AMD64, IA64, __sparc, __powerpc__, ARM, ARM\n  #endif\n\n  // Identify compatability class for VM's architecture and library's architecture\n  // Obtain string descriptions for architectures\n\n  arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};\n  int running_arch_index=-1;\n\n  for (unsigned int i=0 ; i < ARRAY_SIZE(arch_array) ; i++ ) {\n    if (running_arch_code == arch_array[i].code) {\n      running_arch_index    = i;\n    }\n    if (lib_arch.code == arch_array[i].code) {\n      lib_arch.compat_class = arch_array[i].compat_class;\n      lib_arch.name         = arch_array[i].name;\n    }\n  }\n\n  assert(running_arch_index != -1,\n    \"Didn't find running architecture code (running_arch_code) in arch_array\");\n  if (running_arch_index == -1) {\n    // Even though running architecture detection failed\n    // we may still continue with reporting dlerror() message\n    return NULL;\n  }\n\n  if (lib_arch.endianess != arch_array[running_arch_index].endianess) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n    return NULL;\n  }\n\n  if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n    return NULL;\n  }\n\n  if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {\n    if ( lib_arch.name!=NULL ) {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n        \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n        lib_arch.name, arch_array[running_arch_index].name);\n    } else {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n      \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n        lib_arch.code,\n        arch_array[running_arch_index].name);\n    }\n  }\n\n  return NULL;\n}\n\nvoid* os::dll_lookup(void* handle, const char* name) {\n  return dlsym(handle, name);\n}\n\nvoid* os::get_default_process_handle() {\n  return (void*)::dlopen(NULL, RTLD_LAZY);\n}\n\nint os::stat(const char *path, struct stat *sbuf) {\n  char pathbuf[MAX_PATH];\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  os::native_path(strcpy(pathbuf, path));\n  return ::stat(pathbuf, sbuf);\n}\n\nstatic bool _print_ascii_file(const char* filename, outputStream* st) {\n  int fd = ::open(filename, O_RDONLY);\n  if (fd == -1) {\n     return false;\n  }\n\n  char buf[32];\n  int bytes;\n  while ((bytes = ::read(fd, buf, sizeof(buf))) > 0) {\n    st->print_raw(buf, bytes);\n  }\n\n  ::close(fd);\n\n  return true;\n}\n\nvoid os::print_os_info_brief(outputStream* st) {\n  os::Solaris::print_distro_info(st);\n\n  os::Posix::print_uname_info(st);\n\n  os::Solaris::print_libversion_info(st);\n}\n\nvoid os::print_os_info(outputStream* st) {\n  st->print(\"OS:\");\n\n  os::Solaris::print_distro_info(st);\n\n  os::Posix::print_uname_info(st);\n\n  os::Solaris::print_libversion_info(st);\n\n  os::Posix::print_rlimit_info(st);\n\n  os::Posix::print_load_average(st);\n}\n\nvoid os::Solaris::print_distro_info(outputStream* st) {\n  if (!_print_ascii_file(\"/etc/release\", st)) {\n      st->print(\"Solaris\");\n    }\n    st->cr();\n}\n\nvoid os::Solaris::print_libversion_info(outputStream* st) {\n  if (os::Solaris::T2_libthread()) {\n    st->print(\"  (T2 libthread)\");\n  }\n  else {\n    st->print(\"  (T1 libthread)\");\n  }\n  st->cr();\n}\n\nstatic bool check_addr0(outputStream* st) {\n  jboolean status = false;\n  int fd = ::open(\"/proc/self/map\",O_RDONLY);\n  if (fd >= 0) {\n    prmap_t p;\n    while(::read(fd, &p, sizeof(p)) > 0) {\n      if (p.pr_vaddr == 0x0) {\n        st->print(\"Warning: Address: 0x%x, Size: %dK, \",p.pr_vaddr, p.pr_size/1024, p.pr_mapname);\n        st->print(\"Mapped file: %s, \", p.pr_mapname[0] == '\\0' ? \"None\" : p.pr_mapname);\n        st->print(\"Access:\");\n        st->print(\"%s\",(p.pr_mflags & MA_READ)  ? \"r\" : \"-\");\n        st->print(\"%s\",(p.pr_mflags & MA_WRITE) ? \"w\" : \"-\");\n        st->print(\"%s\",(p.pr_mflags & MA_EXEC)  ? \"x\" : \"-\");\n        st->cr();\n        status = true;\n      }\n    }\n    ::close(fd);\n  }\n  return status;\n}\n\nvoid os::pd_print_cpu_info(outputStream* st) {\n  // Nothing to do for now.\n}\n\nvoid os::print_memory_info(outputStream* st) {\n  st->print(\"Memory:\");\n  st->print(\" %dk page\", os::vm_page_size()>>10);\n  st->print(\", physical \" UINT64_FORMAT \"k\", os::physical_memory()>>10);\n  st->print(\"(\" UINT64_FORMAT \"k free)\", os::available_memory() >> 10);\n  st->cr();\n  if (VMError::fatal_error_in_progress()) {\n     (void) check_addr0(st);\n  }\n}\n\nvoid os::print_siginfo(outputStream* st, void* siginfo) {\n  const siginfo_t* si = (const siginfo_t*)siginfo;\n\n  os::Posix::print_siginfo_brief(st, si);\n\n  if (si && (si->si_signo == SIGBUS || si->si_signo == SIGSEGV) &&\n      UseSharedSpaces) {\n    FileMapInfo* mapinfo = FileMapInfo::current_info();\n    if (mapinfo->is_in_shared_space(si->si_addr)) {\n      st->print(\"\\n\\nError accessing class data sharing archive.\"   \\\n                \" Mapped file inaccessible during execution, \"      \\\n                \" possible disk/network problem.\");\n    }\n  }\n  st->cr();\n}\n\n// Moved from whole group, because we need them here for diagnostic\n// prints.\n#define OLDMAXSIGNUM 32\nstatic int Maxsignum = 0;\nstatic int *ourSigFlags = NULL;\n\nextern \"C\" void sigINTRHandler(int, siginfo_t*, void*);\n\nint os::Solaris::get_our_sigflags(int sig) {\n  assert(ourSigFlags!=NULL, \"signal data structure not initialized\");\n  assert(sig > 0 && sig < Maxsignum, \"vm signal out of expected range\");\n  return ourSigFlags[sig];\n}\n\nvoid os::Solaris::set_our_sigflags(int sig, int flags) {\n  assert(ourSigFlags!=NULL, \"signal data structure not initialized\");\n  assert(sig > 0 && sig < Maxsignum, \"vm signal out of expected range\");\n  ourSigFlags[sig] = flags;\n}\n\n\nstatic const char* get_signal_handler_name(address handler,\n                                           char* buf, int buflen) {\n  int offset;\n  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n  if (found) {\n    // skip directory names\n    const char *p1, *p2;\n    p1 = buf;\n    size_t len = strlen(os::file_separator());\n    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n  } else {\n    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n  }\n  return buf;\n}\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                  char* buf, size_t buflen) {\n  struct sigaction sa;\n\n  sigaction(sig, NULL, &sa);\n\n  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n\n  address handler = (sa.sa_flags & SA_SIGINFO)\n                  ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n                  : CAST_FROM_FN_PTR(address, sa.sa_handler);\n\n  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n    st->print(\"SIG_DFL\");\n  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n    st->print(\"SIG_IGN\");\n  } else {\n    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n  }\n\n  st->print(\", sa_mask[0]=\");\n  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n\n  address rh = VMError::get_resetted_sighandler(sig);\n  // May be, handler was resetted by VMError?\n  if(rh != NULL) {\n    handler = rh;\n    sa.sa_flags = VMError::get_resetted_sigflags(sig);\n  }\n\n  st->print(\", sa_flags=\");\n  os::Posix::print_sa_flags(st, sa.sa_flags);\n\n  // Check: is it our handler?\n  if(handler == CAST_FROM_FN_PTR(address, signalHandler) ||\n     handler == CAST_FROM_FN_PTR(address, sigINTRHandler)) {\n    // It is our signal handler\n    // check for flags\n    if(sa.sa_flags != os::Solaris::get_our_sigflags(sig)) {\n      st->print(\n        \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n        os::Solaris::get_our_sigflags(sig));\n    }\n  }\n  st->cr();\n}\n\nvoid os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n  st->print_cr(\"Signal Handlers:\");\n  print_signal_handler(st, SIGSEGV, buf, buflen);\n  print_signal_handler(st, SIGBUS , buf, buflen);\n  print_signal_handler(st, SIGFPE , buf, buflen);\n  print_signal_handler(st, SIGPIPE, buf, buflen);\n  print_signal_handler(st, SIGXFSZ, buf, buflen);\n  print_signal_handler(st, SIGILL , buf, buflen);\n  print_signal_handler(st, INTERRUPT_SIGNAL, buf, buflen);\n  print_signal_handler(st, ASYNC_SIGNAL, buf, buflen);\n  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n  print_signal_handler(st, SHUTDOWN1_SIGNAL , buf, buflen);\n  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n  print_signal_handler(st, SHUTDOWN3_SIGNAL, buf, buflen);\n  print_signal_handler(st, os::Solaris::SIGinterrupt(), buf, buflen);\n  print_signal_handler(st, os::Solaris::SIGasync(), buf, buflen);\n}\n\nstatic char saved_jvm_path[MAXPATHLEN] = { 0 };\n\n// Find the full path to the current module, libjvm.so\nvoid os::jvm_path(char *buf, jint buflen) {\n  // Error checking.\n  if (buflen < MAXPATHLEN) {\n    assert(false, \"must use a large-enough buffer\");\n    buf[0] = '\\0';\n    return;\n  }\n  // Lazy resolve the path to current module.\n  if (saved_jvm_path[0] != 0) {\n    strcpy(buf, saved_jvm_path);\n    return;\n  }\n\n  Dl_info dlinfo;\n  int ret = dladdr(CAST_FROM_FN_PTR(void *, os::jvm_path), &dlinfo);\n  assert(ret != 0, \"cannot locate libjvm\");\n  if (ret != 0 && dlinfo.dli_fname != NULL) {\n    realpath((char *)dlinfo.dli_fname, buf);\n  } else {\n    buf[0] = '\\0';\n    return;\n  }\n\n  if (Arguments::created_by_gamma_launcher()) {\n    // Support for the gamma launcher.  Typical value for buf is\n    // \"<JAVA_HOME>/jre/lib/<arch>/<vmtype>/libjvm.so\".  If \"/jre/lib/\" appears at\n    // the right place in the string, then assume we are installed in a JDK and\n    // we're done.  Otherwise, check for a JAVA_HOME environment variable and fix\n    // up the path so it looks like libjvm.so is installed there (append a\n    // fake suffix hotspot/libjvm.so).\n    const char *p = buf + strlen(buf) - 1;\n    for (int count = 0; p > buf && count < 5; ++count) {\n      for (--p; p > buf && *p != '/'; --p)\n        /* empty */ ;\n    }\n\n    if (strncmp(p, \"/jre/lib/\", 9) != 0) {\n      // Look for JAVA_HOME in the environment.\n      char* java_home_var = ::getenv(\"JAVA_HOME\");\n      if (java_home_var != NULL && java_home_var[0] != 0) {\n        char cpu_arch[12];\n        char* jrelib_p;\n        int   len;\n        sysinfo(SI_ARCHITECTURE, cpu_arch, sizeof(cpu_arch));\n#ifdef _LP64\n        // If we are on sparc running a 64-bit vm, look in jre/lib/sparcv9.\n        if (strcmp(cpu_arch, \"sparc\") == 0) {\n          strcat(cpu_arch, \"v9\");\n        } else if (strcmp(cpu_arch, \"i386\") == 0) {\n          strcpy(cpu_arch, \"amd64\");\n        }\n#endif\n        // Check the current module name \"libjvm.so\".\n        p = strrchr(buf, '/');\n        assert(strstr(p, \"/libjvm\") == p, \"invalid library name\");\n\n        realpath(java_home_var, buf);\n        // determine if this is a legacy image or modules image\n        // modules image doesn't have \"jre\" subdirectory\n        len = strlen(buf);\n        assert(len < buflen, \"Ran out of buffer space\");\n        jrelib_p = buf + len;\n        snprintf(jrelib_p, buflen-len, \"/jre/lib/%s\", cpu_arch);\n        if (0 != access(buf, F_OK)) {\n          snprintf(jrelib_p, buflen-len, \"/lib/%s\", cpu_arch);\n        }\n\n        if (0 == access(buf, F_OK)) {\n          // Use current module name \"libjvm.so\"\n          len = strlen(buf);\n          snprintf(buf + len, buflen-len, \"/hotspot/libjvm.so\");\n        } else {\n          // Go back to path of .so\n          realpath((char *)dlinfo.dli_fname, buf);\n        }\n      }\n    }\n  }\n\n  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n}\n\n\nvoid os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n  // no prefix required, not even \"_\"\n}\n\n\nvoid os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n  // no suffix required\n}\n\n// This method is a copy of JDK's sysGetLastErrorString\n// from src/solaris/hpi/src/system_md.c\n\nsize_t os::lasterror(char *buf, size_t len) {\n\n  if (errno == 0)  return 0;\n\n  const char *s = ::strerror(errno);\n  size_t n = ::strlen(s);\n  if (n >= len) {\n    n = len - 1;\n  }\n  ::strncpy(buf, s, n);\n  buf[n] = '\\0';\n  return n;\n}\n\n\n// sun.misc.Signal\n\nextern \"C\" {\n  static void UserHandler(int sig, void *siginfo, void *context) {\n    // Ctrl-C is pressed during error reporting, likely because the error\n    // handler fails to abort. Let VM die immediately.\n    if (sig == SIGINT && is_error_reported()) {\n       os::die();\n    }\n\n    os::signal_notify(sig);\n    // We do not need to reinstate the signal handler each time...\n  }\n}\n\nvoid* os::user_handler() {\n  return CAST_FROM_FN_PTR(void*, UserHandler);\n}\n\nclass Semaphore : public StackObj {\n  public:\n    Semaphore();\n    ~Semaphore();\n    void signal();\n    void wait();\n    bool trywait();\n    bool timedwait(unsigned int sec, int nsec);\n  private:\n    sema_t _semaphore;\n};\n\n\nSemaphore::Semaphore() {\n  sema_init(&_semaphore, 0, NULL, NULL);\n}\n\nSemaphore::~Semaphore() {\n  sema_destroy(&_semaphore);\n}\n\nvoid Semaphore::signal() {\n  sema_post(&_semaphore);\n}\n\nvoid Semaphore::wait() {\n  sema_wait(&_semaphore);\n}\n\nbool Semaphore::trywait() {\n  return sema_trywait(&_semaphore) == 0;\n}\n\nbool Semaphore::timedwait(unsigned int sec, int nsec) {\n  struct timespec ts;\n  unpackTime(&ts, false, (sec * NANOSECS_PER_SEC) + nsec);\n\n  while (1) {\n    int result = sema_timedwait(&_semaphore, &ts);\n    if (result == 0) {\n      return true;\n    } else if (errno == EINTR) {\n      continue;\n    } else if (errno == ETIME) {\n      return false;\n    } else {\n      return false;\n    }\n  }\n}\n\nextern \"C\" {\n  typedef void (*sa_handler_t)(int);\n  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n}\n\nvoid* os::signal(int signal_number, void* handler) {\n  struct sigaction sigAct, oldSigAct;\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_flags = SA_RESTART & ~SA_RESETHAND;\n  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n\n  if (sigaction(signal_number, &sigAct, &oldSigAct))\n    // -1 means registration failed\n    return (void *)-1;\n\n  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n}\n\nvoid os::signal_raise(int signal_number) {\n  raise(signal_number);\n}\n\n/*\n * The following code is moved from os.cpp for making this\n * code platform specific, which it is by its very nature.\n */\n\n// a counter for each possible signal value\nstatic int Sigexit = 0;\nstatic int Maxlibjsigsigs;\nstatic jint *pending_signals = NULL;\nstatic int *preinstalled_sigs = NULL;\nstatic struct sigaction *chainedsigactions = NULL;\nstatic sema_t sig_sem;\ntypedef int (*version_getting_t)();\nversion_getting_t os::Solaris::get_libjsig_version = NULL;\nstatic int libjsigversion = NULL;\n\nint os::sigexitnum_pd() {\n  assert(Sigexit > 0, \"signal memory not yet initialized\");\n  return Sigexit;\n}\n\nvoid os::Solaris::init_signal_mem() {\n  // Initialize signal structures\n  Maxsignum = SIGRTMAX;\n  Sigexit = Maxsignum+1;\n  assert(Maxsignum >0, \"Unable to obtain max signal number\");\n\n  Maxlibjsigsigs = Maxsignum;\n\n  // pending_signals has one int per signal\n  // The additional signal is for SIGEXIT - exit signal to signal_thread\n  pending_signals = (jint *)os::malloc(sizeof(jint) * (Sigexit+1), mtInternal);\n  memset(pending_signals, 0, (sizeof(jint) * (Sigexit+1)));\n\n  if (UseSignalChaining) {\n     chainedsigactions = (struct sigaction *)malloc(sizeof(struct sigaction)\n       * (Maxsignum + 1), mtInternal);\n     memset(chainedsigactions, 0, (sizeof(struct sigaction) * (Maxsignum + 1)));\n     preinstalled_sigs = (int *)os::malloc(sizeof(int) * (Maxsignum + 1), mtInternal);\n     memset(preinstalled_sigs, 0, (sizeof(int) * (Maxsignum + 1)));\n  }\n  ourSigFlags = (int*)malloc(sizeof(int) * (Maxsignum + 1 ), mtInternal);\n  memset(ourSigFlags, 0, sizeof(int) * (Maxsignum + 1));\n}\n\nvoid os::signal_init_pd() {\n  int ret;\n\n  ret = ::sema_init(&sig_sem, 0, NULL, NULL);\n  assert(ret == 0, \"sema_init() failed\");\n}\n\nvoid os::signal_notify(int signal_number) {\n  int ret;\n\n  Atomic::inc(&pending_signals[signal_number]);\n  ret = ::sema_post(&sig_sem);\n  assert(ret == 0, \"sema_post() failed\");\n}\n\nstatic int check_pending_signals(bool wait_for_signal) {\n  int ret;\n  while (true) {\n    for (int i = 0; i < Sigexit + 1; i++) {\n      jint n = pending_signals[i];\n      if (n > 0 && n == Atomic::cmpxchg(n - 1, &pending_signals[i], n)) {\n        return i;\n      }\n    }\n    if (!wait_for_signal) {\n      return -1;\n    }\n    JavaThread *thread = JavaThread::current();\n    ThreadBlockInVM tbivm(thread);\n\n    bool threadIsSuspended;\n    do {\n      thread->set_suspend_equivalent();\n      // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n      while((ret = ::sema_wait(&sig_sem)) == EINTR)\n          ;\n      assert(ret == 0, \"sema_wait() failed\");\n\n      // were we externally suspended while we were waiting?\n      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n      if (threadIsSuspended) {\n        //\n        // The semaphore has been incremented, but while we were waiting\n        // another thread suspended us. We don't want to continue running\n        // while suspended because that would surprise the thread that\n        // suspended us.\n        //\n        ret = ::sema_post(&sig_sem);\n        assert(ret == 0, \"sema_post() failed\");\n\n        thread->java_suspend_self();\n      }\n    } while (threadIsSuspended);\n  }\n}\n\nint os::signal_lookup() {\n  return check_pending_signals(false);\n}\n\nint os::signal_wait() {\n  return check_pending_signals(true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Virtual Memory\n\nstatic int page_size = -1;\n\n// The mmap MAP_ALIGN flag is supported on Solaris 9 and later.  init_2() will\n// clear this var if support is not available.\nstatic bool has_map_align = true;\n\nint os::vm_page_size() {\n  assert(page_size != -1, \"must call os::init\");\n  return page_size;\n}\n\n// Solaris allocates memory by pages.\nint os::vm_allocation_granularity() {\n  assert(page_size != -1, \"must call os::init\");\n  return page_size;\n}\n\nstatic bool recoverable_mmap_error(int err) {\n  // See if the error is one we can let the caller handle. This\n  // list of errno values comes from the Solaris mmap(2) man page.\n  switch (err) {\n  case EBADF:\n  case EINVAL:\n  case ENOTSUP:\n    // let the caller deal with these errors\n    return true;\n\n  default:\n    // Any remaining errors on this OS can cause our reserved mapping\n    // to be lost. That can cause confusion where different data\n    // structures think they have the same memory mapped. The worst\n    // scenario is if both the VM and a library think they have the\n    // same memory mapped.\n    return false;\n  }\n}\n\nstatic void warn_fail_commit_memory(char* addr, size_t bytes, bool exec,\n                                    int err) {\n  warning(\"INFO: os::commit_memory(\" PTR_FORMAT \", \" SIZE_FORMAT\n          \", %d) failed; error='%s' (errno=%d)\", addr, bytes, exec,\n          strerror(err), err);\n}\n\nstatic void warn_fail_commit_memory(char* addr, size_t bytes,\n                                    size_t alignment_hint, bool exec,\n                                    int err) {\n  warning(\"INFO: os::commit_memory(\" PTR_FORMAT \", \" SIZE_FORMAT\n          \", \" SIZE_FORMAT \", %d) failed; error='%s' (errno=%d)\", addr, bytes,\n          alignment_hint, exec, strerror(err), err);\n}\n\nint os::Solaris::commit_memory_impl(char* addr, size_t bytes, bool exec) {\n  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n  size_t size = bytes;\n  char *res = Solaris::mmap_chunk(addr, size, MAP_PRIVATE|MAP_FIXED, prot);\n  if (res != NULL) {\n    if (UseNUMAInterleaving) {\n      numa_make_global(addr, bytes);\n    }\n    return 0;\n  }\n\n  int err = errno;  // save errno from mmap() call in mmap_chunk()\n\n  if (!recoverable_mmap_error(err)) {\n    warn_fail_commit_memory(addr, bytes, exec, err);\n    vm_exit_out_of_memory(bytes, OOM_MMAP_ERROR, \"committing reserved memory.\");\n  }\n\n  return err;\n}\n\nbool os::pd_commit_memory(char* addr, size_t bytes, bool exec) {\n  return Solaris::commit_memory_impl(addr, bytes, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t bytes, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  int err = os::Solaris::commit_memory_impl(addr, bytes, exec);\n  if (err != 0) {\n    // the caller wants all commit errors to exit with the specified mesg:\n    warn_fail_commit_memory(addr, bytes, exec, err);\n    vm_exit_out_of_memory(bytes, OOM_MMAP_ERROR, mesg);\n  }\n}\n\nsize_t os::Solaris::page_size_for_alignment(size_t alignment) {\n  assert(is_size_aligned(alignment, (size_t) vm_page_size()),\n         err_msg(SIZE_FORMAT \" is not aligned to \" SIZE_FORMAT,\n                 alignment, (size_t) vm_page_size()));\n\n  for (int i = 0; _page_sizes[i] != 0; i++) {\n    if (is_size_aligned(alignment, _page_sizes[i])) {\n      return _page_sizes[i];\n    }\n  }\n\n  return (size_t) vm_page_size();\n}\n\nint os::Solaris::commit_memory_impl(char* addr, size_t bytes,\n                                    size_t alignment_hint, bool exec) {\n  int err = Solaris::commit_memory_impl(addr, bytes, exec);\n  if (err == 0 && UseLargePages && alignment_hint > 0) {\n    assert(is_size_aligned(bytes, alignment_hint),\n           err_msg(SIZE_FORMAT \" is not aligned to \" SIZE_FORMAT, bytes, alignment_hint));\n\n    // The syscall memcntl requires an exact page size (see man memcntl for details).\n    size_t page_size = page_size_for_alignment(alignment_hint);\n    if (page_size > (size_t) vm_page_size()) {\n      (void)Solaris::setup_large_pages(addr, bytes, page_size);\n    }\n  }\n  return err;\n}\n\nbool os::pd_commit_memory(char* addr, size_t bytes, size_t alignment_hint,\n                          bool exec) {\n  return Solaris::commit_memory_impl(addr, bytes, alignment_hint, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t bytes,\n                                  size_t alignment_hint, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  int err = os::Solaris::commit_memory_impl(addr, bytes, alignment_hint, exec);\n  if (err != 0) {\n    // the caller wants all commit errors to exit with the specified mesg:\n    warn_fail_commit_memory(addr, bytes, alignment_hint, exec, err);\n    vm_exit_out_of_memory(bytes, OOM_MMAP_ERROR, mesg);\n  }\n}\n\n// Uncommit the pages in a specified region.\nvoid os::pd_free_memory(char* addr, size_t bytes, size_t alignment_hint) {\n  if (madvise(addr, bytes, MADV_FREE) < 0) {\n    debug_only(warning(\"MADV_FREE failed.\"));\n    return;\n  }\n}\n\nbool os::pd_create_stack_guard_pages(char* addr, size_t size) {\n  return os::commit_memory(addr, size, !ExecMem);\n}\n\nbool os::remove_stack_guard_pages(char* addr, size_t size) {\n  return os::uncommit_memory(addr, size);\n}\n\n// Change the page size in a given range.\nvoid os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {\n  assert((intptr_t)addr % alignment_hint == 0, \"Address should be aligned.\");\n  assert((intptr_t)(addr + bytes) % alignment_hint == 0, \"End should be aligned.\");\n  if (UseLargePages) {\n    Solaris::setup_large_pages(addr, bytes, alignment_hint);\n  }\n}\n\n// Tell the OS to make the range local to the first-touching LWP\nvoid os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {\n  assert((intptr_t)addr % os::vm_page_size() == 0, \"Address should be page-aligned.\");\n  if (madvise(addr, bytes, MADV_ACCESS_LWP) < 0) {\n    debug_only(warning(\"MADV_ACCESS_LWP failed.\"));\n  }\n}\n\n// Tell the OS that this range would be accessed from different LWPs.\nvoid os::numa_make_global(char *addr, size_t bytes) {\n  assert((intptr_t)addr % os::vm_page_size() == 0, \"Address should be page-aligned.\");\n  if (madvise(addr, bytes, MADV_ACCESS_MANY) < 0) {\n    debug_only(warning(\"MADV_ACCESS_MANY failed.\"));\n  }\n}\n\n// Get the number of the locality groups.\nsize_t os::numa_get_groups_num() {\n  size_t n = Solaris::lgrp_nlgrps(Solaris::lgrp_cookie());\n  return n != -1 ? n : 1;\n}\n\n// Get a list of leaf locality groups. A leaf lgroup is group that\n// doesn't have any children. Typical leaf group is a CPU or a CPU/memory\n// board. An LWP is assigned to one of these groups upon creation.\nsize_t os::numa_get_leaf_groups(int *ids, size_t size) {\n   if ((ids[0] = Solaris::lgrp_root(Solaris::lgrp_cookie())) == -1) {\n     ids[0] = 0;\n     return 1;\n   }\n   int result_size = 0, top = 1, bottom = 0, cur = 0;\n   for (int k = 0; k < size; k++) {\n     int r = Solaris::lgrp_children(Solaris::lgrp_cookie(), ids[cur],\n                                    (Solaris::lgrp_id_t*)&ids[top], size - top);\n     if (r == -1) {\n       ids[0] = 0;\n       return 1;\n     }\n     if (!r) {\n       // That's a leaf node.\n       assert (bottom <= cur, \"Sanity check\");\n       // Check if the node has memory\n       if (Solaris::lgrp_resources(Solaris::lgrp_cookie(), ids[cur],\n                                   NULL, 0, LGRP_RSRC_MEM) > 0) {\n         ids[bottom++] = ids[cur];\n       }\n     }\n     top += r;\n     cur++;\n   }\n   if (bottom == 0) {\n     // Handle a situation, when the OS reports no memory available.\n     // Assume UMA architecture.\n     ids[0] = 0;\n     return 1;\n   }\n   return bottom;\n}\n\n// Detect the topology change. Typically happens during CPU plugging-unplugging.\nbool os::numa_topology_changed() {\n  int is_stale = Solaris::lgrp_cookie_stale(Solaris::lgrp_cookie());\n  if (is_stale != -1 && is_stale) {\n    Solaris::lgrp_fini(Solaris::lgrp_cookie());\n    Solaris::lgrp_cookie_t c = Solaris::lgrp_init(Solaris::LGRP_VIEW_CALLER);\n    assert(c != 0, \"Failure to initialize LGRP API\");\n    Solaris::set_lgrp_cookie(c);\n    return true;\n  }\n  return false;\n}\n\n// Get the group id of the current LWP.\nint os::numa_get_group_id() {\n  int lgrp_id = Solaris::lgrp_home(P_LWPID, P_MYID);\n  if (lgrp_id == -1) {\n    return 0;\n  }\n  const int size = os::numa_get_groups_num();\n  int *ids = (int*)alloca(size * sizeof(int));\n\n  // Get the ids of all lgroups with memory; r is the count.\n  int r = Solaris::lgrp_resources(Solaris::lgrp_cookie(), lgrp_id,\n                                  (Solaris::lgrp_id_t*)ids, size, LGRP_RSRC_MEM);\n  if (r <= 0) {\n    return 0;\n  }\n  return ids[os::random() % r];\n}\n\n// Request information about the page.\nbool os::get_page_info(char *start, page_info* info) {\n  const uint_t info_types[] = { MEMINFO_VLGRP, MEMINFO_VPAGESIZE };\n  uint64_t addr = (uintptr_t)start;\n  uint64_t outdata[2];\n  uint_t validity = 0;\n\n  if (os::Solaris::meminfo(&addr, 1, info_types, 2, outdata, &validity) < 0) {\n    return false;\n  }\n\n  info->size = 0;\n  info->lgrp_id = -1;\n\n  if ((validity & 1) != 0) {\n    if ((validity & 2) != 0) {\n      info->lgrp_id = outdata[0];\n    }\n    if ((validity & 4) != 0) {\n      info->size = outdata[1];\n    }\n    return true;\n  }\n  return false;\n}\n\n// Scan the pages from start to end until a page different than\n// the one described in the info parameter is encountered.\nchar *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {\n  const uint_t info_types[] = { MEMINFO_VLGRP, MEMINFO_VPAGESIZE };\n  const size_t types = sizeof(info_types) / sizeof(info_types[0]);\n  uint64_t addrs[MAX_MEMINFO_CNT], outdata[types * MAX_MEMINFO_CNT + 1];\n  uint_t validity[MAX_MEMINFO_CNT];\n\n  size_t page_size = MAX2((size_t)os::vm_page_size(), page_expected->size);\n  uint64_t p = (uint64_t)start;\n  while (p < (uint64_t)end) {\n    addrs[0] = p;\n    size_t addrs_count = 1;\n    while (addrs_count < MAX_MEMINFO_CNT && addrs[addrs_count - 1] + page_size < (uint64_t)end) {\n      addrs[addrs_count] = addrs[addrs_count - 1] + page_size;\n      addrs_count++;\n    }\n\n    if (os::Solaris::meminfo(addrs, addrs_count, info_types, types, outdata, validity) < 0) {\n      return NULL;\n    }\n\n    size_t i = 0;\n    for (; i < addrs_count; i++) {\n      if ((validity[i] & 1) != 0) {\n        if ((validity[i] & 4) != 0) {\n          if (outdata[types * i + 1] != page_expected->size) {\n            break;\n          }\n        } else\n          if (page_expected->size != 0) {\n            break;\n          }\n\n        if ((validity[i] & 2) != 0 && page_expected->lgrp_id > 0) {\n          if (outdata[types * i] != page_expected->lgrp_id) {\n            break;\n          }\n        }\n      } else {\n        return NULL;\n      }\n    }\n\n    if (i < addrs_count) {\n      if ((validity[i] & 2) != 0) {\n        page_found->lgrp_id = outdata[types * i];\n      } else {\n        page_found->lgrp_id = -1;\n      }\n      if ((validity[i] & 4) != 0) {\n        page_found->size = outdata[types * i + 1];\n      } else {\n        page_found->size = 0;\n      }\n      return (char*)addrs[i];\n    }\n\n    p = addrs[addrs_count - 1] + page_size;\n  }\n  return end;\n}\n\nbool os::pd_uncommit_memory(char* addr, size_t bytes) {\n  size_t size = bytes;\n  // Map uncommitted pages PROT_NONE so we fail early if we touch an\n  // uncommitted page. Otherwise, the read/write might succeed if we\n  // have enough swap space to back the physical page.\n  return\n    NULL != Solaris::mmap_chunk(addr, size,\n                                MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE,\n                                PROT_NONE);\n}\n\nchar* os::Solaris::mmap_chunk(char *addr, size_t size, int flags, int prot) {\n  char *b = (char *)mmap(addr, size, prot, flags, os::Solaris::_dev_zero_fd, 0);\n\n  if (b == MAP_FAILED) {\n    return NULL;\n  }\n  return b;\n}\n\nchar* os::Solaris::anon_mmap(char* requested_addr, size_t bytes, size_t alignment_hint, bool fixed) {\n  char* addr = requested_addr;\n  int flags = MAP_PRIVATE | MAP_NORESERVE;\n\n  assert(!(fixed && (alignment_hint > 0)), \"alignment hint meaningless with fixed mmap\");\n\n  if (fixed) {\n    flags |= MAP_FIXED;\n  } else if (has_map_align && (alignment_hint > (size_t) vm_page_size())) {\n    flags |= MAP_ALIGN;\n    addr = (char*) alignment_hint;\n  }\n\n  // Map uncommitted pages PROT_NONE so we fail early if we touch an\n  // uncommitted page. Otherwise, the read/write might succeed if we\n  // have enough swap space to back the physical page.\n  return mmap_chunk(addr, bytes, flags, PROT_NONE);\n}\n\nchar* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {\n  char* addr = Solaris::anon_mmap(requested_addr, bytes, alignment_hint, (requested_addr != NULL));\n\n  guarantee(requested_addr == NULL || requested_addr == addr,\n            \"OS failed to return requested mmap address.\");\n  return addr;\n}\n\n// Reserve memory at an arbitrary address, only if that area is\n// available (and not reserved for something else).\n\nchar* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {\n  const int max_tries = 10;\n  char* base[max_tries];\n  size_t size[max_tries];\n\n  // Solaris adds a gap between mmap'ed regions.  The size of the gap\n  // is dependent on the requested size and the MMU.  Our initial gap\n  // value here is just a guess and will be corrected later.\n  bool had_top_overlap = false;\n  bool have_adjusted_gap = false;\n  size_t gap = 0x400000;\n\n  // Assert only that the size is a multiple of the page size, since\n  // that's all that mmap requires, and since that's all we really know\n  // about at this low abstraction level.  If we need higher alignment,\n  // we can either pass an alignment to this method or verify alignment\n  // in one of the methods further up the call chain.  See bug 5044738.\n  assert(bytes % os::vm_page_size() == 0, \"reserving unexpected size block\");\n\n  // Since snv_84, Solaris attempts to honor the address hint - see 5003415.\n  // Give it a try, if the kernel honors the hint we can return immediately.\n  char* addr = Solaris::anon_mmap(requested_addr, bytes, 0, false);\n\n  volatile int err = errno;\n  if (addr == requested_addr) {\n    return addr;\n  } else if (addr != NULL) {\n    pd_unmap_memory(addr, bytes);\n  }\n\n  if (PrintMiscellaneous && Verbose) {\n    char buf[256];\n    buf[0] = '\\0';\n    if (addr == NULL) {\n      jio_snprintf(buf, sizeof(buf), \": %s\", strerror(err));\n    }\n    warning(\"attempt_reserve_memory_at: couldn't reserve \" SIZE_FORMAT \" bytes at \"\n            PTR_FORMAT \": reserve_memory_helper returned \" PTR_FORMAT\n            \"%s\", bytes, requested_addr, addr, buf);\n  }\n\n  // Address hint method didn't work.  Fall back to the old method.\n  // In theory, once SNV becomes our oldest supported platform, this\n  // code will no longer be needed.\n  //\n  // Repeatedly allocate blocks until the block is allocated at the\n  // right spot. Give up after max_tries.\n  int i;\n  for (i = 0; i < max_tries; ++i) {\n    base[i] = reserve_memory(bytes);\n\n    if (base[i] != NULL) {\n      // Is this the block we wanted?\n      if (base[i] == requested_addr) {\n        size[i] = bytes;\n        break;\n      }\n\n      // check that the gap value is right\n      if (had_top_overlap && !have_adjusted_gap) {\n        size_t actual_gap = base[i-1] - base[i] - bytes;\n        if (gap != actual_gap) {\n          // adjust the gap value and retry the last 2 allocations\n          assert(i > 0, \"gap adjustment code problem\");\n          have_adjusted_gap = true;  // adjust the gap only once, just in case\n          gap = actual_gap;\n          if (PrintMiscellaneous && Verbose) {\n            warning(\"attempt_reserve_memory_at: adjusted gap to 0x%lx\", gap);\n          }\n          unmap_memory(base[i], bytes);\n          unmap_memory(base[i-1], size[i-1]);\n          i-=2;\n          continue;\n        }\n      }\n\n      // Does this overlap the block we wanted? Give back the overlapped\n      // parts and try again.\n      //\n      // There is still a bug in this code: if top_overlap == bytes,\n      // the overlap is offset from requested region by the value of gap.\n      // In this case giving back the overlapped part will not work,\n      // because we'll give back the entire block at base[i] and\n      // therefore the subsequent allocation will not generate a new gap.\n      // This could be fixed with a new algorithm that used larger\n      // or variable size chunks to find the requested region -\n      // but such a change would introduce additional complications.\n      // It's rare enough that the planets align for this bug,\n      // so we'll just wait for a fix for 6204603/5003415 which\n      // will provide a mmap flag to allow us to avoid this business.\n\n      size_t top_overlap = requested_addr + (bytes + gap) - base[i];\n      if (top_overlap >= 0 && top_overlap < bytes) {\n        had_top_overlap = true;\n        unmap_memory(base[i], top_overlap);\n        base[i] += top_overlap;\n        size[i] = bytes - top_overlap;\n      } else {\n        size_t bottom_overlap = base[i] + bytes - requested_addr;\n        if (bottom_overlap >= 0 && bottom_overlap < bytes) {\n          if (PrintMiscellaneous && Verbose && bottom_overlap == 0) {\n            warning(\"attempt_reserve_memory_at: possible alignment bug\");\n          }\n          unmap_memory(requested_addr, bottom_overlap);\n          size[i] = bytes - bottom_overlap;\n        } else {\n          size[i] = bytes;\n        }\n      }\n    }\n  }\n\n  // Give back the unused reserved pieces.\n\n  for (int j = 0; j < i; ++j) {\n    if (base[j] != NULL) {\n      unmap_memory(base[j], size[j]);\n    }\n  }\n\n  return (i < max_tries) ? requested_addr : NULL;\n}\n\nbool os::pd_release_memory(char* addr, size_t bytes) {\n  size_t size = bytes;\n  return munmap(addr, size) == 0;\n}\n\nstatic bool solaris_mprotect(char* addr, size_t bytes, int prot) {\n  assert(addr == (char*)align_size_down((uintptr_t)addr, os::vm_page_size()),\n         \"addr must be page aligned\");\n  int retVal = mprotect(addr, bytes, prot);\n  return retVal == 0;\n}\n\n// Protect memory (Used to pass readonly pages through\n// JNI GetArray<type>Elements with empty arrays.)\n// Also, used for serialization page and for compressed oops null pointer\n// checking.\nbool os::protect_memory(char* addr, size_t bytes, ProtType prot,\n                        bool is_committed) {\n  unsigned int p = 0;\n  switch (prot) {\n  case MEM_PROT_NONE: p = PROT_NONE; break;\n  case MEM_PROT_READ: p = PROT_READ; break;\n  case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;\n  case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;\n  default:\n    ShouldNotReachHere();\n  }\n  // is_committed is unused.\n  return solaris_mprotect(addr, bytes, p);\n}\n\n// guard_memory and unguard_memory only happens within stack guard pages.\n// Since ISM pertains only to the heap, guard and unguard memory should not\n/// happen with an ISM region.\nbool os::guard_memory(char* addr, size_t bytes) {\n  return solaris_mprotect(addr, bytes, PROT_NONE);\n}\n\nbool os::unguard_memory(char* addr, size_t bytes) {\n  return solaris_mprotect(addr, bytes, PROT_READ|PROT_WRITE);\n}\n\n// Large page support\nstatic size_t _large_page_size = 0;\n\n// Insertion sort for small arrays (descending order).\nstatic void insertion_sort_descending(size_t* array, int len) {\n  for (int i = 0; i < len; i++) {\n    size_t val = array[i];\n    for (size_t key = i; key > 0 && array[key - 1] < val; --key) {\n      size_t tmp = array[key];\n      array[key] = array[key - 1];\n      array[key - 1] = tmp;\n    }\n  }\n}\n\nbool os::Solaris::mpss_sanity_check(bool warn, size_t* page_size) {\n  const unsigned int usable_count = VM_Version::page_size_count();\n  if (usable_count == 1) {\n    return false;\n  }\n\n  // Find the right getpagesizes interface.  When solaris 11 is the minimum\n  // build platform, getpagesizes() (without the '2') can be called directly.\n  typedef int (*gps_t)(size_t[], int);\n  gps_t gps_func = CAST_TO_FN_PTR(gps_t, dlsym(RTLD_DEFAULT, \"getpagesizes2\"));\n  if (gps_func == NULL) {\n    gps_func = CAST_TO_FN_PTR(gps_t, dlsym(RTLD_DEFAULT, \"getpagesizes\"));\n    if (gps_func == NULL) {\n      if (warn) {\n        warning(\"MPSS is not supported by the operating system.\");\n      }\n      return false;\n    }\n  }\n\n  // Fill the array of page sizes.\n  int n = (*gps_func)(_page_sizes, page_sizes_max);\n  assert(n > 0, \"Solaris bug?\");\n\n  if (n == page_sizes_max) {\n    // Add a sentinel value (necessary only if the array was completely filled\n    // since it is static (zeroed at initialization)).\n    _page_sizes[--n] = 0;\n    DEBUG_ONLY(warning(\"increase the size of the os::_page_sizes array.\");)\n  }\n  assert(_page_sizes[n] == 0, \"missing sentinel\");\n  trace_page_sizes(\"available page sizes\", _page_sizes, n);\n\n  if (n == 1) return false;     // Only one page size available.\n\n  // Skip sizes larger than 4M (or LargePageSizeInBytes if it was set) and\n  // select up to usable_count elements.  First sort the array, find the first\n  // acceptable value, then copy the usable sizes to the top of the array and\n  // trim the rest.  Make sure to include the default page size :-).\n  //\n  // A better policy could get rid of the 4M limit by taking the sizes of the\n  // important VM memory regions (java heap and possibly the code cache) into\n  // account.\n  insertion_sort_descending(_page_sizes, n);\n  const size_t size_limit =\n    FLAG_IS_DEFAULT(LargePageSizeInBytes) ? 4 * M : LargePageSizeInBytes;\n  int beg;\n  for (beg = 0; beg < n && _page_sizes[beg] > size_limit; ++beg) /* empty */ ;\n  const int end = MIN2((int)usable_count, n) - 1;\n  for (int cur = 0; cur < end; ++cur, ++beg) {\n    _page_sizes[cur] = _page_sizes[beg];\n  }\n  _page_sizes[end] = vm_page_size();\n  _page_sizes[end + 1] = 0;\n\n  if (_page_sizes[end] > _page_sizes[end - 1]) {\n    // Default page size is not the smallest; sort again.\n    insertion_sort_descending(_page_sizes, end + 1);\n  }\n  *page_size = _page_sizes[0];\n\n  trace_page_sizes(\"usable page sizes\", _page_sizes, end + 1);\n  return true;\n}\n\nvoid os::large_page_init() {\n  if (UseLargePages) {\n    // print a warning if any large page related flag is specified on command line\n    bool warn_on_failure = !FLAG_IS_DEFAULT(UseLargePages)        ||\n                           !FLAG_IS_DEFAULT(LargePageSizeInBytes);\n\n    UseLargePages = Solaris::mpss_sanity_check(warn_on_failure, &_large_page_size);\n  }\n}\n\nbool os::Solaris::is_valid_page_size(size_t bytes) {\n  for (int i = 0; _page_sizes[i] != 0; i++) {\n    if (_page_sizes[i] == bytes) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool os::Solaris::setup_large_pages(caddr_t start, size_t bytes, size_t align) {\n  assert(is_valid_page_size(align), err_msg(SIZE_FORMAT \" is not a valid page size\", align));\n  assert(is_ptr_aligned((void*) start, align),\n         err_msg(PTR_FORMAT \" is not aligned to \" SIZE_FORMAT, p2i((void*) start), align));\n  assert(is_size_aligned(bytes, align),\n         err_msg(SIZE_FORMAT \" is not aligned to \" SIZE_FORMAT, bytes, align));\n\n  // Signal to OS that we want large pages for addresses\n  // from addr, addr + bytes\n  struct memcntl_mha mpss_struct;\n  mpss_struct.mha_cmd = MHA_MAPSIZE_VA;\n  mpss_struct.mha_pagesize = align;\n  mpss_struct.mha_flags = 0;\n  // Upon successful completion, memcntl() returns 0\n  if (memcntl(start, bytes, MC_HAT_ADVISE, (caddr_t) &mpss_struct, 0, 0)) {\n    debug_only(warning(\"Attempt to use MPSS failed.\"));\n    return false;\n  }\n  return true;\n}\n\nchar* os::reserve_memory_special(size_t size, size_t alignment, char* addr, bool exec) {\n  fatal(\"os::reserve_memory_special should not be called on Solaris.\");\n  return NULL;\n}\n\nbool os::release_memory_special(char* base, size_t bytes) {\n  fatal(\"os::release_memory_special should not be called on Solaris.\");\n  return false;\n}\n\nsize_t os::large_page_size() {\n  return _large_page_size;\n}\n\n// MPSS allows application to commit large page memory on demand; with ISM\n// the entire memory region must be allocated as shared memory.\nbool os::can_commit_large_page_memory() {\n  return true;\n}\n\nbool os::can_execute_large_page_memory() {\n  return true;\n}\n\nstatic int os_sleep(jlong millis, bool interruptible) {\n  const jlong limit = INT_MAX;\n  jlong prevtime;\n  int res;\n\n  while (millis > limit) {\n    if ((res = os_sleep(limit, interruptible)) != OS_OK)\n      return res;\n    millis -= limit;\n  }\n\n  // Restart interrupted polls with new parameters until the proper delay\n  // has been completed.\n\n  prevtime = getTimeMillis();\n\n  while (millis > 0) {\n    jlong newtime;\n\n    if (!interruptible) {\n      // Following assert fails for os::yield_all:\n      // assert(!thread->is_Java_thread(), \"must not be java thread\");\n      res = poll(NULL, 0, millis);\n    } else {\n      JavaThread *jt = JavaThread::current();\n\n      INTERRUPTIBLE_NORESTART_VM_ALWAYS(poll(NULL, 0, millis), res, jt,\n        os::Solaris::clear_interrupted);\n    }\n\n    // INTERRUPTIBLE_NORESTART_VM_ALWAYS returns res == OS_INTRPT for\n    // thread.Interrupt.\n\n    // See c/r 6751923. Poll can return 0 before time\n    // has elapsed if time is set via clock_settime (as NTP does).\n    // res == 0 if poll timed out (see man poll RETURN VALUES)\n    // using the logic below checks that we really did\n    // sleep at least \"millis\" if not we'll sleep again.\n    if( ( res == 0 ) || ((res == OS_ERR) && (errno == EINTR))) {\n      newtime = getTimeMillis();\n      assert(newtime >= prevtime, \"time moving backwards\");\n    /* Doing prevtime and newtime in microseconds doesn't help precision,\n       and trying to round up to avoid lost milliseconds can result in a\n       too-short delay. */\n      millis -= newtime - prevtime;\n      if(millis <= 0)\n        return OS_OK;\n      prevtime = newtime;\n    } else\n      return res;\n  }\n\n  return OS_OK;\n}\n\n// Read calls from inside the vm need to perform state transitions\nsize_t os::read(int fd, void *buf, unsigned int nBytes) {\n  INTERRUPTIBLE_RETURN_INT_VM(::read(fd, buf, nBytes), os::Solaris::clear_interrupted);\n}\n\nsize_t os::restartable_read(int fd, void *buf, unsigned int nBytes) {\n  INTERRUPTIBLE_RETURN_INT(::read(fd, buf, nBytes), os::Solaris::clear_interrupted);\n}\n\nint os::sleep(Thread* thread, jlong millis, bool interruptible) {\n  assert(thread == Thread::current(),  \"thread consistency check\");\n\n  // TODO-FIXME: this should be removed.\n  // On Solaris machines (especially 2.5.1) we found that sometimes the VM gets into a live lock\n  // situation with a JavaThread being starved out of a lwp. The kernel doesn't seem to generate\n  // a SIGWAITING signal which would enable the threads library to create a new lwp for the starving\n  // thread. We suspect that because the Watcher thread keeps waking up at periodic intervals the kernel\n  // is fooled into believing that the system is making progress. In the code below we block the\n  // the watcher thread while safepoint is in progress so that it would not appear as though the\n  // system is making progress.\n  if (!Solaris::T2_libthread() &&\n      thread->is_Watcher_thread() && SafepointSynchronize::is_synchronizing() && !Arguments::has_profile()) {\n    // We now try to acquire the threads lock. Since this lock is held by the VM thread during\n    // the entire safepoint, the watcher thread will  line up here during the safepoint.\n    Threads_lock->lock_without_safepoint_check();\n    Threads_lock->unlock();\n  }\n\n  if (thread->is_Java_thread()) {\n    // This is a JavaThread so we honor the _thread_blocked protocol\n    // even for sleeps of 0 milliseconds. This was originally done\n    // as a workaround for bug 4338139. However, now we also do it\n    // to honor the suspend-equivalent protocol.\n\n    JavaThread *jt = (JavaThread *) thread;\n    ThreadBlockInVM tbivm(jt);\n\n    jt->set_suspend_equivalent();\n    // cleared by handle_special_suspend_equivalent_condition() or\n    // java_suspend_self() via check_and_wait_while_suspended()\n\n    int ret_code;\n    if (millis <= 0) {\n      thr_yield();\n      ret_code = 0;\n    } else {\n      // The original sleep() implementation did not create an\n      // OSThreadWaitState helper for sleeps of 0 milliseconds.\n      // I'm preserving that decision for now.\n      OSThreadWaitState osts(jt->osthread(), false /* not Object.wait() */);\n\n      ret_code = os_sleep(millis, interruptible);\n    }\n\n    // were we externally suspended while we were waiting?\n    jt->check_and_wait_while_suspended();\n\n    return ret_code;\n  }\n\n  // non-JavaThread from this point on:\n\n  if (millis <= 0) {\n    thr_yield();\n    return 0;\n  }\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n\n  return os_sleep(millis, interruptible);\n}\n\nvoid os::naked_short_sleep(jlong ms) {\n  assert(ms < 1000, \"Un-interruptable sleep, short time use only\");\n\n  // usleep is deprecated and removed from POSIX, in favour of nanosleep, but\n  // Solaris requires -lrt for this.\n  usleep((ms * 1000));\n\n  return;\n}\n\n// Sleep forever; naked call to OS-specific sleep; use with CAUTION\nvoid os::infinite_sleep() {\n  while (true) {    // sleep forever ...\n    ::sleep(100);   // ... 100 seconds at a time\n  }\n}\n\n// Used to convert frequent JVM_Yield() to nops\nbool os::dont_yield() {\n  if (DontYieldALot) {\n    static hrtime_t last_time = 0;\n    hrtime_t diff = getTimeNanos() - last_time;\n\n    if (diff < DontYieldALotInterval * 1000000)\n      return true;\n\n    last_time += diff;\n\n    return false;\n  }\n  else {\n    return false;\n  }\n}\n\n// Caveat: Solaris os::yield() causes a thread-state transition whereas\n// the linux and win32 implementations do not.  This should be checked.\n\nvoid os::yield() {\n  // Yields to all threads with same or greater priority\n  os::sleep(Thread::current(), 0, false);\n}\n\n// Note that yield semantics are defined by the scheduling class to which\n// the thread currently belongs.  Typically, yield will _not yield to\n// other equal or higher priority threads that reside on the dispatch queues\n// of other CPUs.\n\nos::YieldResult os::NakedYield() { thr_yield(); return os::YIELD_UNKNOWN; }\n\n\n// On Solaris we found that yield_all doesn't always yield to all other threads.\n// There have been cases where there is a thread ready to execute but it doesn't\n// get an lwp as the VM thread continues to spin with sleeps of 1 millisecond.\n// The 1 millisecond wait doesn't seem long enough for the kernel to issue a\n// SIGWAITING signal which will cause a new lwp to be created. So we count the\n// number of times yield_all is called in the one loop and increase the sleep\n// time after 8 attempts. If this fails too we increase the concurrency level\n// so that the starving thread would get an lwp\n\nvoid os::yield_all(int attempts) {\n  // Yields to all threads, including threads with lower priorities\n  if (attempts == 0) {\n    os::sleep(Thread::current(), 1, false);\n  } else {\n    int iterations = attempts % 30;\n    if (iterations == 0 && !os::Solaris::T2_libthread()) {\n      // thr_setconcurrency and _getconcurrency make sense only under T1.\n      int noofLWPS = thr_getconcurrency();\n      if (noofLWPS < (Threads::number_of_threads() + 2)) {\n        thr_setconcurrency(thr_getconcurrency() + 1);\n      }\n    } else if (iterations < 25) {\n      os::sleep(Thread::current(), 1, false);\n    } else {\n      os::sleep(Thread::current(), 10, false);\n    }\n  }\n}\n\n// Called from the tight loops to possibly influence time-sharing heuristics\nvoid os::loop_breaker(int attempts) {\n  os::yield_all(attempts);\n}\n\n\n// Interface for setting lwp priorities.  If we are using T2 libthread,\n// which forces the use of BoundThreads or we manually set UseBoundThreads,\n// all of our threads will be assigned to real lwp's.  Using the thr_setprio\n// function is meaningless in this mode so we must adjust the real lwp's priority\n// The routines below implement the getting and setting of lwp priorities.\n//\n// Note: There are three priority scales used on Solaris.  Java priotities\n//       which range from 1 to 10, libthread \"thr_setprio\" scale which range\n//       from 0 to 127, and the current scheduling class of the process we\n//       are running in.  This is typically from -60 to +60.\n//       The setting of the lwp priorities in done after a call to thr_setprio\n//       so Java priorities are mapped to libthread priorities and we map from\n//       the latter to lwp priorities.  We don't keep priorities stored in\n//       Java priorities since some of our worker threads want to set priorities\n//       higher than all Java threads.\n//\n// For related information:\n// (1)  man -s 2 priocntl\n// (2)  man -s 4 priocntl\n// (3)  man dispadmin\n// =    librt.so\n// =    libthread/common/rtsched.c - thrp_setlwpprio().\n// =    ps -cL <pid> ... to validate priority.\n// =    sched_get_priority_min and _max\n//              pthread_create\n//              sched_setparam\n//              pthread_setschedparam\n//\n// Assumptions:\n// +    We assume that all threads in the process belong to the same\n//              scheduling class.   IE. an homogenous process.\n// +    Must be root or in IA group to change change \"interactive\" attribute.\n//              Priocntl() will fail silently.  The only indication of failure is when\n//              we read-back the value and notice that it hasn't changed.\n// +    Interactive threads enter the runq at the head, non-interactive at the tail.\n// +    For RT, change timeslice as well.  Invariant:\n//              constant \"priority integral\"\n//              Konst == TimeSlice * (60-Priority)\n//              Given a priority, compute appropriate timeslice.\n// +    Higher numerical values have higher priority.\n\n// sched class attributes\ntypedef struct {\n        int   schedPolicy;              // classID\n        int   maxPrio;\n        int   minPrio;\n} SchedInfo;\n\n\nstatic SchedInfo tsLimits, iaLimits, rtLimits, fxLimits;\n\n#ifdef ASSERT\nstatic int  ReadBackValidate = 1;\n#endif\nstatic int  myClass     = 0;\nstatic int  myMin       = 0;\nstatic int  myMax       = 0;\nstatic int  myCur       = 0;\nstatic bool priocntl_enable = false;\n\nstatic const int criticalPrio = 60; // FX/60 is critical thread class/priority on T4\nstatic int java_MaxPriority_to_os_priority = 0; // Saved mapping\n\n\n// lwp_priocntl_init\n//\n// Try to determine the priority scale for our process.\n//\n// Return errno or 0 if OK.\n//\nstatic int lwp_priocntl_init () {\n  int rslt;\n  pcinfo_t ClassInfo;\n  pcparms_t ParmInfo;\n  int i;\n\n  if (!UseThreadPriorities) return 0;\n\n  // We are using Bound threads, we need to determine our priority ranges\n  if (os::Solaris::T2_libthread() || UseBoundThreads) {\n    // If ThreadPriorityPolicy is 1, switch tables\n    if (ThreadPriorityPolicy == 1) {\n      for (i = 0 ; i < CriticalPriority+1; i++)\n        os::java_to_os_priority[i] = prio_policy1[i];\n    }\n    if (UseCriticalJavaThreadPriority) {\n      // MaxPriority always maps to the FX scheduling class and criticalPrio.\n      // See set_native_priority() and set_lwp_class_and_priority().\n      // Save original MaxPriority mapping in case attempt to\n      // use critical priority fails.\n      java_MaxPriority_to_os_priority = os::java_to_os_priority[MaxPriority];\n      // Set negative to distinguish from other priorities\n      os::java_to_os_priority[MaxPriority] = -criticalPrio;\n    }\n  }\n  // Not using Bound Threads, set to ThreadPolicy 1\n  else {\n    for ( i = 0 ; i < CriticalPriority+1; i++ ) {\n      os::java_to_os_priority[i] = prio_policy1[i];\n    }\n    return 0;\n  }\n\n  // Get IDs for a set of well-known scheduling classes.\n  // TODO-FIXME: GETCLINFO returns the current # of classes in the\n  // the system.  We should have a loop that iterates over the\n  // classID values, which are known to be \"small\" integers.\n\n  strcpy(ClassInfo.pc_clname, \"TS\");\n  ClassInfo.pc_cid = -1;\n  rslt = priocntl(P_ALL, 0, PC_GETCID, (caddr_t)&ClassInfo);\n  if (rslt < 0) return errno;\n  assert(ClassInfo.pc_cid != -1, \"cid for TS class is -1\");\n  tsLimits.schedPolicy = ClassInfo.pc_cid;\n  tsLimits.maxPrio = ((tsinfo_t*)ClassInfo.pc_clinfo)->ts_maxupri;\n  tsLimits.minPrio = -tsLimits.maxPrio;\n\n  strcpy(ClassInfo.pc_clname, \"IA\");\n  ClassInfo.pc_cid = -1;\n  rslt = priocntl(P_ALL, 0, PC_GETCID, (caddr_t)&ClassInfo);\n  if (rslt < 0) return errno;\n  assert(ClassInfo.pc_cid != -1, \"cid for IA class is -1\");\n  iaLimits.schedPolicy = ClassInfo.pc_cid;\n  iaLimits.maxPrio = ((iainfo_t*)ClassInfo.pc_clinfo)->ia_maxupri;\n  iaLimits.minPrio = -iaLimits.maxPrio;\n\n  strcpy(ClassInfo.pc_clname, \"RT\");\n  ClassInfo.pc_cid = -1;\n  rslt = priocntl(P_ALL, 0, PC_GETCID, (caddr_t)&ClassInfo);\n  if (rslt < 0) return errno;\n  assert(ClassInfo.pc_cid != -1, \"cid for RT class is -1\");\n  rtLimits.schedPolicy = ClassInfo.pc_cid;\n  rtLimits.maxPrio = ((rtinfo_t*)ClassInfo.pc_clinfo)->rt_maxpri;\n  rtLimits.minPrio = 0;\n\n  strcpy(ClassInfo.pc_clname, \"FX\");\n  ClassInfo.pc_cid = -1;\n  rslt = priocntl(P_ALL, 0, PC_GETCID, (caddr_t)&ClassInfo);\n  if (rslt < 0) return errno;\n  assert(ClassInfo.pc_cid != -1, \"cid for FX class is -1\");\n  fxLimits.schedPolicy = ClassInfo.pc_cid;\n  fxLimits.maxPrio = ((fxinfo_t*)ClassInfo.pc_clinfo)->fx_maxupri;\n  fxLimits.minPrio = 0;\n\n  // Query our \"current\" scheduling class.\n  // This will normally be IA, TS or, rarely, FX or RT.\n  memset(&ParmInfo, 0, sizeof(ParmInfo));\n  ParmInfo.pc_cid = PC_CLNULL;\n  rslt = priocntl(P_PID, P_MYID, PC_GETPARMS, (caddr_t)&ParmInfo);\n  if (rslt < 0) return errno;\n  myClass = ParmInfo.pc_cid;\n\n  // We now know our scheduling classId, get specific information\n  // about the class.\n  ClassInfo.pc_cid = myClass;\n  ClassInfo.pc_clname[0] = 0;\n  rslt = priocntl((idtype)0, 0, PC_GETCLINFO, (caddr_t)&ClassInfo);\n  if (rslt < 0) return errno;\n\n  if (ThreadPriorityVerbose) {\n    tty->print_cr(\"lwp_priocntl_init: Class=%d(%s)...\", myClass, ClassInfo.pc_clname);\n  }\n\n  memset(&ParmInfo, 0, sizeof(pcparms_t));\n  ParmInfo.pc_cid = PC_CLNULL;\n  rslt = priocntl(P_PID, P_MYID, PC_GETPARMS, (caddr_t)&ParmInfo);\n  if (rslt < 0) return errno;\n\n  if (ParmInfo.pc_cid == rtLimits.schedPolicy) {\n    myMin = rtLimits.minPrio;\n    myMax = rtLimits.maxPrio;\n  } else if (ParmInfo.pc_cid == iaLimits.schedPolicy) {\n    iaparms_t *iaInfo  = (iaparms_t*)ParmInfo.pc_clparms;\n    myMin = iaLimits.minPrio;\n    myMax = iaLimits.maxPrio;\n    myMax = MIN2(myMax, (int)iaInfo->ia_uprilim);       // clamp - restrict\n  } else if (ParmInfo.pc_cid == tsLimits.schedPolicy) {\n    tsparms_t *tsInfo  = (tsparms_t*)ParmInfo.pc_clparms;\n    myMin = tsLimits.minPrio;\n    myMax = tsLimits.maxPrio;\n    myMax = MIN2(myMax, (int)tsInfo->ts_uprilim);       // clamp - restrict\n  } else if (ParmInfo.pc_cid == fxLimits.schedPolicy) {\n    fxparms_t *fxInfo = (fxparms_t*)ParmInfo.pc_clparms;\n    myMin = fxLimits.minPrio;\n    myMax = fxLimits.maxPrio;\n    myMax = MIN2(myMax, (int)fxInfo->fx_uprilim);       // clamp - restrict\n  } else {\n    // No clue - punt\n    if (ThreadPriorityVerbose)\n      tty->print_cr (\"Unknown scheduling class: %s ... \\n\", ClassInfo.pc_clname);\n    return EINVAL;      // no clue, punt\n  }\n\n  if (ThreadPriorityVerbose) {\n    tty->print_cr (\"Thread priority Range: [%d..%d]\\n\", myMin, myMax);\n  }\n\n  priocntl_enable = true;  // Enable changing priorities\n  return 0;\n}\n\n#define IAPRI(x)        ((iaparms_t *)((x).pc_clparms))\n#define RTPRI(x)        ((rtparms_t *)((x).pc_clparms))\n#define TSPRI(x)        ((tsparms_t *)((x).pc_clparms))\n#define FXPRI(x)        ((fxparms_t *)((x).pc_clparms))\n\n\n// scale_to_lwp_priority\n//\n// Convert from the libthread \"thr_setprio\" scale to our current\n// lwp scheduling class scale.\n//\nstatic\nint     scale_to_lwp_priority (int rMin, int rMax, int x)\n{\n  int v;\n\n  if (x == 127) return rMax;            // avoid round-down\n    v = (((x*(rMax-rMin)))/128)+rMin;\n  return v;\n}\n\n\n// set_lwp_class_and_priority\n//\n// Set the class and priority of the lwp.  This call should only\n// be made when using bound threads (T2 threads are bound by default).\n//\nint set_lwp_class_and_priority(int ThreadID, int lwpid,\n                               int newPrio, int new_class, bool scale) {\n  int rslt;\n  int Actual, Expected, prv;\n  pcparms_t ParmInfo;                   // for GET-SET\n#ifdef ASSERT\n  pcparms_t ReadBack;                   // for readback\n#endif\n\n  // Set priority via PC_GETPARMS, update, PC_SETPARMS\n  // Query current values.\n  // TODO: accelerate this by eliminating the PC_GETPARMS call.\n  // Cache \"pcparms_t\" in global ParmCache.\n  // TODO: elide set-to-same-value\n\n  // If something went wrong on init, don't change priorities.\n  if ( !priocntl_enable ) {\n    if (ThreadPriorityVerbose)\n      tty->print_cr(\"Trying to set priority but init failed, ignoring\");\n    return EINVAL;\n  }\n\n  // If lwp hasn't started yet, just return\n  // the _start routine will call us again.\n  if ( lwpid <= 0 ) {\n    if (ThreadPriorityVerbose) {\n      tty->print_cr (\"deferring the set_lwp_class_and_priority of thread \"\n                     INTPTR_FORMAT \" to %d, lwpid not set\",\n                     ThreadID, newPrio);\n    }\n    return 0;\n  }\n\n  if (ThreadPriorityVerbose) {\n    tty->print_cr (\"set_lwp_class_and_priority(\"\n                   INTPTR_FORMAT \"@\" INTPTR_FORMAT \" %d) \",\n                   ThreadID, lwpid, newPrio);\n  }\n\n  memset(&ParmInfo, 0, sizeof(pcparms_t));\n  ParmInfo.pc_cid = PC_CLNULL;\n  rslt = priocntl(P_LWPID, lwpid, PC_GETPARMS, (caddr_t)&ParmInfo);\n  if (rslt < 0) return errno;\n\n  int cur_class = ParmInfo.pc_cid;\n  ParmInfo.pc_cid = (id_t)new_class;\n\n  if (new_class == rtLimits.schedPolicy) {\n    rtparms_t *rtInfo  = (rtparms_t*)ParmInfo.pc_clparms;\n    rtInfo->rt_pri     = scale ? scale_to_lwp_priority(rtLimits.minPrio,\n                                                       rtLimits.maxPrio, newPrio)\n                               : newPrio;\n    rtInfo->rt_tqsecs  = RT_NOCHANGE;\n    rtInfo->rt_tqnsecs = RT_NOCHANGE;\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"RT: %d->%d\\n\", newPrio, rtInfo->rt_pri);\n    }\n  } else if (new_class == iaLimits.schedPolicy) {\n    iaparms_t* iaInfo  = (iaparms_t*)ParmInfo.pc_clparms;\n    int maxClamped     = MIN2(iaLimits.maxPrio,\n                              cur_class == new_class\n                                ? (int)iaInfo->ia_uprilim : iaLimits.maxPrio);\n    iaInfo->ia_upri    = scale ? scale_to_lwp_priority(iaLimits.minPrio,\n                                                       maxClamped, newPrio)\n                               : newPrio;\n    iaInfo->ia_uprilim = cur_class == new_class\n                           ? IA_NOCHANGE : (pri_t)iaLimits.maxPrio;\n    iaInfo->ia_mode    = IA_NOCHANGE;\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"IA: [%d...%d] %d->%d\\n\",\n                    iaLimits.minPrio, maxClamped, newPrio, iaInfo->ia_upri);\n    }\n  } else if (new_class == tsLimits.schedPolicy) {\n    tsparms_t* tsInfo  = (tsparms_t*)ParmInfo.pc_clparms;\n    int maxClamped     = MIN2(tsLimits.maxPrio,\n                              cur_class == new_class\n                                ? (int)tsInfo->ts_uprilim : tsLimits.maxPrio);\n    tsInfo->ts_upri    = scale ? scale_to_lwp_priority(tsLimits.minPrio,\n                                                       maxClamped, newPrio)\n                               : newPrio;\n    tsInfo->ts_uprilim = cur_class == new_class\n                           ? TS_NOCHANGE : (pri_t)tsLimits.maxPrio;\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"TS: [%d...%d] %d->%d\\n\",\n                    tsLimits.minPrio, maxClamped, newPrio, tsInfo->ts_upri);\n    }\n  } else if (new_class == fxLimits.schedPolicy) {\n    fxparms_t* fxInfo  = (fxparms_t*)ParmInfo.pc_clparms;\n    int maxClamped     = MIN2(fxLimits.maxPrio,\n                              cur_class == new_class\n                                ? (int)fxInfo->fx_uprilim : fxLimits.maxPrio);\n    fxInfo->fx_upri    = scale ? scale_to_lwp_priority(fxLimits.minPrio,\n                                                       maxClamped, newPrio)\n                               : newPrio;\n    fxInfo->fx_uprilim = cur_class == new_class\n                           ? FX_NOCHANGE : (pri_t)fxLimits.maxPrio;\n    fxInfo->fx_tqsecs  = FX_NOCHANGE;\n    fxInfo->fx_tqnsecs = FX_NOCHANGE;\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"FX: [%d...%d] %d->%d\\n\",\n                    fxLimits.minPrio, maxClamped, newPrio, fxInfo->fx_upri);\n    }\n  } else {\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"Unknown new scheduling class %d\\n\", new_class);\n    }\n    return EINVAL;    // no clue, punt\n  }\n\n  rslt = priocntl(P_LWPID, lwpid, PC_SETPARMS, (caddr_t)&ParmInfo);\n  if (ThreadPriorityVerbose && rslt) {\n    tty->print_cr (\"PC_SETPARMS ->%d %d\\n\", rslt, errno);\n  }\n  if (rslt < 0) return errno;\n\n#ifdef ASSERT\n  // Sanity check: read back what we just attempted to set.\n  // In theory it could have changed in the interim ...\n  //\n  // The priocntl system call is tricky.\n  // Sometimes it'll validate the priority value argument and\n  // return EINVAL if unhappy.  At other times it fails silently.\n  // Readbacks are prudent.\n\n  if (!ReadBackValidate) return 0;\n\n  memset(&ReadBack, 0, sizeof(pcparms_t));\n  ReadBack.pc_cid = PC_CLNULL;\n  rslt = priocntl(P_LWPID, lwpid, PC_GETPARMS, (caddr_t)&ReadBack);\n  assert(rslt >= 0, \"priocntl failed\");\n  Actual = Expected = 0xBAD;\n  assert(ParmInfo.pc_cid == ReadBack.pc_cid, \"cid's don't match\");\n  if (ParmInfo.pc_cid == rtLimits.schedPolicy) {\n    Actual   = RTPRI(ReadBack)->rt_pri;\n    Expected = RTPRI(ParmInfo)->rt_pri;\n  } else if (ParmInfo.pc_cid == iaLimits.schedPolicy) {\n    Actual   = IAPRI(ReadBack)->ia_upri;\n    Expected = IAPRI(ParmInfo)->ia_upri;\n  } else if (ParmInfo.pc_cid == tsLimits.schedPolicy) {\n    Actual   = TSPRI(ReadBack)->ts_upri;\n    Expected = TSPRI(ParmInfo)->ts_upri;\n  } else if (ParmInfo.pc_cid == fxLimits.schedPolicy) {\n    Actual   = FXPRI(ReadBack)->fx_upri;\n    Expected = FXPRI(ParmInfo)->fx_upri;\n  } else {\n    if (ThreadPriorityVerbose) {\n      tty->print_cr(\"set_lwp_class_and_priority: unexpected class in readback: %d\\n\",\n                    ParmInfo.pc_cid);\n    }\n  }\n\n  if (Actual != Expected) {\n    if (ThreadPriorityVerbose) {\n      tty->print_cr (\"set_lwp_class_and_priority(%d %d) Class=%d: actual=%d vs expected=%d\\n\",\n                     lwpid, newPrio, ReadBack.pc_cid, Actual, Expected);\n    }\n  }\n#endif\n\n  return 0;\n}\n\n// Solaris only gives access to 128 real priorities at a time,\n// so we expand Java's ten to fill this range.  This would be better\n// if we dynamically adjusted relative priorities.\n//\n// The ThreadPriorityPolicy option allows us to select 2 different\n// priority scales.\n//\n// ThreadPriorityPolicy=0\n// Since the Solaris' default priority is MaximumPriority, we do not\n// set a priority lower than Max unless a priority lower than\n// NormPriority is requested.\n//\n// ThreadPriorityPolicy=1\n// This mode causes the priority table to get filled with\n// linear values.  NormPriority get's mapped to 50% of the\n// Maximum priority an so on.  This will cause VM threads\n// to get unfair treatment against other Solaris processes\n// which do not explicitly alter their thread priorities.\n//\n\nint os::java_to_os_priority[CriticalPriority + 1] = {\n  -99999,         // 0 Entry should never be used\n\n  0,              // 1 MinPriority\n  32,             // 2\n  64,             // 3\n\n  96,             // 4\n  127,            // 5 NormPriority\n  127,            // 6\n\n  127,            // 7\n  127,            // 8\n  127,            // 9 NearMaxPriority\n\n  127,            // 10 MaxPriority\n\n  -criticalPrio   // 11 CriticalPriority\n};\n\nOSReturn os::set_native_priority(Thread* thread, int newpri) {\n  OSThread* osthread = thread->osthread();\n\n  // Save requested priority in case the thread hasn't been started\n  osthread->set_native_priority(newpri);\n\n  // Check for critical priority request\n  bool fxcritical = false;\n  if (newpri == -criticalPrio) {\n    fxcritical = true;\n    newpri = criticalPrio;\n  }\n\n  assert(newpri >= MinimumPriority && newpri <= MaximumPriority, \"bad priority mapping\");\n  if (!UseThreadPriorities) return OS_OK;\n\n  int status = 0;\n\n  if (!fxcritical) {\n    // Use thr_setprio only if we have a priority that thr_setprio understands\n    status = thr_setprio(thread->osthread()->thread_id(), newpri);\n  }\n\n  if (os::Solaris::T2_libthread() ||\n      (UseBoundThreads && osthread->is_vm_created())) {\n    int lwp_status =\n      set_lwp_class_and_priority(osthread->thread_id(),\n                                 osthread->lwp_id(),\n                                 newpri,\n                                 fxcritical ? fxLimits.schedPolicy : myClass,\n                                 !fxcritical);\n    if (lwp_status != 0 && fxcritical) {\n      // Try again, this time without changing the scheduling class\n      newpri = java_MaxPriority_to_os_priority;\n      lwp_status = set_lwp_class_and_priority(osthread->thread_id(),\n                                              osthread->lwp_id(),\n                                              newpri, myClass, false);\n    }\n    status |= lwp_status;\n  }\n  return (status == 0) ? OS_OK : OS_ERR;\n}\n\n\nOSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {\n  int p;\n  if ( !UseThreadPriorities ) {\n    *priority_ptr = NormalPriority;\n    return OS_OK;\n  }\n  int status = thr_getprio(thread->osthread()->thread_id(), &p);\n  if (status != 0) {\n    return OS_ERR;\n  }\n  *priority_ptr = p;\n  return OS_OK;\n}\n\n\n// Hint to the underlying OS that a task switch would not be good.\n// Void return because it's a hint and can fail.\nvoid os::hint_no_preempt() {\n  schedctl_start(schedctl_init());\n}\n\nstatic void resume_clear_context(OSThread *osthread) {\n  osthread->set_ucontext(NULL);\n}\n\nstatic void suspend_save_context(OSThread *osthread, ucontext_t* context) {\n  osthread->set_ucontext(context);\n}\n\nstatic Semaphore sr_semaphore;\n\nvoid os::Solaris::SR_handler(Thread* thread, ucontext_t* uc) {\n  // Save and restore errno to avoid confusing native code with EINTR\n  // after sigsuspend.\n  int old_errno = errno;\n\n  OSThread* osthread = thread->osthread();\n  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n\n  os::SuspendResume::State current = osthread->sr.state();\n  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n    suspend_save_context(osthread, uc);\n\n    // attempt to switch the state, we assume we had a SUSPEND_REQUEST\n    os::SuspendResume::State state = osthread->sr.suspended();\n    if (state == os::SuspendResume::SR_SUSPENDED) {\n      sigset_t suspend_set;  // signals for sigsuspend()\n\n      // get current set of blocked signals and unblock resume signal\n      thr_sigsetmask(SIG_BLOCK, NULL, &suspend_set);\n      sigdelset(&suspend_set, os::Solaris::SIGasync());\n\n      sr_semaphore.signal();\n      // wait here until we are resumed\n      while (1) {\n        sigsuspend(&suspend_set);\n\n        os::SuspendResume::State result = osthread->sr.running();\n        if (result == os::SuspendResume::SR_RUNNING) {\n          sr_semaphore.signal();\n          break;\n        }\n      }\n\n    } else if (state == os::SuspendResume::SR_RUNNING) {\n      // request was cancelled, continue\n    } else {\n      ShouldNotReachHere();\n    }\n\n    resume_clear_context(osthread);\n  } else if (current == os::SuspendResume::SR_RUNNING) {\n    // request was cancelled, continue\n  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // ignore\n  } else {\n    // ignore\n  }\n\n  errno = old_errno;\n}\n\n\nvoid os::interrupt(Thread* thread) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(), \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  int isInterrupted = osthread->interrupted();\n  if (!isInterrupted) {\n      osthread->set_interrupted(true);\n      OrderAccess::fence();\n      // os::sleep() is implemented with either poll (NULL,0,timeout) or\n      // by parking on _SleepEvent.  If the former, thr_kill will unwedge\n      // the sleeper by SIGINTR, otherwise the unpark() will wake the sleeper.\n      ParkEvent * const slp = thread->_SleepEvent ;\n      if (slp != NULL) slp->unpark() ;\n  }\n\n  // For JSR166:  unpark after setting status but before thr_kill -dl\n  if (thread->is_Java_thread()) {\n    ((JavaThread*)thread)->parker()->unpark();\n  }\n\n  // Handle interruptible wait() ...\n  ParkEvent * const ev = thread->_ParkEvent ;\n  if (ev != NULL) ev->unpark() ;\n\n  // When events are used everywhere for os::sleep, then this thr_kill\n  // will only be needed if UseVMInterruptibleIO is true.\n\n  if (!isInterrupted) {\n    int status = thr_kill(osthread->thread_id(), os::Solaris::SIGinterrupt());\n    assert_status(status == 0, status, \"thr_kill\");\n\n    // Bump thread interruption counter\n    RuntimeService::record_thread_interrupt_signaled_count();\n  }\n}\n\n\nbool os::is_interrupted(Thread* thread, bool clear_interrupted) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(), \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  bool res = osthread->interrupted();\n\n  // NOTE that since there is no \"lock\" around these two operations,\n  // there is the possibility that the interrupted flag will be\n  // \"false\" but that the interrupt event will be set. This is\n  // intentional. The effect of this is that Object.wait() will appear\n  // to have a spurious wakeup, which is not harmful, and the\n  // possibility is so rare that it is not worth the added complexity\n  // to add yet another lock. It has also been recommended not to put\n  // the interrupted flag into the os::Solaris::Event structure,\n  // because it hides the issue.\n  if (res && clear_interrupted) {\n    osthread->set_interrupted(false);\n  }\n  return res;\n}\n\n\nvoid os::print_statistics() {\n}\n\nint os::message_box(const char* title, const char* message) {\n  int i;\n  fdStream err(defaultStream::error_fd());\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n  err.print_raw_cr(title);\n  for (i = 0; i < 78; i++) err.print_raw(\"-\");\n  err.cr();\n  err.print_raw_cr(message);\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n\n  char buf[16];\n  // Prevent process from exiting upon \"read error\" without consuming all CPU\n  while (::read(0, buf, sizeof(buf)) <= 0) { ::sleep(100); }\n\n  return buf[0] == 'y' || buf[0] == 'Y';\n}\n\nstatic int sr_notify(OSThread* osthread) {\n  int status = thr_kill(osthread->thread_id(), os::Solaris::SIGasync());\n  assert_status(status == 0, status, \"thr_kill\");\n  return status;\n}\n\n// \"Randomly\" selected value for how long we want to spin\n// before bailing out on suspending a thread, also how often\n// we send a signal to a thread we want to resume\nstatic const int RANDOMLY_LARGE_INTEGER = 1000000;\nstatic const int RANDOMLY_LARGE_INTEGER2 = 100;\n\nstatic bool do_suspend(OSThread* osthread) {\n  assert(osthread->sr.is_running(), \"thread should be running\");\n  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n\n  // mark as suspended and send signal\n  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n    // failed to switch, state wasn't running?\n    ShouldNotReachHere();\n    return false;\n  }\n\n  if (sr_notify(osthread) != 0) {\n    ShouldNotReachHere();\n  }\n\n  // managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n  while (true) {\n    if (sr_semaphore.timedwait(0, 2000 * NANOSECS_PER_MILLISEC)) {\n      break;\n    } else {\n      // timeout\n      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n      if (cancelled == os::SuspendResume::SR_RUNNING) {\n        return false;\n      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n        // make sure that we consume the signal on the semaphore as well\n        sr_semaphore.wait();\n        break;\n      } else {\n        ShouldNotReachHere();\n        return false;\n      }\n    }\n  }\n\n  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n  return true;\n}\n\nstatic void do_resume(OSThread* osthread) {\n  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n\n  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // failed to switch to WAKEUP_REQUEST\n    ShouldNotReachHere();\n    return;\n  }\n\n  while (true) {\n    if (sr_notify(osthread) == 0) {\n      if (sr_semaphore.timedwait(0, 2 * NANOSECS_PER_MILLISEC)) {\n        if (osthread->sr.is_running()) {\n          return;\n        }\n      }\n    } else {\n      ShouldNotReachHere();\n    }\n  }\n\n  guarantee(osthread->sr.is_running(), \"Must be running!\");\n}\n\nvoid os::SuspendedThreadTask::internal_do_task() {\n  if (do_suspend(_thread->osthread())) {\n    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n    do_task(context);\n    do_resume(_thread->osthread());\n  }\n}\n\nclass PcFetcher : public os::SuspendedThreadTask {\npublic:\n  PcFetcher(Thread* thread) : os::SuspendedThreadTask(thread) {}\n  ExtendedPC result();\nprotected:\n  void do_task(const os::SuspendedThreadTaskContext& context);\nprivate:\n  ExtendedPC _epc;\n};\n\nExtendedPC PcFetcher::result() {\n  guarantee(is_done(), \"task is not done yet.\");\n  return _epc;\n}\n\nvoid PcFetcher::do_task(const os::SuspendedThreadTaskContext& context) {\n  Thread* thread = context.thread();\n  OSThread* osthread = thread->osthread();\n  if (osthread->ucontext() != NULL) {\n    _epc = os::Solaris::ucontext_get_pc((ucontext_t *) context.ucontext());\n  } else {\n    // NULL context is unexpected, double-check this is the VMThread\n    guarantee(thread->is_VM_thread(), \"can only be called for VMThread\");\n  }\n}\n\n// A lightweight implementation that does not suspend the target thread and\n// thus returns only a hint. Used for profiling only!\nExtendedPC os::get_thread_pc(Thread* thread) {\n  // Make sure that it is called by the watcher and the Threads lock is owned.\n  assert(Thread::current()->is_Watcher_thread(), \"Must be watcher and own Threads_lock\");\n  // For now, is only used to profile the VM Thread\n  assert(thread->is_VM_thread(), \"Can only be called for VMThread\");\n  PcFetcher fetcher(thread);\n  fetcher.run();\n  return fetcher.result();\n}\n\n\n// This does not do anything on Solaris. This is basically a hook for being\n// able to use structured exception handling (thread-local exception filters) on, e.g., Win32.\nvoid os::os_exception_wrapper(java_call_t f, JavaValue* value, methodHandle* method, JavaCallArguments* args, Thread* thread) {\n  f(value, method, args, thread);\n}\n\n// This routine may be used by user applications as a \"hook\" to catch signals.\n// The user-defined signal handler must pass unrecognized signals to this\n// routine, and if it returns true (non-zero), then the signal handler must\n// return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n// routine will never retun false (zero), but instead will execute a VM panic\n// routine kill the process.\n//\n// If this routine returns false, it is OK to call it again.  This allows\n// the user-defined signal handler to perform checks either before or after\n// the VM performs its own checks.  Naturally, the user code would be making\n// a serious error if it tried to handle an exception (such as a null check\n// or breakpoint) that the VM was generating for its own correct operation.\n//\n// This routine may recognize any of the following kinds of signals:\n// SIGBUS, SIGSEGV, SIGILL, SIGFPE, BREAK_SIGNAL, SIGPIPE, SIGXFSZ,\n// os::Solaris::SIGasync\n// It should be consulted by handlers for any of those signals.\n// It explicitly does not recognize os::Solaris::SIGinterrupt\n//\n// The caller of this routine must pass in the three arguments supplied\n// to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n// field of the structure passed to sigaction().  This routine assumes that\n// the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n//\n// Note that the VM will print warnings if it detects conflicting signal\n// handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n//\nextern \"C\" JNIEXPORT int\nJVM_handle_solaris_signal(int signo, siginfo_t* siginfo, void* ucontext,\n                          int abort_if_unrecognized);\n\n\nvoid signalHandler(int sig, siginfo_t* info, void* ucVoid) {\n  int orig_errno = errno;  // Preserve errno value over signal handler.\n  JVM_handle_solaris_signal(sig, info, ucVoid, true);\n  errno = orig_errno;\n}\n\n/* Do not delete - if guarantee is ever removed,  a signal handler (even empty)\n   is needed to provoke threads blocked on IO to return an EINTR\n   Note: this explicitly does NOT call JVM_handle_solaris_signal and\n   does NOT participate in signal chaining due to requirement for\n   NOT setting SA_RESTART to make EINTR work. */\nextern \"C\" void sigINTRHandler(int sig, siginfo_t* info, void* ucVoid) {\n   if (UseSignalChaining) {\n      struct sigaction *actp = os::Solaris::get_chained_signal_action(sig);\n      if (actp && actp->sa_handler) {\n        vm_exit_during_initialization(\"Signal chaining detected for VM interrupt signal, try -XX:+UseAltSigs\");\n      }\n   }\n}\n\n// This boolean allows users to forward their own non-matching signals\n// to JVM_handle_solaris_signal, harmlessly.\nbool os::Solaris::signal_handlers_are_installed = false;\n\n// For signal-chaining\nbool os::Solaris::libjsig_is_loaded = false;\ntypedef struct sigaction *(*get_signal_t)(int);\nget_signal_t os::Solaris::get_signal_action = NULL;\n\nstruct sigaction* os::Solaris::get_chained_signal_action(int sig) {\n  struct sigaction *actp = NULL;\n\n  if ((libjsig_is_loaded)  && (sig <= Maxlibjsigsigs)) {\n    // Retrieve the old signal handler from libjsig\n    actp = (*get_signal_action)(sig);\n  }\n  if (actp == NULL) {\n    // Retrieve the preinstalled signal handler from jvm\n    actp = get_preinstalled_handler(sig);\n  }\n\n  return actp;\n}\n\nstatic bool call_chained_handler(struct sigaction *actp, int sig,\n                                 siginfo_t *siginfo, void *context) {\n  // Call the old signal handler\n  if (actp->sa_handler == SIG_DFL) {\n    // It's more reasonable to let jvm treat it as an unexpected exception\n    // instead of taking the default action.\n    return false;\n  } else if (actp->sa_handler != SIG_IGN) {\n    if ((actp->sa_flags & SA_NODEFER) == 0) {\n      // automaticlly block the signal\n      sigaddset(&(actp->sa_mask), sig);\n    }\n\n    sa_handler_t hand;\n    sa_sigaction_t sa;\n    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n    // retrieve the chained handler\n    if (siginfo_flag_set) {\n      sa = actp->sa_sigaction;\n    } else {\n      hand = actp->sa_handler;\n    }\n\n    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n      actp->sa_handler = SIG_DFL;\n    }\n\n    // try to honor the signal mask\n    sigset_t oset;\n    thr_sigsetmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n\n    // call into the chained handler\n    if (siginfo_flag_set) {\n      (*sa)(sig, siginfo, context);\n    } else {\n      (*hand)(sig);\n    }\n\n    // restore the signal mask\n    thr_sigsetmask(SIG_SETMASK, &oset, 0);\n  }\n  // Tell jvm's signal handler the signal is taken care of.\n  return true;\n}\n\nbool os::Solaris::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n  bool chained = false;\n  // signal-chaining\n  if (UseSignalChaining) {\n    struct sigaction *actp = get_chained_signal_action(sig);\n    if (actp != NULL) {\n      chained = call_chained_handler(actp, sig, siginfo, context);\n    }\n  }\n  return chained;\n}\n\nstruct sigaction* os::Solaris::get_preinstalled_handler(int sig) {\n  assert((chainedsigactions != (struct sigaction *)NULL) && (preinstalled_sigs != (int *)NULL) , \"signals not yet initialized\");\n  if (preinstalled_sigs[sig] != 0) {\n    return &chainedsigactions[sig];\n  }\n  return NULL;\n}\n\nvoid os::Solaris::save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n\n  assert(sig > 0 && sig <= Maxsignum, \"vm signal out of expected range\");\n  assert((chainedsigactions != (struct sigaction *)NULL) && (preinstalled_sigs != (int *)NULL) , \"signals not yet initialized\");\n  chainedsigactions[sig] = oldAct;\n  preinstalled_sigs[sig] = 1;\n}\n\nvoid os::Solaris::set_signal_handler(int sig, bool set_installed, bool oktochain) {\n  // Check for overwrite.\n  struct sigaction oldAct;\n  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n  void* oldhand = oldAct.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n                                      : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n      oldhand != CAST_FROM_FN_PTR(void*, signalHandler)) {\n    if (AllowUserSignalHandlers || !set_installed) {\n      // Do not overwrite; user takes responsibility to forward to us.\n      return;\n    } else if (UseSignalChaining) {\n      if (oktochain) {\n        // save the old handler in jvm\n        save_preinstalled_handler(sig, oldAct);\n      } else {\n        vm_exit_during_initialization(\"Signal chaining not allowed for VM interrupt signal, try -XX:+UseAltSigs.\");\n      }\n      // libjsig also interposes the sigaction() call below and saves the\n      // old sigaction on it own.\n    } else {\n      fatal(err_msg(\"Encountered unexpected pre-existing sigaction handler \"\n                    \"%#lx for signal %d.\", (long)oldhand, sig));\n    }\n  }\n\n  struct sigaction sigAct;\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_handler = SIG_DFL;\n\n  sigAct.sa_sigaction = signalHandler;\n  // Handle SIGSEGV on alternate signal stack if\n  // not using stack banging\n  if (!UseStackBanging && sig == SIGSEGV) {\n    sigAct.sa_flags = SA_SIGINFO | SA_RESTART | SA_ONSTACK;\n  // Interruptible i/o requires SA_RESTART cleared so EINTR\n  // is returned instead of restarting system calls\n  } else if (sig == os::Solaris::SIGinterrupt()) {\n    sigemptyset(&sigAct.sa_mask);\n    sigAct.sa_handler = NULL;\n    sigAct.sa_flags = SA_SIGINFO;\n    sigAct.sa_sigaction = sigINTRHandler;\n  } else {\n    sigAct.sa_flags = SA_SIGINFO | SA_RESTART;\n  }\n  os::Solaris::set_our_sigflags(sig, sigAct.sa_flags);\n\n  sigaction(sig, &sigAct, &oldAct);\n\n  void* oldhand2 = oldAct.sa_sigaction ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n                                       : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n}\n\n\n#define DO_SIGNAL_CHECK(sig) \\\n  if (!sigismember(&check_signal_done, sig)) \\\n    os::Solaris::check_signal_handler(sig)\n\n// This method is a periodic task to check for misbehaving JNI applications\n// under CheckJNI, we can add any periodic checks here\n\nvoid os::run_periodic_checks() {\n  // A big source of grief is hijacking virt. addr 0x0 on Solaris,\n  // thereby preventing a NULL checks.\n  if(!check_addr0_done) check_addr0_done = check_addr0(tty);\n\n  if (check_signals == false) return;\n\n  // SEGV and BUS if overridden could potentially prevent\n  // generation of hs*.log in the event of a crash, debugging\n  // such a case can be very challenging, so we absolutely\n  // check for the following for a good measure:\n  DO_SIGNAL_CHECK(SIGSEGV);\n  DO_SIGNAL_CHECK(SIGILL);\n  DO_SIGNAL_CHECK(SIGFPE);\n  DO_SIGNAL_CHECK(SIGBUS);\n  DO_SIGNAL_CHECK(SIGPIPE);\n  DO_SIGNAL_CHECK(SIGXFSZ);\n\n  // ReduceSignalUsage allows the user to override these handlers\n  // see comments at the very top and jvm_solaris.h\n  if (!ReduceSignalUsage) {\n    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n  }\n\n  // See comments above for using JVM1/JVM2 and UseAltSigs\n  DO_SIGNAL_CHECK(os::Solaris::SIGinterrupt());\n  DO_SIGNAL_CHECK(os::Solaris::SIGasync());\n\n}\n\ntypedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic os_sigaction_t os_sigaction = NULL;\n\nvoid os::Solaris::check_signal_handler(int sig) {\n  char buf[O_BUFLEN];\n  address jvmHandler = NULL;\n\n  struct sigaction act;\n  if (os_sigaction == NULL) {\n    // only trust the default sigaction, in case it has been interposed\n    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n    if (os_sigaction == NULL) return;\n  }\n\n  os_sigaction(sig, (struct sigaction*)NULL, &act);\n\n  address thisHandler = (act.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, act.sa_handler) ;\n\n\n  switch(sig) {\n    case SIGSEGV:\n    case SIGBUS:\n    case SIGFPE:\n    case SIGPIPE:\n    case SIGXFSZ:\n    case SIGILL:\n      jvmHandler = CAST_FROM_FN_PTR(address, signalHandler);\n      break;\n\n    case SHUTDOWN1_SIGNAL:\n    case SHUTDOWN2_SIGNAL:\n    case SHUTDOWN3_SIGNAL:\n    case BREAK_SIGNAL:\n      jvmHandler = (address)user_handler();\n      break;\n\n    default:\n      int intrsig = os::Solaris::SIGinterrupt();\n      int asynsig = os::Solaris::SIGasync();\n\n      if (sig == intrsig) {\n        jvmHandler = CAST_FROM_FN_PTR(address, sigINTRHandler);\n      } else if (sig == asynsig) {\n        jvmHandler = CAST_FROM_FN_PTR(address, signalHandler);\n      } else {\n        return;\n      }\n      break;\n  }\n\n\n  if (thisHandler != jvmHandler) {\n    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n    // Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n                    exception_name(sig, buf, O_BUFLEN));\n    }\n  } else if(os::Solaris::get_our_sigflags(sig) != 0 && act.sa_flags != os::Solaris::get_our_sigflags(sig)) {\n    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:\" PTR32_FORMAT, os::Solaris::get_our_sigflags(sig));\n    tty->print_cr(\"  found:\" PTR32_FORMAT, act.sa_flags);\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n  }\n\n  // Print all the signal handler state\n  if (sigismember(&check_signal_done, sig)) {\n    print_signal_handlers(tty, buf, O_BUFLEN);\n  }\n\n}\n\nvoid os::Solaris::install_signal_handlers() {\n  bool libjsigdone = false;\n  signal_handlers_are_installed = true;\n\n  // signal-chaining\n  typedef void (*signal_setting_t)();\n  signal_setting_t begin_signal_setting = NULL;\n  signal_setting_t end_signal_setting = NULL;\n  begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                                        dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n  if (begin_signal_setting != NULL) {\n    end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                                        dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n    get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n                                       dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n    get_libjsig_version = CAST_TO_FN_PTR(version_getting_t,\n                                         dlsym(RTLD_DEFAULT, \"JVM_get_libjsig_version\"));\n    libjsig_is_loaded = true;\n    if (os::Solaris::get_libjsig_version != NULL) {\n      libjsigversion =  (*os::Solaris::get_libjsig_version)();\n    }\n    assert(UseSignalChaining, \"should enable signal-chaining\");\n  }\n  if (libjsig_is_loaded) {\n    // Tell libjsig jvm is setting signal handlers\n    (*begin_signal_setting)();\n  }\n\n  set_signal_handler(SIGSEGV, true, true);\n  set_signal_handler(SIGPIPE, true, true);\n  set_signal_handler(SIGXFSZ, true, true);\n  set_signal_handler(SIGBUS, true, true);\n  set_signal_handler(SIGILL, true, true);\n  set_signal_handler(SIGFPE, true, true);\n\n\n  if (os::Solaris::SIGinterrupt() > OLDMAXSIGNUM || os::Solaris::SIGasync() > OLDMAXSIGNUM) {\n\n    // Pre-1.4.1 Libjsig limited to signal chaining signals <= 32 so\n    // can not register overridable signals which might be > 32\n    if (libjsig_is_loaded && libjsigversion <= JSIG_VERSION_1_4_1) {\n    // Tell libjsig jvm has finished setting signal handlers\n      (*end_signal_setting)();\n      libjsigdone = true;\n    }\n  }\n\n  // Never ok to chain our SIGinterrupt\n  set_signal_handler(os::Solaris::SIGinterrupt(), true, false);\n  set_signal_handler(os::Solaris::SIGasync(), true, true);\n\n  if (libjsig_is_loaded && !libjsigdone) {\n    // Tell libjsig jvm finishes setting signal handlers\n    (*end_signal_setting)();\n  }\n\n  // We don't activate signal checker if libjsig is in place, we trust ourselves\n  // and if UserSignalHandler is installed all bets are off.\n  // Log that signal checking is off only if -verbose:jni is specified.\n  if (CheckJNICalls) {\n    if (libjsig_is_loaded) {\n      if (PrintJNIResolving) {\n        tty->print_cr(\"Info: libjsig is activated, all active signal checking is disabled\");\n      }\n      check_signals = false;\n    }\n    if (AllowUserSignalHandlers) {\n      if (PrintJNIResolving) {\n        tty->print_cr(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n      }\n      check_signals = false;\n    }\n  }\n}\n\n\nvoid report_error(const char* file_name, int line_no, const char* title, const char* format, ...);\n\nconst char * signames[] = {\n  \"SIG0\",\n  \"SIGHUP\", \"SIGINT\", \"SIGQUIT\", \"SIGILL\", \"SIGTRAP\",\n  \"SIGABRT\", \"SIGEMT\", \"SIGFPE\", \"SIGKILL\", \"SIGBUS\",\n  \"SIGSEGV\", \"SIGSYS\", \"SIGPIPE\", \"SIGALRM\", \"SIGTERM\",\n  \"SIGUSR1\", \"SIGUSR2\", \"SIGCLD\", \"SIGPWR\", \"SIGWINCH\",\n  \"SIGURG\", \"SIGPOLL\", \"SIGSTOP\", \"SIGTSTP\", \"SIGCONT\",\n  \"SIGTTIN\", \"SIGTTOU\", \"SIGVTALRM\", \"SIGPROF\", \"SIGXCPU\",\n  \"SIGXFSZ\", \"SIGWAITING\", \"SIGLWP\", \"SIGFREEZE\", \"SIGTHAW\",\n  \"SIGCANCEL\", \"SIGLOST\"\n};\n\nconst char* os::exception_name(int exception_code, char* buf, size_t size) {\n  if (0 < exception_code && exception_code <= SIGRTMAX) {\n    // signal\n    if (exception_code < sizeof(signames)/sizeof(const char*)) {\n       jio_snprintf(buf, size, \"%s\", signames[exception_code]);\n    } else {\n       jio_snprintf(buf, size, \"SIG%d\", exception_code);\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\n// (Static) wrappers for the new libthread API\nint_fnP_thread_t_iP_uP_stack_tP_gregset_t os::Solaris::_thr_getstate;\nint_fnP_thread_t_i_gregset_t os::Solaris::_thr_setstate;\nint_fnP_thread_t_i os::Solaris::_thr_setmutator;\nint_fnP_thread_t os::Solaris::_thr_suspend_mutator;\nint_fnP_thread_t os::Solaris::_thr_continue_mutator;\n\n// (Static) wrapper for getisax(2) call.\nos::Solaris::getisax_func_t os::Solaris::_getisax = 0;\n\n// (Static) wrappers for the liblgrp API\nos::Solaris::lgrp_home_func_t os::Solaris::_lgrp_home;\nos::Solaris::lgrp_init_func_t os::Solaris::_lgrp_init;\nos::Solaris::lgrp_fini_func_t os::Solaris::_lgrp_fini;\nos::Solaris::lgrp_root_func_t os::Solaris::_lgrp_root;\nos::Solaris::lgrp_children_func_t os::Solaris::_lgrp_children;\nos::Solaris::lgrp_resources_func_t os::Solaris::_lgrp_resources;\nos::Solaris::lgrp_nlgrps_func_t os::Solaris::_lgrp_nlgrps;\nos::Solaris::lgrp_cookie_stale_func_t os::Solaris::_lgrp_cookie_stale;\nos::Solaris::lgrp_cookie_t os::Solaris::_lgrp_cookie = 0;\n\n// (Static) wrapper for meminfo() call.\nos::Solaris::meminfo_func_t os::Solaris::_meminfo = 0;\n\nstatic address resolve_symbol_lazy(const char* name) {\n  address addr = (address) dlsym(RTLD_DEFAULT, name);\n  if(addr == NULL) {\n    // RTLD_DEFAULT was not defined on some early versions of 2.5.1\n    addr = (address) dlsym(RTLD_NEXT, name);\n  }\n  return addr;\n}\n\nstatic address resolve_symbol(const char* name) {\n  address addr = resolve_symbol_lazy(name);\n  if(addr == NULL) {\n    fatal(dlerror());\n  }\n  return addr;\n}\n\n\n\n// isT2_libthread()\n//\n// Routine to determine if we are currently using the new T2 libthread.\n//\n// We determine if we are using T2 by reading /proc/self/lstatus and\n// looking for a thread with the ASLWP bit set.  If we find this status\n// bit set, we must assume that we are NOT using T2.  The T2 team\n// has approved this algorithm.\n//\n// We need to determine if we are running with the new T2 libthread\n// since setting native thread priorities is handled differently\n// when using this library.  All threads created using T2 are bound\n// threads. Calling thr_setprio is meaningless in this case.\n//\nbool isT2_libthread() {\n  static prheader_t * lwpArray = NULL;\n  static int lwpSize = 0;\n  static int lwpFile = -1;\n  lwpstatus_t * that;\n  char lwpName [128];\n  bool isT2 = false;\n\n#define ADR(x)  ((uintptr_t)(x))\n#define LWPINDEX(ary,ix)   ((lwpstatus_t *)(((ary)->pr_entsize * (ix)) + (ADR((ary) + 1))))\n\n  lwpFile = ::open(\"/proc/self/lstatus\", O_RDONLY, 0);\n  if (lwpFile < 0) {\n      if (ThreadPriorityVerbose) warning (\"Couldn't open /proc/self/lstatus\\n\");\n      return false;\n  }\n  lwpSize = 16*1024;\n  for (;;) {\n    ::lseek64 (lwpFile, 0, SEEK_SET);\n    lwpArray = (prheader_t *)NEW_C_HEAP_ARRAY(char, lwpSize, mtInternal);\n    if (::read(lwpFile, lwpArray, lwpSize) < 0) {\n      if (ThreadPriorityVerbose) warning(\"Error reading /proc/self/lstatus\\n\");\n      break;\n    }\n    if ((lwpArray->pr_nent * lwpArray->pr_entsize) <= lwpSize) {\n       // We got a good snapshot - now iterate over the list.\n      int aslwpcount = 0;\n      for (int i = 0; i < lwpArray->pr_nent; i++ ) {\n        that = LWPINDEX(lwpArray,i);\n        if (that->pr_flags & PR_ASLWP) {\n          aslwpcount++;\n        }\n      }\n      if (aslwpcount == 0) isT2 = true;\n      break;\n    }\n    lwpSize = lwpArray->pr_nent * lwpArray->pr_entsize;\n    FREE_C_HEAP_ARRAY(char, lwpArray, mtInternal);  // retry.\n  }\n\n  FREE_C_HEAP_ARRAY(char, lwpArray, mtInternal);\n  ::close (lwpFile);\n  if (ThreadPriorityVerbose) {\n    if (isT2) tty->print_cr(\"We are running with a T2 libthread\\n\");\n    else tty->print_cr(\"We are not running with a T2 libthread\\n\");\n  }\n  return isT2;\n}\n\n\nvoid os::Solaris::libthread_init() {\n  address func = (address)dlsym(RTLD_DEFAULT, \"_thr_suspend_allmutators\");\n\n  // Determine if we are running with the new T2 libthread\n  os::Solaris::set_T2_libthread(isT2_libthread());\n\n  lwp_priocntl_init();\n\n  // RTLD_DEFAULT was not defined on some early versions of 5.5.1\n  if(func == NULL) {\n    func = (address) dlsym(RTLD_NEXT, \"_thr_suspend_allmutators\");\n    // Guarantee that this VM is running on an new enough OS (5.6 or\n    // later) that it will have a new enough libthread.so.\n    guarantee(func != NULL, \"libthread.so is too old.\");\n  }\n\n  // Initialize the new libthread getstate API wrappers\n  func = resolve_symbol(\"thr_getstate\");\n  os::Solaris::set_thr_getstate(CAST_TO_FN_PTR(int_fnP_thread_t_iP_uP_stack_tP_gregset_t, func));\n\n  func = resolve_symbol(\"thr_setstate\");\n  os::Solaris::set_thr_setstate(CAST_TO_FN_PTR(int_fnP_thread_t_i_gregset_t, func));\n\n  func = resolve_symbol(\"thr_setmutator\");\n  os::Solaris::set_thr_setmutator(CAST_TO_FN_PTR(int_fnP_thread_t_i, func));\n\n  func = resolve_symbol(\"thr_suspend_mutator\");\n  os::Solaris::set_thr_suspend_mutator(CAST_TO_FN_PTR(int_fnP_thread_t, func));\n\n  func = resolve_symbol(\"thr_continue_mutator\");\n  os::Solaris::set_thr_continue_mutator(CAST_TO_FN_PTR(int_fnP_thread_t, func));\n\n  int size;\n  void (*handler_info_func)(address *, int *);\n  handler_info_func = CAST_TO_FN_PTR(void (*)(address *, int *), resolve_symbol(\"thr_sighndlrinfo\"));\n  handler_info_func(&handler_start, &size);\n  handler_end = handler_start + size;\n}\n\n\nint_fnP_mutex_tP os::Solaris::_mutex_lock;\nint_fnP_mutex_tP os::Solaris::_mutex_trylock;\nint_fnP_mutex_tP os::Solaris::_mutex_unlock;\nint_fnP_mutex_tP_i_vP os::Solaris::_mutex_init;\nint_fnP_mutex_tP os::Solaris::_mutex_destroy;\nint os::Solaris::_mutex_scope = USYNC_THREAD;\n\nint_fnP_cond_tP_mutex_tP_timestruc_tP os::Solaris::_cond_timedwait;\nint_fnP_cond_tP_mutex_tP os::Solaris::_cond_wait;\nint_fnP_cond_tP os::Solaris::_cond_signal;\nint_fnP_cond_tP os::Solaris::_cond_broadcast;\nint_fnP_cond_tP_i_vP os::Solaris::_cond_init;\nint_fnP_cond_tP os::Solaris::_cond_destroy;\nint os::Solaris::_cond_scope = USYNC_THREAD;\n\nvoid os::Solaris::synchronization_init() {\n  if(UseLWPSynchronization) {\n    os::Solaris::set_mutex_lock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"_lwp_mutex_lock\")));\n    os::Solaris::set_mutex_trylock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"_lwp_mutex_trylock\")));\n    os::Solaris::set_mutex_unlock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"_lwp_mutex_unlock\")));\n    os::Solaris::set_mutex_init(lwp_mutex_init);\n    os::Solaris::set_mutex_destroy(lwp_mutex_destroy);\n    os::Solaris::set_mutex_scope(USYNC_THREAD);\n\n    os::Solaris::set_cond_timedwait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP_timestruc_tP, resolve_symbol(\"_lwp_cond_timedwait\")));\n    os::Solaris::set_cond_wait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP, resolve_symbol(\"_lwp_cond_wait\")));\n    os::Solaris::set_cond_signal(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"_lwp_cond_signal\")));\n    os::Solaris::set_cond_broadcast(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"_lwp_cond_broadcast\")));\n    os::Solaris::set_cond_init(lwp_cond_init);\n    os::Solaris::set_cond_destroy(lwp_cond_destroy);\n    os::Solaris::set_cond_scope(USYNC_THREAD);\n  }\n  else {\n    os::Solaris::set_mutex_scope(USYNC_THREAD);\n    os::Solaris::set_cond_scope(USYNC_THREAD);\n\n    if(UsePthreads) {\n      os::Solaris::set_mutex_lock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"pthread_mutex_lock\")));\n      os::Solaris::set_mutex_trylock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"pthread_mutex_trylock\")));\n      os::Solaris::set_mutex_unlock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"pthread_mutex_unlock\")));\n      os::Solaris::set_mutex_init(pthread_mutex_default_init);\n      os::Solaris::set_mutex_destroy(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"pthread_mutex_destroy\")));\n\n      os::Solaris::set_cond_timedwait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP_timestruc_tP, resolve_symbol(\"pthread_cond_timedwait\")));\n      os::Solaris::set_cond_wait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP, resolve_symbol(\"pthread_cond_wait\")));\n      os::Solaris::set_cond_signal(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"pthread_cond_signal\")));\n      os::Solaris::set_cond_broadcast(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"pthread_cond_broadcast\")));\n      os::Solaris::set_cond_init(pthread_cond_default_init);\n      os::Solaris::set_cond_destroy(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"pthread_cond_destroy\")));\n    }\n    else {\n      os::Solaris::set_mutex_lock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"mutex_lock\")));\n      os::Solaris::set_mutex_trylock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"mutex_trylock\")));\n      os::Solaris::set_mutex_unlock(CAST_TO_FN_PTR(int_fnP_mutex_tP, resolve_symbol(\"mutex_unlock\")));\n      os::Solaris::set_mutex_init(::mutex_init);\n      os::Solaris::set_mutex_destroy(::mutex_destroy);\n\n      os::Solaris::set_cond_timedwait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP_timestruc_tP, resolve_symbol(\"cond_timedwait\")));\n      os::Solaris::set_cond_wait(CAST_TO_FN_PTR(int_fnP_cond_tP_mutex_tP, resolve_symbol(\"cond_wait\")));\n      os::Solaris::set_cond_signal(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"cond_signal\")));\n      os::Solaris::set_cond_broadcast(CAST_TO_FN_PTR(int_fnP_cond_tP, resolve_symbol(\"cond_broadcast\")));\n      os::Solaris::set_cond_init(::cond_init);\n      os::Solaris::set_cond_destroy(::cond_destroy);\n    }\n  }\n}\n\nbool os::Solaris::liblgrp_init() {\n  void *handle = dlopen(\"liblgrp.so.1\", RTLD_LAZY);\n  if (handle != NULL) {\n    os::Solaris::set_lgrp_home(CAST_TO_FN_PTR(lgrp_home_func_t, dlsym(handle, \"lgrp_home\")));\n    os::Solaris::set_lgrp_init(CAST_TO_FN_PTR(lgrp_init_func_t, dlsym(handle, \"lgrp_init\")));\n    os::Solaris::set_lgrp_fini(CAST_TO_FN_PTR(lgrp_fini_func_t, dlsym(handle, \"lgrp_fini\")));\n    os::Solaris::set_lgrp_root(CAST_TO_FN_PTR(lgrp_root_func_t, dlsym(handle, \"lgrp_root\")));\n    os::Solaris::set_lgrp_children(CAST_TO_FN_PTR(lgrp_children_func_t, dlsym(handle, \"lgrp_children\")));\n    os::Solaris::set_lgrp_resources(CAST_TO_FN_PTR(lgrp_resources_func_t, dlsym(handle, \"lgrp_resources\")));\n    os::Solaris::set_lgrp_nlgrps(CAST_TO_FN_PTR(lgrp_nlgrps_func_t, dlsym(handle, \"lgrp_nlgrps\")));\n    os::Solaris::set_lgrp_cookie_stale(CAST_TO_FN_PTR(lgrp_cookie_stale_func_t,\n                                       dlsym(handle, \"lgrp_cookie_stale\")));\n\n    lgrp_cookie_t c = lgrp_init(LGRP_VIEW_CALLER);\n    set_lgrp_cookie(c);\n    return true;\n  }\n  return false;\n}\n\nvoid os::Solaris::misc_sym_init() {\n  address func;\n\n  // getisax\n  func = resolve_symbol_lazy(\"getisax\");\n  if (func != NULL) {\n    os::Solaris::_getisax = CAST_TO_FN_PTR(getisax_func_t, func);\n  }\n\n  // meminfo\n  func = resolve_symbol_lazy(\"meminfo\");\n  if (func != NULL) {\n    os::Solaris::set_meminfo(CAST_TO_FN_PTR(meminfo_func_t, func));\n  }\n}\n\nuint_t os::Solaris::getisax(uint32_t* array, uint_t n) {\n  assert(_getisax != NULL, \"_getisax not set\");\n  return _getisax(array, n);\n}\n\n// int pset_getloadavg(psetid_t pset, double loadavg[], int nelem);\ntypedef long (*pset_getloadavg_type)(psetid_t pset, double loadavg[], int nelem);\nstatic pset_getloadavg_type pset_getloadavg_ptr = NULL;\n\nvoid init_pset_getloadavg_ptr(void) {\n  pset_getloadavg_ptr =\n    (pset_getloadavg_type)dlsym(RTLD_DEFAULT, \"pset_getloadavg\");\n  if (PrintMiscellaneous && Verbose && pset_getloadavg_ptr == NULL) {\n    warning(\"pset_getloadavg function not found\");\n  }\n}\n\nint os::Solaris::_dev_zero_fd = -1;\n\n// this is called _before_ the global arguments have been parsed\nvoid os::init(void) {\n  _initial_pid = getpid();\n\n  max_hrtime = first_hrtime = gethrtime();\n\n  init_random(1234567);\n\n  page_size = sysconf(_SC_PAGESIZE);\n  if (page_size == -1)\n    fatal(err_msg(\"os_solaris.cpp: os::init: sysconf failed (%s)\",\n                  strerror(errno)));\n  init_page_sizes((size_t) page_size);\n\n  Solaris::initialize_system_info();\n\n  // Initialize misc. symbols as soon as possible, so we can use them\n  // if we need them.\n  Solaris::misc_sym_init();\n\n  int fd = ::open(\"/dev/zero\", O_RDWR);\n  if (fd < 0) {\n    fatal(err_msg(\"os::init: cannot open /dev/zero (%s)\", strerror(errno)));\n  } else {\n    Solaris::set_dev_zero_fd(fd);\n\n    // Close on exec, child won't inherit.\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n  }\n\n  clock_tics_per_sec = CLK_TCK;\n\n  // check if dladdr1() exists; dladdr1 can provide more information than\n  // dladdr for os::dll_address_to_function_name. It comes with SunOS 5.9\n  // and is available on linker patches for 5.7 and 5.8.\n  // libdl.so must have been loaded, this call is just an entry lookup\n  void * hdl = dlopen(\"libdl.so\", RTLD_NOW);\n  if (hdl)\n    dladdr1_func = CAST_TO_FN_PTR(dladdr1_func_type, dlsym(hdl, \"dladdr1\"));\n\n  // (Solaris only) this switches to calls that actually do locking.\n  ThreadCritical::initialize();\n\n  main_thread = thr_self();\n\n  // Constant minimum stack size allowed. It must be at least\n  // the minimum of what the OS supports (thr_min_stack()), and\n  // enough to allow the thread to get to user bytecode execution.\n  Solaris::min_stack_allowed = MAX2(thr_min_stack(), Solaris::min_stack_allowed);\n  // If the pagesize of the VM is greater than 8K determine the appropriate\n  // number of initial guard pages.  The user can change this with the\n  // command line arguments, if needed.\n  if (vm_page_size() > 8*K) {\n    StackYellowPages = 1;\n    StackRedPages = 1;\n    StackShadowPages = round_to((StackShadowPages*8*K), vm_page_size()) / vm_page_size();\n  }\n}\n\n// To install functions for atexit system call\nextern \"C\" {\n  static void perfMemory_exit_helper() {\n    perfMemory_exit();\n  }\n}\n\n// this is called _after_ the global arguments have been parsed\njint os::init_2(void) {\n  // try to enable extended file IO ASAP, see 6431278\n  os::Solaris::try_enable_extended_io();\n\n  // Allocate a single page and mark it as readable for safepoint polling.  Also\n  // use this first mmap call to check support for MAP_ALIGN.\n  address polling_page = (address)Solaris::mmap_chunk((char*)page_size,\n                                                      page_size,\n                                                      MAP_PRIVATE | MAP_ALIGN,\n                                                      PROT_READ);\n  if (polling_page == NULL) {\n    has_map_align = false;\n    polling_page = (address)Solaris::mmap_chunk(NULL, page_size, MAP_PRIVATE,\n                                                PROT_READ);\n  }\n\n  os::set_polling_page(polling_page);\n\n#ifndef PRODUCT\n  if( Verbose && PrintMiscellaneous )\n    tty->print(\"[SafePoint Polling address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)polling_page);\n#endif\n\n  if (!UseMembar) {\n    address mem_serialize_page = (address)Solaris::mmap_chunk( NULL, page_size, MAP_PRIVATE, PROT_READ | PROT_WRITE );\n    guarantee( mem_serialize_page != NULL, \"mmap Failed for memory serialize page\");\n    os::set_memory_serialize_page( mem_serialize_page );\n\n#ifndef PRODUCT\n    if(Verbose && PrintMiscellaneous)\n      tty->print(\"[Memory Serialize  Page address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)mem_serialize_page);\n#endif\n  }\n\n  // Check minimum allowable stack size for thread creation and to initialize\n  // the java system classes, including StackOverflowError - depends on page\n  // size.  Add a page for compiler2 recursion in main thread.\n  // Add in 2*BytesPerWord times page size to account for VM stack during\n  // class initialization depending on 32 or 64 bit VM.\n  os::Solaris::min_stack_allowed = MAX2(os::Solaris::min_stack_allowed,\n            (size_t)(StackYellowPages+StackRedPages+StackShadowPages+\n                    2*BytesPerWord COMPILER2_PRESENT(+1)) * page_size);\n\n  size_t threadStackSizeInBytes = ThreadStackSize * K;\n  if (threadStackSizeInBytes != 0 &&\n    threadStackSizeInBytes < os::Solaris::min_stack_allowed) {\n    tty->print_cr(\"\\nThe stack size specified is too small, Specify at least %dk\",\n                  os::Solaris::min_stack_allowed/K);\n    return JNI_ERR;\n  }\n\n  // For 64kbps there will be a 64kb page size, which makes\n  // the usable default stack size quite a bit less.  Increase the\n  // stack for 64kb (or any > than 8kb) pages, this increases\n  // virtual memory fragmentation (since we're not creating the\n  // stack on a power of 2 boundary.  The real fix for this\n  // should be to fix the guard page mechanism.\n\n  if (vm_page_size() > 8*K) {\n      threadStackSizeInBytes = (threadStackSizeInBytes != 0)\n         ? threadStackSizeInBytes +\n           ((StackYellowPages + StackRedPages) * vm_page_size())\n         : 0;\n      ThreadStackSize = threadStackSizeInBytes/K;\n  }\n\n  // Make the stack size a multiple of the page size so that\n  // the yellow/red zones can be guarded.\n  JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,\n        vm_page_size()));\n\n  Solaris::libthread_init();\n\n  if (UseNUMA) {\n    if (!Solaris::liblgrp_init()) {\n      UseNUMA = false;\n    } else {\n      size_t lgrp_limit = os::numa_get_groups_num();\n      int *lgrp_ids = NEW_C_HEAP_ARRAY(int, lgrp_limit, mtInternal);\n      size_t lgrp_num = os::numa_get_leaf_groups(lgrp_ids, lgrp_limit);\n      FREE_C_HEAP_ARRAY(int, lgrp_ids, mtInternal);\n      if (lgrp_num < 2) {\n        // There's only one locality group, disable NUMA.\n        UseNUMA = false;\n      }\n    }\n    if (!UseNUMA && ForceNUMA) {\n      UseNUMA = true;\n    }\n  }\n\n  Solaris::signal_sets_init();\n  Solaris::init_signal_mem();\n  Solaris::install_signal_handlers();\n\n  if (libjsigversion < JSIG_VERSION_1_4_1) {\n    Maxlibjsigsigs = OLDMAXSIGNUM;\n  }\n\n  // initialize synchronization primitives to use either thread or\n  // lwp synchronization (controlled by UseLWPSynchronization)\n  Solaris::synchronization_init();\n\n  if (MaxFDLimit) {\n    // set the number of file descriptors to max. print out error\n    // if getrlimit/setrlimit fails but continue regardless.\n    struct rlimit nbr_files;\n    int status = getrlimit(RLIMIT_NOFILE, &nbr_files);\n    if (status != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode))\n        perror(\"os::init_2 getrlimit failed\");\n    } else {\n      nbr_files.rlim_cur = nbr_files.rlim_max;\n      status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n      if (status != 0) {\n        if (PrintMiscellaneous && (Verbose || WizardMode))\n          perror(\"os::init_2 setrlimit failed\");\n      }\n    }\n  }\n\n  // Calculate theoretical max. size of Threads to guard gainst\n  // artifical out-of-memory situations, where all available address-\n  // space has been reserved by thread stacks. Default stack size is 1Mb.\n  size_t pre_thread_stack_size = (JavaThread::stack_size_at_create()) ?\n    JavaThread::stack_size_at_create() : (1*K*K);\n  assert(pre_thread_stack_size != 0, \"Must have a stack\");\n  // Solaris has a maximum of 4Gb of user programs. Calculate the thread limit when\n  // we should start doing Virtual Memory banging. Currently when the threads will\n  // have used all but 200Mb of space.\n  size_t max_address_space = ((unsigned int)4 * K * K * K) - (200 * K * K);\n  Solaris::_os_thread_limit = max_address_space / pre_thread_stack_size;\n\n  // at-exit methods are called in the reverse order of their registration.\n  // In Solaris 7 and earlier, atexit functions are called on return from\n  // main or as a result of a call to exit(3C). There can be only 32 of\n  // these functions registered and atexit() does not set errno. In Solaris\n  // 8 and later, there is no limit to the number of functions registered\n  // and atexit() sets errno. In addition, in Solaris 8 and later, atexit\n  // functions are called upon dlclose(3DL) in addition to return from main\n  // and exit(3C).\n\n  if (PerfAllowAtExitRegistration) {\n    // only register atexit functions if PerfAllowAtExitRegistration is set.\n    // atexit functions can be delayed until process exit time, which\n    // can be problematic for embedded VM situations. Embedded VMs should\n    // call DestroyJavaVM() to assure that VM resources are released.\n\n    // note: perfMemory_exit_helper atexit function may be removed in\n    // the future if the appropriate cleanup code can be added to the\n    // VM_Exit VMOperation's doit method.\n    if (atexit(perfMemory_exit_helper) != 0) {\n      warning(\"os::init2 atexit(perfMemory_exit_helper) failed\");\n    }\n  }\n\n  // Init pset_loadavg function pointer\n  init_pset_getloadavg_ptr();\n\n  return JNI_OK;\n}\n\n// Mark the polling page as unreadable\nvoid os::make_polling_page_unreadable(void) {\n  if( mprotect((char *)_polling_page, page_size, PROT_NONE) != 0 )\n    fatal(\"Could not disable polling page\");\n};\n\n// Mark the polling page as readable\nvoid os::make_polling_page_readable(void) {\n  if( mprotect((char *)_polling_page, page_size, PROT_READ) != 0 )\n    fatal(\"Could not enable polling page\");\n};\n\n// OS interface.\n\nbool os::check_heap(bool force) { return true; }\n\ntypedef int (*vsnprintf_t)(char* buf, size_t count, const char* fmt, va_list argptr);\nstatic vsnprintf_t sol_vsnprintf = NULL;\n\nint local_vsnprintf(char* buf, size_t count, const char* fmt, va_list argptr) {\n  if (!sol_vsnprintf) {\n    //search  for the named symbol in the objects that were loaded after libjvm\n    void* where = RTLD_NEXT;\n    if ((sol_vsnprintf = CAST_TO_FN_PTR(vsnprintf_t, dlsym(where, \"__vsnprintf\"))) == NULL)\n        sol_vsnprintf = CAST_TO_FN_PTR(vsnprintf_t, dlsym(where, \"vsnprintf\"));\n    if (!sol_vsnprintf){\n      //search  for the named symbol in the objects that were loaded before libjvm\n      where = RTLD_DEFAULT;\n      if ((sol_vsnprintf = CAST_TO_FN_PTR(vsnprintf_t, dlsym(where, \"__vsnprintf\"))) == NULL)\n        sol_vsnprintf = CAST_TO_FN_PTR(vsnprintf_t, dlsym(where, \"vsnprintf\"));\n      assert(sol_vsnprintf != NULL, \"vsnprintf not found\");\n    }\n  }\n  return (*sol_vsnprintf)(buf, count, fmt, argptr);\n}\n\n\n// Is a (classpath) directory empty?\nbool os::dir_is_empty(const char* path) {\n  DIR *dir = NULL;\n  struct dirent *ptr;\n\n  dir = opendir(path);\n  if (dir == NULL) return true;\n\n  /* Scan the directory */\n  bool result = true;\n  char buf[sizeof(struct dirent) + MAX_PATH];\n  struct dirent *dbuf = (struct dirent *) buf;\n  while (result && (ptr = readdir(dir, dbuf)) != NULL) {\n    if (strcmp(ptr->d_name, \".\") != 0 && strcmp(ptr->d_name, \"..\") != 0) {\n      result = false;\n    }\n  }\n  closedir(dir);\n  return result;\n}\n\n// This code originates from JDK's sysOpen and open64_w\n// from src/solaris/hpi/src/system_md.c\n\n#ifndef O_DELETE\n#define O_DELETE 0x10000\n#endif\n\n// Open a file. Unlink the file immediately after open returns\n// if the specified oflag has the O_DELETE flag set.\n// O_DELETE is used only in j2se/src/share/native/java/util/zip/ZipFile.c\n\nint os::open(const char *path, int oflag, int mode) {\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  int fd;\n  int o_delete = (oflag & O_DELETE);\n  oflag = oflag & ~O_DELETE;\n\n  fd = ::open64(path, oflag, mode);\n  if (fd == -1) return -1;\n\n  //If the open succeeded, the file might still be a directory\n  {\n    struct stat64 buf64;\n    int ret = ::fstat64(fd, &buf64);\n    int st_mode = buf64.st_mode;\n\n    if (ret != -1) {\n      if ((st_mode & S_IFMT) == S_IFDIR) {\n        errno = EISDIR;\n        ::close(fd);\n        return -1;\n      }\n    } else {\n      ::close(fd);\n      return -1;\n    }\n  }\n    /*\n     * 32-bit Solaris systems suffer from:\n     *\n     * - an historical default soft limit of 256 per-process file\n     *   descriptors that is too low for many Java programs.\n     *\n     * - a design flaw where file descriptors created using stdio\n     *   fopen must be less than 256, _even_ when the first limit above\n     *   has been raised.  This can cause calls to fopen (but not calls to\n     *   open, for example) to fail mysteriously, perhaps in 3rd party\n     *   native code (although the JDK itself uses fopen).  One can hardly\n     *   criticize them for using this most standard of all functions.\n     *\n     * We attempt to make everything work anyways by:\n     *\n     * - raising the soft limit on per-process file descriptors beyond\n     *   256\n     *\n     * - As of Solaris 10u4, we can request that Solaris raise the 256\n     *   stdio fopen limit by calling function enable_extended_FILE_stdio.\n     *   This is done in init_2 and recorded in enabled_extended_FILE_stdio\n     *\n     * - If we are stuck on an old (pre 10u4) Solaris system, we can\n     *   workaround the bug by remapping non-stdio file descriptors below\n     *   256 to ones beyond 256, which is done below.\n     *\n     * See:\n     * 1085341: 32-bit stdio routines should support file descriptors >255\n     * 6533291: Work around 32-bit Solaris stdio limit of 256 open files\n     * 6431278: Netbeans crash on 32 bit Solaris: need to call\n     *          enable_extended_FILE_stdio() in VM initialisation\n     * Giri Mandalika's blog\n     * http://technopark02.blogspot.com/2005_05_01_archive.html\n     */\n#ifndef  _LP64\n     if ((!enabled_extended_FILE_stdio) && fd < 256) {\n         int newfd = ::fcntl(fd, F_DUPFD, 256);\n         if (newfd != -1) {\n             ::close(fd);\n             fd = newfd;\n         }\n     }\n#endif // 32-bit Solaris\n    /*\n     * All file descriptors that are opened in the JVM and not\n     * specifically destined for a subprocess should have the\n     * close-on-exec flag set.  If we don't set it, then careless 3rd\n     * party native code might fork and exec without closing all\n     * appropriate file descriptors (e.g. as we do in closeDescriptors in\n     * UNIXProcess.c), and this in turn might:\n     *\n     * - cause end-of-file to fail to be detected on some file\n     *   descriptors, resulting in mysterious hangs, or\n     *\n     * - might cause an fopen in the subprocess to fail on a system\n     *   suffering from bug 1085341.\n     *\n     * (Yes, the default setting of the close-on-exec flag is a Unix\n     * design flaw)\n     *\n     * See:\n     * 1085341: 32-bit stdio routines should support file descriptors >255\n     * 4843136: (process) pipe file descriptor from Runtime.exec not being closed\n     * 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9\n     */\n#ifdef FD_CLOEXEC\n    {\n        int flags = ::fcntl(fd, F_GETFD);\n        if (flags != -1)\n            ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n    }\n#endif\n\n  if (o_delete != 0) {\n    ::unlink(path);\n  }\n  return fd;\n}\n\n// create binary file, rewriting existing file if required\nint os::create_binary_file(const char* path, bool rewrite_existing) {\n  int oflags = O_WRONLY | O_CREAT;\n  if (!rewrite_existing) {\n    oflags |= O_EXCL;\n  }\n  return ::open64(path, oflags, S_IREAD | S_IWRITE);\n}\n\n// return current position of file pointer\njlong os::current_file_offset(int fd) {\n  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);\n}\n\n// move file pointer to the specified offset\njlong os::seek_to_file_offset(int fd, jlong offset) {\n  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);\n}\n\njlong os::lseek(int fd, jlong offset, int whence) {\n  return (jlong) ::lseek64(fd, offset, whence);\n}\n\nchar * os::native_path(char *path) {\n  return path;\n}\n\nint os::ftruncate(int fd, jlong length) {\n  return ::ftruncate64(fd, length);\n}\n\nint os::fsync(int fd)  {\n  RESTARTABLE_RETURN_INT(::fsync(fd));\n}\n\nint os::available(int fd, jlong *bytes) {\n  jlong cur, end;\n  int mode;\n  struct stat64 buf64;\n\n  if (::fstat64(fd, &buf64) >= 0) {\n    mode = buf64.st_mode;\n    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n      /*\n      * XXX: is the following call interruptible? If so, this might\n      * need to go through the INTERRUPT_IO() wrapper as for other\n      * blocking, interruptible calls in this file.\n      */\n      int n,ioctl_return;\n\n      INTERRUPTIBLE(::ioctl(fd, FIONREAD, &n),ioctl_return,os::Solaris::clear_interrupted);\n      if (ioctl_return>= 0) {\n          *bytes = n;\n        return 1;\n      }\n    }\n  }\n  if ((cur = ::lseek64(fd, 0L, SEEK_CUR)) == -1) {\n    return 0;\n  } else if ((end = ::lseek64(fd, 0L, SEEK_END)) == -1) {\n    return 0;\n  } else if (::lseek64(fd, cur, SEEK_SET) == -1) {\n    return 0;\n  }\n  *bytes = end - cur;\n  return 1;\n}\n\n// Map a block of memory.\nchar* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,\n                     char *addr, size_t bytes, bool read_only,\n                     bool allow_exec) {\n  int prot;\n  int flags;\n\n  if (read_only) {\n    prot = PROT_READ;\n    flags = MAP_SHARED;\n  } else {\n    prot = PROT_READ | PROT_WRITE;\n    flags = MAP_PRIVATE;\n  }\n\n  if (allow_exec) {\n    prot |= PROT_EXEC;\n  }\n\n  if (addr != NULL) {\n    flags |= MAP_FIXED;\n  }\n\n  char* mapped_address = (char*)mmap(addr, (size_t)bytes, prot, flags,\n                                     fd, file_offset);\n  if (mapped_address == MAP_FAILED) {\n    return NULL;\n  }\n  return mapped_address;\n}\n\n\n// Remap a block of memory.\nchar* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,\n                       char *addr, size_t bytes, bool read_only,\n                       bool allow_exec) {\n  // same as map_memory() on this OS\n  return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,\n                        allow_exec);\n}\n\n\n// Unmap a block of memory.\nbool os::pd_unmap_memory(char* addr, size_t bytes) {\n  return munmap(addr, bytes) == 0;\n}\n\nvoid os::pause() {\n  char filename[MAX_PATH];\n  if (PauseAtStartupFile && PauseAtStartupFile[0]) {\n    jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);\n  } else {\n    jio_snprintf(filename, MAX_PATH, \"./vm.paused.%d\", current_process_id());\n  }\n\n  int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n  if (fd != -1) {\n    struct stat buf;\n    ::close(fd);\n    while (::stat(filename, &buf) == 0) {\n      (void)::poll(NULL, 0, 100);\n    }\n  } else {\n    jio_fprintf(stderr,\n      \"Could not open pause file '%s', continuing immediately.\\n\", filename);\n  }\n}\n\n#ifndef PRODUCT\n#ifdef INTERPOSE_ON_SYSTEM_SYNCH_FUNCTIONS\n// Turn this on if you need to trace synch operations.\n// Set RECORD_SYNCH_LIMIT to a large-enough value,\n// and call record_synch_enable and record_synch_disable\n// around the computation of interest.\n\nvoid record_synch(char* name, bool returning);  // defined below\n\nclass RecordSynch {\n  char* _name;\n public:\n  RecordSynch(char* name) :_name(name)\n                 { record_synch(_name, false); }\n  ~RecordSynch() { record_synch(_name,   true);  }\n};\n\n#define CHECK_SYNCH_OP(ret, name, params, args, inner)          \\\nextern \"C\" ret name params {                                    \\\n  typedef ret name##_t params;                                  \\\n  static name##_t* implem = NULL;                               \\\n  static int callcount = 0;                                     \\\n  if (implem == NULL) {                                         \\\n    implem = (name##_t*) dlsym(RTLD_NEXT, #name);               \\\n    if (implem == NULL)  fatal(dlerror());                      \\\n  }                                                             \\\n  ++callcount;                                                  \\\n  RecordSynch _rs(#name);                                       \\\n  inner;                                                        \\\n  return implem args;                                           \\\n}\n// in dbx, examine callcounts this way:\n// for n in $(eval whereis callcount | awk '{print $2}'); do print $n; done\n\n#define CHECK_POINTER_OK(p) \\\n  (!Universe::is_fully_initialized() || !Universe::is_reserved_heap((oop)(p)))\n#define CHECK_MU \\\n  if (!CHECK_POINTER_OK(mu)) fatal(\"Mutex must be in C heap only.\");\n#define CHECK_CV \\\n  if (!CHECK_POINTER_OK(cv)) fatal(\"Condvar must be in C heap only.\");\n#define CHECK_P(p) \\\n  if (!CHECK_POINTER_OK(p))  fatal(false,  \"Pointer must be in C heap only.\");\n\n#define CHECK_MUTEX(mutex_op) \\\nCHECK_SYNCH_OP(int, mutex_op, (mutex_t *mu), (mu), CHECK_MU);\n\nCHECK_MUTEX(   mutex_lock)\nCHECK_MUTEX(  _mutex_lock)\nCHECK_MUTEX( mutex_unlock)\nCHECK_MUTEX(_mutex_unlock)\nCHECK_MUTEX( mutex_trylock)\nCHECK_MUTEX(_mutex_trylock)\n\n#define CHECK_COND(cond_op) \\\nCHECK_SYNCH_OP(int, cond_op, (cond_t *cv, mutex_t *mu), (cv, mu), CHECK_MU;CHECK_CV);\n\nCHECK_COND( cond_wait);\nCHECK_COND(_cond_wait);\nCHECK_COND(_cond_wait_cancel);\n\n#define CHECK_COND2(cond_op) \\\nCHECK_SYNCH_OP(int, cond_op, (cond_t *cv, mutex_t *mu, timestruc_t* ts), (cv, mu, ts), CHECK_MU;CHECK_CV);\n\nCHECK_COND2( cond_timedwait);\nCHECK_COND2(_cond_timedwait);\nCHECK_COND2(_cond_timedwait_cancel);\n\n// do the _lwp_* versions too\n#define mutex_t lwp_mutex_t\n#define cond_t  lwp_cond_t\nCHECK_MUTEX(  _lwp_mutex_lock)\nCHECK_MUTEX(  _lwp_mutex_unlock)\nCHECK_MUTEX(  _lwp_mutex_trylock)\nCHECK_MUTEX( __lwp_mutex_lock)\nCHECK_MUTEX( __lwp_mutex_unlock)\nCHECK_MUTEX( __lwp_mutex_trylock)\nCHECK_MUTEX(___lwp_mutex_lock)\nCHECK_MUTEX(___lwp_mutex_unlock)\n\nCHECK_COND(  _lwp_cond_wait);\nCHECK_COND( __lwp_cond_wait);\nCHECK_COND(___lwp_cond_wait);\n\nCHECK_COND2(  _lwp_cond_timedwait);\nCHECK_COND2( __lwp_cond_timedwait);\n#undef mutex_t\n#undef cond_t\n\nCHECK_SYNCH_OP(int, _lwp_suspend2,       (int lwp, int *n), (lwp, n), 0);\nCHECK_SYNCH_OP(int,__lwp_suspend2,       (int lwp, int *n), (lwp, n), 0);\nCHECK_SYNCH_OP(int, _lwp_kill,           (int lwp, int n),  (lwp, n), 0);\nCHECK_SYNCH_OP(int,__lwp_kill,           (int lwp, int n),  (lwp, n), 0);\nCHECK_SYNCH_OP(int, _lwp_sema_wait,      (lwp_sema_t* p),   (p),  CHECK_P(p));\nCHECK_SYNCH_OP(int,__lwp_sema_wait,      (lwp_sema_t* p),   (p),  CHECK_P(p));\nCHECK_SYNCH_OP(int, _lwp_cond_broadcast, (lwp_cond_t* cv),  (cv), CHECK_CV);\nCHECK_SYNCH_OP(int,__lwp_cond_broadcast, (lwp_cond_t* cv),  (cv), CHECK_CV);\n\n\n// recording machinery:\n\nenum { RECORD_SYNCH_LIMIT = 200 };\nchar* record_synch_name[RECORD_SYNCH_LIMIT];\nvoid* record_synch_arg0ptr[RECORD_SYNCH_LIMIT];\nbool record_synch_returning[RECORD_SYNCH_LIMIT];\nthread_t record_synch_thread[RECORD_SYNCH_LIMIT];\nint record_synch_count = 0;\nbool record_synch_enabled = false;\n\n// in dbx, examine recorded data this way:\n// for n in name arg0ptr returning thread; do print record_synch_$n[0..record_synch_count-1]; done\n\nvoid record_synch(char* name, bool returning) {\n  if (record_synch_enabled) {\n    if (record_synch_count < RECORD_SYNCH_LIMIT) {\n      record_synch_name[record_synch_count] = name;\n      record_synch_returning[record_synch_count] = returning;\n      record_synch_thread[record_synch_count] = thr_self();\n      record_synch_arg0ptr[record_synch_count] = &name;\n      record_synch_count++;\n    }\n    // put more checking code here:\n    // ...\n  }\n}\n\nvoid record_synch_enable() {\n  // start collecting trace data, if not already doing so\n  if (!record_synch_enabled)  record_synch_count = 0;\n  record_synch_enabled = true;\n}\n\nvoid record_synch_disable() {\n  // stop collecting trace data\n  record_synch_enabled = false;\n}\n\n#endif // INTERPOSE_ON_SYSTEM_SYNCH_FUNCTIONS\n#endif // PRODUCT\n\nconst intptr_t thr_time_off  = (intptr_t)(&((prusage_t *)(NULL))->pr_utime);\nconst intptr_t thr_time_size = (intptr_t)(&((prusage_t *)(NULL))->pr_ttime) -\n                               (intptr_t)(&((prusage_t *)(NULL))->pr_utime);\n\n\n// JVMTI & JVM monitoring and management support\n// The thread_cpu_time() and current_thread_cpu_time() are only\n// supported if is_thread_cpu_time_supported() returns true.\n// They are not supported on Solaris T1.\n\n// current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)\n// are used by JVM M&M and JVMTI to get user+sys or user CPU time\n// of a thread.\n//\n// current_thread_cpu_time() and thread_cpu_time(Thread *)\n// returns the fast estimate available on the platform.\n\n// hrtime_t gethrvtime() return value includes\n// user time but does not include system time\njlong os::current_thread_cpu_time() {\n  return (jlong) gethrvtime();\n}\n\njlong os::thread_cpu_time(Thread *thread) {\n  // return user level CPU time only to be consistent with\n  // what current_thread_cpu_time returns.\n  // thread_cpu_time_info() must be changed if this changes\n  return os::thread_cpu_time(thread, false /* user time only */);\n}\n\njlong os::current_thread_cpu_time(bool user_sys_cpu_time) {\n  if (user_sys_cpu_time) {\n    return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);\n  } else {\n    return os::current_thread_cpu_time();\n  }\n}\n\njlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {\n  char proc_name[64];\n  int count;\n  prusage_t prusage;\n  jlong lwp_time;\n  int fd;\n\n  sprintf(proc_name, \"/proc/%d/lwp/%d/lwpusage\",\n                     getpid(),\n                     thread->osthread()->lwp_id());\n  fd = ::open(proc_name, O_RDONLY);\n  if ( fd == -1 ) return -1;\n\n  do {\n    count = ::pread(fd,\n                  (void *)&prusage.pr_utime,\n                  thr_time_size,\n                  thr_time_off);\n  } while (count < 0 && errno == EINTR);\n  ::close(fd);\n  if ( count < 0 ) return -1;\n\n  if (user_sys_cpu_time) {\n    // user + system CPU time\n    lwp_time = (((jlong)prusage.pr_stime.tv_sec +\n                 (jlong)prusage.pr_utime.tv_sec) * (jlong)1000000000) +\n                 (jlong)prusage.pr_stime.tv_nsec +\n                 (jlong)prusage.pr_utime.tv_nsec;\n  } else {\n    // user level CPU time only\n    lwp_time = ((jlong)prusage.pr_utime.tv_sec * (jlong)1000000000) +\n                (jlong)prusage.pr_utime.tv_nsec;\n  }\n\n  return(lwp_time);\n}\n\nvoid os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;      // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;    // elapsed time not wall time\n  info_ptr->may_skip_forward = false;     // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_USER_CPU;  // only user time is returned\n}\n\nvoid os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;      // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;    // elapsed time not wall time\n  info_ptr->may_skip_forward = false;     // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_USER_CPU;  // only user time is returned\n}\n\nbool os::is_thread_cpu_time_supported() {\n  if ( os::Solaris::T2_libthread() || UseBoundThreads ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// System loadavg support.  Returns -1 if load average cannot be obtained.\n// Return the load average for our processor set if the primitive exists\n// (Solaris 9 and later).  Otherwise just return system wide loadavg.\nint os::loadavg(double loadavg[], int nelem) {\n  if (pset_getloadavg_ptr != NULL) {\n    return (*pset_getloadavg_ptr)(PS_MYID, loadavg, nelem);\n  } else {\n    return ::getloadavg(loadavg, nelem);\n  }\n}\n\n//---------------------------------------------------------------------------------\n\nbool os::find(address addr, outputStream* st) {\n  Dl_info dlinfo;\n  memset(&dlinfo, 0, sizeof(dlinfo));\n  if (dladdr(addr, &dlinfo) != 0) {\n    st->print(PTR_FORMAT \": \", addr);\n    if (dlinfo.dli_sname != NULL && dlinfo.dli_saddr != NULL) {\n      st->print(\"%s+%#lx\", dlinfo.dli_sname, addr-(intptr_t)dlinfo.dli_saddr);\n    } else if (dlinfo.dli_fbase != NULL)\n      st->print(\"<offset %#lx>\", addr-(intptr_t)dlinfo.dli_fbase);\n    else\n      st->print(\"<absolute address>\");\n    if (dlinfo.dli_fname != NULL) {\n      st->print(\" in %s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL) {\n      st->print(\" at \" PTR_FORMAT, dlinfo.dli_fbase);\n    }\n    st->cr();\n\n    if (Verbose) {\n      // decode some bytes around the PC\n      address begin = clamp_address_in_page(addr-40, addr, os::vm_page_size());\n      address end   = clamp_address_in_page(addr+40, addr, os::vm_page_size());\n      address       lowest = (address) dlinfo.dli_sname;\n      if (!lowest)  lowest = (address) dlinfo.dli_fbase;\n      if (begin < lowest)  begin = lowest;\n      Dl_info dlinfo2;\n      if (dladdr(end, &dlinfo2) != 0 && dlinfo2.dli_saddr != dlinfo.dli_saddr\n          && end > dlinfo2.dli_saddr && dlinfo2.dli_saddr > begin)\n        end = (address) dlinfo2.dli_saddr;\n      Disassembler::decode(begin, end, st);\n    }\n    return true;\n  }\n  return false;\n}\n\n// Following function has been added to support HotSparc's libjvm.so running\n// under Solaris production JDK 1.2.2 / 1.3.0.  These came from\n// src/solaris/hpi/native_threads in the EVM codebase.\n//\n// NOTE: This is no longer needed in the 1.3.1 and 1.4 production release\n// libraries and should thus be removed. We will leave it behind for a while\n// until we no longer want to able to run on top of 1.3.0 Solaris production\n// JDK. See 4341971.\n\n#define STACK_SLACK 0x800\n\nextern \"C\" {\n  intptr_t sysThreadAvailableStackWithSlack() {\n    stack_t st;\n    intptr_t retval, stack_top;\n    retval = thr_stksegment(&st);\n    assert(retval == 0, \"incorrect return value from thr_stksegment\");\n    assert((address)&st < (address)st.ss_sp, \"Invalid stack base returned\");\n    assert((address)&st > (address)st.ss_sp-st.ss_size, \"Invalid stack size returned\");\n    stack_top=(intptr_t)st.ss_sp-st.ss_size;\n    return ((intptr_t)&stack_top - stack_top - STACK_SLACK);\n  }\n}\n\n// ObjectMonitor park-unpark infrastructure ...\n//\n// We implement Solaris and Linux PlatformEvents with the\n// obvious condvar-mutex-flag triple.\n// Another alternative that works quite well is pipes:\n// Each PlatformEvent consists of a pipe-pair.\n// The thread associated with the PlatformEvent\n// calls park(), which reads from the input end of the pipe.\n// Unpark() writes into the other end of the pipe.\n// The write-side of the pipe must be set NDELAY.\n// Unfortunately pipes consume a large # of handles.\n// Native solaris lwp_park() and lwp_unpark() work nicely, too.\n// Using pipes for the 1st few threads might be workable, however.\n//\n// park() is permitted to return spuriously.\n// Callers of park() should wrap the call to park() in\n// an appropriate loop.  A litmus test for the correct\n// usage of park is the following: if park() were modified\n// to immediately return 0 your code should still work,\n// albeit degenerating to a spin loop.\n//\n// An interesting optimization for park() is to use a trylock()\n// to attempt to acquire the mutex.  If the trylock() fails\n// then we know that a concurrent unpark() operation is in-progress.\n// in that case the park() code could simply set _count to 0\n// and return immediately.  The subsequent park() operation *might*\n// return immediately.  That's harmless as the caller of park() is\n// expected to loop.  By using trylock() we will have avoided a\n// avoided a context switch caused by contention on the per-thread mutex.\n//\n// TODO-FIXME:\n// 1.  Reconcile Doug's JSR166 j.u.c park-unpark with the\n//     objectmonitor implementation.\n// 2.  Collapse the JSR166 parker event, and the\n//     objectmonitor ParkEvent into a single \"Event\" construct.\n// 3.  In park() and unpark() add:\n//     assert (Thread::current() == AssociatedWith).\n// 4.  add spurious wakeup injection on a -XX:EarlyParkReturn=N switch.\n//     1-out-of-N park() operations will return immediately.\n//\n// _Event transitions in park()\n//   -1 => -1 : illegal\n//    1 =>  0 : pass - return immediately\n//    0 => -1 : block\n//\n// _Event serves as a restricted-range semaphore.\n//\n// Another possible encoding of _Event would be with\n// explicit \"PARKED\" == 01b and \"SIGNALED\" == 10b bits.\n//\n// TODO-FIXME: add DTRACE probes for:\n// 1.   Tx parks\n// 2.   Ty unparks Tx\n// 3.   Tx resumes from park\n\n\n// value determined through experimentation\n#define ROUNDINGFIX 11\n\n// utility to compute the abstime argument to timedwait.\n// TODO-FIXME: switch from compute_abstime() to unpackTime().\n\nstatic timestruc_t* compute_abstime(timestruc_t* abstime, jlong millis) {\n  // millis is the relative timeout time\n  // abstime will be the absolute timeout time\n  if (millis < 0)  millis = 0;\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n  jlong seconds = millis / 1000;\n  jlong max_wait_period;\n\n  if (UseLWPSynchronization) {\n    // forward port of fix for 4275818 (not sleeping long enough)\n    // There was a bug in Solaris 6, 7 and pre-patch 5 of 8 where\n    // _lwp_cond_timedwait() used a round_down algorithm rather\n    // than a round_up. For millis less than our roundfactor\n    // it rounded down to 0 which doesn't meet the spec.\n    // For millis > roundfactor we may return a bit sooner, but\n    // since we can not accurately identify the patch level and\n    // this has already been fixed in Solaris 9 and 8 we will\n    // leave it alone rather than always rounding down.\n\n    if (millis > 0 && millis < ROUNDINGFIX) millis = ROUNDINGFIX;\n       // It appears that when we go directly through Solaris _lwp_cond_timedwait()\n           // the acceptable max time threshold is smaller than for libthread on 2.5.1 and 2.6\n           max_wait_period = 21000000;\n  } else {\n    max_wait_period = 50000000;\n  }\n  millis %= 1000;\n  if (seconds > max_wait_period) {      // see man cond_timedwait(3T)\n     seconds = max_wait_period;\n  }\n  abstime->tv_sec = now.tv_sec  + seconds;\n  long       usec = now.tv_usec + millis * 1000;\n  if (usec >= 1000000) {\n    abstime->tv_sec += 1;\n    usec -= 1000000;\n  }\n  abstime->tv_nsec = usec * 1000;\n  return abstime;\n}\n\n// Test-and-clear _Event, always leaves _Event set to 0, returns immediately.\n// Conceptually TryPark() should be equivalent to park(0).\n\nint os::PlatformEvent::TryPark() {\n  for (;;) {\n    const int v = _Event ;\n    guarantee ((v == 0) || (v == 1), \"invariant\") ;\n    if (Atomic::cmpxchg (0, &_Event, v) == v) return v  ;\n  }\n}\n\nvoid os::PlatformEvent::park() {           // AKA: down()\n  // Invariant: Only the thread associated with the Event/PlatformEvent\n  // may call park().\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v == 0) {\n     // Do this the hard way by blocking ...\n     // See http://monaco.sfbay/detail.jsf?cr=5094058.\n     // TODO-FIXME: for Solaris SPARC set fprs.FEF=0 prior to parking.\n     // Only for SPARC >= V8PlusA\n#if defined(__sparc) && defined(COMPILER2)\n     if (ClearFPUAtPark) { _mark_fpu_nosave() ; }\n#endif\n     int status = os::Solaris::mutex_lock(_mutex);\n     assert_status(status == 0, status,  \"mutex_lock\");\n     guarantee (_nParked == 0, \"invariant\") ;\n     ++ _nParked ;\n     while (_Event < 0) {\n        // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...\n        // Treat this the same as if the wait was interrupted\n        // With usr/lib/lwp going to kernel, always handle ETIME\n        status = os::Solaris::cond_wait(_cond, _mutex);\n        if (status == ETIME) status = EINTR ;\n        assert_status(status == 0 || status == EINTR, status, \"cond_wait\");\n     }\n     -- _nParked ;\n     _Event = 0 ;\n     status = os::Solaris::mutex_unlock(_mutex);\n     assert_status(status == 0, status, \"mutex_unlock\");\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other.\n    OrderAccess::fence();\n  }\n}\n\nint os::PlatformEvent::park(jlong millis) {\n  guarantee (_nParked == 0, \"invariant\") ;\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v != 0) return OS_OK ;\n\n  int ret = OS_TIMEOUT;\n  timestruc_t abst;\n  compute_abstime (&abst, millis);\n\n  // See http://monaco.sfbay/detail.jsf?cr=5094058.\n  // For Solaris SPARC set fprs.FEF=0 prior to parking.\n  // Only for SPARC >= V8PlusA\n#if defined(__sparc) && defined(COMPILER2)\n if (ClearFPUAtPark) { _mark_fpu_nosave() ; }\n#endif\n  int status = os::Solaris::mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  guarantee (_nParked == 0, \"invariant\") ;\n  ++ _nParked ;\n  while (_Event < 0) {\n     int status = os::Solaris::cond_timedwait(_cond, _mutex, &abst);\n     assert_status(status == 0 || status == EINTR ||\n                   status == ETIME || status == ETIMEDOUT,\n                   status, \"cond_timedwait\");\n     if (!FilterSpuriousWakeups) break ;                // previous semantics\n     if (status == ETIME || status == ETIMEDOUT) break ;\n     // We consume and ignore EINTR and spurious wakeups.\n  }\n  -- _nParked ;\n  if (_Event >= 0) ret = OS_OK ;\n  _Event = 0 ;\n  status = os::Solaris::mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other.\n  OrderAccess::fence();\n  return ret;\n}\n\nvoid os::PlatformEvent::unpark() {\n  // Transitions for _Event:\n  //    0 :=> 1\n  //    1 :=> 1\n  //   -1 :=> either 0 or 1; must signal target thread\n  //          That is, we can safely transition _Event from -1 to either\n  //          0 or 1. Forcing 1 is slightly more efficient for back-to-back\n  //          unpark() calls.\n  // See also: \"Semaphores in Plan 9\" by Mullender & Cox\n  //\n  // Note: Forcing a transition from \"-1\" to \"1\" on an unpark() means\n  // that it will take two back-to-back park() calls for the owning\n  // thread to block. This has the benefit of forcing a spurious return\n  // from the first park() call after an unpark() call which will help\n  // shake out uses of park() and unpark() without condition variables.\n\n  if (Atomic::xchg(1, &_Event) >= 0) return;\n\n  // If the thread associated with the event was parked, wake it.\n  // Wait for the thread assoc with the PlatformEvent to vacate.\n  int status = os::Solaris::mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  int AnyWaiters = _nParked;\n  status = os::Solaris::mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  guarantee(AnyWaiters == 0 || AnyWaiters == 1, \"invariant\");\n  if (AnyWaiters != 0) {\n    // We intentional signal *after* dropping the lock\n    // to avoid a common class of futile wakeups.\n    status = os::Solaris::cond_signal(_cond);\n    assert_status(status == 0, status, \"cond_signal\");\n  }\n}\n\n// JSR166\n// -------------------------------------------------------\n\n/*\n * The solaris and linux implementations of park/unpark are fairly\n * conservative for now, but can be improved. They currently use a\n * mutex/condvar pair, plus _counter.\n * Park decrements _counter if > 0, else does a condvar wait.  Unpark\n * sets count to 1 and signals condvar.  Only one thread ever waits\n * on the condvar. Contention seen when trying to park implies that someone\n * is unparking you, so don't wait. And spurious returns are fine, so there\n * is no need to track notifications.\n */\n\n#define MAX_SECS 100000000\n/*\n * This code is common to linux and solaris and will be moved to a\n * common place in dolphin.\n *\n * The passed in time value is either a relative time in nanoseconds\n * or an absolute time in milliseconds. Either way it has to be unpacked\n * into suitable seconds and nanoseconds components and stored in the\n * given timespec structure.\n * Given time is a 64-bit value and the time_t used in the timespec is only\n * a signed-32-bit value (except on 64-bit Linux) we have to watch for\n * overflow if times way in the future are given. Further on Solaris versions\n * prior to 10 there is a restriction (see cond_timedwait) that the specified\n * number of seconds, in abstime, is less than current_time  + 100,000,000.\n * As it will be 28 years before \"now + 100000000\" will overflow we can\n * ignore overflow and just impose a hard-limit on seconds using the value\n * of \"now + 100,000,000\". This places a limit on the timeout of about 3.17\n * years from \"now\".\n */\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {\n  assert (time > 0, \"convertTime\");\n\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n\n  time_t max_secs = now.tv_sec + MAX_SECS;\n\n  if (isAbsolute) {\n    jlong secs = time / 1000;\n    if (secs > max_secs) {\n      absTime->tv_sec = max_secs;\n    }\n    else {\n      absTime->tv_sec = secs;\n    }\n    absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;\n  }\n  else {\n    jlong secs = time / NANOSECS_PER_SEC;\n    if (secs >= MAX_SECS) {\n      absTime->tv_sec = max_secs;\n      absTime->tv_nsec = 0;\n    }\n    else {\n      absTime->tv_sec = now.tv_sec + secs;\n      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;\n      if (absTime->tv_nsec >= NANOSECS_PER_SEC) {\n        absTime->tv_nsec -= NANOSECS_PER_SEC;\n        ++absTime->tv_sec; // note: this must be <= max_secs\n      }\n    }\n  }\n  assert(absTime->tv_sec >= 0, \"tv_sec < 0\");\n  assert(absTime->tv_sec <= max_secs, \"tv_sec > max_secs\");\n  assert(absTime->tv_nsec >= 0, \"tv_nsec < 0\");\n  assert(absTime->tv_nsec < NANOSECS_PER_SEC, \"tv_nsec >= nanos_per_sec\");\n}\n\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n\n  // Optional fast-exit: Check interrupt before trying to wait\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n  JavaThread *jt = (JavaThread *)thread;\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n\n  // First, demultiplex/decode time arguments\n  timespec absTime;\n  if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all\n    return;\n  }\n  if (time > 0) {\n    // Warning: this code might be exposed to the old Solaris time\n    // round-down bugs.  Grep \"roundingFix\" for details.\n    unpackTime(&absTime, isAbsolute, time);\n  }\n\n  // Enter safepoint region\n  // Beware of deadlocks such as 6317397.\n  // The per-thread Parker:: _mutex is a classic leaf-lock.\n  // In particular a thread must never block on the Threads_lock while\n  // holding the Parker:: mutex.  If safepoints are pending both the\n  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.\n  ThreadBlockInVM tbivm(jt);\n\n  // Don't wait if cannot get lock since interference arises from\n  // unblocking.  Also. check interrupt before trying wait\n  if (Thread::is_interrupted(thread, false) ||\n      os::Solaris::mutex_trylock(_mutex) != 0) {\n    return;\n  }\n\n  int status ;\n\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = os::Solaris::mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other and Java-level accesses.\n    OrderAccess::fence();\n    return;\n  }\n\n#ifdef ASSERT\n  // Don't catch signals while blocked; let the running threads have the signals.\n  // (This allows a debugger to break into the running thread.)\n  sigset_t oldsigs;\n  sigset_t* allowdebug_blocked = os::Solaris::allowdebug_blocked_signals();\n  thr_sigsetmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);\n#endif\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n  // Do this the hard way by blocking ...\n  // See http://monaco.sfbay/detail.jsf?cr=5094058.\n  // TODO-FIXME: for Solaris SPARC set fprs.FEF=0 prior to parking.\n  // Only for SPARC >= V8PlusA\n#if defined(__sparc) && defined(COMPILER2)\n  if (ClearFPUAtPark) { _mark_fpu_nosave() ; }\n#endif\n\n  if (time == 0) {\n    status = os::Solaris::cond_wait (_cond, _mutex) ;\n  } else {\n    status = os::Solaris::cond_timedwait (_cond, _mutex, &absTime);\n  }\n  // Note that an untimed cond_wait() can sometimes return ETIME on older\n  // versions of the Solaris.\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIME || status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  thr_sigsetmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n  _counter = 0 ;\n  status = os::Solaris::mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other and Java-level accesses.\n  OrderAccess::fence();\n\n  // If externally suspended while waiting, re-suspend\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n}\n\nvoid Parker::unpark() {\n  int s, status ;\n  status = os::Solaris::mutex_lock (_mutex) ;\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  status = os::Solaris::mutex_unlock (_mutex) ;\n  assert (status == 0, \"invariant\") ;\n\n  if (s < 1) {\n    status = os::Solaris::cond_signal (_cond) ;\n    assert (status == 0, \"invariant\") ;\n  }\n}\n\nextern char** environ;\n\n// Run the specified command in a separate process. Return its exit value,\n// or -1 on failure (e.g. can't fork a new process).\n// Unlike system(), this function can be called from signal handler. It\n// doesn't block SIGINT et al.\nint os::fork_and_exec(char* cmd) {\n  char * argv[4];\n  argv[0] = (char *)\"sh\";\n  argv[1] = (char *)\"-c\";\n  argv[2] = cmd;\n  argv[3] = NULL;\n\n  // fork is async-safe, fork1 is not so can't use in signal handler\n  pid_t pid;\n  Thread* t = ThreadLocalStorage::get_thread_slow();\n  if (t != NULL && t->is_inside_signal_handler()) {\n    pid = fork();\n  } else {\n    pid = fork1();\n  }\n\n  if (pid < 0) {\n    // fork failed\n    warning(\"fork failed: %s\", strerror(errno));\n    return -1;\n\n  } else if (pid == 0) {\n    // child process\n\n    // try to be consistent with system(), which uses \"/usr/bin/sh\" on Solaris\n    execve(\"/usr/bin/sh\", argv, environ);\n\n    // execve failed\n    _exit(-1);\n\n  } else  {\n    // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n    // care about the actual exit code, for now.\n\n    int status;\n\n    // Wait for the child process to exit.  This returns immediately if\n    // the child has already exited. */\n    while (waitpid(pid, &status, 0) < 0) {\n        switch (errno) {\n        case ECHILD: return 0;\n        case EINTR: break;\n        default: return -1;\n        }\n    }\n\n    if (WIFEXITED(status)) {\n       // The child exited normally; get its exit code.\n       return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n       // The child exited because of a signal\n       // The best value to return is 0x80 + signal number,\n       // because that is what all Unix shells do, and because\n       // it allows callers to distinguish between process exit and\n       // process death by signal.\n       return 0x80 + WTERMSIG(status);\n    } else {\n       // Unknown exit code; pass it through\n       return status;\n    }\n  }\n}\n\n// is_headless_jre()\n//\n// Test for the existence of xawt/libmawt.so or libawt_xawt.so\n// in order to report if we are running in a headless jre\n//\n// Since JDK8 xawt/libmawt.so was moved into the same directory\n// as libawt.so, and renamed libawt_xawt.so\n//\nbool os::is_headless_jre() {\n    struct stat statbuf;\n    char buf[MAXPATHLEN];\n    char libmawtpath[MAXPATHLEN];\n    const char *xawtstr  = \"/xawt/libmawt.so\";\n    const char *new_xawtstr = \"/libawt_xawt.so\";\n    char *p;\n\n    // Get path to libjvm.so\n    os::jvm_path(buf, sizeof(buf));\n\n    // Get rid of libjvm.so\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // Get rid of client or server\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // check xawt/libmawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    // check libawt_xawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, new_xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    return true;\n}\n\nsize_t os::write(int fd, const void *buf, unsigned int nBytes) {\n  INTERRUPTIBLE_RETURN_INT(::write(fd, buf, nBytes), os::Solaris::clear_interrupted);\n}\n\nint os::close(int fd) {\n  return ::close(fd);\n}\n\nint os::socket_close(int fd) {\n  return ::close(fd);\n}\n\nint os::recv(int fd, char* buf, size_t nBytes, uint flags) {\n  INTERRUPTIBLE_RETURN_INT((int)::recv(fd, buf, nBytes, flags), os::Solaris::clear_interrupted);\n}\n\nint os::send(int fd, char* buf, size_t nBytes, uint flags) {\n  INTERRUPTIBLE_RETURN_INT((int)::send(fd, buf, nBytes, flags), os::Solaris::clear_interrupted);\n}\n\nint os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {\n  RESTARTABLE_RETURN_INT((int)::send(fd, buf, nBytes, flags));\n}\n\n// As both poll and select can be interrupted by signals, we have to be\n// prepared to restart the system call after updating the timeout, unless\n// a poll() is done with timeout == -1, in which case we repeat with this\n// \"wait forever\" value.\n\nint os::timeout(int fd, long timeout) {\n  int res;\n  struct timeval t;\n  julong prevtime, newtime;\n  static const char* aNull = 0;\n  struct pollfd pfd;\n  pfd.fd = fd;\n  pfd.events = POLLIN;\n\n  gettimeofday(&t, &aNull);\n  prevtime = ((julong)t.tv_sec * 1000)  +  t.tv_usec / 1000;\n\n  for(;;) {\n    INTERRUPTIBLE_NORESTART(::poll(&pfd, 1, timeout), res, os::Solaris::clear_interrupted);\n    if(res == OS_ERR && errno == EINTR) {\n        if(timeout != -1) {\n          gettimeofday(&t, &aNull);\n          newtime = ((julong)t.tv_sec * 1000)  +  t.tv_usec /1000;\n          timeout -= newtime - prevtime;\n          if(timeout <= 0)\n            return OS_OK;\n          prevtime = newtime;\n        }\n    } else return res;\n  }\n}\n\nint os::connect(int fd, struct sockaddr *him, socklen_t len) {\n  int _result;\n  INTERRUPTIBLE_NORESTART(::connect(fd, him, len), _result,\\\n                          os::Solaris::clear_interrupted);\n\n  // Depending on when thread interruption is reset, _result could be\n  // one of two values when errno == EINTR\n\n  if (((_result == OS_INTRPT) || (_result == OS_ERR))\n      && (errno == EINTR)) {\n     /* restarting a connect() changes its errno semantics */\n     INTERRUPTIBLE(::connect(fd, him, len), _result,\\\n                   os::Solaris::clear_interrupted);\n     /* undo these changes */\n     if (_result == OS_ERR) {\n       if (errno == EALREADY) {\n         errno = EINPROGRESS; /* fall through */\n       } else if (errno == EISCONN) {\n         errno = 0;\n         return OS_OK;\n       }\n     }\n   }\n   return _result;\n }\n\nint os::accept(int fd, struct sockaddr* him, socklen_t* len) {\n  if (fd < 0) {\n    return OS_ERR;\n  }\n  INTERRUPTIBLE_RETURN_INT((int)::accept(fd, him, len),\\\n                           os::Solaris::clear_interrupted);\n}\n\nint os::recvfrom(int fd, char* buf, size_t nBytes, uint flags,\n                 sockaddr* from, socklen_t* fromlen) {\n  INTERRUPTIBLE_RETURN_INT((int)::recvfrom(fd, buf, nBytes, flags, from, fromlen),\\\n                           os::Solaris::clear_interrupted);\n}\n\nint os::sendto(int fd, char* buf, size_t len, uint flags,\n               struct sockaddr* to, socklen_t tolen) {\n  INTERRUPTIBLE_RETURN_INT((int)::sendto(fd, buf, len, flags, to, tolen),\\\n                           os::Solaris::clear_interrupted);\n}\n\nint os::socket_available(int fd, jint *pbytes) {\n  if (fd < 0) {\n    return OS_OK;\n  }\n  int ret;\n  RESTARTABLE(::ioctl(fd, FIONREAD, pbytes), ret);\n  // note: ioctl can return 0 when successful, JVM_SocketAvailable\n  // is expected to return 0 on failure and 1 on success to the jdk.\n  return (ret == OS_ERR) ? 0 : 1;\n}\n\nint os::bind(int fd, struct sockaddr* him, socklen_t len) {\n   INTERRUPTIBLE_RETURN_INT_NORESTART(::bind(fd, him, len),\\\n                                      os::Solaris::clear_interrupted);\n}\n\n// Get the default path to the core file\n// Returns the length of the string\nint os::get_core_path(char* buffer, size_t bufferSize) {\n  const char* p = get_current_directory(buffer, bufferSize);\n\n  if (p == NULL) {\n    assert(p != NULL, \"failed to get current directory\");\n    return 0;\n  }\n\n  return strlen(buffer);\n}\n\n#ifndef PRODUCT\nvoid TestReserveMemorySpecial_test() {\n  // No tests available for this platform\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os/bsd/vm/jsig.c": "/*\n * Copyright (c) 2001, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n/* CopyrightVersion 1.2 */\n\n/* This is a special library that should be loaded before libc &\n * libthread to interpose the signal handler installation functions:\n * sigaction(), signal(), sigset().\n * Used for signal-chaining. See RFE 4381843.\n */\n\n#include <signal.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAXSIGNUM 32\n#define MASK(sig) ((unsigned int)1 << sig)\n\nstatic struct sigaction sact[MAXSIGNUM]; /* saved signal handlers */\nstatic unsigned int jvmsigs = 0; /* signals used by jvm */\n\nstatic pthread_key_t reentry_flag_key;\nstatic pthread_once_t reentry_key_init_once = PTHREAD_ONCE_INIT;\n\n/* used to synchronize the installation of signal handlers */\nstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t tid = 0;\n\ntypedef void (*sa_handler_t)(int);\ntypedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\ntypedef sa_handler_t (*signal_t)(int, sa_handler_t);\ntypedef int (*sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic signal_t os_signal = 0; /* os's version of signal()/sigset() */\nstatic sigaction_t os_sigaction = 0; /* os's version of sigaction() */\n\nstatic bool jvm_signal_installing = false;\nstatic bool jvm_signal_installed = false;\n\n#define check_status(cmd) \\\n  do { \\\n    int status = (cmd); \\\n    if (status != 0) { \\\n      printf(\"error %s (%d) in \" #cmd \"\\n\", strerror(status), status); \\\n      exit(1); \\\n    } \\\n  } while (0)\n\nstatic void signal_lock() {\n  pthread_mutex_lock(&mutex);\n  /* When the jvm is installing its set of signal handlers, threads\n   * other than the jvm thread should wait */\n  if (jvm_signal_installing) {\n    if (tid != pthread_self()) {\n      pthread_cond_wait(&cond, &mutex);\n    }\n  }\n}\n\nstatic void signal_unlock() {\n  pthread_mutex_unlock(&mutex);\n}\n\nstatic void reentry_tls_init() {\n    // value for reentry_flag_key will default to NULL (false)\n    check_status(pthread_key_create(&reentry_flag_key, NULL));\n}\n\nstatic sa_handler_t call_os_signal(int sig, sa_handler_t disp,\n                                   bool is_sigset) {\n  sa_handler_t res;\n\n  if (os_signal == NULL) {\n    if (!is_sigset) {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"signal\");\n    } else {\n      os_signal = (signal_t)dlsym(RTLD_NEXT, \"sigset\");\n    }\n    if (os_signal == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  check_status(pthread_once(&reentry_key_init_once, reentry_tls_init));\n  // set reentry_flag_key to non-NULL to show reentry\n  check_status(pthread_setspecific(reentry_flag_key, &res));\n  res = (*os_signal)(sig, disp);\n  check_status(pthread_setspecific(reentry_flag_key, NULL));\n  return res;\n}\n\nstatic void save_signal_handler(int sig, sa_handler_t disp) {\n  sigset_t set;\n  sact[sig].sa_handler = disp;\n  sigemptyset(&set);\n  sact[sig].sa_mask = set;\n  sact[sig].sa_flags = 0;\n}\n\nstatic sa_handler_t set_signal(int sig, sa_handler_t disp, bool is_sigset) {\n  sa_handler_t oldhandler;\n  bool sigused;\n\n  signal_lock();\n\n  sigused = (MASK(sig) & jvmsigs) != 0;\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    oldhandler = sact[sig].sa_handler;\n    save_signal_handler(sig, disp);\n\n    signal_unlock();\n    return oldhandler;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. jvm uses sigaction().\n     * Leave the piece here just in case. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n    save_signal_handler(sig, oldhandler);\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return oldhandler;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n\n    signal_unlock();\n    return oldhandler;\n  }\n}\n\nsa_handler_t signal(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, false);\n}\n\nsa_handler_t sigset(int sig, sa_handler_t disp) {\n  printf(\"sigset() is not supported by BSD\");\n  exit(0);\n }\n\nstatic int call_os_sigaction(int sig, const struct sigaction  *act,\n                             struct sigaction *oact) {\n  if (os_sigaction == NULL) {\n    os_sigaction = (sigaction_t)dlsym(RTLD_NEXT, \"sigaction\");\n    if (os_sigaction == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_sigaction)(sig, act, oact);\n}\n\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact) {\n  int res;\n  bool sigused;\n  struct sigaction oldAct;\n\n  check_status(pthread_once(&reentry_key_init_once, reentry_tls_init));\n  if (pthread_getspecific(reentry_flag_key) != NULL) {\n    return call_os_sigaction(sig, act, oact);\n  }\n\n  signal_lock();\n\n  sigused = (MASK(sig) & jvmsigs) != 0;\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    if (oact != NULL) {\n      *oact = sact[sig];\n    }\n    if (act != NULL) {\n      sact[sig] = *act;\n    }\n\n    signal_unlock();\n    return 0;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. */\n    res = call_os_sigaction(sig, act, &oldAct);\n    sact[sig] = oldAct;\n    if (oact != NULL) {\n      *oact = oldAct;\n    }\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return res;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    res = call_os_sigaction(sig, act, oact);\n\n    signal_unlock();\n    return res;\n  }\n}\n\n/* The three functions for the jvm to call into */\nvoid JVM_begin_signal_setting() {\n  signal_lock();\n  jvm_signal_installing = true;\n  tid = pthread_self();\n  signal_unlock();\n}\n\nvoid JVM_end_signal_setting() {\n  signal_lock();\n  jvm_signal_installed = true;\n  jvm_signal_installing = false;\n  pthread_cond_broadcast(&cond);\n  signal_unlock();\n}\n\nstruct sigaction *JVM_get_signal_action(int sig) {\n  /* Does race condition make sense here? */\n  if ((MASK(sig) & jvmsigs) != 0) {\n    return &sact[sig];\n  }\n  return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os/bsd/vm/os_bsd.cpp": "/*\n * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n// no precompiled headers\n#include \"classfile/classLoader.hpp\"\n#include \"classfile/systemDictionary.hpp\"\n#include \"classfile/vmSymbols.hpp\"\n#include \"code/icBuffer.hpp\"\n#include \"code/vtableStubs.hpp\"\n#include \"compiler/compileBroker.hpp\"\n#include \"compiler/disassembler.hpp\"\n#include \"interpreter/interpreter.hpp\"\n#include \"jvm_bsd.h\"\n#include \"memory/allocation.inline.hpp\"\n#include \"memory/filemap.hpp\"\n#include \"mutex_bsd.inline.hpp\"\n#include \"oops/oop.inline.hpp\"\n#include \"os_share_bsd.hpp\"\n#include \"prims/jniFastGetField.hpp\"\n#include \"prims/jvm.h\"\n#include \"prims/jvm_misc.hpp\"\n#include \"runtime/arguments.hpp\"\n#include \"runtime/extendedPC.hpp\"\n#include \"runtime/globals.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/java.hpp\"\n#include \"runtime/javaCalls.hpp\"\n#include \"runtime/mutexLocker.hpp\"\n#include \"runtime/objectMonitor.hpp\"\n#include \"runtime/orderAccess.inline.hpp\"\n#include \"runtime/osThread.hpp\"\n#include \"runtime/perfMemory.hpp\"\n#include \"runtime/sharedRuntime.hpp\"\n#include \"runtime/statSampler.hpp\"\n#include \"runtime/stubRoutines.hpp\"\n#include \"runtime/thread.inline.hpp\"\n#include \"runtime/threadCritical.hpp\"\n#include \"runtime/timer.hpp\"\n#include \"services/attachListener.hpp\"\n#include \"services/memTracker.hpp\"\n#include \"services/runtimeService.hpp\"\n#include \"utilities/decoder.hpp\"\n#include \"utilities/defaultStream.hpp\"\n#include \"utilities/events.hpp\"\n#include \"utilities/growableArray.hpp\"\n#include \"utilities/vmError.hpp\"\n\n// put OS-includes here\n# include <sys/types.h>\n# include <sys/mman.h>\n# include <sys/stat.h>\n# include <sys/select.h>\n# include <pthread.h>\n# include <signal.h>\n# include <errno.h>\n# include <dlfcn.h>\n# include <stdio.h>\n# include <unistd.h>\n# include <sys/resource.h>\n# include <pthread.h>\n# include <sys/stat.h>\n# include <sys/time.h>\n# include <sys/times.h>\n# include <sys/utsname.h>\n# include <sys/socket.h>\n# include <sys/wait.h>\n# include <time.h>\n# include <pwd.h>\n# include <poll.h>\n# include <semaphore.h>\n# include <fcntl.h>\n# include <string.h>\n# include <sys/param.h>\n# include <sys/sysctl.h>\n# include <sys/ipc.h>\n# include <sys/shm.h>\n#ifndef __APPLE__\n# include <link.h>\n#endif\n# include <stdint.h>\n# include <inttypes.h>\n# include <sys/ioctl.h>\n# include <sys/syscall.h>\n\n#if defined(__FreeBSD__) || defined(__NetBSD__)\n# include <elf.h>\n#endif\n\n#ifdef __APPLE__\n# include <mach/mach.h> // semaphore_* API\n# include <mach-o/dyld.h>\n# include <sys/proc_info.h>\n# include <objc/objc-auto.h>\n#endif\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#define MAX_PATH    (2 * K)\n\n// for timer info max values which include all bits\n#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n\n#define LARGEPAGES_BIT (1 << 6)\n\nPRAGMA_FORMAT_MUTE_WARNINGS_FOR_GCC\n\n////////////////////////////////////////////////////////////////////////////////\n// global variables\njulong os::Bsd::_physical_memory = 0;\n\n#ifdef __APPLE__\nmach_timebase_info_data_t os::Bsd::_timebase_info = {0, 0};\nvolatile uint64_t         os::Bsd::_max_abstime   = 0;\n#else\nint (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;\n#endif\npthread_t os::Bsd::_main_thread;\nint os::Bsd::_page_size = -1;\n\nstatic jlong initial_time_count=0;\n\nstatic int clock_tics_per_sec = 100;\n\n// For diagnostics to print a message once. see run_periodic_checks\nstatic sigset_t check_signal_done;\nstatic bool check_signals = true;\n\nstatic pid_t _initial_pid = 0;\n\n/* Signal number used to suspend/resume a thread */\n\n/* do not use any signal number less than SIGSEGV, see 4355769 */\nstatic int SR_signum = SIGUSR2;\nsigset_t SR_sigset;\n\n\n////////////////////////////////////////////////////////////////////////////////\n// utility functions\n\nstatic int SR_initialize();\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time);\n\njulong os::available_memory() {\n  return Bsd::available_memory();\n}\n\n// available here means free\njulong os::Bsd::available_memory() {\n  uint64_t available = physical_memory() >> 2;\n#ifdef __APPLE__\n  mach_msg_type_number_t count = HOST_VM_INFO64_COUNT;\n  vm_statistics64_data_t vmstat;\n  kern_return_t kerr = host_statistics64(mach_host_self(), HOST_VM_INFO64,\n                                         (host_info64_t)&vmstat, &count);\n  assert(kerr == KERN_SUCCESS,\n         \"host_statistics64 failed - check mach_host_self() and count\");\n  if (kerr == KERN_SUCCESS) {\n    available = vmstat.free_count * os::vm_page_size();\n  }\n#endif\n  return available;\n}\n\njulong os::physical_memory() {\n  return Bsd::physical_memory();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// environment support\n\nbool os::getenv(const char* name, char* buf, int len) {\n  const char* val = ::getenv(name);\n  if (val != NULL && strlen(val) < (size_t)len) {\n    strcpy(buf, val);\n    return true;\n  }\n  if (len > 0) buf[0] = 0;  // return a null string\n  return false;\n}\n\n\n// Return true if user is running as root.\n\nbool os::have_special_privileges() {\n  static bool init = false;\n  static bool privileges = false;\n  if (!init) {\n    privileges = (getuid() != geteuid()) || (getgid() != getegid());\n    init = true;\n  }\n  return privileges;\n}\n\n\n\n// Cpu architecture string\n#if   defined(ZERO)\nstatic char cpu_arch[] = ZERO_LIBARCH;\n#elif defined(IA64)\nstatic char cpu_arch[] = \"ia64\";\n#elif defined(IA32)\nstatic char cpu_arch[] = \"i386\";\n#elif defined(AMD64)\nstatic char cpu_arch[] = \"amd64\";\n#elif defined(ARM)\nstatic char cpu_arch[] = \"arm\";\n#elif defined(PPC32)\nstatic char cpu_arch[] = \"ppc\";\n#elif defined(SPARC)\n#  ifdef _LP64\nstatic char cpu_arch[] = \"sparcv9\";\n#  else\nstatic char cpu_arch[] = \"sparc\";\n#  endif\n#else\n#error Add appropriate cpu_arch setting\n#endif\n\n// Compiler variant\n#ifdef COMPILER2\n#define COMPILER_VARIANT \"server\"\n#else\n#define COMPILER_VARIANT \"client\"\n#endif\n\n\nvoid os::Bsd::initialize_system_info() {\n  int mib[2];\n  size_t len;\n  int cpu_val;\n  julong mem_val;\n\n  /* get processors count via hw.ncpus sysctl */\n  mib[0] = CTL_HW;\n  mib[1] = HW_NCPU;\n  len = sizeof(cpu_val);\n  if (sysctl(mib, 2, &cpu_val, &len, NULL, 0) != -1 && cpu_val >= 1) {\n       assert(len == sizeof(cpu_val), \"unexpected data size\");\n       set_processor_count(cpu_val);\n  }\n  else {\n       set_processor_count(1);   // fallback\n  }\n\n  /* get physical memory via hw.memsize sysctl (hw.memsize is used\n   * since it returns a 64 bit value)\n   */\n  mib[0] = CTL_HW;\n\n#if defined (HW_MEMSIZE) // Apple\n  mib[1] = HW_MEMSIZE;\n#elif defined(HW_PHYSMEM) // Most of BSD\n  mib[1] = HW_PHYSMEM;\n#elif defined(HW_REALMEM) // Old FreeBSD\n  mib[1] = HW_REALMEM;\n#else\n  #error No ways to get physmem\n#endif\n\n  len = sizeof(mem_val);\n  if (sysctl(mib, 2, &mem_val, &len, NULL, 0) != -1) {\n       assert(len == sizeof(mem_val), \"unexpected data size\");\n       _physical_memory = mem_val;\n  } else {\n       _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)\n  }\n\n#ifdef __OpenBSD__\n  {\n       // limit _physical_memory memory view on OpenBSD since\n       // datasize rlimit restricts us anyway.\n       struct rlimit limits;\n       getrlimit(RLIMIT_DATA, &limits);\n       _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);\n  }\n#endif\n}\n\n#ifdef __APPLE__\nstatic const char *get_home() {\n  const char *home_dir = ::getenv(\"HOME\");\n  if ((home_dir == NULL) || (*home_dir == '\\0')) {\n    struct passwd *passwd_info = getpwuid(geteuid());\n    if (passwd_info != NULL) {\n      home_dir = passwd_info->pw_dir;\n    }\n  }\n\n  return home_dir;\n}\n#endif\n\nvoid os::init_system_properties_values() {\n  // The next steps are taken in the product version:\n  //\n  // Obtain the JAVA_HOME value from the location of libjvm.so.\n  // This library should be located at:\n  // <JAVA_HOME>/jre/lib/<arch>/{client|server}/libjvm.so.\n  //\n  // If \"/jre/lib/\" appears at the right place in the path, then we\n  // assume libjvm.so is installed in a JDK and we use this path.\n  //\n  // Otherwise exit with message: \"Could not create the Java virtual machine.\"\n  //\n  // The following extra steps are taken in the debugging version:\n  //\n  // If \"/jre/lib/\" does NOT appear at the right place in the path\n  // instead of exit check for $JAVA_HOME environment variable.\n  //\n  // If it is defined and we are able to locate $JAVA_HOME/jre/lib/<arch>,\n  // then we append a fake suffix \"hotspot/libjvm.so\" to this path so\n  // it looks like libjvm.so is installed there\n  // <JAVA_HOME>/jre/lib/<arch>/hotspot/libjvm.so.\n  //\n  // Otherwise exit.\n  //\n  // Important note: if the location of libjvm.so changes this\n  // code needs to be changed accordingly.\n\n// See ld(1):\n//      The linker uses the following search paths to locate required\n//      shared libraries:\n//        1: ...\n//        ...\n//        7: The default directories, normally /lib and /usr/lib.\n#ifndef DEFAULT_LIBPATH\n#define DEFAULT_LIBPATH \"/lib:/usr/lib\"\n#endif\n\n// Base path of extensions installed on the system.\n#define SYS_EXT_DIR     \"/usr/java/packages\"\n#define EXTENSIONS_DIR  \"/lib/ext\"\n#define ENDORSED_DIR    \"/lib/endorsed\"\n\n#ifndef __APPLE__\n\n  // Buffer that fits several sprintfs.\n  // Note that the space for the colon and the trailing null are provided\n  // by the nulls included by the sizeof operator.\n  const size_t bufsize =\n    MAX3((size_t)MAXPATHLEN,  // For dll_dir & friends.\n         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + sizeof(SYS_EXT_DIR) + sizeof(EXTENSIONS_DIR), // extensions dir\n         (size_t)MAXPATHLEN + sizeof(ENDORSED_DIR)); // endorsed dir\n  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n\n  // sysclasspath, java_home, dll_dir\n  {\n    char *pslash;\n    os::jvm_path(buf, bufsize);\n\n    // Found the full path to libjvm.so.\n    // Now cut the path to <java_home>/jre if we can.\n    *(strrchr(buf, '/')) = '\\0'; // Get rid of /libjvm.so.\n    pslash = strrchr(buf, '/');\n    if (pslash != NULL) {\n      *pslash = '\\0';            // Get rid of /{client|server|hotspot}.\n    }\n    Arguments::set_dll_dir(buf);\n\n    if (pslash != NULL) {\n      pslash = strrchr(buf, '/');\n      if (pslash != NULL) {\n        *pslash = '\\0';          // Get rid of /<arch>.\n        pslash = strrchr(buf, '/');\n        if (pslash != NULL) {\n          *pslash = '\\0';        // Get rid of /lib.\n        }\n      }\n    }\n    Arguments::set_java_home(buf);\n    set_boot_path('/', ':');\n  }\n\n  // Where to look for native libraries.\n  //\n  // Note: Due to a legacy implementation, most of the library path\n  // is set in the launcher. This was to accomodate linking restrictions\n  // on legacy Bsd implementations (which are no longer supported).\n  // Eventually, all the library path setting will be done here.\n  //\n  // However, to prevent the proliferation of improperly built native\n  // libraries, the new path component /usr/java/packages is added here.\n  // Eventually, all the library path setting will be done here.\n  {\n    // Get the user setting of LD_LIBRARY_PATH, and prepended it. It\n    // should always exist (until the legacy problem cited above is\n    // addressed).\n    const char *v = ::getenv(\"LD_LIBRARY_PATH\");\n    const char *v_colon = \":\";\n    if (v == NULL) { v = \"\"; v_colon = \"\"; }\n    // That's +1 for the colon and +1 for the trailing '\\0'.\n    char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,\n                                                     strlen(v) + 1 +\n                                                     sizeof(SYS_EXT_DIR) + sizeof(\"/lib/\") + strlen(cpu_arch) + sizeof(DEFAULT_LIBPATH) + 1,\n                                                     mtInternal);\n    sprintf(ld_library_path, \"%s%s\" SYS_EXT_DIR \"/lib/%s:\" DEFAULT_LIBPATH, v, v_colon, cpu_arch);\n    Arguments::set_library_path(ld_library_path);\n    FREE_C_HEAP_ARRAY(char, ld_library_path, mtInternal);\n  }\n\n  // Extensions directories.\n  sprintf(buf, \"%s\" EXTENSIONS_DIR \":\" SYS_EXT_DIR EXTENSIONS_DIR, Arguments::get_java_home());\n  Arguments::set_ext_dirs(buf);\n\n  // Endorsed standards default directory.\n  sprintf(buf, \"%s\" ENDORSED_DIR, Arguments::get_java_home());\n  Arguments::set_endorsed_dirs(buf);\n\n  FREE_C_HEAP_ARRAY(char, buf, mtInternal);\n\n#else // __APPLE__\n\n#define SYS_EXTENSIONS_DIR   \"/Library/Java/Extensions\"\n#define SYS_EXTENSIONS_DIRS  SYS_EXTENSIONS_DIR \":/Network\" SYS_EXTENSIONS_DIR \":/System\" SYS_EXTENSIONS_DIR \":/usr/lib/java\"\n\n  const char *user_home_dir = get_home();\n  // The null in SYS_EXTENSIONS_DIRS counts for the size of the colon after user_home_dir.\n  size_t system_ext_size = strlen(user_home_dir) + sizeof(SYS_EXTENSIONS_DIR) +\n    sizeof(SYS_EXTENSIONS_DIRS);\n\n  // Buffer that fits several sprintfs.\n  // Note that the space for the colon and the trailing null are provided\n  // by the nulls included by the sizeof operator.\n  const size_t bufsize =\n    MAX3((size_t)MAXPATHLEN,  // for dll_dir & friends.\n         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + system_ext_size, // extensions dir\n         (size_t)MAXPATHLEN + sizeof(ENDORSED_DIR)); // endorsed dir\n  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n\n  // sysclasspath, java_home, dll_dir\n  {\n    char *pslash;\n    os::jvm_path(buf, bufsize);\n\n    // Found the full path to libjvm.so.\n    // Now cut the path to <java_home>/jre if we can.\n    *(strrchr(buf, '/')) = '\\0'; // Get rid of /libjvm.so.\n    pslash = strrchr(buf, '/');\n    if (pslash != NULL) {\n      *pslash = '\\0';            // Get rid of /{client|server|hotspot}.\n    }\n    Arguments::set_dll_dir(buf);\n\n    if (pslash != NULL) {\n      pslash = strrchr(buf, '/');\n      if (pslash != NULL) {\n        *pslash = '\\0';          // Get rid of /lib.\n      }\n    }\n    Arguments::set_java_home(buf);\n    set_boot_path('/', ':');\n  }\n\n  // Where to look for native libraries.\n  //\n  // Note: Due to a legacy implementation, most of the library path\n  // is set in the launcher. This was to accomodate linking restrictions\n  // on legacy Bsd implementations (which are no longer supported).\n  // Eventually, all the library path setting will be done here.\n  //\n  // However, to prevent the proliferation of improperly built native\n  // libraries, the new path component /usr/java/packages is added here.\n  // Eventually, all the library path setting will be done here.\n  {\n    // Get the user setting of LD_LIBRARY_PATH, and prepended it. It\n    // should always exist (until the legacy problem cited above is\n    // addressed).\n    // Prepend the default path with the JAVA_LIBRARY_PATH so that the app launcher code\n    // can specify a directory inside an app wrapper\n    const char *l = ::getenv(\"JAVA_LIBRARY_PATH\");\n    const char *l_colon = \":\";\n    if (l == NULL) { l = \"\"; l_colon = \"\"; }\n\n    const char *v = ::getenv(\"DYLD_LIBRARY_PATH\");\n    const char *v_colon = \":\";\n    if (v == NULL) { v = \"\"; v_colon = \"\"; }\n\n    // Apple's Java6 has \".\" at the beginning of java.library.path.\n    // OpenJDK on Windows has \".\" at the end of java.library.path.\n    // OpenJDK on Linux and Solaris don't have \".\" in java.library.path\n    // at all. To ease the transition from Apple's Java6 to OpenJDK7,\n    // \".\" is appended to the end of java.library.path. Yes, this\n    // could cause a change in behavior, but Apple's Java6 behavior\n    // can be achieved by putting \".\" at the beginning of the\n    // JAVA_LIBRARY_PATH environment variable.\n    char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,\n                                                     strlen(v) + 1 + strlen(l) + 1 +\n                                                     system_ext_size + 3,\n                                                     mtInternal);\n    sprintf(ld_library_path, \"%s%s%s%s%s\" SYS_EXTENSIONS_DIR \":\" SYS_EXTENSIONS_DIRS \":.\",\n            v, v_colon, l, l_colon, user_home_dir);\n    Arguments::set_library_path(ld_library_path);\n    FREE_C_HEAP_ARRAY(char, ld_library_path, mtInternal);\n  }\n\n  // Extensions directories.\n  //\n  // Note that the space for the colon and the trailing null are provided\n  // by the nulls included by the sizeof operator (so actually one byte more\n  // than necessary is allocated).\n  sprintf(buf, \"%s\" SYS_EXTENSIONS_DIR \":%s\" EXTENSIONS_DIR \":\" SYS_EXTENSIONS_DIRS,\n          user_home_dir, Arguments::get_java_home());\n  Arguments::set_ext_dirs(buf);\n\n  // Endorsed standards default directory.\n  sprintf(buf, \"%s\" ENDORSED_DIR, Arguments::get_java_home());\n  Arguments::set_endorsed_dirs(buf);\n\n  FREE_C_HEAP_ARRAY(char, buf, mtInternal);\n\n#undef SYS_EXTENSIONS_DIR\n#undef SYS_EXTENSIONS_DIRS\n\n#endif // __APPLE__\n\n#undef SYS_EXT_DIR\n#undef EXTENSIONS_DIR\n#undef ENDORSED_DIR\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// breakpoint support\n\nvoid os::breakpoint() {\n  BREAKPOINT;\n}\n\nextern \"C\" void breakpoint() {\n  // use debugger to set breakpoint here\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// signal support\n\ndebug_only(static bool signal_sets_initialized = false);\nstatic sigset_t unblocked_sigs, vm_sigs, allowdebug_blocked_sigs;\n\nbool os::Bsd::is_sig_ignored(int sig) {\n      struct sigaction oact;\n      sigaction(sig, (struct sigaction*)NULL, &oact);\n      void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oact.sa_sigaction)\n                                     : CAST_FROM_FN_PTR(void*,  oact.sa_handler);\n      if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN))\n           return true;\n      else\n           return false;\n}\n\nvoid os::Bsd::signal_sets_init() {\n  // Should also have an assertion stating we are still single-threaded.\n  assert(!signal_sets_initialized, \"Already initialized\");\n  // Fill in signals that are necessarily unblocked for all threads in\n  // the VM. Currently, we unblock the following signals:\n  // SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n  //                         by -Xrs (=ReduceSignalUsage));\n  // BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n  // other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n  // the dispositions or masks wrt these signals.\n  // Programs embedding the VM that want to use the above signals for their\n  // own purposes must, at this time, use the \"-Xrs\" option to prevent\n  // interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n  // (See bug 4345157, and other related bugs).\n  // In reality, though, unblocking these signals is really a nop, since\n  // these signals are not blocked by default.\n  sigemptyset(&unblocked_sigs);\n  sigemptyset(&allowdebug_blocked_sigs);\n  sigaddset(&unblocked_sigs, SIGILL);\n  sigaddset(&unblocked_sigs, SIGSEGV);\n  sigaddset(&unblocked_sigs, SIGBUS);\n  sigaddset(&unblocked_sigs, SIGFPE);\n  sigaddset(&unblocked_sigs, SR_signum);\n\n  if (!ReduceSignalUsage) {\n   if (!os::Bsd::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN1_SIGNAL);\n   }\n   if (!os::Bsd::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN2_SIGNAL);\n   }\n   if (!os::Bsd::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n      sigaddset(&allowdebug_blocked_sigs, SHUTDOWN3_SIGNAL);\n   }\n  }\n  // Fill in signals that are blocked by all but the VM thread.\n  sigemptyset(&vm_sigs);\n  if (!ReduceSignalUsage)\n    sigaddset(&vm_sigs, BREAK_SIGNAL);\n  debug_only(signal_sets_initialized = true);\n\n}\n\n// These are signals that are unblocked while a thread is running Java.\n// (For some reason, they get blocked by default.)\nsigset_t* os::Bsd::unblocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &unblocked_sigs;\n}\n\n// These are the signals that are blocked while a (non-VM) thread is\n// running Java. Only the VM thread handles these signals.\nsigset_t* os::Bsd::vm_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &vm_sigs;\n}\n\n// These are signals that are blocked during cond_wait to allow debugger in\nsigset_t* os::Bsd::allowdebug_blocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &allowdebug_blocked_sigs;\n}\n\nvoid os::Bsd::hotspot_sigmask(Thread* thread) {\n\n  //Save caller's signal mask before setting VM signal mask\n  sigset_t caller_sigmask;\n  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n\n  OSThread* osthread = thread->osthread();\n  osthread->set_caller_sigmask(caller_sigmask);\n\n  pthread_sigmask(SIG_UNBLOCK, os::Bsd::unblocked_signals(), NULL);\n\n  if (!ReduceSignalUsage) {\n    if (thread->is_VM_thread()) {\n      // Only the VM thread handles BREAK_SIGNAL ...\n      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n    } else {\n      // ... all other threads block BREAK_SIGNAL\n      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n    }\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n// create new thread\n\n// check if it's safe to start a new thread\nstatic bool _thread_safety_check(Thread* thread) {\n  return true;\n}\n\n#ifdef __APPLE__\n// library handle for calling objc_registerThreadWithCollector()\n// without static linking to the libobjc library\n#define OBJC_LIB \"/usr/lib/libobjc.dylib\"\n#define OBJC_GCREGISTER \"objc_registerThreadWithCollector\"\ntypedef void (*objc_registerThreadWithCollector_t)();\nextern \"C\" objc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction;\nobjc_registerThreadWithCollector_t objc_registerThreadWithCollectorFunction = NULL;\n#endif\n\n#ifdef __APPLE__\nstatic uint64_t locate_unique_thread_id(mach_port_t mach_thread_port) {\n  // Additional thread_id used to correlate threads in SA\n  thread_identifier_info_data_t     m_ident_info;\n  mach_msg_type_number_t            count = THREAD_IDENTIFIER_INFO_COUNT;\n\n  thread_info(mach_thread_port, THREAD_IDENTIFIER_INFO,\n              (thread_info_t) &m_ident_info, &count);\n\n  return m_ident_info.thread_id;\n}\n#endif\n\n// Thread start routine for all newly created threads\nstatic void *java_start(Thread *thread) {\n  // Try to randomize the cache line index of hot stack frames.\n  // This helps when threads of the same stack traces evict each other's\n  // cache lines. The threads can be either from the same JVM instance, or\n  // from different JVM instances. The benefit is especially true for\n  // processors with hyperthreading technology.\n  static int counter = 0;\n  int pid = os::current_process_id();\n  alloca(((pid ^ counter++) & 7) * 128);\n\n  ThreadLocalStorage::set_thread(thread);\n\n  OSThread* osthread = thread->osthread();\n  Monitor* sync = osthread->startThread_lock();\n\n  // non floating stack BsdThreads needs extra check, see above\n  if (!_thread_safety_check(thread)) {\n    // notify parent thread\n    MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);\n    osthread->set_state(ZOMBIE);\n    sync->notify_all();\n    return NULL;\n  }\n\n  osthread->set_thread_id(os::Bsd::gettid());\n\n#ifdef __APPLE__\n  uint64_t unique_thread_id = locate_unique_thread_id(osthread->thread_id());\n  guarantee(unique_thread_id != 0, \"unique thread id was not found\");\n  osthread->set_unique_thread_id(unique_thread_id);\n#endif\n  // initialize signal mask for this thread\n  os::Bsd::hotspot_sigmask(thread);\n\n  // initialize floating point control register\n  os::Bsd::init_thread_fpu_state();\n\n#ifdef __APPLE__\n  // register thread with objc gc\n  if (objc_registerThreadWithCollectorFunction != NULL) {\n    objc_registerThreadWithCollectorFunction();\n  }\n#endif\n\n  // handshaking with parent thread\n  {\n    MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);\n\n    // notify parent thread\n    osthread->set_state(INITIALIZED);\n    sync->notify_all();\n\n    // wait until os::start_thread()\n    while (osthread->get_state() == INITIALIZED) {\n      sync->wait(Mutex::_no_safepoint_check_flag);\n    }\n  }\n\n  // call one more level start routine\n  thread->run();\n\n  return 0;\n}\n\nbool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) {\n  assert(thread->osthread() == NULL, \"caller responsible\");\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // set the correct thread state\n  osthread->set_thread_type(thr_type);\n\n  // Initial state is ALLOCATED but not INITIALIZED\n  osthread->set_state(ALLOCATED);\n\n  thread->set_osthread(osthread);\n\n  // init thread attributes\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n  // stack size\n  if (os::Bsd::supports_variable_stack_size()) {\n    // calculate stack size if it's not specified by caller\n    if (stack_size == 0) {\n      stack_size = os::Bsd::default_stack_size(thr_type);\n\n      switch (thr_type) {\n      case os::java_thread:\n        // Java threads use ThreadStackSize which default value can be\n        // changed with the flag -Xss\n        assert (JavaThread::stack_size_at_create() > 0, \"this should be set\");\n        stack_size = JavaThread::stack_size_at_create();\n        break;\n      case os::compiler_thread:\n        if (CompilerThreadStackSize > 0) {\n          stack_size = (size_t)(CompilerThreadStackSize * K);\n          break;\n        } // else fall through:\n          // use VMThreadStackSize if CompilerThreadStackSize is not defined\n      case os::vm_thread:\n      case os::pgc_thread:\n      case os::cgc_thread:\n      case os::watcher_thread:\n        if (VMThreadStackSize > 0) stack_size = (size_t)(VMThreadStackSize * K);\n        break;\n      }\n    }\n\n    stack_size = MAX2(stack_size, os::Bsd::min_stack_allowed);\n    pthread_attr_setstacksize(&attr, stack_size);\n  } else {\n    // let pthread_create() pick the default value.\n  }\n\n  ThreadState state;\n\n  {\n    pthread_t tid;\n    int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);\n\n    pthread_attr_destroy(&attr);\n\n    if (ret != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode)) {\n        perror(\"pthread_create()\");\n      }\n      // Need to clean up stuff we've allocated so far\n      thread->set_osthread(NULL);\n      delete osthread;\n      return false;\n    }\n\n    // Store pthread info into the OSThread\n    osthread->set_pthread_id(tid);\n\n    // Wait until child thread is either initialized or aborted\n    {\n      Monitor* sync_with_child = osthread->startThread_lock();\n      MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);\n      while ((state = osthread->get_state()) == ALLOCATED) {\n        sync_with_child->wait(Mutex::_no_safepoint_check_flag);\n      }\n    }\n\n  }\n\n  // Aborted due to thread limit being reached\n  if (state == ZOMBIE) {\n      thread->set_osthread(NULL);\n      delete osthread;\n      return false;\n  }\n\n  // The thread is returned suspended (in state INITIALIZED),\n  // and is started higher up in the call chain\n  assert(state == INITIALIZED, \"race condition\");\n  return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// attach existing thread\n\n// bootstrap the main thread\nbool os::create_main_thread(JavaThread* thread) {\n  assert(os::Bsd::_main_thread == pthread_self(), \"should be called inside main thread\");\n  return create_attached_thread(thread);\n}\n\nbool os::create_attached_thread(JavaThread* thread) {\n#ifdef ASSERT\n    thread->verify_not_published();\n#endif\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n\n  if (osthread == NULL) {\n    return false;\n  }\n\n  osthread->set_thread_id(os::Bsd::gettid());\n\n  // Store pthread info into the OSThread\n#ifdef __APPLE__\n  uint64_t unique_thread_id = locate_unique_thread_id(osthread->thread_id());\n  guarantee(unique_thread_id != 0, \"just checking\");\n  osthread->set_unique_thread_id(unique_thread_id);\n#endif\n  osthread->set_pthread_id(::pthread_self());\n\n  // initialize floating point control register\n  os::Bsd::init_thread_fpu_state();\n\n  // Initial thread state is RUNNABLE\n  osthread->set_state(RUNNABLE);\n\n  thread->set_osthread(osthread);\n\n  // initialize signal mask for this thread\n  // and save the caller's signal mask\n  os::Bsd::hotspot_sigmask(thread);\n\n  return true;\n}\n\nvoid os::pd_start_thread(Thread* thread) {\n  OSThread * osthread = thread->osthread();\n  assert(osthread->get_state() != INITIALIZED, \"just checking\");\n  Monitor* sync_with_child = osthread->startThread_lock();\n  MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);\n  sync_with_child->notify();\n}\n\n// Free Bsd resources related to the OSThread\nvoid os::free_thread(OSThread* osthread) {\n  assert(osthread != NULL, \"osthread not set\");\n\n  if (Thread::current()->osthread() == osthread) {\n    // Restore caller's signal mask\n    sigset_t sigmask = osthread->caller_sigmask();\n    pthread_sigmask(SIG_SETMASK, &sigmask, NULL);\n   }\n\n  delete osthread;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// thread local storage\n\n// Restore the thread pointer if the destructor is called. This is in case\n// someone from JNI code sets up a destructor with pthread_key_create to run\n// detachCurrentThread on thread death. Unless we restore the thread pointer we\n// will hang or crash. When detachCurrentThread is called the key will be set\n// to null and we will not be called again. If detachCurrentThread is never\n// called we could loop forever depending on the pthread implementation.\nstatic void restore_thread_pointer(void* p) {\n  Thread* thread = (Thread*) p;\n  os::thread_local_storage_at_put(ThreadLocalStorage::thread_index(), thread);\n}\n\nint os::allocate_thread_local_storage() {\n  pthread_key_t key;\n  int rslt = pthread_key_create(&key, restore_thread_pointer);\n  assert(rslt == 0, \"cannot allocate thread local storage\");\n  return (int)key;\n}\n\n// Note: This is currently not used by VM, as we don't destroy TLS key\n// on VM exit.\nvoid os::free_thread_local_storage(int index) {\n  int rslt = pthread_key_delete((pthread_key_t)index);\n  assert(rslt == 0, \"invalid index\");\n}\n\nvoid os::thread_local_storage_at_put(int index, void* value) {\n  int rslt = pthread_setspecific((pthread_key_t)index, value);\n  assert(rslt == 0, \"pthread_setspecific failed\");\n}\n\nextern \"C\" Thread* get_thread() {\n  return ThreadLocalStorage::thread();\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n// time support\n\n// Time since start-up in seconds to a fine granularity.\n// Used by VMSelfDestructTimer and the MemProfiler.\ndouble os::elapsedTime() {\n\n  return ((double)os::elapsed_counter()) / os::elapsed_frequency();\n}\n\njlong os::elapsed_counter() {\n  return javaTimeNanos() - initial_time_count;\n}\n\njlong os::elapsed_frequency() {\n  return NANOSECS_PER_SEC; // nanosecond resolution\n}\n\nbool os::supports_vtime() { return true; }\nbool os::enable_vtime()   { return false; }\nbool os::vtime_enabled()  { return false; }\n\ndouble os::elapsedVTime() {\n  // better than nothing, but not much\n  return elapsedTime();\n}\n\njlong os::javaTimeMillis() {\n  timeval time;\n  int status = gettimeofday(&time, NULL);\n  assert(status != -1, \"bsd error\");\n  return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);\n}\n\n#ifndef __APPLE__\n#ifndef CLOCK_MONOTONIC\n#define CLOCK_MONOTONIC (1)\n#endif\n#endif\n\n#ifdef __APPLE__\nvoid os::Bsd::clock_init() {\n  mach_timebase_info(&_timebase_info);\n}\n#else\nvoid os::Bsd::clock_init() {\n  struct timespec res;\n  struct timespec tp;\n  if (::clock_getres(CLOCK_MONOTONIC, &res) == 0 &&\n      ::clock_gettime(CLOCK_MONOTONIC, &tp)  == 0) {\n    // yes, monotonic clock is supported\n    _clock_gettime = ::clock_gettime;\n  }\n}\n#endif\n\n\n#ifdef __APPLE__\n\njlong os::javaTimeNanos() {\n    const uint64_t tm = mach_absolute_time();\n    const uint64_t now = (tm * Bsd::_timebase_info.numer) / Bsd::_timebase_info.denom;\n    const uint64_t prev = Bsd::_max_abstime;\n    if (now <= prev) {\n      return prev;   // same or retrograde time;\n    }\n    const uint64_t obsv = Atomic::cmpxchg(now, (volatile jlong*)&Bsd::_max_abstime, prev);\n    assert(obsv >= prev, \"invariant\");   // Monotonicity\n    // If the CAS succeeded then we're done and return \"now\".\n    // If the CAS failed and the observed value \"obsv\" is >= now then\n    // we should return \"obsv\".  If the CAS failed and now > obsv > prv then\n    // some other thread raced this thread and installed a new value, in which case\n    // we could either (a) retry the entire operation, (b) retry trying to install now\n    // or (c) just return obsv.  We use (c).   No loop is required although in some cases\n    // we might discard a higher \"now\" value in deference to a slightly lower but freshly\n    // installed obsv value.   That's entirely benign -- it admits no new orderings compared\n    // to (a) or (b) -- and greatly reduces coherence traffic.\n    // We might also condition (c) on the magnitude of the delta between obsv and now.\n    // Avoiding excessive CAS operations to hot RW locations is critical.\n    // See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate\n    return (prev == obsv) ? now : obsv;\n}\n\n#else // __APPLE__\n\njlong os::javaTimeNanos() {\n  if (Bsd::supports_monotonic_clock()) {\n    struct timespec tp;\n    int status = Bsd::_clock_gettime(CLOCK_MONOTONIC, &tp);\n    assert(status == 0, \"gettime error\");\n    jlong result = jlong(tp.tv_sec) * (1000 * 1000 * 1000) + jlong(tp.tv_nsec);\n    return result;\n  } else {\n    timeval time;\n    int status = gettimeofday(&time, NULL);\n    assert(status != -1, \"bsd error\");\n    jlong usecs = jlong(time.tv_sec) * (1000 * 1000) + jlong(time.tv_usec);\n    return 1000 * usecs;\n  }\n}\n\n#endif // __APPLE__\n\nvoid os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n  if (Bsd::supports_monotonic_clock()) {\n    info_ptr->max_value = ALL_64_BITS;\n\n    // CLOCK_MONOTONIC - amount of time since some arbitrary point in the past\n    info_ptr->may_skip_backward = false;      // not subject to resetting or drifting\n    info_ptr->may_skip_forward = false;       // not subject to resetting or drifting\n  } else {\n    // gettimeofday - based on time in seconds since the Epoch thus does not wrap\n    info_ptr->max_value = ALL_64_BITS;\n\n    // gettimeofday is a real time clock so it skips\n    info_ptr->may_skip_backward = true;\n    info_ptr->may_skip_forward = true;\n  }\n\n  info_ptr->kind = JVMTI_TIMER_ELAPSED;                // elapsed not CPU time\n}\n\n// Return the real, user, and system times in seconds from an\n// arbitrary fixed point in the past.\nbool os::getTimesSecs(double* process_real_time,\n                      double* process_user_time,\n                      double* process_system_time) {\n  struct tms ticks;\n  clock_t real_ticks = times(&ticks);\n\n  if (real_ticks == (clock_t) (-1)) {\n    return false;\n  } else {\n    double ticks_per_second = (double) clock_tics_per_sec;\n    *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;\n    *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;\n    *process_real_time = ((double) real_ticks) / ticks_per_second;\n\n    return true;\n  }\n}\n\n\nchar * os::local_time_string(char *buf, size_t buflen) {\n  struct tm t;\n  time_t long_time;\n  time(&long_time);\n  localtime_r(&long_time, &t);\n  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n               t.tm_hour, t.tm_min, t.tm_sec);\n  return buf;\n}\n\nstruct tm* os::localtime_pd(const time_t* clock, struct tm*  res) {\n  return localtime_r(clock, res);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// runtime exit support\n\n// Note: os::shutdown() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::shutdown(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::shutdown() {\n\n  // allow PerfMemory to attempt cleanup of any persistent resources\n  perfMemory_exit();\n\n  // needs to remove object in file system\n  AttachListener::abort();\n\n  // flush buffered output, finish log files\n  ostream_abort();\n\n  // Check for abort hook\n  abort_hook_t abort_hook = Arguments::abort_hook();\n  if (abort_hook != NULL) {\n    abort_hook();\n  }\n\n}\n\n// Note: os::abort() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::abort(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::abort(bool dump_core) {\n  os::shutdown();\n  if (dump_core) {\n#ifndef PRODUCT\n    fdStream out(defaultStream::output_fd());\n    out.print_raw(\"Current thread is \");\n    char buf[16];\n    jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());\n    out.print_raw_cr(buf);\n    out.print_raw_cr(\"Dumping core ...\");\n#endif\n    ::abort(); // dump core\n  }\n\n  ::exit(1);\n}\n\n// Die immediately, no exit hook, no abort hook, no cleanup.\nvoid os::die() {\n  // _exit() on BsdThreads only kills current thread\n  ::abort();\n}\n\n// This method is a copy of JDK's sysGetLastErrorString\n// from src/solaris/hpi/src/system_md.c\n\nsize_t os::lasterror(char *buf, size_t len) {\n\n  if (errno == 0)  return 0;\n\n  const char *s = ::strerror(errno);\n  size_t n = ::strlen(s);\n  if (n >= len) {\n    n = len - 1;\n  }\n  ::strncpy(buf, s, n);\n  buf[n] = '\\0';\n  return n;\n}\n\n// Information of current thread in variety of formats\npid_t os::Bsd::gettid() {\n  int retval = -1;\n\n#ifdef __APPLE__ //XNU kernel\n  // despite the fact mach port is actually not a thread id use it\n  // instead of syscall(SYS_thread_selfid) as it certainly fits to u4\n  retval = ::pthread_mach_thread_np(::pthread_self());\n  guarantee(retval != 0, \"just checking\");\n  return retval;\n\n#else\n  #ifdef __FreeBSD__\n  retval = syscall(SYS_thr_self);\n  #else\n    #ifdef __OpenBSD__\n  retval = syscall(SYS_getthrid);\n    #else\n      #ifdef __NetBSD__\n  retval = (pid_t) syscall(SYS__lwp_self);\n      #endif\n    #endif\n  #endif\n#endif\n\n  if (retval == -1) {\n    return getpid();\n  }\n}\n\nintx os::current_thread_id() {\n#ifdef __APPLE__\n  return (intx)::pthread_mach_thread_np(::pthread_self());\n#else\n  return (intx)::pthread_self();\n#endif\n}\n\nint os::current_process_id() {\n\n  // Under the old bsd thread library, bsd gives each thread\n  // its own process id. Because of this each thread will return\n  // a different pid if this method were to return the result\n  // of getpid(2). Bsd provides no api that returns the pid\n  // of the launcher thread for the vm. This implementation\n  // returns a unique pid, the pid of the launcher thread\n  // that starts the vm 'process'.\n\n  // Under the NPTL, getpid() returns the same pid as the\n  // launcher thread rather than a unique pid per thread.\n  // Use gettid() if you want the old pre NPTL behaviour.\n\n  // if you are looking for the result of a call to getpid() that\n  // returns a unique pid for the calling thread, then look at the\n  // OSThread::thread_id() method in osThread_bsd.hpp file\n\n  return (int)(_initial_pid ? _initial_pid : getpid());\n}\n\n// DLL functions\n\n#define JNI_LIB_PREFIX \"lib\"\n#ifdef __APPLE__\n#define JNI_LIB_SUFFIX \".dylib\"\n#else\n#define JNI_LIB_SUFFIX \".so\"\n#endif\n\nconst char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }\n\n// This must be hard coded because it's the system's temporary\n// directory not the java application's temp directory, ala java.io.tmpdir.\n#ifdef __APPLE__\n// macosx has a secure per-user temporary directory\nchar temp_path_storage[PATH_MAX];\nconst char* os::get_temp_directory() {\n  static char *temp_path = NULL;\n  if (temp_path == NULL) {\n    int pathSize = confstr(_CS_DARWIN_USER_TEMP_DIR, temp_path_storage, PATH_MAX);\n    if (pathSize == 0 || pathSize > PATH_MAX) {\n      strlcpy(temp_path_storage, \"/tmp/\", sizeof(temp_path_storage));\n    }\n    temp_path = temp_path_storage;\n  }\n  return temp_path;\n}\n#else /* __APPLE__ */\nconst char* os::get_temp_directory() { return \"/tmp\"; }\n#endif /* __APPLE__ */\n\nstatic bool file_exists(const char* filename) {\n  struct stat statbuf;\n  if (filename == NULL || strlen(filename) == 0) {\n    return false;\n  }\n  return os::stat(filename, &statbuf) == 0;\n}\n\nbool os::dll_build_name(char* buffer, size_t buflen,\n                        const char* pname, const char* fname) {\n  bool retval = false;\n  // Copied from libhpi\n  const size_t pnamelen = pname ? strlen(pname) : 0;\n\n  // Return error on buffer overflow.\n  if (pnamelen + strlen(fname) + strlen(JNI_LIB_PREFIX) + strlen(JNI_LIB_SUFFIX) + 2 > buflen) {\n    return retval;\n  }\n\n  if (pnamelen == 0) {\n    snprintf(buffer, buflen, JNI_LIB_PREFIX \"%s\" JNI_LIB_SUFFIX, fname);\n    retval = true;\n  } else if (strchr(pname, *os::path_separator()) != NULL) {\n    int n;\n    char** pelements = split_path(pname, &n);\n    if (pelements == NULL) {\n      return false;\n    }\n    for (int i = 0 ; i < n ; i++) {\n      // Really shouldn't be NULL, but check can't hurt\n      if (pelements[i] == NULL || strlen(pelements[i]) == 0) {\n        continue; // skip the empty path values\n      }\n      snprintf(buffer, buflen, \"%s/\" JNI_LIB_PREFIX \"%s\" JNI_LIB_SUFFIX,\n          pelements[i], fname);\n      if (file_exists(buffer)) {\n        retval = true;\n        break;\n      }\n    }\n    // release the storage\n    for (int i = 0 ; i < n ; i++) {\n      if (pelements[i] != NULL) {\n        FREE_C_HEAP_ARRAY(char, pelements[i], mtInternal);\n      }\n    }\n    if (pelements != NULL) {\n      FREE_C_HEAP_ARRAY(char*, pelements, mtInternal);\n    }\n  } else {\n    snprintf(buffer, buflen, \"%s/\" JNI_LIB_PREFIX \"%s\" JNI_LIB_SUFFIX, pname, fname);\n    retval = true;\n  }\n  return retval;\n}\n\n// check if addr is inside libjvm.so\nbool os::address_is_in_vm(address addr) {\n  static address libjvm_base_addr;\n  Dl_info dlinfo;\n\n  if (libjvm_base_addr == NULL) {\n    if (dladdr(CAST_FROM_FN_PTR(void *, os::address_is_in_vm), &dlinfo) != 0) {\n      libjvm_base_addr = (address)dlinfo.dli_fbase;\n    }\n    assert(libjvm_base_addr !=NULL, \"Cannot obtain base address for libjvm\");\n  }\n\n  if (dladdr((void *)addr, &dlinfo) != 0) {\n    if (libjvm_base_addr == (address)dlinfo.dli_fbase) return true;\n  }\n\n  return false;\n}\n\n\n#define MACH_MAXSYMLEN 256\n\nbool os::dll_address_to_function_name(address addr, char *buf,\n                                      int buflen, int *offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n  char localbuf[MACH_MAXSYMLEN];\n\n  if (dladdr((void*)addr, &dlinfo) != 0) {\n    // see if we have a matching symbol\n    if (dlinfo.dli_saddr != NULL && dlinfo.dli_sname != NULL) {\n      if (!Decoder::demangle(dlinfo.dli_sname, buf, buflen)) {\n        jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_sname);\n      }\n      if (offset != NULL) *offset = addr - (address)dlinfo.dli_saddr;\n      return true;\n    }\n    // no matching symbol so try for just file info\n    if (dlinfo.dli_fname != NULL && dlinfo.dli_fbase != NULL) {\n      if (Decoder::decode((address)(addr - (address)dlinfo.dli_fbase),\n                          buf, buflen, offset, dlinfo.dli_fname)) {\n         return true;\n      }\n    }\n\n    // Handle non-dynamic manually:\n    if (dlinfo.dli_fbase != NULL &&\n        Decoder::decode(addr, localbuf, MACH_MAXSYMLEN, offset,\n                        dlinfo.dli_fbase)) {\n      if (!Decoder::demangle(localbuf, buf, buflen)) {\n        jio_snprintf(buf, buflen, \"%s\", localbuf);\n      }\n      return true;\n    }\n  }\n  buf[0] = '\\0';\n  if (offset != NULL) *offset = -1;\n  return false;\n}\n\n// ported from solaris version\nbool os::dll_address_to_library_name(address addr, char* buf,\n                                     int buflen, int* offset) {\n  // buf is not optional, but offset is optional\n  assert(buf != NULL, \"sanity check\");\n\n  Dl_info dlinfo;\n\n  if (dladdr((void*)addr, &dlinfo) != 0) {\n    if (dlinfo.dli_fname != NULL) {\n      jio_snprintf(buf, buflen, \"%s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL && offset != NULL) {\n      *offset = addr - (address)dlinfo.dli_fbase;\n    }\n    return true;\n  }\n\n  buf[0] = '\\0';\n  if (offset) *offset = -1;\n  return false;\n}\n\n// Loads .dll/.so and\n// in case of error it checks if .dll/.so was built for the\n// same architecture as Hotspot is running on\n\n#ifdef __APPLE__\nvoid * os::dll_load(const char *filename, char *ebuf, int ebuflen) {\n  void * result= ::dlopen(filename, RTLD_LAZY);\n  if (result != NULL) {\n    // Successful loading\n    return result;\n  }\n\n  // Read system error message into ebuf\n  ::strncpy(ebuf, ::dlerror(), ebuflen-1);\n  ebuf[ebuflen-1]='\\0';\n\n  return NULL;\n}\n#else\nvoid * os::dll_load(const char *filename, char *ebuf, int ebuflen)\n{\n  void * result= ::dlopen(filename, RTLD_LAZY);\n  if (result != NULL) {\n    // Successful loading\n    return result;\n  }\n\n  Elf32_Ehdr elf_head;\n\n  // Read system error message into ebuf\n  // It may or may not be overwritten below\n  ::strncpy(ebuf, ::dlerror(), ebuflen-1);\n  ebuf[ebuflen-1]='\\0';\n  int diag_msg_max_length=ebuflen-strlen(ebuf);\n  char* diag_msg_buf=ebuf+strlen(ebuf);\n\n  if (diag_msg_max_length==0) {\n    // No more space in ebuf for additional diagnostics message\n    return NULL;\n  }\n\n\n  int file_descriptor= ::open(filename, O_RDONLY | O_NONBLOCK);\n\n  if (file_descriptor < 0) {\n    // Can't open library, report dlerror() message\n    return NULL;\n  }\n\n  bool failed_to_read_elf_head=\n    (sizeof(elf_head)!=\n        (::read(file_descriptor, &elf_head,sizeof(elf_head)))) ;\n\n  ::close(file_descriptor);\n  if (failed_to_read_elf_head) {\n    // file i/o error - report dlerror() msg\n    return NULL;\n  }\n\n  typedef struct {\n    Elf32_Half  code;         // Actual value as defined in elf.h\n    Elf32_Half  compat_class; // Compatibility of archs at VM's sense\n    char        elf_class;    // 32 or 64 bit\n    char        endianess;    // MSB or LSB\n    char*       name;         // String representation\n  } arch_t;\n\n  #ifndef EM_486\n  #define EM_486          6               /* Intel 80486 */\n  #endif\n\n  #ifndef EM_MIPS_RS3_LE\n  #define EM_MIPS_RS3_LE  10              /* MIPS */\n  #endif\n\n  #ifndef EM_PPC64\n  #define EM_PPC64        21              /* PowerPC64 */\n  #endif\n\n  #ifndef EM_S390\n  #define EM_S390         22              /* IBM System/390 */\n  #endif\n\n  #ifndef EM_IA_64\n  #define EM_IA_64        50              /* HP/Intel IA-64 */\n  #endif\n\n  #ifndef EM_X86_64\n  #define EM_X86_64       62              /* AMD x86-64 */\n  #endif\n\n  static const arch_t arch_array[]={\n    {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)\"IA 32\"},\n    {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)\"IA 64\"},\n    {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)\"AMD 64\"},\n    {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)\"Sparc 32\"},\n    {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)\"Sparc v9 64\"},\n    {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)\"Power PC 32\"},\n    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)\"Power PC 64\"},\n    {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)\"ARM\"},\n    {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)\"IBM System/390\"},\n    {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)\"Alpha\"},\n    {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)\"MIPSel\"},\n    {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)\"MIPS\"},\n    {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)\"PARISC\"},\n    {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)\"M68k\"}\n  };\n\n  #if  (defined IA32)\n    static  Elf32_Half running_arch_code=EM_386;\n  #elif   (defined AMD64)\n    static  Elf32_Half running_arch_code=EM_X86_64;\n  #elif  (defined IA64)\n    static  Elf32_Half running_arch_code=EM_IA_64;\n  #elif  (defined __sparc) && (defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARCV9;\n  #elif  (defined __sparc) && (!defined _LP64)\n    static  Elf32_Half running_arch_code=EM_SPARC;\n  #elif  (defined __powerpc64__)\n    static  Elf32_Half running_arch_code=EM_PPC64;\n  #elif  (defined __powerpc__)\n    static  Elf32_Half running_arch_code=EM_PPC;\n  #elif  (defined ARM)\n    static  Elf32_Half running_arch_code=EM_ARM;\n  #elif  (defined S390)\n    static  Elf32_Half running_arch_code=EM_S390;\n  #elif  (defined ALPHA)\n    static  Elf32_Half running_arch_code=EM_ALPHA;\n  #elif  (defined MIPSEL)\n    static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;\n  #elif  (defined PARISC)\n    static  Elf32_Half running_arch_code=EM_PARISC;\n  #elif  (defined MIPS)\n    static  Elf32_Half running_arch_code=EM_MIPS;\n  #elif  (defined M68K)\n    static  Elf32_Half running_arch_code=EM_68K;\n  #else\n    #error Method os::dll_load requires that one of following is defined:\\\n         IA32, AMD64, IA64, __sparc, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K\n  #endif\n\n  // Identify compatability class for VM's architecture and library's architecture\n  // Obtain string descriptions for architectures\n\n  arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};\n  int running_arch_index=-1;\n\n  for (unsigned int i=0 ; i < ARRAY_SIZE(arch_array) ; i++ ) {\n    if (running_arch_code == arch_array[i].code) {\n      running_arch_index    = i;\n    }\n    if (lib_arch.code == arch_array[i].code) {\n      lib_arch.compat_class = arch_array[i].compat_class;\n      lib_arch.name         = arch_array[i].name;\n    }\n  }\n\n  assert(running_arch_index != -1,\n    \"Didn't find running architecture code (running_arch_code) in arch_array\");\n  if (running_arch_index == -1) {\n    // Even though running architecture detection failed\n    // we may still continue with reporting dlerror() message\n    return NULL;\n  }\n\n  if (lib_arch.endianess != arch_array[running_arch_index].endianess) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n    return NULL;\n  }\n\n#ifndef S390\n  if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {\n    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n    return NULL;\n  }\n#endif // !S390\n\n  if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {\n    if ( lib_arch.name!=NULL ) {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n        \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n        lib_arch.name, arch_array[running_arch_index].name);\n    } else {\n      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n      \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n        lib_arch.code,\n        arch_array[running_arch_index].name);\n    }\n  }\n\n  return NULL;\n}\n#endif /* !__APPLE__ */\n\nvoid* os::get_default_process_handle() {\n#ifdef __APPLE__\n  // MacOS X needs to use RTLD_FIRST instead of RTLD_LAZY\n  // to avoid finding unexpected symbols on second (or later)\n  // loads of a library.\n  return (void*)::dlopen(NULL, RTLD_FIRST);\n#else\n  return (void*)::dlopen(NULL, RTLD_LAZY);\n#endif\n}\n\n// XXX: Do we need a lock around this as per Linux?\nvoid* os::dll_lookup(void* handle, const char* name) {\n  return dlsym(handle, name);\n}\n\n\nstatic bool _print_ascii_file(const char* filename, outputStream* st) {\n  int fd = ::open(filename, O_RDONLY);\n  if (fd == -1) {\n     return false;\n  }\n\n  char buf[32];\n  int bytes;\n  while ((bytes = ::read(fd, buf, sizeof(buf))) > 0) {\n    st->print_raw(buf, bytes);\n  }\n\n  ::close(fd);\n\n  return true;\n}\n\nvoid os::print_dll_info(outputStream *st) {\n  st->print_cr(\"Dynamic libraries:\");\n#ifdef RTLD_DI_LINKMAP\n  Dl_info dli;\n  void *handle;\n  Link_map *map;\n  Link_map *p;\n\n  if (dladdr(CAST_FROM_FN_PTR(void *, os::print_dll_info), &dli) == 0 ||\n      dli.dli_fname == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n  handle = dlopen(dli.dli_fname, RTLD_LAZY);\n  if (handle == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n  dlinfo(handle, RTLD_DI_LINKMAP, &map);\n  if (map == NULL) {\n    st->print_cr(\"Error: Cannot print dynamic libraries.\");\n    return;\n  }\n\n  while (map->l_prev != NULL)\n    map = map->l_prev;\n\n  while (map != NULL) {\n    st->print_cr(PTR_FORMAT \" \\t%s\", map->l_addr, map->l_name);\n    map = map->l_next;\n  }\n\n  dlclose(handle);\n#elif defined(__APPLE__)\n  uint32_t count;\n  uint32_t i;\n\n  count = _dyld_image_count();\n  for (i = 1; i < count; i++) {\n    const char *name = _dyld_get_image_name(i);\n    intptr_t slide = _dyld_get_image_vmaddr_slide(i);\n    st->print_cr(PTR_FORMAT \" \\t%s\", slide, name);\n  }\n#else\n  st->print_cr(\"Error: Cannot print dynamic libraries.\");\n#endif\n}\n\nvoid os::print_os_info_brief(outputStream* st) {\n  st->print(\"Bsd\");\n\n  os::Posix::print_uname_info(st);\n}\n\nvoid os::print_os_info(outputStream* st) {\n  st->print(\"OS:\");\n  st->print(\"Bsd\");\n\n  os::Posix::print_uname_info(st);\n\n  os::Posix::print_rlimit_info(st);\n\n  os::Posix::print_load_average(st);\n}\n\nvoid os::pd_print_cpu_info(outputStream* st) {\n  // Nothing to do for now.\n}\n\nvoid os::print_memory_info(outputStream* st) {\n\n  st->print(\"Memory:\");\n  st->print(\" %dk page\", os::vm_page_size()>>10);\n\n  st->print(\", physical \" UINT64_FORMAT \"k\",\n            os::physical_memory() >> 10);\n  st->print(\"(\" UINT64_FORMAT \"k free)\",\n            os::available_memory() >> 10);\n  st->cr();\n\n  // meminfo\n  st->print(\"\\n/proc/meminfo:\\n\");\n  _print_ascii_file(\"/proc/meminfo\", st);\n  st->cr();\n}\n\nvoid os::print_siginfo(outputStream* st, void* siginfo) {\n  const siginfo_t* si = (const siginfo_t*)siginfo;\n\n  os::Posix::print_siginfo_brief(st, si);\n\n  if (si && (si->si_signo == SIGBUS || si->si_signo == SIGSEGV) &&\n      UseSharedSpaces) {\n    FileMapInfo* mapinfo = FileMapInfo::current_info();\n    if (mapinfo->is_in_shared_space(si->si_addr)) {\n      st->print(\"\\n\\nError accessing class data sharing archive.\"   \\\n                \" Mapped file inaccessible during execution, \"      \\\n                \" possible disk/network problem.\");\n    }\n  }\n  st->cr();\n}\n\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen);\n\nvoid os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n  st->print_cr(\"Signal Handlers:\");\n  print_signal_handler(st, SIGSEGV, buf, buflen);\n  print_signal_handler(st, SIGBUS , buf, buflen);\n  print_signal_handler(st, SIGFPE , buf, buflen);\n  print_signal_handler(st, SIGPIPE, buf, buflen);\n  print_signal_handler(st, SIGXFSZ, buf, buflen);\n  print_signal_handler(st, SIGILL , buf, buflen);\n  print_signal_handler(st, INTERRUPT_SIGNAL, buf, buflen);\n  print_signal_handler(st, SR_signum, buf, buflen);\n  print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n  print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n}\n\nstatic char saved_jvm_path[MAXPATHLEN] = {0};\n\n// Find the full path to the current module, libjvm\nvoid os::jvm_path(char *buf, jint buflen) {\n  // Error checking.\n  if (buflen < MAXPATHLEN) {\n    assert(false, \"must use a large-enough buffer\");\n    buf[0] = '\\0';\n    return;\n  }\n  // Lazy resolve the path to current module.\n  if (saved_jvm_path[0] != 0) {\n    strcpy(buf, saved_jvm_path);\n    return;\n  }\n\n  char dli_fname[MAXPATHLEN];\n  bool ret = dll_address_to_library_name(\n                CAST_FROM_FN_PTR(address, os::jvm_path),\n                dli_fname, sizeof(dli_fname), NULL);\n  assert(ret, \"cannot locate libjvm\");\n  char *rp = NULL;\n  if (ret && dli_fname[0] != '\\0') {\n    rp = realpath(dli_fname, buf);\n  }\n  if (rp == NULL)\n    return;\n\n  if (Arguments::created_by_gamma_launcher()) {\n    // Support for the gamma launcher.  Typical value for buf is\n    // \"<JAVA_HOME>/jre/lib/<arch>/<vmtype>/libjvm\".  If \"/jre/lib/\" appears at\n    // the right place in the string, then assume we are installed in a JDK and\n    // we're done.  Otherwise, check for a JAVA_HOME environment variable and\n    // construct a path to the JVM being overridden.\n\n    const char *p = buf + strlen(buf) - 1;\n    for (int count = 0; p > buf && count < 5; ++count) {\n      for (--p; p > buf && *p != '/'; --p)\n        /* empty */ ;\n    }\n\n    if (strncmp(p, \"/jre/lib/\", 9) != 0) {\n      // Look for JAVA_HOME in the environment.\n      char* java_home_var = ::getenv(\"JAVA_HOME\");\n      if (java_home_var != NULL && java_home_var[0] != 0) {\n        char* jrelib_p;\n        int len;\n\n        // Check the current module name \"libjvm\"\n        p = strrchr(buf, '/');\n        assert(strstr(p, \"/libjvm\") == p, \"invalid library name\");\n\n        rp = realpath(java_home_var, buf);\n        if (rp == NULL)\n          return;\n\n        // determine if this is a legacy image or modules image\n        // modules image doesn't have \"jre\" subdirectory\n        len = strlen(buf);\n        assert(len < buflen, \"Ran out of buffer space\");\n        jrelib_p = buf + len;\n\n        // Add the appropriate library subdir\n        snprintf(jrelib_p, buflen-len, \"/jre/lib\");\n        if (0 != access(buf, F_OK)) {\n          snprintf(jrelib_p, buflen-len, \"/lib\");\n        }\n\n        // Add the appropriate client or server subdir\n        len = strlen(buf);\n        jrelib_p = buf + len;\n        snprintf(jrelib_p, buflen-len, \"/%s\", COMPILER_VARIANT);\n        if (0 != access(buf, F_OK)) {\n          snprintf(jrelib_p, buflen-len, \"\");\n        }\n\n        // If the path exists within JAVA_HOME, add the JVM library name\n        // to complete the path to JVM being overridden.  Otherwise fallback\n        // to the path to the current library.\n        if (0 == access(buf, F_OK)) {\n          // Use current module name \"libjvm\"\n          len = strlen(buf);\n          snprintf(buf + len, buflen-len, \"/libjvm%s\", JNI_LIB_SUFFIX);\n        } else {\n          // Fall back to path of current library\n          rp = realpath(dli_fname, buf);\n          if (rp == NULL)\n            return;\n        }\n      }\n    }\n  }\n\n  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n}\n\nvoid os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n  // no prefix required, not even \"_\"\n}\n\nvoid os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n  // no suffix required\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// sun.misc.Signal support\n\nstatic volatile jint sigint_count = 0;\n\nstatic void\nUserHandler(int sig, void *siginfo, void *context) {\n  // 4511530 - sem_post is serialized and handled by the manager thread. When\n  // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We\n  // don't want to flood the manager thread with sem_post requests.\n  if (sig == SIGINT && Atomic::add(1, &sigint_count) > 1)\n      return;\n\n  // Ctrl-C is pressed during error reporting, likely because the error\n  // handler fails to abort. Let VM die immediately.\n  if (sig == SIGINT && is_error_reported()) {\n     os::die();\n  }\n\n  os::signal_notify(sig);\n}\n\nvoid* os::user_handler() {\n  return CAST_FROM_FN_PTR(void*, UserHandler);\n}\n\nextern \"C\" {\n  typedef void (*sa_handler_t)(int);\n  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n}\n\nvoid* os::signal(int signal_number, void* handler) {\n  struct sigaction sigAct, oldSigAct;\n\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n\n  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n    // -1 means registration failed\n    return (void *)-1;\n  }\n\n  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n}\n\nvoid os::signal_raise(int signal_number) {\n  ::raise(signal_number);\n}\n\n/*\n * The following code is moved from os.cpp for making this\n * code platform specific, which it is by its very nature.\n */\n\n// Will be modified when max signal is changed to be dynamic\nint os::sigexitnum_pd() {\n  return NSIG;\n}\n\n// a counter for each possible signal value\nstatic volatile jint pending_signals[NSIG+1] = { 0 };\n\n// Bsd(POSIX) specific hand shaking semaphore.\n#ifdef __APPLE__\ntypedef semaphore_t os_semaphore_t;\n#define SEM_INIT(sem, value)    semaphore_create(mach_task_self(), &sem, SYNC_POLICY_FIFO, value)\n#define SEM_WAIT(sem)           semaphore_wait(sem)\n#define SEM_POST(sem)           semaphore_signal(sem)\n#define SEM_DESTROY(sem)        semaphore_destroy(mach_task_self(), sem)\n#else\ntypedef sem_t os_semaphore_t;\n#define SEM_INIT(sem, value)    sem_init(&sem, 0, value)\n#define SEM_WAIT(sem)           sem_wait(&sem)\n#define SEM_POST(sem)           sem_post(&sem)\n#define SEM_DESTROY(sem)        sem_destroy(&sem)\n#endif\n\nclass Semaphore : public StackObj {\n  public:\n    Semaphore();\n    ~Semaphore();\n    void signal();\n    void wait();\n    bool trywait();\n    bool timedwait(unsigned int sec, int nsec);\n  private:\n    jlong currenttime() const;\n    os_semaphore_t _semaphore;\n};\n\nSemaphore::Semaphore() : _semaphore(0) {\n  SEM_INIT(_semaphore, 0);\n}\n\nSemaphore::~Semaphore() {\n  SEM_DESTROY(_semaphore);\n}\n\nvoid Semaphore::signal() {\n  SEM_POST(_semaphore);\n}\n\nvoid Semaphore::wait() {\n  SEM_WAIT(_semaphore);\n}\n\njlong Semaphore::currenttime() const {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (tv.tv_sec * NANOSECS_PER_SEC) + (tv.tv_usec * 1000);\n}\n\n#ifdef __APPLE__\nbool Semaphore::trywait() {\n  return timedwait(0, 0);\n}\n\nbool Semaphore::timedwait(unsigned int sec, int nsec) {\n  kern_return_t kr = KERN_ABORTED;\n  mach_timespec_t waitspec;\n  waitspec.tv_sec = sec;\n  waitspec.tv_nsec = nsec;\n\n  jlong starttime = currenttime();\n\n  kr = semaphore_timedwait(_semaphore, waitspec);\n  while (kr == KERN_ABORTED) {\n    jlong totalwait = (sec * NANOSECS_PER_SEC) + nsec;\n\n    jlong current = currenttime();\n    jlong passedtime = current - starttime;\n\n    if (passedtime >= totalwait) {\n      waitspec.tv_sec = 0;\n      waitspec.tv_nsec = 0;\n    } else {\n      jlong waittime = totalwait - (current - starttime);\n      waitspec.tv_sec = waittime / NANOSECS_PER_SEC;\n      waitspec.tv_nsec = waittime % NANOSECS_PER_SEC;\n    }\n\n    kr = semaphore_timedwait(_semaphore, waitspec);\n  }\n\n  return kr == KERN_SUCCESS;\n}\n\n#else\n\nbool Semaphore::trywait() {\n  return sem_trywait(&_semaphore) == 0;\n}\n\nbool Semaphore::timedwait(unsigned int sec, int nsec) {\n  struct timespec ts;\n  unpackTime(&ts, false, (sec * NANOSECS_PER_SEC) + nsec);\n\n  while (1) {\n    int result = sem_timedwait(&_semaphore, &ts);\n    if (result == 0) {\n      return true;\n    } else if (errno == EINTR) {\n      continue;\n    } else if (errno == ETIMEDOUT) {\n      return false;\n    } else {\n      return false;\n    }\n  }\n}\n\n#endif // __APPLE__\n\nstatic os_semaphore_t sig_sem;\nstatic Semaphore sr_semaphore;\n\nvoid os::signal_init_pd() {\n  // Initialize signal structures\n  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n\n  // Initialize signal semaphore\n  ::SEM_INIT(sig_sem, 0);\n}\n\nvoid os::signal_notify(int sig) {\n  Atomic::inc(&pending_signals[sig]);\n  ::SEM_POST(sig_sem);\n}\n\nstatic int check_pending_signals(bool wait) {\n  Atomic::store(0, &sigint_count);\n  for (;;) {\n    for (int i = 0; i < NSIG + 1; i++) {\n      jint n = pending_signals[i];\n      if (n > 0 && n == Atomic::cmpxchg(n - 1, &pending_signals[i], n)) {\n        return i;\n      }\n    }\n    if (!wait) {\n      return -1;\n    }\n    JavaThread *thread = JavaThread::current();\n    ThreadBlockInVM tbivm(thread);\n\n    bool threadIsSuspended;\n    do {\n      thread->set_suspend_equivalent();\n      // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n      ::SEM_WAIT(sig_sem);\n\n      // were we externally suspended while we were waiting?\n      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n      if (threadIsSuspended) {\n        //\n        // The semaphore has been incremented, but while we were waiting\n        // another thread suspended us. We don't want to continue running\n        // while suspended because that would surprise the thread that\n        // suspended us.\n        //\n        ::SEM_POST(sig_sem);\n\n        thread->java_suspend_self();\n      }\n    } while (threadIsSuspended);\n  }\n}\n\nint os::signal_lookup() {\n  return check_pending_signals(false);\n}\n\nint os::signal_wait() {\n  return check_pending_signals(true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Virtual Memory\n\nint os::vm_page_size() {\n  // Seems redundant as all get out\n  assert(os::Bsd::page_size() != -1, \"must call os::init\");\n  return os::Bsd::page_size();\n}\n\n// Solaris allocates memory by pages.\nint os::vm_allocation_granularity() {\n  assert(os::Bsd::page_size() != -1, \"must call os::init\");\n  return os::Bsd::page_size();\n}\n\n// Rationale behind this function:\n//  current (Mon Apr 25 20:12:18 MSD 2005) oprofile drops samples without executable\n//  mapping for address (see lookup_dcookie() in the kernel module), thus we cannot get\n//  samples for JITted code. Here we create private executable mapping over the code cache\n//  and then we can use standard (well, almost, as mapping can change) way to provide\n//  info for the reporting script by storing timestamp and location of symbol\nvoid bsd_wrap_code(char* base, size_t size) {\n  static volatile jint cnt = 0;\n\n  if (!UseOprofile) {\n    return;\n  }\n\n  char buf[PATH_MAX + 1];\n  int num = Atomic::add(1, &cnt);\n\n  snprintf(buf, PATH_MAX + 1, \"%s/hs-vm-%d-%d\",\n           os::get_temp_directory(), os::current_process_id(), num);\n  unlink(buf);\n\n  int fd = ::open(buf, O_CREAT | O_RDWR, S_IRWXU);\n\n  if (fd != -1) {\n    off_t rv = ::lseek(fd, size-2, SEEK_SET);\n    if (rv != (off_t)-1) {\n      if (::write(fd, \"\", 1) == 1) {\n        mmap(base, size,\n             PROT_READ|PROT_WRITE|PROT_EXEC,\n             MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE, fd, 0);\n      }\n    }\n    ::close(fd);\n    unlink(buf);\n  }\n}\n\nstatic void warn_fail_commit_memory(char* addr, size_t size, bool exec,\n                                    int err) {\n  warning(\"INFO: os::commit_memory(\" PTR_FORMAT \", \" SIZE_FORMAT\n          \", %d) failed; error='%s' (errno=%d)\", addr, size, exec,\n          strerror(err), err);\n}\n\n// NOTE: Bsd kernel does not really reserve the pages for us.\n//       All it does is to check if there are enough free pages\n//       left at the time of mmap(). This could be a potential\n//       problem.\nbool os::pd_commit_memory(char* addr, size_t size, bool exec) {\n  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n#ifdef __OpenBSD__\n  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD\n  if (::mprotect(addr, size, prot) == 0) {\n    return true;\n  }\n#else\n  uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,\n                                   MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n  if (res != (uintptr_t) MAP_FAILED) {\n    return true;\n  }\n#endif\n\n  // Warn about any commit errors we see in non-product builds just\n  // in case mmap() doesn't work as described on the man page.\n  NOT_PRODUCT(warn_fail_commit_memory(addr, size, exec, errno);)\n\n  return false;\n}\n\nbool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,\n                       bool exec) {\n  // alignment_hint is ignored on this OS\n  return pd_commit_memory(addr, size, exec);\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  if (!pd_commit_memory(addr, size, exec)) {\n    // add extra info in product mode for vm_exit_out_of_memory():\n    PRODUCT_ONLY(warn_fail_commit_memory(addr, size, exec, errno);)\n    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, mesg);\n  }\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size,\n                                  size_t alignment_hint, bool exec,\n                                  const char* mesg) {\n  // alignment_hint is ignored on this OS\n  pd_commit_memory_or_exit(addr, size, exec, mesg);\n}\n\nvoid os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {\n}\n\nvoid os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n  ::madvise(addr, bytes, MADV_DONTNEED);\n}\n\nvoid os::numa_make_global(char *addr, size_t bytes) {\n}\n\nvoid os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {\n}\n\nbool os::numa_topology_changed()   { return false; }\n\nsize_t os::numa_get_groups_num() {\n  return 1;\n}\n\nint os::numa_get_group_id() {\n  return 0;\n}\n\nsize_t os::numa_get_leaf_groups(int *ids, size_t size) {\n  if (size > 0) {\n    ids[0] = 0;\n    return 1;\n  }\n  return 0;\n}\n\nbool os::get_page_info(char *start, page_info* info) {\n  return false;\n}\n\nchar *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {\n  return end;\n}\n\n\nbool os::pd_uncommit_memory(char* addr, size_t size) {\n#ifdef __OpenBSD__\n  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD\n  return ::mprotect(addr, size, PROT_NONE) == 0;\n#else\n  uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,\n                MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);\n  return res  != (uintptr_t) MAP_FAILED;\n#endif\n}\n\nbool os::pd_create_stack_guard_pages(char* addr, size_t size) {\n  return os::commit_memory(addr, size, !ExecMem);\n}\n\n// If this is a growable mapping, remove the guard pages entirely by\n// munmap()ping them.  If not, just call uncommit_memory().\nbool os::remove_stack_guard_pages(char* addr, size_t size) {\n  return os::uncommit_memory(addr, size);\n}\n\nstatic address _highest_vm_reserved_address = NULL;\n\n// If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory\n// at 'requested_addr'. If there are existing memory mappings at the same\n// location, however, they will be overwritten. If 'fixed' is false,\n// 'requested_addr' is only treated as a hint, the return value may or\n// may not start from the requested address. Unlike Bsd mmap(), this\n// function returns NULL to indicate failure.\nstatic char* anon_mmap(char* requested_addr, size_t bytes, bool fixed) {\n  char * addr;\n  int flags;\n\n  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n  if (fixed) {\n    assert((uintptr_t)requested_addr % os::Bsd::page_size() == 0, \"unaligned address\");\n    flags |= MAP_FIXED;\n  }\n\n  // Map reserved/uncommitted pages PROT_NONE so we fail early if we\n  // touch an uncommitted page. Otherwise, the read/write might\n  // succeed if we have enough swap space to back the physical page.\n  addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,\n                       flags, -1, 0);\n\n  if (addr != MAP_FAILED) {\n    // anon_mmap() should only get called during VM initialization,\n    // don't need lock (actually we can skip locking even it can be called\n    // from multiple threads, because _highest_vm_reserved_address is just a\n    // hint about the upper limit of non-stack memory regions.)\n    if ((address)addr + bytes > _highest_vm_reserved_address) {\n      _highest_vm_reserved_address = (address)addr + bytes;\n    }\n  }\n\n  return addr == MAP_FAILED ? NULL : addr;\n}\n\n// Don't update _highest_vm_reserved_address, because there might be memory\n// regions above addr + size. If so, releasing a memory region only creates\n// a hole in the address space, it doesn't help prevent heap-stack collision.\n//\nstatic int anon_munmap(char * addr, size_t size) {\n  return ::munmap(addr, size) == 0;\n}\n\nchar* os::pd_reserve_memory(size_t bytes, char* requested_addr,\n                         size_t alignment_hint) {\n  return anon_mmap(requested_addr, bytes, (requested_addr != NULL));\n}\n\nbool os::pd_release_memory(char* addr, size_t size) {\n  return anon_munmap(addr, size);\n}\n\nstatic bool bsd_mprotect(char* addr, size_t size, int prot) {\n  // Bsd wants the mprotect address argument to be page aligned.\n  char* bottom = (char*)align_size_down((intptr_t)addr, os::Bsd::page_size());\n\n  // According to SUSv3, mprotect() should only be used with mappings\n  // established by mmap(), and mmap() always maps whole pages. Unaligned\n  // 'addr' likely indicates problem in the VM (e.g. trying to change\n  // protection of malloc'ed or statically allocated memory). Check the\n  // caller if you hit this assert.\n  assert(addr == bottom, \"sanity check\");\n\n  size = align_size_up(pointer_delta(addr, bottom, 1) + size, os::Bsd::page_size());\n  return ::mprotect(bottom, size, prot) == 0;\n}\n\n// Set protections specified\nbool os::protect_memory(char* addr, size_t bytes, ProtType prot,\n                        bool is_committed) {\n  unsigned int p = 0;\n  switch (prot) {\n  case MEM_PROT_NONE: p = PROT_NONE; break;\n  case MEM_PROT_READ: p = PROT_READ; break;\n  case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;\n  case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;\n  default:\n    ShouldNotReachHere();\n  }\n  // is_committed is unused.\n  return bsd_mprotect(addr, bytes, p);\n}\n\nbool os::guard_memory(char* addr, size_t size) {\n  return bsd_mprotect(addr, size, PROT_NONE);\n}\n\nbool os::unguard_memory(char* addr, size_t size) {\n  return bsd_mprotect(addr, size, PROT_READ|PROT_WRITE);\n}\n\nbool os::Bsd::hugetlbfs_sanity_check(bool warn, size_t page_size) {\n  return false;\n}\n\n// Large page support\n\nstatic size_t _large_page_size = 0;\n\nvoid os::large_page_init() {\n}\n\n\nchar* os::reserve_memory_special(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  fatal(\"This code is not used or maintained.\");\n\n  // \"exec\" is passed in but not used.  Creating the shared image for\n  // the code cache doesn't have an SHM_X executable permission to check.\n  assert(UseLargePages && UseSHM, \"only for SHM large pages\");\n\n  key_t key = IPC_PRIVATE;\n  char *addr;\n\n  bool warn_on_failure = UseLargePages &&\n                        (!FLAG_IS_DEFAULT(UseLargePages) ||\n                         !FLAG_IS_DEFAULT(LargePageSizeInBytes)\n                        );\n\n  // Create a large shared memory region to attach to based on size.\n  // Currently, size is the total size of the heap\n  int shmid = shmget(key, bytes, IPC_CREAT|SHM_R|SHM_W);\n  if (shmid == -1) {\n     // Possible reasons for shmget failure:\n     // 1. shmmax is too small for Java heap.\n     //    > check shmmax value: cat /proc/sys/kernel/shmmax\n     //    > increase shmmax value: echo \"0xffffffff\" > /proc/sys/kernel/shmmax\n     // 2. not enough large page memory.\n     //    > check available large pages: cat /proc/meminfo\n     //    > increase amount of large pages:\n     //          echo new_value > /proc/sys/vm/nr_hugepages\n     //      Note 1: different Bsd may use different name for this property,\n     //            e.g. on Redhat AS-3 it is \"hugetlb_pool\".\n     //      Note 2: it's possible there's enough physical memory available but\n     //            they are so fragmented after a long run that they can't\n     //            coalesce into large pages. Try to reserve large pages when\n     //            the system is still \"fresh\".\n     if (warn_on_failure) {\n       warning(\"Failed to reserve shared memory (errno = %d).\", errno);\n     }\n     return NULL;\n  }\n\n  // attach to the region\n  addr = (char*)shmat(shmid, req_addr, 0);\n  int err = errno;\n\n  // Remove shmid. If shmat() is successful, the actual shared memory segment\n  // will be deleted when it's detached by shmdt() or when the process\n  // terminates. If shmat() is not successful this will remove the shared\n  // segment immediately.\n  shmctl(shmid, IPC_RMID, NULL);\n\n  if ((intptr_t)addr == -1) {\n     if (warn_on_failure) {\n       warning(\"Failed to attach shared memory (errno = %d).\", err);\n     }\n     return NULL;\n  }\n\n  // The memory is committed\n  MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);\n\n  return addr;\n}\n\nbool os::release_memory_special(char* base, size_t bytes) {\n  if (MemTracker::tracking_level() > NMT_minimal) {\n    Tracker tkr = MemTracker::get_virtual_memory_release_tracker();\n    // detaching the SHM segment will also delete it, see reserve_memory_special()\n    int rslt = shmdt(base);\n    if (rslt == 0) {\n      tkr.record((address)base, bytes);\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return shmdt(base) == 0;\n  }\n}\n\nsize_t os::large_page_size() {\n  return _large_page_size;\n}\n\n// HugeTLBFS allows application to commit large page memory on demand;\n// with SysV SHM the entire memory region must be allocated as shared\n// memory.\nbool os::can_commit_large_page_memory() {\n  return UseHugeTLBFS;\n}\n\nbool os::can_execute_large_page_memory() {\n  return UseHugeTLBFS;\n}\n\n// Reserve memory at an arbitrary address, only if that area is\n// available (and not reserved for something else).\n\nchar* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {\n  const int max_tries = 10;\n  char* base[max_tries];\n  size_t size[max_tries];\n  const size_t gap = 0x000000;\n\n  // Assert only that the size is a multiple of the page size, since\n  // that's all that mmap requires, and since that's all we really know\n  // about at this low abstraction level.  If we need higher alignment,\n  // we can either pass an alignment to this method or verify alignment\n  // in one of the methods further up the call chain.  See bug 5044738.\n  assert(bytes % os::vm_page_size() == 0, \"reserving unexpected size block\");\n\n  // Repeatedly allocate blocks until the block is allocated at the\n  // right spot. Give up after max_tries. Note that reserve_memory() will\n  // automatically update _highest_vm_reserved_address if the call is\n  // successful. The variable tracks the highest memory address every reserved\n  // by JVM. It is used to detect heap-stack collision if running with\n  // fixed-stack BsdThreads. Because here we may attempt to reserve more\n  // space than needed, it could confuse the collision detecting code. To\n  // solve the problem, save current _highest_vm_reserved_address and\n  // calculate the correct value before return.\n  address old_highest = _highest_vm_reserved_address;\n\n  // Bsd mmap allows caller to pass an address as hint; give it a try first,\n  // if kernel honors the hint then we can return immediately.\n  char * addr = anon_mmap(requested_addr, bytes, false);\n  if (addr == requested_addr) {\n     return requested_addr;\n  }\n\n  if (addr != NULL) {\n     // mmap() is successful but it fails to reserve at the requested address\n     anon_munmap(addr, bytes);\n  }\n\n  int i;\n  for (i = 0; i < max_tries; ++i) {\n    base[i] = reserve_memory(bytes);\n\n    if (base[i] != NULL) {\n      // Is this the block we wanted?\n      if (base[i] == requested_addr) {\n        size[i] = bytes;\n        break;\n      }\n\n      // Does this overlap the block we wanted? Give back the overlapped\n      // parts and try again.\n\n      size_t top_overlap = requested_addr + (bytes + gap) - base[i];\n      if (top_overlap >= 0 && top_overlap < bytes) {\n        unmap_memory(base[i], top_overlap);\n        base[i] += top_overlap;\n        size[i] = bytes - top_overlap;\n      } else {\n        size_t bottom_overlap = base[i] + bytes - requested_addr;\n        if (bottom_overlap >= 0 && bottom_overlap < bytes) {\n          unmap_memory(requested_addr, bottom_overlap);\n          size[i] = bytes - bottom_overlap;\n        } else {\n          size[i] = bytes;\n        }\n      }\n    }\n  }\n\n  // Give back the unused reserved pieces.\n\n  for (int j = 0; j < i; ++j) {\n    if (base[j] != NULL) {\n      unmap_memory(base[j], size[j]);\n    }\n  }\n\n  if (i < max_tries) {\n    _highest_vm_reserved_address = MAX2(old_highest, (address)requested_addr + bytes);\n    return requested_addr;\n  } else {\n    _highest_vm_reserved_address = old_highest;\n    return NULL;\n  }\n}\n\nsize_t os::read(int fd, void *buf, unsigned int nBytes) {\n  RESTARTABLE_RETURN_INT(::read(fd, buf, nBytes));\n}\n\n// TODO-FIXME: reconcile Solaris' os::sleep with the bsd variation.\n// Solaris uses poll(), bsd uses park().\n// Poll() is likely a better choice, assuming that Thread.interrupt()\n// generates a SIGUSRx signal. Note that SIGUSR1 can interfere with\n// SIGSEGV, see 4355769.\n\nint os::sleep(Thread* thread, jlong millis, bool interruptible) {\n  assert(thread == Thread::current(),  \"thread consistency check\");\n\n  ParkEvent * const slp = thread->_SleepEvent ;\n  slp->reset() ;\n  OrderAccess::fence() ;\n\n  if (interruptible) {\n    jlong prevtime = javaTimeNanos();\n\n    for (;;) {\n      if (os::is_interrupted(thread, true)) {\n        return OS_INTRPT;\n      }\n\n      jlong newtime = javaTimeNanos();\n\n      if (newtime - prevtime < 0) {\n        // time moving backwards, should only happen if no monotonic clock\n        // not a guarantee() because JVM should not abort on kernel/glibc bugs\n        assert(!Bsd::supports_monotonic_clock(), \"time moving backwards\");\n      } else {\n        millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n      }\n\n      if(millis <= 0) {\n        return OS_OK;\n      }\n\n      prevtime = newtime;\n\n      {\n        assert(thread->is_Java_thread(), \"sanity check\");\n        JavaThread *jt = (JavaThread *) thread;\n        ThreadBlockInVM tbivm(jt);\n        OSThreadWaitState osts(jt->osthread(), false /* not Object.wait() */);\n\n        jt->set_suspend_equivalent();\n        // cleared by handle_special_suspend_equivalent_condition() or\n        // java_suspend_self() via check_and_wait_while_suspended()\n\n        slp->park(millis);\n\n        // were we externally suspended while we were waiting?\n        jt->check_and_wait_while_suspended();\n      }\n    }\n  } else {\n    OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n    jlong prevtime = javaTimeNanos();\n\n    for (;;) {\n      // It'd be nice to avoid the back-to-back javaTimeNanos() calls on\n      // the 1st iteration ...\n      jlong newtime = javaTimeNanos();\n\n      if (newtime - prevtime < 0) {\n        // time moving backwards, should only happen if no monotonic clock\n        // not a guarantee() because JVM should not abort on kernel/glibc bugs\n        assert(!Bsd::supports_monotonic_clock(), \"time moving backwards\");\n      } else {\n        millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n      }\n\n      if(millis <= 0) break ;\n\n      prevtime = newtime;\n      slp->park(millis);\n    }\n    return OS_OK ;\n  }\n}\n\nvoid os::naked_short_sleep(jlong ms) {\n  struct timespec req;\n\n  assert(ms < 1000, \"Un-interruptable sleep, short time use only\");\n  req.tv_sec = 0;\n  if (ms > 0) {\n    req.tv_nsec = (ms % 1000) * 1000000;\n  }\n  else {\n    req.tv_nsec = 1;\n  }\n\n  nanosleep(&req, NULL);\n\n  return;\n}\n\n// Sleep forever; naked call to OS-specific sleep; use with CAUTION\nvoid os::infinite_sleep() {\n  while (true) {    // sleep forever ...\n    ::sleep(100);   // ... 100 seconds at a time\n  }\n}\n\n// Used to convert frequent JVM_Yield() to nops\nbool os::dont_yield() {\n  return DontYieldALot;\n}\n\nvoid os::yield() {\n  sched_yield();\n}\n\nos::YieldResult os::NakedYield() { sched_yield(); return os::YIELD_UNKNOWN ;}\n\nvoid os::yield_all(int attempts) {\n  // Yields to all threads, including threads with lower priorities\n  // Threads on Bsd are all with same priority. The Solaris style\n  // os::yield_all() with nanosleep(1ms) is not necessary.\n  sched_yield();\n}\n\n// Called from the tight loops to possibly influence time-sharing heuristics\nvoid os::loop_breaker(int attempts) {\n  os::yield_all(attempts);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// thread priority support\n\n// Note: Normal Bsd applications are run with SCHED_OTHER policy. SCHED_OTHER\n// only supports dynamic priority, static priority must be zero. For real-time\n// applications, Bsd supports SCHED_RR which allows static priority (1-99).\n// However, for large multi-threaded applications, SCHED_RR is not only slower\n// than SCHED_OTHER, but also very unstable (my volano tests hang hard 4 out\n// of 5 runs - Sep 2005).\n//\n// The following code actually changes the niceness of kernel-thread/LWP. It\n// has an assumption that setpriority() only modifies one kernel-thread/LWP,\n// not the entire user process, and user level threads are 1:1 mapped to kernel\n// threads. It has always been the case, but could change in the future. For\n// this reason, the code should not be used as default (ThreadPriorityPolicy=0).\n// It is only used when ThreadPriorityPolicy=1 and requires root privilege.\n\n#if !defined(__APPLE__)\nint os::java_to_os_priority[CriticalPriority + 1] = {\n  19,              // 0 Entry should never be used\n\n   0,              // 1 MinPriority\n   3,              // 2\n   6,              // 3\n\n  10,              // 4\n  15,              // 5 NormPriority\n  18,              // 6\n\n  21,              // 7\n  25,              // 8\n  28,              // 9 NearMaxPriority\n\n  31,              // 10 MaxPriority\n\n  31               // 11 CriticalPriority\n};\n#else\n/* Using Mach high-level priority assignments */\nint os::java_to_os_priority[CriticalPriority + 1] = {\n   0,              // 0 Entry should never be used (MINPRI_USER)\n\n  27,              // 1 MinPriority\n  28,              // 2\n  29,              // 3\n\n  30,              // 4\n  31,              // 5 NormPriority (BASEPRI_DEFAULT)\n  32,              // 6\n\n  33,              // 7\n  34,              // 8\n  35,              // 9 NearMaxPriority\n\n  36,              // 10 MaxPriority\n\n  36               // 11 CriticalPriority\n};\n#endif\n\nstatic int prio_init() {\n  if (ThreadPriorityPolicy == 1) {\n    // Only root can raise thread priority. Don't allow ThreadPriorityPolicy=1\n    // if effective uid is not root. Perhaps, a more elegant way of doing\n    // this is to test CAP_SYS_NICE capability, but that will require libcap.so\n    if (geteuid() != 0) {\n      if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {\n        warning(\"-XX:ThreadPriorityPolicy requires root privilege on Bsd\");\n      }\n      ThreadPriorityPolicy = 0;\n    }\n  }\n  if (UseCriticalJavaThreadPriority) {\n    os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];\n  }\n  return 0;\n}\n\nOSReturn os::set_native_priority(Thread* thread, int newpri) {\n  if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) return OS_OK;\n\n#ifdef __OpenBSD__\n  // OpenBSD pthread_setprio starves low priority threads\n  return OS_OK;\n#elif defined(__FreeBSD__)\n  int ret = pthread_setprio(thread->osthread()->pthread_id(), newpri);\n#elif defined(__APPLE__) || defined(__NetBSD__)\n  struct sched_param sp;\n  int policy;\n  pthread_t self = pthread_self();\n\n  if (pthread_getschedparam(self, &policy, &sp) != 0)\n    return OS_ERR;\n\n  sp.sched_priority = newpri;\n  if (pthread_setschedparam(self, policy, &sp) != 0)\n    return OS_ERR;\n\n  return OS_OK;\n#else\n  int ret = setpriority(PRIO_PROCESS, thread->osthread()->thread_id(), newpri);\n  return (ret == 0) ? OS_OK : OS_ERR;\n#endif\n}\n\nOSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {\n  if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) {\n    *priority_ptr = java_to_os_priority[NormPriority];\n    return OS_OK;\n  }\n\n  errno = 0;\n#if defined(__OpenBSD__) || defined(__FreeBSD__)\n  *priority_ptr = pthread_getprio(thread->osthread()->pthread_id());\n#elif defined(__APPLE__) || defined(__NetBSD__)\n  int policy;\n  struct sched_param sp;\n\n  pthread_getschedparam(pthread_self(), &policy, &sp);\n  *priority_ptr = sp.sched_priority;\n#else\n  *priority_ptr = getpriority(PRIO_PROCESS, thread->osthread()->thread_id());\n#endif\n  return (*priority_ptr != -1 || errno == 0 ? OS_OK : OS_ERR);\n}\n\n// Hint to the underlying OS that a task switch would not be good.\n// Void return because it's a hint and can fail.\nvoid os::hint_no_preempt() {}\n\n////////////////////////////////////////////////////////////////////////////////\n// suspend/resume support\n\n//  the low-level signal-based suspend/resume support is a remnant from the\n//  old VM-suspension that used to be for java-suspension, safepoints etc,\n//  within hotspot. Now there is a single use-case for this:\n//    - calling get_thread_pc() on the VMThread by the flat-profiler task\n//      that runs in the watcher thread.\n//  The remaining code is greatly simplified from the more general suspension\n//  code that used to be used.\n//\n//  The protocol is quite simple:\n//  - suspend:\n//      - sends a signal to the target thread\n//      - polls the suspend state of the osthread using a yield loop\n//      - target thread signal handler (SR_handler) sets suspend state\n//        and blocks in sigsuspend until continued\n//  - resume:\n//      - sets target osthread state to continue\n//      - sends signal to end the sigsuspend loop in the SR_handler\n//\n//  Note that the SR_lock plays no role in this suspend/resume protocol.\n//\n\nstatic void resume_clear_context(OSThread *osthread) {\n  osthread->set_ucontext(NULL);\n  osthread->set_siginfo(NULL);\n}\n\nstatic void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n  osthread->set_ucontext(context);\n  osthread->set_siginfo(siginfo);\n}\n\n//\n// Handler function invoked when a thread's execution is suspended or\n// resumed. We have to be careful that only async-safe functions are\n// called here (Note: most pthread functions are not async safe and\n// should be avoided.)\n//\n// Note: sigwait() is a more natural fit than sigsuspend() from an\n// interface point of view, but sigwait() prevents the signal hander\n// from being run. libpthread would get very confused by not having\n// its signal handlers run and prevents sigwait()'s use with the\n// mutex granting granting signal.\n//\n// Currently only ever called on the VMThread or JavaThread\n//\nstatic void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n  // Save and restore errno to avoid confusing native code with EINTR\n  // after sigsuspend.\n  int old_errno = errno;\n\n  Thread* thread = Thread::current();\n  OSThread* osthread = thread->osthread();\n  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n\n  os::SuspendResume::State current = osthread->sr.state();\n  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n    suspend_save_context(osthread, siginfo, context);\n\n    // attempt to switch the state, we assume we had a SUSPEND_REQUEST\n    os::SuspendResume::State state = osthread->sr.suspended();\n    if (state == os::SuspendResume::SR_SUSPENDED) {\n      sigset_t suspend_set;  // signals for sigsuspend()\n\n      // get current set of blocked signals and unblock resume signal\n      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n      sigdelset(&suspend_set, SR_signum);\n\n      sr_semaphore.signal();\n      // wait here until we are resumed\n      while (1) {\n        sigsuspend(&suspend_set);\n\n        os::SuspendResume::State result = osthread->sr.running();\n        if (result == os::SuspendResume::SR_RUNNING) {\n          sr_semaphore.signal();\n          break;\n        } else if (result != os::SuspendResume::SR_SUSPENDED) {\n          ShouldNotReachHere();\n        }\n      }\n\n    } else if (state == os::SuspendResume::SR_RUNNING) {\n      // request was cancelled, continue\n    } else {\n      ShouldNotReachHere();\n    }\n\n    resume_clear_context(osthread);\n  } else if (current == os::SuspendResume::SR_RUNNING) {\n    // request was cancelled, continue\n  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // ignore\n  } else {\n    // ignore\n  }\n\n  errno = old_errno;\n}\n\n\nstatic int SR_initialize() {\n  struct sigaction act;\n  char *s;\n  /* Get signal number to use for suspend/resume */\n  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n    int sig = ::strtol(s, 0, 10);\n    if (sig > 0 || sig < NSIG) {\n        SR_signum = sig;\n    }\n  }\n\n  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n        \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n\n  sigemptyset(&SR_sigset);\n  sigaddset(&SR_sigset, SR_signum);\n\n  /* Set up signal handler for suspend/resume */\n  act.sa_flags = SA_RESTART|SA_SIGINFO;\n  act.sa_handler = (void (*)(int)) SR_handler;\n\n  // SR_signum is blocked by default.\n  // 4528190 - We also need to block pthread restart signal (32 on all\n  // supported Bsd platforms). Note that BsdThreads need to block\n  // this signal for all threads to work properly. So we don't have\n  // to use hard-coded signal number when setting up the mask.\n  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n\n  if (sigaction(SR_signum, &act, 0) == -1) {\n    return -1;\n  }\n\n  // Save signal flag\n  os::Bsd::set_our_sigflags(SR_signum, act.sa_flags);\n  return 0;\n}\n\nstatic int sr_notify(OSThread* osthread) {\n  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n  assert_status(status == 0, status, \"pthread_kill\");\n  return status;\n}\n\n// \"Randomly\" selected value for how long we want to spin\n// before bailing out on suspending a thread, also how often\n// we send a signal to a thread we want to resume\nstatic const int RANDOMLY_LARGE_INTEGER = 1000000;\nstatic const int RANDOMLY_LARGE_INTEGER2 = 100;\n\n// returns true on success and false on error - really an error is fatal\n// but this seems the normal response to library errors\nstatic bool do_suspend(OSThread* osthread) {\n  assert(osthread->sr.is_running(), \"thread should be running\");\n  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n\n  // mark as suspended and send signal\n  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n    // failed to switch, state wasn't running?\n    ShouldNotReachHere();\n    return false;\n  }\n\n  if (sr_notify(osthread) != 0) {\n    ShouldNotReachHere();\n  }\n\n  // managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n  while (true) {\n    if (sr_semaphore.timedwait(0, 2 * NANOSECS_PER_MILLISEC)) {\n      break;\n    } else {\n      // timeout\n      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n      if (cancelled == os::SuspendResume::SR_RUNNING) {\n        return false;\n      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n        // make sure that we consume the signal on the semaphore as well\n        sr_semaphore.wait();\n        break;\n      } else {\n        ShouldNotReachHere();\n        return false;\n      }\n    }\n  }\n\n  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n  return true;\n}\n\nstatic void do_resume(OSThread* osthread) {\n  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n\n  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // failed to switch to WAKEUP_REQUEST\n    ShouldNotReachHere();\n    return;\n  }\n\n  while (true) {\n    if (sr_notify(osthread) == 0) {\n      if (sr_semaphore.timedwait(0, 2 * NANOSECS_PER_MILLISEC)) {\n        if (osthread->sr.is_running()) {\n          return;\n        }\n      }\n    } else {\n      ShouldNotReachHere();\n    }\n  }\n\n  guarantee(osthread->sr.is_running(), \"Must be running!\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// interrupt support\n\nvoid os::interrupt(Thread* thread) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  if (!osthread->interrupted()) {\n    osthread->set_interrupted(true);\n    // More than one thread can get here with the same value of osthread,\n    // resulting in multiple notifications.  We do, however, want the store\n    // to interrupted() to be visible to other threads before we execute unpark().\n    OrderAccess::fence();\n    ParkEvent * const slp = thread->_SleepEvent ;\n    if (slp != NULL) slp->unpark() ;\n  }\n\n  // For JSR166. Unpark even if interrupt status already was set\n  if (thread->is_Java_thread())\n    ((JavaThread*)thread)->parker()->unpark();\n\n  ParkEvent * ev = thread->_ParkEvent ;\n  if (ev != NULL) ev->unpark() ;\n\n}\n\nbool os::is_interrupted(Thread* thread, bool clear_interrupted) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  bool interrupted = osthread->interrupted();\n\n  if (interrupted && clear_interrupted) {\n    osthread->set_interrupted(false);\n    // consider thread->_SleepEvent->reset() ... optional optimization\n  }\n\n  return interrupted;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// signal handling (except suspend/resume)\n\n// This routine may be used by user applications as a \"hook\" to catch signals.\n// The user-defined signal handler must pass unrecognized signals to this\n// routine, and if it returns true (non-zero), then the signal handler must\n// return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n// routine will never retun false (zero), but instead will execute a VM panic\n// routine kill the process.\n//\n// If this routine returns false, it is OK to call it again.  This allows\n// the user-defined signal handler to perform checks either before or after\n// the VM performs its own checks.  Naturally, the user code would be making\n// a serious error if it tried to handle an exception (such as a null check\n// or breakpoint) that the VM was generating for its own correct operation.\n//\n// This routine may recognize any of the following kinds of signals:\n//    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n// It should be consulted by handlers for any of those signals.\n//\n// The caller of this routine must pass in the three arguments supplied\n// to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n// field of the structure passed to sigaction().  This routine assumes that\n// the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n//\n// Note that the VM will print warnings if it detects conflicting signal\n// handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n//\nextern \"C\" JNIEXPORT int\nJVM_handle_bsd_signal(int signo, siginfo_t* siginfo,\n                        void* ucontext, int abort_if_unrecognized);\n\nvoid signalHandler(int sig, siginfo_t* info, void* uc) {\n  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n  int orig_errno = errno;  // Preserve errno value over signal handler.\n  JVM_handle_bsd_signal(sig, info, uc, true);\n  errno = orig_errno;\n}\n\n\n// This boolean allows users to forward their own non-matching signals\n// to JVM_handle_bsd_signal, harmlessly.\nbool os::Bsd::signal_handlers_are_installed = false;\n\n// For signal-chaining\nstruct sigaction os::Bsd::sigact[MAXSIGNUM];\nunsigned int os::Bsd::sigs = 0;\nbool os::Bsd::libjsig_is_loaded = false;\ntypedef struct sigaction *(*get_signal_t)(int);\nget_signal_t os::Bsd::get_signal_action = NULL;\n\nstruct sigaction* os::Bsd::get_chained_signal_action(int sig) {\n  struct sigaction *actp = NULL;\n\n  if (libjsig_is_loaded) {\n    // Retrieve the old signal handler from libjsig\n    actp = (*get_signal_action)(sig);\n  }\n  if (actp == NULL) {\n    // Retrieve the preinstalled signal handler from jvm\n    actp = get_preinstalled_handler(sig);\n  }\n\n  return actp;\n}\n\nstatic bool call_chained_handler(struct sigaction *actp, int sig,\n                                 siginfo_t *siginfo, void *context) {\n  // Call the old signal handler\n  if (actp->sa_handler == SIG_DFL) {\n    // It's more reasonable to let jvm treat it as an unexpected exception\n    // instead of taking the default action.\n    return false;\n  } else if (actp->sa_handler != SIG_IGN) {\n    if ((actp->sa_flags & SA_NODEFER) == 0) {\n      // automaticlly block the signal\n      sigaddset(&(actp->sa_mask), sig);\n    }\n\n    sa_handler_t hand;\n    sa_sigaction_t sa;\n    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n    // retrieve the chained handler\n    if (siginfo_flag_set) {\n      sa = actp->sa_sigaction;\n    } else {\n      hand = actp->sa_handler;\n    }\n\n    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n      actp->sa_handler = SIG_DFL;\n    }\n\n    // try to honor the signal mask\n    sigset_t oset;\n    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n\n    // call into the chained handler\n    if (siginfo_flag_set) {\n      (*sa)(sig, siginfo, context);\n    } else {\n      (*hand)(sig);\n    }\n\n    // restore the signal mask\n    pthread_sigmask(SIG_SETMASK, &oset, 0);\n  }\n  // Tell jvm's signal handler the signal is taken care of.\n  return true;\n}\n\nbool os::Bsd::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n  bool chained = false;\n  // signal-chaining\n  if (UseSignalChaining) {\n    struct sigaction *actp = get_chained_signal_action(sig);\n    if (actp != NULL) {\n      chained = call_chained_handler(actp, sig, siginfo, context);\n    }\n  }\n  return chained;\n}\n\nstruct sigaction* os::Bsd::get_preinstalled_handler(int sig) {\n  if ((( (unsigned int)1 << sig ) & sigs) != 0) {\n    return &sigact[sig];\n  }\n  return NULL;\n}\n\nvoid os::Bsd::save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigact[sig] = oldAct;\n  sigs |= (unsigned int)1 << sig;\n}\n\n// for diagnostic\nint os::Bsd::sigflags[MAXSIGNUM];\n\nint os::Bsd::get_our_sigflags(int sig) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  return sigflags[sig];\n}\n\nvoid os::Bsd::set_our_sigflags(int sig, int flags) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = flags;\n}\n\nvoid os::Bsd::set_signal_handler(int sig, bool set_installed) {\n  // Check for overwrite.\n  struct sigaction oldAct;\n  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n\n  void* oldhand = oldAct.sa_sigaction\n                ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n                : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)signalHandler)) {\n    if (AllowUserSignalHandlers || !set_installed) {\n      // Do not overwrite; user takes responsibility to forward to us.\n      return;\n    } else if (UseSignalChaining) {\n      // save the old handler in jvm\n      save_preinstalled_handler(sig, oldAct);\n      // libjsig also interposes the sigaction() call below and saves the\n      // old sigaction on it own.\n    } else {\n      fatal(err_msg(\"Encountered unexpected pre-existing sigaction handler \"\n                    \"%#lx for signal %d.\", (long)oldhand, sig));\n    }\n  }\n\n  struct sigaction sigAct;\n  sigfillset(&(sigAct.sa_mask));\n  sigAct.sa_handler = SIG_DFL;\n  if (!set_installed) {\n    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n  } else {\n    sigAct.sa_sigaction = signalHandler;\n    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n  }\n#ifdef __APPLE__\n  // Needed for main thread as XNU (Mac OS X kernel) will only deliver SIGSEGV\n  // (which starts as SIGBUS) on main thread with faulting address inside \"stack+guard pages\"\n  // if the signal handler declares it will handle it on alternate stack.\n  // Notice we only declare we will handle it on alt stack, but we are not\n  // actually going to use real alt stack - this is just a workaround.\n  // Please see ux_exception.c, method catch_mach_exception_raise for details\n  // link http://www.opensource.apple.com/source/xnu/xnu-2050.18.24/bsd/uxkern/ux_exception.c\n  if (sig == SIGSEGV) {\n    sigAct.sa_flags |= SA_ONSTACK;\n  }\n#endif\n\n  // Save flags, which are set by ours\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = sigAct.sa_flags;\n\n  int ret = sigaction(sig, &sigAct, &oldAct);\n  assert(ret == 0, \"check\");\n\n  void* oldhand2  = oldAct.sa_sigaction\n                  ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n                  : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n}\n\n// install signal handlers for signals that HotSpot needs to\n// handle in order to support Java-level exception handling.\n\nvoid os::Bsd::install_signal_handlers() {\n  if (!signal_handlers_are_installed) {\n    signal_handlers_are_installed = true;\n\n    // signal-chaining\n    typedef void (*signal_setting_t)();\n    signal_setting_t begin_signal_setting = NULL;\n    signal_setting_t end_signal_setting = NULL;\n    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n    if (begin_signal_setting != NULL) {\n      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n                            dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n      libjsig_is_loaded = true;\n      assert(UseSignalChaining, \"should enable signal-chaining\");\n    }\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm is setting signal handlers\n      (*begin_signal_setting)();\n    }\n\n    set_signal_handler(SIGSEGV, true);\n    set_signal_handler(SIGPIPE, true);\n    set_signal_handler(SIGBUS, true);\n    set_signal_handler(SIGILL, true);\n    set_signal_handler(SIGFPE, true);\n    set_signal_handler(SIGXFSZ, true);\n\n#if defined(__APPLE__)\n    // In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including\n    // signals caught and handled by the JVM. To work around this, we reset the mach task\n    // signal handler that's placed on our process by CrashReporter. This disables\n    // CrashReporter-based reporting.\n    //\n    // This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes\n    // on caught fatal signals.\n    //\n    // Additionally, gdb installs both standard BSD signal handlers, and mach exception\n    // handlers. By replacing the existing task exception handler, we disable gdb's mach\n    // exception handling, while leaving the standard BSD signal handlers functional.\n    kern_return_t kr;\n    kr = task_set_exception_ports(mach_task_self(),\n        EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n        MACH_PORT_NULL,\n        EXCEPTION_STATE_IDENTITY,\n        MACHINE_THREAD_STATE);\n\n    assert(kr == KERN_SUCCESS, \"could not set mach task signal handler\");\n#endif\n\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm finishes setting signal handlers\n      (*end_signal_setting)();\n    }\n\n    // We don't activate signal checker if libjsig is in place, we trust ourselves\n    // and if UserSignalHandler is installed all bets are off\n    if (CheckJNICalls) {\n      if (libjsig_is_loaded) {\n        if (PrintJNIResolving) {\n          tty->print_cr(\"Info: libjsig is activated, all active signal checking is disabled\");\n        }\n        check_signals = false;\n      }\n      if (AllowUserSignalHandlers) {\n        if (PrintJNIResolving) {\n          tty->print_cr(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n        }\n        check_signals = false;\n      }\n    }\n  }\n}\n\n\n/////\n// glibc on Bsd platform uses non-documented flag\n// to indicate, that some special sort of signal\n// trampoline is used.\n// We will never set this flag, and we should\n// ignore this flag in our diagnostic\n#ifdef SIGNIFICANT_SIGNAL_MASK\n#undef SIGNIFICANT_SIGNAL_MASK\n#endif\n#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)\n\nstatic const char* get_signal_handler_name(address handler,\n                                           char* buf, int buflen) {\n  int offset;\n  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n  if (found) {\n    // skip directory names\n    const char *p1, *p2;\n    p1 = buf;\n    size_t len = strlen(os::file_separator());\n    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n  } else {\n    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n  }\n  return buf;\n}\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen) {\n  struct sigaction sa;\n\n  sigaction(sig, NULL, &sa);\n\n  // See comment for SIGNIFICANT_SIGNAL_MASK define\n  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n\n  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n\n  address handler = (sa.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n\n  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n    st->print(\"SIG_DFL\");\n  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n    st->print(\"SIG_IGN\");\n  } else {\n    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n  }\n\n  st->print(\", sa_mask[0]=\");\n  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n\n  address rh = VMError::get_resetted_sighandler(sig);\n  // May be, handler was resetted by VMError?\n  if(rh != NULL) {\n    handler = rh;\n    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;\n  }\n\n  st->print(\", sa_flags=\");\n  os::Posix::print_sa_flags(st, sa.sa_flags);\n\n  // Check: is it our handler?\n  if(handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler) ||\n     handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n    // It is our signal handler\n    // check for flags, reset system-used one!\n    if((int)sa.sa_flags != os::Bsd::get_our_sigflags(sig)) {\n      st->print(\n                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n                os::Bsd::get_our_sigflags(sig));\n    }\n  }\n  st->cr();\n}\n\n\n#define DO_SIGNAL_CHECK(sig) \\\n  if (!sigismember(&check_signal_done, sig)) \\\n    os::Bsd::check_signal_handler(sig)\n\n// This method is a periodic task to check for misbehaving JNI applications\n// under CheckJNI, we can add any periodic checks here\n\nvoid os::run_periodic_checks() {\n\n  if (check_signals == false) return;\n\n  // SEGV and BUS if overridden could potentially prevent\n  // generation of hs*.log in the event of a crash, debugging\n  // such a case can be very challenging, so we absolutely\n  // check the following for a good measure:\n  DO_SIGNAL_CHECK(SIGSEGV);\n  DO_SIGNAL_CHECK(SIGILL);\n  DO_SIGNAL_CHECK(SIGFPE);\n  DO_SIGNAL_CHECK(SIGBUS);\n  DO_SIGNAL_CHECK(SIGPIPE);\n  DO_SIGNAL_CHECK(SIGXFSZ);\n\n\n  // ReduceSignalUsage allows the user to override these handlers\n  // see comments at the very top and jvm_solaris.h\n  if (!ReduceSignalUsage) {\n    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n  }\n\n  DO_SIGNAL_CHECK(SR_signum);\n  DO_SIGNAL_CHECK(INTERRUPT_SIGNAL);\n}\n\ntypedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic os_sigaction_t os_sigaction = NULL;\n\nvoid os::Bsd::check_signal_handler(int sig) {\n  char buf[O_BUFLEN];\n  address jvmHandler = NULL;\n\n\n  struct sigaction act;\n  if (os_sigaction == NULL) {\n    // only trust the default sigaction, in case it has been interposed\n    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n    if (os_sigaction == NULL) return;\n  }\n\n  os_sigaction(sig, (struct sigaction*)NULL, &act);\n\n\n  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n\n  address thisHandler = (act.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, act.sa_handler) ;\n\n\n  switch(sig) {\n  case SIGSEGV:\n  case SIGBUS:\n  case SIGFPE:\n  case SIGPIPE:\n  case SIGILL:\n  case SIGXFSZ:\n    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler);\n    break;\n\n  case SHUTDOWN1_SIGNAL:\n  case SHUTDOWN2_SIGNAL:\n  case SHUTDOWN3_SIGNAL:\n  case BREAK_SIGNAL:\n    jvmHandler = (address)user_handler();\n    break;\n\n  case INTERRUPT_SIGNAL:\n    jvmHandler = CAST_FROM_FN_PTR(address, SIG_DFL);\n    break;\n\n  default:\n    if (sig == SR_signum) {\n      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n    } else {\n      return;\n    }\n    break;\n  }\n\n  if (thisHandler != jvmHandler) {\n    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n    // Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n                    exception_name(sig, buf, O_BUFLEN));\n    }\n  } else if(os::Bsd::get_our_sigflags(sig) != 0 && (int)act.sa_flags != os::Bsd::get_our_sigflags(sig)) {\n    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:\" PTR32_FORMAT, os::Bsd::get_our_sigflags(sig));\n    tty->print_cr(\"  found:\" PTR32_FORMAT, act.sa_flags);\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n  }\n\n  // Dump all the signal\n  if (sigismember(&check_signal_done, sig)) {\n    print_signal_handlers(tty, buf, O_BUFLEN);\n  }\n}\n\nextern void report_error(char* file_name, int line_no, char* title, char* format, ...);\n\nextern bool signal_name(int signo, char* buf, size_t len);\n\nconst char* os::exception_name(int exception_code, char* buf, size_t size) {\n  if (0 < exception_code && exception_code <= SIGRTMAX) {\n    // signal\n    if (!signal_name(exception_code, buf, size)) {\n      jio_snprintf(buf, size, \"SIG%d\", exception_code);\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\n// this is called _before_ the most of global arguments have been parsed\nvoid os::init(void) {\n  char dummy;   /* used to get a guess on initial stack address */\n//  first_hrtime = gethrtime();\n\n  // With BsdThreads the JavaMain thread pid (primordial thread)\n  // is different than the pid of the java launcher thread.\n  // So, on Bsd, the launcher thread pid is passed to the VM\n  // via the sun.java.launcher.pid property.\n  // Use this property instead of getpid() if it was correctly passed.\n  // See bug 6351349.\n  pid_t java_launcher_pid = (pid_t) Arguments::sun_java_launcher_pid();\n\n  _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();\n\n  clock_tics_per_sec = CLK_TCK;\n\n  init_random(1234567);\n\n  ThreadCritical::initialize();\n\n  Bsd::set_page_size(getpagesize());\n  if (Bsd::page_size() == -1) {\n    fatal(err_msg(\"os_bsd.cpp: os::init: sysconf failed (%s)\",\n                  strerror(errno)));\n  }\n  init_page_sizes((size_t) Bsd::page_size());\n\n  Bsd::initialize_system_info();\n\n  // main_thread points to the aboriginal thread\n  Bsd::_main_thread = pthread_self();\n\n  Bsd::clock_init();\n  initial_time_count = javaTimeNanos();\n\n#ifdef __APPLE__\n  // XXXDARWIN\n  // Work around the unaligned VM callbacks in hotspot's\n  // sharedRuntime. The callbacks don't use SSE2 instructions, and work on\n  // Linux, Solaris, and FreeBSD. On Mac OS X, dyld (rightly so) enforces\n  // alignment when doing symbol lookup. To work around this, we force early\n  // binding of all symbols now, thus binding when alignment is known-good.\n  _dyld_bind_fully_image_containing_address((const void *) &os::init);\n#endif\n}\n\n// To install functions for atexit system call\nextern \"C\" {\n  static void perfMemory_exit_helper() {\n    perfMemory_exit();\n  }\n}\n\n// this is called _after_ the global arguments have been parsed\njint os::init_2(void)\n{\n  // Allocate a single page and mark it as readable for safepoint polling\n  address polling_page = (address) ::mmap(NULL, Bsd::page_size(), PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n  guarantee( polling_page != MAP_FAILED, \"os::init_2: failed to allocate polling page\" );\n\n  os::set_polling_page( polling_page );\n\n#ifndef PRODUCT\n  if(Verbose && PrintMiscellaneous)\n    tty->print(\"[SafePoint Polling address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)polling_page);\n#endif\n\n  if (!UseMembar) {\n    address mem_serialize_page = (address) ::mmap(NULL, Bsd::page_size(), PROT_READ | PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    guarantee( mem_serialize_page != MAP_FAILED, \"mmap Failed for memory serialize page\");\n    os::set_memory_serialize_page( mem_serialize_page );\n\n#ifndef PRODUCT\n    if(Verbose && PrintMiscellaneous)\n      tty->print(\"[Memory Serialize  Page address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)mem_serialize_page);\n#endif\n  }\n\n  // initialize suspend/resume support - must do this before signal_sets_init()\n  if (SR_initialize() != 0) {\n    perror(\"SR_initialize failed\");\n    return JNI_ERR;\n  }\n\n  Bsd::signal_sets_init();\n  Bsd::install_signal_handlers();\n\n  // Check minimum allowable stack size for thread creation and to initialize\n  // the java system classes, including StackOverflowError - depends on page\n  // size.  Add a page for compiler2 recursion in main thread.\n  // Add in 2*BytesPerWord times page size to account for VM stack during\n  // class initialization depending on 32 or 64 bit VM.\n  os::Bsd::min_stack_allowed = MAX2(os::Bsd::min_stack_allowed,\n            (size_t)(StackYellowPages+StackRedPages+StackShadowPages+\n                    2*BytesPerWord COMPILER2_PRESENT(+1)) * Bsd::page_size());\n\n  size_t threadStackSizeInBytes = ThreadStackSize * K;\n  if (threadStackSizeInBytes != 0 &&\n      threadStackSizeInBytes < os::Bsd::min_stack_allowed) {\n        tty->print_cr(\"\\nThe stack size specified is too small, \"\n                      \"Specify at least %dk\",\n                      os::Bsd::min_stack_allowed/ K);\n        return JNI_ERR;\n  }\n\n  // Make the stack size a multiple of the page size so that\n  // the yellow/red zones can be guarded.\n  JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,\n        vm_page_size()));\n\n  if (MaxFDLimit) {\n    // set the number of file descriptors to max. print out error\n    // if getrlimit/setrlimit fails but continue regardless.\n    struct rlimit nbr_files;\n    int status = getrlimit(RLIMIT_NOFILE, &nbr_files);\n    if (status != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode))\n        perror(\"os::init_2 getrlimit failed\");\n    } else {\n      nbr_files.rlim_cur = nbr_files.rlim_max;\n\n#ifdef __APPLE__\n      // Darwin returns RLIM_INFINITY for rlim_max, but fails with EINVAL if\n      // you attempt to use RLIM_INFINITY. As per setrlimit(2), OPEN_MAX must\n      // be used instead\n      nbr_files.rlim_cur = MIN(OPEN_MAX, nbr_files.rlim_cur);\n#endif\n\n      status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n      if (status != 0) {\n        if (PrintMiscellaneous && (Verbose || WizardMode))\n          perror(\"os::init_2 setrlimit failed\");\n      }\n    }\n  }\n\n  // at-exit methods are called in the reverse order of their registration.\n  // atexit functions are called on return from main or as a result of a\n  // call to exit(3C). There can be only 32 of these functions registered\n  // and atexit() does not set errno.\n\n  if (PerfAllowAtExitRegistration) {\n    // only register atexit functions if PerfAllowAtExitRegistration is set.\n    // atexit functions can be delayed until process exit time, which\n    // can be problematic for embedded VM situations. Embedded VMs should\n    // call DestroyJavaVM() to assure that VM resources are released.\n\n    // note: perfMemory_exit_helper atexit function may be removed in\n    // the future if the appropriate cleanup code can be added to the\n    // VM_Exit VMOperation's doit method.\n    if (atexit(perfMemory_exit_helper) != 0) {\n      warning(\"os::init2 atexit(perfMemory_exit_helper) failed\");\n    }\n  }\n\n  // initialize thread priority policy\n  prio_init();\n\n#ifdef __APPLE__\n  // dynamically link to objective c gc registration\n  void *handleLibObjc = dlopen(OBJC_LIB, RTLD_LAZY);\n  if (handleLibObjc != NULL) {\n    objc_registerThreadWithCollectorFunction = (objc_registerThreadWithCollector_t) dlsym(handleLibObjc, OBJC_GCREGISTER);\n  }\n#endif\n\n  return JNI_OK;\n}\n\n// Mark the polling page as unreadable\nvoid os::make_polling_page_unreadable(void) {\n  if( !guard_memory((char*)_polling_page, Bsd::page_size()) )\n    fatal(\"Could not disable polling page\");\n};\n\n// Mark the polling page as readable\nvoid os::make_polling_page_readable(void) {\n  if( !bsd_mprotect((char *)_polling_page, Bsd::page_size(), PROT_READ)) {\n    fatal(\"Could not enable polling page\");\n  }\n};\n\nint os::active_processor_count() {\n  return _processor_count;\n}\n\nvoid os::set_native_thread_name(const char *name) {\n#if defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_5\n  // This is only supported in Snow Leopard and beyond\n  if (name != NULL) {\n    // Add a \"Java: \" prefix to the name\n    char buf[MAXTHREADNAMESIZE];\n    snprintf(buf, sizeof(buf), \"Java: %s\", name);\n    pthread_setname_np(buf);\n  }\n#endif\n}\n\nbool os::distribute_processes(uint length, uint* distribution) {\n  // Not yet implemented.\n  return false;\n}\n\nbool os::bind_to_processor(uint processor_id) {\n  // Not yet implemented.\n  return false;\n}\n\nvoid os::SuspendedThreadTask::internal_do_task() {\n  if (do_suspend(_thread->osthread())) {\n    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n    do_task(context);\n    do_resume(_thread->osthread());\n  }\n}\n\n///\nclass PcFetcher : public os::SuspendedThreadTask {\npublic:\n  PcFetcher(Thread* thread) : os::SuspendedThreadTask(thread) {}\n  ExtendedPC result();\nprotected:\n  void do_task(const os::SuspendedThreadTaskContext& context);\nprivate:\n  ExtendedPC _epc;\n};\n\nExtendedPC PcFetcher::result() {\n  guarantee(is_done(), \"task is not done yet.\");\n  return _epc;\n}\n\nvoid PcFetcher::do_task(const os::SuspendedThreadTaskContext& context) {\n  Thread* thread = context.thread();\n  OSThread* osthread = thread->osthread();\n  if (osthread->ucontext() != NULL) {\n    _epc = os::Bsd::ucontext_get_pc((ucontext_t *) context.ucontext());\n  } else {\n    // NULL context is unexpected, double-check this is the VMThread\n    guarantee(thread->is_VM_thread(), \"can only be called for VMThread\");\n  }\n}\n\n// Suspends the target using the signal mechanism and then grabs the PC before\n// resuming the target. Used by the flat-profiler only\nExtendedPC os::get_thread_pc(Thread* thread) {\n  // Make sure that it is called by the watcher for the VMThread\n  assert(Thread::current()->is_Watcher_thread(), \"Must be watcher\");\n  assert(thread->is_VM_thread(), \"Can only be called for VMThread\");\n\n  PcFetcher fetcher(thread);\n  fetcher.run();\n  return fetcher.result();\n}\n\nint os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime)\n{\n  return pthread_cond_timedwait(_cond, _mutex, _abstime);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// debug support\n\nbool os::find(address addr, outputStream* st) {\n  Dl_info dlinfo;\n  memset(&dlinfo, 0, sizeof(dlinfo));\n  if (dladdr(addr, &dlinfo) != 0) {\n    st->print(PTR_FORMAT \": \", addr);\n    if (dlinfo.dli_sname != NULL && dlinfo.dli_saddr != NULL) {\n      st->print(\"%s+%#x\", dlinfo.dli_sname,\n                 addr - (intptr_t)dlinfo.dli_saddr);\n    } else if (dlinfo.dli_fbase != NULL) {\n      st->print(\"<offset %#x>\", addr - (intptr_t)dlinfo.dli_fbase);\n    } else {\n      st->print(\"<absolute address>\");\n    }\n    if (dlinfo.dli_fname != NULL) {\n      st->print(\" in %s\", dlinfo.dli_fname);\n    }\n    if (dlinfo.dli_fbase != NULL) {\n      st->print(\" at \" PTR_FORMAT, dlinfo.dli_fbase);\n    }\n    st->cr();\n\n    if (Verbose) {\n      // decode some bytes around the PC\n      address begin = clamp_address_in_page(addr-40, addr, os::vm_page_size());\n      address end   = clamp_address_in_page(addr+40, addr, os::vm_page_size());\n      address       lowest = (address) dlinfo.dli_sname;\n      if (!lowest)  lowest = (address) dlinfo.dli_fbase;\n      if (begin < lowest)  begin = lowest;\n      Dl_info dlinfo2;\n      if (dladdr(end, &dlinfo2) != 0 && dlinfo2.dli_saddr != dlinfo.dli_saddr\n          && end > dlinfo2.dli_saddr && dlinfo2.dli_saddr > begin)\n        end = (address) dlinfo2.dli_saddr;\n      Disassembler::decode(begin, end, st);\n    }\n    return true;\n  }\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// misc\n\n// This does not do anything on Bsd. This is basically a hook for being\n// able to use structured exception handling (thread-local exception filters)\n// on, e.g., Win32.\nvoid\nos::os_exception_wrapper(java_call_t f, JavaValue* value, methodHandle* method,\n                         JavaCallArguments* args, Thread* thread) {\n  f(value, method, args, thread);\n}\n\nvoid os::print_statistics() {\n}\n\nint os::message_box(const char* title, const char* message) {\n  int i;\n  fdStream err(defaultStream::error_fd());\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n  err.print_raw_cr(title);\n  for (i = 0; i < 78; i++) err.print_raw(\"-\");\n  err.cr();\n  err.print_raw_cr(message);\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n\n  char buf[16];\n  // Prevent process from exiting upon \"read error\" without consuming all CPU\n  while (::read(0, buf, sizeof(buf)) <= 0) { ::sleep(100); }\n\n  return buf[0] == 'y' || buf[0] == 'Y';\n}\n\nint os::stat(const char *path, struct stat *sbuf) {\n  char pathbuf[MAX_PATH];\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  os::native_path(strcpy(pathbuf, path));\n  return ::stat(pathbuf, sbuf);\n}\n\nbool os::check_heap(bool force) {\n  return true;\n}\n\nATTRIBUTE_PRINTF(3, 0)\nint local_vsnprintf(char* buf, size_t count, const char* format, va_list args) {\n  return ::vsnprintf(buf, count, format, args);\n}\n\n// Is a (classpath) directory empty?\nbool os::dir_is_empty(const char* path) {\n  DIR *dir = NULL;\n  struct dirent *ptr;\n\n  dir = opendir(path);\n  if (dir == NULL) return true;\n\n  /* Scan the directory */\n  bool result = true;\n  char buf[sizeof(struct dirent) + MAX_PATH];\n  while (result && (ptr = ::readdir(dir)) != NULL) {\n    if (strcmp(ptr->d_name, \".\") != 0 && strcmp(ptr->d_name, \"..\") != 0) {\n      result = false;\n    }\n  }\n  closedir(dir);\n  return result;\n}\n\n// This code originates from JDK's sysOpen and open64_w\n// from src/solaris/hpi/src/system_md.c\n\n#ifndef O_DELETE\n#define O_DELETE 0x10000\n#endif\n\n// Open a file. Unlink the file immediately after open returns\n// if the specified oflag has the O_DELETE flag set.\n// O_DELETE is used only in j2se/src/share/native/java/util/zip/ZipFile.c\n\nint os::open(const char *path, int oflag, int mode) {\n\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  int fd;\n  int o_delete = (oflag & O_DELETE);\n  oflag = oflag & ~O_DELETE;\n\n  fd = ::open(path, oflag, mode);\n  if (fd == -1) return -1;\n\n  //If the open succeeded, the file might still be a directory\n  {\n    struct stat buf;\n    int ret = ::fstat(fd, &buf);\n    int st_mode = buf.st_mode;\n\n    if (ret != -1) {\n      if ((st_mode & S_IFMT) == S_IFDIR) {\n        errno = EISDIR;\n        ::close(fd);\n        return -1;\n      }\n    } else {\n      ::close(fd);\n      return -1;\n    }\n  }\n\n    /*\n     * All file descriptors that are opened in the JVM and not\n     * specifically destined for a subprocess should have the\n     * close-on-exec flag set.  If we don't set it, then careless 3rd\n     * party native code might fork and exec without closing all\n     * appropriate file descriptors (e.g. as we do in closeDescriptors in\n     * UNIXProcess.c), and this in turn might:\n     *\n     * - cause end-of-file to fail to be detected on some file\n     *   descriptors, resulting in mysterious hangs, or\n     *\n     * - might cause an fopen in the subprocess to fail on a system\n     *   suffering from bug 1085341.\n     *\n     * (Yes, the default setting of the close-on-exec flag is a Unix\n     * design flaw)\n     *\n     * See:\n     * 1085341: 32-bit stdio routines should support file descriptors >255\n     * 4843136: (process) pipe file descriptor from Runtime.exec not being closed\n     * 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9\n     */\n#ifdef FD_CLOEXEC\n    {\n        int flags = ::fcntl(fd, F_GETFD);\n        if (flags != -1)\n            ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n    }\n#endif\n\n  if (o_delete != 0) {\n    ::unlink(path);\n  }\n  return fd;\n}\n\n\n// create binary file, rewriting existing file if required\nint os::create_binary_file(const char* path, bool rewrite_existing) {\n  int oflags = O_WRONLY | O_CREAT;\n  if (!rewrite_existing) {\n    oflags |= O_EXCL;\n  }\n  return ::open(path, oflags, S_IREAD | S_IWRITE);\n}\n\n// return current position of file pointer\njlong os::current_file_offset(int fd) {\n  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);\n}\n\n// move file pointer to the specified offset\njlong os::seek_to_file_offset(int fd, jlong offset) {\n  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);\n}\n\n// This code originates from JDK's sysAvailable\n// from src/solaris/hpi/src/native_threads/src/sys_api_td.c\n\nint os::available(int fd, jlong *bytes) {\n  jlong cur, end;\n  int mode;\n  struct stat buf;\n\n  if (::fstat(fd, &buf) >= 0) {\n    mode = buf.st_mode;\n    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n      /*\n      * XXX: is the following call interruptible? If so, this might\n      * need to go through the INTERRUPT_IO() wrapper as for other\n      * blocking, interruptible calls in this file.\n      */\n      int n;\n      if (::ioctl(fd, FIONREAD, &n) >= 0) {\n        *bytes = n;\n        return 1;\n      }\n    }\n  }\n  if ((cur = ::lseek(fd, 0L, SEEK_CUR)) == -1) {\n    return 0;\n  } else if ((end = ::lseek(fd, 0L, SEEK_END)) == -1) {\n    return 0;\n  } else if (::lseek(fd, cur, SEEK_SET) == -1) {\n    return 0;\n  }\n  *bytes = end - cur;\n  return 1;\n}\n\nint os::socket_available(int fd, jint *pbytes) {\n   if (fd < 0)\n     return OS_OK;\n\n   int ret;\n\n   RESTARTABLE(::ioctl(fd, FIONREAD, pbytes), ret);\n\n   //%% note ioctl can return 0 when successful, JVM_SocketAvailable\n   // is expected to return 0 on failure and 1 on success to the jdk.\n\n   return (ret == OS_ERR) ? 0 : 1;\n}\n\n// Map a block of memory.\nchar* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,\n                     char *addr, size_t bytes, bool read_only,\n                     bool allow_exec) {\n  int prot;\n  int flags;\n\n  if (read_only) {\n    prot = PROT_READ;\n    flags = MAP_SHARED;\n  } else {\n    prot = PROT_READ | PROT_WRITE;\n    flags = MAP_PRIVATE;\n  }\n\n  if (allow_exec) {\n    prot |= PROT_EXEC;\n  }\n\n  if (addr != NULL) {\n    flags |= MAP_FIXED;\n  }\n\n  char* mapped_address = (char*)mmap(addr, (size_t)bytes, prot, flags,\n                                     fd, file_offset);\n  if (mapped_address == MAP_FAILED) {\n    return NULL;\n  }\n  return mapped_address;\n}\n\n\n// Remap a block of memory.\nchar* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,\n                       char *addr, size_t bytes, bool read_only,\n                       bool allow_exec) {\n  // same as map_memory() on this OS\n  return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,\n                        allow_exec);\n}\n\n\n// Unmap a block of memory.\nbool os::pd_unmap_memory(char* addr, size_t bytes) {\n  return munmap(addr, bytes) == 0;\n}\n\n// current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)\n// are used by JVM M&M and JVMTI to get user+sys or user CPU time\n// of a thread.\n//\n// current_thread_cpu_time() and thread_cpu_time(Thread*) returns\n// the fast estimate available on the platform.\n\njlong os::current_thread_cpu_time() {\n#ifdef __APPLE__\n  return os::thread_cpu_time(Thread::current(), true /* user + sys */);\n#else\n  Unimplemented();\n  return 0;\n#endif\n}\n\njlong os::thread_cpu_time(Thread* thread) {\n#ifdef __APPLE__\n  return os::thread_cpu_time(thread, true /* user + sys */);\n#else\n  Unimplemented();\n  return 0;\n#endif\n}\n\njlong os::current_thread_cpu_time(bool user_sys_cpu_time) {\n#ifdef __APPLE__\n  return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);\n#else\n  Unimplemented();\n  return 0;\n#endif\n}\n\njlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {\n#ifdef __APPLE__\n  struct thread_basic_info tinfo;\n  mach_msg_type_number_t tcount = THREAD_INFO_MAX;\n  kern_return_t kr;\n  thread_t mach_thread;\n\n  mach_thread = thread->osthread()->thread_id();\n  kr = thread_info(mach_thread, THREAD_BASIC_INFO, (thread_info_t)&tinfo, &tcount);\n  if (kr != KERN_SUCCESS)\n    return -1;\n\n  if (user_sys_cpu_time) {\n    jlong nanos;\n    nanos = ((jlong) tinfo.system_time.seconds + tinfo.user_time.seconds) * (jlong)1000000000;\n    nanos += ((jlong) tinfo.system_time.microseconds + (jlong) tinfo.user_time.microseconds) * (jlong)1000;\n    return nanos;\n  } else {\n    return ((jlong)tinfo.user_time.seconds * 1000000000) + ((jlong)tinfo.user_time.microseconds * (jlong)1000);\n  }\n#else\n  Unimplemented();\n  return 0;\n#endif\n}\n\n\nvoid os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nvoid os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nbool os::is_thread_cpu_time_supported() {\n#ifdef __APPLE__\n  return true;\n#else\n  return false;\n#endif\n}\n\n// System loadavg support.  Returns -1 if load average cannot be obtained.\n// Bsd doesn't yet have a (official) notion of processor sets,\n// so just return the system wide load average.\nint os::loadavg(double loadavg[], int nelem) {\n  return ::getloadavg(loadavg, nelem);\n}\n\nvoid os::pause() {\n  char filename[MAX_PATH];\n  if (PauseAtStartupFile && PauseAtStartupFile[0]) {\n    jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);\n  } else {\n    jio_snprintf(filename, MAX_PATH, \"./vm.paused.%d\", current_process_id());\n  }\n\n  int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n  if (fd != -1) {\n    struct stat buf;\n    ::close(fd);\n    while (::stat(filename, &buf) == 0) {\n      (void)::poll(NULL, 0, 100);\n    }\n  } else {\n    jio_fprintf(stderr,\n      \"Could not open pause file '%s', continuing immediately.\\n\", filename);\n  }\n}\n\n\n// Refer to the comments in os_solaris.cpp park-unpark.\n//\n// Beware -- Some versions of NPTL embody a flaw where pthread_cond_timedwait() can\n// hang indefinitely.  For instance NPTL 0.60 on 2.4.21-4ELsmp is vulnerable.\n// For specifics regarding the bug see GLIBC BUGID 261237 :\n//    http://www.mail-archive.com/debian-glibc@lists.debian.org/msg10837.html.\n// Briefly, pthread_cond_timedwait() calls with an expiry time that's not in the future\n// will either hang or corrupt the condvar, resulting in subsequent hangs if the condvar\n// is used.  (The simple C test-case provided in the GLIBC bug report manifests the\n// hang).  The JVM is vulernable via sleep(), Object.wait(timo), LockSupport.parkNanos()\n// and monitorenter when we're using 1-0 locking.  All those operations may result in\n// calls to pthread_cond_timedwait().  Using LD_ASSUME_KERNEL to use an older version\n// of libpthread avoids the problem, but isn't practical.\n//\n// Possible remedies:\n//\n// 1.   Establish a minimum relative wait time.  50 to 100 msecs seems to work.\n//      This is palliative and probabilistic, however.  If the thread is preempted\n//      between the call to compute_abstime() and pthread_cond_timedwait(), more\n//      than the minimum period may have passed, and the abstime may be stale (in the\n//      past) resultin in a hang.   Using this technique reduces the odds of a hang\n//      but the JVM is still vulnerable, particularly on heavily loaded systems.\n//\n// 2.   Modify park-unpark to use per-thread (per ParkEvent) pipe-pairs instead\n//      of the usual flag-condvar-mutex idiom.  The write side of the pipe is set\n//      NDELAY. unpark() reduces to write(), park() reduces to read() and park(timo)\n//      reduces to poll()+read().  This works well, but consumes 2 FDs per extant\n//      thread.\n//\n// 3.   Embargo pthread_cond_timedwait() and implement a native \"chron\" thread\n//      that manages timeouts.  We'd emulate pthread_cond_timedwait() by enqueuing\n//      a timeout request to the chron thread and then blocking via pthread_cond_wait().\n//      This also works well.  In fact it avoids kernel-level scalability impediments\n//      on certain platforms that don't handle lots of active pthread_cond_timedwait()\n//      timers in a graceful fashion.\n//\n// 4.   When the abstime value is in the past it appears that control returns\n//      correctly from pthread_cond_timedwait(), but the condvar is left corrupt.\n//      Subsequent timedwait/wait calls may hang indefinitely.  Given that, we\n//      can avoid the problem by reinitializing the condvar -- by cond_destroy()\n//      followed by cond_init() -- after all calls to pthread_cond_timedwait().\n//      It may be possible to avoid reinitialization by checking the return\n//      value from pthread_cond_timedwait().  In addition to reinitializing the\n//      condvar we must establish the invariant that cond_signal() is only called\n//      within critical sections protected by the adjunct mutex.  This prevents\n//      cond_signal() from \"seeing\" a condvar that's in the midst of being\n//      reinitialized or that is corrupt.  Sadly, this invariant obviates the\n//      desirable signal-after-unlock optimization that avoids futile context switching.\n//\n//      I'm also concerned that some versions of NTPL might allocate an auxilliary\n//      structure when a condvar is used or initialized.  cond_destroy()  would\n//      release the helper structure.  Our reinitialize-after-timedwait fix\n//      put excessive stress on malloc/free and locks protecting the c-heap.\n//\n// We currently use (4).  See the WorkAroundNTPLTimedWaitHang flag.\n// It may be possible to refine (4) by checking the kernel and NTPL verisons\n// and only enabling the work-around for vulnerable environments.\n\n// utility to compute the abstime argument to timedwait:\n// millis is the relative timeout time\n// abstime will be the absolute timeout time\n// TODO: replace compute_abstime() with unpackTime()\n\nstatic struct timespec* compute_abstime(struct timespec* abstime, jlong millis) {\n  if (millis < 0)  millis = 0;\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n  jlong seconds = millis / 1000;\n  millis %= 1000;\n  if (seconds > 50000000) { // see man cond_timedwait(3T)\n    seconds = 50000000;\n  }\n  abstime->tv_sec = now.tv_sec  + seconds;\n  long       usec = now.tv_usec + millis * 1000;\n  if (usec >= 1000000) {\n    abstime->tv_sec += 1;\n    usec -= 1000000;\n  }\n  abstime->tv_nsec = usec * 1000;\n  return abstime;\n}\n\n\n// Test-and-clear _Event, always leaves _Event set to 0, returns immediately.\n// Conceptually TryPark() should be equivalent to park(0).\n\nint os::PlatformEvent::TryPark() {\n  for (;;) {\n    const int v = _Event ;\n    guarantee ((v == 0) || (v == 1), \"invariant\") ;\n    if (Atomic::cmpxchg (0, &_Event, v) == v) return v  ;\n  }\n}\n\nvoid os::PlatformEvent::park() {       // AKA \"down()\"\n  // Invariant: Only the thread associated with the Event/PlatformEvent\n  // may call park().\n  // TODO: assert that _Assoc != NULL or _Assoc == Self\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v == 0) {\n     // Do this the hard way by blocking ...\n     int status = pthread_mutex_lock(_mutex);\n     assert_status(status == 0, status, \"mutex_lock\");\n     guarantee (_nParked == 0, \"invariant\") ;\n     ++ _nParked ;\n     while (_Event < 0) {\n        status = pthread_cond_wait(_cond, _mutex);\n        // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...\n        // Treat this the same as if the wait was interrupted\n        if (status == ETIMEDOUT) { status = EINTR; }\n        assert_status(status == 0 || status == EINTR, status, \"cond_wait\");\n     }\n     -- _nParked ;\n\n    _Event = 0 ;\n     status = pthread_mutex_unlock(_mutex);\n     assert_status(status == 0, status, \"mutex_unlock\");\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other.\n    OrderAccess::fence();\n  }\n  guarantee (_Event >= 0, \"invariant\") ;\n}\n\nint os::PlatformEvent::park(jlong millis) {\n  guarantee (_nParked == 0, \"invariant\") ;\n\n  int v ;\n  for (;;) {\n      v = _Event ;\n      if (Atomic::cmpxchg (v-1, &_Event, v) == v) break ;\n  }\n  guarantee (v >= 0, \"invariant\") ;\n  if (v != 0) return OS_OK ;\n\n  // We do this the hard way, by blocking the thread.\n  // Consider enforcing a minimum timeout value.\n  struct timespec abst;\n  compute_abstime(&abst, millis);\n\n  int ret = OS_TIMEOUT;\n  int status = pthread_mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  guarantee (_nParked == 0, \"invariant\") ;\n  ++_nParked ;\n\n  // Object.wait(timo) will return because of\n  // (a) notification\n  // (b) timeout\n  // (c) thread.interrupt\n  //\n  // Thread.interrupt and object.notify{All} both call Event::set.\n  // That is, we treat thread.interrupt as a special case of notification.\n  // The underlying Solaris implementation, cond_timedwait, admits\n  // spurious/premature wakeups, but the JLS/JVM spec prevents the\n  // JVM from making those visible to Java code.  As such, we must\n  // filter out spurious wakeups.  We assume all ETIME returns are valid.\n  //\n  // TODO: properly differentiate simultaneous notify+interrupt.\n  // In that case, we should propagate the notify to another waiter.\n\n  while (_Event < 0) {\n    status = os::Bsd::safe_cond_timedwait(_cond, _mutex, &abst);\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (_cond);\n      pthread_cond_init (_cond, NULL) ;\n    }\n    assert_status(status == 0 || status == EINTR ||\n                  status == ETIMEDOUT,\n                  status, \"cond_timedwait\");\n    if (!FilterSpuriousWakeups) break ;                 // previous semantics\n    if (status == ETIMEDOUT) break ;\n    // We consume and ignore EINTR and spurious wakeups.\n  }\n  --_nParked ;\n  if (_Event >= 0) {\n     ret = OS_OK;\n  }\n  _Event = 0 ;\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  assert (_nParked == 0, \"invariant\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other.\n  OrderAccess::fence();\n  return ret;\n}\n\nvoid os::PlatformEvent::unpark() {\n  // Transitions for _Event:\n  //    0 :=> 1\n  //    1 :=> 1\n  //   -1 :=> either 0 or 1; must signal target thread\n  //          That is, we can safely transition _Event from -1 to either\n  //          0 or 1. Forcing 1 is slightly more efficient for back-to-back\n  //          unpark() calls.\n  // See also: \"Semaphores in Plan 9\" by Mullender & Cox\n  //\n  // Note: Forcing a transition from \"-1\" to \"1\" on an unpark() means\n  // that it will take two back-to-back park() calls for the owning\n  // thread to block. This has the benefit of forcing a spurious return\n  // from the first park() call after an unpark() call which will help\n  // shake out uses of park() and unpark() without condition variables.\n\n  if (Atomic::xchg(1, &_Event) >= 0) return;\n\n  // Wait for the thread associated with the event to vacate\n  int status = pthread_mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  int AnyWaiters = _nParked;\n  assert(AnyWaiters == 0 || AnyWaiters == 1, \"invariant\");\n  if (AnyWaiters != 0 && WorkAroundNPTLTimedWaitHang) {\n    AnyWaiters = 0;\n    pthread_cond_signal(_cond);\n  }\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  if (AnyWaiters != 0) {\n    status = pthread_cond_signal(_cond);\n    assert_status(status == 0, status, \"cond_signal\");\n  }\n\n  // Note that we signal() _after dropping the lock for \"immortal\" Events.\n  // This is safe and avoids a common class of  futile wakeups.  In rare\n  // circumstances this can cause a thread to return prematurely from\n  // cond_{timed}wait() but the spurious wakeup is benign and the victim will\n  // simply re-test the condition and re-park itself.\n}\n\n\n// JSR166\n// -------------------------------------------------------\n\n/*\n * The solaris and bsd implementations of park/unpark are fairly\n * conservative for now, but can be improved. They currently use a\n * mutex/condvar pair, plus a a count.\n * Park decrements count if > 0, else does a condvar wait.  Unpark\n * sets count to 1 and signals condvar.  Only one thread ever waits\n * on the condvar. Contention seen when trying to park implies that someone\n * is unparking you, so don't wait. And spurious returns are fine, so there\n * is no need to track notifications.\n */\n\n#define MAX_SECS 100000000\n/*\n * This code is common to bsd and solaris and will be moved to a\n * common place in dolphin.\n *\n * The passed in time value is either a relative time in nanoseconds\n * or an absolute time in milliseconds. Either way it has to be unpacked\n * into suitable seconds and nanoseconds components and stored in the\n * given timespec structure.\n * Given time is a 64-bit value and the time_t used in the timespec is only\n * a signed-32-bit value (except on 64-bit Bsd) we have to watch for\n * overflow if times way in the future are given. Further on Solaris versions\n * prior to 10 there is a restriction (see cond_timedwait) that the specified\n * number of seconds, in abstime, is less than current_time  + 100,000,000.\n * As it will be 28 years before \"now + 100000000\" will overflow we can\n * ignore overflow and just impose a hard-limit on seconds using the value\n * of \"now + 100,000,000\". This places a limit on the timeout of about 3.17\n * years from \"now\".\n */\n\nstatic void unpackTime(struct timespec* absTime, bool isAbsolute, jlong time) {\n  assert (time > 0, \"convertTime\");\n\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n\n  time_t max_secs = now.tv_sec + MAX_SECS;\n\n  if (isAbsolute) {\n    jlong secs = time / 1000;\n    if (secs > max_secs) {\n      absTime->tv_sec = max_secs;\n    }\n    else {\n      absTime->tv_sec = secs;\n    }\n    absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;\n  }\n  else {\n    jlong secs = time / NANOSECS_PER_SEC;\n    if (secs >= MAX_SECS) {\n      absTime->tv_sec = max_secs;\n      absTime->tv_nsec = 0;\n    }\n    else {\n      absTime->tv_sec = now.tv_sec + secs;\n      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;\n      if (absTime->tv_nsec >= NANOSECS_PER_SEC) {\n        absTime->tv_nsec -= NANOSECS_PER_SEC;\n        ++absTime->tv_sec; // note: this must be <= max_secs\n      }\n    }\n  }\n  assert(absTime->tv_sec >= 0, \"tv_sec < 0\");\n  assert(absTime->tv_sec <= max_secs, \"tv_sec > max_secs\");\n  assert(absTime->tv_nsec >= 0, \"tv_nsec < 0\");\n  assert(absTime->tv_nsec < NANOSECS_PER_SEC, \"tv_nsec >= nanos_per_sec\");\n}\n\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n  if (Atomic::xchg(0, &_counter) > 0) return;\n\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n  JavaThread *jt = (JavaThread *)thread;\n\n  // Optional optimization -- avoid state transitions if there's an interrupt pending.\n  // Check interrupt before trying to wait\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n\n  // Next, demultiplex/decode time arguments\n  struct timespec absTime;\n  if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all\n    return;\n  }\n  if (time > 0) {\n    unpackTime(&absTime, isAbsolute, time);\n  }\n\n\n  // Enter safepoint region\n  // Beware of deadlocks such as 6317397.\n  // The per-thread Parker:: mutex is a classic leaf-lock.\n  // In particular a thread must never block on the Threads_lock while\n  // holding the Parker:: mutex.  If safepoints are pending both the\n  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.\n  ThreadBlockInVM tbivm(jt);\n\n  // Don't wait if cannot get lock since interference arises from\n  // unblocking.  Also. check interrupt before trying wait\n  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {\n    return;\n  }\n\n  int status ;\n  if (_counter > 0)  { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other and Java-level accesses.\n    OrderAccess::fence();\n    return;\n  }\n\n#ifdef ASSERT\n  // Don't catch signals while blocked; let the running threads have the signals.\n  // (This allows a debugger to break into the running thread.)\n  sigset_t oldsigs;\n  sigset_t* allowdebug_blocked = os::Bsd::allowdebug_blocked_signals();\n  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);\n#endif\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex) ;\n  } else {\n    status = os::Bsd::safe_cond_timedwait (_cond, _mutex, &absTime) ;\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (_cond) ;\n      pthread_cond_init    (_cond, NULL);\n    }\n  }\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n\n  _counter = 0 ;\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other and Java-level accesses.\n  OrderAccess::fence();\n\n  // If externally suspended while waiting, re-suspend\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n}\n\nvoid Parker::unpark() {\n  int s, status ;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n     if (WorkAroundNPTLTimedWaitHang) {\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") ;\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n     } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\") ;\n        status = pthread_cond_signal (_cond) ;\n        assert (status == 0, \"invariant\") ;\n     }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n\n\n/* Darwin has no \"environ\" in a dynamic library. */\n#ifdef __APPLE__\n#include <crt_externs.h>\n#define environ (*_NSGetEnviron())\n#else\nextern char** environ;\n#endif\n\n// Run the specified command in a separate process. Return its exit value,\n// or -1 on failure (e.g. can't fork a new process).\n// Unlike system(), this function can be called from signal handler. It\n// doesn't block SIGINT et al.\nint os::fork_and_exec(char* cmd) {\n  const char * argv[4] = {\"sh\", \"-c\", cmd, NULL};\n\n  // fork() in BsdThreads/NPTL is not async-safe. It needs to run\n  // pthread_atfork handlers and reset pthread library. All we need is a\n  // separate process to execve. Make a direct syscall to fork process.\n  // On IA64 there's no fork syscall, we have to use fork() and hope for\n  // the best...\n  pid_t pid = fork();\n\n  if (pid < 0) {\n    // fork failed\n    return -1;\n\n  } else if (pid == 0) {\n    // child process\n\n    // execve() in BsdThreads will call pthread_kill_other_threads_np()\n    // first to kill every thread on the thread list. Because this list is\n    // not reset by fork() (see notes above), execve() will instead kill\n    // every thread in the parent process. We know this is the only thread\n    // in the new process, so make a system call directly.\n    // IA64 should use normal execve() from glibc to match the glibc fork()\n    // above.\n    execve(\"/bin/sh\", (char* const*)argv, environ);\n\n    // execve failed\n    _exit(-1);\n\n  } else  {\n    // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n    // care about the actual exit code, for now.\n\n    int status;\n\n    // Wait for the child process to exit.  This returns immediately if\n    // the child has already exited. */\n    while (waitpid(pid, &status, 0) < 0) {\n        switch (errno) {\n        case ECHILD: return 0;\n        case EINTR: break;\n        default: return -1;\n        }\n    }\n\n    if (WIFEXITED(status)) {\n       // The child exited normally; get its exit code.\n       return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n       // The child exited because of a signal\n       // The best value to return is 0x80 + signal number,\n       // because that is what all Unix shells do, and because\n       // it allows callers to distinguish between process exit and\n       // process death by signal.\n       return 0x80 + WTERMSIG(status);\n    } else {\n       // Unknown exit code; pass it through\n       return status;\n    }\n  }\n}\n\n// is_headless_jre()\n//\n// Test for the existence of xawt/libmawt.so or libawt_xawt.so\n// in order to report if we are running in a headless jre\n//\n// Since JDK8 xawt/libmawt.so was moved into the same directory\n// as libawt.so, and renamed libawt_xawt.so\n//\nbool os::is_headless_jre() {\n#ifdef __APPLE__\n    // We no longer build headless-only on Mac OS X\n    return false;\n#else\n    struct stat statbuf;\n    char buf[MAXPATHLEN];\n    char libmawtpath[MAXPATHLEN];\n    const char *xawtstr  = \"/xawt/libmawt\" JNI_LIB_SUFFIX;\n    const char *new_xawtstr = \"/libawt_xawt\" JNI_LIB_SUFFIX;\n    char *p;\n\n    // Get path to libjvm.so\n    os::jvm_path(buf, sizeof(buf));\n\n    // Get rid of libjvm.so\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // Get rid of client or server\n    p = strrchr(buf, '/');\n    if (p == NULL) return false;\n    else *p = '\\0';\n\n    // check xawt/libmawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    // check libawt_xawt.so\n    strcpy(libmawtpath, buf);\n    strcat(libmawtpath, new_xawtstr);\n    if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n    return true;\n#endif\n}\n\n// Get the default path to the core file\n// Returns the length of the string\nint os::get_core_path(char* buffer, size_t bufferSize) {\n  int n = jio_snprintf(buffer, bufferSize, \"/cores\");\n\n  // Truncate if theoretical string was longer than bufferSize\n  n = MIN2(n, (int)bufferSize);\n\n  return n;\n}\n\n#ifndef PRODUCT\nvoid TestReserveMemorySpecial_test() {\n  // No tests available for this platform\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os/aix/vm/os_aix.cpp": "/*\n * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.\n * Copyright 2012, 2014 SAP AG. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n// According to the AIX OS doc #pragma alloca must be used\n// with C++ compiler before referencing the function alloca()\n#pragma alloca\n\n// no precompiled headers\n#include \"classfile/classLoader.hpp\"\n#include \"classfile/systemDictionary.hpp\"\n#include \"classfile/vmSymbols.hpp\"\n#include \"code/icBuffer.hpp\"\n#include \"code/vtableStubs.hpp\"\n#include \"compiler/compileBroker.hpp\"\n#include \"interpreter/interpreter.hpp\"\n#include \"jvm_aix.h\"\n#include \"libperfstat_aix.hpp\"\n#include \"loadlib_aix.hpp\"\n#include \"memory/allocation.inline.hpp\"\n#include \"memory/filemap.hpp\"\n#include \"mutex_aix.inline.hpp\"\n#include \"oops/oop.inline.hpp\"\n#include \"os_share_aix.hpp\"\n#include \"porting_aix.hpp\"\n#include \"prims/jniFastGetField.hpp\"\n#include \"prims/jvm.h\"\n#include \"prims/jvm_misc.hpp\"\n#include \"runtime/arguments.hpp\"\n#include \"runtime/extendedPC.hpp\"\n#include \"runtime/globals.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/java.hpp\"\n#include \"runtime/javaCalls.hpp\"\n#include \"runtime/mutexLocker.hpp\"\n#include \"runtime/objectMonitor.hpp\"\n#include \"runtime/orderAccess.inline.hpp\"\n#include \"runtime/osThread.hpp\"\n#include \"runtime/perfMemory.hpp\"\n#include \"runtime/sharedRuntime.hpp\"\n#include \"runtime/statSampler.hpp\"\n#include \"runtime/stubRoutines.hpp\"\n#include \"runtime/thread.inline.hpp\"\n#include \"runtime/threadCritical.hpp\"\n#include \"runtime/timer.hpp\"\n#include \"services/attachListener.hpp\"\n#include \"services/runtimeService.hpp\"\n#include \"utilities/decoder.hpp\"\n#include \"utilities/defaultStream.hpp\"\n#include \"utilities/events.hpp\"\n#include \"utilities/growableArray.hpp\"\n#include \"utilities/vmError.hpp\"\n\n// put OS-includes here (sorted alphabetically)\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <poll.h>\n#include <procinfo.h>\n#include <pthread.h>\n#include <pwd.h>\n#include <semaphore.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <sys/ipc.h>\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <sys/select.h>\n#include <sys/shm.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/sysinfo.h>\n#include <sys/systemcfg.h>\n#include <sys/time.h>\n#include <sys/times.h>\n#include <sys/types.h>\n#include <sys/utsname.h>\n#include <sys/vminfo.h>\n#include <sys/wait.h>\n\n// Add missing declarations (should be in procinfo.h but isn't until AIX 6.1).\n#if !defined(_AIXVERSION_610)\nextern \"C\" {\n  int getthrds64(pid_t ProcessIdentifier,\n                 struct thrdentry64* ThreadBuffer,\n                 int ThreadSize,\n                 tid64_t* IndexPointer,\n                 int Count);\n}\n#endif\n\n#define MAX_PATH (2 * K)\n\n// for timer info max values which include all bits\n#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n// for multipage initialization error analysis (in 'g_multipage_error')\n#define ERROR_MP_OS_TOO_OLD                          100\n#define ERROR_MP_EXTSHM_ACTIVE                       101\n#define ERROR_MP_VMGETINFO_FAILED                    102\n#define ERROR_MP_VMGETINFO_CLAIMS_NO_SUPPORT_FOR_64K 103\n\n// The semantics in this file are thus that codeptr_t is a *real code ptr*.\n// This means that any function taking codeptr_t as arguments will assume\n// a real codeptr and won't handle function descriptors (eg getFuncName),\n// whereas functions taking address as args will deal with function\n// descriptors (eg os::dll_address_to_library_name).\ntypedef unsigned int* codeptr_t;\n\n// Typedefs for stackslots, stack pointers, pointers to op codes.\ntypedef unsigned long stackslot_t;\ntypedef stackslot_t* stackptr_t;\n\n// Excerpts from systemcfg.h definitions newer than AIX 5.3.\n#ifndef PV_7\n#define PV_7 0x200000          /* Power PC 7 */\n#define PV_7_Compat 0x208000   /* Power PC 7 */\n#endif\n#ifndef PV_8\n#define PV_8 0x300000          /* Power PC 8 */\n#define PV_8_Compat 0x308000   /* Power PC 8 */\n#endif\n\n#define trcVerbose(fmt, ...) { /* PPC port */  \\\n  if (Verbose) { \\\n    fprintf(stderr, fmt, ##__VA_ARGS__); \\\n    fputc('\\n', stderr); fflush(stderr); \\\n  } \\\n}\n#define trc(fmt, ...)        /* PPC port */\n\n#define ERRBYE(s) { \\\n    trcVerbose(s); \\\n    return -1; \\\n}\n\n// query dimensions of the stack of the calling thread\nstatic void query_stack_dimensions(address* p_stack_base, size_t* p_stack_size);\n\n// function to check a given stack pointer against given stack limits\ninline bool is_valid_stackpointer(stackptr_t sp, stackptr_t stack_base, size_t stack_size) {\n  if (((uintptr_t)sp) & 0x7) {\n    return false;\n  }\n  if (sp > stack_base) {\n    return false;\n  }\n  if (sp < (stackptr_t) ((address)stack_base - stack_size)) {\n    return false;\n  }\n  return true;\n}\n\n// returns true if function is a valid codepointer\ninline bool is_valid_codepointer(codeptr_t p) {\n  if (!p) {\n    return false;\n  }\n  if (((uintptr_t)p) & 0x3) {\n    return false;\n  }\n  if (LoadedLibraries::find_for_text_address((address)p) == NULL) {\n    return false;\n  }\n  return true;\n}\n\n// Macro to check a given stack pointer against given stack limits and to die if test fails.\n#define CHECK_STACK_PTR(sp, stack_base, stack_size) { \\\n    guarantee(is_valid_stackpointer((stackptr_t)(sp), (stackptr_t)(stack_base), stack_size), \"Stack Pointer Invalid\"); \\\n}\n\n// Macro to check the current stack pointer against given stacklimits.\n#define CHECK_CURRENT_STACK_PTR(stack_base, stack_size) { \\\n  address sp; \\\n  sp = os::current_stack_pointer(); \\\n  CHECK_STACK_PTR(sp, stack_base, stack_size); \\\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// global variables (for a description see os_aix.hpp)\n\njulong    os::Aix::_physical_memory = 0;\npthread_t os::Aix::_main_thread = ((pthread_t)0);\nint       os::Aix::_page_size = -1;\nint       os::Aix::_on_pase = -1;\nint       os::Aix::_os_version = -1;\nint       os::Aix::_stack_page_size = -1;\nsize_t    os::Aix::_shm_default_page_size = -1;\nint       os::Aix::_can_use_64K_pages = -1;\nint       os::Aix::_can_use_16M_pages = -1;\nint       os::Aix::_xpg_sus_mode = -1;\nint       os::Aix::_extshm = -1;\nint       os::Aix::_logical_cpus = -1;\n\n////////////////////////////////////////////////////////////////////////////////\n// local variables\n\nstatic int      g_multipage_error  = -1;   // error analysis for multipage initialization\nstatic jlong    initial_time_count = 0;\nstatic int      clock_tics_per_sec = 100;\nstatic sigset_t check_signal_done;         // For diagnostics to print a message once (see run_periodic_checks)\nstatic bool     check_signals      = true;\nstatic pid_t    _initial_pid       = 0;\nstatic int      SR_signum          = SIGUSR2; // Signal used to suspend/resume a thread (must be > SIGSEGV, see 4355769)\nstatic sigset_t SR_sigset;\nstatic pthread_mutex_t dl_mutex;              // Used to protect dlsym() calls.\n\njulong os::available_memory() {\n  return Aix::available_memory();\n}\n\njulong os::Aix::available_memory() {\n  os::Aix::meminfo_t mi;\n  if (os::Aix::get_meminfo(&mi)) {\n    return mi.real_free;\n  } else {\n    return 0xFFFFFFFFFFFFFFFFLL;\n  }\n}\n\njulong os::physical_memory() {\n  return Aix::physical_memory();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// environment support\n\nbool os::getenv(const char* name, char* buf, int len) {\n  const char* val = ::getenv(name);\n  if (val != NULL && strlen(val) < (size_t)len) {\n    strcpy(buf, val);\n    return true;\n  }\n  if (len > 0) buf[0] = 0;  // return a null string\n  return false;\n}\n\n// Return true if user is running as root.\n\nbool os::have_special_privileges() {\n  static bool init = false;\n  static bool privileges = false;\n  if (!init) {\n    privileges = (getuid() != geteuid()) || (getgid() != getegid());\n    init = true;\n  }\n  return privileges;\n}\n\n// Helper function, emulates disclaim64 using multiple 32bit disclaims\n// because we cannot use disclaim64() on AS/400 and old AIX releases.\nstatic bool my_disclaim64(char* addr, size_t size) {\n\n  if (size == 0) {\n    return true;\n  }\n\n  // Maximum size 32bit disclaim() accepts. (Theoretically 4GB, but I just do not trust that.)\n  const unsigned int maxDisclaimSize = 0x80000000;\n\n  const unsigned int numFullDisclaimsNeeded = (size / maxDisclaimSize);\n  const unsigned int lastDisclaimSize = (size % maxDisclaimSize);\n\n  char* p = addr;\n\n  for (int i = 0; i < numFullDisclaimsNeeded; i ++) {\n    if (::disclaim(p, maxDisclaimSize, DISCLAIM_ZEROMEM) != 0) {\n      trc(\"Cannot disclaim %p - %p (errno %d)\\n\", p, p + maxDisclaimSize, errno);\n      return false;\n    }\n    p += maxDisclaimSize;\n  }\n\n  if (lastDisclaimSize > 0) {\n    if (::disclaim(p, lastDisclaimSize, DISCLAIM_ZEROMEM) != 0) {\n      trc(\"Cannot disclaim %p - %p (errno %d)\\n\", p, p + lastDisclaimSize, errno);\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Cpu architecture string\n#if defined(PPC32)\nstatic char cpu_arch[] = \"ppc\";\n#elif defined(PPC64)\nstatic char cpu_arch[] = \"ppc64\";\n#else\n#error Add appropriate cpu_arch setting\n#endif\n\n\n// Given an address, returns the size of the page backing that address.\nsize_t os::Aix::query_pagesize(void* addr) {\n\n  vm_page_info pi;\n  pi.addr = (uint64_t)addr;\n  if (::vmgetinfo(&pi, VM_PAGE_INFO, sizeof(pi)) == 0) {\n    return pi.pagesize;\n  } else {\n    fprintf(stderr, \"vmgetinfo failed to retrieve page size for address %p (errno %d).\\n\", addr, errno);\n    assert(false, \"vmgetinfo failed to retrieve page size\");\n    return SIZE_4K;\n  }\n\n}\n\n// Returns the kernel thread id of the currently running thread.\npid_t os::Aix::gettid() {\n  return (pid_t) thread_self();\n}\n\nvoid os::Aix::initialize_system_info() {\n\n  // Get the number of online(logical) cpus instead of configured.\n  os::_processor_count = sysconf(_SC_NPROCESSORS_ONLN);\n  assert(_processor_count > 0, \"_processor_count must be > 0\");\n\n  // Retrieve total physical storage.\n  os::Aix::meminfo_t mi;\n  if (!os::Aix::get_meminfo(&mi)) {\n    fprintf(stderr, \"os::Aix::get_meminfo failed.\\n\"); fflush(stderr);\n    assert(false, \"os::Aix::get_meminfo failed.\");\n  }\n  _physical_memory = (julong) mi.real_total;\n}\n\n// Helper function for tracing page sizes.\nstatic const char* describe_pagesize(size_t pagesize) {\n  switch (pagesize) {\n    case SIZE_4K : return \"4K\";\n    case SIZE_64K: return \"64K\";\n    case SIZE_16M: return \"16M\";\n    case SIZE_16G: return \"16G\";\n    default:\n      assert(false, \"surprise\");\n      return \"??\";\n  }\n}\n\n// Retrieve information about multipage size support. Will initialize\n// Aix::_page_size, Aix::_stack_page_size, Aix::_can_use_64K_pages,\n// Aix::_can_use_16M_pages.\n// Must be called before calling os::large_page_init().\nvoid os::Aix::query_multipage_support() {\n\n  guarantee(_page_size == -1 &&\n            _stack_page_size == -1 &&\n            _can_use_64K_pages == -1 &&\n            _can_use_16M_pages == -1 &&\n            g_multipage_error == -1,\n            \"do not call twice\");\n\n  _page_size = ::sysconf(_SC_PAGESIZE);\n\n  // This really would surprise me.\n  assert(_page_size == SIZE_4K, \"surprise!\");\n\n\n  // Query default data page size (default page size for C-Heap, pthread stacks and .bss).\n  // Default data page size is influenced either by linker options (-bdatapsize)\n  // or by environment variable LDR_CNTRL (suboption DATAPSIZE). If none is given,\n  // default should be 4K.\n  size_t data_page_size = SIZE_4K;\n  {\n    void* p = ::malloc(SIZE_16M);\n    guarantee(p != NULL, \"malloc failed\");\n    data_page_size = os::Aix::query_pagesize(p);\n    ::free(p);\n  }\n\n  // query default shm page size (LDR_CNTRL SHMPSIZE)\n  {\n    const int shmid = ::shmget(IPC_PRIVATE, 1, IPC_CREAT | S_IRUSR | S_IWUSR);\n    guarantee(shmid != -1, \"shmget failed\");\n    void* p = ::shmat(shmid, NULL, 0);\n    ::shmctl(shmid, IPC_RMID, NULL);\n    guarantee(p != (void*) -1, \"shmat failed\");\n    _shm_default_page_size = os::Aix::query_pagesize(p);\n    ::shmdt(p);\n  }\n\n  // before querying the stack page size, make sure we are not running as primordial\n  // thread (because primordial thread's stack may have different page size than\n  // pthread thread stacks). Running a VM on the primordial thread won't work for a\n  // number of reasons so we may just as well guarantee it here\n  guarantee(!os::Aix::is_primordial_thread(), \"Must not be called for primordial thread\");\n\n  // query stack page size\n  {\n    int dummy = 0;\n    _stack_page_size = os::Aix::query_pagesize(&dummy);\n    // everything else would surprise me and should be looked into\n    guarantee(_stack_page_size == SIZE_4K || _stack_page_size == SIZE_64K, \"Wrong page size\");\n    // also, just for completeness: pthread stacks are allocated from C heap, so\n    // stack page size should be the same as data page size\n    guarantee(_stack_page_size == data_page_size, \"stack page size should be the same as data page size\");\n  }\n\n  // EXTSHM is bad: among other things, it prevents setting pagesize dynamically\n  // for system V shm.\n  if (Aix::extshm()) {\n    if (Verbose) {\n      fprintf(stderr, \"EXTSHM is active - will disable large page support.\\n\"\n                      \"Please make sure EXTSHM is OFF for large page support.\\n\");\n    }\n    g_multipage_error = ERROR_MP_EXTSHM_ACTIVE;\n    _can_use_64K_pages = _can_use_16M_pages = 0;\n    goto query_multipage_support_end;\n  }\n\n  // now check which page sizes the OS claims it supports, and of those, which actually can be used.\n  {\n    const int MAX_PAGE_SIZES = 4;\n    psize_t sizes[MAX_PAGE_SIZES];\n    const int num_psizes = ::vmgetinfo(sizes, VMINFO_GETPSIZES, MAX_PAGE_SIZES);\n    if (num_psizes == -1) {\n      if (Verbose) {\n        fprintf(stderr, \"vmgetinfo(VMINFO_GETPSIZES) failed (errno: %d)\\n\", errno);\n        fprintf(stderr, \"disabling multipage support.\\n\");\n      }\n      g_multipage_error = ERROR_MP_VMGETINFO_FAILED;\n      _can_use_64K_pages = _can_use_16M_pages = 0;\n      goto query_multipage_support_end;\n    }\n    guarantee(num_psizes > 0, \"vmgetinfo(.., VMINFO_GETPSIZES, ...) failed.\");\n    assert(num_psizes <= MAX_PAGE_SIZES, \"Surprise! more than 4 page sizes?\");\n    if (Verbose) {\n      fprintf(stderr, \"vmgetinfo(.., VMINFO_GETPSIZES, ...) returns %d supported page sizes: \", num_psizes);\n      for (int i = 0; i < num_psizes; i ++) {\n        fprintf(stderr, \" %s \", describe_pagesize(sizes[i]));\n      }\n      fprintf(stderr, \" .\\n\");\n    }\n\n    // Can we use 64K, 16M pages?\n    _can_use_64K_pages = 0;\n    _can_use_16M_pages = 0;\n    for (int i = 0; i < num_psizes; i ++) {\n      if (sizes[i] == SIZE_64K) {\n        _can_use_64K_pages = 1;\n      } else if (sizes[i] == SIZE_16M) {\n        _can_use_16M_pages = 1;\n      }\n    }\n\n    if (!_can_use_64K_pages) {\n      g_multipage_error = ERROR_MP_VMGETINFO_CLAIMS_NO_SUPPORT_FOR_64K;\n    }\n\n    // Double-check for 16M pages: Even if AIX claims to be able to use 16M pages,\n    // there must be an actual 16M page pool, and we must run with enough rights.\n    if (_can_use_16M_pages) {\n      const int shmid = ::shmget(IPC_PRIVATE, SIZE_16M, IPC_CREAT | S_IRUSR | S_IWUSR);\n      guarantee(shmid != -1, \"shmget failed\");\n      struct shmid_ds shm_buf = { 0 };\n      shm_buf.shm_pagesize = SIZE_16M;\n      const bool can_set_pagesize = ::shmctl(shmid, SHM_PAGESIZE, &shm_buf) == 0 ? true : false;\n      const int en = errno;\n      ::shmctl(shmid, IPC_RMID, NULL);\n      if (!can_set_pagesize) {\n        if (Verbose) {\n          fprintf(stderr, \"Failed to allocate even one misely 16M page. shmctl failed with %d (%s).\\n\"\n                          \"Will deactivate 16M support.\\n\", en, strerror(en));\n        }\n        _can_use_16M_pages = 0;\n      }\n    }\n\n  } // end: check which pages can be used for shared memory\n\nquery_multipage_support_end:\n\n  guarantee(_page_size != -1 &&\n            _stack_page_size != -1 &&\n            _can_use_64K_pages != -1 &&\n            _can_use_16M_pages != -1, \"Page sizes not properly initialized\");\n\n  if (_can_use_64K_pages) {\n    g_multipage_error = 0;\n  }\n\n  if (Verbose) {\n    fprintf(stderr, \"Data page size (C-Heap, bss, etc): %s\\n\", describe_pagesize(data_page_size));\n    fprintf(stderr, \"Thread stack page size (pthread): %s\\n\", describe_pagesize(_stack_page_size));\n    fprintf(stderr, \"Default shared memory page size: %s\\n\", describe_pagesize(_shm_default_page_size));\n    fprintf(stderr, \"Can use 64K pages dynamically with shared meory: %s\\n\", (_can_use_64K_pages ? \"yes\" :\"no\"));\n    fprintf(stderr, \"Can use 16M pages dynamically with shared memory: %s\\n\", (_can_use_16M_pages ? \"yes\" :\"no\"));\n    fprintf(stderr, \"Multipage error details: %d\\n\", g_multipage_error);\n  }\n\n} // end os::Aix::query_multipage_support()\n\nvoid os::init_system_properties_values() {\n\n#define DEFAULT_LIBPATH \"/usr/lib:/lib\"\n#define EXTENSIONS_DIR  \"/lib/ext\"\n#define ENDORSED_DIR    \"/lib/endorsed\"\n\n  // Buffer that fits several sprintfs.\n  // Note that the space for the trailing null is provided\n  // by the nulls included by the sizeof operator.\n  const size_t bufsize =\n    MAX3((size_t)MAXPATHLEN,  // For dll_dir & friends.\n         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR), // extensions dir\n         (size_t)MAXPATHLEN + sizeof(ENDORSED_DIR)); // endorsed dir\n  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n\n  // sysclasspath, java_home, dll_dir\n  {\n    char *pslash;\n    os::jvm_path(buf, bufsize);\n\n    // Found the full path to libjvm.so.\n    // Now cut the path to <java_home>/jre if we can.\n    *(strrchr(buf, '/')) = '\\0'; // Get rid of /libjvm.so.\n    pslash = strrchr(buf, '/');\n    if (pslash != NULL) {\n      *pslash = '\\0';            // Get rid of /{client|server|hotspot}.\n    }\n    Arguments::set_dll_dir(buf);\n\n    if (pslash != NULL) {\n      pslash = strrchr(buf, '/');\n      if (pslash != NULL) {\n        *pslash = '\\0';          // Get rid of /<arch>.\n        pslash = strrchr(buf, '/');\n        if (pslash != NULL) {\n          *pslash = '\\0';        // Get rid of /lib.\n        }\n      }\n    }\n    Arguments::set_java_home(buf);\n    set_boot_path('/', ':');\n  }\n\n  // Where to look for native libraries.\n\n  // On Aix we get the user setting of LIBPATH.\n  // Eventually, all the library path setting will be done here.\n  // Get the user setting of LIBPATH.\n  const char *v = ::getenv(\"LIBPATH\");\n  const char *v_colon = \":\";\n  if (v == NULL) { v = \"\"; v_colon = \"\"; }\n\n  // Concatenate user and invariant part of ld_library_path.\n  // That's +1 for the colon and +1 for the trailing '\\0'.\n  char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char, strlen(v) + 1 + sizeof(DEFAULT_LIBPATH) + 1, mtInternal);\n  sprintf(ld_library_path, \"%s%s\" DEFAULT_LIBPATH, v, v_colon);\n  Arguments::set_library_path(ld_library_path);\n  FREE_C_HEAP_ARRAY(char, ld_library_path, mtInternal);\n\n  // Extensions directories.\n  sprintf(buf, \"%s\" EXTENSIONS_DIR, Arguments::get_java_home());\n  Arguments::set_ext_dirs(buf);\n\n  // Endorsed standards default directory.\n  sprintf(buf, \"%s\" ENDORSED_DIR, Arguments::get_java_home());\n  Arguments::set_endorsed_dirs(buf);\n\n  FREE_C_HEAP_ARRAY(char, buf, mtInternal);\n\n#undef DEFAULT_LIBPATH\n#undef EXTENSIONS_DIR\n#undef ENDORSED_DIR\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// breakpoint support\n\nvoid os::breakpoint() {\n  BREAKPOINT;\n}\n\nextern \"C\" void breakpoint() {\n  // use debugger to set breakpoint here\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// signal support\n\ndebug_only(static bool signal_sets_initialized = false);\nstatic sigset_t unblocked_sigs, vm_sigs, allowdebug_blocked_sigs;\n\nbool os::Aix::is_sig_ignored(int sig) {\n  struct sigaction oact;\n  sigaction(sig, (struct sigaction*)NULL, &oact);\n  void* ohlr = oact.sa_sigaction ? CAST_FROM_FN_PTR(void*, oact.sa_sigaction)\n    : CAST_FROM_FN_PTR(void*, oact.sa_handler);\n  if (ohlr == CAST_FROM_FN_PTR(void*, SIG_IGN)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid os::Aix::signal_sets_init() {\n  // Should also have an assertion stating we are still single-threaded.\n  assert(!signal_sets_initialized, \"Already initialized\");\n  // Fill in signals that are necessarily unblocked for all threads in\n  // the VM. Currently, we unblock the following signals:\n  // SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n  //                         by -Xrs (=ReduceSignalUsage));\n  // BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n  // other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n  // the dispositions or masks wrt these signals.\n  // Programs embedding the VM that want to use the above signals for their\n  // own purposes must, at this time, use the \"-Xrs\" option to prevent\n  // interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n  // (See bug 4345157, and other related bugs).\n  // In reality, though, unblocking these signals is really a nop, since\n  // these signals are not blocked by default.\n  sigemptyset(&unblocked_sigs);\n  sigemptyset(&allowdebug_blocked_sigs);\n  sigaddset(&unblocked_sigs, SIGILL);\n  sigaddset(&unblocked_sigs, SIGSEGV);\n  sigaddset(&unblocked_sigs, SIGBUS);\n  sigaddset(&unblocked_sigs, SIGFPE);\n  sigaddset(&unblocked_sigs, SIGTRAP);\n  sigaddset(&unblocked_sigs, SIGDANGER);\n  sigaddset(&unblocked_sigs, SR_signum);\n\n  if (!ReduceSignalUsage) {\n   if (!os::Aix::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n     sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n     sigaddset(&allowdebug_blocked_sigs, SHUTDOWN1_SIGNAL);\n   }\n   if (!os::Aix::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n     sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n     sigaddset(&allowdebug_blocked_sigs, SHUTDOWN2_SIGNAL);\n   }\n   if (!os::Aix::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n     sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n     sigaddset(&allowdebug_blocked_sigs, SHUTDOWN3_SIGNAL);\n   }\n  }\n  // Fill in signals that are blocked by all but the VM thread.\n  sigemptyset(&vm_sigs);\n  if (!ReduceSignalUsage)\n    sigaddset(&vm_sigs, BREAK_SIGNAL);\n  debug_only(signal_sets_initialized = true);\n}\n\n// These are signals that are unblocked while a thread is running Java.\n// (For some reason, they get blocked by default.)\nsigset_t* os::Aix::unblocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &unblocked_sigs;\n}\n\n// These are the signals that are blocked while a (non-VM) thread is\n// running Java. Only the VM thread handles these signals.\nsigset_t* os::Aix::vm_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &vm_sigs;\n}\n\n// These are signals that are blocked during cond_wait to allow debugger in\nsigset_t* os::Aix::allowdebug_blocked_signals() {\n  assert(signal_sets_initialized, \"Not initialized\");\n  return &allowdebug_blocked_sigs;\n}\n\nvoid os::Aix::hotspot_sigmask(Thread* thread) {\n\n  //Save caller's signal mask before setting VM signal mask\n  sigset_t caller_sigmask;\n  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n\n  OSThread* osthread = thread->osthread();\n  osthread->set_caller_sigmask(caller_sigmask);\n\n  pthread_sigmask(SIG_UNBLOCK, os::Aix::unblocked_signals(), NULL);\n\n  if (!ReduceSignalUsage) {\n    if (thread->is_VM_thread()) {\n      // Only the VM thread handles BREAK_SIGNAL ...\n      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n    } else {\n      // ... all other threads block BREAK_SIGNAL\n      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n    }\n  }\n}\n\n// retrieve memory information.\n// Returns false if something went wrong;\n// content of pmi undefined in this case.\nbool os::Aix::get_meminfo(meminfo_t* pmi) {\n\n  assert(pmi, \"get_meminfo: invalid parameter\");\n\n  memset(pmi, 0, sizeof(meminfo_t));\n\n  if (os::Aix::on_pase()) {\n\n    Unimplemented();\n    return false;\n\n  } else {\n\n    // On AIX, I use the (dynamically loaded) perfstat library to retrieve memory statistics\n    // See:\n    // http://publib.boulder.ibm.com/infocenter/systems/index.jsp\n    //        ?topic=/com.ibm.aix.basetechref/doc/basetrf1/perfstat_memtot.htm\n    // http://publib.boulder.ibm.com/infocenter/systems/index.jsp\n    //        ?topic=/com.ibm.aix.files/doc/aixfiles/libperfstat.h.htm\n\n    perfstat_memory_total_t psmt;\n    memset (&psmt, '\\0', sizeof(psmt));\n    const int rc = libperfstat::perfstat_memory_total(NULL, &psmt, sizeof(psmt), 1);\n    if (rc == -1) {\n      fprintf(stderr, \"perfstat_memory_total() failed (errno=%d)\\n\", errno);\n      assert(0, \"perfstat_memory_total() failed\");\n      return false;\n    }\n\n    assert(rc == 1, \"perfstat_memory_total() - weird return code\");\n\n    // excerpt from\n    // http://publib.boulder.ibm.com/infocenter/systems/index.jsp\n    //        ?topic=/com.ibm.aix.files/doc/aixfiles/libperfstat.h.htm\n    // The fields of perfstat_memory_total_t:\n    // u_longlong_t virt_total         Total virtual memory (in 4 KB pages).\n    // u_longlong_t real_total         Total real memory (in 4 KB pages).\n    // u_longlong_t real_free          Free real memory (in 4 KB pages).\n    // u_longlong_t pgsp_total         Total paging space (in 4 KB pages).\n    // u_longlong_t pgsp_free          Free paging space (in 4 KB pages).\n\n    pmi->virt_total = psmt.virt_total * 4096;\n    pmi->real_total = psmt.real_total * 4096;\n    pmi->real_free = psmt.real_free * 4096;\n    pmi->pgsp_total = psmt.pgsp_total * 4096;\n    pmi->pgsp_free = psmt.pgsp_free * 4096;\n\n    return true;\n\n  }\n} // end os::Aix::get_meminfo\n\n// Retrieve global cpu information.\n// Returns false if something went wrong;\n// the content of pci is undefined in this case.\nbool os::Aix::get_cpuinfo(cpuinfo_t* pci) {\n  assert(pci, \"get_cpuinfo: invalid parameter\");\n  memset(pci, 0, sizeof(cpuinfo_t));\n\n  perfstat_cpu_total_t psct;\n  memset (&psct, '\\0', sizeof(psct));\n\n  if (-1 == libperfstat::perfstat_cpu_total(NULL, &psct, sizeof(perfstat_cpu_total_t), 1)) {\n    fprintf(stderr, \"perfstat_cpu_total() failed (errno=%d)\\n\", errno);\n    assert(0, \"perfstat_cpu_total() failed\");\n    return false;\n  }\n\n  // global cpu information\n  strcpy (pci->description, psct.description);\n  pci->processorHZ = psct.processorHZ;\n  pci->ncpus = psct.ncpus;\n  os::Aix::_logical_cpus = psct.ncpus;\n  for (int i = 0; i < 3; i++) {\n    pci->loadavg[i] = (double) psct.loadavg[i] / (1 << SBITS);\n  }\n\n  // get the processor version from _system_configuration\n  switch (_system_configuration.version) {\n  case PV_8:\n    strcpy(pci->version, \"Power PC 8\");\n    break;\n  case PV_7:\n    strcpy(pci->version, \"Power PC 7\");\n    break;\n  case PV_6_1:\n    strcpy(pci->version, \"Power PC 6 DD1.x\");\n    break;\n  case PV_6:\n    strcpy(pci->version, \"Power PC 6\");\n    break;\n  case PV_5:\n    strcpy(pci->version, \"Power PC 5\");\n    break;\n  case PV_5_2:\n    strcpy(pci->version, \"Power PC 5_2\");\n    break;\n  case PV_5_3:\n    strcpy(pci->version, \"Power PC 5_3\");\n    break;\n  case PV_5_Compat:\n    strcpy(pci->version, \"PV_5_Compat\");\n    break;\n  case PV_6_Compat:\n    strcpy(pci->version, \"PV_6_Compat\");\n    break;\n  case PV_7_Compat:\n    strcpy(pci->version, \"PV_7_Compat\");\n    break;\n  case PV_8_Compat:\n    strcpy(pci->version, \"PV_8_Compat\");\n    break;\n  default:\n    strcpy(pci->version, \"unknown\");\n  }\n\n  return true;\n\n} //end os::Aix::get_cpuinfo\n\n//////////////////////////////////////////////////////////////////////////////\n// detecting pthread library\n\nvoid os::Aix::libpthread_init() {\n  return;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// create new thread\n\n// Thread start routine for all newly created threads\nstatic void *java_start(Thread *thread) {\n\n  // find out my own stack dimensions\n  {\n    // actually, this should do exactly the same as thread->record_stack_base_and_size...\n    address base = 0;\n    size_t size = 0;\n    query_stack_dimensions(&base, &size);\n    thread->set_stack_base(base);\n    thread->set_stack_size(size);\n  }\n\n  // Do some sanity checks.\n  CHECK_CURRENT_STACK_PTR(thread->stack_base(), thread->stack_size());\n\n  // Try to randomize the cache line index of hot stack frames.\n  // This helps when threads of the same stack traces evict each other's\n  // cache lines. The threads can be either from the same JVM instance, or\n  // from different JVM instances. The benefit is especially true for\n  // processors with hyperthreading technology.\n\n  static int counter = 0;\n  int pid = os::current_process_id();\n  alloca(((pid ^ counter++) & 7) * 128);\n\n  ThreadLocalStorage::set_thread(thread);\n\n  OSThread* osthread = thread->osthread();\n\n  // thread_id is kernel thread id (similar to Solaris LWP id)\n  osthread->set_thread_id(os::Aix::gettid());\n\n  // initialize signal mask for this thread\n  os::Aix::hotspot_sigmask(thread);\n\n  // initialize floating point control register\n  os::Aix::init_thread_fpu_state();\n\n  assert(osthread->get_state() == RUNNABLE, \"invalid os thread state\");\n\n  // call one more level start routine\n  thread->run();\n\n  return 0;\n}\n\nbool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) {\n\n  // We want the whole function to be synchronized.\n  ThreadCritical cs;\n\n  assert(thread->osthread() == NULL, \"caller responsible\");\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // set the correct thread state\n  osthread->set_thread_type(thr_type);\n\n  // Initial state is ALLOCATED but not INITIALIZED\n  osthread->set_state(ALLOCATED);\n\n  thread->set_osthread(osthread);\n\n  // init thread attributes\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  guarantee(pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) == 0, \"???\");\n\n  // Make sure we run in 1:1 kernel-user-thread mode.\n  if (os::Aix::on_aix()) {\n    guarantee(pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM) == 0, \"???\");\n    guarantee(pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED) == 0, \"???\");\n  } // end: aix\n\n  // Start in suspended state, and in os::thread_start, wake the thread up.\n  guarantee(pthread_attr_setsuspendstate_np(&attr, PTHREAD_CREATE_SUSPENDED_NP) == 0, \"???\");\n\n  // calculate stack size if it's not specified by caller\n  if (os::Aix::supports_variable_stack_size()) {\n    if (stack_size == 0) {\n      stack_size = os::Aix::default_stack_size(thr_type);\n\n      switch (thr_type) {\n      case os::java_thread:\n        // Java threads use ThreadStackSize whose default value can be changed with the flag -Xss.\n        assert(JavaThread::stack_size_at_create() > 0, \"this should be set\");\n        stack_size = JavaThread::stack_size_at_create();\n        break;\n      case os::compiler_thread:\n        if (CompilerThreadStackSize > 0) {\n          stack_size = (size_t)(CompilerThreadStackSize * K);\n          break;\n        } // else fall through:\n          // use VMThreadStackSize if CompilerThreadStackSize is not defined\n      case os::vm_thread:\n      case os::pgc_thread:\n      case os::cgc_thread:\n      case os::watcher_thread:\n        if (VMThreadStackSize > 0) stack_size = (size_t)(VMThreadStackSize * K);\n        break;\n      }\n    }\n\n    stack_size = MAX2(stack_size, os::Aix::min_stack_allowed);\n    pthread_attr_setstacksize(&attr, stack_size);\n  } //else let thread_create() pick the default value (96 K on AIX)\n\n  pthread_t tid;\n  int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);\n\n  pthread_attr_destroy(&attr);\n\n  if (ret == 0) {\n    // PPC port traceOsMisc((\"Created New Thread : pthread-id %u\", tid));\n  } else {\n    if (PrintMiscellaneous && (Verbose || WizardMode)) {\n      perror(\"pthread_create()\");\n    }\n    // Need to clean up stuff we've allocated so far\n    thread->set_osthread(NULL);\n    delete osthread;\n    return false;\n  }\n\n  // Store pthread info into the OSThread\n  osthread->set_pthread_id(tid);\n\n  return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// attach existing thread\n\n// bootstrap the main thread\nbool os::create_main_thread(JavaThread* thread) {\n  assert(os::Aix::_main_thread == pthread_self(), \"should be called inside main thread\");\n  return create_attached_thread(thread);\n}\n\nbool os::create_attached_thread(JavaThread* thread) {\n#ifdef ASSERT\n    thread->verify_not_published();\n#endif\n\n  // Allocate the OSThread object\n  OSThread* osthread = new OSThread(NULL, NULL);\n\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // Store pthread info into the OSThread\n  osthread->set_thread_id(os::Aix::gettid());\n  osthread->set_pthread_id(::pthread_self());\n\n  // initialize floating point control register\n  os::Aix::init_thread_fpu_state();\n\n  // some sanity checks\n  CHECK_CURRENT_STACK_PTR(thread->stack_base(), thread->stack_size());\n\n  // Initial thread state is RUNNABLE\n  osthread->set_state(RUNNABLE);\n\n  thread->set_osthread(osthread);\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n\n  // initialize signal mask for this thread\n  // and save the caller's signal mask\n  os::Aix::hotspot_sigmask(thread);\n\n  return true;\n}\n\nvoid os::pd_start_thread(Thread* thread) {\n  int status = pthread_continue_np(thread->osthread()->pthread_id());\n  assert(status == 0, \"thr_continue failed\");\n}\n\n// Free OS resources related to the OSThread\nvoid os::free_thread(OSThread* osthread) {\n  assert(osthread != NULL, \"osthread not set\");\n\n  if (Thread::current()->osthread() == osthread) {\n    // Restore caller's signal mask\n    sigset_t sigmask = osthread->caller_sigmask();\n    pthread_sigmask(SIG_SETMASK, &sigmask, NULL);\n   }\n\n  delete osthread;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// thread local storage\n\nint os::allocate_thread_local_storage() {\n  pthread_key_t key;\n  int rslt = pthread_key_create(&key, NULL);\n  assert(rslt == 0, \"cannot allocate thread local storage\");\n  return (int)key;\n}\n\n// Note: This is currently not used by VM, as we don't destroy TLS key\n// on VM exit.\nvoid os::free_thread_local_storage(int index) {\n  int rslt = pthread_key_delete((pthread_key_t)index);\n  assert(rslt == 0, \"invalid index\");\n}\n\nvoid os::thread_local_storage_at_put(int index, void* value) {\n  int rslt = pthread_setspecific((pthread_key_t)index, value);\n  assert(rslt == 0, \"pthread_setspecific failed\");\n}\n\nextern \"C\" Thread* get_thread() {\n  return ThreadLocalStorage::thread();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// time support\n\n// Time since start-up in seconds to a fine granularity.\n// Used by VMSelfDestructTimer and the MemProfiler.\ndouble os::elapsedTime() {\n  return (double)(os::elapsed_counter()) * 0.000001;\n}\n\njlong os::elapsed_counter() {\n  timeval time;\n  int status = gettimeofday(&time, NULL);\n  return jlong(time.tv_sec) * 1000 * 1000 + jlong(time.tv_usec) - initial_time_count;\n}\n\njlong os::elapsed_frequency() {\n  return (1000 * 1000);\n}\n\n// For now, we say that linux does not support vtime. I have no idea\n// whether it can actually be made to (DLD, 9/13/05).\n\nbool os::supports_vtime() { return false; }\nbool os::enable_vtime()   { return false; }\nbool os::vtime_enabled()  { return false; }\ndouble os::elapsedVTime() {\n  // better than nothing, but not much\n  return elapsedTime();\n}\n\njlong os::javaTimeMillis() {\n  timeval time;\n  int status = gettimeofday(&time, NULL);\n  assert(status != -1, \"aix error at gettimeofday()\");\n  return jlong(time.tv_sec) * 1000 + jlong(time.tv_usec / 1000);\n}\n\n// We need to manually declare mread_real_time,\n// because IBM didn't provide a prototype in time.h.\n// (they probably only ever tested in C, not C++)\nextern \"C\"\nint mread_real_time(timebasestruct_t *t, size_t size_of_timebasestruct_t);\n\njlong os::javaTimeNanos() {\n  if (os::Aix::on_pase()) {\n    Unimplemented();\n    return 0;\n  } else {\n    // On AIX use the precision of processors real time clock\n    // or time base registers.\n    timebasestruct_t time;\n    int rc;\n\n    // If the CPU has a time register, it will be used and\n    // we have to convert to real time first. After convertion we have following data:\n    // time.tb_high [seconds since 00:00:00 UTC on 1.1.1970]\n    // time.tb_low  [nanoseconds after the last full second above]\n    // We better use mread_real_time here instead of read_real_time\n    // to ensure that we will get a monotonic increasing time.\n    if (mread_real_time(&time, TIMEBASE_SZ) != RTC_POWER) {\n      rc = time_base_to_time(&time, TIMEBASE_SZ);\n      assert(rc != -1, \"aix error at time_base_to_time()\");\n    }\n    return jlong(time.tb_high) * (1000 * 1000 * 1000) + jlong(time.tb_low);\n  }\n}\n\nvoid os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n  {\n    // gettimeofday - based on time in seconds since the Epoch thus does not wrap\n    info_ptr->max_value = ALL_64_BITS;\n\n    // gettimeofday is a real time clock so it skips\n    info_ptr->may_skip_backward = true;\n    info_ptr->may_skip_forward = true;\n  }\n\n  info_ptr->kind = JVMTI_TIMER_ELAPSED;    // elapsed not CPU time\n}\n\n// Return the real, user, and system times in seconds from an\n// arbitrary fixed point in the past.\nbool os::getTimesSecs(double* process_real_time,\n                      double* process_user_time,\n                      double* process_system_time) {\n  struct tms ticks;\n  clock_t real_ticks = times(&ticks);\n\n  if (real_ticks == (clock_t) (-1)) {\n    return false;\n  } else {\n    double ticks_per_second = (double) clock_tics_per_sec;\n    *process_user_time = ((double) ticks.tms_utime) / ticks_per_second;\n    *process_system_time = ((double) ticks.tms_stime) / ticks_per_second;\n    *process_real_time = ((double) real_ticks) / ticks_per_second;\n\n    return true;\n  }\n}\n\nchar * os::local_time_string(char *buf, size_t buflen) {\n  struct tm t;\n  time_t long_time;\n  time(&long_time);\n  localtime_r(&long_time, &t);\n  jio_snprintf(buf, buflen, \"%d-%02d-%02d %02d:%02d:%02d\",\n               t.tm_year + 1900, t.tm_mon + 1, t.tm_mday,\n               t.tm_hour, t.tm_min, t.tm_sec);\n  return buf;\n}\n\nstruct tm* os::localtime_pd(const time_t* clock, struct tm* res) {\n  return localtime_r(clock, res);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// runtime exit support\n\n// Note: os::shutdown() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::shutdown(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::shutdown() {\n\n  // allow PerfMemory to attempt cleanup of any persistent resources\n  perfMemory_exit();\n\n  // needs to remove object in file system\n  AttachListener::abort();\n\n  // flush buffered output, finish log files\n  ostream_abort();\n\n  // Check for abort hook\n  abort_hook_t abort_hook = Arguments::abort_hook();\n  if (abort_hook != NULL) {\n    abort_hook();\n  }\n}\n\n// Note: os::abort() might be called very early during initialization, or\n// called from signal handler. Before adding something to os::abort(), make\n// sure it is async-safe and can handle partially initialized VM.\nvoid os::abort(bool dump_core) {\n  os::shutdown();\n  if (dump_core) {\n#ifndef PRODUCT\n    fdStream out(defaultStream::output_fd());\n    out.print_raw(\"Current thread is \");\n    char buf[16];\n    jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());\n    out.print_raw_cr(buf);\n    out.print_raw_cr(\"Dumping core ...\");\n#endif\n    ::abort(); // dump core\n  }\n\n  ::exit(1);\n}\n\n// Die immediately, no exit hook, no abort hook, no cleanup.\nvoid os::die() {\n  ::abort();\n}\n\n// This method is a copy of JDK's sysGetLastErrorString\n// from src/solaris/hpi/src/system_md.c\n\nsize_t os::lasterror(char *buf, size_t len) {\n  if (errno == 0) return 0;\n\n  const char *s = ::strerror(errno);\n  size_t n = ::strlen(s);\n  if (n >= len) {\n    n = len - 1;\n  }\n  ::strncpy(buf, s, n);\n  buf[n] = '\\0';\n  return n;\n}\n\nintx os::current_thread_id() { return (intx)pthread_self(); }\n\nint os::current_process_id() {\n\n  // This implementation returns a unique pid, the pid of the\n  // launcher thread that starts the vm 'process'.\n\n  // Under POSIX, getpid() returns the same pid as the\n  // launcher thread rather than a unique pid per thread.\n  // Use gettid() if you want the old pre NPTL behaviour.\n\n  // if you are looking for the result of a call to getpid() that\n  // returns a unique pid for the calling thread, then look at the\n  // OSThread::thread_id() method in osThread_linux.hpp file\n\n  return (int)(_initial_pid ? _initial_pid : getpid());\n}\n\n// DLL functions\n\nconst char* os::dll_file_extension() { return \".so\"; }\n\n// This must be hard coded because it's the system's temporary\n// directory not the java application's temp directory, ala java.io.tmpdir.\nconst char* os::get_temp_directory() { return \"/tmp\"; }\n\nstatic bool file_exists(const char* filename) {\n  struct stat statbuf;\n  if (filename == NULL || strlen(filename) == 0) {\n    return false;\n  }\n  return os::stat(filename, &statbuf) == 0;\n}\n\nbool os::dll_build_name(char* buffer, size_t buflen,\n                        const char* pname, const char* fname) {\n  bool retval = false;\n  // Copied from libhpi\n  const size_t pnamelen = pname ? strlen(pname) : 0;\n\n  // Return error on buffer overflow.\n  if (pnamelen + strlen(fname) + 10 > (size_t) buflen) {\n    *buffer = '\\0';\n    return retval;\n  }\n\n  if (pnamelen == 0) {\n    snprintf(buffer, buflen, \"lib%s.so\", fname);\n    retval = true;\n  } else if (strchr(pname, *os::path_separator()) != NULL) {\n    int n;\n    char** pelements = split_path(pname, &n);\n    for (int i = 0; i < n; i++) {\n      // Really shouldn't be NULL, but check can't hurt\n      if (pelements[i] == NULL || strlen(pelements[i]) == 0) {\n        continue; // skip the empty path values\n      }\n      snprintf(buffer, buflen, \"%s/lib%s.so\", pelements[i], fname);\n      if (file_exists(buffer)) {\n        retval = true;\n        break;\n      }\n    }\n    // release the storage\n    for (int i = 0; i < n; i++) {\n      if (pelements[i] != NULL) {\n        FREE_C_HEAP_ARRAY(char, pelements[i], mtInternal);\n      }\n    }\n    if (pelements != NULL) {\n      FREE_C_HEAP_ARRAY(char*, pelements, mtInternal);\n    }\n  } else {\n    snprintf(buffer, buflen, \"%s/lib%s.so\", pname, fname);\n    retval = true;\n  }\n  return retval;\n}\n\n// Check if addr is inside libjvm.so.\nbool os::address_is_in_vm(address addr) {\n\n  // Input could be a real pc or a function pointer literal. The latter\n  // would be a function descriptor residing in the data segment of a module.\n\n  const LoadedLibraryModule* lib = LoadedLibraries::find_for_text_address(addr);\n  if (lib) {\n    if (strcmp(lib->get_shortname(), \"libjvm.so\") == 0) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    lib = LoadedLibraries::find_for_data_address(addr);\n    if (lib) {\n      if (strcmp(lib->get_shortname(), \"libjvm.so\") == 0) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n}\n\n// Resolve an AIX function descriptor literal to a code pointer.\n// If the input is a valid code pointer to a text segment of a loaded module,\n//   it is returned unchanged.\n// If the input is a valid AIX function descriptor, it is resolved to the\n//   code entry point.\n// If the input is neither a valid function descriptor nor a valid code pointer,\n//   NULL is returned.\nstatic address resolve_function_descriptor_to_code_pointer(address p) {\n\n  const LoadedLibraryModule* lib = LoadedLibraries::find_for_text_address(p);\n  if (lib) {\n    // its a real code pointer\n    return p;\n  } else {\n    lib = LoadedLibraries::find_for_data_address(p);\n    if (lib) {\n      // pointer to data segment, potential function descriptor\n      address code_entry = (address)(((FunctionDescriptor*)p)->entry());\n      if (LoadedLibraries::find_for_text_address(code_entry)) {\n        // Its a function descriptor\n        return code_entry;\n      }\n    }\n  }\n  return NULL;\n}\n\nbool os::dll_address_to_function_name(address addr, char *buf,\n                                      int buflen, int *offset) {\n  if (offset) {\n    *offset = -1;\n  }\n  // Buf is not optional, but offset is optional.\n  assert(buf != NULL, \"sanity check\");\n  buf[0] = '\\0';\n\n  // Resolve function ptr literals first.\n  addr = resolve_function_descriptor_to_code_pointer(addr);\n  if (!addr) {\n    return false;\n  }\n\n  // Go through Decoder::decode to call getFuncName which reads the name from the traceback table.\n  return Decoder::decode(addr, buf, buflen, offset);\n}\n\nstatic int getModuleName(codeptr_t pc,                    // [in] program counter\n                         char* p_name, size_t namelen,    // [out] optional: function name\n                         char* p_errmsg, size_t errmsglen // [out] optional: user provided buffer for error messages\n                         ) {\n\n  // initialize output parameters\n  if (p_name && namelen > 0) {\n    *p_name = '\\0';\n  }\n  if (p_errmsg && errmsglen > 0) {\n    *p_errmsg = '\\0';\n  }\n\n  const LoadedLibraryModule* const lib = LoadedLibraries::find_for_text_address((address)pc);\n  if (lib) {\n    if (p_name && namelen > 0) {\n      sprintf(p_name, \"%.*s\", namelen, lib->get_shortname());\n    }\n    return 0;\n  }\n\n  trcVerbose(\"pc outside any module\");\n\n  return -1;\n}\n\nbool os::dll_address_to_library_name(address addr, char* buf,\n                                     int buflen, int* offset) {\n  if (offset) {\n    *offset = -1;\n  }\n  // Buf is not optional, but offset is optional.\n  assert(buf != NULL, \"sanity check\");\n  buf[0] = '\\0';\n\n  // Resolve function ptr literals first.\n  addr = resolve_function_descriptor_to_code_pointer(addr);\n  if (!addr) {\n    return false;\n  }\n\n  if (::getModuleName((codeptr_t) addr, buf, buflen, 0, 0) == 0) {\n    return true;\n  }\n  return false;\n}\n\n// Loads .dll/.so and in case of error it checks if .dll/.so was built\n// for the same architecture as Hotspot is running on.\nvoid *os::dll_load(const char *filename, char *ebuf, int ebuflen) {\n\n  if (ebuf && ebuflen > 0) {\n    ebuf[0] = '\\0';\n    ebuf[ebuflen - 1] = '\\0';\n  }\n\n  if (!filename || strlen(filename) == 0) {\n    ::strncpy(ebuf, \"dll_load: empty filename specified\", ebuflen - 1);\n    return NULL;\n  }\n\n  // RTLD_LAZY is currently not implemented. The dl is loaded immediately with all its dependants.\n  void * result= ::dlopen(filename, RTLD_LAZY);\n  if (result != NULL) {\n    // Reload dll cache. Don't do this in signal handling.\n    LoadedLibraries::reload();\n    return result;\n  } else {\n    // error analysis when dlopen fails\n    const char* const error_report = ::dlerror();\n    if (error_report && ebuf && ebuflen > 0) {\n      snprintf(ebuf, ebuflen - 1, \"%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s\",\n               filename, ::getenv(\"LIBPATH\"), ::getenv(\"LD_LIBRARY_PATH\"), error_report);\n    }\n  }\n  return NULL;\n}\n\n// Glibc-2.0 libdl is not MT safe. If you are building with any glibc,\n// chances are you might want to run the generated bits against glibc-2.0\n// libdl.so, so always use locking for any version of glibc.\nvoid* os::dll_lookup(void* handle, const char* name) {\n  pthread_mutex_lock(&dl_mutex);\n  void* res = dlsym(handle, name);\n  pthread_mutex_unlock(&dl_mutex);\n  return res;\n}\n\nvoid* os::get_default_process_handle() {\n  return (void*)::dlopen(NULL, RTLD_LAZY);\n}\n\nvoid os::print_dll_info(outputStream *st) {\n  st->print_cr(\"Dynamic libraries:\");\n  LoadedLibraries::print(st);\n}\n\nvoid os::print_os_info(outputStream* st) {\n  st->print(\"OS:\");\n\n  st->print(\"uname:\");\n  struct utsname name;\n  uname(&name);\n  st->print(name.sysname); st->print(\" \");\n  st->print(name.nodename); st->print(\" \");\n  st->print(name.release); st->print(\" \");\n  st->print(name.version); st->print(\" \");\n  st->print(name.machine);\n  st->cr();\n\n  // rlimit\n  st->print(\"rlimit:\");\n  struct rlimit rlim;\n\n  st->print(\" STACK \");\n  getrlimit(RLIMIT_STACK, &rlim);\n  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n  else st->print(\"%uk\", rlim.rlim_cur >> 10);\n\n  st->print(\", CORE \");\n  getrlimit(RLIMIT_CORE, &rlim);\n  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n  else st->print(\"%uk\", rlim.rlim_cur >> 10);\n\n  st->print(\", NPROC \");\n  st->print(\"%d\", sysconf(_SC_CHILD_MAX));\n\n  st->print(\", NOFILE \");\n  getrlimit(RLIMIT_NOFILE, &rlim);\n  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n  else st->print(\"%d\", rlim.rlim_cur);\n\n  st->print(\", AS \");\n  getrlimit(RLIMIT_AS, &rlim);\n  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n  else st->print(\"%uk\", rlim.rlim_cur >> 10);\n\n  // Print limits on DATA, because it limits the C-heap.\n  st->print(\", DATA \");\n  getrlimit(RLIMIT_DATA, &rlim);\n  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n  else st->print(\"%uk\", rlim.rlim_cur >> 10);\n  st->cr();\n\n  // load average\n  st->print(\"load average:\");\n  double loadavg[3] = {-1.L, -1.L, -1.L};\n  os::loadavg(loadavg, 3);\n  st->print(\"%0.02f %0.02f %0.02f\", loadavg[0], loadavg[1], loadavg[2]);\n  st->cr();\n}\n\nvoid os::print_memory_info(outputStream* st) {\n\n  st->print_cr(\"Memory:\");\n\n  st->print_cr(\"  default page size: %s\", describe_pagesize(os::vm_page_size()));\n  st->print_cr(\"  default stack page size: %s\", describe_pagesize(os::vm_page_size()));\n  st->print_cr(\"  default shm page size: %s\", describe_pagesize(os::Aix::shm_default_page_size()));\n  st->print_cr(\"  can use 64K pages dynamically: %s\", (os::Aix::can_use_64K_pages() ? \"yes\" :\"no\"));\n  st->print_cr(\"  can use 16M pages dynamically: %s\", (os::Aix::can_use_16M_pages() ? \"yes\" :\"no\"));\n  if (g_multipage_error != 0) {\n    st->print_cr(\"  multipage error: %d\", g_multipage_error);\n  }\n\n  // print out LDR_CNTRL because it affects the default page sizes\n  const char* const ldr_cntrl = ::getenv(\"LDR_CNTRL\");\n  st->print_cr(\"  LDR_CNTRL=%s.\", ldr_cntrl ? ldr_cntrl : \"<unset>\");\n\n  const char* const extshm = ::getenv(\"EXTSHM\");\n  st->print_cr(\"  EXTSHM=%s.\", extshm ? extshm : \"<unset>\");\n\n  // Call os::Aix::get_meminfo() to retrieve memory statistics.\n  os::Aix::meminfo_t mi;\n  if (os::Aix::get_meminfo(&mi)) {\n    char buffer[256];\n    if (os::Aix::on_aix()) {\n      jio_snprintf(buffer, sizeof(buffer),\n                   \"  physical total : %llu\\n\"\n                   \"  physical free  : %llu\\n\"\n                   \"  swap total     : %llu\\n\"\n                   \"  swap free      : %llu\\n\",\n                   mi.real_total,\n                   mi.real_free,\n                   mi.pgsp_total,\n                   mi.pgsp_free);\n    } else {\n      Unimplemented();\n    }\n    st->print_raw(buffer);\n  } else {\n    st->print_cr(\"  (no more information available)\");\n  }\n}\n\nvoid os::pd_print_cpu_info(outputStream* st) {\n  // cpu\n  st->print(\"CPU:\");\n  st->print(\"total %d\", os::processor_count());\n  // It's not safe to query number of active processors after crash\n  // st->print(\"(active %d)\", os::active_processor_count());\n  st->print(\" %s\", VM_Version::cpu_features());\n  st->cr();\n}\n\nvoid os::print_siginfo(outputStream* st, void* siginfo) {\n  // Use common posix version.\n  os::Posix::print_siginfo_brief(st, (const siginfo_t*) siginfo);\n  st->cr();\n}\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen);\n\nvoid os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n  st->print_cr(\"Signal Handlers:\");\n  print_signal_handler(st, SIGSEGV, buf, buflen);\n  print_signal_handler(st, SIGBUS , buf, buflen);\n  print_signal_handler(st, SIGFPE , buf, buflen);\n  print_signal_handler(st, SIGPIPE, buf, buflen);\n  print_signal_handler(st, SIGXFSZ, buf, buflen);\n  print_signal_handler(st, SIGILL , buf, buflen);\n  print_signal_handler(st, INTERRUPT_SIGNAL, buf, buflen);\n  print_signal_handler(st, SR_signum, buf, buflen);\n  print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n  print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n  print_signal_handler(st, SIGTRAP, buf, buflen);\n  print_signal_handler(st, SIGDANGER, buf, buflen);\n}\n\nstatic char saved_jvm_path[MAXPATHLEN] = {0};\n\n// Find the full path to the current module, libjvm.so.\nvoid os::jvm_path(char *buf, jint buflen) {\n  // Error checking.\n  if (buflen < MAXPATHLEN) {\n    assert(false, \"must use a large-enough buffer\");\n    buf[0] = '\\0';\n    return;\n  }\n  // Lazy resolve the path to current module.\n  if (saved_jvm_path[0] != 0) {\n    strcpy(buf, saved_jvm_path);\n    return;\n  }\n\n  Dl_info dlinfo;\n  int ret = dladdr(CAST_FROM_FN_PTR(void *, os::jvm_path), &dlinfo);\n  assert(ret != 0, \"cannot locate libjvm\");\n  char* rp = realpath((char *)dlinfo.dli_fname, buf);\n  assert(rp != NULL, \"error in realpath(): maybe the 'path' argument is too long?\");\n\n  strcpy(saved_jvm_path, buf);\n}\n\nvoid os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n  // no prefix required, not even \"_\"\n}\n\nvoid os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n  // no suffix required\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// sun.misc.Signal support\n\nstatic volatile jint sigint_count = 0;\n\nstatic void\nUserHandler(int sig, void *siginfo, void *context) {\n  // 4511530 - sem_post is serialized and handled by the manager thread. When\n  // the program is interrupted by Ctrl-C, SIGINT is sent to every thread. We\n  // don't want to flood the manager thread with sem_post requests.\n  if (sig == SIGINT && Atomic::add(1, &sigint_count) > 1)\n    return;\n\n  // Ctrl-C is pressed during error reporting, likely because the error\n  // handler fails to abort. Let VM die immediately.\n  if (sig == SIGINT && is_error_reported()) {\n    os::die();\n  }\n\n  os::signal_notify(sig);\n}\n\nvoid* os::user_handler() {\n  return CAST_FROM_FN_PTR(void*, UserHandler);\n}\n\nextern \"C\" {\n  typedef void (*sa_handler_t)(int);\n  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n}\n\nvoid* os::signal(int signal_number, void* handler) {\n  struct sigaction sigAct, oldSigAct;\n\n  sigfillset(&(sigAct.sa_mask));\n\n  // Do not block out synchronous signals in the signal handler.\n  // Blocking synchronous signals only makes sense if you can really\n  // be sure that those signals won't happen during signal handling,\n  // when the blocking applies. Normal signal handlers are lean and\n  // do not cause signals. But our signal handlers tend to be \"risky\"\n  // - secondary SIGSEGV, SIGILL, SIGBUS' may and do happen.\n  // On AIX, PASE there was a case where a SIGSEGV happened, followed\n  // by a SIGILL, which was blocked due to the signal mask. The process\n  // just hung forever. Better to crash from a secondary signal than to hang.\n  sigdelset(&(sigAct.sa_mask), SIGSEGV);\n  sigdelset(&(sigAct.sa_mask), SIGBUS);\n  sigdelset(&(sigAct.sa_mask), SIGILL);\n  sigdelset(&(sigAct.sa_mask), SIGFPE);\n  sigdelset(&(sigAct.sa_mask), SIGTRAP);\n\n  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n\n  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n\n  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n    // -1 means registration failed\n    return (void *)-1;\n  }\n\n  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n}\n\nvoid os::signal_raise(int signal_number) {\n  ::raise(signal_number);\n}\n\n//\n// The following code is moved from os.cpp for making this\n// code platform specific, which it is by its very nature.\n//\n\n// Will be modified when max signal is changed to be dynamic\nint os::sigexitnum_pd() {\n  return NSIG;\n}\n\n// a counter for each possible signal value\nstatic volatile jint pending_signals[NSIG+1] = { 0 };\n\n// Linux(POSIX) specific hand shaking semaphore.\nstatic sem_t sig_sem;\n\nvoid os::signal_init_pd() {\n  // Initialize signal structures\n  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n\n  // Initialize signal semaphore\n  int rc = ::sem_init(&sig_sem, 0, 0);\n  guarantee(rc != -1, \"sem_init failed\");\n}\n\nvoid os::signal_notify(int sig) {\n  Atomic::inc(&pending_signals[sig]);\n  ::sem_post(&sig_sem);\n}\n\nstatic int check_pending_signals(bool wait) {\n  Atomic::store(0, &sigint_count);\n  for (;;) {\n    for (int i = 0; i < NSIG + 1; i++) {\n      jint n = pending_signals[i];\n      if (n > 0 && n == Atomic::cmpxchg(n - 1, &pending_signals[i], n)) {\n        return i;\n      }\n    }\n    if (!wait) {\n      return -1;\n    }\n    JavaThread *thread = JavaThread::current();\n    ThreadBlockInVM tbivm(thread);\n\n    bool threadIsSuspended;\n    do {\n      thread->set_suspend_equivalent();\n      // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n      ::sem_wait(&sig_sem);\n\n      // were we externally suspended while we were waiting?\n      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n      if (threadIsSuspended) {\n        //\n        // The semaphore has been incremented, but while we were waiting\n        // another thread suspended us. We don't want to continue running\n        // while suspended because that would surprise the thread that\n        // suspended us.\n        //\n        ::sem_post(&sig_sem);\n\n        thread->java_suspend_self();\n      }\n    } while (threadIsSuspended);\n  }\n}\n\nint os::signal_lookup() {\n  return check_pending_signals(false);\n}\n\nint os::signal_wait() {\n  return check_pending_signals(true);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Virtual Memory\n\n// AddrRange describes an immutable address range\n//\n// This is a helper class for the 'shared memory bookkeeping' below.\nclass AddrRange {\n  friend class ShmBkBlock;\n\n  char* _start;\n  size_t _size;\n\npublic:\n\n  AddrRange(char* start, size_t size)\n    : _start(start), _size(size)\n  {}\n\n  AddrRange(const AddrRange& r)\n    : _start(r.start()), _size(r.size())\n  {}\n\n  char* start() const { return _start; }\n  size_t size() const { return _size; }\n  char* end() const { return _start + _size; }\n  bool is_empty() const { return _size == 0 ? true : false; }\n\n  static AddrRange empty_range() { return AddrRange(NULL, 0); }\n\n  bool contains(const char* p) const {\n    return start() <= p && end() > p;\n  }\n\n  bool contains(const AddrRange& range) const {\n    return start() <= range.start() && end() >= range.end();\n  }\n\n  bool intersects(const AddrRange& range) const {\n    return (range.start() <= start() && range.end() > start()) ||\n           (range.start() < end() && range.end() >= end()) ||\n           contains(range);\n  }\n\n  bool is_same_range(const AddrRange& range) const {\n    return start() == range.start() && size() == range.size();\n  }\n\n  // return the closest inside range consisting of whole pages\n  AddrRange find_closest_aligned_range(size_t pagesize) const {\n    if (pagesize == 0 || is_empty()) {\n      return empty_range();\n    }\n    char* const from = (char*)align_size_up((intptr_t)_start, pagesize);\n    char* const to = (char*)align_size_down((intptr_t)end(), pagesize);\n    if (from > to) {\n      return empty_range();\n    }\n    return AddrRange(from, to - from);\n  }\n};\n\n////////////////////////////////////////////////////////////////////////////\n// shared memory bookkeeping\n//\n// the os::reserve_memory() API and friends hand out different kind of memory, depending\n// on need and circumstances. Memory may be allocated with mmap() or with shmget/shmat.\n//\n// But these memory types have to be treated differently. For example, to uncommit\n// mmap-based memory, msync(MS_INVALIDATE) is needed, to uncommit shmat-based memory,\n// disclaim64() is needed.\n//\n// Therefore we need to keep track of the allocated memory segments and their\n// properties.\n\n// ShmBkBlock: base class for all blocks in the shared memory bookkeeping\nclass ShmBkBlock {\n\n  ShmBkBlock* _next;\n\nprotected:\n\n  AddrRange _range;\n  const size_t _pagesize;\n  const bool _pinned;\n\npublic:\n\n  ShmBkBlock(AddrRange range, size_t pagesize, bool pinned)\n    : _range(range), _pagesize(pagesize), _pinned(pinned) , _next(NULL) {\n\n    assert(_pagesize == SIZE_4K || _pagesize == SIZE_64K || _pagesize == SIZE_16M, \"invalid page size\");\n    assert(!_range.is_empty(), \"invalid range\");\n  }\n\n  virtual void print(outputStream* st) const {\n    st->print(\"0x%p ... 0x%p (%llu) - %d %s pages - %s\",\n              _range.start(), _range.end(), _range.size(),\n              _range.size() / _pagesize, describe_pagesize(_pagesize),\n              _pinned ? \"pinned\" : \"\");\n  }\n\n  enum Type { MMAP, SHMAT };\n  virtual Type getType() = 0;\n\n  char* base() const { return _range.start(); }\n  size_t size() const { return _range.size(); }\n\n  void setAddrRange(AddrRange range) {\n    _range = range;\n  }\n\n  bool containsAddress(const char* p) const {\n    return _range.contains(p);\n  }\n\n  bool containsRange(const char* p, size_t size) const {\n    return _range.contains(AddrRange((char*)p, size));\n  }\n\n  bool isSameRange(const char* p, size_t size) const {\n    return _range.is_same_range(AddrRange((char*)p, size));\n  }\n\n  virtual bool disclaim(char* p, size_t size) = 0;\n  virtual bool release() = 0;\n\n  // blocks live in a list.\n  ShmBkBlock* next() const { return _next; }\n  void set_next(ShmBkBlock* blk) { _next = blk; }\n\n}; // end: ShmBkBlock\n\n\n// ShmBkMappedBlock: describes an block allocated with mmap()\nclass ShmBkMappedBlock : public ShmBkBlock {\npublic:\n\n  ShmBkMappedBlock(AddrRange range)\n    : ShmBkBlock(range, SIZE_4K, false) {} // mmap: always 4K, never pinned\n\n  void print(outputStream* st) const {\n    ShmBkBlock::print(st);\n    st->print_cr(\" - mmap'ed\");\n  }\n\n  Type getType() {\n    return MMAP;\n  }\n\n  bool disclaim(char* p, size_t size) {\n\n    AddrRange r(p, size);\n\n    guarantee(_range.contains(r), \"invalid disclaim\");\n\n    // only disclaim whole ranges.\n    const AddrRange r2 = r.find_closest_aligned_range(_pagesize);\n    if (r2.is_empty()) {\n      return true;\n    }\n\n    const int rc = ::msync(r2.start(), r2.size(), MS_INVALIDATE);\n\n    if (rc != 0) {\n      warning(\"msync(0x%p, %llu, MS_INVALIDATE) failed (%d)\\n\", r2.start(), r2.size(), errno);\n    }\n\n    return rc == 0 ? true : false;\n  }\n\n  bool release() {\n    // mmap'ed blocks are released using munmap\n    if (::munmap(_range.start(), _range.size()) != 0) {\n      warning(\"munmap(0x%p, %llu) failed (%d)\\n\", _range.start(), _range.size(), errno);\n      return false;\n    }\n    return true;\n  }\n}; // end: ShmBkMappedBlock\n\n// ShmBkShmatedBlock: describes an block allocated with shmget/shmat()\nclass ShmBkShmatedBlock : public ShmBkBlock {\npublic:\n\n  ShmBkShmatedBlock(AddrRange range, size_t pagesize, bool pinned)\n    : ShmBkBlock(range, pagesize, pinned) {}\n\n  void print(outputStream* st) const {\n    ShmBkBlock::print(st);\n    st->print_cr(\" - shmat'ed\");\n  }\n\n  Type getType() {\n    return SHMAT;\n  }\n\n  bool disclaim(char* p, size_t size) {\n\n    AddrRange r(p, size);\n\n    if (_pinned) {\n      return true;\n    }\n\n    // shmat'ed blocks are disclaimed using disclaim64\n    guarantee(_range.contains(r), \"invalid disclaim\");\n\n    // only disclaim whole ranges.\n    const AddrRange r2 = r.find_closest_aligned_range(_pagesize);\n    if (r2.is_empty()) {\n      return true;\n    }\n\n    const bool rc = my_disclaim64(r2.start(), r2.size());\n\n    if (Verbose && !rc) {\n      warning(\"failed to disclaim shm %p-%p\\n\", r2.start(), r2.end());\n    }\n\n    return rc;\n  }\n\n  bool release() {\n    bool rc = false;\n    if (::shmdt(_range.start()) != 0) {\n      warning(\"shmdt(0x%p) failed (%d)\\n\", _range.start(), errno);\n    } else {\n      rc = true;\n    }\n    return rc;\n  }\n\n}; // end: ShmBkShmatedBlock\n\nstatic ShmBkBlock* g_shmbk_list = NULL;\nstatic volatile jint g_shmbk_table_lock = 0;\n\n// keep some usage statistics\nstatic struct {\n  int nodes;    // number of nodes in list\n  size_t bytes; // reserved - not committed - bytes.\n  int reserves; // how often reserve was called\n  int lookups;  // how often a lookup was made\n} g_shmbk_stats = { 0, 0, 0, 0 };\n\n// add information about a shared memory segment to the bookkeeping\nstatic void shmbk_register(ShmBkBlock* p_block) {\n  guarantee(p_block, \"logic error\");\n  p_block->set_next(g_shmbk_list);\n  g_shmbk_list = p_block;\n  g_shmbk_stats.reserves ++;\n  g_shmbk_stats.bytes += p_block->size();\n  g_shmbk_stats.nodes ++;\n}\n\n// remove information about a shared memory segment by its starting address\nstatic void shmbk_unregister(ShmBkBlock* p_block) {\n  ShmBkBlock* p = g_shmbk_list;\n  ShmBkBlock* prev = NULL;\n  while (p) {\n    if (p == p_block) {\n      if (prev) {\n        prev->set_next(p->next());\n      } else {\n        g_shmbk_list = p->next();\n      }\n      g_shmbk_stats.nodes --;\n      g_shmbk_stats.bytes -= p->size();\n      return;\n    }\n    prev = p;\n    p = p->next();\n  }\n  assert(false, \"should not happen\");\n}\n\n// given a pointer, return shared memory bookkeeping record for the segment it points into\n// using the returned block info must happen under lock protection\nstatic ShmBkBlock* shmbk_find_by_containing_address(const char* addr) {\n  g_shmbk_stats.lookups ++;\n  ShmBkBlock* p = g_shmbk_list;\n  while (p) {\n    if (p->containsAddress(addr)) {\n      return p;\n    }\n    p = p->next();\n  }\n  return NULL;\n}\n\n// dump all information about all memory segments allocated with os::reserve_memory()\nvoid shmbk_dump_info() {\n  tty->print_cr(\"-- shared mem bookkeeping (alive: %d segments, %llu bytes, \"\n    \"total reserves: %d total lookups: %d)\",\n    g_shmbk_stats.nodes, g_shmbk_stats.bytes, g_shmbk_stats.reserves, g_shmbk_stats.lookups);\n  const ShmBkBlock* p = g_shmbk_list;\n  int i = 0;\n  while (p) {\n    p->print(tty);\n    p = p->next();\n    i ++;\n  }\n}\n\n#define LOCK_SHMBK     { ThreadCritical _LOCK_SHMBK;\n#define UNLOCK_SHMBK   }\n\n// End: shared memory bookkeeping\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint os::vm_page_size() {\n  // Seems redundant as all get out\n  assert(os::Aix::page_size() != -1, \"must call os::init\");\n  return os::Aix::page_size();\n}\n\n// Aix allocates memory by pages.\nint os::vm_allocation_granularity() {\n  assert(os::Aix::page_size() != -1, \"must call os::init\");\n  return os::Aix::page_size();\n}\n\nint os::Aix::commit_memory_impl(char* addr, size_t size, bool exec) {\n\n  // Commit is a noop. There is no explicit commit\n  // needed on AIX. Memory is committed when touched.\n  //\n  // Debug : check address range for validity\n#ifdef ASSERT\n  LOCK_SHMBK\n    ShmBkBlock* const block = shmbk_find_by_containing_address(addr);\n    if (!block) {\n      fprintf(stderr, \"invalid pointer: \" INTPTR_FORMAT \"\\n\", addr);\n      shmbk_dump_info();\n      assert(false, \"invalid pointer\");\n      return false;\n    } else if (!block->containsRange(addr, size)) {\n      fprintf(stderr, \"invalid range: \" INTPTR_FORMAT \" .. \" INTPTR_FORMAT \"\\n\", addr, addr + size);\n      shmbk_dump_info();\n      assert(false, \"invalid range\");\n      return false;\n    }\n  UNLOCK_SHMBK\n#endif // ASSERT\n\n  return 0;\n}\n\nbool os::pd_commit_memory(char* addr, size_t size, bool exec) {\n  return os::Aix::commit_memory_impl(addr, size, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,\n                                  const char* mesg) {\n  assert(mesg != NULL, \"mesg must be specified\");\n  os::Aix::commit_memory_impl(addr, size, exec);\n}\n\nint os::Aix::commit_memory_impl(char* addr, size_t size,\n                                size_t alignment_hint, bool exec) {\n  return os::Aix::commit_memory_impl(addr, size, exec);\n}\n\nbool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,\n                          bool exec) {\n  return os::Aix::commit_memory_impl(addr, size, alignment_hint, exec) == 0;\n}\n\nvoid os::pd_commit_memory_or_exit(char* addr, size_t size,\n                                  size_t alignment_hint, bool exec,\n                                  const char* mesg) {\n  os::Aix::commit_memory_impl(addr, size, alignment_hint, exec);\n}\n\nbool os::pd_uncommit_memory(char* addr, size_t size) {\n\n  // Delegate to ShmBkBlock class which knows how to uncommit its memory.\n\n  bool rc = false;\n  LOCK_SHMBK\n    ShmBkBlock* const block = shmbk_find_by_containing_address(addr);\n    if (!block) {\n      fprintf(stderr, \"invalid pointer: 0x%p.\\n\", addr);\n      shmbk_dump_info();\n      assert(false, \"invalid pointer\");\n      return false;\n    } else if (!block->containsRange(addr, size)) {\n      fprintf(stderr, \"invalid range: 0x%p .. 0x%p.\\n\", addr, addr + size);\n      shmbk_dump_info();\n      assert(false, \"invalid range\");\n      return false;\n    }\n    rc = block->disclaim(addr, size);\n  UNLOCK_SHMBK\n\n  if (Verbose && !rc) {\n    warning(\"failed to disclaim 0x%p .. 0x%p (0x%llX bytes).\", addr, addr + size, size);\n  }\n  return rc;\n}\n\nbool os::pd_create_stack_guard_pages(char* addr, size_t size) {\n  return os::guard_memory(addr, size);\n}\n\nbool os::remove_stack_guard_pages(char* addr, size_t size) {\n  return os::unguard_memory(addr, size);\n}\n\nvoid os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {\n}\n\nvoid os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n}\n\nvoid os::numa_make_global(char *addr, size_t bytes) {\n}\n\nvoid os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {\n}\n\nbool os::numa_topology_changed() {\n  return false;\n}\n\nsize_t os::numa_get_groups_num() {\n  return 1;\n}\n\nint os::numa_get_group_id() {\n  return 0;\n}\n\nsize_t os::numa_get_leaf_groups(int *ids, size_t size) {\n  if (size > 0) {\n    ids[0] = 0;\n    return 1;\n  }\n  return 0;\n}\n\nbool os::get_page_info(char *start, page_info* info) {\n  return false;\n}\n\nchar *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {\n  return end;\n}\n\n// Flags for reserve_shmatted_memory:\n#define RESSHM_WISHADDR_OR_FAIL                     1\n#define RESSHM_TRY_16M_PAGES                        2\n#define RESSHM_16M_PAGES_OR_FAIL                    4\n\n// Result of reserve_shmatted_memory:\nstruct shmatted_memory_info_t {\n  char* addr;\n  size_t pagesize;\n  bool pinned;\n};\n\n// Reserve a section of shmatted memory.\n// params:\n// bytes [in]: size of memory, in bytes\n// requested_addr [in]: wish address.\n//                      NULL = no wish.\n//                      If RESSHM_WISHADDR_OR_FAIL is set in flags and wish address cannot\n//                      be obtained, function will fail. Otherwise wish address is treated as hint and\n//                      another pointer is returned.\n// flags [in]:          some flags. Valid flags are:\n//                      RESSHM_WISHADDR_OR_FAIL - fail if wish address is given and cannot be obtained.\n//                      RESSHM_TRY_16M_PAGES - try to allocate from 16M page pool\n//                          (requires UseLargePages and Use16MPages)\n//                      RESSHM_16M_PAGES_OR_FAIL - if you cannot allocate from 16M page pool, fail.\n//                          Otherwise any other page size will do.\n// p_info [out] :       holds information about the created shared memory segment.\nstatic bool reserve_shmatted_memory(size_t bytes, char* requested_addr, int flags, shmatted_memory_info_t* p_info) {\n\n  assert(p_info, \"parameter error\");\n\n  // init output struct.\n  p_info->addr = NULL;\n\n  // neither should we be here for EXTSHM=ON.\n  if (os::Aix::extshm()) {\n    ShouldNotReachHere();\n  }\n\n  // extract flags. sanity checks.\n  const bool wishaddr_or_fail =\n    flags & RESSHM_WISHADDR_OR_FAIL;\n  const bool try_16M_pages =\n    flags & RESSHM_TRY_16M_PAGES;\n  const bool f16M_pages_or_fail =\n    flags & RESSHM_16M_PAGES_OR_FAIL;\n\n  // first check: if a wish address is given and it is mandatory, but not aligned to segment boundary,\n  // shmat will fail anyway, so save some cycles by failing right away\n  if (requested_addr && ((uintptr_t)requested_addr % SIZE_256M == 0)) {\n    if (wishaddr_or_fail) {\n      return false;\n    } else {\n      requested_addr = NULL;\n    }\n  }\n\n  char* addr = NULL;\n\n  // Align size of shm up to the largest possible page size, to avoid errors later on when we try to change\n  // pagesize dynamically.\n  const size_t size = align_size_up(bytes, SIZE_16M);\n\n  // reserve the shared segment\n  int shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | S_IRUSR | S_IWUSR);\n  if (shmid == -1) {\n    warning(\"shmget(.., %lld, ..) failed (errno: %d).\", size, errno);\n    return false;\n  }\n\n  // Important note:\n  // It is very important that we, upon leaving this function, do not leave a shm segment alive.\n  // We must right after attaching it remove it from the system. System V shm segments are global and\n  // survive the process.\n  // So, from here on: Do not assert. Do not return. Always do a \"goto cleanup_shm\".\n\n  // try forcing the page size\n  size_t pagesize = -1; // unknown so far\n\n  if (UseLargePages) {\n\n    struct shmid_ds shmbuf;\n    memset(&shmbuf, 0, sizeof(shmbuf));\n\n    // First, try to take from 16M page pool if...\n    if (os::Aix::can_use_16M_pages()  // we can ...\n        && Use16MPages                // we are not explicitly forbidden to do so (-XX:-Use16MPages)..\n        && try_16M_pages) {           // caller wants us to.\n      shmbuf.shm_pagesize = SIZE_16M;\n      if (shmctl(shmid, SHM_PAGESIZE, &shmbuf) == 0) {\n        pagesize = SIZE_16M;\n      } else {\n        warning(\"Failed to allocate %d 16M pages. 16M page pool might be exhausted. (shmctl failed with %d)\",\n                size / SIZE_16M, errno);\n        if (f16M_pages_or_fail) {\n          goto cleanup_shm;\n        }\n      }\n    }\n\n    // Nothing yet? Try setting 64K pages. Note that I never saw this fail, but in theory it might,\n    // because the 64K page pool may also be exhausted.\n    if (pagesize == -1) {\n      shmbuf.shm_pagesize = SIZE_64K;\n      if (shmctl(shmid, SHM_PAGESIZE, &shmbuf) == 0) {\n        pagesize = SIZE_64K;\n      } else {\n        warning(\"Failed to allocate %d 64K pages. (shmctl failed with %d)\",\n                size / SIZE_64K, errno);\n        // here I give up. leave page_size -1 - later, after attaching, we will query the\n        // real page size of the attached memory. (in theory, it may be something different\n        // from 4K if LDR_CNTRL SHM_PSIZE is set)\n      }\n    }\n  }\n\n  // sanity point\n  assert(pagesize == -1 || pagesize == SIZE_16M || pagesize == SIZE_64K, \"wrong page size\");\n\n  // Now attach the shared segment.\n  addr = (char*) shmat(shmid, requested_addr, 0);\n  if (addr == (char*)-1) {\n    // How to handle attach failure:\n    // If it failed for a specific wish address, tolerate this: in that case, if wish address was\n    // mandatory, fail, if not, retry anywhere.\n    // If it failed for any other reason, treat that as fatal error.\n    addr = NULL;\n    if (requested_addr) {\n      if (wishaddr_or_fail) {\n        goto cleanup_shm;\n      } else {\n        addr = (char*) shmat(shmid, NULL, 0);\n        if (addr == (char*)-1) { // fatal\n          addr = NULL;\n          warning(\"shmat failed (errno: %d)\", errno);\n          goto cleanup_shm;\n        }\n      }\n    } else { // fatal\n      addr = NULL;\n      warning(\"shmat failed (errno: %d)\", errno);\n      goto cleanup_shm;\n    }\n  }\n\n  // sanity point\n  assert(addr && addr != (char*) -1, \"wrong address\");\n\n  // after successful Attach remove the segment - right away.\n  if (::shmctl(shmid, IPC_RMID, NULL) == -1) {\n    warning(\"shmctl(%u, IPC_RMID) failed (%d)\\n\", shmid, errno);\n    guarantee(false, \"failed to remove shared memory segment!\");\n  }\n  shmid = -1;\n\n  // query the real page size. In case setting the page size did not work (see above), the system\n  // may have given us something other then 4K (LDR_CNTRL)\n  {\n    const size_t real_pagesize = os::Aix::query_pagesize(addr);\n    if (pagesize != -1) {\n      assert(pagesize == real_pagesize, \"unexpected pagesize after shmat\");\n    } else {\n      pagesize = real_pagesize;\n    }\n  }\n\n  // Now register the reserved block with internal book keeping.\n  LOCK_SHMBK\n    const bool pinned = pagesize >= SIZE_16M ? true : false;\n    ShmBkShmatedBlock* const p_block = new ShmBkShmatedBlock(AddrRange(addr, size), pagesize, pinned);\n    assert(p_block, \"\");\n    shmbk_register(p_block);\n  UNLOCK_SHMBK\n\ncleanup_shm:\n\n  // if we have not done so yet, remove the shared memory segment. This is very important.\n  if (shmid != -1) {\n    if (::shmctl(shmid, IPC_RMID, NULL) == -1) {\n      warning(\"shmctl(%u, IPC_RMID) failed (%d)\\n\", shmid, errno);\n      guarantee(false, \"failed to remove shared memory segment!\");\n    }\n    shmid = -1;\n  }\n\n  // trace\n  if (Verbose && !addr) {\n    if (requested_addr != NULL) {\n      warning(\"failed to shm-allocate 0x%llX bytes at wish address 0x%p.\", size, requested_addr);\n    } else {\n      warning(\"failed to shm-allocate 0x%llX bytes at any address.\", size);\n    }\n  }\n\n  // hand info to caller\n  if (addr) {\n    p_info->addr = addr;\n    p_info->pagesize = pagesize;\n    p_info->pinned = pagesize == SIZE_16M ? true : false;\n  }\n\n  // sanity test:\n  if (requested_addr && addr && wishaddr_or_fail) {\n    guarantee(addr == requested_addr, \"shmat error\");\n  }\n\n  // just one more test to really make sure we have no dangling shm segments.\n  guarantee(shmid == -1, \"dangling shm segments\");\n\n  return addr ? true : false;\n\n} // end: reserve_shmatted_memory\n\n// Reserve memory using mmap. Behaves the same as reserve_shmatted_memory():\n// will return NULL in case of an error.\nstatic char* reserve_mmaped_memory(size_t bytes, char* requested_addr) {\n\n  // if a wish address is given, but not aligned to 4K page boundary, mmap will fail.\n  if (requested_addr && ((uintptr_t)requested_addr % os::vm_page_size() != 0)) {\n    warning(\"Wish address 0x%p not aligned to page boundary.\", requested_addr);\n    return NULL;\n  }\n\n  const size_t size = align_size_up(bytes, SIZE_4K);\n\n  // Note: MAP_SHARED (instead of MAP_PRIVATE) needed to be able to\n  // msync(MS_INVALIDATE) (see os::uncommit_memory)\n  int flags = MAP_ANONYMOUS | MAP_SHARED;\n\n  // MAP_FIXED is needed to enforce requested_addr - manpage is vague about what\n  // it means if wishaddress is given but MAP_FIXED is not set.\n  //\n  // Note however that this changes semantics in SPEC1170 mode insofar as MAP_FIXED\n  // clobbers the address range, which is probably not what the caller wants. That's\n  // why I assert here (again) that the SPEC1170 compat mode is off.\n  // If we want to be able to run under SPEC1170, we have to do some porting and\n  // testing.\n  if (requested_addr != NULL) {\n    assert(!os::Aix::xpg_sus_mode(), \"SPEC1170 mode not allowed.\");\n    flags |= MAP_FIXED;\n  }\n\n  char* addr = (char*)::mmap(requested_addr, size, PROT_READ|PROT_WRITE|PROT_EXEC, flags, -1, 0);\n\n  if (addr == MAP_FAILED) {\n    // attach failed: tolerate for specific wish addresses. Not being able to attach\n    // anywhere is a fatal error.\n    if (requested_addr == NULL) {\n      // It's ok to fail here if the machine has not enough memory.\n      warning(\"mmap(NULL, 0x%llX, ..) failed (%d)\", size, errno);\n    }\n    addr = NULL;\n    goto cleanup_mmap;\n  }\n\n  // If we did request a specific address and that address was not available, fail.\n  if (addr && requested_addr) {\n    guarantee(addr == requested_addr, \"unexpected\");\n  }\n\n  // register this mmap'ed segment with book keeping\n  LOCK_SHMBK\n    ShmBkMappedBlock* const p_block = new ShmBkMappedBlock(AddrRange(addr, size));\n    assert(p_block, \"\");\n    shmbk_register(p_block);\n  UNLOCK_SHMBK\n\ncleanup_mmap:\n\n  // trace\n  if (Verbose) {\n    if (addr) {\n      fprintf(stderr, \"mmap-allocated 0x%p .. 0x%p (0x%llX bytes)\\n\", addr, addr + bytes, bytes);\n    }\n    else {\n      if (requested_addr != NULL) {\n        warning(\"failed to mmap-allocate 0x%llX bytes at wish address 0x%p.\", bytes, requested_addr);\n      } else {\n        warning(\"failed to mmap-allocate 0x%llX bytes at any address.\", bytes);\n      }\n    }\n  }\n\n  return addr;\n\n} // end: reserve_mmaped_memory\n\n// Reserves and attaches a shared memory segment.\n// Will assert if a wish address is given and could not be obtained.\nchar* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {\n  return os::attempt_reserve_memory_at(bytes, requested_addr);\n}\n\nbool os::pd_release_memory(char* addr, size_t size) {\n\n  // delegate to ShmBkBlock class which knows how to uncommit its memory.\n\n  bool rc = false;\n  LOCK_SHMBK\n    ShmBkBlock* const block = shmbk_find_by_containing_address(addr);\n    if (!block) {\n      fprintf(stderr, \"invalid pointer: 0x%p.\\n\", addr);\n      shmbk_dump_info();\n      assert(false, \"invalid pointer\");\n      return false;\n    }\n    else if (!block->isSameRange(addr, size)) {\n      if (block->getType() == ShmBkBlock::MMAP) {\n        // Release only the same range or a the beginning or the end of a range.\n        if (block->base() == addr && size < block->size()) {\n          ShmBkMappedBlock* const b = new ShmBkMappedBlock(AddrRange(block->base() + size, block->size() - size));\n          assert(b, \"\");\n          shmbk_register(b);\n          block->setAddrRange(AddrRange(addr, size));\n        }\n        else if (addr > block->base() && addr + size == block->base() + block->size()) {\n          ShmBkMappedBlock* const b = new ShmBkMappedBlock(AddrRange(block->base(), block->size() - size));\n          assert(b, \"\");\n          shmbk_register(b);\n          block->setAddrRange(AddrRange(addr, size));\n        }\n        else {\n          fprintf(stderr, \"invalid mmap range: 0x%p .. 0x%p.\\n\", addr, addr + size);\n          shmbk_dump_info();\n          assert(false, \"invalid mmap range\");\n          return false;\n        }\n      }\n      else {\n        // Release only the same range. No partial release allowed.\n        // Soften the requirement a bit, because the user may think he owns a smaller size\n        // than the block is due to alignment etc.\n        if (block->base() != addr || block->size() < size) {\n          fprintf(stderr, \"invalid shmget range: 0x%p .. 0x%p.\\n\", addr, addr + size);\n          shmbk_dump_info();\n          assert(false, \"invalid shmget range\");\n          return false;\n        }\n      }\n    }\n    rc = block->release();\n    assert(rc, \"release failed\");\n    // remove block from bookkeeping\n    shmbk_unregister(block);\n    delete block;\n  UNLOCK_SHMBK\n\n  if (!rc) {\n    warning(\"failed to released %lu bytes at 0x%p\", size, addr);\n  }\n\n  return rc;\n}\n\nstatic bool checked_mprotect(char* addr, size_t size, int prot) {\n\n  // Little problem here: if SPEC1170 behaviour is off, mprotect() on AIX will\n  // not tell me if protection failed when trying to protect an un-protectable range.\n  //\n  // This means if the memory was allocated using shmget/shmat, protection wont work\n  // but mprotect will still return 0:\n  //\n  // See http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/mprotect.htm\n\n  bool rc = ::mprotect(addr, size, prot) == 0 ? true : false;\n\n  if (!rc) {\n    const char* const s_errno = strerror(errno);\n    warning(\"mprotect(\" PTR_FORMAT \"-\" PTR_FORMAT \", 0x%X) failed (%s).\", addr, addr + size, prot, s_errno);\n    return false;\n  }\n\n  // mprotect success check\n  //\n  // Mprotect said it changed the protection but can I believe it?\n  //\n  // To be sure I need to check the protection afterwards. Try to\n  // read from protected memory and check whether that causes a segfault.\n  //\n  if (!os::Aix::xpg_sus_mode()) {\n\n    if (StubRoutines::SafeFetch32_stub()) {\n\n      const bool read_protected =\n        (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &&\n         SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;\n\n      if (prot & PROT_READ) {\n        rc = !read_protected;\n      } else {\n        rc = read_protected;\n      }\n    }\n  }\n  if (!rc) {\n    assert(false, \"mprotect failed.\");\n  }\n  return rc;\n}\n\n// Set protections specified\nbool os::protect_memory(char* addr, size_t size, ProtType prot, bool is_committed) {\n  unsigned int p = 0;\n  switch (prot) {\n  case MEM_PROT_NONE: p = PROT_NONE; break;\n  case MEM_PROT_READ: p = PROT_READ; break;\n  case MEM_PROT_RW:   p = PROT_READ|PROT_WRITE; break;\n  case MEM_PROT_RWX:  p = PROT_READ|PROT_WRITE|PROT_EXEC; break;\n  default:\n    ShouldNotReachHere();\n  }\n  // is_committed is unused.\n  return checked_mprotect(addr, size, p);\n}\n\nbool os::guard_memory(char* addr, size_t size) {\n  return checked_mprotect(addr, size, PROT_NONE);\n}\n\nbool os::unguard_memory(char* addr, size_t size) {\n  return checked_mprotect(addr, size, PROT_READ|PROT_WRITE|PROT_EXEC);\n}\n\n// Large page support\n\nstatic size_t _large_page_size = 0;\n\n// Enable large page support if OS allows that.\nvoid os::large_page_init() {\n\n  // Note: os::Aix::query_multipage_support must run first.\n\n  if (!UseLargePages) {\n    return;\n  }\n\n  if (!Aix::can_use_64K_pages()) {\n    assert(!Aix::can_use_16M_pages(), \"64K is a precondition for 16M.\");\n    UseLargePages = false;\n    return;\n  }\n\n  if (!Aix::can_use_16M_pages() && Use16MPages) {\n    fprintf(stderr, \"Cannot use 16M pages. Please ensure that there is a 16M page pool \"\n            \" and that the VM runs with CAP_BYPASS_RAC_VMM and CAP_PROPAGATE capabilities.\\n\");\n  }\n\n  // Do not report 16M page alignment as part of os::_page_sizes if we are\n  // explicitly forbidden from using 16M pages. Doing so would increase the\n  // alignment the garbage collector calculates with, slightly increasing\n  // heap usage. We should only pay for 16M alignment if we really want to\n  // use 16M pages.\n  if (Use16MPages && Aix::can_use_16M_pages()) {\n    _large_page_size = SIZE_16M;\n    _page_sizes[0] = SIZE_16M;\n    _page_sizes[1] = SIZE_64K;\n    _page_sizes[2] = SIZE_4K;\n    _page_sizes[3] = 0;\n  } else if (Aix::can_use_64K_pages()) {\n    _large_page_size = SIZE_64K;\n    _page_sizes[0] = SIZE_64K;\n    _page_sizes[1] = SIZE_4K;\n    _page_sizes[2] = 0;\n  }\n\n  if (Verbose) {\n    (\"Default large page size is 0x%llX.\", _large_page_size);\n  }\n} // end: os::large_page_init()\n\nchar* os::reserve_memory_special(size_t bytes, size_t alignment, char* req_addr, bool exec) {\n  // \"exec\" is passed in but not used. Creating the shared image for\n  // the code cache doesn't have an SHM_X executable permission to check.\n  Unimplemented();\n  return 0;\n}\n\nbool os::release_memory_special(char* base, size_t bytes) {\n  // detaching the SHM segment will also delete it, see reserve_memory_special()\n  Unimplemented();\n  return false;\n}\n\nsize_t os::large_page_size() {\n  return _large_page_size;\n}\n\nbool os::can_commit_large_page_memory() {\n  // Well, sadly we cannot commit anything at all (see comment in\n  // os::commit_memory) but we claim to so we can make use of large pages\n  return true;\n}\n\nbool os::can_execute_large_page_memory() {\n  // We can do that\n  return true;\n}\n\n// Reserve memory at an arbitrary address, only if that area is\n// available (and not reserved for something else).\nchar* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {\n\n  bool use_mmap = false;\n\n  // mmap: smaller graining, no large page support\n  // shm: large graining (256M), large page support, limited number of shm segments\n  //\n  // Prefer mmap wherever we either do not need large page support or have OS limits\n\n  if (!UseLargePages || bytes < SIZE_16M) {\n    use_mmap = true;\n  }\n\n  char* addr = NULL;\n  if (use_mmap) {\n    addr = reserve_mmaped_memory(bytes, requested_addr);\n  } else {\n    // shmat: wish address is mandatory, and do not try 16M pages here.\n    shmatted_memory_info_t info;\n    const int flags = RESSHM_WISHADDR_OR_FAIL;\n    if (reserve_shmatted_memory(bytes, requested_addr, flags, &info)) {\n      addr = info.addr;\n    }\n  }\n\n  return addr;\n}\n\nsize_t os::read(int fd, void *buf, unsigned int nBytes) {\n  return ::read(fd, buf, nBytes);\n}\n\n#define NANOSECS_PER_MILLISEC 1000000\n\nint os::sleep(Thread* thread, jlong millis, bool interruptible) {\n  assert(thread == Thread::current(), \"thread consistency check\");\n\n  // Prevent nasty overflow in deadline calculation\n  // by handling long sleeps similar to solaris or windows.\n  const jlong limit = INT_MAX;\n  int result;\n  while (millis > limit) {\n    if ((result = os::sleep(thread, limit, interruptible)) != OS_OK) {\n      return result;\n    }\n    millis -= limit;\n  }\n\n  ParkEvent * const slp = thread->_SleepEvent;\n  slp->reset();\n  OrderAccess::fence();\n\n  if (interruptible) {\n    jlong prevtime = javaTimeNanos();\n\n    // Prevent precision loss and too long sleeps\n    jlong deadline = prevtime + millis * NANOSECS_PER_MILLISEC;\n\n    for (;;) {\n      if (os::is_interrupted(thread, true)) {\n        return OS_INTRPT;\n      }\n\n      jlong newtime = javaTimeNanos();\n\n      assert(newtime >= prevtime, \"time moving backwards\");\n      // Doing prevtime and newtime in microseconds doesn't help precision,\n      // and trying to round up to avoid lost milliseconds can result in a\n      // too-short delay.\n      millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n\n      if (millis <= 0) {\n        return OS_OK;\n      }\n\n      // Stop sleeping if we passed the deadline\n      if (newtime >= deadline) {\n        return OS_OK;\n      }\n\n      prevtime = newtime;\n\n      {\n        assert(thread->is_Java_thread(), \"sanity check\");\n        JavaThread *jt = (JavaThread *) thread;\n        ThreadBlockInVM tbivm(jt);\n        OSThreadWaitState osts(jt->osthread(), false /* not Object.wait() */);\n\n        jt->set_suspend_equivalent();\n\n        slp->park(millis);\n\n        // were we externally suspended while we were waiting?\n        jt->check_and_wait_while_suspended();\n      }\n    }\n  } else {\n    OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n    jlong prevtime = javaTimeNanos();\n\n    // Prevent precision loss and too long sleeps\n    jlong deadline = prevtime + millis * NANOSECS_PER_MILLISEC;\n\n    for (;;) {\n      // It'd be nice to avoid the back-to-back javaTimeNanos() calls on\n      // the 1st iteration ...\n      jlong newtime = javaTimeNanos();\n\n      if (newtime - prevtime < 0) {\n        // time moving backwards, should only happen if no monotonic clock\n        // not a guarantee() because JVM should not abort on kernel/glibc bugs\n        // - HS14 Commented out as not implemented.\n        // - TODO Maybe we should implement it?\n        //assert(!Aix::supports_monotonic_clock(), \"time moving backwards\");\n      } else {\n        millis -= (newtime - prevtime) / NANOSECS_PER_MILLISEC;\n      }\n\n      if (millis <= 0) break;\n\n      if (newtime >= deadline) {\n        break;\n      }\n\n      prevtime = newtime;\n      slp->park(millis);\n    }\n    return OS_OK;\n  }\n}\n\nvoid os::naked_short_sleep(jlong ms) {\n  struct timespec req;\n\n  assert(ms < 1000, \"Un-interruptable sleep, short time use only\");\n  req.tv_sec = 0;\n  if (ms > 0) {\n    req.tv_nsec = (ms % 1000) * 1000000;\n  }\n  else {\n    req.tv_nsec = 1;\n  }\n\n  nanosleep(&req, NULL);\n\n  return;\n}\n\n// Sleep forever; naked call to OS-specific sleep; use with CAUTION\nvoid os::infinite_sleep() {\n  while (true) {    // sleep forever ...\n    ::sleep(100);   // ... 100 seconds at a time\n  }\n}\n\n// Used to convert frequent JVM_Yield() to nops\nbool os::dont_yield() {\n  return DontYieldALot;\n}\n\nvoid os::yield() {\n  sched_yield();\n}\n\nos::YieldResult os::NakedYield() { sched_yield(); return os::YIELD_UNKNOWN; }\n\nvoid os::yield_all(int attempts) {\n  // Yields to all threads, including threads with lower priorities\n  // Threads on Linux are all with same priority. The Solaris style\n  // os::yield_all() with nanosleep(1ms) is not necessary.\n  sched_yield();\n}\n\n// Called from the tight loops to possibly influence time-sharing heuristics\nvoid os::loop_breaker(int attempts) {\n  os::yield_all(attempts);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// thread priority support\n\n// From AIX manpage to pthread_setschedparam\n// (see: http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?\n//    topic=/com.ibm.aix.basetechref/doc/basetrf1/pthread_setschedparam.htm):\n//\n// \"If schedpolicy is SCHED_OTHER, then sched_priority must be in the\n// range from 40 to 80, where 40 is the least favored priority and 80\n// is the most favored.\"\n//\n// (Actually, I doubt this even has an impact on AIX, as we do kernel\n// scheduling there; however, this still leaves iSeries.)\n//\n// We use the same values for AIX and PASE.\nint os::java_to_os_priority[CriticalPriority + 1] = {\n  54,             // 0 Entry should never be used\n\n  55,             // 1 MinPriority\n  55,             // 2\n  56,             // 3\n\n  56,             // 4\n  57,             // 5 NormPriority\n  57,             // 6\n\n  58,             // 7\n  58,             // 8\n  59,             // 9 NearMaxPriority\n\n  60,             // 10 MaxPriority\n\n  60              // 11 CriticalPriority\n};\n\nOSReturn os::set_native_priority(Thread* thread, int newpri) {\n  if (!UseThreadPriorities) return OS_OK;\n  pthread_t thr = thread->osthread()->pthread_id();\n  int policy = SCHED_OTHER;\n  struct sched_param param;\n  param.sched_priority = newpri;\n  int ret = pthread_setschedparam(thr, policy, &param);\n\n  if (ret != 0) {\n    trcVerbose(\"Could not change priority for thread %d to %d (error %d, %s)\",\n        (int)thr, newpri, ret, strerror(ret));\n  }\n  return (ret == 0) ? OS_OK : OS_ERR;\n}\n\nOSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {\n  if (!UseThreadPriorities) {\n    *priority_ptr = java_to_os_priority[NormPriority];\n    return OS_OK;\n  }\n  pthread_t thr = thread->osthread()->pthread_id();\n  int policy = SCHED_OTHER;\n  struct sched_param param;\n  int ret = pthread_getschedparam(thr, &policy, &param);\n  *priority_ptr = param.sched_priority;\n\n  return (ret == 0) ? OS_OK : OS_ERR;\n}\n\n// Hint to the underlying OS that a task switch would not be good.\n// Void return because it's a hint and can fail.\nvoid os::hint_no_preempt() {}\n\n////////////////////////////////////////////////////////////////////////////////\n// suspend/resume support\n\n//  the low-level signal-based suspend/resume support is a remnant from the\n//  old VM-suspension that used to be for java-suspension, safepoints etc,\n//  within hotspot. Now there is a single use-case for this:\n//    - calling get_thread_pc() on the VMThread by the flat-profiler task\n//      that runs in the watcher thread.\n//  The remaining code is greatly simplified from the more general suspension\n//  code that used to be used.\n//\n//  The protocol is quite simple:\n//  - suspend:\n//      - sends a signal to the target thread\n//      - polls the suspend state of the osthread using a yield loop\n//      - target thread signal handler (SR_handler) sets suspend state\n//        and blocks in sigsuspend until continued\n//  - resume:\n//      - sets target osthread state to continue\n//      - sends signal to end the sigsuspend loop in the SR_handler\n//\n//  Note that the SR_lock plays no role in this suspend/resume protocol.\n//\n\nstatic void resume_clear_context(OSThread *osthread) {\n  osthread->set_ucontext(NULL);\n  osthread->set_siginfo(NULL);\n}\n\nstatic void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n  osthread->set_ucontext(context);\n  osthread->set_siginfo(siginfo);\n}\n\n//\n// Handler function invoked when a thread's execution is suspended or\n// resumed. We have to be careful that only async-safe functions are\n// called here (Note: most pthread functions are not async safe and\n// should be avoided.)\n//\n// Note: sigwait() is a more natural fit than sigsuspend() from an\n// interface point of view, but sigwait() prevents the signal hander\n// from being run. libpthread would get very confused by not having\n// its signal handlers run and prevents sigwait()'s use with the\n// mutex granting granting signal.\n//\n// Currently only ever called on the VMThread and JavaThreads (PC sampling).\n//\nstatic void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n  // Save and restore errno to avoid confusing native code with EINTR\n  // after sigsuspend.\n  int old_errno = errno;\n\n  Thread* thread = Thread::current();\n  OSThread* osthread = thread->osthread();\n  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n\n  os::SuspendResume::State current = osthread->sr.state();\n  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n    suspend_save_context(osthread, siginfo, context);\n\n    // attempt to switch the state, we assume we had a SUSPEND_REQUEST\n    os::SuspendResume::State state = osthread->sr.suspended();\n    if (state == os::SuspendResume::SR_SUSPENDED) {\n      sigset_t suspend_set;  // signals for sigsuspend()\n\n      // get current set of blocked signals and unblock resume signal\n      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n      sigdelset(&suspend_set, SR_signum);\n\n      // wait here until we are resumed\n      while (1) {\n        sigsuspend(&suspend_set);\n\n        os::SuspendResume::State result = osthread->sr.running();\n        if (result == os::SuspendResume::SR_RUNNING) {\n          break;\n        }\n      }\n\n    } else if (state == os::SuspendResume::SR_RUNNING) {\n      // request was cancelled, continue\n    } else {\n      ShouldNotReachHere();\n    }\n\n    resume_clear_context(osthread);\n  } else if (current == os::SuspendResume::SR_RUNNING) {\n    // request was cancelled, continue\n  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // ignore\n  } else {\n    ShouldNotReachHere();\n  }\n\n  errno = old_errno;\n}\n\nstatic int SR_initialize() {\n  struct sigaction act;\n  char *s;\n  // Get signal number to use for suspend/resume\n  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n    int sig = ::strtol(s, 0, 10);\n    if (sig > 0 || sig < NSIG) {\n      SR_signum = sig;\n    }\n  }\n\n  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n        \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n\n  sigemptyset(&SR_sigset);\n  sigaddset(&SR_sigset, SR_signum);\n\n  // Set up signal handler for suspend/resume.\n  act.sa_flags = SA_RESTART|SA_SIGINFO;\n  act.sa_handler = (void (*)(int)) SR_handler;\n\n  // SR_signum is blocked by default.\n  // 4528190 - We also need to block pthread restart signal (32 on all\n  // supported Linux platforms). Note that LinuxThreads need to block\n  // this signal for all threads to work properly. So we don't have\n  // to use hard-coded signal number when setting up the mask.\n  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n\n  if (sigaction(SR_signum, &act, 0) == -1) {\n    return -1;\n  }\n\n  // Save signal flag\n  os::Aix::set_our_sigflags(SR_signum, act.sa_flags);\n  return 0;\n}\n\nstatic int SR_finalize() {\n  return 0;\n}\n\nstatic int sr_notify(OSThread* osthread) {\n  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n  assert_status(status == 0, status, \"pthread_kill\");\n  return status;\n}\n\n// \"Randomly\" selected value for how long we want to spin\n// before bailing out on suspending a thread, also how often\n// we send a signal to a thread we want to resume\nstatic const int RANDOMLY_LARGE_INTEGER = 1000000;\nstatic const int RANDOMLY_LARGE_INTEGER2 = 100;\n\n// returns true on success and false on error - really an error is fatal\n// but this seems the normal response to library errors\nstatic bool do_suspend(OSThread* osthread) {\n  assert(osthread->sr.is_running(), \"thread should be running\");\n  // mark as suspended and send signal\n\n  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n    // failed to switch, state wasn't running?\n    ShouldNotReachHere();\n    return false;\n  }\n\n  if (sr_notify(osthread) != 0) {\n    // try to cancel, switch to running\n\n    os::SuspendResume::State result = osthread->sr.cancel_suspend();\n    if (result == os::SuspendResume::SR_RUNNING) {\n      // cancelled\n      return false;\n    } else if (result == os::SuspendResume::SR_SUSPENDED) {\n      // somehow managed to suspend\n      return true;\n    } else {\n      ShouldNotReachHere();\n      return false;\n    }\n  }\n\n  // managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n\n  for (int n = 0; !osthread->sr.is_suspended(); n++) {\n    for (int i = 0; i < RANDOMLY_LARGE_INTEGER2 && !osthread->sr.is_suspended(); i++) {\n      os::yield_all(i);\n    }\n\n    // timeout, try to cancel the request\n    if (n >= RANDOMLY_LARGE_INTEGER) {\n      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n      if (cancelled == os::SuspendResume::SR_RUNNING) {\n        return false;\n      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n        return true;\n      } else {\n        ShouldNotReachHere();\n        return false;\n      }\n    }\n  }\n\n  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n  return true;\n}\n\nstatic void do_resume(OSThread* osthread) {\n  //assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n\n  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n    // failed to switch to WAKEUP_REQUEST\n    ShouldNotReachHere();\n    return;\n  }\n\n  while (!osthread->sr.is_running()) {\n    if (sr_notify(osthread) == 0) {\n      for (int n = 0; n < RANDOMLY_LARGE_INTEGER && !osthread->sr.is_running(); n++) {\n        for (int i = 0; i < 100 && !osthread->sr.is_running(); i++) {\n          os::yield_all(i);\n        }\n      }\n    } else {\n      ShouldNotReachHere();\n    }\n  }\n\n  guarantee(osthread->sr.is_running(), \"Must be running!\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// interrupt support\n\nvoid os::interrupt(Thread* thread) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  if (!osthread->interrupted()) {\n    osthread->set_interrupted(true);\n    // More than one thread can get here with the same value of osthread,\n    // resulting in multiple notifications.  We do, however, want the store\n    // to interrupted() to be visible to other threads before we execute unpark().\n    OrderAccess::fence();\n    ParkEvent * const slp = thread->_SleepEvent;\n    if (slp != NULL) slp->unpark();\n  }\n\n  // For JSR166. Unpark even if interrupt status already was set\n  if (thread->is_Java_thread())\n    ((JavaThread*)thread)->parker()->unpark();\n\n  ParkEvent * ev = thread->_ParkEvent;\n  if (ev != NULL) ev->unpark();\n\n}\n\nbool os::is_interrupted(Thread* thread, bool clear_interrupted) {\n  assert(Thread::current() == thread || Threads_lock->owned_by_self(),\n    \"possibility of dangling Thread pointer\");\n\n  OSThread* osthread = thread->osthread();\n\n  bool interrupted = osthread->interrupted();\n\n  if (interrupted && clear_interrupted) {\n    osthread->set_interrupted(false);\n    // consider thread->_SleepEvent->reset() ... optional optimization\n  }\n\n  return interrupted;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// signal handling (except suspend/resume)\n\n// This routine may be used by user applications as a \"hook\" to catch signals.\n// The user-defined signal handler must pass unrecognized signals to this\n// routine, and if it returns true (non-zero), then the signal handler must\n// return immediately. If the flag \"abort_if_unrecognized\" is true, then this\n// routine will never retun false (zero), but instead will execute a VM panic\n// routine kill the process.\n//\n// If this routine returns false, it is OK to call it again. This allows\n// the user-defined signal handler to perform checks either before or after\n// the VM performs its own checks. Naturally, the user code would be making\n// a serious error if it tried to handle an exception (such as a null check\n// or breakpoint) that the VM was generating for its own correct operation.\n//\n// This routine may recognize any of the following kinds of signals:\n//   SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n// It should be consulted by handlers for any of those signals.\n//\n// The caller of this routine must pass in the three arguments supplied\n// to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n// field of the structure passed to sigaction(). This routine assumes that\n// the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n//\n// Note that the VM will print warnings if it detects conflicting signal\n// handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n//\nextern \"C\" JNIEXPORT int\nJVM_handle_aix_signal(int signo, siginfo_t* siginfo, void* ucontext, int abort_if_unrecognized);\n\n// Set thread signal mask (for some reason on AIX sigthreadmask() seems\n// to be the thing to call; documentation is not terribly clear about whether\n// pthread_sigmask also works, and if it does, whether it does the same.\nbool set_thread_signal_mask(int how, const sigset_t* set, sigset_t* oset) {\n  const int rc = ::pthread_sigmask(how, set, oset);\n  // return value semantics differ slightly for error case:\n  // pthread_sigmask returns error number, sigthreadmask -1 and sets global errno\n  // (so, pthread_sigmask is more theadsafe for error handling)\n  // But success is always 0.\n  return rc == 0 ? true : false;\n}\n\n// Function to unblock all signals which are, according\n// to POSIX, typical program error signals. If they happen while being blocked,\n// they typically will bring down the process immediately.\nbool unblock_program_error_signals() {\n  sigset_t set;\n  ::sigemptyset(&set);\n  ::sigaddset(&set, SIGILL);\n  ::sigaddset(&set, SIGBUS);\n  ::sigaddset(&set, SIGFPE);\n  ::sigaddset(&set, SIGSEGV);\n  return set_thread_signal_mask(SIG_UNBLOCK, &set, NULL);\n}\n\n// Renamed from 'signalHandler' to avoid collision with other shared libs.\nvoid javaSignalHandler(int sig, siginfo_t* info, void* uc) {\n  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n\n  // Never leave program error signals blocked;\n  // on all our platforms they would bring down the process immediately when\n  // getting raised while being blocked.\n  unblock_program_error_signals();\n\n  JVM_handle_aix_signal(sig, info, uc, true);\n}\n\n// This boolean allows users to forward their own non-matching signals\n// to JVM_handle_aix_signal, harmlessly.\nbool os::Aix::signal_handlers_are_installed = false;\n\n// For signal-chaining\nstruct sigaction os::Aix::sigact[MAXSIGNUM];\nunsigned int os::Aix::sigs = 0;\nbool os::Aix::libjsig_is_loaded = false;\ntypedef struct sigaction *(*get_signal_t)(int);\nget_signal_t os::Aix::get_signal_action = NULL;\n\nstruct sigaction* os::Aix::get_chained_signal_action(int sig) {\n  struct sigaction *actp = NULL;\n\n  if (libjsig_is_loaded) {\n    // Retrieve the old signal handler from libjsig\n    actp = (*get_signal_action)(sig);\n  }\n  if (actp == NULL) {\n    // Retrieve the preinstalled signal handler from jvm\n    actp = get_preinstalled_handler(sig);\n  }\n\n  return actp;\n}\n\nstatic bool call_chained_handler(struct sigaction *actp, int sig,\n                                 siginfo_t *siginfo, void *context) {\n  // Call the old signal handler\n  if (actp->sa_handler == SIG_DFL) {\n    // It's more reasonable to let jvm treat it as an unexpected exception\n    // instead of taking the default action.\n    return false;\n  } else if (actp->sa_handler != SIG_IGN) {\n    if ((actp->sa_flags & SA_NODEFER) == 0) {\n      // automaticlly block the signal\n      sigaddset(&(actp->sa_mask), sig);\n    }\n\n    sa_handler_t hand = NULL;\n    sa_sigaction_t sa = NULL;\n    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n    // retrieve the chained handler\n    if (siginfo_flag_set) {\n      sa = actp->sa_sigaction;\n    } else {\n      hand = actp->sa_handler;\n    }\n\n    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n      actp->sa_handler = SIG_DFL;\n    }\n\n    // try to honor the signal mask\n    sigset_t oset;\n    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n\n    // call into the chained handler\n    if (siginfo_flag_set) {\n      (*sa)(sig, siginfo, context);\n    } else {\n      (*hand)(sig);\n    }\n\n    // restore the signal mask\n    pthread_sigmask(SIG_SETMASK, &oset, 0);\n  }\n  // Tell jvm's signal handler the signal is taken care of.\n  return true;\n}\n\nbool os::Aix::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n  bool chained = false;\n  // signal-chaining\n  if (UseSignalChaining) {\n    struct sigaction *actp = get_chained_signal_action(sig);\n    if (actp != NULL) {\n      chained = call_chained_handler(actp, sig, siginfo, context);\n    }\n  }\n  return chained;\n}\n\nstruct sigaction* os::Aix::get_preinstalled_handler(int sig) {\n  if ((((unsigned int)1 << sig) & sigs) != 0) {\n    return &sigact[sig];\n  }\n  return NULL;\n}\n\nvoid os::Aix::save_preinstalled_handler(int sig, struct sigaction& oldAct) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigact[sig] = oldAct;\n  sigs |= (unsigned int)1 << sig;\n}\n\n// for diagnostic\nint os::Aix::sigflags[MAXSIGNUM];\n\nint os::Aix::get_our_sigflags(int sig) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  return sigflags[sig];\n}\n\nvoid os::Aix::set_our_sigflags(int sig, int flags) {\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = flags;\n}\n\nvoid os::Aix::set_signal_handler(int sig, bool set_installed) {\n  // Check for overwrite.\n  struct sigaction oldAct;\n  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n\n  void* oldhand = oldAct.sa_sigaction\n    ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n    : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n  // Renamed 'signalHandler' to avoid collision with other shared libs.\n  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)javaSignalHandler)) {\n    if (AllowUserSignalHandlers || !set_installed) {\n      // Do not overwrite; user takes responsibility to forward to us.\n      return;\n    } else if (UseSignalChaining) {\n      // save the old handler in jvm\n      save_preinstalled_handler(sig, oldAct);\n      // libjsig also interposes the sigaction() call below and saves the\n      // old sigaction on it own.\n    } else {\n      fatal(err_msg(\"Encountered unexpected pre-existing sigaction handler \"\n                    \"%#lx for signal %d.\", (long)oldhand, sig));\n    }\n  }\n\n  struct sigaction sigAct;\n  sigfillset(&(sigAct.sa_mask));\n  if (!set_installed) {\n    sigAct.sa_handler = SIG_DFL;\n    sigAct.sa_flags = SA_RESTART;\n  } else {\n    // Renamed 'signalHandler' to avoid collision with other shared libs.\n    sigAct.sa_sigaction = javaSignalHandler;\n    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n  }\n  // Save flags, which are set by ours\n  assert(sig > 0 && sig < MAXSIGNUM, \"vm signal out of expected range\");\n  sigflags[sig] = sigAct.sa_flags;\n\n  int ret = sigaction(sig, &sigAct, &oldAct);\n  assert(ret == 0, \"check\");\n\n  void* oldhand2 = oldAct.sa_sigaction\n                 ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n                 : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n}\n\n// install signal handlers for signals that HotSpot needs to\n// handle in order to support Java-level exception handling.\nvoid os::Aix::install_signal_handlers() {\n  if (!signal_handlers_are_installed) {\n    signal_handlers_are_installed = true;\n\n    // signal-chaining\n    typedef void (*signal_setting_t)();\n    signal_setting_t begin_signal_setting = NULL;\n    signal_setting_t end_signal_setting = NULL;\n    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n    if (begin_signal_setting != NULL) {\n      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n                             dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n                            dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n      libjsig_is_loaded = true;\n      assert(UseSignalChaining, \"should enable signal-chaining\");\n    }\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm is setting signal handlers\n      (*begin_signal_setting)();\n    }\n\n    set_signal_handler(SIGSEGV, true);\n    set_signal_handler(SIGPIPE, true);\n    set_signal_handler(SIGBUS, true);\n    set_signal_handler(SIGILL, true);\n    set_signal_handler(SIGFPE, true);\n    set_signal_handler(SIGTRAP, true);\n    set_signal_handler(SIGXFSZ, true);\n    set_signal_handler(SIGDANGER, true);\n\n    if (libjsig_is_loaded) {\n      // Tell libjsig jvm finishes setting signal handlers.\n      (*end_signal_setting)();\n    }\n\n    // We don't activate signal checker if libjsig is in place, we trust ourselves\n    // and if UserSignalHandler is installed all bets are off.\n    // Log that signal checking is off only if -verbose:jni is specified.\n    if (CheckJNICalls) {\n      if (libjsig_is_loaded) {\n        tty->print_cr(\"Info: libjsig is activated, all active signal checking is disabled\");\n        check_signals = false;\n      }\n      if (AllowUserSignalHandlers) {\n        tty->print_cr(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n        check_signals = false;\n      }\n      // Need to initialize check_signal_done.\n      ::sigemptyset(&check_signal_done);\n    }\n  }\n}\n\nstatic const char* get_signal_handler_name(address handler,\n                                           char* buf, int buflen) {\n  int offset;\n  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n  if (found) {\n    // skip directory names\n    const char *p1, *p2;\n    p1 = buf;\n    size_t len = strlen(os::file_separator());\n    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n    // The way os::dll_address_to_library_name is implemented on Aix\n    // right now, it always returns -1 for the offset which is not\n    // terribly informative.\n    // Will fix that. For now, omit the offset.\n    jio_snprintf(buf, buflen, \"%s\", p1);\n  } else {\n    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n  }\n  return buf;\n}\n\nstatic void print_signal_handler(outputStream* st, int sig,\n                                 char* buf, size_t buflen) {\n  struct sigaction sa;\n  sigaction(sig, NULL, &sa);\n\n  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n\n  address handler = (sa.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n\n  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n    st->print(\"SIG_DFL\");\n  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n    st->print(\"SIG_IGN\");\n  } else {\n    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n  }\n\n  // Print readable mask.\n  st->print(\", sa_mask[0]=\");\n  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n\n  address rh = VMError::get_resetted_sighandler(sig);\n  // May be, handler was resetted by VMError?\n  if (rh != NULL) {\n    handler = rh;\n    sa.sa_flags = VMError::get_resetted_sigflags(sig);\n  }\n\n  // Print textual representation of sa_flags.\n  st->print(\", sa_flags=\");\n  os::Posix::print_sa_flags(st, sa.sa_flags);\n\n  // Check: is it our handler?\n  if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler) ||\n      handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n    // It is our signal handler.\n    // Check for flags, reset system-used one!\n    if ((int)sa.sa_flags != os::Aix::get_our_sigflags(sig)) {\n      st->print(\", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n                os::Aix::get_our_sigflags(sig));\n    }\n  }\n  st->cr();\n}\n\n#define DO_SIGNAL_CHECK(sig) \\\n  if (!sigismember(&check_signal_done, sig)) \\\n    os::Aix::check_signal_handler(sig)\n\n// This method is a periodic task to check for misbehaving JNI applications\n// under CheckJNI, we can add any periodic checks here\n\nvoid os::run_periodic_checks() {\n\n  if (check_signals == false) return;\n\n  // SEGV and BUS if overridden could potentially prevent\n  // generation of hs*.log in the event of a crash, debugging\n  // such a case can be very challenging, so we absolutely\n  // check the following for a good measure:\n  DO_SIGNAL_CHECK(SIGSEGV);\n  DO_SIGNAL_CHECK(SIGILL);\n  DO_SIGNAL_CHECK(SIGFPE);\n  DO_SIGNAL_CHECK(SIGBUS);\n  DO_SIGNAL_CHECK(SIGPIPE);\n  DO_SIGNAL_CHECK(SIGXFSZ);\n  if (UseSIGTRAP) {\n    DO_SIGNAL_CHECK(SIGTRAP);\n  }\n  DO_SIGNAL_CHECK(SIGDANGER);\n\n  // ReduceSignalUsage allows the user to override these handlers\n  // see comments at the very top and jvm_solaris.h\n  if (!ReduceSignalUsage) {\n    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n  }\n\n  DO_SIGNAL_CHECK(SR_signum);\n  DO_SIGNAL_CHECK(INTERRUPT_SIGNAL);\n}\n\ntypedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic os_sigaction_t os_sigaction = NULL;\n\nvoid os::Aix::check_signal_handler(int sig) {\n  char buf[O_BUFLEN];\n  address jvmHandler = NULL;\n\n  struct sigaction act;\n  if (os_sigaction == NULL) {\n    // only trust the default sigaction, in case it has been interposed\n    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n    if (os_sigaction == NULL) return;\n  }\n\n  os_sigaction(sig, (struct sigaction*)NULL, &act);\n\n  address thisHandler = (act.sa_flags & SA_SIGINFO)\n    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n    : CAST_FROM_FN_PTR(address, act.sa_handler);\n\n  switch(sig) {\n  case SIGSEGV:\n  case SIGBUS:\n  case SIGFPE:\n  case SIGPIPE:\n  case SIGILL:\n  case SIGXFSZ:\n    // Renamed 'signalHandler' to avoid collision with other shared libs.\n    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)javaSignalHandler);\n    break;\n\n  case SHUTDOWN1_SIGNAL:\n  case SHUTDOWN2_SIGNAL:\n  case SHUTDOWN3_SIGNAL:\n  case BREAK_SIGNAL:\n    jvmHandler = (address)user_handler();\n    break;\n\n  case INTERRUPT_SIGNAL:\n    jvmHandler = CAST_FROM_FN_PTR(address, SIG_DFL);\n    break;\n\n  default:\n    if (sig == SR_signum) {\n      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n    } else {\n      return;\n    }\n    break;\n  }\n\n  if (thisHandler != jvmHandler) {\n    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n    // Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n                    exception_name(sig, buf, O_BUFLEN));\n    }\n  } else if (os::Aix::get_our_sigflags(sig) != 0 && (int)act.sa_flags != os::Aix::get_our_sigflags(sig)) {\n    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n    tty->print(\"expected:\" PTR32_FORMAT, os::Aix::get_our_sigflags(sig));\n    tty->print_cr(\"  found:\" PTR32_FORMAT, act.sa_flags);\n    // No need to check this sig any longer\n    sigaddset(&check_signal_done, sig);\n  }\n\n  // Dump all the signal\n  if (sigismember(&check_signal_done, sig)) {\n    print_signal_handlers(tty, buf, O_BUFLEN);\n  }\n}\n\nextern bool signal_name(int signo, char* buf, size_t len);\n\nconst char* os::exception_name(int exception_code, char* buf, size_t size) {\n  if (0 < exception_code && exception_code <= SIGRTMAX) {\n    // signal\n    if (!signal_name(exception_code, buf, size)) {\n      jio_snprintf(buf, size, \"SIG%d\", exception_code);\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\n// To install functions for atexit system call\nextern \"C\" {\n  static void perfMemory_exit_helper() {\n    perfMemory_exit();\n  }\n}\n\n// This is called _before_ the most of global arguments have been parsed.\nvoid os::init(void) {\n  // This is basic, we want to know if that ever changes.\n  // (shared memory boundary is supposed to be a 256M aligned)\n  assert(SHMLBA == ((uint64_t)0x10000000ULL)/*256M*/, \"unexpected\");\n\n  // First off, we need to know whether we run on AIX or PASE, and\n  // the OS level we run on.\n  os::Aix::initialize_os_info();\n\n  // Scan environment (SPEC1170 behaviour, etc)\n  os::Aix::scan_environment();\n\n  // Check which pages are supported by AIX.\n  os::Aix::query_multipage_support();\n\n  // Next, we need to initialize libo4 and libperfstat libraries.\n  if (os::Aix::on_pase()) {\n    os::Aix::initialize_libo4();\n  } else {\n    os::Aix::initialize_libperfstat();\n  }\n\n  // Reset the perfstat information provided by ODM.\n  if (os::Aix::on_aix()) {\n    libperfstat::perfstat_reset();\n  }\n\n  // Now initialze basic system properties. Note that for some of the values we\n  // need libperfstat etc.\n  os::Aix::initialize_system_info();\n\n  // Initialize large page support.\n  if (UseLargePages) {\n    os::large_page_init();\n    if (!UseLargePages) {\n      // initialize os::_page_sizes\n      _page_sizes[0] = Aix::page_size();\n      _page_sizes[1] = 0;\n      if (Verbose) {\n        fprintf(stderr, \"Large Page initialization failed: setting UseLargePages=0.\\n\");\n      }\n    }\n  } else {\n    // initialize os::_page_sizes\n    _page_sizes[0] = Aix::page_size();\n    _page_sizes[1] = 0;\n  }\n\n  // debug trace\n  if (Verbose) {\n    fprintf(stderr, \"os::vm_page_size 0x%llX\\n\", os::vm_page_size());\n    fprintf(stderr, \"os::large_page_size 0x%llX\\n\", os::large_page_size());\n    fprintf(stderr, \"os::_page_sizes = ( \");\n    for (int i = 0; _page_sizes[i]; i ++) {\n      fprintf(stderr, \" %s \", describe_pagesize(_page_sizes[i]));\n    }\n    fprintf(stderr, \")\\n\");\n  }\n\n  _initial_pid = getpid();\n\n  clock_tics_per_sec = sysconf(_SC_CLK_TCK);\n\n  init_random(1234567);\n\n  ThreadCritical::initialize();\n\n  // Main_thread points to the aboriginal thread.\n  Aix::_main_thread = pthread_self();\n\n  initial_time_count = os::elapsed_counter();\n  pthread_mutex_init(&dl_mutex, NULL);\n}\n\n// This is called _after_ the global arguments have been parsed.\njint os::init_2(void) {\n\n  trcVerbose(\"processor count: %d\", os::_processor_count);\n  trcVerbose(\"physical memory: %lu\", Aix::_physical_memory);\n\n  // Initially build up the loaded dll map.\n  LoadedLibraries::reload();\n\n  const int page_size = Aix::page_size();\n  const int map_size = page_size;\n\n  address map_address = (address) MAP_FAILED;\n  const int prot  = PROT_READ;\n  const int flags = MAP_PRIVATE|MAP_ANONYMOUS;\n\n  // use optimized addresses for the polling page,\n  // e.g. map it to a special 32-bit address.\n  if (OptimizePollingPageLocation) {\n    // architecture-specific list of address wishes:\n    address address_wishes[] = {\n      // AIX: addresses lower than 0x30000000 don't seem to work on AIX.\n      // PPC64: all address wishes are non-negative 32 bit values where\n      // the lower 16 bits are all zero. we can load these addresses\n      // with a single ppc_lis instruction.\n      (address) 0x30000000, (address) 0x31000000,\n      (address) 0x32000000, (address) 0x33000000,\n      (address) 0x40000000, (address) 0x41000000,\n      (address) 0x42000000, (address) 0x43000000,\n      (address) 0x50000000, (address) 0x51000000,\n      (address) 0x52000000, (address) 0x53000000,\n      (address) 0x60000000, (address) 0x61000000,\n      (address) 0x62000000, (address) 0x63000000\n    };\n    int address_wishes_length = sizeof(address_wishes)/sizeof(address);\n\n    // iterate over the list of address wishes:\n    for (int i=0; i<address_wishes_length; i++) {\n      // try to map with current address wish.\n      // AIX: AIX needs MAP_FIXED if we provide an address and mmap will\n      // fail if the address is already mapped.\n      map_address = (address) ::mmap(address_wishes[i] - (ssize_t)page_size,\n                                     map_size, prot,\n                                     flags | MAP_FIXED,\n                                     -1, 0);\n      if (Verbose) {\n        fprintf(stderr, \"SafePoint Polling Page address: %p (wish) => %p\\n\",\n                address_wishes[i], map_address + (ssize_t)page_size);\n      }\n\n      if (map_address + (ssize_t)page_size == address_wishes[i]) {\n        // map succeeded and map_address is at wished address, exit loop.\n        break;\n      }\n\n      if (map_address != (address) MAP_FAILED) {\n        // Map succeeded, but polling_page is not at wished address, unmap and continue.\n        ::munmap(map_address, map_size);\n        map_address = (address) MAP_FAILED;\n      }\n      // map failed, continue loop.\n    }\n  } // end OptimizePollingPageLocation\n\n  if (map_address == (address) MAP_FAILED) {\n    map_address = (address) ::mmap(NULL, map_size, prot, flags, -1, 0);\n  }\n  guarantee(map_address != MAP_FAILED, \"os::init_2: failed to allocate polling page\");\n  os::set_polling_page(map_address);\n\n  if (!UseMembar) {\n    address mem_serialize_page = (address) ::mmap(NULL, Aix::page_size(), PROT_READ | PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    guarantee(mem_serialize_page != NULL, \"mmap Failed for memory serialize page\");\n    os::set_memory_serialize_page(mem_serialize_page);\n\n#ifndef PRODUCT\n    if (Verbose && PrintMiscellaneous)\n      tty->print(\"[Memory Serialize Page address: \" INTPTR_FORMAT \"]\\n\", (intptr_t)mem_serialize_page);\n#endif\n  }\n\n  // initialize suspend/resume support - must do this before signal_sets_init()\n  if (SR_initialize() != 0) {\n    perror(\"SR_initialize failed\");\n    return JNI_ERR;\n  }\n\n  Aix::signal_sets_init();\n  Aix::install_signal_handlers();\n\n  // Check minimum allowable stack size for thread creation and to initialize\n  // the java system classes, including StackOverflowError - depends on page\n  // size. Add a page for compiler2 recursion in main thread.\n  // Add in 2*BytesPerWord times page size to account for VM stack during\n  // class initialization depending on 32 or 64 bit VM.\n  os::Aix::min_stack_allowed = MAX2(os::Aix::min_stack_allowed,\n            (size_t)(StackYellowPages+StackRedPages+StackShadowPages +\n                     2*BytesPerWord COMPILER2_PRESENT(+1)) * Aix::page_size());\n\n  size_t threadStackSizeInBytes = ThreadStackSize * K;\n  if (threadStackSizeInBytes != 0 &&\n      threadStackSizeInBytes < os::Aix::min_stack_allowed) {\n        tty->print_cr(\"\\nThe stack size specified is too small, \"\n                      \"Specify at least %dk\",\n                      os::Aix::min_stack_allowed / K);\n        return JNI_ERR;\n  }\n\n  // Make the stack size a multiple of the page size so that\n  // the yellow/red zones can be guarded.\n  // Note that this can be 0, if no default stacksize was set.\n  JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes, vm_page_size()));\n\n  Aix::libpthread_init();\n\n  if (MaxFDLimit) {\n    // set the number of file descriptors to max. print out error\n    // if getrlimit/setrlimit fails but continue regardless.\n    struct rlimit nbr_files;\n    int status = getrlimit(RLIMIT_NOFILE, &nbr_files);\n    if (status != 0) {\n      if (PrintMiscellaneous && (Verbose || WizardMode))\n        perror(\"os::init_2 getrlimit failed\");\n    } else {\n      nbr_files.rlim_cur = nbr_files.rlim_max;\n      status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n      if (status != 0) {\n        if (PrintMiscellaneous && (Verbose || WizardMode))\n          perror(\"os::init_2 setrlimit failed\");\n      }\n    }\n  }\n\n  if (PerfAllowAtExitRegistration) {\n    // only register atexit functions if PerfAllowAtExitRegistration is set.\n    // atexit functions can be delayed until process exit time, which\n    // can be problematic for embedded VM situations. Embedded VMs should\n    // call DestroyJavaVM() to assure that VM resources are released.\n\n    // note: perfMemory_exit_helper atexit function may be removed in\n    // the future if the appropriate cleanup code can be added to the\n    // VM_Exit VMOperation's doit method.\n    if (atexit(perfMemory_exit_helper) != 0) {\n      warning(\"os::init_2 atexit(perfMemory_exit_helper) failed\");\n    }\n  }\n\n  return JNI_OK;\n}\n\n// Mark the polling page as unreadable\nvoid os::make_polling_page_unreadable(void) {\n  if (!guard_memory((char*)_polling_page, Aix::page_size())) {\n    fatal(\"Could not disable polling page\");\n  }\n};\n\n// Mark the polling page as readable\nvoid os::make_polling_page_readable(void) {\n  // Changed according to os_linux.cpp.\n  if (!checked_mprotect((char *)_polling_page, Aix::page_size(), PROT_READ)) {\n    fatal(err_msg(\"Could not enable polling page at \" PTR_FORMAT, _polling_page));\n  }\n};\n\nint os::active_processor_count() {\n  int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);\n  assert(online_cpus > 0 && online_cpus <= processor_count(), \"sanity check\");\n  return online_cpus;\n}\n\nvoid os::set_native_thread_name(const char *name) {\n  // Not yet implemented.\n  return;\n}\n\nbool os::distribute_processes(uint length, uint* distribution) {\n  // Not yet implemented.\n  return false;\n}\n\nbool os::bind_to_processor(uint processor_id) {\n  // Not yet implemented.\n  return false;\n}\n\nvoid os::SuspendedThreadTask::internal_do_task() {\n  if (do_suspend(_thread->osthread())) {\n    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n    do_task(context);\n    do_resume(_thread->osthread());\n  }\n}\n\nclass PcFetcher : public os::SuspendedThreadTask {\npublic:\n  PcFetcher(Thread* thread) : os::SuspendedThreadTask(thread) {}\n  ExtendedPC result();\nprotected:\n  void do_task(const os::SuspendedThreadTaskContext& context);\nprivate:\n  ExtendedPC _epc;\n};\n\nExtendedPC PcFetcher::result() {\n  guarantee(is_done(), \"task is not done yet.\");\n  return _epc;\n}\n\nvoid PcFetcher::do_task(const os::SuspendedThreadTaskContext& context) {\n  Thread* thread = context.thread();\n  OSThread* osthread = thread->osthread();\n  if (osthread->ucontext() != NULL) {\n    _epc = os::Aix::ucontext_get_pc((ucontext_t *) context.ucontext());\n  } else {\n    // NULL context is unexpected, double-check this is the VMThread.\n    guarantee(thread->is_VM_thread(), \"can only be called for VMThread\");\n  }\n}\n\n// Suspends the target using the signal mechanism and then grabs the PC before\n// resuming the target. Used by the flat-profiler only\nExtendedPC os::get_thread_pc(Thread* thread) {\n  // Make sure that it is called by the watcher for the VMThread.\n  assert(Thread::current()->is_Watcher_thread(), \"Must be watcher\");\n  assert(thread->is_VM_thread(), \"Can only be called for VMThread\");\n\n  PcFetcher fetcher(thread);\n  fetcher.run();\n  return fetcher.result();\n}\n\n// Not neede on Aix.\n// int os::Aix::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime) {\n// }\n\n////////////////////////////////////////////////////////////////////////////////\n// debug support\n\nstatic address same_page(address x, address y) {\n  intptr_t page_bits = -os::vm_page_size();\n  if ((intptr_t(x) & page_bits) == (intptr_t(y) & page_bits))\n    return x;\n  else if (x > y)\n    return (address)(intptr_t(y) | ~page_bits) + 1;\n  else\n    return (address)(intptr_t(y) & page_bits);\n}\n\nbool os::find(address addr, outputStream* st) {\n\n  st->print(PTR_FORMAT \": \", addr);\n\n  const LoadedLibraryModule* lib = LoadedLibraries::find_for_text_address(addr);\n  if (lib) {\n    lib->print(st);\n    return true;\n  } else {\n    lib = LoadedLibraries::find_for_data_address(addr);\n    if (lib) {\n      lib->print(st);\n      return true;\n    } else {\n      st->print_cr(\"(outside any module)\");\n    }\n  }\n\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// misc\n\n// This does not do anything on Aix. This is basically a hook for being\n// able to use structured exception handling (thread-local exception filters)\n// on, e.g., Win32.\nvoid\nos::os_exception_wrapper(java_call_t f, JavaValue* value, methodHandle* method,\n                         JavaCallArguments* args, Thread* thread) {\n  f(value, method, args, thread);\n}\n\nvoid os::print_statistics() {\n}\n\nint os::message_box(const char* title, const char* message) {\n  int i;\n  fdStream err(defaultStream::error_fd());\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n  err.print_raw_cr(title);\n  for (i = 0; i < 78; i++) err.print_raw(\"-\");\n  err.cr();\n  err.print_raw_cr(message);\n  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n  err.cr();\n\n  char buf[16];\n  // Prevent process from exiting upon \"read error\" without consuming all CPU\n  while (::read(0, buf, sizeof(buf)) <= 0) { ::sleep(100); }\n\n  return buf[0] == 'y' || buf[0] == 'Y';\n}\n\nint os::stat(const char *path, struct stat *sbuf) {\n  char pathbuf[MAX_PATH];\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  os::native_path(strcpy(pathbuf, path));\n  return ::stat(pathbuf, sbuf);\n}\n\nbool os::check_heap(bool force) {\n  return true;\n}\n\n// int local_vsnprintf(char* buf, size_t count, const char* format, va_list args) {\n//   return ::vsnprintf(buf, count, format, args);\n// }\n\n// Is a (classpath) directory empty?\nbool os::dir_is_empty(const char* path) {\n  DIR *dir = NULL;\n  struct dirent *ptr;\n\n  dir = opendir(path);\n  if (dir == NULL) return true;\n\n  /* Scan the directory */\n  bool result = true;\n  char buf[sizeof(struct dirent) + MAX_PATH];\n  while (result && (ptr = ::readdir(dir)) != NULL) {\n    if (strcmp(ptr->d_name, \".\") != 0 && strcmp(ptr->d_name, \"..\") != 0) {\n      result = false;\n    }\n  }\n  closedir(dir);\n  return result;\n}\n\n// This code originates from JDK's sysOpen and open64_w\n// from src/solaris/hpi/src/system_md.c\n\n#ifndef O_DELETE\n#define O_DELETE 0x10000\n#endif\n\n// Open a file. Unlink the file immediately after open returns\n// if the specified oflag has the O_DELETE flag set.\n// O_DELETE is used only in j2se/src/share/native/java/util/zip/ZipFile.c\n\nint os::open(const char *path, int oflag, int mode) {\n\n  if (strlen(path) > MAX_PATH - 1) {\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  int fd;\n  int o_delete = (oflag & O_DELETE);\n  oflag = oflag & ~O_DELETE;\n\n  fd = ::open64(path, oflag, mode);\n  if (fd == -1) return -1;\n\n  // If the open succeeded, the file might still be a directory.\n  {\n    struct stat64 buf64;\n    int ret = ::fstat64(fd, &buf64);\n    int st_mode = buf64.st_mode;\n\n    if (ret != -1) {\n      if ((st_mode & S_IFMT) == S_IFDIR) {\n        errno = EISDIR;\n        ::close(fd);\n        return -1;\n      }\n    } else {\n      ::close(fd);\n      return -1;\n    }\n  }\n\n  // All file descriptors that are opened in the JVM and not\n  // specifically destined for a subprocess should have the\n  // close-on-exec flag set. If we don't set it, then careless 3rd\n  // party native code might fork and exec without closing all\n  // appropriate file descriptors (e.g. as we do in closeDescriptors in\n  // UNIXProcess.c), and this in turn might:\n  //\n  // - cause end-of-file to fail to be detected on some file\n  //   descriptors, resulting in mysterious hangs, or\n  //\n  // - might cause an fopen in the subprocess to fail on a system\n  //   suffering from bug 1085341.\n  //\n  // (Yes, the default setting of the close-on-exec flag is a Unix\n  // design flaw.)\n  //\n  // See:\n  // 1085341: 32-bit stdio routines should support file descriptors >255\n  // 4843136: (process) pipe file descriptor from Runtime.exec not being closed\n  // 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9\n#ifdef FD_CLOEXEC\n  {\n    int flags = ::fcntl(fd, F_GETFD);\n    if (flags != -1)\n      ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n  }\n#endif\n\n  if (o_delete != 0) {\n    ::unlink(path);\n  }\n  return fd;\n}\n\n// create binary file, rewriting existing file if required\nint os::create_binary_file(const char* path, bool rewrite_existing) {\n  int oflags = O_WRONLY | O_CREAT;\n  if (!rewrite_existing) {\n    oflags |= O_EXCL;\n  }\n  return ::open64(path, oflags, S_IREAD | S_IWRITE);\n}\n\n// return current position of file pointer\njlong os::current_file_offset(int fd) {\n  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);\n}\n\n// move file pointer to the specified offset\njlong os::seek_to_file_offset(int fd, jlong offset) {\n  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);\n}\n\n// This code originates from JDK's sysAvailable\n// from src/solaris/hpi/src/native_threads/src/sys_api_td.c\n\nint os::available(int fd, jlong *bytes) {\n  jlong cur, end;\n  int mode;\n  struct stat64 buf64;\n\n  if (::fstat64(fd, &buf64) >= 0) {\n    mode = buf64.st_mode;\n    if (S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n      // XXX: is the following call interruptible? If so, this might\n      // need to go through the INTERRUPT_IO() wrapper as for other\n      // blocking, interruptible calls in this file.\n      int n;\n      if (::ioctl(fd, FIONREAD, &n) >= 0) {\n        *bytes = n;\n        return 1;\n      }\n    }\n  }\n  if ((cur = ::lseek64(fd, 0L, SEEK_CUR)) == -1) {\n    return 0;\n  } else if ((end = ::lseek64(fd, 0L, SEEK_END)) == -1) {\n    return 0;\n  } else if (::lseek64(fd, cur, SEEK_SET) == -1) {\n    return 0;\n  }\n  *bytes = end - cur;\n  return 1;\n}\n\nint os::socket_available(int fd, jint *pbytes) {\n  // Linux doc says EINTR not returned, unlike Solaris\n  int ret = ::ioctl(fd, FIONREAD, pbytes);\n\n  //%% note ioctl can return 0 when successful, JVM_SocketAvailable\n  // is expected to return 0 on failure and 1 on success to the jdk.\n  return (ret < 0) ? 0 : 1;\n}\n\n// Map a block of memory.\nchar* os::pd_map_memory(int fd, const char* file_name, size_t file_offset,\n                        char *addr, size_t bytes, bool read_only,\n                        bool allow_exec) {\n  Unimplemented();\n  return NULL;\n}\n\n// Remap a block of memory.\nchar* os::pd_remap_memory(int fd, const char* file_name, size_t file_offset,\n                          char *addr, size_t bytes, bool read_only,\n                          bool allow_exec) {\n  // same as map_memory() on this OS\n  return os::map_memory(fd, file_name, file_offset, addr, bytes, read_only,\n                        allow_exec);\n}\n\n// Unmap a block of memory.\nbool os::pd_unmap_memory(char* addr, size_t bytes) {\n  return munmap(addr, bytes) == 0;\n}\n\n// current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)\n// are used by JVM M&M and JVMTI to get user+sys or user CPU time\n// of a thread.\n//\n// current_thread_cpu_time() and thread_cpu_time(Thread*) returns\n// the fast estimate available on the platform.\n\njlong os::current_thread_cpu_time() {\n  // return user + sys since the cost is the same\n  const jlong n = os::thread_cpu_time(Thread::current(), true /* user + sys */);\n  assert(n >= 0, \"negative CPU time\");\n  return n;\n}\n\njlong os::thread_cpu_time(Thread* thread) {\n  // consistent with what current_thread_cpu_time() returns\n  const jlong n = os::thread_cpu_time(thread, true /* user + sys */);\n  assert(n >= 0, \"negative CPU time\");\n  return n;\n}\n\njlong os::current_thread_cpu_time(bool user_sys_cpu_time) {\n  const jlong n = os::thread_cpu_time(Thread::current(), user_sys_cpu_time);\n  assert(n >= 0, \"negative CPU time\");\n  return n;\n}\n\nstatic bool thread_cpu_time_unchecked(Thread* thread, jlong* p_sys_time, jlong* p_user_time) {\n  bool error = false;\n\n  jlong sys_time = 0;\n  jlong user_time = 0;\n\n  // Reimplemented using getthrds64().\n  //\n  // Works like this:\n  // For the thread in question, get the kernel thread id. Then get the\n  // kernel thread statistics using that id.\n  //\n  // This only works of course when no pthread scheduling is used,\n  // i.e. there is a 1:1 relationship to kernel threads.\n  // On AIX, see AIXTHREAD_SCOPE variable.\n\n  pthread_t pthtid = thread->osthread()->pthread_id();\n\n  // retrieve kernel thread id for the pthread:\n  tid64_t tid = 0;\n  struct __pthrdsinfo pinfo;\n  // I just love those otherworldly IBM APIs which force me to hand down\n  // dummy buffers for stuff I dont care for...\n  char dummy[1];\n  int dummy_size = sizeof(dummy);\n  if (pthread_getthrds_np(&pthtid, PTHRDSINFO_QUERY_TID, &pinfo, sizeof(pinfo),\n                          dummy, &dummy_size) == 0) {\n    tid = pinfo.__pi_tid;\n  } else {\n    tty->print_cr(\"pthread_getthrds_np failed.\");\n    error = true;\n  }\n\n  // retrieve kernel timing info for that kernel thread\n  if (!error) {\n    struct thrdentry64 thrdentry;\n    if (getthrds64(getpid(), &thrdentry, sizeof(thrdentry), &tid, 1) == 1) {\n      sys_time = thrdentry.ti_ru.ru_stime.tv_sec * 1000000000LL + thrdentry.ti_ru.ru_stime.tv_usec * 1000LL;\n      user_time = thrdentry.ti_ru.ru_utime.tv_sec * 1000000000LL + thrdentry.ti_ru.ru_utime.tv_usec * 1000LL;\n    } else {\n      tty->print_cr(\"pthread_getthrds_np failed.\");\n      error = true;\n    }\n  }\n\n  if (p_sys_time) {\n    *p_sys_time = sys_time;\n  }\n\n  if (p_user_time) {\n    *p_user_time = user_time;\n  }\n\n  if (error) {\n    return false;\n  }\n\n  return true;\n}\n\njlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {\n  jlong sys_time;\n  jlong user_time;\n\n  if (!thread_cpu_time_unchecked(thread, &sys_time, &user_time)) {\n    return -1;\n  }\n\n  return user_sys_cpu_time ? sys_time + user_time : user_time;\n}\n\nvoid os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nvoid os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {\n  info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits\n  info_ptr->may_skip_backward = false;     // elapsed time not wall time\n  info_ptr->may_skip_forward = false;      // elapsed time not wall time\n  info_ptr->kind = JVMTI_TIMER_TOTAL_CPU;  // user+system time is returned\n}\n\nbool os::is_thread_cpu_time_supported() {\n  return true;\n}\n\n// System loadavg support. Returns -1 if load average cannot be obtained.\n// For now just return the system wide load average (no processor sets).\nint os::loadavg(double values[], int nelem) {\n\n  // Implemented using libperfstat on AIX.\n\n  guarantee(nelem >= 0 && nelem <= 3, \"argument error\");\n  guarantee(values, \"argument error\");\n\n  if (os::Aix::on_pase()) {\n    Unimplemented();\n    return -1;\n  } else {\n    // AIX: use libperfstat\n    //\n    // See also:\n    // http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/perfstat_cputot.htm\n    // /usr/include/libperfstat.h:\n\n    // Use the already AIX version independent get_cpuinfo.\n    os::Aix::cpuinfo_t ci;\n    if (os::Aix::get_cpuinfo(&ci)) {\n      for (int i = 0; i < nelem; i++) {\n        values[i] = ci.loadavg[i];\n      }\n    } else {\n      return -1;\n    }\n    return nelem;\n  }\n}\n\nvoid os::pause() {\n  char filename[MAX_PATH];\n  if (PauseAtStartupFile && PauseAtStartupFile[0]) {\n    jio_snprintf(filename, MAX_PATH, PauseAtStartupFile);\n  } else {\n    jio_snprintf(filename, MAX_PATH, \"./vm.paused.%d\", current_process_id());\n  }\n\n  int fd = ::open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n  if (fd != -1) {\n    struct stat buf;\n    ::close(fd);\n    while (::stat(filename, &buf) == 0) {\n      (void)::poll(NULL, 0, 100);\n    }\n  } else {\n    jio_fprintf(stderr,\n      \"Could not open pause file '%s', continuing immediately.\\n\", filename);\n  }\n}\n\nbool os::Aix::is_primordial_thread() {\n  if (pthread_self() == (pthread_t)1) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// OS recognitions (PASE/AIX, OS level) call this before calling any\n// one of Aix::on_pase(), Aix::os_version() static\nvoid os::Aix::initialize_os_info() {\n\n  assert(_on_pase == -1 && _os_version == -1, \"already called.\");\n\n  struct utsname uts;\n  memset(&uts, 0, sizeof(uts));\n  strcpy(uts.sysname, \"?\");\n  if (::uname(&uts) == -1) {\n    trc(\"uname failed (%d)\", errno);\n    guarantee(0, \"Could not determine whether we run on AIX or PASE\");\n  } else {\n    trcVerbose(\"uname says: sysname \\\"%s\\\" version \\\"%s\\\" release \\\"%s\\\" \"\n               \"node \\\"%s\\\" machine \\\"%s\\\"\\n\",\n               uts.sysname, uts.version, uts.release, uts.nodename, uts.machine);\n    const int major = atoi(uts.version);\n    assert(major > 0, \"invalid OS version\");\n    const int minor = atoi(uts.release);\n    assert(minor > 0, \"invalid OS release\");\n    _os_version = (major << 8) | minor;\n    if (strcmp(uts.sysname, \"OS400\") == 0) {\n      Unimplemented();\n    } else if (strcmp(uts.sysname, \"AIX\") == 0) {\n      // We run on AIX. We do not support versions older than AIX 5.3.\n      _on_pase = 0;\n      if (_os_version < 0x0503) {\n        trc(\"AIX release older than AIX 5.3 not supported.\");\n        assert(false, \"AIX release too old.\");\n      } else {\n        trcVerbose(\"We run on AIX %d.%d\\n\", major, minor);\n      }\n    } else {\n      assert(false, \"unknown OS\");\n    }\n  }\n\n  guarantee(_on_pase != -1 && _os_version, \"Could not determine AIX/OS400 release\");\n} // end: os::Aix::initialize_os_info()\n\n// Scan environment for important settings which might effect the VM.\n// Trace out settings. Warn about invalid settings and/or correct them.\n//\n// Must run after os::Aix::initialue_os_info().\nvoid os::Aix::scan_environment() {\n\n  char* p;\n  int rc;\n\n  // Warn explicity if EXTSHM=ON is used. That switch changes how\n  // System V shared memory behaves. One effect is that page size of\n  // shared memory cannot be change dynamically, effectivly preventing\n  // large pages from working.\n  // This switch was needed on AIX 32bit, but on AIX 64bit the general\n  // recommendation is (in OSS notes) to switch it off.\n  p = ::getenv(\"EXTSHM\");\n  if (Verbose) {\n    fprintf(stderr, \"EXTSHM=%s.\\n\", p ? p : \"<unset>\");\n  }\n  if (p && strcmp(p, \"ON\") == 0) {\n    fprintf(stderr, \"Unsupported setting: EXTSHM=ON. Large Page support will be disabled.\\n\");\n    _extshm = 1;\n  } else {\n    _extshm = 0;\n  }\n\n  // SPEC1170 behaviour: will change the behaviour of a number of POSIX APIs.\n  // Not tested, not supported.\n  //\n  // Note that it might be worth the trouble to test and to require it, if only to\n  // get useful return codes for mprotect.\n  //\n  // Note: Setting XPG_SUS_ENV in the process is too late. Must be set earlier (before\n  // exec() ? before loading the libjvm ? ....)\n  p = ::getenv(\"XPG_SUS_ENV\");\n  trcVerbose(\"XPG_SUS_ENV=%s.\", p ? p : \"<unset>\");\n  if (p && strcmp(p, \"ON\") == 0) {\n    _xpg_sus_mode = 1;\n    trc(\"Unsupported setting: XPG_SUS_ENV=ON\");\n    // This is not supported. Worst of all, it changes behaviour of mmap MAP_FIXED to\n    // clobber address ranges. If we ever want to support that, we have to do some\n    // testing first.\n    guarantee(false, \"XPG_SUS_ENV=ON not supported\");\n  } else {\n    _xpg_sus_mode = 0;\n  }\n\n  // Switch off AIX internal (pthread) guard pages. This has\n  // immediate effect for any pthread_create calls which follow.\n  p = ::getenv(\"AIXTHREAD_GUARDPAGES\");\n  trcVerbose(\"AIXTHREAD_GUARDPAGES=%s.\", p ? p : \"<unset>\");\n  rc = ::putenv(\"AIXTHREAD_GUARDPAGES=0\");\n  guarantee(rc == 0, \"\");\n\n} // end: os::Aix::scan_environment()\n\n// PASE: initialize the libo4 library (AS400 PASE porting library).\nvoid os::Aix::initialize_libo4() {\n  Unimplemented();\n}\n\n// AIX: initialize the libperfstat library (we load this dynamically\n// because it is only available on AIX.\nvoid os::Aix::initialize_libperfstat() {\n\n  assert(os::Aix::on_aix(), \"AIX only\");\n\n  if (!libperfstat::init()) {\n    trc(\"libperfstat initialization failed.\");\n    assert(false, \"libperfstat initialization failed\");\n  } else {\n    if (Verbose) {\n      fprintf(stderr, \"libperfstat initialized.\\n\");\n    }\n  }\n} // end: os::Aix::initialize_libperfstat\n\n/////////////////////////////////////////////////////////////////////////////\n// thread stack\n\n// function to query the current stack size using pthread_getthrds_np\n//\n// ! do not change anything here unless you know what you are doing !\nstatic void query_stack_dimensions(address* p_stack_base, size_t* p_stack_size) {\n\n  // This only works when invoked on a pthread. As we agreed not to use\n  // primordial threads anyway, I assert here\n  guarantee(!os::Aix::is_primordial_thread(), \"not allowed on the primordial thread\");\n\n  // information about this api can be found (a) in the pthread.h header and\n  // (b) in http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/pthread_getthrds_np.htm\n  //\n  // The use of this API to find out the current stack is kind of undefined.\n  // But after a lot of tries and asking IBM about it, I concluded that it is safe\n  // enough for cases where I let the pthread library create its stacks. For cases\n  // where I create an own stack and pass this to pthread_create, it seems not to\n  // work (the returned stack size in that case is 0).\n\n  pthread_t tid = pthread_self();\n  struct __pthrdsinfo pinfo;\n  char dummy[1]; // we only need this to satisfy the api and to not get E\n  int dummy_size = sizeof(dummy);\n\n  memset(&pinfo, 0, sizeof(pinfo));\n\n  const int rc = pthread_getthrds_np (&tid, PTHRDSINFO_QUERY_ALL, &pinfo,\n                                      sizeof(pinfo), dummy, &dummy_size);\n\n  if (rc != 0) {\n    fprintf(stderr, \"pthread_getthrds_np failed (%d)\\n\", rc);\n    guarantee(0, \"pthread_getthrds_np failed\");\n  }\n\n  guarantee(pinfo.__pi_stackend, \"returned stack base invalid\");\n\n  // the following can happen when invoking pthread_getthrds_np on a pthread running on a user provided stack\n  // (when handing down a stack to pthread create, see pthread_attr_setstackaddr).\n  // Not sure what to do here - I feel inclined to forbid this use case completely.\n  guarantee(pinfo.__pi_stacksize, \"returned stack size invalid\");\n\n  // On AIX, stacks are not necessarily page aligned so round the base and size accordingly\n  if (p_stack_base) {\n    (*p_stack_base) = (address) align_size_up((intptr_t)pinfo.__pi_stackend, os::Aix::stack_page_size());\n  }\n\n  if (p_stack_size) {\n    (*p_stack_size) = pinfo.__pi_stacksize - os::Aix::stack_page_size();\n  }\n\n#ifndef PRODUCT\n  if (Verbose) {\n    fprintf(stderr,\n            \"query_stack_dimensions() -> real stack_base=\" INTPTR_FORMAT \", real stack_addr=\" INTPTR_FORMAT\n            \", real stack_size=\" INTPTR_FORMAT\n            \", stack_base=\" INTPTR_FORMAT \", stack_size=\" INTPTR_FORMAT \"\\n\",\n            (intptr_t)pinfo.__pi_stackend, (intptr_t)pinfo.__pi_stackaddr, pinfo.__pi_stacksize,\n            (intptr_t)align_size_up((intptr_t)pinfo.__pi_stackend, os::Aix::stack_page_size()),\n            pinfo.__pi_stacksize - os::Aix::stack_page_size());\n  }\n#endif\n\n} // end query_stack_dimensions\n\n// get the current stack base from the OS (actually, the pthread library)\naddress os::current_stack_base() {\n  address p;\n  query_stack_dimensions(&p, 0);\n  return p;\n}\n\n// get the current stack size from the OS (actually, the pthread library)\nsize_t os::current_stack_size() {\n  size_t s;\n  query_stack_dimensions(0, &s);\n  return s;\n}\n\n// Refer to the comments in os_solaris.cpp park-unpark.\n//\n// Beware -- Some versions of NPTL embody a flaw where pthread_cond_timedwait() can\n// hang indefinitely. For instance NPTL 0.60 on 2.4.21-4ELsmp is vulnerable.\n// For specifics regarding the bug see GLIBC BUGID 261237 :\n//    http://www.mail-archive.com/debian-glibc@lists.debian.org/msg10837.html.\n// Briefly, pthread_cond_timedwait() calls with an expiry time that's not in the future\n// will either hang or corrupt the condvar, resulting in subsequent hangs if the condvar\n// is used. (The simple C test-case provided in the GLIBC bug report manifests the\n// hang). The JVM is vulernable via sleep(), Object.wait(timo), LockSupport.parkNanos()\n// and monitorenter when we're using 1-0 locking. All those operations may result in\n// calls to pthread_cond_timedwait(). Using LD_ASSUME_KERNEL to use an older version\n// of libpthread avoids the problem, but isn't practical.\n//\n// Possible remedies:\n//\n// 1.   Establish a minimum relative wait time. 50 to 100 msecs seems to work.\n//      This is palliative and probabilistic, however. If the thread is preempted\n//      between the call to compute_abstime() and pthread_cond_timedwait(), more\n//      than the minimum period may have passed, and the abstime may be stale (in the\n//      past) resultin in a hang. Using this technique reduces the odds of a hang\n//      but the JVM is still vulnerable, particularly on heavily loaded systems.\n//\n// 2.   Modify park-unpark to use per-thread (per ParkEvent) pipe-pairs instead\n//      of the usual flag-condvar-mutex idiom. The write side of the pipe is set\n//      NDELAY. unpark() reduces to write(), park() reduces to read() and park(timo)\n//      reduces to poll()+read(). This works well, but consumes 2 FDs per extant\n//      thread.\n//\n// 3.   Embargo pthread_cond_timedwait() and implement a native \"chron\" thread\n//      that manages timeouts. We'd emulate pthread_cond_timedwait() by enqueuing\n//      a timeout request to the chron thread and then blocking via pthread_cond_wait().\n//      This also works well. In fact it avoids kernel-level scalability impediments\n//      on certain platforms that don't handle lots of active pthread_cond_timedwait()\n//      timers in a graceful fashion.\n//\n// 4.   When the abstime value is in the past it appears that control returns\n//      correctly from pthread_cond_timedwait(), but the condvar is left corrupt.\n//      Subsequent timedwait/wait calls may hang indefinitely. Given that, we\n//      can avoid the problem by reinitializing the condvar -- by cond_destroy()\n//      followed by cond_init() -- after all calls to pthread_cond_timedwait().\n//      It may be possible to avoid reinitialization by checking the return\n//      value from pthread_cond_timedwait(). In addition to reinitializing the\n//      condvar we must establish the invariant that cond_signal() is only called\n//      within critical sections protected by the adjunct mutex. This prevents\n//      cond_signal() from \"seeing\" a condvar that's in the midst of being\n//      reinitialized or that is corrupt. Sadly, this invariant obviates the\n//      desirable signal-after-unlock optimization that avoids futile context switching.\n//\n//      I'm also concerned that some versions of NTPL might allocate an auxilliary\n//      structure when a condvar is used or initialized. cond_destroy() would\n//      release the helper structure. Our reinitialize-after-timedwait fix\n//      put excessive stress on malloc/free and locks protecting the c-heap.\n//\n// We currently use (4). See the WorkAroundNTPLTimedWaitHang flag.\n// It may be possible to refine (4) by checking the kernel and NTPL verisons\n// and only enabling the work-around for vulnerable environments.\n\n// utility to compute the abstime argument to timedwait:\n// millis is the relative timeout time\n// abstime will be the absolute timeout time\n// TODO: replace compute_abstime() with unpackTime()\n\nstatic struct timespec* compute_abstime(timespec* abstime, jlong millis) {\n  if (millis < 0) millis = 0;\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n  jlong seconds = millis / 1000;\n  millis %= 1000;\n  if (seconds > 50000000) { // see man cond_timedwait(3T)\n    seconds = 50000000;\n  }\n  abstime->tv_sec = now.tv_sec  + seconds;\n  long       usec = now.tv_usec + millis * 1000;\n  if (usec >= 1000000) {\n    abstime->tv_sec += 1;\n    usec -= 1000000;\n  }\n  abstime->tv_nsec = usec * 1000;\n  return abstime;\n}\n\n// Test-and-clear _Event, always leaves _Event set to 0, returns immediately.\n// Conceptually TryPark() should be equivalent to park(0).\n\nint os::PlatformEvent::TryPark() {\n  for (;;) {\n    const int v = _Event;\n    guarantee ((v == 0) || (v == 1), \"invariant\");\n    if (Atomic::cmpxchg (0, &_Event, v) == v) return v;\n  }\n}\n\nvoid os::PlatformEvent::park() {       // AKA \"down()\"\n  // Invariant: Only the thread associated with the Event/PlatformEvent\n  // may call park().\n  // TODO: assert that _Assoc != NULL or _Assoc == Self\n  int v;\n  for (;;) {\n    v = _Event;\n    if (Atomic::cmpxchg (v-1, &_Event, v) == v) break;\n  }\n  guarantee (v >= 0, \"invariant\");\n  if (v == 0) {\n    // Do this the hard way by blocking ...\n    int status = pthread_mutex_lock(_mutex);\n    assert_status(status == 0, status, \"mutex_lock\");\n    guarantee (_nParked == 0, \"invariant\");\n    ++ _nParked;\n    while (_Event < 0) {\n      status = pthread_cond_wait(_cond, _mutex);\n      assert_status(status == 0 || status == ETIMEDOUT, status, \"cond_timedwait\");\n    }\n    -- _nParked;\n\n    // In theory we could move the ST of 0 into _Event past the unlock(),\n    // but then we'd need a MEMBAR after the ST.\n    _Event = 0;\n    status = pthread_mutex_unlock(_mutex);\n    assert_status(status == 0, status, \"mutex_unlock\");\n  }\n  guarantee (_Event >= 0, \"invariant\");\n}\n\nint os::PlatformEvent::park(jlong millis) {\n  guarantee (_nParked == 0, \"invariant\");\n\n  int v;\n  for (;;) {\n    v = _Event;\n    if (Atomic::cmpxchg (v-1, &_Event, v) == v) break;\n  }\n  guarantee (v >= 0, \"invariant\");\n  if (v != 0) return OS_OK;\n\n  // We do this the hard way, by blocking the thread.\n  // Consider enforcing a minimum timeout value.\n  struct timespec abst;\n  compute_abstime(&abst, millis);\n\n  int ret = OS_TIMEOUT;\n  int status = pthread_mutex_lock(_mutex);\n  assert_status(status == 0, status, \"mutex_lock\");\n  guarantee (_nParked == 0, \"invariant\");\n  ++_nParked;\n\n  // Object.wait(timo) will return because of\n  // (a) notification\n  // (b) timeout\n  // (c) thread.interrupt\n  //\n  // Thread.interrupt and object.notify{All} both call Event::set.\n  // That is, we treat thread.interrupt as a special case of notification.\n  // The underlying Solaris implementation, cond_timedwait, admits\n  // spurious/premature wakeups, but the JLS/JVM spec prevents the\n  // JVM from making those visible to Java code. As such, we must\n  // filter out spurious wakeups. We assume all ETIME returns are valid.\n  //\n  // TODO: properly differentiate simultaneous notify+interrupt.\n  // In that case, we should propagate the notify to another waiter.\n\n  while (_Event < 0) {\n    status = pthread_cond_timedwait(_cond, _mutex, &abst);\n    assert_status(status == 0 || status == ETIMEDOUT,\n                  status, \"cond_timedwait\");\n    if (!FilterSpuriousWakeups) break;         // previous semantics\n    if (status == ETIMEDOUT) break;\n    // We consume and ignore EINTR and spurious wakeups.\n  }\n  --_nParked;\n  if (_Event >= 0) {\n     ret = OS_OK;\n  }\n  _Event = 0;\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"mutex_unlock\");\n  assert (_nParked == 0, \"invariant\");\n  return ret;\n}\n\nvoid os::PlatformEvent::unpark() {\n  int v, AnyWaiters;\n  for (;;) {\n    v = _Event;\n    if (v > 0) {\n      // The LD of _Event could have reordered or be satisfied\n      // by a read-aside from this processor's write buffer.\n      // To avoid problems execute a barrier and then\n      // ratify the value.\n      OrderAccess::fence();\n      if (_Event == v) return;\n      continue;\n    }\n    if (Atomic::cmpxchg (v+1, &_Event, v) == v) break;\n  }\n  if (v < 0) {\n    // Wait for the thread associated with the event to vacate\n    int status = pthread_mutex_lock(_mutex);\n    assert_status(status == 0, status, \"mutex_lock\");\n    AnyWaiters = _nParked;\n\n    if (AnyWaiters != 0) {\n      // We intentional signal *after* dropping the lock\n      // to avoid a common class of futile wakeups.\n      status = pthread_cond_signal(_cond);\n      assert_status(status == 0, status, \"cond_signal\");\n    }\n    // Mutex should be locked for pthread_cond_signal(_cond).\n    status = pthread_mutex_unlock(_mutex);\n    assert_status(status == 0, status, \"mutex_unlock\");\n  }\n\n  // Note that we signal() _after dropping the lock for \"immortal\" Events.\n  // This is safe and avoids a common class of futile wakeups. In rare\n  // circumstances this can cause a thread to return prematurely from\n  // cond_{timed}wait() but the spurious wakeup is benign and the victim will\n  // simply re-test the condition and re-park itself.\n}\n\n\n// JSR166\n// -------------------------------------------------------\n\n//\n// The solaris and linux implementations of park/unpark are fairly\n// conservative for now, but can be improved. They currently use a\n// mutex/condvar pair, plus a a count.\n// Park decrements count if > 0, else does a condvar wait. Unpark\n// sets count to 1 and signals condvar. Only one thread ever waits\n// on the condvar. Contention seen when trying to park implies that someone\n// is unparking you, so don't wait. And spurious returns are fine, so there\n// is no need to track notifications.\n//\n\n#define MAX_SECS 100000000\n//\n// This code is common to linux and solaris and will be moved to a\n// common place in dolphin.\n//\n// The passed in time value is either a relative time in nanoseconds\n// or an absolute time in milliseconds. Either way it has to be unpacked\n// into suitable seconds and nanoseconds components and stored in the\n// given timespec structure.\n// Given time is a 64-bit value and the time_t used in the timespec is only\n// a signed-32-bit value (except on 64-bit Linux) we have to watch for\n// overflow if times way in the future are given. Further on Solaris versions\n// prior to 10 there is a restriction (see cond_timedwait) that the specified\n// number of seconds, in abstime, is less than current_time + 100,000,000.\n// As it will be 28 years before \"now + 100000000\" will overflow we can\n// ignore overflow and just impose a hard-limit on seconds using the value\n// of \"now + 100,000,000\". This places a limit on the timeout of about 3.17\n// years from \"now\".\n//\n\nstatic void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {\n  assert (time > 0, \"convertTime\");\n\n  struct timeval now;\n  int status = gettimeofday(&now, NULL);\n  assert(status == 0, \"gettimeofday\");\n\n  time_t max_secs = now.tv_sec + MAX_SECS;\n\n  if (isAbsolute) {\n    jlong secs = time / 1000;\n    if (secs > max_secs) {\n      absTime->tv_sec = max_secs;\n    }\n    else {\n      absTime->tv_sec = secs;\n    }\n    absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;\n  }\n  else {\n    jlong secs = time / NANOSECS_PER_SEC;\n    if (secs >= MAX_SECS) {\n      absTime->tv_sec = max_secs;\n      absTime->tv_nsec = 0;\n    }\n    else {\n      absTime->tv_sec = now.tv_sec + secs;\n      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;\n      if (absTime->tv_nsec >= NANOSECS_PER_SEC) {\n        absTime->tv_nsec -= NANOSECS_PER_SEC;\n        ++absTime->tv_sec; // note: this must be <= max_secs\n      }\n    }\n  }\n  assert(absTime->tv_sec >= 0, \"tv_sec < 0\");\n  assert(absTime->tv_sec <= max_secs, \"tv_sec > max_secs\");\n  assert(absTime->tv_nsec >= 0, \"tv_nsec < 0\");\n  assert(absTime->tv_nsec < NANOSECS_PER_SEC, \"tv_nsec >= nanos_per_sec\");\n}\n\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  if (_counter > 0) {\n    _counter = 0;\n    OrderAccess::fence();\n    return;\n  }\n\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");\n  JavaThread *jt = (JavaThread *)thread;\n\n  // Optional optimization -- avoid state transitions if there's an interrupt pending.\n  // Check interrupt before trying to wait\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n\n  // Next, demultiplex/decode time arguments\n  timespec absTime;\n  if (time < 0 || (isAbsolute && time == 0)) { // don't wait at all\n    return;\n  }\n  if (time > 0) {\n    unpackTime(&absTime, isAbsolute, time);\n  }\n\n  // Enter safepoint region\n  // Beware of deadlocks such as 6317397.\n  // The per-thread Parker:: mutex is a classic leaf-lock.\n  // In particular a thread must never block on the Threads_lock while\n  // holding the Parker:: mutex. If safepoints are pending both the\n  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.\n  ThreadBlockInVM tbivm(jt);\n\n  // Don't wait if cannot get lock since interference arises from\n  // unblocking. Also. check interrupt before trying wait\n  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {\n    return;\n  }\n\n  int status;\n  if (_counter > 0) { // no wait needed\n    _counter = 0;\n    status = pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\");\n    OrderAccess::fence();\n    return;\n  }\n\n#ifdef ASSERT\n  // Don't catch signals while blocked; let the running threads have the signals.\n  // (This allows a debugger to break into the running thread.)\n  sigset_t oldsigs;\n  sigset_t* allowdebug_blocked = os::Aix::allowdebug_blocked_signals();\n  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);\n#endif\n\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n  if (time == 0) {\n    status = pthread_cond_wait (_cond, _mutex);\n  } else {\n    status = pthread_cond_timedwait (_cond, _mutex, &absTime);\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (_cond);\n      pthread_cond_init    (_cond, NULL);\n    }\n  }\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIME || status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n\n  _counter = 0;\n  status = pthread_mutex_unlock(_mutex);\n  assert_status(status == 0, status, \"invariant\");\n  // If externally suspended while waiting, re-suspend\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n\n  OrderAccess::fence();\n}\n\nvoid Parker::unpark() {\n  int s, status;\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\");\n  s = _counter;\n  _counter = 1;\n  if (s < 1) {\n    if (WorkAroundNPTLTimedWaitHang) {\n      status = pthread_cond_signal (_cond);\n      assert (status == 0, \"invariant\");\n      status = pthread_mutex_unlock(_mutex);\n      assert (status == 0, \"invariant\");\n    } else {\n      status = pthread_mutex_unlock(_mutex);\n      assert (status == 0, \"invariant\");\n      status = pthread_cond_signal (_cond);\n      assert (status == 0, \"invariant\");\n    }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\");\n  }\n}\n\nextern char** environ;\n\n// Run the specified command in a separate process. Return its exit value,\n// or -1 on failure (e.g. can't fork a new process).\n// Unlike system(), this function can be called from signal handler. It\n// doesn't block SIGINT et al.\nint os::fork_and_exec(char* cmd) {\n  char * argv[4] = {\"sh\", \"-c\", cmd, NULL};\n\n  pid_t pid = fork();\n\n  if (pid < 0) {\n    // fork failed\n    return -1;\n\n  } else if (pid == 0) {\n    // child process\n\n    // Try to be consistent with system(), which uses \"/usr/bin/sh\" on AIX.\n    execve(\"/usr/bin/sh\", argv, environ);\n\n    // execve failed\n    _exit(-1);\n\n  } else {\n    // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n    // care about the actual exit code, for now.\n\n    int status;\n\n    // Wait for the child process to exit. This returns immediately if\n    // the child has already exited. */\n    while (waitpid(pid, &status, 0) < 0) {\n      switch (errno) {\n        case ECHILD: return 0;\n        case EINTR: break;\n        default: return -1;\n      }\n    }\n\n    if (WIFEXITED(status)) {\n      // The child exited normally; get its exit code.\n      return WEXITSTATUS(status);\n    } else if (WIFSIGNALED(status)) {\n      // The child exited because of a signal.\n      // The best value to return is 0x80 + signal number,\n      // because that is what all Unix shells do, and because\n      // it allows callers to distinguish between process exit and\n      // process death by signal.\n      return 0x80 + WTERMSIG(status);\n    } else {\n      // Unknown exit code; pass it through.\n      return status;\n    }\n  }\n  return -1;\n}\n\n// is_headless_jre()\n//\n// Test for the existence of xawt/libmawt.so or libawt_xawt.so\n// in order to report if we are running in a headless jre.\n//\n// Since JDK8 xawt/libmawt.so is moved into the same directory\n// as libawt.so, and renamed libawt_xawt.so\nbool os::is_headless_jre() {\n  struct stat statbuf;\n  char buf[MAXPATHLEN];\n  char libmawtpath[MAXPATHLEN];\n  const char *xawtstr = \"/xawt/libmawt.so\";\n  const char *new_xawtstr = \"/libawt_xawt.so\";\n\n  char *p;\n\n  // Get path to libjvm.so\n  os::jvm_path(buf, sizeof(buf));\n\n  // Get rid of libjvm.so\n  p = strrchr(buf, '/');\n  if (p == NULL) return false;\n  else *p = '\\0';\n\n  // Get rid of client or server\n  p = strrchr(buf, '/');\n  if (p == NULL) return false;\n  else *p = '\\0';\n\n  // check xawt/libmawt.so\n  strcpy(libmawtpath, buf);\n  strcat(libmawtpath, xawtstr);\n  if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n  // check libawt_xawt.so\n  strcpy(libmawtpath, buf);\n  strcat(libmawtpath, new_xawtstr);\n  if (::stat(libmawtpath, &statbuf) == 0) return false;\n\n  return true;\n}\n\n// Get the default path to the core file\n// Returns the length of the string\nint os::get_core_path(char* buffer, size_t bufferSize) {\n  const char* p = get_current_directory(buffer, bufferSize);\n\n  if (p == NULL) {\n    assert(p != NULL, \"failed to get current directory\");\n    return 0;\n  }\n\n  return strlen(buffer);\n}\n\n#ifndef PRODUCT\nvoid TestReserveMemorySpecial_test() {\n  // No tests available for this platform\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os/aix/vm/jsig.c": "/*\n * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.\n * Copyright 2012, 2013 SAP AG. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n/* CopyrightVersion 1.2 */\n\n/* This is a special library that should be loaded before libc &\n * libthread to interpose the signal handler installation functions:\n * sigaction(), signal(), sigset().\n * Used for signal-chaining. See RFE 4381843.\n */\n\n#include <signal.h>\n#include <dlfcn.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define bool int\n#define true 1\n#define false 0\n\n// Highest so far on AIX 5.2 is SIGSAK (63)\n#define MAXSIGNUM 63\n#define MASK(sig) ((unsigned int)1 << sig)\n\nstatic struct sigaction sact[MAXSIGNUM]; /* saved signal handlers */\nstatic unsigned int jvmsigs = 0; /* signals used by jvm */\n\n/* used to synchronize the installation of signal handlers */\nstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t tid = 0;\n\ntypedef void (*sa_handler_t)(int);\ntypedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n// signal_t is already defined on AIX\ntypedef sa_handler_t (*signal_like_function_t)(int, sa_handler_t);\ntypedef int (*sigaction_t)(int, const struct sigaction *, struct sigaction *);\n\nstatic signal_like_function_t os_signal = 0; /* os's version of signal()/sigset() */\nstatic sigaction_t os_sigaction = 0; /* os's version of sigaction() */\n\nstatic bool jvm_signal_installing = false;\nstatic bool jvm_signal_installed = false;\n\nstatic void signal_lock() {\n  pthread_mutex_lock(&mutex);\n  /* When the jvm is installing its set of signal handlers, threads\n   * other than the jvm thread should wait */\n  if (jvm_signal_installing) {\n    if (tid != pthread_self()) {\n      pthread_cond_wait(&cond, &mutex);\n    }\n  }\n}\n\nstatic void signal_unlock() {\n  pthread_mutex_unlock(&mutex);\n}\n\nstatic sa_handler_t call_os_signal(int sig, sa_handler_t disp,\n                                   bool is_sigset) {\n  if (os_signal == NULL) {\n    if (!is_sigset) {\n      // Aix: call functions directly instead of dlsym'ing them\n      os_signal = signal;\n    } else {\n      // Aix: call functions directly instead of dlsym'ing them\n      os_signal = sigset;\n    }\n    if (os_signal == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_signal)(sig, disp);\n}\n\nstatic void save_signal_handler(int sig, sa_handler_t disp) {\n  sigset_t set;\n  sact[sig].sa_handler = disp;\n  sigemptyset(&set);\n  sact[sig].sa_mask = set;\n  sact[sig].sa_flags = 0;\n}\n\nstatic sa_handler_t set_signal(int sig, sa_handler_t disp, bool is_sigset) {\n  sa_handler_t oldhandler;\n  bool sigused;\n\n  signal_lock();\n\n  sigused = (MASK(sig) & jvmsigs) != 0;\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    oldhandler = sact[sig].sa_handler;\n    save_signal_handler(sig, disp);\n\n    signal_unlock();\n    return oldhandler;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. jvm uses sigaction().\n     * Leave the piece here just in case. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n    save_signal_handler(sig, oldhandler);\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return oldhandler;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    oldhandler = call_os_signal(sig, disp, is_sigset);\n\n    signal_unlock();\n    return oldhandler;\n  }\n}\n\nsa_handler_t signal(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, false);\n}\n\nsa_handler_t sigset(int sig, sa_handler_t disp) {\n  return set_signal(sig, disp, true);\n }\n\nstatic int call_os_sigaction(int sig, const struct sigaction  *act,\n                             struct sigaction *oact) {\n  if (os_sigaction == NULL) {\n    // Aix: call functions directly instead of dlsym'ing them\n    os_sigaction = sigaction;\n    if (os_sigaction == NULL) {\n      printf(\"%s\\n\", dlerror());\n      exit(0);\n    }\n  }\n  return (*os_sigaction)(sig, act, oact);\n}\n\nint sigaction(int sig, const struct sigaction *act, struct sigaction *oact) {\n  int res;\n  bool sigused;\n  struct sigaction oldAct;\n\n  signal_lock();\n\n  sigused = (MASK(sig) & jvmsigs) != 0;\n  if (jvm_signal_installed && sigused) {\n    /* jvm has installed its signal handler for this signal. */\n    /* Save the handler. Don't really install it. */\n    if (oact != NULL) {\n      *oact = sact[sig];\n    }\n    if (act != NULL) {\n      sact[sig] = *act;\n    }\n\n    signal_unlock();\n    return 0;\n  } else if (jvm_signal_installing) {\n    /* jvm is installing its signal handlers. Install the new\n     * handlers and save the old ones. */\n    res = call_os_sigaction(sig, act, &oldAct);\n    sact[sig] = oldAct;\n    if (oact != NULL) {\n      *oact = oldAct;\n    }\n\n    /* Record the signals used by jvm */\n    jvmsigs |= MASK(sig);\n\n    signal_unlock();\n    return res;\n  } else {\n    /* jvm has no relation with this signal (yet). Install the\n     * the handler. */\n    res = call_os_sigaction(sig, act, oact);\n\n    signal_unlock();\n    return res;\n  }\n}\n\n/* The three functions for the jvm to call into */\nvoid JVM_begin_signal_setting() {\n  signal_lock();\n  jvm_signal_installing = true;\n  tid = pthread_self();\n  signal_unlock();\n}\n\nvoid JVM_end_signal_setting() {\n  signal_lock();\n  jvm_signal_installed = true;\n  jvm_signal_installing = false;\n  pthread_cond_broadcast(&cond);\n  signal_unlock();\n}\n\nstruct sigaction *JVM_get_signal_action(int sig) {\n  /* Does race condition make sense here? */\n  if ((MASK(sig) & jvmsigs) != 0) {\n    return &sact[sig];\n  }\n  return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/os/aix/vm/libperfstat_aix.cpp": "/*\n * Copyright 2012, 2013 SAP AG. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include \"runtime/arguments.hpp\"\n#include \"libperfstat_aix.hpp\"\n\n// For dlopen and friends\n#include <fcntl.h>\n\n// handle to the libperfstat\nstatic void* g_libhandle = NULL;\n\n// whether initialization worked\nstatic bool g_initialized = false;\n\n\ntypedef int (*fun_perfstat_cpu_total_t) (perfstat_id_t *name, perfstat_cpu_total_t* userbuff,\n                                         int sizeof_userbuff, int desired_number);\n\ntypedef int (*fun_perfstat_memory_total_t) (perfstat_id_t *name, perfstat_memory_total_t* userbuff,\n                                            int sizeof_userbuff, int desired_number);\n\ntypedef void (*fun_perfstat_reset_t) ();\n\nstatic fun_perfstat_cpu_total_t     g_fun_perfstat_cpu_total = NULL;\nstatic fun_perfstat_memory_total_t  g_fun_perfstat_memory_total = NULL;\nstatic fun_perfstat_reset_t         g_fun_perfstat_reset = NULL;\n\nbool libperfstat::init() {\n\n  if (g_initialized) {\n    return true;\n  }\n\n  g_initialized = false;\n\n  // dynamically load the libperfstat porting library.\n  g_libhandle = dlopen(\"/usr/lib/libperfstat.a(shr_64.o)\", RTLD_MEMBER | RTLD_NOW);\n  if (!g_libhandle) {\n    if (Verbose) {\n      fprintf(stderr, \"Cannot load libperfstat.a (dlerror: %s)\", dlerror());\n    }\n    return false;\n  }\n\n  // resolve function pointers\n\n#define RESOLVE_FUN_NO_ERROR(name) \\\n  g_fun_##name = (fun_##name##_t) dlsym(g_libhandle, #name);\n\n#define RESOLVE_FUN(name) \\\n  RESOLVE_FUN_NO_ERROR(name) \\\n  if (!g_fun_##name) { \\\n    if (Verbose) { \\\n      fprintf(stderr, \"Cannot resolve \" #name \"() from libperfstat.a\\n\" \\\n                      \"   (dlerror: %s)\", dlerror()); \\\n      } \\\n    return false; \\\n  }\n\n  RESOLVE_FUN(perfstat_cpu_total);\n  RESOLVE_FUN(perfstat_memory_total);\n  RESOLVE_FUN(perfstat_reset);\n\n  g_initialized = true;\n\n  return true;\n}\n\nvoid libperfstat::cleanup() {\n\n  g_initialized = false;\n\n  if (g_libhandle) {\n    dlclose(g_libhandle);\n    g_libhandle = NULL;\n  }\n\n  g_fun_perfstat_cpu_total = NULL;\n  g_fun_perfstat_memory_total = NULL;\n  g_fun_perfstat_reset = NULL;\n}\n\nint libperfstat::perfstat_memory_total(perfstat_id_t *name,\n                                       perfstat_memory_total_t* userbuff,\n                                       int sizeof_userbuff, int desired_number) {\n  assert(g_initialized, \"libperfstat not initialized\");\n  assert(g_fun_perfstat_memory_total, \"\");\n  return g_fun_perfstat_memory_total(name, userbuff, sizeof_userbuff, desired_number);\n}\n\nint libperfstat::perfstat_cpu_total(perfstat_id_t *name, perfstat_cpu_total_t* userbuff,\n                                    int sizeof_userbuff, int desired_number) {\n  assert(g_initialized, \"libperfstat not initialized\");\n  assert(g_fun_perfstat_cpu_total, \"\");\n  return g_fun_perfstat_cpu_total(name, userbuff, sizeof_userbuff, desired_number);\n}\n\nvoid libperfstat::perfstat_reset() {\n  assert(g_initialized, \"libperfstat not initialized\");\n  assert(g_fun_perfstat_reset, \"\");\n  g_fun_perfstat_reset();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/native/sadis.c": "/*\n * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include \"sun_jvm_hotspot_asm_Disassembler.h\"\n\n/*\n *  This file implements a binding between Java and the hsdis\n *  dissasembler.  It should compile on Linux/Solaris and Windows.\n *  The only platform dependent pieces of the code for doing\n *  dlopen/dlsym to find the entry point in hsdis.  All the rest is\n *  standard JNI code.\n */\n\n#ifdef _WINDOWS\n\n#define snprintf  _snprintf\n#define vsnprintf _vsnprintf\n\n#include <windows.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#ifdef _DEBUG\n#include <crtdbg.h>\n#endif\n\n#else\n\n#include <string.h>\n#include <dlfcn.h>\n\n#ifndef __APPLE__\n#include <link.h>\n#endif\n\n#endif\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#ifdef _WINDOWS\nstatic int getLastErrorString(char *buf, size_t len)\n{\n    long errval;\n\n    if ((errval = GetLastError()) != 0)\n    {\n      /* DOS error */\n      size_t n = (size_t)FormatMessage(\n            FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,\n            NULL,\n            errval,\n            0,\n            buf,\n            (DWORD)len,\n            NULL);\n      if (n > 3) {\n        /* Drop final '.', CR, LF */\n        if (buf[n - 1] == '\\n') n--;\n        if (buf[n - 1] == '\\r') n--;\n        if (buf[n - 1] == '.') n--;\n        buf[n] = '\\0';\n      }\n      return (int)n;\n    }\n\n    if (errno != 0)\n    {\n      /* C runtime error that has no corresponding DOS error code */\n      const char *s = strerror(errno);\n      size_t n = strlen(s);\n      if (n >= len) n = len - 1;\n      strncpy(buf, s, n);\n      buf[n] = '\\0';\n      return (int)n;\n    }\n    return 0;\n}\n#endif /* _WINDOWS */\n\n/*\n * Class:     sun_jvm_hotspot_asm_Disassembler\n * Method:    load_library\n * Signature: (Ljava/lang/String;)L\n */\nJNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_asm_Disassembler_load_1library(JNIEnv * env,\n                                                                           jclass disclass,\n                                                                           jstring jrepath_s,\n                                                                           jstring libname_s) {\n  uintptr_t func = 0;\n  const char* error_message = NULL;\n  jboolean isCopy;\n\n  const char * jrepath = (*env)->GetStringUTFChars(env, jrepath_s, &isCopy); // like $JAVA_HOME/jre/lib/sparc/\n  const char * libname = (*env)->GetStringUTFChars(env, libname_s, &isCopy);\n  char buffer[128];\n\n  /* Load the hsdis library */\n#ifdef _WINDOWS\n  HINSTANCE hsdis_handle;\n  hsdis_handle = LoadLibrary(libname);\n  if (hsdis_handle == NULL) {\n    snprintf(buffer, sizeof(buffer), \"%s%s\", jrepath, libname);\n    hsdis_handle = LoadLibrary(buffer);\n  }\n  if (hsdis_handle != NULL) {\n    func = (uintptr_t)GetProcAddress(hsdis_handle, \"decode_instructions_virtual\");\n  }\n  if (func == 0) {\n    getLastErrorString(buffer, sizeof(buffer));\n    error_message = buffer;\n  }\n#else\n  void* hsdis_handle;\n  hsdis_handle = dlopen(libname, RTLD_LAZY | RTLD_GLOBAL);\n  if (hsdis_handle == NULL) {\n    snprintf(buffer, sizeof(buffer), \"%s%s\", jrepath, libname);\n    hsdis_handle = dlopen(buffer, RTLD_LAZY | RTLD_GLOBAL);\n  }\n  if (hsdis_handle != NULL) {\n    func = (uintptr_t)dlsym(hsdis_handle, \"decode_instructions_virtual\");\n  }\n  if (func == 0) {\n    error_message = dlerror();\n  }\n#endif\n\n  (*env)->ReleaseStringUTFChars(env, libname_s, libname);\n  (*env)->ReleaseStringUTFChars(env, jrepath_s, jrepath);\n\n  if (func == 0) {\n    /* Couldn't find entry point.  error_message should contain some\n     * platform dependent error message.\n     */\n    jclass eclass = (*env)->FindClass(env, \"sun/jvm/hotspot/debugger/DebuggerException\");\n    (*env)->ThrowNew(env, eclass, error_message);\n  }\n  return (jlong)func;\n}\n\n/* signature of decode_instructions_virtual from hsdis.h */\ntypedef void* (*decode_func)(uintptr_t start_va, uintptr_t end_va,\n                             unsigned char* start, uintptr_t length,\n                             void* (*event_callback)(void*, const char*, void*),\n                             void* event_stream,\n                             int (*printf_callback)(void*, const char*, ...),\n                             void* printf_stream,\n                             const char* options,\n                             int newline);\n\n/* container for call back state when decoding instructions */\ntypedef struct {\n  JNIEnv* env;\n  jobject dis;\n  jobject visitor;\n  jmethodID handle_event;\n  jmethodID raw_print;\n  char buffer[4096];\n} decode_env;\n\n\n/* event callback binding to Disassembler.handleEvent */\nstatic void* event_to_env(void* env_pv, const char* event, void* arg) {\n  decode_env* denv = (decode_env*)env_pv;\n  JNIEnv* env = denv->env;\n  jstring event_string = (*env)->NewStringUTF(env, event);\n  jlong result = (*env)->CallLongMethod(env, denv->dis, denv->handle_event, denv->visitor,\n                                        event_string, (jlong) (uintptr_t)arg);\n  if ((*env)->ExceptionOccurred(env) != NULL) {\n    /* ignore exceptions for now */\n    (*env)->ExceptionClear(env);\n    result = 0;\n  }\n  return (void*)(uintptr_t)result;\n}\n\n/* printing callback binding to Disassembler.rawPrint */\nstatic int printf_to_env(void* env_pv, const char* format, ...) {\n  jstring output;\n  va_list ap;\n  int cnt;\n  decode_env* denv = (decode_env*)env_pv;\n  JNIEnv* env = denv->env;\n  size_t flen = strlen(format);\n  const char* raw = NULL;\n\n  if (flen == 0)  return 0;\n  if (flen < 2 ||\n      strchr(format, '%') == NULL) {\n    raw = format;\n  } else if (format[0] == '%' && format[1] == '%' &&\n             strchr(format+2, '%') == NULL) {\n    // happens a lot on machines with names like %foo\n    flen--;\n    raw = format+1;\n  }\n  if (raw != NULL) {\n    jstring output = (*env)->NewStringUTF(env, raw);\n    (*env)->CallVoidMethod(env, denv->dis, denv->raw_print, denv->visitor, output);\n    if ((*env)->ExceptionOccurred(env) != NULL) {\n      /* ignore exceptions for now */\n      (*env)->ExceptionClear(env);\n    }\n    return (int) flen;\n  }\n  va_start(ap, format);\n  cnt = vsnprintf(denv->buffer, sizeof(denv->buffer), format, ap);\n  va_end(ap);\n\n  output = (*env)->NewStringUTF(env, denv->buffer);\n  (*env)->CallVoidMethod(env, denv->dis, denv->raw_print, denv->visitor, output);\n  if ((*env)->ExceptionOccurred(env) != NULL) {\n    /* ignore exceptions for now */\n    (*env)->ExceptionClear(env);\n  }\n  return cnt;\n}\n\n/*\n * Class:     sun_jvm_hotspot_asm_Disassembler\n * Method:    decode\n * Signature: (Lsun/jvm/hotspot/asm/InstructionVisitor;J[BLjava/lang/String;J)V\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_asm_Disassembler_decode(JNIEnv * env,\n                                                                    jobject dis,\n                                                                    jobject visitor,\n                                                                    jlong startPc,\n                                                                    jbyteArray code,\n                                                                    jstring options_s,\n                                                                    jlong decode_instructions_virtual) {\n  jboolean isCopy;\n  jbyte* start = (*env)->GetByteArrayElements(env, code, &isCopy);\n  jbyte* end = start + (*env)->GetArrayLength(env, code);\n  const char * options = (*env)->GetStringUTFChars(env, options_s, &isCopy);\n  jclass disclass = (*env)->GetObjectClass(env, dis);\n\n  decode_env denv;\n  denv.env = env;\n  denv.dis = dis;\n  denv.visitor = visitor;\n\n  /* find Disassembler.handleEvent callback */\n  denv.handle_event = (*env)->GetMethodID(env, disclass, \"handleEvent\",\n                                          \"(Lsun/jvm/hotspot/asm/InstructionVisitor;Ljava/lang/String;J)J\");\n  if ((*env)->ExceptionOccurred(env)) {\n    return;\n  }\n\n  /* find Disassembler.rawPrint callback */\n  denv.raw_print = (*env)->GetMethodID(env, disclass, \"rawPrint\",\n                                       \"(Lsun/jvm/hotspot/asm/InstructionVisitor;Ljava/lang/String;)V\");\n  if ((*env)->ExceptionOccurred(env)) {\n    return;\n  }\n\n  /* decode the buffer */\n  (*(decode_func)(uintptr_t)decode_instructions_virtual)(startPc,\n                                                         startPc + end - start,\n                                                         (unsigned char*)start,\n                                                         end - start,\n                                                         &event_to_env,  (void*) &denv,\n                                                         &printf_to_env, (void*) &denv,\n                                                         options, 0 /* newline */);\n\n  /* cleanup */\n  (*env)->ReleaseByteArrayElements(env, code, start, JNI_ABORT);\n  (*env)->ReleaseStringUTFChars(env, options_s, options);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/os/solaris/proc/saproc.cpp": "/*\n * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include \"salibproc.h\"\n#include \"sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal.h\"\n#ifndef SOLARIS_11_B159_OR_LATER\n#include <sys/utsname.h>\n#endif\n#include <thread_db.h>\n#include <strings.h>\n#include <limits.h>\n#include <demangle.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#define CHECK_EXCEPTION_(value) if(env->ExceptionOccurred()) { return value; }\n#define CHECK_EXCEPTION if(env->ExceptionOccurred()) { return;}\n#define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { throwNewDebuggerException(env, str); return value; }\n#define THROW_NEW_DEBUGGER_EXCEPTION(str) { throwNewDebuggerException(env, str); return;}\n\n#define SYMBOL_BUF_SIZE  256\n#define ERR_MSG_SIZE     (PATH_MAX + 256)\n\n// debug modes\nstatic int _libsaproc_debug = 0;\n#ifndef SOLARIS_11_B159_OR_LATER\nstatic bool _Pstack_iter_debug = false;\n\nstatic void dprintf_2(const char* format,...) {\n  if (_Pstack_iter_debug) {\n    va_list alist;\n\n    va_start(alist, format);\n    fputs(\"Pstack_iter DEBUG: \", stderr);\n    vfprintf(stderr, format, alist);\n    va_end(alist);\n  }\n}\n#endif // !SOLARIS_11_B159_OR_LATER\n\nstatic void print_debug(const char* format,...) {\n  if (_libsaproc_debug) {\n    va_list alist;\n\n    va_start(alist, format);\n    fputs(\"libsaproc DEBUG: \", stderr);\n    vfprintf(stderr, format, alist);\n    va_end(alist);\n  }\n}\n\nstruct Debugger {\n    JNIEnv* env;\n    jobject this_obj;\n};\n\nstruct DebuggerWithObject : Debugger {\n    jobject obj;\n};\n\nstruct DebuggerWith2Objects : DebuggerWithObject {\n    jobject obj2;\n};\n\n/*\n* Portions of user thread level detail gathering code is from pstack source\n* code. See pstack.c in Solaris 2.8 user commands source code.\n*/\n\nstatic void throwNewDebuggerException(JNIEnv* env, const char* errMsg) {\n  env->ThrowNew(env->FindClass(\"sun/jvm/hotspot/debugger/DebuggerException\"), errMsg);\n}\n\n// JNI ids for some fields, methods\n\n// libproc handler pointer\nstatic jfieldID p_ps_prochandle_ID = 0;\n\n// libthread.so dlopen handle, thread agent ptr and function pointers\nstatic jfieldID libthread_db_handle_ID   = 0;\nstatic jfieldID p_td_thragent_t_ID       = 0;\nstatic jfieldID p_td_init_ID             = 0;\nstatic jfieldID p_td_ta_new_ID           = 0;\nstatic jfieldID p_td_ta_delete_ID        = 0;\nstatic jfieldID p_td_ta_thr_iter_ID      = 0;\nstatic jfieldID p_td_thr_get_info_ID     = 0;\nstatic jfieldID p_td_ta_map_id2thr_ID    = 0;\nstatic jfieldID p_td_thr_getgregs_ID     = 0;\n\n// reg index fields\nstatic jfieldID pcRegIndex_ID            = 0;\nstatic jfieldID fpRegIndex_ID            = 0;\n\n// part of the class sharing workaround\nstatic jfieldID classes_jsa_fd_ID        = 0;\nstatic jfieldID p_file_map_header_ID     = 0;\n\n// method ids\n\nstatic jmethodID getThreadForThreadId_ID = 0;\nstatic jmethodID createSenderFrame_ID    = 0;\nstatic jmethodID createLoadObject_ID     = 0;\nstatic jmethodID createClosestSymbol_ID  = 0;\nstatic jmethodID listAdd_ID              = 0;\n\n/*\n * Functions we need from libthread_db\n */\ntypedef td_err_e\n        (*p_td_init_t)(void);\ntypedef td_err_e\n        (*p_td_ta_new_t)(void *, td_thragent_t **);\ntypedef td_err_e\n        (*p_td_ta_delete_t)(td_thragent_t *);\ntypedef td_err_e\n        (*p_td_ta_thr_iter_t)(const td_thragent_t *, td_thr_iter_f *, void *,\n                td_thr_state_e, int, sigset_t *, unsigned);\ntypedef td_err_e\n        (*p_td_thr_get_info_t)(const td_thrhandle_t *, td_thrinfo_t *);\ntypedef td_err_e\n        (*p_td_ta_map_id2thr_t)(const td_thragent_t *, thread_t,  td_thrhandle_t *);\ntypedef td_err_e\n        (*p_td_thr_getgregs_t)(const td_thrhandle_t *, prgregset_t);\n\nstatic void\nclear_libthread_db_ptrs(JNIEnv* env, jobject this_obj) {\n  // release libthread_db agent, if we had created\n  p_td_ta_delete_t p_td_ta_delete = 0;\n  p_td_ta_delete = (p_td_ta_delete_t) env->GetLongField(this_obj, p_td_ta_delete_ID);\n\n  td_thragent_t *p_td_thragent_t = 0;\n  p_td_thragent_t = (td_thragent_t*) env->GetLongField(this_obj, p_td_thragent_t_ID);\n  if (p_td_thragent_t != 0 && p_td_ta_delete != 0) {\n     p_td_ta_delete(p_td_thragent_t);\n  }\n\n  // dlclose libthread_db.so\n  void* libthread_db_handle = (void*) env->GetLongField(this_obj, libthread_db_handle_ID);\n  if (libthread_db_handle != 0) {\n    dlclose(libthread_db_handle);\n  }\n\n  env->SetLongField(this_obj, libthread_db_handle_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_init_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_ta_new_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_ta_delete_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_ta_thr_iter_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_thr_get_info_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_ta_map_id2thr_ID, (jlong)0);\n  env->SetLongField(this_obj, p_td_thr_getgregs_ID, (jlong)0);\n}\n\n\nstatic void detach_internal(JNIEnv* env, jobject this_obj) {\n  // clear libthread_db stuff\n  clear_libthread_db_ptrs(env, this_obj);\n\n  // release ptr to ps_prochandle\n  jlong p_ps_prochandle;\n  p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  if (p_ps_prochandle != 0L) {\n    Prelease((struct ps_prochandle*) p_ps_prochandle, PRELEASE_CLEAR);\n  }\n\n  // part of the class sharing workaround\n  int classes_jsa_fd = env->GetIntField(this_obj, classes_jsa_fd_ID);\n  if (classes_jsa_fd != -1) {\n    close(classes_jsa_fd);\n    struct FileMapHeader* pheader = (struct FileMapHeader*) env->GetLongField(this_obj, p_file_map_header_ID);\n    if (pheader != NULL) {\n      free(pheader);\n    }\n  }\n}\n\n// Is it okay to ignore libthread_db failure? Set env var to ignore\n// libthread_db failure. You can still debug, but will miss threads\n// related functionality.\nstatic bool sa_ignore_threaddb = (getenv(\"SA_IGNORE_THREADDB\") != 0);\n\n#define HANDLE_THREADDB_FAILURE(msg)          \\\n  if (sa_ignore_threaddb) {                   \\\n     printf(\"libsaproc WARNING: %s\\n\", msg);  \\\n     return;                                  \\\n  } else {                                    \\\n     THROW_NEW_DEBUGGER_EXCEPTION(msg);       \\\n  }\n\n#define HANDLE_THREADDB_FAILURE_(msg, ret)    \\\n  if (sa_ignore_threaddb) {                   \\\n     printf(\"libsaproc WARNING: %s\\n\", msg);  \\\n     return ret;                              \\\n  } else {                                    \\\n     THROW_NEW_DEBUGGER_EXCEPTION_(msg, ret); \\\n  }\n\nstatic const char * alt_root = NULL;\nstatic int alt_root_len = -1;\n\n#define SA_ALTROOT \"SA_ALTROOT\"\n\nstatic void init_alt_root() {\n  if (alt_root_len == -1) {\n    alt_root = getenv(SA_ALTROOT);\n    if (alt_root)\n      alt_root_len = strlen(alt_root);\n    else\n      alt_root_len = 0;\n  }\n}\n\n// This function is a complete substitute for the open system call\n// since it's also used to override open calls from libproc to\n// implement as a pathmap style facility for the SA.  If libproc\n// starts using other interfaces then this might have to extended to\n// cover other calls.\nextern \"C\" int libsaproc_open(const char * name, int oflag, ...) {\n  if (oflag == O_RDONLY) {\n    init_alt_root();\n\n    if (_libsaproc_debug) {\n      printf(\"libsaproc DEBUG: libsaproc_open %s\\n\", name);\n    }\n\n    if (alt_root_len > 0) {\n      int fd = -1;\n      char alt_path[PATH_MAX+1];\n\n      strcpy(alt_path, alt_root);\n      strcat(alt_path, name);\n      fd = open(alt_path, O_RDONLY);\n      if (fd >= 0) {\n        if (_libsaproc_debug) {\n          printf(\"libsaproc DEBUG: libsaproc_open substituted %s\\n\", alt_path);\n        }\n        return fd;\n      }\n\n      if (strrchr(name, '/')) {\n        strcpy(alt_path, alt_root);\n        strcat(alt_path, strrchr(name, '/'));\n        fd = open(alt_path, O_RDONLY);\n        if (fd >= 0) {\n          if (_libsaproc_debug) {\n            printf(\"libsaproc DEBUG: libsaproc_open substituted %s\\n\", alt_path);\n          }\n          return fd;\n        }\n      }\n    }\n  }\n\n  {\n    mode_t mode;\n    va_list ap;\n    va_start(ap, oflag);\n    mode = va_arg(ap, mode_t);\n    va_end(ap);\n\n    return open(name, oflag, mode);\n  }\n}\n\n\nstatic void * pathmap_dlopen(const char * name, int mode) {\n  init_alt_root();\n\n  if (_libsaproc_debug) {\n    printf(\"libsaproc DEBUG: pathmap_dlopen %s\\n\", name);\n  }\n\n  void * handle = NULL;\n  if (alt_root_len > 0) {\n    char alt_path[PATH_MAX+1];\n    strcpy(alt_path, alt_root);\n    strcat(alt_path, name);\n    handle = dlopen(alt_path, mode);\n    if (_libsaproc_debug && handle) {\n      printf(\"libsaproc DEBUG: pathmap_dlopen substituted %s\\n\", alt_path);\n    }\n\n    if (handle == NULL && strrchr(name, '/')) {\n      strcpy(alt_path, alt_root);\n      strcat(alt_path, strrchr(name, '/'));\n      handle = dlopen(alt_path, mode);\n      if (_libsaproc_debug && handle) {\n        printf(\"libsaproc DEBUG: pathmap_dlopen substituted %s\\n\", alt_path);\n      }\n    }\n  }\n  if (handle == NULL) {\n    handle = dlopen(name, mode);\n  }\n  if (_libsaproc_debug) {\n    printf(\"libsaproc DEBUG: pathmap_dlopen %s return 0x%lx\\n\", name, (unsigned long) handle);\n  }\n  return handle;\n}\n\n// libproc and libthread_db callback functions\n\nextern \"C\" {\n\nstatic int\ninit_libthread_db_ptrs(void *cd, const prmap_t *pmp, const char *object_name) {\n  Debugger* dbg = (Debugger*) cd;\n  JNIEnv* env = dbg->env;\n  jobject this_obj = dbg->this_obj;\n  struct ps_prochandle* ph = (struct ps_prochandle*) env->GetLongField(this_obj, p_ps_prochandle_ID);\n\n  char *s1 = 0, *s2 = 0;\n  char libthread_db[PATH_MAX];\n\n  if (strstr(object_name, \"/libthread.so.\") == NULL)\n     return (0);\n\n  /*\n   * We found a libthread.\n   * dlopen() the matching libthread_db and get the thread agent handle.\n   */\n  if (Pstatus(ph)->pr_dmodel == PR_MODEL_NATIVE) {\n     (void) strcpy(libthread_db, object_name);\n     s1 = (char*) strstr(object_name, \".so.\");\n     s2 = (char*) strstr(libthread_db, \".so.\");\n     (void) strcpy(s2, \"_db\");\n     s2 += 3;\n     (void) strcpy(s2, s1);\n  } else {\n#ifdef _LP64\n     /*\n      * The victim process is 32-bit, we are 64-bit.\n      * We have to find the 64-bit version of libthread_db\n      * that matches the victim's 32-bit version of libthread.\n      */\n     (void) strcpy(libthread_db, object_name);\n     s1 = (char*) strstr(object_name, \"/libthread.so.\");\n     s2 = (char*) strstr(libthread_db, \"/libthread.so.\");\n     (void) strcpy(s2, \"/64\");\n     s2 += 3;\n     (void) strcpy(s2, s1);\n     s1 = (char*) strstr(s1, \".so.\");\n     s2 = (char*) strstr(s2, \".so.\");\n     (void) strcpy(s2, \"_db\");\n     s2 += 3;\n     (void) strcpy(s2, s1);\n#else\n     return (0);\n#endif  /* _LP64 */\n  }\n\n  void* libthread_db_handle = 0;\n  if ((libthread_db_handle = pathmap_dlopen(libthread_db, RTLD_LAZY|RTLD_LOCAL)) == NULL) {\n     char errMsg[PATH_MAX + 256];\n     sprintf(errMsg, \"Can't load %s!\", libthread_db);\n     HANDLE_THREADDB_FAILURE_(errMsg, 0);\n  }\n  env->SetLongField(this_obj, libthread_db_handle_ID, (jlong)(uintptr_t)libthread_db_handle);\n\n  void* tmpPtr = 0;\n  tmpPtr = dlsym(libthread_db_handle, \"td_init\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_init!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_init_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr =dlsym(libthread_db_handle, \"td_ta_new\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_ta_new!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_ta_new_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr = dlsym(libthread_db_handle, \"td_ta_delete\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_ta_delete!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_ta_delete_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr = dlsym(libthread_db_handle, \"td_ta_thr_iter\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_ta_thr_iter!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_ta_thr_iter_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr = dlsym(libthread_db_handle, \"td_thr_get_info\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_thr_get_info!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_thr_get_info_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr = dlsym(libthread_db_handle, \"td_ta_map_id2thr\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_ta_map_id2thr!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_ta_map_id2thr_ID, (jlong)(uintptr_t) tmpPtr);\n\n  tmpPtr = dlsym(libthread_db_handle, \"td_thr_getgregs\");\n  if (tmpPtr == 0) {\n     HANDLE_THREADDB_FAILURE_(\"dlsym failed on td_thr_getgregs!\", 0);\n  }\n  env->SetLongField(this_obj, p_td_thr_getgregs_ID, (jlong)(uintptr_t) tmpPtr);\n\n  return 1;\n}\n\nstatic int\nfill_thread_list(const td_thrhandle_t *p_td_thragent_t, void* cd) {\n  DebuggerWithObject* dbgo = (DebuggerWithObject*) cd;\n  JNIEnv* env = dbgo->env;\n  jobject this_obj = dbgo->this_obj;\n  jobject list = dbgo->obj;\n\n  td_thrinfo_t thrinfo;\n  p_td_thr_get_info_t p_td_thr_get_info = (p_td_thr_get_info_t) env->GetLongField(this_obj, p_td_thr_get_info_ID);\n\n  if (p_td_thr_get_info(p_td_thragent_t, &thrinfo) != TD_OK)\n    return (0);\n\n  jobject threadProxy = env->CallObjectMethod(this_obj, getThreadForThreadId_ID, (jlong)(uintptr_t) thrinfo.ti_tid);\n  CHECK_EXCEPTION_(1);\n  env->CallBooleanMethod(list, listAdd_ID, threadProxy);\n  CHECK_EXCEPTION_(1);\n  return 0;\n}\n\nstatic int\nfill_load_object_list(void *cd, const prmap_t* pmp, const char* obj_name) {\n\n  if (obj_name) {\n     DebuggerWithObject* dbgo = (DebuggerWithObject*) cd;\n     JNIEnv* env = dbgo->env;\n     jobject this_obj = dbgo->this_obj;\n     jobject list = dbgo->obj;\n\n     jstring objectName = env->NewStringUTF(obj_name);\n     CHECK_EXCEPTION_(1);\n\n     jlong mapSize = (jlong) pmp->pr_size;\n     jobject sharedObject = env->CallObjectMethod(this_obj, createLoadObject_ID,\n                                  objectName, mapSize, (jlong)(uintptr_t)pmp->pr_vaddr);\n     CHECK_EXCEPTION_(1);\n     env->CallBooleanMethod(list, listAdd_ID, sharedObject);\n     CHECK_EXCEPTION_(1);\n  }\n\n  return 0;\n}\n\n// Pstack_iter() proc_stack_f callback prior to Nevada-B159\nstatic int\nfill_cframe_list(void *cd, const prgregset_t regs, uint_t argc, const long *argv) {\n  DebuggerWith2Objects* dbgo2 = (DebuggerWith2Objects*) cd;\n  JNIEnv* env = dbgo2->env;\n  jobject this_obj = dbgo2->this_obj;\n  jobject curFrame = dbgo2->obj2;\n\n  jint pcRegIndex = env->GetIntField(this_obj, pcRegIndex_ID);\n  jint fpRegIndex = env->GetIntField(this_obj, fpRegIndex_ID);\n\n  jlong pc = (jlong) (uintptr_t) regs[pcRegIndex];\n  jlong fp = (jlong) (uintptr_t) regs[fpRegIndex];\n\n  dbgo2->obj2 = env->CallObjectMethod(this_obj, createSenderFrame_ID,\n                                    curFrame, pc, fp);\n  CHECK_EXCEPTION_(1);\n  if (dbgo2->obj == 0) {\n     dbgo2->obj = dbgo2->obj2;\n  }\n  return 0;\n}\n\n// Pstack_iter() proc_stack_f callback in Nevada-B159 or later\n/*ARGSUSED*/\nstatic int\nwrapper_fill_cframe_list(void *cd, const prgregset_t regs, uint_t argc,\n                         const long *argv, int frame_flags, int sig) {\n  return(fill_cframe_list(cd, regs, argc, argv));\n}\n\n// part of the class sharing workaround\n\n// FIXME: !!HACK ALERT!!\n\n// The format of sharing achive file header is needed to read shared heap\n// file mappings. For now, I am hard coding portion of FileMapHeader here.\n// Refer to filemap.hpp.\n\n// FileMapHeader describes the shared space data in the file to be\n// mapped.  This structure gets written to a file.  It is not a class, so\n// that the compilers don't add any compiler-private data to it.\n\nconst int NUM_SHARED_MAPS = 4;\n\n// Refer to FileMapInfo::_current_version in filemap.hpp\nconst int CURRENT_ARCHIVE_VERSION = 1;\n\nstruct FileMapHeader {\n int   _magic;              // identify file type.\n int   _version;            // (from enum, above.)\n size_t _alignment;         // how shared archive should be aligned\n\n\n struct space_info {\n   int    _file_offset;     // sizeof(this) rounded to vm page size\n   char*  _base;            // copy-on-write base address\n   size_t _capacity;        // for validity checking\n   size_t _used;            // for setting space top on read\n\n   bool   _read_only;       // read only space?\n   bool   _allow_exec;      // executable code in space?\n\n } _space[NUM_SHARED_MAPS];\n\n // Ignore the rest of the FileMapHeader. We don't need those fields here.\n};\n\nstatic bool\nread_jboolean(struct ps_prochandle* ph, psaddr_t addr, jboolean* pvalue) {\n  jboolean i;\n  if (ps_pread(ph, addr, &i, sizeof(i)) == PS_OK) {\n    *pvalue = i;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstatic bool\nread_pointer(struct ps_prochandle* ph, psaddr_t addr, uintptr_t* pvalue) {\n  uintptr_t uip;\n  if (ps_pread(ph, addr, &uip, sizeof(uip)) == PS_OK) {\n    *pvalue = uip;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstatic bool\nread_string(struct ps_prochandle* ph, psaddr_t addr, char* buf, size_t size) {\n  char ch = ' ';\n  size_t i = 0;\n\n  while (ch != '\\0') {\n    if (ps_pread(ph, addr, &ch, sizeof(ch)) != PS_OK)\n      return false;\n\n    if (i < size - 1) {\n      buf[i] = ch;\n    } else { // smaller buffer\n      return false;\n    }\n\n    i++; addr++;\n  }\n\n  buf[i] = '\\0';\n  return true;\n}\n\n#define USE_SHARED_SPACES_SYM   \"UseSharedSpaces\"\n// mangled symbol name for Arguments::SharedArchivePath\n#define SHARED_ARCHIVE_PATH_SYM \"__1cJArgumentsRSharedArchivePath_\"\n\nstatic int\ninit_classsharing_workaround(void *cd, const prmap_t* pmap, const char* obj_name) {\n  Debugger* dbg = (Debugger*) cd;\n  JNIEnv*   env = dbg->env;\n  jobject this_obj = dbg->this_obj;\n  const char* jvm_name = 0;\n  if ((jvm_name = strstr(obj_name, \"libjvm.so\")) != NULL) {\n    jvm_name = obj_name;\n  } else {\n    return 0;\n  }\n\n  struct ps_prochandle* ph = (struct ps_prochandle*) env->GetLongField(this_obj, p_ps_prochandle_ID);\n\n  // initialize classes.jsa file descriptor field.\n  dbg->env->SetIntField(this_obj, classes_jsa_fd_ID, -1);\n\n  // check whether class sharing is on by reading variable \"UseSharedSpaces\"\n  psaddr_t useSharedSpacesAddr = 0;\n  ps_pglobal_lookup(ph, jvm_name, USE_SHARED_SPACES_SYM, &useSharedSpacesAddr);\n  if (useSharedSpacesAddr == 0) {\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't find 'UseSharedSpaces' flag\\n\", 1);\n  }\n\n  // read the value of the flag \"UseSharedSpaces\"\n  // Since hotspot types are not available to build this library. So\n  // equivalent type \"jboolean\" is used to read the value of \"UseSharedSpaces\"\n  // which is same as hotspot type \"bool\".\n  jboolean value = 0;\n  if (read_jboolean(ph, useSharedSpacesAddr, &value) != true) {\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't read 'UseSharedSpaces' flag\", 1);\n  } else if ((int)value == 0) {\n    print_debug(\"UseSharedSpaces is false, assuming -Xshare:off!\\n\");\n    return 1;\n  }\n\n  char classes_jsa[PATH_MAX];\n  psaddr_t sharedArchivePathAddrAddr = 0;\n  ps_pglobal_lookup(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM, &sharedArchivePathAddrAddr);\n  if (sharedArchivePathAddrAddr == 0) {\n    print_debug(\"can't find symbol 'Arguments::SharedArchivePath'\\n\");\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't get shared archive path from debuggee\", 1);\n  }\n\n  uintptr_t sharedArchivePathAddr = 0;\n  if (read_pointer(ph, sharedArchivePathAddrAddr, &sharedArchivePathAddr) != true) {\n    print_debug(\"can't find read pointer 'Arguments::SharedArchivePath'\\n\");\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't get shared archive path from debuggee\", 1);\n  }\n\n  if (read_string(ph, (psaddr_t)sharedArchivePathAddr, classes_jsa, sizeof(classes_jsa)) != true) {\n    print_debug(\"can't find read 'Arguments::SharedArchivePath' value\\n\");\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't get shared archive path from debuggee\", 1);\n  }\n\n  print_debug(\"looking for %s\\n\", classes_jsa);\n\n  // open the classes.jsa\n  int fd = libsaproc_open(classes_jsa, O_RDONLY);\n  if (fd < 0) {\n    char errMsg[ERR_MSG_SIZE];\n    sprintf(errMsg, \"can't open shared archive file %s\", classes_jsa);\n    THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);\n  } else {\n    print_debug(\"opened shared archive file %s\\n\", classes_jsa);\n  }\n\n  // parse classes.jsa\n  struct FileMapHeader* pheader = (struct FileMapHeader*) malloc(sizeof(struct FileMapHeader));\n  if (pheader == NULL) {\n    close(fd);\n    THROW_NEW_DEBUGGER_EXCEPTION_(\"can't allocate memory for shared file map header\", 1);\n  }\n\n  memset(pheader, 0, sizeof(struct FileMapHeader));\n  // read FileMapHeader\n  size_t n = read(fd, pheader, sizeof(struct FileMapHeader));\n  if (n != sizeof(struct FileMapHeader)) {\n    char errMsg[ERR_MSG_SIZE];\n    sprintf(errMsg, \"unable to read shared archive file map header from %s\", classes_jsa);\n    close(fd);\n    free(pheader);\n    THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);\n  }\n\n  // check file magic\n  if (pheader->_magic != 0xf00baba2) {\n    char errMsg[ERR_MSG_SIZE];\n    sprintf(errMsg, \"%s has bad shared archive magic 0x%x, expecting 0xf00baba2\",\n                   classes_jsa, pheader->_magic);\n    close(fd);\n    free(pheader);\n    THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);\n  }\n\n  // check version\n  if (pheader->_version != CURRENT_ARCHIVE_VERSION) {\n    char errMsg[ERR_MSG_SIZE];\n    sprintf(errMsg, \"%s has wrong shared archive version %d, expecting %d\",\n                   classes_jsa, pheader->_version, CURRENT_ARCHIVE_VERSION);\n    close(fd);\n    free(pheader);\n    THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);\n  }\n\n  if (_libsaproc_debug) {\n    for (int m = 0; m < NUM_SHARED_MAPS; m++) {\n       print_debug(\"shared file offset %d mapped at 0x%lx, size = %ld, read only? = %d\\n\",\n          pheader->_space[m]._file_offset, pheader->_space[m]._base,\n          pheader->_space[m]._used, pheader->_space[m]._read_only);\n    }\n  }\n\n  // FIXME: For now, omitting other checks such as VM version etc.\n\n  // store class archive file fd and map header in debugger object fields\n  dbg->env->SetIntField(this_obj, classes_jsa_fd_ID, fd);\n  dbg->env->SetLongField(this_obj, p_file_map_header_ID, (jlong)(uintptr_t) pheader);\n  return 1;\n}\n\n} // extern \"C\"\n\n// error messages for proc_arg_grab failure codes. The messages are\n// modified versions of comments against corresponding #defines in\n// libproc.h.\nstatic const char* proc_arg_grab_errmsgs[] = {\n                      \"\",\n /* G_NOPROC */       \"No such process\",\n /* G_NOCORE */       \"No such core file\",\n /* G_NOPROCORCORE */ \"No such process or core\",\n /* G_NOEXEC */       \"Cannot locate executable file\",\n /* G_ZOMB   */       \"Zombie processs\",\n /* G_PERM   */       \"No permission to attach\",\n /* G_BUSY   */       \"Another process has already attached\",\n /* G_SYS    */       \"System process - can not attach\",\n /* G_SELF   */       \"Process is self - can't debug myself!\",\n /* G_INTR   */       \"Interrupt received while grabbing\",\n /* G_LP64   */       \"debuggee is 64 bit, use java -d64 for debugger\",\n /* G_FORMAT */       \"File is not an ELF format core file - corrupted core?\",\n /* G_ELF    */       \"Libelf error while parsing an ELF file\",\n /* G_NOTE   */       \"Required PT_NOTE Phdr not present - corrupted core?\",\n};\n\nstatic void attach_internal(JNIEnv* env, jobject this_obj, jstring cmdLine, jboolean isProcess) {\n  jboolean isCopy;\n  int gcode;\n  const char* cmdLine_cstr = env->GetStringUTFChars(cmdLine, &isCopy);\n  CHECK_EXCEPTION;\n\n  // some older versions of libproc.so crash when trying to attach 32 bit\n  // debugger to 64 bit core file. check and throw error.\n#ifndef _LP64\n  atoi(cmdLine_cstr);\n  if (errno) {\n     // core file\n     int core_fd;\n     if ((core_fd = open64(cmdLine_cstr, O_RDONLY)) >= 0) {\n        Elf32_Ehdr e32;\n        if (pread64(core_fd, &e32, sizeof (e32), 0) == sizeof (e32) &&\n            memcmp(&e32.e_ident[EI_MAG0], ELFMAG, SELFMAG) == 0 &&\n            e32.e_type == ET_CORE && e32.e_ident[EI_CLASS] == ELFCLASS64) {\n              close(core_fd);\n              THROW_NEW_DEBUGGER_EXCEPTION(\"debuggee is 64 bit, use java -d64 for debugger\");\n        }\n        close(core_fd);\n     }\n     // all other conditions are handled by libproc.so.\n  }\n#endif\n\n  // connect to process/core\n  struct ps_prochandle* ph = proc_arg_grab(cmdLine_cstr, (isProcess? PR_ARG_PIDS : PR_ARG_CORES), PGRAB_FORCE, &gcode);\n  env->ReleaseStringUTFChars(cmdLine, cmdLine_cstr);\n  if (! ph) {\n     if (gcode > 0 && gcode < sizeof(proc_arg_grab_errmsgs)/sizeof(const char*)) {\n        char errMsg[ERR_MSG_SIZE];\n        sprintf(errMsg, \"Attach failed : %s\", proc_arg_grab_errmsgs[gcode]);\n        THROW_NEW_DEBUGGER_EXCEPTION(errMsg);\n    } else {\n        if (_libsaproc_debug && gcode == G_STRANGE) {\n           perror(\"libsaproc DEBUG: \");\n        }\n        if (isProcess) {\n           THROW_NEW_DEBUGGER_EXCEPTION(\"Not able to attach to process!\");\n        } else {\n           THROW_NEW_DEBUGGER_EXCEPTION(\"Not able to attach to core file!\");\n        }\n     }\n  }\n\n  // even though libproc.so supports 64 bit debugger and 32 bit debuggee, we don't\n  // support such cross-bit-debugging. check for that combination and throw error.\n#ifdef _LP64\n  int data_model;\n  if (ps_pdmodel(ph, &data_model) != PS_OK) {\n     Prelease(ph, PRELEASE_CLEAR);\n     THROW_NEW_DEBUGGER_EXCEPTION(\"can't determine debuggee data model (ILP32? or LP64?)\");\n  }\n  if (data_model == PR_MODEL_ILP32) {\n     Prelease(ph, PRELEASE_CLEAR);\n     THROW_NEW_DEBUGGER_EXCEPTION(\"debuggee is 32 bit, use 32 bit java for debugger\");\n  }\n#endif\n\n  env->SetLongField(this_obj, p_ps_prochandle_ID, (jlong)(uintptr_t)ph);\n\n  Debugger dbg;\n  dbg.env = env;\n  dbg.this_obj = this_obj;\n  jthrowable exception = 0;\n  if (! isProcess) {\n    /*\n     * With class sharing, shared perm. gen heap is allocated in with MAP_SHARED|PROT_READ.\n     * These pages are mapped from the file \"classes.jsa\". MAP_SHARED pages are not dumped\n     * in Solaris core.To read shared heap pages, we have to read classes.jsa file.\n     */\n    Pobject_iter(ph, init_classsharing_workaround, &dbg);\n    exception = env->ExceptionOccurred();\n    if (exception) {\n      env->ExceptionClear();\n      detach_internal(env, this_obj);\n      env->Throw(exception);\n      return;\n    }\n  }\n\n  /*\n   * Iterate over the process mappings looking\n   * for libthread and then dlopen the appropriate\n   * libthread_db and get function pointers.\n   */\n  Pobject_iter(ph, init_libthread_db_ptrs, &dbg);\n  exception = env->ExceptionOccurred();\n  if (exception) {\n    env->ExceptionClear();\n    if (!sa_ignore_threaddb) {\n      detach_internal(env, this_obj);\n      env->Throw(exception);\n    }\n    return;\n  }\n\n  // init libthread_db and create thread_db agent\n  p_td_init_t p_td_init = (p_td_init_t) env->GetLongField(this_obj, p_td_init_ID);\n  if (p_td_init == 0) {\n    if (!sa_ignore_threaddb) {\n      detach_internal(env, this_obj);\n    }\n    HANDLE_THREADDB_FAILURE(\"Did not find libthread in target process/core!\");\n  }\n\n  if (p_td_init() != TD_OK) {\n    if (!sa_ignore_threaddb) {\n      detach_internal(env, this_obj);\n    }\n    HANDLE_THREADDB_FAILURE(\"Can't initialize thread_db!\");\n  }\n\n  p_td_ta_new_t p_td_ta_new = (p_td_ta_new_t) env->GetLongField(this_obj, p_td_ta_new_ID);\n\n  td_thragent_t *p_td_thragent_t = 0;\n  if (p_td_ta_new(ph, &p_td_thragent_t) != TD_OK) {\n    if (!sa_ignore_threaddb) {\n      detach_internal(env, this_obj);\n    }\n    HANDLE_THREADDB_FAILURE(\"Can't create thread_db agent!\");\n  }\n  env->SetLongField(this_obj, p_td_thragent_t_ID, (jlong)(uintptr_t) p_td_thragent_t);\n\n}\n\n/*\n * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:    attach0\n * Signature: (Ljava/lang/String;)V\n * Description: process detach\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_attach0__Ljava_lang_String_2\n  (JNIEnv *env, jobject this_obj, jstring pid) {\n  attach_internal(env, this_obj, pid, JNI_TRUE);\n}\n\n/*\n * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:    attach0\n * Signature: (Ljava/lang/String;Ljava/lang/String;)V\n * Description: core file detach\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2\n  (JNIEnv *env, jobject this_obj, jstring executable, jstring corefile) {\n  // ignore executable file name, libproc.so can detect a.out name anyway.\n  attach_internal(env, this_obj, corefile, JNI_FALSE);\n}\n\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      detach0\n * Signature:   ()V\n * Description: process/core file detach\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_detach0\n  (JNIEnv *env, jobject this_obj) {\n  detach_internal(env, this_obj);\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      getRemoteProcessAddressSize0\n * Signature:   ()I\n * Description: get process/core address size\n */\nJNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_getRemoteProcessAddressSize0\n  (JNIEnv *env, jobject this_obj) {\n  jlong p_ps_prochandle;\n  p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  int data_model = PR_MODEL_ILP32;\n  ps_pdmodel((struct ps_prochandle*) p_ps_prochandle, &data_model);\n  print_debug(\"debuggee is %d bit\\n\", data_model == PR_MODEL_ILP32? 32 : 64);\n  return (jint) data_model == PR_MODEL_ILP32? 32 : 64;\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      getPageSize0\n * Signature:   ()I\n * Description: get process/core page size\n */\nJNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_getPageSize0\n  (JNIEnv *env, jobject this_obj) {\n\n/*\n  We are not yet attached to a java process or core file. getPageSize is called from\n  the constructor of ProcDebuggerLocal. The following won't work!\n\n    jlong p_ps_prochandle;\n    p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n    CHECK_EXCEPTION_(-1);\n    struct ps_prochandle* prochandle = (struct ps_prochandle*) p_ps_prochandle;\n    return (Pstate(prochandle) == PS_DEAD) ? Pgetauxval(prochandle, AT_PAGESZ)\n                                           : getpagesize();\n\n  So even though core may have been generated with a different page size settings, for now\n  call getpagesize.\n*/\n\n  return getpagesize();\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      getThreadIntegerRegisterSet0\n * Signature:   (J)[J\n * Description: get gregset for a given thread specified by thread id\n */\nJNIEXPORT jlongArray JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_getThreadIntegerRegisterSet0\n  (JNIEnv *env, jobject this_obj, jlong tid) {\n  // map the thread id to thread handle\n  p_td_ta_map_id2thr_t p_td_ta_map_id2thr = (p_td_ta_map_id2thr_t) env->GetLongField(this_obj, p_td_ta_map_id2thr_ID);\n\n  td_thragent_t* p_td_thragent_t = (td_thragent_t*) env->GetLongField(this_obj, p_td_thragent_t_ID);\n  if (p_td_thragent_t == 0) {\n     return 0;\n  }\n\n  td_thrhandle_t thr_handle;\n  if (p_td_ta_map_id2thr(p_td_thragent_t, (thread_t) tid, &thr_handle) != TD_OK) {\n     THROW_NEW_DEBUGGER_EXCEPTION_(\"can't map thread id to thread handle!\", 0);\n  }\n\n  p_td_thr_getgregs_t p_td_thr_getgregs = (p_td_thr_getgregs_t) env->GetLongField(this_obj, p_td_thr_getgregs_ID);\n  prgregset_t gregs;\n  p_td_thr_getgregs(&thr_handle, gregs);\n\n  jlongArray res = env->NewLongArray(NPRGREG);\n  CHECK_EXCEPTION_(0);\n  jboolean isCopy;\n  jlong* ptr = env->GetLongArrayElements(res, &isCopy);\n  for (int i = 0; i < NPRGREG; i++) {\n    ptr[i] = (jlong) (uintptr_t) gregs[i];\n  }\n  env->ReleaseLongArrayElements(res, ptr, JNI_COMMIT);\n  return res;\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      fillThreadList0\n * Signature:   (Ljava/util/List;)V\n * Description: fills thread list of the debuggee process/core\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_fillThreadList0\n  (JNIEnv *env, jobject this_obj, jobject list) {\n\n  td_thragent_t* p_td_thragent_t = (td_thragent_t*) env->GetLongField(this_obj, p_td_thragent_t_ID);\n  if (p_td_thragent_t == 0) {\n     return;\n  }\n\n  p_td_ta_thr_iter_t p_td_ta_thr_iter = (p_td_ta_thr_iter_t) env->GetLongField(this_obj, p_td_ta_thr_iter_ID);\n\n  DebuggerWithObject dbgo;\n  dbgo.env = env;\n  dbgo.this_obj = this_obj;\n  dbgo.obj = list;\n\n  p_td_ta_thr_iter(p_td_thragent_t, fill_thread_list, &dbgo,\n                   TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY, TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS);\n}\n\n#ifndef SOLARIS_11_B159_OR_LATER\n// building on Nevada-B158 or earlier so more hoops to jump through\nstatic bool has_newer_Pstack_iter = false;  // older version by default\n#endif\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      fillCFrameList0\n * Signature:   ([J)Lsun/jvm/hotspot/debugger/proc/ProcCFrame;\n * Description: fills CFrame list for a given thread\n */\nJNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_fillCFrameList0\n  (JNIEnv *env, jobject this_obj, jlongArray regsArray) {\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n\n  DebuggerWith2Objects dbgo2;\n  dbgo2.env  = env;\n  dbgo2.this_obj = this_obj;\n  dbgo2.obj  = NULL;\n  dbgo2.obj2 = NULL;\n\n  jboolean isCopy;\n  jlong* ptr = env->GetLongArrayElements(regsArray, &isCopy);\n  CHECK_EXCEPTION_(0);\n\n  prgregset_t gregs;\n  for (int i = 0; i < NPRGREG; i++) {\n     gregs[i] = (uintptr_t) ptr[i];\n  }\n\n  env->ReleaseLongArrayElements(regsArray, ptr, JNI_ABORT);\n  CHECK_EXCEPTION_(0);\n\n#ifdef SOLARIS_11_B159_OR_LATER\n  // building on Nevada-B159 or later so use the new callback\n  Pstack_iter((struct ps_prochandle*) p_ps_prochandle, gregs,\n              wrapper_fill_cframe_list, &dbgo2);\n#else\n  // building on Nevada-B158 or earlier so figure out which callback to use\n\n  if (has_newer_Pstack_iter) {\n    // Since we're building on Nevada-B158 or earlier, we have to\n    // cast wrapper_fill_cframe_list to make the compiler happy.\n    Pstack_iter((struct ps_prochandle*) p_ps_prochandle, gregs,\n                (proc_stack_f *)wrapper_fill_cframe_list, &dbgo2);\n  } else {\n    Pstack_iter((struct ps_prochandle*) p_ps_prochandle, gregs,\n                fill_cframe_list, &dbgo2);\n  }\n#endif // SOLARIS_11_B159_OR_LATER\n  return dbgo2.obj;\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      fillLoadObjectList0\n * Signature:   (Ljava/util/List;)V\n * Description: fills shared objects of the debuggee process/core\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_fillLoadObjectList0\n  (JNIEnv *env, jobject this_obj, jobject list) {\n  DebuggerWithObject dbgo;\n  dbgo.env = env;\n  dbgo.this_obj = this_obj;\n  dbgo.obj = list;\n\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  Pobject_iter((struct ps_prochandle*) p_ps_prochandle, fill_load_object_list, &dbgo);\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      readBytesFromProcess0\n * Signature:   (JJ)[B\n * Description: read bytes from debuggee process/core\n */\nJNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_readBytesFromProcess0\n  (JNIEnv *env, jobject this_obj, jlong address, jlong numBytes) {\n\n  jbyteArray array = env->NewByteArray(numBytes);\n  CHECK_EXCEPTION_(0);\n  jboolean isCopy;\n  jbyte* bufPtr = env->GetByteArrayElements(array, &isCopy);\n  CHECK_EXCEPTION_(0);\n\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  ps_err_e ret = ps_pread((struct ps_prochandle*) p_ps_prochandle,\n                       (psaddr_t)address, bufPtr, (size_t)numBytes);\n\n  if (ret != PS_OK) {\n    // part of the class sharing workaround. try shared heap area\n    int classes_jsa_fd = env->GetIntField(this_obj, classes_jsa_fd_ID);\n    if (classes_jsa_fd != -1 && address != (jlong)0) {\n      print_debug(\"read failed at 0x%lx, attempting shared heap area\\n\", (long) address);\n\n      struct FileMapHeader* pheader = (struct FileMapHeader*) env->GetLongField(this_obj, p_file_map_header_ID);\n      // walk through the shared mappings -- we just have 4 of them.\n      // so, linear walking is okay.\n      for (int m = 0; m < NUM_SHARED_MAPS; m++) {\n\n        // We can skip the non-read-only maps. These are mapped as MAP_PRIVATE\n        // and hence will be read by libproc. Besides, the file copy may be\n        // stale because the process might have modified those pages.\n        if (pheader->_space[m]._read_only) {\n          jlong baseAddress = (jlong) (uintptr_t) pheader->_space[m]._base;\n          size_t usedSize = pheader->_space[m]._used;\n          if (address >= baseAddress && address < (baseAddress + usedSize)) {\n            // the given address falls in this shared heap area\n            print_debug(\"found shared map at 0x%lx\\n\", (long) baseAddress);\n\n\n            // If more data is asked than actually mapped from file, we need to zero fill\n            // till the end-of-page boundary. But, java array new does that for us. we just\n            // need to read as much as data available.\n\n#define MIN2(x, y) (((x) < (y))? (x) : (y))\n\n            jlong diff = address - baseAddress;\n            jlong bytesToRead = MIN2(numBytes, usedSize - diff);\n            off_t offset = pheader->_space[m]._file_offset  + off_t(diff);\n            ssize_t bytesRead = pread(classes_jsa_fd, bufPtr, bytesToRead, offset);\n            if (bytesRead != bytesToRead) {\n              env->ReleaseByteArrayElements(array, bufPtr, JNI_ABORT);\n              print_debug(\"shared map read failed\\n\");\n              return jbyteArray(0);\n            } else {\n              print_debug(\"shared map read succeeded\\n\");\n              env->ReleaseByteArrayElements(array, bufPtr, 0);\n              return array;\n            }\n          } // is in current map\n        } // is read only map\n      } // for shared maps\n    } // classes_jsa_fd != -1\n    env->ReleaseByteArrayElements(array, bufPtr, JNI_ABORT);\n    return jbyteArray(0);\n  } else {\n    env->ReleaseByteArrayElements(array, bufPtr, 0);\n    return array;\n  }\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      writeBytesToProcess0\n * Signature:   (JJ[B)V\n * Description: write bytes into debugger process\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_writeBytesToProcess0\n  (JNIEnv *env, jobject this_obj, jlong address, jlong numBytes, jbyteArray data) {\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  jboolean isCopy;\n  jbyte* ptr = env->GetByteArrayElements(data, &isCopy);\n  CHECK_EXCEPTION;\n\n  if (ps_pwrite((struct ps_prochandle*) p_ps_prochandle, address, ptr, numBytes) != PS_OK) {\n     env->ReleaseByteArrayElements(data, ptr, JNI_ABORT);\n     THROW_NEW_DEBUGGER_EXCEPTION(\"Process write failed!\");\n  }\n\n  env->ReleaseByteArrayElements(data, ptr, JNI_ABORT);\n}\n\n/*\n * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:    suspend0\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_suspend0\n  (JNIEnv *env, jobject this_obj) {\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  // for now don't check return value. revisit this again.\n  Pstop((struct ps_prochandle*) p_ps_prochandle, 1000);\n}\n\n/*\n * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:    resume0\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_resume0\n  (JNIEnv *env, jobject this_obj) {\n  jlong p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n  // for now don't check return value. revisit this again.\n  Psetrun((struct ps_prochandle*) p_ps_prochandle, 0, PRCFAULT|PRSTOP);\n}\n\n/*\n  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n  * Method:      lookupByName0\n  * Signature:   (Ljava/lang/String;Ljava/lang/String;)J\n  * Description: symbol lookup by name\n*/\nJNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_lookupByName0\n   (JNIEnv *env, jobject this_obj, jstring objectName, jstring symbolName) {\n   jlong p_ps_prochandle;\n   p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n\n   jboolean isCopy;\n   const char* objectName_cstr = NULL;\n   if (objectName != NULL) {\n     objectName_cstr = env->GetStringUTFChars(objectName, &isCopy);\n     CHECK_EXCEPTION_(0);\n   } else {\n     objectName_cstr = PR_OBJ_EVERY;\n   }\n\n   const char* symbolName_cstr = env->GetStringUTFChars(symbolName, &isCopy);\n   CHECK_EXCEPTION_(0);\n\n   psaddr_t symbol_addr = (psaddr_t) 0;\n   ps_pglobal_lookup((struct ps_prochandle*) p_ps_prochandle,  objectName_cstr,\n                    symbolName_cstr, &symbol_addr);\n\n   if (symbol_addr == 0) {\n      print_debug(\"lookup for %s in %s failed\\n\", symbolName_cstr, objectName_cstr);\n   }\n\n   if (objectName_cstr != PR_OBJ_EVERY) {\n     env->ReleaseStringUTFChars(objectName, objectName_cstr);\n   }\n   env->ReleaseStringUTFChars(symbolName, symbolName_cstr);\n   return (jlong) (uintptr_t) symbol_addr;\n}\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      lookupByAddress0\n * Signature:   (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;\n * Description: lookup symbol name for a given address\n */\nJNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_lookupByAddress0\n   (JNIEnv *env, jobject this_obj, jlong address) {\n   jlong p_ps_prochandle;\n   p_ps_prochandle = env->GetLongField(this_obj, p_ps_prochandle_ID);\n\n   char nameBuf[SYMBOL_BUF_SIZE + 1];\n   GElf_Sym sym;\n   int res = Plookup_by_addr((struct ps_prochandle*) p_ps_prochandle, (uintptr_t) address,\n                                 nameBuf, sizeof(nameBuf), &sym);\n   if (res != 0) { // failed\n      return 0;\n   }\n\n   jstring resSym = env->NewStringUTF(nameBuf);\n   CHECK_EXCEPTION_(0);\n\n   return env->CallObjectMethod(this_obj, createClosestSymbol_ID, resSym, (address - sym.st_value));\n}\n\n/*\n * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:    demangle0\n * Signature: (Ljava/lang/String;)Ljava/lang/String;\n */\nJNIEXPORT jstring JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_demangle0\n  (JNIEnv *env, jobject this_object, jstring name) {\n  jboolean isCopy;\n  const char* ptr = env->GetStringUTFChars(name, &isCopy);\n  char  buf[2*SYMBOL_BUF_SIZE + 1];\n  jstring res = 0;\n  if (cplus_demangle((char*) ptr, buf, sizeof(buf)) != DEMANGLE_ESPACE) {\n    res = env->NewStringUTF(buf);\n  } else {\n    res = name;\n  }\n  env->ReleaseStringUTFChars(name, ptr);\n  return res;\n}\n\n#ifndef SOLARIS_11_B159_OR_LATER\n// Determine if the OS we're running on has the newer version\n// of libproc's Pstack_iter.\n//\n// Set env var PSTACK_ITER_DEBUG=true to debug this logic.\n// Set env var PSTACK_ITER_DEBUG_RELEASE to simulate a 'release' value.\n// Set env var PSTACK_ITER_DEBUG_VERSION to simulate a 'version' value.\n//\n// frankenputer 'uname -r -v': 5.10 Generic_141445-09\n// jurassic 'uname -r -v':     5.11 snv_164\n// lonepeak 'uname -r -v':     5.11 snv_127\n//\nstatic void set_has_newer_Pstack_iter(JNIEnv *env) {\n  static bool done_set = false;\n\n  if (done_set) {\n    // already set has_newer_Pstack_iter\n    return;\n  }\n\n  struct utsname name;\n  if (uname(&name) == -1) {\n    THROW_NEW_DEBUGGER_EXCEPTION(\"uname() failed!\");\n  }\n  dprintf_2(\"release='%s'  version='%s'\\n\", name.release, name.version);\n\n  if (_Pstack_iter_debug) {\n    char *override = getenv(\"PSTACK_ITER_DEBUG_RELEASE\");\n    if (override != NULL) {\n      strncpy(name.release, override, SYS_NMLN - 1);\n      name.release[SYS_NMLN - 2] = '\\0';\n      dprintf_2(\"overriding with release='%s'\\n\", name.release);\n    }\n    override = getenv(\"PSTACK_ITER_DEBUG_VERSION\");\n    if (override != NULL) {\n      strncpy(name.version, override, SYS_NMLN - 1);\n      name.version[SYS_NMLN - 2] = '\\0';\n      dprintf_2(\"overriding with version='%s'\\n\", name.version);\n    }\n  }\n\n  // the major number corresponds to the old SunOS major number\n  int major = atoi(name.release);\n  if (major >= 6) {\n    dprintf_2(\"release is SunOS 6 or later\\n\");\n    has_newer_Pstack_iter = true;\n    done_set = true;\n    return;\n  }\n  if (major < 5) {\n    dprintf_2(\"release is SunOS 4 or earlier\\n\");\n    done_set = true;\n    return;\n  }\n\n  // some SunOS 5.* build so now check for Solaris versions\n  char *dot = strchr(name.release, '.');\n  int minor = 0;\n  if (dot != NULL) {\n    // release is major.minor format\n    *dot = NULL;\n    minor = atoi(dot + 1);\n  }\n\n  if (minor <= 10) {\n    dprintf_2(\"release is Solaris 10 or earlier\\n\");\n    done_set = true;\n    return;\n  } else if (minor >= 12) {\n    dprintf_2(\"release is Solaris 12 or later\\n\");\n    has_newer_Pstack_iter = true;\n    done_set = true;\n    return;\n  }\n\n  // some Solaris 11 build so now check for internal build numbers\n  if (strncmp(name.version, \"snv_\", 4) != 0) {\n    dprintf_2(\"release is Solaris 11 post-GA or later\\n\");\n    has_newer_Pstack_iter = true;\n    done_set = true;\n    return;\n  }\n\n  // version begins with \"snv_\" so a pre-GA build of Solaris 11\n  int build = atoi(&name.version[4]);\n  if (build >= 159) {\n    dprintf_2(\"release is Nevada-B159 or later\\n\");\n    has_newer_Pstack_iter = true;\n  } else {\n    dprintf_2(\"release is Nevada-B158 or earlier\\n\");\n  }\n\n  done_set = true;\n}\n#endif // !SOLARIS_11_B159_OR_LATER\n\n/*\n * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal\n * Method:      initIDs\n * Signature:   ()V\n * Description: get JNI ids for fields and methods of ProcDebuggerLocal class\n */\nJNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_initIDs\n  (JNIEnv *env, jclass clazz) {\n  _libsaproc_debug = getenv(\"LIBSAPROC_DEBUG\") != NULL;\n  if (_libsaproc_debug) {\n     // propagate debug mode to libproc.so\n     static const char* var = \"LIBPROC_DEBUG=1\";\n     putenv((char*)var);\n  }\n\n  void* libproc_handle = dlopen(\"libproc.so\", RTLD_LAZY | RTLD_GLOBAL);\n  if (libproc_handle == 0)\n     THROW_NEW_DEBUGGER_EXCEPTION(\"can't load libproc.so, if you are using Solaris 5.7 or below, copy libproc.so from 5.8!\");\n\n#ifndef SOLARIS_11_B159_OR_LATER\n  _Pstack_iter_debug = getenv(\"PSTACK_ITER_DEBUG\") != NULL;\n\n  set_has_newer_Pstack_iter(env);\n  CHECK_EXCEPTION;\n  dprintf_2(\"has_newer_Pstack_iter=%d\\n\", has_newer_Pstack_iter);\n#endif\n\n  p_ps_prochandle_ID = env->GetFieldID(clazz, \"p_ps_prochandle\", \"J\");\n  CHECK_EXCEPTION;\n\n  libthread_db_handle_ID = env->GetFieldID(clazz, \"libthread_db_handle\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_thragent_t_ID = env->GetFieldID(clazz, \"p_td_thragent_t\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_init_ID = env->GetFieldID(clazz, \"p_td_init\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_ta_new_ID = env->GetFieldID(clazz, \"p_td_ta_new\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_ta_delete_ID = env->GetFieldID(clazz, \"p_td_ta_delete\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_ta_thr_iter_ID = env->GetFieldID(clazz, \"p_td_ta_thr_iter\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_thr_get_info_ID = env->GetFieldID(clazz, \"p_td_thr_get_info\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_ta_map_id2thr_ID = env->GetFieldID(clazz, \"p_td_ta_map_id2thr\", \"J\");\n  CHECK_EXCEPTION;\n\n  p_td_thr_getgregs_ID = env->GetFieldID(clazz, \"p_td_thr_getgregs\", \"J\");\n  CHECK_EXCEPTION;\n\n  getThreadForThreadId_ID = env->GetMethodID(clazz,\n                            \"getThreadForThreadId\", \"(J)Lsun/jvm/hotspot/debugger/ThreadProxy;\");\n  CHECK_EXCEPTION;\n\n  pcRegIndex_ID = env->GetFieldID(clazz, \"pcRegIndex\", \"I\");\n  CHECK_EXCEPTION;\n\n  fpRegIndex_ID = env->GetFieldID(clazz, \"fpRegIndex\", \"I\");\n  CHECK_EXCEPTION;\n\n  createSenderFrame_ID = env->GetMethodID(clazz,\n                            \"createSenderFrame\", \"(Lsun/jvm/hotspot/debugger/proc/ProcCFrame;JJ)Lsun/jvm/hotspot/debugger/proc/ProcCFrame;\");\n  CHECK_EXCEPTION;\n\n  createLoadObject_ID = env->GetMethodID(clazz,\n                            \"createLoadObject\", \"(Ljava/lang/String;JJ)Lsun/jvm/hotspot/debugger/cdbg/LoadObject;\");\n  CHECK_EXCEPTION;\n\n  createClosestSymbol_ID = env->GetMethodID(clazz,\n                            \"createClosestSymbol\", \"(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;\");\n  CHECK_EXCEPTION;\n\n  listAdd_ID = env->GetMethodID(env->FindClass(\"java/util/List\"), \"add\", \"(Ljava/lang/Object;)Z\");\n  CHECK_EXCEPTION;\n\n  // part of the class sharing workaround\n  classes_jsa_fd_ID = env->GetFieldID(clazz, \"classes_jsa_fd\", \"I\");\n  CHECK_EXCEPTION;\n  p_file_map_header_ID = env->GetFieldID(clazz, \"p_file_map_header\", \"J\");\n  CHECK_EXCEPTION;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/os/solaris/proc/saproc_audit.cpp": "/*\n * Copyright (c) 2009, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include <link.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <varargs.h>\n\n// This class sets up an interposer on open calls from libproc.so to\n// support a pathmap facility in the SA.\n\nstatic uintptr_t* libproc_cookie;\nstatic uintptr_t* libc_cookie;\nstatic uintptr_t* libsaproc_cookie;\n\n\nuint_t\nla_version(uint_t version)\n{\n  return (LAV_CURRENT);\n}\n\n\nuint_t\nla_objopen(Link_map * lmp, Lmid_t lmid, uintptr_t * cookie)\n{\n  if (strstr(lmp->l_name, \"/libproc.so\") != NULL) {\n    libproc_cookie = cookie;\n    return LA_FLG_BINDFROM;\n  }\n  if (strstr(lmp->l_name, \"/libc.so\") != NULL) {\n    libc_cookie = cookie;\n    return LA_FLG_BINDTO;\n  }\n  if (strstr(lmp->l_name, \"/libsaproc.so\") != NULL) {\n    libsaproc_cookie = cookie;\n    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n  }\n  return 0;\n}\n\n\n#if     defined(_LP64)\nuintptr_t\nla_symbind64(Elf64_Sym *symp, uint_t symndx, uintptr_t *refcook,\n             uintptr_t *defcook, uint_t *sb_flags, const char *sym_name)\n#else\nuintptr_t\nla_symbind32(Elf32_Sym *symp, uint_t symndx, uintptr_t *refcook,\n             uintptr_t *defcook, uint_t *sb_flags)\n#endif\n{\n#if     !defined(_LP64)\n  const char      *sym_name = (const char *)symp->st_name;\n#endif\n  if (strcmp(sym_name, \"open\") == 0 && refcook == libproc_cookie) {\n    // redirect all open calls from libproc.so through libsaproc_open which will\n    // try the alternate library locations first.\n    void* handle = dlmopen(LM_ID_BASE, \"libsaproc.so\", RTLD_NOLOAD);\n    if (handle == NULL) {\n      fprintf(stderr, \"libsaproc_audit.so: didn't find libsaproc.so during linking\\n\");\n    } else {\n      uintptr_t libsaproc_open = (uintptr_t)dlsym(handle, \"libsaproc_open\");\n      if (libsaproc_open == 0) {\n        fprintf(stderr, \"libsaproc_audit.so: didn't find libsaproc_open during linking\\n\");\n      } else {\n        return libsaproc_open;\n      }\n    }\n  }\n  return symp->st_value;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/rmiregistry.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/idlj.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jvisualvm.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/tnameserv.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/xjc.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/pack200.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jcmd.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jstatd.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jar.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jstat.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jrunscript.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/javadoc.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/javah.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/schemagen.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/wsgen.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jstack.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jdeps.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/javaws.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jmap.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/orbd.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jconsole.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/servertool.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/extcheck.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jarsigner.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/javac.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jsadebugd.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jinfo.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/rmic.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/unpack200.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/java.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/appletviewer.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jdb.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/serialver.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/policytool.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/rmid.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/keytool.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/native2ascii.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jps.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/javap.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/wsimport.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jhat.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/linux/doc/man/ja/jjs.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/windows/native/sun/windows/security_warning.ico",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/windows/native/sun/windows/check.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/windows/native/sun/windows/security_warning_int.ico",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/windows/native/sun/windows/security_warning_bw.ico",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/windows/native/sun/windows/hand.cur",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/windows/resource/icons/awt.ico",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/awt/randr.h",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/native/sun/awt/Xrandr.h",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/classes/sun/awt/X11/java-icon48.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/classes/sun/awt/X11/java-icon24.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/classes/sun/awt/X11/java-icon16.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/classes/sun/awt/X11/java-icon32.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/rmiregistry.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/idlj.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jvisualvm.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/tnameserv.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/xjc.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/pack200.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jcmd.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jstatd.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jar.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jstat.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jrunscript.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/javadoc.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/javah.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/schemagen.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/wsgen.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jstack.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jdeps.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jmap.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/orbd.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jconsole.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/servertool.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/extcheck.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jarsigner.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/javac.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jsadebugd.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jinfo.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/rmic.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/unpack200.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/java.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/appletviewer.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jdb.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/serialver.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/policytool.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/rmid.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/keytool.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/native2ascii.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jps.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/javap.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/wsimport.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jhat.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/solaris/doc/sun/man/man1/ja/jjs.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/native/sun/java2d/cmm/lcms/cmscgats.c",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/native/sun/java2d/cmm/lcms/cmsxform.c",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/native/sun/java2d/cmm/lcms/cmsopt.c",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/native/sun/java2d/cmm/lcms/cmstypes.c",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/native/sun/java2d/cmm/lcms/cmsvirt.c",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/java2d/J2DBench/resources/images/photo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/java2d/J2DBench/resources/cmm_images/img_icc_large.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/java2d/J2DBench/resources/cmm_images/img_icc_medium.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/java2d/J2DBench/resources/cmm_images/img_icc_small.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/Metalworks/resources/HelpFiles/back.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/Metalworks/resources/HelpFiles/javalogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/Metalworks/resources/HelpFiles/duke.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/FileChooserDemo/resources/images/gifIcon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/FileChooserDemo/resources/images/jpgIcon.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/SampleTree/resources/images/expanded.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/SampleTree/resources/images/collapsed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/Notepad/resources/new.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/Notepad/resources/cut.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/Notepad/resources/copy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/Notepad/resources/save.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/Notepad/resources/paste.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/demo/jfc/Notepad/resources/open.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/win32_CopyNoDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/motif_CopyNoDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/win32_MoveDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/invalid32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/motif_MoveDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/win32_LinkNoDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/motif_LinkNoDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/win32_LinkDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/motif_LinkDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/win32_MoveNoDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/motif_MoveNoDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/win32_CopyDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/images/cursors/motif_CopyDrop32x32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/cmm/lcms/sRGB.pf",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/cmm/lcms/CIEXYZ.pf",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/cmm/lcms/GRAY.pf",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/cmm/lcms/PYCC.pf",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/lib/cmm/lcms/LINEAR_RGB.pf",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/sample/jmx/jmx-scandir/docfiles/remote-connection-failed.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/sample/jmx/jmx-scandir/docfiles/connect-local-java-jar.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/sample/jmx/jmx-scandir/docfiles/scandir-result.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/sample/jmx/jmx-scandir/docfiles/connect-local.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/sample/jmx/jmx-scandir/docfiles/connect-local-ant-run.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/sample/jmx/jmx-scandir/docfiles/remote-connection.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/sample/jmx/jmx-scandir/docfiles/scandir-config.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/sample/jmx/jmx-scandir/docfiles/scandir-start.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/print/resources/oneside.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/print/resources/orientLandscape.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/print/resources/orientPortrait.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/print/resources/tumble.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/print/resources/orientRevLandscape.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/print/resources/duplex.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/print/resources/orientRevPortrait.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/text/resources/unorm.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/text/resources/uprops.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/text/resources/ubidi.icu",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-yellow32.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-yellow48.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-bw24.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-interim24.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-interim16.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-bw48.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-yellow16.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-bw32.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-yellow24.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-interim32.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-bw16.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/awt/resources/security-icon-interim48.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/net/idn/uidna.spp",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/masthead-left.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/disconnected16.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/disconnected24.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/xobject.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/connected24.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/connected16.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/mbean.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/expand-winlf.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/collapse-winlf.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/mbeanserverdelegate.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/masthead-right.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/sun/tools/jconsole/resources/brandlogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/org/apache/xml/internal/security/resource/xmlsecurity_de.properties",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/TreeClosed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/File.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/UpFolder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/Warn.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/JavaCup32.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/FloppyDrive.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/ListView.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/TreeOpen.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/Computer.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/Inform.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/HomeFolder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/Directory.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/image-delayed.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/NewFolder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/HardDrive.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/image-failed.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/Question.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/TreeLeaf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/Error.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/windows/icons/DetailsView.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/motif/icons/TreeClosed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/motif/icons/Warn.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/motif/icons/TreeOpen.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/motif/icons/Inform.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/motif/icons/image-delayed.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/motif/icons/image-failed.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/motif/icons/Question.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/motif/icons/Error.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/motif/icons/DesktopIcon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/gtk/icons/File.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/gtk/icons/Directory.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/gtk/icons/image-delayed.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/com/sun/java/swing/plaf/gtk/icons/image-failed.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/groupLayout.sequential.horizontal.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/groupLayout.3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/groupLayout.2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/groupLayout.example.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/BoxLayout-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/JScrollPane-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/SizeSequence-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/groupLayout.sequential.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/JRootPane-2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/groupLayout.sequential.vertical.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/JLayeredPane-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/groupLayout.1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/doc-files/JRootPane-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/undo/doc-files/UndoManager-2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/undo/doc-files/UndoManager-4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/undo/doc-files/UndoManager-3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/undo/doc-files/UndoManager-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/text/doc-files/editor.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/text/doc-files/Document-remove.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/text/doc-files/paragraph.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/text/doc-files/OpenBookIcon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/text/doc-files/Document-coord.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/text/doc-files/Document-insert.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/text/doc-files/Document-structure.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/text/doc-files/View-layout.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/text/doc-files/View-flexibility.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/text/doc-files/Document-notification.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/sortUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/Warn.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/sortDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/Inform.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/Question.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/Error.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/iconify-pressed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/error.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/minimize-pressed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/question.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/expanded.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/newFolder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/paletteClose.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/computer.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/file.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/upFolder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/paletteClose-pressed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/collapsed-rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/collapsed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/menu.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/iconify.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/homeFolder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/maximize.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/info.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/minimize.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/directory.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/hardDrive.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/maximize-pressed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/close-pressed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/icons/ocean/floppy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/FrameMinimize.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/FrameClose.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/OptionPaneInformation.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/FrameRestoreDown.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/FrameMaximize.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/OptionPaneQuestion.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/FrameRestoreUp.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/OptionPaneError.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/OptionPaneWarning.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/MenuItemCommand.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/metal/sounds/PopupMenuPopup.wav",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/multi/doc-files/multi_tsc.html",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/basic/icons/JavaCup16.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/basic/icons/image-delayed.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/javax/swing/plaf/basic/icons/image-failed.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/capiota.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/upsilon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/javalang.doc.anc40.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/capsigma.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/captheta.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/javalang.doc.anc38.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/iota.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/chi.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/sigma1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/capupsil.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/javalang.doc.anc21.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/capchi.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/javalang.doc.anc41.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/lang/doc-files/theta.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/LinearGradientPaint.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/modal-example4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/TextArea-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/modal-example2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/MultiScreen.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/RadialGradientPaint-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/Label-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/FocusCycle.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/RadialGradientPaint-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/FontMetrics-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/modal-example1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/Choice-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/BorderLayout-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/Scrollbar-2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/FlowLayout-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/RadialGradientPaint-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/Scrollbar-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/modal-example3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/TextField-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/List-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/CheckboxGroup-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/GridBagLayout-baseline.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/RadialGradientPaint-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/GridBagLayout-2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/GridLayout-2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/GridLayout-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/ImplicitFocusTransfer.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/Button-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/Checkbox-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/MenuBar-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/share/classes/java/awt/doc-files/GridBagLayout-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/src/macosx/native/sun/osxapp/resource/icons/JavaApp.icns",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JAppletMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTableColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JColorChooserColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPanelColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JAppletColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JOptionPaneColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTreeColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JToggleButtonMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/BoxMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFrameMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuBarMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextAreaColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTableMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JDesktopPaneColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuBarMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JInternalFrameColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRootPaneMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JScrollPaneMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/BoxMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/BorderColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/BoxColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JEditorPaneColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JWindowMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPanelMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRootPaneMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSeparatorColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JCheckBoxColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPasswordFieldMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextAreaColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSliderMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JColorChooserMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JScrollPaneMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JEditorPaneMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRadioButtonMenuItemMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JListColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JWindowMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JLabelColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSplitPaneColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JToggleButtonMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JComboBoxColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JWindowColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JDialogMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JComboBoxMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JButtonMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSpinnerMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTreeMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPasswordFieldColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuItemColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JToggleButtonColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTableMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRadioButtonMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JScrollBarMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFormattedTextFieldMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JButtonColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFormattedTextFieldColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JInternalFrameColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/AbstractButtonColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JCheckBoxColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFileChooserMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JLabelMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JOptionPaneMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JToolBarColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRootPaneColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPopupMenuColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JProgressBarColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JListColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JDialogMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSliderMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JListMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JButtonColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFileChooserMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JEditorPaneColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JWindowColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JInternalFrameMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFrameColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuBarColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFormattedTextFieldColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JDialogColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSeparatorMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextFieldMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JLayeredPaneMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JColorChooserMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSplitPaneMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JComponentColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JOptionPaneMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JScrollPaneColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/BoxColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JComboBoxColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuItemColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JViewportColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextFieldMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextAreaMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFormattedTextFieldMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JDesktopPaneColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSeparatorMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JAppletColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JViewportMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JDialogColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPopupMenuMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTableColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextAreaMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JToolBarMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JLayeredPaneColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JToolBarColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JViewportMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextFieldColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRadioButtonColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextFieldColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPopupMenuMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPanelMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPasswordFieldMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSplitPaneColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JCheckBoxMenuItemColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JCheckBoxMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JCheckBoxMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRadioButtonMenuItemMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JToolBarMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuItemMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JToggleButtonColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JListMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JDesktopPaneMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuItemMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JCheckBoxMenuItemColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPanelColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFileChooserColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JLabelColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSplitPaneMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRadioButtonMenuItemColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JCheckBoxMenuItemMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JAppletMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JEditorPaneMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRadioButtonColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSpinnerMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFrameColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextPaneMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JProgressBarColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSpinnerColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JLayeredPaneMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuBarColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JInternalFrameMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFrameMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JOptionPaneColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JProgressBarMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTabbedPaneColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPasswordFieldColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JProgressBarMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRadioButtonMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JScrollBarColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JLabelMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTabbedPaneColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSliderColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextPaneColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JViewportColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JScrollPaneColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRadioButtonMenuItemColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JButtonMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JScrollBarMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JFileChooserColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JCheckBoxMenuItemMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTreeColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextPaneColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JPopupMenuColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JScrollBarColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSeparatorColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTextPaneMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JLayeredPaneColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JColorChooserColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTreeMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JRootPaneColor32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSliderColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTabbedPaneMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JMenuColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JComboBoxMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JSpinnerColor16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JTabbedPaneMono16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/swingbeaninfo/images/JDesktopPaneMono32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/dtdbuilder/HTMLlat1.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/dtdbuilder/HTMLsymbol.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/make/data/dtdbuilder/HTMLspecial.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/java2d/cmm/ColorConvertOp/SRGB555.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/java2d/cmm/ColorConvertOp/SRGB565.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/java2d/cmm/ColorConvertOp/LRGB565.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/java2d/cmm/ColorConvertOp/CIEXYZ.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/java2d/cmm/ColorConvertOp/SRGB.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/java2d/cmm/ColorConvertOp/GRAY.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/java2d/cmm/ColorConvertOp/PYCC.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/java2d/cmm/ColorConvertOp/LRGB555.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/java2d/cmm/ColorConvertOp/LRGB.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/rsa/rsakeys.ks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/ssl/com/sun/net/ssl/internal/www/protocol/https/HttpsURLConnection/crisubn.jks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/ssl/com/sun/net/ssl/internal/www/protocol/https/HttpsURLConnection/trusted.jks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/provider/PolicyFile/Alias.keystore",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/provider/PolicyFile/TokenStore.keystore",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/provider/PolicyFile/TrustedCert.keystore",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/provider/PolicyFile/TrustedCert.keystore1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/provider/KeyStore/pw.jks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/provider/certpath/CertId/interCA.der",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/provider/PolicyParser/ExtDirsB/b.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/provider/PolicyParser/ExtDirsA/a.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/ec/pkcs12/secp256r1server-secp384r1ca.p12",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/ec/pkcs12/sect193r1server-rsa1024ca.p12",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/util/HostnameMatcher/cert1.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/util/HostnameMatcher/cert3.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/util/HostnameMatcher/cert2.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/util/HostnameMatcher/cert4.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/rsa/rsakeys.ks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/src/nss-3.16_nspr-4.10_src.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/nssdbm3.chk",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/softokn3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/nss3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/nssutil3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/libplc4.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/sqlite3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/nss3.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/ssl3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/libnspr4.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/nssutil3.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/freebl3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/ssl3.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/nssckbi.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/nssdbm3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/libplds4.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/libplds4.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/freebl3.chk",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/softokn3.chk",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/libnspr4.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-amd64/libplc4.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/nssdbm3.chk",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/softokn3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/nss3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/nssutil3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/libplc4.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/sqlite3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/nss3.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/ssl3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/libnspr4.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/nssutil3.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/freebl3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/ssl3.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/nssckbi.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/nssdbm3.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/libplds4.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/libplds4.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/freebl3.chk",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/softokn3.chk",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/libnspr4.lib",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/lib/windows-i586/libplc4.dll",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/db/cert8.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/db/secmod.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/nss/db/key3.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/Secmod/cert8.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/Secmod/keystore.jks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/Secmod/secmod.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/Secmod/key3.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/ec/pkcs12/secp256r1server-secp384r1ca.p12",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/ec/pkcs12/sect193r1server-rsa1024ca.p12",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/fips/cert8.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/fips/secmod.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/fips/key3.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/fips/certs/anchor.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/fips/certs/server.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/fips/certs/ca.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/loader.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/pk2.cert",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/pk1.cert2",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/pk1.cert",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/pk3.cert",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/ca.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/pk2.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/pk3.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/random.cert",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/basic.keystore",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/pk1.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/ca2.cert",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/BasicData/ca.cert",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/ClientAuthData/cert8.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/ClientAuthData/ibutton.cert",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/ClientAuthData/secmod.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/ClientAuthData/server.keystore",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/pkcs11/KeyStore/ClientAuthData/key3.db",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/mscapi/246810.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/tools/jarsigner/AlgOptions.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/tools/jarsigner/JarSigning_RU.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/tools/jarsigner/JarSigning.keystore",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/tools/jarsigner/JavaApplication1.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/tools/jarsigner/oldsig/A.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/tools/jarsigner/oldsig/A.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/tools/jarsigner/a%b/percent.keystore",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/tools/keytool/CloneKeyAskPassword.jks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/security/tools/keytool/SecretKeyKS.jks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/net/www/protocol/jar/resource.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/net/www/protocol/jar/foo2.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/net/www/protocol/jar/foo.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/net/www/protocol/jar/bar.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/net/www/protocol/jar/foo1.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/net/ftp/EncDec.doc",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/tools/jhat/hprof.bin",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/tools/jhat/jmap.bin",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/tools/jhat/minimal.bin",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/tools/native2ascii/A2N_4630463.expected",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/tools/native2ascii/A2N_4701617.expected",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/misc/Hello.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/misc/ClassLoaderUtil/test.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/sun/misc/URLClassPath/testclasses.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/com/sun/security/auth/module/KeyStoreLoginModule/OptionTest.keystore",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/com/sun/crypto/provider/Cipher/DES/PerformanceTest.java",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/management/loading/LibraryLoader/native.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/swing/text/html/TableView/7030332/sample3.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/swing/text/html/TableView/7030332/sample1.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/swing/text/html/TableView/7030332/sample0.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/swing/text/html/TableView/7030332/sample4.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/swing/text/html/TableView/7030332/sample2.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/swing/JSlider/4987336/box.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/swing/JSlider/4987336/cupanim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/swing/plaf/synth/SynthButtonUI/6276188/red.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/imageio/plugins/jpeg/nomarkers.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/imageio/plugins/jpeg/truncated.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/ws/8043129/javax.mail.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/macha.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/user.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/balor.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/nemain.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/lugh.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/ca.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/bres.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/xmldsig.jks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/badb.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/morigu.crt",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/xml/crypto/dsig/data/certs/test.jks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/crypto/SecretKeyFactory/P2.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/crypto/SecretKeyFactory/P1.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/sound/midi/Gervill/SoftSynthesizer/expresso.mid",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/sound/midi/Gervill/SoftSynthesizer/ding.sf2",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/sound/midi/Gervill/SF2SoundbankReader/ding.sf2",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/sound/midi/Gervill/DLSSoundbankReader/ding.dls",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/javax/naming/Name/j2se13-name.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/tools/launcher/UnicodeTest.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/tools/pack200/badattr.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/tools/pack200/pack200-verifier/data/golden.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/io/Externalizable/compatibility/old.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/io/Serializable/classDescFlagConflict/Foo.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/io/Serializable/longString/mesg.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/io/Serializable/illegalHandle/negativeHandle.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/io/Serializable/illegalHandle/tooHighHandle.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/io/Serializable/classDescHooks/Foo.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/io/Serializable/maskSyntheticModifier/Foo.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/beans/PropertyChangeSupport/1.6.0.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/beans/PropertyChangeSupport/1.5.0_10.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/beans/XMLDecoder/4676532/test.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/beans/VetoableChangeSupport/1.6.0.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/beans/VetoableChangeSupport/1.5.0_10.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/beans/Introspector/7064279/test.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/ResourceBundle/awtres.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/PluggableLocale/barprovider.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/PluggableLocale/fooprovider.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/spi/ResourceBundleControlProvider/rbcontrolprovider.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/Locale/Bug4175998Test.java",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/Locale/data/deflocale.rhel5.fmtasdefault",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/Locale/data/deflocale.win7.fmtasdefault",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/Locale/data/deflocale.win7",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/Locale/data/deflocale.rhel5",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/jar/JarFile/test.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/jar/JarFile/thawjar.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/jar/JarFile/bogus-signerinfo-attr.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/jar/JarFile/Signed.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/jar/JarFile/no-manifest.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/jar/JarInputStream/BadSignedJar.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/jar/JarInputStream/signed.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/jar/JarEntry/test.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/zip/test.zip",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/zip/input.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/zip/pkware123456789012345.zip",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/zip/ZipEntry/input.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/zip/ZipFile/input.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/zip/ZipFile/crash.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/util/zip/ZipFile/input.zip",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/ProtectionDomain/AllPerm.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/Security/signedfirst/keystore.jks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/Security/signedfirst/exp.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/Security/ClassLoaderDeadlock/Deadlock.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/SecureRandom/sha1prng-old.bin",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/SecureRandom/sha1prng-new.bin",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/BasicPermission/SerialVersion.1.3.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/BasicPermission/PermClass.1.4",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/BasicPermission/PermClass.1.3.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/BasicPermission/SerialVersion.1.4",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/BasicPermission/PermClass.1.2.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/BasicPermission/SerialVersion.1.2.1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/UnresolvedPermission/AccessorMethods.signer2",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/UnresolvedPermission/AccessorMethods.ca",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/UnresolvedPermission/AccessorMethods.signer1",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyStore/EntryMethods.pre15.keystore",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyStore/keystore.jks",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/HmacSHA1.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/DSA.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/HmacMD5.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/RSA.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/PBE.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/AES.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/RSA.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/DES.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/Blowfish.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/DH.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/DSA.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/DESede.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/KeyRep/RC5.pre.1.5.key",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/CertPathBuilder/targetConstraints/sun.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/pkix/nameConstraintsMinMax/sun2labs2.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/pkix/nameConstraintsMinMax/labs2isrg2.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/pkix/nameConstraintsMinMax/sun.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/CertPathValidatorException/jdk6.serial",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/CertPathValidator/targetConstraints/sun2labs1.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/CertPathValidator/targetConstraints/sun.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/CertPathValidator/nameConstraintsRFC822/jane2jane.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/CertPathValidator/nameConstraintsRFC822/steve2tom.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/CertPathValidator/nameConstraintsRFC822/jane2steve.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/CertPathValidator/trustAnchor/sun2labs2.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/security/cert/CertPathValidator/trustAnchor/labs2isrg2.cer",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/instrument/PremainClass/Agent.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/ClassLoader/resource.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/ClassLoader/findSystemClass/Loadee.classfile",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/EnumPoseur.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/forName/classes/3.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/forName/classes/period.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/forName/classes/Z.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/forName/classes/comma.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/forName/classes/plus.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/forName/classes/left-square.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/forName/classes/semicolon.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/forName/classes/0.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/forName/classes/hyphen.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/lang/Class/forName/classes/right-square.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/awt/print/PrinterJob/duke.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/awt/FontClass/CreateFont/A.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/ResponseCache/file1.cache",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/Inet6Address/serialize/serial1.4.2.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/Inet6Address/serialize/serial-bge0.ser",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/Socket/OldSocketImpl.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/URLConnection/olympus.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/URLConnection/jars/test.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/URLConnection/6212146/test.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/URLClassLoader/sealing/b.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/URLClassLoader/extdir/extention.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/URLClassLoader/jars/class_path_test.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/URLClassLoader/jars/class_path_test_classpath.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jdk_src/test/java/net/URLClassLoader/getresourceasstream/test.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/jaxp_src/src/com/sun/org/apache/xml/internal/serializer/Encodings.properties",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/com/sun/javadoc/testBadPackageFileInJar/badPackageFileInJar.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/Source5.java",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/InnerClassesAttribute/Outside.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/InnerClassesAttribute/Outside$1$Inside.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/6302184/T6302184.java",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/6302184/T6302184.out",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/completion/example/B.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/T5090006/broken.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/missingSuperRecovery/impl.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/6547131/p/Outer$I.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/6547131/p/Outer.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/T6435291/T.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javac/unicode/Unmappable.java",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/langtools_src/test/tools/javadoc/sourceOnly/p/NonSource.class",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/diff.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/structured.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/save.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/graph.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/folder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/saveall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/import.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/structure.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/remove.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/removeall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Settings/src/com/sun/hotspot/igv/settings/settings.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/extract.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/prev_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/hide.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/zoomin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/next_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/blocks.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/overview.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/predsucc.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/export.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/zoomout.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/search.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/delete.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/add.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/branding/core/core.jar/org/netbeans/core/startup/frame.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/branding/core/core.jar/org/netbeans/core/startup/splash.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Bytecodes/src/com/sun/hotspot/igv/bytecodes/images/bytecode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Bytecodes/src/com/sun/hotspot/igv/bytecodes/images/link.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/src/share/tools/IdealGraphVisualizer/Bytecodes/src/com/sun/hotspot/igv/bytecodes/images/method.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/test/runtime/classFileParserBug/emptynumbootstrapmethods.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/test/runtime/7116786/testcases.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/test/runtime/ClassFile/JsrRewritingTestCase.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/test/runtime/ClassFile/testcase.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/sun/jvm/hotspot/ui/resources/breakpoint.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/sun/jvm/hotspot/ui/resources/arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/sun/jvm/hotspot/ui/resources/triangle.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignCenter24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignRight16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignLeft16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignLeft24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignRight24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignCenter16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Open16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Help16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/SaveAs24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/About24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/ZoomIn16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Help24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Save24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Delete24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/SaveAs16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/New16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Find16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/ZoomIn24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/About16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Information16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Save16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Information24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Delete16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/History16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/History24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/New24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Open24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Zoom16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/development/Server16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/development/Server24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/navigation/Up16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/shenandoah_src/agent/src/share/classes/images/toolbarButtonGraphics/navigation/Down16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/tool/i18n.properties",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/tool/images/jtlogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/tool/images/jticon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/tool/images/splash.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/audit/images/dotdotdot.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/mrep/images/dotdotdot.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/mrep/images/Back16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/mrep/images/Home16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/mrep/images/Forward16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Preferences16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Help16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Up16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/SaveAs24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/UpDir.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/question.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/FindAgain24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/snooze.sm.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Pause24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Preferences24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Down16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Down24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Back24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/FastForward16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Help24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Play24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Last16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Dir.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Pause16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/stream.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Back16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Home16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Save24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/drop-down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Forward16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/SaveAs16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Forward24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Find16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Edit24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/fullView.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/stdView.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Stop24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/magnify.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/FindAgain16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Save16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Play16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Find24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Print16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Print24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Stop16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Edit16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Home24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/exec/images/Up24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/javatest/agent/jticon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/interview/wizard/back.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/interview/wizard/next.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/interview/wizard/done.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/interview/wizard/blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/interview/wizard/history.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/interview/wizard/find.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/interview/wizard/cancel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/interview/wizard/arrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/interview/wizard/info.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/test/jtreg/com/sun/interview/wizard/check.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/overlays/openjdk/jdk/test/closed/sun/security/rsa/keystore.bad",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/overlays/openjdk/jdk/test/closed/sun/security/rsa/keystore.good",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/overlays/openjdk/jdk/test/com/sun/media/sound/SoftSynthesizer/expresso.mid",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/overlays/openjdk/jdk/test/com/sun/media/sound/SoftSynthesizer/ding.sf2",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/overlays/openjdk/jdk/test/com/sun/media/sound/SF2SoundbankReader/ding.sf2",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/overlays/openjdk/jdk/test/com/sun/media/sound/DLSSoundbankReader/ding.dls",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/test/script/jfx/flyingimage/flyingimage.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/test/script/jfx/flyingimage/golden/windows.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/test/script/jfx/flyingimage/golden/linux.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/test/script/jfx/flyingimage/golden/macosx.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/test/script/jfx/kaleidoscope/golden/windows.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/test/script/jfx/kaleidoscope/golden/linux.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/test/script/jfx/kaleidoscope/golden/macosx.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/test/script/jfx/spread/golden/windows.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/test/script/jfx/spread/golden/linux.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/test/script/jfx/spread/golden/macosx.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/nashorn_src/docs/JavaScriptingProgrammersGuide.html",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/diff.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/structured.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/save.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/graph.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/folder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/saveall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/import.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/structure.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/remove.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Coordinator/src/com/sun/hotspot/igv/coordinator/images/removeall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Settings/src/com/sun/hotspot/igv/settings/settings.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/extract.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/prev_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/hide.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/zoomin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/next_diagram.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/blocks.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/overview.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/predsucc.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/export.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/zoomout.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/search.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/View/src/com/sun/hotspot/igv/view/images/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/delete.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/add.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/FilterWindow/src/com/sun/hotspot/igv/filterwindow/images/down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/branding/core/core.jar/org/netbeans/core/startup/frame.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/branding/core/core.jar/org/netbeans/core/startup/splash.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Bytecodes/src/com/sun/hotspot/igv/bytecodes/images/bytecode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Bytecodes/src/com/sun/hotspot/igv/bytecodes/images/link.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/src/share/tools/IdealGraphVisualizer/Bytecodes/src/com/sun/hotspot/igv/bytecodes/images/method.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/test/runtime/classFileParserBug/emptynumbootstrapmethods.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/test/runtime/7116786/testcases.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/test/runtime/ClassFile/JsrRewritingTestCase.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/test/runtime/ClassFile/testcase.jar",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/sun/jvm/hotspot/ui/resources/breakpoint.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/sun/jvm/hotspot/ui/resources/arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/sun/jvm/hotspot/ui/resources/triangle.png",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignCenter24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignRight16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignLeft16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignLeft24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignRight24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/text/AlignCenter16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Open16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Help16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/SaveAs24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/About24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/ZoomIn16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Help24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Save24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Delete24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/SaveAs16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/New16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Find16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/ZoomIn24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/About16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Information16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Save16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Information24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Delete16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/History16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/History24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/New24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Open24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/general/Zoom16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/development/Server16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/development/Server24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/navigation/Up16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.4.0-fjlgts57l5vn2dx3hkthfoz7st3iiz54/spack-src/hotspot_src/agent/src/share/classes/images/toolbarButtonGraphics/navigation/Down16.gif"
    ],
    "total_files": 50289
}