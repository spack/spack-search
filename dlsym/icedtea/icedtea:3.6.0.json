{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/patches/hotspot/aarch32/8175813-pr3394-rh1448880.patch": "# HG changeset patch\n# User gromero\n# Date 1496364169 14400\n#      Thu Jun 01 20:42:49 2017 -0400\n# Node ID 4dc64f3c3e2342970f091a1a73165a3e2a0c2f88\n# Parent  d77ea5a8ca52f04fc087ea2785ed4087ff630806\n8175813, PR3394, RH1448880: PPC64: \"mbind: Invalid argument\" when -XX:+UseNUMA is used\nReviewed-by: dholmes, zgu\n\ndiff -r d77ea5a8ca52 -r 4dc64f3c3e23 src/os/linux/vm/os_linux.cpp\n--- openjdk/hotspot/src/os/linux/vm/os_linux.cpp\n+++ openjdk/hotspot/src/os/linux/vm/os_linux.cpp\n@@ -2747,8 +2747,9 @@\n bool os::numa_topology_changed()   { return false; }\n \n size_t os::numa_get_groups_num() {\n-  int max_node = Linux::numa_max_node();\n-  return max_node > 0 ? max_node + 1 : 1;\n+  // Return just the number of nodes in which it's possible to allocate memory\n+  // (in numa terminology, configured nodes).\n+  return Linux::numa_num_configured_nodes();\n }\n \n int os::numa_get_group_id() {\n@@ -2762,11 +2763,33 @@\n   return 0;\n }\n \n+int os::Linux::get_existing_num_nodes() {\n+  size_t node;\n+  size_t highest_node_number = Linux::numa_max_node();\n+  int num_nodes = 0;\n+\n+  // Get the total number of nodes in the system including nodes without memory.\n+  for (node = 0; node <= highest_node_number; node++) {\n+    if (isnode_in_existing_nodes(node)) {\n+      num_nodes++;\n+    }\n+  }\n+  return num_nodes;\n+}\n+\n size_t os::numa_get_leaf_groups(int *ids, size_t size) {\n-  for (size_t i = 0; i < size; i++) {\n-    ids[i] = i;\n-  }\n-  return size;\n+  size_t highest_node_number = Linux::numa_max_node();\n+  size_t i = 0;\n+\n+  // Map all node ids in which is possible to allocate memory. Also nodes are\n+  // not always consecutively available, i.e. available from 0 to the highest\n+  // node number.\n+  for (size_t node = 0; node <= highest_node_number; node++) {\n+    if (Linux::isnode_in_configured_nodes(node)) {\n+      ids[i++] = node;\n+    }\n+  }\n+  return i;\n }\n \n bool os::get_page_info(char *start, page_info* info) {\n@@ -2836,18 +2859,28 @@\n                                            libnuma_dlsym(handle, \"numa_node_to_cpus\")));\n       set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,\n                                        libnuma_dlsym(handle, \"numa_max_node\")));\n+      set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,\n+                                                   libnuma_dlsym(handle, \"numa_num_configured_nodes\")));\n       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,\n                                         libnuma_dlsym(handle, \"numa_available\")));\n       set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,\n                                             libnuma_dlsym(handle, \"numa_tonode_memory\")));\n       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,\n-                                            libnuma_dlsym(handle, \"numa_interleave_memory\")));\n+                                                libnuma_dlsym(handle, \"numa_interleave_memory\")));\n       set_numa_set_bind_policy(CAST_TO_FN_PTR(numa_set_bind_policy_func_t,\n-                                            libnuma_dlsym(handle, \"numa_set_bind_policy\")));\n-\n+                                              libnuma_dlsym(handle, \"numa_set_bind_policy\")));\n+      set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,\n+                                               libnuma_dlsym(handle, \"numa_bitmask_isbitset\")));\n+      set_numa_distance(CAST_TO_FN_PTR(numa_distance_func_t,\n+                                       libnuma_dlsym(handle, \"numa_distance\")));\n \n       if (numa_available() != -1) {\n         set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, \"numa_all_nodes\"));\n+        set_numa_all_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, \"numa_all_nodes_ptr\"));\n+        set_numa_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, \"numa_nodes_ptr\"));\n+        // Create an index -> node mapping, since nodes are not always consecutive\n+        _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, true);\n+        rebuild_nindex_to_node_map();\n         // Create a cpu -> node mapping\n         _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, true);\n         rebuild_cpu_to_node_map();\n@@ -2858,6 +2891,17 @@\n   return false;\n }\n \n+void os::Linux::rebuild_nindex_to_node_map() {\n+  int highest_node_number = Linux::numa_max_node();\n+\n+  nindex_to_node()->clear();\n+  for (int node = 0; node <= highest_node_number; node++) {\n+    if (Linux::isnode_in_existing_nodes(node)) {\n+      nindex_to_node()->append(node);\n+    }\n+  }\n+}\n+\n // rebuild_cpu_to_node_map() constructs a table mapping cpud id to node id.\n // The table is later used in get_node_by_cpu().\n void os::Linux::rebuild_cpu_to_node_map() {\n@@ -2877,16 +2921,46 @@\n \n   cpu_to_node()->clear();\n   cpu_to_node()->at_grow(cpu_num - 1);\n-  size_t node_num = numa_get_groups_num();\n-\n+\n+  size_t node_num = get_existing_num_nodes();\n+\n+  int distance = 0;\n+  int closest_distance = INT_MAX;\n+  int closest_node = 0;\n   unsigned long *cpu_map = NEW_C_HEAP_ARRAY(unsigned long, cpu_map_size, mtInternal);\n   for (size_t i = 0; i < node_num; i++) {\n-    if (numa_node_to_cpus(i, cpu_map, cpu_map_size * sizeof(unsigned long)) != -1) {\n+    // Check if node is configured (not a memory-less node). If it is not, find\n+    // the closest configured node.\n+    if (!isnode_in_configured_nodes(nindex_to_node()->at(i))) {\n+      closest_distance = INT_MAX;\n+      // Check distance from all remaining nodes in the system. Ignore distance\n+      // from itself and from another non-configured node.\n+      for (size_t m = 0; m < node_num; m++) {\n+        if (m != i && isnode_in_configured_nodes(nindex_to_node()->at(m))) {\n+          distance = numa_distance(nindex_to_node()->at(i), nindex_to_node()->at(m));\n+          // If a closest node is found, update. There is always at least one\n+          // configured node in the system so there is always at least one node\n+          // close.\n+          if (distance != 0 && distance < closest_distance) {\n+            closest_distance = distance;\n+            closest_node = nindex_to_node()->at(m);\n+          }\n+        }\n+      }\n+     } else {\n+       // Current node is already a configured node.\n+       closest_node = nindex_to_node()->at(i);\n+     }\n+\n+    // Get cpus from the original node and map them to the closest node. If node\n+    // is a configured node (not a memory-less node), then original node and\n+    // closest node are the same.\n+    if (numa_node_to_cpus(nindex_to_node()->at(i), cpu_map, cpu_map_size * sizeof(unsigned long)) != -1) {\n       for (size_t j = 0; j < cpu_map_valid_size; j++) {\n         if (cpu_map[j] != 0) {\n           for (size_t k = 0; k < BitsPerCLong; k++) {\n             if (cpu_map[j] & (1UL << k)) {\n-              cpu_to_node()->at_put(j * BitsPerCLong + k, i);\n+              cpu_to_node()->at_put(j * BitsPerCLong + k, closest_node);\n             }\n           }\n         }\n@@ -2904,14 +2978,20 @@\n }\n \n GrowableArray<int>* os::Linux::_cpu_to_node;\n+GrowableArray<int>* os::Linux::_nindex_to_node;\n os::Linux::sched_getcpu_func_t os::Linux::_sched_getcpu;\n os::Linux::numa_node_to_cpus_func_t os::Linux::_numa_node_to_cpus;\n os::Linux::numa_max_node_func_t os::Linux::_numa_max_node;\n+os::Linux::numa_num_configured_nodes_func_t os::Linux::_numa_num_configured_nodes;\n os::Linux::numa_available_func_t os::Linux::_numa_available;\n os::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;\n os::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;\n os::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;\n+os::Linux::numa_bitmask_isbitset_func_t os::Linux::_numa_bitmask_isbitset;\n+os::Linux::numa_distance_func_t os::Linux::_numa_distance;\n unsigned long* os::Linux::_numa_all_nodes;\n+struct bitmask* os::Linux::_numa_all_nodes_ptr;\n+struct bitmask* os::Linux::_numa_nodes_ptr;\n \n bool os::pd_uncommit_memory(char* addr, size_t size) {\n   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,\ndiff -r d77ea5a8ca52 -r 4dc64f3c3e23 src/os/linux/vm/os_linux.hpp\n--- openjdk/hotspot/src/os/linux/vm/os_linux.hpp\n+++ openjdk/hotspot/src/os/linux/vm/os_linux.hpp\n@@ -67,6 +67,7 @@\n   static bool _supports_fast_thread_cpu_time;\n \n   static GrowableArray<int>* _cpu_to_node;\n+  static GrowableArray<int>* _nindex_to_node;\n \n  protected:\n \n@@ -94,7 +95,9 @@\n   static void set_is_floating_stack()         { _is_floating_stack = true; }\n \n   static void rebuild_cpu_to_node_map();\n+  static void rebuild_nindex_to_node_map();\n   static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }\n+  static GrowableArray<int>* nindex_to_node()  { return _nindex_to_node; }\n \n   static size_t find_large_page_size();\n   static size_t setup_large_page_size();\n@@ -243,28 +246,41 @@\n   typedef int (*sched_getcpu_func_t)(void);\n   typedef int (*numa_node_to_cpus_func_t)(int node, unsigned long *buffer, int bufferlen);\n   typedef int (*numa_max_node_func_t)(void);\n+  typedef int (*numa_num_configured_nodes_func_t)(void);\n   typedef int (*numa_available_func_t)(void);\n   typedef int (*numa_tonode_memory_func_t)(void *start, size_t size, int node);\n   typedef void (*numa_interleave_memory_func_t)(void *start, size_t size, unsigned long *nodemask);\n   typedef void (*numa_set_bind_policy_func_t)(int policy);\n+  typedef int (*numa_bitmask_isbitset_func_t)(struct bitmask *bmp, unsigned int n);\n+  typedef int (*numa_distance_func_t)(int node1, int node2);\n \n   static sched_getcpu_func_t _sched_getcpu;\n   static numa_node_to_cpus_func_t _numa_node_to_cpus;\n   static numa_max_node_func_t _numa_max_node;\n+  static numa_num_configured_nodes_func_t _numa_num_configured_nodes;\n   static numa_available_func_t _numa_available;\n   static numa_tonode_memory_func_t _numa_tonode_memory;\n   static numa_interleave_memory_func_t _numa_interleave_memory;\n   static numa_set_bind_policy_func_t _numa_set_bind_policy;\n+  static numa_bitmask_isbitset_func_t _numa_bitmask_isbitset;\n+  static numa_distance_func_t _numa_distance;\n   static unsigned long* _numa_all_nodes;\n+  static struct bitmask* _numa_all_nodes_ptr;\n+  static struct bitmask* _numa_nodes_ptr;\n \n   static void set_sched_getcpu(sched_getcpu_func_t func) { _sched_getcpu = func; }\n   static void set_numa_node_to_cpus(numa_node_to_cpus_func_t func) { _numa_node_to_cpus = func; }\n   static void set_numa_max_node(numa_max_node_func_t func) { _numa_max_node = func; }\n+  static void set_numa_num_configured_nodes(numa_num_configured_nodes_func_t func) { _numa_num_configured_nodes = func; }\n   static void set_numa_available(numa_available_func_t func) { _numa_available = func; }\n   static void set_numa_tonode_memory(numa_tonode_memory_func_t func) { _numa_tonode_memory = func; }\n   static void set_numa_interleave_memory(numa_interleave_memory_func_t func) { _numa_interleave_memory = func; }\n   static void set_numa_set_bind_policy(numa_set_bind_policy_func_t func) { _numa_set_bind_policy = func; }\n+  static void set_numa_bitmask_isbitset(numa_bitmask_isbitset_func_t func) { _numa_bitmask_isbitset = func; }\n+  static void set_numa_distance(numa_distance_func_t func) { _numa_distance = func; }\n   static void set_numa_all_nodes(unsigned long* ptr) { _numa_all_nodes = ptr; }\n+  static void set_numa_all_nodes_ptr(struct bitmask **ptr) { _numa_all_nodes_ptr = *ptr; }\n+  static void set_numa_nodes_ptr(struct bitmask **ptr) { _numa_nodes_ptr = *ptr; }\n   static int sched_getcpu_syscall(void);\n public:\n   static int sched_getcpu()  { return _sched_getcpu != NULL ? _sched_getcpu() : -1; }\n@@ -272,6 +288,9 @@\n     return _numa_node_to_cpus != NULL ? _numa_node_to_cpus(node, buffer, bufferlen) : -1;\n   }\n   static int numa_max_node() { return _numa_max_node != NULL ? _numa_max_node() : -1; }\n+  static int numa_num_configured_nodes() {\n+    return _numa_num_configured_nodes != NULL ? _numa_num_configured_nodes() : -1;\n+  }\n   static int numa_available() { return _numa_available != NULL ? _numa_available() : -1; }\n   static int numa_tonode_memory(void *start, size_t size, int node) {\n     return _numa_tonode_memory != NULL ? _numa_tonode_memory(start, size, node) : -1;\n@@ -286,7 +305,25 @@\n       _numa_set_bind_policy(policy);\n     }\n   }\n+  static int numa_distance(int node1, int node2) {\n+    return _numa_distance != NULL ? _numa_distance(node1, node2) : -1;\n+  }\n   static int get_node_by_cpu(int cpu_id);\n+  static int get_existing_num_nodes();\n+  // Check if numa node is configured (non-zero memory node).\n+  static bool isnode_in_configured_nodes(unsigned int n) {\n+    if (_numa_bitmask_isbitset != NULL && _numa_all_nodes_ptr != NULL) {\n+      return _numa_bitmask_isbitset(_numa_all_nodes_ptr, n);\n+    } else\n+      return 0;\n+  }\n+  // Check if numa node exists in the system (including zero memory nodes).\n+  static bool isnode_in_existing_nodes(unsigned int n) {\n+    if (_numa_bitmask_isbitset != NULL && _numa_nodes_ptr != NULL) {\n+      return _numa_bitmask_isbitset(_numa_nodes_ptr, n);\n+    } else\n+      return 0;\n+  }\n };\n \n \n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/patches/hotspot/aarch32/8181055-pr3394-rh1448880.patch": "diff -Nru openjdk.orig/hotspot/src/os/linux/vm/os_linux.cpp openjdk/hotspot/src/os/linux/vm/os_linux.cpp\n--- openjdk.orig/hotspot/src/os/linux/vm/os_linux.cpp\t2017-07-07 02:39:53.074767403 +0100\n+++ openjdk/hotspot/src/os/linux/vm/os_linux.cpp\t2017-07-07 02:41:44.196961739 +0100\n@@ -2827,11 +2827,8 @@\n extern \"C\" JNIEXPORT void numa_error(char *where) { }\n extern \"C\" JNIEXPORT int fork1() { return fork(); }\n \n-\n-// If we are running with libnuma version > 2, then we should\n-// be trying to use symbols with versions 1.1\n-// If we are running with earlier version, which did not have symbol versions,\n-// we should use the base version.\n+// Handle request to load libnuma symbol version 1.1 (API v1). If it fails\n+// load symbol from base version instead.\n void* os::Linux::libnuma_dlsym(void* handle, const char *name) {\n #ifndef __UCLIBC__\n   void *f = dlvsym(handle, name, \"libnuma_1.1\");\n@@ -2844,6 +2841,12 @@\n #endif\n }\n \n+// Handle request to load libnuma symbol version 1.2 (API v2) only.\n+// Return NULL if the symbol is not defined in this particular version.\n+void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {\n+  return dlvsym(handle, name, \"libnuma_1.2\");\n+}\n+\n bool os::Linux::libnuma_init() {\n   // sched_getcpu() should be in libc.\n   set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,\n@@ -2868,6 +2871,8 @@\n                                             libnuma_dlsym(handle, \"numa_tonode_memory\")));\n       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,\n                                                 libnuma_dlsym(handle, \"numa_interleave_memory\")));\n+      set_numa_interleave_memory_v2(CAST_TO_FN_PTR(numa_interleave_memory_v2_func_t,\n+                                                libnuma_v2_dlsym(handle, \"numa_interleave_memory\")));\n       set_numa_set_bind_policy(CAST_TO_FN_PTR(numa_set_bind_policy_func_t,\n                                               libnuma_dlsym(handle, \"numa_set_bind_policy\")));\n       set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,\n@@ -2987,6 +2992,7 @@\n os::Linux::numa_available_func_t os::Linux::_numa_available;\n os::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;\n os::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;\n+os::Linux::numa_interleave_memory_v2_func_t os::Linux::_numa_interleave_memory_v2;\n os::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;\n os::Linux::numa_bitmask_isbitset_func_t os::Linux::_numa_bitmask_isbitset;\n os::Linux::numa_distance_func_t os::Linux::_numa_distance;\ndiff -Nru openjdk.orig/hotspot/src/os/linux/vm/os_linux.hpp openjdk/hotspot/src/os/linux/vm/os_linux.hpp\n--- openjdk.orig/hotspot/src/os/linux/vm/os_linux.hpp\t2017-07-07 02:39:53.074767403 +0100\n+++ openjdk/hotspot/src/os/linux/vm/os_linux.hpp\t2017-07-07 02:41:03.353625308 +0100\n@@ -192,6 +192,8 @@\n   static void libpthread_init();\n   static bool libnuma_init();\n   static void* libnuma_dlsym(void* handle, const char* name);\n+  // libnuma v2 (libnuma_1.2) symbols\n+  static void* libnuma_v2_dlsym(void* handle, const char* name);\n   // Minimum stack size a thread can be created with (allowing\n   // the VM to completely create the thread and enter user code)\n   static size_t min_stack_allowed;\n@@ -252,6 +254,8 @@\n   typedef int (*numa_available_func_t)(void);\n   typedef int (*numa_tonode_memory_func_t)(void *start, size_t size, int node);\n   typedef void (*numa_interleave_memory_func_t)(void *start, size_t size, unsigned long *nodemask);\n+  typedef void (*numa_interleave_memory_v2_func_t)(void *start, size_t size, struct bitmask* mask);\n+\n   typedef void (*numa_set_bind_policy_func_t)(int policy);\n   typedef int (*numa_bitmask_isbitset_func_t)(struct bitmask *bmp, unsigned int n);\n   typedef int (*numa_distance_func_t)(int node1, int node2);\n@@ -263,6 +267,7 @@\n   static numa_available_func_t _numa_available;\n   static numa_tonode_memory_func_t _numa_tonode_memory;\n   static numa_interleave_memory_func_t _numa_interleave_memory;\n+  static numa_interleave_memory_v2_func_t _numa_interleave_memory_v2;\n   static numa_set_bind_policy_func_t _numa_set_bind_policy;\n   static numa_bitmask_isbitset_func_t _numa_bitmask_isbitset;\n   static numa_distance_func_t _numa_distance;\n@@ -277,6 +282,7 @@\n   static void set_numa_available(numa_available_func_t func) { _numa_available = func; }\n   static void set_numa_tonode_memory(numa_tonode_memory_func_t func) { _numa_tonode_memory = func; }\n   static void set_numa_interleave_memory(numa_interleave_memory_func_t func) { _numa_interleave_memory = func; }\n+  static void set_numa_interleave_memory_v2(numa_interleave_memory_v2_func_t func) { _numa_interleave_memory_v2 = func; }\n   static void set_numa_set_bind_policy(numa_set_bind_policy_func_t func) { _numa_set_bind_policy = func; }\n   static void set_numa_bitmask_isbitset(numa_bitmask_isbitset_func_t func) { _numa_bitmask_isbitset = func; }\n   static void set_numa_distance(numa_distance_func_t func) { _numa_distance = func; }\n@@ -298,7 +304,10 @@\n     return _numa_tonode_memory != NULL ? _numa_tonode_memory(start, size, node) : -1;\n   }\n   static void numa_interleave_memory(void *start, size_t size) {\n-    if (_numa_interleave_memory != NULL && _numa_all_nodes != NULL) {\n+    // Use v2 api if available\n+    if (_numa_interleave_memory_v2 != NULL && _numa_all_nodes_ptr != NULL) {\n+      _numa_interleave_memory_v2(start, size, _numa_all_nodes_ptr);\n+    } else if (_numa_interleave_memory != NULL && _numa_all_nodes != NULL) {\n       _numa_interleave_memory(start, size, _numa_all_nodes);\n     }\n   }\n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/patches/hotspot/shenandoah/8175813-pr3394-rh1448880.patch": "# HG changeset patch\n# User gromero\n# Date 1496364169 14400\n#      Thu Jun 01 20:42:49 2017 -0400\n# Node ID 4dc64f3c3e2342970f091a1a73165a3e2a0c2f88\n# Parent  d77ea5a8ca52f04fc087ea2785ed4087ff630806\n8175813, PR3394, RH1448880: PPC64: \"mbind: Invalid argument\" when -XX:+UseNUMA is used\nReviewed-by: dholmes, zgu\n\ndiff -r d77ea5a8ca52 -r 4dc64f3c3e23 src/os/linux/vm/os_linux.cpp\n--- openjdk/hotspot/src/os/linux/vm/os_linux.cpp\n+++ openjdk/hotspot/src/os/linux/vm/os_linux.cpp\n@@ -2747,8 +2747,9 @@\n bool os::numa_topology_changed()   { return false; }\n \n size_t os::numa_get_groups_num() {\n-  int max_node = Linux::numa_max_node();\n-  return max_node > 0 ? max_node + 1 : 1;\n+  // Return just the number of nodes in which it's possible to allocate memory\n+  // (in numa terminology, configured nodes).\n+  return Linux::numa_num_configured_nodes();\n }\n \n int os::numa_get_group_id() {\n@@ -2762,11 +2763,33 @@\n   return 0;\n }\n \n+int os::Linux::get_existing_num_nodes() {\n+  size_t node;\n+  size_t highest_node_number = Linux::numa_max_node();\n+  int num_nodes = 0;\n+\n+  // Get the total number of nodes in the system including nodes without memory.\n+  for (node = 0; node <= highest_node_number; node++) {\n+    if (isnode_in_existing_nodes(node)) {\n+      num_nodes++;\n+    }\n+  }\n+  return num_nodes;\n+}\n+\n size_t os::numa_get_leaf_groups(int *ids, size_t size) {\n-  for (size_t i = 0; i < size; i++) {\n-    ids[i] = i;\n-  }\n-  return size;\n+  size_t highest_node_number = Linux::numa_max_node();\n+  size_t i = 0;\n+\n+  // Map all node ids in which is possible to allocate memory. Also nodes are\n+  // not always consecutively available, i.e. available from 0 to the highest\n+  // node number.\n+  for (size_t node = 0; node <= highest_node_number; node++) {\n+    if (Linux::isnode_in_configured_nodes(node)) {\n+      ids[i++] = node;\n+    }\n+  }\n+  return i;\n }\n \n bool os::get_page_info(char *start, page_info* info) {\n@@ -2836,18 +2859,28 @@\n                                            libnuma_dlsym(handle, \"numa_node_to_cpus\")));\n       set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,\n                                        libnuma_dlsym(handle, \"numa_max_node\")));\n+      set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,\n+                                                   libnuma_dlsym(handle, \"numa_num_configured_nodes\")));\n       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,\n                                         libnuma_dlsym(handle, \"numa_available\")));\n       set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,\n                                             libnuma_dlsym(handle, \"numa_tonode_memory\")));\n       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,\n-                                            libnuma_dlsym(handle, \"numa_interleave_memory\")));\n+                                                libnuma_dlsym(handle, \"numa_interleave_memory\")));\n       set_numa_set_bind_policy(CAST_TO_FN_PTR(numa_set_bind_policy_func_t,\n-                                            libnuma_dlsym(handle, \"numa_set_bind_policy\")));\n-\n+                                              libnuma_dlsym(handle, \"numa_set_bind_policy\")));\n+      set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,\n+                                               libnuma_dlsym(handle, \"numa_bitmask_isbitset\")));\n+      set_numa_distance(CAST_TO_FN_PTR(numa_distance_func_t,\n+                                       libnuma_dlsym(handle, \"numa_distance\")));\n \n       if (numa_available() != -1) {\n         set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, \"numa_all_nodes\"));\n+        set_numa_all_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, \"numa_all_nodes_ptr\"));\n+        set_numa_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, \"numa_nodes_ptr\"));\n+        // Create an index -> node mapping, since nodes are not always consecutive\n+        _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, true);\n+        rebuild_nindex_to_node_map();\n         // Create a cpu -> node mapping\n         _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, true);\n         rebuild_cpu_to_node_map();\n@@ -2858,6 +2891,17 @@\n   return false;\n }\n \n+void os::Linux::rebuild_nindex_to_node_map() {\n+  int highest_node_number = Linux::numa_max_node();\n+\n+  nindex_to_node()->clear();\n+  for (int node = 0; node <= highest_node_number; node++) {\n+    if (Linux::isnode_in_existing_nodes(node)) {\n+      nindex_to_node()->append(node);\n+    }\n+  }\n+}\n+\n // rebuild_cpu_to_node_map() constructs a table mapping cpud id to node id.\n // The table is later used in get_node_by_cpu().\n void os::Linux::rebuild_cpu_to_node_map() {\n@@ -2877,16 +2921,46 @@\n \n   cpu_to_node()->clear();\n   cpu_to_node()->at_grow(cpu_num - 1);\n-  size_t node_num = numa_get_groups_num();\n-\n+\n+  size_t node_num = get_existing_num_nodes();\n+\n+  int distance = 0;\n+  int closest_distance = INT_MAX;\n+  int closest_node = 0;\n   unsigned long *cpu_map = NEW_C_HEAP_ARRAY(unsigned long, cpu_map_size, mtInternal);\n   for (size_t i = 0; i < node_num; i++) {\n-    if (numa_node_to_cpus(i, cpu_map, cpu_map_size * sizeof(unsigned long)) != -1) {\n+    // Check if node is configured (not a memory-less node). If it is not, find\n+    // the closest configured node.\n+    if (!isnode_in_configured_nodes(nindex_to_node()->at(i))) {\n+      closest_distance = INT_MAX;\n+      // Check distance from all remaining nodes in the system. Ignore distance\n+      // from itself and from another non-configured node.\n+      for (size_t m = 0; m < node_num; m++) {\n+        if (m != i && isnode_in_configured_nodes(nindex_to_node()->at(m))) {\n+          distance = numa_distance(nindex_to_node()->at(i), nindex_to_node()->at(m));\n+          // If a closest node is found, update. There is always at least one\n+          // configured node in the system so there is always at least one node\n+          // close.\n+          if (distance != 0 && distance < closest_distance) {\n+            closest_distance = distance;\n+            closest_node = nindex_to_node()->at(m);\n+          }\n+        }\n+      }\n+     } else {\n+       // Current node is already a configured node.\n+       closest_node = nindex_to_node()->at(i);\n+     }\n+\n+    // Get cpus from the original node and map them to the closest node. If node\n+    // is a configured node (not a memory-less node), then original node and\n+    // closest node are the same.\n+    if (numa_node_to_cpus(nindex_to_node()->at(i), cpu_map, cpu_map_size * sizeof(unsigned long)) != -1) {\n       for (size_t j = 0; j < cpu_map_valid_size; j++) {\n         if (cpu_map[j] != 0) {\n           for (size_t k = 0; k < BitsPerCLong; k++) {\n             if (cpu_map[j] & (1UL << k)) {\n-              cpu_to_node()->at_put(j * BitsPerCLong + k, i);\n+              cpu_to_node()->at_put(j * BitsPerCLong + k, closest_node);\n             }\n           }\n         }\n@@ -2904,14 +2978,20 @@\n }\n \n GrowableArray<int>* os::Linux::_cpu_to_node;\n+GrowableArray<int>* os::Linux::_nindex_to_node;\n os::Linux::sched_getcpu_func_t os::Linux::_sched_getcpu;\n os::Linux::numa_node_to_cpus_func_t os::Linux::_numa_node_to_cpus;\n os::Linux::numa_max_node_func_t os::Linux::_numa_max_node;\n+os::Linux::numa_num_configured_nodes_func_t os::Linux::_numa_num_configured_nodes;\n os::Linux::numa_available_func_t os::Linux::_numa_available;\n os::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;\n os::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;\n os::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;\n+os::Linux::numa_bitmask_isbitset_func_t os::Linux::_numa_bitmask_isbitset;\n+os::Linux::numa_distance_func_t os::Linux::_numa_distance;\n unsigned long* os::Linux::_numa_all_nodes;\n+struct bitmask* os::Linux::_numa_all_nodes_ptr;\n+struct bitmask* os::Linux::_numa_nodes_ptr;\n \n bool os::pd_uncommit_memory(char* addr, size_t size) {\n   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,\ndiff -r d77ea5a8ca52 -r 4dc64f3c3e23 src/os/linux/vm/os_linux.hpp\n--- openjdk/hotspot/src/os/linux/vm/os_linux.hpp\n+++ openjdk/hotspot/src/os/linux/vm/os_linux.hpp\n@@ -67,6 +67,7 @@\n   static bool _supports_fast_thread_cpu_time;\n \n   static GrowableArray<int>* _cpu_to_node;\n+  static GrowableArray<int>* _nindex_to_node;\n \n  protected:\n \n@@ -94,7 +95,9 @@\n   static void set_is_floating_stack()         { _is_floating_stack = true; }\n \n   static void rebuild_cpu_to_node_map();\n+  static void rebuild_nindex_to_node_map();\n   static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }\n+  static GrowableArray<int>* nindex_to_node()  { return _nindex_to_node; }\n \n   static size_t find_large_page_size();\n   static size_t setup_large_page_size();\n@@ -243,28 +246,41 @@\n   typedef int (*sched_getcpu_func_t)(void);\n   typedef int (*numa_node_to_cpus_func_t)(int node, unsigned long *buffer, int bufferlen);\n   typedef int (*numa_max_node_func_t)(void);\n+  typedef int (*numa_num_configured_nodes_func_t)(void);\n   typedef int (*numa_available_func_t)(void);\n   typedef int (*numa_tonode_memory_func_t)(void *start, size_t size, int node);\n   typedef void (*numa_interleave_memory_func_t)(void *start, size_t size, unsigned long *nodemask);\n   typedef void (*numa_set_bind_policy_func_t)(int policy);\n+  typedef int (*numa_bitmask_isbitset_func_t)(struct bitmask *bmp, unsigned int n);\n+  typedef int (*numa_distance_func_t)(int node1, int node2);\n \n   static sched_getcpu_func_t _sched_getcpu;\n   static numa_node_to_cpus_func_t _numa_node_to_cpus;\n   static numa_max_node_func_t _numa_max_node;\n+  static numa_num_configured_nodes_func_t _numa_num_configured_nodes;\n   static numa_available_func_t _numa_available;\n   static numa_tonode_memory_func_t _numa_tonode_memory;\n   static numa_interleave_memory_func_t _numa_interleave_memory;\n   static numa_set_bind_policy_func_t _numa_set_bind_policy;\n+  static numa_bitmask_isbitset_func_t _numa_bitmask_isbitset;\n+  static numa_distance_func_t _numa_distance;\n   static unsigned long* _numa_all_nodes;\n+  static struct bitmask* _numa_all_nodes_ptr;\n+  static struct bitmask* _numa_nodes_ptr;\n \n   static void set_sched_getcpu(sched_getcpu_func_t func) { _sched_getcpu = func; }\n   static void set_numa_node_to_cpus(numa_node_to_cpus_func_t func) { _numa_node_to_cpus = func; }\n   static void set_numa_max_node(numa_max_node_func_t func) { _numa_max_node = func; }\n+  static void set_numa_num_configured_nodes(numa_num_configured_nodes_func_t func) { _numa_num_configured_nodes = func; }\n   static void set_numa_available(numa_available_func_t func) { _numa_available = func; }\n   static void set_numa_tonode_memory(numa_tonode_memory_func_t func) { _numa_tonode_memory = func; }\n   static void set_numa_interleave_memory(numa_interleave_memory_func_t func) { _numa_interleave_memory = func; }\n   static void set_numa_set_bind_policy(numa_set_bind_policy_func_t func) { _numa_set_bind_policy = func; }\n+  static void set_numa_bitmask_isbitset(numa_bitmask_isbitset_func_t func) { _numa_bitmask_isbitset = func; }\n+  static void set_numa_distance(numa_distance_func_t func) { _numa_distance = func; }\n   static void set_numa_all_nodes(unsigned long* ptr) { _numa_all_nodes = ptr; }\n+  static void set_numa_all_nodes_ptr(struct bitmask **ptr) { _numa_all_nodes_ptr = *ptr; }\n+  static void set_numa_nodes_ptr(struct bitmask **ptr) { _numa_nodes_ptr = *ptr; }\n   static int sched_getcpu_syscall(void);\n public:\n   static int sched_getcpu()  { return _sched_getcpu != NULL ? _sched_getcpu() : -1; }\n@@ -272,6 +288,9 @@\n     return _numa_node_to_cpus != NULL ? _numa_node_to_cpus(node, buffer, bufferlen) : -1;\n   }\n   static int numa_max_node() { return _numa_max_node != NULL ? _numa_max_node() : -1; }\n+  static int numa_num_configured_nodes() {\n+    return _numa_num_configured_nodes != NULL ? _numa_num_configured_nodes() : -1;\n+  }\n   static int numa_available() { return _numa_available != NULL ? _numa_available() : -1; }\n   static int numa_tonode_memory(void *start, size_t size, int node) {\n     return _numa_tonode_memory != NULL ? _numa_tonode_memory(start, size, node) : -1;\n@@ -286,7 +305,25 @@\n       _numa_set_bind_policy(policy);\n     }\n   }\n+  static int numa_distance(int node1, int node2) {\n+    return _numa_distance != NULL ? _numa_distance(node1, node2) : -1;\n+  }\n   static int get_node_by_cpu(int cpu_id);\n+  static int get_existing_num_nodes();\n+  // Check if numa node is configured (non-zero memory node).\n+  static bool isnode_in_configured_nodes(unsigned int n) {\n+    if (_numa_bitmask_isbitset != NULL && _numa_all_nodes_ptr != NULL) {\n+      return _numa_bitmask_isbitset(_numa_all_nodes_ptr, n);\n+    } else\n+      return 0;\n+  }\n+  // Check if numa node exists in the system (including zero memory nodes).\n+  static bool isnode_in_existing_nodes(unsigned int n) {\n+    if (_numa_bitmask_isbitset != NULL && _numa_nodes_ptr != NULL) {\n+      return _numa_bitmask_isbitset(_numa_nodes_ptr, n);\n+    } else\n+      return 0;\n+  }\n };\n \n \n",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/patches/hotspot/shenandoah/8181055-pr3394-rh1448880.patch": "# HG changeset patch\n# User zgu\n# Date 1499204074 -3600\n#      Tue Jul 04 22:34:34 2017 +0100\n# Node ID 13a04e8df5a3af73794146b930b32556c7cbc5b0\n# Parent  4dc64f3c3e2342970f091a1a73165a3e2a0c2f88\n8181055, PR3394, RH1448880: PPC64: \"mbind: Invalid argument\" still seen after 8175813\nSummary: Use numa_interleave_memory v2 api when available\nReviewed-by: dholmes, shade, gromero\n\ndiff -r 4dc64f3c3e23 -r 13a04e8df5a3 src/os/linux/vm/os_linux.cpp\n--- openjdk/hotspot/src/os/linux/vm/os_linux.cpp\n+++ openjdk/hotspot/src/os/linux/vm/os_linux.cpp\n@@ -2830,11 +2830,8 @@\n extern \"C\" JNIEXPORT void numa_error(char *where) { }\n extern \"C\" JNIEXPORT int fork1() { return fork(); }\n \n-\n-// If we are running with libnuma version > 2, then we should\n-// be trying to use symbols with versions 1.1\n-// If we are running with earlier version, which did not have symbol versions,\n-// we should use the base version.\n+// Handle request to load libnuma symbol version 1.1 (API v1). If it fails\n+// load symbol from base version instead.\n void* os::Linux::libnuma_dlsym(void* handle, const char *name) {\n   void *f = dlvsym(handle, name, \"libnuma_1.1\");\n   if (f == NULL) {\n@@ -2843,6 +2840,12 @@\n   return f;\n }\n \n+// Handle request to load libnuma symbol version 1.2 (API v2) only.\n+// Return NULL if the symbol is not defined in this particular version.\n+void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {\n+  return dlvsym(handle, name, \"libnuma_1.2\");\n+}\n+\n bool os::Linux::libnuma_init() {\n   // sched_getcpu() should be in libc.\n   set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,\n@@ -2867,6 +2870,8 @@\n                                             libnuma_dlsym(handle, \"numa_tonode_memory\")));\n       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,\n                                                 libnuma_dlsym(handle, \"numa_interleave_memory\")));\n+      set_numa_interleave_memory_v2(CAST_TO_FN_PTR(numa_interleave_memory_v2_func_t,\n+                                                libnuma_v2_dlsym(handle, \"numa_interleave_memory\")));\n       set_numa_set_bind_policy(CAST_TO_FN_PTR(numa_set_bind_policy_func_t,\n                                               libnuma_dlsym(handle, \"numa_set_bind_policy\")));\n       set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,\n@@ -2986,6 +2991,7 @@\n os::Linux::numa_available_func_t os::Linux::_numa_available;\n os::Linux::numa_tonode_memory_func_t os::Linux::_numa_tonode_memory;\n os::Linux::numa_interleave_memory_func_t os::Linux::_numa_interleave_memory;\n+os::Linux::numa_interleave_memory_v2_func_t os::Linux::_numa_interleave_memory_v2;\n os::Linux::numa_set_bind_policy_func_t os::Linux::_numa_set_bind_policy;\n os::Linux::numa_bitmask_isbitset_func_t os::Linux::_numa_bitmask_isbitset;\n os::Linux::numa_distance_func_t os::Linux::_numa_distance;\ndiff -r 4dc64f3c3e23 -r 13a04e8df5a3 src/os/linux/vm/os_linux.hpp\n--- openjdk/hotspot/src/os/linux/vm/os_linux.hpp\n+++ openjdk/hotspot/src/os/linux/vm/os_linux.hpp\n@@ -190,6 +190,8 @@\n   static void libpthread_init();\n   static bool libnuma_init();\n   static void* libnuma_dlsym(void* handle, const char* name);\n+  // libnuma v2 (libnuma_1.2) symbols\n+  static void* libnuma_v2_dlsym(void* handle, const char* name);\n   // Minimum stack size a thread can be created with (allowing\n   // the VM to completely create the thread and enter user code)\n   static size_t min_stack_allowed;\n@@ -250,6 +252,8 @@\n   typedef int (*numa_available_func_t)(void);\n   typedef int (*numa_tonode_memory_func_t)(void *start, size_t size, int node);\n   typedef void (*numa_interleave_memory_func_t)(void *start, size_t size, unsigned long *nodemask);\n+  typedef void (*numa_interleave_memory_v2_func_t)(void *start, size_t size, struct bitmask* mask);\n+\n   typedef void (*numa_set_bind_policy_func_t)(int policy);\n   typedef int (*numa_bitmask_isbitset_func_t)(struct bitmask *bmp, unsigned int n);\n   typedef int (*numa_distance_func_t)(int node1, int node2);\n@@ -261,6 +265,7 @@\n   static numa_available_func_t _numa_available;\n   static numa_tonode_memory_func_t _numa_tonode_memory;\n   static numa_interleave_memory_func_t _numa_interleave_memory;\n+  static numa_interleave_memory_v2_func_t _numa_interleave_memory_v2;\n   static numa_set_bind_policy_func_t _numa_set_bind_policy;\n   static numa_bitmask_isbitset_func_t _numa_bitmask_isbitset;\n   static numa_distance_func_t _numa_distance;\n@@ -275,6 +280,7 @@\n   static void set_numa_available(numa_available_func_t func) { _numa_available = func; }\n   static void set_numa_tonode_memory(numa_tonode_memory_func_t func) { _numa_tonode_memory = func; }\n   static void set_numa_interleave_memory(numa_interleave_memory_func_t func) { _numa_interleave_memory = func; }\n+  static void set_numa_interleave_memory_v2(numa_interleave_memory_v2_func_t func) { _numa_interleave_memory_v2 = func; }\n   static void set_numa_set_bind_policy(numa_set_bind_policy_func_t func) { _numa_set_bind_policy = func; }\n   static void set_numa_bitmask_isbitset(numa_bitmask_isbitset_func_t func) { _numa_bitmask_isbitset = func; }\n   static void set_numa_distance(numa_distance_func_t func) { _numa_distance = func; }\n@@ -296,7 +302,10 @@\n     return _numa_tonode_memory != NULL ? _numa_tonode_memory(start, size, node) : -1;\n   }\n   static void numa_interleave_memory(void *start, size_t size) {\n-    if (_numa_interleave_memory != NULL && _numa_all_nodes != NULL) {\n+    // Use v2 api if available\n+    if (_numa_interleave_memory_v2 != NULL && _numa_all_nodes_ptr != NULL) {\n+      _numa_interleave_memory_v2(start, size, _numa_all_nodes_ptr);\n+    } else if (_numa_interleave_memory != NULL && _numa_all_nodes != NULL) {\n       _numa_interleave_memory(start, size, _numa_all_nodes);\n     }\n   }\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/tool/i18n.properties",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/tool/images/jtlogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/tool/images/jticon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/tool/images/splash.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/audit/images/dotdotdot.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/mrep/images/dotdotdot.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/mrep/images/Back16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/mrep/images/Home16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/mrep/images/Forward16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Preferences16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Help16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Up16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/SaveAs24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/UpDir.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/question.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/FindAgain24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/snooze.sm.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Pause24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Preferences24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Down16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Down24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Back24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/FastForward16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Help24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Play24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Last16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Dir.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Pause16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/stream.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Back16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Home16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Save24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/drop-down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Forward16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/SaveAs16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Forward24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Find16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Edit24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/fullView.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/stdView.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Stop24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/magnify.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/FindAgain16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Save16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Play16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Find24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Print16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Print24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Stop16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Edit16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Home24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/exec/images/Up24.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/javatest/agent/jticon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/interview/wizard/back.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/interview/wizard/next.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/interview/wizard/done.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/interview/wizard/blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/interview/wizard/history.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/interview/wizard/find.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/interview/wizard/cancel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/interview/wizard/arrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/interview/wizard/info.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/test/jtreg/com/sun/interview/wizard/check.gif",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/overlays/openjdk/jdk/test/closed/sun/security/rsa/keystore.bad",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/overlays/openjdk/jdk/test/closed/sun/security/rsa/keystore.good",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/overlays/openjdk/jdk/test/com/sun/media/sound/SoftSynthesizer/expresso.mid",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/overlays/openjdk/jdk/test/com/sun/media/sound/SoftSynthesizer/ding.sf2",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/overlays/openjdk/jdk/test/com/sun/media/sound/SF2SoundbankReader/ding.sf2",
        "/tmp/vanessa/spack-stage/spack-stage-icedtea-3.6.0-mfnhsee3lq3hygihrhdfja7ymshaq7gr/spack-src/overlays/openjdk/jdk/test/com/sun/media/sound/DLSSoundbankReader/ding.dls"
    ],
    "total_files": 790
}