{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-vecgeom-1.1.5-xv6meoqgxmrixy3oo6xqedgyx3od4blb/spack-src/source/GeoManager.cpp": "// This file is part of VecGeom and is distributed under the\n// conditions in the file LICENSE.txt in the top directory.\n// For the full list of authors see CONTRIBUTORS.txt and `git log`.\n\n/// \\file GeoManager.cpp\n\n#include \"management/GeoManager.h\"\n#include \"volumes/PlacedVolume.h\"\n#include \"navigation/NavigationState.h\"\n#include \"management/ABBoxManager.h\"\n#include \"volumes/UnplacedBooleanVolume.h\"\n#include \"volumes/UnplacedScaledShape.h\"\n#include \"volumes/LogicalVolume.h\"\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <list>\n#include <vector>\n#include <set>\n#include <functional>\n\nnamespace vecgeom {\ninline namespace VECGEOM_IMPL_NAMESPACE {\n\nVPlacedVolume *GeoManager::gCompactPlacedVolBuffer = nullptr;\n\nvoid GeoManager::RegisterLogicalVolume(LogicalVolume *const logical_volume)\n{\n  if (!fIsClosed)\n    fLogicalVolumesMap[logical_volume->id()] = logical_volume;\n  else {\n    std::cerr << \"Logical Volume created after geometry is closed --> will not be registered\\n\";\n  }\n}\n\nvoid GeoManager::RegisterPlacedVolume(VPlacedVolume *const placed_volume)\n{\n  if (!fIsClosed)\n    fPlacedVolumesMap[placed_volume->id()] = placed_volume;\n  else {\n    std::cerr << \"PlacedVolume created after geometry is closed --> will not be registered\\n\";\n  }\n}\n\nvoid GeoManager::DeregisterLogicalVolume(const int id)\n{\n  if (fLogicalVolumesMap.find(id) != fLogicalVolumesMap.end()) {\n    if (fIsClosed) {\n      std::cerr << \"deregistering an object from GeoManager while geometry is closed\\n\";\n    }\n    fLogicalVolumesMap.erase(id);\n  }\n}\n\nvoid GeoManager::DeregisterPlacedVolume(const int id)\n{\n  if (fPlacedVolumesMap.find(id) != fPlacedVolumesMap.end()) {\n    if (fIsClosed) {\n      std::cerr << \"deregistering an object from GeoManager while geometry is closed\\n\";\n    }\n    fPlacedVolumesMap.erase(id);\n  }\n}\n\nvoid GeoManager::CompactifyMemory()\n{\n  // this function will compactify the memory a-posteriori\n  // it might be worth investigating other methods that do this directly\n  // ( for instance via specialized allocators )\n\n  // ---------------------------------\n  // start with just the placedvolumes\n\n  // do a check on a fundamental hypothesis :\n  // all placed volume objects have the same size ( so that we can compactify them in an array )\n  for (auto v : fPlacedVolumesMap) {\n    if (v.second->MemorySize() != fWorld->MemorySize())\n      std::cerr << \"Fatal Warning : placed volume instances have non-uniform size \\n\";\n  }\n\n  unsigned int pvolumecount = fPlacedVolumesMap.size();\n\n  //  This piece of code was just to cross check something:\n\n  //  std::vector<VPlacedVolume const *> pvolumes;\n  //  getAllPlacedVolumes(pvolumes);\n  //  // make it a set ( to get rid of potential duplicates )\n  //  std::set<VPlacedVolume const *> pvolumeset(pvolumes.begin(), pvolumes.end());\n\n  //  std::vector<LogicalVolume const *> lvolumes;\n  //  GetAllLogicalVolumes(lvolumes);\n  //  std::set<LogicalVolume const *> lvolumeset(lvolumes.begin(), lvolumes.end());\n\n  //  std::cerr << pvolumecount << \" vs \" << pvolumeset.size() << \"\\n\";\n  //  std::cerr << fLogicalVolumesMap.size() << \" vs \" << lvolumeset.size() << \"\\n\";\n\n  // conversion map to repair pointers from old to new\n  std::map<VPlacedVolume const *, VPlacedVolume const *> conversionmap;\n\n  // allocate the buffer ( consider alignment issues later )\n  // BIG NOTE HERE: we cannot call new VPlacedVolume[pvolumecount] as it is a pure virtual class\n  // this also means: our mechanism will only work if none of the derived classes of VPlacedVolumes\n  // adds a data member and we have to find a way to check or forbid this\n  // ( a runtime check is done above )\n  gCompactPlacedVolBuffer = (VPlacedVolume *)malloc(pvolumecount * sizeof(VPlacedVolume));\n\n  //    // the first element in the buffer has to be the world\n  //    buffer[0] = *fWorld; // copy assignment of PlacedVolumes\n  //    // fix the index to pointer map\n  //    fPlacedVolumesMap[fWorld->id()] = &buffer[0];\n  //    conversionmap[ fWorld ] = &buffer[0];\n  //    // free memory ( we should really be doing this with smart pointers --> check CUDA ! )\n  //    // delete fWorld;\n  //    // fix the global world pointer\n  //    fWorld = &buffer[0];\n\n  // go through rest of volumes\n  // TODO: we could take an influence on the order here ( to place certain volumes next to each other )\n  for (auto v : fPlacedVolumesMap) {\n    unsigned int volumeindex             = v.first;\n    gCompactPlacedVolBuffer[volumeindex] = *v.second;\n    fPlacedVolumesMap[volumeindex]       = &gCompactPlacedVolBuffer[volumeindex];\n    conversionmap[v.second]              = &gCompactPlacedVolBuffer[volumeindex];\n    //   delete v.second;\n  }\n\n  // a little reusable lambda for the pointer conversion\n  std::function<VPlacedVolume const *(VPlacedVolume const *)> ConvertOldToNew = [&](VPlacedVolume const *old) {\n    if (conversionmap.find(old) == conversionmap.cend()) {\n      // std::cerr << \"CANNOT CONVERT ... probably already done\" << std::endl;\n      return old;\n    }\n    return conversionmap[old];\n  };\n\n  // fix pointers to placed volumes referenced in all logical volumes\n  for (auto v : fLogicalVolumesMap) {\n    LogicalVolume *lvol = v.second;\n    auto ndaughter      = lvol->GetDaughtersp()->size();\n    for (decltype(ndaughter) i = 0; i < ndaughter; ++i) {\n      lvol->GetDaughtersp()->operator[](i) = ConvertOldToNew(lvol->GetDaughtersp()->operator[](i));\n    }\n  }\n\n  for (auto v : fLogicalVolumesMap) {\n\n    // check if this is a boolean type\n    // FIXME: make this shorter!\n    {\n      using BoolT = UnplacedBooleanVolume<kSubtraction>;\n      BoolT *bvol;\n      if ((bvol = const_cast<BoolT *>(dynamic_cast<BoolT const *>(v.second->GetUnplacedVolume())))) {\n        bvol->SetLeft(ConvertOldToNew(bvol->GetLeft()));\n        bvol->SetRight(ConvertOldToNew(bvol->GetRight()));\n      }\n    }\n    {\n      using BoolT = UnplacedBooleanVolume<kUnion>;\n      BoolT *bvol;\n      if ((bvol = const_cast<BoolT *>(dynamic_cast<BoolT const *>(v.second->GetUnplacedVolume())))) {\n        bvol->SetLeft(ConvertOldToNew(bvol->GetLeft()));\n        bvol->SetRight(ConvertOldToNew(bvol->GetRight()));\n      }\n    }\n    {\n      using BoolT = UnplacedBooleanVolume<kIntersection>;\n      BoolT *bvol;\n      if ((bvol = const_cast<BoolT *>(dynamic_cast<BoolT const *>(v.second->GetUnplacedVolume())))) {\n        bvol->SetLeft(ConvertOldToNew(bvol->GetLeft()));\n        bvol->SetRight(ConvertOldToNew(bvol->GetRight()));\n      }\n    }\n\n    // same for scaled shape volume\n    UnplacedScaledShape *svol;\n    if ((svol = const_cast<UnplacedScaledShape *>(\n             dynamic_cast<UnplacedScaledShape const *>(v.second->GetUnplacedVolume())))) {\n      svol->SetPlaced(ConvertOldToNew(svol->GetPlaced()));\n    }\n  }\n  // cleanup conversion map ... automatically done\n\n  // fix reference to World in GeoManager ( and everywhere else )\n  fWorld = ConvertOldToNew(fWorld);\n}\n\nvoid GeoManager::CloseGeometry()\n{\n  assert(GetWorld() != nullptr);\n  if (fIsClosed) {\n    std::cerr << \"geometry is already closed; I cannot close it again (very likely this message signifies a \"\n                 \"substational error !!!\\n\";\n  }\n  // cache some important variables of this geometry\n  GetMaxDepthVisitor depthvisitor;\n  visitAllPlacedVolumes(GetWorld(), &depthvisitor, 1);\n  fMaxDepth = depthvisitor.getMaxDepth();\n\n  GetTotalNodeCountVisitor totalcountvisitor;\n  visitAllPlacedVolumes(GetWorld(), &totalcountvisitor, 1);\n  fTotalNodeCount = totalcountvisitor.GetTotalNodeCount();\n\n  // get a consistent state for index - placed volumes lookups\n  for (auto element : fPlacedVolumesMap) {\n    fVolumeToIndexMap[element.second] = element.first;\n  }\n\n  CompactifyMemory();\n  vecgeom::ABBoxManager::Instance().InitABBoxesForCompleteGeometry();\n\n  fIsClosed = true;\n}\n\nvoid GeoManager::LoadGeometryFromSharedLib(std::string libname, bool close)\n{\n  void *handle;\n  handle = dlopen(libname.c_str(), RTLD_NOW);\n  if (!handle) {\n    std::cerr << \"Error loading geometry shared lib: \" << dlerror() << \"\\n\";\n  }\n\n  // the create detector \"function type\":\n  typedef VPlacedVolume const *(*CreateFunc_t)();\n\n  // find entry symbol to geometry creation\n  // TODO: get rid of hard coded name\n  CreateFunc_t create = (CreateFunc_t)dlsym(handle, \"_Z16generateDetectorv\");\n\n  if (create != nullptr) {\n    // call the create function and set the geometry world\n    VPlacedVolume const *world = create();\n    world->PrintType();\n    SetWorld(world);\n\n    // close the geometry\n    // TODO: This step often necessitates extensive computation and could be done\n    // as part of the shared lib load itself\n    if (close)\n      CloseGeometry();\n    else {\n      std::cerr << \"Geometry left open for further manipulation; Please close later\\n\";\n    }\n  } else {\n    std::cerr << \"Loading geometry from shared lib failed\\n\";\n  }\n  //    dlclose(handle);\n}\n\nVPlacedVolume *GeoManager::FindPlacedVolume(const int id)\n{\n  auto iterator = fPlacedVolumesMap.find(id);\n  return (iterator != fPlacedVolumesMap.end()) ? iterator->second : NULL;\n}\n\nVPlacedVolume *GeoManager::FindPlacedVolume(char const *const label)\n{\n  VPlacedVolume *output = NULL;\n  bool multiple         = false;\n  for (auto v = fPlacedVolumesMap.begin(), v_end = fPlacedVolumesMap.end(); v != v_end; ++v) {\n    if (v->second->GetLabel() == label) {\n      if (!output) {\n        output = v->second;\n      } else {\n        if (!multiple) {\n          multiple = true;\n          printf(\"GeoManager::FindPlacedVolume: Multiple placed volumes with \"\n                 \"identifier \\\"%s\\\" found: [%i], \",\n                 label, output->id());\n        } else {\n          printf(\", \");\n        }\n        printf(\"[%i]\", v->second->id());\n      }\n    }\n  }\n  if (multiple) printf(\". Returning first occurence.\\n\");\n  return output;\n}\n\nLogicalVolume *GeoManager::FindLogicalVolume(const int id)\n{\n  auto iterator = fLogicalVolumesMap.find(id);\n  return (iterator != fLogicalVolumesMap.end()) ? iterator->second : NULL;\n}\n\nLogicalVolume *GeoManager::FindLogicalVolume(char const *const label)\n{\n  LogicalVolume *output = NULL;\n  bool multiple         = false;\n  for (auto v = fLogicalVolumesMap.begin(), v_end = fLogicalVolumesMap.end(); v != v_end; ++v) {\n\n    const std::string &fullname = v->second->GetLabel();\n    if (fullname.compare(label) == 0) {\n      if (!output) {\n        output = v->second;\n      } else {\n        if (!multiple) {\n          multiple = true;\n          printf(\"GeoManager::FindLogicalVolume: Multiple logical volumes with \"\n                 \"identifier \\\"%s\\\" found: [%i], \",\n                 label, output->id());\n        } else {\n          printf(\", \");\n        }\n        printf(\"[%i]\", v->second->id());\n      }\n    }\n  }\n  if (multiple) printf(\". Returning first occurence.\\n\");\n  return output;\n}\n\nvoid GeoManager::Clear()\n{\n  fVolumeCount    = 0;\n  fTotalNodeCount = 0;\n  fWorld          = nullptr;\n  fPlacedVolumesMap.clear();\n  fLogicalVolumesMap.clear();\n  fVolumeToIndexMap.clear();\n  fMaxDepth = -1;\n  fIsClosed = false;\n  // should we also reset the global static id counts?\n  LogicalVolume::gIdCount   = 0;\n  VPlacedVolume::g_id_count = 0;\n  // delete compact buffer for placed volumes\n  if (GeoManager::gCompactPlacedVolBuffer != nullptr) {\n    free(gCompactPlacedVolBuffer);\n    gCompactPlacedVolBuffer = nullptr;\n  }\n}\n\ntemplate <typename Container>\nclass GetPathsForLogicalVolumeVisitor : public GeoVisitorWithAccessToPath<Container> {\nprivate:\n  LogicalVolume const *fReferenceLogicalVolume;\n  int fMaxDepth;\n\npublic:\n  GetPathsForLogicalVolumeVisitor(Container &c, LogicalVolume const *lv, int maxd)\n      : GeoVisitorWithAccessToPath<Container>(c), fReferenceLogicalVolume(lv), fMaxDepth(maxd)\n  {\n  }\n\n  void apply(NavigationState *state, int /* level */)\n  {\n    if (state->Top()->GetLogicalVolume() == fReferenceLogicalVolume) {\n      // the current state is a good one;\n\n      // make a copy and store it in the container for this visitor\n      NavigationState *copy = NavigationState::MakeCopy(*state);\n\n      this->c_.push_back(copy);\n    }\n  }\n};\n\ntemplate <typename Visitor>\nvoid GeoManager::visitAllPlacedVolumesWithContext(VPlacedVolume const *currentvolume, Visitor *visitor,\n                                                  NavigationState *state, int level) const\n{\n  if (currentvolume != NULL) {\n    state->Push(currentvolume);\n    visitor->apply(state, level);\n    int size = currentvolume->GetDaughters().size();\n    for (int i = 0; i < size; ++i) {\n      visitAllPlacedVolumesWithContext(currentvolume->GetDaughters().operator[](i), visitor, state, level + 1);\n    }\n    state->Pop();\n  }\n}\n\ntemplate <typename Container>\n__attribute__((noinline)) void GeoManager::getAllPathForLogicalVolume(LogicalVolume const *lvol, Container &c) const\n{\n  NavigationState *state = NavigationState::MakeInstance(getMaxDepth());\n  c.clear();\n  state->Clear();\n\n  // instantiate the visitor\n  GetPathsForLogicalVolumeVisitor<Container> pv(c, lvol, getMaxDepth());\n\n  // now walk the placed volume hierarchy\n  visitAllPlacedVolumesWithContext(GetWorld(), &pv, state);\n  NavigationState::ReleaseInstance(state);\n}\n\n// explicitely init some symbols\ntemplate void GeoManager::getAllPathForLogicalVolume(LogicalVolume const *lvol, std::list<NavigationState *> &c) const;\ntemplate void GeoManager::getAllPathForLogicalVolume(LogicalVolume const *lvol,\n                                                     std::vector<NavigationState *> &c) const;\n}\n} // End global namespace\n",
        "/tmp/vanessa/spack-stage/spack-stage-vecgeom-1.1.5-xv6meoqgxmrixy3oo6xqedgyx3od4blb/spack-src/test/globalbenchmarks/NavigationKernelBenchmarker.cpp": "#include \"volumes/utilities/VolumeUtilities.h\"\n#include \"base/Global.h\"\n#include \"base/Vector3D.h\"\n#include \"base/SOA3D.h\"\n#include \"base/RNG.h\"\n#include \"navigation/GlobalLocator.h\"\n#include \"navigation/NavStatePool.h\"\n#include \"navigation/NavigationState.h\"\n#include \"volumes/PlacedVolume.h\"\n#include \"volumes/LogicalVolume.h\"\n#include \"management/RootGeoManager.h\"\n#include \"management/GeoManager.h\"\n#include \"base/Stopwatch.h\"\n#include \"navigation/NewSimpleNavigator.h\"\n#include \"navigation/SimpleABBoxNavigator.h\"\n#include \"navigation/SimpleABBoxLevelLocator.h\"\n#include \"navigation/HybridLevelLocator.h\"\n#include \"navigation/HybridNavigator2.h\"\n#include \"management/HybridManager2.h\"\n#ifdef VECGEOM_EMBREE\n#include \"navigation/EmbreeNavigator.h\"\n#endif\n//#define BENCH_GENERATED_NAVIGATOR\n#ifdef BENCH_GENERATED_NAVIGATOR\n#include \"navigation/GeneratedNavigator.h\"\n#endif\n\n#ifdef VECGEOM_ROOT\n#include \"TGeoNavigator.h\"\n#include \"TGeoNode.h\"\n#include \"TGeoManager.h\"\n#include \"TGeoBranchArray.h\"\n#include \"TGeoBBox.h\"\n#endif\n\n#ifdef VECGEOM_GEANT4\n#include \"G4Navigator.hh\"\n#include \"G4VPhysicalVolume.hh\"\n#include \"G4ThreeVector.hh\"\n#include \"management/G4GeoManager.h\"\n#endif\n\n#include <iostream>\n#include <set>\n#include <sstream>\n#include <dlfcn.h>\n\n#undef NDEBUG\n#include <cassert>\n\n//#define CALLGRIND_ENABLED\n#ifdef CALLGRIND_ENABLED\n#include <valgrind/callgrind.h>\n#endif\n\n#ifdef CALLGRIND_ENABLED\n#define RUNBENCH(NAME)             \\\n  CALLGRIND_START_INSTRUMENTATION; \\\n  NAME;                            \\\n  CALLGRIND_STOP_INSTRUMENTATION;  \\\n  CALLGRIND_DUMP_STATS\n#else\n#define RUNBENCH(NAME) NAME\n#endif\n\nusing namespace vecgeom;\n\nbool gBenchVecInterface = false;\nbool gAnalyseOutStates  = false;\nbool gBenchWithSafety   = false;\nbool gSpecializedLib    = false;\ndouble gMAXSTEP         = vecgeom::kInfLength; // global variable to configure max step asked in ComputeStep\n\nstd::string gSpecLibName;\nVNavigator const *gSpecializedNavigator;\n\nvoid InitNavigators()\n{\n  for (auto &lvol : GeoManager::Instance().GetLogicalVolumesMap()) {\n    if (lvol.second->GetDaughtersp()->size() < 4) {\n      lvol.second->SetNavigator(NewSimpleNavigator<>::Instance());\n    }\n    if (lvol.second->GetDaughtersp()->size() >= 5) {\n      lvol.second->SetNavigator(SimpleABBoxNavigator<>::Instance());\n    }\n    if (lvol.second->GetDaughtersp()->size() >= 10) {\n      lvol.second->SetNavigator(HybridNavigator<>::Instance());\n      HybridManager2::Instance().InitStructure((lvol.second));\n    }\n    if (lvol.second->GetDaughtersp()->size() >= 10) {\n      lvol.second->SetNavigator(HybridNavigator<>::Instance());\n      HybridManager2::Instance().InitStructure((lvol.second));\n    }\n\n    if (lvol.second->ContainsAssembly()) {\n      lvol.second->SetLevelLocator(SimpleAssemblyAwareABBoxLevelLocator::GetInstance());\n    } else {\n      lvol.second->SetLevelLocator(SimpleABBoxLevelLocator::GetInstance());\n    }\n  }\n}\n\nvoid InitSpecializedNavigators(std::string libname)\n{\n  void *handle;\n  handle = dlopen(libname.c_str(), RTLD_NOW);\n  if (!handle) {\n    std::cerr << \"Error loading navigator shared lib: \" << dlerror() << \"\\n\";\n    std::cerr << \"doing nothing ... \\n\";\n    return;\n  }\n\n  // the create detector \"function type\":\n  typedef void (*InitFunc_t)();\n\n  // find entry symbol correct symbol in lib\n  // TODO: get rid of hard coded name (which might not be portable)\n  InitFunc_t init = (InitFunc_t)dlsym(handle, \"_Z25InitSpecializedNavigatorsv\");\n\n  if (init != nullptr) {\n    // call the init function which is going to set specific navigators as\n    // compiled in by the user\n    init();\n  } else {\n    std::cerr << \"Init specialized navigators from shared lib failed; symbol not found\\n\";\n  }\n}\n\nvoid analyseOutStates(NavStatePool &inpool, NavStatePool const &outpool)\n{\n  std::set<VPlacedVolume const *> pset;\n  std::set<LogicalVolume const *> lset;\n  std::set<std::string> pathset;\n  std::set<std::string> crossset;\n  std::set<std::string> diffset;\n  std::set<std::string> matrices;\n  for (auto j = decltype(outpool.capacity()){0}; j < outpool.capacity(); ++j) {\n    std::stringstream pathstringstream2;\n    auto *navstate = outpool[j];\n    navstate->printValueSequence(pathstringstream2);\n    pset.insert(navstate->Top());\n    lset.insert(navstate->Top()->GetLogicalVolume());\n    pathset.insert(pathstringstream2.str());\n\n    std::stringstream pathstringstream1;\n    auto *instate = inpool[j];\n    instate->printValueSequence(pathstringstream1);\n    crossset.insert(pathstringstream1.str() + \" -- \" + pathstringstream2.str());\n    diffset.insert(instate->RelativePath(*navstate));\n\n    Transformation3D g;\n    Transformation3D g2;\n    Transformation3D invg2;\n\n    instate->TopMatrix(g);\n    navstate->TopMatrix(g2);\n    g.SetProperties();\n    g2.SetProperties();\n    g2.Inverse(invg2);\n    invg2.MultiplyFromRight(g);\n    invg2.FixZeroes();\n    std::stringstream matrixstream;\n    invg2.Print(matrixstream);\n    matrices.insert(matrixstream.str());\n  }\n\n  std::cerr << \" size of diffset \" << diffset.size() << \"\\n\";\n  std::cerr << \" size of matrixset \" << matrices.size() << \"\\n\";\n  std::cerr << \" size of target pset \" << pset.size() << \"\\n\";\n  std::cerr << \" size of target lset \" << lset.size() << \"\\n\";\n  std::cerr << \" size of target state set \" << pathset.size() << \"\\n\";\n  std::cerr << \" total combinations \" << crossset.size() << \"\\n\";\n  std::cerr << \" normalized per input state \" << crossset.size() / (1. * pathset.size()) << \"\\n\";\n\n  for (auto &s : crossset) {\n    std::cerr << s << \"\\n\";\n  }\n  for (auto &s : diffset) {\n    std::cerr << s << \"\\n\";\n  }\n  for (auto &s : matrices) {\n    std::cerr << s << \"\\n\";\n  }\n}\n\n#ifdef VECGEOM_ROOT\ntemplate <bool WithSafety = false, bool WithReloc = true>\n__attribute__((noinline)) void benchmarkROOTNavigator(SOA3D<Precision> const &points, SOA3D<Precision> const &dirs)\n{\n\n  TGeoNavigator *rootnav      = ::gGeoManager->GetCurrentNavigator();\n  auto nPoints                = points.size();\n  TGeoBranchArray **instates  = new TGeoBranchArray *[nPoints];\n  TGeoBranchArray **outstates = new TGeoBranchArray *[nPoints];\n  Precision *steps            = new Precision[points.size()];\n  Precision *safeties;\n  if (WithSafety) {\n    safeties = new Precision[points.size()];\n  }\n  // we don't have the input state container in ROOT form\n  // we generate them but do not take this into account for the timing measurement\n  for (size_t i = 0; i < nPoints; ++i) {\n    Vector3D<Precision> const &pos = points[i];\n    rootnav->ResetState();\n    rootnav->FindNode(pos.x(), pos.y(), pos.z());\n    instates[i]  = TGeoBranchArray::MakeInstance(GeoManager::Instance().getMaxDepth());\n    outstates[i] = TGeoBranchArray::MakeInstance(GeoManager::Instance().getMaxDepth());\n    instates[i]->InitFromNavigator(rootnav);\n  }\n#ifdef CALLGRIND_ENABLED\n  CALLGRIND_START_INSTRUMENTATION;\n#endif\n  Stopwatch timer;\n  timer.Start();\n  for (size_t i = 0; i < nPoints; ++i) {\n    Vector3D<Precision> const &pos = points[i];\n    Vector3D<Precision> const &dir = dirs[i];\n    rootnav->ResetState();\n    instates[i]->UpdateNavigator(rootnav);\n\n    rootnav->SetCurrentPoint(pos.x(), pos.y(), pos.z());\n    rootnav->SetCurrentDirection(dir.x(), dir.y(), dir.z());\n    if (WithSafety) {\n      safeties[i] = rootnav->Safety(true);\n    }\n    if (WithReloc) {\n      volatile TGeoNode *node = rootnav->FindNextBoundaryAndStep(gMAXSTEP);\n      (void)node;\n    } else {\n      volatile TGeoNode *node = rootnav->FindNextBoundary(gMAXSTEP);\n      (void)node;\n    }\n    steps[i] = rootnav->GetStep();\n    if (WithReloc) {\n      // save output states ( for fair comparison with VecGeom )\n      outstates[i]->InitFromNavigator(rootnav);\n    }\n  }\n  timer.Stop();\n#ifdef CALLGRIND_ENABLED\n  CALLGRIND_STOP_INSTRUMENTATION;\n  CALLGRIND_DUMP_STATS;\n#endif\n  std::cerr << timer.Elapsed() << \"\\n\";\n  double accum(0.);\n  double saccum(0.);\n  size_t hittargetchecksum = 0L;\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    accum += steps[i];\n    if (WithSafety) {\n      saccum += safeties[i];\n    }\n    // target checksum via the table held from RootGeoManager\n    hittargetchecksum +=\n        (size_t)RootGeoManager::Instance().Lookup(outstates[i]->GetNode(outstates[i]->GetLevel()))->id();\n  }\n  delete[] steps;\n  if (WithSafety) {\n    delete safeties;\n  }\n\n  // cleanup states\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    delete instates[i];\n    delete outstates[i];\n  }\n  delete[] instates;\n  delete[] outstates;\n\n  std::cerr << \"accum  TGeo \" << accum << \" target checksum \" << hittargetchecksum << \"\\n\";\n  if (WithSafety) {\n    std::cerr << \"safety accum  TGeo \" << saccum << \"\\n\";\n  }\n}\n\n#ifdef VECGEOM_GEANT4\ntemplate <bool WithSafety = false>\n__attribute__((noinline)) void benchmarkG4Navigator(SOA3D<Precision> const &points, SOA3D<Precision> const &dirs)\n{\n  G4VPhysicalVolume *world(vecgeom::G4GeoManager::Instance().GetG4GeometryFromROOT());\n  if (world != nullptr) G4GeoManager::Instance().LoadG4Geometry(world);\n\n  // Note: Vector3D's are expressed in cm, while G4ThreeVectors are expressed in mm\n  const Precision cm = 10.; // cm --> mm conversion\n  G4Navigator &g4nav = *(G4GeoManager::Instance().GetNavigator());\n  // G4TouchableHistory **g4history = new G4TouchableHistory *[nPoints];\n\n  Precision *steps = new Precision[points.size()];\n\n  // get a time estimate to just to locate points\n  // (The reason is that the G4Navigator has a huge internal state and it is not foreseen to do\n  //  multi-track processing with a basked of G4TouchableHistories as states)\n  Stopwatch timer;\n  timer.Start();\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    G4ThreeVector g4pos(points[i].x() * cm, points[i].y() * cm, points[i].z() * cm);\n    G4ThreeVector g4dir(dirs[i].x(), dirs[i].y(), dirs[i].z());\n    // false --> locate from top\n    g4nav.LocateGlobalPointAndSetup(g4pos, &g4dir, false);\n  }\n  Precision timeForLocate = (Precision)timer.Stop();\n\n#ifdef CALLGRIND_ENABLED\n  CALLGRIND_START_INSTRUMENTATION;\n#endif\n  timer.Start();\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    G4ThreeVector g4pos(points[i].x() * cm, points[i].y() * cm, points[i].z() * cm);\n    G4ThreeVector g4dir(dirs[i].x(), dirs[i].y(), dirs[i].z());\n    G4double maxStep = gMAXSTEP;\n\n    // false --> locate from top\n    G4VPhysicalVolume const *vol = g4nav.LocateGlobalPointAndSetup(g4pos, &g4dir, false);\n    (void)vol;\n    G4double safety = 0.0;\n    steps[i]        = g4nav.ComputeStep(g4pos, g4dir, maxStep, safety);\n\n    G4ThreeVector nextPos = g4pos + (steps[i] + 1.0e-6) * g4dir;\n    // TODO: save touchable history array - returnable?  symmetrize with ROOT/VECGEOM benchmark\n    g4nav.SetGeometricallyLimitedStep();\n\n    volatile G4VPhysicalVolume const *nextvol = g4nav.LocateGlobalPointAndSetup(nextPos);\n    (void)nextvol;\n  }\n  timer.Stop();\n  std::cerr << (Precision)timer.Elapsed() - timeForLocate << \"\\n\";\n#ifdef CALLGRIND_ENABLED\n  CALLGRIND_STOP_INSTRUMENTATION;\n  CALLGRIND_DUMP_STATS;\n#endif\n  // cleanup\n  // delete[] g4history;\n  //_mm_free(maxSteps);\n  double accum{0.};\n  size_t hittargetchecksum{0L};\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    accum += steps[i];\n    if (WithSafety) {\n      // saccum += safeties[i];\n    }\n    // target checksum via the table held from RootGeoManager\n    // hittargetchecksum +=\n    //    (size_t)RootGeoManager::Instance().Lookup(outstates[i]->GetNode(outstates[i]->GetLevel()))->id();\n  }\n  std::cerr << \"accum  G4 \" << accum / cm << \" target checksum \" << hittargetchecksum << \"\\n\";\n}\n#endif // end if G4\n#endif // end if ROOT\n\ntemplate <bool WithSafety = true>\n__attribute__((noinline)) void benchNavigator(VNavigator const *se, SOA3D<Precision> const &points,\n                                              SOA3D<Precision> const &dirs, NavStatePool const &inpool,\n                                              NavStatePool &outpool)\n{\n  Precision *steps = new Precision[points.size()];\n  Precision *safeties;\n  if (WithSafety) safeties = new Precision[points.size()];\n  Stopwatch timer;\n  size_t hittargetchecksum = 0L;\n  timer.Start();\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    if (WithSafety) {\n      steps[i] = se->ComputeStepAndSafetyAndPropagatedState(points[i], dirs[i], gMAXSTEP, *inpool[i], *outpool[i], true,\n                                                            safeties[i]);\n    } else {\n      steps[i] = se->ComputeStepAndPropagatedState(points[i], dirs[i], gMAXSTEP, *inpool[i], *outpool[i]);\n    }\n  }\n  timer.Stop();\n  std::cerr << timer.Elapsed() << \"\\n\";\n  double accum(0.), saccum(0.);\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    accum += steps[i];\n    if (WithSafety) {\n      saccum += safeties[i];\n    }\n    if (outpool[i]->Top()) hittargetchecksum += (size_t)outpool[i]->Top()->id();\n  }\n  delete[] steps;\n  std::cerr << \"accum  \" << se->GetName() << \" \" << accum << \" target checksum \" << hittargetchecksum << \"\\n\";\n  if (WithSafety) {\n    std::cerr << \"saccum  \" << se->GetName() << \" \" << saccum << \"\\n\";\n  }\n}\n\n// version benchmarking navigation without relocation\ntemplate <bool WithSafety = true>\n__attribute__((noinline)) void benchNavigatorNoReloc(VNavigator const *se, SOA3D<Precision> const &points,\n                                                     SOA3D<Precision> const &dirs, NavStatePool const &inpool,\n                                                     NavStatePool &outpool)\n{\n  Precision *steps = new Precision[points.size()];\n  Precision *safeties;\n  if (WithSafety) safeties = new Precision[points.size()];\n  Stopwatch timer;\n  size_t hittargetchecksum = 0L;\n  timer.Start();\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    if (WithSafety) {\n      steps[i] = se->ComputeStepAndSafety(points[i], dirs[i], gMAXSTEP, *const_cast<NavigationState *>(inpool[i]), true,\n                                          safeties[i]);\n    } else {\n      steps[i] = se->ComputeStep(points[i], dirs[i], gMAXSTEP, *inpool[i], *outpool[i]);\n    }\n  }\n  timer.Stop();\n  std::cerr << timer.Elapsed() << \"\\n\";\n  double accum(0.), saccum(0.);\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    accum += steps[i];\n    if (WithSafety) {\n      saccum += safeties[i];\n    }\n    if (outpool[i]->Top()) hittargetchecksum += (size_t)outpool[i]->Top()->id();\n  }\n  delete[] steps;\n  std::cerr << \"accum  \" << se->GetName() << \" \" << accum << \" target checksum \" << hittargetchecksum << \"\\n\";\n  if (WithSafety) {\n    std::cerr << \"saccum  \" << se->GetName() << \" \" << saccum << \"\\n\";\n  }\n}\n\ntemplate <typename T, bool WithSafety = true>\n__attribute__((noinline)) void benchVectorNavigator(SOA3D<Precision> const &__restrict__ points,\n                                                    SOA3D<Precision> const &__restrict__ dirs,\n                                                    NavStatePool const &__restrict__ inpool,\n                                                    NavStatePool &__restrict__ outpool)\n{\n  Precision *step_max = (double *)vecCore::AlignedAlloc(32, sizeof(double) * points.size());\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    step_max[i] = gMAXSTEP;\n  }\n  Precision *steps    = (double *)vecCore::AlignedAlloc(32, sizeof(double) * points.size());\n  Precision *safeties = nullptr;\n  bool *calcs;\n  if (WithSafety) {\n    safeties = (double *)vecCore::AlignedAlloc(32, sizeof(double) * points.size());\n    calcs    = (bool *)vecCore::AlignedAlloc(32, sizeof(bool) * points.size());\n    for (decltype(points.size()) i = 0; i < points.size(); ++i)\n      calcs[i] = true;\n  }\n\n  Stopwatch timer;\n  VNavigator *se = T::Instance();\n  NavigationState const **inpoolarray;\n  NavigationState **outpoolarray;\n  inpool.ToPlainPointerArray(inpoolarray);\n  outpool.ToPlainPointerArray(outpoolarray);\n  timer.Start();\n  if (WithSafety) {\n    se->ComputeStepsAndSafetiesAndPropagatedStates(points, dirs, step_max, inpoolarray, outpoolarray, steps, calcs,\n                                                   safeties);\n  } else {\n    se->ComputeStepsAndPropagatedStates(points, dirs, step_max, inpoolarray, outpoolarray, steps);\n  }\n  timer.Stop();\n  std::cerr << timer.Elapsed() << \"\\n\";\n  double accum(0.);\n  double saccum(0.);\n  size_t hittargetchecksum = 0L;\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    // std::cerr << \"---- \" << steps[i] << \"\\n\";\n    accum += steps[i];\n    if (WithSafety) {\n      saccum += safeties[i];\n    }\n    if (outpool[i]->Top()) hittargetchecksum += (size_t)outpool[i]->Top()->id();\n  }\n  std::cerr << \"VECTOR accum  \" << T::GetClassName() << \" \" << accum << \" target checksum \" << hittargetchecksum\n            << \"\\n\";\n  if (WithSafety) {\n    std::cerr << \"VECTOR saccum  \" << T::GetClassName() << \" \" << saccum << \"\\n\";\n    vecCore::AlignedFree(safeties);\n  }\n  vecCore::AlignedFree(steps);\n  vecCore::AlignedFree(step_max);\n  delete[] inpoolarray;\n  delete[] outpoolarray;\n}\n\ntemplate <typename T, bool WithSafety = true>\n__attribute__((noinline)) void benchVectorNavigatorNoReloc(SOA3D<Precision> const &__restrict__ points,\n                                                           SOA3D<Precision> const &__restrict__ dirs,\n                                                           NavStatePool const &__restrict__ inpool,\n                                                           NavStatePool &__restrict__ outpool)\n{\n  Precision *step_max = (double *)vecCore::AlignedAlloc(32, sizeof(double) * points.size());\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    step_max[i] = gMAXSTEP;\n  }\n  Precision *steps    = (double *)vecCore::AlignedAlloc(32, sizeof(double) * points.size());\n  Precision *safeties = nullptr;\n  bool *calcs;\n\n  if (WithSafety) {\n    safeties = (double *)vecCore::AlignedAlloc(32, sizeof(double) * points.size());\n    calcs    = (bool *)vecCore::AlignedAlloc(32, sizeof(bool) * points.size());\n    for (decltype(points.size()) i = 0; i < points.size(); ++i)\n      calcs[i] = true;\n  }\n\n  Stopwatch timer;\n  VNavigator *se = T::Instance();\n  NavigationState const **inpoolarray;\n  NavigationState **outpoolarray;\n  inpool.ToPlainPointerArray(inpoolarray);\n  outpool.ToPlainPointerArray(outpoolarray);\n  timer.Start();\n  if (WithSafety) {\n    se->ComputeStepsAndSafeties(points, dirs, step_max, inpoolarray, steps, calcs, safeties);\n  } else {\n    // nothing to do\n  }\n  timer.Stop();\n  std::cerr << timer.Elapsed() << \"\\n\";\n  double accum(0.);\n  double saccum(0.);\n  size_t hittargetchecksum = 0L;\n  for (decltype(points.size()) i = 0; i < points.size(); ++i) {\n    // std::cerr << \"---- \" << steps[i] << \"\\n\";\n    accum += steps[i];\n    if (WithSafety) {\n      saccum += safeties[i];\n    }\n    if (outpool[i]->Top()) hittargetchecksum += (size_t)outpool[i]->Top()->id();\n  }\n  std::cerr << \"VECTOR accum  \" << T::GetClassName() << \" \" << accum << \" target checksum \" << hittargetchecksum\n            << \"\\n\";\n  if (WithSafety) {\n    std::cerr << \"VECTOR saccum  \" << T::GetClassName() << \" \" << saccum << \"\\n\";\n    vecCore::AlignedFree(safeties);\n  }\n  vecCore::AlignedFree(steps);\n  vecCore::AlignedFree(step_max);\n  delete[] inpoolarray;\n  delete[] outpoolarray;\n}\n\ntemplate <bool WithSafety = false>\nvoid benchDifferentNavigators(SOA3D<Precision> const &points, SOA3D<Precision> const &dirs, NavStatePool &pool,\n                              NavStatePool &outpool, std::string outfilenamebase)\n{\n  std::cerr << \"##\\n\";\n  if (gSpecializedLib) {\n    RUNBENCH((benchNavigator<WithSafety>(gSpecializedNavigator, points, dirs, pool, outpool)));\n  }\n  std::cerr << \"##\\n\";\n  RUNBENCH((benchNavigator<WithSafety>(NewSimpleNavigator<false>::Instance(), points, dirs, pool, outpool)));\n  std::stringstream str;\n  str << outfilenamebase << \"_simple.bin\";\n  outpool.ToFile(str.str());\n  std::cerr << \"##\\n\";\n  RUNBENCH((benchNavigator<WithSafety>(NewSimpleNavigator<true>::Instance(), points, dirs, pool, outpool)));\n  std::cerr << \"##\\n\";\n\n#ifdef VECGEOM_ROOT\n  benchmarkROOTNavigator<WithSafety>(points, dirs);\n#ifdef VECGEOM_GEANT4\n  benchmarkG4Navigator<WithSafety>(points, dirs);\n#endif // VECGEOM_GEANT4\n#endif\n\n#ifdef BENCH_GENERATED_NAVIGATOR\n  RUNBENCH((benchNavigator<GeneratedNavigator, WithSafety>(points, dirs, pool, outpool)));\n  outpool.ToFile(\"generatedoutpool.bin\");\n  std::cerr << \"##\\n\";\n  RUNBENCH((benchVectorNavigator<GeneratedNavigator, WithSafety>(points, dirs, pool, outpool)));\n  std::cerr << \"##\\n\";\n#endif\n  if (gBenchVecInterface) {\n    RUNBENCH((benchVectorNavigator<NewSimpleNavigator<false>, WithSafety>(points, dirs, pool, outpool)));\n    std::cerr << \"##\\n\";\n    RUNBENCH((benchVectorNavigator<NewSimpleNavigator<true>, WithSafety>(points, dirs, pool, outpool)));\n    std::cerr << \"##\\n\";\n  }\n  RUNBENCH((benchNavigator<WithSafety>(SimpleABBoxNavigator<false>::Instance(), points, dirs, pool, outpool)));\n  std::cerr << \"##\\n\";\n  RUNBENCH((benchNavigator<WithSafety>(SimpleABBoxNavigator<false>::Instance(), points, dirs, pool, outpool)));\n  std::cerr << \"##\\n\";\n  if (gBenchVecInterface) {\n    RUNBENCH((benchVectorNavigator<SimpleABBoxNavigator<false>, WithSafety>(points, dirs, pool, outpool)));\n    std::cerr << \"##\\n\";\n    RUNBENCH((benchVectorNavigator<SimpleABBoxNavigator<true>, WithSafety>(points, dirs, pool, outpool)));\n    std::cerr << \"##\\n\";\n  }\n  RUNBENCH((benchNavigator<WithSafety>(HybridNavigator<false>::Instance(), points, dirs, pool, outpool)));\n  std::cerr << \"##\\n\";\n  RUNBENCH((benchNavigator<WithSafety>(HybridNavigator<true>::Instance(), points, dirs, pool, outpool)));\n  std::cerr << \"##\\n\";\n  if (gBenchVecInterface) {\n    RUNBENCH((benchVectorNavigator<HybridNavigator<false>, WithSafety>(points, dirs, pool, outpool)));\n    std::cerr << \"##\\n\";\n    RUNBENCH((benchVectorNavigator<HybridNavigator<true>, WithSafety>(points, dirs, pool, outpool)));\n    std::cerr << \"##\\n\";\n  }\n\n#ifdef VECGEOM_EMBREE\n  // Embree\n  RUNBENCH((benchNavigator<WithSafety>(EmbreeNavigator<false>::Instance(), points, dirs, pool, outpool)));\n  std::cerr << \"##\\n\";\n  RUNBENCH((benchNavigator<WithSafety>(EmbreeNavigator<true>::Instance(), points, dirs, pool, outpool)));\n  std::cerr << \"##\\n\";\n  if (gBenchVecInterface) {\n    RUNBENCH((benchVectorNavigator<EmbreeNavigator<false>, WithSafety>(points, dirs, pool, outpool)));\n    std::cerr << \"##\\n\";\n    RUNBENCH((benchVectorNavigator<EmbreeNavigator<true>, WithSafety>(points, dirs, pool, outpool)));\n    std::cerr << \"##\\n\";\n  }\n#endif\n\n#ifdef VECGEOM_ROOT\n  benchmarkROOTNavigator<WithSafety>(points, dirs);\n#ifdef VECGEOM_GEANT4\n  benchmarkG4Navigator<WithSafety>(points, dirs);\n#endif // VECGEOM_GEANT4\n#endif\n\n  std::cerr << \"## -- TESTING WITHOUT RELOC\\n\";\n  // testing interfaces without relocation\n  RUNBENCH((benchNavigatorNoReloc<WithSafety>(NewSimpleNavigator<false>::Instance(), points, dirs, pool, outpool)));\n  // the vector navigator\n  RUNBENCH((benchVectorNavigatorNoReloc<NewSimpleNavigator<false>, WithSafety>(points, dirs, pool, outpool)));\n  // testing interfaces without relocation\n  RUNBENCH((benchNavigatorNoReloc<WithSafety>(SimpleABBoxNavigator<false>::Instance(), points, dirs, pool, outpool)));\n  // the vector navigator\n  RUNBENCH((benchVectorNavigatorNoReloc<SimpleABBoxNavigator<false>, WithSafety>(points, dirs, pool, outpool)));\n\n#ifdef VECGEOM_ROOT\n  benchmarkROOTNavigator<true, false>(points, dirs);\n#endif\n  if (gAnalyseOutStates) {\n    analyseOutStates(pool, outpool);\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  // read in detector passed as argument\n  if (argc > 1) {\n    RootGeoManager::Instance().set_verbose(3);\n    RootGeoManager::Instance().LoadRootGeometry(std::string(argv[1]));\n  } else {\n    std::cerr << \"please give a ROOT geometry file\\n\";\n    return 1;\n  }\n\n  // play with some heuristics to init level locators\n  for (auto &element : GeoManager::Instance().GetLogicalVolumesMap()) {\n    LogicalVolume *lvol = element.second;\n    if (lvol->GetDaughtersp()->size() > 8) {\n      // HybridManager2::Instance().InitStructure(lvol);\n      lvol->SetLevelLocator(SimpleABBoxLevelLocator::GetInstance());\n      // lvol->SetLevelLocator(HybridLevelLocator::GetInstance());\n    }\n  }\n  InitNavigators();\n\n  std::string volname(argv[2]);\n  auto lvol = GeoManager::Instance().FindLogicalVolume(volname.c_str());\n  HybridManager2::Instance().InitStructure(lvol);\n#ifdef VECGEOM_EMBREE\n  EmbreeManager::Instance().InitStructure(lvol);\n#endif\n\n  // some output on volume\n  std::cerr << \"NavigationKernelBenchmarker run on \" << argv[2] << \" having \" << lvol->GetDaughters().size()\n            << \" daughters \\n\";\n\n  bool usecached = false;\n  int npoints    = 500000;\n  for (auto i = 3; i < argc; i++) {\n    if (!strcmp(argv[i], \"--usecache\")) usecached = true;\n    // benchmark vector interface?\n    if (!strcmp(argv[i], \"--vecbench\")) gBenchVecInterface = true;\n    // analyse state transitions\n    if (!strcmp(argv[i], \"--statetrans\")) gAnalyseOutStates = true;\n    // whether to benchmark navigation with safeties\n    if (!strcmp(argv[i], \"--withsafety\")) gBenchWithSafety = true;\n    // to set the maxstep number\n    if (!strcmp(argv[i], \"--maxstep\")) {\n      if (i + 1 < argc) {\n        gMAXSTEP = atof(argv[i + 1]);\n        std::cout << \"setting maxstep to \" << gMAXSTEP << \"\\n\";\n      }\n    }\n    // to set the number of tracks\n    if (!strcmp(argv[i], \"--ntracks\")) {\n      if (i + 1 < argc) {\n        npoints = atoi(argv[i + 1]);\n        std::cout << \"setting npoints to \" << npoints << \"\\n\";\n      }\n    }\n    if (!strcmp(argv[i], \"--navlib\")) {\n      if (i + 1 < argc) {\n        gSpecializedLib = true;\n        gSpecLibName    = argv[i + 1];\n        InitSpecializedNavigators(gSpecLibName);\n        gSpecializedNavigator = lvol->GetNavigator();\n        std::cerr << gSpecializedNavigator->GetName() << \"\\n\";\n      }\n    }\n  }\n\n  // setup data structures\n  SOA3D<Precision> points(npoints);\n  SOA3D<Precision> localpoints(npoints);\n  SOA3D<Precision> directions(npoints);\n  NavStatePool statepool(npoints, GeoManager::Instance().getMaxDepth());\n  NavStatePool statepoolout(npoints, GeoManager::Instance().getMaxDepth());\n\n  std::stringstream pstream;\n  std::string geomfilename(argv[1]);\n  std::string geomfilename_nopath(geomfilename.substr(1 + geomfilename.find_last_of(\"\\\\/\")));\n  pstream << \"points_\" << geomfilename_nopath << \"_\" << argv[2] << \".bin\";\n  std::stringstream dstream;\n  dstream << \"directions_\" << geomfilename_nopath << \"_\" << argv[2] << \".bin\";\n  std::stringstream statestream;\n  statestream << \"states_\" << geomfilename_nopath << \"_\" << argv[2] << \".bin\";\n  std::stringstream outstatestream;\n  outstatestream << \"outstates_\" << geomfilename_nopath << \"_\" << argv[2];\n  if (usecached) {\n    std::cerr << \" loading points from cache \\n\";\n    bool fail = (npoints != points.FromFile(pstream.str()));\n    fail |= (npoints != directions.FromFile(dstream.str()));\n    fail |= (npoints != statepool.FromFile(statestream.str()));\n    if (fail) {\n      std::cerr << \" loading points from cache failed ... continuing normally \\n\";\n      usecached = false;\n    }\n  }\n  if (!usecached) {\n    volumeUtilities::FillGlobalPointsAndDirectionsForLogicalVolume<SOA3D<Precision>>(lvol, localpoints, points,\n                                                                                     directions, 0.4, npoints);\n    std::cerr << \"\\n points filled\\n\";\n    for (unsigned int i = 0; i < points.size(); ++i) {\n      GlobalLocator::LocateGlobalPoint(GeoManager::Instance().GetWorld(), points[i], *(statepool[i]), true);\n      if (statepool[i]->Top()->GetLogicalVolume() != lvol) {\n        //\n        std::cerr << \"problem : point \" << i << \" probably in overlapping region \\n\";\n        points.set(i, points[i - 1]);\n        statepool[i - 1]->CopyTo(statepool[i]);\n      }\n    }\n    std::cerr << \"located ...\\n\";\n\n    points.ToFile(pstream.str());\n    directions.ToFile(dstream.str());\n    statepool.ToFile(statestream.str());\n  }\n  if (gBenchWithSafety) {\n    benchDifferentNavigators<true>(points, directions, statepool, statepoolout, outstatestream.str());\n  } else {\n    benchDifferentNavigators<false>(points, directions, statepool, statepoolout, outstatestream.str());\n  }\n  return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-vecgeom-1.1.5-xv6meoqgxmrixy3oo6xqedgyx3od4blb/spack-src/vecgeom_logo_blue_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-vecgeom-1.1.5-xv6meoqgxmrixy3oo6xqedgyx3od4blb/spack-src/vecgeom_logo_blue_big.png",
        "/tmp/vanessa/spack-stage/spack-stage-vecgeom-1.1.5-xv6meoqgxmrixy3oo6xqedgyx3od4blb/spack-src/doc/shapes_conventions.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-vecgeom-1.1.5-xv6meoqgxmrixy3oo6xqedgyx3od4blb/spack-src/doc/shapes_conventions.ppt"
    ],
    "total_files": 725
}