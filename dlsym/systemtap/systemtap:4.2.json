{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/stapdyn/dynutil.cxx": "// stapdyn utility functions\n// Copyright (C) 2014 Red Hat Inc.\n//\n// This file is part of systemtap, and is free software.  You can\n// redistribute it and/or modify it under the terms of the GNU General\n// Public License (GPL); either version 2, or (at your option) any\n// later version.\n\n#include \"config.h\"\n\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nextern \"C\" {\n#include <dlfcn.h>\n#include <err.h>\n#include <link.h>\n}\n\n#ifdef HAVE_SELINUX\n#include <selinux/selinux.h>\n#endif\n\n#include \"dynutil.h\"\n#include \"../util.h\"\n\nusing namespace std;\n\n\n// Callback for dl_iterate_phdr to look for libdyninstAPI.so\nstatic int\nguess_dyninst_rt_callback(struct dl_phdr_info *info,\n                          size_t size __attribute__ ((unused)),\n                          void *data)\n{\n  string& libdyninstAPI = *static_cast<string*>(data);\n\n  const string name = info->dlpi_name ?: \"(null)\";\n  if (name.find(\"libdyninstAPI.so\") != string::npos)\n    libdyninstAPI = name;\n\n  return 0;\n}\n\n// Look for libdyninstAPI.so in our own process, and use that\n// to guess the path for libdyninstAPI_RT.so\nstatic const string\nguess_dyninst_rt(void)\n{\n  string libdyninstAPI;\n  dl_iterate_phdr(guess_dyninst_rt_callback, &libdyninstAPI);\n\n  string libdyninstAPI_RT;\n  size_t so = libdyninstAPI.rfind(\".so\");\n  if (so != string::npos)\n    {\n      libdyninstAPI_RT = libdyninstAPI;\n      libdyninstAPI_RT.insert(so, \"_RT\");\n    }\n  return libdyninstAPI_RT;\n}\n\n\n// Check that environment DYNINSTAPI_RT_LIB exists and is a valid file.\n// If not, try to guess a good value and set it.\nbool\ncheck_dyninst_rt(void)\n{\n  static const char rt_env_name[] = \"DYNINSTAPI_RT_LIB\";\n  static const char dyn_rw_env_name[] = \"DYNINST_REWRITER_PATHS\";\n\n  char* rt_env = getenv(rt_env_name);\n  if (rt_env)\n    {\n      if (file_exists(rt_env))\n\t{\n\t  if (appendenv(dyn_rw_env_name, rt_env) != 0)\n\t    {\n\t      int olderrno = errno;\n\t      staperror() << \"Can't set \" << dyn_rw_env_name << \": \" << strerror(olderrno);\n\t      return false;\n\t    }\n\t  return true;\n\t}\n      staperror() << \"Invalid \" << rt_env_name << \": \\\"\" << rt_env << \"\\\"\" << endl;\n    }\n\n  const string rt = guess_dyninst_rt();\n  if (rt.empty() || !file_exists(rt))\n    {\n      staperror() << \"Can't find libdyninstAPI_RT.so; try setting \" << rt_env_name << endl;\n      return false;\n    }\n\n  if (appendenv(dyn_rw_env_name, rt) != 0)\n    {\n      int olderrno = errno;\n      staperror() << \"Can't set \" << rt_env_name << \": \" << strerror(olderrno);\n      return false;\n    }\n\n  return true;\n}\n\n\n// Check that SELinux settings are ok for Dyninst operation.\nbool\ncheck_dyninst_sebools(bool attach)\n{\n#ifdef HAVE_SELINUX\n  // For all these checks, we could examine errno on failure to act differently\n  // for e.g. ENOENT vs. EPERM.  But since these are just early diagnostices,\n  // I'm only going worry about successful bools for now.\n\n  // deny_ptrace is definitely a blocker for us to attach at all\n  if (security_get_boolean_active(\"deny_ptrace\") > 0)\n    {\n      staperror() << \"SELinux boolean 'deny_ptrace' is active, \"\n                       \"which blocks Dyninst\" << endl;\n      return false;\n    }\n\n  // We might have to get more nuanced about allow_execstack, especially if\n  // Dyninst is later enhanced to work around this restriction.  But for now,\n  // this is also a blocker.\n  if (security_get_boolean_active(\"allow_execstack\") == 0)\n    {\n      staperror() << \"SELinux boolean 'allow_execstack' is disabled, \"\n                       \"which blocks Dyninst\" << endl;\n      return false;\n    }\n\n  // In process-attach mode, SELinux will trigger \"avc:  denied  { execmod }\"\n  // on ld.so, when the mutator is injecting the dlopen for libdyninstAPI_RT.so.\n  if (attach && security_get_boolean_active(\"allow_execmod\") == 0)\n    {\n      staperror() << \"SELinux boolean 'allow_execmod' is disabled, \"\n                       \"which blocks Dyninst\" << endl;\n      return false;\n    }\n#else\n  (void)attach; // unused\n#endif\n\n  return true;\n}\n\n\n// Check whether a process exited cleanly\nbool\ncheck_dyninst_exit(BPatch_process *process)\n{\n  int code;\n  switch (process->terminationStatus())\n    {\n    case ExitedNormally:\n      code = process->getExitCode();\n      if (code == EXIT_SUCCESS)\n        return true;\n      stapwarn() << \"Child process exited with status \" << code << endl;\n      return false;\n\n    case ExitedViaSignal:\n      code = process->getExitSignal();\n      stapwarn() << \"Child process exited with signal \" << code\n            << \" (\" << strsignal(code) << \")\" << endl;\n      return false;\n\n    case NoExit:\n      if (process->isTerminated())\n        stapwarn() << \"Child process exited in an unknown manner\" << endl;\n      else\n        stapwarn() << \"Child process has not exited\" << endl;\n      return false;\n\n    default:\n      return false;\n    }\n}\n\n\n// Get an untyped symbol from a dlopened module.\n// If flagged as 'required', throw an exception if missing or NULL.\nvoid *\nget_dlsym(void* handle, const char* symbol, bool required)\n{\n  const char* err = dlerror(); // clear previous errors\n  void *pointer = dlsym(handle, symbol);\n  if (required)\n    {\n      if ((err = dlerror()))\n        throw std::runtime_error(\"dlsym \" + std::string(err));\n      if (pointer == NULL)\n        throw std::runtime_error(\"dlsym \" + std::string(symbol) + \" is NULL\");\n    }\n  return pointer;\n}\n\n\n//\n// Logging, warnings, and errors, oh my!\n//\n\n// A null-sink output stream, similar to /dev/null\n// (no buffer -> badbit -> quietly suppressed output)\nstatic ostream nullstream(NULL);\n\n// verbosity, increased by -v\nunsigned stapdyn_log_level = 0;\n\n// Whether to suppress warnings, set by -w\nbool stapdyn_suppress_warnings = false;\n\n// Output file name, set by -o\nchar *stapdyn_outfile_name = NULL;\n\n// Return a stream for logging at the given verbosity level.\nostream&\nstaplog(unsigned level)\n{\n  if (level > stapdyn_log_level)\n    return nullstream;\n  return clog << program_invocation_short_name << \": \";\n}\n\n// Return a stream for warning messages.\nostream&\nstapwarn(void)\n{\n  if (stapdyn_suppress_warnings)\n    return nullstream;\n  return clog << program_invocation_short_name << \": \"\n                   << colorize(\"WARNING:\", \"warning\") << \" \";\n}\n\n// Return a stream for error messages.\nostream&\nstaperror(void)\n{\n  return clog << program_invocation_short_name << \": \"\n                   << colorize(\"ERROR:\", \"error\") << \" \";\n}\n\n// Whether to color error and warning messages\nbool color_errors; // Initialized in main()\n\n// Adds coloring to strings\nstd::string\ncolorize(std::string str, std::string type)\n{\n  if (str.empty() || !color_errors)\n    return str;\n  else {\n    // Check if this type is defined in SYSTEMTAP_COLORS\n    std::string color = parse_stap_color(type);\n    if (!color.empty()) // no need to pollute terminal if not necessary\n      return \"\\033[\" + color + \"m\\033[K\" + str + \"\\033[m\\033[K\";\n    else\n      return str;\n  }\n}\n\n/* Parse SYSTEMTAP_COLORS and returns the SGR parameter(s) for the given\ntype. The env var SYSTEMTAP_COLORS must be in the following format:\n'key1=val1:key2=val2:' etc... where valid keys are 'error', 'warning',\n'source', 'caret', 'token' and valid values constitute SGR parameter(s).\nFor example, the default setting would be:\n'error=01;31:warning=00;33:source=00;34:caret=01:token=01'\n*/\nstd::string\nparse_stap_color(std::string type)\n{\n  const char *key, *col, *eq;\n  int n = type.size();\n  int done = 0;\n\n  key = getenv(\"SYSTEMTAP_COLORS\");\n  if (key == NULL)\n    key = \"error=01;31:warning=00;33:source=00;34:caret=01:token=01\";\n  else if (*key == '\\0')\n    return \"\"; // disable colors if set but empty\n\n  while (!done) {\n    if (!(col = strchr(key, ':'))) {\n      col = strchr(key, '\\0');\n      done = 1;\n    }\n    if (!((eq = strchr(key, '=')) && eq < col))\n      return \"\"; /* invalid syntax: no = in range */\n    if (!(key < eq && eq < col-1))\n      return \"\"; /* invalid syntax: key or val empty */\n    if (strspn(eq+1, \"0123456789;\") < (size_t)(col-eq-1))\n      return \"\"; /* invalid syntax: invalid char in val */\n    if (eq-key == n && type.compare(0, n, key, n) == 0)\n      return string(eq+1, col-eq-1);\n    if (!done) key = col+1; /* advance to next key */\n  }\n\n  // Could not find the key\n  return \"\";\n}\n\n/* vim: set sw=2 ts=8 cino=>4,n-2,{2,^-2,t0,(0,u0,w1,M1 : */\n",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/stapdyn/dynutil.h": "// stapdyn utility functions\n// Copyright (C) 2012 Red Hat Inc.\n//\n// This file is part of systemtap, and is free software.  You can\n// redistribute it and/or modify it under the terms of the GNU General\n// Public License (GPL); either version 2, or (at your option) any\n// later version.\n\n#ifndef DYNUTIL_H\n#define DYNUTIL_H\n\n#include <ostream>\n#include <stdexcept>\n#include <string>\n\n#include <BPatch_process.h>\n\n// Check that environment DYNINSTAPI_RT_LIB exists and is a valid file.\n// If not, try to guess a good value and set it.\nbool check_dyninst_rt(void);\n\n// Check that SELinux settings are ok for Dyninst operation.\nbool check_dyninst_sebools(bool attach=false);\n\n// Check whether a process exited cleanly\nbool check_dyninst_exit(BPatch_process *process);\n\n\n// Get an untyped symbol from a dlopened module.\n// If flagged as 'required', throw an exception if missing or NULL.\nvoid* get_dlsym(void* handle, const char* symbol, bool required=true);\n\n// Set a typed pointer by looking it up in a dlopened module.\n// If flagged as 'required', throw an exception if missing or NULL.\ntemplate <typename T> void\nset_dlsym(T*& pointer, void* handle, const char* symbol, bool required=true)\n{\n  pointer = reinterpret_cast<T*>(get_dlsym(handle, symbol, required));\n}\n\n\n//\n// Logging, warnings, and errors, oh my!\n//\n\n// verbosity, increased by -v\nextern unsigned stapdyn_log_level;\n\n// Whether to suppress warnings, set by -w\nextern bool stapdyn_suppress_warnings;\n\n// Output file name, set by -o\nextern char *stapdyn_outfile_name;\n\n// Return a stream for logging at the given verbosity level.\nstd::ostream& staplog(unsigned level=0);\n\n// Return a stream for warning messages.\nstd::ostream& stapwarn(void);\n\n// Return a stream for error messages.\nstd::ostream& staperror(void);\n\n// Whether to color error and warning messages\nextern bool color_errors;\n\n// Adds coloring to strings\nstd::string colorize(std::string str, std::string type);\n\n// Parse SYSTEMTAP_COLORS\nstd::string parse_stap_color(std::string type);\n\n#endif // DYNUTIL_H\n\n/* vim: set sw=2 ts=8 cino=>4,n-2,{2,^-2,t0,(0,u0,w1,M1 : */\n",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/stapdyn/dynprobe.cxx": "// stapdyn probe functions\n// Copyright (C) 2012-2014 Red Hat Inc.\n//\n// This file is part of systemtap, and is free software.  You can\n// redistribute it and/or modify it under the terms of the GNU General\n// Public License (GPL); either version 2, or (at your option) any\n// later version.\n\n#include \"dynprobe.h\"\n#include \"dynutil.h\"\n#include \"../util.h\"\n\nextern \"C\" {\n#include \"../runtime/dyninst/stapdyn.h\"\n}\n\n\nusing namespace std;\n\n\n// Look for probes in the stap module which need Dyninst instrumentation.\nint\nfind_dynprobes(void* module, vector<dynprobe_target>& targets)\n{\n  // We query for probes with a function interface, so first we have\n  // to get function pointers from the stap module.\n  decltype(&stp_dyninst_target_count) target_count = NULL;\n  decltype(&stp_dyninst_target_path) target_path = NULL;\n\n  decltype(&stp_dyninst_probe_count) probe_count = NULL;\n  decltype(&stp_dyninst_probe_target) probe_target = NULL;\n  decltype(&stp_dyninst_probe_offset) probe_offset = NULL;\n  decltype(&stp_dyninst_probe_semaphore) probe_semaphore = NULL;\n\n  // If we don't even have this, then there aren't any uprobes in the module.\n  set_dlsym(target_count, module, \"stp_dyninst_target_count\", false);\n  if (target_count == NULL)\n    return 0;\n\n  try\n    {\n      // If target_count exists, the rest of these should too.\n      set_dlsym(target_path, module, \"stp_dyninst_target_path\");\n      set_dlsym(probe_count, module, \"stp_dyninst_probe_count\");\n      set_dlsym(probe_target, module, \"stp_dyninst_probe_target\");\n      set_dlsym(probe_offset, module, \"stp_dyninst_probe_offset\");\n      set_dlsym(probe_semaphore, module, \"stp_dyninst_probe_semaphore\");\n    }\n  catch (runtime_error& e)\n    {\n      staperror() << e.what() << endl;\n      return 1;\n    }\n\n  // This is optional - was only added post-2.0\n  decltype(&stp_dyninst_probe_flags) probe_flags = NULL;\n  set_dlsym(probe_flags, module, \"stp_dyninst_probe_flags\", false);\n\n  // Construct all the targets in the module.\n  const uint64_t ntargets = target_count();\n  for (uint64_t i = 0; i < ntargets; ++i)\n    {\n      const char* path = target_path(i);\n      if (path == NULL)\n\t  path = \"\";\n      dynprobe_target target(path);\n      targets.push_back(target);\n    }\n\n  // Construct all the probes in the module,\n  // and associate each with their target.\n  const uint64_t nprobes = probe_count();\n  for (uint64_t i = 0; i < nprobes; ++i)\n    {\n      uint64_t target_index = probe_target(i);\n      uint64_t offset = probe_offset(i);\n      uint64_t semaphore = probe_semaphore(i);\n      uint64_t flags = probe_flags ? probe_flags(i) : 0;\n      dynprobe_location p(i, offset, semaphore, flags);\n      if (p.validate() && target_index < ntargets)\n        targets[target_index].probes.push_back(p);\n    }\n\n  // For debugging, dump what we found.\n  for (uint64_t i = 0; i < ntargets; ++i)\n    {\n      dynprobe_target& t = targets[i];\n      staplog(3) << \"target \\\"\" << t.path << \"\\\" has \"\n                 << t.probes.size() << \" probes\" << endl;\n      for (uint64_t j = 0; j < t.probes.size(); ++j)\n        staplog(3) << \"  offset:\" << lex_cast_hex(t.probes[j].offset)\n                   << \" semaphore:\" << lex_cast_hex(t.probes[j].semaphore)\n                   << \" flags:\" << lex_cast_hex(t.probes[j].flags) << endl;\n    }\n\n  return 0;\n}\n\n\ndynprobe_location::dynprobe_location(uint64_t index, uint64_t offset,\n                                     uint64_t semaphore, uint64_t flags):\n      index(index), offset(offset), semaphore(semaphore),\n      flags(flags), return_p(flags & STAPDYN_PROBE_FLAG_RETURN)\n{\n}\n\nbool\ndynprobe_location::validate()\n{\n  if (flags & ~STAPDYN_PROBE_ALL_FLAGS)\n    {\n      stapwarn() << \"Unknown flags \" << lex_cast_hex(flags)\n                 << \" in probe \" << index << endl;\n      return false;\n    }\n\n  return true;\n}\n\n\n/* vim: set sw=2 ts=8 cino=>4,n-2,{2,^-2,t0,(0,u0,w1,M1 : */\n",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/stapdyn/mutator.cxx": "// stapdyn mutator functions\n// Copyright (C) 2012-2018 Red Hat Inc.\n//\n// This file is part of systemtap, and is free software.  You can\n// redistribute it and/or modify it under the terms of the GNU General\n// Public License (GPL); either version 2, or (at your option) any\n// later version.\n\n#include \"mutator.h\"\n\n#include <algorithm>\n\nextern \"C\" {\n#include <dlfcn.h>\n#include <wordexp.h>\n#include <signal.h>\n#include <time.h>\n}\n\n#include <BPatch_snippet.h>\n\n#include \"dynutil.h\"\n#include \"../util.h\"\n\nextern \"C\" {\n#include \"../runtime/dyninst/stapdyn.h\"\n}\n\nusing namespace std;\n\n\n// NB: since Dyninst callbacks have no context, we have to demux it\n// to every mutator we've created, tracked by this vector.\nstatic vector<mutator*> g_mutators;\n\nstatic void\ng_dynamic_library_callback(BPatch_thread *thread,\n                           BPatch_object *object,\n                           bool load)\n{\n  for (size_t i = 0; i < g_mutators.size(); ++i)\n    g_mutators[i]->dynamic_library_callback(thread, object, load);\n}\n\n#ifndef DYNINST_9_1\nstatic void\ng_dynamic_module_callback(BPatch_thread *thread,\n                          BPatch_module *module,\n                          bool load)\n{\n  g_dynamic_library_callback(thread, module->getObject(), load);\n}\n#define g_dynamic_library_callback g_dynamic_module_callback\n#endif\n\n\nstatic void\ng_post_fork_callback(BPatch_thread *parent, BPatch_thread *child)\n{\n  for (size_t i = 0; i < g_mutators.size(); ++i)\n    g_mutators[i]->post_fork_callback(parent, child);\n}\n\n\nstatic void\ng_exec_callback(BPatch_thread *thread)\n{\n  for (size_t i = 0; i < g_mutators.size(); ++i)\n    g_mutators[i]->exec_callback(thread);\n}\n\n\nstatic void\ng_exit_callback(BPatch_thread *thread, BPatch_exitType type)\n{\n  for (size_t i = 0; i < g_mutators.size(); ++i)\n    g_mutators[i]->exit_callback(thread, type);\n}\n\n\nstatic void\ng_thread_create_callback(BPatch_process *proc, BPatch_thread *thread)\n{\n  for (size_t i = 0; i < g_mutators.size(); ++i)\n    g_mutators[i]->thread_create_callback(proc, thread);\n}\n\n\nstatic void\ng_thread_destroy_callback(BPatch_process *proc, BPatch_thread *thread)\n{\n  for (size_t i = 0; i < g_mutators.size(); ++i)\n    g_mutators[i]->thread_destroy_callback(proc, thread);\n}\n\n\nstatic pthread_t g_main_thread = pthread_self();\nstatic const sigset_t *g_signal_mask;\n\nstatic void\ng_signal_handler(int signal)\n{\n  /* We only want the signal on our main thread, so it will interrupt the ppoll\n   * loop.  If we get it on a different thread, just forward it.  */\n  if (!pthread_equal(pthread_self(), g_main_thread))\n    {\n      pthread_kill(g_main_thread, signal);\n      return;\n    }\n\n  for (size_t i = 0; i < g_mutators.size(); ++i)\n    g_mutators[i]->signal_callback(signal);\n}\n\n__attribute__((constructor))\nstatic void\nsetup_signals (void)\n{\n  struct sigaction sa;\n  static sigset_t mask;\n  static const int signals[] = {\n      SIGHUP, SIGINT, SIGTERM, SIGQUIT,\n  };\n\n  /* Prepare the global sigmask for future use.  */\n  sigemptyset (&mask);\n  for (size_t i = 0; i < sizeof(signals) / sizeof(*signals); ++i)\n    sigaddset (&mask, signals[i]);\n  g_signal_mask = &mask;\n\n  /* Prepare the common signal handler.  */\n  memset(&sa, 0, sizeof(sa));\n  sa.sa_handler = g_signal_handler;\n  sa.sa_flags = SA_RESTART;\n  sigemptyset (&sa.sa_mask);\n  for (size_t i = 0; i < sizeof(signals) / sizeof(*signals); ++i)\n    sigaddset (&sa.sa_mask, signals[i]);\n\n  /* Activate the handler for every signal.  */\n  for (size_t i = 0; i < sizeof(signals) / sizeof(*signals); ++i)\n    sigaction (signals[i], &sa, NULL);\n}\n\n\nmutator::mutator (const string& module_name,\n                  vector<string>& module_options):\n  module(NULL), module_name(resolve_path(module_name)),\n  modoptions(module_options), p_target_created(false),\n  p_target_error(false), utrace_enter_fn(NULL)\n{\n  // NB: dlopen does a library-path search if the filename doesn't have any\n  // path components, which is why we use resolve_path(module_name)\n\n  sigemptyset(&signals_received);\n\n  g_mutators.push_back(this);\n}\n\nmutator::~mutator ()\n{\n  // Explicitly drop our mutatee references, so we better\n  // control when their instrumentation is removed.\n  target_mutatee.reset();\n  mutatees.clear();\n\n  if (module)\n    {\n      dlclose(module);\n      module = NULL;\n    }\n\n  g_mutators.erase(find(g_mutators.begin(), g_mutators.end(), this));\n}\n\n\n// Do probes matching 'flag' exist?\nbool\nmutator::matching_probes_exist(uint64_t flag)\n{\n  for (size_t i = 0; i < targets.size(); ++i)\n    {\n      for (size_t j = 0; j < targets[i].probes.size(); ++j)\n        {\n\t  if (targets[i].probes[j].flags & flag)\n\t    return true;\n\t}\n    }\n  return false;\n}\n\n\n// Load the stap module and initialize all probe info.\nbool\nmutator::load ()\n{\n  int rc;\n\n  // Open the module directly, so we can query probes or run simple ones.\n  (void)dlerror(); // clear previous errors\n  module = dlopen(module_name.c_str(), RTLD_NOW);\n  if (!module)\n    {\n      staperror() << \"dlopen \" << dlerror() << endl;\n      return false;\n    }\n\n  if ((rc = find_dynprobes(module, targets)))\n    return rc;\n  if (!targets.empty())\n    {\n      // Always watch for new libraries to probe.\n      patch.registerDynLibraryCallback(g_dynamic_library_callback);\n\n      // Always watch for new child processes, even if we don't have\n      // STAPDYN_PROBE_FLAG_PROC_BEGIN, because we might want to trigger\n      // any of the other types of probes in new processes too.\n      patch.registerPostForkCallback(g_post_fork_callback);\n      patch.registerExecCallback(g_exec_callback);\n\n      // Do we need a exit callback?\n      if (matching_probes_exist(STAPDYN_PROBE_FLAG_PROC_END))\n\tpatch.registerExitCallback(g_exit_callback);\n\n      // Do we need a thread create callback?\n      if (matching_probes_exist(STAPDYN_PROBE_FLAG_THREAD_BEGIN))\n\tpatch.registerThreadEventCallback(BPatch_threadCreateEvent,\n\t\t\t\t\t  g_thread_create_callback);\n\n      // Do we need a thread destroy callback?\n      if (matching_probes_exist(STAPDYN_PROBE_FLAG_THREAD_END))\n\tpatch.registerThreadEventCallback(BPatch_threadDestroyEvent,\n\t\t\t\t\t  g_thread_destroy_callback);\n    }\n\n  return true;\n}\n\n// Create a new process with the given command line\nbool\nmutator::create_process(const string& command)\n{\n  if (target_mutatee)\n    {\n      staperror() << \"Already attached to a target process!\" << endl;\n      return false;\n    }\n\n  // Split the command into words.  If wordexp can't do it,\n  // we'll just run via \"sh -c\" instead.\n  const char** child_argv;\n  const char* sh_argv[] = { \"/bin/sh\", \"-c\", command.c_str(), NULL };\n  wordexp_t words;\n  int rc = wordexp (command.c_str(), &words, WRDE_NOCMD|WRDE_UNDEF);\n  if (rc == 0)\n    child_argv = (/*cheater*/ const char**) words.we_wordv;\n  else if (rc == WRDE_BADCHAR)\n    child_argv = sh_argv;\n  else\n    {\n      staperror() << \"wordexp parsing error (\" << rc << \")\" << endl;\n      return false;\n    }\n\n  // Search the PATH if necessary, then create the target process!\n  string fullpath = find_executable(child_argv[0]);\n  BPatch_process* app = patch.processCreate(fullpath.c_str(), child_argv);\n  if (!app)\n    {\n      staperror() << \"Couldn't create the target process\" << endl;\n      return false;\n    }\n\n  auto m = make_shared<mutatee>(app);\n  mutatees.push_back(m);\n  target_mutatee = m;\n  p_target_created = true;\n\n  if (!m->load_stap_dso(module_name))\n    return false;\n\n  if (!targets.empty())\n    m->instrument_dynprobes(targets);\n\n  return true;\n}\n\n// Attach to a specific existing process.\nbool\nmutator::attach_process(pid_t pid)\n{\n  if (target_mutatee)\n    {\n      staperror() << \"Already attached to a target process!\" << endl;\n      return false;\n    }\n\n  BPatch_process* app = patch.processAttach(NULL, pid);\n  if (!app)\n    {\n      staperror() << \"Couldn't attach to the target process\" << endl;\n      return false;\n    }\n\n  auto m = make_shared<mutatee>(app);\n  mutatees.push_back(m);\n  target_mutatee = m;\n  p_target_created = false;\n\n  if (!m->load_stap_dso(module_name))\n    return false;\n\n  if (!targets.empty())\n    m->instrument_dynprobes(targets);\n\n  return true;\n}\n\nbool\nmutator::init_modoptions()\n{\n  decltype(&stp_global_setter) global_setter = NULL;\n  set_dlsym(global_setter, module, \"stp_global_setter\", false);\n\n  if (global_setter == NULL)\n    {\n      // Hypothetical backwards compatibility with older stapdyn:\n      stapwarn() << \"Compiled module does not support -G globals\" << endl;\n      return true; // soft warning; let it go on anyway\n    }\n\n  for (vector<string>::iterator it = modoptions.begin();\n       it != modoptions.end(); it++)\n    {\n      string modoption = *it;\n\n      // Parse modoption as \"name=value\"\n      // XXX: compare whether this behaviour fits safety regex in buildrun.cxx\n      string::size_type separator = modoption.find('=');\n      if (separator == string::npos)\n        {\n          staperror() << \"Could not parse module option '\" << modoption << \"'\" << endl;\n          return false; // XXX: perhaps ignore the option instead?\n        }\n      string name = modoption.substr(0, separator);\n      string value = modoption.substr(separator+1);\n\n      int rc = global_setter(name.c_str(), value.c_str());\n      if (rc == -ENOENT)\n        {\n          stapwarn() << \"Ignoring unknown module option '\" << name << \"'\" << endl;\n          continue; // soft warning; let it go on anyway\n        }\n      else if (rc != 0)\n        {\n          staperror() << \"module option '\" << modoption << \"': \"\n                      << strerror(abs(rc)) << endl;\n          return false;\n        }\n    }\n\n  return true;\n}\n\nvoid\nmutator::init_session_attributes()\n{\n  decltype(&stp_global_setter) global_setter = NULL;\n  set_dlsym(global_setter, module, \"stp_global_setter\", false);\n\n  if (global_setter == NULL)\n    {\n      // Just return.\n      return;\n    }\n\n  // Note that the list of supported attributes should match with the\n  // list in 'struct _stp_sesion_attributes' in\n  // runtime/dyninst/session_attributes.h.\n\n  int rc = global_setter(\"@log_level\", lex_cast(stapdyn_log_level).c_str());\n  if (rc != 0)\n    stapwarn() << \"Couldn't set 'log_level' global\" << endl;\n\n  rc = global_setter(\"@suppress_warnings\",\n\t\t     lex_cast(stapdyn_suppress_warnings).c_str());\n  if (rc != 0)\n    stapwarn() << \"Couldn't set 'suppress_warnings' global\" << endl;\n\n  rc = global_setter(\"@stp_pid\", lex_cast(getpid()).c_str());\n  if (rc != 0)\n    stapwarn() << \"Couldn't set 'stp_pid' global\" << endl;\n\n  if (target_mutatee)\n    {\n      rc = global_setter(\"@target\", lex_cast(target_mutatee->process_id()).c_str());\n      if (rc != 0)\n        stapwarn() << \"Couldn't set 'target' global\" << endl;\n    }\n\n  size_t module_endpath = module_name.rfind('/');\n  size_t module_basename_start =\n    (module_endpath != string::npos) ? module_endpath + 1 : 0;\n  size_t module_basename_end = module_name.find('.', module_basename_start);\n  size_t module_basename_len = module_basename_end - module_basename_start;\n  string module_basename(module_name, module_basename_start, module_basename_len);\n  rc = global_setter(\"@module_name\", module_basename.c_str());\n  if (rc != 0)\n    stapwarn() << \"Couldn't set 'module_name' global\" << endl;\n\n  time_t now_t = time(NULL);\n  struct tm* now = localtime(&now_t);\n  if (now)\n    {\n      rc = global_setter(\"@tz_gmtoff\", lex_cast(-now->tm_gmtoff).c_str());\n      if (rc != 0)\n        stapwarn() << \"Couldn't set 'tz_gmtoff' global\" << endl;\n      rc = global_setter(\"@tz_name\", now->tm_zone);\n      if (rc != 0)\n        stapwarn() << \"Couldn't set 'tz_name' global\" << endl;\n    }\n  else\n    stapwarn() << \"Couldn't discover local timezone info\" << endl;\n\n  if (stapdyn_outfile_name)\n    {\n      rc = global_setter(\"@outfile_name\",\n\t\t\t lex_cast(stapdyn_outfile_name).c_str());\n      if (rc != 0)\n\tstapwarn() << \"Couldn't set 'outfile_name' global\" << endl;\n    }\n\n  return;\n}\n\n// Initialize the module session\nbool\nmutator::run_module_init()\n{\n  if (!module)\n    return false;\n\n  // First see if this is a shared-memory, multiprocess-capable module\n  decltype(&stp_dyninst_shm_init) shm_init = NULL;\n  decltype(&stp_dyninst_shm_connect) shm_connect = NULL;\n  set_dlsym(shm_init, module, \"stp_dyninst_shm_init\", false);\n  set_dlsym(shm_connect, module, \"stp_dyninst_shm_connect\", false);\n  if (shm_init && shm_connect)\n    {\n      // Initialize the shared-memory locally.\n      const char* shmem = shm_init();\n      if (shmem == NULL)\n        {\n          stapwarn() << \"stp_dyninst_shm_init failed!\" << endl;\n          return false;\n        }\n      module_shmem = shmem;\n      // After the session is initilized, then we'll map shmem in the target\n    }\n  else if (target_mutatee)\n    {\n      // For modules that don't support shared-memory, but still have a target\n      // process, we'll run init/exit in the target.\n      target_mutatee->call_function(\"stp_dyninst_session_init\");\n      return true;\n    }\n\n  // From here, either this is a shared-memory module,\n  // or we have no target and thus run init directly anyway.\n\n  decltype(&stp_dyninst_session_init) session_init = NULL;\n  try\n    {\n      set_dlsym(session_init, module, \"stp_dyninst_session_init\");\n    }\n  catch (runtime_error& e)\n    {\n      staperror() << e.what() << endl;\n      return false;\n    }\n\n  // Before init runs, set any custom variables\n  if (!modoptions.empty() && !init_modoptions())\n    return false;\n\n  init_session_attributes();\n\n  int rc = session_init();\n  if (rc)\n    {\n      stapwarn() << \"stp_dyninst_session_init returned \" << rc << endl;\n      return false;\n    }\n\n  // Now we map the shared-memory into the target\n  if (target_mutatee && !module_shmem.empty())\n    {\n      vector<BPatch_snippet *> args;\n      args.push_back(new BPatch_constExpr(module_shmem.c_str()));\n      target_mutatee->call_function(\"stp_dyninst_shm_connect\", args);\n    }\n\n  return true;\n}\n\n// Shutdown the module session\nbool\nmutator::run_module_exit()\n{\n  if (!module)\n    return false;\n\n  if (target_mutatee && module_shmem.empty())\n    {\n      // For modules that don't support shared-memory, but still have a target\n      // process, we'll run init/exit in the target.\n      // XXX This may already have been done in its deconstructor if the process exited.\n      target_mutatee->call_function(\"stp_dyninst_session_exit\");\n      return true;\n    }\n\n  // From here, either this is a shared-memory module,\n  // or we have no target and thus run exit directly anyway.\n\n  decltype(&stp_dyninst_session_exit) session_exit = NULL;\n  try\n    {\n      set_dlsym(session_exit, module, \"stp_dyninst_session_exit\");\n    }\n  catch (runtime_error& e)\n    {\n      staperror() << e.what() << endl;\n      return false;\n    }\n\n  session_exit();\n  return true;\n}\n\n\n// Check the status of all mutatees\nbool\nmutator::update_mutatees()\n{\n  // We'll always break right away for SIGQUIT.  We'll also break for any other\n  // signal if we didn't create the process.  Otherwise, we should give the\n  // created process a chance to finish.\n  if (sigismember(&signals_received, SIGQUIT) ||\n      (!sigisemptyset(&signals_received) && !p_target_created))\n    return false;\n\n  if (target_mutatee && target_mutatee->is_terminated())\n    return false;\n\n  for (size_t i = 0; i < mutatees.size();)\n    {\n      auto m = mutatees[i];\n      if (m != target_mutatee && m->is_terminated())\n        {\n          mutatees.erase(mutatees.begin() + i);\n          continue; // NB: without ++i\n        }\n      ++i;\n    }\n\n  return true;\n}\n\n\n// Start the actual systemtap session!\nbool\nmutator::run ()\n{\n  if (!targets.empty() && !target_mutatee)\n    stapwarn() << \"process probes require a target (-c or -x)\" << endl;\n\n  // Get the stap module ready...\n  if (!run_module_init())\n    {\n      // Detach from everything\n      target_mutatee.reset();\n      mutatees.clear();\n\n      return false;\n    }\n\n  // And away we go!\n  if (target_mutatee)\n    {\n      // For our first event, fire the target's process.begin probes (if any)\n      target_mutatee->begin_callback();\n      target_mutatee->continue_execution();\n\n      // Dyninst's notification FD was fixed in 8.1; for earlier versions we'll\n      // fall back to the fully-blocking wait for now.\n#ifdef DYNINST_8_1\n      // mask signals while we're preparing to poll\n      stap_sigmasker masked(g_signal_mask);\n\n      pollfd pfd;\n      pfd.fd = patch.getNotificationFD();\n      pfd.events = POLLIN;\n      pfd.revents = 0;\n\n      // Polling with a notification FD lets us wait on Dyninst while still\n      // letting signals break us out of the loop.\n      while (update_mutatees())\n        {\n          struct timespec timeout = { 10, 0 };\n\n          // When a mutatee exits, the cleanup may cause dyninstAPI to dequeue\n          // other events from proccontrol (which clears the poll FD), without\n          // actually processing those events yet.  Check before we sleep...\n          if (patch.pollForStatusChange())\n            continue;\n\n          int rc = ppoll (&pfd, 1, &timeout, &masked.old);\n          if (rc < 0 && errno != EINTR)\n            break;\n\n          // Acknowledge and activate whatever events are waiting\n          patch.pollForStatusChange();\n        }\n#else\n      while (update_mutatees())\n        patch.waitForStatusChange();\n#endif\n    }\n  else // !target_mutatee\n    {\n      // With no mutatees, we just wait for a signal to exit.\n      stap_sigmasker masked(g_signal_mask);\n      while (sigisemptyset(&signals_received))\n        sigsuspend(&masked.old);\n    }\n\n  // Indicate failure if the target had anything but EXIT_SUCCESS\n  if (target_mutatee && target_mutatee->is_terminated())\n    p_target_error = !target_mutatee->check_exit();\n\n  // Apply a timeout to the following; dyninst or other bugs can\n  // sometimes hang during this stage (PR23572).\n  alarm(30);\n  // Detach from everything\n  target_mutatee.reset();\n  mutatees.clear();\n  // Stand down.\n  alarm(0);\n  \n  // Shutdown the stap module.\n  return run_module_exit();\n}\n\n\n// Get the final exit status of this mutator\nint mutator::exit_status ()\n{\n  if (!module)\n    return EXIT_FAILURE;\n\n  // NB: Only shm modules are new enough to have stp_dyninst_exit_status at\n  // all, so we don't need to try in-target for old modules like session_exit.\n\n  decltype(&stp_dyninst_exit_status) get_exit_status = NULL;\n  set_dlsym(get_exit_status, module, \"stp_dyninst_exit_status\", false);\n  if (get_exit_status)\n    {\n      int status = get_exit_status();\n      if (status != EXIT_SUCCESS)\n        return status;\n    }\n\n  return p_target_error ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n\n\n// Find a mutatee which matches the given process, else return NULL\nshared_ptr<mutatee>\nmutator::find_mutatee(BPatch_process* process)\n{\n  for (size_t i = 0; i < mutatees.size(); ++i)\n    if (*mutatees[i] == process)\n      return mutatees[i];\n  return {};\n}\n\n\n// Callback to respond to dynamically loaded libraries.\n// Check if it matches our targets, and instrument accordingly.\nvoid\nmutator::dynamic_library_callback(BPatch_thread *thread,\n                                  BPatch_object *object,\n                                  bool load)\n{\n  if (!load || !thread || !object)\n    return;\n\n  BPatch_process* process = thread->getProcess();\n  staplog(1) << \"dlopen \\\"\" << object->name()\n             << \"\\\", pid = \" << process->getPid() << endl;\n  auto mut = find_mutatee(process);\n  if (mut)\n    mut->instrument_object_dynprobes(object, targets);\n}\n\n\n// Callback to respond to post fork events.  Check if it matches our\n// targets, and handle accordingly.\nvoid\nmutator::post_fork_callback(BPatch_thread *parent, BPatch_thread *child)\n{\n  if (!child || !parent)\n    return;\n\n  BPatch_process* child_process = child->getProcess();\n  BPatch_process* parent_process = parent->getProcess();\n\n  staplog(1) << \"post fork, parent \" << parent_process->getPid()\n\t     << \", child \" << child_process->getPid() << endl;\n\n  auto mut = find_mutatee(parent_process);\n  if (mut)\n    {\n      // Clone the mutatee for the new process.\n      auto m = make_shared<mutatee>(child_process);\n      mutatees.push_back(m);\n      m->copy_forked_instrumentation(*mut);\n\n      // Trigger any process.begin probes.\n      m->begin_callback(child);\n    }\n}\n\n\n// Callback to respond to exec events.  Check if it matches our\n// targets, and handle accordingly.\nvoid\nmutator::exec_callback(BPatch_thread *thread)\n{\n  if (!thread)\n    return;\n\n  BPatch_process* process = thread->getProcess();\n\n  staplog(1) << \"exec, pid = \" << process->getPid() << endl;\n\n  auto mut = find_mutatee(process);\n  if (mut)\n    {\n      // Clear previous instrumentation\n      mut->exec_reset_instrumentation();\n\n      // NB: Until Dyninst commit 2b6c10ac15dc (in 8.2), loadLibrary in a\n      // fork-execed would hang waiting for a stopped process to continue.\n#ifdef DYNINST_8_2\n      // Load our module again in the new process\n      if (mut->load_stap_dso(module_name))\n        {\n          if (!targets.empty())\n            mut->instrument_dynprobes(targets);\n\n          // Now we map the shared-memory into the target\n          if (!module_shmem.empty())\n            {\n              vector<BPatch_snippet *> args;\n              args.push_back(new BPatch_constExpr(module_shmem.c_str()));\n              mut->call_function(\"stp_dyninst_shm_connect\", args);\n            }\n\n          // Trigger any process.end probes for the pre-exec process.\n          mut->exit_callback(thread, true);\n\n          // Trigger any process.begin probes.\n          mut->begin_callback(thread);\n        }\n#endif\n    }\n}\n\n\nvoid\nmutator::exit_callback(BPatch_thread *thread,\n\t\t       BPatch_exitType type __attribute__((unused)))\n{\n  if (!thread)\n    return;\n\n  // 'thread' is the thread that requested the exit, not necessarily the\n  // main thread.\n  BPatch_process* process = thread->getProcess();\n  int pid = process->getPid();\n  staplog(1) << \"exit callback, pid = \" << pid << endl;\n\n  auto mut = find_mutatee(process);\n  if (mut)\n    {\n      // FIXME: We'd like to call the mutatee's exit_callback()\n      // function, but we've got a problem. The mutatee can't stop the\n      // process to call the exit probe within the target (it finishes\n      // exiting before we can). So, we'll call the probe(s) locally\n      // here. This works, but the context is wrong (the mutator, not\n      // the mutatee).\n      const vector<dynprobe_location>& proc_end_probes =\n\tmut->find_attached_probes(STAPDYN_PROBE_FLAG_PROC_END);\n      if (proc_end_probes.empty())\n\treturn;\n\n      if (utrace_enter_fn == NULL)\n\ttry\n\t  {\n\t    set_dlsym(utrace_enter_fn, module, \"enter_dyninst_utrace_probe\");\n\t  }\n\tcatch (runtime_error& e)\n\t  {\n\t    staperror() << e.what() << endl;\n\t    return;\n\t  }\n\n      staplog(2) << \"firing \" << proc_end_probes.size()\n\t\t << \" process.end probes in the mutator for pid \"\n\t\t << pid << endl;\n      for (size_t p = 0; p < proc_end_probes.size(); ++p)\n        {\n\t  const dynprobe_location& probe = proc_end_probes[p];\n\t  staplog(3) << \"calling utrace function in the mutator for pid \"\n\t\t     << pid << \", probe index \" << probe.index << endl;\n\t  int rc = utrace_enter_fn(probe.index, NULL);\n\t  if (rc)\n\t    stapwarn() << \"enter_dyninst_utrace_probe returned \"\n\t\t       << rc << endl;\n\t}\n    }\n}\n\n\nvoid\nmutator::thread_create_callback(BPatch_process *proc, BPatch_thread *thread)\n{\n  if (!proc || !thread)\n    return;\n\n  auto mut = find_mutatee(proc);\n  if (mut)\n    mut->thread_callback(thread, true);\n}\n\n\nvoid\nmutator::thread_destroy_callback(BPatch_process *proc, BPatch_thread *thread)\n{\n  if (!proc || !thread)\n    return;\n\n  auto mut = find_mutatee(proc);\n  if (mut)\n    mut->thread_callback(thread, false);\n}\n\n\n// Callback to respond to signals.\nvoid\nmutator::signal_callback(int signal)\n{\n  sigaddset(&signals_received, signal);\n}\n\n\n/* vim: set sw=2 ts=8 cino=>4,n-2,{2,^-2,t0,(0,u0,w1,M1 : */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/po/en.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/po/fr.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/po/cs.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/po/pl.gmo",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Tapset_Reference/tapsets.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/SystemTap_Beginners_Guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/images/gnuplotsample.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/stock-go-forward.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/7.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/dot2.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/12.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/37.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/17.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/green.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/30.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/8.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/20.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/image_left.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/6.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/22.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/23.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/watermark-draft.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/5.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/15.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/19.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/11.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/35.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/18.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/1.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/31.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/29.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/25.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/2.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/40.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/3.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/9.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/10.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/stock-home.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/image_right.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/h1-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/stock-go-back.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/21.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/14.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/38.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/13.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/39.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/note.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/26.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/32.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/yellow.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/title_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/dot.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/33.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/shine.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/4.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/28.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/16.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/27.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/34.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/36.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/important.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/stock-go-up.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/24.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/doc/SystemTap_Beginners_Guide/en-US/Common_Content/images/red.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/testsuite/systemtap.examples/metadatabase.db",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/testsuite/systemtap.examples/general/return.wav",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/testsuite/systemtap.examples/general/click.wav",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/testsuite/systemtap.examples/html/systemtapcorner.gif",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/testsuite/systemtap.examples/html/systemtaplogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-systemtap-4.2-p72ho46qbgohqpy2kw2rinlfssnptlpo/spack-src/testsuite/systemtap.base/buildid.hex"
    ],
    "total_files": 4791
}