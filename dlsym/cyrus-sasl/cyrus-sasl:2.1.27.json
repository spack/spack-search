{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/configure.ac": "dnl configure.ac for the SASL library\ndnl Rob Siemborski\ndnl Rob Earhart\ndnl $Id: configure.ac,v 1.224 2011/09/22 14:44:15 mel Exp $\ndnl\ndnl Copyright (c) 2001 Carnegie Mellon University.  All rights reserved.\ndnl\ndnl Redistribution and use in source and binary forms, with or without\ndnl modification, are permitted provided that the following conditions\ndnl are met:\ndnl\ndnl 1. Redistributions of source code must retain the above copyright\ndnl    notice, this list of conditions and the following disclaimer. \ndnl\ndnl 2. Redistributions in binary form must reproduce the above copyright\ndnl    notice, this list of conditions and the following disclaimer in\ndnl    the documentation and/or other materials provided with the\ndnl    distribution.\ndnl\ndnl 3. The name \"Carnegie Mellon University\" must not be used to\ndnl    endorse or promote products derived from this software without\ndnl    prior written permission. For permission or any other legal\ndnl    details, please contact  \ndnl      Office of Technology Transfer\ndnl      Carnegie Mellon University\ndnl      5000 Forbes Avenue\ndnl      Pittsburgh, PA  15213-3890\ndnl      (412) 268-4387, fax: (412) 268-7395\ndnl      tech-transfer@andrew.cmu.edu\ndnl\ndnl 4. Redistributions of any form whatsoever must retain the following\ndnl    acknowledgment:\ndnl    \\\"This product includes software developed by Computing Services\ndnl     at Carnegie Mellon University (http://www.cmu.edu/computing/).\\\"\ndnl\ndnl CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO\ndnl THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\ndnl AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE\ndnl FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\ndnl WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\ndnl AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\ndnl OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\ndnl\n\nAC_PREREQ(2.63)\n\ndnl\ndnl REMINDER: When changing the version number here, please also update\ndnl the values in win32/include/config.h and include/sasl.h as well.\ndnl\nAC_INIT([cyrus-sasl],\n        [2.1.27],\n        [https://github.com/cyrusimap/cyrus-sasl/issues],\n        [cyrus-sasl],\n        [http://cyrusimap.org])\n\nAC_CONFIG_MACRO_DIR([m4])\n\ndnl use ./config.cache as the default cache file.\ndnl we require a cache file to successfully configure our build.\nif test $cache_file = \"/dev/null\"; then\ncache_file=\"./config.cache\"\nAC_CACHE_LOAD\nfi\n\nAC_CONFIG_AUX_DIR(config)\nAC_CANONICAL_HOST\nAC_CANONICAL_TARGET\n\nAM_INIT_AUTOMAKE([1.11 tar-ustar dist-bzip2 foreign -Wno-portability subdir-objects])\n\nDIRS=\"\"\n\nAC_ARG_ENABLE(cmulocal,\n              [AC_HELP_STRING([--enable-cmulocal],\n                              [enable local mods for CMU [[no]]])],\n              [],\n              enable_cmulocal=no)\n\nAC_ARG_ENABLE(sample,\n              [AC_HELP_STRING([--enable-sample],\n                              [compile sample code [[yes]]])],\n              [],\n              enable_sample=yes)\n\nAC_ARG_ENABLE(obsolete_cram_attr,\n              [AC_HELP_STRING([--enable-obsolete_cram_attr],\n                              [enable support for cmusaslsecretCRAM-MD5 auxprop property [[yes]]])],\n              enable_obsolete_cram_attr=$enableval,\n              enable_obsolete_cram_attr=yes)\n\nAC_ARG_ENABLE(obsolete_digest_attr,\n              [AC_HELP_STRING([--enable-obsolete_digest_attr],\n                              [enable support for cmusaslsecretDIGEST-MD5 auxprop property [[yes]]])],\n              enable_obsolete_digest_attr=$enableval,\n              enable_obsolete_digest_attr=yes)\n\nAC_PROG_CC\nAX_PROG_CC_FOR_BUILD\nAC_PROG_CPP\nAC_PROG_AWK\nAC_PROG_LN_S\nAC_PROG_MAKE_SET\nAC_PROG_INSTALL\nAC_USE_SYSTEM_EXTENSIONS\n\ndnl check for -R, etc. switch\nCMU_GUESS_RUNPATH_SWITCH\n\ndnl xxx compatibility\nAC_ARG_WITH(staticsasl)\nif test \"$with_staticsasl\" = yes; then\n\tenable_shared=yes\n\tenable_static=yes\nfi\n\nsave_target=$target\nif test -z \"$target\"; then\n\ttarget=\"NONE\"\nfi\n\n# new libtool\nAM_DISABLE_STATIC\nAC_PROG_LIBTOOL\n\ntarget=$save_target\n\nif test \"$enable_static\" = yes; then\n\tSASL_STATIC_LIBS=libsasl2.a\nelse\n\tSASL_STATIC_LIBS=\nfi\n\nAC_ARG_ENABLE(staticdlopen, [  --enable-staticdlopen   try dynamic plugins when we are a static libsasl [[no]] ],\n                enable_staticdlopen=$enableval,\n                enable_staticdlopen=no)\n\nif test \"$enable_staticdlopen\" = yes; then\n  AC_DEFINE(TRY_DLOPEN_WHEN_STATIC,[],[Should we try to dlopen() plugins while statically compiled?])\nfi\n\nif test \"$ac_cv_prog_gcc\" = yes; then\n  CFLAGS=\"-Wall -W ${CFLAGS}\"\nfi\n\nAC_ARG_WITH(purecov,[  --with-purecov          link with purecov])\nif test \"$with_purecov\" = yes; then\n  AC_CHECK_PROGS(PURECOV, purecov)\nfi\nAC_ARG_WITH(purify,[  --with-purify           link with purify])\nif test \"$with_purify\" = yes; then\n  AC_CHECK_PROGS(PURIFY, purify)\nfi\n\nAC_ARG_ENABLE(java, [  --enable-java           compile Java support [[no]]],\n\tenable_java=$enableval, enable_java=no)\nif test \"$enable_java\" = yes; then\n  AC_PATH_PROG(JAVAC, javac, no)\n  AC_PATH_PROGS(JAVAH, javah kaffeh, no)\n  AC_CHECK_PROGS(JAVADOC, javadoc, :)\t\n  if test \"$JAVAC\" = \"no\" -o \"$JAVAH\" = \"no\"; then\n    AC_WARN([Disabling Java support])\n    enable_java=no\n  fi\nelse\n# Make distcheck work\n  JAVAC=\"true\"\n  JAVAH=\"true\"\n  JAVADOC=\"true\"\nfi\nAM_CONDITIONAL(JAVA, test \"$enable_java\" = yes)\n\nif test \"$enable_java\" = yes; then\n  AC_MSG_CHECKING([JNI cpp flags])\n  AC_CACHE_VAL(sasl_cv_java_includes,[\n  if test `echo $JAVAH | sed 's,.*/,,'` = \"kaffeh\"; then\n    sasl_cv_java_includes=-I`echo $JAVAH | sed -e 's,/bin.*,/include/kaffe,'`\n  else\n    java_base=`echo $JAVAC | sed 's,/bin.*,'','`\n\n    AC_ARG_WITH(javabase, [  --with-javabase=PATH    set path to find jni.h in [/usr/java/include] ],\n        java_base=$withval,)\n\t\n\n    sasl_cv_java_includes=''\n    for dir in `find ${java_base}/include -follow -type d -print | grep -v green_threads`; do\n      sasl_cv_java_includes=\"${sasl_cv_java_includes} -I$dir\"\n    done\n  fi\n\n  sasl_cv_java_includes=\"${sasl_cv_java_includes} -I$javapath/include\"])\n\n  JAVA_INCLUDES=$sasl_cv_java_includes\n  AC_SUBST(JAVA_INCLUDES)\n  AC_MSG_RESULT(ok)\n\n  JAVAROOT=\"..\"\n  AC_SUBST(JAVAROOT)\n  JAVAC=`echo \"$JAVAC\" | sed 's,.*/,,'`\n  JAVAH=`echo \"$JAVAH\" | sed 's,.*/,,'`\nfi\n\nAM_CONDITIONAL(SAMPLE, test \"$enable_sample\" = yes)\n\ndnl call before we do the berkeley DB checks\nCMU_SOCKETS\n\ndnl we extracted this to config/sasldb.m4\nSASL_DB_PATH_CHECK()\nSASL_DB_CHECK()\n\n# Do we not install the SASL DB man pages?\nAM_CONDITIONAL(NO_SASL_DB_MANS, test \"x$SASL_DB_MANS\" = \"x\")\n\nAC_ARG_ENABLE(keep_db_open, [  --enable-keep-db-open   keep handle to DB open for improved performance [[no]] ],\n                keep_db_open=$enableval,\n                keep_db_open=no)\n\n# Disable if Berkeley DB and LMDB are not used\nif test \"$dblib\" != berkeley -a \"$dblib\" != lmdb; then\n  keep_db_open=no\nfi\n\nif test \"$keep_db_open\" = yes; then\n  AC_DEFINE(KEEP_DB_OPEN,[],[Should we keep handle to DB open in SASLDB plugin?])\nfi\nAC_MSG_CHECKING(if DB handle is kept open in SASLDB)\nAC_MSG_RESULT($keep_db_open)\n\nAC_CHECK_LIB(dl, dlopen, SASL_DL_LIB=\"-ldl\", SASL_DL_LIB=\"\")\nAC_SUBST(SASL_DL_LIB)\n\ndnl /dev/random ?\n\nAC_ARG_WITH(devrandom, [  --with-devrandom=PATH   set the path to pseudo random number generator [[/dev/urandom]] ],\n  devrandom=$withval,\n  devrandom=/dev/urandom)\nAC_MSG_CHECKING(PRNG to use)\nAC_MSG_RESULT($devrandom)\nAC_DEFINE_UNQUOTED(SASL_DEV_RANDOM, \"$devrandom\", [File to use for source of randomness])\n\ndnl Do we need leading underscores on our symbols?\n\nAC_CHECK_PROGS(NM, nm)\n\nAC_MSG_CHECKING(for underscore before symbols)\nAC_CACHE_VAL(sasl_cv_uscore,[\n    echo \"int main(){int i=1; return 0;}\n    void foo(){int i=6;}\" > conftest.c\n    ${CC} -o a.out conftest.c > /dev/null\n    if (${NM} a.out | grep _foo) > /dev/null; then\n      sasl_cv_uscore=yes\n    else\n      sasl_cv_uscore=no\n    fi])\nAC_MSG_RESULT($sasl_cv_uscore)\nrm -f conftest.c a.out\n\nif test $sasl_cv_uscore = yes; then\n  if test $ac_cv_lib_dl_dlopen = yes ; then\n\tAC_MSG_CHECKING(whether dlsym adds the underscore for us)\n\tcmu_save_LIBS=\"$LIBS\"\n\tLIBS=\"$LIBS $SASL_DL_LIB\"\n\tAC_CACHE_VAL(sasl_cv_dlsym_adds_uscore,AC_TRY_RUN( [\n#include <dlfcn.h>\n#include <stdio.h>\nvoid foo() { int i=0;}\nint main() { void *self, *ptr1, *ptr2; self=dlopen(NULL,RTLD_LAZY);\n    if(self) { ptr1=dlsym(self,\"foo\"); ptr2=dlsym(self,\"_foo\");\n    if(ptr1 && !ptr2) exit(0); } exit(1); } \n], [sasl_cv_dlsym_adds_uscore=yes], sasl_cv_dlsym_adds_uscore=no\n\tAC_DEFINE(DLSYM_NEEDS_UNDERSCORE, [], [Do we need a leading _ for dlsym?]),\n\tAC_MSG_WARN(cross-compiler, we'll do our best)))\n\tLIBS=\"$cmu_save_LIBS\"\n      AC_MSG_RESULT($sasl_cv_dlsym_adds_uscore)\n  fi\nfi\n\ndnl See if we can provide a default logging function...\nAC_CHECK_FUNCS(syslog)\n\nAC_ARG_WITH(saslauthd, [  --with-saslauthd=DIR    enable use of the saslauth daemon using state dir DIR ],\n\t\twith_saslauthd=$withval,\n\t\twith_saslauthd=yes)\nif test \"$with_saslauthd\" != no; then\n  if test \"$with_saslauthd\" = yes; then\n    with_saslauthd=\"/var/state/saslauthd\"\n  fi\n  AC_DEFINE(HAVE_SASLAUTHD,[],[Include support for saslauthd?])\n  AC_DEFINE_UNQUOTED(PATH_SASLAUTHD_RUNDIR, \"$with_saslauthd\",\n\t\t     [Where do we look for saslauthd's socket?])\nfi\nAM_CONDITIONAL(SASLAUTHD, test \"$with_saslauthd\" != no)\nAC_MSG_CHECKING(if I should include saslauthd)\nAC_MSG_RESULT($with_saslauthd)\n\nAC_ARG_WITH(authdaemond, [  --with-authdaemond=PATH enable use of authdaemon with default socket=PATH [[yes]] ],\n\t\twith_authdaemon=$withval,\n\t\twith_authdaemon=yes)\nif test \"$with_authdaemon\" != no; then\n  if test \"$with_authdaemon\" = yes; then\n    with_authdaemon=\"/dev/null\"\n  fi\n  AC_DEFINE(HAVE_AUTHDAEMON,[],[Include support for Courier's authdaemond?])\n  AC_DEFINE_UNQUOTED(PATH_AUTHDAEMON_SOCKET, \"$with_authdaemon\",\n\t\t     [Where do we look for Courier authdaemond's socket?])\nfi\nAC_MSG_CHECKING(to include Courier authdaemond support)\nAC_MSG_RESULT($with_authdaemon)\n\nAC_ARG_WITH(pwcheck,\n[  --with-pwcheck=DIR     enable deprecated pwcheck daemon using statedir DIR ],\n\twith_pwcheck=$withval,\n\twith_pwcheck=no)\nif test \"$with_pwcheck\" != no; then\n   if test \"$with_pwcheck\" = yes; then\n     with_pwcheck=/var/pwcheck\n   fi\n   AC_DEFINE(HAVE_PWCHECK,[],[Include Support for pwcheck daemon?])\n   AC_DEFINE_UNQUOTED(PWCHECKDIR, \"$with_pwcheck\", [Location of pwcheck socket])\n   AC_CHECK_FUNC(getspnam,PWCHECKMETH=\"getspnam\",PWCHECKMETH=\"getpwnam\")\n   AC_SUBST(PWCHECKMETH)\nfi\nAM_CONDITIONAL(PWCHECK, test \"$with_pwcheck\" != no)\nAC_MSG_CHECKING(if I should include pwcheck)\nAC_MSG_RESULT($with_pwcheck)\n\nAC_ARG_WITH(ipctype, [  --with-ipctype={unix,doors}    use ipctype [[unix]] ],\n       with_ipctype=$withval,\n       with_ipctype=\"unix\")\nIPCTYPE=$with_ipctype\nAC_SUBST(IPCTYPE)\nLIB_DOOR=\nif test \"$with_ipctype\" = \"doors\"; then\n   LIB_DOOR=\"-ldoor\"\n   AC_DEFINE(USE_DOORS,[],[use the doors IPC API for saslauthd?])\nfi\nAC_SUBST(LIB_DOOR)\n\nAC_ARG_ENABLE(alwaystrue, [  --enable-alwaystrue     enable the alwaystrue password verifier (discouraged)],\n\t\tenable_alwaystrue=$enableval,\n\t\tenable_alwaystrue=no)\nif test \"$enable_alwaystrue\" = yes; then\n  AC_DEFINE(HAVE_ALWAYSTRUE, [], [Enable 'alwaystrue' password verifier?])\nfi\nAC_MSG_CHECKING(if I should include the alwaystrue verifier)\nAC_MSG_RESULT($enable_alwaystrue)\n\ndnl sasl_checkapop support\nAC_ARG_ENABLE(checkapop, [  --enable-checkapop      enable use of sasl_checkapop [[yes]] ],\n  checkapop=$enableval,\n  checkapop=yes)\n\nAC_MSG_CHECKING(if we should enable sasl_checkapop)\nif test \"$checkapop\" != no; then\n  AC_MSG_RESULT(enabled)\n  AC_DEFINE(DO_SASL_CHECKAPOP, [], [should we support sasl_checkapop?])\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\ndnl CRAM-MD5\nAC_ARG_ENABLE(cram, [  --enable-cram           enable CRAM-MD5 authentication [[yes]] ],\n  cram=$enableval,\n  cram=yes)\n\nAC_MSG_CHECKING(CRAM-MD5)\nif test \"$cram\" != no; then\n  AC_MSG_RESULT(enabled)\n  SASL_MECHS=\"$SASL_MECHS libcrammd5.la\"\n  if test \"$enable_obsolete_cram_attr\" = yes; then\n    CPPFLAGS=\"$CPPFLAGS -DOBSOLETE_CRAM_ATTR=1\"\n  fi\n  if test \"$enable_static\" = yes; then\n    SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS cram.o\"\n    SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/cram.c\"\n    AC_DEFINE(STATIC_CRAMMD5, [], [Link CRAM-MD5 Statically])\n  fi\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\nCMU_HAVE_OPENSSL\nAC_MSG_CHECKING(for OpenSSL)\nAC_MSG_RESULT($with_openssl)\n\nSASL_DES_CHK\n\ndnl DIGEST-MD5\nAC_ARG_ENABLE(digest, [  --enable-digest         enable DIGEST-MD5 authentication [[yes]] ],\n  digest=$enableval,\n  digest=yes)\n\nif test \"$digest\" != no; then\n  dnl In order to compile digest, we should look for need libdes.\n  if test -d $digest; then\n    CPPFLAGS=\"$CPPFLAGS -I$digest/include\"\n    LDFLAGS=\"$LDFLAGS -L$digest/lib\"\n  fi\n  if test \"$with_des\" = no; then\n    AC_WARN(No DES support for DIGEST-MD5)\n  fi\nfi\n\nAC_MSG_CHECKING(DIGEST-MD5)\nif test \"$digest\" != no; then\n  AC_MSG_RESULT(enabled)\n  SASL_MECHS=\"$SASL_MECHS libdigestmd5.la\"\n  if test \"$enable_obsolete_digest_attr\" = yes; then\n    CPPFLAGS=\"$CPPFLAGS -DOBSOLETE_DIGEST_ATTR=1\"\n  fi\n  if test \"$enable_static\" = yes; then\n    SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/digestmd5.c\"\n    SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS digestmd5.o\"\n    AC_DEFINE(STATIC_DIGESTMD5, [], [Link DIGEST-MD5 Statically])\n  fi\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\ndnl SCRAM\nAC_ARG_ENABLE(scram, [  --enable-scram            enable SCRAM authentication [[yes]] ],\n  scram=$enableval,\n  scram=yes)\n\nif test \"$with_openssl\" = no; then\n  AC_WARN([OpenSSL not found -- SCRAM will be disabled])\n  scram=no\nfi\n\nAC_MSG_CHECKING(SCRAM)\nif test \"$scram\" != no; then\n  AC_MSG_RESULT(enabled)\n  SCRAM_LIBS=\"-lcrypto $LIB_RSAREF\"\n\n  SASL_MECHS=\"$SASL_MECHS libscram.la\"\n  if test \"$enable_static\" = yes; then\n    SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/scram.c\"\n    SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS scram.o\"\n    AC_DEFINE(STATIC_SCRAM, [], [Link SCRAM Statically])\n  fi\n\n  AC_SUBST(SCRAM_LIBS)\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\ndnl OTP\nAC_ARG_ENABLE(otp, [  --enable-otp            enable OTP authentication [[yes]] ],\n  otp=$enableval,\n  otp=yes)\n\nif test \"$with_openssl\" = no; then\n  AC_WARN([OpenSSL not found -- OTP will be disabled])\n  otp=no\nfi\n\nAC_MSG_CHECKING(OTP)\nif test \"$otp\" != no; then\n  AC_MSG_RESULT(enabled)\n  OTP_LIBS=\"-lcrypto $LIB_RSAREF\"\n\n  SASL_MECHS=\"$SASL_MECHS libotp.la\"\n  if test \"$enable_static\" = yes; then\n    SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/otp.c\"\n    SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS otp.o\"\n    AC_DEFINE(STATIC_OTP, [], [Link OTP Statically])\n  fi\n\n  dnl Test for OPIE\n  AC_ARG_WITH(opie, AC_HELP_STRING([--with-opie=PATH], [use OPIE (One Time Passwords in Everything) from PATH]))\n\n  case \"$with_opie\" in\n\t\"\"|yes) \n\t\tAC_CHECK_LIB(opie, opiechallenge, [\n\t\t\tAC_CHECK_HEADER(opie.h, with_opie=\"yes\",\n\t\t\t\t\twith_opie=\"no\")],\n\t\t\twith_opie=\"no\")\n\t\t;;\n\t*)\n\t\tif test -d $with_opie; then\n\t\t  CPPFLAGS=\"${CPPFLAGS} -I${with_opie}/include\"\n\t\t  LDFLAGS=\"${LDFLAGS} -L${with_opie}/lib\"\n\t\telse\n\t\t  with_opie=\"no\"\n\t\tfi\n\t\t;;\n  esac\n\n  AC_MSG_CHECKING(for OPIE)\n  AC_MSG_RESULT($with_opie)\n\n  if test \"$with_opie\" != no; then\n    AC_DEFINE(HAVE_OPIE,[],[Use OPIE for server-side OTP?])\n    OTP_LIBS=\"$OTP_LIBS -lopie\"\n  fi\n\n  AC_SUBST(OTP_LIBS)\n\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\ndnl SRP\nAC_ARG_ENABLE(srp, [  --enable-srp            enable SRP authentication [[no]] ],\n  srp=$enableval,\n  srp=no)\n\nif test \"$with_openssl\" = no; then\n  AC_WARN([OpenSSL not found -- SRP will be disabled])\n  srp=no\nfi\n\nAC_MSG_CHECKING(SRP)\nif test \"$srp\" != no; then\n  AC_MSG_RESULT(enabled)\n  SRP_LIBS=\"-lcrypto $LIB_RSAREF\"\n\n  SASL_MECHS=\"$SASL_MECHS libsrp.la\"\n  if test \"$enable_static\" = yes; then\n    SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/srp.c\"\n    SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS srp.o\"\n    AC_DEFINE(STATIC_SRP, [], [Link SRP Statically])\n  fi\n\ndnl srp_setpass support\n  AC_ARG_ENABLE(srp_setpass, [  --enable-srp-setpass    enable setting SRP secrets with saslpasswd [[no]]],\n      srp_setpass=$enableval,\n      srp_setpass=no)\n\n  AC_MSG_CHECKING(if we should enable setting SRP secrets with saslpasswd)\n  if test \"$srp_setpass\" != no; then\n    AC_MSG_RESULT(enabled)\n    AC_DEFINE(DO_SRP_SETPASS, [], [should we support setpass() for SRP?])\n  else\n    AC_MSG_RESULT(disabled)\n  fi\n\n  AC_SUBST(SRP_LIBS)\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\ndnl Kerberos based Mechanisms\nSASL_KERBEROS_V4_CHK\nSASL_GSSAPI_CHK\n\nif test \"$gssapi\" != \"no\"; then\n  AC_DEFINE(STATIC_GSSAPIV2,[],[Link GSSAPI Statically])\n  AC_DEFINE(HAVE_GSSAPI,[],[Include GSSAPI/Kerberos 5 Support])\n\n  mutex_default=\"no\"\n  if test \"$gss_impl\" = \"mit\"; then\n     mutex_default=\"yes\"\n  elif test \"$gss_impl\" = \"heimdal\"; then\n     AC_DEFINE(KRB5_HEIMDAL,[],[Using Heimdal]) \n  fi\n\n  AC_MSG_CHECKING(to use mutexes aroung GSS calls)\n  AC_ARG_ENABLE(gss_mutexes, [  --enable-gss_mutexes     use mutexes around calls to the GSS library],\n                use_gss_mutexes=$enableval,\n                use_gss_mutexes=$mutex_default)\n  if test $use_gss_mutexes = \"yes\"; then\n     AC_DEFINE(GSS_USE_MUTEXES, [], [should we mutex-wrap calls into the GSS library?])\n  fi\n  AC_MSG_RESULT($use_gss_mutexes)\nfi\n\nSASL2_CRYPT_CHK\n\nAC_ARG_ENABLE(sia, [  --enable-sia            enable SIA authentication [no] ],\n  sia=$enableval,\n  sia=no)\nLIB_SIA=\"\"\nif test \"$sia\" != no; then\n  if test -f /etc/sia/matrix.conf; then\n    AC_DEFINE(HAVE_SIA,[],[Include SIA Support])\n    LIB_SIA=\"-lsecurity -ldb -lm -laud\"\n  else\n    AC_MSG_ERROR([No support for SIA found])\n  fi\nfi\nAC_SUBST(LIB_SIA)\n\nAC_ARG_ENABLE(auth-sasldb, [  --enable-auth-sasldb    enable experimental SASLdb authentication module [no] ],\n  authsasldb=$enableval,\n  authsasldb=no)\nif test \"$authsasldb\" != no; then\n  AC_DEFINE(AUTH_SASLDB,[],[Include SASLdb Support])\n  SASL_DB_PATH_CHECK()\n  SASL_DB_CHECK()\nfi\nAM_CONDITIONAL(AUTH_SASLDB, test \"$authsasldb\" != no)\n\nAC_ARG_ENABLE(httpform, [  --enable-httpform       enable HTTP form authentication [[no]] ],\n  httpform=$enableval,\n  httpform=no)\nif test \"$httpform\" != no; then\n  AC_DEFINE(HAVE_HTTPFORM,[],[Include HTTP form Support])\nfi\n\nAC_ARG_WITH(pam, AC_HELP_STRING([--with-pam=DIR], [use PAM (rooted in DIR) [yes]]),,\n\twith_pam=yes)\nif test \"$with_pam\" != no; then\n  if test -d $with_pam; then\n    CPPFLAGS=\"$CPPFLAGS -I${with_pam}/include\"\n    LDFLAGS=\"$LDFLAGS -L${with_pam}/lib\"\n  fi\n  cmu_save_LIBS=\"$LIBS\"\n  AC_CHECK_LIB(pam, pam_start, [\n  AC_CHECK_HEADER(security/pam_appl.h,,\n\t\t  with_pam=no)],\n\twith_pam=no, $SASL_DL_LIB)\n  LIBS=\"$cmu_save_LIBS\"\nfi\n\nAC_MSG_CHECKING(for PAM support)\nAC_MSG_RESULT($with_pam)\nLIB_PAM=\"\"\nif test \"$with_pam\" != no; then\n  AC_DEFINE(HAVE_PAM,[],[Support for PAM?])\n  LIB_PAM=\"-lpam\"\nfi\nAC_SUBST(LIB_PAM)\n\ndnl PLAIN\nSASL_PLAIN_CHK\n\ndnl ANONYMOUS\nAC_ARG_ENABLE(anon, [  --enable-anon           enable ANONYMOUS authentication [[yes]] ],\n  anon=$enableval,\n  anon=yes)\n\nAC_MSG_CHECKING(ANONYMOUS)\nif test \"$anon\" != no; then\n  AC_MSG_RESULT(enabled)\n  SASL_MECHS=\"$SASL_MECHS libanonymous.la\"\n  if test \"$enable_static\" = yes; then\n    SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS anonymous.o\"\n    SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/anonymous.c\"\n    AC_DEFINE(STATIC_ANONYMOUS, [], [Link ANONYMOUS Statically])\n  fi\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\ndnl LOGIN\nAC_ARG_ENABLE(login, [  --enable-login          enable unsupported LOGIN authentication [[no]] ],\n  login=$enableval,\n  login=no)\n\nAC_MSG_CHECKING(LOGIN)\nif test \"$login\" != no; then\n  AC_MSG_RESULT(enabled)\n  SASL_MECHS=\"$SASL_MECHS liblogin.la\"\n  if test \"$enable_static\" = yes; then\n    SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/login.c\"\n    SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS login.o\"\n    AC_DEFINE(STATIC_LOGIN,[],[Link LOGIN Statically])\n  fi\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\ndnl NTLM\nAC_ARG_ENABLE(ntlm, [  --enable-ntlm           enable unsupported NTLM authentication [[no]] ],\n  ntlm=$enableval,\n  ntlm=no)\n\nif test \"$with_openssl\" = no; then\n  AC_WARN([OpenSSL not found -- NTLM will be disabled])\n  ntlm=no\nfi\n\nAC_MSG_CHECKING(NTLM)\nif test \"$ntlm\" != no; then\n  AC_MSG_RESULT(enabled)\n  NTLM_LIBS=\"-lcrypto $LIB_RSAREF\"\n  AC_SUBST(NTLM_LIBS)\n\n  SASL_MECHS=\"$SASL_MECHS libntlm.la\"\n  if test \"$enable_static\" = yes; then\n    SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/ntlm.c\"\n    SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS ntlm.o\"\n    AC_DEFINE(STATIC_NTLM,[],[Link NTLM Statically])\n  fi\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\ndnl PASSDSS\nAC_ARG_ENABLE(passdss, [  --enable-passdss        enable PASSDSS authentication (experimental) [[no]] ],\n  passdss=$enableval,\n  passdss=no)\n\nif test \"$with_openssl\" = no; then\n  AC_WARN([OpenSSL not found -- PASSDSS will be disabled])\n  passdss=no\nfi\n\nAC_MSG_CHECKING(PASSDSS)\nif test \"$passdss\" != no; then\n  AC_MSG_RESULT(enabled)\n  PASSDSS_LIBS=\"-lcrypto $LIB_RSAREF\"\n  AC_SUBST(PASSDSS_LIBS)\n\n  SASL_MECHS=\"$SASL_MECHS libpassdss.la\"\n  if test \"$enable_static\" = yes; then\n    SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS passdss.o\"\n    SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/passdss.c\"\n    AC_DEFINE(STATIC_PASSDSS,[],[Link PASSDSS Statically])\n  fi\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\n\nAC_MSG_CHECKING(to include LDAP support)\nAC_ARG_WITH(ldap, [  --with-ldap=DIR         use LDAP (in DIR) for saslauthd [no] ],\n\twith_ldap=$withval,\n\twith_ldap=no)\nAC_MSG_RESULT($with_ldap)\n\nif test -d $with_ldap; then\n    CPPFLAGS=\"$CPPFLAGS -I${with_ldap}/include\"\n    CMU_ADD_LIBPATH(${with_ldap}/lib)\nfi\n\nLDAP_LIBS=\"\"\nif test \"$with_ldap\" != no; then\n  AC_CHECK_LIB(ldap, ldap_initialize, [ AC_DEFINE(HAVE_LDAP,[],[Support for LDAP?])\n                                        LDAP_LIBS=\"-lldap -llber\"\n\t\t\t\t\tif test \"$with_openssl\" != \"no\"; then\n\t\t\t\t\t    LDAP_LIBS=\"$LDAP_LIBS -lcrypto $LIB_RSAREF\"\n\t\t\t\t\tfi],,-llber)\nfi\nAC_SUBST(LDAP_LIBS)\n\n\ndnl SQL\ndnl This flag also changes the requirements of --with-mysql and --with-pgsql\ndnl\ndnl Desired behavior:\ndnl\ndnl doesn't require mysql or postgres if --disable-sql is chosen\ndnl requires at least one (but not both) if --enable-sql is chosen\n\nAC_ARG_ENABLE(sql, [  --enable-sql            enable SQL auxprop [[no]] ],\n  sql=$enableval,\n  sql=no)\n\nAC_MSG_CHECKING(SQL)\nif test \"$sql\" != no; then\n  AC_MSG_RESULT(enabled)\n  SASL_MECHS=\"$SASL_MECHS libsql.la\"\n  if test \"$enable_static\" = yes; then\n    SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/sql.c\"\n    SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS sql.o\"\n    AC_DEFINE(STATIC_SQL,[],[Link SQL plugin statically])\n  fi\nelse\n  AC_MSG_RESULT(disabled)\nfi\n\ndnl MySQL\nAC_ARG_WITH(mysql,  [  --with-mysql=PATH       use MySQL from PATH ],\n  with_mysql=$withval,\n  with_mysql=$sql)\n\n# find location of library \n# presuming if one given then correct\nif test \"${with_mysql}\" = \"yes\"; then\n  with_mysql=notfound\n  for mysqlloc in lib/mysql lib mysql/lib\n  do\n    if test -f ${prefix}/${mysqlloc}/libmysqlclient.a; then\n      with_mysql=\"${prefix}\"\n      break\n    elif test -f /usr/local/${mysqlloc}/libmysqlclient.a; then\n      with_mysql=\"/usr/local\"\n      break\n    elif test -f /usr/${mysqlloc}/libmysqlclient.a; then\n      with_mysql=\"/usr\"\n      break\n    fi\n  done\nfi\n\nLIB_MYSQL=\"\"\n\ncase \"$with_mysql\" in\n    no) true;;\n    notfound)\n     save_LDFLAGS=$LDFLAGS\n     LIB_MYSQL=`mysql_config --libs`\n     LIB_MYSQL=\"-lmysqlclient\"\n     LDFLAGS=\"$LDFLAGS $LIB_MYSQL\"\n     # CPPFLAGS=\"${CPPFLAGS} `mysql_config --include`\"\n     AC_CHECK_LIB(mysqlclient, mysql_select_db,\n           AC_DEFINE(HAVE_MYSQL, [], [Do we have mysql support?]),\n           [AC_WARN([MySQL library mysqlclient does not work])\n            with_mysql=no])\n     LDFLAGS=$save_LDFLAGS\n     ;;\n    *)\n     if test -d ${with_mysql}/lib/mysql; then\n\tCMU_ADD_LIBPATH_TO(${with_mysql}/lib/mysql, LIB_MYSQL)\n     elif test -d ${with_mysql}/mysql/lib; then\n\tCMU_ADD_LIBPATH_TO(${with_mysql}/mysql/lib, LIB_MYSQL)\n     elif test -d ${with_mysql}/lib; then\n\tCMU_ADD_LIBPATH_TO(${with_mysql}/lib, LIB_MYSQL)\n     else\n\tCMU_ADD_LIBPATH_TO(${with_mysql}, LIB_MYSQL)\n     fi\n\n     LIB_MYSQL_DIR=$LIB_MYSQL\n     LIB_MYSQL=\"$LIB_MYSQL -lmysqlclient\"\n\n     if test -d ${with_mysql}/include/mysql; then\n         CPPFLAGS=\"${CPPFLAGS} -I${with_mysql}/include/mysql\"\n     elif test -d ${with_mysql}/mysql/include; then\n         CPPFLAGS=\"${CPPFLAGS} -I${with_mysql}/mysql/include\"\n     elif test -d ${with_mysql}/include; then\n         CPPFLAGS=\"${CPPFLAGS} -I${with_mysql}/include\"\n     elif test -d ${prefix}/include/mysql; then\n         CPPFLAGS=\"${CPPFLAGS} -I${prefix}/include/mysql\"\n     else\n         CPPFLAGS=\"${CPPFLAGS} -I${with_mysql}\"\n     fi\n\n       save_LDFLAGS=$LDFLAGS\n       LDFLAGS=\"$LDFLAGS $LIB_MYSQL_DIR\"\n       AC_CHECK_LIB(mysqlclient, mysql_select_db,\n\t   AC_DEFINE(HAVE_MYSQL, [], [Do we have mysql support?]),\n           [AC_WARN([MySQL library mysqlclient does not work])\n\t    with_mysql=no])\n       LDFLAGS=$save_LDFLAGS;;\n         \nesac\nAC_SUBST(LIB_MYSQL)\n\ndnl PgSQL\nAC_ARG_WITH(pgsql,  [  --with-pgsql=PATH       use PostgreSQL from PATH ],\n  with_pgsql=$withval,\n  with_pgsql=$sql)\n\n# find location of library \n# presuing if one given then correct\nif test \"${with_pgsql}\" = \"yes\"; then\n  with_pgsql=notfound\n  for pgsqlloc in lib/pgsql lib pgsql/lib\n  do\n    if test -f ${prefix}/${pgsqlloc}/libpq.a; then\n      with_pgsql=\"${prefix}\"\n      break\n    elif test -f /usr/local/${pgsqlloc}/libpq.a; then\n      with_pgsql=\"/usr/local\"\n      break\n    elif test -f /usr/${pgsqlloc}/libpq.a; then\n      with_pgsql=\"/usr\"\n      break\n    fi\n  done\nfi\n\nLIB_PGSQL=\"\"\n\ncase \"$with_pgsql\" in\n    no) true;;\n    notfound)\n     LIB_PGSQL=\"-lpq\"\n     # CPPFLAGS=\"${CPPFLAGS} -I`pg_config --includedir`\"\n     save_LDFLAGS=$LDFLAGS\n     LDFLAGS=\"$LDFLAGS $LIB_PGSQL\"\n     AC_CHECK_LIB(pq, PQsetdbLogin, AC_DEFINE(HAVE_PGSQL,[],\n         [Do we have Postgres support?]),\n         [AC_WARN([PostgreSQL Library pq does not work])\n          with_pgsql=no])\n     LDFLAGS=$save_LDFLAGS\n     ;;\n    *)\n     if test -d ${with_pgsql}/lib/pgsql; then\n\tCMU_ADD_LIBPATH_TO(${with_pgsql}/lib/pgsql, LIB_PGSQL)\n     elif test -d ${with_pgsql}/pgsql/lib; then\n\tCMU_ADD_LIBPATH_TO(${with_pgsql}/pgsql/lib, LIB_PGSQL)\n     elif test -d ${with_pgsql}/lib; then\n\tCMU_ADD_LIBPATH_TO(${with_pgsql}/lib, LIB_PGSQL)\n     else\n\tCMU_ADD_LIBPATH_TO(${with_pgsql}, LIB_PGSQL)\n     fi\n\n     LIB_PGSQL_DIR=$LIB_PGSQL\n     LIB_PGSQL=\"$LIB_PGSQL -lpq\"\n\n     if test -d ${with_pgsql}/include/pgsql; then\n         CPPFLAGS=\"${CPPFLAGS} -I${with_pgsql}/include/pgsql\"\n     elif test -d ${with_pgsql}/pgsql/include; then\n         CPPFLAGS=\"${CPPFLAGS} -I${with_pgsql}/pgsql/include\"\n     elif test -d ${with_pgsql}/include; then\n         CPPFLAGS=\"${CPPFLAGS} -I${with_pgsql}/include\"\n     elif test -d ${prefix}/include; then\n         CPPFLAGS=\"${CPPFLAGS} -I${prefix}/include\"\n     else\n         CPPFLAGS=\"${CPPFLAGS} -I${with_pgsql}\"\n     fi\n\n\n       save_LDFLAGS=$LDFLAGS\n       LDFLAGS=\"$LDFLAGS $LIB_PGSQL_DIR\"\n       AC_CHECK_LIB(pq, PQsetdbLogin, AC_DEFINE(HAVE_PGSQL,[],\n\t   [Do we have Postgres support?]),\n           [AC_WARN([PostgreSQL Library pq does not work])\n\t    with_pgsql=no])\n       LDFLAGS=$save_LDFLAGS;;\n         \nesac\nAC_SUBST(LIB_PGSQL)\n\ndnl SQLite\nAC_ARG_WITH(sqlite,  [  --with-sqlite=PATH       use SQLite from PATH ],\n  with_sqlite=$withval,\n  with_sqlite=$sql)\n\n# find location of library\n# presuing if one given then correct\nif test \"${with_sqlite}\" = \"yes\"; then\n  with_sqlite=notfound\n  for sqliteloc in lib\n  do\n    if test -f ${prefix}/${sqliteloc}/libsqlite.a; then\n      with_sqlite=\"${prefix}\"\n      break\n    elif test -f /usr/local/${sqliteloc}/libsqlite.a; then\n      with_sqlite=\"/usr/local\"\n      break\n    elif test -f /usr/${sqliteloc}/libsqlite.a; then\n      with_sqlite=\"/usr\"\n      break\n    fi\n  done\nfi\n\nLIB_SQLITE=\"\"\n\ncase \"$with_sqlite\" in\n    no) true;;\n    notfound) AC_WARN([SQLite Library not found]); true;;\n    *)\n     if test -d ${with_sqlite}/lib; then\n         CMU_ADD_LIBPATH_TO(${with_sqlite}/lib, LIB_SQLITE)\n     else\n         CMU_ADD_LIBPATH_TO(${with_sqlite}, LIB_SQLITE)\n     fi\n\n     LIB_SQLITE_DIR=$LIB_SQLITE\n     LIB_SQLITE=\"$LIB_SQLITE -lsqlite\"\n\n     if test -d ${with_sqlite}/include; then\n         CPPFLAGS=\"${CPPFLAGS} -I${with_sqlite}/include\"\n     else\n         CPPFLAGS=\"${CPPFLAGS} -I${with_sqlite}\"\n     fi\n       AC_CHECK_LIB(sqlite, sqlite_open, AC_DEFINE(HAVE_SQLITE,[],\n\t   [Do we have SQLite support?]),\n           [AC_WARN([SQLite Library sqlite does not work])\n\t    with_sqlite=no], $LIB_SQLITE_DIR);;\n\nesac\nAC_SUBST(LIB_SQLITE)\n\ndnl SQLite3\nAC_ARG_WITH(sqlite3,  [  --with-sqlite3=PATH       use SQLite3 from PATH ],\n  with_sqlite3=$withval,\n  with_sqlite3=$sql)\n\n# find location of library\n# we assume that if one given then it is correct\nif test \"${with_sqlite3}\" = \"yes\"; then\n  with_sqlite3=notfound\n  for sqlite3loc in lib\n  do\n    if test -f ${prefix}/${sqlite3loc}/libsqlite3.a; then\n      with_sqlite3=\"${prefix}\"\n      break\n    elif test -f /usr/local/${sqlite3loc}/libsqlite3.a; then\n      with_sqlite3=\"/usr/local\"\n      break\n    elif test -f /usr/${sqlite3loc}/libsqlite3.a; then\n      with_sqlite3=\"/usr\"\n      break\n    fi\n  done\nfi\n\nLIB_SQLITE3=\"\"\n\ncase \"$with_sqlite3\" in\n    no) true;;\n    notfound) AC_WARN([SQLite3 Library not found]); true;;\n    *)\n     if test -d ${with_sqlite3}/lib; then\n         CMU_ADD_LIBPATH_TO(${with_sqlite3}/lib, LIB_SQLITE3)\n     else\n         CMU_ADD_LIBPATH_TO(${with_sqlite3}, LIB_SQLITE3)\n     fi\n\n     LIB_SQLITE3_DIR=$LIB_SQLITE3\n     LIB_SQLITE3=\"$LIB_SQLITE3 -lsqlite3\"\n\n     if test -d ${with_sqlite3}/include; then\n         CPPFLAGS=\"${CPPFLAGS} -I${with_sqlite3}/include\"\n     else\n         CPPFLAGS=\"${CPPFLAGS} -I${with_sqlite3}\"\n     fi\n       AC_CHECK_LIB(sqlite3, sqlite3_open, AC_DEFINE(HAVE_SQLITE3,[],\n\t   [Do we have SQLite3 support?]),\n           [AC_WARN([SQLite3 Library sqlite3 does not work])\n\t    with_sqlite3=no], $LIB_SQLITE3_DIR);;\n\nesac\nAC_SUBST(LIB_SQLITE3)\n\nif test \"$sql\" = yes -a \"$with_pgsql\" = no -a \"$with_mysql\" = no -a \"$with_sqlite\" = no -a \"$with_sqlite3\" = no; then\n    AC_MSG_ERROR([--enable-sql chosen but neither Postgres nor MySQL nor SQLite nor SQLite3 found])\nfi\n\nif test \"$enable_shared\" = yes; then\n\tAC_DEFINE(DO_DLOPEN,[],[Should we build a shared plugin (via dlopen) library?])\nfi\n\ndnl LDAPDB\nAC_ARG_ENABLE(ldapdb, [  --enable-ldapdb         enable LDAPDB plugin [no] ],\n  ldapdb=$enableval,\n  ldapdb=no)\nAC_MSG_CHECKING(LDAPDB)\nif test \"$ldapdb\" != no; then\n    AC_MSG_RESULT(enabled)\n\n    if test \"$with_ldap\" = no; then\n        AC_MSG_ERROR([Cannot enable LDAPDB plugin: You need to specify --with-ldap])\n    fi\n\n    save_CPPFLAGS=$CPPFLAGS\n    save_LDFLAGS=$LDFLAGS\n\n    if test -d $with_ldap; then\n        CPPFLAGS=\"${CPPFLAGS} -I${with_ldap}/include\"\n        CMU_ADD_LIBPATH(${with_ldap}/lib)\n    fi\n\n    AC_CHECK_HEADERS(ldap.h lber.h)\n\n    if test $ac_cv_header_ldap_h = yes -a $ac_cv_header_lber_h = yes; then\n        CMU_OPENLDAP_API\n\n        if test \"$cmu_cv_openldap_api\" = yes; then\n            AC_CHECK_LIB(ldap, ldap_initialize, [ cmu_link_openldap=\"-lldap -llber\" ], [ cmu_link_openldap=no ],-llber)\n        fi\n    fi\n\n    if test \"$cmu_cv_openldap_api\" = no -o \"$cmu_link_openldap\" = no; then\n        AC_MSG_ERROR([Cannot enable LDAPDB plugin: Could not locate OpenLDAP])\n    else\n        CMU_OPENLDAP_COMPAT\n\n        if test \"$cmu_cv_openldap_compat\" = no; then\n            AC_MSG_ERROR([Cannot enable LDAPDB plugin: OpenLDAP library located but incompatible])\n        else\n            LIB_LDAP=$cmu_link_openldap\n            AC_SUBST(LIB_LDAP)\n\n            SASL_MECHS=\"$SASL_MECHS libldapdb.la\"\n            if test \"$enable_static\" = yes; then\n                SASL_STATIC_SRCS=\"$SASL_STATIC_SRCS \\$(top_srcdir)/plugins/ldapdb.c\"\n                SASL_STATIC_OBJS=\"$SASL_STATIC_OBJS ldapdb.o\"\n                AC_DEFINE(STATIC_LDAPDB,[],[Link ldapdb plugin Statically])\n            fi\n        fi\n    fi\n\n    if test \"$cmu_cv_openldap_compat\" != yes; then\n        CPPFLAGS=$save_CPPFLAGS\n        LDFLAGS=$save_LDFLAGS\n    fi\nelse\n    AC_MSG_RESULT(disabled)\nfi\n\nAC_SUBST(SASL_MECHS)\nAC_SUBST(SASL_STATIC_SRCS)\nAC_SUBST(SASL_STATIC_OBJS)\nAC_SUBST(SASL_STATIC_LIBS)\n\nAC_ARG_WITH(plugindir, [  --with-plugindir=DIR    set the directory where plugins will\n                          be found [[LIBDIR/sasl2]] ],\n  plugindir=$withval,\n  plugindir='${libdir}/sasl2')\nAC_SUBST(plugindir)\n\nAC_ARG_WITH(configdir, [   --with-configdir=DIR    set the directory where config files will\n                          be found [PLUGINDIR:SYSCONFDIR/sasl2] ],\n  configdir=$withval,\n  configdir='${plugindir}:${sysconfdir}/sasl2')\nAC_SUBST(configdir)\n\ndnl look for rc4 libraries. we accept the CMU one or one from openSSL\nAC_ARG_WITH(rc4, [  --with-rc4              use internal rc4 routines [[yes]] ],\n\twith_rc4=$withval,\n\twith_rc4=yes)\n\nif test \"$with_rc4\" != no; then\n    AC_DEFINE(WITH_RC4,[],[Use internal RC4 implementation?])\nfi\n\nbuilding_for_macosx=no\ncase \"$host_os\" in\n        darwin*)\nAC_ARG_ENABLE(macos-framework, [  --disable-macos-framework       disable building and installing replacement SASL2 Framework for MacOS X-provided SASL Framework [[no]]],building_for_macosx=no,building_for_macosx=yes)\n        ;;\nesac\nAM_CONDITIONAL(MACOSX, test \"$building_for_macosx\" = yes)\nAM_CONDITIONAL(WINDOWS, test \"$host_os\" = \"mingw32\")\n\ndnl dmalloc tests\nAC_MSG_CHECKING(for dmalloc library)\nAC_ARG_WITH(dmalloc, [  --with-dmalloc=DIR      with DMALLOC support (for test applications) [[no]] ],\n\twith_dmalloc=$withval,\n\twith_dmalloc=no)\n\nDMALLOC_LIBS=\"\"\n\nif test \"$with_dmalloc\" != \"no\"; then\n   if test \"$with_dmalloc\" = \"yes\"; then\n\twith_dmalloc=\"/usr/local\"\n   fi\n\n   if test -r \"$with_dmalloc/libdmalloc.a\"; then\n\tDMALLOC_LIBS=\"$with_dmalloc/libdmalloc.a\"\n\tAC_DEFINE(WITH_DMALLOC,[],[Linking against dmalloc?])\n\tAC_MSG_RESULT(yes)\n   elif test -r \"$with_dmalloc/lib/libdmalloc.a\"; then\n\tDMALLOC_LIBS=\"$with_dmalloc/lib/libdmalloc.a\"\n\tAC_DEFINE(WITH_DMALLOC,[],[Linking against dmalloc?])\n\tAC_MSG_RESULT(yes)\n   else\n\tAC_MSG_ERROR(cannot find dmalloc library, please check your installation.)\n   fi\nelse\n   AC_MSG_RESULT(no)\nfi\n\nAC_SUBST(DMALLOC_LIBS)\n\ndnl sfio tests\nAC_MSG_CHECKING(for sfio library)\nAC_ARG_WITH(sfio, [  --with-sfio=DIR         with SFIO support (for smtptest/libsfsasl) [[no]] ],\n\twith_sfio=$withval,\n\twith_sfio=no)\n\nif test \"$with_sfio\" != \"no\"; then\n   if test \"$with_sfio\" = \"yes\"; then\n\twith_sfio=\"/usr/local\"\n   fi\n\n   AC_DEFUN([SFIO_INC_CHK],\n\t[if test -r \"$with_sfio$1/sfio.h\"; then SFIO_DIR=$with_sfio;\n\t\t\t\t\t      SFIO_INC_DIR=$with_sfio$1])\n\n   AC_DEFUN([SFIO_LIB_CHK],[\n\t\tstr=\"$SFIO_DIR/$1/libsfio.*\"\n\t\tfor i in `echo $str`; do\n\t\t\tif test -r $i; then\n\t\t\t\tSFIO_LIBDIR=$SFIO_DIR/$1\n\t\t\t\tbreak 2\n\t\t\tfi\n\t\tdone\n\t\t])\n\n   SFIO_INC_CHK()\n   el[]SFIO_INC_CHK(/include)\n   el[]SFIO_INC_CHK(/include/sfio)\n   fi\n\n   if test -z \"$SFIO_DIR\"; then\n\tAC_MSG_ERROR(Cannot find sfio.h, Please check your SFIO installation.)\n   fi\n\n   SFIO_LIB_CHK(lib)\n   SFIO_LIB_CHK(lib/sfio)\n\n   if test -z \"$SFIO_LIBDIR\"; then\n\tAC_MSG_ERROR(Cannot find sfio library, Please check your SFIO installation.)\n   fi\n\n   SFIO_INC_FLAGS=\"-I$SFIO_INC_DIR\"\n   SFIO_LIB_FLAGS=\"-L$SFIO_LIBDIR -lsfio\"\n   SMTPTEST_PROGRAM=\"smtptest\"\n   SASL_UTIL_LIBS_EXTRA=libsfsasl2.la\n   SASL_UTIL_HEADERS_EXTRA=sfsasl.h\n\n   AC_MSG_RESULT(yes)\nelse\n   AC_MSG_RESULT(no)\n   SFIO_INC_FLAGS=\"\"\n   SFIO_LIB_FLAGS=\"\"\n   SMTPTEST_PROGRAM=\"\"\n   SASL_UTIL_LIBS_EXTRA=\"\"\n   SASL_UTIL_HEADERS_EXTRA=\"\"\nfi\n\nAC_SUBST(SFIO_INC_FLAGS)\nAC_SUBST(SFIO_LIB_FLAGS)\nAC_SUBST(SMTPTEST_PROGRAM)\nAC_SUBST(SASL_UTIL_LIBS_EXTRA)\nAC_SUBST(SASL_UTIL_HEADERS_EXTRA)\n\ndnl check for getsubopt\nsasl_cv_getsubopt=no\nAC_CHECK_FUNC(getsubopt, [AC_DEFINE(HAVE_GETSUBOPT,[],\n\t[do we have getsubopt()?])], [sasl_cv_getsubopt=yes])\nif test $sasl_cv_getsubopt = yes; then\n\tAC_LIBOBJ(getsubopt)\n\tGETSUBOPT=\"getsubopt.lo\"\nfi\nAC_SUBST(GETSUBOPT)\n\ndnl Check for snprintf\nsasl_cv_snprintf=no\nSNPRINTFOBJS=\"\"\nLTSNPRINTFOBJS=\"\"\nAC_CHECK_FUNC(snprintf, [AC_DEFINE(HAVE_SNPRINTF,[],[Does the system have snprintf()?])], [sasl_cv_snprintf=yes])\nAC_CHECK_FUNC(vsnprintf, [AC_DEFINE(HAVE_VSNPRINTF,[],[Does the system have vsnprintf()?])], [sasl_cv_snprintf=yes])\nif test $sasl_cv_snprintf = yes; then\n       AC_LIBOBJ(snprintf)\n       SNPRINTFOBJS=\"snprintf.o\"\n       LTSNPRINTFOBJS=\"snprintf.lo\"\nfi\nAC_SUBST(SNPRINTFOBJS)\nAC_SUBST(LTSNPRINTFOBJS)\n\ndnl do we need to link in -lresolv?\nAC_CHECK_LIB(resolv, inet_aton)\n\ndnl Check for getaddrinfo\nGETADDRINFOOBJS=\"\"\nsasl_cv_getaddrinfo=yes\nIPv6_CHECK_FUNC(getaddrinfo, [IPv6_CHECK_FUNC(gai_strerror,\n                [AC_DEFINE(HAVE_GETADDRINFO,[],[Do we have a getaddrinfo() function?])\n                sasl_cv_getaddrinfo=no])])\nif test $sasl_cv_getaddrinfo = yes; then\n    AC_LIBOBJ(getaddrinfo)\n    GETADDRINFOOBJS=\"getaddrinfo.o\"\n    LTGETADDRINFOOBJS=\"getaddrinfo.lo\"\nfi\nAC_SUBST(GETADDRINFOOBJS)\nAC_SUBST(LTGETADDRINFOOBJS)\n\ndnl Check for getnameinfo\nGETNAMEINFOOBJS=\"\"\nsasl_cv_getnameinfo=no\nIPv6_CHECK_FUNC(getnameinfo,\n\t\t[AC_DEFINE(HAVE_GETNAMEINFO,[],[Do we have a getnameinfo() function?])], [sasl_cv_getnameinfo=yes])\nif test $sasl_cv_getnameinfo = yes; then\n\tAC_LIBOBJ(getnameinfo)\n        GETNAMEINFOOBJS=\"getnameinfo.o\"\n        LTGETNAMEINFOOBJS=\"getnameinfo.lo\"\nfi\nAC_SUBST(GETNAMEINFOOBJS)\nAC_SUBST(LTGETNAMEINFOOBJS)\n\nLTLIBOBJS=`echo \"$LIB@&t@OBJS\" | sed 's,\\.[[^.]]* ,.lo ,g;s,\\.[[^.]]*$,.lo,'`\nAM_CONDITIONAL(BUILD_LIBOBJ, test \"$LTLIBOBJS\" != \"\")\nAC_SUBST(LTLIBOBJS)\n\nAC_C_CONST\nAC_C_INLINE\nAC_TYPE_MODE_T\nAC_TYPE_PID_T\nAC_TYPE_SIGNAL\n\nAC_HEADER_TIME\nAC_HEADER_STDC\nAC_HEADER_DIRENT\nAC_HEADER_SYS_WAIT\nAC_CHECK_HEADERS(crypt.h des.h dlfcn.h fcntl.h limits.h malloc.h paths.h strings.h sys/file.h sys/time.h syslog.h unistd.h inttypes.h sys/uio.h sys/param.h sysexits.h stdarg.h varargs.h krb5.h)\n\nIPv6_CHECK_SS_FAMILY()\nIPv6_CHECK_SA_LEN()\nIPv6_CHECK_SOCKLEN_T()\n\n#AC_FUNC_MEMCMP\n#AC_FUNC_VPRINTF\nAC_CHECK_FUNCS(gethostname getdomainname getpwnam getspnam gettimeofday inet_aton memcpy mkdir select socket strchr strdup strerror strspn strstr strtol jrand48 getpassphrase asprintf strlcat strlcpy)\n\nif test $ac_cv_func_getspnam = yes; then\n\tAC_MSG_CHECKING(if getpwnam_r/getspnam_r take 5 arguments)\n\tAC_TRY_COMPILE(\n\t\t[\n#include <sys/types.h>\n#include <pwd.h>\n#include <shadow.h>\n\t\t],\n\t\t[\nstruct passwd *pw;\nstruct passwd pwbuf;\nchar pwdata[512];\n(void) getpwnam_r(\"bin\", &pwbuf, pwdata, sizeof(pwdata), &pw);\n\t\t],\n\t\t[AC_MSG_RESULT(yes)\n\t\t AC_DEFINE(GETXXNAM_R_5ARG, 1,\n\t\t\t[Define if your getpwnam_r()/getspnam_r()\n\t\t\tfunctions take 5 arguments])],\n\t\t[AC_MSG_RESULT(no)]\n\t)\nfi\n\nif test $enable_cmulocal = yes; then\n    AC_WARN([enabling CMU local kludges])\n    AC_DEFINE(KRB4_IGNORE_IP_ADDRESS,[],[Ignore IP Address in Kerberos 4 tickets?])\n    AC_DEFINE_UNQUOTED(PREFER_MECH, \"KERBEROS_V4\", [Force a preferred mechanism])\nfi\n\nAC_EGREP_HEADER(sockaddr_storage, sys/socket.h, [\n\t\tAC_DEFINE(HAVE_STRUCT_SOCKADDR_STORAGE,[],[Do we have struct sockaddr_stroage?])])\n\nAC_SUBST(DIRS)\n\ndnl documentation generation (sphinx, perl2rst)\nAC_ARG_VAR(SPHINX_BUILD, [Location of sphinx-build])\nAC_ARG_WITH([sphinx-build],\n            AS_HELP_STRING([with-sphinx-build=(yes|no|PATH)], [Look for sphinx-build in PATH]),\n            [with_sphinx_build=$withval],\n            [with_sphinx_build=yes])\nAS_CASE([$with_sphinx_build],\n        [yes],  [AC_PATH_PROG(SPHINX_BUILD, sphinx-build)],\n        [no],   [SPHINX_BUILD=''],\n        [*],    [AC_PATH_PROG(SPHINX_BUILD, sphinx-build, [], [$with_sphinx_build])])\nAS_IF([test -z \"$SPHINX_BUILD\"],\n      [AC_MSG_WARN([No sphinx-build, won't be able to regenerate docs])])\nAC_SUBST([SPHINX_BUILD])\nAC_PROG_PERL_MODULES([Pod::POM::View::Restructured],\n                     [have_ppvr=yes],\n                     [AC_MSG_WARN([No Pod::POM::View::Restructured, won't be able to regenerate docs])])\nAM_CONDITIONAL([HAVE_SPHINX_BUILD], [ test -n \"$SPHINX_BUILD\" -a x\"$have_ppvr\" = xyes])\n\n\nAH_TOP([\n/* acconfig.h - autoheader configuration input */\n/* \n * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The name \"Carnegie Mellon University\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For permission or any other legal\n *    details, please contact  \n *      Office of Technology Transfer\n *      Carnegie Mellon University\n *      5000 Forbes Avenue\n *      Pittsburgh, PA  15213-3890\n *      (412) 268-4387, fax: (412) 268-7395\n *      tech-transfer@andrew.cmu.edu\n *\n * 4. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by Computing Services\n *     at Carnegie Mellon University (http://www.cmu.edu/computing/).\"\n *\n * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO\n * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE\n * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef CONFIG_H\n#define CONFIG_H\n])\n\nAH_BOTTOM([\n\n\n/* Create a struct iovec if we need one */\n#if !defined(_WIN32)\n#if !defined(HAVE_SYS_UIO_H)\n/* (win32 is handled in sasl.h) */\nstruct iovec {\n    char *iov_base;\n    long iov_len;\n};\n#else\n#include <sys/types.h>\n#include <sys/uio.h>\n#endif\n#endif\n\n/* location of the random number generator */\n#ifdef DEV_RANDOM\n#undef DEV_RANDOM\n#endif\n#define DEV_RANDOM SASL_DEV_RANDOM\n\n/* if we've got krb_get_err_txt, we might as well use it;\n   especially since krb_err_txt isn't in some newer distributions\n   (MIT Kerb for Mac 4 being a notable example). If we don't have\n   it, we fall back to the krb_err_txt array */\n#ifdef HAVE_KRB_GET_ERR_TEXT\n#define get_krb_err_txt krb_get_err_text\n#else\n#define get_krb_err_txt(X) (krb_err_txt[(X)])\n#endif\n\n/* Make Solaris happy... */\n#ifndef __EXTENSIONS__\n#define __EXTENSIONS__\n#endif\n\n/* Make Linux happy... */\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#define SASL_PATH_ENV_VAR \"SASL_PATH\"\n#define SASL_CONF_PATH_ENV_VAR \"SASL_CONF_PATH\"\n\n#include <stdlib.h>\n#include <sys/types.h>\n#ifndef WIN32\n# include <sys/socket.h>\n# include <netdb.h>\n# include <netinet/in.h>\n# ifdef HAVE_SYS_PARAM_H\n#  include <sys/param.h>\n# endif\n#else /* WIN32 */\n# include <winsock2.h>\n#endif /* WIN32 */\n#include <string.h>\n\n#ifndef HAVE_SOCKLEN_T\ntypedef unsigned int socklen_t;\n#endif /* HAVE_SOCKLEN_T */\n\n#if !defined(HAVE_STRUCT_SOCKADDR_STORAGE) && !defined(WIN32)\n#define\t_SS_MAXSIZE\t128\t/* Implementation specific max size */\n#define\t_SS_PADSIZE\t(_SS_MAXSIZE - sizeof (struct sockaddr))\n\nstruct sockaddr_storage {\n\tstruct\tsockaddr ss_sa;\n\tchar\t\t__ss_pad2[_SS_PADSIZE];\n};\n# define ss_family ss_sa.sa_family\n#endif /* !HAVE_STRUCT_SOCKADDR_STORAGE */\n\n#ifndef AF_INET6\n/* Define it to something that should never appear */\n#define\tAF_INET6\tAF_MAX\n#endif\n\n#ifndef HAVE_GETADDRINFO\n#define\tgetaddrinfo\tsasl_getaddrinfo\n#define\tfreeaddrinfo\tsasl_freeaddrinfo\n#define\tgai_strerror\tsasl_gai_strerror\n#endif\n\n#ifndef HAVE_GETNAMEINFO\n#define\tgetnameinfo\tsasl_getnameinfo\n#endif\n\n#if !defined(HAVE_GETNAMEINFO) || !defined(HAVE_GETADDRINFO)\n#include \"gai.h\"\n#endif\n\n#ifndef AI_NUMERICHOST   /* support glibc 2.0.x */\n#define AI_NUMERICHOST  4\n#define NI_NUMERICHOST  2\n#define NI_NAMEREQD     4\n#define NI_NUMERICSERV  8\n#endif\n\n/* Defined in RFC 1035. max strlen is only 253 due to length bytes. */\n#ifndef MAXHOSTNAMELEN\n#define        MAXHOSTNAMELEN  255\n#endif\n\n#ifndef HAVE_SYSEXITS_H\n#include \"exits.h\"\n#else\n#include \"sysexits.h\"\n#endif\n\n/* Get the correct time.h */\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n\n#ifndef HIER_DELIMITER\n#define HIER_DELIMITER '/'\n#endif\n\n#ifdef WIN32\n#define SASL_ROOT_KEY \"SOFTWARE\\\\Carnegie Mellon\\\\Project Cyrus\\\\SASL Library\"\n#define SASL_PLUGIN_PATH_ATTR \"SearchPath\"\n#define SASL_CONF_PATH_ATTR \"ConfFile\"\n\n#include <windows.h>\ninline static unsigned int sleep(unsigned int seconds) {\n       Sleep(seconds * 1000);\n       return 0;\n}\n#endif\n\n/* handy string manipulation functions */\n#ifndef HAVE_STRLCPY\nextern size_t saslauthd_strlcpy(char *dst, const char *src, size_t len);\n#define strlcpy(x,y,z) saslauthd_strlcpy((x),(y),(z))\n#endif\n#ifndef HAVE_STRLCAT\nextern size_t saslauthd_strlcat(char *dst, const char *src, size_t len);\n#define strlcat(x,y,z) saslauthd_strlcat((x),(y),(z))\n#endif\n#ifndef HAVE_ASPRINTF\nextern int asprintf(char **str, const char *fmt, ...);\n#endif\n\n#endif /* CONFIG_H */\n])\n\nAH_BOTTOM([#if defined __GNUC__ &&  __GNUC__ > 6\n    #define GCC_FALLTHROUGH __attribute__((fallthrough));\n#else\n    #define GCC_FALLTHROUGH /* fall through */\n#endif\n])\n\nAC_CONFIG_HEADERS(config.h)\n\nAC_OUTPUT(Makefile\nlibsasl2.pc\ninclude/Makefile\nsaslauthd/Makefile\nsasldb/Makefile\ncommon/Makefile\nplugins/Makefile\nlib/Makefile\nutils/Makefile\nsample/Makefile\njava/Makefile\njava/CyrusSasl/Makefile\njava/Test/Makefile\njava/javax/Makefile\njava/javax/security/Makefile\njava/javax/security/auth/Makefile\njava/javax/security/auth/callback/Makefile\npwcheck/Makefile)\n\nAC_MSG_NOTICE([\n\ncyrus-sasl - $VERSION\n\n\u2022 Prefix: $prefix\n\u2022 Plugins: $SASL_MECHS\n\nNow type 'make' to build $PACKAGE\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/lib/dlopen.c": "/* dlopen.c--Unix dlopen() dynamic loader interface\n * Rob Siemborski\n * Rob Earhart\n */\n/* \n * Copyright (c) 1998-2016 Carnegie Mellon University.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The name \"Carnegie Mellon University\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For permission or any other legal\n *    details, please contact  \n *      Carnegie Mellon University\n *      Center for Technology Transfer and Enterprise Creation\n *      4615 Forbes Avenue\n *      Suite 302\n *      Pittsburgh, PA  15213\n *      (412) 268-7393, fax: (412) 268-7395\n *      innovation@andrew.cmu.edu\n *\n * 4. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by Computing Services\n *     at Carnegie Mellon University (http://www.cmu.edu/computing/).\"\n *\n * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO\n * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE\n * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <config.h>\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdlib.h>\n#include <errno.h>\n#include <stdio.h>\n#include <limits.h>\n\n#include <sasl.h>\n#include \"saslint.h\"\n\n#ifndef PIC\n#include <saslplug.h>\n#include \"staticopen.h\"\n#endif\n\n#ifdef DO_DLOPEN\n#if HAVE_DIRENT_H\n# include <dirent.h>\n# define NAMLEN(dirent) strlen((dirent)->d_name)\n#else /* HAVE_DIRENT_H */\n# define dirent direct\n# define NAMLEN(dirent) (dirent)->d_namlen\n# if HAVE_SYS_NDIR_H\n#  include <sys/ndir.h>\n# endif\n# if HAVE_SYS_DIR_H\n#  include <sys/dir.h>\n# endif\n# if HAVE_NDIR_H\n#  include <ndir.h>\n# endif\n#endif /* ! HAVE_DIRENT_H */\n\n#ifndef NAME_MAX\n# ifdef _POSIX_NAME_MAX\n#  define NAME_MAX _POSIX_NAME_MAX\n# else\n#  define NAME_MAX 16\n# endif\n#endif\n \n#if NAME_MAX < 8\n#  define NAME_MAX 8\n#endif\n\n#ifdef __hpux\n#ifndef HAVE_DLFCN_H\n#include <dl.h>\n\ntypedef shl_t * dll_handle;\ntypedef void * dll_func;\n\ndll_handle\ndlopen(char *fname, int mode)\n{\n    shl_t h = shl_load(fname, BIND_DEFERRED, 0L);\n    shl_t *hp = NULL;\n    \n    if (h) {\n\thp = (shl_t *)malloc(sizeof (shl_t));\n\tif (!hp) {\n\t    shl_unload(h);\n\t} else {\n\t    *hp = h;\n\t}\n    }\n\n    return (dll_handle)hp;\n}\n\nint\ndlclose(dll_handle hp)\n{\n    shl_t h;\n\n    if (hp != NULL) {\n\th = *((shl_t *)hp);\n\tfree(hp);\n\treturn shl_unload(h);\n    } else {\n\t/* Return error */\n\treturn -1;\n    }\n}\n\ndll_func\ndlsym(dll_handle h, char *n)\n{\n    dll_func handle;\n    \n    if (shl_findsym ((shl_t *)h, n, TYPE_PROCEDURE, &handle))\n\treturn NULL;\n    \n    return (dll_func)handle;\n}\n\nchar *dlerror()\n{\n    if (errno != 0) {\n\treturn strerror(errno);\n    }\n    return \"Generic shared library error\";\n}\n\n#endif /* HAVE_DLFCN_H */\n\n#ifdef __ia64\n#define SO_SUFFIX       \".so\"\n#else\n#define SO_SUFFIX\t\".sl\"\n#endif /* __ia64 */\n\n#else /* __hpux */\n#define SO_SUFFIX\t\".so\"\n#endif\n\n#define LA_SUFFIX       \".la\"\n\ntypedef struct lib_list \n{\n    struct lib_list *next;\n    void *library;\n} lib_list_t;\n\nstatic lib_list_t *lib_list_head = NULL;\n\n#endif /* DO_DLOPEN */\n\nint _sasl_locate_entry(void *library, const char *entryname,\n\t\t       void **entry_point) \n{\n#ifdef DO_DLOPEN\n/* note that we still check for known problem systems in\n * case we are cross-compiling */\n#if defined(DLSYM_NEEDS_UNDERSCORE) || (defined(__OpenBSD__) && !defined(__ELF__))\n    char adj_entryname[1024];\n#else\n#define adj_entryname entryname\n#endif\n\n    if(!entryname) {\n\t_sasl_log(NULL, SASL_LOG_ERR,\n\t\t  \"no entryname in _sasl_locate_entry\");\n\treturn SASL_BADPARAM;\n    }\n\n    if(!library) {\n\t_sasl_log(NULL, SASL_LOG_ERR,\n\t\t  \"no library in _sasl_locate_entry\");\n\treturn SASL_BADPARAM;\n    }\n\n    if(!entry_point) {\n\t_sasl_log(NULL, SASL_LOG_ERR,\n\t\t  \"no entrypoint output pointer in _sasl_locate_entry\");\n\treturn SASL_BADPARAM;\n    }\n\n#if defined(DLSYM_NEEDS_UNDERSCORE) || (defined(__OpenBSD__) && !defined(__ELF__))\n    snprintf(adj_entryname, sizeof adj_entryname, \"_%s\", entryname);\n#endif\n\n    *entry_point = NULL;\n    *entry_point = dlsym(library, adj_entryname);\n    if (*entry_point == NULL) {\n#if 0 /* This message appears to confuse people */\n\t_sasl_log(NULL, SASL_LOG_DEBUG,\n\t\t  \"unable to get entry point %s: %s\", adj_entryname,\n\t\t  dlerror());\n#endif\n\treturn SASL_FAIL;\n    }\n\n    return SASL_OK;\n#else\n    return SASL_FAIL;\n#endif /* DO_DLOPEN */\n}\n\n#ifdef DO_DLOPEN\n\nstatic int _sasl_plugin_load(char *plugin, void *library,\n\t\t\t     const char *entryname,\n\t\t\t     int (*add_plugin)(const char *, void *)) \n{\n    void *entry_point;\n    int result;\n    \n    result = _sasl_locate_entry(library, entryname, &entry_point);\n    if(result == SASL_OK) {\n\tresult = add_plugin(plugin, entry_point);\n\tif(result != SASL_OK)\n\t    _sasl_log(NULL, SASL_LOG_DEBUG,\n\t\t      \"_sasl_plugin_load failed on %s for plugin: %s\\n\",\n\t\t      entryname, plugin);\n    }\n\n    return result;\n}\n\n/* this returns the file to actually open.\n *  out should be a buffer of size PATH_MAX\n *  and may be the same as in. */\n\n/* We'll use a static buffer for speed unless someone complains */\n#define MAX_LINE 2048\n\nstatic int _parse_la(const char *prefix, const char *in, char *out) \n{\n    FILE *file;\n    size_t length;\n    char line[MAX_LINE];\n    char *ntmp = NULL;\n\n    if(!in || !out || !prefix || out == in) return SASL_BADPARAM;\n\n    /* Set this so we can detect failure */\n    *out = '\\0';\n\n    length = strlen(in);\n\n    if (strcmp(in + (length - strlen(LA_SUFFIX)), LA_SUFFIX)) {\n\tif(!strcmp(in + (length - strlen(SO_SUFFIX)),SO_SUFFIX)) {\n\t    /* check for a .la file */\n\t    if (strlen(prefix) + strlen(in) + strlen(LA_SUFFIX) + 1 >= MAX_LINE)\n\t\treturn SASL_BADPARAM;\n\t    strcpy(line, prefix);\n\t    strcat(line, in);\n\t    length = strlen(line);\n\t    *(line + (length - strlen(SO_SUFFIX))) = '\\0';\n\t    strcat(line, LA_SUFFIX);\n\t    file = fopen(line, \"r\");\n\t    if(file) {\n\t\t/* We'll get it on the .la open */\n\t\tfclose(file);\n\t\treturn SASL_FAIL;\n\t    }\n\t}\n        if (strlen(prefix) + strlen(in) + 1 >= PATH_MAX)\n            return SASL_BADPARAM;\n\tstrcpy(out, prefix);\n\tstrcat(out, in);\n\treturn SASL_OK;\n    }\n\n    if (strlen(prefix) + strlen(in) + 1 >= MAX_LINE)\n        return SASL_BADPARAM;\n    strcpy(line, prefix);\n    strcat(line, in);\n\n    file = fopen(line, \"r\");\n    if(!file) {\n\t_sasl_log(NULL, SASL_LOG_WARN,\n\t\t  \"unable to open LA file: %s\", line);\n\treturn SASL_FAIL;\n    }\n    \n    while(!feof(file)) {\n\tif(!fgets(line, MAX_LINE, file)) break;\n\tif(line[strlen(line) - 1] != '\\n') {\n\t    _sasl_log(NULL, SASL_LOG_WARN,\n\t\t      \"LA file has too long of a line: %s\", in);\n\t    fclose(file);\n\t    return SASL_BUFOVER;\n\t}\n\tif(line[0] == '\\n' || line[0] == '#') continue;\n\tif(!strncmp(line, \"dlname=\", sizeof(\"dlname=\") - 1)) {\n\t    /* We found the line with the name in it */\n\t    char *end;\n\t    char *start;\n\t    size_t len;\n\t    end = strrchr(line, '\\'');\n\t    if(!end) continue;\n\t    start = &line[sizeof(\"dlname=\")-1];\n\t    len = strlen(start);\n\t    if(len > 3 && start[0] == '\\'') {\n\t\tntmp=&start[1];\n\t\t*end='\\0';\n\t\t/* Do we have dlname=\"\" ? */\n\t\tif(ntmp == end) {\n\t\t    _sasl_log(NULL, SASL_LOG_DEBUG,\n\t\t\t      \"dlname is empty in .la file: %s\", in);\n\t\t    fclose(file);\n\t\t    return SASL_FAIL;\n\t\t}\n\t\tstrcpy(out, prefix);\n\t\tstrcat(out, ntmp);\n\t    }\n\t    break;\n\t}\n    }\n    if(ferror(file) || feof(file)) {\n\t_sasl_log(NULL, SASL_LOG_WARN,\n\t\t  \"Error reading .la: %s\\n\", in);\n\tfclose(file);\n\treturn SASL_FAIL;\n    }\n    fclose(file);\n\n    if(!(*out)) {\n\t_sasl_log(NULL, SASL_LOG_WARN,\n\t\t  \"Could not find a dlname line in .la file: %s\", in);\n\treturn SASL_FAIL;\n    }\n\n    return SASL_OK;\n}\n#endif /* DO_DLOPEN */\n\n/* loads a plugin library */\nint _sasl_get_plugin(const char *file,\n\t\t     const sasl_callback_t *verifyfile_cb,\n\t\t     void **libraryptr)\n{\n#ifdef DO_DLOPEN\n    int r = 0;\n    int flag;\n    void *library;\n    lib_list_t *newhead;\n    \n    r = ((sasl_verifyfile_t *)(verifyfile_cb->proc))\n\t\t    (verifyfile_cb->context, file, SASL_VRFY_PLUGIN);\n    if (r != SASL_OK) return r;\n\n#ifdef RTLD_NOW\n    flag = RTLD_NOW;\n#else\n    flag = 0;\n#endif\n\n    newhead = sasl_ALLOC(sizeof(lib_list_t));\n    if(!newhead) return SASL_NOMEM;\n\n    if (!(library = dlopen(file, flag))) {\n\t_sasl_log(NULL, SASL_LOG_ERR,\n\t\t  \"unable to dlopen %s: %s\", file, dlerror());\n\tsasl_FREE(newhead);\n\treturn SASL_FAIL;\n    }\n\n    newhead->library = library;\n    newhead->next = lib_list_head;\n    lib_list_head = newhead;\n\n    *libraryptr = library;\n    return SASL_OK;\n#else\n    return SASL_FAIL;\n#endif /* DO_DLOPEN */\n}\n\n/* gets the list of mechanisms */\nint _sasl_load_plugins(const add_plugin_list_t *entrypoints,\n\t\t       const sasl_callback_t *getpath_cb,\n\t\t       const sasl_callback_t *verifyfile_cb)\n{\n    int result;\n    const add_plugin_list_t *cur_ep;\n#ifdef DO_DLOPEN\n    char str[PATH_MAX], tmp[PATH_MAX+2], prefix[PATH_MAX+2];\n\t\t\t\t/* 1 for '/' 1 for trailing '\\0' */\n    char c;\n    int pos;\n    const char *path=NULL;\n    int position;\n    DIR *dp;\n    struct dirent *dir;\n#endif\n#ifndef PIC\n    add_plugin_t *add_plugin;\n    _sasl_plug_type type;\n    _sasl_plug_rec *p;\n#endif\n\n    if (! entrypoints\n\t|| ! getpath_cb\n\t|| getpath_cb->id != SASL_CB_GETPATH\n\t|| ! getpath_cb->proc\n\t|| ! verifyfile_cb\n\t|| verifyfile_cb->id != SASL_CB_VERIFYFILE\n\t|| ! verifyfile_cb->proc)\n\treturn SASL_BADPARAM;\n\n#ifndef PIC\n    /* do all the static plugins first */\n\n    for(cur_ep = entrypoints; cur_ep->entryname; cur_ep++) {\n\n\t/* What type of plugin are we looking for? */\n\tif(!strcmp(cur_ep->entryname, \"sasl_server_plug_init\")) {\n\t    type = SERVER;\n\t    add_plugin = (add_plugin_t *)sasl_server_add_plugin;\n\t} else if (!strcmp(cur_ep->entryname, \"sasl_client_plug_init\")) {\n\t    type = CLIENT;\n\t    add_plugin = (add_plugin_t *)sasl_client_add_plugin;\n\t} else if (!strcmp(cur_ep->entryname, \"sasl_auxprop_plug_init\")) {\n\t    type = AUXPROP;\n\t    add_plugin = (add_plugin_t *)sasl_auxprop_add_plugin;\n\t} else if (!strcmp(cur_ep->entryname, \"sasl_canonuser_init\")) {\n\t    type = CANONUSER;\n\t    add_plugin = (add_plugin_t *)sasl_canonuser_add_plugin;\n\t} else {\n\t    /* What are we looking for then? */\n\t    return SASL_FAIL;\n\t}\n\tfor (p=_sasl_static_plugins; p->type; p++) {\n\t    if(type == p->type)\n\t    \tresult = add_plugin(p->name, p->plug);\n\t}\n    }\n#endif /* !PIC */\n\n/* only do the following if:\n * \n * we support dlopen()\n *  AND we are not staticly compiled\n *      OR we are staticly compiled and TRY_DLOPEN_WHEN_STATIC is defined\n */\n#if defined(DO_DLOPEN) && (defined(PIC) || (!defined(PIC) && defined(TRY_DLOPEN_WHEN_STATIC)))\n    /* get the path to the plugins */\n    result = ((sasl_getpath_t *)(getpath_cb->proc))(getpath_cb->context,\n\t\t\t\t\t\t    &path);\n    if (result != SASL_OK) return result;\n    if (! path) return SASL_FAIL;\n\n    if (strlen(path) >= PATH_MAX) { /* no you can't buffer overrun */\n\treturn SASL_FAIL;\n    }\n\n    position=0;\n    do {\n\tpos=0;\n\tdo {\n\t    c=path[position];\n\t    position++;\n\t    str[pos]=c;\n\t    pos++;\n\t} while ((c!=':') && (c!='=') && (c!=0));\n\tstr[pos-1]='\\0';\n\n\tstrcpy(prefix,str);\n\tstrcat(prefix,\"/\");\n\n\tif ((dp=opendir(str)) !=NULL) /* ignore errors */    \n\t{\n\t    while ((dir=readdir(dp)) != NULL)\n\t    {\n\t\tsize_t length;\n\t\tvoid *library;\n\t\tchar *c;\n\t\tchar plugname[PATH_MAX];\n\t\tchar name[PATH_MAX];\n\n\t\tlength = NAMLEN(dir);\n\t\tif (length < 4) \n\t\t    continue; /* can not possibly be what we're looking for */\n\n\t\tif (length + pos>=PATH_MAX) continue; /* too big */\n\n\t\tif (strcmp(dir->d_name + (length - strlen(SO_SUFFIX)),\n\t\t\t   SO_SUFFIX)\n\t\t    && strcmp(dir->d_name + (length - strlen(LA_SUFFIX)),\n\t\t\t   LA_SUFFIX))\n\t\t    continue;\n\n\t\tmemcpy(name,dir->d_name,length);\n\t\tname[length]='\\0';\n\n\t\tresult = _parse_la(prefix, name, tmp);\n\t\tif(result != SASL_OK)\n\t\t    continue;\n\t\t\n\t\t/* skip \"lib\" and cut off suffix --\n\t\t   this only need be approximate */\n\t\tstrcpy(plugname, name + 3);\n\t\tc = strchr(plugname, (int)'.');\n\t\tif(c) *c = '\\0';\n\n\t\tresult = _sasl_get_plugin(tmp, verifyfile_cb, &library);\n\n\t\tif(result != SASL_OK)\n\t\t    continue;\n\n\t\tfor(cur_ep = entrypoints; cur_ep->entryname; cur_ep++) {\n\t\t\t_sasl_plugin_load(plugname, library, cur_ep->entryname,\n\t\t\t\t\t  cur_ep->add_plugin);\n\t\t\t/* If this fails, it's not the end of the world */\n\t\t}\n\t    }\n\n\t    closedir(dp);\n\t} else {\n\t    _sasl_log(NULL, SASL_LOG_DEBUG,\n\t\t      \"looking for plugins in '%s', failed to open directory, error: %s\",\n\t\t      str,\n\t\t      strerror(errno));\n\t}\n\n    } while ((c!='=') && (c!=0));\n#endif /* defined(DO_DLOPEN) && (!defined(PIC) || (defined(PIC) && defined(TRY_DLOPEN_WHEN_STATIC))) */\n\n    return SASL_OK;\n}\n\nint\n_sasl_done_with_plugins(void)\n{\n#ifdef DO_DLOPEN\n    lib_list_t *libptr, *libptr_next;\n    \n    for(libptr = lib_list_head; libptr; libptr = libptr_next) {\n\tlibptr_next = libptr->next;\n\tif(libptr->library)\n\t    dlclose(libptr->library);\n\tsasl_FREE(libptr);\n    }\n\n    lib_list_head = NULL;\n#endif /* DO_DLOPEN */\n    return SASL_OK;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/dlcompat-20010505/dlfcn.h": "/*\n * This file was modified by Christoph Pfisterer <cp@chrisp.de>\n * on Sat, May 5 2001. See the file \"ChangeLog\" for details of what\n * was changed.\n *\n *\n * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.\n *\n * @APPLE_LICENSE_HEADER_START@\n * \n * Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights\n * Reserved.  This file contains Original Code and/or Modifications of\n * Original Code as defined in and that are subject to the Apple Public\n * Source License Version 1.1 (the \"License\").  You may not use this file\n * except in compliance with the License.  Please obtain a copy of the\n * License at http://www.apple.com/publicsource and read it before using\n * this file.\n * \n * The Original Code and all software distributed under the License are\n * distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY KIND, EITHER\n * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,\n * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE OR NON- INFRINGEMENT.  Please see the\n * License for the specific language governing rights and limitations\n * under the License.\n * \n * @APPLE_LICENSE_HEADER_END@\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern void * dlopen(\n    const char *path,\n    int mode);\nextern void * dlsym(\n    void * handle,\n    const char *symbol);\nextern const char * dlerror(\n    void);\nextern int dlclose(\n    void * handle);\n\n#define RTLD_LAZY\t0x1\n#define RTLD_NOW\t0x2\n#define RTLD_LOCAL\t0x4\n#define RTLD_GLOBAL\t0x8\n#define RTLD_NOLOAD\t0x10\n#define RTLD_SHARED\t0x20\t/* not used, the default */\n#define RTLD_UNSHARED\t0x40\n#define RTLD_NODELETE\t0x80\n#define RTLD_LAZY_UNDEF\t0x100\n\n#ifdef __cplusplus\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/dlcompat-20010505/dlopen.c": "/*\n * This file was modified by Christoph Pfisterer <cp@chrisp.de>\n * on Tue, Jan 23 2001. See the file \"ChangeLog\" for details of what\n * was changed.\n *\n *\n * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.\n *\n * @APPLE_LICENSE_HEADER_START@\n * \n * Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights\n * Reserved.  This file contains Original Code and/or Modifications of\n * Original Code as defined in and that are subject to the Apple Public\n * Source License Version 1.1 (the \"License\").  You may not use this file\n * except in compliance with the License.  Please obtain a copy of the\n * License at http://www.apple.com/publicsource and read it before using\n * this file.\n * \n * The Original Code and all software distributed under the License are\n * distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY KIND, EITHER\n * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,\n * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE OR NON- INFRINGEMENT.  Please see the\n * License for the specific language governing rights and limitations\n * under the License.\n * \n * @APPLE_LICENSE_HEADER_END@\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <limits.h>\n#include \"mach-o/dyld.h\"\n#include \"dlfcn.h\"\n\n/*\n * debugging macros\n */\n#if DEBUG > 0\n#define DEBUG_PRINT(format) fprintf(stderr,(format));fflush(stderr)\n#define DEBUG_PRINT1(format,arg1) fprintf(stderr,(format),(arg1));\\\n  fflush(stderr)\n#define DEBUG_PRINT2(format,arg1,arg2) fprintf(stderr,(format),\\\n  (arg1),(arg2));fflush(stderr)\n#define DEBUG_PRINT3(format,arg1,arg2,arg3) fprintf(stderr,(format),\\\n  (arg1),(arg2),(arg3));fflush(stderr)\n#else\n#define DEBUG_PRINT(format) /**/\n#define DEBUG_PRINT1(format,arg1) /**/\n#define DEBUG_PRINT2(format,arg1,arg2) /**/\n#define DEBUG_PRINT3(format,arg1,arg2,arg3) /**/\n#undef DEBUG\n#endif\n\n/*\n * The structure of a dlopen() handle.\n */\nstruct dlopen_handle {\n    dev_t dev;\t\t/* the path's device and inode number from stat(2) */\n    ino_t ino; \n    int dlopen_mode;\t/* current dlopen mode for this handle */\n    int dlopen_count;\t/* number of times dlopen() called on this handle */\n    NSModule module;\t/* the NSModule returned by NSLinkModule() */\n    struct dlopen_handle *prev;\n    struct dlopen_handle *next;\n};\nstatic struct dlopen_handle *dlopen_handles = NULL;\nstatic const struct dlopen_handle main_program_handle = {NULL};\nstatic char *dlerror_pointer = NULL;\n\n/*\n * NSMakePrivateModulePublic() is not part of the public dyld API so we define\n * it here.  The internal dyld function pointer for\n * __dyld_NSMakePrivateModulePublic is returned so thats all that maters to get\n * the functionality need to implement the dlopen() interfaces.\n */\nstatic\nint\nNSMakePrivateModulePublic(\nNSModule module)\n{\n    static int (*p)(NSModule module) = NULL;\n\n\tif(p == NULL)\n\t    _dyld_func_lookup(\"__dyld_NSMakePrivateModulePublic\",\n\t\t\t      (unsigned long *)&p);\n\tif(p == NULL){\n#ifdef DEBUG\n\t    printf(\"_dyld_func_lookup of __dyld_NSMakePrivateModulePublic \"\n\t\t   \"failed\\n\");\n#endif\n\t    return(FALSE);\n\t}\n\treturn(p(module));\n}\n\n/*\n * helper routine: search for a named module in various locations\n */\nstatic\nint\n_dl_search_paths(\nconst char *filename,\nchar *pathbuf,\nstruct stat *stat_buf)\n{\n    const char *pathspec;\n    const char *element;\n    const char *p;\n    char *q;\n    char *pathbuf_end;\n    const char *envvars[] = {\n        \"$DYLD_LIBRARY_PATH\",\n        \"$LD_LIBRARY_PATH\",\n        \"/usr/lib:/lib\",\n        NULL };\n    int envvar_index;\n\n        pathbuf_end = pathbuf + PATH_MAX - 8;\n\n\tfor(envvar_index = 0; envvars[envvar_index]; envvar_index++){\n\t    if(envvars[envvar_index][0] == '$'){\n\t        pathspec = getenv(envvars[envvar_index]+1);\n\t    }\n\t    else {\n\t        pathspec = envvars[envvar_index];\n\t    }\n\n\t    if(pathspec != NULL){\n\t        element = pathspec;\n\t\twhile(*element){\n\t            /* extract path list element */\n\t\t    p = element;\n\t\t    q = pathbuf;\n\t\t    while(*p && *p != ':' && q < pathbuf_end)\n                        *q++ = *p++;\n\t\t    if(q == pathbuf){  /* empty element */\n\t\t        if(*p){\n\t\t            element = p+1;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*p){\n\t\t        element = p+1;\n\t\t    }\n\t\t    else{\n\t\t        element = p;  /* this terminates the loop */\n\t\t    }\n\n\t\t    /* add slash if neccessary */\n\t\t    if(*(q-1) != '/' && q < pathbuf_end){\n\t\t        *q++ = '/';\n\t\t    }\n\n\t\t    /* append module name */\n\t\t    p = filename;\n\t\t    while(*p && q < pathbuf_end) *q++ = *p++;\n\t\t    *q++ = 0;\n\n\t\t    if(q >= pathbuf_end){\n\t\t        /* maybe add an error message here */\n\t\t        break;\n\t\t    }\n\n\t\t    if(stat(pathbuf, stat_buf) == 0){\n\t\t        return 0;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t/* we have searched everywhere, now we give up */\n\treturn -1;\n}\n\n/*\n * dlopen() the MacOS X version of the FreeBSD dlopen() interface.\n */\nvoid *\ndlopen(\nconst char *path,\nint mode)\n{\n    const char *module_path;\n    void *retval;\n    struct stat stat_buf;\n    NSObjectFileImage objectFileImage;\n    NSObjectFileImageReturnCode ofile_result_code;\n    NSModule module;\n    struct dlopen_handle *p;\n    unsigned long options;\n    NSSymbol NSSymbol;\n    void (*init)(void);\n    char pathbuf[PATH_MAX];\n\n        DEBUG_PRINT2(\"libdl: dlopen(%s,0x%x) -> \", path, (unsigned int)mode);\n\n\tdlerror_pointer = NULL;\n\t/*\n\t * A NULL path is to indicate the caller wants a handle for the\n\t * main program.\n \t */\n\tif(path == NULL){\n\t    retval = (void *)&main_program_handle;\n\t    DEBUG_PRINT1(\"main / %p\\n\", retval);\n\t    return(retval);\n\t}\n\n\t/* see if the path exists and if so get the device and inode number */\n\tif(stat(path, &stat_buf) == -1){\n\t    dlerror_pointer = strerror(errno);\n\n\t    if(path[0] == '/'){\n\t        DEBUG_PRINT1(\"ERROR (stat): %s\\n\", dlerror_pointer);\n\t        return(NULL);\n\t    }\n\n\t    /* search for the module in various places */\n\t    if(_dl_search_paths(path, pathbuf, &stat_buf)){\n\t        /* dlerror_pointer is unmodified */\n\t        DEBUG_PRINT1(\"ERROR (stat): %s\\n\", dlerror_pointer);\n\t        return(NULL);\n\t    }\n\t    DEBUG_PRINT1(\"found %s -> \", pathbuf);\n\t    module_path = pathbuf;\n\t    dlerror_pointer = NULL;\n\t}\n\telse{\n\t    module_path = path;\n\t}\n\n\t/*\n\t * If we don't want an unshared handle see if we already have a handle\n\t * for this path.\n\t */\n\tif((mode & RTLD_UNSHARED) != RTLD_UNSHARED){\n\t    p = dlopen_handles;\n\t    while(p != NULL){\n\t\tif(p->dev == stat_buf.st_dev && p->ino == stat_buf.st_ino){\n\t\t    /* skip unshared handles */\n\t\t    if((p->dlopen_mode & RTLD_UNSHARED) == RTLD_UNSHARED)\n\t\t\tcontinue;\n\t\t    /*\n\t\t     * We have already created a handle for this path.  The\n\t\t     * caller might be trying to promote an RTLD_LOCAL handle\n\t\t     * to a RTLD_GLOBAL.  Or just looking it up with\n\t\t     * RTLD_NOLOAD.\n\t\t     */\n\t\t    if((p->dlopen_mode & RTLD_LOCAL) == RTLD_LOCAL &&\n\t\t       (mode & RTLD_GLOBAL) == RTLD_GLOBAL){\n\t\t\t/* promote the handle */\n\t\t\tif(NSMakePrivateModulePublic(p->module) == TRUE){\n\t\t\t    p->dlopen_mode &= ~RTLD_LOCAL;\n\t\t\t    p->dlopen_mode |= RTLD_GLOBAL;\n\t\t\t    p->dlopen_count++;\n\t\t\t    DEBUG_PRINT1(\"%p\\n\", p);\n\t\t\t    return(p);\n\t\t\t}\n\t\t\telse{\n\t\t\t    dlerror_pointer = \"can't promote handle from \"\n\t\t\t\t\t      \"RTLD_LOCAL to RTLD_GLOBAL\";\n\t\t\t    DEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\t\t    return(NULL);\n\t\t\t}\n\t\t    }\n\t\t    p->dlopen_count++;\n\t\t    DEBUG_PRINT1(\"%p\\n\", p);\n\t\t    return(p);\n\t\t}\n\t\tp = p->next;\n\t    }\n\t}\n\t\n\t/*\n\t * We do not have a handle for this path if we were just trying to\n\t * look it up return NULL to indicate we don't have it.\n\t */\n\tif((mode & RTLD_NOLOAD) == RTLD_NOLOAD){\n\t    dlerror_pointer = \"no existing handle for path RTLD_NOLOAD test\";\n\t    DEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t    return(NULL);\n\t}\n\n\t/* try to create an object file image from this path */\n\tofile_result_code = NSCreateObjectFileImageFromFile(module_path,\n\t\t\t\t\t\t\t    &objectFileImage);\n\tif(ofile_result_code != NSObjectFileImageSuccess){\n\t    switch(ofile_result_code){\n\t    case NSObjectFileImageFailure:\n\t\tdlerror_pointer = \"object file setup failure\";\n\t\tDEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\treturn(NULL);\n\t    case NSObjectFileImageInappropriateFile:\n\t\tdlerror_pointer = \"not a Mach-O MH_BUNDLE file type\";\n\t\tDEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\treturn(NULL);\n\t    case NSObjectFileImageArch:\n\t\tdlerror_pointer = \"no object for this architecture\";\n\t\tDEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\treturn(NULL);\n\t    case NSObjectFileImageFormat:\n\t\tdlerror_pointer = \"bad object file format\";\n\t\tDEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\treturn(NULL);\n\t    case NSObjectFileImageAccess:\n\t\tdlerror_pointer = \"can't read object file\";\n\t\tDEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\treturn(NULL);\n\t    default:\n\t\tdlerror_pointer = \"unknown error from \"\n\t\t\t\t  \"NSCreateObjectFileImageFromFile()\";\n\t\tDEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\treturn(NULL);\n\t    }\n\t}\n\n\t/* try to link in this object file image */\n\toptions = NSLINKMODULE_OPTION_PRIVATE;\n\tif((mode & RTLD_NOW) == RTLD_NOW)\n\t    options |= NSLINKMODULE_OPTION_BINDNOW;\n\tmodule = NSLinkModule(objectFileImage, module_path, options);\n\tNSDestroyObjectFileImage(objectFileImage) ;\n\tif(module == NULL){\n\t    dlerror_pointer = \"NSLinkModule() failed for dlopen()\";\n\t    DEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t    return(NULL);\n\t}\n\n\t/*\n\t * If the handle is to be global promote the handle.  It is done this\n\t * way to avoid multiply defined symbols.\n\t */\n\tif((mode & RTLD_GLOBAL) == RTLD_GLOBAL){\n\t    if(NSMakePrivateModulePublic(module) == FALSE){\n\t\tdlerror_pointer = \"can't promote handle from RTLD_LOCAL to \"\n\t\t\t\t  \"RTLD_GLOBAL\";\n\t\tDEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\treturn(NULL);\n\t    }\n\t}\n\n\tp = malloc(sizeof(struct dlopen_handle));\n\tif(p == NULL){\n\t    dlerror_pointer = \"can't allocate memory for the dlopen handle\";\n\t    DEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t    return(NULL);\n\t}\n\n\t/* fill in the handle */\n\tp->dev = stat_buf.st_dev;\n        p->ino = stat_buf.st_ino;\n\tif(mode & RTLD_GLOBAL)\n\t    p->dlopen_mode = RTLD_GLOBAL;\n\telse\n\t    p->dlopen_mode = RTLD_LOCAL;\n\tp->dlopen_mode |= (mode & RTLD_UNSHARED) |\n\t\t\t  (mode & RTLD_NODELETE) |\n\t\t\t  (mode & RTLD_LAZY_UNDEF);\n\tp->dlopen_count = 1;\n\tp->module = module;\n\tp->prev = NULL;\n\tp->next = dlopen_handles;\n\tif(dlopen_handles != NULL)\n\t    dlopen_handles->prev = p;\n\tdlopen_handles = p;\n\n\t/* call the init function if one exists */\n\tNSSymbol = NSLookupSymbolInModule(p->module, \"__init\");\n\tif(NSSymbol != NULL){\n\t    init = NSAddressOfSymbol(NSSymbol);\n\t    init();\n\t}\n\t\n\tDEBUG_PRINT1(\"%p\\n\", p);\n\treturn(p);\n}\n\n/*\n * dlsym() the MacOS X version of the FreeBSD dlopen() interface.\n */\nvoid *\ndlsym(\nvoid * handle,\nconst char *symbol)\n{\n    struct dlopen_handle *dlopen_handle, *p;\n    NSSymbol NSSymbol;\n    void *address;\n\n        DEBUG_PRINT2(\"libdl: dlsym(%p,%s) -> \", handle, symbol);\n\n\tdlopen_handle = (struct dlopen_handle *)handle;\n\n\t/*\n\t * If this is the handle for the main program do a global lookup.\n\t */\n\tif(dlopen_handle == (struct dlopen_handle *)&main_program_handle){\n\t    if(NSIsSymbolNameDefined(symbol) == TRUE){\n\t\tNSSymbol = NSLookupAndBindSymbol(symbol);\n\t\taddress = NSAddressOfSymbol(NSSymbol);\n\t\tdlerror_pointer = NULL;\n\t\tDEBUG_PRINT1(\"%p\\n\", address);\n\t\treturn(address);\n\t    }\n\t    else{\n\t\tdlerror_pointer = \"symbol not found\";\n\t\tDEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\treturn(NULL);\n\t    }\n\t}\n\n\t/*\n\t * Find this handle and do a lookup in just this module.\n\t */\n\tp = dlopen_handles;\n\twhile(p != NULL){\n\t    if(dlopen_handle == p){\n\t\tNSSymbol = NSLookupSymbolInModule(p->module, symbol);\n\t\tif(NSSymbol != NULL){\n\t\t    address = NSAddressOfSymbol(NSSymbol);\n\t\t    dlerror_pointer = NULL;\n\t\t    DEBUG_PRINT1(\"%p\\n\", address);\n\t\t    return(address);\n\t\t}\n\t\telse{\n\t\t    dlerror_pointer = \"symbol not found\";\n\t\t    DEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\t    return(NULL);\n\t\t}\n\t    }\n\t    p = p->next;\n\t}\n\n\tdlerror_pointer = \"bad handle passed to dlsym()\";\n\tDEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\treturn(NULL);\n}\n\n/*\n * dlerror() the MacOS X version of the FreeBSD dlopen() interface.\n */\nconst char *\ndlerror(\nvoid)\n{\n    const char *p;\n\n\tp = (const char *)dlerror_pointer;\n\tdlerror_pointer = NULL;\n\treturn(p);\n}\n\n/*\n * dlclose() the MacOS X version of the FreeBSD dlopen() interface.\n */\nint\ndlclose(\nvoid * handle)\n{\n    struct dlopen_handle *p, *q;\n    unsigned long options;\n    NSSymbol NSSymbol;\n    void (*fini)(void);\n\n        DEBUG_PRINT1(\"libdl: dlclose(%p) -> \", handle);\n\n\tdlerror_pointer = NULL;\n\tq = (struct dlopen_handle *)handle;\n\tp = dlopen_handles;\n\twhile(p != NULL){\n\t    if(p == q){\n\t\t/* if the dlopen() count is not zero we are done */\n\t\tp->dlopen_count--;\n\t\tif(p->dlopen_count != 0){\n\t\t    DEBUG_PRINT(\"OK\");\n\t\t    return(0);\n\t\t}\n\n\t\t/* call the fini function if one exists */\n\t\tNSSymbol = NSLookupSymbolInModule(p->module, \"__fini\");\n\t\tif(NSSymbol != NULL){\n\t\t    fini = NSAddressOfSymbol(NSSymbol);\n\t\t    fini();\n\t\t}\n\n\t\t/* unlink the module for this handle */\n\t\toptions = 0;\n\t\tif(p->dlopen_mode & RTLD_NODELETE)\n\t\t    options |= NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED;\n\t\tif(p->dlopen_mode & RTLD_LAZY_UNDEF)\n\t\t    options |= NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES;\n\t\tif(NSUnLinkModule(p->module, options) == FALSE){\n\t\t    dlerror_pointer = \"NSUnLinkModule() failed for dlclose()\";\n\t\t    DEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\t\t    return(-1);\n\t\t}\n\t\tif(p->prev != NULL)\n\t\t    p->prev->next = p->next;\n\t\tif(p->next != NULL)\n\t\t    p->next->prev = p->prev;\n\t\tif(dlopen_handles == p)\n\t\t    dlopen_handles = p->next;\n\t\tfree(p);\n\t\tDEBUG_PRINT(\"OK\");\n\t\treturn(0);\n\t    }\n\t    p = p->next;\n\t}\n\tdlerror_pointer = \"invalid handle passed to dlclose()\";\n\tDEBUG_PRINT1(\"ERROR: %s\\n\", dlerror_pointer);\n\treturn(-1);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/contrib/cyrus-sasl-1.5.24-ltdl.patches": "diff -x ltcf-c.sh -x ltconfig -x ltmain.sh -x libltdl -x config.guess -x config.sub -x configure -x aclocal.m4 -x Makefile.in -uNr cyrus-sasl-1.5.24.orig/Makefile.am cyrus-sasl-1.5.24.new/Makefile.am\n--- cyrus-sasl-1.5.24.orig/Makefile.am\tFri Apr 28 19:16:11 2000\n+++ cyrus-sasl-1.5.24.new/Makefile.am\tTue Jul 17 12:41:06 2001\n@@ -58,7 +58,7 @@\n JAV =\n endif\n \n-SUBDIRS=include lib plugins utils doc man $(PWC) $(SAM) $(JAV)\n+SUBDIRS=include libltdl lib plugins utils doc man $(PWC) $(SAM) $(JAV)\n EXTRA_DIST=config cmulocal win32 testing.txt\n \n dist-hook:\ndiff -x ltcf-c.sh -x ltconfig -x ltmain.sh -x libltdl -x config.guess -x config.sub -x configure -x aclocal.m4 -x Makefile.in -uNr cyrus-sasl-1.5.24.orig/configure.in cyrus-sasl-1.5.24.new/configure.in\n--- cyrus-sasl-1.5.24.orig/configure.in\tFri Jul 21 04:35:01 2000\n+++ cyrus-sasl-1.5.24.new/configure.in\tTue Jul 17 13:20:18 2001\n@@ -71,8 +71,14 @@\n \n AM_DISABLE_STATIC\n \n+AC_LIBLTDL_INSTALLABLE\n+AC_SUBST(INCLTDL)\n+AC_SUBST(LIBLTDL)\n+AC_LIBTOOL_DLOPEN\n+\n CMU_PROG_LIBTOOL\n \n+\n if test \"$ac_cv_prog_gcc\" = yes; then\n   CFLAGS=\"-Wall -W ${CFLAGS}\"\n fi\n@@ -374,11 +380,11 @@\n   fi\n fi\n \n-\n-\n if test \"$with_des\" != no; then\n   AC_DEFINE(WITH_DES)\n-  LIB_DES=\"-ldes\"\n+  if test \"x$LIB_DES\" = x; then\n+    LIB_DES=\"-ldes\"\n+  fi\n fi\n \n AC_SUBST(LIB_DES)\n@@ -716,5 +722,7 @@\n fi\n \n AC_SUBST(DIRS)\n+\n+AC_CONFIG_SUBDIRS(libltdl)\n \n AC_OUTPUT(Makefile include/Makefile lib/Makefile plugins/Makefile utils/Makefile doc/Makefile sample/Makefile java/Makefile java/CyrusSasl/Makefile pwcheck/Makefile man/Makefile)\ndiff -x ltcf-c.sh -x ltconfig -x ltmain.sh -x libltdl -x config.guess -x config.sub -x configure -x aclocal.m4 -x Makefile.in -uNr cyrus-sasl-1.5.24.orig/lib/Makefile.am cyrus-sasl-1.5.24.new/lib/Makefile.am\n--- cyrus-sasl-1.5.24.orig/lib/Makefile.am\tFri Jul 21 04:35:02 2000\n+++ cyrus-sasl-1.5.24.new/lib/Makefile.am\tTue Jul 17 12:41:08 2001\n@@ -43,7 +43,10 @@\n # Library version info - here at the top, for sanity\n sasl_version = 8:8:1\n \n-INCLUDES=-I$(top_srcdir)/include\n+INCLTDL= @INCLTDL@\n+LIBLTDL= @LIBLTDL@\n+\n+INCLUDES=-I$(top_srcdir)/include $(INCLTDL)\n \n EXTRA_DIST = saslint.h windlopen.c\n \n@@ -53,5 +56,5 @@\n EXTRA_libsasl_la_SOURCES = db_none.c db_ndbm.c db_gdbm.c db_berkeley.c db_testw32.c\n libsasl_la_LDFLAGS = -version-info $(sasl_version)\n libsasl_la_DEPENDENCIES = $(SASL_DB_BACKEND) @LTLIBOBJS@\n-libsasl_la_LIBADD = @LTLIBOBJS@ $(SASL_DB_BACKEND) $(SASL_DB_LIB) $(SASL_DL_LIB) $(PLAIN_LIBS)\n+libsasl_la_LIBADD = @LTLIBOBJS@ $(LIBLTDL) $(SASL_DB_BACKEND) $(SASL_DB_LIB) $(SASL_DL_LIB) $(PLAIN_LIBS)\n # PLAIN_LIBS are linked in for sasl_checkpass\ndiff -x ltcf-c.sh -x ltconfig -x ltmain.sh -x libltdl -x config.guess -x config.sub -x configure -x aclocal.m4 -x Makefile.in -uNr cyrus-sasl-1.5.24.orig/lib/client.c cyrus-sasl-1.5.24.new/lib/client.c\n--- cyrus-sasl-1.5.24.orig/lib/client.c\tThu Apr  6 16:50:22 2000\n+++ cyrus-sasl-1.5.24.new/lib/client.c\tTue Jul 17 12:41:08 2001\n@@ -49,6 +49,7 @@\n #include <string.h>\n #include <sasl.h>\n #include <saslutil.h>\n+#include <ltdl.h>\n #include \"saslint.h\"\n \n static int\n@@ -218,7 +219,7 @@\n {\n   int version;\n   const sasl_client_plug_t *plug;\n-  void *library;\n+  lt_dlhandle library;\n \n   struct cmechanism *next;  \n } cmechanism_t;\n@@ -370,6 +371,10 @@\n \n   cmechlist->mech_list=NULL;\n   cmechlist->mech_length=0;\n+\n+  /* init libltdl */\n+  if (lt_dlinit() != 0)\n+    return SASL_FAIL;\n \n   add_plugin((void *) &external_client_init, NULL);\n \ndiff -x ltcf-c.sh -x ltconfig -x ltmain.sh -x libltdl -x config.guess -x config.sub -x configure -x aclocal.m4 -x Makefile.in -uNr cyrus-sasl-1.5.24.orig/lib/common.c cyrus-sasl-1.5.24.new/lib/common.c\n--- cyrus-sasl-1.5.24.orig/lib/common.c\tMon Jul 17 19:21:02 2000\n+++ cyrus-sasl-1.5.24.new/lib/common.c\tTue Jul 17 16:26:01 2001\n@@ -117,6 +117,11 @@\n   _sasl_mutex_utils.lock=l;\n   _sasl_mutex_utils.unlock=u;\n   _sasl_mutex_utils.dispose=d;\n+  /* XXX seb FIXME: add a call to lt_dlmutex_register() for libltdl.\n+     sasl_set_mutex args must surely be modified to add func ptr\n+     for libtool's callbacks SETERROR and GETERROR; n/l/u can \n+     certainly be reused for libtool's callbacks LOCK and UNLOCK.\n+     see (libtool.info) Thread Saftey in libltdl */\n }\n \n \ndiff -x ltcf-c.sh -x ltconfig -x ltmain.sh -x libltdl -x config.guess -x config.sub -x configure -x aclocal.m4 -x Makefile.in -uNr cyrus-sasl-1.5.24.orig/lib/dlopen.c cyrus-sasl-1.5.24.new/lib/dlopen.c\n--- cyrus-sasl-1.5.24.orig/lib/dlopen.c\tThu Mar  9 21:53:47 2000\n+++ cyrus-sasl-1.5.24.new/lib/dlopen.c\tTue Jul 17 12:45:35 2001\n@@ -50,6 +50,7 @@\n #include <limits.h>\n #include <sys/param.h>\n #include <sasl.h>\n+#include <ltdl.h>\n #include \"saslint.h\"\n \n #if HAVE_DIRENT_H\n@@ -91,61 +92,7 @@\n #  define NAME_MAX 8\n #endif\n \n-#ifdef __hpux\n-#include <dl.h>\n-\n-typedef shl_t dll_handle;\n-typedef void * dll_func;\n-\n-dll_handle\n-dlopen(char *fname, int mode)\n-{\n-    shl_t h = shl_load(fname, BIND_DEFERRED, 0L);\n-    shl_t *hp = NULL;\n-    \n-    if (h) {\n-\thp = (shl_t *)malloc(sizeof (shl_t));\n-\tif (!hp) {\n-\t    shl_unload(h);\n-\t} else {\n-\t    *hp = h;\n-\t}\n-    }\n-\n-    return (dll_handle)hp;\n-}\n-\n-int\n-dlclose(dll_handle h)\n-{\n-    shl_t hp = *((shl_t *)h);\n-    if (hp != NULL) free(hp);\n-    return shl_unload(h);\n-}\n-\n-dll_func\n-dlsym(dll_handle h, char *n)\n-{\n-    dll_func handle;\n-    \n-    if (shl_findsym ((shl_t *)h, n, TYPE_PROCEDURE, &handle))\n-\treturn NULL;\n-    \n-    return (dll_func)handle;\n-}\n-\n-char *dlerror()\n-{\n-    if (errno != 0) {\n-\treturn strerror(errno);\n-    }\n-    return \"Generic shared library error\";\n-}\n-\n-#define SO_SUFFIX\t\".sl\"\n-#else /* __hpux */\n-#define SO_SUFFIX\t\".so\"\n-#endif /* __hpux */\n+#define LA_SUFFIX\t\".la\"\n \n \n /* gets the list of mechanisms */\n@@ -159,11 +106,6 @@\n    * checks appropriately. */\n   int result;\n   char str[PATH_MAX], tmp[PATH_MAX+2], c, prefix[PATH_MAX+2]; /* 1 for '/' 1 for trailing '\\0' */\n-#if __OpenBSD__\n-  char adj_entryname[1024];\n-#else\n-#define adj_entryname entryname\n-#endif\n   int pos;\n   char *path=NULL;\n   int position;\n@@ -180,10 +122,6 @@\n       || ! add_plugin)\n     return SASL_BADPARAM;\n \n-#if __OpenBSD__\n-  snprintf(adj_entryname, sizeof adj_entryname, \"_%s\", entryname);\n-#endif\n-\n   /* get the path to the plugins */\n   result = ((sasl_getpath_t *)(getpath_cb->proc))(getpath_cb->context,\n \t\t\t\t\t\t  &path);\n@@ -214,10 +152,9 @@\n       while ((dir=readdir(dp)) != NULL)\n       {\n \tsize_t length;\n-\tvoid *library;\n-\tvoid *entry_point;\n+\tlt_dlhandle library;\n+\tlt_ptr entry_point;\n \tchar name[PATH_MAX];\n-\tint flag;\n \n \n \tlength = NAMLEN(dir);\n@@ -225,7 +162,7 @@\n \n \tif (length + pos>=PATH_MAX) continue; /* too big */\n \n-\tif (strcmp(dir->d_name + (length - 3), SO_SUFFIX)) continue;\n+\tif (strcmp(dir->d_name + (length - 3), LA_SUFFIX)) continue;\n \n \tmemcpy(name,dir->d_name,length);\n \tname[length]='\\0';\n@@ -243,28 +180,23 @@\n \t\n \tif (result != SASL_OK) return result;\n \t\n-#ifdef RTLD_NOW\n-\tflag = RTLD_NOW;\n-#else\n-\tflag = 0;\n-#endif\n-\tif (!(library = dlopen(tmp, flag))) {\n+\tif (!(library = lt_dlopen(tmp))) {\n \t    _sasl_log(NULL, SASL_LOG_ERR, NULL, 0, 0,\n-\t\t      \"unable to dlopen %s: %s\", tmp, dlerror());\n+\t\t      \"unable to lt_dlopen %s: %s\", tmp, lt_dlerror());\n \t    continue;\n \t}\n \tentry_point = NULL;\n-\tentry_point = dlsym(library, adj_entryname);\n+\tentry_point = lt_dlsym(library, entryname);\n \n \tif (entry_point == NULL) {\n \t  VL((\"can't get an entry point\\n\"));\n-\t  dlclose(library);\n+\t  lt_dlclose(library);\n \t  continue;\n \t}\n \n \tif ((*add_plugin)(entry_point, library) != SASL_OK) {\n \t  VL((\"add_plugin to list failed\\n\"));\n-\t  dlclose(library);\n+\t  lt_dlclose(library);\n \t  continue;\n \t}\n \tVL((\"added [%s] successfully\\n\",dir->d_name));\n@@ -281,12 +213,12 @@\n }\n \n int\n-_sasl_done_with_plugin(void *plugin)\n+_sasl_done_with_plugin(lt_dlhandle plugin)\n {\n   if (! plugin)\n     return SASL_BADPARAM;\n \n-  dlclose(plugin);\n+  lt_dlclose(plugin);\n \n   return SASL_OK;\n }\ndiff -x ltcf-c.sh -x ltconfig -x ltmain.sh -x libltdl -x config.guess -x config.sub -x configure -x aclocal.m4 -x Makefile.in -uNr cyrus-sasl-1.5.24.orig/lib/saslint.h cyrus-sasl-1.5.24.new/lib/saslint.h\n--- cyrus-sasl-1.5.24.orig/lib/saslint.h\tThu Apr  6 16:50:22 2000\n+++ cyrus-sasl-1.5.24.new/lib/saslint.h\tTue Jul 17 12:43:27 2001\n@@ -45,6 +45,7 @@\n #define SASLINT_H\n \n #include <config.h>\n+#include <ltdl.h>\n #include \"sasl.h\"\n #include \"saslplug.h\"\n \n@@ -61,7 +62,7 @@\n extern const sasl_callback_t *\n _sasl_find_verifyfile_callback(const sasl_callback_t *callbacks);\n \n-extern int _sasl_done_with_plugin(void *plugin);\n+extern int _sasl_done_with_plugin(lt_dlhandle plugin);\n \n extern void (*_sasl_client_cleanup_hook)(void);\n extern void (*_sasl_server_cleanup_hook)(void);\ndiff -x ltcf-c.sh -x ltconfig -x ltmain.sh -x libltdl -x config.guess -x config.sub -x configure -x aclocal.m4 -x Makefile.in -uNr cyrus-sasl-1.5.24.orig/lib/server.c cyrus-sasl-1.5.24.new/lib/server.c\n--- cyrus-sasl-1.5.24.orig/lib/server.c\tMon Aug 14 04:04:42 2000\n+++ cyrus-sasl-1.5.24.new/lib/server.c\tTue Jul 17 12:56:40 2001\n@@ -54,6 +54,7 @@\n #include <sys/stat.h>\n #include <fcntl.h>\n #include <string.h>\n+#include <ltdl.h>\n \n #define DEFAULT_PLAIN_MECHANISM \"sasldb\"\n \n@@ -238,7 +239,7 @@\n   int condition; /* set to SASL_NOUSER if no available users */\n   const sasl_server_plug_t *plug;\n   struct mechanism *next;\n-  void *library; /* this a pointer to shared library returned by dlopen \n+  lt_dlhandle library; /* this a pointer to shared library returned by dlopen \n \t\t    or some similar function on other platforms */\n } mechanism_t;\n \n@@ -668,6 +669,10 @@\n \n   /* check db */\n   ret = _sasl_server_check_db(vf);\n+\n+  /* init libltdl */\n+  if (lt_dlinit() != 0)\n+    return SASL_FAIL;\n \n   /* load plugins */\n   add_plugin((void *)&external_server_init, NULL);\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/include/makemd5.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/sphinx_rtd_theme/static/fonts/RobotoSlab-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/sphinx_rtd_theme/static/fonts/Inconsolata.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/sphinx_rtd_theme/static/fonts/Inconsolata-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/sphinx_rtd_theme/static/fonts/Lato-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/sphinx_rtd_theme/static/fonts/Lato-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/sphinx_rtd_theme/static/fonts/RobotoSlab-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/sphinx_rtd_theme/static/fonts/fontawesome-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/cyrus/static/fonts/RobotoSlab-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/cyrus/static/fonts/Inconsolata.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/cyrus/static/fonts/Inconsolata-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/cyrus/static/fonts/Lato-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/cyrus/static/fonts/Lato-Regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/cyrus/static/fonts/RobotoSlab-Bold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/cyrus/static/fonts/fontawesome-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/cyrus/static/fonts/fontawesome-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/exts/themes/cyrus/static/fonts/fontawesome-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/_static/headimg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/_static/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/docsrc/_static/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/krb4_sources/mk_priv.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/krb4_sources/lsb_addr_comp.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/krb4_sources/mk_auth.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/krb4_sources/rd_safe.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/krb4_sources/krb-protos.h",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/krb4_sources/mk_req.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/krb4_sources/rd_priv.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/krb4_sources/mk_safe.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/krb4_sources/rw.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/build_plugins/build_plugins.Carbon",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/kerberos_includes/krb-protos.h",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/sc_shlb/sc_shlb.Carbon",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/sc_shlb/sc_shlb.mono",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/CommonKClient/mac_kclient3/Headers/KerberosPreferences/KerberosPreferences.h",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/CommonKClient/mac_kclient3/Headers/KerberosSupport/ShlibDriver.h",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/CommonKClient/mac_kclient/KClient.h",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/CommonKClient/mac_kclient/KClient.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/CommonKClient/mac_kclient/KrbDriver.h",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/md4.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/sha.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/mdtest.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/passwd_dlg.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/md5.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/key_par.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/dllmain.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/passwd_dlg.h",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/passwd_dialog.res",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/md5.h",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/passwd_dialog.rc",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/sha.h",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/rnd_keys.c",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/passwd_dialog.aps",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/src/md4.h",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libdes/libdes_ppc/libdes_ppc.Carbon",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/libsasl/libsasl.Carbon",
        "/tmp/vanessa/spack-stage/spack-stage-cyrus-sasl-2.1.27-hnal7aquex6gy2ydqk4wp52b2upmktrt/spack-src/mac/osx_cfm_glue/cfmglue.proj"
    ],
    "total_files": 730
}