{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-scr-1.2.1-vmhj2kgarsq5fkkryvy6ekr7yneyzsm6/spack-src/src/scr_interpose.c": "/*\n * Copyright (c) 2009, Lawrence Livermore National Security, LLC.\n * Produced at the Lawrence Livermore National Laboratory.\n * Written by Adam Moody <moody20@llnl.gov>.\n * LLNL-CODE-411039.\n * All rights reserved.\n * This file is part of The Scalable Checkpoint / Restart (SCR) library.\n * For details, see https://sourceforge.net/projects/scalablecr/\n * Please also read this file: LICENSE.TXT.\n*/\n\n/* This code builds a library which can be interpositioned into an existing binary\n * such that it may utilize SCR without requiring any changes to the application\n * or even a rebuild.  This library intercepts the following calls made by the\n * application:\n *   1) MPI_Init() to call SCR_Init() after returning from MPI_Init()\n *   2) MPI_Finalize() to call SCR_Finalize() before calling MPI_Finalize()\n *   3) open()/fopen() to call SCR_Start_checkpoint() and/or SCR_Route_file()\n *      before opening the file\n *   4) close()/fclose() to call SCR_Complete_checkpoint() after closing file\n *\n * This library determines which files are checkpoint files by comparing them\n * to a regular expression provided by the user via an environment variable.\n *\n * Here are some articles and examples on interposing libraries:\n *   http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15213-s03/src/interposition/mymalloc.c\n *   http://nixforums.org/about36762.html\n *   http://unix.derkeiler.com/Newsgroups/comp.unix.programmer/2004-05/0178.html\n*/\n\n/* need this to pick up correct definitions for strndup and RTLD_NEXT */\n#define  _GNU_SOURCE\n\n#include <dlfcn.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdarg.h>\n\n#include <string.h>\n#include <regex.h>\n\n#include <unistd.h>\n#include <libgen.h>\n\n#include <errno.h>\n\n#include \"mpi.h\"\n#include \"scr.h\"\n\nstatic int scri_initialized       = 0;\nstatic int scri_interpose_enabled = 0;\nstatic int scri_in_checkpoint     = 0;\nstatic int scri_ranks             = 0;\nstatic int scri_rank              = -1;\n\nstatic int scri_re_low_high_compiled = 0;\nstatic int scri_re_low_N_compiled    = 0;\nstatic int scri_re_scr_file_compiled = 0;\nstatic regex_t scri_re_low_high;\nstatic regex_t scri_re_low_N;\nstatic regex_t scri_re_scr_file;\n\n/* interpose MPI functions */\nint (* scri_real_mpi_init)  (int *, char ***) = NULL;\nint (* scri_real_mpi_fini)  ()                = NULL;\n\n/* interpose open/close functions */\n/*\nint (* scri_real_open)      (const char *, int, mode_t);\n*/\nint (* scri_real_open)      (const char *, int, ...) = NULL;\nint (* scri_real_close)     (int)                    = NULL;\n\n/* interpose fopen/fclose functions */\nFILE* (* scri_real_fopen)   (const char *, const char *) = NULL;\nint   (* scri_real_fclose)  (FILE*)                      = NULL;\n\n/* interpose mkdir function */\nint (* scri_real_mkdir)     (const char *, mode_t) = NULL;\n\n/* TODO: also intercept\n *   creat() -- form of open()\n *   mkdir() -- for checkpoint directories -- turn into a NOP\n */\n\n/* interpose read/write functions */\n/*\nssize_t (* real_read)  (int fd, void *buf, size_t count);\nssize_t (* real_write) (int fd, const void *buf, size_t count);\n*/\n\n/*\n==============================================================================\nCheckpoint tracking functions and data structures\n==============================================================================\n*/\n\n#ifndef MAX_CHECKPOINT_FILES\n#define MAX_CHECKPOINT_FILES (8)\n#endif\n\n#define SCRI_FNULL   (0)\n#define SCRI_FD      (1)\n#define SCRI_FSTREAM (2)\n\nstruct scri_checkpointfile\n{\n  int   valid;   /* whether checkpoint file entry is valid */\n  int   enabled; /* whether open/close interposing is currently enabled */\n  int   need_closed; /* whether checkpoint file is open and needs to be closed to complete a checkpoint */\n  char* filename;\n  char* tempname;\n  regex_t re;\n  int   ftype;\n  int   fd;\n  int   flags;\n  FILE* fstream;\n  char* mode;\n};\n\n/* TODO: change this fixed array to a linked list */\n/* keeps track of checkpoint files */\nstatic int    scri_checkpoint_files_valid = 0;\nstatic struct scri_checkpointfile scri_checkpoint_files[MAX_CHECKPOINT_FILES];\n\n/* TODO: support a list of directories like we do for files */\n/* keeps track of checkpoint directory */\nstatic int     scri_checkpoint_dir_valid = 0;\nstatic regex_t scri_re_checkpoint_dir;\n\n/* given a filename and regular expression, return whether there is a match */\nstatic int scri_file_matches(const char* filename, regex_t* re)\n{\n  size_t nmatch = 0;\n  regmatch_t pmatch[5];\n\n  /* check for a match on the filename, and check that it's *not* an .scr file */\n  memset(pmatch, 0, sizeof(regmatch_t) * nmatch);\n  if (regexec(re, filename, nmatch, pmatch, 0) == 0 &&\n      regexec(&scri_re_scr_file, filename, nmatch, pmatch, 0) == REG_NOMATCH)\n  {\n    return 1;\n  }\n  return 0;\n}\n\n/* start a new checkpoint if not already in one, mark each file as need_closed */\nstatic int scri_start_checkpoint()\n{\n  if (!scri_in_checkpoint) {\n    /* mark all files as needing to be completed */\n    int i;\n    for(i=0; i<MAX_CHECKPOINT_FILES; i++) {\n      if (scri_checkpoint_files[i].valid) {\n        scri_checkpoint_files[i].need_closed = 1;\n      }\n    }\n\n    /* start the checkpoint */\n    scri_interpose_enabled = 0;\n    SCR_Start_checkpoint();\n    scri_interpose_enabled = 1;\n\n    /* mark us inside a checkpoint */\n    scri_in_checkpoint = 1;\n  }\n\n  return SCR_SUCCESS;\n}\n\n/* given an index into the checkpoint file array, mark the file as closed\n * if all files are now closed, complete the checkpoint */\nstatic int scri_complete_checkpoint(int index)\n{\n  if (scri_in_checkpoint) {\n    /* mark this checkpoint file as complete */\n    if (index < MAX_CHECKPOINT_FILES) {\n      scri_checkpoint_files[index].need_closed = 0;\n    }\n\n    /* scan through to see if we have any files not yet complete */\n    int still_open = 0;\n    int i;\n    for(i=0; i<MAX_CHECKPOINT_FILES; i++) {\n      if (scri_checkpoint_files[i].valid && scri_checkpoint_files[i].need_closed) {\n        still_open = 1;\n      }\n    }\n\n    /* if there are no files yet to be completed, complete the checkpoint */\n    if (!still_open) {\n      /* disable the interposer since SCR_Complete_checkpoint calls open/close */\n      scri_interpose_enabled = 0;\n      SCR_Complete_checkpoint(1);\n      scri_interpose_enabled = 1;\n\n      /* mark us out of the checkpoint */\n      scri_in_checkpoint = 0;\n    }\n  }\n\n  return SCR_SUCCESS;\n}\n\n/* lookup a checkpoint file index given a filename */\nstatic int scri_index_by_filename(const char* filename)\n{\n  int i;\n  for(i=0; i<MAX_CHECKPOINT_FILES; i++) {\n    if (scri_checkpoint_files[i].valid &&\n        scri_file_matches(filename, &scri_checkpoint_files[i].re))\n    {\n      return i;\n    }\n  }\n  return MAX_CHECKPOINT_FILES;\n}\n\n/* lookup a checkpoint file index given an open file descriptor */\nstatic int scri_index_by_fd(const int fd)\n{\n  int i;\n  for(i=0; i<MAX_CHECKPOINT_FILES; i++) {\n    if (scri_checkpoint_files[i].valid &&\n        scri_checkpoint_files[i].ftype == SCRI_FD &&\n        fd == scri_checkpoint_files[i].fd)\n    {\n      return i;\n    }\n  }\n  return MAX_CHECKPOINT_FILES;\n}\n\n/* lookup a checkpoint file index given an open file stream */\nstatic int scri_index_by_fstream(const FILE* fstream)\n{\n  int i;\n  for(i=0; i<MAX_CHECKPOINT_FILES; i++) {\n    if (scri_checkpoint_files[i].valid &&\n        scri_checkpoint_files[i].ftype == SCRI_FSTREAM &&\n        fstream == scri_checkpoint_files[i].fstream)\n    {\n      return i;\n    }\n  }\n  return MAX_CHECKPOINT_FILES;\n}\n\n/* returns 1 if the given filename is a checkpoint file, and 0 otherwise */\nstatic int scri_is_checkpoint_dirname(const char* name)\n{\n  if (scri_interpose_enabled &&\n      scri_checkpoint_dir_valid &&\n      scri_file_matches(name, &scri_re_checkpoint_dir))\n  {\n    return 1;\n  }\n  return 0;\n}\n\n/* returns 1 if the given filename is a checkpoint file, and 0 otherwise */\nstatic int scri_is_checkpoint_filename(const char* file)\n{\n  int i = scri_index_by_filename(file);\n  if (scri_interpose_enabled &&\n      i < MAX_CHECKPOINT_FILES &&\n      scri_checkpoint_files[i].enabled)\n  {\n    return 1;\n  }\n  return 0;\n}\n\n/* returns 1 if the given file descriptor is a checkpoint file, and 0 otherwise */\nstatic int scri_is_checkpoint_fd(const int fd)\n{\n  int i = scri_index_by_fd(fd);\n  if (scri_interpose_enabled &&\n      i < MAX_CHECKPOINT_FILES &&\n      scri_checkpoint_files[i].enabled)\n  {\n    return 1;\n  }\n  return 0;\n}\n\n/* returns 1 if the given file stream is a checkpoint file, and 0 otherwise */\nstatic int scri_is_checkpoint_fstream(const FILE* fstream)\n{\n  int i = scri_index_by_fstream(fstream);\n  if (scri_interpose_enabled &&\n      i < MAX_CHECKPOINT_FILES &&\n      scri_checkpoint_files[i].enabled)\n  {\n    return 1;\n  }\n  return 0;\n}\n\n/* record file descriptor and flags used in open call for this filename */\nstatic int scri_add_checkpoint_fd(const char* file, const char* temp, const int fd, const int flags)\n{\n  int i = scri_index_by_filename(file);\n  if (i < MAX_CHECKPOINT_FILES) {\n    scri_checkpoint_files[i].tempname = strdup(temp);\n    scri_checkpoint_files[i].ftype    = SCRI_FD;\n    scri_checkpoint_files[i].fd       = fd;\n    scri_checkpoint_files[i].flags    = flags;\n    return 0;\n  }\n\n  /* couldn't find an empty slot for this file */\n  fprintf(stderr,\"SCRI: ERROR: Too many checkpoint files open when registering %s, maximum supported is %d @ %s:%d\\n\",\n          file, MAX_CHECKPOINT_FILES, __FILE__, __LINE__\n  );\n  exit(1);\n\n  return 1;\n}\n\n/* drop the file descriptor for this filename (file has been closed) */\nstatic int scri_drop_checkpoint_fd(const int fd)\n{\n  int i = scri_index_by_fd(fd);\n  if (i < MAX_CHECKPOINT_FILES) {\n    if (scri_checkpoint_files[i].tempname != NULL) {\n      free(scri_checkpoint_files[i].tempname);\n      scri_checkpoint_files[i].tempname = NULL;\n    }\n    scri_checkpoint_files[i].ftype = SCRI_FNULL;\n    scri_checkpoint_files[i].fd    = -1;\n    scri_checkpoint_files[i].flags = 0;\n    return 0;\n  }\n  /* TODO: an error to get here */\n  return 1;\n}\n\n/* record the fstream value and the mode used in the fopen call for this filename */\nstatic int scri_add_checkpoint_fstream(const char* file, const char* temp, const FILE* fstream, const char* mode)\n{\n  int i = scri_index_by_filename(file);\n  if (i < MAX_CHECKPOINT_FILES) {\n    scri_checkpoint_files[i].tempname = strdup(temp);\n    scri_checkpoint_files[i].ftype    = SCRI_FSTREAM;\n    scri_checkpoint_files[i].fstream  = (FILE*) fstream;\n    scri_checkpoint_files[i].mode     = strdup(mode);\n    return 0;\n  }\n\n  /* couldn't find an empty slot for this file */\n  fprintf(stderr,\"SCRI: ERROR: Too many checkpoint files open when registering %s, maximum supported is %d @ %s:%d\\n\",\n          file, MAX_CHECKPOINT_FILES, __FILE__, __LINE__\n  );\n  exit(1);\n\n  return 1;\n}\n\n/* drop the fstream for this filename (file has been closed) */\nstatic int scri_drop_checkpoint_fstream(const FILE* fstream)\n{\n  int i = scri_index_by_fstream(fstream);\n  if (i < MAX_CHECKPOINT_FILES) {\n    if (scri_checkpoint_files[i].tempname != NULL) {\n      free(scri_checkpoint_files[i].tempname);\n      scri_checkpoint_files[i].tempname = NULL;\n    }\n    scri_checkpoint_files[i].ftype   = SCRI_FNULL;\n    scri_checkpoint_files[i].fstream = NULL;\n    if (scri_checkpoint_files[i].mode != NULL) {\n      free(scri_checkpoint_files[i].mode);\n      scri_checkpoint_files[i].mode = NULL;\n    }\n    return 0;\n  }\n  /* TODO: an error to get here */\n  return 1;\n}\n\n/* given a regular expression for a checkpoint directory, prepare it for testing */\nstatic int scri_define_checkpoint_dirname_regex(const char* dirname)\n{\n  /* compile the filename regex pattern */\n  int rc = regcomp(&scri_re_checkpoint_dir, dirname, REG_EXTENDED);\n  if (rc != 0) {\n    fprintf(stderr,\"SCRI: ERROR: Checkpoint directory name regex compilation for %s failed (rc=%d) @ %s:%d\\n\",\n            dirname, rc, __FILE__, __LINE__\n    );\n    exit(1);\n  }\n\n  /* note that the checkpoint directory regular expression is valid */\n  scri_checkpoint_dir_valid = 1;\n\n  return 0;\n}\n\n/* given a regular expression for a checkpoint file, add it to our list and prepare it for testing */\nstatic int scri_define_checkpoint_filename_regex(const char* filename)\n{\n  int i;\n  for(i=0; i<MAX_CHECKPOINT_FILES; i++) {\n    if (! scri_checkpoint_files[i].valid) {\n      /* mark this entry as valid and copy in the filename */\n      scri_checkpoint_files[i].valid = 1;\n      scri_checkpoint_files[i].filename = strdup(filename);\n      if (scri_checkpoint_files[i].filename == NULL) {\n        fprintf(stderr,\"SCRI: ERROR: Failed to allocate space to record filename regex for %s @ %s:%d\\n\",\n                filename, __FILE__, __LINE__\n        );\n        exit(1);\n      }\n\n      /* compile the filename regex pattern */\n      int rc = regcomp(&scri_checkpoint_files[i].re, filename, REG_EXTENDED);\n      if (rc != 0) {\n        fprintf(stderr,\"SCRI: ERROR: Failed to compile filename regex %s (rc=%d) @ %s:%d\\n\",\n                filename, rc, __FILE__, __LINE__\n        );\n        exit(1);\n      }\n\n      return 0;\n    }\n  }\n\n  /* couldn't find an empty slot for this file */\n  fprintf(stderr,\"SCRI: ERROR: Too many filename regex specified, maximum is %d @ %s:%d\\n\",\n          MAX_CHECKPOINT_FILES, __FILE__, __LINE__\n  );\n  exit(1);\n\n  return 1;\n}\n\n/* given a filename and regular expression, return whether there is a match */\nstatic int scri_define_checkpoint_filename_regex_by_rank(const char* filename)\n{\n  size_t nmatch = 3;\n  regmatch_t pmatch[nmatch];\n\n  /* check for a match */\n  int low  = -1;\n  int high = -1;\n  const char* file = NULL;\n  char* value = NULL;\n  memset(pmatch, 0, sizeof(regmatch_t) * nmatch);\n  if (regexec(&scri_re_low_N, filename, nmatch, pmatch, 0) == 0) {\n    /* handles 0-N:regex */\n\n    /* pull out the low */\n    value = strndup(filename + pmatch[1].rm_so,\n           (size_t)(pmatch[1].rm_eo - pmatch[1].rm_so));\n    low = atoi(value);\n    free(value); value = NULL;\n\n    /* set high to total number of ranks minus one */\n    high = scri_ranks - 1;\n\n    /* pull out the file regex */\n    file = filename + pmatch[2].rm_eo + 1;\n  } else if (regexec(&scri_re_low_high, filename, nmatch, pmatch, 0) == 0) {\n    /* e.g., handles 0-3:regex */\n\n    /* pull out the low */\n    value = strndup(filename + pmatch[1].rm_so,\n           (size_t)(pmatch[1].rm_eo - pmatch[1].rm_so));\n    low = atoi(value);\n    free(value); value = NULL;\n\n    /* pull out the high */\n    value = strndup(filename + pmatch[2].rm_so,\n           (size_t)(pmatch[2].rm_eo - pmatch[2].rm_so));\n    high = atoi(value);\n    free(value); value = NULL;\n\n    /* pull out the file regex */\n    file = filename + pmatch[2].rm_eo + 1;\n  } else {\n    fprintf(stderr,\"SCRI: ERROR: Unknown MPI rank range for file: %s, perhaps specify '0-N:%s' @ %s:%d\\n\",\n            filename, filename, __FILE__, __LINE__\n    );\n    exit(1);\n  }\n\n  /* add the file if our rank is in the low-high range */\n  if (low <= scri_rank && scri_rank <= high) {\n    scri_define_checkpoint_filename_regex(file);\n    return 1;\n  }\n\n  return 0;\n}\n\n/* parse SCR environment variables and add checkpoint file regular expressions */\nstatic int scri_define_checkpoint_files()\n{\n  /* read in environment variables */\n  char* value   = NULL;\n  char* pattern = NULL;\n  char  token   = ',';\n  char* dir_pattern = NULL;\n\n  /* read in the list of checkpoint file regular expressions separated by token */\n  if ((value = getenv(\"SCR_CHECKPOINT_PATTERN\")) != NULL) {\n    if (strcmp(value, \"\") != 0) {\n      pattern = strdup(value);\n    }\n  }\n\n  /* override default token of ':' for separating checkpoint file regex in pattern */\n  if ((value = getenv(\"SCR_CHECKPOINT_PATTERN_TOKEN\")) != NULL) {\n    if (strcmp(value, \"\") != 0) {\n      token = value[0];\n    }\n  }\n\n  /* read in the pattern for the checkpoint directory names */\n  if ((value = getenv(\"SCR_CHECKPOINT_DIR_PATTERN\")) != NULL) {\n    if (strcmp(value, \"\") != 0) {\n      dir_pattern = strdup(value);\n    }\n  }\n\n  /* add the regex patterns to our list */\n  if (pattern != NULL) {\n    int i = 0;\n    char* file = pattern;\n\n    /* loop through breaking string into pieces using token */\n    char* stop = strchr(file, (int) token);\n    while (stop != NULL) {\n      if (i >= MAX_CHECKPOINT_FILES) {\n        fprintf(stderr,\"SCRI: ERROR: Rank %d: Too many files in SCR_CHECKPOINT_PATTERN '%s' maximum allowed is %d @ %s:%d\\n\",\n                scri_rank, pattern, MAX_CHECKPOINT_FILES, __FILE__, __LINE__\n        );\n        exit(1);\n      }\n      *stop = '\\0';\n      i += scri_define_checkpoint_filename_regex_by_rank(file);\n      file = stop + 1;\n      stop = strchr(file, (int) token);\n    }\n\n    /* now add the last file if we have one */\n    if (strcmp(file, \"\") != 0 && i < MAX_CHECKPOINT_FILES) {\n      if (i >= MAX_CHECKPOINT_FILES) {\n        fprintf(stderr,\"SCRI: ERROR: Rank %d: Too many files in SCR_CHECKPOINT_PATTERN '%s' maximum allowed is %d @ %s:%d\\n\",\n                scri_rank, pattern, MAX_CHECKPOINT_FILES, __FILE__, __LINE__\n        );\n        exit(1);\n      }\n      i += scri_define_checkpoint_filename_regex_by_rank(file);\n    }\n\n    free(pattern); pattern = NULL;\n  }\n\n  /* add the checkpoint directory pattern if specified */\n  if (dir_pattern != NULL) {\n    scri_define_checkpoint_dirname_regex(dir_pattern);\n    free(dir_pattern); dir_pattern = NULL;\n  }\n\n  /* check that every rank has at least one file (so we know when to complete each checkpoint) */\n  int i;\n  int found_one = 0;\n  for (i=0; i < MAX_CHECKPOINT_FILES; i++) {\n    if (scri_checkpoint_files[i].valid) { found_one = 1; }\n  }\n  if (!found_one) {\n    fprintf(stderr,\"SCRI: ERROR: Rank %d: No checkpoint file specified @ %s:%d\\n\",\n            scri_rank, __FILE__, __LINE__\n    );\n    exit(1);\n  }\n\n  return 0;\n}\n\n/*\n==============================================================================\nInterpose functions\n==============================================================================\n*/\n\nstatic void* mydlsym(const char *name)\n{\n  void *p = dlsym(RTLD_NEXT, name);\n  if (!p) {\n    fprintf(stderr,\"dlsym(RTLD_NEXT, %s) failed: %s\\n\", name, dlerror());\n    exit(1);\n  }\n  return p;\n}\n\n/* call dlsym to interpose a set of functions */\nstatic void scr_interpose_init()\n{\n  if (scri_initialized) { return; }\n\n  /* interpose MPI functions */\n  if (scri_real_mpi_init == NULL) {\n    scri_real_mpi_init = (int (*)(int *, char ***)) mydlsym(\"MPI_Init\");\n  }\n  if (scri_real_mpi_fini == NULL) {\n    scri_real_mpi_fini = (int (*)()) mydlsym(\"MPI_Finalize\");\n  }\n\n  /* interpose open/close functions */\n  if (scri_real_open == NULL) {\n    scri_real_open  = (int (*)(const char *, int, ...)) mydlsym(\"open\");\n  }\n  /*\n  scri_real_open  = (int (*)(const char *, int, mode_t)) mydlsym(\"open\");\n  */\n  if (scri_real_close == NULL) {\n    scri_real_close = (int (*)(int fd)) mydlsym(\"close\");\n  }\n\n  /* interpose fopen/fclose functions */\n  if (scri_real_fopen == NULL) {\n    scri_real_fopen  = (FILE* (*)(const char *, const char *)) mydlsym(\"fopen\");\n  }\n  if (scri_real_fclose == NULL) {\n    scri_real_fclose = (int (*)(FILE*)) mydlsym(\"fclose\");\n  }\n\n  /* interpose mkdir */\n  if (scri_real_mkdir == NULL) {\n    scri_real_mkdir = (int (*)(const char*, mode_t)) mydlsym(\"mkdir\");\n  }\n\n  /* interpose read/write functions */\n/*\n  real_read  = (ssize_t (*)(int fd, void *buf, size_t count))       mydlsym(\"read\");\n  real_write = (ssize_t (*)(int fd, const void *buf, size_t count)) mydlsym(\"write\");\n*/\n\n  /* initialize the data structures */\n  if (!scri_checkpoint_files_valid) {\n    scri_checkpoint_files_valid = 1;\n    int i;\n    for(i=0; i<MAX_CHECKPOINT_FILES; i++) {\n      scri_checkpoint_files[i].valid    = 0;\n      scri_checkpoint_files[i].enabled  = 1;\n      scri_checkpoint_files[i].filename = NULL;\n      scri_checkpoint_files[i].tempname = NULL;\n      scri_checkpoint_files[i].ftype    = SCRI_FNULL;\n      scri_checkpoint_files[i].fd       = -1;\n      scri_checkpoint_files[i].flags    = 0;\n      scri_checkpoint_files[i].fstream  = NULL;\n      scri_checkpoint_files[i].mode     = NULL;\n    }\n  }\n\n  /* compile the low-high range regex pattern */\n  /* we surround each regcomp with a compiled flag in case the call to regex,\n   * leads to a call to open, which in turns calls scri_init() again\n   * (e.g., when debugging with TV's memory debugger) */\n  int rc;\n  char low_high_range[] = \"^([0-9]+)-([0-9]+):\";\n  char low_N_range[]    = \"^([0-9]+)-(N):\";\n  char scr_file_ext[]   = \".scr$\";\n  if (!scri_re_low_high_compiled) {\n    scri_re_low_high_compiled = 1;\n    rc = regcomp(&scri_re_low_high, low_high_range, REG_EXTENDED);\n    if (rc != 0) {\n      fprintf(stderr,\"SCRI: ERROR: Failed to compile low-to-high range regex: %s (rc=%d) @ %s:%d\\n\",\n             low_high_range, rc, __FILE__, __LINE__\n      );\n      exit(1);\n    }\n  }\n  if (!scri_re_low_N_compiled) {\n    scri_re_low_N_compiled = 1;\n    rc = regcomp(&scri_re_low_N, low_N_range, REG_EXTENDED);\n    if (rc != 0) {\n      fprintf(stderr,\"SCRI: ERROR: Failed to compile low-to-N range regex: %s (rc=%d) @ %s:%d\\n\",\n             low_N_range, rc, __FILE__, __LINE__\n      );\n      exit(1);\n    }\n  }\n  if (!scri_re_scr_file_compiled) {\n    scri_re_scr_file_compiled = 1;\n    rc = regcomp(&scri_re_scr_file, scr_file_ext, REG_EXTENDED);\n    if (rc != 0) {\n      fprintf(stderr,\"SCRI: ERROR: Failed to compile scr file extension regex: %s (rc=%d) @ %s:%d\\n\",\n             scr_file_ext, rc, __FILE__, __LINE__\n      );\n      exit(1);\n    }\n  }\n\n  scri_interpose_enabled = 1;\n  scri_initialized = 1;\n}\n\n/*\n==============================================================================\nInterpose MPI functions\n==============================================================================\n*/\n\n/* see wrappers_special.c from mpiP */\n/* this function has the logic, the C and Fortran versions of MPI_Init route here */\nstatic int _MPI_Init (int *argc, char ***argv)\n{\n  int rc = 0;\n\n  /* initialize the interposer */\n  if (!scri_initialized) { scr_interpose_init(); }\n  \n  /* call the real MPI_Init */\n  rc = (*scri_real_mpi_init)(argc, argv);\n\n  /* initialize the SCR library */\n  scri_interpose_enabled = 0;\n  SCR_Init();\n  scri_interpose_enabled = 1;\n\n  /* get our MPI rank */\n  MPI_Comm_rank(MPI_COMM_WORLD, &scri_rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &scri_ranks);\n\n  /* parse our checkpoint files (we do this after MPI_Init so we know which rank we are) */\n  scri_define_checkpoint_files();\n\n  return rc;\n}\n\n#ifdef MPI_Init\n#undef MPI_Init\n#endif\nint MPI_Init (int *argc, char ***argv)\n{\n  int rc = 0;\n  rc = _MPI_Init (argc, argv);\n  return rc;\n}\n\n#ifdef MPI_Finalize\n#undef MPI_Finalize\n#endif\nint MPI_Finalize ()\n{\n  int rc = 0;\n\n  /* initialize the interposer */\n  if (!scri_initialized) { scr_interpose_init(); }\n  \n  /* finalize the SCR library */\n  scri_interpose_enabled = 0;\n  SCR_Finalize();\n\n  /* we called finalize, so we can just leave the interposer disabled */\n\n  /* free off the regular expression structures */\n  regfree(&scri_re_low_high);\n  regfree(&scri_re_low_N);\n  regfree(&scri_re_scr_file);\n  if (scri_checkpoint_dir_valid) {\n    regfree(&scri_re_checkpoint_dir);\n  }\n  if (scri_checkpoint_files_valid) {\n    int i;\n    for(i=0; i<MAX_CHECKPOINT_FILES; i++) {\n      if (scri_checkpoint_files[i].valid) {\n        scri_checkpoint_files[i].valid   = 0;\n        scri_checkpoint_files[i].enabled = 0;\n        if (scri_checkpoint_files[i].filename != NULL) {\n          free(scri_checkpoint_files[i].filename);\n          scri_checkpoint_files[i].filename = NULL;\n        }\n        if (scri_checkpoint_files[i].tempname != NULL) {\n          free(scri_checkpoint_files[i].tempname);\n          scri_checkpoint_files[i].tempname = NULL;\n        }\n        regfree(&scri_checkpoint_files[i].re);\n      }\n    }\n  }\n\n  /* call the real MPI_Finalize */\n  rc = (*scri_real_mpi_fini)();\n\n  return rc;\n}\n\n/*\n==============================================================================\nInterpose open/close functions\n==============================================================================\n*/\n\n#ifdef open \n#undef open\n#endif\n/*\nint open(const char *pathname, int flags, mode_t mode)\n*/\nint open(const char *pathname, int flags, ...)\n{\n  const char* name = pathname;\n\n  if (!scri_initialized) { scr_interpose_init(); }\n\n  /* check whether pathname matches pattern for a checkpoint file */\n  char temp[SCR_MAX_FILENAME];\n  int checkpoint = scri_is_checkpoint_filename(pathname);\n  if (checkpoint) {\n    /* don't start a new checkpoint if the file is being opened as read-only */\n    /* O_RDONLY == 0 so we can't do a straight bit test, instead check whether either RDWR or WRONLY is set */\n    /* TODO: must be a better way to do this */\n    if ((flags & O_RDWR) || (flags & O_WRONLY)) {\n      scri_start_checkpoint();\n    }\n\n    /* reroute file to cache */\n    scri_interpose_enabled = 0;\n    if (SCR_Route_file((char*) pathname, temp) == SCR_SUCCESS) {\n      name = temp;\n    }\n    scri_interpose_enabled = 1;\n  }\n\n  /* extract the mode (see man 2 open) */\n  mode_t mode = 0;\n  if (flags & O_CREAT) {\n    va_list ap;\n    va_start(ap, flags);\n    mode = va_arg(ap, mode_t);\n    va_end(ap);\n  }\n\n  /* open the file */\n  int rc = (*scri_real_open)(name, flags, mode);\n\n  /* mark file descriptor as checkpoint file */\n  if (checkpoint) {\n    if (rc < 0) {\n      /* Don't want to kick out here because user may have expected this open to fail, e.g., read-only */\n      fprintf(stderr,\"SCRI: ERROR: Failed to open %s for rerouting %s (errno=%d %s) @ %s:%d\\n\",\n              name, pathname, errno, strerror(errno), __FILE__, __LINE__\n      );\n    } else {\n      scri_add_checkpoint_fd(pathname, name, rc, flags);\n    }\n  }\n\n  /* return what ever the real open call returned */\n  return rc;\n}\n\n#ifdef close \n#undef close\n#endif\nint close(int fd)\n{\n  if (!scri_initialized) { scr_interpose_init(); }\n\n  /* TODO: need to fsync here as well? */\n\n  /* close the file */\n  int rc = (*scri_real_close)(fd);\n\n  /* if fd matches a checkpoint file, call SCR_COMPLETE and then remove fd from list */\n  if (scri_is_checkpoint_fd(fd)) {\n    /* complete the checkpoint */\n    int i = scri_index_by_fd(fd);\n    scri_complete_checkpoint(i);\n\n    /* drop the file descriptor from our active set */\n    scri_drop_checkpoint_fd(fd);\n  }\n\n  /* return what ever the real close call gave us */\n  return rc;\n} \n\n#ifdef fopen \n#undef fopen\n#endif\nFILE* fopen(const char * pathname, const char * mode)\n{\n  const char* name = pathname;\n\n  if (!scri_initialized) { scr_interpose_init(); }\n\n  /* check whether pathname matches pattern for a checkpoint file */\n  char temp[SCR_MAX_FILENAME];\n  int checkpoint = scri_is_checkpoint_filename(pathname);\n  if (checkpoint) {\n    /* don't start a new checkpoint if the file is being opened as read-only */\n    if (strcmp(mode, \"r\") != 0 && strcmp(mode, \"rb\") != 0) {\n      scri_start_checkpoint();\n    }\n\n    /* reroute file to cache */\n    scri_interpose_enabled = 0;\n    if (SCR_Route_file((char*) pathname, temp) == SCR_SUCCESS) {\n      name = temp;\n    }\n    scri_interpose_enabled = 1;\n  }\n\n  /* open the file */\n  FILE* rc = (*scri_real_fopen)(name, mode);\n\n  /* mark file descriptor as checkpoint file */\n  if (checkpoint) {\n    if (rc == NULL) {\n      /* Don't want to kick out here because user may have expected this open to fail, e.g., read-only */\n      fprintf(stderr,\"SCRI: ERROR: Failed to fopen %s for rerouting %s with mode %s (errno=%d %s) @ %s:%d\\n\",\n             name, pathname, mode, errno, strerror(errno), __FILE__, __LINE__\n      );\n    } else {\n      scri_add_checkpoint_fstream(pathname, name, rc, mode);\n    }\n  }\n\n  /* return what ever the real open call returned */\n  return rc;\n}\n\n#ifdef fclose \n#undef fclose\n#endif\nint fclose(FILE* fstream)\n{\n  if (!scri_initialized) { scr_interpose_init(); }\n\n  /* TODO: need to fsync here as well? */\n\n  /* close the file */\n  int rc = (*scri_real_fclose)(fstream);\n\n  /* if fd matches a checkpoint file, call SCR_COMPLETE and then remove fd from list */\n  if (scri_is_checkpoint_fstream(fstream)) {\n    /* complete the checkpoint */\n    int i = scri_index_by_fstream(fstream);\n    scri_complete_checkpoint(i);\n\n    /* drop the file descriptor from our active set */\n    scri_drop_checkpoint_fstream(fstream);\n  }\n\n  /* return what ever the real close call gave us */\n  return rc;\n} \n\n/*\n==============================================================================\nInterpose mkdir functions\n==============================================================================\n*/\n\n#ifdef mkdir \n#undef mkdir\n#endif\nint mkdir(const char *pathname, mode_t mode)\n{\n  int rc = 0;\n\n  if (!scri_initialized) { scr_interpose_init(); }\n\n  /* if the user is trying to create a checkpoint directory,\n   * do nothing and return success, otherwise, just call mkdir */\n  int checkpoint = scri_is_checkpoint_dirname(pathname);\n  if (!checkpoint) {\n    rc = (*scri_real_mkdir)(pathname, mode);\n  }\n\n  /* return what ever the real open call returned */\n  return rc;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-scr-1.2.1-vmhj2kgarsq5fkkryvy6ekr7yneyzsm6/spack-src/doc/scr_users_manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-scr-1.2.1-vmhj2kgarsq5fkkryvy6ekr7yneyzsm6/spack-src/doc/rst/users/fig/aggr_bw.png",
        "/tmp/vanessa/spack-stage/spack-stage-scr-1.2.1-vmhj2kgarsq5fkkryvy6ekr7yneyzsm6/spack-src/doc/rst/users/fig/restart.png",
        "/tmp/vanessa/spack-stage/spack-stage-scr-1.2.1-vmhj2kgarsq5fkkryvy6ekr7yneyzsm6/spack-src/doc/rst/users/fig/scr-states3.png",
        "/tmp/vanessa/spack-stage/spack-stage-scr-1.2.1-vmhj2kgarsq5fkkryvy6ekr7yneyzsm6/spack-src/doc/rst/users/fig/directories_wide2.png"
    ],
    "total_files": 217
}