{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-lvm2-2.03.01-boqkhxcjv5mjui6v7ajkw3ttrkzbv2yi/spack-src/lib/commands/toolcontext.c": "/*\n * Copyright (C) 2001-2004 Sistina Software, Inc. All rights reserved.\n * Copyright (C) 2004-2014 Red Hat, Inc. All rights reserved.\n *\n * This file is part of LVM2.\n *\n * This copyrighted material is made available to anyone wishing to use,\n * modify, copy, or redistribute it subject to the terms and conditions\n * of the GNU Lesser General Public License v.2.1.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"base/memory/zalloc.h\"\n#include \"lib/misc/lib.h\"\n#include \"lib/commands/toolcontext.h\"\n#include \"lib/metadata/metadata.h\"\n#include \"lib/config/defaults.h\"\n#include \"lib/misc/lvm-string.h\"\n#include \"lib/activate/activate.h\"\n#include \"lib/filters/filter.h\"\n#include \"lib/label/label.h\"\n#include \"lib/misc/lvm-file.h\"\n#include \"lib/format_text/format-text.h\"\n#include \"lib/display/display.h\"\n#include \"lib/mm/memlock.h\"\n#include \"lib/datastruct/str_list.h\"\n#include \"lib/metadata/segtype.h\"\n#include \"lib/cache/lvmcache.h\"\n#include \"lib/format_text/archiver.h\"\n#include \"lib/lvmpolld/lvmpolld-client.h\"\n\n#ifdef HAVE_LIBDL\n#include \"lib/misc/sharedlib.h\"\n#endif\n\n#include <locale.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/utsname.h>\n#include <syslog.h>\n#include <time.h>\n\n#ifdef __linux__\n#  include <malloc.h>\n#endif\n\nstatic const size_t _linebuffer_size = 4096;\n\n/*\n * Copy the input string, removing invalid characters.\n */\nconst char *system_id_from_string(struct cmd_context *cmd, const char *str)\n{\n\tchar *system_id;\n\n\tif (!str || !*str) {\n\t\tlog_warn(\"WARNING: Empty system ID supplied.\");\n\t\treturn \"\";\n\t}\n\n\tif (!(system_id = dm_pool_zalloc(cmd->libmem, strlen(str) + 1))) {\n\t\tlog_warn(\"WARNING: Failed to allocate system ID.\");\n\t\treturn NULL;\n\t}\n\n\tcopy_systemid_chars(str, system_id);\n\n\tif (!*system_id) {\n\t\tlog_warn(\"WARNING: Invalid system ID format: %s\", str);\n\t\treturn NULL;\n\t}\n\n\tif (!strncmp(system_id, \"localhost\", 9)) {\n\t\tlog_warn(\"WARNING: system ID may not begin with the string \\\"localhost\\\".\");\n\t\treturn NULL;\n\t}\n\n\treturn system_id;\n}\n\nstatic const char *_read_system_id_from_file(struct cmd_context *cmd, const char *file)\n{\n\tchar *line = NULL;\n\tsize_t line_size;\n\tchar *start, *end;\n\tconst char *system_id = NULL;\n\tFILE *fp;\n\n\tif (!file || !strlen(file) || !file[0])\n\t\treturn_NULL;\n\n\tif (!(fp = fopen(file, \"r\"))) {\n\t\tlog_warn(\"WARNING: %s: fopen failed: %s\", file, strerror(errno));\n\t\treturn NULL;\n\t}\n\n\twhile (getline(&line, &line_size, fp) > 0) {\n\t\tstart = line;\n\n\t\t/* Ignore leading whitespace */\n\t\twhile (*start && isspace(*start))\n\t\t\tstart++;\n\n\t\t/* Ignore rest of line after # */\n\t\tif (!*start || *start == '#')\n\t\t\tcontinue;\n\n\t\tif (system_id && *system_id) {\n\t\t\tlog_warn(\"WARNING: Ignoring extra line(s) in system ID file %s.\", file);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Remove any comments from end of line */\n\t\tfor (end = start; *end; end++)\n\t\t\tif (*end == '#') {\n\t\t\t\t*end = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tsystem_id = system_id_from_string(cmd, start);\n\t}\n\n\tfree(line);\n\n\tif (fclose(fp))\n\t\tstack;\n\n\treturn system_id;\n}\n\nstatic const char *_system_id_from_source(struct cmd_context *cmd, const char *source)\n{\n\tchar filebuf[PATH_MAX];\n\tconst char *file;\n\tconst char *etc_str;\n\tconst char *str;\n\tconst char *system_id = NULL;\n\n\tif (!strcasecmp(source, \"uname\")) {\n\t\tif (cmd->hostname)\n\t\t\tsystem_id = system_id_from_string(cmd, cmd->hostname);\n\t\tgoto out;\n\t}\n\n\t/* lvm.conf and lvmlocal.conf are merged into one config tree */\n\tif (!strcasecmp(source, \"lvmlocal\")) {\n\t\tif ((str = find_config_tree_str(cmd, local_system_id_CFG, NULL)))\n\t\t\tsystem_id = system_id_from_string(cmd, str);\n\t\tgoto out;\n\t}\n\n\tif (!strcasecmp(source, \"machineid\") || !strcasecmp(source, \"machine-id\")) {\n\t\tetc_str = find_config_tree_str(cmd, global_etc_CFG, NULL);\n\t\tif (dm_snprintf(filebuf, sizeof(filebuf), \"%s/machine-id\", etc_str) != -1)\n\t\t\tsystem_id = _read_system_id_from_file(cmd, filebuf);\n\t\tgoto out;\n\t}\n\n\tif (!strcasecmp(source, \"file\")) {\n\t\tfile = find_config_tree_str(cmd, global_system_id_file_CFG, NULL);\n\t\tsystem_id = _read_system_id_from_file(cmd, file);\n\t\tgoto out;\n\t}\n\n\tlog_warn(\"WARNING: Unrecognised system_id_source \\\"%s\\\".\", source);\n\nout:\n\treturn system_id;\n}\n\nstatic int _get_env_vars(struct cmd_context *cmd)\n{\n\tconst char *e;\n\n\t/* Set to \"\" to avoid using any system directory */\n\tif ((e = getenv(\"LVM_SYSTEM_DIR\"))) {\n\t\tif (dm_snprintf(cmd->system_dir, sizeof(cmd->system_dir),\n\t\t\t\t \"%s\", e) < 0) {\n\t\t\tlog_error(\"LVM_SYSTEM_DIR environment variable \"\n\t\t\t\t  \"is too long.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (strcmp((getenv(\"LVM_RUN_BY_DMEVENTD\") ? : \"0\"), \"1\") == 0)\n\t\tinit_run_by_dmeventd(cmd);\n\n\treturn 1;\n}\n\nstatic void _get_sysfs_dir(struct cmd_context *cmd, char *buf, size_t buf_size)\n{\n\tstatic char proc_mounts[PATH_MAX];\n\tstatic char *split[4], buffer[PATH_MAX + 16];\n\tFILE *fp;\n\tchar *sys_mnt = NULL;\n\n\t*buf = '\\0';\n\n\tif (!*cmd->proc_dir) {\n\t\tlog_debug(\"No proc filesystem found: skipping sysfs detection\");\n\t\treturn;\n\t}\n\n\tif (dm_snprintf(proc_mounts, sizeof(proc_mounts),\n\t\t\t \"%s/mounts\", cmd->proc_dir) < 0) {\n\t\tlog_error(\"Failed to create /proc/mounts string for sysfs detection\");\n\t\treturn;\n\t}\n\n\tif (!(fp = fopen(proc_mounts, \"r\"))) {\n\t\tlog_sys_error(\"_get_sysfs_dir fopen\", proc_mounts);\n\t\treturn;\n\t}\n\n\twhile (fgets(buffer, sizeof(buffer), fp)) {\n\t\tif (dm_split_words(buffer, 4, 0, split) == 4 &&\n\t\t    !strcmp(split[2], \"sysfs\")) {\n\t\t\tsys_mnt = split[1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fclose(fp))\n\t\tlog_sys_error(\"fclose\", proc_mounts);\n\n\tif (!sys_mnt) {\n\t\tlog_error(\"Failed to find sysfs mount point\");\n\t\treturn;\n\t}\n\n\tstrncpy(buf, sys_mnt, buf_size);\n}\n\nstatic int _parse_debug_classes(struct cmd_context *cmd)\n{\n\tconst struct dm_config_node *cn;\n\tconst struct dm_config_value *cv;\n\tint debug_classes = 0;\n\n\tif (!(cn = find_config_tree_array(cmd, log_debug_classes_CFG, NULL))) {\n\t\tlog_error(INTERNAL_ERROR \"Unable to find configuration for log/debug_classes.\");\n\t\treturn -1;\n\t}\n\n\tfor (cv = cn->v; cv; cv = cv->next) {\n\t\tif (cv->type != DM_CFG_STRING) {\n\t\t\tlog_verbose(\"log/debug_classes contains a value \"\n\t\t\t\t    \"which is not a string.  Ignoring.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcasecmp(cv->v.str, \"all\"))\n\t\t\treturn -1;\n\n\t\tif (!strcasecmp(cv->v.str, \"memory\"))\n\t\t\tdebug_classes |= LOG_CLASS_MEM;\n\t\telse if (!strcasecmp(cv->v.str, \"devices\"))\n\t\t\tdebug_classes |= LOG_CLASS_DEVS;\n\t\telse if (!strcasecmp(cv->v.str, \"activation\"))\n\t\t\tdebug_classes |= LOG_CLASS_ACTIVATION;\n\t\telse if (!strcasecmp(cv->v.str, \"allocation\"))\n\t\t\tdebug_classes |= LOG_CLASS_ALLOC;\n\t\telse if (!strcasecmp(cv->v.str, \"metadata\"))\n\t\t\tdebug_classes |= LOG_CLASS_METADATA;\n\t\telse if (!strcasecmp(cv->v.str, \"cache\"))\n\t\t\tdebug_classes |= LOG_CLASS_CACHE;\n\t\telse if (!strcasecmp(cv->v.str, \"locking\"))\n\t\t\tdebug_classes |= LOG_CLASS_LOCKING;\n\t\telse if (!strcasecmp(cv->v.str, \"lvmpolld\"))\n\t\t\tdebug_classes |= LOG_CLASS_LVMPOLLD;\n\t\telse if (!strcasecmp(cv->v.str, \"dbus\"))\n\t\t\tdebug_classes |= LOG_CLASS_DBUS;\n\t\telse if (!strcasecmp(cv->v.str, \"io\"))\n\t\t\tdebug_classes |= LOG_CLASS_IO;\n\t\telse\n\t\t\tlog_verbose(\"Unrecognised value for log/debug_classes: %s\", cv->v.str);\n\t}\n\n\treturn debug_classes;\n}\n\nstatic void _init_logging(struct cmd_context *cmd)\n{\n\tint append = 1;\n\ttime_t t;\n\n\tconst char *log_file;\n\tchar timebuf[26];\n\n\t/* Syslog */\n\tcmd->default_settings.syslog = find_config_tree_bool(cmd, log_syslog_CFG, NULL);\n\tif (cmd->default_settings.syslog != 1)\n\t\tfin_syslog();\n\n\tif (cmd->default_settings.syslog > 1)\n\t\tinit_syslog(cmd->default_settings.syslog);\n\n\t/* Debug level for log file output */\n\tcmd->default_settings.debug = find_config_tree_int(cmd, log_level_CFG, NULL);\n\tinit_debug(cmd->default_settings.debug);\n\n\t/*\n\t * Suppress all non-essential stdout?\n\t * -qq can override the default of 0 to 1 later.\n\t * Once set to 1, there is no facility to change it back to 0.\n\t */\n\tcmd->default_settings.silent = silent_mode() ? :\n\t    find_config_tree_bool(cmd, log_silent_CFG, NULL);\n\tinit_silent(cmd->default_settings.silent);\n\n\t/* Verbose level for tty output */\n\tcmd->default_settings.verbose = find_config_tree_int(cmd, log_verbose_CFG, NULL);\n\tinit_verbose(cmd->default_settings.verbose + VERBOSE_BASE_LEVEL);\n\n\t/* Log message formatting */\n\tinit_indent(find_config_tree_bool(cmd, log_indent_CFG, NULL));\n\tinit_abort_on_internal_errors(find_config_tree_bool(cmd, global_abort_on_internal_errors_CFG, NULL));\n\n\tcmd->default_settings.msg_prefix = find_config_tree_str_allow_empty(cmd, log_prefix_CFG, NULL);\n\tinit_msg_prefix(cmd->default_settings.msg_prefix);\n\n\tcmd->default_settings.cmd_name = find_config_tree_bool(cmd, log_command_names_CFG, NULL);\n\tinit_cmd_name(cmd->default_settings.cmd_name);\n\n\t/* Test mode */\n\tcmd->default_settings.test =\n\t    find_config_tree_bool(cmd, global_test_CFG, NULL);\n\tinit_test(cmd->default_settings.test);\n\n\t/* Settings for logging to file */\n\tif (find_config_tree_bool(cmd, log_overwrite_CFG, NULL))\n\t\tappend = 0;\n\n\tlog_file = find_config_tree_str(cmd, log_file_CFG, NULL);\n\n\tif (log_file) {\n\t\trelease_log_memory();\n\t\tfin_log();\n\t\tinit_log_file(log_file, append);\n\t}\n\n\tlog_file = find_config_tree_str(cmd, log_activate_file_CFG, NULL);\n\tif (log_file)\n\t\tinit_log_direct(log_file, append);\n\n\tinit_log_while_suspended(find_config_tree_bool(cmd, log_activation_CFG, NULL));\n\n\tcmd->default_settings.debug_classes = _parse_debug_classes(cmd);\n\tlog_debug(\"Setting log debug classes to %d\", cmd->default_settings.debug_classes);\n\tinit_debug_classes_logged(cmd->default_settings.debug_classes);\n\n\tt = time(NULL);\n\tctime_r(&t, &timebuf[0]);\n\ttimebuf[24] = '\\0';\n\tlog_verbose(\"Logging initialised at %s\", timebuf);\n\n\t/* Tell device-mapper about our logging */\n#ifdef DEVMAPPER_SUPPORT\n\tif (!dm_log_is_non_default())\n\t\tdm_log_with_errno_init(print_log_libdm);\n#endif\n\treset_log_duplicated();\n\treset_lvm_errno(1);\n}\n\nstatic int _check_disable_udev(const char *msg) {\n\tif (getenv(\"DM_DISABLE_UDEV\")) {\n\t\tlog_very_verbose(\"DM_DISABLE_UDEV environment variable set. \"\n\t\t\t\t \"Overriding configuration to use \"\n\t\t\t\t \"udev_rules=0, udev_sync=0, verify_udev_operations=1.\");\n\t\tif (udev_is_running())\n\t\t\tlog_warn(\"Udev is running and DM_DISABLE_UDEV environment variable is set. \"\n\t\t\t\t \"Bypassing udev, LVM will %s.\", msg);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int _check_config_by_source(struct cmd_context *cmd, config_source_t source)\n{\n\tstruct dm_config_tree *cft;\n\tstruct cft_check_handle *handle;\n\n\tif (!(cft = get_config_tree_by_source(cmd, source)) ||\n\t    !(handle = get_config_tree_check_handle(cmd, cft)))\n\t\treturn 1;\n\n\treturn config_def_check(handle);\n}\n\nstatic int _check_config(struct cmd_context *cmd)\n{\n\tint abort_on_error;\n\n\tif (!find_config_tree_bool(cmd, config_checks_CFG, NULL))\n\t\treturn 1;\n\n\tabort_on_error = find_config_tree_bool(cmd, config_abort_on_errors_CFG, NULL);\n\n\tif ((!_check_config_by_source(cmd, CONFIG_STRING) ||\n\t    !_check_config_by_source(cmd, CONFIG_MERGED_FILES) ||\n\t    !_check_config_by_source(cmd, CONFIG_FILE)) &&\n\t    abort_on_error) {\n\t\tlog_error(\"LVM_ configuration invalid.\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic const char *_set_time_format(struct cmd_context *cmd)\n{\n\t/* Compared to strftime, we do not allow \"newline\" character - the %n in format. */\n\tstatic const char *allowed_format_chars = \"aAbBcCdDeFGghHIjklmMpPrRsStTuUVwWxXyYzZ%\";\n\tstatic const char *allowed_alternative_format_chars_e = \"cCxXyY\";\n\tstatic const char *allowed_alternative_format_chars_o = \"deHImMSuUVwWy\";\n\tstatic const char *chars_to_check;\n\tconst char *tf = find_config_tree_str(cmd, report_time_format_CFG, NULL);\n\tconst char *p_fmt;\n\tsize_t i;\n\tchar c;\n\n\tif (!*tf) {\n\t\tlog_error(\"Configured time format is empty string.\");\n\t\tgoto bad;\n\t} else {\n\t\tp_fmt = tf;\n\t\twhile ((c = *p_fmt)) {\n\t\t\tif (c == '%') {\n\t\t\t\tc = *++p_fmt;\n\t\t\t\tif (c == 'E') {\n\t\t\t\t\tc = *++p_fmt;\n\t\t\t\t\tchars_to_check = allowed_alternative_format_chars_e;\n\t\t\t\t} else if (c == 'O') {\n\t\t\t\t\tc = *++p_fmt;\n\t\t\t\t\tchars_to_check = allowed_alternative_format_chars_o;\n\t\t\t\t} else\n\t\t\t\t\tchars_to_check = allowed_format_chars;\n\n\t\t\t\tfor (i = 0; chars_to_check[i]; i++) {\n\t\t\t\t\tif (c == chars_to_check[i])\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!chars_to_check[i])\n\t\t\t\t\tgoto_bad;\n\t\t\t}\n\t\t\telse if (isprint(c))\n\t\t\t\tp_fmt++;\n\t\t\telse {\n\t\t\t\tlog_error(\"Configured time format contains non-printable characters.\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tf;\nbad:\n\tlog_error(\"Invalid time format \\\"%s\\\" supplied.\", tf);\n\treturn NULL;\n}\n\nint process_profilable_config(struct cmd_context *cmd)\n{\n\tconst char *units;\n\n\tif (!(cmd->default_settings.unit_factor =\n\t      dm_units_to_factor(units = find_config_tree_str(cmd, global_units_CFG, NULL),\n\t\t\t\t &cmd->default_settings.unit_type, 1, NULL))) {\n\t\tlog_error(\"Unrecognised configuration setting for global/units: %s\", units);\n\t\treturn 0;\n\t}\n\n\tcmd->si_unit_consistency = find_config_tree_bool(cmd, global_si_unit_consistency_CFG, NULL);\n\tcmd->report_binary_values_as_numeric = find_config_tree_bool(cmd, report_binary_values_as_numeric_CFG, NULL);\n\tcmd->report_mark_hidden_devices = find_config_tree_bool(cmd, report_mark_hidden_devices_CFG, NULL);\n\tcmd->default_settings.suffix = find_config_tree_bool(cmd, global_suffix_CFG, NULL);\n\tcmd->report_list_item_separator = find_config_tree_str(cmd, report_list_item_separator_CFG, NULL);\n\tif (!(cmd->time_format = _set_time_format(cmd)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int _init_system_id(struct cmd_context *cmd)\n{\n\tconst char *source, *system_id;\n\tint local_set = 0;\n\n\tcmd->system_id = NULL;\n\tcmd->unknown_system_id = 0;\n\n\tsystem_id = find_config_tree_str_allow_empty(cmd, local_system_id_CFG, NULL);\n\tif (system_id && *system_id)\n\t\tlocal_set = 1;\n\n\tsource = find_config_tree_str(cmd, global_system_id_source_CFG, NULL);\n\tif (!source)\n\t\tsource = \"none\";\n\n\t/* Defining local system_id but not using it is probably a config mistake. */\n\tif (local_set && strcmp(source, \"lvmlocal\"))\n\t\tlog_warn(\"WARNING: local/system_id is set, so should global/system_id_source be \\\"lvmlocal\\\" not \\\"%s\\\"?\", source);\n\n\tif (!strcmp(source, \"none\"))\n\t\treturn 1;\n\n\tif ((system_id = _system_id_from_source(cmd, source)) && *system_id) {\n\t\tcmd->system_id = system_id;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * The source failed to resolve a system_id.  In this case allow\n\t * VGs with no system_id to be accessed, but not VGs with a system_id.\n\t */\n\tlog_warn(\"WARNING: No system ID found from system_id_source %s.\", source);\n\tcmd->unknown_system_id = 1;\n\n\treturn 1;\n}\n\nstatic int _process_config(struct cmd_context *cmd)\n{\n\tmode_t old_umask;\n\tconst char *dev_ext_info_src;\n\tconst char *read_ahead;\n\tstruct stat st;\n\tconst struct dm_config_node *cn;\n\tconst struct dm_config_value *cv;\n\tint64_t pv_min_kb;\n\tint udev_disabled = 0;\n\tchar sysfs_dir[PATH_MAX];\n\n\tif (!_check_config(cmd))\n\t\treturn_0;\n\n\t/* umask */\n\tcmd->default_settings.umask = find_config_tree_int(cmd, global_umask_CFG, NULL);\n\n\tif ((old_umask = umask((mode_t) cmd->default_settings.umask)) !=\n\t    (mode_t) cmd->default_settings.umask)\n\t\tlog_verbose(\"Set umask from %04o to %04o\",\n                            old_umask, cmd->default_settings.umask);\n\n\t/* dev dir */\n\tif (dm_snprintf(cmd->dev_dir, sizeof(cmd->dev_dir), \"%s/\",\n\t\t\t find_config_tree_str(cmd, devices_dir_CFG, NULL)) < 0) {\n\t\tlog_error(\"Device directory given in config file too long\");\n\t\treturn 0;\n\t}\n#ifdef DEVMAPPER_SUPPORT\n\tdm_set_dev_dir(cmd->dev_dir);\n\n\tif (!dm_set_uuid_prefix(UUID_PREFIX))\n\t\treturn_0;\n#endif\n\n\tdev_ext_info_src = find_config_tree_str(cmd, devices_external_device_info_source_CFG, NULL);\n\tif (dev_ext_info_src && !strcmp(dev_ext_info_src, \"none\"))\n\t\tinit_external_device_info_source(DEV_EXT_NONE);\n\telse if (dev_ext_info_src && !strcmp(dev_ext_info_src, \"udev\"))\n\t\tinit_external_device_info_source(DEV_EXT_UDEV);\n\telse {\n\t\tlog_error(\"Invalid external device info source specification.\");\n\t\treturn 0;\n\t}\n\n\t/* proc dir */\n\tif (dm_snprintf(cmd->proc_dir, sizeof(cmd->proc_dir), \"%s\",\n\t\t\t find_config_tree_str(cmd, global_proc_CFG, NULL)) < 0) {\n\t\tlog_error(\"Device directory given in config file too long\");\n\t\treturn 0;\n\t}\n\n\tif (*cmd->proc_dir && !dir_exists(cmd->proc_dir)) {\n\t\tlog_warn(\"WARNING: proc dir %s not found - some checks will be bypassed\",\n\t\t\t cmd->proc_dir);\n\t\tcmd->proc_dir[0] = '\\0';\n\t}\n\n\t_get_sysfs_dir(cmd, sysfs_dir, sizeof(sysfs_dir));\n\tdm_set_sysfs_dir(sysfs_dir);\n\n\t/* activation? */\n\tcmd->default_settings.activation = find_config_tree_bool(cmd, global_activation_CFG, NULL);\n\tset_activation(cmd->default_settings.activation, 0);\n\n\tcmd->auto_set_activation_skip = find_config_tree_bool(cmd, activation_auto_set_activation_skip_CFG, NULL);\n\n\tread_ahead = find_config_tree_str(cmd, activation_readahead_CFG, NULL);\n\tif (!strcasecmp(read_ahead, \"auto\"))\n\t\tcmd->default_settings.read_ahead = DM_READ_AHEAD_AUTO;\n\telse if (!strcasecmp(read_ahead, \"none\"))\n\t\tcmd->default_settings.read_ahead = DM_READ_AHEAD_NONE;\n\telse {\n\t\tlog_error(\"Invalid readahead specification\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If udev is disabled using DM_DISABLE_UDEV environment\n\t * variable, override existing config and hardcode these:\n\t *   - udev_rules = 0\n\t *   - udev_sync = 0\n\t *   - udev_fallback = 1\n\t */\n\tudev_disabled = _check_disable_udev(\"manage logical volume symlinks in device directory\");\n\n\tcmd->default_settings.udev_rules = udev_disabled ? 0 :\n\t\tfind_config_tree_bool(cmd, activation_udev_rules_CFG, NULL);\n\n\tcmd->default_settings.udev_sync = udev_disabled ? 0 :\n\t\tfind_config_tree_bool(cmd, activation_udev_sync_CFG, NULL);\n\n\t/*\n\t * Set udev_fallback lazily on first use since it requires\n\t * checking DM driver version which is an extra ioctl!\n\t * This also prevents unnecessary use of mapper/control.\n\t * If udev is disabled globally, set fallback mode immediately.\n\t */\n\tcmd->default_settings.udev_fallback = udev_disabled ? 1 : -1;\n\n\tinit_retry_deactivation(find_config_tree_bool(cmd, activation_retry_deactivation_CFG, NULL));\n\n\tinit_activation_checks(find_config_tree_bool(cmd, activation_checks_CFG, NULL));\n\n\tcmd->use_linear_target = find_config_tree_bool(cmd, activation_use_linear_target_CFG, NULL);\n\n\tcmd->stripe_filler = find_config_tree_str(cmd, activation_missing_stripe_filler_CFG, NULL);\n\n\t/* FIXME Missing error code checks from the stats, not log_warn?, notify if setting overridden, delay message/check till it is actually used (eg consider if lvm shell - file could appear later after this check)? */\n\tif (!strcmp(cmd->stripe_filler, \"/dev/ioerror\") &&\n\t    stat(cmd->stripe_filler, &st))\n\t\tcmd->stripe_filler = \"error\";\n\telse if (strcmp(cmd->stripe_filler, \"error\") &&\n\t\t strcmp(cmd->stripe_filler, \"zero\")) {\n\t\tif (stat(cmd->stripe_filler, &st)) {\n\t\t\tlog_warn(\"WARNING: activation/missing_stripe_filler = \\\"%s\\\" \"\n\t\t\t\t \"is invalid,\", cmd->stripe_filler);\n\t\t\tlog_warn(\"         stat failed: %s\", strerror(errno));\n\t\t\tlog_warn(\"Falling back to \\\"error\\\" missing_stripe_filler.\");\n\t\t\tcmd->stripe_filler = \"error\";\n\t\t} else if (!S_ISBLK(st.st_mode)) {\n\t\t\tlog_warn(\"WARNING: activation/missing_stripe_filler = \\\"%s\\\" \"\n\t\t\t\t \"is not a block device.\", cmd->stripe_filler);\n\t\t\tlog_warn(\"Falling back to \\\"error\\\" missing_stripe_filler.\");\n\t\t\tcmd->stripe_filler = \"error\";\n\t\t}\n\t}\n\n\tif ((cn = find_config_tree_array(cmd, activation_mlock_filter_CFG, NULL)))\n\t\tfor (cv = cn->v; cv; cv = cv->next) \n\t\t\tif ((cv->type != DM_CFG_STRING) || !cv->v.str[0]) \n\t\t\t\tlog_error(\"Ignoring invalid activation/mlock_filter entry in config file\");\n\n\tcmd->metadata_read_only = find_config_tree_bool(cmd, global_metadata_read_only_CFG, NULL);\n\n\tpv_min_kb = find_config_tree_int64(cmd, devices_pv_min_size_CFG, NULL);\n\tif (pv_min_kb < PV_MIN_SIZE_KB) {\n\t\tlog_warn(\"Ignoring too small pv_min_size %\" PRId64 \"KB, using default %dKB.\",\n\t\t\t pv_min_kb, PV_MIN_SIZE_KB);\n\t\tpv_min_kb = PV_MIN_SIZE_KB;\n\t}\n\t/* LVM stores sizes internally in units of 512-byte sectors. */\n\tinit_pv_min_size((uint64_t)pv_min_kb * (1024 >> SECTOR_SHIFT));\n\n\tcmd->check_pv_dev_sizes = find_config_tree_bool(cmd, metadata_check_pv_device_sizes_CFG, NULL);\n\n\tif (!process_profilable_config(cmd))\n\t\treturn_0;\n\n\tif (find_config_tree_bool(cmd, report_two_word_unknown_device_CFG, NULL))\n\t\tinit_unknown_device_name(\"unknown device\");\n\n\tif (!_init_system_id(cmd))\n\t\treturn_0;\n\n\treturn 1;\n}\n\nstatic int _set_tag(struct cmd_context *cmd, const char *tag)\n{\n\tlog_very_verbose(\"Setting host tag: %s\", dm_pool_strdup(cmd->libmem, tag));\n\n\tif (!str_list_add(cmd->libmem, &cmd->tags, tag)) {\n\t\tlog_error(\"_set_tag: str_list_add %s failed\", tag);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int _check_host_filters(struct cmd_context *cmd, const struct dm_config_node *hn,\n\t\t\t       int *passes)\n{\n\tconst struct dm_config_node *cn;\n\tconst struct dm_config_value *cv;\n\n\t*passes = 1;\n\n\tfor (cn = hn; cn; cn = cn->sib) {\n\t\tif (!cn->v)\n\t\t\tcontinue;\n\t\tif (!strcmp(cn->key, \"host_list\")) {\n\t\t\t*passes = 0;\n\t\t\tif (cn->v->type == DM_CFG_EMPTY_ARRAY)\n\t\t\t\tcontinue;\n\t\t\tfor (cv = cn->v; cv; cv = cv->next) {\n\t\t\t\tif (cv->type != DM_CFG_STRING) {\n\t\t\t\t\tlog_error(\"Invalid hostname string \"\n\t\t\t\t\t\t  \"for tag %s\", cn->key);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(cv->v.str, cmd->hostname)) {\n\t\t\t\t\t*passes = 1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(cn->key, \"host_filter\")) {\n\t\t\tlog_error(\"host_filter not supported yet\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int _init_tags(struct cmd_context *cmd, struct dm_config_tree *cft)\n{\n\tconst struct dm_config_node *tn, *cn;\n\tconst char *tag;\n\tint passes;\n\n\t/* Access tags section directly */\n\tif (!(tn = find_config_node(cmd, cft, tags_CFG_SECTION)) || !tn->child)\n\t\treturn 1;\n\n\t/* NB hosttags 0 when already 1 intentionally does not delete the tag */\n\tif (!cmd->hosttags && find_config_bool(cmd, cft, tags_hosttags_CFG)) {\n\t\t/* FIXME Strip out invalid chars: only A-Za-z0-9_+.- */\n\t\tif (!_set_tag(cmd, cmd->hostname))\n\t\t\treturn_0;\n\t\tcmd->hosttags = 1;\n\t}\n\n\tfor (cn = tn->child; cn; cn = cn->sib) {\n\t\tif (cn->v)\n\t\t\tcontinue;\n\t\ttag = cn->key;\n\t\tif (*tag == '@')\n\t\t\ttag++;\n\t\tif (!validate_name(tag)) {\n\t\t\tlog_error(\"Invalid tag in config file: %s\", cn->key);\n\t\t\treturn 0;\n\t\t}\n\t\tif (cn->child) {\n\t\t\tpasses = 0;\n\t\t\tif (!_check_host_filters(cmd, cn->child, &passes))\n\t\t\t\treturn_0;\n\t\t\tif (!passes)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (!_set_tag(cmd, tag))\n\t\t\treturn_0;\n\t}\n\n\treturn 1;\n}\n\nstatic int _load_config_file(struct cmd_context *cmd, const char *tag, int local)\n{\n\tstatic char config_file[PATH_MAX] = \"\";\n\tconst char *filler = \"\";\n\tstruct config_tree_list *cfl;\n\n\tif (*tag)\n\t\tfiller = \"_\";\n\telse if (local) {\n\t\tfiller = \"\";\n\t\ttag = \"local\";\n\t}\n\n\tif (dm_snprintf(config_file, sizeof(config_file), \"%s/lvm%s%s.conf\",\n\t\t\t cmd->system_dir, filler, tag) < 0) {\n\t\tlog_error(\"LVM_SYSTEM_DIR or tag was too long\");\n\t\treturn 0;\n\t}\n\n\tif (!(cfl = dm_pool_alloc(cmd->libmem, sizeof(*cfl)))) {\n\t\tlog_error(\"config_tree_list allocation failed\");\n\t\treturn 0;\n\t}\n\n\tif (!(cfl->cft = config_file_open_and_read(config_file, CONFIG_FILE, cmd)))\n\t\treturn_0;\n\n\tdm_list_add(&cmd->config_files, &cfl->list);\n\n\tif (*tag) {\n\t\tif (!_init_tags(cmd, cfl->cft))\n\t\t\treturn_0;\n\t} else\n\t\t/* Use temporary copy of lvm.conf while loading other files */\n\t\tcmd->cft = cfl->cft;\n\n\treturn 1;\n}\n\n/*\n * Find and read lvm.conf.\n */\nstatic int _init_lvm_conf(struct cmd_context *cmd)\n{\n\t/* No config file if LVM_SYSTEM_DIR is empty */\n\tif (!*cmd->system_dir) {\n\t\tif (!(cmd->cft = config_open(CONFIG_FILE, NULL, 0))) {\n\t\t\tlog_error(\"Failed to create config tree\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (!_load_config_file(cmd, \"\", 0))\n\t\treturn_0;\n\n\treturn 1;\n}\n\n/* Read any additional config files */\nstatic int _init_tag_configs(struct cmd_context *cmd)\n{\n\tstruct dm_str_list *sl;\n\n\t/* Tag list may grow while inside this loop */\n\tdm_list_iterate_items(sl, &cmd->tags) {\n\t\tif (!_load_config_file(cmd, sl->str, 0))\n\t\t\treturn_0;\n\t}\n\n\treturn 1;\n}\n\nstatic int _init_profiles(struct cmd_context *cmd)\n{\n\tconst char *dir;\n\n\tif (!(dir = find_config_tree_str(cmd, config_profile_dir_CFG, NULL)))\n\t\treturn_0;\n\n\tif (!cmd->profile_params) {\n\t\tif (!(cmd->profile_params = dm_pool_zalloc(cmd->libmem, sizeof(*cmd->profile_params)))) {\n\t\t\tlog_error(\"profile_params alloc failed\");\n\t\t\treturn 0;\n\t\t}\n\t\tdm_list_init(&cmd->profile_params->profiles_to_load);\n\t\tdm_list_init(&cmd->profile_params->profiles);\n\t}\n\n\tif (!(dm_strncpy(cmd->profile_params->dir, dir, sizeof(cmd->profile_params->dir)))) {\n\t\tlog_error(\"_init_profiles: dm_strncpy failed\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic struct dm_config_tree *_merge_config_files(struct cmd_context *cmd, struct dm_config_tree *cft)\n{\n\tstruct config_tree_list *cfl;\n\n\t/* Replace temporary duplicate copy of lvm.conf */\n\tif (cft->root) {\n\t\tif (!(cft = config_open(CONFIG_MERGED_FILES, NULL, 0))) {\n\t\t\tlog_error(\"Failed to create config tree\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdm_list_iterate_items(cfl, &cmd->config_files) {\n\t\t/* Merge all config trees into cmd->cft using merge/tag rules */\n\t\tif (!merge_config_tree(cmd, cft, cfl->cft, CONFIG_MERGE_TYPE_TAGS))\n\t\t\treturn_0;\n\t}\n\n\treturn cft;\n}\n\nstatic void _destroy_tags(struct cmd_context *cmd)\n{\n\tstruct dm_list *slh, *slht;\n\n\tdm_list_iterate_safe(slh, slht, &cmd->tags) {\n\t\tdm_list_del(slh);\n\t}\n}\n\nint config_files_changed(struct cmd_context *cmd)\n{\n\tstruct config_tree_list *cfl;\n\n\tdm_list_iterate_items(cfl, &cmd->config_files) {\n\t\tif (config_file_changed(cfl->cft))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void _destroy_config(struct cmd_context *cmd)\n{\n\tstruct config_tree_list *cfl;\n\tstruct dm_config_tree *cft;\n\tstruct profile *profile, *tmp_profile;\n\n\t/*\n\t * Configuration cascade:\n\t * CONFIG_STRING -> CONFIG_PROFILE -> CONFIG_FILE/CONFIG_MERGED_FILES\n\t */\n\n\t/* CONFIG_FILE/CONFIG_MERGED_FILES */\n\tif ((cft = remove_config_tree_by_source(cmd, CONFIG_MERGED_FILES)))\n\t\tconfig_destroy(cft);\n\telse\n\t\tremove_config_tree_by_source(cmd, CONFIG_FILE);\n\n\tdm_list_iterate_items(cfl, &cmd->config_files)\n\t\tconfig_destroy(cfl->cft);\n\tdm_list_init(&cmd->config_files);\n\n\t/* CONFIG_PROFILE */\n\tif (cmd->profile_params) {\n\t\tremove_config_tree_by_source(cmd, CONFIG_PROFILE_COMMAND);\n\t\tremove_config_tree_by_source(cmd, CONFIG_PROFILE_METADATA);\n\t\t/*\n\t\t * Destroy config trees for any loaded profiles and\n\t\t * move these profiles to profile_to_load list.\n\t\t * Whenever these profiles are referenced later,\n\t\t * they will get loaded again automatically.\n\t\t */\n\t\tdm_list_iterate_items_safe(profile, tmp_profile, &cmd->profile_params->profiles) {\n\t\t\tif (cmd->is_interactive && (profile == cmd->profile_params->shell_profile))\n\t\t\t\tcontinue;\n\n\t\t\tconfig_destroy(profile->cft);\n\t\t\tprofile->cft = NULL;\n\t\t\tdm_list_move(&cmd->profile_params->profiles_to_load, &profile->list);\n\t\t}\n\t}\n\n\t/* CONFIG_STRING */\n\tif ((cft = remove_config_tree_by_source(cmd, CONFIG_STRING)))\n\t\tconfig_destroy(cft);\n\n\tif (cmd->cft)\n\t\tlog_error(INTERNAL_ERROR \"_destroy_config: \"\n\t\t\t  \"cmd config tree not destroyed fully\");\n}\n\nstatic int _init_dev_cache(struct cmd_context *cmd)\n{\n\tconst struct dm_config_node *cn;\n\tconst struct dm_config_value *cv;\n\tsize_t len, udev_dir_len = strlen(DM_UDEV_DEV_DIR);\n\tint len_diff;\n\tint device_list_from_udev;\n\n\tif (!dev_cache_init(cmd))\n\t\treturn_0;\n\n\t/*\n\t * Override existing config and hardcode device_list_from_udev = 0 if:\n\t *   - udev is not running\n\t *   - udev is disabled using DM_DISABLE_UDEV environment variable\n\t */\n\tif (_check_disable_udev(\"obtain device list by scanning device directory\"))\n\t\tdevice_list_from_udev = 0;\n\telse\n\t\tdevice_list_from_udev = udev_is_running() ?\n\t\t\tfind_config_tree_bool(cmd, devices_obtain_device_list_from_udev_CFG, NULL) : 0;\n\n\tinit_obtain_device_list_from_udev(device_list_from_udev);\n\n\tif (!(cn = find_config_tree_array(cmd, devices_scan_CFG, NULL))) {\n\t\tlog_error(INTERNAL_ERROR \"Unable to find configuration for devices/scan.\");\n\t\treturn 0;\n\t}\n\n\tfor (cv = cn->v; cv; cv = cv->next) {\n\t\tif (cv->type != DM_CFG_STRING) {\n\t\t\tlog_error(\"Invalid string in config file: \"\n\t\t\t\t  \"devices/scan\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (device_list_from_udev) {\n\t\t\tlen = strlen(cv->v.str);\n\n\t\t\t/*\n\t\t\t * DM_UDEV_DEV_DIR always has '/' at its end.\n\t\t\t * If the item in the conf does not have it, be sure\n\t\t\t * to make the right comparison without the '/' char!\n\t\t\t */\n\t\t\tlen_diff = len && cv->v.str[len - 1] != '/' ?\n\t\t\t\t\tudev_dir_len - 1 != len :\n\t\t\t\t\tudev_dir_len != len;\n\n\t\t\tif (len_diff || strncmp(DM_UDEV_DEV_DIR, cv->v.str, len)) {\n\t\t\t\tlog_very_verbose(\"Non standard udev dir %s, resetting \"\n\t\t\t\t\t\t \"devices/obtain_device_list_from_udev.\",\n\t\t\t\t\t\t cv->v.str);\n\t\t\t\tdevice_list_from_udev = 0;\n\t\t\t\tinit_obtain_device_list_from_udev(0);\n\t\t\t}\n\t\t}\n\n\t\tif (!dev_cache_add_dir(cv->v.str)) {\n\t\t\tlog_error(\"Failed to add %s to internal device cache\",\n\t\t\t\t  cv->v.str);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n#define MAX_FILTERS 10\n\nstatic struct dev_filter *_init_lvmetad_filter_chain(struct cmd_context *cmd)\n{\n\tint nr_filt = 0;\n\tconst struct dm_config_node *cn;\n\tstruct dev_filter *filters[MAX_FILTERS] = { 0 };\n\tstruct dev_filter *composite;\n\n\t/*\n\t * Filters listed in order: top one gets applied first.\n\t * Failure to initialise some filters is not fatal.\n\t * Update MAX_FILTERS definition above when adding new filters.\n\t */\n\n\t/*\n\t * sysfs filter. Only available on 2.6 kernels.  Non-critical.\n\t * Listed first because it's very efficient at eliminating\n\t * unavailable devices.\n\t */\n\tif (find_config_tree_bool(cmd, devices_sysfs_scan_CFG, NULL)) {\n\t\tif ((filters[nr_filt] = sysfs_filter_create()))\n\t\t\tnr_filt++;\n\t}\n\n\t/* internal filter used by command processing. */\n\tif (!(filters[nr_filt] = internal_filter_create())) {\n\t\tlog_error(\"Failed to create internal device filter\");\n\t\tgoto bad;\n\t}\n\tnr_filt++;\n\n\t/* global regex filter. Optional. */\n\tif ((cn = find_config_tree_node(cmd, devices_global_filter_CFG, NULL))) {\n\t\tif (!(filters[nr_filt] = regex_filter_create(cn->v))) {\n\t\t\tlog_error(\"Failed to create global regex device filter\");\n\t\t\tgoto bad;\n\t\t}\n\t\tnr_filt++;\n\t}\n\n\t/* regex filter. Optional. */\n\tif ((cn = find_config_tree_node(cmd, devices_filter_CFG, NULL))) {\n\t\tif (!(filters[nr_filt] = regex_filter_create(cn->v))) {\n\t\t\tlog_error(\"Failed to create regex device filter\");\n\t\t\tgoto bad;\n\t\t}\n\t\tnr_filt++;\n\t}\n\n\t/* device type filter. Required. */\n\tif (!(filters[nr_filt] = lvm_type_filter_create(cmd->dev_types))) {\n\t\tlog_error(\"Failed to create lvm type filter\");\n\t\tgoto bad;\n\t}\n\tnr_filt++;\n\n\t/* usable device filter. Required. */\n\tif (!(filters[nr_filt] = usable_filter_create(cmd, cmd->dev_types, FILTER_MODE_NO_LVMETAD))) {\n\t\tlog_error(\"Failed to create usabled device filter\");\n\t\tgoto bad;\n\t}\n\tnr_filt++;\n\n\t/* mpath component filter. Optional, non-critical. */\n\tif (find_config_tree_bool(cmd, devices_multipath_component_detection_CFG, NULL)) {\n\t\tif ((filters[nr_filt] = mpath_filter_create(cmd->dev_types)))\n\t\t\tnr_filt++;\n\t}\n\n\t/* partitioned device filter. Required. */\n\tif (!(filters[nr_filt] = partitioned_filter_create(cmd->dev_types))) {\n\t\tlog_error(\"Failed to create partitioned device filter\");\n\t\tgoto bad;\n\t}\n\tnr_filt++;\n\n\t/* signature filter. Required. */\n\tif (!(filters[nr_filt] = signature_filter_create(cmd->dev_types))) {\n\t\tlog_error(\"Failed to create signature device filter\");\n\t\tgoto bad;\n\t}\n\tnr_filt++;\n\n\t/* md component filter. Optional, non-critical. */\n\tif (find_config_tree_bool(cmd, devices_md_component_detection_CFG, NULL)) {\n\t\tinit_md_filtering(1);\n\t\tif ((filters[nr_filt] = md_filter_create(cmd, cmd->dev_types)))\n\t\t\tnr_filt++;\n\t}\n\n\t/* firmware raid filter. Optional, non-critical. */\n\tif (find_config_tree_bool(cmd, devices_fw_raid_component_detection_CFG, NULL)) {\n\t\tinit_fwraid_filtering(1);\n\t\tif ((filters[nr_filt] = fwraid_filter_create(cmd->dev_types)))\n\t\t\tnr_filt++;\n\t}\n\n\tif (!(composite = composite_filter_create(nr_filt, 1, filters)))\n\t\tgoto_bad;\n\n\treturn composite;\n\nbad:\n\twhile (--nr_filt >= 0)\n\t\t filters[nr_filt]->destroy(filters[nr_filt]);\n\n\treturn NULL;\n}\n\n/*\n * The way the filtering is initialized depends on whether lvmetad is uesd or not.\n *\n * If lvmetad is used, there are three filter chains:\n *\n *   - cmd->lvmetad_filter - the lvmetad filter chain used when scanning devs for lvmetad update:\n *     sysfs filter -> internal filter -> global regex filter -> type filter ->\n *     usable device filter(FILTER_MODE_PRE_LVMETAD) ->\n *     mpath component filter -> partitioned filter ->\n *     md component filter -> fw raid filter\n *\n *   - cmd->filter - the filter chain used for lvmetad responses:\n *     persistent filter -> regex_filter -> usable device filter(FILTER_MODE_POST_LVMETAD)\n *\n *   - cmd->full_filter - the filter chain used for all the remaining situations:\n *     cmd->lvmetad_filter -> cmd->filter\n *\n * If lvmetad is not used, there's just one filter chain:\n *\n *   - cmd->filter == cmd->full_filter:\n *     persistent filter -> sysfs filter -> internal filter -> global regex filter ->\n *     regex_filter -> type filter -> usable device filter(FILTER_MODE_NO_LVMETAD) ->\n *     mpath component filter -> partitioned filter -> md component filter -> fw raid filter\n *\n */\nint init_filters(struct cmd_context *cmd, unsigned load_persistent_cache)\n{\n\tstruct dev_filter *pfilter, *filter = NULL, *filter_components[2] = {0};\n\n\tif (!cmd->initialized.connections) {\n\t\tlog_error(INTERNAL_ERROR \"connections must be initialized before filters\");\n\t\treturn 0;\n\t}\n\n\tcmd->lvmetad_filter = _init_lvmetad_filter_chain(cmd);\n\tif (!cmd->lvmetad_filter)\n\t\tgoto_bad;\n\n\tinit_ignore_suspended_devices(find_config_tree_bool(cmd, devices_ignore_suspended_devices_CFG, NULL));\n\tinit_ignore_lvm_mirrors(find_config_tree_bool(cmd, devices_ignore_lvm_mirrors_CFG, NULL));\n\n\t/*\n\t * If lvmetad is used, there's a separation between pre-lvmetad filter chain\n\t * (\"cmd->lvmetad_filter\") applied only if scanning for lvmetad update and\n\t * post-lvmetad filter chain (\"filter\") applied on each lvmetad response.\n\t * However, if lvmetad is not used, these two chains are not separated\n\t * and we use exactly one filter chain during device scanning (\"filter\"\n\t * that includes also \"cmd->lvmetad_filter\" chain).\n\t */\n\tfilter = cmd->lvmetad_filter;\n\tcmd->lvmetad_filter = NULL;\n\n\tif (!(pfilter = persistent_filter_create(cmd->dev_types, filter))) {\n\t\tlog_verbose(\"Failed to create persistent device filter.\");\n\t\tgoto bad;\n\t}\n\n\tcmd->filter = filter = pfilter;\n\n\tcmd->full_filter = filter;\n\n\tcmd->initialized.filters = 1;\n\treturn 1;\nbad:\n\tif (!filter) {\n\t\t/*\n\t\t * composite filter not created - destroy\n\t\t * each component directly\n\t\t */\n\t\tif (filter_components[0])\n\t\t\tfilter_components[0]->destroy(filter_components[0]);\n\t\tif (filter_components[1])\n\t\t\tfilter_components[1]->destroy(filter_components[1]);\n\t} else {\n\t\t/*\n\t\t * composite filter created - destroy it - this\n\t\t * will also destroy any of its components\n\t\t */\n\t\tfilter->destroy(filter);\n\t}\n\n\t/* if lvmetad is used, the cmd->lvmetad_filter is separate */\n\tif (cmd->lvmetad_filter)\n\t\tcmd->lvmetad_filter->destroy(cmd->lvmetad_filter);\n\n\tcmd->initialized.filters = 0;\n\treturn 0;\n}\n\nstruct format_type *get_format_by_name(struct cmd_context *cmd, const char *format)\n{\n        struct format_type *fmt;\n\n        dm_list_iterate_items(fmt, &cmd->formats)\n                if (!strcasecmp(fmt->name, format) ||\n                    !strcasecmp(fmt->name + 3, format) ||\n                    (fmt->alias && !strcasecmp(fmt->alias, format)))\n                        return fmt;\n\n        return NULL;\n}\n\n/* FIXME: there's only one format, get rid of the list of formats */\n\nstatic int _init_formats(struct cmd_context *cmd)\n{\n\tstruct format_type *fmt;\n\n\tif (!(fmt = create_text_format(cmd)))\n\t\treturn 0;\n\n\tdm_list_add(&cmd->formats, &fmt->list);\n\tcmd->fmt_backup = fmt;\n\tcmd->default_settings.fmt_name = fmt->name;\n\tcmd->fmt = fmt;\n\n\treturn 1;\n}\n\nint init_lvmcache_orphans(struct cmd_context *cmd)\n{\n\tstruct format_type *fmt;\n\n\tdm_list_iterate_items(fmt, &cmd->formats)\n\t\tif (!lvmcache_add_orphan_vginfo(fmt->orphan_vg_name, fmt))\n\t\t\treturn_0;\n\n\treturn 1;\n}\n\nstruct segtype_library {\n\tstruct cmd_context *cmd;\n\tvoid *lib;\n\tconst char *libname;\n};\n\nint lvm_register_segtype(struct segtype_library *seglib,\n\t\t\t struct segment_type *segtype)\n{\n\tstruct segment_type *segtype2;\n\n\tsegtype->library = seglib->lib;\n\n\tdm_list_iterate_items(segtype2, &seglib->cmd->segtypes) {\n\t\tif (strcmp(segtype2->name, segtype->name))\n\t\t\tcontinue;\n\t\tlog_error(\"Duplicate segment type %s: \"\n\t\t\t  \"unloading shared library %s\",\n\t\t\t  segtype->name, seglib->libname);\n\t\tsegtype->ops->destroy(segtype);\n\t\treturn 0;\n\t}\n\n\tdm_list_add(&seglib->cmd->segtypes, &segtype->list);\n\n\treturn 1;\n}\n\nstatic int _init_single_segtype(struct cmd_context *cmd,\n\t\t\t\tstruct segtype_library *seglib)\n{\n\tstruct segment_type *(*init_segtype_fn) (struct cmd_context *);\n\tstruct segment_type *segtype;\n\n\tif (!(init_segtype_fn = dlsym(seglib->lib, \"init_segtype\"))) {\n\t\tlog_error(\"Shared library %s does not contain segment type \"\n\t\t\t  \"functions\", seglib->libname);\n\t\treturn 0;\n\t}\n\n\tif (!(segtype = init_segtype_fn(seglib->cmd)))\n\t\treturn_0;\n\n\treturn lvm_register_segtype(seglib, segtype);\n}\n\nstatic int _init_segtypes(struct cmd_context *cmd)\n{\n\tint i;\n\tstruct segment_type *segtype;\n\tstruct segtype_library seglib = { .cmd = cmd, .lib = NULL };\n\tstruct segment_type *(*init_segtype_array[])(struct cmd_context *cmd) = {\n\t\tinit_linear_segtype,\n\t\tinit_striped_segtype,\n\t\tinit_zero_segtype,\n\t\tinit_error_segtype,\n\t\t/* disabled until needed init_free_segtype, */\n#ifdef SNAPSHOT_INTERNAL\n\t\tinit_snapshot_segtype,\n#endif\n#ifdef MIRRORED_INTERNAL\n\t\tinit_mirrored_segtype,\n#endif\n\t\tNULL\n\t};\n\n#ifdef HAVE_LIBDL\n\tconst struct dm_config_node *cn;\n#endif\n\n\tfor (i = 0; init_segtype_array[i]; i++) {\n\t\tif (!(segtype = init_segtype_array[i](cmd)))\n\t\t\treturn 0;\n\t\tsegtype->library = NULL;\n\t\tdm_list_add(&cmd->segtypes, &segtype->list);\n\t}\n\n#ifdef RAID_INTERNAL\n\tif (!init_raid_segtypes(cmd, &seglib))\n\t\treturn 0;\n#endif\n\n#ifdef THIN_INTERNAL\n\tif (!init_thin_segtypes(cmd, &seglib))\n\t\treturn 0;\n#endif\n\n#ifdef CACHE_INTERNAL\n\tif (!init_cache_segtypes(cmd, &seglib))\n\t\treturn 0;\n#endif\n\n#ifdef VDO_INTERNAL\n\tif (!init_vdo_segtypes(cmd, &seglib))\n\t\treturn_0;\n#endif\n\n#ifdef HAVE_LIBDL\n\t/* Load any formats in shared libs unless static */\n\tif (!is_static() &&\n\t    (cn = find_config_tree_array(cmd, global_segment_libraries_CFG, NULL))) {\n\n\t\tconst struct dm_config_value *cv;\n\t\tint (*init_multiple_segtypes_fn) (struct cmd_context *,\n\t\t\t\t\t\t  struct segtype_library *);\n\n\t\tfor (cv = cn->v; cv; cv = cv->next) {\n\t\t\tif (cv->type != DM_CFG_STRING) {\n\t\t\t\tlog_error(\"Invalid string in config file: \"\n\t\t\t\t\t  \"global/segment_libraries\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tseglib.libname = cv->v.str;\n\t\t\tif (!(seglib.lib = load_shared_library(cmd,\n\t\t\t\t\t\t\tseglib.libname,\n\t\t\t\t\t\t\t\"segment type\", 0)))\n\t\t\t\treturn_0;\n\n\t\t\tif ((init_multiple_segtypes_fn =\n\t\t\t    dlsym(seglib.lib, \"init_multiple_segtypes\"))) {\n\t\t\t\tif (dlsym(seglib.lib, \"init_segtype\"))\n\t\t\t\t\tlog_warn(\"WARNING: Shared lib %s has \"\n\t\t\t\t\t\t \"conflicting init fns.  Using\"\n\t\t\t\t\t\t \" init_multiple_segtypes().\",\n\t\t\t\t\t\t seglib.libname);\n\t\t\t} else\n\t\t\t\tinit_multiple_segtypes_fn =\n\t\t\t\t    _init_single_segtype;\n \n\t\t\tif (!init_multiple_segtypes_fn(cmd, &seglib)) {\n\t\t\t\tstruct dm_list *sgtl, *tmp;\n\t\t\t\tlog_error(\"init_multiple_segtypes() failed: \"\n\t\t\t\t\t  \"Unloading shared library %s\",\n\t\t\t\t\t  seglib.libname);\n\t\t\t\tdm_list_iterate_safe(sgtl, tmp, &cmd->segtypes) {\n\t\t\t\t\tsegtype = dm_list_item(sgtl, struct segment_type);\n\t\t\t\t\tif (segtype->library == seglib.lib) {\n\t\t\t\t\t\tdm_list_del(&segtype->list);\n\t\t\t\t\t\tsegtype->ops->destroy(segtype);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdlclose(seglib.lib);\n\t\t\t\treturn_0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\treturn 1;\n}\n\nstatic int _init_hostname(struct cmd_context *cmd)\n{\n\tstruct utsname uts;\n\n\tif (uname(&uts)) {\n\t\tlog_sys_error(\"uname\", \"_init_hostname\");\n\t\treturn 0;\n\t}\n\n\tif (!(cmd->hostname = dm_pool_strdup(cmd->libmem, uts.nodename))) {\n\t\tlog_error(\"_init_hostname: dm_pool_strdup failed\");\n\t\treturn 0;\n\t}\n\n\tif (!(cmd->kernel_vsn = dm_pool_strdup(cmd->libmem, uts.release))) {\n\t\tlog_error(\"_init_hostname: dm_pool_strdup kernel_vsn failed\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int _init_backup(struct cmd_context *cmd)\n{\n\tuint32_t days, min;\n\tconst char *dir;\n\n\tif (!cmd->system_dir[0]) {\n\t\tlog_warn(\"WARNING: Metadata changes will NOT be backed up\");\n\t\tbackup_init(cmd, \"\", 0);\n\t\tarchive_init(cmd, \"\", 0, 0, 0);\n\t\treturn 1;\n\t}\n\n\t/* set up archiving */\n\tcmd->default_settings.archive =\n\t    find_config_tree_bool(cmd, backup_archive_CFG, NULL);\n\n\tdays = (uint32_t) find_config_tree_int(cmd, backup_retain_days_CFG, NULL);\n\n\tmin = (uint32_t) find_config_tree_int(cmd, backup_retain_min_CFG, NULL);\n\n\tif (!(dir = find_config_tree_str(cmd, backup_archive_dir_CFG, NULL)))\n\t\treturn_0;\n\n\tif (!archive_init(cmd, dir, days, min,\n\t\t\t  cmd->default_settings.archive)) {\n\t\tlog_debug(\"archive_init failed.\");\n\t\treturn 0;\n\t}\n\n\t/* set up the backup */\n\tcmd->default_settings.backup = find_config_tree_bool(cmd, backup_backup_CFG, NULL);\n\n\tif (!(dir = find_config_tree_str(cmd, backup_backup_dir_CFG, NULL)))\n\t\treturn_0;\n\n\tif (!backup_init(cmd, dir, cmd->default_settings.backup)) {\n\t\tlog_debug(\"backup_init failed.\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void _init_rand(struct cmd_context *cmd)\n{\n\tif (read_urandom(&cmd->rand_seed, sizeof(cmd->rand_seed))) {\n\t\treset_lvm_errno(1);\n\t\treturn;\n\t}\n\n\tcmd->rand_seed = (unsigned) time(NULL) + (unsigned) getpid();\n\treset_lvm_errno(1);\n}\n\nstatic void _init_globals(struct cmd_context *cmd)\n{\n\tinit_mirror_in_sync(0);\n}\n\nstatic int _init_lvmpolld(struct cmd_context *cmd)\n{\n\tconst char *lvmpolld_socket;\n\n\tlvmpolld_disconnect();\n\n\tlvmpolld_socket = getenv(\"LVM_LVMPOLLD_SOCKET\");\n\tif (!lvmpolld_socket)\n\t\tlvmpolld_socket = DEFAULT_RUN_DIR \"/lvmpolld.socket\";\n\tlvmpolld_set_socket(lvmpolld_socket);\n\n\tlvmpolld_set_active(find_config_tree_bool(cmd, global_use_lvmpolld_CFG, NULL));\n\treturn 1;\n}\n\nint init_connections(struct cmd_context *cmd)\n{\n\tif (!_init_lvmpolld(cmd)) {\n\t\tlog_error(\"Failed to initialize lvmpolld connection.\");\n\t\tgoto bad;\n\t}\n\n\tcmd->initialized.connections = 1;\n\treturn 1;\nbad:\n\tcmd->initialized.connections = 0;\n\treturn 0;\n}\n\nint init_run_by_dmeventd(struct cmd_context *cmd)\n{\n\tinit_dmeventd_monitor(DMEVENTD_MONITOR_IGNORE);\n\tinit_ignore_suspended_devices(1);\n\tinit_disable_dmeventd_monitoring(1); /* Lock settings */\n\n\treturn 0;\n}\n\nvoid destroy_config_context(struct cmd_context *cmd)\n{\n\t_destroy_config(cmd);\n\n\tif (cmd->mem)\n\t\tdm_pool_destroy(cmd->mem);\n\tif (cmd->libmem)\n\t\tdm_pool_destroy(cmd->libmem);\n\n\tfree(cmd);\n}\n\n/*\n * A \"config context\" is a very light weight toolcontext that\n * is only used for reading config settings from lvm.conf.\n *\n * FIXME: this needs to go back to parametrized create_toolcontext()\n */\nstruct cmd_context *create_config_context(void)\n{\n\tstruct cmd_context *cmd;\n\n\tif (!(cmd = zalloc(sizeof(*cmd))))\n\t\tgoto_out;\n\n\tstrcpy(cmd->system_dir, DEFAULT_SYS_DIR);\n\n\tif (!_get_env_vars(cmd))\n\t\tgoto_out;\n\n\tif (!(cmd->libmem = dm_pool_create(\"library\", 4 * 1024)))\n\t\tgoto_out;\n\n\tif (!(cmd->mem = dm_pool_create(\"command\", 4 * 1024)))\n\t\tgoto out;\n\n\tdm_list_init(&cmd->config_files);\n\tdm_list_init(&cmd->tags);\n\n\tif (!_init_lvm_conf(cmd))\n\t\tgoto_out;\n\n\tif (!_init_hostname(cmd))\n\t\tgoto_out;\n\n\tif (!_init_tags(cmd, cmd->cft))\n\t\tgoto_out;\n\n\t/* Load lvmlocal.conf */\n\tif (*cmd->system_dir && !_load_config_file(cmd, \"\", 1))\n\t\tgoto_out;\n\n\tif (!_init_tag_configs(cmd))\n\t\tgoto_out;\n\n\tif (!(cmd->cft = _merge_config_files(cmd, cmd->cft)))\n\t\tgoto_out;\n\n\treturn cmd;\nout:\n\tif (cmd)\n\t\tdestroy_config_context(cmd);\n\treturn NULL;\n}\n\n/* Entry point */\nstruct cmd_context *create_toolcontext(unsigned is_clvmd,\n\t\t\t\t       const char *system_dir,\n\t\t\t\t       unsigned set_buffering,\n\t\t\t\t       unsigned threaded,\n\t\t\t\t       unsigned set_connections,\n\t\t\t\t       unsigned set_filters)\n{\n\tstruct cmd_context *cmd;\n\tint flags;\n\n#ifdef M_MMAP_MAX\n\tmallopt(M_MMAP_MAX, 0);\n#endif\n\n\tif (!setlocale(LC_ALL, \"\"))\n\t\tlog_very_verbose(\"setlocale failed\");\n\n#ifdef INTL_PACKAGE\n\tbindtextdomain(INTL_PACKAGE, LOCALEDIR);\n#endif\n\n\tinit_syslog(DEFAULT_LOG_FACILITY);\n\n\tif (!(cmd = zalloc(sizeof(*cmd)))) {\n\t\tlog_error(\"Failed to allocate command context\");\n\t\treturn NULL;\n\t}\n\tcmd->is_long_lived = is_clvmd;\n\tcmd->is_clvmd = is_clvmd;\n\tcmd->threaded = threaded ? 1 : 0;\n\tcmd->handles_missing_pvs = 0;\n\tcmd->handles_unknown_segments = 0;\n\tcmd->hosttags = 0;\n\tdm_list_init(&cmd->arg_value_groups);\n\tdm_list_init(&cmd->formats);\n\tdm_list_init(&cmd->segtypes);\n\tdm_list_init(&cmd->tags);\n\tdm_list_init(&cmd->config_files);\n\tlabel_init();\n\n\t/* FIXME Make this configurable? */\n\treset_lvm_errno(1);\n\n#ifndef VALGRIND_POOL\n\t/* Set in/out stream buffering before glibc */\n\tif (set_buffering\n#ifdef SYS_gettid\n\t    /* For threaded programs no changes of streams */\n            /* On linux gettid() is implemented only via syscall */\n\t    && (syscall(SYS_gettid) == getpid())\n#endif\n\t   ) {\n\t\t/* Allocate 2 buffers */\n\t\tif (!(cmd->linebuffer = malloc(2 * _linebuffer_size))) {\n\t\t\tlog_error(\"Failed to allocate line buffer.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* nohup might set stdin O_WRONLY ! */\n\t\tif (is_valid_fd(STDIN_FILENO) &&\n\t\t    ((flags = fcntl(STDIN_FILENO, F_GETFL)) > 0) &&\n\t\t    (flags & O_ACCMODE) != O_WRONLY) {\n\t\t\tif (!reopen_standard_stream(&stdin, \"r\"))\n\t\t\t\tgoto_out;\n\t\t\tif (setvbuf(stdin, cmd->linebuffer, _IOLBF, _linebuffer_size)) {\n\t\t\t\tlog_sys_error(\"setvbuf\", \"\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (is_valid_fd(STDOUT_FILENO) &&\n\t\t    ((flags = fcntl(STDOUT_FILENO, F_GETFL)) > 0) &&\n\t\t    (flags & O_ACCMODE) != O_RDONLY) {\n\t\t\tif (!reopen_standard_stream(&stdout, \"w\"))\n\t\t\t\tgoto_out;\n\t\t\tif (setvbuf(stdout, cmd->linebuffer + _linebuffer_size,\n\t\t\t\t     _IOLBF, _linebuffer_size)) {\n\t\t\t\tlog_sys_error(\"setvbuf\", \"\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* Buffers are used for lines without '\\n' */\n\t} else if (!set_buffering)\n\t\t/* Without buffering, must not use stdin/stdout */\n\t\tinit_silent(1);\n#endif\n\t/*\n\t * Environment variable LVM_SYSTEM_DIR overrides this below.\n\t */\n        if (system_dir)\n\t\tstrncpy(cmd->system_dir, system_dir, sizeof(cmd->system_dir) - 1);\n\telse\n\t\tstrcpy(cmd->system_dir, DEFAULT_SYS_DIR);\n\n\tif (!_get_env_vars(cmd))\n\t\tgoto_out;\n\n\t/* Create system directory if it doesn't already exist */\n\tif (*cmd->system_dir && !dm_create_dir(cmd->system_dir)) {\n\t\tlog_error(\"Failed to create LVM2 system dir for metadata backups, config \"\n\t\t\t  \"files and internal cache.\");\n\t\tlog_error(\"Set environment variable LVM_SYSTEM_DIR to alternative location \"\n\t\t\t  \"or empty string.\");\n\t\tgoto out;\n\t}\n\n\tif (!(cmd->libmem = dm_pool_create(\"library\", 4 * 1024))) {\n\t\tlog_error(\"Library memory pool creation failed\");\n\t\tgoto out;\n\t}\n\n\tif (!(cmd->mem = dm_pool_create(\"command\", 4 * 1024))) {\n\t\tlog_error(\"Command memory pool creation failed\");\n\t\tgoto out;\n\t}\n\n\tif (!_init_lvm_conf(cmd))\n\t\tgoto_out;\n\n\t_init_logging(cmd);\n\n\tif (!_init_hostname(cmd))\n\t\tgoto_out;\n\n\tif (!_init_tags(cmd, cmd->cft))\n\t\tgoto_out;\n\n\t/* Load lvmlocal.conf */\n\tif (*cmd->system_dir && !_load_config_file(cmd, \"\", 1))\n\t\tgoto_out;\n\n\tif (!_init_tag_configs(cmd))\n\t\tgoto_out;\n\n\tif (!(cmd->cft = _merge_config_files(cmd, cmd->cft)))\n\t\tgoto_out;\n\n\tif (!_process_config(cmd))\n\t\tgoto_out;\n\n\tif (!_init_profiles(cmd))\n\t\tgoto_out;\n\n\tif (!(cmd->dev_types = create_dev_types(cmd->proc_dir,\n\t\t\t\t\t\tfind_config_tree_array(cmd, devices_types_CFG, NULL))))\n\t\tgoto_out;\n\n\tif (!_init_dev_cache(cmd))\n\t\tgoto_out;\n\n\tmemlock_init(cmd);\n\n\tif (!_init_formats(cmd))\n\t\tgoto_out;\n\n\tif (!lvmcache_init(cmd))\n\t\tgoto_out;\n\n\t/* FIXME: move into lvmcache_init */\n\tif (!init_lvmcache_orphans(cmd))\n\t\tgoto_out;\n\n\tdm_list_init(&cmd->unused_duplicate_devs);\n\n\tif (!_init_segtypes(cmd))\n\t\tgoto_out;\n\n\tif (!_init_backup(cmd))\n\t\tgoto_out;\n\n\t_init_rand(cmd);\n\n\t_init_globals(cmd);\n\n\tif (set_connections && !init_connections(cmd))\n\t\tgoto_out;\n\n\tif (set_filters && !init_filters(cmd, 1))\n\t\tgoto_out;\n\n\tcmd->current_settings = cmd->default_settings;\n\n\tcmd->initialized.config = 1;\nout:\n\tif (!cmd->initialized.config) {\n\t\tdestroy_toolcontext(cmd);\n\t\tcmd = NULL;\n\t}\n\n\treturn cmd;\n}\n\nstatic void _destroy_formats(struct cmd_context *cmd, struct dm_list *formats)\n{\n\tstruct dm_list *fmtl, *tmp;\n\tstruct format_type *fmt;\n\n\tdm_list_iterate_safe(fmtl, tmp, formats) {\n\t\tfmt = dm_list_item(fmtl, struct format_type);\n\t\tdm_list_del(&fmt->list);\n\t\tfmt->ops->destroy(fmt);\n\t}\n}\n\nstatic void _destroy_segtypes(struct dm_list *segtypes)\n{\n\tstruct dm_list *sgtl, *tmp;\n\tstruct segment_type *segtype;\n\tvoid *lib;\n\n\tdm_list_iterate_safe(sgtl, tmp, segtypes) {\n\t\tsegtype = dm_list_item(sgtl, struct segment_type);\n\t\tdm_list_del(&segtype->list);\n\t\tlib = segtype->library;\n\t\tsegtype->ops->destroy(segtype);\n#ifdef HAVE_LIBDL\n\t\t/*\n\t\t * If no segtypes remain from this library, close it.\n\t\t */\n\t\tif (lib) {\n\t\t\tstruct segment_type *segtype2;\n\t\t\tdm_list_iterate_items(segtype2, segtypes)\n\t\t\t\tif (segtype2->library == lib)\n\t\t\t\t\tgoto skip_dlclose;\n\t\t\tdlclose(lib);\nskip_dlclose:\n\t\t\t;\n\t\t}\n#endif\n\t}\n}\n\nstatic void _destroy_dev_types(struct cmd_context *cmd)\n{\n\tif (!cmd->dev_types)\n\t\treturn;\n\n\tfree(cmd->dev_types);\n\tcmd->dev_types = NULL;\n}\n\nstatic void _destroy_filters(struct cmd_context *cmd)\n{\n\tif (cmd->full_filter) {\n\t\tcmd->full_filter->destroy(cmd->full_filter);\n\t\tcmd->lvmetad_filter = cmd->filter = cmd->full_filter = NULL;\n\t}\n\tcmd->initialized.filters = 0;\n}\n\nint refresh_filters(struct cmd_context *cmd)\n{\n\tint r, saved_ignore_suspended_devices = ignore_suspended_devices();\n\n\tif (!cmd->initialized.filters)\n\t\t/* if filters not initialized, there's nothing to refresh */\n\t\treturn 1;\n\n\t_destroy_filters(cmd);\n\tif (!(r = init_filters(cmd, 0)))\n                stack;\n\n\t/*\n\t * During repair code must not reset suspended flag.\n\t */\n\tinit_ignore_suspended_devices(saved_ignore_suspended_devices);\n\n\treturn r;\n}\n\nint refresh_toolcontext(struct cmd_context *cmd)\n{\n\tstruct dm_config_tree *cft_cmdline, *cft_tmp;\n\tconst char *profile_command_name, *profile_metadata_name;\n\tstruct profile *profile;\n\n\tlog_verbose(\"Reloading config files\");\n\n\t/*\n\t * Don't update the persistent filter cache as we will\n\t * perform a full rescan.\n\t */\n\n\tactivation_release();\n\tlvmcache_destroy(cmd, 0, 0);\n\tlabel_scan_destroy(cmd);\n\tlabel_exit();\n\t_destroy_segtypes(&cmd->segtypes);\n\t_destroy_formats(cmd, &cmd->formats);\n\n\tif (!dev_cache_exit())\n\t\tstack;\n\t_destroy_dev_types(cmd);\n\t_destroy_tags(cmd);\n\n\t/* save config string passed on the command line */\n\tcft_cmdline = remove_config_tree_by_source(cmd, CONFIG_STRING);\n\n\t/* save the global profile name used */\n\tprofile_command_name = cmd->profile_params->global_command_profile ?\n\t\t\t\tcmd->profile_params->global_command_profile->name : NULL;\n\tprofile_metadata_name = cmd->profile_params->global_metadata_profile ?\n\t\t\t\tcmd->profile_params->global_metadata_profile->name : NULL;\n\n\t_destroy_config(cmd);\n\n\tcmd->initialized.config = 0;\n\n\tcmd->hosttags = 0;\n\n\tcmd->lib_dir = NULL;\n\n\tif (!_init_lvm_conf(cmd))\n\t\treturn_0;\n\n\t/* Temporary duplicate cft pointer holding lvm.conf - replaced later */\n\tcft_tmp = cmd->cft;\n\tif (cft_cmdline)\n\t\tcmd->cft = dm_config_insert_cascaded_tree(cft_cmdline, cft_tmp);\n\n\t/* Reload the global profile. */\n\tif (profile_command_name) {\n\t\tif (!(profile = add_profile(cmd, profile_command_name, CONFIG_PROFILE_COMMAND)) ||\n\t\t    !override_config_tree_from_profile(cmd, profile))\n\t\t\treturn_0;\n\t}\n\tif (profile_metadata_name) {\n\t\tif (!(profile = add_profile(cmd, profile_metadata_name, CONFIG_PROFILE_METADATA)) ||\n\t\t    !override_config_tree_from_profile(cmd, profile))\n\t\t\treturn_0;\n\t}\n\n\t/* Uses cmd->cft i.e. cft_cmdline + lvm.conf */\n\t_init_logging(cmd);\n\n\t/* Init tags from lvm.conf. */\n\tif (!_init_tags(cmd, cft_tmp))\n\t\treturn_0;\n\n\t/* Load lvmlocal.conf */\n\tif (*cmd->system_dir && !_load_config_file(cmd, \"\", 1))\n\t\treturn_0;\n\n\t/* Doesn't change cmd->cft */\n\tif (!_init_tag_configs(cmd))\n\t\treturn_0;\n\n\t/* Merge all the tag config files with lvm.conf, returning a\n\t * fresh cft pointer in place of cft_tmp. */\n\tif (!(cmd->cft = _merge_config_files(cmd, cft_tmp)))\n\t\treturn_0;\n\n\t/* Finally we can make the proper, fully-merged, cmd->cft */\n\tif (cft_cmdline)\n\t\tcmd->cft = dm_config_insert_cascaded_tree(cft_cmdline, cmd->cft);\n\n\tif (!_process_config(cmd))\n\t\treturn_0;\n\n\tif (!_init_profiles(cmd))\n\t\treturn_0;\n\n\tif (!(cmd->dev_types = create_dev_types(cmd->proc_dir,\n\t\t\t\t\t\tfind_config_tree_array(cmd, devices_types_CFG, NULL))))\n\t\treturn_0;\n\n\tif (!_init_dev_cache(cmd))\n\t\treturn_0;\n\n\tif (!_init_formats(cmd))\n\t\treturn_0;\n\n\tif (!lvmcache_init(cmd))\n\t\treturn_0;\n\n\tif (!init_lvmcache_orphans(cmd))\n\t\treturn_0;\n\n\tif (!_init_segtypes(cmd))\n\t\treturn_0;\n\n\tif (!_init_backup(cmd))\n\t\treturn_0;\n\n\tcmd->initialized.config = 1;\n\n\tif (cmd->initialized.connections && !init_connections(cmd))\n\t\treturn_0;\n\n\tif (!refresh_filters(cmd))\n\t\treturn_0;\n\n\treset_lvm_errno(1);\n\treturn 1;\n}\n\nvoid destroy_toolcontext(struct cmd_context *cmd)\n{\n\tstruct dm_config_tree *cft_cmdline;\n\tint flags;\n\n\tarchive_exit(cmd);\n\tbackup_exit(cmd);\n\tlvmcache_destroy(cmd, 0, 0);\n\tlabel_scan_destroy(cmd);\n\tlabel_exit();\n\t_destroy_segtypes(&cmd->segtypes);\n\t_destroy_formats(cmd, &cmd->formats);\n\t_destroy_filters(cmd);\n\tif (cmd->mem)\n\t\tdm_pool_destroy(cmd->mem);\n\tdev_cache_exit();\n\t_destroy_dev_types(cmd);\n\t_destroy_tags(cmd);\n\n\tif ((cft_cmdline = remove_config_tree_by_source(cmd, CONFIG_STRING)))\n\t\tconfig_destroy(cft_cmdline);\n\t_destroy_config(cmd);\n\n\tif (cmd->cft_def_hash)\n\t\tdm_hash_destroy(cmd->cft_def_hash);\n\n\tif (cmd->libmem)\n\t\tdm_pool_destroy(cmd->libmem);\n\n#ifndef VALGRIND_POOL\n\tif (cmd->linebuffer) {\n\t\t/* Reset stream buffering to defaults */\n\t\tif (is_valid_fd(STDIN_FILENO) &&\n\t\t    ((flags = fcntl(STDIN_FILENO, F_GETFL)) > 0) &&\n\t\t    (flags & O_ACCMODE) != O_WRONLY) {\n\t\t\tif (reopen_standard_stream(&stdin, \"r\"))\n\t\t\t\tsetlinebuf(stdin);\n\t\t\telse\n\t\t\t\tcmd->linebuffer = NULL;\t/* Leave buffer in place (deliberate leak) */\n\t\t}\n\n\t\tif (is_valid_fd(STDOUT_FILENO) &&\n\t\t    ((flags = fcntl(STDOUT_FILENO, F_GETFL)) > 0) &&\n\t\t    (flags & O_ACCMODE) != O_RDONLY) {\n\t\t\tif (reopen_standard_stream(&stdout, \"w\"))\n\t\t\t\tsetlinebuf(stdout);\n\t\t\telse\n\t\t\t\tcmd->linebuffer = NULL;\t/* Leave buffer in place (deliberate leak) */\n\t\t}\n\n\t\tfree(cmd->linebuffer);\n\t}\n#endif\n\tfree(cmd);\n\n\tlvmpolld_disconnect();\n\n\trelease_log_memory();\n\tactivation_exit();\n\treset_log_duplicated();\n\tfin_log();\n\tfin_syslog();\n\treset_lvm_errno(0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-lvm2-2.03.01-boqkhxcjv5mjui6v7ajkw3ttrkzbv2yi/spack-src/lib/mm/memlock.c": "/*\n * Copyright (C) 2003-2004 Sistina Software, Inc. All rights reserved.\n * Copyright (C) 2004-2011 Red Hat, Inc. All rights reserved.\n *\n * This file is part of LVM2.\n *\n * This copyrighted material is made available to anyone wishing to use,\n * modify, copy, or redistribute it subject to the terms and conditions\n * of the GNU Lesser General Public License v.2.1.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"lib/misc/lib.h\"\n#include \"lib/mm/memlock.h\"\n#include \"lib/config/defaults.h\"\n#include \"lib/config/config.h\"\n#include \"lib/commands/toolcontext.h\"\n\n#include <limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <malloc.h>\n\n#ifdef HAVE_VALGRIND\n#include <valgrind.h>\n#endif\n\n#ifndef DEVMAPPER_SUPPORT\n\nvoid memlock_inc_daemon(struct cmd_context *cmd)\n{\n\treturn;\n}\n\nvoid memlock_dec_daemon(struct cmd_context *cmd)\n{\n\treturn;\n}\n\nvoid critical_section_inc(struct cmd_context *cmd, const char *reason)\n{\n\treturn;\n}\n\nvoid critical_section_dec(struct cmd_context *cmd, const char *reason)\n{\n\treturn;\n}\n\nint critical_section(void)\n{\n\treturn 0;\n}\nvoid memlock_init(struct cmd_context *cmd)\n{\n\treturn;\n}\n\nvoid memlock_unlock(struct cmd_context *cmd)\n{\n\treturn;\n}\n\nvoid memlock_reset(void)\n{\n\treturn;\n}\n\nint memlock_count_daemon(void)\n{\n\treturn 0;\n}\n\n#else\t\t\t\t/* DEVMAPPER_SUPPORT */\n\nstatic size_t _size_stack;\nstatic size_t _size_malloc_tmp;\nstatic size_t _size_malloc = 2000000;\n\nstatic void *_malloc_mem = NULL;\nstatic int _mem_locked = 0;\nstatic int _priority_raised = 0;\nstatic int _critical_section = 0;\nstatic int _prioritized_section = 0;\nstatic int _memlock_count_daemon = 0;\nstatic int _priority;\nstatic int _default_priority;\n\n/* list of maps, that are unconditionaly ignored */\nstatic const char * const _ignore_maps[] = {\n\t\"[vdso]\",\n\t\"[vsyscall]\",\n\t\"[vectors]\",\n};\n\n/* default blacklist for maps */\nstatic const char * const _blacklist_maps[] = {\n\t\"locale/locale-archive\",\n\t\"/LC_MESSAGES/\",\n\t\"gconv/gconv-modules.cache\",\n\t\"/ld-2.\",\t\t/* not using dlopen,dlsym during mlock */\n\t\"/libaio.so.\",\t\t/* not using aio during mlock */\n\t\"/libattr.so.\",\t\t/* not using during mlock (udev) */\n\t\"/libblkid.so.\",\t/* not using blkid during mlock (udev) */\n\t\"/libbz2.so.\",\t\t/* not using during mlock (udev) */\n\t\"/libcap.so.\",\t\t/* not using during mlock (systemd) */\n\t\"/libdl-\",\t\t/* not using dlopen,dlsym during mlock */\n\t\"/libdw-\",\t\t/* not using during mlock (udev) */\n\t\"/libelf-\",\t\t/* not using during mlock (udev) */\n\t\"/libgcrypt.so.\",\t/* not using during mlock (systemd) */\n\t\"/libgpg-error.so.\",\t/* not using gpg-error during mlock (systemd) */\n\t\"/liblz4.so.\",\t\t/* not using lz4 during mlock (systemd) */\n\t\"/liblzma.so.\",\t\t/* not using lzma during mlock (systemd) */\n\t\"/libmount.so.\",\t/* not using mount during mlock (udev) */\n\t\"/libncurses.so.\",\t/* not using ncurses during mlock */\n\t\"/libpcre.so.\",\t\t/* not using pcre during mlock (selinux) */\n\t\"/libpcre2-\",\t\t/* not using pcre during mlock (selinux) */\n\t\"/libreadline.so.\",\t/* not using readline during mlock */\n\t\"/libresolv-\",\t\t/* not using during mlock (udev) */\n\t\"/libselinux.so.\",\t/* not using selinux during mlock */\n\t\"/libsepol.so.\",\t/* not using sepol during mlock */\n\t\"/libsystemd.so.\",\t/* not using systemd during mlock */\n\t\"/libtinfo.so.\",\t/* not using tinfo during mlock */\n\t\"/libudev.so.\",\t\t/* not using udev during mlock */\n\t\"/libuuid.so.\",\t\t/* not using uuid during mlock (blkid) */\n\t\"/libz.so.\",\t\t/* not using during mlock (udev) */\n\t\"/etc/selinux\",\t\t/* not using selinux during mlock */\n\t/* \"/libdevmapper-event.so\" */\n};\n\ntypedef enum { LVM_MLOCK, LVM_MUNLOCK } lvmlock_t;\n\nstatic unsigned _use_mlockall;\nstatic int _maps_fd;\nstatic size_t _maps_len = 8192; /* Initial buffer size for reading /proc/self/maps */\nstatic char *_maps_buffer;\nstatic char _procselfmaps[PATH_MAX] = \"\";\n#define SELF_MAPS \"/self/maps\"\n\nstatic size_t _mstats; /* statistic for maps locking */\n\nstatic void _touch_memory(void *mem, size_t size)\n{\n\tsize_t pagesize = lvm_getpagesize();\n\tchar *pos = mem;\n\tchar *end = pos + size - sizeof(long);\n\n\twhile (pos < end) {\n\t\t*(long *) pos = 1;\n\t\tpos += pagesize;\n\t}\n}\n\nstatic void _allocate_memory(void)\n{\n#ifndef VALGRIND_POOL\n\tvoid *stack_mem;\n\tstruct rlimit limit;\n\tint i, area = 0, missing = _size_malloc_tmp, max_areas = 32, hblks;\n\tchar *areas[max_areas];\n\n\t/* Check if we could preallocate requested stack */\n\tif ((getrlimit (RLIMIT_STACK, &limit) == 0) &&\n\t    ((_size_stack * 2) < limit.rlim_cur) &&\n\t    ((stack_mem = alloca(_size_stack))))\n\t\t_touch_memory(stack_mem, _size_stack);\n\t/* FIXME else warn user setting got ignored */\n\n        /*\n         *  When a brk() fails due to fragmented address space (which sometimes\n         *  happens when we try to grab 8M or so), glibc will make a new\n         *  arena. In this arena, the rules for using \u201cdirect\u201d mmap are relaxed,\n         *  circumventing the MAX_MMAPs and MMAP_THRESHOLD settings. We can,\n         *  however, detect when this happens with mallinfo() and try to co-opt\n         *  malloc into using MMAP as a MORECORE substitute instead of returning\n         *  MMAP'd memory directly. Since MMAP-as-MORECORE does not munmap the\n         *  memory on free(), this is good enough for our purposes.\n         */\n\twhile (missing > 0) {\n\t\tstruct mallinfo inf = mallinfo();\n\t\thblks = inf.hblks;\n\n\t\tif ((areas[area] = malloc(_size_malloc_tmp)))\n\t\t\t_touch_memory(areas[area], _size_malloc_tmp);\n\n\t\tinf = mallinfo();\n\n\t\tif (hblks < inf.hblks) {\n\t\t\t/* malloc cheated and used mmap, even though we told it\n\t\t\t   not to; we try with twice as many areas, each half\n\t\t\t   the size, to circumvent the faulty logic in glibc */\n\t\t\tfree(areas[area]);\n\t\t\t_size_malloc_tmp /= 2;\n\t\t} else {\n\t\t\t++ area;\n\t\t\tmissing -= _size_malloc_tmp;\n\t\t}\n\n\t\tif (area == max_areas && missing > 0) {\n\t\t\t/* Too bad. Warn the user and proceed, as things are\n\t\t\t * most likely going to work out anyway. */\n\t\t\tlog_warn(\"WARNING: Failed to reserve memory, %d bytes missing.\", missing);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((_malloc_mem = malloc(_size_malloc)))\n\t\t_touch_memory(_malloc_mem, _size_malloc);\n\n\t/* free up the reserves so subsequent malloc's can use that memory */\n\tfor (i = 0; i < area; ++i)\n\t\tfree(areas[i]);\n#endif\n}\n\nstatic void _release_memory(void)\n{\n\tfree(_malloc_mem);\n}\n\n/*\n * mlock/munlock memory areas from /proc/self/maps\n * format described in kernel/Documentation/filesystem/proc.txt\n */\nstatic int _maps_line(const struct dm_config_node *cn, lvmlock_t lock,\n\t\t      const char *line, size_t *mstats)\n{\n\tconst struct dm_config_value *cv;\n\tlong from, to;\n\tint pos;\n\tunsigned i;\n\tchar fr, fw, fx, fp;\n\tsize_t sz;\n\tconst char *lock_str = (lock == LVM_MLOCK) ? \"mlock\" : \"munlock\";\n\n\tif (sscanf(line, \"%lx-%lx %c%c%c%c%n\",\n\t\t   &from, &to, &fr, &fw, &fx, &fp, &pos) != 6) {\n\t\tlog_error(\"Failed to parse maps line: %s\", line);\n\t\treturn 0;\n\t}\n\n\t/* Select readable maps */\n\tif (fr != 'r') {\n\t\tlog_debug_mem(\"%s area unreadable %s : Skipping.\", lock_str, line);\n\t\treturn 1;\n\t}\n\n\t/* always ignored areas */\n\tfor (i = 0; i < DM_ARRAY_SIZE(_ignore_maps); ++i)\n\t\tif (strstr(line + pos, _ignore_maps[i])) {\n\t\t\tlog_debug_mem(\"%s ignore filter '%s' matches '%s': Skipping.\",\n\t\t\t\t      lock_str, _ignore_maps[i], line);\n\t\t\treturn 1;\n\t\t}\n\n\tsz = to - from;\n\tif (!cn) {\n\t\t/* If no blacklist configured, use an internal set */\n\t\tfor (i = 0; i < DM_ARRAY_SIZE(_blacklist_maps); ++i)\n\t\t\tif (strstr(line + pos, _blacklist_maps[i])) {\n\t\t\t\tlog_debug_mem(\"%s default filter '%s' matches '%s': Skipping.\",\n\t\t\t\t\t      lock_str, _blacklist_maps[i], line);\n\t\t\t\treturn 1;\n\t\t\t}\n\t} else {\n\t\tfor (cv = cn->v; cv; cv = cv->next) {\n\t\t\tif ((cv->type != DM_CFG_STRING) || !cv->v.str[0])\n\t\t\t\tcontinue;\n\t\t\tif (strstr(line + pos, cv->v.str)) {\n\t\t\t\tlog_debug_mem(\"%s_filter '%s' matches '%s': Skipping.\",\n\t\t\t\t\t      lock_str, cv->v.str, line);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef HAVE_VALGRIND\n\t/*\n\t * Valgrind is continually eating memory while executing code\n\t * so we need to deactivate check of locked memory size\n\t */\n#ifndef VALGRIND_POOL\n\tif (RUNNING_ON_VALGRIND)\n#endif\n\t\tsz -= sz; /* = 0, but avoids getting warning about dead assigment */\n\n#endif\n\t*mstats += sz;\n\tlog_debug_mem(\"%s %10ldKiB %12lx - %12lx %c%c%c%c%s\", lock_str,\n\t\t      ((long)sz + 1023) / 1024, from, to, fr, fw, fx, fp, line + pos);\n\n\tif (lock == LVM_MLOCK) {\n\t\tif (mlock((const void*)from, sz) < 0) {\n\t\t\tlog_sys_error(\"mlock\", line);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (munlock((const void*)from, sz) < 0) {\n\t\t\tlog_sys_error(\"munlock\", line);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int _memlock_maps(struct cmd_context *cmd, lvmlock_t lock, size_t *mstats)\n{\n\tconst struct dm_config_node *cn;\n\tchar *line, *line_end;\n\tsize_t len;\n\tssize_t n;\n\tint ret = 1;\n\n\tif (_use_mlockall) {\n#ifdef MCL_CURRENT\n\t\tif (lock == LVM_MLOCK) {\n\t\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE)) {\n\t\t\t\tlog_sys_error(\"mlockall\", \"\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (munlockall()) {\n\t\t\t\tlog_sys_error(\"munlockall\", \"\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n#else\n\t\treturn 0;\n#endif\n\t}\n\n\t/* Reset statistic counters */\n\t*mstats = 0;\n\n\t/* read mapping into a single memory chunk without reallocation\n\t * in the middle of reading maps file */\n\tfor (len = 0;;) {\n\t\tif (!_maps_buffer || len >= _maps_len) {\n\t\t\tif (_maps_buffer)\n\t\t\t\t_maps_len *= 2;\n\t\t\tif (!(line = realloc(_maps_buffer, _maps_len))) {\n\t\t\t\tlog_error(\"Allocation of maps buffer failed.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t_maps_buffer = line;\n\t\t}\n\t\tif (lseek(_maps_fd, 0, SEEK_SET))\n\t\t\tlog_sys_error(\"lseek\", _procselfmaps);\n\t\tfor (len = 0 ; len < _maps_len; len += n) {\n\t\t\tif (!(n = read(_maps_fd, _maps_buffer + len, _maps_len - len)))\n\t\t\t\tbreak; /* EOF */\n\t\t\tif (n == -1) {\n\t\t\t\tlog_sys_error(\"read\", _procselfmaps);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (len < _maps_len) { /* fits in buffer */\n\t\t\t_maps_buffer[len] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tline = _maps_buffer;\n\tcn = find_config_tree_array(cmd, activation_mlock_filter_CFG, NULL);\n\n\twhile ((line_end = strchr(line, '\\n'))) {\n\t\t*line_end = '\\0'; /* remove \\n */\n\t\tif (!_maps_line(cn, lock, line, mstats))\n\t\t\tret = 0;\n\t\tline = line_end + 1;\n\t}\n\n\tlog_debug_mem(\"%socked %ld bytes\",\n\t\t      (lock == LVM_MLOCK) ? \"L\" : \"Unl\", (long)*mstats);\n\n\treturn ret;\n}\n\n#ifdef DEBUG_MEMLOCK\n/*\n * LVM is not supposed to use mmap while devices are suspended.\n * This code causes a core dump if gets called.\"\n */\n#  ifdef __i386__\n#    define ARCH_X86\n#  endif /* __i386__ */\n#  ifdef __x86_64__\n#    ifndef ARCH_X86\n#      define ARCH_X86\n#    endif /* ARCH_X86 */\n#  endif /* __x86_64__ */\n\n#endif /* DEBUG_MEMLOCK */\n\n#ifdef ARCH_X86\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <dlfcn.h>\nstatic const unsigned char _instruction_hlt = 0x94;\nstatic char _mmap_orig;\nstatic unsigned char *_mmap_addr;\n#ifdef __i386__\nstatic char _mmap64_orig;\nstatic unsigned char *_mmap64_addr;\n#endif /* __i386__ */\n#endif /* ARCH_X86 */\n\nstatic int _disable_mmap(void)\n{\n#ifdef ARCH_X86\n\tvolatile unsigned char *abs_addr;\n\n\tif (!_mmap_addr) {\n\t\t_mmap_addr = (unsigned char *) dlsym(RTLD_NEXT, \"mmap\");\n\t\tif (_mmap_addr[0] == 0xff && _mmap_addr[1] == 0x25) { /* plt */\n#ifdef __x86_64__\n\t\t\tabs_addr = _mmap_addr + 6 + *(int32_t *)(_mmap_addr + 2);\n#endif /* __x86_64__ */\n#ifdef __i386__\n\t\t\tabs_addr = *(void **)(_mmap_addr + 2);\n#endif /* __i386__ */\n\t\t\t_mmap_addr = *(void **)abs_addr;\n\t\t} else\n\t\t\tlog_debug_mem(\"Can't find PLT jump entry assuming -fPIE linkage.\");\n\t\tif (mprotect((void *)((unsigned long)_mmap_addr & ~4095UL), 4096, PROT_READ|PROT_WRITE|PROT_EXEC)) {\n\t\t\tlog_sys_error(\"mprotect\", \"\");\n\t\t\t_mmap_addr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t_mmap_orig = *_mmap_addr;\n\t}\n\tlog_debug_mem(\"Remapping mmap entry %02x to %02x.\", _mmap_orig, _instruction_hlt);\n\t*_mmap_addr = _instruction_hlt;\n\n#ifdef __i386__\n\tif (!_mmap64_addr) {\n\t\t_mmap64_addr = (unsigned char *) dlsym(RTLD_NEXT, \"mmap64\");\n\t\tif (_mmap64_addr[0] == 0xff && _mmap64_addr[1] == 0x25) {\n\t\t\tabs_addr = *(void **)(_mmap64_addr + 2);\n\t\t\t_mmap64_addr = *(void **)abs_addr;\n\t\t} /* Can't find PLT jump entry assuming -fPIE linkage */\n\t\tif (mprotect((void *)((unsigned long)_mmap64_addr & ~4095UL), 4096, PROT_READ|PROT_WRITE|PROT_EXEC)) {\n\t\t\tlog_sys_error(\"mprotect\", \"\");\n\t\t\t_mmap64_addr = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\t_mmap64_orig = *_mmap64_addr;\n\t}\n\t*_mmap64_addr = INSTRUCTION_HLT;\n#endif /* __i386__ */\n#endif /* ARCH_X86 */\n\treturn 1;\n}\n\nstatic int _restore_mmap(void)\n{\n#ifdef ARCH_X86\n\tif (_mmap_addr)\n\t\t*_mmap_addr = _mmap_orig;\n#ifdef __i386__\n\tif (_mmap64_addr)\n\t\t*_mmap64_addr = _mmap64_orig;\n#endif /* __i386__ */\n\tlog_debug_mem(\"Restored mmap entry.\");\n#endif /* ARCH_X86 */\n\treturn 1;\n}\nstatic void _raise_priority(struct cmd_context *cmd)\n{\n\tif (_priority_raised)\n\t\treturn;\n\n\t_priority_raised = 1;\n\terrno = 0;\n\tif (((_priority = getpriority(PRIO_PROCESS, 0)) == -1) && errno)\n\t\tlog_sys_debug(\"getpriority\", \"\");\n\telse if (_default_priority < _priority) {\n\t\tif (setpriority(PRIO_PROCESS, 0, _default_priority) == 0)\n\t\t\tlog_debug_activation(\"Raised task priority %d -> %d.\",\n\t\t\t\t\t     _priority, _default_priority);\n\t\telse\n\t\t\tlog_warn(\"WARNING: setpriority %d failed: %s.\",\n\t\t\t\t _default_priority, strerror(errno));\n\t}\n}\n\nstatic void _restore_priority_if_possible(struct cmd_context *cmd)\n{\n\tif (!_priority_raised || _critical_section || _memlock_count_daemon)\n\t\treturn;\n\n\tif (setpriority(PRIO_PROCESS, 0, _priority) == 0)\n\t\tlog_debug_activation(\"Restoring original task priority %d.\", _priority);\n\telse\n\t\tlog_warn(\"WARNING: setpriority %u failed: %s.\",\n\t\t\t _priority, strerror(errno));\n\n\t_priority_raised = 0;\n}\n\n/* Stop memory getting swapped out */\nstatic void _lock_mem(struct cmd_context *cmd)\n{\n\t_allocate_memory();\n\t(void)strerror(0);\t\t/* Force libc.mo load */\n\t(void)dm_udev_get_sync_support(); /* udev is initialized */\n\tlog_very_verbose(\"Locking memory\");\n\n\t/*\n\t * For daemon we need to use mlockall()\n\t * so even future adition of thread which may not even use lvm lib\n\t * will not block memory locked thread\n\t * Note: assuming _memlock_count_daemon is updated before _memlock_count\n\t */\n\t_use_mlockall = _memlock_count_daemon ? 1 :\n\t\tfind_config_tree_bool(cmd, activation_use_mlockall_CFG, NULL);\n\n\tif (!_use_mlockall) {\n\t\tif (!*_procselfmaps &&\n\t\t    dm_snprintf(_procselfmaps, sizeof(_procselfmaps),\n\t\t\t\t\"%s\" SELF_MAPS, cmd->proc_dir) < 0) {\n\t\t\tlog_error(\"proc_dir too long\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!(_maps_fd = open(_procselfmaps, O_RDONLY))) {\n\t\t\tlog_sys_error(\"open\", _procselfmaps);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!_disable_mmap())\n\t\t\tstack;\n\t}\n\n\tif (!_memlock_maps(cmd, LVM_MLOCK, &_mstats))\n\t\tstack;\n}\n\nstatic void _unlock_mem(struct cmd_context *cmd)\n{\n\tsize_t unlock_mstats;\n\n\tlog_very_verbose(\"Unlocking memory\");\n\n\tif (!_memlock_maps(cmd, LVM_MUNLOCK, &unlock_mstats))\n\t\tstack;\n\n\tif (!_use_mlockall) {\n\t\t_restore_mmap();\n\t\tif (close(_maps_fd))\n\t\t\tlog_sys_error(\"close\", _procselfmaps);\n\t\tfree(_maps_buffer);\n\t\t_maps_buffer = NULL;\n\t\tif (_mstats < unlock_mstats) {\n\t\t\tif ((_mstats + lvm_getpagesize()) < unlock_mstats)\n\t\t\t\tlog_error(INTERNAL_ERROR\n\t\t\t\t\t  \"Reserved memory (%ld) not enough: used %ld. Increase activation/reserved_memory?\",\n\t\t\t\t\t  (long)_mstats, (long)unlock_mstats);\n\t\t\telse\n\t\t\t\t/* FIXME Believed due to incorrect use of yes_no_prompt while locks held */\n\t\t\t\tlog_debug_mem(\"Suppressed internal error: Maps lock %ld < unlock %ld, a one-page difference.\",\n\t\t\t\t\t      (long)_mstats, (long)unlock_mstats);\n\t\t}\n\t}\n\n\t_restore_priority_if_possible(cmd);\n\n\t_release_memory();\n}\n\nstatic void _lock_mem_if_needed(struct cmd_context *cmd)\n{\n\tlog_debug_mem(\"Lock:   Memlock counters: prioritized:%d locked:%d critical:%d daemon:%d suspended:%d\",\n\t\t      _priority_raised, _mem_locked, _critical_section, _memlock_count_daemon, dm_get_suspended_counter());\n\tif (!_mem_locked &&\n\t    ((_critical_section + _memlock_count_daemon) == 1)) {\n\t\t_mem_locked = 1;\n\t\t_lock_mem(cmd);\n\t}\n}\n\nstatic void _unlock_mem_if_possible(struct cmd_context *cmd)\n{\n\tlog_debug_mem(\"Unlock: Memlock counters: prioritized:%d locked:%d critical:%d daemon:%d suspended:%d\",\n\t\t      _priority_raised, _mem_locked, _critical_section, _memlock_count_daemon, dm_get_suspended_counter());\n\tif (_mem_locked &&\n\t    !_critical_section &&\n\t    !_memlock_count_daemon) {\n\t\t_unlock_mem(cmd);\n\t\t_mem_locked = 0;\n\t}\n}\n\n/*\n * Critical section is only triggered with suspending reason.\n * Other reasons only raise process priority so the table manipulation\n * remains fast.\n *\n * Memory stays locked until 'memlock_unlock()' is called so when possible\n * it may stay locked across multiple crictical section entrances.\n */\nvoid critical_section_inc(struct cmd_context *cmd, const char *reason)\n{\n\tif (!_critical_section &&\n\t    (strcmp(reason, \"suspending\") == 0)) {\n\t\t/*\n\t\t * Profiles are loaded on-demand so make sure that before\n\t\t * entering the critical section all needed profiles are\n\t\t * loaded to avoid the disk access later.\n\t\t */\n\t\t(void) load_pending_profiles(cmd);\n\t\t_critical_section = 1;\n\t\tlog_debug_activation(\"Entering critical section (%s).\", reason);\n\t\t_lock_mem_if_needed(cmd);\n\t} else\n\t\tlog_debug_activation(\"Entering prioritized section (%s).\", reason);\n\n\t_raise_priority(cmd);\n\t_prioritized_section++;\n}\n\nvoid critical_section_dec(struct cmd_context *cmd, const char *reason)\n{\n\tif (_critical_section && !dm_get_suspended_counter()) {\n\t\t_critical_section = 0;\n\t\tlog_debug_activation(\"Leaving critical section (%s).\", reason);\n\t} else\n\t\tlog_debug_activation(\"Leaving section (%s).\", reason);\n\n\tif (_prioritized_section > 0)\n\t\t_prioritized_section--;\n}\n\nint critical_section(void)\n{\n\treturn _critical_section;\n}\n\nint prioritized_section(void)\n{\n\treturn _prioritized_section;\n}\n\n/*\n * The memlock_*_daemon functions will force the mlockall() call that we need\n * to stay in memory, but they will have no effect on device scans (unlike\n * normal critical_section_inc/dec). Memory is kept locked as long as either\n * of critical_section or memlock_daemon is in effect.\n */\n\nvoid memlock_inc_daemon(struct cmd_context *cmd)\n{\n\t++_memlock_count_daemon;\n\tif (_memlock_count_daemon == 1 && _critical_section > 0)\n\t\tlog_error(INTERNAL_ERROR \"_memlock_inc_daemon used in critical section.\");\n\tlog_debug_mem(\"memlock_count_daemon inc to %d\", _memlock_count_daemon);\n\t_lock_mem_if_needed(cmd);\n\t_raise_priority(cmd);\n}\n\nvoid memlock_dec_daemon(struct cmd_context *cmd)\n{\n\tif (!_memlock_count_daemon)\n\t\tlog_error(INTERNAL_ERROR \"_memlock_count_daemon has dropped below 0.\");\n\t--_memlock_count_daemon;\n\tlog_debug_mem(\"memlock_count_daemon dec to %d\", _memlock_count_daemon);\n\t_unlock_mem_if_possible(cmd);\n}\n\nvoid memlock_init(struct cmd_context *cmd)\n{\n\t/* When threaded, caller already limited stack size so just use the default. */\n\t_size_stack = 1024ULL * (cmd->threaded ? DEFAULT_RESERVED_STACK :\n\t\t\t\t find_config_tree_int(cmd, activation_reserved_stack_CFG, NULL));\n\t_size_malloc_tmp = find_config_tree_int(cmd, activation_reserved_memory_CFG, NULL) * 1024ULL;\n\t_default_priority = find_config_tree_int(cmd, activation_process_priority_CFG, NULL);\n}\n\nvoid memlock_reset(void)\n{\n\tlog_debug_mem(\"memlock reset.\");\n\t_mem_locked = 0;\n\t_priority_raised = 0;\n\t_critical_section = 0;\n\t_prioritized_section = 0;\n\t_memlock_count_daemon = 0;\n}\n\nvoid memlock_unlock(struct cmd_context *cmd)\n{\n\t_unlock_mem_if_possible(cmd);\n\t_restore_priority_if_possible(cmd);\n}\n\nint memlock_count_daemon(void)\n{\n\treturn _memlock_count_daemon;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-lvm2-2.03.01-boqkhxcjv5mjui6v7ajkw3ttrkzbv2yi/spack-src/daemons/dmeventd/dmeventd.c": "/*\n * Copyright (C) 2005-2015 Red Hat, Inc. All rights reserved.\n *\n * This file is part of the device-mapper userspace tools.\n *\n * This copyrighted material is made available to anyone wishing to use,\n * modify, copy, or redistribute it subject to the terms and conditions\n * of the GNU Lesser General Public License v.2.1.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/*\n * dmeventd - dm event daemon to monitor active mapped devices\n */\n\n#include \"device_mapper/misc/dmlib.h\"\n#include \"base/memory/zalloc.h\"\n#include \"device_mapper/misc/dm-logging.h\"\n\n#include \"daemons/dmeventd/libdevmapper-event.h\"\n#include \"dmeventd.h\"\n\n#include \"tools/tool.h\"\n\n#include <dlfcn.h>\n#include <pthread.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <signal.h>\n#include <arpa/inet.h>\t\t/* for htonl, ntohl */\n#include <fcntl.h>\t\t/* for musl libc */\n\n#ifdef __linux__\n/*\n * Kernel version 2.6.36 and higher has\n * new OOM killer adjustment interface.\n */\n#  define OOM_ADJ_FILE_OLD \"/proc/self/oom_adj\"\n#  define OOM_ADJ_FILE \"/proc/self/oom_score_adj\"\n\n/* From linux/oom.h */\n/* Old interface */\n#  define OOM_DISABLE (-17)\n#  define OOM_ADJUST_MIN (-16)\n/* New interface */\n#  define OOM_SCORE_ADJ_MIN (-1000)\n\n/* Systemd on-demand activation support */\n#  define SD_RUNTIME_UNIT_FILE_DIR DEFAULT_DM_RUN_DIR \"/systemd/system/\"\n#  define SD_ACTIVATION_ENV_VAR_NAME \"SD_ACTIVATION\"\n#  define SD_LISTEN_PID_ENV_VAR_NAME \"LISTEN_PID\"\n#  define SD_LISTEN_FDS_ENV_VAR_NAME \"LISTEN_FDS\"\n#  define SD_LISTEN_FDS_START 3\n#  define SD_FD_FIFO_SERVER SD_LISTEN_FDS_START\n#  define SD_FD_FIFO_CLIENT (SD_LISTEN_FDS_START + 1)\n\n#endif\n\n#include <syslog.h>\n\n#define DM_SIGNALED_EXIT  1\n#define DM_SCHEDULED_EXIT 2\nstatic volatile sig_atomic_t _exit_now = 0;\t/* set to '1' when signal is given to exit */\n\n/* List (un)link macros. */\n#define\tLINK(x, head)\t\tdm_list_add(head, &(x)->list)\n#define\tLINK_DSO(dso)\t\tLINK(dso, &_dso_registry)\n#define\tLINK_THREAD(thread)\tLINK(thread, &_thread_registry)\n\n#define\tUNLINK(x)\t\tdm_list_del(&(x)->list)\n#define\tUNLINK_DSO(x)\t\tUNLINK(x)\n#define\tUNLINK_THREAD(x)\tUNLINK(x)\n\n#define DAEMON_NAME \"dmeventd\"\n\n/*\n  Global mutex for thread list access. Has to be held when:\n  - iterating thread list\n  - adding or removing elements from thread list\n  - changing or reading thread_status's fields:\n    processing, status, events\n  Use _lock_mutex() and _unlock_mutex() to hold/release it\n*/\nstatic pthread_mutex_t _global_mutex;\n\nstatic const size_t THREAD_STACK_SIZE = 300 * 1024;\n\n/* Default idle exit timeout 1 hour (in seconds) */\nstatic const time_t DMEVENTD_IDLE_EXIT_TIMEOUT = 60 * 60;\n\nstatic int _debug_level = 0;\nstatic int _use_syslog = 1;\nstatic int _systemd_activation = 0;\nstatic int _foreground = 0;\nstatic int _restart = 0;\nstatic time_t _idle_since = 0;\nstatic char **_initial_registrations = 0;\n\n/* FIXME Make configurable at runtime */\n\n/* All libdm messages */\n__attribute__((format(printf, 5, 6)))\nstatic void _libdm_log(int level, const char *file, int line,\n\t\t       int dm_errno_or_class, const char *format, ...)\n{\n\tva_list ap;\n\tva_start(ap, format);\n\tdm_event_log(\"#dm\", level, file, line, dm_errno_or_class, format, ap);\n\tva_end(ap);\n}\n\n/* All dmeventd messages */\n#undef LOG_MESG\n#define LOG_MESG(l, f, ln, e, x...) _dmeventd_log(l, f, ln, e, ## x)\n__attribute__((format(printf, 5, 6)))\nstatic void _dmeventd_log(int level, const char *file, int line,\n\t\t\t  int dm_errno_or_class, const char *format, ...)\n{\n\tva_list ap;\n\tva_start(ap, format);\n\tdm_event_log(\"dmeventd\", level, file, line, dm_errno_or_class, format, ap);\n\tva_end(ap);\n}\n\n#ifdef DEBUG\n#  define DEBUGLOG  log_debug\nstatic const char *decode_cmd(uint32_t cmd)\n{\n\tswitch (cmd) {\n\tcase DM_EVENT_CMD_ACTIVE:\t\t\treturn \"ACTIVE\";\n\tcase DM_EVENT_CMD_REGISTER_FOR_EVENT:\t\treturn \"REGISTER_FOR_EVENT\";\n\tcase DM_EVENT_CMD_UNREGISTER_FOR_EVENT:\t\treturn \"UNREGISTER_FOR_EVENT\";\n\tcase DM_EVENT_CMD_GET_REGISTERED_DEVICE:\treturn \"GET_REGISTERED_DEVICE\";\n\tcase DM_EVENT_CMD_GET_NEXT_REGISTERED_DEVICE:\treturn \"GET_NEXT_REGISTERED_DEVICE\";\n\tcase DM_EVENT_CMD_SET_TIMEOUT:\t\t\treturn \"SET_TIMEOUT\";\n\tcase DM_EVENT_CMD_GET_TIMEOUT:\t\t\treturn \"GET_TIMEOUT\";\n\tcase DM_EVENT_CMD_HELLO:\t\t\treturn \"HELLO\";\n\tcase DM_EVENT_CMD_DIE:\t\t\t\treturn \"DIE\";\n\tcase DM_EVENT_CMD_GET_STATUS:\t\t\treturn \"GET_STATUS\";\n\tcase DM_EVENT_CMD_GET_PARAMETERS:\t\treturn \"GET_PARAMETERS\";\n\tdefault:\t\t\t\t\treturn \"unknown\";\n\t}\n}\n\n#else\n#  define DEBUGLOG(fmt, args...) do { } while (0)\n#endif\n\n/* Data kept about a DSO. */\nstruct dso_data {\n\tstruct dm_list list;\n\n\tchar *dso_name;\t\t/* DSO name (eg, \"evms\", \"dmraid\", \"lvm2\"). */\n\n\tvoid *dso_handle;\t/* Opaque handle as returned from dlopen(). */\n\tunsigned int ref_count;\t/* Library reference count. */\n\n\t/*\n\t * Event processing.\n\t *\n\t * The DSO can do whatever appropriate steps if an event\n\t * happens such as changing the mapping in case a mirror\n\t * fails, update the application metadata etc.\n\t *\n\t * This function gets a dm_task that is a result of\n\t * DM_DEVICE_WAITEVENT ioctl (results equivalent to\n\t * DM_DEVICE_STATUS). It should not destroy it.\n\t * The caller must dispose of the task.\n\t */\n\tvoid (*process_event)(struct dm_task *dmt, enum dm_event_mask event, void **user);\n\n\t/*\n\t * Device registration.\n\t *\n\t * When an application registers a device for an event, the DSO\n\t * can carry out appropriate steps so that a later call to\n\t * the process_event() function is sane (eg, read metadata\n\t * and activate a mapping).\n\t */\n\tint (*register_device)(const char *device, const char *uuid, int major,\n\t\t\t       int minor, void **user);\n\n\t/*\n\t * Device unregistration.\n\t *\n\t * In case all devices of a mapping (eg, RAID10) are unregistered\n\t * for events, the DSO can recognize this and carry out appropriate\n\t * steps (eg, deactivate mapping, metadata update).\n\t */\n\tint (*unregister_device)(const char *device, const char *uuid,\n\t\t\t\t int major, int minor, void **user);\n};\nstatic DM_LIST_INIT(_dso_registry);\n\n/* Structure to keep parsed register variables from client message. */\nstruct message_data {\n\tchar *id;\n\tchar *dso_name;\t\t/* Name of DSO. */\n\tchar *device_uuid;\t/* Mapped device path. */\n\tchar *events_str;\t/* Events string as fetched from message. */\n\tenum dm_event_mask events_field;\t/* Events bitfield. */\n\tchar *timeout_str;\n\tuint32_t timeout_secs;\n\tstruct dm_event_daemon_message *msg;\t/* Pointer to message buffer. */\n};\n\n/* There are three states a thread can attain. */\nenum {\n\tDM_THREAD_REGISTERING,\t/* Registering, transitions to RUNNING */\n\tDM_THREAD_RUNNING,\t/* Working on events, transitions to DONE */\n\tDM_THREAD_DONE\t\t/* Terminated and cleanup is pending */\n};\n\n/*\n * Housekeeping of thread+device states.\n *\n * One thread per mapped device which can block on it until an event\n * occurs and the event processing function of the DSO gets called.\n */\nstruct thread_status {\n\tstruct dm_list list;\n\n\tpthread_t thread;\n\n\tstruct dso_data *dso_data;\t/* DSO this thread accesses. */\n\n\tstruct {\n\t\tchar *uuid;\n\t\tchar *name;\n\t\tint major, minor;\n\t} device;\n\tint processing;\t\t/* Set when event is being processed */\n\n\tint status;\t\t/* See DM_THREAD_{REGISTERING,RUNNING,DONE} */\n\n\tint events;\t\t/* bitfield for event filter. */\n\tint current_events;\t/* bitfield for occured events. */\n\tstruct dm_task *wait_task;\n\tint pending;\t\t/* Set when event filter change is pending */\n\ttime_t next_time;\n\tuint32_t timeout;\n\tstruct dm_list timeout_list;\n\tvoid *dso_private; /* dso per-thread status variable */\n\t/* TODO per-thread mutex */\n};\n\nstatic DM_LIST_INIT(_thread_registry);\nstatic DM_LIST_INIT(_thread_registry_unused);\n\nstatic int _timeout_running;\nstatic DM_LIST_INIT(_timeout_registry);\nstatic pthread_mutex_t _timeout_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t _timeout_cond = PTHREAD_COND_INITIALIZER;\n\n\n/**********\n *   DSO\n **********/\n\n/* DSO data allocate/free. */\nstatic void _free_dso_data(struct dso_data *data)\n{\n\tfree(data->dso_name);\n\tfree(data);\n}\n\nstatic struct dso_data *_alloc_dso_data(struct message_data *data)\n{\n\tstruct dso_data *ret = (typeof(ret)) zalloc(sizeof(*ret));\n\n\tif (!ret)\n\t\treturn_NULL;\n\n\tif (!(ret->dso_name = strdup(data->dso_name))) {\n\t\tfree(ret);\n\t\treturn_NULL;\n\t}\n\n\treturn ret;\n}\n\n/* DSO reference counting. */\nstatic void _lib_get(struct dso_data *data)\n{\n\tdata->ref_count++;\n}\n\nstatic void _lib_put(struct dso_data *data)\n{\n\tif (!--data->ref_count) {\n\t\tdlclose(data->dso_handle);\n\t\tUNLINK_DSO(data);\n\t\t_free_dso_data(data);\n\n\t\t/* Close control device if there is no plugin in-use */\n\t\tif (dm_list_empty(&_dso_registry)) {\n\t\t\tDEBUGLOG(\"Unholding control device.\");\n\t\t\tdm_hold_control_dev(0);\n\t\t\tdm_lib_release();\n\t\t\t_idle_since = time(NULL);\n\t\t}\n\t}\n}\n\n/* Find DSO data. */\nstatic struct dso_data *_lookup_dso(struct message_data *data)\n{\n\tstruct dso_data *dso_data, *ret = NULL;\n\n\tdm_list_iterate_items(dso_data, &_dso_registry)\n\t\tif (!strcmp(data->dso_name, dso_data->dso_name)) {\n\t\t\tret = dso_data;\n\t\t\tbreak;\n\t\t}\n\n\treturn ret;\n}\n\n/* Lookup DSO symbols we need. */\nstatic int _lookup_symbol(void *dl, void **symbol, const char *name)\n{\n\tif (!(*symbol = dlsym(dl, name)))\n\t\treturn_0;\n\n\treturn 1;\n}\n\nstatic int _lookup_symbols(void *dl, struct dso_data *data)\n{\n\treturn _lookup_symbol(dl, (void *) &data->process_event,\n\t\t\t     \"process_event\") &&\n\t    _lookup_symbol(dl, (void *) &data->register_device,\n\t\t\t  \"register_device\") &&\n\t    _lookup_symbol(dl, (void *) &data->unregister_device,\n\t\t\t  \"unregister_device\");\n}\n\n/* Load an application specific DSO. */\nstatic struct dso_data *_load_dso(struct message_data *data)\n{\n\tvoid *dl;\n\tstruct dso_data *ret;\n\tconst char *dlerr;\n\n\tif (!(dl = dlopen(data->dso_name, RTLD_NOW))) {\n\t\tdlerr = dlerror();\n\t\tgoto_bad;\n\t}\n\n\tif (!(ret = _alloc_dso_data(data))) {\n\t\tdlclose(dl);\n\t\tdlerr = \"no memory\";\n\t\tgoto_bad;\n\t}\n\n\tif (!(_lookup_symbols(dl, ret))) {\n\t\t_free_dso_data(ret);\n\t\tdlclose(dl);\n\t\tdlerr = \"symbols missing\";\n\t\tgoto_bad;\n\t}\n\n\t/* Keep control device open until last user closes */\n\tif (dm_list_empty(&_dso_registry)) {\n\t\tDEBUGLOG(\"Holding control device open.\");\n\t\tdm_hold_control_dev(1);\n\t\t_idle_since = 0;\n\t}\n\n\t/*\n\t * Keep handle to close the library once\n\t * we've got no references to it any more.\n\t */\n\tret->dso_handle = dl;\n\tLINK_DSO(ret);\n\n\treturn ret;\nbad:\n\tlog_error(\"dmeventd %s dlopen failed: %s.\", data->dso_name, dlerr);\n\tdata->msg->size = dm_asprintf(&(data->msg->data), \"%s %s dlopen failed: %s\",\n\t\t\t\t      data->id, data->dso_name, dlerr);\n\treturn NULL;\n}\n\n/************\n *  THREAD\n ************/\n\n/* Allocate/free the thread status structure for a monitoring thread. */\nstatic void _free_thread_status(struct thread_status *thread)\n{\n\n\t_lib_put(thread->dso_data);\n\tif (thread->wait_task)\n\t\tdm_task_destroy(thread->wait_task);\n\tfree(thread->device.uuid);\n\tfree(thread->device.name);\n\tfree(thread);\n}\n\n/* Note: events_field must not be 0, ensured by caller */\nstatic struct thread_status *_alloc_thread_status(const struct message_data *data,\n\t\t\t\t\t\t  struct dso_data *dso_data)\n{\n\tstruct thread_status *thread;\n\n\tif (!(thread = zalloc(sizeof(*thread)))) {\n\t\tlog_error(\"Cannot create new thread, out of memory.\");\n\t\treturn NULL;\n\t}\n\n\t_lib_get(dso_data);\n\tthread->dso_data = dso_data;\n\n\tif (!(thread->wait_task = dm_task_create(DM_DEVICE_WAITEVENT)))\n\t\tgoto_out;\n\n\tif (!dm_task_set_uuid(thread->wait_task, data->device_uuid))\n\t\tgoto_out;\n\n\tif (!(thread->device.uuid = strdup(data->device_uuid)))\n\t\tgoto_out;\n\n\t/* Until real name resolved, use UUID */\n\tif (!(thread->device.name = strdup(data->device_uuid)))\n\t\tgoto_out;\n\n\t/* runs ioctl and may register lvm2 pluging */\n\tthread->processing = 1;\n\tthread->status = DM_THREAD_REGISTERING;\n\n\tthread->events = data->events_field;\n\tthread->pending = DM_EVENT_REGISTRATION_PENDING;\n\tthread->timeout = data->timeout_secs;\n\tdm_list_init(&thread->timeout_list);\n\n\treturn thread;\n\nout:\n\t_free_thread_status(thread);\n\n\treturn NULL;\n}\n\n/*\n * Create a device monitoring thread.\n * N.B.  Error codes returned are positive.\n */\nstatic int _pthread_create_smallstack(pthread_t *t, void *(*fun)(void *), void *arg)\n{\n\tint r;\n\tpthread_t tmp;\n\tpthread_attr_t attr;\n\n\t/*\n\t * From pthread_attr_init man page:\n\t * POSIX.1-2001 documents an ENOMEM error for pthread_attr_init(); on\n\t * Linux these functions always succeed (but portable and future-proof\n\t * applications should nevertheless handle a possible error return).\n\t */\n\tif ((r = pthread_attr_init(&attr)) != 0) {\n\t\tlog_sys_error(\"pthread_attr_init\", \"\");\n\t\treturn r;\n\t}\n\n\t/*\n\t * We use a smaller stack since it gets preallocated in its entirety\n\t */\n\tpthread_attr_setstacksize(&attr, THREAD_STACK_SIZE + getpagesize());\n\n\t/*\n\t * If no-one will be waiting, we need to detach.\n\t */\n\tif (!t) {\n\t\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\t\tt = &tmp;\n\t}\n\n\tif ((r = pthread_create(t, &attr, fun, arg)))\n\t\tlog_sys_error(\"pthread_create\", \"\");\n\n\tpthread_attr_destroy(&attr);\n\n\treturn r;\n}\n\n/*\n * Fetch a string off src and duplicate it into *ptr.\n * Pay attention to zero-length and 'empty' strings ('-').\n */\n/* FIXME? move to libdevmapper to share with the client lib (need to\n   make delimiter a parameter then) */\nstatic int _fetch_string(char **ptr, char **src, const int delimiter)\n{\n\tint ret = 1;\n\tchar *p;\n\tsize_t len;\n\t*ptr = NULL; /* Empty field returns NULL pointer */\n\n\tif ((*src)[0] == '-') {\n\t\t/* Could be empty field '-', handle without allocation */\n\t\tif ((*src)[1] == '\\0') {\n\t\t\t(*src)++;\n\t\t\tgoto out;\n\t\t} else if ((*src)[1] == delimiter) {\n\t\t\t(*src) += 2;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((p = strchr(*src, delimiter))) {\n\t\tif (*src < p) {\n\t\t\t*p = 0; /* Temporary exit with \\0 */\n\t\t\tif (!(*ptr = strdup(*src))) {\n\t\t\t\tlog_error(\"Failed to fetch item %s.\", *src);\n\t\t\t\tret = 0; /* Allocation fail */\n\t\t\t}\n\t\t\t*p = delimiter;\n\t\t\t*src = p;\n\t\t}\n\t\t(*src)++; /* Skip delmiter, next field */\n\t} else if ((len = strlen(*src))) {\n\t\t/* No delimiter, item ends with '\\0' */\n\t\tif (!(*ptr = strdup(*src))) {\n\t\t\tlog_error(\"Failed to fetch last item %s.\", *src);\n\t\t\tret = 0; /* Fail */\n\t\t}\n\t\t*src += len + 1;\n\t}\nout:\n\treturn ret;\n}\n\n/* Free message memory. */\nstatic void _free_message(struct message_data *message_data)\n{\n\tfree(message_data->id);\n\tfree(message_data->dso_name);\n\tfree(message_data->device_uuid);\n\tfree(message_data->events_str);\n\tfree(message_data->timeout_str);\n}\n\n/* Parse a register message from the client. */\nstatic int _parse_message(struct message_data *message_data)\n{\n\tint ret = 0;\n\tstruct dm_event_daemon_message *msg = message_data->msg;\n\tchar *p = msg->data;\n\n\tif (!msg->data)\n\t\treturn 0;\n\n\t/*\n\t * Retrieve application identifier, mapped device\n\t * path and events # string from message.\n\t */\n\tif (_fetch_string(&message_data->id, &p, ' ') &&\n\t    _fetch_string(&message_data->dso_name, &p, ' ') &&\n\t    _fetch_string(&message_data->device_uuid, &p, ' ') &&\n\t    _fetch_string(&message_data->events_str, &p, ' ') &&\n\t    _fetch_string(&message_data->timeout_str, &p, ' ')) {\n\t\tif (message_data->events_str)\n\t\t\tmessage_data->events_field =\n\t\t\t\tatoi(message_data->events_str);\n\t\tif (message_data->timeout_str)\n\t\t\tmessage_data->timeout_secs =\n\t\t\t\tatoi(message_data->timeout_str)\n\t\t\t\t? : DM_EVENT_DEFAULT_TIMEOUT;\n\t\tret = 1;\n\t}\n\n\tfree(msg->data);\n\tmsg->data = NULL;\n\n\treturn ret;\n}\n\n/* Global mutex to lock access to lists et al. See _global_mutex\n   above. */\nstatic int _lock_mutex(void)\n{\n\treturn pthread_mutex_lock(&_global_mutex);\n}\n\nstatic int _unlock_mutex(void)\n{\n\treturn pthread_mutex_unlock(&_global_mutex);\n}\n\n/* Check, if a device exists. */\nstatic int _fill_device_data(struct thread_status *ts)\n{\n\tstruct dm_task *dmt;\n\tstruct dm_info dmi;\n\tint ret = 0;\n\n\tif (!(dmt = dm_task_create(DM_DEVICE_INFO)))\n\t\treturn 0;\n\n\tif (!dm_task_set_uuid(dmt, ts->device.uuid))\n\t\tgoto fail;\n\n\tif (!dm_task_run(dmt))\n\t\tgoto fail;\n\n\tfree(ts->device.name);\n\tif (!(ts->device.name = strdup(dm_task_get_name(dmt))))\n\t\tgoto fail;\n\n\tif (!dm_task_get_info(dmt, &dmi))\n\t\tgoto fail;\n\n\tts->device.major = dmi.major;\n\tts->device.minor = dmi.minor;\n\tdm_task_set_event_nr(ts->wait_task, dmi.event_nr);\n\n\tret = 1;\nfail:\n\tdm_task_destroy(dmt);\n\n\treturn ret;\n}\n\nstatic struct dm_task *_get_device_status(struct thread_status *ts)\n{\n\tstruct dm_task *dmt = dm_task_create(DM_DEVICE_STATUS);\n\n\tif (!dmt)\n\t\treturn_NULL;\n\n\tif (!dm_task_set_uuid(dmt, ts->device.uuid)) {\n\t\tdm_task_destroy(dmt);\n\t\treturn_NULL;\n\t}\n\n\t/* Non-blocking status read */\n\tif (!dm_task_no_flush(dmt))\n\t\tlog_warn(\"WARNING: Can't set no_flush for dm status.\");\n\n\tif (!dm_task_run(dmt)) {\n\t\tdm_task_destroy(dmt);\n\t\treturn_NULL;\n\t}\n\n\treturn dmt;\n}\n\n/*\n * Find an existing thread for a device.\n *\n * Mutex must be held when calling this.\n */\nstatic struct thread_status *_lookup_thread_status(struct message_data *data)\n{\n\tstruct thread_status *thread;\n\n\tdm_list_iterate_items(thread, &_thread_registry)\n\t\tif (!strcmp(data->device_uuid, thread->device.uuid))\n\t\t\treturn thread;\n\n\treturn NULL;\n}\n\nstatic int _get_status(struct message_data *message_data)\n{\n\tstruct dm_event_daemon_message *msg = message_data->msg;\n\tstruct thread_status *thread;\n\tint i = 0, j;\n\tint ret = -ENOMEM;\n\tint count;\n\tint size = 0, current;\n\tsize_t len;\n\tchar **buffers;\n\tchar *message;\n\n\t_lock_mutex();\n\tcount = dm_list_size(&_thread_registry);\n\tbuffers = alloca(sizeof(char*) * count);\n\tdm_list_iterate_items(thread, &_thread_registry) {\n\t\tif ((current = dm_asprintf(buffers + i, \"0:%d %s %s %u %\" PRIu32 \";\",\n\t\t\t\t\t   i, thread->dso_data->dso_name,\n\t\t\t\t\t   thread->device.uuid, thread->events,\n\t\t\t\t\t   thread->timeout)) < 0) {\n\t\t\t_unlock_mutex();\n\t\t\tgoto out;\n\t\t}\n\t\t++i;\n\t\tsize += current; /* count with trailing '\\0' */\n\t}\n\t_unlock_mutex();\n\n\tlen = strlen(message_data->id);\n\tmsg->size = size + len + 1;\n\tfree(msg->data);\n\tif (!(msg->data = malloc(msg->size)))\n\t\tgoto out;\n\n\tmemcpy(msg->data, message_data->id, len);\n\tmessage = msg->data + len;\n\t*message++ = ' ';\n\tfor (j = 0; j < i; ++j) {\n\t\tlen = strlen(buffers[j]);\n\t\tmemcpy(message, buffers[j], len);\n\t\tmessage += len;\n\t}\n\n\tret = 0;\n out:\n\tfor (j = 0; j < i; ++j)\n\t\tfree(buffers[j]);\n\n\treturn ret;\n}\n\nstatic int _get_parameters(struct message_data *message_data) {\n\tstruct dm_event_daemon_message *msg = message_data->msg;\n\tint size;\n\n\tfree(msg->data);\n\tif ((size = dm_asprintf(&msg->data, \"%s pid=%d daemon=%s exec_method=%s\",\n\t\t\t\tmessage_data->id, getpid(),\n\t\t\t\t_foreground ? \"no\" : \"yes\",\n\t\t\t\t_systemd_activation ? \"systemd\" : \"direct\")) < 0) {\n\t\tstack;\n\t\treturn -ENOMEM;\n\t}\n\n\tmsg->size = (uint32_t) size;\n\n\treturn 0;\n}\n\n/* Cleanup at exit. */\nstatic void _exit_dm_lib(void)\n{\n\tdm_lib_release();\n\tdm_lib_exit();\n}\n\nstatic void _exit_timeout(void *unused __attribute__((unused)))\n{\n\t_timeout_running = 0;\n\tpthread_mutex_unlock(&_timeout_mutex);\n}\n\n/* Wake up monitor threads every so often. */\nstatic void *_timeout_thread(void *unused __attribute__((unused)))\n{\n\tstruct thread_status *thread;\n\tstruct timespec timeout;\n\ttime_t curr_time;\n\tint ret;\n\n\tDEBUGLOG(\"Timeout thread starting.\");\n\tpthread_cleanup_push(_exit_timeout, NULL);\n\tpthread_mutex_lock(&_timeout_mutex);\n\n\twhile (!dm_list_empty(&_timeout_registry)) {\n\t\ttimeout.tv_sec = 0;\n\t\ttimeout.tv_nsec = 0;\n\t\tcurr_time = time(NULL);\n\n\t\tdm_list_iterate_items_gen(thread, &_timeout_registry, timeout_list) {\n\t\t\tif (thread->next_time <= curr_time) {\n\t\t\t\tthread->next_time = curr_time + thread->timeout;\n\t\t\t\t_lock_mutex();\n\t\t\t\tif (thread->processing) {\n\t\t\t\t\t/* Cannot signal processing monitoring thread */\n\t\t\t\t\tlog_debug(\"Skipping SIGALRM to processing Thr %x for timeout.\",\n\t\t\t\t\t\t  (int) thread->thread);\n\t\t\t\t} else {\n\t\t\t\t\tDEBUGLOG(\"Sending SIGALRM to Thr %x for timeout.\",\n\t\t\t\t\t\t (int) thread->thread);\n\t\t\t\t\tret = pthread_kill(thread->thread, SIGALRM);\n\t\t\t\t\tif (ret && (ret != ESRCH))\n\t\t\t\t\t\tlog_error(\"Unable to wakeup Thr %x for timeout: %s.\",\n\t\t\t\t\t\t\t  (int) thread->thread, strerror(ret));\n\t\t\t\t}\n\t\t\t\t_unlock_mutex();\n\t\t\t}\n\n\t\t\tif (thread->next_time < timeout.tv_sec || !timeout.tv_sec)\n\t\t\t\ttimeout.tv_sec = thread->next_time;\n\t\t}\n\n\t\tpthread_cond_timedwait(&_timeout_cond, &_timeout_mutex,\n\t\t\t\t       &timeout);\n\t}\n\n\tDEBUGLOG(\"Timeout thread finished.\");\n\tpthread_cleanup_pop(1);\n\n\treturn NULL;\n}\n\nstatic int _register_for_timeout(struct thread_status *thread)\n{\n\tint ret = 0;\n\n\tpthread_mutex_lock(&_timeout_mutex);\n\n\tif (dm_list_empty(&thread->timeout_list)) {\n\t\tthread->next_time = time(NULL) + thread->timeout;\n\t\tdm_list_add(&_timeout_registry, &thread->timeout_list);\n\t\tif (_timeout_running)\n\t\t\tpthread_cond_signal(&_timeout_cond);\n\t}\n\n\tif (!_timeout_running &&\n\t    !(ret = _pthread_create_smallstack(NULL, _timeout_thread, NULL)))\n\t\t_timeout_running = 1;\n\n\tpthread_mutex_unlock(&_timeout_mutex);\n\n\treturn ret;\n}\n\nstatic void _unregister_for_timeout(struct thread_status *thread)\n{\n\tpthread_mutex_lock(&_timeout_mutex);\n\tif (!dm_list_empty(&thread->timeout_list)) {\n\t\tdm_list_del(&thread->timeout_list);\n\t\tdm_list_init(&thread->timeout_list);\n\t\tif (dm_list_empty(&_timeout_registry))\n\t\t\t/* No more work -> wakeup to finish quickly */\n\t\t\tpthread_cond_signal(&_timeout_cond);\n\t}\n\tpthread_mutex_unlock(&_timeout_mutex);\n}\n\n#ifdef DEBUG_SIGNALS\n/* Print list of signals within a signal set */\nstatic void _print_sigset(const char *prefix, const sigset_t *sigset)\n{\n\tint sig, cnt = 0;\n\n\tfor (sig = 1; sig < NSIG; sig++)\n\t\tif (!sigismember(sigset, sig)) {\n\t\t\tcnt++;\n\t\t\tlog_debug(\"%s%d (%s)\", prefix, sig, strsignal(sig));\n\t\t}\n\n\tif (!cnt)\n\t\tlog_debug(\"%s<empty signal set>\", prefix);\n}\n#endif\n\nenum {\n\tDM_WAIT_RETRY,\n\tDM_WAIT_INTR,\n\tDM_WAIT_FATAL\n};\n\n/* Wait on a device until an event occurs. */\nstatic int _event_wait(struct thread_status *thread)\n{\n\tsigset_t set, old;\n\tint ret = DM_WAIT_RETRY;\n\tstruct dm_info info;\n\n\t/* TODO: audit libdm thread usage */\n\n\t/*\n\t * This is so that you can break out of waiting on an event,\n\t * either for a timeout event, or to cancel the thread.\n\t */\n\tsigemptyset(&old);\n\tsigemptyset(&set);\n\tsigaddset(&set, SIGALRM);\n\tif (pthread_sigmask(SIG_UNBLOCK, &set, &old) != 0) {\n\t\tlog_sys_error(\"pthread_sigmask\", \"unblock alarm\");\n\t\treturn ret; /* What better */\n\t}\n\n\tif (dm_task_run(thread->wait_task)) {\n\t\tthread->current_events |= DM_EVENT_DEVICE_ERROR;\n\t\tret = DM_WAIT_INTR;\n\t\t/* Update event_nr */\n\t\tif (dm_task_get_info(thread->wait_task, &info))\n\t\t\tdm_task_set_event_nr(thread->wait_task, info.event_nr);\n\t} else {\n\t\tswitch (dm_task_get_errno(thread->wait_task)) {\n\t\tcase ENXIO:\n\t\t\tlog_error(\"%s disappeared, detaching.\",\n\t\t\t\t  thread->device.name);\n\t\t\tret = DM_WAIT_FATAL;\n\t\t\tbreak;\n\t\tcase EINTR:\n\t\t\tthread->current_events |= DM_EVENT_TIMEOUT;\n\t\t\tret = DM_WAIT_INTR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_sys_error(\"dm_task_run\", \"waitevent\");\n\t\t}\n\t}\n\n\tif (pthread_sigmask(SIG_SETMASK, &old, NULL) != 0)\n\t\tlog_sys_error(\"pthread_sigmask\", \"block alarm\");\n\n#ifdef DEBUG_SIGNALS\n\t_print_sigset(\"dmeventd blocking \", &old);\n#endif\n\tDEBUGLOG(\"Completed waitevent task for %s.\", thread->device.name);\n\n\treturn ret;\n}\n\n/* Register a device with the DSO. */\nstatic int _do_register_device(struct thread_status *thread)\n{\n\treturn thread->dso_data->register_device(thread->device.name,\n\t\t\t\t\t\t thread->device.uuid,\n\t\t\t\t\t\t thread->device.major,\n\t\t\t\t\t\t thread->device.minor,\n\t\t\t\t\t\t &(thread->dso_private));\n}\n\n/* Unregister a device with the DSO. */\nstatic int _do_unregister_device(struct thread_status *thread)\n{\n\treturn thread->dso_data->unregister_device(thread->device.name,\n\t\t\t\t\t\t   thread->device.uuid,\n\t\t\t\t\t\t   thread->device.major,\n\t\t\t\t\t\t   thread->device.minor,\n\t\t\t\t\t\t   &(thread->dso_private));\n}\n\n/* Process an event in the DSO. */\nstatic void _do_process_event(struct thread_status *thread)\n{\n\tstruct dm_task *task;\n\n\t/* NOTE: timeout event gets status */\n\ttask = (thread->current_events & DM_EVENT_TIMEOUT)\n\t\t? _get_device_status(thread) : thread->wait_task;\n\n\tif (!task)\n\t\tlog_error(\"Lost event in Thr %x.\", (int)thread->thread);\n\telse {\n\t\tthread->dso_data->process_event(task, thread->current_events, &(thread->dso_private));\n\t\tif (task != thread->wait_task)\n\t\t\tdm_task_destroy(task);\n\t}\n}\n\nstatic void _thread_unused(struct thread_status *thread)\n{\n\tUNLINK_THREAD(thread);\n\tLINK(thread, &_thread_registry_unused);\n}\n\n/* Thread cleanup handler to unregister device. */\nstatic void _monitor_unregister(void *arg)\n{\n\tstruct thread_status *thread = arg, *thread_iter;\n\n\tdm_list_iterate_items(thread_iter, &_thread_registry)\n\t\tif (thread_iter == thread) {\n\t\t\t/* Relink to _unused */\n\t\t\t_thread_unused(thread);\n\t\t\tbreak;\n\t\t}\n\n\tthread->events = 0;\t/* Filter is now empty */\n\tthread->pending = 0;\t/* Event pending resolved */\n\tthread->processing = 1;\t/* Process unregistering */\n\n\t_unlock_mutex();\n\n\tDEBUGLOG(\"Unregistering monitor for %s.\", thread->device.name);\n\t_unregister_for_timeout(thread);\n\n\tif ((thread->status != DM_THREAD_REGISTERING) &&\n\t    !_do_unregister_device(thread))\n\t\tlog_error(\"%s: %s unregister failed.\", __func__,\n\t\t\t  thread->device.name);\n\n\tDEBUGLOG(\"Marking Thr %x as DONE and unused.\", (int)thread->thread);\n\n\t_lock_mutex();\n\tthread->status = DM_THREAD_DONE; /* Last access to thread memory! */\n\t_unlock_mutex();\n}\n\n/* Device monitoring thread. */\nstatic void *_monitor_thread(void *arg)\n{\n\tstruct thread_status *thread = arg;\n\tint ret;\n\tsigset_t pendmask;\n\n\tpthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);\n\tpthread_cleanup_push(_monitor_unregister, thread);\n\n\tif (!_fill_device_data(thread)) {\n\t\tlog_error(\"Failed to fill device data for %s.\", thread->device.uuid);\n\t\t_lock_mutex();\n\t\tgoto out;\n\t}\n\n\tif (!_do_register_device(thread)) {\n\t\tlog_error(\"Failed to register device %s.\", thread->device.name);\n\t\t_lock_mutex();\n\t\tgoto out;\n\t}\n\n\t_lock_mutex();\n\tthread->status = DM_THREAD_RUNNING;\n\tthread->processing = 0;\n\n\t/* Loop awaiting/analyzing device events. */\n\twhile (thread->events) {\n\n\t\tthread->pending = 0; /* Event is no longer pending...  */\n\n\t\t/*\n\t\t * Check against bitmask filter.\n\t\t *\n\t\t * If there's current events delivered from _event_wait() AND\n\t\t * the device got registered for those events AND\n\t\t * those events haven't been processed yet, call\n\t\t * the DSO's process_event() handler.\n\t\t */\n\t\tif (thread->events & thread->current_events) {\n\t\t\tthread->processing = 1;  /* Cannot be removed/signaled */\n\t\t\t_unlock_mutex();\n\n\t\t\t_do_process_event(thread);\n\t\t\tthread->current_events = 0; /* Current events processed */\n\n\t\t\t_lock_mutex();\n\t\t\tthread->processing = 0;\n\n\t\t\t/*\n\t\t\t * Thread can terminate itself from plugin via SIGALRM\n\t\t\t * Timer thread will not send signal while processing\n\t\t\t * TODO: maybe worth API change and return value for\n\t\t\t *       _do_process_event() instead of this signal solution\n\t\t\t */\n\t\t\tif (sigpending(&pendmask) < 0)\n\t\t\t\tlog_sys_error(\"sigpending\", \"\");\n\t\t\telse if (sigismember(&pendmask, SIGALRM))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t_unlock_mutex();\n\n\t\t\tif ((ret = _event_wait(thread)) == DM_WAIT_RETRY)\n\t\t\t\tusleep(100); /* Avoid busy loop, wait without mutex */\n\n\t\t\t_lock_mutex();\n\n\t\t\tif (ret == DM_WAIT_FATAL)\n\t\t\t\tbreak;\n\t\t}\n\t}\nout:\n\t/* ';' fixes gcc compilation problem with older pthread macros\n\t * \"label at end of compound statement\" */\n\t;\n\n\tpthread_cleanup_pop(1);\n\n\treturn NULL;\n}\n\n/* Create a device monitoring thread. */\nstatic int _create_thread(struct thread_status *thread)\n{\n\treturn _pthread_create_smallstack(&thread->thread, _monitor_thread, thread);\n}\n\n/* Update events - needs to be locked */\nstatic int _update_events(struct thread_status *thread, int events)\n{\n\tint ret = 0;\n\n\tif (thread->events == events)\n\t\treturn 0; /* Nothing has changed */\n\n\tthread->events = events;\n\tthread->pending = DM_EVENT_REGISTRATION_PENDING;\n\n\t/* Only non-processing threads can be notified */\n\tif (!thread->processing) {\n\t\tDEBUGLOG(\"Sending SIGALRM to wakeup Thr %x.\", (int)thread->thread);\n\n\t\t/* Notify thread waiting in ioctl (to speed-up) */\n\t\tif ((ret = pthread_kill(thread->thread, SIGALRM))) {\n\t\t\tif (ret == ESRCH)\n\t\t\t\tthread->events = 0;  /* thread is gone */\n\t\t\telse\n\t\t\t\tlog_error(\"Unable to wakeup thread: %s\",\n\t\t\t\t\t  strerror(ret));\n\t\t}\n\t}\n\n\t/* Threads with no events has to be moved to unused */\n\tif (!thread->events)\n\t\t_thread_unused(thread);\n\n\treturn -ret;\n}\n\n/* Return success on daemon active check. */\nstatic int _active(struct message_data *message_data)\n{\n\treturn 0;\n}\n\n/*\n * Unregister for an event.\n *\n * Only one caller at a time here as with register_for_event().\n */\nstatic int _unregister_for_event(struct message_data *message_data)\n{\n\tstruct thread_status *thread;\n\tint ret;\n\n\t/*\n\t * Clear event in bitfield and deactivate\n\t * monitoring thread in case bitfield is 0.\n\t */\n\t_lock_mutex();\n\n\tif (!(thread = _lookup_thread_status(message_data))) {\n\t\t_unlock_mutex();\n\t\treturn -ENODEV;\n\t}\n\n\t/* AND mask event ~# from events bitfield. */\n\tret = _update_events(thread, (thread->events & ~message_data->events_field));\n\n\t_unlock_mutex();\n\n\t/* If there are no events, thread is later garbage\n\t * collected by _cleanup_unused_threads */\n\tif (message_data->events_field & DM_EVENT_TIMEOUT)\n\t\t_unregister_for_timeout(thread);\n\n\tDEBUGLOG(\"Unregistered event for %s.\", thread->device.name);\n\n\treturn ret;\n}\n\n/*\n * Register for an event.\n *\n * Only one caller at a time here, because we use\n * a FIFO and lock it against multiple accesses.\n */\nstatic int _register_for_event(struct message_data *message_data)\n{\n\tint ret = 0;\n\tstruct thread_status *thread;\n\tstruct dso_data *dso_data;\n\n\tif (!(dso_data = _lookup_dso(message_data)) &&\n\t    !(dso_data = _load_dso(message_data))) {\n\t\tstack;\n#ifdef ELIBACC\n\t\tret = ELIBACC;\n#else\n\t\tret = ENODEV;\n#endif\n\t\treturn ret;\n\t}\n\n\t_lock_mutex();\n\n\tif ((thread = _lookup_thread_status(message_data))) {\n\t\t/* OR event # into events bitfield. */\n\t\tret = _update_events(thread, (thread->events | message_data->events_field));\n\t} else {\n\t\t_unlock_mutex();\n\n\t\t/* Only creating thread during event processing\n\t\t * Remaining initialization happens within monitoring thread */\n\t\tif (!(thread = _alloc_thread_status(message_data, dso_data))) {\n\t\t\tstack;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif ((ret = _create_thread(thread))) {\n\t\t\tstack;\n\t\t\t_free_thread_status(thread);\n\t\t\treturn -ret;\n\t\t}\n\n\t\t_lock_mutex();\n\t\t/* Note: same uuid can't be added in parallel */\n\t\tLINK_THREAD(thread);\n\t}\n\n\t_unlock_mutex();\n\n\t/* If creation of timeout thread fails (as it may), we fail\n\t   here completely. The client is responsible for either\n\t   retrying later or trying to register without timeout\n\t   events. However, if timeout thread cannot be started, it\n\t   usually means we are so starved on resources that we are\n\t   almost as good as dead already... */\n\tif ((message_data->events_field & DM_EVENT_TIMEOUT) &&\n\t    (ret = _register_for_timeout(thread))) {\n\t\tstack;\n\t\t_unregister_for_event(message_data);\n\t}\n\n\treturn -ret;\n}\n\n/*\n * Get registered device.\n *\n * Only one caller at a time here as with register_for_event().\n */\nstatic int _registered_device(struct message_data *message_data,\n\t\t\t     struct thread_status *thread)\n{\n\tint r;\n\tstruct dm_event_daemon_message *msg = message_data->msg;\n\n\tfree(msg->data);\n\n\tif ((r = dm_asprintf(&(msg->data), \"%s %s %s %u\",\n\t\t\t     message_data->id,\n\t\t\t     thread->dso_data->dso_name,\n\t\t\t     thread->device.uuid,\n\t\t\t     thread->events | thread->pending)) < 0)\n\t\treturn -ENOMEM;\n\n\tmsg->size = (uint32_t) r;\n\tDEBUGLOG(\"Registered %s.\", msg->data);\n\n\treturn 0;\n}\n\nstatic int _want_registered_device(char *dso_name, char *device_uuid,\n\t\t\t\t   struct thread_status *thread)\n{\n\t/* If DSO names and device paths are equal. */\n\tif (dso_name && device_uuid)\n\t\treturn !strcmp(dso_name, thread->dso_data->dso_name) &&\n\t\t    !strcmp(device_uuid, thread->device.uuid);\n\n\t/* If DSO names are equal. */\n\tif (dso_name)\n\t\treturn !strcmp(dso_name, thread->dso_data->dso_name);\n\n\t/* If device paths are equal. */\n\tif (device_uuid)\n\t\treturn !strcmp(device_uuid, thread->device.uuid);\n\n\treturn 1;\n}\n\nstatic int _get_registered_dev(struct message_data *message_data, int next)\n{\n\tstruct thread_status *thread, *hit = NULL;\n\tint ret = -ENOENT;\n\n\tDEBUGLOG(\"Get%s dso:%s  uuid:%s.\", next ? \"\" : \"Next\",\n\t\t message_data->dso_name,\n\t\t message_data->device_uuid);\n\t_lock_mutex();\n\n\t/* Iterate list of threads checking if we want a particular one. */\n\tdm_list_iterate_items(thread, &_thread_registry)\n\t\tif (_want_registered_device(message_data->dso_name,\n\t\t\t\t\t    message_data->device_uuid,\n\t\t\t\t\t    thread)) {\n\t\t\thit = thread;\n\t\t\tbreak;\n\t\t}\n\n\t/*\n\t * If we got a registered device and want the next one ->\n\t * fetch next conforming element off the list.\n\t */\n\tif (hit && !next)\n\t\tgoto reg;\n\n\t/*\n\t * If we didn't get a match, try the threads waiting to be deleted.\n\t * FIXME Do something similar if 'next' is set.\n\t */\n\tif (!hit && !next)\n\t\tdm_list_iterate_items(thread, &_thread_registry_unused)\n\t\t\tif (_want_registered_device(message_data->dso_name,\n\t\t\t\t\t\t    message_data->device_uuid, thread)) {\n\t\t\t\thit = thread;\n\t\t\t\tgoto reg;\n\t\t\t}\n\n\tif (!hit) {\n\t\tDEBUGLOG(\"Get%s not registered\", next ? \"\" : \"Next\");\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tif (dm_list_end(&_thread_registry, &thread->list))\n\t\t\tgoto out;\n\n\t\tthread = dm_list_item(thread->list.n, struct thread_status);\n\t\tif (_want_registered_device(message_data->dso_name, NULL, thread)) {\n\t\t\thit = thread;\n\t\t\tbreak;\n\t\t}\n\t}\n\n      reg:\n\tret = _registered_device(message_data, hit);\n\n      out:\n\t_unlock_mutex();\n\n\treturn ret;\n}\n\nstatic int _get_registered_device(struct message_data *message_data)\n{\n\treturn _get_registered_dev(message_data, 0);\n}\n\nstatic int _get_next_registered_device(struct message_data *message_data)\n{\n\treturn _get_registered_dev(message_data, 1);\n}\n\nstatic int _set_timeout(struct message_data *message_data)\n{\n\tstruct thread_status *thread;\n\n\t_lock_mutex();\n\tthread = _lookup_thread_status(message_data);\n\t_unlock_mutex();\n\n\tif (!thread)\n\t\treturn -ENODEV;\n\n\t/* Lets reprogram timer */\n\tpthread_mutex_lock(&_timeout_mutex);\n\tthread->timeout = message_data->timeout_secs;\n\tthread->next_time = 0;\n\tpthread_cond_signal(&_timeout_cond);\n\tpthread_mutex_unlock(&_timeout_mutex);\n\n\treturn 0;\n}\n\nstatic int _get_timeout(struct message_data *message_data)\n{\n\tstruct thread_status *thread;\n\tstruct dm_event_daemon_message *msg = message_data->msg;\n\n\t_lock_mutex();\n\tthread = _lookup_thread_status(message_data);\n\t_unlock_mutex();\n\n\tif (!thread)\n\t\treturn -ENODEV;\n\n\tfree(msg->data);\n\tmsg->size = dm_asprintf(&(msg->data), \"%s %\" PRIu32,\n\t\t\t\tmessage_data->id, thread->timeout);\n\n\treturn (msg->data && msg->size) ? 0 : -ENOMEM;\n}\n\nstatic int _open_fifo(const char *path)\n{\n\tstruct stat st;\n\tint fd = -1;\n \n \t/*\n\t * FIXME Explicitly verify the code's requirement that path is secure:\n\t * - All parent directories owned by root without group/other write access unless sticky.\n\t */\n\n\t/* If path exists, only use it if it is root-owned fifo mode 0600 */\n\tif ((lstat(path, &st) < 0)) {\n\t\tif (errno != ENOENT) {\n\t\t\tlog_sys_error(\"stat\", path);\n\t\t\treturn -1;\n\t\t}\n\t} else if (!S_ISFIFO(st.st_mode) || st.st_uid ||\n\t\t   (st.st_mode & (S_IEXEC | S_IRWXG | S_IRWXO))) {\n\t\tlog_warn(\"WARNING: %s has wrong attributes: Replacing.\", path);\n\t\tif (unlink(path)) {\n\t\t\tlog_sys_error(\"unlink\", path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Create fifo. */\n\t(void) dm_prepare_selinux_context(path, S_IFIFO);\n\tif ((mkfifo(path, 0600) == -1) && errno != EEXIST) {\n\t\tlog_sys_error(\"mkfifo\", path);\n\t\t(void) dm_prepare_selinux_context(NULL, 0);\n\t\tgoto fail;\n\t}\n\n\t(void) dm_prepare_selinux_context(NULL, 0);\n\n\t/* Need to open read+write or we will block or fail */\n\tif ((fd = open(path, O_RDWR)) < 0) {\n\t\tlog_sys_error(\"open\", path);\n\t\tgoto fail;\n\t}\n\n\t/* Warn about wrong permissions if applicable */\n\tif (fstat(fd, &st)) {\n\t\tlog_sys_error(\"fstat\", path);\n\t\tgoto fail;\n\t}\n\n\tif (!S_ISFIFO(st.st_mode) || st.st_uid ||\n\t    (st.st_mode & (S_IEXEC | S_IRWXG | S_IRWXO))) {\n\t\tlog_error(\"%s: fifo has incorrect attributes\", path);\n\t\tgoto fail;\n\t}\n\n\tif (fcntl(fd, F_SETFD, FD_CLOEXEC)) {\n\t\tlog_sys_error(\"fcntl(FD_CLOEXEC)\", path);\n\t\tgoto fail;\n\t}\n\n\treturn fd;\n\nfail:\n\tif ((fd >= 0) && close(fd))\n\t\tlog_sys_error(\"close\", path);\n\n\treturn -1;\n}\n\n/* Open fifos used for client communication. */\nstatic int _open_fifos(struct dm_event_fifos *fifos)\n{\n\t/* Create client fifo. */\n\tif ((fifos->client = _open_fifo(fifos->client_path)) < 0)\n\t\tgoto fail;\n\n\t/* Create server fifo. */\n\tif ((fifos->server = _open_fifo(fifos->server_path)) < 0)\n\t\tgoto fail;\n\n\treturn 1;\n\nfail:\n\tif (fifos->client >= 0 && close(fifos->client))\n\t\tlog_sys_error(\"close\", fifos->client_path);\n\n\treturn 0;\n}\n\n/*\n * Read message from client making sure that data is available\n * and a complete message is read.  Must not block indefinitely.\n */\nstatic int _client_read(struct dm_event_fifos *fifos,\n\t\t\tstruct dm_event_daemon_message *msg)\n{\n\tstruct timeval t;\n\tunsigned bytes = 0;\n\tint ret = 0;\n\tfd_set fds;\n\tsize_t size = 2 * sizeof(uint32_t);\t/* status + size */\n\tuint32_t *header = alloca(size);\n\tchar *buf = (char *)header;\n\n\tmsg->data = NULL;\n\n\terrno = 0;\n\twhile (bytes < size && errno != EOF) {\n\t\t/* Watch client read FIFO for input. */\n\t\tFD_ZERO(&fds);\n\t\tFD_SET(fifos->client, &fds);\n\t\tt.tv_sec = 1;\n\t\tt.tv_usec = 0;\n\t\tret = select(fifos->client + 1, &fds, NULL, NULL, &t);\n\n\t\tif (!ret && !bytes)\t/* nothing to read */\n\t\t\treturn 0;\n\n\t\tif (!ret)\t/* trying to finish read */\n\t\t\tcontinue;\n\n\t\tif (ret < 0)\t/* error */\n\t\t\treturn 0;\n\n\t\tret = read(fifos->client, buf + bytes, size - bytes);\n\t\tbytes += ret > 0 ? ret : 0;\n\t\tif (header && (bytes == 2 * sizeof(uint32_t))) {\n\t\t\tmsg->cmd = ntohl(header[0]);\n\t\t\tsize = msg->size = ntohl(header[1]);\n\t\t\tbytes = 0;\n\t\t\tif (!size)\n\t\t\t\tbreak; /* No data -> error */\n\t\t\tbuf = msg->data = malloc(msg->size);\n\t\t\tif (!buf)\n\t\t\t\tbreak; /* No mem -> error */\n\t\t\theader = 0;\n\t\t}\n\t}\n\n\tif (bytes != size) {\n\t\tfree(msg->data);\n\t\tmsg->data = NULL;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\n * Write a message to the client making sure that it is ready to write.\n */\nstatic int _client_write(struct dm_event_fifos *fifos,\n\t\t\tstruct dm_event_daemon_message *msg)\n{\n\tuint32_t temp[2];\n\tunsigned bytes = 0;\n\tint ret = 0;\n\tfd_set fds;\n\n\tsize_t size = 2 * sizeof(uint32_t) + ((msg->data) ? msg->size : 0);\n\tuint32_t *header = malloc(size);\n\tchar *buf = (char *)header;\n\n\tif (!header) {\n\t\t/* Reply with ENOMEM message */\n\t\theader = temp;\n\t\tsize = sizeof(temp);\n\t\theader[0] = htonl(-ENOMEM);\n\t\theader[1] = 0;\n\t} else {\n\t\theader[0] = htonl(msg->cmd);\n\t\theader[1] = htonl((msg->data) ? msg->size : 0);\n\t\tif (msg->data)\n\t\t\tmemcpy(buf + 2 * sizeof(uint32_t), msg->data, msg->size);\n\t}\n\n\twhile (bytes < size) {\n\t\tdo {\n\t\t\t/* Watch client write FIFO to be ready for output. */\n\t\t\tFD_ZERO(&fds);\n\t\t\tFD_SET(fifos->server, &fds);\n\t\t} while (select(fifos->server + 1, NULL, &fds, NULL, NULL) != 1);\n\n\t\tif ((ret = write(fifos->server, buf + bytes, size - bytes)) > 0)\n\t\t\tbytes += ret;\n\t\telse if (errno == EIO)\n\t\t\tbreak;\n\t}\n\n\tif (header != temp)\n\t\tfree(header);\n\n\treturn (bytes == size);\n}\n\n/*\n * Handle a client request.\n *\n * We put the request handling functions into\n * a list because of the growing number.\n */\nstatic int _handle_request(struct dm_event_daemon_message *msg,\n\t\t\t  struct message_data *message_data)\n{\n\tswitch (msg->cmd) {\n\tcase DM_EVENT_CMD_REGISTER_FOR_EVENT:\n\t\tif (!message_data->events_field)\n\t\t\treturn -EINVAL;\n\t\treturn _register_for_event(message_data);\n\tcase DM_EVENT_CMD_UNREGISTER_FOR_EVENT:\n\t\treturn _unregister_for_event(message_data);\n\tcase DM_EVENT_CMD_GET_REGISTERED_DEVICE:\n\t\treturn _get_registered_device(message_data);\n\tcase DM_EVENT_CMD_GET_NEXT_REGISTERED_DEVICE:\n\t\treturn _get_next_registered_device(message_data);\n\tcase DM_EVENT_CMD_SET_TIMEOUT:\n\t\treturn _set_timeout(message_data);\n\tcase DM_EVENT_CMD_GET_TIMEOUT:\n\t\treturn _get_timeout(message_data);\n\tcase DM_EVENT_CMD_ACTIVE:\n\t\treturn _active(message_data);\n\tcase DM_EVENT_CMD_GET_STATUS:\n\t\treturn _get_status(message_data);\n\t/* dmeventd parameters of running dmeventd,\n\t * returns 'pid=<pid> daemon=<no/yes> exec_method=<direct/systemd>'\n\t * \tpid - pidfile of running dmeventd\n\t * \tdaemon - running as a daemon or not (foreground)?\n\t * \texec_method - \"direct\" if executed directly or\n\t * \t\t      \"systemd\" if executed via systemd\n\t */\n\tcase DM_EVENT_CMD_GET_PARAMETERS:\n\t\treturn _get_parameters(message_data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* Process a request passed from the communication thread. */\nstatic int _do_process_request(struct dm_event_daemon_message *msg)\n{\n\tint ret;\n\tchar *answer;\n\tstruct message_data message_data = { .msg =  msg };\n\n\t/* Parse the message. */\n\tif (msg->cmd == DM_EVENT_CMD_HELLO || msg->cmd == DM_EVENT_CMD_DIE)  {\n\t\tret = 0;\n\t\tanswer = msg->data;\n\t\tif (answer) {\n\t\t\tmsg->size = dm_asprintf(&(msg->data), \"%s %s %d\", answer,\n\t\t\t\t\t\t(msg->cmd == DM_EVENT_CMD_DIE) ? \"DYING\" : \"HELLO\",\n\t\t\t\t\t\tDM_EVENT_PROTOCOL_VERSION);\n\t\t\tfree(answer);\n\t\t}\n\t} else if (msg->cmd != DM_EVENT_CMD_ACTIVE && !_parse_message(&message_data)) {\n\t\tstack;\n\t\tret = -EINVAL;\n\t} else\n\t\tret = _handle_request(msg, &message_data);\n\n\tmsg->cmd = ret;\n\tif (!msg->data)\n\t\tmsg->size = dm_asprintf(&(msg->data), \"%s %s\", message_data.id, strerror(-ret));\n\n\t_free_message(&message_data);\n\n\treturn ret;\n}\n\n/* Only one caller at a time. */\nstatic void _process_request(struct dm_event_fifos *fifos)\n{\n\tstruct dm_event_daemon_message msg = { 0 };\n\tint cmd;\n\t/*\n\t * Read the request from the client (client_read, client_write\n\t * give true on success and false on failure).\n\t */\n\tif (!_client_read(fifos, &msg))\n\t\treturn;\n\n\tcmd = msg.cmd;\n\n\tDEBUGLOG(\">>> CMD:%s (0x%x) processing...\", decode_cmd(cmd), cmd);\n\n\t/* _do_process_request fills in msg (if memory allows for\n\t   data, otherwise just cmd and size = 0) */\n\t_do_process_request(&msg);\n\n\tif (!_client_write(fifos, &msg))\n\t\tstack;\n\n\tDEBUGLOG(\"<<< CMD:%s (0x%x) completed (result %d).\", decode_cmd(cmd), cmd, msg.cmd);\n\n\tfree(msg.data);\n\n\tif (cmd == DM_EVENT_CMD_DIE) {\n\t\tif (unlink(DMEVENTD_PIDFILE))\n\t\t\tlog_sys_error(\"unlink\", DMEVENTD_PIDFILE);\n\t\t_exit(0);\n\t}\n}\n\nstatic void _process_initial_registrations(void)\n{\n\tint i;\n\tchar *reg;\n\tstruct dm_event_daemon_message msg = { 0 };\n\n\tfor (i = 0; (reg = _initial_registrations[i]); ++i) {\n\t\tmsg.cmd = DM_EVENT_CMD_REGISTER_FOR_EVENT;\n\t\tif ((msg.size = strlen(reg))) {\n\t\t\tmsg.data = reg;\n\t\t\t_do_process_request(&msg);\n\t\t}\n\t}\n}\n\nstatic void _cleanup_unused_threads(void)\n{\n\tstruct dm_list *l;\n\tstruct thread_status *thread;\n\tint ret;\n\n\t_lock_mutex();\n\n\twhile ((l = dm_list_first(&_thread_registry_unused))) {\n\t\tthread = dm_list_item(l, struct thread_status);\n\t\tif (thread->status != DM_THREAD_DONE) {\n\t\t\tif (thread->processing)\n\t\t\t\tbreak; /* cleanup on the next round */\n\n\t\t\t/* Signal possibly sleeping thread */\n\t\t\tret = pthread_kill(thread->thread, SIGALRM);\n\t\t\tif (!ret || (ret != ESRCH))\n\t\t\t\tbreak; /* check again on the next round */\n\n\t\t\t/* thread is likely gone */\n\t\t}\n\n\t\tdm_list_del(l);\n\t\t_unlock_mutex();\n\n\t\tDEBUGLOG(\"Destroying Thr %x.\", (int)thread->thread);\n\n\t\tif (pthread_join(thread->thread, NULL))\n\t\t\tlog_sys_error(\"pthread_join\", \"\");\n\n\t\t_free_thread_status(thread);\n\t\t_lock_mutex();\n\t}\n\n\t_unlock_mutex();\n}\n\nstatic void _sig_alarm(int signum __attribute__((unused)))\n{\n\t/* empty SIG_IGN */;\n}\n\n/* Init thread signal handling. */\nstatic void _init_thread_signals(void)\n{\n\tsigset_t my_sigset;\n\tstruct sigaction act = { .sa_handler = _sig_alarm };\n\n\tsigaction(SIGALRM, &act, NULL);\n\tsigfillset(&my_sigset);\n\n\t/* These are used for exiting */\n\tsigdelset(&my_sigset, SIGTERM);\n\tsigdelset(&my_sigset, SIGINT);\n\tsigdelset(&my_sigset, SIGHUP);\n\tsigdelset(&my_sigset, SIGQUIT);\n\n\tpthread_sigmask(SIG_BLOCK, &my_sigset, NULL);\n}\n\n/*\n * exit_handler\n * @sig\n *\n * Set the global variable which the process should\n * be watching to determine when to exit.\n */\nstatic void _exit_handler(int sig __attribute__((unused)))\n{\n\t_exit_now = DM_SIGNALED_EXIT;\n}\n\n#ifdef __linux__\nstatic int _set_oom_adj(const char *oom_adj_path, int val)\n{\n\tFILE *fp;\n\n\tif (!(fp = fopen(oom_adj_path, \"w\"))) {\n\t\tlog_sys_error(\"open\", oom_adj_path);\n\t\treturn 0;\n\t}\n\n\tfprintf(fp, \"%i\", val);\n\n\tif (dm_fclose(fp))\n\t\tlog_sys_error(\"fclose\", oom_adj_path);\n\n\treturn 1;\n}\n\n/*\n * Protection against OOM killer if kernel supports it\n */\nstatic int _protect_against_oom_killer(void)\n{\n\tstruct stat st;\n\n\tif (stat(OOM_ADJ_FILE, &st) == -1) {\n\t\tif (errno != ENOENT)\n\t\t\tlog_sys_error(\"stat\", OOM_ADJ_FILE);\n\n\t\t/* Try old oom_adj interface as a fallback */\n\t\tif (stat(OOM_ADJ_FILE_OLD, &st) == -1) {\n\t\t\tlog_sys_error(\"stat\", OOM_ADJ_FILE_OLD);\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn _set_oom_adj(OOM_ADJ_FILE_OLD, OOM_DISABLE) ||\n\t\t       _set_oom_adj(OOM_ADJ_FILE_OLD, OOM_ADJUST_MIN);\n\t}\n\n\treturn _set_oom_adj(OOM_ADJ_FILE, OOM_SCORE_ADJ_MIN);\n}\n\nstatic int _handle_preloaded_fifo(int fd, const char *path)\n{\n\tstruct stat st_fd, st_path;\n\tint flags;\n\n\tif ((flags = fcntl(fd, F_GETFD)) < 0)\n\t\treturn 0;\n\n\tif (flags & FD_CLOEXEC)\n\t\treturn 0;\n\n\tif (fstat(fd, &st_fd) < 0 || !S_ISFIFO(st_fd.st_mode))\n\t\treturn 0;\n\n\tif (stat(path, &st_path) < 0 ||\n\t    st_path.st_dev != st_fd.st_dev ||\n\t    st_path.st_ino != st_fd.st_ino)\n\t\treturn 0;\n\n\tif (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int _systemd_handover(struct dm_event_fifos *fifos)\n{\n\tconst char *e;\n\tchar *p;\n\tunsigned long env_pid, env_listen_fds;\n\tint r = 0;\n\n\t/* SD_ACTIVATION must be set! */\n\tif (!(e = getenv(SD_ACTIVATION_ENV_VAR_NAME)) || strcmp(e, \"1\"))\n\t\tgoto out;\n\n\t/* LISTEN_PID must be equal to our PID! */\n\tif (!(e = getenv(SD_LISTEN_PID_ENV_VAR_NAME)))\n\t\tgoto out;\n\n\terrno = 0;\n\tenv_pid = strtoul(e, &p, 10);\n\tif (errno || !p || *p || env_pid <= 0 ||\n\t    getpid() != (pid_t) env_pid)\n\t\tgoto out;\n\n\t/* LISTEN_FDS must be 2 and the fds must be FIFOSs! */\n\tif (!(e = getenv(SD_LISTEN_FDS_ENV_VAR_NAME)))\n\t\tgoto out;\n\n\terrno = 0;\n\tenv_listen_fds = strtoul(e, &p, 10);\n\tif (errno || !p || *p || env_listen_fds != 2)\n\t\tgoto out;\n\n\t/* Check and handle the FIFOs passed in */\n\tr = (_handle_preloaded_fifo(SD_FD_FIFO_SERVER, DM_EVENT_FIFO_SERVER) &&\n\t     _handle_preloaded_fifo(SD_FD_FIFO_CLIENT, DM_EVENT_FIFO_CLIENT));\n\n\tif (r) {\n\t\tfifos->server = SD_FD_FIFO_SERVER;\n\t\tfifos->server_path = DM_EVENT_FIFO_SERVER;\n\t\tfifos->client = SD_FD_FIFO_CLIENT;\n\t\tfifos->client_path = DM_EVENT_FIFO_CLIENT;\n\t}\n\nout:\n\tunsetenv(SD_ACTIVATION_ENV_VAR_NAME);\n\tunsetenv(SD_LISTEN_PID_ENV_VAR_NAME);\n\tunsetenv(SD_LISTEN_FDS_ENV_VAR_NAME);\n\treturn r;\n}\n\n#endif\n\nstatic void _remove_files_on_exit(void)\n{\n\tif (unlink(DMEVENTD_PIDFILE))\n\t\tlog_sys_error(\"unlink\", DMEVENTD_PIDFILE);\n\n\tif (!_systemd_activation) {\n\t\tif (unlink(DM_EVENT_FIFO_CLIENT))\n\t\t\tlog_sys_error(\"unlink\", DM_EVENT_FIFO_CLIENT);\n\n\t\tif (unlink(DM_EVENT_FIFO_SERVER))\n\t\t\tlog_sys_error(\"unlink\", DM_EVENT_FIFO_SERVER);\n\t}\n}\n\nstatic void _daemonize(void)\n{\n\tint child_status;\n\tint fd;\n\tpid_t pid;\n\tstruct rlimit rlim;\n\tstruct timeval tval;\n\tsigset_t my_sigset;\n\n\tsigemptyset(&my_sigset);\n\tif (sigprocmask(SIG_SETMASK, &my_sigset, NULL) < 0) {\n\t\tfprintf(stderr, \"Unable to restore signals.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tsignal(SIGTERM, &_exit_handler);\n\n\tswitch (pid = fork()) {\n\tcase -1:\n\t\tlog_sys_error(\"fork\", \"\");\n\t\texit(EXIT_FAILURE);\n\tcase 0:\t\t/* Child */\n\t\tbreak;\n\n\tdefault:\n\t\t/* Wait for response from child */\n\t\twhile (!waitpid(pid, &child_status, WNOHANG) && !_exit_now) {\n\t\t\ttval.tv_sec = 0;\n\t\t\ttval.tv_usec = 250000;\t/* .25 sec */\n\t\t\tselect(0, NULL, NULL, NULL, &tval);\n\t\t}\n\n\t\tif (_exit_now)\t/* Child has signaled it is ok - we can exit now */\n\t\t\texit(EXIT_SUCCESS);\n\n\t\t/* Problem with child.  Determine what it is by exit code */\n\t\tswitch (WEXITSTATUS(child_status)) {\n\t\tcase EXIT_DESC_CLOSE_FAILURE:\n\t\tcase EXIT_DESC_OPEN_FAILURE:\n\t\tcase EXIT_FIFO_FAILURE:\n\t\tcase EXIT_CHDIR_FAILURE:\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Child exited with code %d\\n\", WEXITSTATUS(child_status));\n\t\t\tbreak;\n\t\t}\n\n\t\texit(WEXITSTATUS(child_status));\n\t}\n\n\tif (chdir(\"/\"))\n\t\texit(EXIT_CHDIR_FAILURE);\n\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) < 0)\n\t\tfd = 256;\t/* just have to guess */\n\telse\n\t\tfd = rlim.rlim_cur;\n\n\tfor (--fd; fd >= 0; fd--) {\n#ifdef __linux__\n\t\t/* Do not close fds preloaded by systemd! */\n\t\tif (_systemd_activation &&\n\t\t    (fd == SD_FD_FIFO_SERVER || fd == SD_FD_FIFO_CLIENT))\n\t\t\tcontinue;\n#endif\n\t\t(void) close(fd);\n\t}\n\n\tif ((open(\"/dev/null\", O_RDONLY) < 0) ||\n\t    (open(\"/dev/null\", O_WRONLY) < 0) ||\n\t    (open(\"/dev/null\", O_WRONLY) < 0))\n\t\texit(EXIT_DESC_OPEN_FAILURE);\n\n\tsetsid();\n}\n\nstatic int _reinstate_registrations(struct dm_event_fifos *fifos)\n{\n\tstatic const char _failed_parsing_msg[] = \"Failed to parse existing event registration.\\n\";\n\tstatic const char *_delim = \" \";\n\tstruct dm_event_daemon_message msg = { 0 };\n\tchar *endp, *dso_name, *dev_name, *mask, *timeout;\n\tunsigned long mask_value, timeout_value;\n\tint i, ret;\n\n\tret = daemon_talk(fifos, &msg, DM_EVENT_CMD_HELLO, NULL, NULL, 0, 0);\n\tfree(msg.data);\n\tmsg.data = NULL;\n\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to communicate with new instance of dmeventd.\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; _initial_registrations[i]; ++i) {\n\t\tif (!(strtok(_initial_registrations[i], _delim)) ||\n\t\t    !(dso_name = strtok(NULL, _delim)) ||\n\t\t    !(dev_name = strtok(NULL, _delim)) ||\n\t\t    !(mask = strtok(NULL, _delim)) ||\n\t\t    !(timeout = strtok(NULL, _delim))) {\n\t\t\tfputs(_failed_parsing_msg, stderr);\n\t\t\tcontinue;\n\t\t}\n\n\t\terrno = 0;\n\t\tmask_value = strtoul(mask, &endp, 10);\n\t\tif (errno || !endp || *endp) {\n\t\t\tfputs(_failed_parsing_msg, stderr);\n\t\t\tcontinue;\n\t\t}\n\n\t\terrno = 0;\n\t\ttimeout_value = strtoul(timeout, &endp, 10);\n\t\tif (errno || !endp || *endp) {\n\t\t\tfputs(_failed_parsing_msg, stderr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (daemon_talk(fifos, &msg, DM_EVENT_CMD_REGISTER_FOR_EVENT,\n\t\t\t\tdso_name,\n\t\t\t\tdev_name,\n\t\t\t\t(enum dm_event_mask) mask_value,\n\t\t\t\ttimeout_value))\n\t\t\tfprintf(stderr, \"Failed to reinstate monitoring for device %s.\\n\", dev_name);\n\t}\n\n\treturn 1;\n}\n\nstatic void _restart_dmeventd(void)\n{\n\tstruct dm_event_fifos fifos = {\n\t\t.server = -1,\n\t\t.client = -1,\n\t\t/* FIXME Make these either configurable or depend directly on dmeventd_path */\n\t\t.client_path = DM_EVENT_FIFO_CLIENT,\n\t\t.server_path = DM_EVENT_FIFO_SERVER\n\t};\n\tstruct dm_event_daemon_message msg = { 0 };\n\tint i, count = 0;\n\tchar *message;\n\tint version;\n\tconst char *e;\n\n\t/* Get the list of registrations from the running daemon. */\n\tif (!init_fifos(&fifos)) {\n\t\tfprintf(stderr, \"WARNING: Could not initiate communication with existing dmeventd.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!dm_event_get_version(&fifos, &version)) {\n\t\tfprintf(stderr, \"WARNING: Could not communicate with existing dmeventd.\\n\");\n\t\tgoto bad;\n\t}\n\n\tif (version < 1) {\n\t\tfprintf(stderr, \"WARNING: The running dmeventd instance is too old.\\n\"\n\t\t\t\t\"Protocol version %d (required: 1). Action cancelled.\\n\",\n\t\t\t\tversion);\n\t\tgoto bad;\n\t}\n\n\tif (daemon_talk(&fifos, &msg, DM_EVENT_CMD_GET_STATUS, \"-\", \"-\", 0, 0))\n\t\tgoto bad;\n\n\tmessage = strchr(msg.data, ' ') + 1;\n\tfor (i = 0; msg.data[i]; ++i)\n\t\tif (msg.data[i] == ';') {\n\t\t\tmsg.data[i] = 0;\n\t\t\t++count;\n\t\t}\n\n\tif (!(_initial_registrations = malloc(sizeof(char*) * (count + 1)))) {\n\t\tfprintf(stderr, \"Memory allocation registration failed.\\n\");\n\t\tgoto bad;\n\t}\n\n\tfor (i = 0; i < count; ++i) {\n\t\tif (!(_initial_registrations[i] = strdup(message))) {\n\t\t\tfprintf(stderr, \"Memory allocation for message failed.\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmessage += strlen(message) + 1;\n\t}\n\t_initial_registrations[count] = NULL;\n\n\tif (version >= 2) {\n\t\tif (daemon_talk(&fifos, &msg, DM_EVENT_CMD_GET_PARAMETERS, \"-\", \"-\", 0, 0)) {\n\t\t\tfprintf(stderr, \"Failed to acquire parameters from old dmeventd.\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (strstr(msg.data, \"exec_method=systemd\"))\n\t\t\t_systemd_activation = 1;\n\t}\n#ifdef __linux__\n\t/*\n\t* If the protocol version is old, just assume that if systemd is running,\n\t* the dmeventd is also run as a systemd service via fifo activation.\n\t*/\n\tif (version < 2) {\n\t\t/* This check is copied from sd-daemon.c. */\n\t\tstruct stat st;\n\t\tif (!lstat(SD_RUNTIME_UNIT_FILE_DIR, &st) && !!S_ISDIR(st.st_mode))\n\t\t\t_systemd_activation = 1;\n\t}\n#endif\n\n\tif (daemon_talk(&fifos, &msg, DM_EVENT_CMD_DIE, \"-\", \"-\", 0, 0)) {\n\t\tfprintf(stderr, \"Old dmeventd refused to die.\\n\");\n\t\tgoto bad;\n\t}\n\n\tif (!_systemd_activation &&\n\t    ((e = getenv(SD_ACTIVATION_ENV_VAR_NAME)) && strcmp(e, \"1\")))\n\t\t_systemd_activation = 1;\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tif ((access(DMEVENTD_PIDFILE, F_OK) == -1) && (errno == ENOENT))\n\t\t\tbreak;\n\t\tusleep(10);\n\t}\n\n\tif (!_systemd_activation) {\n\t\tfini_fifos(&fifos);\n\t\treturn;\n\t}\n\n\t/* Reopen fifos. */\n\tfini_fifos(&fifos);\n\tif (!init_fifos(&fifos)) {\n\t\tfprintf(stderr, \"Could not initiate communication with new instance of dmeventd.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (!_reinstate_registrations(&fifos)) {\n\t\tfprintf(stderr, \"Failed to reinstate monitoring with new instance of dmeventd.\\n\");\n\t\tgoto bad;\n\t}\n\n\tfini_fifos(&fifos);\n\texit(EXIT_SUCCESS);\nbad:\n\tfini_fifos(&fifos);\n\texit(EXIT_FAILURE);\n}\n\nstatic void _usage(char *prog, FILE *file)\n{\n\tfprintf(file, \"Usage:\\n\"\n\t\t\"%s [-d [-d [-d]]] [-f] [-h] [-l] [-R] [-V] [-?]\\n\\n\"\n\t\t\"   -d       Log debug messages to syslog (-d, -dd, -ddd)\\n\"\n\t\t\"   -f       Don't fork, run in the foreground\\n\"\n\t\t\"   -h       Show this help information\\n\"\n\t\t\"   -l       Log to stdout,stderr instead of syslog\\n\"\n\t\t\"   -?       Show this help information on stderr\\n\"\n\t\t\"   -R       Restart dmeventd\\n\"\n\t\t\"   -V       Show version of dmeventd\\n\\n\", prog);\n}\n\nint main(int argc, char *argv[])\n{\n\tsigned char opt;\n\tstruct dm_event_fifos fifos = {\n\t\t.client = -1,\n\t\t.server = -1,\n\t\t.client_path = DM_EVENT_FIFO_CLIENT,\n\t\t.server_path = DM_EVENT_FIFO_SERVER\n\t};\n\ttime_t now, idle_exit_timeout = DMEVENTD_IDLE_EXIT_TIMEOUT;\n\topterr = 0;\n\toptind = 0;\n\n\twhile ((opt = getopt(argc, argv, \"?fhVdlR\")) != EOF) {\n\t\tswitch (opt) {\n\t\tcase 'h':\n\t\t\t_usage(argv[0], stdout);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase '?':\n\t\t\t_usage(argv[0], stderr);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase 'R':\n\t\t\t_restart++;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t_foreground++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t_debug_level++;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t_use_syslog = 0;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprintf(\"dmeventd version: %s\\n\", DM_LIB_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\t}\n\n\tif (!_foreground && !_use_syslog) {\n\t\tprintf(\"WARNING: Ignoring logging to stdout, needs options -f\\n\");\n\t\t_use_syslog = 1;\n\t}\n\t/*\n\t * Switch to C locale to avoid reading large locale-archive file\n\t * used by some glibc (on some distributions it takes over 100MB).\n\t * Daemon currently needs to use mlockall().\n\t */\n\tif (setenv(\"LC_ALL\", \"C\", 1))\n\t\tperror(\"Cannot set LC_ALL to C\");\n\n\tif (_restart)\n\t\t_restart_dmeventd();\n\n#ifdef __linux__\n\t_systemd_activation = _systemd_handover(&fifos);\n#endif\n\n\tif (!_foreground)\n\t\t_daemonize();\n\n\tif (_use_syslog)\n\t\topenlog(\"dmeventd\", LOG_PID, LOG_DAEMON);\n\n\tdm_event_log_set(_debug_level, _use_syslog);\n\tdm_log_with_errno_init(_libdm_log);\n\n\t(void) dm_prepare_selinux_context(DMEVENTD_PIDFILE, S_IFREG);\n\tif (dm_create_lockfile(DMEVENTD_PIDFILE) == 0)\n\t\texit(EXIT_FAILURE);\n\n\tatexit(_remove_files_on_exit);\n\t(void) dm_prepare_selinux_context(NULL, 0);\n\n\t/* Set the rest of the signals to cause '_exit_now' to be set */\n\tsignal(SIGTERM, &_exit_handler);\n\tsignal(SIGINT, &_exit_handler);\n\tsignal(SIGHUP, &_exit_handler);\n\tsignal(SIGQUIT, &_exit_handler);\n\n#ifdef __linux__\n\t/* Systemd has adjusted oom killer for us already */\n\tif (!_systemd_activation && !_protect_against_oom_killer())\n\t\tlog_warn(\"WARNING: Failed to protect against OOM killer.\");\n#endif\n\n\t_init_thread_signals();\n\n\tpthread_mutex_init(&_global_mutex, NULL);\n\n\tif (!_systemd_activation && !_open_fifos(&fifos))\n\t\texit(EXIT_FIFO_FAILURE);\n\n\t/* Signal parent, letting them know we are ready to go. */\n\tif (!_foreground)\n\t\tkill(getppid(), SIGTERM);\n\n\tlog_notice(\"dmeventd ready for processing.\");\n\n\t_idle_since = time(NULL);\n\n\tif (_initial_registrations)\n\t\t_process_initial_registrations();\n\n\tfor (;;) {\n\t\tif (_idle_since) {\n\t\t\tif (_exit_now) {\n\t\t\t\tif (_exit_now == DM_SCHEDULED_EXIT)\n\t\t\t\t\tbreak; /* Only prints shutdown message */\n\t\t\t\tlog_info(\"dmeventd detected break while being idle \"\n\t\t\t\t\t \"for %ld second(s), exiting.\",\n\t\t\t\t\t (long) (time(NULL) - _idle_since));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (idle_exit_timeout) {\n\t\t\t\tnow = time(NULL);\n\t\t\t\tif (now < _idle_since)\n\t\t\t\t\t_idle_since = now; /* clock change? */\n\t\t\t\tnow -= _idle_since;\n\t\t\t\tif (now >= idle_exit_timeout) {\n\t\t\t\t\tlog_info(\"dmeventd was idle for %ld second(s), \"\n\t\t\t\t\t\t \"exiting.\", (long) now);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (_exit_now == DM_SIGNALED_EXIT) {\n\t\t\t_exit_now = DM_SCHEDULED_EXIT;\n\t\t\t/*\n\t\t\t * When '_exit_now' is set, signal has been received,\n\t\t\t * but can not simply exit unless all\n\t\t\t * threads are done processing.\n\t\t\t */\n\t\t\tlog_info(\"dmeventd received break, scheduling exit.\");\n\t\t}\n\t\t_process_request(&fifos);\n\t\t_cleanup_unused_threads();\n\t}\n\n\tpthread_mutex_destroy(&_global_mutex);\n\n\tlog_notice(\"dmeventd shutting down.\");\n\n\tif (fifos.client >= 0 && close(fifos.client))\n\t\tlog_sys_error(\"client close\", fifos.client_path);\n\tif (fifos.server >= 0 && close(fifos.server))\n\t\tlog_sys_error(\"server close\", fifos.server_path);\n\n\tif (_use_syslog)\n\t\tcloselog();\n\n\t_exit_dm_lib();\n\n\texit(EXIT_SUCCESS);\n}\n"
    },
    "skipped": [],
    "total_files": 1035
}