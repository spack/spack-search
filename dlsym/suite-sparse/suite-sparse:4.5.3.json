{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/README.txt": "LDL Copyright (c) 2005-2013 by Timothy A. Davis. http://www.suitesparse.com\n\nLDL: a sparse LDL' factorization and solve package.\n    Written in C, with both a C and MATLAB mexFunction interface. \n\nThese routines are not terrifically fast (they do not use dense matrix kernels),\nbut the code is very short and concise.  The purpose is to illustrate the\nalgorithms in a very concise and readable manner, primarily for educational\npurposes.  Although the code is very concise, this package is slightly faster\nthan the built-in sparse Cholesky factorization in MATLAB 6.5 (chol), when\nusing the same input permutation.\n\nRequires SuiteSparse_config, in the ../SuiteSparse_config directory relative to\nthis directory.\n\nQuick start (Unix, or Windows with Cygwin):\n\n    To compile, test, and install LDL, you may wish to first obtain a copy of\n    AMD from http://www.suitesparse.com and place it in the\n    ../AMD directory, relative to this directory.  Next, type \"make\", which\n    will compile the LDL library and three demo main programs (one of which\n    requires AMD).  It will also compile the LDL MATLAB mexFunction (if you\n    have MATLAB).  Typing \"make clean\" will remove non-essential files.\n    AMD v2.4 or later is required.  Its use is optional.\n\nQuick start (for MATLAB users);\n\n    To compile, test, and install the LDL mexFunctions (ldlsparse and\n    ldlsymbol), start MATLAB in this directory and type ldl_install.\n    This works on any system supported by MATLAB.\n\n--------------------------------------------------------------------------------\n\nLDL License: see LDL/Doc/License.txt for the license\n\nAvailability:\n\n    http://www.suitesparse.com\n\nAcknowledgements:\n\n    This work was supported by the National Science Foundation, under\n    grant CCR-0203270.\n\n    Portions of this work were done while on sabbatical at Stanford University\n    and Lawrence Berkeley National Laboratory (with funding from the SciDAC\n    program).  I would like to thank Gene Golub, Esmond Ng, and Horst Simon\n    for making this sabbatical possible.  I would like to thank Pete Stewart\n    for his comments on a draft of this software and paper.\n\n--------------------------------------------------------------------------------\nFiles and directories in this distribution:\n--------------------------------------------------------------------------------\n\n    Documentation, and compiling:\n\n\tREADME.txt\tthis file\n\tMakefile\tfor compiling LDL\n\tChangeLog\tchanges since V1.0 (Dec 31, 2003)\n\tLicense.txt\tlicense\n\n\tldl_userguide.pdf   user guide in PDF\n\tldl_userguide.ps    user guide in postscript\n\tldl_userguide.tex   user guide in Latex\n\tldl.bib\t\t    bibliography for user guide\n\n    The LDL library itself:\n\n\tldl.c\t\tthe C-callable routines\n\tldl.h\t\tinclude file for any code that calls LDL\n\n    A simple C main program that demonstrates how to use LDL:\n\n\tldlsimple.c\ta stand-alone C program, uses the basic features of LDL\n\tldlsimple.out\toutput of ldlsimple\n\n\tldllsimple.c\tlong integer version of ldlsimple.c\n\n    Demo C program, for testing LDL and providing an example of its use\n\n\tldlmain.c\ta stand-alone C main program that uses and tests LDL\n\tMatrix\t\ta directory containing matrices used by ldlmain.c\n\tldlmain.out\toutput of ldlmain\n\tldlamd.out\toutput of ldlamd (ldlmain.c compiled with AMD)\n\tldllamd.out\toutput of ldllamd (ldlmain.c compiled with AMD, long)\n\n    MATLAB-related, not required for use in a regular C program\n\n\tContents.m\ta list of the MATLAB-callable routines\n\tldl.m\t\tMATLAB help file for the LDL mexFunction\n\tldldemo.m\tMATLAB demo of how to use the LDL mexFunction\n\tldldemo.out\tdiary output of ldldemo\n\tldltest.m\tto test the LDL mexFunction\n\tldltest.out\tdiary output of ldltest\n\tldlmex.c\tthe LDL mexFunction for MATLAB\n\tldlrow.m\tthe numerical algorithm that LDL is based on\n\tldlmain2.m\tcompiles and runs ldlmain.c as a MATLAB mexFunction\n\tldlmain2.out\toutput of ldlmain2.m\n\tldlsymbolmex.c\tsymbolic factorization using LDL (see SYMBFACT, ETREE)\n\tldlsymbol.m\thelp file for the LDLSYMBOL mexFunction\n\n\tldl_install.m\tcompile, install, and test LDL functions\n\tldl_make.m\tcompile LDL (ldlsparse and ldlsymbol)\n\n\tldlsparse.m\thelp for ldlsparse\n\nSee ldl.c for a description of how to use the code from a C program.  Type\n\"help ldl\" in MATLAB for information on how to use LDL in a MATLAB program.\n",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/Doc/ldl_userguide.tex": "\\documentclass[12pt]{article}\n\n\\newcommand{\\m}[1]{{\\bf{#1}}}       % for matrices and vectors\n\\newcommand{\\tr}{^{\\sf T}}          % transpose\n\n\\topmargin 0in\n\\textheight 9in\n\\oddsidemargin 0pt\n\\evensidemargin 0pt\n\\textwidth 6.5in\n\n%-------------------------------------------------------------------------------\n\\begin{document}\n%-------------------------------------------------------------------------------\n\n\\title{User Guide for LDL, a concise sparse Cholesky package}\n\\author{Timothy A. Davis\\thanks{\nemail: DrTimothyAldenDavis@gmail.com,\nhttp://www.suitesparse.com.\nThis work was supported by the National\nScience Foundation, under grant CCR-0203270.\nPortions of the work were done while on sabbatical at Stanford University\nand Lawrence Berkeley National Laboratory (with funding from Stanford\nUniversity and the SciDAC program).\n}}\n\n\\date{VERSION 2.2.6, May 4, 2016}\n\n\\maketitle\n\n%-------------------------------------------------------------------------------\n\\begin{abstract}\nThe {\\tt LDL} software package is a set of short, concise routines for\nfactorizing symmetric positive-definite sparse matrices, with some\napplicability to symmetric indefinite matrices.  Its primary purpose is\nto illustrate much of the basic theory of sparse matrix algorithms in as\nconcise a code as possible, including an elegant method\nof sparse symmetric factorization that computes the factorization row-by-row\nbut stores it column-by-column.  The entire symbolic and numeric factorization\nconsists of less than 50 lines of code.  The package is written in C,\nand includes a MATLAB interface.\n\\end{abstract}\n%-------------------------------------------------------------------------------\n\n%-------------------------------------------------------------------------------\n\\section{Overview}\n%-------------------------------------------------------------------------------\n\n{\\tt LDL} is a set of short, concise routines that compute the $\\m{LDL}\\tr$\nfactorization of a sparse symmetric matrix $\\m{A}$.  Its primary purpose is\nto illustrate much of the basic theory of sparse matrix algorithms in as\ncompact a code as possible, including an elegant method of\nsparse symmetric factorization (related to \\cite{Liu86c,Liu91}).\nThe lower triangular factor $\\m{L}$ is computed row-by-row, in contrast to the\nconventional column-by-column method.\nAlthough it does not achieve the same level of performance\nas methods based on dense matrix kernels\n(such as \\cite{NgPeyton93,RothbergGupta91}),\nits performance is competitive with column-by-column methods that do not\nuse dense kernels \\cite{GeorgeLiu79, GeorgeLiu, GilbertMolerSchreiber}.\n\nSection~\\ref{Algorithm} gives a brief description of the algorithm\nused in the symbolic and numeric factorization.  A more detailed tutorial-level\ndiscussion may be found in \\cite{Stewart03}.  Details\nof the concise implementation of this method are given in\nSection~\\ref{Implementation}.  Sections~\\ref{MATLAB}~and~\\ref{C} give an\noverview of how to use the package in MATLAB and in a stand-alone C program.\n\n%-------------------------------------------------------------------------------\n\\section{Algorithm}\n\\label{Algorithm}\n%-------------------------------------------------------------------------------\n\nThe underlying numerical algorithm is described below.  The $k$th\nstep solves a lower triangular system of dimension $k-1$ to compute the\n$k$th row of $\\m{L}$ and the $d_{kk}$ entry of the diagonal matrix $\\m{D}$.\nColon notation is used for submatrices.  For example,\n$\\m{L}_{k,1:k-1}$ refers to the first $k-1$ columns of\nthe $k$th row of $\\m{L}$.  Similarly, $\\m{L}_{1:k-1,1:k-1}$ refers to\nthe leading $(k-1)$-by-$(k-1)$ submatrix of $\\m{L}$.\n%---------------\n\\vspace{-0.2in}\n\\begin{tabbing}\n\\hspace{2em} \\= \\hspace{2em} \\= \\hspace{2em} \\= \\\\\n{\\bf Algorithm~1\n($\\m{LDL}\\tr$ factorization of a $n$-by-$n$ symmetric matrix $\\m{A}$)} \\\\\n\\> {\\bf for} $k = 1$ {\\bf to} $n$ \\\\\n\\>\\> (step 1) Solve $\\m{L}_{1:k-1,1:k-1}\\m{y} = \\m{A}_{1:k-1,k}$ for $\\m{y}$ \\\\\n\\>\\> (step 2) $\\m{L}_{k,1:k-1} = (\\m{D}_{1:k-1,1:k-1}^{-1} \\m{y})\\tr$ \\\\\n\\>\\> (step 3) $l_{kk} = 1$ \\\\\n\\>\\> (step 4) $d_{kk} = a_{kk} - \\m{L}_{k,1:k-1}\\m{y}$ \\\\\n\\> {\\bf end for}\n\\end{tabbing}\n%---------------\n\nThe algorithm computes an $\\m{LDL}\\tr$ factorization without numerical pivoting.\nIt can thus factorize any symmetric positive definite matrix, and any\nsymmetric indefinite matrix whose leading minors are all well-conditioned.\n\nWhen $\\m{A}$ and $\\m{L}$ are sparse, step 1 of Algorithm~1 requires a\ntriangular solve of the form $\\m{Lx}=\\m{b}$, where all three terms in\nthe equation are sparse.  This is the most costly step of the Algorithm.\nSteps 2 through 4 are fairly straightforward.\n\nLet ${\\cal X}$ and ${\\cal B}$ refer to the set of indices of nonzero entries\nin $\\m{x}$ and $\\m{b}$, respectively, in the lower triangular system\n$\\m{Lx}=\\m{b}$.  To compute $\\m{x}$ efficiently\nthe nonzero pattern ${\\cal X}$ must be found first.\nIn the general case when $\\m{L}$ is arbitrary \\cite{GilbertPeierls88},\nthe nonzero\npattern ${\\cal X}$ is the set of nodes reachable via paths in the graph $G_L$\nfrom all nodes in the set ${\\cal B}$, and where the graph $G_L$ has\n$n$ nodes and a directed edge $(j,i)$ if and only if $l_{ij}$ is nonzero.\nTo compute the numerical solution to $\\m{Lx}=\\m{b}$ by accessing the columns of\n$\\m{L}$ one at a time, ${\\cal X}$ can be traversed\nin any topological order of the subgraph of $G_L$ consisting of nodes in\n${\\cal X}$.  That is, $x_j$ must be computed before $x_i$ if there is a path\nfrom $j$ to $i$ in $G_L$.  The natural order ($1, 2, \\ldots, n$) is one such\nordering, but that requires a costly sort of ${\\cal X}$.\nWith a graph traversal and topological sort, the solution of $\\m{Lx}=\\m{b}$\ncan be computed using Algorithm~2 below.\nThe computation of ${\\cal X}$ and $\\m{x}$ both take\ntime proportional to the floating-point operation count.\n%---------------\n\\vspace{-0.2in}\n\\begin{tabbing}\n\\hspace{2em} \\= \\hspace{2em} \\= \\hspace{2em} \\= \\\\\n{\\bf Algorithm~2\n(Solve $\\m{Lx}=\\m{b}$, where $\\m{L}$ is lower triangular with unit diagonal)} \\\\\n\\> ${\\cal X} = \\mbox{Reach}_{G_L} ({\\cal B})$ \\\\\n\\> $\\m{x} = \\m{b}$ \\\\\n\\> {\\bf for} $i \\in {\\cal X}$ in any topological order \\\\\n\\>\\> $\\m{x}_{i+1:n} = \\m{x}_{i+1:n} - \\m{L}_{i+1:n,i} x_i$ \\\\\n\\> {\\bf end for}\n\\end{tabbing}\n%---------------\n\nThe general result also governs the pattern of $\\m{y}$ in Algorithm~1.\nHowever, in this case $\\m{L}$ arises from a sparse Cholesky factorization,\nand is governed by the elimination tree \\cite{Liu90a}.\nA general graph traversal is not required.\nIn the elimination tree, the parent of node $i$ is the smallest $j > i$\nsuch that $l_{ji}$ is nonzero.  Node $i$ has no parent if column $i$ of\n$\\m{L}$ is completely zero below the diagonal; $i$ is a root of the\nelimination tree in this case.  The nonzero pattern of $\\m{x}$ is the\nunion of all the nodes on the paths from any node $i$ (where $b_i$ is nonzero) to the\nroot of the elimination tree \\cite[Thm 2.4]{Liu86c}.  It is referred to here as a tree,\nbut in general it can be a forest.\n\nRather than a general topological sort of the subgraph of $G_L$ consisting\nnodes reachable from nodes in ${\\cal B}$, a simpler\ntree traversal can be used.  First, select any nonzero entry $b_i$\nand follow the path from $i$ to the root of tree.\nNodes along this path are marked and placed in a stack,\nwith $i$ at the top of the\nstack and the root at the bottom.\nRepeat for every other nonzero entry in $b_i$, in arbitrary order, but stop\njust before reaching a marked node (the result can be empty if $i$ is already\nin the stack).  The stack now contains ${\\cal X}$, a topological ordering of\nthe nonzero pattern of $\\m{x}$, which can be used in Algorithm~2 to solve\n$\\m{Lx}=\\m{b}$.  The time to compute ${\\cal X}$\nusing an elimination tree traversal is much faster than the general graph\ntraversal, taking time proportional to the size of ${\\cal X}$ rather than the\nnumber of floating-point operations required to compute $\\m{x}$.\n\nIn the $k$th step of the factorization, the set ${\\cal X}$ becomes the\nnonzero pattern of row $k$ of $\\m{L}$.  This step requires the elimination\ntree of $\\m{L}_{1:k-1,1:k-1}$, and must construct the elimination tree of\n$\\m{L}_{1:k,1:k}$ for step $k+1$.  Recall that the parent of $i$ in the\ntree is the smallest $j$ such that $i < j$ and $l_{ji} \\ne 0$.\nThus, if any node $i$ already has a parent $j$, then $j$ will remain the\nparent of $i$ in the elimination trees of all other larger leading submatrices\nof $\\m{L}$, and in the elimination tree of $\\m{L}$ itself.\nIf $l_{ki} \\ne 0$ and $i$ does not have a parent in the elimination tree of\n$\\m{L}_{1:k-1,1:k-1}$, then the parent of $i$ is $k$\nin the elimination tree of $\\m{L}_{1:k,1:k}$.\nNode $k$ becomes the parent of any node $i \\in {\\cal X}$ that does not yet\nhave a parent.\n\nSince Algorithm~2 traverses $\\m{L}$ in column order, $\\m{L}$ is stored in a\nconventional sparse column representation.  Each column $j$ is stored as a list\nof nonzero values and their corresponding row indices.  When row $k$ is\ncomputed, the new entries can be placed at the end of each list.  As\na by-product of computing $\\m{L}$ one row at a time,\nthe columns of $\\m{L}$ are computed in a sorted manner.  This is a convenient\nform of the output.\nMATLAB requires the columns of its sparse matrices to be sorted, for example.\nSorted columns improve the speed of Algorithm~2, since the memory access\npattern is more regular.  The conventional column-by-column algorithm\n\\cite{GeorgeLiu79,GeorgeLiu} does not produce columns of $\\m{L}$ with\nsorted row indices.\n\nA simple symbolic pre-analysis can be obtained by repeating the subtree traversals.\nAll that is required to compute the nonzero pattern of\nthe $k$th row of $\\m{L}$ is the partially constructed elimination tree\nand the nonzero pattern of the $k$th column of $\\m{A}$.  This is computed\nin time proportional to the size of this set, using the elimination tree\ntraversal.  Once constructed, the number of nonzeros in each column of\n$\\m{L}$ is incremented, for each entry in ${\\cal X}$, and then ${\\cal X}$\nis discarded.  The set ${\\cal X}$ need not be constructed in topological\norder, so no stack is required.  The run time of the symbolic analysis\nalgorithm is thus proportional to the number of nonzeros in $\\m{L}$.\nThis is more costly than the optimal algorithm \\cite{GilbertNgPeyton94},\nwhich takes time essentially proportional to the number of nonzeros in $\\m{A}$.\nThe memory requirements are just the matrix $\\m{A}$ and a few size-$n$ integer\narrays.  The result of the algorithm is the elimination tree, a count\nof the number of nonzeros in each column of $\\m{L}$, and\nthe cumulative sum of the column counts.\n\n%-------------------------------------------------------------------------------\n\\section{Implementation}\n\\label{Implementation}\n%-------------------------------------------------------------------------------\n\nBecause of its simplicity, the implementation of this algorithm leads to\na very short, concise code.  The symbolic analysis routine {\\tt ldl\\_symbolic}\nshown in Figure~\\ref{ldlsymbolic}\nconsists of only 18 lines of executable C code.\nThis includes 5 lines of code to allow for a\nsparsity-preserving ordering $\\m{P}$ so that either $\\m{A}$ or $\\m{PAP}\\tr$\ncan be analyzed, 3 lines of code to compute the cumulative sum of\nthe column counts, and one line of code to speed up a {\\tt for} loop.\nAn additional line of code allows for a more general form of the input\nsparse matrix $\\m{A}$.\n\nThe {\\tt n}-by-{\\tt n} sparse matrix $\\m{A}$ is provided in compressed column\nform as an {\\tt int} array {\\tt Ap} of length {\\tt n+1},\nan {\\tt int} array {\\tt Ai} of length {\\tt nz},\nand a {\\tt double} array {\\tt Ax} also of length {\\tt nz},\nwhere {\\tt nz} is the number of entries in the matrix.\nThe numerical values of entries in column $j$ are stored in\n{\\tt Ax[Ap[j]} $\\ldots$ {\\tt Ap[j+1]-1]}\nand the corresponding row indices are in\n{\\tt Ai[Ap[j]} $\\ldots$ {\\tt Ap[j+1]-1]}.\nWith {\\tt Ap[0] = 0}, the number of entries in the matrix is {\\tt nz = Ap[n]}.\nIf no fill-reducing ordering {\\tt P} is provided,\nonly entries in the upper triangular part of $\\m{A}$ are considered.\nIf {\\tt P} is provided and row/column {\\tt i} of the\nmatrix $\\m{A}$ is the {\\tt k}-th row/column of $\\m{PAP}\\tr$, then {\\tt P[k]=i}.\nOnly entries in the upper\ntriangular part of $\\m{PAP}\\tr$ are considered.  These entries may be\nin the lower triangular part of $\\m{A}$, so to ensure that the correct matrix\nis factorized, all entries of $\\m{A}$ should be provided when using the\npermutation input {\\tt P}.\n\nThe outputs of {\\tt ldl\\_symbolic} are three size-{\\tt n} arrays:\n{\\tt Parent} holds the elimination tree,\n{\\tt Lnz} holds the counts of the number of entries in each column of\n$\\m{L}$, and\n{\\tt Lp} holds the cumulative sum of {\\tt Lnz}.\nThe size-{\\tt n} array {\\tt Flag} is used as workspace.\nNone of the output or workspace arrays need to be initialized.\n\n\\begin{figure}\n\\caption{{\\tt ldl\\_symbolic:} finding the elimination tree and column counts}\n\\label{ldlsymbolic}\n{\\scriptsize\n\\begin{verbatim}\nvoid ldl_symbolic\n(\n    int n,              /* A and L are n-by-n, where n >= 0 */\n    int Ap [ ],         /* input of size n+1, not modified */\n    int Ai [ ],         /* input of size nz=Ap[n], not modified */\n    int Lp [ ],         /* output of size n+1, not defined on input */\n    int Parent [ ],     /* output of size n, not defined on input */\n    int Lnz [ ],        /* output of size n, not defined on input */\n    int Flag [ ],       /* workspace of size n, not defn. on input or output */\n    int P [ ],          /* optional input of size n */\n    int Pinv [ ]        /* optional output of size n (used if P is not NULL) */\n)\n{\n    int i, k, p, kk, p2 ;\n    if (P)\n    {\n        /* If P is present then compute Pinv, the inverse of P */\n        for (k = 0 ; k < n ; k++)\n        {\n            Pinv [P [k]] = k ;\n        }\n    }\n    for (k = 0 ; k < n ; k++)\n    {\n        /* L(k,:) pattern: all nodes reachable in etree from nz in A(0:k-1,k) */\n        Parent [k] = -1 ;           /* parent of k is not yet known */\n        Flag [k] = k ;              /* mark node k as visited */\n        Lnz [k] = 0 ;               /* count of nonzeros in column k of L */\n        kk = (P) ? (P [k]) : (k) ;  /* kth original, or permuted, column */\n        p2 = Ap [kk+1] ;\n        for (p = Ap [kk] ; p < p2 ; p++)\n        {\n            /* A (i,k) is nonzero (original or permuted A) */\n            i = (Pinv) ? (Pinv [Ai [p]]) : (Ai [p]) ;\n            if (i < k)\n            {\n                /* follow path from i to root of etree, stop at flagged node */\n                for ( ; Flag [i] != k ; i = Parent [i])\n                {\n                    /* find parent of i if not yet determined */\n                    if (Parent [i] == -1) Parent [i] = k ;\n                    Lnz [i]++ ;                         /* L (k,i) is nonzero */\n                    Flag [i] = k ;                      /* mark i as visited */\n                }\n            }\n        }\n    }\n    /* construct Lp index array from Lnz column counts */\n    Lp [0] = 0 ;\n    for (k = 0 ; k < n ; k++)\n    {\n        Lp [k+1] = Lp [k] + Lnz [k] ;\n    }\n}\n\\end{verbatim}\n}\n\\end{figure}\n\nThe {\\tt ldl\\_numeric} numeric factorization routine shown\nin Figure~\\ref{ldlnumeric} consists of only 31 lines of\nexecutable code.  It includes this same subtree traversal algorithm\nas {\\tt ldl\\_symbolic},\nexcept that each path is placed on a stack that holds\nnonzero pattern of the $k$th row of $\\m{L}$.\nThis traversal is followed by a sparse forward solve\nusing this pattern, and all of the nonzero entries in\nthe resulting $k$th row of $\\m{L}$ are appended to their respective columns\nin the data structure of $\\m{L}$.\n\n\\begin{figure}\n\\caption{{\\tt ldl\\_numeric:} numeric factorization}\n\\label{ldlnumeric}\n{\\scriptsize\n\\begin{verbatim}\nint ldl_numeric         /* returns n if successful, k if D (k,k) is zero */\n(\n    int n,              /* A and L are n-by-n, where n >= 0 */\n    int Ap [ ],         /* input of size n+1, not modified */\n    int Ai [ ],         /* input of size nz=Ap[n], not modified */\n    double Ax [ ],      /* input of size nz=Ap[n], not modified */\n    int Lp [ ],         /* input of size n+1, not modified */\n    int Parent [ ],     /* input of size n, not modified */\n    int Lnz [ ],        /* output of size n, not defn. on input */\n    int Li [ ],         /* output of size lnz=Lp[n], not defined on input */\n    double Lx [ ],      /* output of size lnz=Lp[n], not defined on input */\n    double D [ ],       /* output of size n, not defined on input */\n    double Y [ ],       /* workspace of size n, not defn. on input or output */\n    int Pattern [ ],    /* workspace of size n, not defn. on input or output */\n    int Flag [ ],       /* workspace of size n, not defn. on input or output */\n    int P [ ],          /* optional input of size n */\n    int Pinv [ ]        /* optional input of size n */\n)\n{\n    double yi, l_ki ;\n    int i, k, p, kk, p2, len, top ;\n    for (k = 0 ; k < n ; k++)\n    {\n        /* compute nonzero Pattern of kth row of L, in topological order */\n        Y [k] = 0.0 ;               /* Y(0:k) is now all zero */\n        top = n ;                   /* stack for pattern is empty */\n        Flag [k] = k ;              /* mark node k as visited */\n        Lnz [k] = 0 ;               /* count of nonzeros in column k of L */\n        kk = (P) ? (P [k]) : (k) ;  /* kth original, or permuted, column */\n        p2 = Ap [kk+1] ;\n        for (p = Ap [kk] ; p < p2 ; p++)\n        {\n            i = (Pinv) ? (Pinv [Ai [p]]) : (Ai [p]) ;   /* get A(i,k) */\n            if (i <= k)\n            {\n                Y [i] += Ax [p] ;  /* scatter A(i,k) into Y (sum duplicates) */\n                for (len = 0 ; Flag [i] != k ; i = Parent [i])\n                {\n                    Pattern [len++] = i ;   /* L(k,i) is nonzero */\n                    Flag [i] = k ;          /* mark i as visited */\n                }\n                while (len > 0) Pattern [--top] = Pattern [--len] ;\n            }\n        }\n        /* compute numerical values kth row of L (a sparse triangular solve) */\n        D [k] = Y [k] ;             /* get D(k,k) and clear Y(k) */\n        Y [k] = 0.0 ;\n        for ( ; top < n ; top++)\n        {\n            i = Pattern [top] ;     /* Pattern [top:n-1] is pattern of L(:,k) */\n            yi = Y [i] ;            /* get and clear Y(i) */\n            Y [i] = 0.0 ;\n            p2 = Lp [i] + Lnz [i] ;\n            for (p = Lp [i] ; p < p2 ; p++)\n            {\n                Y [Li [p]] -= Lx [p] * yi ;\n            }\n            l_ki = yi / D [i] ;     /* the nonzero entry L(k,i) */\n            D [k] -= l_ki * yi ;\n            Li [p] = k ;            /* store L(k,i) in column form of L */\n            Lx [p] = l_ki ;\n            Lnz [i]++ ;             /* increment count of nonzeros in col i */\n        }\n        if (D [k] == 0.0) return (k) ;      /* failure, D(k,k) is zero */\n    }\n    return (n) ;        /* success, diagonal of D is all nonzero */\n}\n\\end{verbatim}\n}\n\\end{figure}\n\nAfter the matrix is factorized, the {\\tt ldl\\_lsolve}, {\\tt ldl\\_dsolve},\nand {\\tt ldl\\_ltsolve} routines shown in Figure~\\ref{ldlsolve}\nare provided to solve\n$\\m{Lx}=\\m{b}$, $\\m{Dx}=\\m{b}$, and $\\m{L}\\tr\\m{x}=\\m{b}$, respectively.\nTogether, they solve $\\m{Ax}=\\m{b}$, and consist of only 10 lines of executable\ncode.  If a fill-reducing permutation is used,\n{\\tt ldl\\_perm} and {\\tt ldl\\_permt} must be used to permute $\\m{b}$ and\n$\\m{x}$ accordingly.\n\n\\begin{figure}\n\\caption{Solve routines}\n\\label{ldlsolve}\n{\\scriptsize\n\\begin{verbatim}\nvoid ldl_lsolve\n(\n    int n,              /* L is n-by-n, where n >= 0 */\n    double X [ ],       /* size n.  right-hand-side on input, soln. on output */\n    int Lp [ ],         /* input of size n+1, not modified */\n    int Li [ ],         /* input of size lnz=Lp[n], not modified */\n    double Lx [ ]       /* input of size lnz=Lp[n], not modified */\n)\n{\n    int j, p, p2 ;\n    for (j = 0 ; j < n ; j++)\n    {\n        p2 = Lp [j+1] ;\n        for (p = Lp [j] ; p < p2 ; p++)\n        {\n            X [Li [p]] -= Lx [p] * X [j] ;\n        }\n    }\n}\n\nvoid ldl_dsolve\n(\n    int n,              /* D is n-by-n, where n >= 0 */\n    double X [ ],       /* size n.  right-hand-side on input, soln. on output */\n    double D [ ]        /* input of size n, not modified */\n)\n{\n    int j ;\n    for (j = 0 ; j < n ; j++)\n    {\n        X [j] /= D [j] ;\n    }\n}\n\nvoid ldl_ltsolve\n(\n    int n,              /* L is n-by-n, where n >= 0 */\n    double X [ ],       /* size n.  right-hand-side on input, soln. on output */\n    int Lp [ ],         /* input of size n+1, not modified */\n    int Li [ ],         /* input of size lnz=Lp[n], not modified */\n    double Lx [ ]       /* input of size lnz=Lp[n], not modified */\n)\n{\n    int j, p, p2 ;\n    for (j = n-1 ; j >= 0 ; j--)\n    {\n        p2 = Lp [j+1] ;\n        for (p = Lp [j] ; p < p2 ; p++)\n        {\n            X [j] -= Lx [p] * X [Li [p]] ;\n        }\n    }\n}\n\\end{verbatim}\n}\n\\end{figure}\n\nIn addition to appearing as a Collected Algorithm of the ACM \\cite{Davis05},\n{\\tt LDL} is available at http://www.suitesparse.com.\n\n%-------------------------------------------------------------------------------\n\\section{Using LDL in MATLAB}\n\\label{MATLAB}\n%-------------------------------------------------------------------------------\n\nThe simplest way to use {\\tt LDL} is within MATLAB.  Once the {\\tt ldlsparse}\nmexFunction is compiled and installed, the MATLAB statement\n{\\tt [L, D, Parent, fl] = ldlsparse (A)} returns the sparse factorization\n{\\tt A = (L+I)*D*(L+I)'}, where {\\tt L} is lower triangular, {\\tt D} is a\ndiagonal matrix, and {\\tt I} is the {\\tt n}-by-{\\tt n}\nidentity matrix ({\\tt ldlsparse} does not return the unit diagonal of {\\tt L}).\nThe elimination tree is returned in {\\tt Parent}.\nIf no zero on the diagonal of {\\tt D} is encountered, {\\tt fl} is the\nfloating-point operation count.  Otherwise, {\\tt D(-fl,-fl)} is the first\nzero entry encountered.  Let {\\tt d=-fl}.  The function returns the\nfactorization of {\\tt A (1:d,1:d)}, where rows {\\tt d+1} to {\\tt n} of {\\tt L}\nand {\\tt D} are all zero.  If a sparsity preserving permutation {\\tt P} is\npassed, {\\tt [L, D, Parent, fl] = ldlsparse (A,P)}\noperates on {\\tt A(P,P)} without\nforming it explicitly.\n\nThe statement {\\tt x = ldlsparse (A, [ ], b)} is roughly equivalent to\n{\\tt x = A}$\\backslash${\\tt b}, when {\\tt A} is sparse, real, and symmetric.\nThe $\\m{LDL}\\tr$ factorization of {\\tt A} is performed.  If {\\tt P} is\nprovided, {\\tt x = ldlsparse (A, P, b)} still performs\n{\\tt x = A}$\\backslash${\\tt b}, except that {\\tt A(P,P)} is factorized\ninstead.\n\n%-------------------------------------------------------------------------------\n\\section{Using LDL in a C program}\n\\label{C}\n%-------------------------------------------------------------------------------\n\nTo compile the library, do {\\tt make}.  To install the shared library in\n/usr/local/include and /usr/local/lib, do {\\tt make install}; to remove it\nfrom there, use {\\tt make uninstall}.\nFor alternative installation locations, see the instructions in\n{\\tt SuiteSparse/README.txt}.\n\nThe C-callable {\\tt LDL} library consists of nine user-callable routines\nand one include file.\n\n\\begin{itemize}\n\\item {\\tt ldl\\_symbolic}:  given the nonzero pattern of a sparse symmetric\n    matrix $\\m{A}$ and an optional permutation $\\m{P}$, analyzes either\n    $\\m{A}$ or $\\m{PAP}\\tr$, and returns the elimination tree, the\n    number of nonzeros in each column of $\\m{L}$, and the {\\tt Lp} array\n    for the sparse matrix data structure for $\\m{L}$.\n    Duplicate entries are allowed in the columns of $\\m{A}$, and the\n    row indices in each column need not be sorted.\n    Providing a sparsity-preserving ordering is critical for obtaining\n    good performance.  A minimum degree ordering\n    (such as AMD \\cite{AmestoyDavisDuff96,AmestoyDavisDuff03})\n    or a graph-partitioning based ordering are appropriate.\n\\item {\\tt ldl\\_numeric}:  given {\\tt Lp} and the elimination tree computed\n    by {\\tt ldl\\_symbolic}, and an optional permutation $\\m{P}$,\n    returns the numerical factorization of $\\m{A}$ or $\\m{PAP}\\tr$.\n    Duplicate entries are allowed in the columns of $\\m{A}$\n    (any duplicate entries are summed), and the\n    row indices in each column need not be sorted.\n    The data structure for $\\m{L}$ is the same as $\\m{A}$, except that\n    no duplicates appear, and each column has sorted row indices.\n\\item {\\tt ldl\\_lsolve}:  given the factor $\\m{L}$ computed by\n    {\\tt ldl\\_numeric}, solves the linear system $\\m{Lx}=\\m{b}$, where\n    $\\m{x}$ and $\\m{b}$ are full $n$-by-1 vectors.\n\\item {\\tt ldl\\_dsolve}:  given the factor $\\m{D}$ computed by\n    {\\tt ldl\\_numeric}, solves the linear system $\\m{Dx}=\\m{b}$.\n\\item {\\tt ldl\\_ltsolve}:  given the factor $\\m{L}$ computed by\n    {\\tt ldl\\_numeric}, solves the linear system $\\m{L}\\tr\\m{x}=\\m{b}$.\n\\item {\\tt ldl\\_perm}: given a vector $\\m{b}$ and a permutation $\\m{P}$,\n    returns $\\m{x}=\\m{Pb}$.\n\\item {\\tt ldl\\_permt}: given a vector $\\m{b}$ and a permutation $\\m{P}$,\n    returns $\\m{x}=\\m{P}\\tr\\m{b}$.\n\\item {\\tt ldl\\_valid\\_perm}:  Except for checking if the diagonal of\n    $\\m{D}$ is zero, none of the above routines check their inputs for errors.\n    This routine checks the validity of a permutation $\\m{P}$.\n\\item {\\tt ldl\\_valid\\_matrix}:  checks if a matrix $\\m{A}$ is valid as input\n    to {\\tt ldl\\_symbolic} and {\\tt ldl\\_numeric}.\n\\end{itemize}\n\nNote that the primary input to the {\\tt ldl\\_symbolic} and\n{\\tt ldl\\_numeric} is the sparse matrix $\\m{A}$.  It is provided in\ncolumn-oriented form, and only the upper triangular part is accessed.\nThis is slightly different than the primary output: the matrix $\\m{L}$, \nwhich is lower triangular in column-oriented form.\nIf you wish to factorize a symmetric matrix $\\m{A}$ for which only the lower\ntriangular part is supplied, you would need to transpose $\\m{A}$ before\npassing it {\\tt ldl\\_symbolic} and {\\tt ldl\\_numeric}.\n\nAn additional set of routines is available for use in a 64-bit environment.\nEach routine name changes uniformly; {\\tt ldl\\_symbolic} becomes\n{\\tt ldl\\_l\\_symbolic}, and each {\\tt int} parameter becomes type\n{\\tt SuiteSparse\\_long}.  The {\\tt SuiteSparse\\_long} type is {\\tt long}, except for\nMicrosoft Windows 64, where it becomes {\\tt \\_\\_int64}.\n\n\\begin{figure}\n\\caption{Example of use}\n\\label{ldlsimple}\n{\\scriptsize\n\\begin{verbatim}\n#include <stdio.h>\n#include \"ldl.h\"\n#define N 10    /* A is 10-by-10 */\n#define ANZ 19  /* # of nonzeros on diagonal and upper triangular part of A */\n#define LNZ 13  /* # of nonzeros below the diagonal of L */\n\nint main (void)\n{\n    /* only the upper triangular part of A is required */\n    int    Ap [N+1] = {0, 1, 2, 3, 4,   6, 7,   9,   11,      15,     ANZ},\n           Ai [ANZ] = {0, 1, 2, 3, 1,4, 5, 4,6, 4,7, 0,4,7,8, 1,4,6,9 } ;\n    double Ax [ANZ] = {1.7, 1., 1.5, 1.1, .02,2.6, 1.2, .16,1.3, .09,1.6,\n                     .13,.52,.11,1.4, .01,.53,.56,3.1},\n           b [N] = {.287, .22, .45, .44, 2.486, .72, 1.55, 1.424, 1.621, 3.759};\n    double Lx [LNZ], D [N], Y [N] ;\n    int Li [LNZ], Lp [N+1], Parent [N], Lnz [N], Flag [N], Pattern [N], d, i ;\n\n    /* factorize A into LDL' (P and Pinv not used) */\n    ldl_symbolic (N, Ap, Ai, Lp, Parent, Lnz, Flag, NULL, NULL) ;\n    printf (\"Nonzeros in L, excluding diagonal: %d\\n\", Lp [N]) ;\n    d = ldl_numeric (N, Ap, Ai, Ax, Lp, Parent, Lnz, Li, Lx, D, Y, Pattern,\n        Flag, NULL, NULL) ;\n\n    if (d == N)\n    {\n        /* solve Ax=b, overwriting b with the solution x */\n        ldl_lsolve (N, b, Lp, Li, Lx) ;\n        ldl_dsolve (N, b, D) ;\n        ldl_ltsolve (N, b, Lp, Li, Lx) ;\n        for (i = 0 ; i < N ; i++) printf (\"x [%d] = %g\\n\", i, b [i]) ;\n    }\n    else\n    {\n        printf (\"ldl_numeric failed, D (%d,%d) is zero\\n\", d, d) ;\n    }\n    return (0) ;\n}\n\\end{verbatim}\n}\n\\end{figure}\n\nThe program in Figure~\\ref{ldlsimple}\nillustrates the basic usage of the {\\tt LDL} routines.\nIt analyzes and factorizes the sparse symmetric positive-definite matrix\n{\\small\n\\[\n\\m{A} = \\left[\n\\begin{array}{cccccccccc}\n      1.7 &   0 &   0 &   0 &   0 &   0 &   0 &   0 & .13 &   0 \\\\\n        0 &  1. &   0 &   0 & .02 &   0 &   0 &   0 &   0 & .01 \\\\\n        0 &   0 & 1.5 &   0 &   0 &   0 &   0 &   0 &   0 &   0 \\\\\n        0 &   0 &   0 & 1.1 &   0 &   0 &   0 &   0 &   0 &   0 \\\\\n        0 & .02 &   0 &   0 & 2.6 &   0 & .16 & .09 & .52 & .53 \\\\\n        0 &   0 &   0 &   0 &   0 & 1.2 &   0 &   0 &   0 &   0 \\\\\n        0 &   0 &   0 &   0 & .16 &   0 & 1.3 &   0 &   0 & .56 \\\\\n        0 &   0 &   0 &   0 & .09 &   0 &   0 & 1.6 & .11 &   0 \\\\\n      .13 &   0 &   0 &   0 & .52 &   0 &   0 & .11 & 1.4 &   0 \\\\\n        0 & .01 &   0 &   0 & .53 &   0 & .56 &   0 &   0 & 3.1 \\\\\n\\end{array}\n\\right]\n\\]\n}\nand then solves a system $\\m{Ax}=\\m{b}$ whose true solution is\n$x_i = i/10$.  Note that {\\tt Li} and {\\tt Lx} are statically allocated.\nNormally they would be allocated after their size, {\\tt Lp[n]},\nis determined by {\\tt ldl\\_symbolic}.\nMore example programs are included with the {\\tt LDL} package.\n\n\\section{Acknowledgments}\n\nI would like to thank Pete Stewart for his comments on an earlier draft\nof this software and its accompanying paper.\n\n\\newpage\n\\bibliographystyle{plain}\n\\bibliography{ldl}\n\n\\end{document}\n",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/MATLAB/ldlsymbol.m": "function [Lnz, Parent, fl] = ldlsymbol (A, P)\t\t\t\t    %#ok\n%LDLSYMBOL symbolic Cholesky factorization\n%\n% Example:\n%       [Lnz, Parent, fl] = ldlsymbol (A)\n%       [Lnz, Parent, fl] = ldlsymbol (A, P)\n%\n% P is a permutation of 1:n, an output of AMD, SYMAMD, or SYMRCM, for example.\n% Only the diagonal and upper triangular part of A or A(P,P) is accessed; the\n% lower triangular part is ignored.  If P is not provided, then P = 1:n is\n% assumed.\n%\n% The elimination tree is returned in the Parent array.  The number of nonzeros\n% in each column of L is returned in Lnz.  fl is the floating point operation\n% count for a subsequent LDL' factorization.  This mexFunction replicates the\n% following MATLAB computations, using ldl_symbolic:\n%\n%       Lnz = symbfact (A) - 1 ;\n%       Parent = etree (A) ;\n%       fl = sum (Lnz .* (Lnz + 2)) ;\n%\n% or, if P is provided,\n%\n%       Lnz = symbfact (A (P,P)) - 1 ;\n%       Parent = etree (A (P,P)) ;\n%       fl = sum (Lnz .* (Lnz + 2)) ;\n%\n% Note that this routine is not required by LDL, since LDL does its own\n% symbolic factorization.\n%\n% See also ldlsparse, symbfact, etree\n\n% Copyright 2006-2007 by Timothy A. Davis, http://www.suitesparse.com\n\nerror ('ldlsymbol mexFunction not found') ;\n",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/MATLAB/ldltest.out": "ldltest\n LDLSPARSE LDL' factorization of a real, sparse, symmetric matrix\n \n  Example:\n        [L, D, Parent, fl] = ldlsparse (A)\n        [L, D, Parent, fl] = ldlsparse (A, P)\n        [x, fl] = ldlsparse (A, [ ], b)\n        [x, fl] = ldlsparse (A, P, b)\n \n  Let I = speye (size (A,1)). The factorization is (L+I)*D*(L+I)' = A or A(P,P).\n  A must be sparse, square, and real.  Only the diagonal and upper triangular\n  part of A or A(P,P) are accessed.  L is lower triangular with unit diagonal,\n  but the diagonal is not returned.  D is a diagonal sparse matrix.  P is either\n  a permutation of 1:n, or an empty vector, where n = size (A,1).  If not\n  present, or empty, then P=1:n is assumed.  Parent is the elimination tree of\n  A or A(P,P).  If positive, fl is the floating point operation count, or\n  negative if any entry on the diagonal of D is zero.\n \n  In the x = ldlsparse (A, P, b) usage, the LDL' factorization is not returned.\n  Instead, the system A*x=b is solved for x, where both b and x are dense.\n \n  If a zero entry on the diagonal of D is encountered, the LDL' factorization is\n  terminated at that point.  If there is no fl output argument, an error occurs.\n  Otherwise, fl is negative, and let d=-fl.  D(d,d) is the first zero entry on\n  the diagonal of D.  A partial factorization is returned.  Let B = A, or A(P,P)\n  if P is present.  Let F = (L+I)*D*(L+I)'.  Then F (1:d,1:d) = B (1:d,1:d).\n  Rows d+1 to n of L and D are all zero.\n \n  See also chol, ldl, ldlsymbol, symbfact, etree\n\nerr: 4.44089e-16 fl: 61\nerr: 4.44089e-16\nerr: 4.44089e-16\nerr: 0\nerr: 5.68989e-16\nerr: 5.68989e-16 fl: 123\nerr: 4.57967e-16 fl: 57\nerr: 4.57967e-16\nerr: 4.57967e-16\nerr: 0\nerr: 6.36644e-16\nerr: 6.36644e-16 fl: 119\n\nldl: all tests passed\ndiary off\n",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/MATLAB/ldl_make.m": "function ldl_make\n%LDL_MAKE compile LDL\n%\n% Example:\n%   ldl_make       % compiles ldlsparse and ldlsymbol\n%\n% See also ldlsparse, ldlsymbol\n\n% Copyright 2006-2007 by Timothy A. Davis, http://www.suitesparse.com\n\nd = '' ;\nif (~isempty (strfind (computer, '64')))\n    d = '-largeArrayDims' ;\nend\n\n% MATLAB 8.3.0 now has a -silent option to keep 'mex' from burbling too much\nif (~verLessThan ('matlab', '8.3.0'))\n    d = ['-silent ' d] ;\nend\n\neval (sprintf ('mex -O %s -DLDL_LONG -I../../SuiteSparse_config -I../Include -output ldlsparse ../Source/ldl.c ldlmex.c', d)) ;\neval (sprintf ('mex -O %s -DLDL_LONG -I../../SuiteSparse_config -I../Include -output ldlsymbol ../Source/ldl.c ldlsymbolmex.c', d)) ;\nfprintf ('LDL successfully compiled.\\n') ;\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/MATLAB/ldlsparse.m": "function [arg1, arg2, arg3, arg4] = ldlsparse (A, P, b)\t\t\t    %#ok\n%LDLSPARSE LDL' factorization of a real, sparse, symmetric matrix\n%\n% Example:\n%       [L, D, Parent, fl] = ldlsparse (A)\n%       [L, D, Parent, fl] = ldlsparse (A, P)\n%       [x, fl] = ldlsparse (A, [ ], b)\n%       [x, fl] = ldlsparse (A, P, b)\n%\n% Let I = speye (size (A,1)). The factorization is (L+I)*D*(L+I)' = A or A(P,P).\n% A must be sparse, square, and real.  Only the diagonal and upper triangular\n% part of A or A(P,P) are accessed.  L is lower triangular with unit diagonal,\n% but the diagonal is not returned.  D is a diagonal sparse matrix.  P is either\n% a permutation of 1:n, or an empty vector, where n = size (A,1).  If not\n% present, or empty, then P=1:n is assumed.  Parent is the elimination tree of\n% A or A(P,P).  If positive, fl is the floating point operation count, or\n% negative if any entry on the diagonal of D is zero.\n%\n% In the x = ldlsparse (A, P, b) usage, the LDL' factorization is not returned.\n% Instead, the system A*x=b is solved for x, where both b and x are dense.\n%\n% If a zero entry on the diagonal of D is encountered, the LDL' factorization is\n% terminated at that point.  If there is no fl output argument, an error occurs.\n% Otherwise, fl is negative, and let d=-fl.  D(d,d) is the first zero entry on\n% the diagonal of D.  A partial factorization is returned.  Let B = A, or A(P,P)\n% if P is present.  Let F = (L+I)*D*(L+I)'.  Then F (1:d,1:d) = B (1:d,1:d).\n% Rows d+1 to n of L and D are all zero.\n%\n% See also chol, ldl, ldlsymbol, symbfact, etree\n\n% Copyright 2006-2007 by Timothy A. Davis, http://www.suitesparse.com\n\nerror ('ldlsparse mexFunction not found') ;\n",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/MATLAB/ldldemo.m": "function ldldemo\n%LDLDEMO demo program for LDL\n%\n% Example:\n%   ldldemo\n%\n% See also ldlsparse.\n\n% Copyright 2006-2007 by Timothy A. Davis, http://www.suitesparse.com\n\n% compile the LDLSPARSE and LDLSYMBOL mexFunctions\nhelp ldlsparse\n\nfprintf ('\\nTesting ldlsparse and ldlsymbol:\\n') ;\n\n% create a small random symmetric positive definite sparse matrix\nn = 100 ;\nd = 0.03 ;\nrand ('state', 0) ;\nrandn ('state', 0) ;\nA = sprandn (n, n, d) ;\nA = speye (n) + A*A' ;\nb = randn (n, 1) ;\n\nclf\nsubplot (2,2,1) ;\nspy (A) ;\ntitle ('original matrix') ;\n\n% permute for sparsity\np = symamd (A) ;\nC = A (p,p) ;\n\nsubplot (2,2,2) ;\nspy (C) ;\ntitle ('permuted matrix') ;\ndrawnow\n\n% factorize, without using ldlsparse's internal permutation\n[L, D, Parent, fl] = ldlsparse (C) ;\nL = L + speye (n) ;\nerr = norm (L*D*L' - C, 1) ;\nfprintf ('norm (LDL''-PAP'') = %g\\n', err) ;\n\n% solve Ax=b\nx = L' \\ (D \\ (L \\ (b (p)))) ;\nx (p) = x ;\nresid = norm (A*x-b) ;\nfprintf ('residual %g for ldlsparse, flops %10.1f\\n', resid, fl) ;\n\n% solve Ax=b with one call to ldlsparse\nx = ldlsparse (C, [ ], b (p)) ;\nx (p) = x ;\nresid = norm (A*x-b) ;\nfprintf ('residual %g for ldlsparse solve\\n', resid) ;\n\nsubplot (2,2,3) ;\nspy (L + D + L') ;\ntitle ('L+D+L''') ;\n\nsubplot (2,2,4) ;\ntreeplot (Parent)\ntitle ('elimination tree') ;\n\n% try ldlrow (this will be slow)\n[L, D] = ldlrow (C) ;\nx = L' \\ (D \\ (L \\ (b (p)))) ;\nx (p) = x ;\nresid = norm (A*x-b) ;\nfprintf ('residual %g for ldlrow.m\\n', resid) ;\n\n% factorize, using ldlsparse's internal permutation\n[L, D, Parent, fl] = ldlsparse (A, p) ;\nL = L + speye (n) ;\nerr = norm (L*D*L' - C, 1) ;\nfprintf ('norm (LDL''-PAP'') = %g\\n', err) ;\n\n% solve Ax=b\nx = L' \\ (D \\ (L \\ (b (p)))) ;\nx (p) = x ;\nresid = norm (A*x-b) ;\nfprintf ('residual %g for ldlsparse, flops %10.1f\\n', resid, fl) ;\n\n% solve Ax=b with one call to ldlsparse\nx = ldlsparse (A, p, b) ;\nresid = norm (A*x-b) ;\nfprintf ('residual %g for ldlsparse solve\\n\\n', resid) ;\n\n% compare ldlsymbol and symbfact\n[Lnz, Parent, fl] = ldlsymbol (A) ;\nfprintf ('Original matrix: nz in L: %5d  flop count: %g\\n', sum (Lnz), fl) ;\n\nLnz2 = symbfact (A) - 1 ;\nParent2 = etree (A) ;\nfl2 = sum (Lnz2 .* (Lnz2 + 2)) ;\nif (any (Lnz ~= Lnz2))\n    error ('Lnz mismatch') ;\nend\nif (any (Parent ~= Parent2))\n    error ('Parent mismatch') ;\nend\nif (fl ~= fl2)\n    error ('fl mismatch') ;\nend\n\n[Lnz, Parent, fl] = ldlsymbol (A, p) ;\nfprintf ('Permuted matrix: nz in L: %5d  flop count: %g\\n', sum (Lnz), fl) ;\n\nLnz2 = symbfact (A (p,p)) - 1 ;\nParent2 = etree (A (p,p)) ;\nfl2 = sum (Lnz2 .* (Lnz2 + 2)) ;\nif (any (Lnz ~= Lnz2))\n    error ('Lnz mismatch') ;\nend\nif (any (Parent ~= Parent2))\n    error ('Parent mismatch') ;\nend\nif (fl ~= fl2)\n    error ('fl mismatch') ;\nend\n\n\nfprintf ('\\nldldemo: all tests passed\\n') ;\n",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/MATLAB/ldlsymbolmex.c": "/* ========================================================================== */\n/* === ldlsymbolmex.c:  LDLSYMBOL mexFunction =============================== */\n/* ========================================================================== */\n\n/* MATLAB interface for symbolic LDL' factorization using the LDL sparse matrix\n * package.  This mexFunction is not required by the LDL mexFunction.\n *\n * MATLAB calling syntax is:\n *\n *       [Lnz, Parent, flopcount] = ldlsymbol (A)\n *       [Lnz, Parent, flopcount] = ldlsymbol (A, P)\n *\n * P is a permutation of 1:n, an output of AMD, SYMAMD, or SYMRCM, for example.\n * Only the diagonal and upper triangular part of A or A(P,P) is accessed; the\n * lower triangular part is ignored.\n *\n * The elimination tree is returned in the Parent array.  The number of nonzeros\n * in each column of L is returned in Lnz.  This mexFunction replicates the\n * following MATLAB computations, using ldl_l_symbolic:\n *\n *\tLnz = symbfact (A) - 1 ;\n *\tParent = etree (A) ;\n *\tflopcount = sum (Lnz .* (Lnz + 2)) ;\n *\n * or, if P is provided,\n *\n *\tB = A (P,P) ;\n *\tLnz = symbfact (B) - 1 ;\n *\tParent = etree (B) ;\n *\tflopcount = sum (Lnz .* (Lnz + 2)) ;\n *\n * This code is faster than the above MATLAB statements, typically by a factor\n * of 4 to 40 (median speedup of 9) in MATLAB 6.5 on a Pentium 4 Linux laptop\n * (excluding the B=A(P,P) time), on a wide range of symmetric sparse matrices.\n *\n * Copyright (c) 2006 by Timothy A Davis, http://www.suitesparse.com.\n * All Rights Reserved.  See LDL/Doc/License.txt for the License.\n */\n\n#ifndef LDL_LONG\n#define LDL_LONG\n#endif\n\n#include \"ldl.h\"\n#include \"mex.h\"\n#define Long SuiteSparse_long\n\n/* ========================================================================== */\n/* === LDLSYMBOL mexFunction ================================================ */\n/* ========================================================================== */\n\nvoid mexFunction\n(\n    int\tnargout,\n    mxArray *pargout[ ],\n    int\tnargin,\n    const mxArray *pargin[ ]\n)\n{\n    Long i, n, *Pattern, *Flag, *Lp, *Ap, *Ai, *Lnz, *Parent,\n\t*P, *Pinv, nn, k, j, permute ;\n    double flops, *p ;\n\n    /* ---------------------------------------------------------------------- */\n    /* get inputs and allocate workspace */\n    /* ---------------------------------------------------------------------- */\n\n    if (nargin == 0 || nargin > 2)\n    {\n\tmexErrMsgTxt (\"Usage:\\n\"\n\t    \"  [Lnz, Parent, flopcount] = ldl (A) ;\\n\"\n\t    \"  [Lnz, Parent, flopcount] = ldl (A, P) ;\\n\") ;\n    }\n    n = mxGetM (pargin [0]) ;\n    if (!mxIsSparse (pargin [0]) || n != mxGetN (pargin [0])\n\t    || mxIsComplex (pargin [0]))\n    {\n    \tmexErrMsgTxt (\"ldlsymbol: A must be sparse, square, and real\") ;\n    }\n\n    nn = (n == 0) ? 1 : n ;\n\n    /* get sparse matrix A */\n    Ap = (Long *) mxGetJc (pargin [0]) ;\n    Ai = (Long *) mxGetIr (pargin [0]) ;\n\n    /* get fill-reducing ordering, if present */\n    permute = ((nargin > 1) && !mxIsEmpty (pargin [1])) ;\n    if (permute)\n    {\n\tif (mxGetM (pargin [1]) * mxGetN (pargin [1]) != n ||\n\t\tmxIsSparse (pargin [1]))\n\t{\n\t    mexErrMsgTxt (\"ldlsymbol: invalid input permutation\\n\") ;\n\t}\n\tP    = (Long *) mxMalloc (nn * sizeof (Long)) ;\n\tPinv = (Long *) mxMalloc (nn * sizeof (Long)) ;\n\tp = mxGetPr (pargin [1]) ;\n\tfor (k = 0 ; k < n ; k++)\n\t{\n\t    P [k] = p [k] - 1 ;\t/* convert to 0-based */\n\t}\n    }\n    else\n    {\n\tP    = (Long *) NULL ;\n\tPinv = (Long *) NULL ;\n    }\n\n    /* allocate first part of L */\n    Lp      = (Long *) mxMalloc ((n+1) * sizeof (Long)) ;\n    Parent  = (Long *) mxMalloc (nn * sizeof (Long)) ;\n\n    /* get workspace */\n    Flag    = (Long *) mxMalloc (nn * sizeof (Long)) ;\n    Pattern = (Long *) mxMalloc (nn * sizeof (Long)) ;\n    Lnz     = (Long *) mxMalloc (nn * sizeof (Long)) ;\n\n    /* make sure the input P is valid */\n    if (permute && !ldl_l_valid_perm (n, P, Flag))\n    {\n\tmexErrMsgTxt (\"ldlsymbol: invalid input permutation\\n\") ;\n    }\n\n    /* note that we assume that the input matrix is valid */\n\n    /* ---------------------------------------------------------------------- */\n    /* symbolic factorization to get Lp, Parent, Lnz, and optionally Pinv */\n    /* ---------------------------------------------------------------------- */\n\n    ldl_l_symbolic (n, Ap, Ai, Lp, Parent, Lnz, Flag, P, Pinv) ;\n\n    /* ---------------------------------------------------------------------- */\n    /* create outputs */\n    /* ---------------------------------------------------------------------- */\n\n    /* create the output Lnz vector */\n    pargout [0] = mxCreateDoubleMatrix (1, n, mxREAL) ;\n    p = mxGetPr (pargout [0]) ;\n    for (j = 0 ; j < n ; j++)\n    {\n\tp [j] = Lnz [j] ;\n    }\n\n    /* return elimination tree (add 1 to change from 0-based to 1-based) */\n    if (nargout > 1)\n    {\n\tpargout [1] = mxCreateDoubleMatrix (1, n, mxREAL) ;\n\tp = mxGetPr (pargout [1]) ;\n\tfor (i = 0 ; i < n ; i++)\n\t{\n\t    p [i] = Parent [i] + 1 ;\n\t}\n    }\n\n    if (nargout > 2)\n    {\n\t/* find flop count for ldl_l_numeric */\n\tflops = 0 ;\n\tfor (k = 0 ; k < n ; k++)\n\t{\n\t    flops += ((double) Lnz [k]) * (Lnz [k] + 2) ;\n\t}\n\tpargout [2] = mxCreateDoubleMatrix (1, 1, mxREAL) ;\n\tp = mxGetPr (pargout [2]) ;\n\tp [0] = flops ;\n    }\n\n    if (permute)\n    {\n\tmxFree (P) ;\n\tmxFree (Pinv) ;\n    }\n    mxFree (Lp) ;\n    mxFree (Parent) ;\n    mxFree (Flag) ;\n    mxFree (Pattern) ;\n    mxFree (Lnz) ;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/MATLAB/Contents.m": "% LDL package: simple sparse LDL factorization\n%\n% Primary routines:\n% \n%   ldlsparse   - LDL' factorization of a real, sparse, symmetric matrix\n%   ldlsymbol   - symbolic Cholesky factorization\n%\n% Helper routines:\n%\n%   ldldemo     - demo program for LDL\n%   ldlrow      - an m-file description of the algorithm used by LDL\n%   ldltest     - test program for LDL\n%   ldlmain2    - compiles and runs a longer test program for LDL\n%   ldl_install - compile and install the LDL package for use in MATLAB.\n%   ldl_make    - compile LDL\n%\n% Example:\n%\n%       [L, D, Parent, fl] = ldlsparse (A)\n\n% Copyright 2006-2007 by Timothy A. Davis, http://www.suitesparse.com\n\n% LDL License:  see LDL/Doc/License.txt\n%\n% Acknowledgements:\n%\n%   This work was supported by the National Science Foundation, under\n%   grant CCR-0203270.\n%\n%   Portions of this work were done while on sabbatical at Stanford University\n%   and Lawrence Berkeley National Laboratory (with funding from the SciDAC\n%   program).  I would like to thank Gene Golub, Esmond Ng, and Horst Simon\n%   for making this sabbatical possible.\n",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/MATLAB/ldldemo.out": "ldldemo\n LDLSPARSE LDL' factorization of a real, sparse, symmetric matrix\n \n  Example:\n        [L, D, Parent, fl] = ldlsparse (A)\n        [L, D, Parent, fl] = ldlsparse (A, P)\n        [x, fl] = ldlsparse (A, [ ], b)\n        [x, fl] = ldlsparse (A, P, b)\n \n  Let I = speye (size (A,1)). The factorization is (L+I)*D*(L+I)' = A or A(P,P).\n  A must be sparse, square, and real.  Only the diagonal and upper triangular\n  part of A or A(P,P) are accessed.  L is lower triangular with unit diagonal,\n  but the diagonal is not returned.  D is a diagonal sparse matrix.  P is either\n  a permutation of 1:n, or an empty vector, where n = size (A,1).  If not\n  present, or empty, then P=1:n is assumed.  Parent is the elimination tree of\n  A or A(P,P).  If positive, fl is the floating point operation count, or\n  negative if any entry on the diagonal of D is zero.\n \n  In the x = ldlsparse (A, P, b) usage, the LDL' factorization is not returned.\n  Instead, the system A*x=b is solved for x, where both b and x are dense.\n \n  If a zero entry on the diagonal of D is encountered, the LDL' factorization is\n  terminated at that point.  If there is no fl output argument, an error occurs.\n  Otherwise, fl is negative, and let d=-fl.  D(d,d) is the first zero entry on\n  the diagonal of D.  A partial factorization is returned.  Let B = A, or A(P,P)\n  if P is present.  Let F = (L+I)*D*(L+I)'.  Then F (1:d,1:d) = B (1:d,1:d).\n  Rows d+1 to n of L and D are all zero.\n \n  See also chol, ldl, ldlsymbol, symbfact, etree\n\n\nTesting ldlsparse and ldlsymbol:\nnorm (LDL'-PAP') = 6.51562e-15\nresidual 3.55986e-15 for ldlsparse, flops    14813.0\nresidual 3.86691e-15 for ldlsparse solve\nresidual 3.64202e-15 for ldlrow.m\nnorm (LDL'-PAP') = 6.63575e-15\nresidual 2.96267e-15 for ldlsparse, flops    14813.0\nresidual 3.53833e-15 for ldlsparse solve\n\nOriginal matrix: nz in L:  2206  flop count: 81044\nPermuted matrix: nz in L:   893  flop count: 14813\n\nldldemo: all tests passed\ndiary off\n",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/MATLAB/ldl_install.m": "function ldl_install\n%LDL_INSTALL compile and install the LDL package for use in MATLAB.\n% Your current working directory must be LDL for this function to work.\n%\n% Example:\n%   ldl_install\n%\n% See also ldlsparse, ldlsymbol\n\n% Copyright 2006-2007 by Timothy A. Davis, http://www.suitesparse.com\n\nldl_make\naddpath (pwd) ;\nfprintf ('LDL has been compiled and installed.  The path:\\n') ;\ndisp (pwd) ;\nfprintf ('has been added to your path.  Use pathtool to add it permanently.\\n');\nldldemo\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/RBio/Tcov/matrices/mhd1280a.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/RBio/Tcov/matrices/qc324.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/RBio/Tcov/matrices/Tina_DisCog.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/RBio/Tcov/matrices/plskz362.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/RBio/Tcov/matrices/mhd1280b.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/RBio/Tcov/matrices/dwg961a.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/RBio/Tcov/matrices/west0067.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/SSMULT/tryit.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/SSMULT/Results/CoreDuo_MS_lcc.png",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/SSMULT/Results/sstest2_results.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/SSMULT/Results/Opteron64_Linux.png",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/SSMULT/Results/CoreDuo_MS_vc2005.png",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/SSMULT/Results/Pentium4M_Linux.png",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/SSMULT/Results/CoreDuo_Linux.png",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/SSMULT/Results/Opteron64_sstest2.png",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/find_components/find_components.png",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/shellgui/shellgui.fig",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/MESHND/meshnd_quality.png",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/MESHND/meshnd.png",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/Factorize/Doc/factorize_article.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/Factorize/Doc/factorize_demo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/SJ_Index.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n4c5-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/cis-n4c6-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n3c4-b4.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n3c5-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/ch3-3-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/klein-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n3c4-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n3c6-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n3c4-b2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/ch4-4-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/ch4-4-b2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n2c6-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n3c5-b3.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n4c6-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n3c5-b2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/ch5-5-b1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Homology/n3c4-b3.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Relat/relat3.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Relat/relat4.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Relat/rel3.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Relat/rel4.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Margulies/cat_ears_2_1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Margulies/wheel_4_1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Margulies/wheel_7_1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Margulies/cat_ears_3_1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Margulies/wheel_5_1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Margulies/wheel_3_1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Margulies/flower_4_1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/JGD_Margulies/wheel_6_1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pothen/sphere2.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Sandia/oscil_dcop_34.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Sandia/oscil_dcop_33.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Sandia/oscil_dcop_24.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/ursell_100.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/gravity_100.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/wing_500.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/tomo_100.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/parallax_200.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/wing_100.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/ursell_200.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/foxgood_200.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/i_laplace_100.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/heat_100.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/gravity_200.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/shaw_200.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/i_laplace_200.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/heat_200.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/baart_100.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/foxgood_100.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/gravity_1000.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/wing_200.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/baart_200.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/shaw_100.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Regtools/parallax_100.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/Tina_AskCal.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/Erdos971.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD97_a.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/Tina_DisCal.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD96_b.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD06_theory.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD98_a.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD95_b.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/Sandi_authors.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD01_c.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GlossGT.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD01_b.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD02_b.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD02_a.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD99_b.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/Ragusa16.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/Tina_DisCog.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD96_d.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/football.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD95_a.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD99_c.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/Ragusa18.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD96_c.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD98_c.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD98_b.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/Pajek/GD97_b.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/GHS_indef/laser.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/jgl009.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/bcsstm01.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/can_61.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/west0156.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/can_187.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/lnsp_131.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/dwt_72.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/can_144.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/will199.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/bcsstm04.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/rgg010.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/jgl011.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/bcspwr02.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/dwt_193.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/gent113.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/dwt_209.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/bcsstm03.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/fs_183_3.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/lap_25.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/mcca.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/dwt_198.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/curtis54.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/lns_131.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/will57.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/HB/dwt_162.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/MATLAB_Tools/spqr_rank/SJget/mat/NYPA/Maragal_1.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/LDL/Doc/ldl_userguide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/CHOLMOD/Doc/IA3_2014_Workshop_Rennich_Stosic_Davis_preprint.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/CHOLMOD/Doc/CHOLMOD_UserGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/CXSparse/MATLAB/UFget/UFgui.jar",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/CXSparse/MATLAB/UFget/mat/UF_Index.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/metis-5.1.0/manual/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/SPQR/Doc/spqr.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/SPQR/Doc/qrgpu_paper.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/SPQR/Doc/spqr_user_guide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/SPQR/Doc/algo_spqr.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/CAMD/Doc/CAMD_UserGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/KLU/Doc/palamadai_e.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/KLU/Doc/KLU_UserGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/CSparse/MATLAB/UFget/UFgui.jar",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/CSparse/MATLAB/UFget/mat/UF_Index.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/UMFPACK/Doc/UMFPACK_QuickStart.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/UMFPACK/Doc/UMFPACK_UserGuide.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/UMFPACK/MATLAB/west.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/UMFPACK/Tcov/badsym.umf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/UMFPACK/Tcov/badnum.umf",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/UFget/UFgui.jar",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/UFget/mat/UF_Index.mat",
        "/tmp/vanessa/spack-stage/spack-stage-suite-sparse-4.5.3-gvmzwusydap7jpeksu3ygttbmumhvb24/spack-src/AMD/Doc/AMD_UserGuide.pdf"
    ],
    "total_files": 2279
}