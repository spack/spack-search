{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-vtable-dumper-1.0-q7bsu5wazx4k7cekmron6a6buai2nl5z/spack-src/dump-vtable.c": "/*\n * Vtable-Dumper 1.0\n * A tool to list content of virtual tables in a shared library\n * Copyright (C) 2013 ROSA Laboratory\n * \n * Written by Andrey Ponomarenko\n * \n * PLATFORMS\n * =========\n *  Linux, FreeBSD\n * \n * REQUIREMENTS\n * ============\n *  libelf\n *  libdl\n *  libstdc++\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License or the GNU Lesser\n * General Public License as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * and the GNU Lesser General Public License along with this program.\n * If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"dump-vtable.h\"\n\nconst char* TOOL_VERSION = \"1.0\";\n\nint opt_mangled = 0;\nint opt_demangled = 0;\n\nint get_VTables(char* file, vtable_info*** vtables)\n{\n    int fd;\n    struct stat elf_stats;\n    \n    int symbol_count;\n    int num;\n    int i;\n    char *sname, *ssname;\n    vtable_info* vt;\n    \n    Elf *elf = NULL;\n    Elf_Scn *scn = NULL;\n    GElf_Shdr shdr;\n    Elf_Data *edata = NULL;\n    GElf_Sym sym;\n    \n    if ((fd = open(file, O_RDONLY))==-1)\n    {\n        printf(\"Failed to open %s\\n\", file);\n        return ERR;\n    }\n    \n    if ((fstat(fd, &elf_stats)))\n    {\n        printf(\"Failed to fstat %s\\n\", file);\n        close(fd);\n        return ERR;\n    }\n    \n    if (elf_version(EV_CURRENT) == EV_NONE)\n    {\n        printf(\"WARNING Elf Library is out of date!\\n\");\n    }\n    \n    elf = elf_begin(fd, ELF_C_READ, NULL);\n    \n    while ((scn = elf_nextscn(elf, scn)) != NULL)\n    {\n        gelf_getshdr(scn, &shdr);\n        \n        if (shdr.sh_type == SHT_DYNSYM)\n        {\n            edata = elf_getdata(scn, edata);\n            \n            symbol_count = shdr.sh_size / shdr.sh_entsize;\n            *vtables = (vtable_info**)malloc(sizeof(vtable_info*) * symbol_count);\n            \n            num = 0;\n            for (i = 0; i < symbol_count; i++)\n            {\n                gelf_getsym(edata, i, &sym);\n                \n                if (sym.st_value==0)\n                { // UND\n                    continue;\n                }\n                \n                sname = elf_strptr(elf, shdr.sh_link, sym.st_name);\n                ssname = (char*)malloc(1 + strlen(sname));\n                strcpy(ssname, sname);\n                \n                if (strstr(ssname, \"_ZTV\"))\n                {\n                    vt = (vtable_info*)malloc(sizeof(vtable_info));\n                    vt->name = ssname;\n                    vt->size = sym.st_size;\n                    \n                    (*vtables)[num] = vt;\n                    num += 1;\n                }\n                else\n                {\n                    free(ssname);\n                }\n            }\n            (*vtables)[num] = NULL;\n        }\n    }\n    \n    if (*vtables == NULL)\n    {\n        return ERR;\n    }\n    \n    elf_end(elf);\n    close(fd);\n    \n    return 0;\n}\n\nvoid *\nfptr2ptrp(fptr * fptr)\n{\n#if defined(__ia64__)\n  return fptr->func;\n#else\n  return (void *) *fptr;\n#endif\n}\n\nint integer_len (int val)\n{\n  int len = 1;\n  while (val > 9)\n  {\n      len += 1;\n      val /= 10;\n  }\n  return len;\n}\n\nextern char* __cxa_demangle ( const char* mangled_name,  char* output_buffer, size_t* length, int* status ); // from libstdc++ ( cxxabi.h )\n\nchar *\ndemangle(const char *mangled_name) {\n    return __cxa_demangle(mangled_name, NULL, 0, NULL);\n}\n\nvoid print_VTable(void *dlhndl, vtable_info *vtable)\n{\n    union classvtable_mem *vtablep;\n    unsigned long vtbaseoffset;\n    const char *vttypeinfo;\n    fptr *vtvirtfuncs;\n    void* vfuncp;\n    Dl_info dlainfo;\n    int i, j;\n    int offset;\n    int step;\n    char* demngl;\n    int size;\n    int space;\n    \n    demngl = demangle(vtable->name);\n    demngl[0] = toupper(demngl[0]);\n    printf(\"%s\\n\", demngl);\n    free(demngl);\n    \n    vtablep = dlsym(dlhndl, vtable->name);\n    \n    vtbaseoffset = vtablep->cat1.baseoffset;\n    vttypeinfo = vtablep->cat1.typeinfo;\n    vtvirtfuncs = vtablep->cat1.virtfuncs;\n    \n    size = vtable->size/sizeof(ptrdiff_t);\n    \n    printf(\"%s: %d entries\\n\", vtable->name, size);\n    \n    step = sizeof(ptrdiff_t);\n    \n    offset = 0;\n    if (vtbaseoffset!=0)\n    {\n        printf(\"%d     %luu\\n\", offset, vtbaseoffset);\n    }\n    else\n    {\n        printf(\"%d     (int (*)(...)) 0\\n\", offset);\n    }\n    \n    offset += step;\n    if (dladdr(vttypeinfo, &dlainfo))\n    {\n        printf(\"%d     (int (*)(...)) (& %s)\\n\", offset, dlainfo.dli_sname);\n    }\n    else\n    {\n        if (vtbaseoffset!=0)\n            printf(\"%d     0u\\n\", offset);\n        else\n            printf(\"%d     (int (*)(...)) 0\\n\", offset);\n    }\n    \n    for (i = 0; i <= size - 3; i++)\n    {\n        offset += step;\n        vfuncp = fptr2ptrp(&vtvirtfuncs[i]);\n        memset(&dlainfo, 0, sizeof(dlainfo));\n        \n        space = 5 - integer_len(offset);\n        \n        if (dladdr(vfuncp, &dlainfo))\n        {\n            printf(\"%d\", offset);\n            for (j = 0; j<=space; j++)\n            {\n                printf(\" \");\n            }\n            if (dlainfo.dli_sname==NULL)\n            {\n                printf(\"(int (*)(...)) %p\\n\", (void*) (vfuncp-dlainfo.dli_fbase));\n            }\n            else if (strstr(dlainfo.dli_sname, \"_ZTI\"))\n            {\n                demngl = demangle(dlainfo.dli_sname);\n                if(opt_mangled==1 && opt_demangled==1)\n                {\n                    printf(\"(int (*)(...)) (& %s) [%s]\\n\", demngl, dlainfo.dli_sname);\n                }\n                else if(opt_demangled==1)\n                {\n                    printf(\"(int (*)(...)) (& %s)\\n\", demngl);\n                }\n                else\n                { // show mangled name by default\n                    printf(\"(int (*)(...)) (& %s)\\n\", dlainfo.dli_sname);\n                }\n                free(demngl);\n            }\n            else\n            {\n                demngl = demangle(dlainfo.dli_sname);\n                \n                if(opt_mangled==1 && opt_demangled==1)\n                {\n                    printf(\"(int (*)(...)) %s [%s]\\n\", demngl, dlainfo.dli_sname);\n                }\n                else if(opt_demangled==1)\n                {\n                    printf(\"(int (*)(...)) %s\\n\", demngl);\n                }\n                else if(opt_mangled==1)\n                {\n                    printf(\"(int (*)(...)) %s\\n\", dlainfo.dli_sname);\n                }\n                else\n                {\n                    if(strstr(dlainfo.dli_sname, \"_ZN\") == NULL)\n                    { // _ZThn, _ZTv, __cxa, etc.\n                      // show mangled name by default\n                        printf(\"(int (*)(...)) %s\\n\", dlainfo.dli_sname);\n                    }\n                    else\n                    {\n                        printf(\"(int (*)(...)) %s\\n\", demngl);\n                    }\n                }\n                \n                free(demngl);\n            }\n        }\n        else\n        {\n            printf(\"%d\", offset);\n            for (j = 0; j<=space; j++) \n            {\n                printf(\" \");\n            }\n            if (vfuncp == NULL)\n            {\n                printf(\"0u\\n\");\n            }\n            else\n            {\n                if ((ptrdiff_t)vfuncp < 0)\n                {\n                    printf(\"(int (*)(...)) -%016p\\n\", (void*) -(ptrdiff_t)vfuncp);\n                }\n                else\n                {\n                    printf(\"(int (*)(...)) %016p\\n\", vfuncp);\n                }\n            }\n        }\n    }\n    printf(\"\\n\\n\");\n}\n\nint print_Info(char* file)\n{\n    int i;\n    void *dlhndl;\n    vtable_info **vtables = NULL;\n    char* error;\n    \n    if (get_VTables(file, &vtables) == ERR)\n    {\n        printf(\"Failed to read v-tables\\n\");\n        return ERR;\n    }\n    \n    dlhndl = dlopen(file, RTLD_LAZY);\n    if (dlhndl == NULL)\n    {\n        printf(\"Failed to dlopen %s\\n\", file);\n        if ((error = dlerror()) != NULL)\n        {\n            fprintf(stderr, \"%s\\n\", error);\n        }\n        return ERR;\n    }\n    \n    for (i = 0; vtables[i] != NULL; i++)\n    {\n        print_VTable(dlhndl, vtables[i]);\n        free(vtables[i]->name);\n        free(vtables[i]);\n    }\n    \n    free(vtables);\n    dlclose(dlhndl);\n    \n    return 0;\n}\n\nvoid print_Usage()\n{\n    printf(\"Vtable-Dumper %s\\n\", TOOL_VERSION);\n    printf(\"A tool to list content of virtual tables in a shared library\\n\");\n    printf(\"Copyright (C) 2013 ROSA Laboratory\\n\");\n    printf(\"License: GNU LGPL or GNU GPL\\n\\n\");\n    \n    printf(\"Usage: vtable-dumper [options] file\\n\");\n    printf(\"Example: vtable-dumper /usr/lib64/libstdc++.so.6\\n\");\n    printf(\"Options:\\n\");\n    printf(\"  -mangled       Show mangled symbol names\\n\");\n    printf(\"  -demangled     Show de-mangled symbol names\\n\");\n    printf(\"  -help          Display this help message\\n\");\n    printf(\"  -dumpversion   Print the tool version (%s) and don't do anything else\\n\\n\", TOOL_VERSION);\n    \n    printf(\"More info: https://github.com/lvc/vtable-dumper\\n\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    int i;\n    char *opt;\n    \n    if(argc==1)\n    {\n        print_Usage();\n    }\n    \n    for (i = 1; i < argc; i++)\n    {\n        opt = argv[i];\n        \n        if(strstr(opt, \"-mangled\"))\n        {\n            opt_mangled = 1;\n        }\n        else if(strstr(opt, \"-demangled\") || strstr(opt, \"-unmangled\"))\n        {\n            opt_demangled = 1;\n        }\n        else if(strstr(opt, \"-h\") || strstr(opt, \"-v\"))\n        {\n            print_Usage();\n            return 0;\n        }\n        else if(strstr(opt, \"-dumpversion\"))\n        {\n            printf(\"%s\\n\", TOOL_VERSION);\n            return 0;\n        }\n    }\n    \n    for (i = 1; i < argc; i++)\n    {\n        opt = argv[i];\n        \n        if(strstr(opt, \"-mangled\")\n        || strstr(opt, \"-demangled\")\n        || strstr(opt, \"-unmangled\")\n        || strstr(opt, \"-h\")\n        || strstr(opt, \"-v\")\n        || strstr(opt, \"-dumpversion\")\n        )\n        {\n            continue;\n        }\n        \n        print_Info(opt);\n    }\n    \n    return 0;\n}\n"
    },
    "skipped": [],
    "total_files": 2
}