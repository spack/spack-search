{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-veclibfort-0.4.2-ubd6swdnn4uhmls3bpiwcppdhuwuwp6h/spack-src/vecLibFort.c": "/*\n\n  vecLibFort\n  https://github.com/mcg1969/vecLibFort\n  Run-time F2C/GFORTRAN translation for Apple's vecLib BLAS/LAPACK\n  Copyright (c) 2014 Michael C. Grant\n\n  See README.md for full background and usage details.\n\n  Use, modification and distribution is subject to the Boost Software \n  License, Version 1.0. See the accompanying file LICENSE or\n\n      http://www.booost.org/LICENSE_1_0.txt\n\n*/\n\n#include <stdio.h>\n#include \"cloak.h\"\n/* Don't load the CLAPACK header, because we are using a different calling\n   convention for the replaced functions than the ones listed there. */\n#define __CLAPACK_H\n#include <Accelerate/Accelerate.h>\n#include <AvailabilityMacros.h>\n\n/* Add a SGEMV fix for Mavericks. See\n  http://www.openradar.me/radar?id=5864367807528960 */\n\n#if !defined(VECLIBFORT_SGEMV) && \\\n    defined(MAC_OS_X_VERSION_10_9) && \\\n    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_9      \n#define VECLIBFORT_SGEMV\n#endif\n\n#define VOIDS_(s,i,id) COMMA_IF(i) void*\n#define VOIDS(n) IF(n)(EXPR_S(0)(REPEAT_S(0,DEC(n),VOIDS_,~)),void)\n#define VOIDA_(s,i,id) COMMA_IF(i) void *a ## i\n#define VOIDA(n) IF(n)(EXPR_S(0)(REPEAT_S(0,DEC(n),VOIDA_,~)),void)\n#define PARAM_(s,i,id) COMMA_IF(i)a ## i\n#define PARAM(n) IF(n)(EXPR_S(0)(REPEAT_S(0,DEC(n),PARAM_,~)),)\n\n#ifdef VECLIBFORT_VERBOSE\n#define DEBUG(...) fprintf(stderr,__VA_ARGS__);\nstatic const char* dynamic_msg = \"Entering dynamic %s replacement\\n\";\nstatic const char* static_msg = \"Entering static %s replacement\\n\";\n#define DEBUG_S(x) DEBUG( static_msg, x )\n#define DEBUG_D(x) DEBUG( dynamic_msg, x )\n\n#else\n#define DEBUG(...)\n#define DEBUG_S(x)\n#define DEBUG_D(x)\n#endif\n\n#include <complex.h>\ntypedef float complex c_float;\ntypedef double complex c_double;\n\n#ifdef VECLIBFORT_INTERPOSE\n\n/*\n * INTERPOSING MODE\n *\n * In this mode, dyld is instructed to preload this library even before the\n * executable itself. It reads the __DATA.__interpose section of the library\n * for the interpose information, which it uses to swap out the offending\n * BLAS/LAPACK functions with our replacements. Because vecLib provides two\n * aliases for each function---one with a trailing underscore, and one\n * without---we need two interpose records for each replacement.\n *\n * For instance, for \"sdot\", we define a static function\n *    static float my_sdot( const int* N, const float* X, const int* incX )\n * add interpose data to signify two substitutions:\n *    sdot_ -> my_sdot\n *    sdot  -> my_sdot\n */\n\ntypedef struct interpose_t_ {\n  const void *replacement;\n  const void *original;\n} interpose_t;\n\n#define INTERPOSE(name) \\\n__attribute__((used)) interpose_t interpose_ ## name [] \\\n__attribute__((section (\"__DATA,__interpose\"))) = \\\n{ { (const void*)&my_ ## name, (const void*)&name }, \\\n  { (const void*)&my_ ## name, (const void*)&name ## _ } };\n\n#define D2F_CALL(name,n) \\\nextern double name( VOIDS(n) ); \\\nextern double name ## _( VOIDS(n) ); \\\nstatic float my_ ## name ( VOIDA(n) ) \\\n{ return (float)name ## _( PARAM(n) ); } \\\nINTERPOSE(name)\n\n#define CPLX_CALL(type,name,n) \\\nextern void name( VOIDS(INC(n)) ); \\\nextern void name ## _( VOIDS(INC(n)) ); \\\nstatic c_ ## type my_ ## name ( VOIDA(n) ) \\\n{ \\\n  c_ ## type cplx; \\\n  name ## _( &cplx, PARAM(n) ); \\\n  return cplx; \\\n} \\\nINTERPOSE(name)\n\n/*\n * DYNAMIC BLAS SUBSTITUTION\n *\n * For the interpose library we need to use the same techniques for the BLAS\n * as we do for the LAPACK routines. However, because we have CBLAS versions\n * available to use, we can use the wrappers already created in \"static.h\"\n * by prepending them with the \"my_\" prefixes.\n */\n\n#define BLS_CALL(type,name,n) \\\nextern type name( VOIDS(n) ); \\\nextern type name ## _( VOIDS(n) ); \\\nINTERPOSE(name)\n  \n#define ADD_PREFIX\n#include \"static.h\"\n#undef ADD_PREFIX\n\nBLS_CALL(float,sdsdot,6)\nBLS_CALL(float,sdot,5)\nBLS_CALL(float,snrm2,3)\nBLS_CALL(float,sasum,3)\nBLS_CALL(c_float,cdotu,5)\nBLS_CALL(c_float,cdotc,5)\nBLS_CALL(float,scnrm2,3)\nBLS_CALL(float,scasum,3)\nBLS_CALL(c_double,zdotu,5)\nBLS_CALL(c_double,zdotc,5)\n#if defined(VECLIBFORT_SGEMV)\nBLS_CALL(void,sgemv,11)\n#endif\n\n#else\n\n/*\n * STATIC BLAS SUBSTITUTION\n * \n * For BLAS functions, we have access to CBLAS versions of each function.\n * So the hoops we need to jump through to resolve the name clashes in the\n * dynamic substitution mode can be avoided. Instead, we simply create the\n * replacement functions to call the CBLAS counterparts instead.\n *\n * To void duplicating code, we include the functions in \"static.h\" twice:\n * once for the functions with trailing underscores (e.g., \"sdot_\"), and once \n * without (e.g., \"sdot\"). In theory, we could create just one replacement\n * with two aliases, but clang has thus far been uncooperative. Any assistance \n * on this matter would be appreciated.\n */\n\n#include \"static.h\"\n#define ADD_UNDERSCORE\n#include \"static.h\"\n\n/*\n * DYNAMIC LAPACK SUBSTITUTION\n * \n * In this mode, we give our functions identical names, and rely on link\n * order to ensure that these take precedence over those declared in vecLib.\n * Thus whenever the main code attempts to call one of the covered functions,\n * it will be directed to one of our wrappers instead.\n *\n * Because vecLib provides two aliases for each function---one with a\n * trailing underscore, and one without---we actually need two separate\n * replacement functions (at least until we can figure out how to do aliases\n * cleanly in clang.) Each pair of replacements controls a single static\n * pointer to the replacement function. On the first invocation of either,\n * this pointer is retrieved using a dlsym() command.\n *\n * For instance, for \"sdot\", we define two functions\n *    float sdot_( const int* N, const float* X, const int* incX )\n *    float sdot ( const int* N, const float* X, const int* incX )\n * On the first invocation of either, the \"sdot_\" symbol from vecLib is\n * retrieved using the dlsym() command and stored in\n *    static void* fp_dot;\n * In theory, we could create just one replacement with two aliases, but \n * clang has thus far been uncooperative. Any assistance on this matter would\n * be appreciated. \n */\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define VECLIB_FILE \"/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/vecLib\"\n\nstatic void * veclib = 0;\n\nstatic void unloadlib(void)\n{\n  DEBUG( \"Unloading vecLib\\n\" );\n  dlclose (veclib);\n}\n\nstatic void loadlib(void)\n{\n  static const char* veclib_loc = VECLIB_FILE;\n  DEBUG( \"Loading library: %s\\n\", veclib_loc )\n  veclib = dlopen (veclib_loc, RTLD_LOCAL | RTLD_FIRST);\n  if ( veclib == 0 ) {\n    fprintf( stderr, \"Failed to open vecLib library; aborting.\\n   Location: %s\\n\", veclib );\n    abort ();\n  }\n  atexit(unloadlib); \n}\n\nstatic void* loadsym( const char* nm )\n{\n  if ( veclib == 0 ) loadlib();\n  DEBUG( \"Loading function: %s\\n\", nm )\n  void *ans = dlsym( veclib, nm );\n  if ( ans != 0 ) return ans;\n  fprintf( stderr, \"vecLib symbol '%s' could not be resolved; aborting.\\n\", nm );\n  abort();\n}\n\n#define D2F_CALL_(fname,name,n) \\\nfloat fname( VOIDA(n) ) \\\n{ \\\n  DEBUG_D( #name \"_\" ) \\\n  if ( !fp_ ## name ) fp_ ## name = loadsym( #name \"_\" ); \\\n  return ((ft_ ## name)fp_ ## name)( PARAM(n) ); \\\n}\n\n#define D2F_CALL(name,n) \\\ntypedef double (*ft_ ## name)( VOIDS(n) ); \\\nstatic void *fp_ ## name = 0; \\\nD2F_CALL_(name,name,n) \\\nD2F_CALL_(name ## _,name,n)\n\n#define CPLX_CALL_(type,fname,name,n) \\\nc_ ## type fname( VOIDA(n) ) \\\n{ \\\n  c_ ## type cplx; \\\n  DEBUG_D( #name \"_\" ) \\\n  if ( !fp_ ## name ) fp_ ## name = loadsym( #name \"_\" ); \\\n  ((ft_ ## name)fp_ ## name)( &cplx, PARAM(n) ); \\\n  return cplx; \\\n}\n\n#define CPLX_CALL(type,name,n) \\\ntypedef void (*ft_ ## name)( VOIDS(INC(n)) ); \\\nstatic void *fp_ ## name = 0; \\\nCPLX_CALL_(type,name,name,n) \\\nCPLX_CALL_(type,name ## _,name,n)\n\n#endif\n\nD2F_CALL(clangb,7)\nD2F_CALL(clange,6)\nD2F_CALL(clangt,5)\nD2F_CALL(clanhb,7)\nD2F_CALL(clanhe,6)\nD2F_CALL(clanhp,5)\nD2F_CALL(clanhs,5)\nD2F_CALL(clanht,4)\nD2F_CALL(clansb,7)\nD2F_CALL(clansp,5)\nD2F_CALL(clansy,6)\nD2F_CALL(clantb,8)\nD2F_CALL(clantp,6)\nD2F_CALL(clantr,8)\n\nD2F_CALL(scsum1,3)\n#if defined(MAC_OS_X_VERSION_10_6) && \\\n    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6\nD2F_CALL(slaneg,6)\n#endif\nD2F_CALL(slangb,7)\nD2F_CALL(slange,6)\nD2F_CALL(slangt,5)\nD2F_CALL(slanhs,5)\nD2F_CALL(slansb,7)\nD2F_CALL(slansp,5)\nD2F_CALL(slanst,4)\nD2F_CALL(slansy,6)\nD2F_CALL(slantb,8)\nD2F_CALL(slantp,6)\nD2F_CALL(slantr,8)\nD2F_CALL(slapy2,2)\nD2F_CALL(slapy3,3)\nD2F_CALL(slamch,1)\nD2F_CALL(slamc3,2)\n\n#if defined(MAC_OS_X_VERSION_10_7) && \\\n    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7\nD2F_CALL(clanhf,6)\nD2F_CALL(slansf,6)\n#endif\n\nCPLX_CALL(float,cladiv,2)\nCPLX_CALL(double,zladiv,2)\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-veclibfort-0.4.2-ubd6swdnn4uhmls3bpiwcppdhuwuwp6h/spack-src/README.md": "## A GNU Fortran interface to Apple's Accelerate/vecLib BLAS/LAPACK\n\n### Introduction\n\nvecLibFort is lightweight but flexible \"shim\" designed to rectify\nthe incompatibilities between the Accelerate/vecLib BLAS and LAPACK libraries\nshipped with Mac OS X and FORTRAN code compiled with modern compilers\nsuch as [GNU Fortran][].\n\nYou *will* want this code if you are...\n\n  * compiling your code directly from FORTRAN source; *and*\n  * using Apple's BLAS and/or LAPACK for your linear algebra; *and*\n  * using single-precision or complex arithmetic. \n\nYou *will not* need this code if you are...\n\n  * using some other linear algebra package; *or*\n  * calling BLAS and LAPACK only from C; *or*\n  * using an alternative BLAS/LAPACK package ([OpenBlas][],[MKL][]); *or*\n  * using only double-precision real arithmetic.\n\nYou *may* want this code if you are...\n\n  * running a *pre-compiled* program, or linking to a *pre-compiled*\n    library, that seems to exhibit bugs described in the [next](#background)\n    section. See the section [Preloaded (interposing) library](#preloaded) \n    for more details on how you may be able to fix these programs without\n    recompilation.\n\n<a name=\"background\"></a>\n### Background\n\n[Apple's vecLib framework][vecLib] provides both C and FORTRAN bindings for\nBLAS and LAPACK, the de-facto standard libraries for dense numerical linear\nalgebra. Because there remains quite a bit of useful FORTRAN code out there\nthat in turn depend on BLAS and LAPACK, this is certainly a welcome provision\nfrom Apple.\n\nUnfortunately, those FORTRAN bindings follow an [F2C][]-style return value\nconvention, while [GNU Fortran][] uses a [different convention][gnufarg]. Most\nsubroutines and functions work without modification; in particular, if you \nrely solely on double-precision *real* arithmetic, you are fine. For single\nprecision or complex arithmetic, there are two fatal incompatibilities:\n\n* Functions whose FORTRAN specifications call for returning single-precision\n  real values, such as ``sdot_`` and ``snrm2_``, actually return \n  *double-precision* results in the Apple/F2C calling convention. GNU Fortran, \n  on the other hand, expects to receive the single-precision result.\n* Functions designed to return complex values, whether single-precision or\n  double-precision, are converted to subroutines in the Apple/F2C convention, \n  with a pointer to the return value serving as the first argument. (Note that\n  this differs from the CBLAS convention of passing a pointer to the\n  return value as the *final* argument.) GNU Fortran, on the other hand,\n  expects these values to be returned as a C-style return value.\n\nFor programs that use single-precision or complex arithmetic, then, these\nincompatibilities *must* be addressed or incorrect results and crashes can\noccur. In some projects, these errors go uncorrected, because the use cases\nthat exercise them are uncommon.\n\nOne solution is to force GNU Fortran to adopt the older, F2C-style return\nvalue convention, using the ``-ff2c`` flag. If that solution is sufficient\nfor you, then I encourage you to adopt it. Unfortunately, this may not be\npossible if there is other code or other libraries that you rely upon that\nassume the default GNU Fotran convention. And don't forget to rewrite your\nC code according to the F2C return value conventions.\n\nThe approach taken by vecLibFort is to provide a thin translation layer\nbetween the F2C and GFortran worlds, for the few functions where there is a\ndifference. For BLAS, this is simply a matter of wrapping Apple's CBLAS\ncalls in a FORTRAN-friendly wrapper. For LAPACK, a bit of dlopen/dlsym\ntrickery is required to avoid name conflicts.\n\nStill another option is to use a different BLAS and LAPACK library, such\nas [MKL][] or [OpenBlas][]. I am sure there are good arguments to be made\nfor all three options.\n\n### Using vecLibFort\n\nThis code can be used in one of three ways, and the included ``Makefile``\nbuilds all three for you. The only variable you may want to modify is the\n``PREFIX`` variable, which determines the install location ``$(PREFIX)/lib``.\n\n#### Dynamic library: ``libvecLibFort.dylib``\n\nThe most straightforward way to use ``vecLibFort`` is by linking with the \nstandard dynamic library using ``-lvecLibFort``. Of course, if you installed\nthe library in a non-standard location, you will need an ``-L<path>`` linker\nflag as well.\n\nIf you use this apporach, you do *not* need to add ``-framework vecLib`` or\n``-framework Accelerate`` as well. That is because vecLibFort is built to \nre-export all of Accelerate's symbols, even those it does not \"fix\". Thus it \nserves as a *full replacement* for vecLib/Accelerate.\n\n#### Static library / direct inclusion: ``libvecLibFort.a``\n\nFor new projects, feel free to add ``vecLibFort.c``, ``static.h``, and\n``cloak.h`` to your project, or link with the static library. You will also\nneed to link ``-framework vecLib`` or ``-framework Accelerate``.\n\n<a name=\"preloaded\"></a>\n#### Preloaded (interposing) library: ``libvecLibFortI.dylib``\n\nSuppose you have a program that is already compiled, but which apparently \nexhibits the errors discussed herein. Or perhaps you are using a precompiled\nthird-party library that has not implemented measures like these itself; but\nbecause it has already been linked to vecLib, the bugs are baked in. (If you \ncan alter the linking information of a dynamic library, I bow to your skill.)\n\nIn these cases, there is a *preload* feature of Mac OSX's ``dyld`` system that\ncan come in quite handy. The OS makes it possible to specify a library to be\n*preloaded* before the application, with a list of instructions to replace\nfunctions with alternate versions, a process known as *interposing*. The\nsource file ``vecLibFort.c`` includes this interposing code, but it is\nwrapped with ``#ifdef VECLIBFORT_INTERPOSE`` to avoid clashing with the \nnon-interposing code.\n\nTo use this library, you must add the full path to ``libvecLibFortI.dylib``\nto the [``DYLD_INSERT_LIBRARIES`` environment variable][DYLD]. For instance,\nif it has been installed in the default location, the command\n\n    DYLD_INSERT_LIBRARIES=/usr/local/lib/libvecLibFortI.dylib program\n\nwill run the program ``program`` but with the BLAS and LAPACK calls corrected.\n\nOf course, this may not work---it may be that the bugs you are seeing are not\nin fact caused by the specific issues addressed by vecLibFort. Or I might not\nhave implemented something correctly. (Bug reports are welcome.) And you\nshould *not* use this if the program or library *already* uses the F2C \ncalling conventions correctly; you *will* break it.\n\n### Inspirations\n\nThis code in ``vecLibFort.c`` is new, but the concepts that undergird it are \nmost certainly not. The inspirations include:\n\n* The [dotwrp project][dotwrp] project provides a simple FORTRAN-based wrapper\n  for the 5 most common problematic BLAS functions. Thanks to vecLib's CBLAS \n  interface, the substitutions can be made statically. We have extended this \n  approach to cover all of the relevant BLAS calls, and implemented it in C.\n* The dynamic substitution approach is heavily inspired by the method used by\n  [GNU Octave](https://www.gnu.org/software/octave/), as contributed by Jarno\n  Rajahaime. You can see the [here][blaswrap]. vecLibFort differs from Octave\n  in that it resolves the replacements lazily, eliminating the need for\n  lookup tables and (hopefully) improving performance. It also implements the \n  full set of BLAS/LAPACK replacements, whereas Octave replaces only a subset.\n* The interposing implementation is explained in a variety of places on the \n  Internet, including section 2.6.3.4 of Amit Singh's book \"Mac OSX\n  Internals.\" (http://osxbook.com). Point your favorite search engine to the\n  term [``DYLD_INSERT_LIBRARIES``][Google] to find a wealth of material.\n* In order to make the primary source file as compact as possible, this code\n  employs a simple preprocessor library by Paul Fultz II called [Cloak][]. The\n  [Boost Preprocessor Library][Boost] is perhaps a more well known example\n  of this kind of work, but it is far more complex than needed in this case.\n\n### License\n\n##### English\n\nI've released this under the [Boost Software License][boost]. So do whatever\nyou wish with it. You do not have to redistribute the source code; but if you\ndo, you must include the license with it.\n\nIf you do use this in your projects, I would appreciate it if you would give \nme credit, as I have attempted to do in the previous section. But I'm not \ngoing to get bent out of shape about it. Large piles of cash are welcome, as \nare simple emails of gratitude, or pull requests!\n\n##### Legalese\n\n> Boost Software License - Version 1.0 - August 17th, 2003\n> \n> Permission is hereby granted, free of charge, to any person or organization\n> obtaining a copy of the software and accompanying documentation covered by\n> this license (the \"Software\") to use, reproduce, display, distribute,\n> execute, and transmit the Software, and to prepare derivative works of the\n> Software, and to permit third-parties to whom the Software is furnished to\n> do so, all subject to the following:\n> \n> The copyright notices in the Software and this entire statement, including\n> the above license grant, this restriction and the following disclaimer,\n> must be included in all copies of the Software, in whole or in part, and\n> all derivative works of the Software, unless such copies or derivative\n> works are solely in the form of machine-executable object code generated by\n> a source language processor.\n> \n> THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n> IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n> FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n> SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n> FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n> ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n> DEALINGS IN THE SOFTWARE.\n\n[vecLib]:https://developer.apple.com/library/mac/documentation/Performance/Conceptual/vecLib/Reference/reference.html\n[GNU Fortran]:http://gcc.gnu.org/fortran/\n[gnufarg]:http://gcc.gnu.org/onlinedocs/gfortran/Argument-passing-conventions.html\n[F2C]:http://www.netlib.org/f2c/\n[DYLD]:https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html\n[dotwrp]:https://github.com/tenomoto/dotwrp\n[GNU Octave]:https://www.gnu.org/software/octave/\n[blaswrap]:http://hg.savannah.gnu.org/hgweb/octave/file/tip/liboctave/cruft/misc/blaswrap.c\n[Google]:https://www.google.com/search?q=DYLD_INSERT_LIBRARIES\n[Cloak]:https://github.com/pfultz2/Cloak/blob/master/cloak.h\n[Boost]:http://www.boost.org/doc/libs/1_55_0/libs/preprocessor/doc/index.html \n[OpenBLAS]:http://www.openblas.net/\n[MKL]:http://software.intel.com/en-us/intel-mkl\n[blasbug]:http://www.macresearch.org/lapackblas-fortran-106\n[boost]:http://www.boost.org/users/license.html\n\n"
    },
    "skipped": [],
    "total_files": 5
}