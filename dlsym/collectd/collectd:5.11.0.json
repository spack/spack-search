{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.11.0-nc7v4k27cecpwvdntndazsxgqkvvi3ck/spack-src/src/daemon/plugin.c": "/**\n * collectd - src/plugin.c\n * Copyright (C) 2005-2014  Florian octo Forster\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n *   Florian octo Forster <octo at collectd.org>\n *   Sebastian Harl <sh at tokkee.org>\n **/\n\n/* _GNU_SOURCE is needed in Linux to use pthread_setname_np */\n#define _GNU_SOURCE\n\n#include \"collectd.h\"\n\n#include \"configfile.h\"\n#include \"filter_chain.h\"\n#include \"plugin.h\"\n#include \"utils/avltree/avltree.h\"\n#include \"utils/common/common.h\"\n#include \"utils/heap/heap.h\"\n#include \"utils_cache.h\"\n#include \"utils_complain.h\"\n#include \"utils_llist.h\"\n#include \"utils_random.h\"\n#include \"utils_time.h\"\n\n#ifdef WIN32\n#define EXPORT __declspec(dllexport)\n#include <sys/stat.h>\n#include <unistd.h>\n#else\n#define EXPORT\n#endif\n\n#if HAVE_PTHREAD_NP_H\n#include <pthread_np.h> /* for pthread_set_name_np(3) */\n#endif\n\n#include <dlfcn.h>\n\n/*\n * Private structures\n */\nstruct callback_func_s {\n  void *cf_callback;\n  user_data_t cf_udata;\n  plugin_ctx_t cf_ctx;\n};\ntypedef struct callback_func_s callback_func_t;\n\n#define RF_SIMPLE 0\n#define RF_COMPLEX 1\n#define RF_REMOVE 65535\nstruct read_func_s {\n/* `read_func_t' \"inherits\" from `callback_func_t'.\n * The `rf_super' member MUST be the first one in this structure! */\n#define rf_callback rf_super.cf_callback\n#define rf_udata rf_super.cf_udata\n#define rf_ctx rf_super.cf_ctx\n  callback_func_t rf_super;\n  char rf_group[DATA_MAX_NAME_LEN];\n  char *rf_name;\n  int rf_type;\n  cdtime_t rf_interval;\n  cdtime_t rf_effective_interval;\n  cdtime_t rf_next_read;\n};\ntypedef struct read_func_s read_func_t;\n\nstruct cache_event_func_s {\n  plugin_cache_event_cb callback;\n  char *name;\n  user_data_t user_data;\n  plugin_ctx_t plugin_ctx;\n};\ntypedef struct cache_event_func_s cache_event_func_t;\n\nstruct write_queue_s;\ntypedef struct write_queue_s write_queue_t;\nstruct write_queue_s {\n  value_list_t *vl;\n  plugin_ctx_t ctx;\n  write_queue_t *next;\n};\n\nstruct flush_callback_s {\n  char *name;\n  cdtime_t timeout;\n};\ntypedef struct flush_callback_s flush_callback_t;\n\n/*\n * Private variables\n */\nstatic c_avl_tree_t *plugins_loaded;\n\nstatic llist_t *list_init;\nstatic llist_t *list_write;\nstatic llist_t *list_flush;\nstatic llist_t *list_missing;\nstatic llist_t *list_shutdown;\nstatic llist_t *list_log;\nstatic llist_t *list_notification;\n\nstatic size_t list_cache_event_num;\nstatic cache_event_func_t list_cache_event[32];\n\nstatic fc_chain_t *pre_cache_chain;\nstatic fc_chain_t *post_cache_chain;\n\nstatic c_avl_tree_t *data_sets;\n\nstatic char *plugindir;\n\n#ifndef DEFAULT_MAX_READ_INTERVAL\n#define DEFAULT_MAX_READ_INTERVAL TIME_T_TO_CDTIME_T_STATIC(86400)\n#endif\nstatic c_heap_t *read_heap;\nstatic llist_t *read_list;\nstatic int read_loop = 1;\nstatic pthread_mutex_t read_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t read_cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t *read_threads;\nstatic size_t read_threads_num;\nstatic cdtime_t max_read_interval = DEFAULT_MAX_READ_INTERVAL;\n\nstatic write_queue_t *write_queue_head;\nstatic write_queue_t *write_queue_tail;\nstatic long write_queue_length;\nstatic bool write_loop = true;\nstatic pthread_mutex_t write_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t write_cond = PTHREAD_COND_INITIALIZER;\nstatic pthread_t *write_threads;\nstatic size_t write_threads_num;\n\nstatic pthread_key_t plugin_ctx_key;\nstatic bool plugin_ctx_key_initialized;\n\nstatic long write_limit_high;\nstatic long write_limit_low;\n\nstatic pthread_mutex_t statistics_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic derive_t stats_values_dropped;\nstatic bool record_statistics;\n\n/*\n * Static functions\n */\nstatic int plugin_dispatch_values_internal(value_list_t *vl);\n\nstatic const char *plugin_get_dir(void) {\n  if (plugindir == NULL)\n    return PLUGINDIR;\n  else\n    return plugindir;\n}\n\nstatic int plugin_update_internal_statistics(void) { /* {{{ */\n  gauge_t copy_write_queue_length = (gauge_t)write_queue_length;\n\n  /* Initialize `vl' */\n  value_list_t vl = VALUE_LIST_INIT;\n  sstrncpy(vl.plugin, \"collectd\", sizeof(vl.plugin));\n  vl.interval = plugin_get_interval();\n\n  /* Write queue */\n  sstrncpy(vl.plugin_instance, \"write_queue\", sizeof(vl.plugin_instance));\n\n  /* Write queue : queue length */\n  vl.values = &(value_t){.gauge = copy_write_queue_length};\n  vl.values_len = 1;\n  sstrncpy(vl.type, \"queue_length\", sizeof(vl.type));\n  vl.type_instance[0] = 0;\n  plugin_dispatch_values(&vl);\n\n  /* Write queue : Values dropped (queue length > low limit) */\n  vl.values = &(value_t){.gauge = (gauge_t)stats_values_dropped};\n  vl.values_len = 1;\n  sstrncpy(vl.type, \"derive\", sizeof(vl.type));\n  sstrncpy(vl.type_instance, \"dropped\", sizeof(vl.type_instance));\n  plugin_dispatch_values(&vl);\n\n  /* Cache */\n  sstrncpy(vl.plugin_instance, \"cache\", sizeof(vl.plugin_instance));\n\n  /* Cache : Nb entry in cache tree */\n  vl.values = &(value_t){.gauge = (gauge_t)uc_get_size()};\n  vl.values_len = 1;\n  sstrncpy(vl.type, \"cache_size\", sizeof(vl.type));\n  vl.type_instance[0] = 0;\n  plugin_dispatch_values(&vl);\n\n  return 0;\n} /* }}} int plugin_update_internal_statistics */\n\nstatic void free_userdata(user_data_t const *ud) /* {{{ */\n{\n  if (ud == NULL)\n    return;\n\n  if ((ud->data != NULL) && (ud->free_func != NULL)) {\n    ud->free_func(ud->data);\n  }\n} /* }}} void free_userdata */\n\nstatic void destroy_callback(callback_func_t *cf) /* {{{ */\n{\n  if (cf == NULL)\n    return;\n  free_userdata(&cf->cf_udata);\n  sfree(cf);\n} /* }}} void destroy_callback */\n\nstatic void destroy_all_callbacks(llist_t **list) /* {{{ */\n{\n  llentry_t *le;\n\n  if (*list == NULL)\n    return;\n\n  le = llist_head(*list);\n  while (le != NULL) {\n    llentry_t *le_next;\n\n    le_next = le->next;\n\n    sfree(le->key);\n    destroy_callback(le->value);\n    le->value = NULL;\n\n    le = le_next;\n  }\n\n  llist_destroy(*list);\n  *list = NULL;\n} /* }}} void destroy_all_callbacks */\n\nstatic void destroy_read_heap(void) /* {{{ */\n{\n  if (read_heap == NULL)\n    return;\n\n  while (42) {\n    read_func_t *rf;\n\n    rf = c_heap_get_root(read_heap);\n    if (rf == NULL)\n      break;\n    sfree(rf->rf_name);\n    destroy_callback((callback_func_t *)rf);\n  }\n\n  c_heap_destroy(read_heap);\n  read_heap = NULL;\n} /* }}} void destroy_read_heap */\n\nstatic int register_callback(llist_t **list, /* {{{ */\n                             const char *name, callback_func_t *cf) {\n\n  if (*list == NULL) {\n    *list = llist_create();\n    if (*list == NULL) {\n      ERROR(\"plugin: register_callback: \"\n            \"llist_create failed.\");\n      destroy_callback(cf);\n      return -1;\n    }\n  }\n\n  char *key = strdup(name);\n  if (key == NULL) {\n    ERROR(\"plugin: register_callback: strdup failed.\");\n    destroy_callback(cf);\n    return -1;\n  }\n\n  llentry_t *le = llist_search(*list, name);\n  if (le == NULL) {\n    le = llentry_create(key, cf);\n    if (le == NULL) {\n      ERROR(\"plugin: register_callback: \"\n            \"llentry_create failed.\");\n      sfree(key);\n      destroy_callback(cf);\n      return -1;\n    }\n\n    llist_append(*list, le);\n  } else {\n    callback_func_t *old_cf = le->value;\n    le->value = cf;\n\n    P_WARNING(\"register_callback: \"\n              \"a callback named `%s' already exists - \"\n              \"overwriting the old entry!\",\n              name);\n\n    destroy_callback(old_cf);\n    sfree(key);\n  }\n\n  return 0;\n} /* }}} int register_callback */\n\nstatic void log_list_callbacks(llist_t **list, /* {{{ */\n                               const char *comment) {\n  char *str;\n  int len;\n  int i;\n  llentry_t *le;\n  int n;\n\n  n = llist_size(*list);\n  if (n == 0) {\n    INFO(\"%s: [none]\", comment);\n    return;\n  }\n\n  char **keys = calloc(n, sizeof(*keys));\n  if (keys == NULL) {\n    ERROR(\"%s: failed to allocate memory for list of callbacks\", comment);\n    return;\n  }\n\n  for (le = llist_head(*list), i = 0, len = 0; le != NULL; le = le->next, i++) {\n    keys[i] = le->key;\n    len += strlen(le->key) + 6;\n  }\n  str = malloc(len + 10);\n  if (str == NULL) {\n    ERROR(\"%s: failed to allocate memory for list of callbacks\", comment);\n  } else {\n    *str = '\\0';\n    strjoin(str, len, keys, n, \"', '\");\n    INFO(\"%s ['%s']\", comment, str);\n    sfree(str);\n  }\n  sfree(keys);\n} /* }}} void log_list_callbacks */\n\nstatic int create_register_callback(llist_t **list, /* {{{ */\n                                    const char *name, void *callback,\n                                    user_data_t const *ud) {\n\n  if (name == NULL || callback == NULL)\n    return EINVAL;\n\n  callback_func_t *cf = calloc(1, sizeof(*cf));\n  if (cf == NULL) {\n    free_userdata(ud);\n    ERROR(\"plugin: create_register_callback: calloc failed.\");\n    return ENOMEM;\n  }\n\n  cf->cf_callback = callback;\n  if (ud == NULL) {\n    cf->cf_udata = (user_data_t){\n        .data = NULL,\n        .free_func = NULL,\n    };\n  } else {\n    cf->cf_udata = *ud;\n  }\n\n  cf->cf_ctx = plugin_get_ctx();\n\n  return register_callback(list, name, cf);\n} /* }}} int create_register_callback */\n\nstatic int plugin_unregister(llist_t *list, const char *name) /* {{{ */\n{\n  llentry_t *e;\n\n  if (list == NULL)\n    return -1;\n\n  e = llist_search(list, name);\n  if (e == NULL)\n    return -1;\n\n  llist_remove(list, e);\n\n  sfree(e->key);\n  destroy_callback(e->value);\n\n  llentry_destroy(e);\n\n  return 0;\n} /* }}} int plugin_unregister */\n\n/* plugin_load_file loads the shared object \"file\" and calls its\n * \"module_register\" function. Returns zero on success, non-zero otherwise. */\nstatic int plugin_load_file(char const *file, bool global) {\n  int flags = RTLD_NOW;\n  if (global)\n    flags |= RTLD_GLOBAL;\n\n  void *dlh = dlopen(file, flags);\n  if (dlh == NULL) {\n    char errbuf[1024] = \"\";\n\n    snprintf(errbuf, sizeof(errbuf),\n             \"dlopen(\\\"%s\\\") failed: %s. \"\n             \"The most common cause for this problem is missing dependencies. \"\n             \"Use ldd(1) to check the dependencies of the plugin / shared \"\n             \"object.\",\n             file, dlerror());\n\n    /* This error is printed to STDERR unconditionally. If list_log is NULL,\n     * plugin_log() will also print to STDERR. We avoid duplicate output by\n     * checking that the list of log handlers, list_log, is not NULL. */\n    fprintf(stderr, \"ERROR: %s\\n\", errbuf);\n    if (list_log != NULL) {\n      ERROR(\"%s\", errbuf);\n    }\n\n    return ENOENT;\n  }\n\n  void (*reg_handle)(void) = dlsym(dlh, \"module_register\");\n  if (reg_handle == NULL) {\n    ERROR(\"Couldn't find symbol \\\"module_register\\\" in \\\"%s\\\": %s\\n\", file,\n          dlerror());\n    dlclose(dlh);\n    return ENOENT;\n  }\n\n  (*reg_handle)();\n  return 0;\n}\n\nstatic void *plugin_read_thread(void __attribute__((unused)) * args) {\n  while (read_loop != 0) {\n    read_func_t *rf;\n    plugin_ctx_t old_ctx;\n    cdtime_t start;\n    cdtime_t now;\n    cdtime_t elapsed;\n    int status;\n    int rf_type;\n    int rc;\n\n    /* Get the read function that needs to be read next.\n     * We don't need to hold \"read_lock\" for the heap, but we need\n     * to call c_heap_get_root() and pthread_cond_wait() in the\n     * same protected block. */\n    pthread_mutex_lock(&read_lock);\n    rf = c_heap_get_root(read_heap);\n    if (rf == NULL) {\n      pthread_cond_wait(&read_cond, &read_lock);\n      pthread_mutex_unlock(&read_lock);\n      continue;\n    }\n    pthread_mutex_unlock(&read_lock);\n\n    if (rf->rf_interval == 0) {\n      /* this should not happen, because the interval is set\n       * for each plugin when loading it\n       * XXX: issue a warning? */\n      rf->rf_interval = plugin_get_interval();\n      rf->rf_effective_interval = rf->rf_interval;\n\n      rf->rf_next_read = cdtime();\n    }\n\n    /* sleep until this entry is due,\n     * using pthread_cond_timedwait */\n    pthread_mutex_lock(&read_lock);\n    /* In pthread_cond_timedwait, spurious wakeups are possible\n     * (and really happen, at least on NetBSD with > 1 CPU), thus\n     * we need to re-evaluate the condition every time\n     * pthread_cond_timedwait returns. */\n    rc = 0;\n    while ((read_loop != 0) && (cdtime() < rf->rf_next_read) && rc == 0) {\n      rc = pthread_cond_timedwait(&read_cond, &read_lock,\n                                  &CDTIME_T_TO_TIMESPEC(rf->rf_next_read));\n    }\n\n    /* Must hold `read_lock' when accessing `rf->rf_type'. */\n    rf_type = rf->rf_type;\n    pthread_mutex_unlock(&read_lock);\n\n    /* Check if we're supposed to stop.. This may have interrupted\n     * the sleep, too. */\n    if (read_loop == 0) {\n      /* Insert `rf' again, so it can be free'd correctly */\n      c_heap_insert(read_heap, rf);\n      break;\n    }\n\n    /* The entry has been marked for deletion. The linked list\n     * entry has already been removed by `plugin_unregister_read'.\n     * All we have to do here is free the `read_func_t' and\n     * continue. */\n    if (rf_type == RF_REMOVE) {\n      DEBUG(\"plugin_read_thread: Destroying the `%s' \"\n            \"callback.\",\n            rf->rf_name);\n      sfree(rf->rf_name);\n      destroy_callback((callback_func_t *)rf);\n      rf = NULL;\n      continue;\n    }\n\n    DEBUG(\"plugin_read_thread: Handling `%s'.\", rf->rf_name);\n\n    start = cdtime();\n\n    old_ctx = plugin_set_ctx(rf->rf_ctx);\n\n    if (rf_type == RF_SIMPLE) {\n      int (*callback)(void);\n\n      callback = rf->rf_callback;\n      status = (*callback)();\n    } else {\n      plugin_read_cb callback;\n\n      assert(rf_type == RF_COMPLEX);\n\n      callback = rf->rf_callback;\n      status = (*callback)(&rf->rf_udata);\n    }\n\n    plugin_set_ctx(old_ctx);\n\n    /* If the function signals failure, we will increase the\n     * intervals in which it will be called. */\n    if (status != 0) {\n      rf->rf_effective_interval *= 2;\n      if (rf->rf_effective_interval > max_read_interval)\n        rf->rf_effective_interval = max_read_interval;\n\n      NOTICE(\"read-function of plugin `%s' failed. \"\n             \"Will suspend it for %.3f seconds.\",\n             rf->rf_name, CDTIME_T_TO_DOUBLE(rf->rf_effective_interval));\n    } else {\n      /* Success: Restore the interval, if it was changed. */\n      rf->rf_effective_interval = rf->rf_interval;\n    }\n\n    /* update the ``next read due'' field */\n    now = cdtime();\n\n    /* calculate the time spent in the read function */\n    elapsed = (now - start);\n\n    if (elapsed > rf->rf_effective_interval)\n      WARNING(\n          \"plugin_read_thread: read-function of the `%s' plugin took %.3f \"\n          \"seconds, which is above its read interval (%.3f seconds). You might \"\n          \"want to adjust the `Interval' or `ReadThreads' settings.\",\n          rf->rf_name, CDTIME_T_TO_DOUBLE(elapsed),\n          CDTIME_T_TO_DOUBLE(rf->rf_effective_interval));\n\n    DEBUG(\"plugin_read_thread: read-function of the `%s' plugin took \"\n          \"%.6f seconds.\",\n          rf->rf_name, CDTIME_T_TO_DOUBLE(elapsed));\n\n    DEBUG(\"plugin_read_thread: Effective interval of the \"\n          \"`%s' plugin is %.3f seconds.\",\n          rf->rf_name, CDTIME_T_TO_DOUBLE(rf->rf_effective_interval));\n\n    /* Calculate the next (absolute) time at which this function\n     * should be called. */\n    rf->rf_next_read += rf->rf_effective_interval;\n\n    /* Check, if `rf_next_read' is in the past. */\n    if (rf->rf_next_read < now) {\n      /* `rf_next_read' is in the past. Insert `now'\n       * so this value doesn't trail off into the\n       * past too much. */\n      rf->rf_next_read = now;\n    }\n\n    DEBUG(\"plugin_read_thread: Next read of the `%s' plugin at %.3f.\",\n          rf->rf_name, CDTIME_T_TO_DOUBLE(rf->rf_next_read));\n\n    /* Re-insert this read function into the heap again. */\n    c_heap_insert(read_heap, rf);\n  } /* while (read_loop) */\n\n  pthread_exit(NULL);\n  return (void *)0;\n} /* void *plugin_read_thread */\n\n#ifdef PTHREAD_MAX_NAMELEN_NP\n#define THREAD_NAME_MAX PTHREAD_MAX_NAMELEN_NP\n#else\n#define THREAD_NAME_MAX 16\n#endif\n\nstatic void set_thread_name(pthread_t tid, char const *name) {\n#if defined(HAVE_PTHREAD_SETNAME_NP) || defined(HAVE_PTHREAD_SET_NAME_NP)\n\n  /* glibc limits the length of the name and fails if the passed string\n   * is too long, so we truncate it here. */\n  char n[THREAD_NAME_MAX];\n  if (strlen(name) >= THREAD_NAME_MAX)\n    WARNING(\"set_thread_name(\\\"%s\\\"): name too long\", name);\n  sstrncpy(n, name, sizeof(n));\n\n#if defined(HAVE_PTHREAD_SETNAME_NP)\n  int status = pthread_setname_np(tid, n);\n  if (status != 0) {\n    ERROR(\"set_thread_name(\\\"%s\\\"): %s\", n, STRERROR(status));\n  }\n#else /* if defined(HAVE_PTHREAD_SET_NAME_NP) */\n  pthread_set_name_np(tid, n);\n#endif\n\n#endif\n}\n\nstatic void start_read_threads(size_t num) /* {{{ */\n{\n  if (read_threads != NULL)\n    return;\n\n  read_threads = calloc(num, sizeof(*read_threads));\n  if (read_threads == NULL) {\n    ERROR(\"plugin: start_read_threads: calloc failed.\");\n    return;\n  }\n\n  read_threads_num = 0;\n  for (size_t i = 0; i < num; i++) {\n    int status = pthread_create(read_threads + read_threads_num,\n                                /* attr = */ NULL, plugin_read_thread,\n                                /* arg = */ NULL);\n    if (status != 0) {\n      ERROR(\"plugin: start_read_threads: pthread_create failed with status %i \"\n            \"(%s).\",\n            status, STRERROR(status));\n      return;\n    }\n\n    char name[THREAD_NAME_MAX];\n    ssnprintf(name, sizeof(name), \"reader#%\" PRIu64,\n              (uint64_t)read_threads_num);\n    set_thread_name(read_threads[read_threads_num], name);\n\n    read_threads_num++;\n  } /* for (i) */\n} /* }}} void start_read_threads */\n\nstatic void stop_read_threads(void) {\n  if (read_threads == NULL)\n    return;\n\n  INFO(\"collectd: Stopping %\" PRIsz \" read threads.\", read_threads_num);\n\n  pthread_mutex_lock(&read_lock);\n  read_loop = 0;\n  DEBUG(\"plugin: stop_read_threads: Signalling `read_cond'\");\n  pthread_cond_broadcast(&read_cond);\n  pthread_mutex_unlock(&read_lock);\n\n  for (size_t i = 0; i < read_threads_num; i++) {\n    if (pthread_join(read_threads[i], NULL) != 0) {\n      ERROR(\"plugin: stop_read_threads: pthread_join failed.\");\n    }\n    read_threads[i] = (pthread_t)0;\n  }\n  sfree(read_threads);\n  read_threads_num = 0;\n} /* void stop_read_threads */\n\nstatic void plugin_value_list_free(value_list_t *vl) /* {{{ */\n{\n  if (vl == NULL)\n    return;\n\n  meta_data_destroy(vl->meta);\n  sfree(vl->values);\n  sfree(vl);\n} /* }}} void plugin_value_list_free */\n\nstatic value_list_t *\nplugin_value_list_clone(value_list_t const *vl_orig) /* {{{ */\n{\n  value_list_t *vl;\n\n  if (vl_orig == NULL)\n    return NULL;\n\n  vl = malloc(sizeof(*vl));\n  if (vl == NULL)\n    return NULL;\n  memcpy(vl, vl_orig, sizeof(*vl));\n\n  if (vl->host[0] == 0)\n    sstrncpy(vl->host, hostname_g, sizeof(vl->host));\n\n  vl->values = calloc(vl_orig->values_len, sizeof(*vl->values));\n  if (vl->values == NULL) {\n    plugin_value_list_free(vl);\n    return NULL;\n  }\n  memcpy(vl->values, vl_orig->values,\n         vl_orig->values_len * sizeof(*vl->values));\n\n  vl->meta = meta_data_clone(vl->meta);\n  if ((vl_orig->meta != NULL) && (vl->meta == NULL)) {\n    plugin_value_list_free(vl);\n    return NULL;\n  }\n\n  if (vl->time == 0)\n    vl->time = cdtime();\n\n  /* Fill in the interval from the thread context, if it is zero. */\n  if (vl->interval == 0)\n    vl->interval = plugin_get_interval();\n\n  return vl;\n} /* }}} value_list_t *plugin_value_list_clone */\n\nstatic int plugin_write_enqueue(value_list_t const *vl) /* {{{ */\n{\n  write_queue_t *q;\n\n  q = malloc(sizeof(*q));\n  if (q == NULL)\n    return ENOMEM;\n  q->next = NULL;\n\n  q->vl = plugin_value_list_clone(vl);\n  if (q->vl == NULL) {\n    sfree(q);\n    return ENOMEM;\n  }\n\n  /* Store context of caller (read plugin); otherwise, it would not be\n   * available to the write plugins when actually dispatching the\n   * value-list later on. */\n  q->ctx = plugin_get_ctx();\n\n  pthread_mutex_lock(&write_lock);\n\n  if (write_queue_tail == NULL) {\n    write_queue_head = q;\n    write_queue_tail = q;\n    write_queue_length = 1;\n  } else {\n    write_queue_tail->next = q;\n    write_queue_tail = q;\n    write_queue_length += 1;\n  }\n\n  pthread_cond_signal(&write_cond);\n  pthread_mutex_unlock(&write_lock);\n\n  return 0;\n} /* }}} int plugin_write_enqueue */\n\nstatic value_list_t *plugin_write_dequeue(void) /* {{{ */\n{\n  write_queue_t *q;\n  value_list_t *vl;\n\n  pthread_mutex_lock(&write_lock);\n\n  while (write_loop && (write_queue_head == NULL))\n    pthread_cond_wait(&write_cond, &write_lock);\n\n  if (write_queue_head == NULL) {\n    pthread_mutex_unlock(&write_lock);\n    return NULL;\n  }\n\n  q = write_queue_head;\n  write_queue_head = q->next;\n  write_queue_length -= 1;\n  if (write_queue_head == NULL) {\n    write_queue_tail = NULL;\n    assert(0 == write_queue_length);\n  }\n\n  pthread_mutex_unlock(&write_lock);\n\n  (void)plugin_set_ctx(q->ctx);\n\n  vl = q->vl;\n  sfree(q);\n  return vl;\n} /* }}} value_list_t *plugin_write_dequeue */\n\nstatic void *plugin_write_thread(void __attribute__((unused)) * args) /* {{{ */\n{\n  while (write_loop) {\n    value_list_t *vl = plugin_write_dequeue();\n    if (vl == NULL)\n      continue;\n\n    plugin_dispatch_values_internal(vl);\n\n    plugin_value_list_free(vl);\n  }\n\n  pthread_exit(NULL);\n  return (void *)0;\n} /* }}} void *plugin_write_thread */\n\nstatic void start_write_threads(size_t num) /* {{{ */\n{\n  if (write_threads != NULL)\n    return;\n\n  write_threads = calloc(num, sizeof(*write_threads));\n  if (write_threads == NULL) {\n    ERROR(\"plugin: start_write_threads: calloc failed.\");\n    return;\n  }\n\n  write_threads_num = 0;\n  for (size_t i = 0; i < num; i++) {\n    int status = pthread_create(write_threads + write_threads_num,\n                                /* attr = */ NULL, plugin_write_thread,\n                                /* arg = */ NULL);\n    if (status != 0) {\n      ERROR(\"plugin: start_write_threads: pthread_create failed with status %i \"\n            \"(%s).\",\n            status, STRERROR(status));\n      return;\n    }\n\n    char name[THREAD_NAME_MAX];\n    ssnprintf(name, sizeof(name), \"writer#%\" PRIu64,\n              (uint64_t)write_threads_num);\n    set_thread_name(write_threads[write_threads_num], name);\n\n    write_threads_num++;\n  } /* for (i) */\n} /* }}} void start_write_threads */\n\nstatic void stop_write_threads(void) /* {{{ */\n{\n  write_queue_t *q;\n  size_t i;\n\n  if (write_threads == NULL)\n    return;\n\n  INFO(\"collectd: Stopping %\" PRIsz \" write threads.\", write_threads_num);\n\n  pthread_mutex_lock(&write_lock);\n  write_loop = false;\n  DEBUG(\"plugin: stop_write_threads: Signalling `write_cond'\");\n  pthread_cond_broadcast(&write_cond);\n  pthread_mutex_unlock(&write_lock);\n\n  for (i = 0; i < write_threads_num; i++) {\n    if (pthread_join(write_threads[i], NULL) != 0) {\n      ERROR(\"plugin: stop_write_threads: pthread_join failed.\");\n    }\n    write_threads[i] = (pthread_t)0;\n  }\n  sfree(write_threads);\n  write_threads_num = 0;\n\n  pthread_mutex_lock(&write_lock);\n  i = 0;\n  for (q = write_queue_head; q != NULL;) {\n    write_queue_t *q1 = q;\n    plugin_value_list_free(q->vl);\n    q = q->next;\n    sfree(q1);\n    i++;\n  }\n  write_queue_head = NULL;\n  write_queue_tail = NULL;\n  write_queue_length = 0;\n  pthread_mutex_unlock(&write_lock);\n\n  if (i > 0) {\n    WARNING(\"plugin: %\" PRIsz \" value list%s left after shutting down \"\n            \"the write threads.\",\n            i, (i == 1) ? \" was\" : \"s were\");\n  }\n} /* }}} void stop_write_threads */\n\n/*\n * Public functions\n */\nvoid plugin_set_dir(const char *dir) {\n  sfree(plugindir);\n\n  if (dir == NULL) {\n    plugindir = NULL;\n    return;\n  }\n\n  plugindir = strdup(dir);\n  if (plugindir == NULL)\n    ERROR(\"plugin_set_dir: strdup(\\\"%s\\\") failed\", dir);\n}\n\nbool plugin_is_loaded(char const *name) {\n  if (plugins_loaded == NULL)\n    plugins_loaded =\n        c_avl_create((int (*)(const void *, const void *))strcasecmp);\n  assert(plugins_loaded != NULL);\n\n  int status = c_avl_get(plugins_loaded, name, /* ret_value = */ NULL);\n  return status == 0;\n}\n\nstatic int plugin_mark_loaded(char const *name) {\n  char *name_copy;\n  int status;\n\n  name_copy = strdup(name);\n  if (name_copy == NULL)\n    return ENOMEM;\n\n  status = c_avl_insert(plugins_loaded,\n                        /* key = */ name_copy, /* value = */ NULL);\n  return status;\n}\n\nstatic void plugin_free_loaded(void) {\n  void *key;\n  void *value;\n\n  if (plugins_loaded == NULL)\n    return;\n\n  while (c_avl_pick(plugins_loaded, &key, &value) == 0) {\n    sfree(key);\n    assert(value == NULL);\n  }\n\n  c_avl_destroy(plugins_loaded);\n  plugins_loaded = NULL;\n}\n\n#define BUFSIZE 512\n#ifdef WIN32\n#define SHLIB_SUFFIX \".dll\"\n#else\n#define SHLIB_SUFFIX \".so\"\n#endif\nint plugin_load(char const *plugin_name, bool global) {\n  DIR *dh;\n  const char *dir;\n  char filename[BUFSIZE] = \"\";\n  char typename[BUFSIZE];\n  int ret;\n  struct stat statbuf;\n  struct dirent *de;\n  int status;\n\n  if (plugin_name == NULL)\n    return EINVAL;\n\n  /* Check if plugin is already loaded and don't do anything in this\n   * case. */\n  if (plugin_is_loaded(plugin_name))\n    return 0;\n\n  dir = plugin_get_dir();\n  ret = 1;\n\n  /*\n   * XXX: Magic at work:\n   *\n   * Some of the language bindings, for example the Python and Perl\n   * plugins, need to be able to export symbols to the scripts they run.\n   * For this to happen, the \"Globals\" flag needs to be set.\n   * Unfortunately, this technical detail is hard to explain to the\n   * average user and she shouldn't have to worry about this, ideally.\n   * So in order to save everyone's sanity use a different default for a\n   * handful of special plugins. --octo\n   */\n  if ((strcasecmp(\"perl\", plugin_name) == 0) ||\n      (strcasecmp(\"python\", plugin_name) == 0))\n    global = true;\n\n  /* `cpu' should not match `cpufreq'. To solve this we add SHLIB_SUFFIX to the\n   * type when matching the filename */\n  status = snprintf(typename, sizeof(typename), \"%s\" SHLIB_SUFFIX, plugin_name);\n  if ((status < 0) || ((size_t)status >= sizeof(typename))) {\n    WARNING(\"plugin_load: Filename too long: \\\"%s\" SHLIB_SUFFIX \"\\\"\",\n            plugin_name);\n    return -1;\n  }\n\n  if ((dh = opendir(dir)) == NULL) {\n    ERROR(\"plugin_load: opendir (%s) failed: %s\", dir, STRERRNO);\n    return -1;\n  }\n\n  while ((de = readdir(dh)) != NULL) {\n    if (strcasecmp(de->d_name, typename))\n      continue;\n\n    status = snprintf(filename, sizeof(filename), \"%s/%s\", dir, de->d_name);\n    if ((status < 0) || ((size_t)status >= sizeof(filename))) {\n      WARNING(\"plugin_load: Filename too long: \\\"%s/%s\\\"\", dir, de->d_name);\n      continue;\n    }\n\n    if (lstat(filename, &statbuf) == -1) {\n      WARNING(\"plugin_load: stat (\\\"%s\\\") failed: %s\", filename, STRERRNO);\n      continue;\n    } else if (!S_ISREG(statbuf.st_mode)) {\n      /* don't follow symlinks */\n      WARNING(\"plugin_load: %s is not a regular file.\", filename);\n      continue;\n    }\n\n    status = plugin_load_file(filename, global);\n    if (status == 0) {\n      /* success */\n      plugin_mark_loaded(plugin_name);\n      ret = 0;\n      INFO(\"plugin_load: plugin \\\"%s\\\" successfully loaded.\", plugin_name);\n      break;\n    } else {\n      ERROR(\"plugin_load: Load plugin \\\"%s\\\" failed with \"\n            \"status %i.\",\n            plugin_name, status);\n    }\n  }\n\n  closedir(dh);\n\n  if (filename[0] == 0)\n    ERROR(\"plugin_load: Could not find plugin \\\"%s\\\" in %s\", plugin_name, dir);\n\n  return ret;\n}\n\n/*\n * The `register_*' functions follow\n */\nEXPORT int plugin_register_config(const char *name,\n                                  int (*callback)(const char *key,\n                                                  const char *val),\n                                  const char **keys, int keys_num) {\n  cf_register(name, callback, keys, keys_num);\n  return 0;\n} /* int plugin_register_config */\n\nEXPORT int plugin_register_complex_config(const char *type,\n                                          int (*callback)(oconfig_item_t *)) {\n  return cf_register_complex(type, callback);\n} /* int plugin_register_complex_config */\n\nEXPORT int plugin_register_init(const char *name, int (*callback)(void)) {\n  return create_register_callback(&list_init, name, (void *)callback, NULL);\n} /* plugin_register_init */\n\nstatic int plugin_compare_read_func(const void *arg0, const void *arg1) {\n  const read_func_t *rf0;\n  const read_func_t *rf1;\n\n  rf0 = arg0;\n  rf1 = arg1;\n\n  if (rf0->rf_next_read < rf1->rf_next_read)\n    return -1;\n  else if (rf0->rf_next_read > rf1->rf_next_read)\n    return 1;\n  else\n    return 0;\n} /* int plugin_compare_read_func */\n\n/* Add a read function to both, the heap and a linked list. The linked list if\n * used to look-up read functions, especially for the remove function. The heap\n * is used to determine which plugin to read next. */\nstatic int plugin_insert_read(read_func_t *rf) {\n  int status;\n  llentry_t *le;\n\n  rf->rf_next_read = cdtime();\n  rf->rf_effective_interval = rf->rf_interval;\n\n  pthread_mutex_lock(&read_lock);\n\n  if (read_list == NULL) {\n    read_list = llist_create();\n    if (read_list == NULL) {\n      pthread_mutex_unlock(&read_lock);\n      ERROR(\"plugin_insert_read: read_list failed.\");\n      return -1;\n    }\n  }\n\n  if (read_heap == NULL) {\n    read_heap = c_heap_create(plugin_compare_read_func);\n    if (read_heap == NULL) {\n      pthread_mutex_unlock(&read_lock);\n      ERROR(\"plugin_insert_read: c_heap_create failed.\");\n      return -1;\n    }\n  }\n\n  le = llist_search(read_list, rf->rf_name);\n  if (le != NULL) {\n    pthread_mutex_unlock(&read_lock);\n    P_WARNING(\"The read function \\\"%s\\\" is already registered. \"\n              \"Check for duplicates in your configuration!\",\n              rf->rf_name);\n    return EINVAL;\n  }\n\n  le = llentry_create(rf->rf_name, rf);\n  if (le == NULL) {\n    pthread_mutex_unlock(&read_lock);\n    ERROR(\"plugin_insert_read: llentry_create failed.\");\n    return -1;\n  }\n\n  status = c_heap_insert(read_heap, rf);\n  if (status != 0) {\n    pthread_mutex_unlock(&read_lock);\n    ERROR(\"plugin_insert_read: c_heap_insert failed.\");\n    llentry_destroy(le);\n    return -1;\n  }\n\n  /* This does not fail. */\n  llist_append(read_list, le);\n\n  /* Wake up all the read threads. */\n  pthread_cond_broadcast(&read_cond);\n  pthread_mutex_unlock(&read_lock);\n  return 0;\n} /* int plugin_insert_read */\n\nEXPORT int plugin_register_read(const char *name, int (*callback)(void)) {\n  read_func_t *rf;\n  int status;\n\n  rf = calloc(1, sizeof(*rf));\n  if (rf == NULL) {\n    ERROR(\"plugin_register_read: calloc failed.\");\n    return ENOMEM;\n  }\n\n  rf->rf_callback = (void *)callback;\n  rf->rf_udata.data = NULL;\n  rf->rf_udata.free_func = NULL;\n  rf->rf_ctx = plugin_get_ctx();\n  rf->rf_group[0] = '\\0';\n  rf->rf_name = strdup(name);\n  rf->rf_type = RF_SIMPLE;\n  rf->rf_interval = plugin_get_interval();\n  rf->rf_ctx.interval = rf->rf_interval;\n\n  status = plugin_insert_read(rf);\n  if (status != 0) {\n    sfree(rf->rf_name);\n    sfree(rf);\n  }\n\n  return status;\n} /* int plugin_register_read */\n\nEXPORT int plugin_register_complex_read(const char *group, const char *name,\n                                        plugin_read_cb callback,\n                                        cdtime_t interval,\n                                        user_data_t const *user_data) {\n  read_func_t *rf;\n  int status;\n\n  rf = calloc(1, sizeof(*rf));\n  if (rf == NULL) {\n    free_userdata(user_data);\n    ERROR(\"plugin_register_complex_read: calloc failed.\");\n    return ENOMEM;\n  }\n\n  rf->rf_callback = (void *)callback;\n  if (group != NULL)\n    sstrncpy(rf->rf_group, group, sizeof(rf->rf_group));\n  else\n    rf->rf_group[0] = '\\0';\n  rf->rf_name = strdup(name);\n  rf->rf_type = RF_COMPLEX;\n  rf->rf_interval = (interval != 0) ? interval : plugin_get_interval();\n\n  /* Set user data */\n  if (user_data == NULL) {\n    rf->rf_udata.data = NULL;\n    rf->rf_udata.free_func = NULL;\n  } else {\n    rf->rf_udata = *user_data;\n  }\n\n  rf->rf_ctx = plugin_get_ctx();\n  rf->rf_ctx.interval = rf->rf_interval;\n\n  status = plugin_insert_read(rf);\n  if (status != 0) {\n    free_userdata(&rf->rf_udata);\n    sfree(rf->rf_name);\n    sfree(rf);\n  }\n\n  return status;\n} /* int plugin_register_complex_read */\n\nEXPORT int plugin_register_write(const char *name, plugin_write_cb callback,\n                                 user_data_t const *ud) {\n  return create_register_callback(&list_write, name, (void *)callback, ud);\n} /* int plugin_register_write */\n\nstatic int plugin_flush_timeout_callback(user_data_t *ud) {\n  flush_callback_t *cb = ud->data;\n\n  return plugin_flush(cb->name, cb->timeout, NULL);\n} /* static int plugin_flush_callback */\n\nstatic void plugin_flush_timeout_callback_free(void *data) {\n  flush_callback_t *cb = data;\n\n  if (cb == NULL)\n    return;\n\n  sfree(cb->name);\n  sfree(cb);\n} /* static void plugin_flush_callback_free */\n\nstatic char *plugin_flush_callback_name(const char *name) {\n  const char *flush_prefix = \"flush/\";\n  size_t prefix_size;\n  char *flush_name;\n  size_t name_size;\n\n  prefix_size = strlen(flush_prefix);\n  name_size = strlen(name);\n\n  flush_name = malloc(name_size + prefix_size + 1);\n  if (flush_name == NULL) {\n    ERROR(\"plugin_flush_callback_name: malloc failed.\");\n    return NULL;\n  }\n\n  sstrncpy(flush_name, flush_prefix, prefix_size + 1);\n  sstrncpy(flush_name + prefix_size, name, name_size + 1);\n\n  return flush_name;\n} /* static char *plugin_flush_callback_name */\n\nEXPORT int plugin_register_flush(const char *name, plugin_flush_cb callback,\n                                 user_data_t const *ud) {\n  int status;\n  plugin_ctx_t ctx = plugin_get_ctx();\n\n  status = create_register_callback(&list_flush, name, (void *)callback, ud);\n  if (status != 0)\n    return status;\n\n  if (ctx.flush_interval != 0) {\n    char *flush_name;\n    flush_callback_t *cb;\n\n    flush_name = plugin_flush_callback_name(name);\n    if (flush_name == NULL)\n      return -1;\n\n    cb = malloc(sizeof(*cb));\n    if (cb == NULL) {\n      ERROR(\"plugin_register_flush: malloc failed.\");\n      sfree(flush_name);\n      return -1;\n    }\n\n    cb->name = strdup(name);\n    if (cb->name == NULL) {\n      ERROR(\"plugin_register_flush: strdup failed.\");\n      sfree(cb);\n      sfree(flush_name);\n      return -1;\n    }\n    cb->timeout = ctx.flush_timeout;\n\n    status = plugin_register_complex_read(\n        /* group     = */ \"flush\",\n        /* name      = */ flush_name,\n        /* callback  = */ plugin_flush_timeout_callback,\n        /* interval  = */ ctx.flush_interval,\n        /* user data = */\n        &(user_data_t){\n            .data = cb,\n            .free_func = plugin_flush_timeout_callback_free,\n        });\n\n    sfree(flush_name);\n    return status;\n  }\n\n  return 0;\n} /* int plugin_register_flush */\n\nEXPORT int plugin_register_missing(const char *name, plugin_missing_cb callback,\n                                   user_data_t const *ud) {\n  return create_register_callback(&list_missing, name, (void *)callback, ud);\n} /* int plugin_register_missing */\n\nEXPORT int plugin_register_cache_event(const char *name,\n                                       plugin_cache_event_cb callback,\n                                       user_data_t const *ud) {\n\n  if (name == NULL || callback == NULL)\n    return EINVAL;\n\n  char *name_copy = strdup(name);\n  if (name_copy == NULL) {\n    P_ERROR(\"plugin_register_cache_event: strdup failed.\");\n    free_userdata(ud);\n    return ENOMEM;\n  }\n\n  if (list_cache_event_num >= 32) {\n    P_ERROR(\"plugin_register_cache_event: Too much cache event callbacks tried \"\n            \"to be registered.\");\n    free_userdata(ud);\n    return ENOMEM;\n  }\n\n  for (size_t i = 0; i < list_cache_event_num; i++) {\n    cache_event_func_t *cef = &list_cache_event[i];\n    if (!cef->callback)\n      continue;\n\n    if (strcmp(name, cef->name) == 0) {\n      P_ERROR(\"plugin_register_cache_event: a callback named `%s' already \"\n              \"registered!\",\n              name);\n      free_userdata(ud);\n      return -1;\n    }\n  }\n\n  user_data_t user_data;\n  if (ud == NULL) {\n    user_data = (user_data_t){\n        .data = NULL,\n        .free_func = NULL,\n    };\n  } else {\n    user_data = *ud;\n  }\n\n  list_cache_event[list_cache_event_num] =\n      (cache_event_func_t){.callback = callback,\n                           .name = name_copy,\n                           .user_data = user_data,\n                           .plugin_ctx = plugin_get_ctx()};\n  list_cache_event_num++;\n\n  return 0;\n} /* int plugin_register_cache_event */\n\nEXPORT int plugin_register_shutdown(const char *name, int (*callback)(void)) {\n  return create_register_callback(&list_shutdown, name, (void *)callback, NULL);\n} /* int plugin_register_shutdown */\n\nstatic void plugin_free_data_sets(void) {\n  void *key;\n  void *value;\n\n  if (data_sets == NULL)\n    return;\n\n  while (c_avl_pick(data_sets, &key, &value) == 0) {\n    data_set_t *ds = value;\n    /* key is a pointer to ds->type */\n\n    sfree(ds->ds);\n    sfree(ds);\n  }\n\n  c_avl_destroy(data_sets);\n  data_sets = NULL;\n} /* void plugin_free_data_sets */\n\nEXPORT int plugin_register_data_set(const data_set_t *ds) {\n  data_set_t *ds_copy;\n\n  if ((data_sets != NULL) && (c_avl_get(data_sets, ds->type, NULL) == 0)) {\n    NOTICE(\"Replacing DS `%s' with another version.\", ds->type);\n    plugin_unregister_data_set(ds->type);\n  } else if (data_sets == NULL) {\n    data_sets = c_avl_create((int (*)(const void *, const void *))strcmp);\n    if (data_sets == NULL)\n      return -1;\n  }\n\n  ds_copy = malloc(sizeof(*ds_copy));\n  if (ds_copy == NULL)\n    return -1;\n  memcpy(ds_copy, ds, sizeof(data_set_t));\n\n  ds_copy->ds = malloc(sizeof(*ds_copy->ds) * ds->ds_num);\n  if (ds_copy->ds == NULL) {\n    sfree(ds_copy);\n    return -1;\n  }\n\n  for (size_t i = 0; i < ds->ds_num; i++)\n    memcpy(ds_copy->ds + i, ds->ds + i, sizeof(data_source_t));\n\n  return c_avl_insert(data_sets, (void *)ds_copy->type, (void *)ds_copy);\n} /* int plugin_register_data_set */\n\nEXPORT int plugin_register_log(const char *name, plugin_log_cb callback,\n                               user_data_t const *ud) {\n  return create_register_callback(&list_log, name, (void *)callback, ud);\n} /* int plugin_register_log */\n\nEXPORT int plugin_register_notification(const char *name,\n                                        plugin_notification_cb callback,\n                                        user_data_t const *ud) {\n  return create_register_callback(&list_notification, name, (void *)callback,\n                                  ud);\n} /* int plugin_register_log */\n\nEXPORT int plugin_unregister_config(const char *name) {\n  cf_unregister(name);\n  return 0;\n} /* int plugin_unregister_config */\n\nEXPORT int plugin_unregister_complex_config(const char *name) {\n  cf_unregister_complex(name);\n  return 0;\n} /* int plugin_unregister_complex_config */\n\nEXPORT int plugin_unregister_init(const char *name) {\n  return plugin_unregister(list_init, name);\n}\n\nEXPORT int plugin_unregister_read(const char *name) /* {{{ */\n{\n  llentry_t *le;\n  read_func_t *rf;\n\n  if (name == NULL)\n    return -ENOENT;\n\n  pthread_mutex_lock(&read_lock);\n\n  if (read_list == NULL) {\n    pthread_mutex_unlock(&read_lock);\n    return -ENOENT;\n  }\n\n  le = llist_search(read_list, name);\n  if (le == NULL) {\n    pthread_mutex_unlock(&read_lock);\n    WARNING(\"plugin_unregister_read: No such read function: %s\", name);\n    return -ENOENT;\n  }\n\n  llist_remove(read_list, le);\n\n  rf = le->value;\n  assert(rf != NULL);\n  rf->rf_type = RF_REMOVE;\n\n  pthread_mutex_unlock(&read_lock);\n\n  llentry_destroy(le);\n\n  DEBUG(\"plugin_unregister_read: Marked `%s' for removal.\", name);\n\n  return 0;\n} /* }}} int plugin_unregister_read */\n\nEXPORT void plugin_log_available_writers(void) {\n  log_list_callbacks(&list_write, \"Available write targets:\");\n}\n\nstatic int compare_read_func_group(llentry_t *e, void *ud) /* {{{ */\n{\n  read_func_t *rf = e->value;\n  char *group = ud;\n\n  return strcmp(rf->rf_group, (const char *)group);\n} /* }}} int compare_read_func_group */\n\nEXPORT int plugin_unregister_read_group(const char *group) /* {{{ */\n{\n  llentry_t *le;\n  read_func_t *rf;\n\n  int found = 0;\n\n  if (group == NULL)\n    return -ENOENT;\n\n  pthread_mutex_lock(&read_lock);\n\n  if (read_list == NULL) {\n    pthread_mutex_unlock(&read_lock);\n    return -ENOENT;\n  }\n\n  while (42) {\n    le = llist_search_custom(read_list, compare_read_func_group, (void *)group);\n\n    if (le == NULL)\n      break;\n\n    ++found;\n\n    llist_remove(read_list, le);\n\n    rf = le->value;\n    assert(rf != NULL);\n    rf->rf_type = RF_REMOVE;\n\n    llentry_destroy(le);\n\n    DEBUG(\"plugin_unregister_read_group: \"\n          \"Marked `%s' (group `%s') for removal.\",\n          rf->rf_name, group);\n  }\n\n  pthread_mutex_unlock(&read_lock);\n\n  if (found == 0) {\n    WARNING(\"plugin_unregister_read_group: No such \"\n            \"group of read function: %s\",\n            group);\n    return -ENOENT;\n  }\n\n  return 0;\n} /* }}} int plugin_unregister_read_group */\n\nEXPORT int plugin_unregister_write(const char *name) {\n  return plugin_unregister(list_write, name);\n}\n\nEXPORT int plugin_unregister_flush(const char *name) {\n  plugin_ctx_t ctx = plugin_get_ctx();\n\n  if (ctx.flush_interval != 0) {\n    char *flush_name;\n\n    flush_name = plugin_flush_callback_name(name);\n    if (flush_name != NULL) {\n      plugin_unregister_read(flush_name);\n      sfree(flush_name);\n    }\n  }\n\n  return plugin_unregister(list_flush, name);\n}\n\nEXPORT int plugin_unregister_missing(const char *name) {\n  return plugin_unregister(list_missing, name);\n}\n\nEXPORT int plugin_unregister_cache_event(const char *name) {\n  for (size_t i = 0; i < list_cache_event_num; i++) {\n    cache_event_func_t *cef = &list_cache_event[i];\n    if (!cef->callback)\n      continue;\n    if (strcmp(name, cef->name) == 0) {\n      /* Mark callback as inactive, so mask in cache entries remains actual */\n      cef->callback = NULL;\n      sfree(cef->name);\n      free_userdata(&cef->user_data);\n    }\n  }\n  return 0;\n}\n\nstatic void destroy_cache_event_callbacks() {\n  for (size_t i = 0; i < list_cache_event_num; i++) {\n    cache_event_func_t *cef = &list_cache_event[i];\n    if (!cef->callback)\n      continue;\n    cef->callback = NULL;\n    sfree(cef->name);\n    free_userdata(&cef->user_data);\n  }\n}\n\nEXPORT int plugin_unregister_shutdown(const char *name) {\n  return plugin_unregister(list_shutdown, name);\n}\n\nEXPORT int plugin_unregister_data_set(const char *name) {\n  data_set_t *ds;\n\n  if (data_sets == NULL)\n    return -1;\n\n  if (c_avl_remove(data_sets, name, NULL, (void *)&ds) != 0)\n    return -1;\n\n  sfree(ds->ds);\n  sfree(ds);\n\n  return 0;\n} /* int plugin_unregister_data_set */\n\nEXPORT int plugin_unregister_log(const char *name) {\n  return plugin_unregister(list_log, name);\n}\n\nEXPORT int plugin_unregister_notification(const char *name) {\n  return plugin_unregister(list_notification, name);\n}\n\nEXPORT int plugin_init_all(void) {\n  char const *chain_name;\n  llentry_t *le;\n  int status;\n  int ret = 0;\n\n  /* Init the value cache */\n  uc_init();\n\n  if (IS_TRUE(global_option_get(\"CollectInternalStats\"))) {\n    record_statistics = true;\n    plugin_register_read(\"collectd\", plugin_update_internal_statistics);\n  }\n\n  chain_name = global_option_get(\"PreCacheChain\");\n  pre_cache_chain = fc_chain_get_by_name(chain_name);\n\n  chain_name = global_option_get(\"PostCacheChain\");\n  post_cache_chain = fc_chain_get_by_name(chain_name);\n\n  write_limit_high = global_option_get_long(\"WriteQueueLimitHigh\",\n                                            /* default = */ 0);\n  if (write_limit_high < 0) {\n    ERROR(\"WriteQueueLimitHigh must be positive or zero.\");\n    write_limit_high = 0;\n  }\n\n  write_limit_low =\n      global_option_get_long(\"WriteQueueLimitLow\",\n                             /* default = */ write_limit_high / 2);\n  if (write_limit_low < 0) {\n    ERROR(\"WriteQueueLimitLow must be positive or zero.\");\n    write_limit_low = write_limit_high / 2;\n  } else if (write_limit_low > write_limit_high) {\n    ERROR(\"WriteQueueLimitLow must not be larger than \"\n          \"WriteQueueLimitHigh.\");\n    write_limit_low = write_limit_high;\n  }\n\n  write_threads_num = global_option_get_long(\"WriteThreads\",\n                                             /* default = */ 5);\n  if (write_threads_num < 1) {\n    ERROR(\"WriteThreads must be positive.\");\n    write_threads_num = 5;\n  }\n\n  if ((list_init == NULL) && (read_heap == NULL))\n    return ret;\n\n  /* Calling all init callbacks before checking if read callbacks\n   * are available allows the init callbacks to register the read\n   * callback. */\n  le = llist_head(list_init);\n  while (le != NULL) {\n    callback_func_t *cf;\n    plugin_init_cb callback;\n    plugin_ctx_t old_ctx;\n\n    cf = le->value;\n    old_ctx = plugin_set_ctx(cf->cf_ctx);\n    callback = cf->cf_callback;\n    status = (*callback)();\n    plugin_set_ctx(old_ctx);\n\n    if (status != 0) {\n      ERROR(\"Initialization of plugin `%s' \"\n            \"failed with status %i. \"\n            \"Plugin will be unloaded.\",\n            le->key, status);\n      /* Plugins that register read callbacks from the init\n       * callback should take care of appropriate error\n       * handling themselves. */\n      /* FIXME: Unload _all_ functions */\n      plugin_unregister_read(le->key);\n      ret = -1;\n    }\n\n    le = le->next;\n  }\n\n  start_write_threads((size_t)write_threads_num);\n\n  max_read_interval =\n      global_option_get_time(\"MaxReadInterval\", DEFAULT_MAX_READ_INTERVAL);\n\n  /* Start read-threads */\n  if (read_heap != NULL) {\n    const char *rt;\n    int num;\n\n    rt = global_option_get(\"ReadThreads\");\n    num = atoi(rt);\n    if (num != -1)\n      start_read_threads((num > 0) ? ((size_t)num) : 5);\n  }\n  return ret;\n} /* void plugin_init_all */\n\n/* TODO: Rename this function. */\nEXPORT void plugin_read_all(void) {\n  uc_check_timeout();\n\n  return;\n} /* void plugin_read_all */\n\n/* Read function called when the `-T' command line argument is given. */\nEXPORT int plugin_read_all_once(void) {\n  int status;\n  int return_status = 0;\n\n  if (read_heap == NULL) {\n    NOTICE(\"No read-functions are registered.\");\n    return 0;\n  }\n\n  while (42) {\n    read_func_t *rf;\n    plugin_ctx_t old_ctx;\n\n    rf = c_heap_get_root(read_heap);\n    if (rf == NULL)\n      break;\n\n    old_ctx = plugin_set_ctx(rf->rf_ctx);\n\n    if (rf->rf_type == RF_SIMPLE) {\n      int (*callback)(void);\n\n      callback = rf->rf_callback;\n      status = (*callback)();\n    } else {\n      plugin_read_cb callback;\n\n      callback = rf->rf_callback;\n      status = (*callback)(&rf->rf_udata);\n    }\n\n    plugin_set_ctx(old_ctx);\n\n    if (status != 0) {\n      NOTICE(\"read-function of plugin `%s' failed.\", rf->rf_name);\n      return_status = -1;\n    }\n\n    sfree(rf->rf_name);\n    destroy_callback((void *)rf);\n  }\n\n  return return_status;\n} /* int plugin_read_all_once */\n\nEXPORT int plugin_write(const char *plugin, /* {{{ */\n                        const data_set_t *ds, const value_list_t *vl) {\n  llentry_t *le;\n  int status;\n\n  if (vl == NULL)\n    return EINVAL;\n\n  if (list_write == NULL)\n    return ENOENT;\n\n  if (ds == NULL) {\n    ds = plugin_get_ds(vl->type);\n    if (ds == NULL) {\n      ERROR(\"plugin_write: Unable to lookup type `%s'.\", vl->type);\n      return ENOENT;\n    }\n  }\n\n  if (plugin == NULL) {\n    int success = 0;\n    int failure = 0;\n\n    le = llist_head(list_write);\n    while (le != NULL) {\n      callback_func_t *cf = le->value;\n      plugin_write_cb callback;\n\n      /* Keep the read plugin's interval and flush information but update the\n       * plugin name. */\n      plugin_ctx_t old_ctx = plugin_get_ctx();\n      plugin_ctx_t ctx = old_ctx;\n      ctx.name = cf->cf_ctx.name;\n      plugin_set_ctx(ctx);\n\n      DEBUG(\"plugin: plugin_write: Writing values via %s.\", le->key);\n      callback = cf->cf_callback;\n      status = (*callback)(ds, vl, &cf->cf_udata);\n      if (status != 0)\n        failure++;\n      else\n        success++;\n\n      plugin_set_ctx(old_ctx);\n      le = le->next;\n    }\n\n    if ((success == 0) && (failure != 0))\n      status = -1;\n    else\n      status = 0;\n  } else /* plugin != NULL */\n  {\n    callback_func_t *cf;\n    plugin_write_cb callback;\n\n    le = llist_head(list_write);\n    while (le != NULL) {\n      if (strcasecmp(plugin, le->key) == 0)\n        break;\n\n      le = le->next;\n    }\n\n    if (le == NULL)\n      return ENOENT;\n\n    cf = le->value;\n\n    /* do not switch plugin context; rather keep the context (interval)\n     * information of the calling read plugin */\n\n    DEBUG(\"plugin: plugin_write: Writing values via %s.\", le->key);\n    callback = cf->cf_callback;\n    status = (*callback)(ds, vl, &cf->cf_udata);\n  }\n\n  return status;\n} /* }}} int plugin_write */\n\nEXPORT int plugin_flush(const char *plugin, cdtime_t timeout,\n                        const char *identifier) {\n  llentry_t *le;\n\n  if (list_flush == NULL)\n    return 0;\n\n  le = llist_head(list_flush);\n  while (le != NULL) {\n    callback_func_t *cf;\n    plugin_flush_cb callback;\n    plugin_ctx_t old_ctx;\n\n    if ((plugin != NULL) && (strcmp(plugin, le->key) != 0)) {\n      le = le->next;\n      continue;\n    }\n\n    cf = le->value;\n    old_ctx = plugin_set_ctx(cf->cf_ctx);\n    callback = cf->cf_callback;\n\n    (*callback)(timeout, identifier, &cf->cf_udata);\n\n    plugin_set_ctx(old_ctx);\n\n    le = le->next;\n  }\n  return 0;\n} /* int plugin_flush */\n\nEXPORT int plugin_shutdown_all(void) {\n  llentry_t *le;\n  int ret = 0; // Assume success.\n\n  destroy_all_callbacks(&list_init);\n\n  stop_read_threads();\n\n  pthread_mutex_lock(&read_lock);\n  llist_destroy(read_list);\n  read_list = NULL;\n  pthread_mutex_unlock(&read_lock);\n\n  destroy_read_heap();\n\n  /* blocks until all write threads have shut down. */\n  stop_write_threads();\n\n  /* ask all plugins to write out the state they kept. */\n  plugin_flush(/* plugin = */ NULL,\n               /* timeout = */ 0,\n               /* identifier = */ NULL);\n\n  le = NULL;\n  if (list_shutdown != NULL)\n    le = llist_head(list_shutdown);\n\n  while (le != NULL) {\n    callback_func_t *cf;\n    plugin_shutdown_cb callback;\n    plugin_ctx_t old_ctx;\n\n    cf = le->value;\n    old_ctx = plugin_set_ctx(cf->cf_ctx);\n    callback = cf->cf_callback;\n\n    /* Advance the pointer before calling the callback allows\n     * shutdown functions to unregister themselves. If done the\n     * other way around the memory `le' points to will be freed\n     * after callback returns. */\n    le = le->next;\n\n    if ((*callback)() != 0)\n      ret = -1;\n\n    plugin_set_ctx(old_ctx);\n  }\n\n  /* Write plugins which use the `user_data' pointer usually need the\n   * same data available to the flush callback. If this is the case, set\n   * the free_function to NULL when registering the flush callback and to\n   * the real free function when registering the write callback. This way\n   * the data isn't freed twice. */\n  destroy_all_callbacks(&list_flush);\n  destroy_all_callbacks(&list_missing);\n  destroy_cache_event_callbacks();\n  destroy_all_callbacks(&list_write);\n\n  destroy_all_callbacks(&list_notification);\n  destroy_all_callbacks(&list_shutdown);\n  destroy_all_callbacks(&list_log);\n\n  plugin_free_loaded();\n  plugin_free_data_sets();\n  return ret;\n} /* void plugin_shutdown_all */\n\nEXPORT int plugin_dispatch_missing(const value_list_t *vl) /* {{{ */\n{\n  if (list_missing == NULL)\n    return 0;\n\n  llentry_t *le = llist_head(list_missing);\n  while (le != NULL) {\n    callback_func_t *cf = le->value;\n    plugin_ctx_t old_ctx = plugin_set_ctx(cf->cf_ctx);\n    plugin_missing_cb callback = cf->cf_callback;\n\n    int status = (*callback)(vl, &cf->cf_udata);\n    plugin_set_ctx(old_ctx);\n    if (status != 0) {\n      if (status < 0) {\n        ERROR(\"plugin_dispatch_missing: Callback function \\\"%s\\\" \"\n              \"failed with status %i.\",\n              le->key, status);\n        return status;\n      } else {\n        return 0;\n      }\n    }\n\n    le = le->next;\n  }\n  return 0;\n} /* int }}} plugin_dispatch_missing */\n\nvoid plugin_dispatch_cache_event(enum cache_event_type_e event_type,\n                                 unsigned long callbacks_mask, const char *name,\n                                 const value_list_t *vl) {\n  switch (event_type) {\n  case CE_VALUE_NEW:\n    callbacks_mask = 0;\n    for (size_t i = 0; i < list_cache_event_num; i++) {\n      cache_event_func_t *cef = &list_cache_event[i];\n      plugin_cache_event_cb callback = cef->callback;\n\n      if (!callback)\n        continue;\n\n      cache_event_t event = (cache_event_t){.type = event_type,\n                                            .value_list = vl,\n                                            .value_list_name = name,\n                                            .ret = 0};\n\n      plugin_ctx_t old_ctx = plugin_set_ctx(cef->plugin_ctx);\n      int status = (*callback)(&event, &cef->user_data);\n      plugin_set_ctx(old_ctx);\n\n      if (status != 0) {\n        ERROR(\"plugin_dispatch_cache_event: Callback \\\"%s\\\" failed with status \"\n              \"%i for event NEW.\",\n              cef->name, status);\n      } else {\n        if (event.ret) {\n          DEBUG(\n              \"plugin_dispatch_cache_event: Callback \\\"%s\\\" subscribed to %s.\",\n              cef->name, name);\n          callbacks_mask |= (1 << (i));\n        } else {\n          DEBUG(\"plugin_dispatch_cache_event: Callback \\\"%s\\\" ignores %s.\",\n                cef->name, name);\n        }\n      }\n    }\n\n    if (callbacks_mask)\n      uc_set_callbacks_mask(name, callbacks_mask);\n\n    break;\n  case CE_VALUE_UPDATE:\n  case CE_VALUE_EXPIRED:\n    for (size_t i = 0; i < list_cache_event_num; i++) {\n      cache_event_func_t *cef = &list_cache_event[i];\n      plugin_cache_event_cb callback = cef->callback;\n\n      if (!callback)\n        continue;\n\n      if (callbacks_mask && (1 << (i)) == 0)\n        continue;\n\n      cache_event_t event = (cache_event_t){.type = event_type,\n                                            .value_list = vl,\n                                            .value_list_name = name,\n                                            .ret = 0};\n\n      plugin_ctx_t old_ctx = plugin_set_ctx(cef->plugin_ctx);\n      int status = (*callback)(&event, &cef->user_data);\n      plugin_set_ctx(old_ctx);\n\n      if (status != 0) {\n        ERROR(\"plugin_dispatch_cache_event: Callback \\\"%s\\\" failed with status \"\n              \"%i for event %s.\",\n              cef->name, status,\n              ((event_type == CE_VALUE_UPDATE) ? \"UPDATE\" : \"EXPIRED\"));\n      }\n    }\n    break;\n  }\n  return;\n}\n\nstatic int plugin_dispatch_values_internal(value_list_t *vl) {\n  int status;\n  static c_complain_t no_write_complaint = C_COMPLAIN_INIT_STATIC;\n\n  bool free_meta_data = false;\n\n  assert(vl != NULL);\n\n  /* These fields are initialized by plugin_value_list_clone() if needed: */\n  assert(vl->host[0] != 0);\n  assert(vl->time != 0); /* The time is determined at _enqueue_ time. */\n  assert(vl->interval != 0);\n\n  if (vl->type[0] == 0 || vl->values == NULL || vl->values_len < 1) {\n    ERROR(\"plugin_dispatch_values: Invalid value list \"\n          \"from plugin %s.\",\n          vl->plugin);\n    return -1;\n  }\n\n  /* Free meta data only if the calling function didn't specify any. In\n   * this case matches and targets may add some and the calling function\n   * may not expect (and therefore free) that data. */\n  if (vl->meta == NULL)\n    free_meta_data = true;\n\n  if (list_write == NULL)\n    c_complain_once(LOG_WARNING, &no_write_complaint,\n                    \"plugin_dispatch_values: No write callback has been \"\n                    \"registered. Please load at least one output plugin, \"\n                    \"if you want the collected data to be stored.\");\n\n  if (data_sets == NULL) {\n    ERROR(\"plugin_dispatch_values: No data sets registered. \"\n          \"Could the types database be read? Check \"\n          \"your `TypesDB' setting!\");\n    return -1;\n  }\n\n  data_set_t *ds = NULL;\n  if (c_avl_get(data_sets, vl->type, (void *)&ds) != 0) {\n    char ident[6 * DATA_MAX_NAME_LEN];\n\n    FORMAT_VL(ident, sizeof(ident), vl);\n    INFO(\"plugin_dispatch_values: Dataset not found: %s \"\n         \"(from \\\"%s\\\"), check your types.db!\",\n         vl->type, ident);\n    return -1;\n  }\n\n  DEBUG(\"plugin_dispatch_values: time = %.3f; interval = %.3f; \"\n        \"host = %s; \"\n        \"plugin = %s; plugin_instance = %s; \"\n        \"type = %s; type_instance = %s;\",\n        CDTIME_T_TO_DOUBLE(vl->time), CDTIME_T_TO_DOUBLE(vl->interval),\n        vl->host, vl->plugin, vl->plugin_instance, vl->type, vl->type_instance);\n\n#if COLLECT_DEBUG\n  assert(0 == strcmp(ds->type, vl->type));\n#else\n  if (0 != strcmp(ds->type, vl->type))\n    WARNING(\n        \"plugin_dispatch_values: <%s/%s-%s> (ds->type = %s) != (vl->type = %s)\",\n        vl->host, vl->plugin, vl->plugin_instance, ds->type, vl->type);\n#endif\n\n#if COLLECT_DEBUG\n  assert(ds->ds_num == vl->values_len);\n#else\n  if (ds->ds_num != vl->values_len) {\n    ERROR(\"plugin_dispatch_values: <%s/%s-%s/%s-%s> ds->type = %s: \"\n          \"(ds->ds_num = %\" PRIsz \") != \"\n          \"(vl->values_len = %\" PRIsz \")\",\n          vl->host, vl->plugin, vl->plugin_instance, vl->type,\n          vl->type_instance, ds->type, ds->ds_num, vl->values_len);\n    return -1;\n  }\n#endif\n\n  escape_slashes(vl->host, sizeof(vl->host));\n  escape_slashes(vl->plugin, sizeof(vl->plugin));\n  escape_slashes(vl->plugin_instance, sizeof(vl->plugin_instance));\n  escape_slashes(vl->type, sizeof(vl->type));\n  escape_slashes(vl->type_instance, sizeof(vl->type_instance));\n\n  if (pre_cache_chain != NULL) {\n    status = fc_process_chain(ds, vl, pre_cache_chain);\n    if (status < 0) {\n      WARNING(\"plugin_dispatch_values: Running the \"\n              \"pre-cache chain failed with \"\n              \"status %i (%#x).\",\n              status, status);\n    } else if (status == FC_TARGET_STOP)\n      return 0;\n  }\n\n  /* Update the value cache */\n  uc_update(ds, vl);\n\n  if (post_cache_chain != NULL) {\n    status = fc_process_chain(ds, vl, post_cache_chain);\n    if (status < 0) {\n      WARNING(\"plugin_dispatch_values: Running the \"\n              \"post-cache chain failed with \"\n              \"status %i (%#x).\",\n              status, status);\n    }\n  } else\n    fc_default_action(ds, vl);\n\n  if ((free_meta_data == true) && (vl->meta != NULL)) {\n    meta_data_destroy(vl->meta);\n    vl->meta = NULL;\n  }\n\n  return 0;\n} /* int plugin_dispatch_values_internal */\n\nstatic double get_drop_probability(void) /* {{{ */\n{\n  long pos;\n  long size;\n  long wql;\n\n  pthread_mutex_lock(&write_lock);\n  wql = write_queue_length;\n  pthread_mutex_unlock(&write_lock);\n\n  if (wql < write_limit_low)\n    return 0.0;\n  if (wql >= write_limit_high)\n    return 1.0;\n\n  pos = 1 + wql - write_limit_low;\n  size = 1 + write_limit_high - write_limit_low;\n\n  return (double)pos / (double)size;\n} /* }}} double get_drop_probability */\n\nstatic bool check_drop_value(void) /* {{{ */\n{\n  static cdtime_t last_message_time;\n  static pthread_mutex_t last_message_lock = PTHREAD_MUTEX_INITIALIZER;\n\n  double p;\n  double q;\n  int status;\n\n  if (write_limit_high == 0)\n    return false;\n\n  p = get_drop_probability();\n  if (p == 0.0)\n    return false;\n\n  status = pthread_mutex_trylock(&last_message_lock);\n  if (status == 0) {\n    cdtime_t now;\n\n    now = cdtime();\n    if ((now - last_message_time) > TIME_T_TO_CDTIME_T(1)) {\n      last_message_time = now;\n      ERROR(\"plugin_dispatch_values: Low water mark \"\n            \"reached. Dropping %.0f%% of metrics.\",\n            100.0 * p);\n    }\n    pthread_mutex_unlock(&last_message_lock);\n  }\n\n  if (p == 1.0)\n    return true;\n\n  q = cdrand_d();\n  if (q > p)\n    return true;\n  else\n    return false;\n} /* }}} bool check_drop_value */\n\nEXPORT int plugin_dispatch_values(value_list_t const *vl) {\n  int status;\n\n  if (check_drop_value()) {\n    if (record_statistics) {\n      pthread_mutex_lock(&statistics_lock);\n      stats_values_dropped++;\n      pthread_mutex_unlock(&statistics_lock);\n    }\n    return 0;\n  }\n\n  status = plugin_write_enqueue(vl);\n  if (status != 0) {\n    ERROR(\"plugin_dispatch_values: plugin_write_enqueue failed with status %i \"\n          \"(%s).\",\n          status, STRERROR(status));\n    return status;\n  }\n\n  return 0;\n}\n\n__attribute__((sentinel)) int\nplugin_dispatch_multivalue(value_list_t const *template, /* {{{ */\n                           bool store_percentage, int store_type, ...) {\n  value_list_t *vl;\n  int failed = 0;\n  gauge_t sum = 0.0;\n  va_list ap;\n\n  if (check_drop_value()) {\n    if (record_statistics) {\n      pthread_mutex_lock(&statistics_lock);\n      stats_values_dropped++;\n      pthread_mutex_unlock(&statistics_lock);\n    }\n    return 0;\n  }\n\n  assert(template->values_len == 1);\n\n  /* Calculate sum for Gauge to calculate percent if needed */\n  if (DS_TYPE_GAUGE == store_type) {\n    va_start(ap, store_type);\n    while (42) {\n      char const *name;\n      gauge_t value;\n\n      name = va_arg(ap, char const *);\n      if (name == NULL)\n        break;\n\n      value = va_arg(ap, gauge_t);\n      if (!isnan(value))\n        sum += value;\n    }\n    va_end(ap);\n  }\n\n  vl = plugin_value_list_clone(template);\n  /* plugin_value_list_clone makes sure vl->time is set to non-zero. */\n  if (store_percentage)\n    sstrncpy(vl->type, \"percent\", sizeof(vl->type));\n\n  va_start(ap, store_type);\n  while (42) {\n    char const *name;\n    int status;\n\n    /* Set the type instance. */\n    name = va_arg(ap, char const *);\n    if (name == NULL)\n      break;\n    sstrncpy(vl->type_instance, name, sizeof(vl->type_instance));\n\n    /* Set the value. */\n    switch (store_type) {\n    case DS_TYPE_GAUGE:\n      vl->values[0].gauge = va_arg(ap, gauge_t);\n      if (store_percentage)\n        vl->values[0].gauge *= sum ? (100.0 / sum) : NAN;\n      break;\n    case DS_TYPE_ABSOLUTE:\n      vl->values[0].absolute = va_arg(ap, absolute_t);\n      break;\n    case DS_TYPE_COUNTER:\n      vl->values[0].counter = va_arg(ap, counter_t);\n      break;\n    case DS_TYPE_DERIVE:\n      vl->values[0].derive = va_arg(ap, derive_t);\n      break;\n    default:\n      ERROR(\"plugin_dispatch_multivalue: given store_type is incorrect.\");\n      failed++;\n    }\n\n    status = plugin_write_enqueue(vl);\n    if (status != 0)\n      failed++;\n  }\n  va_end(ap);\n\n  plugin_value_list_free(vl);\n  return failed;\n} /* }}} int plugin_dispatch_multivalue */\n\nEXPORT int plugin_dispatch_notification(const notification_t *notif) {\n  llentry_t *le;\n  /* Possible TODO: Add flap detection here */\n\n  DEBUG(\"plugin_dispatch_notification: severity = %i; message = %s; \"\n        \"time = %.3f; host = %s;\",\n        notif->severity, notif->message, CDTIME_T_TO_DOUBLE(notif->time),\n        notif->host);\n\n  /* Nobody cares for notifications */\n  if (list_notification == NULL)\n    return -1;\n\n  le = llist_head(list_notification);\n  while (le != NULL) {\n    callback_func_t *cf;\n    plugin_notification_cb callback;\n    int status;\n\n    /* do not switch plugin context; rather keep the context\n     * (interval) information of the calling plugin */\n\n    cf = le->value;\n    callback = cf->cf_callback;\n    status = (*callback)(notif, &cf->cf_udata);\n    if (status != 0) {\n      WARNING(\"plugin_dispatch_notification: Notification \"\n              \"callback %s returned %i.\",\n              le->key, status);\n    }\n\n    le = le->next;\n  }\n\n  return 0;\n} /* int plugin_dispatch_notification */\n\nEXPORT void plugin_log(int level, const char *format, ...) {\n  char msg[1024];\n  va_list ap;\n  llentry_t *le;\n\n#if !COLLECT_DEBUG\n  if (level >= LOG_DEBUG)\n    return;\n#endif\n\n  va_start(ap, format);\n  vsnprintf(msg, sizeof(msg), format, ap);\n  msg[sizeof(msg) - 1] = '\\0';\n  va_end(ap);\n\n  if (list_log == NULL) {\n    fprintf(stderr, \"%s\\n\", msg);\n    return;\n  }\n\n  le = llist_head(list_log);\n  while (le != NULL) {\n    callback_func_t *cf;\n    plugin_log_cb callback;\n\n    cf = le->value;\n    callback = cf->cf_callback;\n\n    /* do not switch plugin context; rather keep the context\n     * (interval) information of the calling plugin */\n\n    (*callback)(level, msg, &cf->cf_udata);\n\n    le = le->next;\n  }\n} /* void plugin_log */\n\nvoid daemon_log(int level, const char *format, ...) {\n  char msg[1024] = \"\"; // Size inherits from plugin_log()\n\n  char const *name = plugin_get_ctx().name;\n  if (name == NULL)\n    name = \"UNKNOWN\";\n\n  va_list ap;\n  va_start(ap, format);\n  vsnprintf(msg, sizeof(msg), format, ap);\n  va_end(ap);\n\n  plugin_log(level, \"%s plugin: %s\", name, msg);\n} /* void daemon_log */\n\nint parse_log_severity(const char *severity) {\n  int log_level = -1;\n\n  if ((0 == strcasecmp(severity, \"emerg\")) ||\n      (0 == strcasecmp(severity, \"alert\")) ||\n      (0 == strcasecmp(severity, \"crit\")) || (0 == strcasecmp(severity, \"err\")))\n    log_level = LOG_ERR;\n  else if (0 == strcasecmp(severity, \"warning\"))\n    log_level = LOG_WARNING;\n  else if (0 == strcasecmp(severity, \"notice\"))\n    log_level = LOG_NOTICE;\n  else if (0 == strcasecmp(severity, \"info\"))\n    log_level = LOG_INFO;\n#if COLLECT_DEBUG\n  else if (0 == strcasecmp(severity, \"debug\"))\n    log_level = LOG_DEBUG;\n#endif /* COLLECT_DEBUG */\n\n  return log_level;\n} /* int parse_log_severity */\n\nEXPORT int parse_notif_severity(const char *severity) {\n  int notif_severity = -1;\n\n  if (strcasecmp(severity, \"FAILURE\") == 0)\n    notif_severity = NOTIF_FAILURE;\n  else if (strcmp(severity, \"OKAY\") == 0)\n    notif_severity = NOTIF_OKAY;\n  else if ((strcmp(severity, \"WARNING\") == 0) ||\n           (strcmp(severity, \"WARN\") == 0))\n    notif_severity = NOTIF_WARNING;\n\n  return notif_severity;\n} /* int parse_notif_severity */\n\nEXPORT const data_set_t *plugin_get_ds(const char *name) {\n  data_set_t *ds;\n\n  if (data_sets == NULL) {\n    P_ERROR(\"plugin_get_ds: No data sets are defined yet.\");\n    return NULL;\n  }\n\n  if (c_avl_get(data_sets, name, (void *)&ds) != 0) {\n    DEBUG(\"No such dataset registered: %s\", name);\n    return NULL;\n  }\n\n  return ds;\n} /* data_set_t *plugin_get_ds */\n\nstatic int plugin_notification_meta_add(notification_t *n, const char *name,\n                                        enum notification_meta_type_e type,\n                                        const void *value) {\n  notification_meta_t *meta;\n  notification_meta_t *tail;\n\n  if ((n == NULL) || (name == NULL) || (value == NULL)) {\n    ERROR(\"plugin_notification_meta_add: A pointer is NULL!\");\n    return -1;\n  }\n\n  meta = calloc(1, sizeof(*meta));\n  if (meta == NULL) {\n    ERROR(\"plugin_notification_meta_add: calloc failed.\");\n    return -1;\n  }\n\n  sstrncpy(meta->name, name, sizeof(meta->name));\n  meta->type = type;\n\n  switch (type) {\n  case NM_TYPE_STRING: {\n    meta->nm_value.nm_string = strdup((const char *)value);\n    if (meta->nm_value.nm_string == NULL) {\n      ERROR(\"plugin_notification_meta_add: strdup failed.\");\n      sfree(meta);\n      return -1;\n    }\n    break;\n  }\n  case NM_TYPE_SIGNED_INT: {\n    meta->nm_value.nm_signed_int = *((int64_t *)value);\n    break;\n  }\n  case NM_TYPE_UNSIGNED_INT: {\n    meta->nm_value.nm_unsigned_int = *((uint64_t *)value);\n    break;\n  }\n  case NM_TYPE_DOUBLE: {\n    meta->nm_value.nm_double = *((double *)value);\n    break;\n  }\n  case NM_TYPE_BOOLEAN: {\n    meta->nm_value.nm_boolean = *((bool *)value);\n    break;\n  }\n  default: {\n    ERROR(\"plugin_notification_meta_add: Unknown type: %i\", type);\n    sfree(meta);\n    return -1;\n  }\n  } /* switch (type) */\n\n  meta->next = NULL;\n  tail = n->meta;\n  while ((tail != NULL) && (tail->next != NULL))\n    tail = tail->next;\n\n  if (tail == NULL)\n    n->meta = meta;\n  else\n    tail->next = meta;\n\n  return 0;\n} /* int plugin_notification_meta_add */\n\nint plugin_notification_meta_add_string(notification_t *n, const char *name,\n                                        const char *value) {\n  return plugin_notification_meta_add(n, name, NM_TYPE_STRING, value);\n}\n\nint plugin_notification_meta_add_signed_int(notification_t *n, const char *name,\n                                            int64_t value) {\n  return plugin_notification_meta_add(n, name, NM_TYPE_SIGNED_INT, &value);\n}\n\nint plugin_notification_meta_add_unsigned_int(notification_t *n,\n                                              const char *name,\n                                              uint64_t value) {\n  return plugin_notification_meta_add(n, name, NM_TYPE_UNSIGNED_INT, &value);\n}\n\nint plugin_notification_meta_add_double(notification_t *n, const char *name,\n                                        double value) {\n  return plugin_notification_meta_add(n, name, NM_TYPE_DOUBLE, &value);\n}\n\nint plugin_notification_meta_add_boolean(notification_t *n, const char *name,\n                                         bool value) {\n  return plugin_notification_meta_add(n, name, NM_TYPE_BOOLEAN, &value);\n}\n\nint plugin_notification_meta_copy(notification_t *dst,\n                                  const notification_t *src) {\n  assert(dst != NULL);\n  assert(src != NULL);\n  assert(dst != src);\n  assert((src->meta == NULL) || (src->meta != dst->meta));\n\n  for (notification_meta_t *meta = src->meta; meta != NULL; meta = meta->next) {\n    if (meta->type == NM_TYPE_STRING)\n      plugin_notification_meta_add_string(dst, meta->name,\n                                          meta->nm_value.nm_string);\n    else if (meta->type == NM_TYPE_SIGNED_INT)\n      plugin_notification_meta_add_signed_int(dst, meta->name,\n                                              meta->nm_value.nm_signed_int);\n    else if (meta->type == NM_TYPE_UNSIGNED_INT)\n      plugin_notification_meta_add_unsigned_int(dst, meta->name,\n                                                meta->nm_value.nm_unsigned_int);\n    else if (meta->type == NM_TYPE_DOUBLE)\n      plugin_notification_meta_add_double(dst, meta->name,\n                                          meta->nm_value.nm_double);\n    else if (meta->type == NM_TYPE_BOOLEAN)\n      plugin_notification_meta_add_boolean(dst, meta->name,\n                                           meta->nm_value.nm_boolean);\n  }\n\n  return 0;\n} /* int plugin_notification_meta_copy */\n\nint plugin_notification_meta_free(notification_meta_t *n) {\n  notification_meta_t *this;\n  notification_meta_t *next;\n\n  if (n == NULL) {\n    ERROR(\"plugin_notification_meta_free: n == NULL!\");\n    return -1;\n  }\n\n  this = n;\n  while (this != NULL) {\n    next = this->next;\n\n    if (this->type == NM_TYPE_STRING) {\n      /* Assign to a temporary variable to work around nm_string's const\n       * modifier. */\n      void *tmp = (void *)this->nm_value.nm_string;\n\n      sfree(tmp);\n      this->nm_value.nm_string = NULL;\n    }\n    sfree(this);\n\n    this = next;\n  }\n\n  return 0;\n} /* int plugin_notification_meta_free */\n\nstatic void plugin_ctx_destructor(void *ctx) {\n  sfree(ctx);\n} /* void plugin_ctx_destructor */\n\nstatic plugin_ctx_t ctx_init = {/* interval = */ 0};\n\nstatic plugin_ctx_t *plugin_ctx_create(void) {\n  plugin_ctx_t *ctx;\n\n  ctx = malloc(sizeof(*ctx));\n  if (ctx == NULL) {\n    ERROR(\"Failed to allocate plugin context: %s\", STRERRNO);\n    return NULL;\n  }\n\n  *ctx = ctx_init;\n  assert(plugin_ctx_key_initialized);\n  pthread_setspecific(plugin_ctx_key, ctx);\n  DEBUG(\"Created new plugin context.\");\n  return ctx;\n} /* int plugin_ctx_create */\n\nEXPORT void plugin_init_ctx(void) {\n  pthread_key_create(&plugin_ctx_key, plugin_ctx_destructor);\n  plugin_ctx_key_initialized = true;\n} /* void plugin_init_ctx */\n\nEXPORT plugin_ctx_t plugin_get_ctx(void) {\n  plugin_ctx_t *ctx;\n\n  assert(plugin_ctx_key_initialized);\n  ctx = pthread_getspecific(plugin_ctx_key);\n\n  if (ctx == NULL) {\n    ctx = plugin_ctx_create();\n    /* this must no happen -- exit() instead? */\n    if (ctx == NULL)\n      return ctx_init;\n  }\n\n  return *ctx;\n} /* plugin_ctx_t plugin_get_ctx */\n\nEXPORT plugin_ctx_t plugin_set_ctx(plugin_ctx_t ctx) {\n  plugin_ctx_t *c;\n  plugin_ctx_t old;\n\n  assert(plugin_ctx_key_initialized);\n  c = pthread_getspecific(plugin_ctx_key);\n\n  if (c == NULL) {\n    c = plugin_ctx_create();\n    /* this must no happen -- exit() instead? */\n    if (c == NULL)\n      return ctx_init;\n  }\n\n  old = *c;\n  *c = ctx;\n\n  return old;\n} /* void plugin_set_ctx */\n\nEXPORT cdtime_t plugin_get_interval(void) {\n  cdtime_t interval;\n\n  interval = plugin_get_ctx().interval;\n  if (interval > 0)\n    return interval;\n\n  P_ERROR(\"plugin_get_interval: Unable to determine Interval from context.\");\n\n  return cf_get_default_interval();\n} /* cdtime_t plugin_get_interval */\n\ntypedef struct {\n  plugin_ctx_t ctx;\n  void *(*start_routine)(void *);\n  void *arg;\n} plugin_thread_t;\n\nstatic void *plugin_thread_start(void *arg) {\n  plugin_thread_t *plugin_thread = arg;\n\n  void *(*start_routine)(void *) = plugin_thread->start_routine;\n  void *plugin_arg = plugin_thread->arg;\n\n  plugin_set_ctx(plugin_thread->ctx);\n\n  sfree(plugin_thread);\n\n  return start_routine(plugin_arg);\n} /* void *plugin_thread_start */\n\nint plugin_thread_create(pthread_t *thread, void *(*start_routine)(void *),\n                         void *arg, char const *name) {\n  plugin_thread_t *plugin_thread;\n\n  plugin_thread = malloc(sizeof(*plugin_thread));\n  if (plugin_thread == NULL)\n    return ENOMEM;\n\n  plugin_thread->ctx = plugin_get_ctx();\n  plugin_thread->start_routine = start_routine;\n  plugin_thread->arg = arg;\n\n  int ret = pthread_create(thread, NULL, plugin_thread_start, plugin_thread);\n  if (ret != 0) {\n    sfree(plugin_thread);\n    return ret;\n  }\n\n  if (name != NULL)\n    set_thread_name(*thread, name);\n\n  return 0;\n} /* int plugin_thread_create */\n",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.11.0-nc7v4k27cecpwvdntndazsxgqkvvi3ck/spack-src/contrib/docker/rootfs_prefix/rootfs_prefix.c": "/**\n * collectd - contrib/docker/rootfs_prefix/rootfs_prefix.c\n * Copyright (C) 2016-2018  Marc Fournier\n * Copyright (C) 2016-2018  Ruben Kerkhof\n *\n * MIT License:\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n *   Marc Fournier <marc.fournier at camptocamp.com>\n *   Ruben Kerkhof <ruben at rubenkerkhof.com>\n **/\n\n#define _GNU_SOURCE\n\n#include <dirent.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <error.h>\n#include <stdio.h>\n#include <string.h>\n\n#define PREFIX \"/rootfs\"\n#define BUFSIZE 256\n\nconst char *add_prefix(const char *orig, char *prefixed) {\n  if ((strncmp(orig, \"/proc\", strlen(\"/proc\")) != 0) &&\n      (strncmp(orig, \"/sys\", strlen(\"/sys\")) != 0))\n    return orig;\n\n  int status = snprintf(prefixed, BUFSIZE, \"%s%s\", PREFIX, orig);\n  if (status < 1) {\n    error(status, errno, \"adding '%s' prefix to file path failed: '%s' -> '%s'\",\n          PREFIX, orig, prefixed);\n    return orig;\n  } else if ((unsigned int)status >= BUFSIZE) {\n    error(status, ENAMETOOLONG,\n          \"'%s' got truncated when adding '%s' prefix: '%s'\", orig, PREFIX,\n          prefixed);\n    return orig;\n  } else {\n    return (const char *)prefixed;\n  }\n}\n\nFILE *fopen(const char *path, const char *mode) {\n  char filename[BUFSIZE] = \"\\0\";\n\n  FILE *(*original_fopen)(const char *, const char *);\n  original_fopen = dlsym(RTLD_NEXT, \"fopen\");\n\n  return (*original_fopen)(add_prefix(path, filename), mode);\n}\n\nDIR *opendir(const char *name) {\n  char filename[BUFSIZE] = \"\\0\";\n\n  DIR *(*original_opendir)(const char *);\n  original_opendir = dlsym(RTLD_NEXT, \"opendir\");\n\n  return (*original_opendir)(add_prefix(name, filename));\n}\n\nint *open(const char *pathname, int flags) {\n  char filename[BUFSIZE] = \"\\0\";\n\n  int *(*original_open)(const char *, int);\n  original_open = dlsym(RTLD_NEXT, \"open\");\n\n  return (*original_open)(add_prefix(pathname, filename), flags);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.11.0-nc7v4k27cecpwvdntndazsxgqkvvi3ck/spack-src/src/collectdctl.pod",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.11.0-nc7v4k27cecpwvdntndazsxgqkvvi3ck/spack-src/src/collectdctl.c",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.11.0-nc7v4k27cecpwvdntndazsxgqkvvi3ck/spack-src/src/hddtemp.c",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.11.0-nc7v4k27cecpwvdntndazsxgqkvvi3ck/spack-src/contrib/collectd2html.pl",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.11.0-nc7v4k27cecpwvdntndazsxgqkvvi3ck/spack-src/contrib/collection3/share/shortcut-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-collectd-5.11.0-nc7v4k27cecpwvdntndazsxgqkvvi3ck/spack-src/docs/review_comments_example.png"
    ],
    "total_files": 506
}