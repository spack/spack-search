{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/AttachDetach/reattach_probed_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  Test detaching - reattach Pin on Linux\n *  The application creates threads in a loop. Each thread does some work and exits.\n *  The process in endless, expected to be stopped by tool.\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <math.h>\n#include \"../Utils/threadlib.h\"\n\n#define NTHREADS 20\n\n#ifdef TARGET_LINUX\n\n#define DLL_SUFFIX \".so\"\n\n#elif defined(TARGET_MAC)\n\n#define DLL_SUFFIX \".dylib\"\n\n#endif\n\n# define TLS_GET_GS_REG() \\\n  ({ int __seg; __asm (\"movw %%gs, %w0\" : \"=q\" (__seg)); __seg & 0xffff; })\n\n\nvolatile bool loop1, loop2 ;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        //sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\ntypedef  double (*DLL_FUNC)(double x);\ntypedef  int (*DLL_INT_FUNC)(int x);\n\n\nvoid * thread_dlopen_func (void *arg)\n{    \n    double number = 0.2;\n    double calculatedValue = 0;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libmy_dll\" DLL_SUFFIX, RTLD_LAZY);\n        if (handle)\n        {\n            DLL_FUNC fptr = (DLL_FUNC)dlsym(handle, \"my_dll_sin\");\n            calculatedValue += (*fptr)(number);\n            \n            //sleep(1);\n            dlclose(handle);\n        }\n        else \n        {\n            fprintf(stderr, \"error opening my_dll\" DLL_SUFFIX \", thread %ld\\n\", GetTid());\n            exit(-1);\n        } \n        number += 0.01;\n    }\n        \n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    unsigned long gs_val = TLS_GET_GS_REG();\n    while (1)\n    {\n        loop1 = true;\n        loop2 = true;\n        pthread_t h[NTHREADS];\n        \n        pthread_create (&h[0], 0, thread_dlopen_func, 0);\n        for (unsigned long i = 1; i < NTHREADS; i++)\n        {\n            pthread_create (&h[i], 0, thread_func, 0);\n        }\n        sleep(1);\n\n        loop1 = false;\n        loop2 = false;\n\n        for (unsigned long i = 0; i < NTHREADS; i++)\n        {\n            pthread_join (h[i], 0);\n        }\n    }    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/AttachDetach/detach_probed_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  Test detaching Pin from running process on a Unix compatible system\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n\n#define NTHREADS 20\n\n#ifdef TARGET_MAC\n# define DLL_SUFFIX \".dylib\"\n#else\n# define DLL_SUFFIX \".so\"\n#endif\n\nextern \"C\" void TellPinToDetach(unsigned long *updateWhenReady)\n{\n    return;\n}\n\nvolatile bool loop2 = true;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\nvolatile bool loop1 = true;\ntypedef  double (*SIN_FUNC)(double x);\n\nvoid * thread_dlopen_func (void *arg)\n{    \n\tdouble number = 0.2;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libm\" DLL_SUFFIX, RTLD_LAZY);\n        if (handle)\n        {\n            SIN_FUNC sin_fptr = (SIN_FUNC)dlsym(handle, \"sin\");\n            if (sin_fptr)\n            {\n                double val = (*sin_fptr)(number);\n                printf(\"val = %.4f\\n\", val);\n            }\n            sleep(2);\n            dlclose(handle);\n        }\n\t\tnumber += 0.01;\n    }\n        \n    return 0;\n\n}\n\nint main (int argc, char *argv[])\n{\n    pthread_t h[NTHREADS];\n    \n    pthread_create (&h[0], 0, thread_dlopen_func, 0);\n    for (unsigned long i = 1; i < NTHREADS; i++)\n    {\n        pthread_create (&h[i], 0, thread_func, 0);\n    }\n    \n\tunsigned long pinDetached = false;\n    TellPinToDetach(&pinDetached);\n    \n\twhile (!pinDetached)\n\t{\n    \tsleep(2);\n\t}\n    \n    loop1 = false;\n    loop2 = false;\n    \n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        pthread_join (h[i], 0);\n    }\n    printf(\"All threads exited. The test PASSED\\n\");    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/AttachDetach/reattach_jit_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  Test detaching - reattach Pin on Linux\n *  The application creates threads in a loop. Each thread does some work and exits.\n *  The process in signaled by the pintool (by replacing AppShouldExit()) that it should exit.\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <math.h>\n#include \"../Utils/threadlib.h\"\n\n#define NTHREADS 20\n\nvolatile bool loop1, loop2 ;\nvoid * thread_func (void *arg)\n{\n    do\n    {\n        void *space = malloc(300);\n        //sleep(1);\n        free(space);\n    }\n    while (loop2);\n\n    return 0;\n}\n\nextern \"C\" int AppShouldExit()\n{\n    return 0;\n}\n\ntypedef  double (*DLL_FUNC)(double x);\ntypedef  int (*DLL_INT_FUNC)(int x);\n\n\nvoid * thread_dlopen_func (void *arg)\n{\n    double number = 0.2;\n    double calculatedValue = 0;\n    do\n    {\n        void *handle = dlopen(\"libmy_dll.so\", RTLD_LAZY);\n        if (handle)\n        {\n            DLL_FUNC fptr = (DLL_FUNC)dlsym(handle, \"my_dll_sin\");\n            calculatedValue += (*fptr)(number);\n\n            //sleep(1);\n            dlclose(handle);\n        }\n        else\n        {\n            fprintf(stderr, \"error opening my_dll.so, thread %d\\n\", GetTid());\n            exit(-1);\n        }\n        number += 0.01;\n    }\n    while (loop1);\n\n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    const unsigned int numOfSeconds = 5 * 60; // allow 5 minutes\n    unsigned int secondsRemaining = numOfSeconds;\n    for (; secondsRemaining && (!AppShouldExit()) ; --secondsRemaining)\n    {\n        loop1 = true;\n        loop2 = true;\n        pthread_t h[NTHREADS];\n\n        pthread_create (&h[0], 0, thread_dlopen_func, 0);\n        for (unsigned long i = 1; i < NTHREADS; i++)\n        {\n            pthread_create (&h[i], 0, thread_func, 0);\n        }\n        sleep(1);\n\n        loop1 = false;\n        loop2 = false;\n\n        for (unsigned long i = 0; i < NTHREADS; i++)\n        {\n            pthread_join (h[i], 0);\n        }\n    }\n    if (secondsRemaining == 0)\n    {\n        fprintf(stderr, \"ERROR: The application ran for %u seconds without completion\\n\", numOfSeconds);\n        return 1;\n    }\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/MemTranslate/malloc_translation_app.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#include <link.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// The highest bit value in a pointer\n#define HIGHEST_BIT ((uintptr_t)1 << (8 * sizeof(void*) - 1))\n// Turn on the highest bit in a pointer\n#define MK_PTR(ptr) ((void*)(((uintptr_t)ptr) | HIGHEST_BIT))\n// Turn off the highest bit in a pointer\n#define STRIP_PTR(ptr) ((void*)((uintptr_t)ptr & ~HIGHEST_BIT))\n\n// Initial allocator buffer (see below for explnaition).\nstatic char initial_buf[1024*1024];\nstatic size_t initial_buf_idx = 0;\n\nstatic void* (*libc_malloc)(size_t) = NULL;\nstatic void* (*libc_calloc)(size_t, size_t) = NULL;\nstatic void* (*libc_realloc)(void *ptr, size_t) = NULL;\nstatic void (*libc_free)(void*) = NULL;\n\n/*\n * Initialize all malloc related symbols from libc\n */\nvoid __attribute__((constructor)) init()\n{\n    libc_malloc = dlsym(RTLD_NEXT, \"malloc\");\n    libc_calloc = dlsym(RTLD_NEXT, \"calloc\");\n    libc_realloc = dlsym(RTLD_NEXT, \"realloc\");\n    libc_free = dlsym(RTLD_NEXT, \"free\");\n}\n\n/*********************************************************\n * Below we implement an initial allocator.\n * The first allocated bytes cannot be allocate with libc's\n * memory allocation function.\n * This is merely because calling dlsym() in the loader, to\n * get the address of libc's memory allocation function,\n * causes the loader to call calloc() (the overriden version\n * of calloc()) and if we call dlsym() in calloc() it will\n * eventually cause an infinite recursion.\n * To overcome this, we implement a simple allocator here\n * that allocates the first bytes of the program from\n * the static buffer initial_buf[].\n *********************************************************/\nvoid *initial_malloc(size_t size)\n{\n    void* ret;\n    if (sizeof(initial_buf) < initial_buf_idx + size + sizeof(size_t))\n    {\n        return NULL;\n    }\n    *((size_t*)&initial_buf[initial_buf_idx]) = size;\n    ret = (void*)&initial_buf[initial_buf_idx + sizeof(size_t)];\n    initial_buf_idx += ((size + 2 * sizeof(size_t) - 1) / sizeof(size_t)) * sizeof(size_t);\n    return ret;\n}\n\nsize_t initial_free(void* ptr)\n{\n    if ((ptr >= (void*)initial_buf) && (ptr < (void*)&initial_buf[initial_buf_idx]))\n    {\n        return *((size_t*)ptr - 1);\n    }\n    return 0;\n}\n\n/*********************************************************\n * Wrapper functions for libc memory allocation functions.\n * Here we translate the memory addresses in and out of\n * memory allocation function so the highest bit in the\n * memory address will be turn on.\n *********************************************************/\nvoid *malloc(size_t size)\n{\n    void* ret;\n    if (NULL != (ret = initial_malloc(size)))\n    {\n        return MK_PTR(ret);\n    }\n    return MK_PTR(libc_malloc(size));\n}\n\nvoid *calloc(size_t nmemb, size_t size)\n{\n    void* ret;\n    if (NULL != (ret = initial_malloc(nmemb*size)))\n    {\n        return MK_PTR(ret);\n    }\n    return MK_PTR(libc_calloc(nmemb, size));\n}\n\nvoid *realloc(void *ptr, size_t size)\n{\n    size_t old_size;\n    if (0 != (old_size = initial_free(STRIP_PTR(ptr))))\n    {\n        void* new_ptr = malloc(size);\n        memcpy(STRIP_PTR(new_ptr), STRIP_PTR(ptr), size<old_size?size:old_size);\n        return new_ptr;\n    }\n    return MK_PTR(libc_realloc(STRIP_PTR(ptr), size));\n}\n\nvoid free(void *ptr)\n{\n    if (0 < initial_free(STRIP_PTR(ptr)))\n    {\n        return;\n    }\n    return libc_free(STRIP_PTR(ptr));\n}\n\n/*\n * This simple program just loads the library which its filename was\n * provided ain the command line arguments\n */\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        fprintf(stderr, \"Usage: %s <path to dynamic library>\\n\", argv[0]);\n        exit(1);\n    }\n    const char* file = argv[1];\n    printf(\"Loading shared object %s\\n\", file);\n    fflush(stdout);\n    void *handle = dlopen(file, RTLD_NOW | RTLD_LOCAL);\n    if (NULL == handle)\n    {\n        fprintf(stderr,\"Failed to load %s - %s\\n\", file, dlerror());\n        exit(1);\n    }\n    printf(\"Unloading shared object %s\\n\", file);\n    fflush(stdout);\n    dlclose(handle);\n\n    printf(\"Application finished successfully!\\n\");\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/ToolUnitTests/dltest.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n    \n    Load(ONE, 1);\n    Load(TWO, 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/ToolUnitTests/dltest2.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char *name, int expect)\n{\n    int val;\n    double dval;\n    \n    void *handle;\n    int (*sym)();\n    double (*fsin)(double);\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n        \n    val = sym();\n    if (val != expect)\n        exit(1);\n\n    dlclose(handle);\n}\n\nint main()\n{\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n        switch(1 + rand() % 2) {\n        case 1:\n            Load(ONE, 1);\n            break;\n        case 2:\n            Load(TWO, 2);\n            break;\n        }\n    }\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/ToolUnitTests/main_dll.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n *  pin tool combined from multi-DLLs (main_dll, dynamic_secondary_dll, static_secondary_dll). \n *  This is the \"main DLL\", use PIN API only in this DLL\n *  usage of PIN API in dynamic_secondary_dll and static_secondary_dll is not allowed\n *  (see README for more inforamtion)\n *\n *  NOTE: New Pin image loader supports dynamic loading of Pin DLLs.\n *        Look at Mantis 3280 for implementation details.\n *        The test also validates the dynamic loading feature.\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"pin.H\"\n\nusing std::cerr;\nusing std::endl;\nusing std::hex;\nusing std::string;\n\nKNOB<BOOL> KnobEnumerate(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"enumerate\", \"0\", \"Enumerate modules loaded by Pin\");\n\nKNOB<string> KnobOutputFile1(KNOB_MODE_WRITEONCE, \"pintool\", \n    \"o1\", \"static_secondary_dll.out\", \"Output file 1\");\n\nKNOB<string> KnobOutputFile2(KNOB_MODE_WRITEONCE, \"pintool\", \n    \"o2\", \"dynamic_secondary_dll.out\", \"Output file 2\");\n\n/* ===================================================================== */\n/* Global Variables and Declerations */\n/* ===================================================================== */\n\nPIN_LOCK pinLock;\n\ntypedef VOID (* BEFORE_BBL)(ADDRINT ip);\ntypedef int (* INIT_F)(bool enumerate, const char* out_filename);\ntypedef VOID (* FINI_F)();\n\n// Functions pointers for dynamic_secondary_dll\nBEFORE_BBL pBeforeBBL2;\nINIT_F pInit2;\nFINI_F pFini2;\n\n// Dll imports for static_secondary_dll\nextern \"C\" __declspec( dllimport ) VOID BeforeBBL1(ADDRINT ip);\nextern \"C\" __declspec( dllimport ) VOID Init1(const char*);\nextern \"C\" __declspec( dllimport ) VOID Fini1();\n\n/* ===================================================================== */\n\n// This function is called before every basic block\nVOID PIN_FAST_ANALYSIS_CALL BeforeBBL(ADDRINT ip) \n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(ip);\n    pBeforeBBL2(ip);\n    PIN_ReleaseLock(&pinLock);\n}\n\n/* ===================================================================== */\n\n// Pin calls this function every time a new trace is encountered\nVOID Trace(TRACE trace, VOID *v)\n{\n    // Visit every basic block  in the trace\n    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))\n    {\n        // Insert a call to BeforeBBL before every bbl, passing the ip address.\n        BBL_InsertCall(bbl, IPOINT_BEFORE, (AFUNPTR)BeforeBBL, IARG_FAST_ANALYSIS_CALL, \n                       IARG_INST_PTR, IARG_END);\n    }\n}\n\nVOID ThreadStart(THREADID threadid, CONTEXT *ctxt, INT32 flags, VOID *v)\n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(0);\n    pBeforeBBL2(0);\n    PIN_ReleaseLock(&pinLock);\n}\n\nVOID ThreadFini(THREADID threadid, const CONTEXT *ctxt, INT32 code, VOID *v)\n{\n    PIN_GetLock(&pinLock, PIN_GetTid());\n    BeforeBBL1(0);\n    pBeforeBBL2(0);\n    PIN_ReleaseLock(&pinLock);\n}\n\n/* ===================================================================== */\n\n// This function is called when the application exits\nVOID Fini(INT32 code, VOID *v)\n{\n    Fini1();\n    pFini2();\n}\n\n// This function gets info of an image loaded by Pin loader.\n// Invoked by dl_iterate_phdr()\nint dl_iterate_callback(struct dl_phdr_info * info, size_t size, VOID * data)\n{\n    cerr << info->dlpi_name << \" \" << hex << info->dlpi_addr << \" \" << info->dlpi_phdr->p_memsz << endl;\n    // Increment module counter.\n    ++(*reinterpret_cast<int *>(data));\n    return 0;\n}\n\n/* ===================================================================== */\n\nint main(int argc, char * argv[])\n{\n    // Initialize pin\n    PIN_Init(argc, argv);\n\n    PIN_InitLock(&pinLock);\n\n    // Register Trace() to be called to instrument traces\n    TRACE_AddInstrumentFunction(Trace, 0);\n\n    // Register Fini() to be called when the application exits\n    PIN_AddFiniFunction(Fini, 0);\n\n    // Call Static secondary dll Init1()\n    Init1(KnobOutputFile1.Value().c_str());\n\n    int nModules;\n\n    // Dynamic secondary dll - load library, initialize function pointers\n    // and call Init2()\n    VOID * module = dlopen(\"dynamic_secondary_dll.dll\", RTLD_NOW);\n    if (module == NULL)\n    {\n        cerr << \"Failed to load dynamic_secondary_dll.dll\" << endl;\n        exit(1);\n    }\n    pInit2 = reinterpret_cast<INIT_F>(dlsym(module, \"Init2\"));\n    pBeforeBBL2 = reinterpret_cast<BEFORE_BBL>(dlsym(module, \"BeforeBBL2\"));\n    pFini2 = reinterpret_cast<FINI_F>(dlsym(module, \"Fini2\"));\n    if (pInit2 == NULL || pBeforeBBL2 == NULL || pFini2 == NULL)\n    {\n        cerr << \"Failed to find proc addresses in dynamic_secondary_dll.dll\" << endl;\n        exit(1);\n    }\n\n    nModules = pInit2(KnobEnumerate, KnobOutputFile2.Value().c_str());\n\n    int nModulesMain = 0;\n    // Enumerate DLLs currently loaded by Pin loader.\n    dl_iterate_phdr(dl_iterate_callback, &nModulesMain);\n\n    if (KnobEnumerate && ((nModulesMain <= 0) || (nModulesMain != nModules)))\n    {\n        // Failure. Module enumeration results in main and dynamic Dlls don't match.\n        PIN_ExitApplication(1);\n    }\n\n    // Start the program, never returns\n    PIN_StartProgram();\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/dltest_unix.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"tool_macros.h\"\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n\n    Load(SHARED_LIB(\"libone\"), 1);\n    Load(SHARED_LIB(\"libtwo\"), 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/malloctrace2.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*! @file\n The test shows how wrappers may be implemented in DLL loaded in runtime.\n The dopen() is being called from application space. But it can't be called\n before libc is initialized.\n In this example I call dlopen before main().\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"tool_macros.h\"\nusing std::cerr;\nusing std::endl;\nusing std::cout;\n\n#ifdef TARGET_MAC\n# define MALLOC_LIB \"libsystem_malloc.dylib\"\n#else\n# define MALLOC_LIB \"libc.so\"\n#endif\n\n\n\n/* ===================================================================== */\n\nINT32 Usage()\n{\n    cerr <<\n        \"This pin tool inserts a user-written version of malloc() and free() into the application.\\n\"\n        \"\\n\";\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return -1;\n}\n\n\n/* ===================================================================== */\n/* Definitions for Probe mode */\n/* ===================================================================== */\n\ntypedef typeof(malloc) * MallocType;\ntypedef typeof(free) * FreeType;\ntypedef typeof(dlopen) * DlopenType;\ntypedef typeof(dlsym) * DlsymType;\n\nMallocType MallocWrapper = 0;\nMallocType origMalloc = 0;\n\nFreeType FreeWrapper = 0;\nFreeType origFree = 0;\n\nvoid * MallocTraceHandle = 0;\n\nDlopenType AppDlopen = 0;\nDlsymType AppDlsym = 0;\n\ntypedef VOID (*SET_ORIG_FPTR)(MallocType mallocPtr, FreeType freePtr);\n\n/* ===================================================================== */\n/* Probe mode tool */\n/* ===================================================================== */\n\nVOID *MallocWrapperInTool(size_t size)\n{\n    if (MallocWrapper)\n    {\n        return (*MallocWrapper)(size);\n    }\n    else\n    {\n        ASSERTX(origMalloc != 0);\n        return (*origMalloc)(size);\n    }\n}\n\nVOID FreeWrapperInTool(void *p)\n{\n    if (FreeWrapper)\n    {\n        (*FreeWrapper)(p);\n    }\n    else\n    {\n        ASSERTX(origFree != 0);\n        (*origFree)(p);\n    }\n}\n\n/* I'm calling dlopen before main.\n * Some malloc-free may be lost, of course.\n * But the earliest point you can call dlopen is after init of libc\n */\nVOID MainRtnCallback()\n{\n    cout << \"In main callback\" << endl;\n    // inject libmallocwrappers.so into application by executing application dlopen\n\n    MallocTraceHandle = AppDlopen(SHARED_LIB(\"libmallocwrappers\"), RTLD_LAZY);\n    ASSERTX(MallocTraceHandle);\n\n    // Get function pointers for the wrappers\n    MallocWrapper = MallocType(AppDlsym(MallocTraceHandle, \"mallocWrapper\"));\n    FreeWrapper = FreeType(AppDlsym(MallocTraceHandle, \"freeWrapper\"));\n    ASSERTX(MallocWrapper && FreeWrapper);\n\n    // Send original function pointers to libmallocwrappers.so\n    SET_ORIG_FPTR setOriginalFptr = (SET_ORIG_FPTR) AppDlsym(MallocTraceHandle, \"SetOriginalFptr\");\n    ASSERTX(setOriginalFptr != 0);\n    (*setOriginalFptr)(origMalloc, origFree);\n}\n\nVOID ImageLoad(IMG img, VOID *v)\n{\n    if (strstr(IMG_Name(img).c_str(), \"libdl.so\"))\n    {\n        // Get the function pointer for the application dlopen:\n        // dlopen@@GLIBC_2.1 is the official, versioned name.\n        //\n        // The exact suffix must match the ABI of the libdl header files\n        // this source code gets compiled against. Makefile/configure\n        // trickery would be needed to figure this suffix out, so it\n        // is simply hard-coded here.\n        //\n        // To keep the resulting binaries compatible with future libdl.so\n        // versions, this code also checks for backwards compatibility\n        // versions of the calls as they would be provided in such a\n        // future version.\n\n#if defined(TARGET_IA32E)\n# define DLOPEN_VERSION \"GLIBC_2.2.5\"\n# define DLSYM_VERSION \"GLIBC_2.2.5\"\n#elif defined(TARGET_IA32)\n# define DLOPEN_VERSION \"GLIBC_2.1\"\n# define DLSYM_VERSION \"GLIBC_2.0\"\n#else\n# error symbol versions unknown for this target\n#endif\n\n        RTN dlopenRtn = RTN_FindByName(img, \"dlopen@@\" DLOPEN_VERSION);\n        if (!RTN_Valid(dlopenRtn))\n        {\n            dlopenRtn = RTN_FindByName(img, \"dlopen@\" DLOPEN_VERSION);\n        }\n\n        if (!RTN_Valid(dlopenRtn))\n        {\n            // fallback for the cases in which symbols do not have a version\n            dlopenRtn = RTN_FindByName(img, \"dlopen\");\n        }\n\n        ASSERTX(RTN_Valid(dlopenRtn));\n        AppDlopen = DlopenType(RTN_Funptr(dlopenRtn));\n\n        // Get the function pointer for the application dlsym\n        RTN dlsymRtn = RTN_FindByName(img, \"dlsym@@\" DLSYM_VERSION);\n        if (!RTN_Valid(dlsymRtn)) {\n            dlsymRtn = RTN_FindByName(img, \"dlsym@\" DLSYM_VERSION);\n        }\n        if (!RTN_Valid(dlsymRtn)) {\n            // fallback for the cases in which symbols do not have a version\n            dlsymRtn = RTN_FindByName(img, \"dlsym\");\n        }\n\n        ASSERTX(RTN_Valid(dlsymRtn));\n        AppDlsym = DlsymType(RTN_Funptr(dlsymRtn));\n\n\n    }\n    if (strstr(IMG_Name(img).c_str(), \"libdyld.dylib\"))\n    {\n        RTN dlopenRtn = RTN_FindByName(img, C_MANGLE(\"dlopen\") );\n\n        // Get the function pointer for the application dlsym\n        RTN dlsymRtn = RTN_FindByName(img, C_MANGLE(\"dlsym\") );\n\n        // In some systems, dlsym and dlopen symbols don't exist.\n        // In this case, exit with special return code.\n        if (!RTN_Valid(dlsymRtn) && !RTN_Valid(dlopenRtn))\n        {\n            cerr << \"Error: dlsym and dlopen not found\" << endl;\n            PIN_ExitApplication(13);\n        }\n\n        AppDlopen = DlopenType(RTN_Funptr(dlopenRtn));\n        AppDlsym = DlsymType(RTN_Funptr(dlsymRtn));\n\n    }\n\n    if (strstr(IMG_Name(img).c_str(), MALLOC_LIB))\n    {\n        // Replace malloc and free in application libc with wrappers in libmallocwrappers.so\n        RTN mallocRtn = RTN_FindByName(img, C_MANGLE(\"malloc\"));\n        ASSERTX(RTN_Valid(mallocRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( mallocRtn ) )\n        {\n            cout << \"Cannot replace malloc in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN freeRtn = RTN_FindByName(img, C_MANGLE(\"free\"));\n        ASSERTX(RTN_Valid(freeRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( freeRtn ) )\n        {\n            cout << \"Cannot replace free in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n\n        origMalloc = (MallocType)RTN_ReplaceProbed(mallocRtn, AFUNPTR(MallocWrapperInTool));\n\n        origFree = (FreeType)RTN_ReplaceProbed(freeRtn, AFUNPTR(FreeWrapperInTool));\n\n    }\n\n    /* I call dopen before main. If this point is too late for you,\n    catch init() of libc and call dlopen after init() is done\n    */\n    if (IMG_IsMainExecutable(img))\n    {\n        RTN mainRtn = RTN_FindByName(img, \"_main\");\n        if (!RTN_Valid(mainRtn))\n            mainRtn = RTN_FindByName(img, \"main\");\n\n        if (!RTN_Valid(mainRtn))\n        {\n            cout << \"Can't find the main routine in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN_InsertCallProbed(mainRtn, IPOINT_BEFORE, AFUNPTR(MainRtnCallback), IARG_END);\n    }\n}\n\n\n\n/* ===================================================================== */\n/* main */\n/* ===================================================================== */\n\nint main(int argc, CHAR *argv[])\n{\n    PIN_InitSymbols();\n\n    if( PIN_Init(argc,argv) )\n    {\n        return Usage();\n    }\n\n    IMG_AddInstrumentFunction(ImageLoad, 0);\n\n    PIN_StartProgramProbed();\n\n    return 0;\n}\n\n/* ===================================================================== */\n/* eof */\n/* ===================================================================== */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/tpss_lin_libdl.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\nusing std::string;\nusing std::ios;\nusing std::hex;\nusing std::cerr;\nusing std::ofstream;\nusing std::endl;\n\ntypedef char * CHAR_PTR;\n\ntypedef void * VOID_PTR;\n\nofstream OutFile;\n\n/* ===================================================================== */\n/* Commandline Switches                                                  */\n/* ===================================================================== */\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"o\", \"tpss_lin_libdl.txt\", \"specify tool log file name\");\n\n/* ===================================================================== */\n/* Utility functions                                                     */\n/* ===================================================================== */\n\n// Print help information\nINT32 Usage()\n{\n    cerr << \"This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\" << endl;\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return 1;\n}\n\n// Utility function to return the time\nstring CurrentTime()\n{\n    char tmpbuf[128];\n    time_t thetime = time(NULL);\n    ctime_r(&thetime, tmpbuf);\n    return tmpbuf;\n}\n\n\n/* ===================================================================== */\n/* Function signatures - these functions will be probed                  */\n/* ===================================================================== */\n\nVOID_PTR (*fptrdlopen)(__const CHAR_PTR __file, int  __mode);\n\nint (*fptrdlclose)(VOID_PTR __handle);\n\nVOID_PTR (*fptrdlsym)(VOID_PTR __handle , __const CHAR_PTR __name );\n\nVOID_PTR (*fptrdlvsym)( VOID_PTR __handle, __const CHAR_PTR __name,__const CHAR_PTR __version);\n\nint (*fptrdladdr)(__const void *__address , Dl_info * __info);\n\nint (*fptrdladdr1)(__const void * __address , Dl_info * __info, void ** __extra_info, int __flags);\n\nCHAR_PTR (*fptrdlerror)(void);\n\n/* ===================================================================== */\n/* Probes - implementation of the wrapper functions                      */\n/* ===================================================================== */\n\nVOID_PTR mydlopen(__const CHAR_PTR __file, int __mode)\n{\n   OutFile << CurrentTime() << \"mydlopen called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlopen(__file, __mode);\n\n   return res;\n}\n\nint mydlclose(VOID_PTR __handle)\n{\n   OutFile << CurrentTime() << \"mydlclose called \" << endl;\n   OutFile.flush();\n   int res = fptrdlclose(__handle);\n\n   return res;\n}\n\nVOID_PTR mydlsym(VOID_PTR  __handle, __const CHAR_PTR  __name)\n{\n   OutFile << CurrentTime() << \"mydlsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlsym(__handle, __name);\n\n   return res;\n}\n\nVOID_PTR mydlvsym(VOID_PTR  __handle, __const CHAR_PTR  __name, __const CHAR_PTR __version)\n{\n   OutFile << CurrentTime() << \"mydlvsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlvsym(__handle, __name, __version);\n\n   return res;\n}\n\nint mydladdr(__const void * __address, Dl_info * __info)\n{\n   OutFile << CurrentTime() << \"mydladdr called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr(__address, __info);\n\n   return res;\n}\n\nint mydladdr1(__const void * __address, Dl_info * __info, void ** __extra_info, int __flags)\n{\n   OutFile << CurrentTime() << \"mydladdr1 called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr1(__address, __info, __extra_info, __flags);\n\n   return res;\n}\n\nCHAR_PTR mydlerror(void)\n{\n   OutFile << CurrentTime() << \"CHAR_PTR called \" << endl;\n   OutFile.flush();\n   CHAR_PTR res = fptrdlerror();\n\n   return res;\n}\n\n/* ===================================================================== */\n/* Instrumnetation functions                                             */\n/* ===================================================================== */\n\n// Image load callback - inserts the probes.\nvoid ImgLoad(IMG img, void *v)\n{\n    // Called every time a new image is loaded\n\n    if ( (IMG_Name(img).find(\"libdl.so\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.SO\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.so\") != string::npos) )\n    {\n        RTN rtndlclose = RTN_FindByName(img, \"dlclose\");\n        if (RTN_Valid(rtndlclose) && RTN_IsSafeForProbedReplacement(rtndlclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlclose at \" << RTN_Address(rtndlclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlclose, AFUNPTR(mydlclose)));\n            fptrdlclose = (int (*)(VOID_PTR ))fptr;\n        }\n\n        RTN rtndlopen = RTN_FindByName(img, \"dlopen\");\n        if (RTN_Valid(rtndlopen) && RTN_IsSafeForProbedReplacement(rtndlopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlopen at \" << RTN_Address(rtndlopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlopen, AFUNPTR(mydlopen)));\n            fptrdlopen = (VOID_PTR (*)(__const CHAR_PTR , int ))fptr;\n        }\n\n        RTN rtndlsym = RTN_FindByName(img, \"dlsym\");\n        if (RTN_Valid(rtndlsym) && RTN_IsSafeForProbedReplacement(rtndlsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlsym at \" << RTN_Address(rtndlsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlsym, AFUNPTR(mydlsym)));\n            fptrdlsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR ))fptr;\n        }\n\n        RTN rtndlvsym = RTN_FindByName(img, \"dlvsym\");\n        if (RTN_Valid(rtndlvsym) && RTN_IsSafeForProbedReplacement(rtndlvsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlvsym at \" << RTN_Address(rtndlvsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlvsym, AFUNPTR(mydlvsym)));\n            fptrdlvsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR, __const CHAR_PTR))fptr;\n        }\n\n        RTN rtndladdr = RTN_FindByName(img, \"dladdr\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr at \" << RTN_Address(rtndladdr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr)));\n            fptrdladdr = (int (*)(__const void * , Dl_info * ))fptr;\n        }\n\n        RTN rtndladdr1 = RTN_FindByName(img, \"dladdr1\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr1))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr1 at \" << RTN_Address(rtndladdr1) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr1)));\n            fptrdladdr1 = (int (*)(__const void * , Dl_info *, void **, int ))fptr;\n        }\n\n        RTN rtndlerror = RTN_FindByName(img, \"dlerror\");\n        if (RTN_Valid(rtndlerror) && RTN_IsSafeForProbedReplacement(rtndlerror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlerror at \" << RTN_Address(rtndlerror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlerror, AFUNPTR(mydlerror)));\n            fptrdlerror = (CHAR_PTR (*)(void ))fptr;\n        }\n    }\n    // finished instrumentation\n}\n\n/* ===================================================================== */\n/* Main function                                                         */\n/* ===================================================================== */\n\nint main(int argc, char *argv[])\n{\n    // Initialize Pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc,argv))\n    {\n        return Usage();\n    }\n\n    OutFile.open(KnobOutputFile.Value().c_str());\n    OutFile << hex;\n    OutFile.setf(ios::showbase);\n    OutFile << CurrentTime() << \"started!\" << endl;\n    OutFile.flush();\n\n    // Register the instrumentation callback\n    IMG_AddInstrumentFunction(ImgLoad, 0);\n\n\n    // Start the application\n    PIN_StartProgramProbed(); // never returns\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/unloadtest_unix.c": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"tool_macros.h\"\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n    Load(SHARED_LIB(\"libone\"), 1);\n    Load(SHARED_LIB(\"libtwo\"), 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Tests/sourceLocation_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n/*\n * This app checks a bug in the debug_elf cache mechanism. The cache contains images\n * that have previously been searched for debug information. When a pintool calls the\n * PIN_GetSourceLocation API, this cache is searched first (for the nearest address\n * which is greater or equal to the one being searched for). However, unloaded images\n * were never removed from the cache. When the API was used during an image unload\n * callback, if the images at high addresses were removed first, the search could be\n * conducted on images in the cache that had already been removed from Pin's internal\n * data structures, thus causing an assertion. The solution was to remove these images\n * from the cache as well as from the other data structres.\n * This app loads two images and then unloads the higher addressed one first in order\n * to recreate the conditions mentioned above.\n */\n\n#include <dlfcn.h>\n#include <iostream>\n#include <cstdlib>\n\nusing std::cerr;\nusing std::endl;\n\nvoid* DLopen(const char* filename) {\n    void* handle = dlopen(filename, RTLD_LAZY);\n    if (handle == NULL) {\n        cerr << \"APP ERROR: failed to open \" << filename << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    return handle;\n}\n\nvoid* DLsym(void* handle, const char* symname) {\n    dlerror(); // clear errors\n    void* sym = dlsym(handle, symname);\n    char* error = dlerror();\n    if (error != NULL) {\n        cerr << \"APP ERROR: failed to get address for symbol \" << symname << \" - \" << error << endl;\n        exit(-1);\n    }\n    return sym;\n}\n\nvoid DLcloseBoth(void* first, void* second) {\n    if (dlclose(first) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << first << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    if (dlclose(second) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << second << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n}\n\n/*\n * Expected argv arguments:\n * [1] image1\n * [2] image2\n */\nint main(int argc, char* argv[]) {\n    \n    void* handle1 = DLopen(argv[1]);            // open image1\n    void* handle2 = DLopen(argv[2]);            // open image2\n    void* dummy1 = DLsym(handle1, \"dummy1\");    // get address from image1\n    void* dummy2 = DLsym(handle2, \"dummy2\");    // get address from image2\n\n    // unload images - higher addressed image first\n    if (dummy1 > dummy2) {\n        DLcloseBoth(handle1, handle2);\n    }\n    else {\n        DLcloseBoth(handle2, handle1);\n    }\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/ImageTests/split_image_linux_app.cpp": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software is provided to you as Sample Source Code as defined in the accompanying\n * End User License Agreement for the Intel(R) Software Development Products (\"Agreement\")\n * section 1.L.\n * \n * This software and the related documents are provided as is, with no express or implied\n * warranties, other than those that are expressly stated in the License.\n */\n\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <vector>\n#include <dlfcn.h>\n#include <limits.h>\n#include <link.h>\nusing std::pair;\nusing std::vector;\n\n// The executable filename of this program\nchar progname[4096];\n\n\n/*\n * Iterate over all images known to the loader and print their memory regions\n */\nint dl_iterate(struct dl_phdr_info *info, size_t size, void *data)\n{\n    const char* realname = info->dlpi_name;\n    vector<pair<void*, void*> > vecSegments;\n    if (strstr(realname, \"linux-gate.so\") == realname || strstr(realname, \"linux-vdso.so\") == realname)\n    {\n        // Don't count VDSO, PIN doesn't repont it intentionally\n        return 0;\n    }\n    for (int j = 0; j < info->dlpi_phnum; j++)\n    {\n        if (info->dlpi_phdr[j].p_type == PT_LOAD)\n        {\n            void* start = (void *) (info->dlpi_addr + info->dlpi_phdr[j].p_vaddr);\n            void* end = (void*)((char*)start + info->dlpi_phdr[j].p_memsz - 1);\n            vecSegments.push_back(pair<void*, void*>(start, end));\n            if (*realname == 0 && (void*)dl_iterate >= start && (void*)dl_iterate < end)\n            {\n                realname = progname;\n            }\n        }\n    }\n    if (*realname != 0)\n    {\n        for (vector<pair<void*, void*> >::iterator it = vecSegments.begin(); it != vecSegments.end(); it++)\n        {\n            printf(\"%s, %p-%p\\n\", realname, it->first, it->second);\n        }\n    }\n    return 0;\n}\n\nint main(int argc, const char* argv[], char** envp)\n{\n    if (argc != 2)\n    {\n        printf(\"Usage: %s <path to lib>\\n\", argv[0]);\n        return 1;\n    }\n    realpath(argv[0], progname);\n    void* hDll = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n    if (NULL == hDll)\n    {\n        printf(\"Failed to open %s - %s\\n\", argv[1], dlerror());\n        return 1;\n    }\n    int (*return2)() = (int (*)())dlsym(hDll, \"return2\");\n    if (NULL == return2)\n    {\n        printf(\"Failed to locate 'return2' - %s\\n\", dlerror());\n        return 1;\n    }\n\n    if (return2() != 2)\n    {\n        printf(\"Bad value returned from 'return2'\\n\");\n        return 1;\n    }\n    dl_iterate_phdr(dl_iterate, NULL);\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/include/dlfcn.h": "/*\n * Copyright 2002-2019 Intel Corporation.\n * \n * This software and the related documents are Intel copyrighted materials, and your\n * use of them is governed by the express license under which they were provided to\n * you (\"License\"). Unless the License provides otherwise, you may not use, modify,\n * copy, publish, distribute, disclose or transmit this software or the related\n * documents without Intel's prior written permission.\n * \n * This software and the related documents are provided as is, with no express or\n * implied warranties, other than those that are expressly stated in the License.\n * \n * This file incorporates work covered by the following copyright and permission notice:\n */\n\n/*\n * Copyright (C) 2008 The Android Open Source Project\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#ifndef __DLFCN_H__\n#define __DLFCN_H__\n\n#include <sys/cdefs.h>\n\n__BEGIN_DECLS\n\ntypedef struct {\n    const char *dli_fname;  /* Pathname of shared object that\n                               contains address */\n    void       *dli_fbase;  /* Address at which shared object\n                               is loaded */\n    const char *dli_sname;  /* Name of nearest symbol with address\n                               lower than addr */\n    void       *dli_saddr;  /* Exact address of symbol named\n                               in dli_sname */\n} Dl_info;\n\nextern void*        dlopen(const char*  filename, int flag);\nextern int          dlclose(void*  handle);\nextern const char*  dlerror(void);\nextern void*        dlsym(void*  handle, const char*  symbol);\nextern int          dladdr(const void* addr, Dl_info *info);\n\nenum {\n#if defined(__APPLE__)\n  RTLD_LAZY   = 1,\n  RTLD_NOW    = 2,\n  RTLD_LOCAL  = 4,\n  RTLD_GLOBAL = 8,\n  RTLD_NOLOAD = 0x10,\n  RTLD_NODELETE = 0x80,\n  RTLD_FIRST = 0x100,   /* macOS 10.5 and later */\n#else\n# if defined(__LP64__)\n  RTLD_NOW  = 2,\n# else\n  RTLD_NOW  = 0,\n# endif\n  RTLD_LAZY = 1,\n\n  RTLD_LOCAL  = 0,\n# if defined(__LP64__)\n  RTLD_GLOBAL = 0x00100,\n# else\n  RTLD_GLOBAL = 2,\n# endif\n  RTLD_NOLOAD = 4,\n#endif\n};\n\n#if defined(__APPLE__)\n# define RTLD_NEXT       ((void *) -1)   /* Search subsequent objects. */\n# define RTLD_DEFAULT    ((void *) -2)   /* Use default search algorithm. */\n# define RTLD_SELF       ((void *) -3)   /* Search this and subsequent objects (macOS 10.5 and later) */\n# define RTLD_MAIN_ONLY  ((void *) -5)   /* Search main executable only (macOS 10.5 and later) */\n#else\n# if defined (__LP64__)\n#  define RTLD_DEFAULT  ((void*) 0)\n#  define RTLD_NEXT     ((void*) -1L)\n# else\n#  define RTLD_DEFAULT  ((void*) 0xffffffff)\n#  define RTLD_NEXT     ((void*) 0xfffffffe)\n# endif\n#endif\n\n#if defined(__APPLE__) && defined(__NEED_DYLD_PRIVATE)\n#include <mach-o/dyld.h>\n#include <mach-o/dyld_images.h>\n\nstruct dyld_unwind_sections\n{\n\tconst struct mach_header*\t\tmh;\n\tconst void*\t\t\t\t\t\tdwarf_section;\n\tuintptr_t\t\t\t\t\t\tdwarf_section_length;\n\tconst void*\t\t\t\t\t\tcompact_unwind_section;\n\tuintptr_t\t\t\t\t\t\tcompact_unwind_section_length;\n};\n\nextern bool _dyld_find_unwind_sections(void* addr, struct dyld_unwind_sections* info);\nextern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide));\nextern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide));\n\n#endif\n\n__END_DECLS\n\n#endif /* __DLFCN_H */\n\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/pin.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/bin/pindb.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/bin/pinbin.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib/libsapin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib/libpin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib/libsapin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib/libpin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib/libsapin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib/libpin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib/libpinjitprofiling.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib-ext/libpin3dwarf.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/lib-ext/libpin3dwarf.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libunwind-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/crtbegin.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/linker.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/crtbeginS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libc-static.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libunwind-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libstlport-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/crtendS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/crtend.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/crtbegin.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libdl-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/crtend.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libc-static.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libos-apis.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libos-apis.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libm-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libc-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libstlport-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libm-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/crtendS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libc-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/libdl-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/intel64/runtime/pincrt/crtbeginS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/I18N/win_unicode_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/I18N/win_unicode_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/I18N/win_unicode_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/I18N/win_unicode_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/probefastcall_app.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_defaultcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/probefastcall_app.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_fastcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_defaultcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_stdcall_app_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_fastcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/probestdcall_app.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_stdcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_fastcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_defaultcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_stdcall_app_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_fastcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_defaultcall_app_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/probestdcall_app.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Probes/before_after_stdcall_app_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Tests/winapp_runs_pin_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Tests/winapp_runs_pin.ico",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/source/tools/Tests/winapp_runs_pin_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/bin/pindb.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/bin/pinbin.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib/libsapin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib/libpin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib/libsapin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib/libpin.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib/libsapin-icc.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib/libpin-icc.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib/libpinjitprofiling.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib-ext/libpin3dwarf.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/lib-ext/libpin3dwarf.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libunwind-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/crtbegin.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/linker.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/crtbeginS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libc-static.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libunwind-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libstlport-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/crtendS.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/crtend.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/crtbegin.o",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libdl-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/crtend.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libc-static.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libos-apis.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libos-apis.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libm-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libc-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libstlport-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libm-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/crtendS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libc-dynamic.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/libdl-dynamic.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/ia32/runtime/pincrt/crtbeginS.o.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/xed-intel64/lib/libxed.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/xed-intel64/lib/libxed.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/intel64/libatomic.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/intel64/libdebugger-protocol.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/intel64/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/intel64/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/intel64/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/intel64/libdebugger-protocol.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/ia32/libatomic.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/ia32/libdebugger-protocol.a.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/ia32/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/ia32/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/ia32/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/components/lib/ia32/libdebugger-protocol.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/sync_on.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/sync_off.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/crt/doc/html/search/search_l.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/xed-ia32/lib/libxed.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/extras/xed-ia32/lib/libxed.so.sig",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/pin-debugger-project-properties1.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/pin-debugger-option-pages-properties.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/pin-debugger-attach.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/sync_on.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/stack-debugger-commands.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/pin-debugger-project-properties2.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/stack-debugger-custom-break.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/sync_off.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-3.15-qtcejqqllsur7mgxhvc3qrtragcen4ow/spack-src/doc/html/search/search_l.png"
    ],
    "total_files": 4395
}