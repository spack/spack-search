{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/AttachDetach/reattach_probed_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n// @ORIGINAL_AUTHOR: Elena Demikhovsky\n\n/*! @file\n *  Test detaching - reattach Pin on Linux\n *  The application creates threads in a loop. Each thread does some work and exits.\n *  The process in endless, expected to be stopped by tool.\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <linux/unistd.h>\n#include <math.h>\n#ifdef TARGET_ANDROID\n#include <sys/syscall.h>\n#endif\n\n#define NTHREADS 20\n\n/*\n * Get thread Id\n */\npid_t GetTid()\n{\n     return syscall(__NR_gettid);\n}\n\n# define TLS_GET_GS_REG() \\\n  ({ int __seg; __asm (\"movw %%gs, %w0\" : \"=q\" (__seg)); __seg & 0xffff; })\n\n\nvolatile bool loop1, loop2 ;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        //sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\ntypedef  double (*DLL_FUNC)(double x);\ntypedef  int (*DLL_INT_FUNC)(int x);\n\n\nvoid * thread_dlopen_func (void *arg)\n{    \n    double number = 0.2;\n    double calculatedValue = 0;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libmy_dll.so\", RTLD_LAZY);\n        if (handle)\n        {\n            DLL_FUNC fptr = (DLL_FUNC)dlsym(handle, \"my_dll_sin\");\n            calculatedValue += (*fptr)(number);\n            \n            //sleep(1);\n            dlclose(handle);\n        }\n        else \n        {\n            fprintf(stderr, \"error opening my_dll.so, thread %d\\n\", GetTid());\n            exit(-1);\n        } \n        number += 0.01;\n    }\n        \n    return 0;\n}\n\nint main (int argc, char *argv[])\n{\n    unsigned long gs_val = TLS_GET_GS_REG();\n    while (1)\n    {\n        loop1 = true;\n        loop2 = true;\n        pthread_t h[NTHREADS];\n        \n        pthread_create (&h[0], 0, thread_dlopen_func, 0);\n        for (unsigned long i = 1; i < NTHREADS; i++)\n        {\n            pthread_create (&h[i], 0, thread_func, 0);\n        }\n        sleep(1);\n\n        loop1 = false;\n        loop2 = false;\n\n        for (unsigned long i = 0; i < NTHREADS; i++)\n        {\n            pthread_join (h[i], 0);\n        }\n    }    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/AttachDetach/detach_probed_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n// @ORIGINAL_AUTHOR: Elena Demikhovsky\n\n/*! @file\n *  Test detaching Pin from running process on Linux\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <linux/unistd.h>\n#ifdef TARGET_ANDROID\n#include <sys/syscall.h>\n#endif\n\n#define NTHREADS 20\n\n/*\n * Get thread Id\n */\npid_t GetTid()\n{\n     return syscall(__NR_gettid);\n}\n\nextern \"C\" void TellPinToDetach(unsigned long *updateWhenReady)\n{\n    return;\n}\n\nvolatile bool loop2 = true;\nvoid * thread_func (void *arg)\n{    \n    while (loop2)\n    {\n        void *space = malloc(300);\n        sleep(1);\n        free(space);\n    }\n    return 0;\n\n}\n\nvolatile bool loop1 = true;\ntypedef  double (*SIN_FUNC)(double x);\n\nvoid * thread_dlopen_func (void *arg)\n{    \n\tdouble number = 0.2;\n    while (loop1)\n    {\n        void *handle = dlopen(\"libm.so\", RTLD_LAZY);\n        if (handle)\n        {\n            SIN_FUNC sin_fptr = (SIN_FUNC)dlsym(handle, \"sin\");\n            if (sin_fptr)\n            {\n                double val = (*sin_fptr)(number);\n                printf(\"val = %.4f\\n\", val);\n            }\n            sleep(2);\n            dlclose(handle);\n        }\n\t\tnumber += 0.01;\n    }\n        \n    return 0;\n\n}\n\nint main (int argc, char *argv[])\n{\n    pthread_t h[NTHREADS];\n    \n    pthread_create (&h[0], 0, thread_dlopen_func, 0);\n    for (unsigned long i = 1; i < NTHREADS; i++)\n    {\n        pthread_create (&h[i], 0, thread_func, 0);\n    }\n    \n\tunsigned long pinDetached = false;\n    TellPinToDetach(&pinDetached);\n    \n\twhile (!pinDetached)\n\t{\n    \tsleep(2);\n\t}\n    \n    loop1 = false;\n    loop2 = false;\n    \n    for (unsigned long i = 0; i < NTHREADS; i++)\n    {\n        pthread_join (h[i], 0);\n    }\n    printf(\"All threads exited. The test PASSED\\n\");    \n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ToolUnitTests/dltest.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n    \n    Load(ONE, 1);\n    Load(TWO, 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/ToolUnitTests/dltest2.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\n#ifdef TARGET_MAC\n#define ONE \"libone.dylib\"\n#define TWO \"libtwo.dylib\"\n#else\n#define ONE \"libone.so\"\n#define TWO \"libtwo.so\"\n#endif\n\nvoid Load(char *name, int expect)\n{\n    int val;\n    double dval;\n    \n    void *handle;\n    int (*sym)();\n    double (*fsin)(double);\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n        \n    val = sym();\n    if (val != expect)\n        exit(1);\n\n    dlclose(handle);\n}\n\nint main()\n{\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n        switch(1 + rand() % 2) {\n        case 1:\n            Load(ONE, 1);\n            break;\n        case 2:\n            Load(TWO, 2);\n            break;\n        }\n    }\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/MacTests/bundle_app.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <dlfcn.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n    void *bundle = 0;\n    const char* (*fptr)();\n    bundle = dlopen(argv[1], RTLD_LAZY);\n    if (bundle)\n    {\n        fprintf(stdout, \"Loaded bundle successfully\\n\");\n    }\n    else\n    {\n        fprintf(stderr, \"Failed to load bundle: %s\\n\", dlerror());\n        return 1;\n    }\n\n    fptr = (const char* (*)())dlsym(bundle, \"my_function\");\n\n    if (fptr)\n    {\n        fprintf(stdout, \"Located symbol successfully\\n\");\n    }\n    else\n    {\n        fprintf(stderr, \"Failed to locate symbol in bundle: %s\\n\", dlerror());\n        return 1;\n    }\n\n    fprintf(stdout, \"Calling bundle function...\\n\");\n    fprintf(stdout, \"Bundle function call result: %s\\n\", (*fptr)());\n    fprintf(stdout, \"Called bundle function.\\n\");\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/dltest_unix.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n#if defined(TARGET_MAC) || defined(TARGET_BSD)\n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);\n#else    \n    void * mem = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n#endif    \n    fprintf(stderr, \"Allocated %p\\n\",mem);\n    // This unmap should not trigger a flush\n    munmap(mem, 0x2000);\n    \n    Load(\"libone.so\", 1);\n    Load(\"libtwo.so\", 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/malloctrace2.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n\n/* ===================================================================== */\n/*\n  @ORIGINAL_AUTHOR: Robert Cohn, Elena Demikhovsky\n*/\n\n/* ===================================================================== */\n/*! @file\n The test shows how wrappers may be implemented in DLL loaded in runtime.\n The dopen() is being called from application space. But it can't be called \n before libc is initialized.\n In this example I call dlopen before main().\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n\nusing namespace std;\n\n\n/* ===================================================================== */\n/* Commandline Switches */\n/* ===================================================================== */\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"o\", \"malloctrace2.outfile\", \"specify trace file name\");\n\n/* ===================================================================== */\n\nINT32 Usage()\n{\n    cerr <<\n        \"This pin tool inserts a user-written version of malloc() and free() into the application.\\n\"\n        \"\\n\";\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return -1;\n}\n\n\n/* ===================================================================== */\n/* Definitions for Probe mode */\n/* ===================================================================== */\n\ntypedef typeof(malloc) * MallocType;\ntypedef typeof(free) * FreeType;\ntypedef typeof(dlopen) * DlopenType;\ntypedef typeof(dlsym) * DlsymType;\n\nMallocType MallocWrapper = 0;\nMallocType origMalloc = 0;\n\nFreeType FreeWrapper = 0;\nFreeType origFree = 0;\n\nvoid * MallocTraceHandle = 0;\n\nDlopenType AppDlopen = 0;\nDlsymType AppDlsym = 0;\n\ntypedef VOID (*SET_ORIG_FPTR)(MallocType mallocPtr, FreeType freePtr);\n\n/* ===================================================================== */\n/* Probe mode tool */\n/* ===================================================================== */\n\nVOID *MallocWrapperInTool(size_t size)\n{\n    if (MallocWrapper)\n    {\n        return (*MallocWrapper)(size);\n    }\n    else\n    {\n        ASSERTX(origMalloc != 0);\n        return (*origMalloc)(size);\n    }\n}\n\nVOID FreeWrapperInTool(void *p)\n{\n    if (FreeWrapper)\n    {\n        (*FreeWrapper)(p);\n    }\n    else\n    {\n        ASSERTX(origFree != 0);\n        (*origFree)(p);\n    }\n}\n\n/* I'm calling dlopen before main.\n * Some malloc-free may be lost, of course.\n * But the earliest point you can call dlopen is after init of libc\n */\nVOID MainRtnCallback()\n{\n    cout << \"In main callback\" << endl;\n    // inject libmallocwrappers.so into application by executing application dlopen\n\n    MallocTraceHandle = AppDlopen(\"libmallocwrappers.so\", RTLD_LAZY);\n    ASSERTX(MallocTraceHandle);\n\n    // Get function pointers for the wrappers\n    MallocWrapper = MallocType(AppDlsym(MallocTraceHandle, \"mallocWrapper\"));\n    FreeWrapper = FreeType(AppDlsym(MallocTraceHandle, \"freeWrapper\"));\n    ASSERTX(MallocWrapper && FreeWrapper);\n\n    // Send original function pointers to libmallocwrappers.so\n    SET_ORIG_FPTR setOriginalFptr = (SET_ORIG_FPTR) AppDlsym(MallocTraceHandle, \"SetOriginalFptr\");\n    ASSERTX(setOriginalFptr != 0);\n    (*setOriginalFptr)(origMalloc, origFree);\n}\n\nVOID ImageLoad(IMG img, VOID *v)\n{\n    if (strstr(IMG_Name(img).c_str(), \"libdl.so\"))\n    {\n        // Get the function pointer for the application dlopen:\n        // dlopen@@GLIBC_2.1 is the official, versioned name.\n        // \n        // The exact suffix must match the ABI of the libdl header files\n        // this source code gets compiled against. Makefile/configure\n        // trickery would be needed to figure this suffix out, so it\n        // is simply hard-coded here.\n        //\n        // To keep the resulting binaries compatible with future libdl.so\n        // versions, this code also checks for backwards compatibility\n        // versions of the calls as they would be provided in such a\n        // future version.\n        \n#if defined(TARGET_IA32E)\n# define DLOPEN_VERSION \"GLIBC_2.2.5\"\n# define DLSYM_VERSION \"GLIBC_2.2.5\"\n#elif defined(TARGET_IA32)\n# define DLOPEN_VERSION \"GLIBC_2.1\"\n# define DLSYM_VERSION \"GLIBC_2.0\"\n#else\n# error symbol versions unknown for this target\n#endif\n            \n        RTN dlopenRtn = RTN_FindByName(img, \"dlopen@@\" DLOPEN_VERSION);\n        if (!RTN_Valid(dlopenRtn)) \n        {\n            dlopenRtn = RTN_FindByName(img, \"dlopen@\" DLOPEN_VERSION);\n        }\n\n        if (!RTN_Valid(dlopenRtn)) \n        {\n            // fallback for the cases in which symbols do not have a version\n            dlopenRtn = RTN_FindByName(img, \"dlopen\");\n        }\n        \n        ASSERTX(RTN_Valid(dlopenRtn));\n        AppDlopen = DlopenType(RTN_Funptr(dlopenRtn));\n        \n        // Get the function pointer for the application dlsym\n        RTN dlsymRtn = RTN_FindByName(img, \"dlsym@@\" DLSYM_VERSION);\n        if (!RTN_Valid(dlsymRtn)) {\n            dlsymRtn = RTN_FindByName(img, \"dlsym@\" DLSYM_VERSION);\n        }\n        if (!RTN_Valid(dlsymRtn)) {\n            // fallback for the cases in which symbols do not have a version\n            dlsymRtn = RTN_FindByName(img, \"dlsym\");\n        }\n        \n        ASSERTX(RTN_Valid(dlsymRtn));\n        AppDlsym = DlsymType(RTN_Funptr(dlsymRtn));\n\n        \n    }\n\n    if (strstr(IMG_Name(img).c_str(), \"libc.so\"))\n    {\n        // Replace malloc and free in application libc with wrappers in libmallocwrappers.so\n        RTN mallocRtn = RTN_FindByName(img, \"malloc\");\n        ASSERTX(RTN_Valid(mallocRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( mallocRtn ) )\n        {\n            cout << \"Cannot replace malloc in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN freeRtn = RTN_FindByName(img, \"free\");\n        ASSERTX(RTN_Valid(freeRtn));\n\n        if ( ! RTN_IsSafeForProbedReplacement( freeRtn ) )\n        {\n            cout << \"Cannot replace free in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        \n        origMalloc = (MallocType)RTN_ReplaceProbed(mallocRtn, AFUNPTR(MallocWrapperInTool));\n        \n        origFree = (FreeType)RTN_ReplaceProbed(freeRtn, AFUNPTR(FreeWrapperInTool));\n\n    }\n    \n    /* I call dopen before main. If this point is too late for you,\n    catch init() of libc and call dlopen after init() is done\n    */\n    if (IMG_IsMainExecutable(img))\n    {\n        RTN mainRtn = RTN_FindByName(img, \"_main\");\n        if (!RTN_Valid(mainRtn))\n            mainRtn = RTN_FindByName(img, \"main\");\n\n        if (!RTN_Valid(mainRtn))\n        {\n            cout << \"Can't find the main routine in \" << IMG_Name(img) << endl;\n            exit(1);\n        }\n        RTN_InsertCallProbed(mainRtn, IPOINT_BEFORE, AFUNPTR(MainRtnCallback), IARG_END);\n    }\n}\n\n                    \n\n/* ===================================================================== */\n/* main */\n/* ===================================================================== */\n\nint main(int argc, CHAR *argv[])\n{\n    PIN_InitSymbols();\n    \n    if( PIN_Init(argc,argv) )\n    {\n        return Usage();\n    }\n    \n    IMG_AddInstrumentFunction(ImageLoad, 0);\n        \n    PIN_StartProgramProbed();\n    \n    return 0;\n}\n\n/* ===================================================================== */\n/* eof */\n/* ===================================================================== */\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/tpss_lin_libdl.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n * This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\n * However, in this tool these probes are merely empty wrappers that call the original functions.\n * The objective of the test is to verify that probe generation and insertion don't cause Pin\n * to crash.\n */\n\n#include \"pin.H\"\n#include <iostream>\n#include <fstream>\n#include <dlfcn.h>\n\ntypedef char * CHAR_PTR;\n\ntypedef void * VOID_PTR;\n\nofstream OutFile;\n\n/* ===================================================================== */\n/* Commandline Switches                                                  */\n/* ===================================================================== */\n\nKNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\",\n    \"o\", \"tpss_lin_libdl.txt\", \"specify tool log file name\");\n\n/* ===================================================================== */\n/* Utility functions                                                     */\n/* ===================================================================== */\n\n// Print help information\nINT32 Usage()\n{\n    cerr << \"This tool mimics the behavior of TPSS on Linux by adding probes to various libdl functions.\" << endl;\n    cerr << KNOB_BASE::StringKnobSummary();\n    cerr << endl;\n    return 1;\n}\n\n// Utility function to return the time\nstring CurrentTime()\n{\n    char tmpbuf[128];\n    time_t thetime = time(NULL);\n    ctime_r(&thetime, tmpbuf);\n    return tmpbuf;\n}\n\n\n/* ===================================================================== */\n/* Function signatures - these functions will be probed                  */\n/* ===================================================================== */\n\nVOID_PTR (*fptrdlopen)(__const CHAR_PTR __file, int  __mode);\n\nint (*fptrdlclose)(VOID_PTR __handle);\n\nVOID_PTR (*fptrdlsym)(VOID_PTR __handle , __const CHAR_PTR __name );\n\nVOID_PTR (*fptrdlvsym)( VOID_PTR __handle, __const CHAR_PTR __name,__const CHAR_PTR __version);\n\nint (*fptrdladdr)(__const void *__address , Dl_info * __info);\n\nint (*fptrdladdr1)(__const void * __address , Dl_info * __info, void ** __extra_info, int __flags);\n\nCHAR_PTR (*fptrdlerror)(void);\n\n/* ===================================================================== */\n/* Probes - implementation of the wrapper functions                      */\n/* ===================================================================== */\n\nVOID_PTR mydlopen(__const CHAR_PTR __file, int __mode)\n{\n   OutFile << CurrentTime() << \"mydlopen called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlopen(__file, __mode);\n\n   return res;\n}\n\nint mydlclose(VOID_PTR __handle)\n{\n   OutFile << CurrentTime() << \"mydlclose called \" << endl;\n   OutFile.flush();\n   int res = fptrdlclose(__handle);\n\n   return res;\n}\n\nVOID_PTR mydlsym(VOID_PTR  __handle, __const CHAR_PTR  __name)\n{\n   OutFile << CurrentTime() << \"mydlsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlsym(__handle, __name);\n\n   return res;\n}\n\nVOID_PTR mydlvsym(VOID_PTR  __handle, __const CHAR_PTR  __name, __const CHAR_PTR __version)\n{\n   OutFile << CurrentTime() << \"mydlvsym called \" << endl;\n   OutFile.flush();\n   VOID_PTR res = fptrdlvsym(__handle, __name, __version);\n\n   return res;\n}\n\nint mydladdr(__const void * __address, Dl_info * __info)\n{\n   OutFile << CurrentTime() << \"mydladdr called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr(__address, __info);\n\n   return res;\n}\n\nint mydladdr1(__const void * __address, Dl_info * __info, void ** __extra_info, int __flags)\n{\n   OutFile << CurrentTime() << \"mydladdr1 called \" << endl;\n   OutFile.flush();\n   int res = fptrdladdr1(__address, __info, __extra_info, __flags);\n\n   return res;\n}\n\nCHAR_PTR mydlerror(void)\n{\n   OutFile << CurrentTime() << \"CHAR_PTR called \" << endl;\n   OutFile.flush();\n   CHAR_PTR res = fptrdlerror();\n\n   return res;\n}\n\n/* ===================================================================== */\n/* Instrumnetation functions                                             */\n/* ===================================================================== */\n\n// Image load callback - inserts the probes.\nvoid ImgLoad(IMG img, void *v)\n{\n    // Called every time a new image is loaded\n\n    if ( (IMG_Name(img).find(\"libdl.so\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.SO\") != string::npos) ||\n         (IMG_Name(img).find(\"LIBDL.so\") != string::npos) )\n    {\n        RTN rtndlclose = RTN_FindByName(img, \"dlclose\");\n        if (RTN_Valid(rtndlclose) && RTN_IsSafeForProbedReplacement(rtndlclose))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlclose at \" << RTN_Address(rtndlclose) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlclose, AFUNPTR(mydlclose)));\n            fptrdlclose = (int (*)(VOID_PTR ))fptr;\n        }\n\n        RTN rtndlopen = RTN_FindByName(img, \"dlopen\");\n        if (RTN_Valid(rtndlopen) && RTN_IsSafeForProbedReplacement(rtndlopen))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlopen at \" << RTN_Address(rtndlopen) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlopen, AFUNPTR(mydlopen)));\n            fptrdlopen = (VOID_PTR (*)(__const CHAR_PTR , int ))fptr;\n        }\n\n        RTN rtndlsym = RTN_FindByName(img, \"dlsym\");\n        if (RTN_Valid(rtndlsym) && RTN_IsSafeForProbedReplacement(rtndlsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlsym at \" << RTN_Address(rtndlsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlsym, AFUNPTR(mydlsym)));\n            fptrdlsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR ))fptr;\n        }\n\n        RTN rtndlvsym = RTN_FindByName(img, \"dlvsym\");\n        if (RTN_Valid(rtndlvsym) && RTN_IsSafeForProbedReplacement(rtndlvsym))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlvsym at \" << RTN_Address(rtndlvsym) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlvsym, AFUNPTR(mydlvsym)));\n            fptrdlvsym = (VOID_PTR (*)(VOID_PTR, __const CHAR_PTR, __const CHAR_PTR))fptr;\n        }\n\n        RTN rtndladdr = RTN_FindByName(img, \"dladdr\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr at \" << RTN_Address(rtndladdr) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr)));\n            fptrdladdr = (int (*)(__const void * , Dl_info * ))fptr;\n        }\n\n        RTN rtndladdr1 = RTN_FindByName(img, \"dladdr1\");\n        if (RTN_Valid(rtndladdr) && RTN_IsSafeForProbedReplacement(rtndladdr1))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dladdr1 at \" << RTN_Address(rtndladdr1) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndladdr, AFUNPTR(mydladdr1)));\n            fptrdladdr1 = (int (*)(__const void * , Dl_info *, void **, int ))fptr;\n        }\n\n        RTN rtndlerror = RTN_FindByName(img, \"dlerror\");\n        if (RTN_Valid(rtndlerror) && RTN_IsSafeForProbedReplacement(rtndlerror))\n        {\n            OutFile << CurrentTime() << \"Inserting probe for dlerror at \" << RTN_Address(rtndlerror) << endl;\n            OutFile.flush();\n            AFUNPTR fptr = (RTN_ReplaceProbed(rtndlerror, AFUNPTR(mydlerror)));\n            fptrdlerror = (CHAR_PTR (*)(void ))fptr;\n        }\n    }\n    // finished instrumentation\n}\n\n/* ===================================================================== */\n/* Main function                                                         */\n/* ===================================================================== */\n\nint main(int argc, char *argv[])\n{\n    // Initialize Pin\n    PIN_InitSymbols();\n    if (PIN_Init(argc,argv))\n    {\n        return Usage();\n    }\n\n    OutFile.open(KnobOutputFile.Value().c_str());\n    OutFile << hex;\n    OutFile.setf(ios::showbase);\n    OutFile << CurrentTime() << \"started!\" << endl;\n    OutFile.flush();\n\n    // Register the instrumentation callback\n    IMG_AddInstrumentFunction(ImgLoad, 0);\n\n\n    // Start the application\n    PIN_StartProgramProbed(); // never returns\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/unloadtest_unix.c": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n\nvoid Load(char * name, int expect)\n{\n    int val;\n    \n    void * handle;\n    int (*sym)();\n    \n    handle = dlopen(name, RTLD_LAZY);\n    if (handle == 0)\n    {\n        fprintf(stderr,\"Load of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    sym = (int(*)())dlsym(handle, \"one\");\n    fprintf(stderr, \"Address of sym is %p\\n\",sym);\n    \n    if (sym == 0)\n    {\n        fprintf(stderr,\"Dlsym of %s failed\\n\",name);\n        exit(1);\n    }\n    \n    val = sym();\n    if (val != expect)\n        exit(1);\n    \n    dlclose(handle);\n}\n\nint main()\n{\n    Load(\"libone.so\", 1);\n    Load(\"libtwo.so\", 2);\n\n    return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/sourceLocation_app.cpp": "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2015 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n * This app checks a bug in the debug_elf cache mechanism. The cache contains images\n * that have previously been searched for debug information. When a pintool calls the\n * PIN_GetSourceLocation API, this cache is searched first (for the nearest address\n * which is greater or equal to the one being searched for). However, unloaded images\n * were never removed from the cache. When the API was used during an image unload\n * callback, if the images at high addresses were removed first, the search could be\n * conducted on images in the cache that had already been removed from Pin's internal\n * data structures, thus causing an assertion. The solution was to remove these images\n * from the cache as well as from the other data structres.\n * This app loads two images and then unloads the higher addressed one first in order\n * to recreate the conditions mentioned above.\n */\n\n#include <dlfcn.h>\n#include <iostream>\n#include <cstdlib>\n\nusing std::cerr;\nusing std::endl;\n\nvoid* DLopen(const char* filename) {\n    void* handle = dlopen(filename, RTLD_LAZY);\n    if (handle == NULL) {\n        cerr << \"APP ERROR: failed to open \" << filename << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    return handle;\n}\n\nvoid* DLsym(void* handle, const char* symname) {\n    dlerror(); // clear errors\n    void* sym = dlsym(handle, symname);\n    char* error = dlerror();\n    if (error != NULL) {\n        cerr << \"APP ERROR: failed to get address for symbol \" << symname << \" - \" << error << endl;\n        exit(-1);\n    }\n    return sym;\n}\n\nvoid DLcloseBoth(void* first, void* second) {\n    if (dlclose(first) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << first << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n    if (dlclose(second) != 0) {\n        cerr << \"APP ERROR: failed to close image at \" << second << \" - \" << dlerror() << endl;\n        exit(-1);\n    }\n}\n\n/*\n * Expected argv arguments:\n * [1] image1\n * [2] image2\n */\nint main(int argc, char* argv[]) {\n    \n    void* handle1 = DLopen(argv[1]);            // open image1\n    void* handle2 = DLopen(argv[2]);            // open image2\n    void* dummy1 = DLsym(handle1, \"dummy1\");    // get address from image1\n    void* dummy2 = DLsym(handle2, \"dummy2\");    // get address from image2\n\n    // unload images - higher addressed image first\n    if (dummy1 > dummy2) {\n        DLcloseBoth(handle1, handle2);\n    }\n    else {\n        DLcloseBoth(handle2, handle1);\n    }\n    return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib/libpinapp.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib/libpinvm.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/lib-ext/libpindwarf.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/GPLv3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/cpplibs/libgcc_s.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/cpplibs/libstdc++.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/cpplibs/libstdc++.so.6.0.13",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/cpplibs/libstdc++.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/intel64/runtime/cpplibs/libgcc_s.so.1",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Utils/hello_win.pdb-ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Utils/hello_win.pdb-intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Utils/hello_win.exe-ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Utils/hello_win.exe-intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/I18N/win_unicode_intel64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/I18N/win_unicode_intel64.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/I18N/win_unicode_ia32.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/I18N/win_unicode_ia32.exe",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.pdb.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.exe.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/probestdcall_app.pdb.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.pdb.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_defaultcall_app.exe.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_fastcall_app.pdb.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_defaultcall_app.pdb.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_fastcall_app.exe.zi.intel64",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.exe.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_fastcall_app.exe.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_fastcall_app.pdb.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.exe.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_defaultcall_app.exe.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/probestdcall_app.exe.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/probefastcall_app.pdb.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_defaultcall_app.pdb.zi.ia32",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/probefastcall_app.exe.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Probes/before_after_stdcall_app.pdb.zi",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/winapp_runs_pin_intel64.xex",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/winapp_runs_pin.suo",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/winapp_runs_pin.ico",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/winapp_runs_pin.rc",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/source/tools/Tests/winapp_runs_pin_ia32.xex",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib/libpin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib/libpinapp.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib/libpinjitprofiling.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib/libsapin.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib/libpinvm.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/lib-ext/libpindwarf.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/GPLv3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/cpplibs/libgcc_s.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/cpplibs/libstdc++.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/cpplibs/libstdc++.so.6.0.13",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/cpplibs/libstdc++.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/ia32/runtime/cpplibs/libgcc_s.so.1",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/extlib/libstdc++.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/extlib/libgcc_s.so.1",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/extlib/libm.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/extlib/libc.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/lib/libxed.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/lib/libxed-ild.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/search.idx",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2pnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/tab_l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2mlastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2plastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2vertline.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2lastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2blank.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2link.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/tab_b.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/tab_r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2mnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-intel64/doc/ref-manual/html/ftv2node.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/intel64/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/intel64/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/intel64/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/ia32/libatomic.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/ia32/libdebugger-protocol.so",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/components/lib/ia32/libdebugger-protocol.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/extlib/libstdc++.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/extlib/libgcc_s.so.1",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/extlib/libm.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/extlib/libc.so.6",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/lib/libxed.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/lib/libxed-ild.a",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/search.idx",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2pnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/tab_l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2mlastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2plastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2vertline.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2lastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2blank.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2link.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/tab_b.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/tab_r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2mnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/extras/xed-ia32/doc/ref-manual/html/ftv2node.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/search.idx",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/tab_l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/pin-debugger-project-properties1.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/pin-debugger-option-pages-properties.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/pin-debugger-attach.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/tab_b.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/stack-debugger-commands.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/pin-debugger-project-properties2.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/stack-debugger-custom-break.png",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/tab_r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-intel-pin-2.14-xksvjn74wkua4f6giyfoctousa33xwbg/spack-src/doc/html/doxygen.png"
    ],
    "total_files": 3245
}