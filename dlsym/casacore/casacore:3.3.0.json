{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/casa/OS/MemoryTrace.cc": "//# MemoryTrace.cc: Simple memory usage tracing mechanism\n//# Copyright (C) 2015\n//# Associated Universities, Inc. Washington DC, USA.\n//#\n//# This library is free software; you can redistribute it and/or modify it\n//# under the terms of the GNU Library General Public License as published by\n//# the Free Software Foundation; either version 2 of the License, or (at your\n//# option) any later version.\n//#\n//# This library is distributed in the hope that it will be useful, but WITHOUT\n//# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n//# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public\n//# License for more details.\n//#\n//# You should have received a copy of the GNU Library General Public License\n//# along with this library; if not, write to the Free Software Foundation,\n//# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.\n//#\n//# Correspondence concerning AIPS++ should be addressed as follows:\n//#        Internet email: aips2-request@nrao.edu.\n//#        Postal address: AIPS++ Project Office\n//#                        National Radio Astronomy Observatory\n//#                        520 Edgemont Road\n//#                        Charlottesville, VA 22903-2475 USA\n//#\n//# $Id: Block.h 21120 2011-09-01 13:51:56Z gervandiepen $\n\n//# Comment out for time being because __malloc_hook is deprecated.\n//# Do so by #ifdef on AIPS_LINUX_DEPR instead of AIPS_LINUX.\n\n#include <casacore/casa/OS/MemoryTrace.h>\n#include <casacore/casa/OS/EnvVar.h>\n#include <casacore/casa/BasicSL/String.h>\n#include <casacore/casa/Exceptions/Error.h>\n#ifdef AIPS_LINUX_DEPR\n# include <malloc.h>\n#endif\n\nnamespace casacore { //# NAMESPACE CASACORE - BEGIN\n\n  // Initialize statics.\n  Bool MemoryTrace::theirDoTrace = False;\n  std::ofstream MemoryTrace::theirFile;\n  Timer MemoryTrace::theirTimer;\n  void* (*MemoryTrace::theirOldMallocHook)(size_t, const void*) = 0;\n  void (*MemoryTrace::theirOldFreeHook)(void*, const void*) = 0;\n\n  void MemoryTrace::open()\n  {\n    if (! theirFile.is_open()) {\n      String name (EnvironmentVariable::get (\"CASACORE_MEMORYTRACE\"));\n      if (name.empty()) {\n        name = \"casacore_memorytrace.log\";\n      }\n      theirFile.open (name.c_str());\n      if (!theirFile) {\n        throw AipsError (\"Could not create memorytrace file \" + name);\n      }\n    }\n  }\n\n  void MemoryTrace::start()\n  {\n    if (! theirFile.is_open()) {\n      open();\n    }\n    if (!theirDoTrace) {\n#ifdef AIPS_LINUX_DEPR\n      theirOldMallocHook = __malloc_hook;\n      theirOldFreeHook   = __free_hook;\n      __malloc_hook      = &mallocHook;\n      __free_hook        = &freeHook;\n#endif\n      theirDoTrace = True;\n    }\n  }\n\n  void MemoryTrace::stop()\n  {\n    if (theirDoTrace) {\n#ifdef AIPS_LINUX_DEPR\n      __malloc_hook = theirOldMallocHook;\n      __free_hook   = theirOldFreeHook;\n#endif\n      theirDoTrace = False;\n    }\n  }\n\n  std::ofstream& MemoryTrace::writeAlloc (const void* ptr, size_t size)\n  {\n    theirFile << Int64(1000 * theirTimer.real()) << \" a b-\" << ptr\n              << ' ' << size << ' ';\n    return theirFile;\n  }\n\n  std::ofstream& MemoryTrace::writeFree (const void* ptr)\n  {\n    theirFile << Int64(1000 * theirTimer.real()) << \" f b-\" << ptr\n              << ' ';\n    return theirFile;\n  }\n\n  void MemoryTrace::close()\n  {\n    stop();\n    if (theirFile.is_open()) {\n      theirFile.close();\n    }\n  }\n\n#ifdef AIPS_LINUX_DEPR\n  void* MemoryTrace::mallocHook (size_t size, const void* caller)\n  {\n    if (size == 0) {\n      return NULL;\n    }\n    // Restore the old hooks.\n    __malloc_hook = theirOldMallocHook;\n    __free_hook   = theirOldFreeHook;\n    // Call recursively.\n    void* ptr = malloc(size);\n    // Save hooks (to be safe).\n    theirOldMallocHook = __malloc_hook;\n    theirOldFreeHook   = __free_hook;\n    // iostream might call malloc/free; it is protected too.\n    theirFile << Int64(1000 * theirTimer.real()) << \" a \" << ptr << ' '\n              << size << ' ' << caller << std::endl;\n    // Restore our own hooks.\n    __malloc_hook = &mallocHook;\n    __free_hook   = &freeHook;\n    return ptr;\n  }\n#else\n  void* MemoryTrace::mallocHook (size_t, const void*)\n  {\n    return NULL;\n  }\n#endif\n\n#ifdef AIPS_LINUX_DEPR\n  void MemoryTrace::freeHook (void* ptr, const void* caller)\n  {\n    if (ptr != NULL) {\n      // Restore the old hooks.\n      __malloc_hook = theirOldMallocHook;\n      __free_hook   = theirOldFreeHook;\n      // Call recursively.\n      free (ptr);\n      // Save hooks (to be safe).\n      theirOldMallocHook = __malloc_hook;\n      theirOldFreeHook   = __free_hook;\n      // iostream might call malloc/free; it is protected too.\n      theirFile << Int64(1000 * theirTimer.real()) << \" f \" << ptr << ' '\n                << caller << std::endl;\n      // Restore our own hooks.\n      __malloc_hook = &mallocHook;\n      __free_hook   = &freeHook;\n    }\n  }\n#else\n  void MemoryTrace::freeHook (void*, const void*)\n  {}\n#endif\n\n  void MemoryTrace::writeBlock (const char* msg, const std::string& name)\n  {\n    if (isOpen()) {\n#ifdef AIPS_LINUX_DEPR\n      if (theirDoTrace) {\n        // Restore the old hooks.\n        __malloc_hook = theirOldMallocHook;\n        __free_hook   = theirOldFreeHook;\n      }\n#endif\n      theirFile << Int64(1000 * theirTimer.real()) << msg\n                << name << std::endl;\n#ifdef AIPS_LINUX_DEPR\n      if (theirDoTrace) {\n        // Restore our own hooks.\n        __malloc_hook = &mallocHook;\n        __free_hook   = &freeHook;\n      }\n#endif\n    }\n  }\n\n  void MemoryTrace::writeBlock (const char* msg, const char* name)\n  {\n    if (isOpen()) {\n#ifdef AIPS_LINUX_DEPR\n      if (theirDoTrace) {\n        // Restore the old hooks.\n        __malloc_hook = theirOldMallocHook;\n        __free_hook   = theirOldFreeHook;\n      }\n#endif\n      theirFile << Int64(1000 * theirTimer.real()) << msg\n                << name << std::endl;\n#ifdef AIPS_LINUX_DEPR\n      if (theirDoTrace) {\n        // Restore our own hooks.\n        __malloc_hook = &mallocHook;\n        __free_hook   = &freeHook;\n      }\n#endif\n    }\n  }\n\n  std::string MemoryTrace::makeString (const char* name)\n  {\n#ifdef AIPS_LINUX_DEPR\n    if (theirDoTrace) {\n      // Restore the old hooks to avoid trace messages when making the string.\n      __malloc_hook = theirOldMallocHook;\n      __free_hook   = theirOldFreeHook;\n    }\n#endif\n    std::string str(name);\n#ifdef AIPS_LINUX_DEPR\n    if (theirDoTrace) {\n      // Restore our own hooks.\n      __malloc_hook = &mallocHook;\n      __free_hook   = &freeHook;\n    }\n#endif\n    return str;\n  }\n\n\n\n\n  MemoryTraceBlock::MemoryTraceBlock (const std::string& name)\n    : itsName (name)\n  {\n    traceMemoryBlockBegin (itsName);\n  }\n\n  MemoryTraceBlock::MemoryTraceBlock (const char* name)\n    : itsName (MemoryTrace::makeString(name))\n  {\n    traceMemoryBlockBegin (itsName);\n  }\n\n  MemoryTraceBlock::~MemoryTraceBlock()\n  {\n    traceMemoryBlockEnd (itsName);\n  }\n\n\n} //# NAMESPACE CASACORE - END\n\n\n\n// Note: another way to do memory tracing is by preloading a shared library\n// containing the overloaded malloc and free. This could be done in a\n// casacore package memorytrace or so.\n// The disadvantage of it is that it is less selective; furthermore it always\n// has to find the symbol which can be a bit expensive.\n// See the following code.\n\n/*\n//# See http://www.stev.org/post/2012/11/03/HowTo-Override-malloc-free-in-c.aspx\n\n#include <stdio.h>\n#include <dlfcn.h>\n#include <stdlib.h>\n \nvoid* malloc(size_t size) noexcept\n{\n  if (size == 0) {\n    return NULL;\n  }\n  // For the compiler data pointers and function pointers are different, which\n  // can be the case for special hardware. Not here, so make them equal.\n  typedef void* (*func_ptr)(size_t);\n  typedef union {\n    func_ptr funcPtr;\n    void* ptr;\n  } ptrCastUnion;\n  ptrCastUnion ptrCast;\n\n  void* handle = RTLD_NEXT;\n  ptrCast.ptr = dlsym(handle, \"malloc\");\n  if (ptrCast.ptr == NULL) {\n    printf(\"libcasa_malloclog cannot find malloc\\n\");\n    exit(1);\n  }\n  void* addr = (ptrCast.funcPtr)(size);\n  printf(\"Alloc = %p Size: %ld\\n\", addr, size);\n  return addr;\n}\n\nvoid free(void* addr) noexcept\n{\n  if (addr == NULL) {\n    return;\n  }\n  typedef void (*func_ptr)(void*);\n  typedef union {\n    func_ptr funcPtr;\n    void* ptr;\n  } ptrCastUnion;\n  ptrCastUnion ptrCast;\n\n  printf(\"free %p\\n\", addr);\n  void* handle = RTLD_NEXT;\n  ptrCast.ptr = dlsym(handle, \"free\");\n  if (ptrCast.ptr == NULL) {\n    exit(1);\n  }\n  (ptrCast.funcPtr)(addr);\n}\n*/\n\n/*\nSee http://stackoverflow.com/questions/17803456/an-alternative-for-the-deprecated-malloc-hook-functionality-of-glibc\nSee also http://elinux.org/images/b/b5/Elc2013_Kobayashi.pdf\n\nMy complete hooking function now looks like this:\n\nextern void *__libc_malloc(size_t size);\n\nint malloc_hook_active = 0;\n\nvoid*\nmalloc (size_t size)\n{\n  void *caller = __builtin_return_address(0);\n  if (malloc_hook_active)\n    return my_malloc_hook(size, caller);\n  return __libc_malloc(size);\n}\n\nwhere my_malloc_hook looks like this:\n\nvoid*\nmy_malloc_hook (size_t size, void *caller)\n{\n  void *result;\n\n  // deactivate hooks for logging\n  malloc_hook_active = 0;\n\n  result = malloc(size);\n\n  // do logging\n  [ ... ]\n\n  // reactivate hooks\n  malloc_hook_active = 1;\n\n  return result;\n}\n\nOf course, the hooks for calloc, realloc and free work similarly.\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/casa/OS/DynLib.cc": "//# DynLib.cc: Class to handle loading of dynamic libraries\n//# Copyright (C) 2009\n//# Associated Universities, Inc. Washington DC, USA.\n//#\n//# This library is free software; you can redistribute it and/or modify it\n//# under the terms of the GNU Library General Public License as published by\n//# the Free Software Foundation; either version 2 of the License, or (at your\n//# option) any later version.\n//#\n//# This library is distributed in the hope that it will be useful, but WITHOUT\n//# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n//# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public\n//# License for more details.\n//#\n//# You should have received a copy of the GNU Library General Public License\n//# along with this library; if not, write to the Free Software Foundation,\n//# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.\n//#\n//# Correspondence concerning AIPS++ should be addressed as follows:\n//#        Internet email: aips2-request@nrao.edu.\n//#        Postal address: AIPS++ Project Office\n//#                        National Radio Astronomy Observatory\n//#                        520 Edgemont Road\n//#                        Charlottesville, VA 22903-2475 USA\n//#\n//# $Id$\n\n//# For the time being assume that all systems have dlopen.\n#ifndef HAVE_DLOPEN\n# define HAVE_DLOPEN\n#endif\n\n//# Includes\n#include <casacore/casa/OS/DynLib.h>\n#include <casacore/casa/OS/EnvVar.h>\n#include <casacore/casa/BasicSL/String.h>\n#include <casacore/casa/Arrays/Array.h>\n#include <casacore/casa/Utilities/Assert.h>\n#include <casacore/casa/Logging/LogIO.h>\n#include <casacore/casa/Exceptions/Error.h>\n#ifdef HAVE_DLOPEN\n#include <dlfcn.h>\n#endif\n\nusing namespace std;\n\nnamespace casacore { //# NAMESPACE CASACORE - BEGIN\n\n  DynLib::DynLib (const std::string& library,\n                  const std::string& prefix,\n                  const std::string& funcName,\n                  bool closeOnDestruction)\n    : itsHandle  (0),\n      itsDoClose (closeOnDestruction)\n  {\n    attach (library, prefix, std::string(), funcName);\n  }\n\n  DynLib::DynLib (const std::string& library,\n                  const std::string& prefix,\n                  const std::string& version,\n                  const std::string& funcName,\n                  bool closeOnDestruction)\n    : itsHandle  (0),\n      itsDoClose (closeOnDestruction)\n  {\n    // Add a dot to the version if needed.\n    std::string vers(version);\n    if (! vers.empty()  &&  vers[0] != '.') {\n      vers = '.' + vers;\n    }\n    attach (library, prefix, vers, funcName);\n  }\n\n  DynLib::DynLib (const std::string& library,\n                  Bool closeOnDestruction,\n                  const std::string& prefix,\n                  const std::string& suffix)\n    : itsHandle  (0),\n      itsDoClose (closeOnDestruction)\n  {\n    open (prefix + library + suffix);\n  }\n\n  DynLib::~DynLib()\n  {\n    if (itsDoClose) {\n      close();\n    }\n  }\n\n  void* DynLib::getFunc (const std::string& funcName)\n  {\n    itsError.clear();\n#ifdef HAVE_DLOPEN\n    if (itsHandle ) {\n      void* fptr = dlsym (itsHandle, funcName.c_str());\n      if (fptr == 0) {\n        itsError = dlerror();\n      }\n      return fptr;\n    }\n#endif\n    return 0;\n  }\n\n  void DynLib::open (const std::string& name)\n  {\n#ifdef HAVE_DLOPEN\n    itsHandle = dlopen (name.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (itsHandle == 0) {\n      itsError += string(dlerror()) + '\\n';\n    }\n#endif\n  }\n\n  void DynLib::close()\n  {\n    if (itsHandle) {\n#ifdef HAVE_DLOPEN\n      dlclose (itsHandle);\n#endif\n      itsHandle= 0;\n    }\n  }\n\n  std::string DynLib::tryOpen (const std::string& library,\n                               const std::string& dir,\n                               const std::string& prefix,\n                               const std::string& version)\n  {\n    std::string pref(prefix);\n    std::string vers(version);\n    std::string fullName;\n    // Try a maximum 4 times (1 or 2 prefix, 1 or 2 version, 1 ext).\n    int i=0;\n    while (i<4  &&  itsHandle==0) {\n#ifdef __APPLE__\n      fullName = dir + pref + library + vers + \".dylib\";\n#else\n      fullName = dir + pref + library + \".so\" + vers;\n#endif\n      open (fullName);\n      i++;\n      if (i == 2) {\n        if (pref == \"lib\") i += 2;     // no specific prefix given\n        pref = \"lib\";\n      }\n      if (i%2 == 1) {\n        vers = std::string();\n        if (version.empty()) i++;      // no version given\n      } else {\n        vers = version; \n      }\n    }\n    return (itsHandle==0  ?  std::string() : fullName);\n  }\n\n  void DynLib::attach (const std::string& library,\n                       const std::string& prefix,\n                       const std::string& version,\n                       const std::string& funcName)\n  {\n    std::string fullName = tryCasacorePath (library, prefix, version);\n    if (fullName.empty()) {\n      fullName = tryOpen (library, string(), prefix, version);\n    }\n    if (itsHandle == 0) {\n      throw AipsError (\"Shared library \" + library +\n                       \" not found in CASACORE_LDPATH or (DY)LD_LIBRARY_PATH\\n\"\n                       + itsError);\n    }\n    LogIO os(LogOrigin(\"DynLib\"));\n    os << LogIO::NORMAL3\n       << \"Loaded shared library \" << fullName\n       << LogIO::POST;\n    if (itsHandle  &&  !funcName.empty()) {\n      // Found the dynamic library.\n      // Now find and execute the given function.\n      // Because a compiler like g++ gives a warning when casting a pointer\n      // to a function pointer, a union is used to achieve this.\n      // Ensure the pointer sizes are the same.\n      typedef void (*func_ptr)();\n      AlwaysAssert (sizeof(func_ptr) == sizeof(void*), AipsError);\n      typedef union {\n\tfunc_ptr funcPtr;\n\tvoid* ptr;\n      } ptrCastUnion;\n      ptrCastUnion ptrCast;\n      ptrCast.ptr = getFunc (funcName.c_str());\n      if (! ptrCast.ptr) {\n        close();\n        throw AipsError(\"Found dynamic library \" + fullName +\n                        \", but not its \" + funcName + \" function\\n  \" +\n                        itsError);\n      }\n/// Note: the following is a g++ specific way to avoid the warning.\n///#ifdef __GNUC__\n///__extension__\n///#endif\n      // Execute the function.\n      ptrCast.funcPtr();\n      os << LogIO::NORMAL3\n         << \"Executed \" << funcName << \" in shared library \" << fullName\n         << LogIO::POST;\n    }\n  }\n\n  std::string DynLib::tryCasacorePath (const std::string& library,\n                                       const std::string& prefix,\n                                       const std::string& version)\n  {\n    // Check if CASACORE_LDPATH is defined.\n    String casapath(\"CASACORE_LDPATH\");\n    String path = EnvironmentVariable::get(casapath);\n    if (! path.empty()) {\n      // Split using : as delimiter.\n      Vector<String> parts = stringToVector (path, ':');\n      for (uInt j=0; j<parts.size(); ++j) {\n        if (! parts[j].empty()) {\n          string libDir = parts[j] + '/';\n          // Check if shared library can be found there.\n          std::string fullName = tryOpen (library, libDir, prefix, version);\n          if (itsHandle) {\n            return fullName;\n          }\n        }\n      }\n    }\n    return std::string();\n  }\n\n} //# NAMESPACE CASACORE - END\n",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/casa/OS/DynLib.h": "//# DynLib.h: Class to handle loadig of dynamic libraries\n//# Copyright (C) 2009\n//# Associated Universities, Inc. Washington DC, USA.\n//#\n//# This library is free software; you can redistribute it and/or modify it\n//# under the terms of the GNU Library General Public License as published by\n//# the Free Software Foundation; either version 2 of the License, or (at your\n//# option) any later version.\n//#\n//# This library is distributed in the hope that it will be useful, but WITHOUT\n//# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n//# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public\n//# License for more details.\n//#\n//# You should have received a copy of the GNU Library General Public License\n//# along with this library; if not, write to the Free Software Foundation,\n//# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.\n//#\n//# Correspondence concerning AIPS++ should be addressed as follows:\n//#        Internet email: aips2-request@nrao.edu.\n//#        Postal address: AIPS++ Project Office\n//#                        National Radio Astronomy Observatory\n//#                        520 Edgemont Road\n//#                        Charlottesville, VA 22903-2475 USA\n//#\n//# $Id$\n\n#ifndef CASA_DYNLIB_H\n#define CASA_DYNLIB_H\n\n//# Includes\n#include <casacore/casa/aips.h>\n#include <string>\n\nnamespace casacore { //# NAMESPACE CASACORE - BEGIN\n\n  // <summary> \n  // Class to handle loading of dynamic libraries\n  // </summary>\n  // <reviewed reviewer=\"UNKNOWN\" date=\"before2004/08/25\" tests=\"\" demos=\"\">\n  // </reviewed>\n\n  // <use visibility=export>\n\n  // <prerequisite> \n  //    <li> Basic knowledge of the dlopen function family\n  // </prerequisite>\n\n  // <synopsis> \n  // This class makes it possible to load a dynamic library and execute an\n  // initialization function. Furthermore, one can get a pointer to any function\n  // in the dynamic library and close the library.\n  //\n  // The search path of the shared library is as follows:\n  // <ul>\n  //  <li> If the environment library CASACORE_LDPATH is defined, it is tried to\n  //       find the library using that path.\n  //  <li> If not defined or not found, the system's (DY)LD_LIBRARY_PATH is used.\n  //  <li> The library looked for has the name 'prefix'libname'suffix'.\n  //       <br>As prefix first \"lib\" is used, thereafter the given one\n  //       (e.g., \"libcasa_\").\n  //       <br>As suffix first \".so\" is used, thereafter \".dylib\" (for OS-X).\n  // </ul>\n  //\n  // It is a wrapper around functions dlopen, dlsym, and dlclose.\n  // If dlopen and so are not supported on a platform, the class acts as if\n  // the shared library could not be found.\n  // </synopsis>\n\n  // <example>\n  // <srcblock>\n  //    DynLib dl(\"derivedmscal\", \"libcasa_\", \"register_derivedmscal\");\n  //    AlwaysAssert (dl.getHandle());\n  // </srcblock>\n  // Using this \n  //  loads the shared library <src>libcasa_derivedmscal.so</src> and\n  //  executes the given register initialization function.\n  // </example>\n\n  // <motivation> \n  // dlopen is a standard UNIX system call, but some operating systems\n  // do not support it or have different function names (notably Windows).\n  // In this way use of dynamic libraries is centralized and can easily b\n  // tailored as needed.\n  // </motivation>\n\n  class DynLib\n  {\n  public:\n\n    // Load the dynamic library. It is tried with prefixes <src>prefix</src>\n    // and \"lib\" (in that order) and with suffix \".so\" or \".dylib\" (for Apple).\n    // No library version number is used.\n    // If not loaded successfully, an exception is thrown.\n    // <br>If a non-empty funcName is given, that function is looked up and\n    // executed for initialization purposes. Its signature must be\n    // <src>void func()</src>.\n    // Note that the function name should not be mangled, thus declared\n    // <src>extern \"C\"</src>.\n    // An exception is thrown if the library is loaded successfully, but\n    // <src>funcName</src> could not be found.\n    // <br>If <src>closeOnDestruction=True</src>, the dynamic library is\n    // closed on destruction of the DynLib object.\n    DynLib (const std::string& library,\n            const std::string& prefix=std::string(),\n            const std::string& funcName=std::string(),\n            bool closeOnDestruction=True);\n\n    // The same as above, but it is tried with and without the given version\n    // (in that order).\n    DynLib (const std::string& library,\n            const std::string& prefix,\n            const std::string& version,\n            const std::string& funcName,\n            bool closeOnDestruction=True);\n\n    // Load the dynamic library with the given name, prefix, and suffix.\n    // If not loaded successfully, the internal handle is NULL.\n    // <br>If <src>closeOnDestruction=True</src>, the dynamic library is closed\n    // when the DynLib object is destructed.\n    DynLib (const std::string& library,\n            Bool closeOnDestruction,\n            const std::string& prefix=\"lib\",\n#ifdef __APPLE__\n            const std::string& suffix=\".dylib\");\n#else\n            const std::string& suffix=\".so\");\n#endif\n\n    // Close the dynamic library if told so in the constructor.\n    ~DynLib();\n\n    // Get a pointer to a function in the dynamic library.\n    // The pointer has to be casted with a reinterpret_cast to a function\n    // pointer with the correct signature. When compiling with -pedantic the\n    // compiler will give a warning for such a cast, because on some systems\n    // (in particular some micro-controllers) a data pointer differs from a\n    // function pointer. However, that problem cannot be solved.\n    // For example:\n    // <srcblock>\n    //   typedef Int MyFunc(Int, Int);\n    //   void* initfunc = DynLib::getFunc (mod, (\"register_\"+name).c_str());\n    //   if (initFunc) {\n    //     MyFunc* func = reinterpret_cast<MyFunc*>(initfunc);\n    //     Int result = func(1,2);\n    //   }\n    // </srcblock>\n    // casts to a function returning Int and taking two Ints.\n    // <br>A null pointer is returned if the function could not be found.\n    void* getFunc (const std::string& funcName);\n\n    // Get the dynamic library handle.\n    void* getHandle() const\n      { return itsHandle; }\n\n    // Get the possible error.\n    const std::string& getError() const\n      { return itsError; }\n\n  private:\n    // Try to open the library with some prefixes, suffixes and versions\n    // and to execute the initialization function.\n    // If successful, itsHandle is filled. Otherwise an exception is thrown.\n    void attach (const std::string& name,\n                 const std::string& prefix,\n                 const std::string& version,\n                 const std::string& funcName);\n\n    // Try to open the library with some prefixes, suffixes and versions\n    // If successful, itsHandle is filled and the full library name is\n    // returned. Otherwise an empty name is returned.\n    std::string tryOpen (const std::string& name,\n                         const std::string& libdir,\n                         const std::string& prefix,\n                         const std::string& version);\n\n    // Open (load) the dynamic library.\n    void open (const std::string& name);\n\n    // Close (unload) the dynamic library (if opened).\n    void close();\n\n    // Try if the library can be opened using CASACORE_LDPATH.\n    std::string tryCasacorePath (const std::string& library,\n                                 const std::string& prefix,\n                                 const std::string& version);\n\n    //# Handle to dynamic library; note that the pointer is not owned, so the\n    //# generated copy ctor and assignment are fine.\n    void*       itsHandle;\n    Bool        itsDoClose;\n    std::string itsError;\n  };\n\n} //# NAMESPACE CASACORE - END\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/qualityimage.fits",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/imageStats.fits",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/mexinputtest.fits",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/imagetestimage.fits",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/test_image.im/table.f0_TSM0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/test_image.im/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/test_image.im/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/test_image.im/table.lock",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/test_image.im/logtable/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/test_image.im/logtable/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/test_image.im/logtable/table.lock",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/decon_test.im/table.f0_TSM0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/decon_test.im/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/decon_test.im/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/decon_test.im/table.lock",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/decon_test.im/logtable/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/decon_test.im/logtable/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/images/Images/test/decon_test.im/logtable/table.lock",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/measures/Measures/test/tMeasIERS.in_tgz",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/casa/IO/IO_2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/casa/IO/IO_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/casa/OS/OS_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/casa/Containers/test/tHashMap.in_words.gz",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/Tables/test/tTable_2.data_v1/table.f2",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/Tables/test/tTable_2.data_v1/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/Tables/test/tTable_2.data_v1/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/Tables/test/tTable_2.data_v1/table.f0i0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/Tables/test/tTable_2.data_v1/table.f1",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/Tables/test/tTable_2.data_v0/table.f2",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/Tables/test/tTable_2.data_v0/table.dat",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/Tables/test/tTable_2.data_v0/table.f0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/Tables/test/tTable_2.data_v0/table.f0i0",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/Tables/test/tTable_2.data_v0/table.f1",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/tables/DataMan/test/tSSMAddRemove.in",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/ms/MSSel/test/mssel_test_small_multifield_spw.ms.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/ms/MSSel/test/mssel_test_small.ms.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-casacore-3.3.0-hcvc6klvnemshvyn6dp3qp7jqpryk3gv/spack-src/ms/MSOper/test/tMSSummary.in"
    ],
    "total_files": 3213
}