{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/ao2mo/_ao2mo.py": "#!/usr/bin/env python\n# Copyright 2014-2018 The PySCF Developers. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport ctypes\nimport _ctypes\nimport numpy\nfrom pyscf import lib\nfrom pyscf.gto.moleintor import make_cintopt, make_loc, ascint3\nfrom pyscf.scf import _vhf\n\nlibao2mo = lib.load_library('libao2mo')\ndef _fpointer(name):\n    return ctypes.c_void_p(_ctypes.dlsym(libao2mo._handle, name))\n\nclass AO2MOpt(object):\n    def __init__(self, mol, intor, prescreen='CVHFnoscreen', qcondname=None):\n        intor = ascint3(intor)\n        self._this = ctypes.POINTER(_vhf._CVHFOpt)()\n        #print self._this.contents, expect ValueError: NULL pointer access\n        self._intor = intor\n\n        c_atm = numpy.asarray(mol._atm, dtype=numpy.int32, order='C')\n        c_bas = numpy.asarray(mol._bas, dtype=numpy.int32, order='C')\n        c_env = numpy.asarray(mol._env, dtype=numpy.double, order='C')\n        natm = ctypes.c_int(c_atm.shape[0])\n        nbas = ctypes.c_int(c_bas.shape[0])\n        self._cintopt = make_cintopt(c_atm, c_bas, c_env, intor)\n\n        libao2mo.CVHFinit_optimizer(ctypes.byref(self._this),\n                                    c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n                                    c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n                                    c_env.ctypes.data_as(ctypes.c_void_p))\n        self._this.contents.fprescreen = _fpointer(prescreen)\n\n        if prescreen != 'CVHFnoscreen' and intor in ('int2e_sph', 'int2e_cart'):\n            # for int2e_sph, qcondname is 'CVHFsetnr_direct_scf'\n            ao_loc = make_loc(c_bas, intor)\n            fsetqcond = getattr(libao2mo, qcondname)\n            fsetqcond(self._this,\n                      getattr(libao2mo, intor), self._cintopt,\n                      ao_loc.ctypes.data_as(ctypes.c_void_p),\n                      c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n                      c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n                      c_env.ctypes.data_as(ctypes.c_void_p))\n\n    def __del__(self):\n        try:\n            libao2mo.CVHFdel_optimizer(ctypes.byref(self._this))\n        except AttributeError:\n            pass\n\n\n# if out is not None, transform AO to MO in-place\ndef nr_e1fill(intor, sh_range, atm, bas, env,\n              aosym='s1', comp=1, ao2mopt=None, out=None):\n    assert(aosym in ('s4', 's2ij', 's2kl', 's1'))\n    intor = ascint3(intor)\n    c_atm = numpy.asarray(atm, dtype=numpy.int32, order='C')\n    c_bas = numpy.asarray(bas, dtype=numpy.int32, order='C')\n    c_env = numpy.asarray(env, order='C')\n    natm = ctypes.c_int(c_atm.shape[0])\n    nbas = ctypes.c_int(c_bas.shape[0])\n    ao_loc = make_loc(bas, intor)\n    nao = ao_loc[-1]\n\n    klsh0, klsh1, nkl = sh_range\n\n    if aosym in ('s4', 's2ij'):\n        nao_pair = nao * (nao+1) // 2\n    else:\n        nao_pair = nao * nao\n    out = numpy.ndarray((comp,nkl,nao_pair), buffer=out)\n    if out.size == 0:\n        return out\n\n    if ao2mopt is not None:\n        cao2mopt = ao2mopt._this\n        cintopt = ao2mopt._cintopt\n        intor = ao2mopt._intor\n    else:\n        cao2mopt = lib.c_null_ptr()\n        cintopt = make_cintopt(c_atm, c_bas, c_env, intor)\n    cintor = _fpointer(intor)\n\n    fdrv = getattr(libao2mo, 'AO2MOnr_e1fill_drv')\n    fill = _fpointer('AO2MOfill_nr_' + aosym)\n    fdrv(cintor, fill, out.ctypes.data_as(ctypes.c_void_p),\n         ctypes.c_int(klsh0), ctypes.c_int(klsh1-klsh0),\n         ctypes.c_int(nkl), ctypes.c_int(comp),\n         ao_loc.ctypes.data_as(ctypes.c_void_p), cintopt, cao2mopt,\n         c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n         c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n         c_env.ctypes.data_as(ctypes.c_void_p))\n    return out\n\ndef nr_e1(eri, mo_coeff, orbs_slice, aosym='s1', mosym='s1', out=None):\n    assert(eri.flags.c_contiguous)\n    assert(aosym in ('s4', 's2ij', 's2kl', 's1'))\n    assert(mosym in ('s2', 's1'))\n    mo_coeff = numpy.asfortranarray(mo_coeff)\n    assert(mo_coeff.dtype == numpy.double)\n    nao = mo_coeff.shape[0]\n    i0, i1, j0, j1 = orbs_slice\n    icount = i1 - i0\n    jcount = j1 - j0\n    ij_count = icount * jcount\n\n    if aosym in ('s4', 's2ij'):\n        if mosym == 's2':\n            fmmm = _fpointer('AO2MOmmm_nr_s2_s2')\n            assert(icount == jcount)\n            ij_count = icount * (icount+1) // 2\n        elif icount <= jcount:\n            fmmm = _fpointer('AO2MOmmm_nr_s2_iltj')\n        else:\n            fmmm = _fpointer('AO2MOmmm_nr_s2_igtj')\n    else:\n        if icount <= jcount:\n            fmmm = _fpointer('AO2MOmmm_nr_s1_iltj')\n        else:\n            fmmm = _fpointer('AO2MOmmm_nr_s1_igtj')\n\n    nrow = eri.shape[0]\n    out = numpy.ndarray((nrow,ij_count), buffer=out)\n    if out.size == 0:\n        return out\n\n    fdrv = getattr(libao2mo, 'AO2MOnr_e2_drv')\n    pao_loc = ctypes.POINTER(ctypes.c_void_p)()\n    c_nbas = ctypes.c_int(0)\n    ftrans = _fpointer('AO2MOtranse1_nr_' + aosym)\n    fdrv(ftrans, fmmm,\n         out.ctypes.data_as(ctypes.c_void_p),\n         eri.ctypes.data_as(ctypes.c_void_p),\n         mo_coeff.ctypes.data_as(ctypes.c_void_p),\n         ctypes.c_int(nrow), ctypes.c_int(nao),\n         (ctypes.c_int*4)(*orbs_slice), pao_loc, c_nbas)\n    return out\n\n# if out is not None, transform AO to MO in-place\n# ao_loc has nbas+1 elements, last element in ao_loc == nao\ndef nr_e2(eri, mo_coeff, orbs_slice, aosym='s1', mosym='s1', out=None,\n           ao_loc=None):\n    assert(eri.flags.c_contiguous)\n    assert(aosym in ('s4', 's2ij', 's2kl', 's2', 's1'))\n    assert(mosym in ('s2', 's1'))\n    mo_coeff = numpy.asfortranarray(mo_coeff)\n    assert(mo_coeff.dtype == numpy.double)\n    nao = mo_coeff.shape[0]\n    k0, k1, l0, l1 = orbs_slice\n    kc = k1 - k0\n    lc = l1 - l0\n    kl_count = kc * lc\n\n    if aosym in ('s4', 's2', 's2kl'):\n        if mosym == 's2':\n            fmmm = _fpointer('AO2MOmmm_nr_s2_s2')\n            assert(kc == lc)\n            kl_count = kc * (kc+1) // 2\n        elif kc <= lc:\n            fmmm = _fpointer('AO2MOmmm_nr_s2_iltj')\n        else:\n            fmmm = _fpointer('AO2MOmmm_nr_s2_igtj')\n    else:\n        if kc <= lc:\n            fmmm = _fpointer('AO2MOmmm_nr_s1_iltj')\n        else:\n            fmmm = _fpointer('AO2MOmmm_nr_s1_igtj')\n\n    nrow = eri.shape[0]\n    out = numpy.ndarray((nrow,kl_count), buffer=out)\n    if out.size == 0:\n        return out\n\n    if ao_loc is None:\n        pao_loc = ctypes.POINTER(ctypes.c_void_p)()\n        c_nbas = ctypes.c_int(0)\n        ftrans = _fpointer('AO2MOtranse2_nr_' + aosym)\n    else:\n        ao_loc = numpy.asarray(ao_loc, dtype=numpy.int32)\n        c_nbas = ctypes.c_int(ao_loc.shape[0]-1)\n        pao_loc = ao_loc.ctypes.data_as(ctypes.c_void_p)\n        ftrans = _fpointer('AO2MOsortranse2_nr_' + aosym)\n\n    fdrv = getattr(libao2mo, 'AO2MOnr_e2_drv')\n    fdrv(ftrans, fmmm,\n         out.ctypes.data_as(ctypes.c_void_p),\n         eri.ctypes.data_as(ctypes.c_void_p),\n         mo_coeff.ctypes.data_as(ctypes.c_void_p),\n         ctypes.c_int(nrow), ctypes.c_int(nao),\n         (ctypes.c_int*4)(*orbs_slice), pao_loc, c_nbas)\n    return out\n\n\n# if out is not None, transform AO to MO in-place\ndef r_e1(intor, mo_coeff, orbs_slice, sh_range, atm, bas, env,\n         tao, aosym='s1', comp=1, ao2mopt=None, out=None):\n    assert(aosym in ('s4', 's2ij', 's2kl', 's1', 'a2ij', 'a2kl', 'a4ij',\n                     'a4kl', 'a4'))\n    intor = ascint3(intor)\n    mo_coeff = numpy.asfortranarray(mo_coeff)\n    i0, i1, j0, j1 = orbs_slice\n    icount = i1 - i0\n    jcount = j1 - j0\n    ij_count = icount * jcount\n\n    c_atm = numpy.asarray(atm, dtype=numpy.int32)\n    c_bas = numpy.asarray(bas, dtype=numpy.int32)\n    c_env = numpy.asarray(env)\n    natm = ctypes.c_int(c_atm.shape[0])\n    nbas = ctypes.c_int(c_bas.shape[0])\n\n    klsh0, klsh1, nkl = sh_range\n\n    if icount <= jcount:\n        fmmm = _fpointer('AO2MOmmm_r_iltj')\n    else:\n        fmmm = _fpointer('AO2MOmmm_r_igtj')\n\n    out = numpy.ndarray((comp,nkl,ij_count), dtype=numpy.complex, buffer=out)\n    if out.size == 0:\n        return out\n\n    if ao2mopt is not None:\n        cao2mopt = ao2mopt._this\n        cintopt = ao2mopt._cintopt\n        intor = ao2mopt._intor\n    else:\n        cao2mopt = lib.c_null_ptr()\n        cintopt = make_cintopt(c_atm, c_bas, c_env, intor)\n    cintor = _fpointer(intor)\n\n    tao = numpy.asarray(tao, dtype=numpy.int32)\n    ao_loc = make_loc(bas, 'spinor')\n\n    fdrv = getattr(libao2mo, 'AO2MOr_e1_drv')\n    fill = _fpointer('AO2MOfill_r_' + aosym)\n    ftrans = _fpointer('AO2MOtranse1_r_' + aosym)\n    fdrv(cintor, fill, ftrans, fmmm,\n         out.ctypes.data_as(ctypes.c_void_p),\n         mo_coeff.ctypes.data_as(ctypes.c_void_p),\n         ctypes.c_int(klsh0), ctypes.c_int(klsh1-klsh0),\n         ctypes.c_int(nkl), ctypes.c_int(comp),\n         (ctypes.c_int*4)(*orbs_slice), tao.ctypes.data_as(ctypes.c_void_p),\n         ao_loc.ctypes.data_as(ctypes.c_void_p), cintopt, cao2mopt,\n         c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n         c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n         c_env.ctypes.data_as(ctypes.c_void_p))\n    return out\n\n# if out is not None, transform AO to MO in-place\n# ao_loc has nbas+1 elements, last element in ao_loc == nao\ndef r_e2(eri, mo_coeff, orbs_slice, tao, ao_loc, aosym='s1', out=None):\n    assert(eri.flags.c_contiguous)\n    assert(aosym in ('s4', 's2ij', 's2kl', 's1', 'a2ij', 'a2kl', 'a4ij',\n                     'a4kl', 'a4'))\n    mo_coeff = numpy.asarray(mo_coeff, dtype=numpy.complex128, order='F')\n    nao = mo_coeff.shape[0]\n    k0, k1, l0, l1 = orbs_slice\n    kc = k1 - k0\n    lc = l1 - l0\n    kl_count = kc * lc\n\n    if kc <= lc:\n        fmmm = _fpointer('AO2MOmmm_r_iltj')\n    else:\n        fmmm = _fpointer('AO2MOmmm_r_igtj')\n\n    nrow = eri.shape[0]\n    out = numpy.ndarray((nrow,kl_count), dtype=numpy.complex128, buffer=out)\n    if out.size == 0:\n        return out\n\n    tao = numpy.asarray(tao, dtype=numpy.int32)\n    if ao_loc is None:\n        c_ao_loc = ctypes.POINTER(ctypes.c_void_p)()\n        c_nbas = ctypes.c_int(0)\n        ftrans = _fpointer('AO2MOtranse2_r_' + aosym)\n    else:\n        ao_loc = numpy.asarray(ao_loc, dtype=numpy.int32)\n        c_ao_loc = ao_loc.ctypes.data_as(ctypes.c_void_p)\n        c_nbas = ctypes.c_int(ao_loc.shape[0]-1)\n        ftrans = _fpointer('AO2MOsortranse2_r_' + aosym)\n\n    fdrv = getattr(libao2mo, 'AO2MOr_e2_drv')\n    fdrv(ftrans, fmmm,\n         out.ctypes.data_as(ctypes.c_void_p),\n         eri.ctypes.data_as(ctypes.c_void_p),\n         mo_coeff.ctypes.data_as(ctypes.c_void_p),\n         ctypes.c_int(nrow), ctypes.c_int(nao),\n         (ctypes.c_int*4)(*orbs_slice),\n         tao.ctypes.data_as(ctypes.c_void_p), c_ao_loc, c_nbas)\n    return out\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/lib/vhf/test/test_nr_direct.py": "#!/usr/bin/env python\n# Copyright 2014-2018 The PySCF Developers. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport ctypes\nimport _ctypes\nimport unittest\nimport numpy\nfrom pyscf import lib\nfrom pyscf import scf\nfrom pyscf import gto\nfrom pyscf import ao2mo\n\nlibcvhf2 = lib.load_library('libcvhf')\n\nmol = gto.Mole()\nmol.verbose = 0\nmol.output = None#'out_h2o'\nmol.atom = [\n    ['O' , (0. , 0.     , 0.)],\n    [1   , (0. , -0.757 , 0.587)],\n    [1   , (0. , 0.757  , 0.587)] ]\n\nmol.basis = 'cc-pvdz'\n\nmol.build()\nrhf = scf.RHF(mol)\nrhf.scf()\n\n\nnao = mol.nao_nr()\nnpair = nao*(nao+1)//2\nc_atm = numpy.array(mol._atm, dtype=numpy.int32)\nc_bas = numpy.array(mol._bas, dtype=numpy.int32)\nc_env = numpy.array(mol._env)\nnatm = ctypes.c_int(c_atm.shape[0])\nnbas = ctypes.c_int(c_bas.shape[0])\ncvhfopt = lib.c_null_ptr()\ncintopt = lib.c_null_ptr()\nao_loc = numpy.asarray(mol.ao_loc_nr(), dtype=numpy.int32)\n# for each dm1, call namejk\ndef runjk(dm1, ncomp, intorname, filldot, *namejk):\n    fdrv = getattr(libcvhf2, 'CVHFnr_direct_drv')\n    intor = getattr(libcvhf2, intorname)\n    fdot = getattr(libcvhf2, filldot)\n\n    njk = len(namejk)\n    if dm1.ndim == 2:\n        n_dm = 1\n        dm1 = (dm1,)\n    else:\n        n_dm = dm1.shape[0]\n\n    vjk = numpy.zeros((njk,n_dm*ncomp,nao,nao))\n    fjk = (ctypes.c_void_p*(njk*n_dm))()\n    dmsptr = (ctypes.c_void_p*(njk*n_dm))()\n    vjkptr = (ctypes.c_void_p*(njk*n_dm))()\n    for i, symb in enumerate(namejk):\n        f1 = ctypes.c_void_p(_ctypes.dlsym(libcvhf2._handle, symb))\n        for j in range(n_dm):\n            dmsptr[i*n_dm+j] = dm1[j].ctypes.data_as(ctypes.c_void_p)\n            vjkptr[i*n_dm+j] = vjk[i,j*ncomp].ctypes.data_as(ctypes.c_void_p)\n            fjk[i*n_dm+j] = f1\n    shls_slice = (ctypes.c_int*8)(*([0, mol.nbas]*4))\n\n    fdrv(intor, fdot, fjk, dmsptr, vjkptr,\n         ctypes.c_int(njk*n_dm), ctypes.c_int(ncomp),\n         shls_slice, ao_loc.ctypes.data_as(ctypes.c_void_p),\n         cintopt, cvhfopt,\n         c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n         c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n         c_env.ctypes.data_as(ctypes.c_void_p))\n    if n_dm * ncomp == 1:\n        vjk = vjk.reshape(njk,nao,nao)\n    return vjk\n\ndef runjks2(dm1, ncomp, intorname, filldot, *namejk):\n    vjk = runjk(dm1, ncomp, intorname, filldot, *namejk)\n    return [lib.hermi_triu(v, 1) for v in vjk]\n\ndef makeri(fname, comp):\n    nao = mol.nao_nr()\n    eri = numpy.empty((comp,nao,nao,nao,nao))\n    ip = 0\n    for i in range(mol.nbas):\n        jp = 0\n        for j in range(mol.nbas):\n            kp = 0\n            for k in range(mol.nbas):\n                lp = 0\n                for l in range(mol.nbas):\n                    buf = gto.moleintor.getints_by_shell(fname, (i,j,k,l), mol._atm,\n                                                         mol._bas, mol._env, comp)\n                    di,dj,dk,dl = buf.shape[1:]\n                    eri[:,ip:ip+di,jp:jp+dj,kp:kp+dk,lp:lp+dl] = buf\n                    lp += dl\n                kp += dk\n            jp += dj\n        ip += di\n    return eri\n\n\nclass KnowValues(unittest.TestCase):\n    def test_direct_jk_s1(self):\n        numpy.random.seed(15)\n\n        dm1 = numpy.random.random((nao,nao))\n        dm1 = dm1 + dm1.T\n        vj0, vk0 = scf._vhf.incore(rhf._eri, dm1, 1)\n        vj1, vk1 = runjk(dm1, 1, 'int2e_sph', 'CVHFdot_nrs8',\n                         'CVHFnrs8_ji_s1kl', 'CVHFnrs8_jk_s1il')\n        self.assertTrue(numpy.allclose(vj0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vk1))\n\n        dm1 = numpy.array((dm1,dm1))\n        vj1, vk1 = runjk(dm1, 1, 'int2e_sph', 'CVHFdot_nrs8',\n                         'CVHFnrs8_ji_s1kl', 'CVHFnrs8_jk_s1il')\n        self.assertTrue(numpy.allclose(vj0,vj1[0]))\n        self.assertTrue(numpy.allclose(vk0,vk1[0]))\n        self.assertTrue(numpy.allclose(vj0,vj1[1]))\n        self.assertTrue(numpy.allclose(vk0,vk1[1]))\n\n        dm1 = numpy.random.random((nao,nao))\n        eri1 = ao2mo.restore(1, rhf._eri, nao)\n        vj0 = numpy.einsum('ijkl,kl->ij', eri1, dm1)\n        vk0 = numpy.einsum('ijkl,jk->il', eri1, dm1)\n        vj1, vj2 = runjk(dm1, 1, 'int2e_sph', 'CVHFdot_nrs4',\n                         'CVHFnrs4_ji_s1kl', 'CVHFnrs4_jk_s1il')\n        self.assertTrue(numpy.allclose(vj0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vj2))\n\n        vk1 = runjk(dm1, 1, 'int2e_sph', 'CVHFdot_nrs4',\n                    'CVHFnrs4_li_s1kj', 'CVHFnrs4_jk_s1il')\n        self.assertTrue(numpy.allclose(vk0,vk1[0]))\n        self.assertTrue(numpy.allclose(vk0,vk1[1]))\n\n        dm1 = dm1 + dm1.T\n        vk0 = numpy.einsum('ijkl,jk->il', eri1, dm1)\n        vk1 = runjk(dm1, 1, 'int2e_sph', 'CVHFdot_nrs4',\n                    'CVHFnrs4_li_s1kj', 'CVHFnrs4_jk_s1il',\n                    'CVHFnrs4_li_s1kj', 'CVHFnrs4_jk_s1il')\n        self.assertTrue(numpy.allclose(vk0,vk1[0]))\n        self.assertTrue(numpy.allclose(vk0,vk1[1]))\n        self.assertTrue(numpy.allclose(vk0,vk1[2]))\n        self.assertTrue(numpy.allclose(vk0,vk1[3]))\n\n        dm1 = numpy.random.random((nao,nao))\n        vj0 = numpy.einsum('ijkl,kl->ij', eri1, dm1)\n        vk0 = numpy.einsum('ijkl,jk->il', eri1, dm1)\n        vk1 = runjk(dm1, 1, 'int2e_sph', 'CVHFdot_nrs2kl',\n                    'CVHFnrs2kl_ji_s1kl', 'CVHFnrs2kl_lk_s1ij',\n                    'CVHFnrs2kl_jk_s1il', 'CVHFnrs2kl_li_s1kj')\n        self.assertTrue(numpy.allclose(vj0,vk1[0]))\n        self.assertTrue(numpy.allclose(vj0,vk1[1]))\n        self.assertTrue(numpy.allclose(vk0,vk1[2]))\n        self.assertTrue(numpy.allclose(vk0,vk1[3]))\n\n        vk1 = runjk(dm1, 1, 'int2e_sph', 'CVHFdot_nrs2ij',\n                    'CVHFnrs2ij_ji_s1kl', 'CVHFnrs2ij_lk_s1ij',\n                    'CVHFnrs2ij_jk_s1il', 'CVHFnrs2ij_li_s1kj')\n        self.assertTrue(numpy.allclose(vj0,vk1[0]))\n        self.assertTrue(numpy.allclose(vj0,vk1[1]))\n        self.assertTrue(numpy.allclose(vk0,vk1[2]))\n        self.assertTrue(numpy.allclose(vk0,vk1[3]))\n\n        vk1 = runjk(dm1, 1, 'int2e_sph', 'CVHFdot_nrs1',\n                    'CVHFnrs1_ji_s1kl', 'CVHFnrs1_lk_s1ij',\n                    'CVHFnrs1_jk_s1il', 'CVHFnrs1_li_s1kj')\n        self.assertTrue(numpy.allclose(vj0,vk1[0]))\n        self.assertTrue(numpy.allclose(vj0,vk1[1]))\n        self.assertTrue(numpy.allclose(vk0,vk1[2]))\n        self.assertTrue(numpy.allclose(vk0,vk1[3]))\n\n    def test_direct_jk_ncomp_s1(self):\n        numpy.random.seed(15)\n        dm1 = numpy.random.random((nao,nao))\n        dm1 = dm1 + dm1.T\n        eri0 = makeri('int2e_ip1_sph', 3)\n        vj0 = numpy.einsum('pijkl,ji->pkl', eri0, dm1)\n        vk0 = numpy.einsum('pijkl,li->pkj', eri0, dm1)\n        vj1, vk1 = runjk(dm1, 3, 'int2e_ip1_sph', 'CVHFdot_nrs1',\n                         'CVHFnrs1_ji_s1kl', 'CVHFnrs1_li_s1kj')\n        self.assertTrue(numpy.allclose(vj0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vk1))\n\n        vj1, vk1 = runjk(dm1, 3, 'int2e_ip1_sph', 'CVHFdot_nrs2kl',\n                       'CVHFnrs2kl_ji_s1kl', 'CVHFnrs2kl_li_s1kj')\n        self.assertTrue(numpy.allclose(vj0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vk1))\n\n        eri0 = makeri('int2e_ig1_sph', 3)\n        vj0 = numpy.einsum('pijkl,ji->pkl', eri0, dm1)\n        vk0 = numpy.einsum('pijkl,li->pkj', eri0, dm1)\n        vj1, vk1 = runjk(dm1, 3, 'int2e_ig1_sph', 'CVHFdot_nrs1',\n                         'CVHFnrs1_ji_s1kl', 'CVHFnrs1_li_s1kj')\n        self.assertTrue(numpy.allclose(vj0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vk1))\n\n        vj1, vk1 = runjk(dm1, 3, 'int2e_ig1_sph', 'CVHFdot_nrs2kl',\n                       'CVHFnrs2kl_ji_s1kl', 'CVHFnrs2kl_li_s1kj')\n        self.assertTrue(numpy.allclose(vj0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vk1))\n\n        vj1, vk1 = runjk(dm1, 3, 'int2e_ig1_sph', 'CVHFdot_nrs4',\n                       'CVHFnra4ij_ji_s1kl', 'CVHFnra4ij_li_s1kj')\n        self.assertTrue(numpy.allclose(vj0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vk1))\n\n    def test_direct_jk_s2(self):\n        numpy.random.seed(15)\n\n        dm1 = numpy.random.random((nao,nao))\n        dm1 = dm1 + dm1.T\n        vj0, vk0 = scf._vhf.incore(rhf._eri, dm1, 1)\n        vj1, vk1 = runjks2(dm1, 1, 'int2e_sph', 'CVHFdot_nrs8',\n                         'CVHFnrs8_ji_s2kl', 'CVHFnrs8_jk_s2il')\n        self.assertTrue(numpy.allclose(vj0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vk1))\n\n        eri1 = ao2mo.restore(1, rhf._eri, nao)\n        vj0 = numpy.einsum('ijkl,kl->ij', eri1, dm1)\n        vk0 = numpy.einsum('ijkl,jk->il', eri1, dm1)\n        vj1, vj2 = runjks2(dm1, 1, 'int2e_sph', 'CVHFdot_nrs4',\n                         'CVHFnrs4_ji_s2kl', 'CVHFnrs4_jk_s2il')\n        self.assertTrue(numpy.allclose(vj0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vj2))\n\n        vj1, vk1 = runjks2(dm1, 1, 'int2e_sph', 'CVHFdot_nrs4',\n                           'CVHFnrs4_li_s2kj', 'CVHFnrs4_jk_s2il')\n        self.assertTrue(numpy.allclose(vk0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vk1))\n\n        vk0 = numpy.einsum('ijkl,jk->il', eri1, dm1)\n        vk1 = runjks2(dm1, 1, 'int2e_sph', 'CVHFdot_nrs4',\n                    'CVHFnrs4_li_s2kj', 'CVHFnrs4_jk_s2il',\n                    'CVHFnrs4_li_s2kj', 'CVHFnrs4_jk_s2il')\n        self.assertTrue(numpy.allclose(vk0,vk1[0]))\n        self.assertTrue(numpy.allclose(vk0,vk1[1]))\n        self.assertTrue(numpy.allclose(vk0,vk1[2]))\n        self.assertTrue(numpy.allclose(vk0,vk1[3]))\n\n        vj0 = numpy.einsum('ijkl,kl->ij', eri1, dm1)\n        vk0 = numpy.einsum('ijkl,jk->il', eri1, dm1)\n        vk1 = runjks2(dm1, 1, 'int2e_sph', 'CVHFdot_nrs2kl',\n                    'CVHFnrs2kl_ji_s2kl', 'CVHFnrs2kl_lk_s2ij',\n                    'CVHFnrs2kl_jk_s2il', 'CVHFnrs2kl_li_s2kj')\n        self.assertTrue(numpy.allclose(vj0,vk1[0]))\n        self.assertTrue(numpy.allclose(vj0,vk1[1]))\n        self.assertTrue(numpy.allclose(vk0,vk1[2]))\n        self.assertTrue(numpy.allclose(vk0,vk1[3]))\n\n        vk1 = runjks2(dm1, 1, 'int2e_sph', 'CVHFdot_nrs2ij',\n                    'CVHFnrs2ij_ji_s2kl', 'CVHFnrs2ij_lk_s2ij',\n                    'CVHFnrs2ij_jk_s2il', 'CVHFnrs2ij_li_s2kj')\n        self.assertTrue(numpy.allclose(vj0,vk1[0]))\n        self.assertTrue(numpy.allclose(vj0,vk1[1]))\n        self.assertTrue(numpy.allclose(vk0,vk1[2]))\n        self.assertTrue(numpy.allclose(vk0,vk1[3]))\n\n        vk1 = runjks2(dm1, 1, 'int2e_sph', 'CVHFdot_nrs1',\n                    'CVHFnrs1_ji_s2kl', 'CVHFnrs1_lk_s2ij',\n                    'CVHFnrs1_jk_s2il', 'CVHFnrs1_li_s2kj')\n        self.assertTrue(numpy.allclose(vj0,vk1[0]))\n        self.assertTrue(numpy.allclose(vj0,vk1[1]))\n        self.assertTrue(numpy.allclose(vk0,vk1[2]))\n        self.assertTrue(numpy.allclose(vk0,vk1[3]))\n\n        vj0, vk0 = scf._vhf.incore(rhf._eri, dm1, 1)\n        vj1, vk1 = runjk(dm1, 1, 'int2e_sph', 'CVHFdot_nrs8',\n                         'CVHFnrs8_ji_s2kl', 'CVHFnrs8_jk_s2il')\n        vj1 = lib.hermi_triu(vj1, 1)\n        vk1 = lib.hermi_triu(vk1, 1)\n        self.assertTrue(numpy.allclose(vj0,vj1))\n        self.assertTrue(numpy.allclose(vk0,vk1))\n\n\n\nif __name__ == '__main__':\n    print('Full Tests for nr_direct')\n    unittest.main()\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/scf/_vhf.py": "#!/usr/bin/env python\n# Copyright 2014-2018 The PySCF Developers. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport sys\nimport ctypes\nimport _ctypes\nimport numpy\nfrom pyscf import lib\nfrom pyscf import gto\nfrom pyscf.gto.moleintor import make_cintopt, make_loc, ascint3\n\nlibcvhf = lib.load_library('libcvhf')\ndef _fpointer(name):\n    return ctypes.c_void_p(_ctypes.dlsym(libcvhf._handle, name))\n\nclass VHFOpt(object):\n    def __init__(self, mol, intor,\n                 prescreen='CVHFnoscreen', qcondname=None, dmcondname=None):\n        '''If function \"qcondname\" is presented, the qcond (sqrt(integrals))\n        and will be initialized in __init__.\n        '''\n        intor = mol._add_suffix(intor)\n        self._this = ctypes.POINTER(_CVHFOpt)()\n        #print self._this.contents, expect ValueError: NULL pointer access\n        self._intor = intor\n        self._cintopt = make_cintopt(mol._atm, mol._bas, mol._env, intor)\n        self._dmcondname = dmcondname\n        natm = ctypes.c_int(mol.natm)\n        nbas = ctypes.c_int(mol.nbas)\n        libcvhf.CVHFinit_optimizer(ctypes.byref(self._this),\n                                   mol._atm.ctypes.data_as(ctypes.c_void_p), natm,\n                                   mol._bas.ctypes.data_as(ctypes.c_void_p), nbas,\n                                   mol._env.ctypes.data_as(ctypes.c_void_p))\n        self.prescreen = prescreen\n        if qcondname is not None:\n            self.init_cvhf_direct(mol, intor, qcondname)\n\n    def init_cvhf_direct(self, mol, intor, qcondname):\n        intor = mol._add_suffix(intor)\n        if intor == self._intor:\n            cintopt = self._cintopt\n        else:\n            cintopt = lib.c_null_ptr()\n        ao_loc = make_loc(mol._bas, intor)\n        fsetqcond = getattr(libcvhf, qcondname)\n        natm = ctypes.c_int(mol.natm)\n        nbas = ctypes.c_int(mol.nbas)\n        fsetqcond(self._this, getattr(libcvhf, intor), cintopt,\n                  ao_loc.ctypes.data_as(ctypes.c_void_p),\n                  mol._atm.ctypes.data_as(ctypes.c_void_p), natm,\n                  mol._bas.ctypes.data_as(ctypes.c_void_p), nbas,\n                  mol._env.ctypes.data_as(ctypes.c_void_p))\n\n    @property\n    def direct_scf_tol(self):\n        return self._this.contents.direct_scf_cutoff\n    @direct_scf_tol.setter\n    def direct_scf_tol(self, v):\n        self._this.contents.direct_scf_cutoff = v\n\n    @property\n    def prescreen(self):\n        return self._this.contents.fprescreen\n    @prescreen.setter\n    def prescreen(self, v):\n        if isinstance(v, int):\n            self._this.contents.fprescreen = v\n        else:\n            self._this.contents.fprescreen = _fpointer(v)\n\n    def set_dm(self, dm, atm, bas, env):\n        if self._dmcondname is not None:\n            c_atm = numpy.asarray(atm, dtype=numpy.int32, order='C')\n            c_bas = numpy.asarray(bas, dtype=numpy.int32, order='C')\n            c_env = numpy.asarray(env, dtype=numpy.double, order='C')\n            natm = ctypes.c_int(c_atm.shape[0])\n            nbas = ctypes.c_int(c_bas.shape[0])\n            if isinstance(dm, numpy.ndarray) and dm.ndim == 2:\n                n_dm = 1\n            else:\n                n_dm = len(dm)\n            dm = numpy.asarray(dm, order='C')\n            ao_loc = make_loc(c_bas, self._intor)\n            fsetdm = getattr(libcvhf, self._dmcondname)\n            fsetdm(self._this,\n                   dm.ctypes.data_as(ctypes.c_void_p), ctypes.c_int(n_dm),\n                   ao_loc.ctypes.data_as(ctypes.c_void_p),\n                   c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n                   c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n                   c_env.ctypes.data_as(ctypes.c_void_p))\n\n    def __del__(self):\n        try:\n            libcvhf.CVHFdel_optimizer(ctypes.byref(self._this))\n        except AttributeError:\n            pass\n\n    def get_q_cond(self, shape=None):\n        '''Return an array associated to q_cond. Contents of q_cond can be\n        modified through this array\n        '''\n        if shape is None:\n            nbas = self._this.contents.nbas\n            shape = (nbas, nbas)\n        data = ctypes.cast(self._this.contents.q_cond,\n                           ctypes.POINTER(ctypes.c_double))\n        return numpy.ctypeslib.as_array(data, shape=shape)\n    q_cond = property(get_q_cond)\n\n    def get_dm_cond(self, shape=None):\n        '''Return an array associated to dm_cond. Contents of dm_cond can be\n        modified through this array\n        '''\n        if shape is None:\n            nbas = self._this.contents.nbas\n            shape = (nbas, nbas)\n        data = ctypes.cast(self._this.contents.dm_cond,\n                           ctypes.POINTER(ctypes.c_double))\n        return numpy.ctypeslib.as_array(data, shape=shape)\n    dm_cond = property(get_dm_cond)\n\nclass _CVHFOpt(ctypes.Structure):\n    _fields_ = [('nbas', ctypes.c_int),\n                ('_padding', ctypes.c_int),\n                ('direct_scf_cutoff', ctypes.c_double),\n                ('q_cond', ctypes.c_void_p),\n                ('dm_cond', ctypes.c_void_p),\n                ('fprescreen', ctypes.c_void_p),\n                ('r_vkscreen', ctypes.c_void_p)]\n\n################################################\n# for general DM\n# hermi = 0 : arbitary\n# hermi = 1 : hermitian\n# hermi = 2 : anti-hermitian\n################################################\ndef incore(eri, dms, hermi=0, with_j=True, with_k=True):\n    assert(eri.dtype == numpy.double)\n    eri = numpy.asarray(eri, order='C')\n    dms = numpy.asarray(dms, order='C')\n    dms_shape = dms.shape\n    nao = dms_shape[-1]\n\n    dms = dms.reshape(-1,nao,nao)\n    n_dm = dms.shape[0]\n\n    vj = vk = None\n    if with_j:\n        vj = numpy.zeros((n_dm,nao,nao))\n    if with_k:\n        vk = numpy.zeros((n_dm,nao,nao))\n\n    dmsptr = []\n    vjkptr = []\n    fjkptr = []\n\n    npair = nao*(nao+1)//2\n    if eri.ndim == 2 and npair*npair == eri.size: # 4-fold symmetry eri\n        fdrv = getattr(libcvhf, 'CVHFnrs4_incore_drv')\n        if with_j:\n            # 'ijkl,kl->ij'\n            fvj = _fpointer('CVHFics4_kl_s2ij')\n            # or\n            ## 'ijkl,ij->kl'\n            #fvj = _fpointer('CVHFics4_ij_s2kl')\n            for i, dm in enumerate(dms):\n                dmsptr.append(dm.ctypes.data_as(ctypes.c_void_p))\n                vjkptr.append(vj[i].ctypes.data_as(ctypes.c_void_p))\n                fjkptr.append(fvj)\n        if with_k:\n            # 'ijkl,il->jk'\n            fvk = _fpointer('CVHFics4_il_s1jk')\n            # or\n            ## 'ijkl,jk->il'\n            #fvk = _fpointer('CVHFics4_jk_s1il')\n            for i, dm in enumerate(dms):\n                dmsptr.append(dm.ctypes.data_as(ctypes.c_void_p))\n                vjkptr.append(vk[i].ctypes.data_as(ctypes.c_void_p))\n                fjkptr.append(fvk)\n\n    elif eri.ndim == 1 and npair*(npair+1)//2 == eri.size: # 8-fold symmetry eri\n        fdrv = getattr(libcvhf, 'CVHFnrs8_incore_drv')\n        if with_j:\n            fvj = _fpointer('CVHFics8_tridm_vj')\n            tridms = lib.pack_tril(lib.hermi_sum(dms, axes=(0,2,1)))\n            idx = numpy.arange(nao)\n            tridms[:,idx*(idx+1)//2+idx] *= .5\n            for i, tridm in enumerate(tridms):\n                dmsptr.append(tridm.ctypes.data_as(ctypes.c_void_p))\n                vjkptr.append(vj[i].ctypes.data_as(ctypes.c_void_p))\n                fjkptr.append(fvj)\n        if with_k:\n            if hermi == 1:\n                fvk = _fpointer('CVHFics8_jk_s2il')\n            else:\n                fvk = _fpointer('CVHFics8_jk_s1il')\n            for i, dm in enumerate(dms):\n                dmsptr.append(dm.ctypes.data_as(ctypes.c_void_p))\n                vjkptr.append(vk[i].ctypes.data_as(ctypes.c_void_p))\n                fjkptr.append(fvk)\n    else:\n        raise RuntimeError('Array shape not consistent: DM %s, eri %s'\n                           % (dms_shape, eri.shape))\n\n    n_ops = len(dmsptr)\n    fdrv(eri.ctypes.data_as(ctypes.c_void_p),\n         (ctypes.c_void_p*n_ops)(*dmsptr), (ctypes.c_void_p*n_ops)(*vjkptr),\n         ctypes.c_int(n_ops), ctypes.c_int(nao),\n         (ctypes.c_void_p*n_ops)(*fjkptr))\n\n    if with_j:\n        for i in range(n_dm):\n            lib.hermi_triu(vj[i], 1, inplace=True)\n        vj = vj.reshape(dms_shape)\n    if with_k:\n        if hermi != 0:\n            for i in range(n_dm):\n                lib.hermi_triu(vk[i], hermi, inplace=True)\n        vk = vk.reshape(dms_shape)\n    return vj, vk\n\n# use int2e_sph as cintor, CVHFnrs8_ij_s2kl, CVHFnrs8_jk_s2il as fjk to call\n# direct_mapdm\ndef direct(dms, atm, bas, env, vhfopt=None, hermi=0, cart=False,\n           with_j=True, with_k=True):\n    c_atm = numpy.asarray(atm, dtype=numpy.int32, order='C')\n    c_bas = numpy.asarray(bas, dtype=numpy.int32, order='C')\n    c_env = numpy.asarray(env, dtype=numpy.double, order='C')\n    natm = ctypes.c_int(c_atm.shape[0])\n    nbas = ctypes.c_int(c_bas.shape[0])\n\n    dms = numpy.asarray(dms, order='C')\n    dms_shape = dms.shape\n    nao = dms_shape[-1]\n    dms = dms.reshape(-1,nao,nao)\n    n_dm = dms.shape[0]\n\n    if vhfopt is None:\n        if cart:\n            intor = 'int2e_cart'\n        else:\n            intor = 'int2e_sph'\n        cintopt = make_cintopt(c_atm, c_bas, c_env, intor)\n        cvhfopt = lib.c_null_ptr()\n    else:\n        vhfopt.set_dm(dms, atm, bas, env)\n        cvhfopt = vhfopt._this\n        cintopt = vhfopt._cintopt\n        intor = vhfopt._intor\n    cintor = _fpointer(intor)\n\n    fdrv = getattr(libcvhf, 'CVHFnr_direct_drv')\n    fdot = _fpointer('CVHFdot_nrs8')\n\n    vj = vk = None\n    dmsptr = []\n    vjkptr = []\n    fjk = []\n\n    if with_j:\n        fvj = _fpointer('CVHFnrs8_ji_s2kl')\n        vj = numpy.empty((n_dm,nao,nao))\n        for i, dm in enumerate(dms):\n            dmsptr.append(dm.ctypes.data_as(ctypes.c_void_p))\n            vjkptr.append(vj[i].ctypes.data_as(ctypes.c_void_p))\n            fjk.append(fvj)\n\n    if with_k:\n        if hermi == 1:\n            fvk = _fpointer('CVHFnrs8_li_s2kj')\n        else:\n            fvk = _fpointer('CVHFnrs8_li_s1kj')\n        vk = numpy.empty((n_dm,nao,nao))\n        for i, dm in enumerate(dms):\n            dmsptr.append(dm.ctypes.data_as(ctypes.c_void_p))\n            vjkptr.append(vk[i].ctypes.data_as(ctypes.c_void_p))\n            fjk.append(fvk)\n\n    shls_slice = (ctypes.c_int*8)(*([0, c_bas.shape[0]]*4))\n    ao_loc = make_loc(bas, intor)\n    n_ops = len(dmsptr)\n    comp = 1\n    fdrv(cintor, fdot, (ctypes.c_void_p*n_ops)(*fjk),\n         (ctypes.c_void_p*n_ops)(*dmsptr), (ctypes.c_void_p*n_ops)(*vjkptr),\n         ctypes.c_int(n_ops), ctypes.c_int(comp),\n         shls_slice, ao_loc.ctypes.data_as(ctypes.c_void_p), cintopt, cvhfopt,\n         c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n         c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n         c_env.ctypes.data_as(ctypes.c_void_p))\n\n    if with_j:\n        # vj must be symmetric\n        for i in range(n_dm):\n            lib.hermi_triu(vj[i], 1, inplace=True)\n        vj = vj.reshape(dms_shape)\n    if with_k:\n        if hermi != 0:\n            for i in range(n_dm):\n                lib.hermi_triu(vk[i], hermi, inplace=True)\n        vk = vk.reshape(dms_shape)\n    return vj, vk\n\n# call all fjk for each dm, the return array has len(dms)*len(jkdescript)*ncomp components\n# jkdescript: 'ij->s1kl', 'kl->s2ij', ...\ndef direct_mapdm(intor, aosym, jkdescript,\n                 dms, ncomp, atm, bas, env, vhfopt=None, cintopt=None,\n                 shls_slice=None):\n    assert(aosym in ('s8', 's4', 's2ij', 's2kl', 's1',\n                     'aa4', 'a4ij', 'a4kl', 'a2ij', 'a2kl'))\n    intor = ascint3(intor)\n    c_atm = numpy.asarray(atm, dtype=numpy.int32, order='C')\n    c_bas = numpy.asarray(bas, dtype=numpy.int32, order='C')\n    c_env = numpy.asarray(env, dtype=numpy.double, order='C')\n    natm = ctypes.c_int(c_atm.shape[0])\n    nbas = ctypes.c_int(c_bas.shape[0])\n\n    if isinstance(dms, numpy.ndarray) and dms.ndim == 2:\n        dms = dms[numpy.newaxis,:,:]\n    n_dm = len(dms)\n    dms = [numpy.asarray(dm, order='C') for dm in dms]\n    if isinstance(jkdescript, str):\n        jkdescripts = (jkdescript,)\n    else:\n        jkdescripts = jkdescript\n    njk = len(jkdescripts)\n\n    if vhfopt is None:\n        cintor = _fpointer(intor)\n        cvhfopt = lib.c_null_ptr()\n    else:\n        vhfopt.set_dm(dms, atm, bas, env)\n        cvhfopt = vhfopt._this\n        cintopt = vhfopt._cintopt\n        cintor = getattr(libcvhf, vhfopt._intor)\n    if cintopt is None:\n        cintopt = make_cintopt(c_atm, c_bas, c_env, intor)\n\n    fdrv = getattr(libcvhf, 'CVHFnr_direct_drv')\n    dotsym = _INTSYMAP[aosym]\n    fdot = _fpointer('CVHFdot_nr'+dotsym)\n\n    if shls_slice is None:\n        shls_slice = (0, c_bas.shape[0])*4\n    ao_loc = make_loc(bas, intor)\n\n    vjk = []\n    descr_sym = [x.split('->') for x in jkdescripts]\n    fjk = (ctypes.c_void_p*(njk*n_dm))()\n    dmsptr = (ctypes.c_void_p*(njk*n_dm))()\n    vjkptr = (ctypes.c_void_p*(njk*n_dm))()\n    for i, (dmsym, vsym) in enumerate(descr_sym):\n        if dmsym in ('ij', 'kl', 'il', 'kj'):\n            sys.stderr.write('not support DM description %s, transpose to %s\\n' %\n                             (dmsym, dmsym[::-1]))\n            dmsym = dmsym[::-1]\n        f1 = _fpointer('CVHFnr%s_%s_%s'%(aosym, dmsym, vsym))\n\n        vshape = (n_dm,ncomp) + get_dims(vsym[-2:], shls_slice, ao_loc)\n        vjk.append(numpy.empty(vshape))\n        for j in range(n_dm):\n            if dms[j].shape != get_dims(dmsym, shls_slice, ao_loc):\n                raise RuntimeError('dm[%d] shape %s is inconsistent with the '\n                                   'shls_slice shape %s' %\n                                   (j, dms[j].shape, get_dims(dmsym, shls_slice, ao_loc)))\n            dmsptr[i*n_dm+j] = dms[j].ctypes.data_as(ctypes.c_void_p)\n            vjkptr[i*n_dm+j] = vjk[i][j].ctypes.data_as(ctypes.c_void_p)\n            fjk[i*n_dm+j] = f1\n    shls_slice = (ctypes.c_int*8)(*shls_slice)\n\n    fdrv(cintor, fdot, fjk, dmsptr, vjkptr,\n         ctypes.c_int(njk*n_dm), ctypes.c_int(ncomp),\n         shls_slice, ao_loc.ctypes.data_as(ctypes.c_void_p), cintopt, cvhfopt,\n         c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n         c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n         c_env.ctypes.data_as(ctypes.c_void_p))\n\n    if n_dm * ncomp == 1:\n        vjk = [v.reshape(v.shape[2:]) for v in vjk]\n    elif n_dm == 1:\n        vjk = [v.reshape((ncomp,)+v.shape[2:]) for v in vjk]\n    elif ncomp == 1:\n        vjk = [v.reshape((n_dm,)+v.shape[2:]) for v in vjk]\n    if isinstance(jkdescript, str):\n        vjk = vjk[0]\n    return vjk\n\n# for density matrices in dms, bind each dm to a jk operator\n# jkdescript: 'ij->s1kl', 'kl->s2ij', ...\ndef direct_bindm(intor, aosym, jkdescript,\n                 dms, ncomp, atm, bas, env, vhfopt=None, cintopt=None,\n                 shls_slice=None):\n    assert(aosym in ('s8', 's4', 's2ij', 's2kl', 's1',\n                     'aa4', 'a4ij', 'a4kl', 'a2ij', 'a2kl'))\n    intor = ascint3(intor)\n    c_atm = numpy.asarray(atm, dtype=numpy.int32, order='C')\n    c_bas = numpy.asarray(bas, dtype=numpy.int32, order='C')\n    c_env = numpy.asarray(env, dtype=numpy.double, order='C')\n    natm = ctypes.c_int(c_atm.shape[0])\n    nbas = ctypes.c_int(c_bas.shape[0])\n\n    if isinstance(dms, numpy.ndarray) and dms.ndim == 2:\n        dms = dms[numpy.newaxis,:,:]\n    n_dm = len(dms)\n    dms = [numpy.asarray(dm, order='C') for dm in dms]\n    if isinstance(jkdescript, str):\n        jkdescripts = (jkdescript,)\n    else:\n        jkdescripts = jkdescript\n    njk = len(jkdescripts)\n    assert(njk == n_dm)\n\n    if vhfopt is None:\n        cintor = _fpointer(intor)\n        cvhfopt = lib.c_null_ptr()\n    else:\n        vhfopt.set_dm(dms, atm, bas, env)\n        cvhfopt = vhfopt._this\n        cintopt = vhfopt._cintopt\n        cintor = getattr(libcvhf, vhfopt._intor)\n    if cintopt is None:\n        cintopt = make_cintopt(c_atm, c_bas, c_env, intor)\n\n    fdrv = getattr(libcvhf, 'CVHFnr_direct_drv')\n    dotsym = _INTSYMAP[aosym]\n    fdot = _fpointer('CVHFdot_nr'+dotsym)\n\n    if shls_slice is None:\n        shls_slice = (0, c_bas.shape[0])*4\n    ao_loc = make_loc(bas, intor)\n\n    vjk = []\n    descr_sym = [x.split('->') for x in jkdescripts]\n    fjk = (ctypes.c_void_p*(n_dm))()\n    dmsptr = (ctypes.c_void_p*(n_dm))()\n    vjkptr = (ctypes.c_void_p*(n_dm))()\n    for i, (dmsym, vsym) in enumerate(descr_sym):\n        f1 = _fpointer('CVHFnr%s_%s_%s'%(aosym, dmsym, vsym))\n\n        if dms[i].shape != get_dims(dmsym, shls_slice, ao_loc):\n            raise RuntimeError('dm[%d] shape %s is inconsistent with the '\n                               'shls_slice shape %s' %\n                               (i, dms[i].shape, get_dims(dmsym, shls_slice, ao_loc)))\n        vshape = (ncomp,) + get_dims(vsym[-2:], shls_slice, ao_loc)\n        vjk.append(numpy.empty(vshape))\n        dmsptr[i] = dms[i].ctypes.data_as(ctypes.c_void_p)\n        vjkptr[i] = vjk[i].ctypes.data_as(ctypes.c_void_p)\n        fjk[i] = f1\n    shls_slice = (ctypes.c_int*8)(*shls_slice)\n\n    fdrv(cintor, fdot, fjk, dmsptr, vjkptr,\n         ctypes.c_int(n_dm), ctypes.c_int(ncomp),\n         shls_slice, ao_loc.ctypes.data_as(ctypes.c_void_p), cintopt, cvhfopt,\n         c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n         c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n         c_env.ctypes.data_as(ctypes.c_void_p))\n\n    if ncomp == 1:\n        vjk = [v.reshape(v.shape[1:]) for v in vjk]\n    if isinstance(jkdescript, str):\n        vjk = vjk[0]\n    return vjk\n\n\n# 8-fold permutation symmetry\ndef int2e_sph(atm, bas, env, cart=False):  # pragma: no cover\n    if cart:\n        intor = 'int2e_cart'\n    else:\n        intor = 'int2e_sph'\n    return gto.moleintor.getints4c(intor, atm, bas, env, aosym='s8')\n\n\n################################################################\n# relativistic\ndef rdirect_mapdm(intor, aosym, jkdescript,\n                  dms, ncomp, atm, bas, env, vhfopt=None, cintopt=None,\n                  shls_slice=None):\n    assert(aosym in ('s8', 's4', 's2ij', 's2kl', 's1',\n                     'a4ij', 'a4kl', 'a2ij', 'a2kl'))\n    intor = ascint3(intor)\n    c_atm = numpy.asarray(atm, dtype=numpy.int32, order='C')\n    c_bas = numpy.asarray(bas, dtype=numpy.int32, order='C')\n    c_env = numpy.asarray(env, dtype=numpy.double, order='C')\n    natm = ctypes.c_int(c_atm.shape[0])\n    nbas = ctypes.c_int(c_bas.shape[0])\n\n    if isinstance(dms, numpy.ndarray) and dms.ndim == 2:\n        dms = dms[numpy.newaxis,:,:]\n    n_dm = len(dms)\n    nao = dms[0].shape[0]\n    dms = numpy.asarray(dms, order='C', dtype=numpy.complex128)\n    if isinstance(jkdescript, str):\n        jkdescript = (jkdescript,)\n    njk = len(jkdescript)\n\n    if vhfopt is None:\n        cintor = _fpointer(intor)\n        cvhfopt = lib.c_null_ptr()\n    else:\n        vhfopt.set_dm(dms, atm, bas, env)\n        cvhfopt = vhfopt._this\n        cintopt = vhfopt._cintopt\n        cintor = getattr(libcvhf, vhfopt._intor)\n    if cintopt is None:\n        cintopt = make_cintopt(c_atm, c_bas, c_env, intor)\n\n    fdrv = getattr(libcvhf, 'CVHFr_direct_drv')\n    dotsym = _INTSYMAP[aosym]\n    fdot = _fpointer('CVHFdot_r'+dotsym)\n\n    if shls_slice is None:\n        shls_slice = (0, c_bas.shape[0])*4\n    else:\n        raise NotImplementedError\n    ao_loc = make_loc(bas, intor)\n\n    unpackas = _INTUNPACKMAP_R[aosym]\n    descr_sym = [x.split('->') for x in jkdescript]\n    fjk = (ctypes.c_void_p*(njk*n_dm))()\n    dm1 = (ctypes.c_void_p*(njk*n_dm))()\n    for i, (dmsym, vsym) in enumerate(descr_sym):\n        f1 = _fpointer('CVHFr%s_%s_%s'%(unpackas, dmsym, vsym))\n        for j in range(n_dm):\n            dm1[i*n_dm+j] = dms[j].ctypes.data_as(ctypes.c_void_p)\n            fjk[i*n_dm+j] = f1\n    vjk = numpy.empty((njk,n_dm*ncomp,nao,nao), dtype=numpy.complex)\n\n    fdrv(cintor, fdot, fjk, dm1,\n         vjk.ctypes.data_as(ctypes.c_void_p),\n         ctypes.c_int(njk*n_dm), ctypes.c_int(ncomp),\n         (ctypes.c_int*8)(*shls_slice),\n         ao_loc.ctypes.data_as(ctypes.c_void_p), cintopt, cvhfopt,\n         c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n         c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n         c_env.ctypes.data_as(ctypes.c_void_p))\n\n    if n_dm * ncomp == 1:\n        vjk = vjk.reshape(njk,nao,nao)\n    if njk == 1:\n        vjk = vjk.reshape(vjk.shape[1:])\n    return vjk\n\n# for density matrices in dms, bind each dm to a jk operator\ndef rdirect_bindm(intor, aosym, jkdescript,\n                  dms, ncomp, atm, bas, env, vhfopt=None, cintopt=None,\n                  shls_slice=None):\n    assert(aosym in ('s8', 's4', 's2ij', 's2kl', 's1',\n                     'a4ij', 'a4kl', 'a2ij', 'a2kl'))\n    intor = ascint3(intor)\n    c_atm = numpy.asarray(atm, dtype=numpy.int32, order='C')\n    c_bas = numpy.asarray(bas, dtype=numpy.int32, order='C')\n    c_env = numpy.asarray(env, dtype=numpy.double, order='C')\n    natm = ctypes.c_int(c_atm.shape[0])\n    nbas = ctypes.c_int(c_bas.shape[0])\n\n    if isinstance(dms, numpy.ndarray) and dms.ndim == 2:\n        dms = dms[numpy.newaxis,:,:]\n    n_dm = len(dms)\n    nao = dms[0].shape[0]\n    dms = numpy.asarray(dms, order='C', dtype=numpy.complex128)\n    if isinstance(jkdescript, str):\n        jkdescript = (jkdescript,)\n    njk = len(jkdescript)\n    assert(njk == n_dm)\n\n    if vhfopt is None:\n        cintor = _fpointer(intor)\n        cvhfopt = lib.c_null_ptr()\n    else:\n        vhfopt.set_dm(dms, atm, bas, env)\n        cvhfopt = vhfopt._this\n        cintopt = vhfopt._cintopt\n        cintor = getattr(libcvhf, vhfopt._intor)\n    if cintopt is None:\n        cintopt = make_cintopt(c_atm, c_bas, c_env, intor)\n\n    fdrv = getattr(libcvhf, 'CVHFr_direct_drv')\n    dotsym = _INTSYMAP[aosym]\n    fdot = _fpointer('CVHFdot_r'+dotsym)\n\n    if shls_slice is None:\n        shls_slice = (0, c_bas.shape[0])*4\n    else:\n        raise NotImplementedError\n    ao_loc = make_loc(bas, intor)\n\n    unpackas = _INTUNPACKMAP_R[aosym]\n    descr_sym = [x.split('->') for x in jkdescript]\n    fjk = (ctypes.c_void_p*(n_dm))()\n    dm1 = (ctypes.c_void_p*(n_dm))()\n    for i, (dmsym, vsym) in enumerate(descr_sym):\n        f1 = _fpointer('CVHFr%s_%s_%s'%(unpackas, dmsym, vsym))\n        dm1[i] = dms[i].ctypes.data_as(ctypes.c_void_p)\n        fjk[i] = f1\n    vjk = numpy.empty((njk,ncomp,nao,nao), dtype=numpy.complex)\n\n    fdrv(cintor, fdot, fjk, dm1,\n         vjk.ctypes.data_as(ctypes.c_void_p),\n         ctypes.c_int(n_dm), ctypes.c_int(ncomp),\n         (ctypes.c_int*8)(*shls_slice),\n         ao_loc.ctypes.data_as(ctypes.c_void_p), cintopt, cvhfopt,\n         c_atm.ctypes.data_as(ctypes.c_void_p), natm,\n         c_bas.ctypes.data_as(ctypes.c_void_p), nbas,\n         c_env.ctypes.data_as(ctypes.c_void_p))\n\n    if ncomp == 1:\n        vjk = vjk.reshape(njk,nao,nao)\n    if njk == 1:\n        vjk = vjk.reshape(vjk.shape[1:])\n    return vjk\n\n# 'a4ij': anti-symm between ij, symm between kl\n# 'a4kl': anti-symm between kl, symm between ij\n# 'a2ij': anti-symm between ij,\n# 'a2kl': anti-symm between kl,\n_INTSYMAP= {\n    's8'  : 's8'  ,\n    's4'  : 's4'  ,\n    's2ij': 's2ij',\n    's2kl': 's2kl',\n    's1'  : 's1'  ,\n    'aa4' : 's4'  ,\n    'a4ij': 's4'  ,\n    'a4kl': 's4'  ,\n    'a2ij': 's2ij',\n    'a2kl': 's2kl',\n}\n\n_INTUNPACKMAP_R = {\n    's8'  : 's8'  ,\n    's4'  : 's4'  ,\n    's2ij': 's2ij',\n    's2kl': 's2kl',\n    's1'  : 's1'  ,\n    'a4ij': 'ah4'  ,\n    'a4kl': 'ha4'  ,\n    'a2ij': 'ah2ij',\n    'a2kl': 'ha2kl',\n}\n\n_SHLINDEX = {'i': 0, 'j': 2, 'k': 4, 'l': 6}\ndef get_dims(descr_sym, shls_slice, ao_loc):\n    i = _SHLINDEX[descr_sym[0]]\n    j = _SHLINDEX[descr_sym[1]]\n    di = ao_loc[shls_slice[i+1]] - ao_loc[shls_slice[i]]\n    dj = ao_loc[shls_slice[j+1]] - ao_loc[shls_slice[j]]\n    return (di,dj)\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/.git/objects/pack/pack-711da927b7feefe896cb8e7efc569c798b6d9bee.idx",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/.git/objects/pack/pack-711da927b7feefe896cb8e7efc569c798b6d9bee.pack",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/doc_legacy/logo/logo-32x32.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/doc_legacy/logo/logo-64x64.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/doc_legacy/logo/pyscf-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/examples/fci/spin_op_hamiltonian.h5",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/df/test/test_df_jk.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/pbc/tdscf/test/frozen_test_cderi.h5",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/pbc/gw/test/frozen_test_cderi.h5",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/fci/test/spin_op_hamiltonian.h5",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/n2.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/water.PLD",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/water.DIM",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/water_sz.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/li.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/n2.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/oxygen.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/water.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/lih.DIM",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/oxygen.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/water.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/water_sz.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/li.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/lih.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/water.scfout",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/lih.PLD",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/lih.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/tddft_iter_output_water_ref.hdf5",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/ice/siesta.PLD",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/ice/siesta.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/ice/siesta.DIM",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/ice/siesta.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/S2_triplet/S2.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/S2_triplet/S2.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/test_ag13_noghost/siesta.PLD",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/test_ag13_noghost/siesta.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/test_ag13_noghost/siesta.DIM",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/test_ag13_noghost/siesta.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/test_ag13_ghost/siesta.PLD",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/test_ag13_ghost/siesta.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/test_ag13_ghost/siesta.DIM",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/test_ag13_ghost/siesta.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/sodium_20/siesta.PLD",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/sodium_20/siesta.HSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/sodium_20/siesta.DIM",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/nao/test/sodium_20/siesta.fullBZ.WFSX",
        "/tmp/vanessa/spack-stage/spack-stage-py-pyscf-1.7.5-cvc2mfd6y5ybb2v6z5vc336m2ipmtzom/spack-src/pyscf/dft/test/dm_h4.npy"
    ],
    "total_files": 2644
}