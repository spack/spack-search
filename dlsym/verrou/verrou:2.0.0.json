{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/glibc-2.2.supp": "\n##----------------------------------------------------------------------##\n\n# Errors to suppress by default with glibc 2.2.4 / 2.2.5\n\n# Format of this file is:\n# {\n#     name_of_suppression\n#     tool_name:supp_kind\n#     (optional extra info for some suppression types)\n#     caller0 name, or /name/of/so/file.so\n#     caller1 name, or ditto\n#     (optionally: caller2 name)\n#     (optionally: caller3 name)\n#  }\n#\n# For Memcheck, the supp_kinds are:\n#\n#     Param Value1 Value2 Value4 Value8 Value16 Jump\n#     Free Addr1 Addr2 Addr4 Addr8 Addr16\n#     Cond (previously known as Value0)\n#\n# and the optional extra info is:\n#     if Param: name of system call param\n\n#-------- For SuSE 8.2 (gcc 3.3, glibc 2.3.2)\n{\n   __GI___stpcpy/*\n   Memcheck:Cond\n   fun:__GI___stpcpy\n   fun:*\n}\n{\n   strlen/__GI__dl_open/dlopen_doit\n   Memcheck:Cond\n   fun:strlen\n   fun:__GI__dl_open\n   fun:dlopen_doit\n}\n{\n   strlen/_dl_signal_cerror/_dl_lookup_symbol_internal/do_dlsym\n   Memcheck:Cond\n   fun:_dl_signal_cerror\n   fun:_dl_lookup_symbol_internal\n   fun:do_dlsym\n}\n\n\n#-------- For R H 8.0\n{\n   elf_dynamic_do_rel.7/_dl_relocate_object_internal/dl_open_worker(Cond)\n   Memcheck:Cond\n   fun:elf_dynamic_do_rel.7\n   fun:_dl_relocate_object_internal\n   fun:dl_open_worker\n}\n\n\n#-------- For R H 7.3 on i686\n{\n   _dl_relocate_object*/*libc-2.2.?.so/_dl_catch_error*(Cond)\n   Memcheck:Cond\n   fun:_dl_relocate_object*\n   obj:*libc-2.2.?.so\n   fun:_dl_catch_error*\n}\n{\n   _dl_relocate_object_internal\n   Memcheck:Cond\n   fun:_dl_relocate_object_internal\n}\n{\n   index/*-2.2.5.so/*-2.2.5.so\n   Memcheck:Cond\n   fun:index\n   obj:*-2.2.5.so\n   obj:*-2.2.5.so\n}\n{\n   Red Hat 7.3 #4\n   Memcheck:Cond\n   fun:strlen\n   fun:dl_main\n   fun:_dl_sysdep_start\n}\n\n#-------- SuSE 8.1 stuff (gcc-3.2, glibc-2.2.5 + SuSE's hacks)\n{\n   __stpcpy/*\n   Memcheck:Cond\n   fun:__stpcpy\n   fun:*\n}\n{\n   strlen/decompose_rpath/_dl_map_object\n   Memcheck:Cond\n   fun:strlen\n   fun:decompose_rpath\n   fun:_dl_map_object\n}\n{\n   strlen/_dl_sym/dlsym_doit\n   Memcheck:Cond\n   fun:strlen\n   fun:_dl_sym\n   fun:dlsym_doit\n}\n{\n   trecurse/__gconv_release_shlib(Addr4)\n   Memcheck:Addr4\n   fun:trecurse\n   fun:__gconv_release_shlib\n}\n{\n   do_release_shlib/trecurse(Addr4)\n   Memcheck:Addr4\n   fun:do_release_shlib\n   fun:trecurse\n}\n\n#-------- R H Limbo (glibc-2.2.90) stuff\n{\n   elf_dynamic_do_rela.8/_dl_relocate_object_internal\n   Memcheck:Cond\n   fun:elf_dynamic_do_rela.8\n   fun:_dl_relocate_object_internal\n}\n\n{\n   __strnlen/_nl_make_l10nflist(Cond)\n   Memcheck:Cond\n   fun:__strnlen\n   fun:_nl_make_l10nflist\n}\n\n{\n   __strnlen/*vfprintf*\n   Memcheck:Cond\n   fun:__strnlen\n   fun:*vfprintf*\n}\n\n{\n   libXaw.so.7.0(Cond)\n   Memcheck:Cond\n   obj:*libXaw.so.7.0\n}\n\n#-------- Suppress errors appearing as a result of calling\n#-------- __libc_freeres()\n\n{\n   __twalk/*(Addr4)\n   Memcheck:Addr4\n   fun:__twalk\n}\n\n{\n   do_release_shlib/__twalk(Addr4)\n   Memcheck:Addr4\n   fun:do_release_shlib\n   fun:__twalk\n}\n\n{\n   __libc_freeres/free_mem/free(Free)\n   Memcheck:Free\n   fun:free\n   fun:free_mem\n   fun:__libc_freeres\n}\n\n# even more glibc suppressions ?\n{\n   libc-2.2.4.so/libc-2.2.4.so/libc-2.2.4.so(Cond)\n   Memcheck:Cond\n   obj:*libc-2.2.?.so\n   obj:*libc-2.2.?.so\n   obj:*libc-2.2.?.so\n}\n{\n   libc-2.2.4.so/libc-2.2.4.so/libc-2.2.4.so(Value4)\n   Memcheck:Value4\n   obj:*libc-2.2.?.so\n   obj:*libc-2.2.?.so\n   obj:*libc-2.2.?.so\n}\n\n##### glibc 2.2.5 stuff perhaps?\n##### suppressions for coolo\n{\n   strchr/dl_open_worker(Cond)\n   Memcheck:Cond\n   fun:strchr\n   fun:dl_open_worker\n}\n{ \n   __rawmemchr(Cond)\n   Memcheck:Cond \n   fun:__rawmemchr\n} \n{ \n   _IO_vfprintf/__strnlen(Cond)\n   Memcheck:Cond \n   fun:__strnlen\n   fun:_IO_vfprintf\n} \n{ \n   __strchrnul/gethostbyname*(Cond)\n   Memcheck:Cond \n   fun:__strchrnul\n   fun:gethostbyname*\n} \n\n\n##----\n{\n   strlen/*dl_map_object*(Cond)\n   Memcheck:Cond\n   fun:strlen\n   fun:*dl_map_object*\n}\n\n{\n   strlen/*dl_open_worker*(Cond)\n   Memcheck:Cond\n   fun:strlen\n   fun:*dl_open_worker*\n}\n\n{\n   *rawmemchr*/*nss*(Cond)\n   Memcheck:Cond\n   fun:*rawmemchr*\n   fun:*nss*\n}\n\n{\n   *strchrnul*/*nss*(Cond)\n   Memcheck:Cond\n   fun:*strchrnul*\n   fun:*nss*\n}\n\n# gcc version 2.96 20000731 (Red Hat Linux 7.1 2.96-98)\n# on Red Hat 7.2 (x86) miscompiles __mpn_construct_double in\n# __mpn_construct_double (../sysdeps/ieee754/dbl-64/mpn2dbl.c:45)\n# (glibc-2.2.4) to read and write below %esp.  Hence the following\n# two:\n{\n   __mpn_construct_double/*(Addr4)\n   Memcheck:Addr4\n   fun:__mpn_construct_double\n   fun:*\n}\n{\n   __mpn_construct_double/*(Addr8)\n   Memcheck:Addr8\n   fun:__mpn_construct_double\n   fun:*\n}\n\n# More of the same (gcc bug, I'm pretty sure)\n{\n   __fabs/*(Addr4)\n   Memcheck:Addr4\n   fun:__fabs\n   fun:*\n}\n{\n   __fabs/*(Addr8)\n   Memcheck:Addr8\n   fun:__fabs\n   fun:*\n}\n\n\n# Not sure what this is about ... but anyway\n{\n   pthread_sighandler/*(Addr4)\n   Memcheck:Addr4\n   fun:pthread_sighandler\n   fun:*\n}\n\n\n# More glibc stuff, AFAICS\n\n{\n   __strnlen/__argz_stringify/_nl_make_l10nflist(Cond)\n   Memcheck:Cond\n   fun:__strnlen\n   fun:__argz_stringify\n   fun:_nl_make_l10nflist\n}\n\n#--------------\n{\n   _dl_relocate_object*/dl_open_worker/_dl_catch_error*(Cond)\n   Memcheck:Cond\n   fun:_dl_relocate_object*\n   fun:dl_open_worker\n   fun:_dl_catch_error*\n}\n{\n   _dl_relocate_object/libc-2.2.4.so/_dl_catch_error(Cond)\n   Memcheck:Cond\n   fun:_dl_relocate_object\n   obj:*libc-2.2.?.so\n   fun:_dl_catch_error\n}\n{\n   _dl_relocate_object/dl_main(Cond)\n   Memcheck:Cond\n   fun:_dl_relocate_object\n   fun:dl_main\n}\n{\n   _dl_relocate_object_internal/dl_main(Cond)\n   Memcheck:Cond\n   fun:_dl_relocate_object_internal\n   fun:dl_main\n}\n\n{\n   strrchr/_dl_map_object_from_fd/_dl_map_object(Cond)\n   Memcheck:Cond\n   fun:strrchr\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   _dl_start/ld-2.2.4.so(Cond)\n   Memcheck:Cond\n   fun:_dl_start\n   obj:/lib/ld-2.2.4.so\n}\n\n#-------- glibc 2.2.5/ Debian 3.0\n{\n   _dl_start(Cond)\n   Memcheck:Cond\n   fun:_dl_start\n}\n\n{\n   _dl_start(Cond)\n   Memcheck:Cond\n   fun:_dl_relocate_object\n}\n\n#-------------------\n{\n   socketcall.connect(serv_addr)/connect/*\n   Memcheck:Param\n   socketcall.connect(serv_addr)\n   fun:connect\n   fun:*\n}\n{\n   socketcall.connect(serv_addr)/libc-2.2.4.so/libc-2.2.4.so\n   Memcheck:Param\n   socketcall.connect(serv_addr)\n   obj:*libc-2.2.?.so\n   obj:*libc-2.2.?.so\n}\n\n#----------------------\n{\n   write(buf)/write/libX11.so.6.2/libX11.so.6.2(Param)\n   Memcheck:Param\n   write(buf)\n   fun:write\n   obj:/usr/X11R6/lib/libX11.so.6.2\n   obj:/usr/X11R6/lib/libX11.so.6.2\n}\n{\n   write(buf)/libc-2.2.4.so/libX11.so.6.2/libX11.so.6.2(Param)\n   Memcheck:Param\n   write(buf)\n   obj:*libc-2.2.?.so\n   obj:/usr/X11R6/lib/libX11.so.6.2\n   obj:/usr/X11R6/lib/libX11.so.6.2\n}\n\n#{\n#   llseek(result)/lseek64/_IO_file_seek(Param)\n#   Param\n#   llseek(result)\n#   fun:lseek64\n#   fun:_IO_file_seek\n#}\n\n{\n   writev(vector[...])/__writev/libX11.so.6.2/libX11.so.6.2\n   Memcheck:Param\n   writev(vector[...])\n   fun:__writev\n   obj:/usr/X11R6/lib/libX11.so.6.2\n   obj:/usr/X11R6/lib/libX11.so.6.2\n}\n\n#----------------\n{\n   __rawmemchr/libXt.so.6.0/libXt.so.6.0\n   Memcheck:Cond\n   fun:__rawmemchr\n   obj:/usr/X11R6/lib/libXt.so.6.0\n   obj:/usr/X11R6/lib/libXt.so.6.0\n}\n{\n   libc-2.2.4.so/libXt.so.6.0/libXt.so.6.0\n   Memcheck:Cond\n   obj:*libc-2.2.?.so\n   obj:/usr/X11R6/lib/libXt.so.6.0\n   obj:/usr/X11R6/lib/libXt.so.6.0\n}\n\n## Bug in PRE(sys_clone), really.  Some args are not used.\n{\n   LinuxThread clone use (child_tidptr)\n   Memcheck:Param\n   clone(child_tidptr)\n   fun:clone\n   fun:__pthread_initialize_manager\n   fun:pthread_create@@GLIBC_2.2.5\n}\n\n## LinuxThreads manager writes messages containing undefined bytes\n{\n   LinuxThreads: write/pthread_create\n   Memcheck:Param\n   write(buf)\n   fun:pthread_create@@GLIBC_2.1\n}\n{\n   LinuxThreads: write/pthread_create\n   Memcheck:Param\n   write(buf)\n   fun:write\n   fun:pthread_create@@GLIBC_2.1\n}\n{\n   LinuxThreads: write/pthread_onexit_process\n   Memcheck:Param\n   write(buf)\n   fun:write\n   fun:pthread_onexit_process\n   fun:exit\n}\n{\n   LinuxThreads: write/pthread_join\n   Memcheck:Param\n   write(buf)\n   fun:write\n   fun:pthread_join\n}\n{\n   LinuxThreads: write/pthread_create\n   Memcheck:Param\n   write(buf)\n   fun:write\n   fun:pthread_create@@GLIBC_2.2.5\n}\n{\n   LinuxThreads: write/__pthread_initialize_manager/pthread_create\n   Memcheck:Param\n   write(buf)\n   fun:write\n   fun:__pthread_initialize_manager\n   fun:pthread_create@@GLIBC_2.2.5\n}\n\n## LinuxThreads leaks the stack and TLS data for the manager thread\n{\n   LinuxThreads: leaks stack of manager thread\n   Memcheck:Leak\n   fun:malloc\n   fun:__pthread_initialize_manager\n   fun:pthread_create@@GLIBC_2.1\n}\n{\n   LinuxThreads: leaks TLS data for manager thread\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:__pthread_initialize_minimal\n}\n{\n   LinuxThreads: leaks TLS data for manager thread\n   Memcheck:Leak\n   fun:memalign\n   fun:_dl_allocate_tls\n   fun:__pthread_initialize_minimal\n}\n{\n   LinuxThreads: leaks stack of manager thread\n   Memcheck:Leak\n   fun:malloc\n   fun:__pthread_initialize_manager\n   fun:pthread_create@@GLIBC_2.2.5\n}\n{\n   LinuxThreads: leaks TLS data for manager thread\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls_storage\n   fun:_dl_allocate_tls\n   fun:__pthread_initialize_minimal\n}\n{\n   LinuxThreads: leaks TLS data for manager thread\n   Memcheck:Leak\n   fun:memalign\n   fun:_dl_allocate_tls_storage\n   fun:_dl_allocate_tls\n   fun:__pthread_initialize_minimal\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/glibc-2.3.supp": "\n##----------------------------------------------------------------------##\n\n# Errors to suppress by default with glibc 2.3.x\n\n# Format of this file is:\n# {\n#     name_of_suppression\n#     tool_name:supp_kind\n#     (optional extra info for some suppression types)\n#     caller0 name, or /name/of/so/file.so\n#     caller1 name, or ditto\n#     (optionally: caller2 name)\n#     (optionally: caller3 name)\n#  }\n#\n# For Memcheck, the supp_kinds are:\n#\n#     Param Value1 Value2 Value4 Value8 Value16 Jump\n#     Free Addr1 Addr2 Addr4 Addr8 Addr16\n#     Cond (previously known as Value0)\n#\n# and the optional extra info is:\n#     if Param: name of system call param\n\n{\n   __GI___stpcpy/*\n   Memcheck:Cond\n   fun:__GI___stpcpy\n   fun:*\n}\n{\n   strlen/__GI__dl_open/dlopen_doit\n   Memcheck:Cond\n   fun:strlen\n   fun:__GI__dl_open\n   fun:dlopen_doit\n}\n{\n   strlen/_dl_signal_cerror/_dl_lookup_symbol_internal/do_dlsym\n   Memcheck:Cond\n   fun:_dl_signal_cerror\n   fun:_dl_lookup_symbol_internal\n   fun:do_dlsym\n}\n{\n   strlen/*dl_map_object*(Cond)\n   Memcheck:Cond\n   fun:strlen\n   fun:*dl_map_object*\n}\n\n{\n   strlen/*dl_open_worker*(Cond)\n   Memcheck:Cond\n   fun:strlen\n   fun:*dl_open_worker*\n}\n{\n   strlen/_dl_sym/dlsym_doit\n   Memcheck:Cond\n   fun:strlen\n   fun:_dl_sym\n   fun:dlsym_doit\n}\n{\n   realpath is inefficiently coded\n   Memcheck:Overlap\n   fun:memcpy\n   fun:realpath*\n}\n\n{\n   realpath stupidity part II\n   Memcheck:Overlap\n   fun:strcpy\n   fun:realpath*\n}\n{\n   strlen/decompose_rpath/_dl_map_object\n   Memcheck:Cond\n   fun:strlen\n   fun:decompose_rpath\n   fun:*dl_map_object*\n}\n{\n   stpcpy/_dl_sym*\n   Memcheck:Cond\n   fun:__stpcpy\n   fun:_dl_*\n}\n\n#-------- For R H 8.0\n{\n   elf_dynamic_do_rel.7/_dl_relocate_object_internal/dl_open_worker(Cond)\n   Memcheck:Cond\n   fun:elf_dynamic_do_rel.7\n   fun:_dl_relocate_object_internal\n   fun:dl_open_worker\n}\n{\n   dl_relocate/dl_open_worker\n   Memcheck:Cond\n   fun:_dl_relocate_object_internal\n   fun:dl_open_worker\n}\n{\n   RedHat8-1\n   Memcheck:Cond\n   fun:elf_dynamic_do_rela.8\n   fun:_dl_relocate_object\n   fun:dl_main\n   fun:_dl_sysdep_start\n}\n{\n   RedHat8-2\n   Memcheck:Cond\n   fun:elf_dynamic_do_rel.7\n   fun:_dl_relocate_object\n   fun:dl_main\n   fun:_dl_sysdep_start\n}\n{\n   RedHat8-3\n   Memcheck:Cond\n   fun:elf_dynamic_do_rela.8\n   fun:_dl_relocate_object\n   fun:dl_open_worker\n}\n\n#-------- glibc 2.3.2/ Fedora Core 1\n{\n   dl_relocate/dl_main\n   Memcheck:Cond\n   fun:_dl_relocate_object_internal\n   fun:dl_main\n}\n\n#-------- glibc 2.3.3/ Fedora Core 2\n{\n   dl_relocate_object/dl_main\n   Memcheck:Cond\n   fun:_dl_relocate_object\n   fun:dl_main\n}\n{\n   _dl_relocate_object/dl_open_worker\n   Memcheck:Cond\n   fun:_dl_relocate_object\n   fun:dl_open_worker\n}\n\n#-------- glibc 2.3.4/ Fedora Core 3\n{\n   dl_relocate_object\n   Memcheck:Cond\n   fun:_dl_relocate_object\n}\n\n##----------------------------------------------------------------------##\n## Bugs in helper library supplied with Intel Icc 7.0 (65)\n## in /opt/intel/compiler70/ia32/lib/libcxa.so.3\n{\n   Intel compiler70/ia32/lib/libcxa.so.3 below-esp accesses\n   Memcheck:Addr4\n   obj:/opt/intel/compiler70/ia32/lib/libcxa.so.3\n}\n\n##----------------------------------------------------------------------##\n## SuSE 9 after FV changes (post 2.1.0)\n\n{\n   strlen/_dl_init_paths/dl_main/_dl_sysdep_start(Cond)\n   Memcheck:Cond\n   fun:strlen\n   fun:_dl_init_paths\n   fun:dl_main\n   fun:_dl_sysdep_start\n}\n\n{\n   Ugly strchr error in /lib/ld-2.3.2.so\n   Memcheck:Cond\n   obj:/lib/ld-2.3.2.so\n}\n\n##----------------------------------------------------------------------##\n## SuSE 9.1 with post 2.1.2\n{\n   Ugly strchr error in /lib/ld-2.3.3.so\n   Memcheck:Cond\n   obj:/lib/ld-2.3.3.so\n}\n\n##----------------------------------------------------------------------##\n## SuSE 9.1 with 3.0 branch (x86)\n{\n   Strstr dubiousness in pthread_initialize\n   Memcheck:Cond\n   fun:strstr\n   fun:pthread_initialize\n   obj:/lib/libpthread.so.0\n   obj:/lib/libpthread.so.0\n}\n\n##----------------------------------------------------------------------##\n## glibc-2.3.3 on FC2\n## Assumes that sysctl returns \\0-terminated strings in is_smp_system\n#{\n#   Unterminated strstr string in is_smp_system() (NPTL)\n#   Memcheck:Cond\n#   fun:strstr\n#   fun:__pthread_initialize_minimal\n#   obj:/lib/tls/libpthread*.so*\n#   obj:/lib/tls/libpthread*.so*\n#}\n#{\n#   Unterminated strstr string in is_smp_system() (LinuxThreads)\n#   Memcheck:Cond\n#   fun:strstr\n#   fun:pthread_initialize\n#   obj:/lib/i686/libpthread*.so*\n#   obj:/lib/i686/libpthread*.so*\n#}\n#{\n#   Unterminated strstr string in is_smp_system() (LinuxThreads)\n#   Memcheck:Cond\n#   fun:strstr\n#   fun:pthread_initialize\n#   obj:/lib/libpthread-0.10.so\n#   obj:/lib/libpthread-0.10.so\n#}\n\n## Bug in PRE(sys_clone), really.  Some args are not used.\n{\n   LinuxThread clone use (parent_tidptr)\n   Memcheck:Param\n   clone(parent_tidptr)\n   fun:clone\n   fun:pthread_create\n}\n{\n   LinuxThread clone use (child_tidptr)\n   Memcheck:Param\n   clone(child_tidptr)\n   fun:clone\n   fun:pthread_create\n}\n{\n   LinuxThread clone use (tlsinfo)\n   Memcheck:Param\n   clone(tlsinfo)\n   fun:clone\n   fun:pthread_create\n}\n{\n   LinuxThread clone use (parent_tidptr)\n   Memcheck:Param\n   clone(parent_tidptr)\n   fun:clone\n   fun:pthread_create@@GLIBC_2.1\n}\n{\n   LinuxThread clone use (child_tidptr)\n   Memcheck:Param\n   clone(child_tidptr)\n   fun:clone\n   fun:pthread_create@@GLIBC_2.1\n}\n{\n   LinuxThread clone use (tlsinfo)\n   Memcheck:Param\n   clone(tlsinfo)\n   fun:clone\n   fun:pthread_create@@GLIBC_2.1\n}\n\n## LinuxThreads manager writes messages containing undefined bytes\n{\n   LinuxThreads: write/pthread_onexit_process\n   Memcheck:Param\n   write(buf)\n   fun:pthread_onexit_process\n   fun:exit\n}\n{\n   LinuxThreads: write/pthread_join\n   Memcheck:Param\n   write(buf)\n   fun:pthread_join\n}\n{\n   LinuxThreads: write/pthread_create\n   Memcheck:Param\n   write(buf)\n   fun:pthread_create@@GLIBC_2.1\n}\n{\n   LinuxThreads: write/pthread_create 2\n   Memcheck:Param\n   write(buf)\n   fun:write\n   fun:pthread_create@@GLIBC_2.1\n   fun:main\n}\n{\n   LinuxThreads: write/__pthread_initialize_manager/pthread_create\n   Memcheck:Param\n   write(buf)\n   fun:__pthread_initialize_manager\n   fun:pthread_create@@GLIBC_2.1\n}\n\n{\n   LinuxThreads: write/pthread_create\n   Memcheck:Param\n   write(buf)\n   fun:write\n   fun:pthread_create\n}\n\n## LinuxThreads leaks the stack and TLS data for the manager thread\n{\n   LinuxThreads: leaks stack of manager thread\n   Memcheck:Leak\n   fun:malloc\n   fun:__pthread_initialize_manager\n   fun:pthread_create@@GLIBC_2.1\n}\n{\n   LinuxThreads: leaks TLS data for manager thread\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:__pthread_initialize_minimal\n}\n{\n   LinuxThreads: leaks TLS data for manager thread\n   Memcheck:Leak\n   fun:memalign\n   fun:_dl_allocate_tls\n   fun:__pthread_initialize_minimal\n}\n\n##----------------------------------------------------------------------##\n## glibc-2.3.4 on FC3\n## Assumes that sysctl returns \\0-terminated strings in is_smp_system\n#{\n#   Unterminated strstr string in is_smp_system() (NPTL)\n#   Memcheck:Cond\n#   fun:strstr\n#   fun:__pthread_initialize_minimal\n#   obj:/lib/tls/libpthread-2.3.4.so\n#   obj:/lib/tls/libpthread-2.3.4.so\n#}\n#{\n#   Unterminated strstr string in is_smp_system() (NPTL)\n#   Memcheck:Cond\n#   fun:strstr\n#   fun:__pthread_initialize_minimal\n#   obj:/lib64/tls/libpthread*.so*\n#}\n\n##----------------------------------------------------------------------##\n## glibc-2.3.5 on FC4\n## Assumes that sysctl returns \\0-terminated strings in is_smp_system\n#{\n#   Unterminated strstr string in is_smp_system() (NPTL)\n#   Memcheck:Cond\n#   fun:strstr\n#   fun:__pthread_initialize_minimal\n#   obj:*/libpthread-2.3.5.so\n#   obj:*/libpthread-2.3.5.so\n#}\n\n\n##----------------------------------------------------------------------##\n# \n# I don't know why this is needed, but still:\n{\n   glibc-2.3.x-on-SuSE-10.0-(PPC)-1\n   Memcheck:Cond\n   fun:_dl_start\n   fun:_start\n}\n{\n   glibc-2.3.x-on-SuSE-10.1-(PPC)-1\n   Memcheck:Cond\n   fun:_dl_start_final\n   fun:_dl_start\n   fun:_start\n}\n{\n   glibc-2.3.x-on-SuSE-10.0/10.1-(PPC)-2a\n   Memcheck:Cond\n   fun:index\n   obj:*ld-2.3.*.so\n}\n{\n   glibc-2.3.x-on-SuSE-10.0/10.1-(PPC)-2b\n   Memcheck:Addr4\n   fun:index\n   fun:expand_dynamic_string_token\n}\n{\n   glibc-2.3.5-on-SuSE-10.0/10.1-(PPC)-2c\n   Memcheck:Addr4\n   fun:index\n   obj:*ld-2.3.*.so\n}\n{\n   glibc-2.3.5-on-SuSE-10.0/10.1-(PPC)-3\n   Memcheck:Addr4\n   fun:*wordcopy_fwd_dest_aligned*\n   fun:mem*cpy\n   obj:*lib*2.3.*.so\n}\n{\n   glibc-2.3.5-on-SuSE-10.0/10.1-(PPC)-4\n   Memcheck:Addr4\n   fun:bcmp\n   fun:*rpath*\n   fun:*rpath*\n   fun:*rpath*\n}\n\n##----------------------------------------------------------------------##\n# Hacks pertaining to the fact that our intercept mechanism can't\n# always get hold of strlen early enough, due to idiocy in the low\n# level memory manager.\n\n## HACK to do with strlen not being intercepted early enough\n{\n   strlen-not-intercepted-early-enough-HACK-1\n   Memcheck:Addr4\n   fun:strlen\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   strlen-not-intercepted-early-enough-HACK-2\n   Memcheck:Addr4\n   fun:strlen\n   fun:decompose_rpath\n   fun:cache_rpath\n   fun:_dl_map_object\n}\n\n{\n   strlen-not-intercepted-early-enough-HACK-3\n   Memcheck:Cond\n   fun:strlen\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   strlen-not-intercepted-early-enough-HACK-4\n   Memcheck:Cond\n   fun:strlen\n   fun:expand_dynamic_string_token\n   fun:_dl_map_object\n}\n\n{\n   strlen-not-intercepted-early-enough-HACK-5\n   Memcheck:Cond\n   fun:strlen\n   fun:fillin_rpath\n   fun:_dl_init_paths\n}\n\n\n## HACK to do with index not being intercepted early enough\n{\n   index-not-intercepted-early-enough-HACK-1\n   Memcheck:Cond\n   fun:index\n   obj:*\n   fun:_dl_map_object\n}\n{\n   index-not-intercepted-early-enough-HACK-2\n   Memcheck:Cond\n   fun:index\n   fun:_dl_map_object\n   obj:*\n   fun:_dl_catch_error\n}\n{\n   index-not-intercepted-early-enough-HACK-3\n   Memcheck:Cond\n   fun:index\n   fun:_dl_map_object\n   obj:*\n   fun:_dl_sysdep_start\n}\n\n{\n   index-not-intercepted-early-enough-HACK-4\n   Memcheck:Cond\n   fun:index\n   fun:expand_dynamic_string_token\n}\n\n\n##----------------------------------------------------------------------##\n## MontaVista 3.1 on ppc32 integer only\n{\n   MontaVista-3.1-ppc32-#1\n   Memcheck:Value4\n   obj:/lib/ld-2.3.2.so\n   obj:/lib/ld-2.3.2.so\n   fun:*dl_map_object*\n   obj:/lib/libc-2.3.2.so\n}\n\n{\n   MontaVista-3.1-ppc32-#2\n   Memcheck:Value4\n   fun:malloc\n   obj:/lib/ld-2.3.2.so\n   obj:/lib/ld-2.3.2.so\n   obj:/lib/libc-2.3.2.so\n}\n\n{\n   MontaVista-3.1-ppc32-#3\n   Memcheck:Value4\n   obj:/lib/ld-2.3.2.so\n   obj:/lib/ld-2.3.2.so\n}\n\n##----------------------------------------------------------------------##\n## Ubuntu something (based on Debian 3.0?) on x86\n\n{\n   Ubuntu-stripped-ld.so\n   Memcheck:Cond\n   obj:/lib/ld-2.3.*.so\n   obj:/lib/ld-2.3.*.so\n   obj:/lib/ld-2.3.*.so\n   obj:/lib/ld-2.3.*.so\n   obj:/lib/ld-2.3.*.so\n}\n\n##----------------------------------------------------------------------##\n# MontaVista Linux 4.0.1 on ppc32\n{\n    MVL-401-linuxthreads-pthread_create\n    Memcheck:Param\n    write(buf)\n    fun:pthread_create\n}\n{\n   MVL-401-linuxthreads-pthread_create\n   Memcheck:Param\n   write(buf)\n   obj:/lib/libpthread-0.10.so\n   fun:pthread_create\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/darwin9-drd.supp": "\n# DRD suppressions for Darwin 9.x / Mac OS X 10.5 Leopard\n\n#\n# Suppression patterns for dyld, the dynamic loader.\n#\n\n{\n   drd-darwin-dyld-register-func-for-add-image\n   drd:MutexErr\n   fun:pthread_mutex_unlock\n   fun:_dyld_register_func_for_add_image\n   fun:__keymgr_initializer\n   fun:libSystem_initializer\n}\n{\n   drd-darwin-dyld-register-func-for-remove-image\n   drd:MutexErr\n   fun:pthread_mutex_unlock\n   fun:_dyld_register_func_for_remove_image\n   fun:__keymgr_initializer\n   fun:libSystem_initializer\n}\n{\n   drd-darwin-dyld-GlobalLockInitialize\n   drd:MutexErr\n   fun:pthread_mutex_init\n   fun:_Z24dyldGlobalLockInitializev\n   fun:_dyld_initializer\n}\n{\n   drd-darwin-dyld-bindLazySymbol\n   drd:ConflictingAccess\n   ...\n   fun:_ZN4dyld14bindLazySymbolEPK11mach_headerPm\n   fun:stub_binding_helper_interface2\n}\n{\n   drd-darwin-dyld-addImage\n   drd:ConflictingAccess\n   fun:_ZN4dyld8addImageEP11ImageLoader\n}\n{\n   dyld-ImageLoader::link\n   drd:ConflictingAccess\n   ...\n   fun:_ZN4dyld18notifyBatchPartialE17dyld_image_statesbPFPKcS0_jPK15dyld_image_infoE\n   fun:_ZN11ImageLoader4linkERKNS_11LinkContextEbbRKNS_10RPathChainE\n   fun:_ZN4dyld4linkEP11ImageLoaderbRKNS0_10RPathChainE\n}\n{\n   drd-darwin-dyld-ImageLoaderMachO::resolveUndefined\n   drd:ConflictingAccess\n   ...\n   fun:_ZN16ImageLoaderMachO16resolveUndefinedERKN11ImageLoader11LinkContextEPK11macho_nlistbPPKS0_\n}\n{\n   drd-darwin-dyld-ImageLoaderMachO::findExportedSymbol\n   drd:ConflictingAccess\n   fun:_ZNK16ImageLoaderMachO18findExportedSymbolEPKcPKvbPPK11ImageLoader\n   fun:_ZNK11ImageLoader41findExportedSymbolInDependentImagesExceptEPKcPPKS_RS4_S4_S4_\n   fun:_ZNK11ImageLoader42findExportedSymbolInImageOrDependentImagesEPKcRKNS_11LinkContextEPPKS_\n   fun:dlsym\n}\n\n\n#\n# Suppression patterns for libc, Darwin's C library.\n#\n\n{\n   drd-darwin-libc-cerror\n   drd:ConflictingAccess\n   ...\n   fun:cerror\n}\n{\n   drd-darwin-libc-rand\n   drd:ConflictingAccess\n   fun:do_rand\n}\n{\n   drd-darwin-libc-vfprintf-1\n   drd:ConflictingAccess\n   fun:vfprintf_l\n}\n{\n   drd-darwin-libc-vfprintf-2\n   drd:ConflictingAccess\n   fun:__vfprintf\n}\n{\n   drd-darwin-libc-localeconv\n   drd:ConflictingAccess\n   fun:localeconv_l\n}\n{\n   drd-darwin-libc-fwrite\n   drd:ConflictingAccess\n   ...\n   fun:fwrite$UNIX2003\n}\n{\n   drd-darwin-cxa-guard-acquire\n   drd:ConflictingAccess\n   obj:*\n   fun:__cxa_current_exception_type\n   fun:__cxa_guard_acquire\n}\n{\n   drd-darwin-cxa-guard-release\n   drd:ConflictingAccess\n   fun:__cxa_guard_release\n}\n{\n   drd-darwin-cxa-finalize\n   drd:MutexErr\n   fun:pthread_mutex_destroy\n   fun:__tcf_115\n   fun:__cxa_finalize\n   fun:exit\n}\n{\n   drd-darwin-atexit-register\n   drd:ConflictingAccess\n   fun:atexit_register\n}\n{\n   drd-darwin-opendir\n   drd:ConflictingAccess\n   fun:telldir$UNIX2003\n   fun:__opendir2$UNIX2003\n   fun:opendir$UNIX2003\n}\n{\n   drd-darwin-readdir\n   drd:ConflictingAccess\n   fun:readdir\n}\n{\n   drd-darwin-closedir\n   drd:ConflictingAccess\n   fun:closedir$UNIX2003\n}\n{\n   drd:darwin-ptrace\n   drd:ConflictingAccess\n   fun:ptrace\n}\n\n\n#\n# Suppression patterns for libpthread, Darwin's POSIX threads implementation.\n#\n\n{\n   drd-darwin-pthread-create-1\n   drd:ConflictingAccess\n   obj:*\n   fun:thread_start\n}\n{\n   drd-darwin-pthread-create-2\n   drd:ConflictingAccess\n   ...\n   fun:pthread_create*\n}\n{\n   drd-darwin-pthread-join-1\n   drd:ConflictingAccess\n   ...\n   fun:pthread_join$UNIX2003\n}\n{\n   drd-darwin-pthread-exit\n   drd:ConflictingAccess\n   ...\n   fun:_pthread_exit\n}\n{\n   drd-darwin-pthread-find-thread\n   drd:ConflictingAccess\n   fun:_pthread_find_thread\n}\n{\n   drd-darwin-pthread-spin-unlock\n   drd:ConflictingAccess\n   fun:spin_unlock\n}\n{\n   drd-darwin-pthread-testcancel\n   drd:ConflictingAccess\n   fun:_pthread_testcancel\n}\n{\n   drd-darwin-pthread-detach\n   drd:ConflictingAccess\n   ...\n   fun:pthread_detach\n}\n{\n   drd-darwin-pthread-detach\n   drd:CondRaceErr\n   ...\n   fun:pthread_detach\n}\n{\n   drd-darwin-pthread-kill\n   drd:ConflictingAccess\n   ...\n   fun:pthread_kill\n}\n{\n   drd-darwin-pthread-free-pthread-onstack\n   drd:ConflictingAccess\n   fun:mig_dealloc_reply_port\n   fun:_pthread_free_pthread_onstack\n}\n{\n   drd-darwin-pthread-mach-thread-np\n   drd:ConflictingAccess\n   ...\n   fun:pthread_mach_thread_np\n}\n{\n   drd-darwin-pthread-key-create\n   drd:ConflictingAccess\n   fun:pthread_key_create\n}\n\n\n#\n# Suppression patterns for libobjc.\n#\n\n# It looks like the implementation of objc_msgSend uses another means than the\n# POSIX threads library for locking. More information about messaging and\n# objc_msgSend can be found here: \n# http://devworld.apple.com/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html\n#\n\n{\n   drd-darwin-objc-msgSend\n   drd:ConflictingAccess\n   ...\n   fun:objc_msgSend\n}\n{\n   drd-darwin-objc-msgSend\n   drd:ConflictingAccess\n   ...\n   fun:objc_sync_enter\n}\n\n\n#\n# Suppression patterns for CoreFoundation.framework.\n#\n\n# Suppressions for NSObject methods. For more information about the NSObject\n# class, see also\n# http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html\n{\n   drd-darwin-NSObject-release\n   drd:ConflictingAccess\n   ...\n   fun:-[NSObject release]\n}\n{\n   drd-darwin-NSObject-autorelease-1\n   drd:ConflictingAccess\n   ...\n   fun:-[NSObject(NSObject) autorelease]\n}\n{\n   drd-darwin-NSObject-autorelease-2\n   drd:ConflictingAccess\n   fun:__NSAutoreleaseObject\n}\n{\n   drd-darwin-NSObject-NSDeallocateObject\n   drd:ConflictingAccess\n   fun:_internal_object_dispose\n   fun:NSDeallocateObject\n}\n{\n   drd-darwin-NSObject-retain\n   drd:ConflictingAccess\n   ...\n   fun:-[NSObject retain]\n}\n{\n   drd-darwin-NSObject-retainCount\n   drd:ConflictingAccess\n   ...\n   fun:-[NSObject retainCount]\n}\n{\n   drd-darwin-NSObject-NSDelayedPerforming-1\n   drd:ConflictingAccess\n   ...\n   fun:+[NSObject(NSDelayedPerforming) cancelPreviousPerformRequestsWithTarget:selector:object:]\n}\n{\n   drd-darwin-NSObject-NSDelayedPerforming-2\n   drd:ConflictingAccess\n   ...\n   fun:-[NSObject(NSDelayedPerforming) performSelector:withObject:afterDelay:]\n}\n{\n   drd-darwin-NSObject-NSDelayedPerforming-3\n   drd:ConflictingAccess\n   ...\n   fun:-[NSObject(NSDelayedPerforming) performSelector:withObject:afterDelay:inModes:]\n}\n{\n   drd-darwin-NSObject-NSDelayedPerforming-4\n   drd:ConflictingAccess\n   ...\n   fun:-[NSObject(NSThreadPerformAdditions) performSelector:onThread:withObject:waitUntilDone:modes:]\n}\n{\n   drd-darwin-NSObject-NSDelayedPerforming-5\n   drd:ConflictingAccess\n   ...\n   fun:-[NSObject(NSThreadPerformAdditions) performSelectorOnMainThread:withObject:waitUntilDone:]\n}\n\n# Suppressions for methods of the NSThread class.\n{\n   drd-NSThread-nq\n   drd:ConflictingAccess\n   ...\n   fun:-[NSThread _nq:]\n}\n\n# Suppressions for methods of the NSLock class. See also\n# http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSLock_Class/Reference/Reference.html\n{\n   drd-darwin-NSLock-lock\n   drd:ConflictingAccess\n   fun:-[NSLock lock]\n}\n{\n   drd-darwin-NSLock-unlock\n   drd:ConflictingAccess\n   fun:-[NSLock unlock]\n}\n# Suppressions for NSCondition methods.\n{\n   drd-darwin-NSConditionLock-lock\n   drd:ConflictingAccess\n   fun:-[NSCondition lock]\n}\n# Suppressions for NSConditionLock methods.\n{\n   drd-darwin-NSConditionLock-lockWhenCondition:beforeDate:\n   drd:ConflictingAccess\n   fun:-[NSConditionLock lockWhenCondition:beforeDate:]\n}\n\n\n# NSExtraRefCount returns the specified object's reference count, and\n# NSDecrementExtraRefCountWasZero decrements the specified object's reference\n# count.\n# See also http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html\n{\n   drd-darwin-NSExtraRefCount\n   drd:ConflictingAccess\n   ...\n   fun:NSExtraRefCount\n}\n{\n   drd-darwin-NSDecrementExtraRefCountWasZero\n   drd:ConflictingAccess\n   ...\n   fun:NSDecrementExtraRefCountWasZero\n}\n# For more information about key-value observing, see also the NSKeyValueObserving Protocol Reference:\n# http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/Reference/Reference.html\n{\n   drd-darwin-NSKVONotify\n   drd:ConflictingAccess\n   ...\n   fun:NSKVONotify\n}\n{\n   drd-darwin-NSKVONotifyingEnableForInfoAndKey\n   drd:ConflictingAccess\n   ...\n   fun:_NSKVONotifyingEnableForInfoAndKey\n}\n# From the NSRunLoop class reference:\n# Warning: The NSRunLoop class is generally not considered to be thread-safe\n# and its methods should only be called within the context of the current\n# thread. You should never try to call the methods of an NSRunLoop object\n# running in a different thread, as doing so might cause unexpected results.\n# See also the NSRunLoop Class Reference:\n# http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/Reference/Reference.html\n# {\n#    drd-darwin-CFRunLoop*\n#    drd:ConflictingAccess\n#    ...\n#    fun:CFRunLoop*\n# }\n# See also the CFBag reference:\n# http://developer.apple.com/documentation/CoreFoundation/Reference/CFBagRef/Reference/reference.html\n# {\n#    drd-darwin-CFBag*\n#    drd:ConflictingAccess\n#    fun:CFBag*\n# }\n\n# Suppression patterns for the memory allocation functions in WTF.\n{\n   drd-WTF::fastCalloc\n   drd:ConflictingAccess\n   ...\n   fun:_ZN3WTF10fastCallocEmm\n}\n{\n   drd-WTF::fastMalloc\n   drd:ConflictingAccess\n   ...\n   fun:_ZN3WTF10fastMallocEm\n}\n{\n   drd-WTF::fastFree\n   drd:ConflictingAccess\n   ...\n   fun:_ZN3WTF8fastFreeEPv\n}\n\n# Suppression patterns for the string manipulation functions in WebCore.\n{\n   drd-WebCore::StringImpl::init\n   drd:ConflictingAccess\n   ...\n   fun:_ZN7WebCore10StringImpl4initEPKcj\n}\n{\n   drd-WebCore::StringImpl::append\n   drd:ConflictingAccess\n   ...\n   fun:_ZN7WebCore10StringImpl6appendEPKtj\n}\n{\n   drd-WebCore::CString::init\n   drd:ConflictingAccess\n   ...\n   fun:_ZN7WebCore7CString4initEPKcj\n}\n\n# Suppression patterns for the text encoding functions in WebCore.\n{\n   drd-WebCore::WebCore::TextCodec::~TextCodec()\n   drd:ConflictingAccess\n   fun:_ZN7WebCore9TextCodecD2Ev\n}\n{\n   drd-WebCore::TextCodecICU::TextCodecICU\n   drd:ConflictingAccess\n   fun:_ZN7WebCore12TextCodecICUC2ERKNS_12TextEncodingE\n}\n{\n   drd-WebCore::TextCodecICU::~TextCodecICU\n   drd:ConflictingAccess\n   fun:_ZN7WebCore12TextCodecICUD0Ev\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/glibc-2.34567-NPTL-helgrind.supp": "\n# FIXME 22 Jan 09: helgrind-glibc2X-005 overlaps with a lot of\n# other stuff.  They should be removed.\n\n##----------------------------------------------------------------------##\n# Suppressions for the Helgrind tool when using \n# a glibc-2.{3,4,5,6,7,8,9} system\n\n####################################################\n# glibc-2.X specific\n# These are generic cover-alls which catch a lot of stuff\n# in various combinations of ld, libc and libpthread\n#\n# Note this is heavyhanded and not very clever:\n#\n# - suppress anything that has its top frame in ld.so\n#   That's fine, since it's mostly dynamic linking stuff,\n#   which has various deliberate (harmless) races\n#\n# - suppress anything that has its top frame in libc.so.\n#   This really isn't clever, since it could hide some \n#   legitimate races.  But the problem is, if we don't do\n#   this, then loads of errors to do with stdio are reported, because\n#   H fails to see glibc's internal locking/unlocking of FILE*s\n#   as required by POSIX.  A better solution is needed.\n#\n# - some of the stdio functions in newer glibc manipulate stdio\n#   FILE*s state through mempcpy, which we intercept, so we also need\n#   to suppress such manipulations.\n\n#{\n#   helgrind-glibc2X-001\n#   Helgrind:Race\n#   obj:*/lib*/ld-2.*so*\n#}\n\n# helgrind-glibc2X-002 was merged into helgrind-glibc2X-001\n\n# helgrind-glibc2X-003 was merged into helgrind-glibc2X-001\n\n{\n   helgrind-glibc2X-004\n   Helgrind:Race\n   obj:*/lib*/libc-2.*so*\n}\n\n{\n   helgrind-glibc-io-xsputn-mempcpy\n   Helgrind:Race\n   fun:__GI_mempcpy\n   fun:_IO_*xsputn*\n   obj:*/lib*/libc-2.*so*\n}\n\n{\n   helgrind-glibc2X-005\n   Helgrind:Race\n   obj:*/lib*/libpthread-2.*so*\n}\n\n# helgrind-glibc2X-006 was merged into helgrind-glibc2X-005\n\n# helgrind-glibc2X-007 was merged into helgrind-glibc2X-001\n\n# helgrind-glibc2X-008 was merged into helgrind-glibc2X-004\n\n# helgrind-glibc2X-009 was merged into helgrind-glibc2X-004\n\n# helgrind-glibc2X-010 was merged into helgrind-glibc2X-001\n\n# helgrind-glibc2X-011 was merged into helgrind-glibc2X-004\n\n# helgrind-glibc2X-012 was merged into helgrind-glibc2X-001\n\n# helgrind-glibc2X-013 was merged into helgrind-glibc2X-001\n\n# helgrind-glibc2X-014 was merged into helgrind-glibc2X-001\n\n# helgrind-glibc2X-015 was merged into helgrind-glibc2X-004\n\n# helgrind-glibc2X-016 was merged into helgrind-glibc2X-004\n\n# These are very ugly.  They are needed to suppress errors inside (eg)\n# NPTL's pthread_cond_signal.  Why only one stack frame -- at least we\n# should see the wrapper calling the real functions, right?\n# Unfortunately, no: the real functions are handwritten assembly (in\n# the glibc-2.5 sources) and does not create a proper stack frame.\n# Therefore it's only one level of unwinding before we're back out in\n# user code rather than the 2 levels you'd expect.\n{\n   helgrind-glibc2X-101\n   Helgrind:Race\n   obj:*/lib*/libpthread-2.*so*\n   fun:pthread_*\n}\n{\n   helgrind-glibc2X-102\n   Helgrind:Race\n   fun:mythread_wrapper\n   obj:*/lib*/libpthread-2.*so*\n}\n{\n   helgrind-glibc2X-103\n   Helgrind:Race\n   fun:pthread_cond_*@@GLIBC_2.*\n}\n{\n   helgrind-glibc2X-104\n   Helgrind:Race\n   fun:__lll_mutex_*\n}\n{\n   helgrind-glibc2X-105\n   Helgrind:Race\n   fun:pthread_rwlock_*lock*\n}\n{\n   helgrind-glibc2X-106\n   Helgrind:Race\n   fun:__lll_lock_wait\n}\n{\n   helgrind-glibc2X-107\n   Helgrind:Race\n   obj:*/lib*/libpthread-2.*so*\n   fun:sem_*\n}\n{\n   helgrind-glibc2X-108\n   Helgrind:Race\n   fun:clone\n}\n{\n   helgrind-glibc2X-109\n   Helgrind:Race\n   fun:start_thread\n}\n{\n   helgrind-glibc2X-110\n   Helgrind:Race\n   obj:*/lib*/libc-2.*so*\n   fun:pthread_*\n}\n{\n   helgrind-glibc2X-111\n   Helgrind:Race\n   fun:__lll_*lock_*\n}\n{\n   helgrind-glibc2X-113\n   Helgrind:Race\n   fun:pthread_barrier_wait*\n}\n\n\n####################################################\n# qt4 specific (GNU mangling)\n#\n{\n   helgrind-qt4---QMutex::lock()-QMutex::lock()\n   Helgrind:Race\n   ...\n   fun:_ZN6QMutex4lockEv\n   fun:_ZN6QMutex4lockEv\n}\n\n{                                                               \n   helgrind-qt4---QMutex::unlock()-QMutex::unlock()\n   Helgrind:Race                                                \n   ...\n   fun:_ZN6QMutex6unlockEv                                      \n   fun:_ZN6QMutex6unlockEv\n}\n\n{\n   helgrind-qt4---pthread_setspecific-QThreadPrivate::start(void*)\n   Helgrind:Race\n   fun:pthread_setspecific\n   fun:_ZN14QThreadPrivate5startEPv\n}\n\n\n####################################################\n# Other stuff.\n#\n# pthread_exit apparently calls some kind of unwind\n# mechanism - maybe to remove some number of frames\n# from the thread's stack, so as to get back to the \n# outermost frame for the thread?  Anyway..\n\n{\n   helgrind---*Unwind*-...-pthread_exit\n   Helgrind:Race\n   fun:*Unwind*\n   ...\n   fun:pthread_exit\n}\n\n{\n   helgrind---...-*Unwind*-*pthread_unwind*\n   Helgrind:Race\n   ...\n   fun:*Unwind*\n   fun:*pthread_unwind*\n}\n\n{\n   helgrind---...-*Unwind*-*pthread_unwind*\n   Helgrind:Race\n   ...\n   fun:_Unwind*\n   ...\n   fun:_Unwind_Backtrace\n}\n\n\n\n\n####################################################\n# To do with thread stack allocation and deallocation?\n#\n{\n   helgrind---free_stacks-__deallocate_stack\n   Helgrind:Race\n   fun:free_stacks\n   fun:__deallocate_stack\n}\n\n{\n   helgrind---__deallocate_stack-start_thread-clone\n   Helgrind:Race\n   fun:__deallocate_stack\n   fun:start_thread\n   fun:clone\n}\n\n\n####################################################\n# To do with pthread_{set,get}specific\n#\n{\n   helgrind---pthread_setspecific\n   Helgrind:Race\n   fun:pthread_setspecific\n}\n\n{\n   helgrind---pthread_getspecific\n   Helgrind:Race\n   fun:pthread_getspecific\n}\n\n\n####################################################\n# To do with dynamic linking\n#\n# helgrind---ld.so-...-dlsym was merged into helgrind-glibc2X-001\n\n{\n   helgrind---_dl_allocate_tls \n   Helgrind:Race\n   fun:mempcpy\n   fun:_dl_allocate_tls_init\n   ...\n   fun:pthread_create@@GLIBC_2.2*\n   fun:pthread_create_WRK\n   fun:pthread_create@*\n}\n\n{\n   helgrind---_dl_allocate_tls2\n   Helgrind:Race\n   fun:memcpy\n   fun:__mempcpy_inline\n   fun:_dl_allocate_tls_init\n   ...\n   fun:pthread_create@@GLIBC_2.2*\n   fun:pthread_create_WRK\n   fun:pthread_create@*\n}\n\n####################################################\n# To do with GNU libgomp\n#\n{\n   helgrind---libgomp43-1\n   Helgrind:Race\n   fun:gomp_ordered_sync\n}\n\n{\n   helgrind---libgomp43-1\n   Helgrind:Race\n   fun:gomp_ordered_next\n}\n\n{\n   helgrind---libgomp43-1\n   Helgrind:Race\n   fun:gomp_ordered_last\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/mpi/libmpiwrap.c": "\n/*---------------------------------------------------------------*/\n/*---                                                         ---*/\n/*--- A library of wrappers for MPI 2 functions.              ---*/\n/*---                                                         ---*/\n/*---------------------------------------------------------------*/\n\n/* ----------------------------------------------------------------\n\n   Notice that the following BSD-style license applies to this one\n   file (mpiwrap.c) only.  The rest of Valgrind is licensed under the\n   terms of the GNU General Public License, version 2, unless\n   otherwise indicated.  See the COPYING file in the source\n   distribution for details.\n\n   ----------------------------------------------------------------\n\n   This file is part of Valgrind, a dynamic binary instrumentation\n   framework.\n\n   Copyright (C) 2006-2017 OpenWorks LLP.  All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n\n   1. Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n   2. The origin of this software must not be misrepresented; you must\n      not claim that you wrote the original software.  If you use this\n      software in a product, an acknowledgment in the product\n      documentation would be appreciated but is not required.\n\n   3. Altered source versions must be plainly marked as such, and must\n      not be misrepresented as being the original software.\n\n   4. The name of the author may not be used to endorse or promote\n      products derived from this software without specific prior written\n      permission.\n\n   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n   Neither the names of the U.S. Department of Energy nor the\n   University of California nor the names of its contributors may be\n   used to endorse or promote products derived from this software\n   without prior written permission.\n*/\n\n/* Handling of MPI_STATUS{ES}_IGNORE for MPI_Status* arguments.\n\n   The MPI-2 spec allows many functions which have MPI_Status* purely\n   as an out parameter, to accept the constants MPI_STATUS_IGNORE or\n   MPI_STATUSES_IGNORE there instead, if the caller does not care\n   about the status.  See the MPI-2 spec sec 4.5.1 (\"Passing\n   MPI_STATUS_IGNORE for Status\").  (mpi2-report.pdf, 1615898 bytes,\n   md5=694a5efe2fd291eecf7e8c9875b5f43f).\n\n   This library handles such cases by allocating a fake MPI_Status\n   object (on the stack) or an array thereof (on the heap), and\n   passing that onwards instead.  From the outside the caller sees no\n   difference.  Unfortunately the simpler approach of merely detecting\n   and handling these special cases at a lower level does not work,\n   because we need to use information returned in MPI_Status*\n   arguments to paint result buffers, even if the caller doesn't\n   supply a real MPI_Status object.\n\n   Eg, MPI_Recv.  We can't paint the result buffer without knowing how\n   many items arrived; but we can't find that out without passing a\n   real MPI_Status object to the (real) MPI_Recv call.  Hence, if the\n   caller did not supply one, we have no option but to use a temporary\n   stack allocated one for the inner call.  Ditto, more indirectly\n   (via maybe_complete) for nonblocking receives and the various\n   associated wait/test calls. */\n\n\n/*------------------------------------------------------------*/\n/*--- includes                                             ---*/\n/*------------------------------------------------------------*/\n\n#include <stdio.h>\n#include <assert.h>\n#include <unistd.h>     /* getpid */\n#include <stdlib.h>     /* exit */\n#include <string.h>     /* strstr */\n#include <pthread.h>    /* pthread_mutex_{lock,unlock} */\n\n/* Include Valgrind magic macros for writing wrappers. */\n#include \"../memcheck/memcheck.h\"\n\n/* Include macros for VALGRIND_{DIS,EN}ABLE_ERROR_REPORTING.\n   This is somewhat experimental and hence disable-able, by\n   setting cONFIG_DER to zero. */\n#include \"../include/valgrind.h\"\n\n#define cONFIG_DER  1   /* set to 0 to disable */\n\n\n/*------------------------------------------------------------*/\n/*--- Connect to MPI library                               ---*/\n/*------------------------------------------------------------*/\n\n/* Include headers for whatever MPI implementation the wrappers are to\n   be used with.  The configure system will tell us what the path to\n   the chosen MPI implementation is, via -I.. to the compiler. */\n#include \"mpi.h\"\n\n/* Where are API symbols?\n   Open MPI      lib/libmpi.so,   soname = libmpi.so.0\n   Quadrics MPI  lib/libmpi.so,   soname = libmpi.so.0\n   MPICH         libmpich.so.1.0, soname = libmpich.so.1.0\n\n   A suitable soname to match with is therefore \"libmpi*.so*\".\n*/\n#define I_WRAP_FNNAME_U(_name) \\\n        I_WRAP_SONAME_FNNAME_ZU(libmpiZaZdsoZa,_name)\n\n\n/* Define HAVE_MPI_STATUS_IGNORE iff we have to deal with\n   MPI_STATUS{ES}_IGNORE. */\n#if MPI_VERSION >= 2 \\\n    || (defined(MPI_STATUS_IGNORE) && defined(MPI_STATUSES_IGNORE))\n#  undef HAVE_MPI_STATUS_IGNORE\n#  define HAVE_MPI_STATUS_IGNORE 1\n#else\n#  undef HAVE_MPI_STATUS_IGNORE\n#endif\n\n\n/*------------------------------------------------------------*/\n/*--- Decls                                                ---*/\n/*------------------------------------------------------------*/\n\ntypedef  unsigned char  Bool;\n#define False ((Bool)0)\n#define True  ((Bool)1)\n\n/* Word, UWord are machine words - same size as a pointer.  This is\n   checked at startup.  The wrappers below use 'long' to mean a\n   machine word - this too is tested at startup. */\ntypedef    signed long  Word;\ntypedef  unsigned long  UWord;\n\n#if !defined(offsetof)\n#  define offsetof(type,memb) ((UWord)&((type*)0)->memb)\n#endif\n\n/* Find the size of long double image (not 'sizeof(long double)').\n   See comments in sizeofOneNamedTy. */\nstatic long sizeof_long_double_image ( void );\n\n\n/*------------------------------------------------------------*/\n/*--- Simple helpers                                       ---*/\n/*------------------------------------------------------------*/\n\n/* ------ Helpers for debug printing ------ */\n\n/* constant */\nstatic const char* preamble = \"valgrind MPI wrappers\";\n\n/* established at startup */\nstatic pid_t my_pid         = -1;\nstatic char* options_str    = NULL;\nstatic int   opt_verbosity  = 1;\nstatic Bool  opt_missing    = 0; /* 0:silent; 1:warn; 2:abort */\nstatic Bool  opt_help       = False;\nstatic Bool  opt_initkludge = False;\n\nstatic void before ( char* fnname )\n{\n   /* This isn't thread-safe wrt 'done' (no locking).  It's not\n      critical. */\n   static int done = 0;\n   if (done == 0) {\n      done = 1;\n      my_pid = getpid();\n      options_str = getenv(\"MPIWRAP_DEBUG\");\n      if (options_str) {\n         if (NULL != strstr(options_str, \"warn\"))\n            opt_missing = 1;\n         if (NULL != strstr(options_str, \"strict\"))\n            opt_missing = 2;\n         if (NULL != strstr(options_str, \"verbose\"))\n            opt_verbosity++;\n         if (NULL != strstr(options_str, \"quiet\"))\n            opt_verbosity--;\n         if (NULL != strstr(options_str, \"help\"))\n            opt_help = True;\n         if (NULL != strstr(options_str, \"initkludge\"))\n            opt_initkludge = True;\n      }\n      if (opt_verbosity > 0)\n         fprintf(stderr, \"%s %5d: Active for pid %d\\n\", \n                         preamble, my_pid, my_pid);\n      /* Sanity check - that Word/UWord really are machine words. */\n      assert(sizeof(Word)  == sizeof(void*));\n      assert(sizeof(UWord) == sizeof(void*));\n      /* Sanity check - char is byte-sized (else address calculations\n         in walk_type don't work. */\n      assert(sizeof(char) == 1);\n      if (opt_help) {\n         fprintf(stderr, \"\\n\");\n         fprintf(stderr, \"Valid options for the MPIWRAP_DEBUG environment\"\n                         \" variable are:\\n\");\n         fprintf(stderr, \"\\n\");\n         fprintf(stderr, \"   quiet       be silent except for errors\\n\");\n         fprintf(stderr, \"   verbose     show wrapper entries/exits\\n\");\n         fprintf(stderr, \"   strict      abort the program if a function\"\n                         \" with no wrapper is used\\n\");\n         fprintf(stderr, \"   warn        give a warning if a function\"\n                         \" with no wrapper is used\\n\");\n         fprintf(stderr, \"   help        display this message, then exit\\n\");\n         fprintf(stderr, \"   initkludge  debugging hack; do not use\\n\");\n         fprintf(stderr, \"\\n\");\n         fprintf(stderr, \"Multiple options are allowed, eg\"\n                         \" MPIWRAP_DEBUG=strict,verbose\\n\");\n         fprintf(stderr, \"Note: 'warn' generates output even if 'quiet'\"\n                         \" is also specified\\n\");\n         fprintf(stderr, \"\\n\");\n         fprintf(stderr, \"%s %5d: exiting now\\n\", preamble, my_pid );\n         exit(1);\n      }\n      if (opt_verbosity > 0)\n         fprintf(stderr, \n                 \"%s %5d: Try MPIWRAP_DEBUG=help for possible options\\n\", \n                 preamble, my_pid);\n\n   }\n   if (opt_verbosity > 1)\n      fprintf(stderr, \"%s %5d: enter PMPI_%s\\n\", preamble,  my_pid, fnname );\n}\n\nstatic __inline__ void after ( char* fnname, int err )\n{\n   if (opt_verbosity > 1)\n      fprintf(stderr, \"%s %5d:  exit PMPI_%s (err = %d)\\n\", \n                      preamble, my_pid, fnname, err );\n}\n\nstatic void barf ( char* msg )\n{\n   fprintf(stderr, \"%s %5d: fatal: %s\\n\",   preamble, my_pid, msg);\n   fprintf(stderr, \"%s %5d: exiting now\\n\", preamble, my_pid );\n   exit(1);\n}\n\n/* Half-hearted type-showing function (for debugging). */\nstatic void showTy ( FILE* f, MPI_Datatype ty )\n{\n        if (ty == MPI_DATATYPE_NULL)  fprintf(f,\"DATATYPE_NULL\");\n   else if (ty == MPI_BYTE)           fprintf(f,\"BYTE\");\n   else if (ty == MPI_PACKED)         fprintf(f,\"PACKED\");\n   else if (ty == MPI_CHAR)           fprintf(f,\"CHAR\");\n   else if (ty == MPI_SHORT)          fprintf(f,\"SHORT\");\n   else if (ty == MPI_INT)            fprintf(f,\"INT\");\n   else if (ty == MPI_LONG)           fprintf(f,\"LONG\");\n   else if (ty == MPI_FLOAT)          fprintf(f,\"FLOAT\");\n   else if (ty == MPI_DOUBLE)         fprintf(f,\"DOUBLE\");\n   else if (ty == MPI_LONG_DOUBLE)    fprintf(f,\"LONG_DOUBLE\");\n   else if (ty == MPI_UNSIGNED_CHAR)  fprintf(f,\"UNSIGNED_CHAR\");\n   else if (ty == MPI_UNSIGNED_SHORT) fprintf(f,\"UNSIGNED_SHORT\");\n   else if (ty == MPI_UNSIGNED_LONG)  fprintf(f,\"UNSIGNED_LONG\");\n   else if (ty == MPI_UNSIGNED)       fprintf(f,\"UNSIGNED\");\n   else if (ty == MPI_FLOAT_INT)      fprintf(f,\"FLOAT_INT\");\n   else if (ty == MPI_DOUBLE_INT)     fprintf(f,\"DOUBLE_INT\");\n   else if (ty == MPI_LONG_DOUBLE_INT) fprintf(f,\"LONG_DOUBLE_INT\");\n   else if (ty == MPI_LONG_INT)       fprintf(f,\"LONG_INT\");\n   else if (ty == MPI_SHORT_INT)      fprintf(f,\"SHORT_INT\");\n   else if (ty == MPI_2INT)           fprintf(f,\"2INT\");\n   else if (ty == MPI_UB)             fprintf(f,\"UB\");\n   else if (ty == MPI_LB)             fprintf(f,\"LB\");\n#  if defined(MPI_WCHAR)\n   else if (ty == MPI_WCHAR)          fprintf(f,\"WCHAR\");\n#  endif\n   else if (ty == MPI_LONG_LONG_INT)  fprintf(f,\"LONG_LONG_INT\");\n#  if defined(MPI_LONG_LONG)\n   else if (ty == MPI_LONG_LONG)      fprintf(f,\"LONG_LONG\");\n#  endif\n#  if defined(MPI_UNSIGNED_LONG_LONG)\n   else if (ty == MPI_UNSIGNED_LONG_LONG) fprintf(f,\"UNSIGNED_LONG_LONG\");\n#  endif\n#  if defined(MPI_REAL8)\n   else if (ty == MPI_REAL8)          fprintf(f, \"REAL8\");\n#  endif\n#  if defined(MPI_REAL4)\n   else if (ty == MPI_REAL4)          fprintf(f, \"REAL4\");\n#  endif\n#  if defined(MPI_REAL)\n   else if (ty == MPI_REAL)           fprintf(f, \"REAL\");\n#  endif\n#  if defined(MPI_INTEGER8)\n   else if (ty == MPI_INTEGER8)       fprintf(f, \"INTEGER8\");\n#  endif\n#  if defined(MPI_INTEGER4)\n   else if (ty == MPI_INTEGER4)       fprintf(f, \"INTEGER4\");\n#  endif\n#  if defined(MPI_INTEGER)\n   else if (ty == MPI_INTEGER)        fprintf(f, \"INTEGER\");\n#  endif\n#  if defined(MPI_DOUBLE_PRECISION)\n   else if (ty == MPI_DOUBLE_PRECISION) fprintf(f, \"DOUBLE_PRECISION\");\n#  endif\n#  if defined(MPI_COMPLEX)\n   else if (ty == MPI_COMPLEX)          fprintf(f, \"COMPLEX\");\n#  endif\n#  if defined(MPI_DOUBLE_COMPLEX)\n   else if (ty == MPI_DOUBLE_COMPLEX)   fprintf(f, \"DOUBLE_COMPLEX\");\n#  endif\n#  if defined(MPI_LOGICAL)\n   else if (ty == MPI_LOGICAL)          fprintf(f, \"LOGICAL\");\n#  endif\n#  if defined(MPI_2INTEGER)\n   else if (ty == MPI_2INTEGER)         fprintf(f, \"2INTEGER\");\n#  endif\n#  if defined(MPI_2COMPLEX)\n   else if (ty == MPI_2COMPLEX)         fprintf(f, \"2COMPLEX\");\n#  endif\n#  if defined(MPI_2DOUBLE_COMPLEX)\n   else if (ty == MPI_2DOUBLE_COMPLEX)  fprintf(f, \"2DOUBLE_COMPLEX\");\n#  endif\n#  if defined(MPI_2REAL)\n   else if (ty == MPI_2REAL)            fprintf(f, \"2REAL\");\n#  endif\n#  if defined(MPI_2DOUBLE_PRECISION)\n   else if (ty == MPI_2DOUBLE_PRECISION) fprintf(f, \"2DOUBLE_PRECISION\");\n#  endif\n#  if defined(MPI_CHARACTER)\n   else if (ty == MPI_CHARACTER)         fprintf(f, \"CHARACTER\");\n#  endif\n   else fprintf(f,\"showTy:???\");\n}\n\nstatic void showCombiner ( FILE* f, int combiner )\n{\n   switch (combiner) {\n      case MPI_COMBINER_NAMED:       fprintf(f, \"NAMED\"); break;\n#if   defined(MPI_COMBINER_DUP)\n      case MPI_COMBINER_DUP:         fprintf(f, \"DUP\"); break;\n#     endif\n      case MPI_COMBINER_CONTIGUOUS:  fprintf(f, \"CONTIGUOUS\"); break;\n      case MPI_COMBINER_VECTOR:      fprintf(f, \"VECTOR\"); break;\n#if   defined(MPI_COMBINER_HVECTOR_INTEGER)\n      case MPI_COMBINER_HVECTOR_INTEGER: fprintf(f, \"HVECTOR_INTEGER\"); break;\n#     endif\n      case MPI_COMBINER_HVECTOR:     fprintf(f, \"HVECTOR\"); break;\n      case MPI_COMBINER_INDEXED:     fprintf(f, \"INDEXED\"); break;\n#if   defined(MPI_COMBINER_HINDEXED_INTEGER)\n      case MPI_COMBINER_HINDEXED_INTEGER: fprintf(f, \"HINDEXED_INTEGER\"); break;\n#     endif\n      case MPI_COMBINER_HINDEXED:    fprintf(f, \"HINDEXED\"); break;\n#if   defined(MPI_COMBINER_INDEXED_BLOCK)\n      case MPI_COMBINER_INDEXED_BLOCK: fprintf(f, \"INDEXED_BLOCK\"); break;\n#     endif\n#if   defined(MPI_COMBINER_STRUCT_INTEGER)\n      case MPI_COMBINER_STRUCT_INTEGER: fprintf(f, \"STRUCT_INTEGER\"); break;\n#     endif\n      case MPI_COMBINER_STRUCT:      fprintf(f, \"STRUCT\"); break;\n#if   defined(MPI_COMBINER_SUBARRAY)\n      case MPI_COMBINER_SUBARRAY:    fprintf(f, \"SUBARRAY\"); break;\n#     endif\n#if   defined(MPI_COMBINER_DARRAY)\n      case MPI_COMBINER_DARRAY:      fprintf(f, \"DARRAY\"); break;\n#     endif\n#if   defined(MPI_COMBINER_F90_REAL)\n      case MPI_COMBINER_F90_REAL:    fprintf(f, \"F90_REAL\"); break;\n#     endif\n#if   defined(MPI_COMBINER_F90_COMPLEX)\n      case MPI_COMBINER_F90_COMPLEX: fprintf(f, \"F90_COMPLEX\"); break;\n#     endif\n#if   defined(MPI_COMBINER_F90_INTEGER)\n      case MPI_COMBINER_F90_INTEGER: fprintf(f, \"F90_INTEGER\"); break;\n#     endif\n#if   defined(MPI_COMBINER_RESIZED)\n      case MPI_COMBINER_RESIZED:     fprintf(f, \"RESIZED\"); break;\n#     endif\n      default: fprintf(f, \"showCombiner:??\"); break;\n   }\n}\n\n\n/* ------ Get useful bits of info ------ */\n\n/* Note, PMPI_Comm_rank/size are themselves wrapped.  Should work\n   fine. */\n\nstatic __inline__ int comm_rank ( MPI_Comm comm ) \n{\n   int err, r;\n   err = PMPI_Comm_rank(comm, &r);\n   return err ? 0/*arbitrary*/ : r;\n}\n\nstatic __inline__ int comm_size ( MPI_Comm comm ) \n{\n   int err, r;\n   err = PMPI_Comm_size(comm, &r);\n   return err ? 0/*arbitrary*/ : r;\n}\n\nstatic __inline__ Bool count_from_Status( /*OUT*/int* recv_count, \n                                      MPI_Datatype datatype, \n                                      MPI_Status* status)\n{\n   int n;\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   int err = PMPI_Get_count(status, datatype, &n);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   if (err == MPI_SUCCESS) {\n      VALGRIND_MAKE_MEM_DEFINED(&n, sizeof(n));\n      *recv_count = n;\n      return True;\n   } else {\n      return False;\n   }\n}\n\n/* It's critical that we can do equality on MPI_Requests.\n   Unfortunately these are opaque objects to us (handles, in the\n   parlance of the MPI 1.1 spec).  Fortunately Sec 2.4.1 (\"Opaque\n   Objects\") specifies that \"In C, [...] These [handles] should be\n   types that support assignment and equality operations.\"  Hence the\n   following function should compile for any compliant definition of\n   MPI_Request. */\nstatic __inline__ \nBool eq_MPI_Request ( MPI_Request r1, MPI_Request r2 )\n{\n   return r1 == r2;\n}\n\n/* Return True if status is MPI_STATUS_IGNORE or MPI_STATUSES_IGNORE.\n   On MPI-1.x platforms which don't have these symbols (and they would\n   only have them if they've been backported from 2.x) always return\n   False. */\nstatic __inline__\nBool isMSI ( MPI_Status* status )\n{\n#  if defined(HAVE_MPI_STATUS_IGNORE)\n   return status == MPI_STATUSES_IGNORE || status == MPI_STATUS_IGNORE;\n#  else\n   return False;\n#  endif\n}\n\n/* Get the 'extent' of a type.  Note, as per the MPI spec this\n   includes whatever padding would be required when using 'ty' in an\n   array. */\nstatic long extentOfTy ( MPI_Datatype ty )\n{\n   int      r;\n   MPI_Aint n;\n   r = PMPI_Type_extent(ty, &n);\n   assert(r == MPI_SUCCESS);\n   return (long)n;\n}\n\n/* Free up *ty, if it is safe to do so */\nstatic void maybeFreeTy ( MPI_Datatype* ty )\n{\n   int r, n_ints, n_addrs, n_dtys, tycon;\n\n   r = PMPI_Type_get_envelope( *ty, &n_ints, &n_addrs, &n_dtys, &tycon );\n   assert(r == MPI_SUCCESS);\n\n   /* can't free named types */\n   if (tycon == MPI_COMBINER_NAMED)\n      return;\n\n   /* some kinds of structs are predefined so we can't free them\n      either. */\n   if (*ty == MPI_FLOAT_INT || *ty == MPI_DOUBLE_INT \n       || *ty == MPI_LONG_INT || *ty == MPI_2INT \n       || *ty == MPI_SHORT_INT || *ty == MPI_LONG_DOUBLE_INT)\n      return;\n\n   /* Looks OK - free it. */\n   if (0) {\n      /* show me what you're about to free .. */\n      fprintf(stderr, \"freeing combiner \");\n      showCombiner(stderr,tycon);\n      fprintf(stderr, \" ty= \");\n      showTy(stderr,*ty);\n      fprintf(stderr,\"\\n\");\n   }\n   r = PMPI_Type_free(ty);\n   assert(r == MPI_SUCCESS);\n}\n\n/* How big is a \"named\" (base) type?  Returns 0 if not known.  Note.\n   There is a subtlety, which is that this is required to return the\n   exact size of one item of the type, NOT the size of it when padded\n   suitably to make an array of them.  In particular that's why the\n   size of LONG_DOUBLE is computed by looking at the result of doing a\n   long double store, rather than just asking what is the sizeof(long\n   double).\n\n   For LONG_DOUBLE on x86-linux and amd64-linux my impression is that\n   the right answer is 10 even though sizeof(long double) says 12 and\n   16 respectively.  On ppc32-linux it appears to be 16.\n\n   Ref: MPI 1.1 doc p18 */\nstatic long sizeofOneNamedTy ( MPI_Datatype ty )\n{\n   if (ty == MPI_CHAR)           return sizeof(signed char);\n   if (ty == MPI_SHORT)          return sizeof(signed short int);\n   if (ty == MPI_INT)            return sizeof(signed int);\n   if (ty == MPI_LONG)           return sizeof(signed long int);\n   if (ty == MPI_UNSIGNED_CHAR)  return sizeof(unsigned char);\n   if (ty == MPI_UNSIGNED_SHORT) return sizeof(unsigned short int);\n   if (ty == MPI_UNSIGNED)       return sizeof(unsigned int);\n   if (ty == MPI_UNSIGNED_LONG)  return sizeof(unsigned long int);\n   if (ty == MPI_FLOAT)          return sizeof(float);\n   if (ty == MPI_DOUBLE)         return sizeof(double);\n   if (ty == MPI_BYTE)           return 1;\n   if (ty == MPI_LONG_DOUBLE)    return sizeof_long_double_image();\n   if (ty == MPI_PACKED)         return 1;\n   if (ty == MPI_LONG_LONG_INT)  return sizeof(signed long long int);\n\n#  if defined(MPI_REAL8)\n   if (ty == MPI_REAL8)          return 8; /* MPI2 spec */;\n#  endif\n#  if defined(MPI_REAL4)\n   if (ty == MPI_REAL4)          return 4; /* MPI2 spec */;\n#  endif\n#  if defined(MPI_REAL)\n   if (ty == MPI_REAL)           return 4; /* MPI2 spec */;\n#  endif\n#  if defined(MPI_INTEGER8)\n   if (ty == MPI_INTEGER8)       return 8; /* MPI2 spec */;\n#  endif\n#  if defined(MPI_INTEGER4)\n   if (ty == MPI_INTEGER4)       return 4; /* MPI2 spec */;\n#  endif\n#  if defined(MPI_INTEGER)\n   if (ty == MPI_INTEGER)        return 4; /* MPI2 spec */;\n#  endif\n#  if defined(MPI_DOUBLE_PRECISION)\n   if (ty == MPI_DOUBLE_PRECISION) return 8; /* MPI2 spec */;\n#  endif\n\n   /* new in MPI2: */\n#  if defined(MPI_WCHAR)\n   if (ty == MPI_WCHAR)              return 2; /* MPI2 spec */;\n#  endif\n#  if defined(MPI_SIGNED_CHAR)\n   if (ty == MPI_SIGNED_CHAR)        return 1; /* MPI2 spec */;\n#  endif\n#  if defined(MPI_UNSIGNED_LONG_LONG)\n   if (ty == MPI_UNSIGNED_LONG_LONG) return 8; /* MPI2 spec */;\n#  endif\n#  if defined(MPI_COMPLEX)\n   if (ty == MPI_COMPLEX)            return 2 * 4; /* MPI2 spec */\n#  endif\n#  if defined(MPI_DOUBLE_COMPLEX)\n   if (ty == MPI_DOUBLE_COMPLEX)     return 2 * 8; /* MPI2 spec */\n#  endif\n#  if defined(MPI_LOGICAL)\n   if (ty == MPI_LOGICAL)            return 4; /* MPI2 spec */\n#  endif\n#  if defined(MPI_2INTEGER)\n   if (ty == MPI_2INTEGER)      return 2 * 4; /* undocumented in MPI2 */\n#  endif\n#  if defined(MPI_2COMPLEX)\n   if (ty == MPI_2COMPLEX)      return 2 * 8; /* undocumented in MPI2 */\n#  endif\n#  if defined(MPI_2DOUBLE_COMPLEX)\n   /* 32: this is how openmpi-1.2.2 behaves on x86-linux, but I have\n      really no idea if this is right. */\n   if (ty == MPI_2DOUBLE_COMPLEX)   return 32; /* undocumented in MPI2 */\n#  endif\n#  if defined(MPI_2REAL)\n   if (ty == MPI_2REAL)              return 2 * 4; /* undocumented in MPI2 */\n#  endif\n#  if defined(MPI_2DOUBLE_PRECISION)\n   if (ty == MPI_2DOUBLE_PRECISION)  return 2 * 8; /* undocumented in MPI2 */\n#  endif\n#  if defined(MPI_CHARACTER)\n   if (ty == MPI_CHARACTER)          return 1; /* MPI2 spec */\n#  endif\n\n   /* Note: the following are named structs, not named basic types,\n      and so are not handled here:\n         FLOAT_INT DOUBLE_INT LONG_INT 2INT SHORT_INT LONG_DOUBLE_INT\n      My guess is they are probably for doing max-w-index style\n      reductions, the INT carrying the index of the max/min and the\n      other type its actual value.\n   */\n   return 0;\n}\n\n\n/* Find the size of long double image (not 'sizeof(long double)').\n   See comments in sizeofOneNamedTy. \n*/\nstatic long sizeof_long_double_image ( void )\n{\n   long i;\n   unsigned char* p;\n   static long cached_result = 0;\n\n   /* Hopefully we have it already. */\n   if (cached_result != 0) {\n      assert(cached_result == 10 || cached_result == 16 || cached_result == 8);\n      return cached_result;\n   }\n\n   /* No?  Then we'll have to compute it.  This isn't thread-safe but\n      it doesn't really matter since all races to compute it should\n      produce the same answer. */\n   p = malloc(64);\n   assert(p);\n   for (i = 0; i < 64; i++)\n      p[i] = 0x55;\n\n   /* Write a value which isn't known at compile time and therefore\n      must come out of a register.  If we just store a constant here,\n      some compilers write more data than a store from a machine\n      register would.  Therefore we have to force a store from a\n      machine register by storing a value which isn't known at compile\n      time.  Since getpid() will return a value < 1 million, turn it\n      into a zero by dividing by 1e+30. */\n   *(long double*)(&p[16]) = (long double)(1.0e-30 * (double)getpid());\n\n   for (i = 0; i < 16; i++) {\n      assert(p[i] == 0x55);\n      assert(p[i+48] == 0x55);\n   }\n   for (i = 16; i <= 48; i++) {\n      if (p[i] == 0x55)\n         break;\n   }\n\n   assert(i < 48);\n   assert(i > 16);\n   free(p);\n   cached_result = i - 16;\n\n   if (0) \n      printf(\"sizeof_long_double_image: computed %d\\n\", (int)cached_result);\n\n   assert(cached_result == 10 || cached_result == 16 || cached_result == 8);\n   return cached_result;\n}\n\n\n/*------------------------------------------------------------*/\n/*--- Unpicking datatypes                                  ---*/\n/*------------------------------------------------------------*/\n\nstatic __inline__\nvoid walk_type_array ( void(*f)(void*,long), char* base, \n                       MPI_Datatype ty, long count );\n\n\n/* Walk over all fragments of the object of type 'ty' with base\n   address 'base', and apply 'f' to the start/length of each\n   contiguous fragment. */\nstatic \nvoid walk_type ( void(*f)(void*,long), char* base, MPI_Datatype ty )\n{\n   int  r, n_ints, n_addrs, n_dtys, tycon;\n   long ex, i;\n   int*          ints  = NULL;\n   MPI_Aint*     addrs = NULL;\n   MPI_Datatype* dtys  = NULL;\n\n   /* Stuff for limiting how much complaining text it spews out */\n   static int complaints = 3;\n   static int last_complained_about_tycon = -987654321; /* presumably bogus */\n\n   if (0)\n      printf(\"walk_type %p\\n\", (void*)(unsigned long)ty);\n\n   r = PMPI_Type_get_envelope( ty, &n_ints, &n_addrs, &n_dtys, &tycon );\n   assert(r == MPI_SUCCESS);\n\n   /* Handle the base cases fast(er/ish). */\n   if (tycon == MPI_COMBINER_NAMED) {\n      long sz = sizeofOneNamedTy(ty);\n      if (sz > 0) {\n         f(base, sz);\n         return;\n      }\n      /* Hmm.  Perhaps it's a named struct?  Unfortunately we can't\n         take them to bits so we have to do a really ugly hack, which\n         makes assumptions about how the MPI implementation has laid\n         out these types.  At least Open MPI 1.0.1 appears to put\n         the 'val' field first.  MPICH2 agrees.\n      */\n      if (ty == MPI_2INT) {\n         typedef struct { int val; int loc; } Ty;\n         f(base + offsetof(Ty,val), sizeof(int));\n         f(base + offsetof(Ty,loc), sizeof(int));\n         return;\n      }\n      if (ty == MPI_LONG_INT) {\n         typedef struct { long val; int loc; } Ty;\n         f(base + offsetof(Ty,val), sizeof(long));\n         f(base + offsetof(Ty,loc), sizeof(int));\n         return;\n      }\n      if (ty == MPI_DOUBLE_INT) {\n         typedef struct { double val; int loc; } Ty;\n         f(base + offsetof(Ty,val), sizeof(double));\n         f(base + offsetof(Ty,loc), sizeof(int));\n         return;\n      }\n      if (ty == MPI_SHORT_INT) {\n         typedef struct { short val; int loc; } Ty;\n         f(base + offsetof(Ty,val), sizeof(short));\n         f(base + offsetof(Ty,loc), sizeof(int));\n         return;\n      }\n      if (ty == MPI_FLOAT_INT) {\n         typedef struct { float val; int loc; } Ty;\n         f(base + offsetof(Ty,val), sizeof(float));\n         f(base + offsetof(Ty,loc), sizeof(int));\n         return;\n      }\n      if (ty == MPI_LONG_DOUBLE_INT) {\n         typedef struct { long double val; int loc; } Ty;\n         f(base + offsetof(Ty,val), sizeof_long_double_image());\n         f(base + offsetof(Ty,loc), sizeof(int));\n         return;\n      }\n      if (ty == MPI_LB || ty == MPI_UB)\n         return; /* have zero size, so nothing needs to be done */\n      goto unhandled;\n      /*NOTREACHED*/\n   }\n\n   if (0) {\n      ex = extentOfTy(ty);\n      printf(\"tycon 0x%llx %d %d %d (ext %d)\\n\",\n             (unsigned long long int)tycon, \n             n_ints, n_addrs, n_dtys, (int)ex );\n   }\n\n   /* Now safe to do MPI_Type_get_contents */\n   assert(n_ints  >= 0);\n   assert(n_addrs >= 0);\n   assert(n_dtys  >= 0);\n\n   if (n_ints  > 0) {\n      ints = malloc(n_ints * sizeof(int));\n      assert(ints);\n   }\n   if (n_addrs > 0) {\n      addrs = malloc(n_addrs * sizeof(MPI_Aint));\n      assert(addrs);\n   }\n   if (n_dtys  > 0) {\n      dtys = malloc(n_dtys * sizeof(MPI_Datatype));\n      assert(dtys);\n   }\n\n   r = PMPI_Type_get_contents( ty, n_ints, n_addrs, n_dtys,\n                                   ints, addrs, dtys );\n   assert(r == MPI_SUCCESS);\n\n   switch (tycon) {\n\n      case MPI_COMBINER_CONTIGUOUS:\n         assert(n_ints == 1 && n_addrs == 0 && n_dtys == 1);\n\t walk_type_array( f, base, dtys[0], ints[0] );\n         maybeFreeTy( &dtys[0] );\n         break;\n\n      case MPI_COMBINER_VECTOR:\n         assert(n_ints == 3 && n_addrs == 0 && n_dtys == 1);\n         ex = extentOfTy(dtys[0]);\n         if (0)\n         printf(\"vector count %d x (bl %d stride %d)\\n\", \n                (int)ints[0], (int)ints[1], (int)ints[2]);\n         for (i = 0; i < ints[0]; i++) {\n            walk_type_array( f, base + i * ints[2]/*stride*/ * ex,\n                                dtys[0], ints[1]/*blocklength*/ );\n         }\n         maybeFreeTy( &dtys[0] );\n         break;\n\n      case MPI_COMBINER_HVECTOR:\n         assert(n_ints == 2 && n_addrs == 1 && n_dtys == 1);\n         ex = extentOfTy(dtys[0]);\n         if (0)\n         printf(\"hvector count %d x (bl %d hstride %d)\\n\", \n                (int)ints[0], (int)ints[1], (int)addrs[0]);\n         for (i = 0; i < ints[0]; i++) {\n            walk_type_array( f, base + i * addrs[0]/*hstride*/,\n                                dtys[0], ints[1]/*blocklength*/ );\n         }\n         maybeFreeTy( &dtys[0] );\n         break;\n\n      case MPI_COMBINER_INDEXED:\n         assert(n_addrs == 0 && n_dtys == 1);\n         assert(n_ints > 0);\n         assert(n_ints == 2 * ints[0] + 1);\n         ex = extentOfTy(dtys[0]);\n         for (i = 0; i < ints[0]; i++) {\n            if (0) \n            printf(\"indexed (elem %d) off %d copies %d\\n\",\n                   (int)i, ints[i+1+ints[0]], ints[i+1] );\n            walk_type_array( f, base + ex * ints[i+1+ints[0]], \n                                dtys[0], ints[i+1] );\n         }\n         maybeFreeTy( &dtys[0] );\n         break;\n\n      case MPI_COMBINER_HINDEXED:\n         assert(n_ints > 0);\n         assert(n_ints == ints[0] + 1);\n         assert(n_addrs == ints[0] && n_dtys == 1);\n         ex = extentOfTy(dtys[0]);\n         for (i = 0; i < ints[0]; i++) {\n            if (0) \n            printf(\"hindexed (elem %d) hoff %d copies %d\\n\",\n                   (int)i, (int)addrs[i], ints[i+1] );\n            walk_type_array( f, base + addrs[i], \n                                dtys[0], ints[i+1] );\n         }\n         maybeFreeTy( &dtys[0] );\n         break;\n\n      case MPI_COMBINER_STRUCT:\n         assert(n_addrs == n_ints-1);\n         assert(n_dtys  == n_ints-1);\n         assert(n_ints > 0);\n         assert(n_ints == ints[0] + 1);\n\t for (i = 0; i < ints[0]; i++) {\n            if (0)\n            printf(\"struct (elem %d limit %d) hoff %d copies %d\\n\", \n                   (int)i, (int)ints[0], (int)addrs[i], (int)ints[i+1]);\n            walk_type_array( f, base + addrs[i], dtys[i], (long)ints[i+1] );\n            maybeFreeTy( &dtys[i] );\n\t }\n         break;\n\n      default:\n         goto unhandled;\n\n   }\n\n   /* normal exit */\n   if (ints)  free(ints);\n   if (addrs) free(addrs);\n   if (dtys)  free(dtys);\n   return;\n\n  unhandled:\n   /* Complain, but limit the amount of complaining that can happen to\n      the first 3 different unhandled tycons that show up, so as to\n      avoid swamping users with thousands of duplicate messages. */\n   if (complaints > 0 && tycon != last_complained_about_tycon) {\n      complaints--;\n      last_complained_about_tycon = tycon;\n      if (tycon == MPI_COMBINER_NAMED) {\n         fprintf(stderr, \"%s %5d: walk_type: unhandled base type 0x%lx \",\n                         preamble, my_pid, (long)ty);\n         showTy(stderr, ty);\n         fprintf(stderr, \"\\n\");\n      } else {\n         fprintf(stderr, \"%s %5d: walk_type: unhandled combiner 0x%lx\\n\",\n                         preamble, my_pid, (long)tycon);\n      }\n   }\n   if (ints)  free(ints);\n   if (addrs) free(addrs);\n   if (dtys)  free(dtys);\n   if (opt_missing >= 2)\n      barf(\"walk_type: unhandled combiner, strict checking selected\");\n}\n\n\n/* Same as walk_type but apply 'f' to every element in an array of\n   'count' items starting at 'base'.  The only purpose of pushing this\n   into a different routine is so it can attempt to optimise the case\n   where the array elements are contiguous and packed together without\n   holes. */\nstatic __inline__\nvoid walk_type_array ( void(*f)(void*,long), char* base, \n                       MPI_Datatype elemTy, long count )\n{\n   long i, ex;\n\n   assert(sizeof(unsigned long) == sizeof(char*));\n\n   /* First see if we can do this the fast way. */\n   ex = sizeofOneNamedTy(elemTy);\n\n   if ( /* ty is a primitive type with power-of-2 size */\n        (ex == 8 || ex == 4 || ex == 2 || ex == 1)\n        && /* base is suitably aligned for ty */\n           ( ((unsigned long)base) & (ex-1)) == 0)  {\n\n      /* We're sure it's contiguous, so just paint/check it in one\n         go. */\n     if (0) printf(\"walk_type_array fast %ld of size %ld\\n\", count, ex );\n     f ( base, count * ex );\n\n   } else {\n\n      /* Bad news.  We have to futz with each element individually.\n         This could be very expensive.\n\n         Note: subtle.  If ty is LONG_DOUBLE then the extent will be\n         12, so the following loop will jump along in steps of 12, but\n         the size painted by walk_type will be 10 since it uses\n         sizeofOneNamedTy to establish the size of base types.  Which\n         is what we need to happen. */\n      ex = extentOfTy(elemTy);\n      if (0) printf(\"walk_type_array SLOW %ld of size %ld\\n\", count, ex );\n      for (i = 0; i < count; i++)\n         walk_type( f, base + i * ex, elemTy );\n\n   }\n}\n\n\n/* Hook so it's visible from outside (can be handy to dlopen/dlsym\n   it) */\nvoid mpiwrap_walk_type_EXTERNALLY_VISIBLE\n    ( void(*f)(void*,long), char* base, MPI_Datatype ty )\n{\n   walk_type(f, base, ty);\n}\n\n\n/*------------------------------------------------------------*/\n/*--- Address-range helpers                                ---*/\n/*------------------------------------------------------------*/\n\n/* ----------------\n   Do corresponding checks on memory areas defined using a \n   straightforward (start, length) description.\n   ----------------\n*/\n\nstatic __inline__\nvoid check_mem_is_defined_untyped ( void* buffer, long nbytes )\n{\n   if (nbytes > 0) {\n      VALGRIND_CHECK_MEM_IS_DEFINED(buffer, nbytes);\n   }\n}\n\nstatic __inline__\nvoid check_mem_is_addressable_untyped ( void* buffer, long nbytes )\n{\n   if (nbytes > 0) {\n      VALGRIND_CHECK_MEM_IS_ADDRESSABLE(buffer, nbytes);\n   }\n}\n\nstatic __inline__\nvoid make_mem_defined_if_addressable_untyped ( void* buffer, long nbytes )\n{\n   if (nbytes > 0) {\n      VALGRIND_MAKE_MEM_DEFINED_IF_ADDRESSABLE(buffer, nbytes);\n   }\n}\n\nstatic __inline__\nvoid make_mem_defined_if_addressable_if_success_untyped ( int err, \n                                       void* buffer, long nbytes )\n{\n   if (err == MPI_SUCCESS && nbytes > 0) {\n      VALGRIND_MAKE_MEM_DEFINED_IF_ADDRESSABLE(buffer, nbytes);\n   }\n}\n\n\n/* ----------------\n   Do checks on memory areas defined using the MPI (buffer, count,\n   type) convention.\n   ----------------\n*/\n\n/* Check that the specified area is both addressible and contains\n   initialised data, and cause V to complain if not. */\n\nstatic __inline__\nvoid check_mem_is_defined ( char* buffer, long count, MPI_Datatype datatype )\n{\n   walk_type_array( check_mem_is_defined_untyped, buffer, datatype, count );\n}\n\n\n/* Check that the specified area is addressible, and cause V to\n   complain if not. Doesn't matter whether the data there is\n   initialised or not. */\n\nstatic __inline__\nvoid check_mem_is_addressable ( void *buffer, long count, MPI_Datatype datatype )\n{\n   walk_type_array( check_mem_is_addressable_untyped, buffer, datatype, count );\n}\n\n\n/* Set the specified area to 'defined for each byte which is\n   addressible' state. */\n\nstatic __inline__\nvoid make_mem_defined_if_addressable ( void *buffer, int count, MPI_Datatype datatype )\n{\n   walk_type_array( make_mem_defined_if_addressable_untyped,\n                    buffer, datatype, count );\n}\n\nstatic __inline__\nvoid \nmake_mem_defined_if_addressable_if_success ( int err, void *buffer, int count, \n                                             MPI_Datatype datatype )\n{\n   if (err == MPI_SUCCESS)\n      make_mem_defined_if_addressable(buffer, count, datatype);\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- The wrappers proper.   They are listed in the order  ---*/\n/*--- in which they appear in \"MPI: A Message-Passing      ---*/\n/*--- Interface Standard, MPIF, Nov 15 2003\" (the MPI 1.1  ---*/\n/*--- spec.  All unimplemented wrappers are listed at the  ---*/\n/*--- end of the file.  The list of function names is      ---*/\n/*--- taken from the headers of Open MPI svn r9191.        ---*/\n/*--- Hopefully it is a complete list of all the MPI 2     ---*/\n/*--- functions.                                           ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* Handy abbreviation */\n#define WRAPPER_FOR(name) I_WRAP_FNNAME_U(name)\n\n/* Generates (conceptually) a wrapper which does nothing.  In\n   fact just generate no wrapper at all. */\n#define HAS_NO_WRAPPER(basename) /* */\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 3.2, Blocking Send and Receive Operations        ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* --- {,B,S,R}Send --- */\n/* pre: rd: (buf,count,datatype) */\nstatic\nint generic_Send(void *buf, int count, MPI_Datatype datatype, \n                            int dest, int tag, MPI_Comm comm)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"{,B,S,R}Send\");\n   check_mem_is_defined(buf, count, datatype);\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_6W(err, fn, buf,count,datatype,dest,tag,comm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   after(\"{,B,S,R}Send\", err);\n   return err;\n}\nint WRAPPER_FOR(PMPI_Send)(void *buf, int count, MPI_Datatype datatype, \n                           int dest, int tag, MPI_Comm comm) {\n   return generic_Send(buf,count,datatype, dest,tag,comm);\n}\nint WRAPPER_FOR(PMPI_Bsend)(void *buf, int count, MPI_Datatype datatype, \n                            int dest, int tag, MPI_Comm comm) {\n   return generic_Send(buf,count,datatype, dest,tag,comm);\n}\nint WRAPPER_FOR(PMPI_Ssend)(void *buf, int count, MPI_Datatype datatype, \n                            int dest, int tag, MPI_Comm comm) {\n   return generic_Send(buf,count,datatype, dest,tag,comm);\n}\nint WRAPPER_FOR(PMPI_Rsend)(void *buf, int count, MPI_Datatype datatype, \n                            int dest, int tag, MPI_Comm comm) {\n   return generic_Send(buf,count,datatype, dest,tag,comm);\n}\n\n/* --- Recv --- */\n/* pre:  must be writable: (buf,count,datatype)\n         must be writable: status\n   post: make readable: (buf,recv_count,datatype)\n         where recv_count is determined from *status\n*/\nint WRAPPER_FOR(PMPI_Recv)(void *buf, int count, MPI_Datatype datatype, \n                           int source, int tag, \n                           MPI_Comm comm, MPI_Status *status)\n{\n   OrigFn     fn;\n   int        err, recv_count = 0;\n   MPI_Status fake_status;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Recv\");\n   if (isMSI(status))\n      status = &fake_status;\n   check_mem_is_addressable(buf, count, datatype);\n   check_mem_is_addressable_untyped(status, sizeof(*status));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_7W(err, fn, buf,count,datatype,source,tag,comm,status);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success_untyped(err, status, sizeof(*status));\n   if (err == MPI_SUCCESS && count_from_Status(&recv_count,datatype,status)) {\n      make_mem_defined_if_addressable(buf, recv_count, datatype);\n   }\n   after(\"Recv\", err);\n   return err;\n}\n\n/* --- Get_count --- */\n/* pre:  must be readable: *status\n   post: make defined: *count -- don't bother, libmpi will surely do this\n*/\nint WRAPPER_FOR(PMPI_Get_count)(MPI_Status* status, \n                                MPI_Datatype ty, int* count )\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Get_count\");\n   check_mem_is_defined_untyped(status, sizeof(*status));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WWW(err, fn, status,ty,count);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   after(\"Get_count\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 3.7, Nonblocking communication                   ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* Maintain a table that makes it possible for the wrappers to\n   complete MPI_Irecv successfully.\n\n   The issue is that MPI_Irecv states the recv buffer and returns\n   immediately, giving a handle (MPI_Request) for the transaction.\n   Later the user will have to poll for completion with MPI_Wait etc,\n   and at that point these wrappers have to paint the recv buffer.\n   But the recv buffer details are not presented to MPI_Wait - only\n   the handle is.  We therefore have to use a shadow table\n   (sReqs{,_size,_used,_lock}) which associates uncompleted\n   MPI_Requests with the corresponding buffer address/count/type.\n\n   Only read requests are placed in the table, since there is no need\n   to do any buffer painting following completion of an Isend - all\n   the checks for that are done at the time Isend is called.\n\n   Care has to be take to remove completed requests from the table.\n\n   Access to the table is guarded by sReqs_lock so as to make it\n   thread-safe.\n*/\n\ntypedef\n   struct {\n      Bool         inUse;\n      MPI_Request  key;\n      void*        buf;\n      int          count;\n      MPI_Datatype datatype;\n   }\n   ShadowRequest;\n\nstatic ShadowRequest*  sReqs      = NULL;\nstatic int             sReqs_size = 0;\nstatic int             sReqs_used = 0;\nstatic pthread_mutex_t sReqs_lock = PTHREAD_MUTEX_INITIALIZER;\n\n#define LOCK_SREQS                                  \\\n  do { int pr = pthread_mutex_lock(&sReqs_lock);    \\\n       assert(pr == 0);                             \\\n  } while (0)\n\n#define UNLOCK_SREQS                                \\\n  do { int pr = pthread_mutex_unlock(&sReqs_lock);  \\\n       assert(pr == 0);                             \\\n  } while (0)\n\n\n/* Ensure the sReqs expandable array has at least one free slot, by\n   copying it into a larger one if necessary.  NOTE: sReqs_lock is\n   held throughout this procedure.*/\nstatic void ensure_sReq_space ( void )\n{\n   int            i;\n   ShadowRequest* sReqs2;\n   if (sReqs_used == sReqs_size) {\n      sReqs_size = sReqs_size==0 ? 2 : 2*sReqs_size;\n      sReqs2 = malloc( sReqs_size * sizeof(ShadowRequest) );\n      if (sReqs2 == NULL) {\n         UNLOCK_SREQS;\n         barf(\"add_shadow_Request: malloc failed.\\n\");\n      }\n      for (i = 0; i < sReqs_used; i++)\n         sReqs2[i] = sReqs[i];\n      if (sReqs)\n         free(sReqs);\n      sReqs = sReqs2;\n   }\n   assert(sReqs_used < sReqs_size);\n}\n\n\n/* Find shadow info for 'request', or NULL if none. */\n\nstatic \nShadowRequest* find_shadow_Request ( MPI_Request request )\n{\n   ShadowRequest* ret = NULL;\n   int i;\n   LOCK_SREQS;\n   for (i = 0; i < sReqs_used; i++) {\n      if (sReqs[i].inUse && eq_MPI_Request(sReqs[i].key,request)) {\n         ret = &sReqs[i];\n         break;\n      }\n   }\n   UNLOCK_SREQS;\n   return ret;\n}\n\n\n/* Delete shadow info for 'request', if any. */\n\nstatic void delete_shadow_Request ( MPI_Request request )\n{\n   int i;\n   LOCK_SREQS;\n   for (i = 0; i < sReqs_used; i++) {\n      if (sReqs[i].inUse && eq_MPI_Request(sReqs[i].key,request)) {\n         sReqs[i].inUse = False;\n         break;\n      }\n   }\n   UNLOCK_SREQS;\n}\n\n\n/* Add a shadow for 'request', overwriting any old binding for it. */\n\nstatic \nvoid add_shadow_Request( MPI_Request request, \n                         void* buf, int count, \n                         MPI_Datatype datatype )\n{\n   int i, ix = -1;\n   LOCK_SREQS;\n   assert(sReqs_used >= 0);\n   assert(sReqs_size >= 0);\n   assert(sReqs_used <= sReqs_size);\n   if (sReqs == NULL) assert(sReqs_size == 0);\n\n   /* First of all see if we already have a binding for this key; if\n      so just replace it, and have done. */\n   for (i = 0; i < sReqs_used; i++) {\n      if (sReqs[i].inUse && eq_MPI_Request(sReqs[i].key,request)) {\n         ix = i;\n         break;\n      }\n   }\n\n   if (ix < 0) {\n      /* Ok, we don't have it, so will have to add it.  First search\n         to see if there is an existing empty slot. */\n      for (i = 0; i < sReqs_used; i++) {\n         if (!sReqs[i].inUse) {\n            ix = i;\n            break;\n         }\n      }\n   }\n\n   /* No empty slots.  Allocate a new one. */\n   if (ix < 0) {\n      ensure_sReq_space();\n      assert(sReqs_used < sReqs_size);\n      ix = sReqs_used;\n      sReqs_used++;\n   }\n\n   assert(ix >= 0 && ix < sReqs_used);\n   assert(sReqs_used <= sReqs_size);\n\n   sReqs[ix].inUse    = True;\n   sReqs[ix].key      = request;\n   sReqs[ix].buf      = buf;\n   sReqs[ix].count    = count;\n   sReqs[ix].datatype = datatype;\n\n   UNLOCK_SREQS;\n   if (opt_verbosity > 1)\n      fprintf(stderr, \"%s %5d: sReq+ 0x%lx -> b/c/d %p/%d/0x%lx [slot %d]\\n\",\n                      preamble, my_pid, (unsigned long)request, \n                                buf, count, (long)datatype, ix);\n}\n\nstatic \nMPI_Request* clone_Request_array ( int count, MPI_Request* orig )\n{\n   MPI_Request* copy;\n   int i;\n   LOCK_SREQS;\n   if (count < 0) \n      count = 0; /* Hmm.  Call Mulder and Scully. */\n   copy = malloc( count * sizeof(MPI_Request) );\n   if (copy == NULL && count > 0) {\n      UNLOCK_SREQS;\n      barf(\"clone_Request_array: malloc failed\");\n   }\n   for (i = 0; i < count; i++)\n      copy[i] = orig[i];\n   UNLOCK_SREQS;\n   return copy;\n}\n\n#undef LOCK_SREQS\n#undef UNLOCK_SREQS\n\n\nstatic void maybe_complete ( Bool         error_in_status,\n                             MPI_Request  request_before,\n                             MPI_Request  request_after,\n                             MPI_Status*  status )\n{\n   int recv_count = 0;\n   ShadowRequest* shadow;\n   /* How do we know if this is an Irecv request that has now\n      finished successfully? \n      \n      request_before isn't MPI_REQUEST_NULL\n      and request_before is found in the shadow table\n      and request_after *is* MPI_REQUEST_NULL\n      and (if error_in_status then status.MPI_ERROR is MPI_SUCCESS)\n\n      (when error_in_status == False, then we expect not to get\n      called at all if there was an error.)\n   */\n   if (request_before != MPI_REQUEST_NULL\n       && request_after == MPI_REQUEST_NULL\n       && (error_in_status ? status->MPI_ERROR == MPI_SUCCESS : True)\n       && ( (shadow=find_shadow_Request(request_before)) != NULL) ) {\n      /* The Irecv detailed in 'shadow' completed.  Paint the result\n         buffer, and delete the entry. */\n      if (count_from_Status(&recv_count, shadow->datatype, status)) {\n         make_mem_defined_if_addressable(shadow->buf, recv_count, shadow->datatype);\n         if (opt_verbosity > 1)\n            fprintf(stderr, \"%s %5d: sReq- %p (completed)\\n\", \n                            preamble, my_pid, request_before);\n      }\n      delete_shadow_Request(request_before);\n   }\n}\n\n\n/* --- Isend --- */\n/* rd: (buf,count,datatype) */\n/* wr: *request */\nstatic __inline__\nint generic_Isend(void *buf, int count, MPI_Datatype datatype, \n                             int dest, int tag, MPI_Comm comm, \n                             MPI_Request* request)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"{,B,S,R}Isend\");\n   check_mem_is_defined(buf, count, datatype);\n   check_mem_is_addressable_untyped(request, sizeof(*request));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_7W(err, fn, buf,count,datatype,dest,tag,comm,request);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success_untyped(err, request, sizeof(*request));\n   after(\"{,B,S,R}Isend\", err);\n   return err;\n}\nint WRAPPER_FOR(PMPI_Isend)(void *buf, int count, MPI_Datatype datatype, \n                            int dest, int tag, MPI_Comm comm, \n                            MPI_Request* request) {\n   return generic_Isend(buf,count,datatype, dest,tag,comm, request);\n}\nint WRAPPER_FOR(PMPI_Ibsend)(void *buf, int count, MPI_Datatype datatype, \n                             int dest, int tag, MPI_Comm comm, \n                             MPI_Request* request) {\n   return generic_Isend(buf,count,datatype, dest,tag,comm, request);\n}\nint WRAPPER_FOR(PMPI_Issend)(void *buf, int count, MPI_Datatype datatype, \n                             int dest, int tag, MPI_Comm comm, \n                             MPI_Request* request) {\n   return generic_Isend(buf,count,datatype, dest,tag,comm, request);\n}\nint WRAPPER_FOR(PMPI_Irsend)(void *buf, int count, MPI_Datatype datatype, \n                             int dest, int tag, MPI_Comm comm, \n                             MPI_Request* request) {\n   return generic_Isend(buf,count,datatype, dest,tag,comm, request);\n}\n\n\n/* --- Irecv --- */\n/* pre:  must be writable: (buf,count,datatype), *request\n   post: make readable *request\n         add a request->(buf,count,ty) binding to the \n         shadow request table. \n*/\nint WRAPPER_FOR(PMPI_Irecv)( void* buf, int count, MPI_Datatype datatype, \n                             int source, int tag, MPI_Comm comm, \n                             MPI_Request* request )\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Irecv\");\n   check_mem_is_addressable(buf, count, datatype);\n   check_mem_is_addressable_untyped(request, sizeof(*request));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_7W(err, fn, buf,count,datatype,source,tag,comm,request);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   if (err == MPI_SUCCESS) {\n      make_mem_defined_if_addressable_untyped(request, sizeof(*request));\n      add_shadow_Request( *request, buf,count,datatype );\n   }\n   after(\"Irecv\", err);\n   return err;\n}\n\n/* --- Wait --- */\n/* The MPI1 spec (imprecisely) defines 3 request states:\n   - \"null\"     if the request is MPI_REQUEST_NULL\n   - \"inactive\" if not \"null\" and not associated with ongoing comms\n   - \"active\"   if not \"null\" and is associated with ongoing comms\n*/\nint WRAPPER_FOR(PMPI_Wait)( MPI_Request* request,\n                            MPI_Status* status )\n{\n   MPI_Request  request_before;\n   MPI_Status   fake_status;\n   OrigFn       fn;\n   int          err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Wait\");\n   if (isMSI(status))\n      status = &fake_status;\n   check_mem_is_addressable_untyped(status, sizeof(MPI_Status));\n   check_mem_is_defined_untyped(request, sizeof(MPI_Request));\n   request_before = *request;\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WW(err, fn, request,status);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   if (err == MPI_SUCCESS) {\n      maybe_complete(False/*err in status?*/, \n                     request_before, *request, status);\n      make_mem_defined_if_addressable_untyped(status, sizeof(MPI_Status));\n   }\n   after(\"Wait\", err);\n   return err;\n}\n\n/* --- Waitany --- */\nint WRAPPER_FOR(PMPI_Waitany)( int count,\n                               MPI_Request* requests,\n                               int* index,\n                               MPI_Status* status )\n{\n   MPI_Request* requests_before = NULL;\n   MPI_Status   fake_status;\n   OrigFn       fn;\n   int          err, i;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Waitany\");\n   if (isMSI(status))\n      status = &fake_status;\n   if (0) fprintf(stderr, \"Waitany: %d\\n\", count);\n   check_mem_is_addressable_untyped(index, sizeof(int));\n   check_mem_is_addressable_untyped(status, sizeof(MPI_Status));\n   for (i = 0; i < count; i++) {\n      check_mem_is_defined_untyped(&requests[i], sizeof(MPI_Request));\n   }\n   requests_before = clone_Request_array( count, requests );\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WWWW(err, fn, count,requests,index,status);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   if (err == MPI_SUCCESS && *index >= 0 && *index < count) {\n      maybe_complete(False/*err in status?*/, \n                     requests_before[*index], requests[*index], status);\n      make_mem_defined_if_addressable_untyped(status, sizeof(MPI_Status));\n   }\n   if (requests_before)\n      free(requests_before);\n   after(\"Waitany\", err);\n   return err;\n}\n\n/* --- Waitall --- */\nint WRAPPER_FOR(PMPI_Waitall)( int count, \n                               MPI_Request* requests,\n                               MPI_Status* statuses )\n{\n   MPI_Request* requests_before = NULL;\n   OrigFn       fn;\n   int          err, i;\n   Bool         free_sta = False;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Waitall\");\n   if (0) fprintf(stderr, \"Waitall: %d\\n\", count);\n   if (isMSI(statuses)) {\n      free_sta = True;\n      statuses = malloc( (count < 0 ? 0 : count) * sizeof(MPI_Status) );\n   }\n   for (i = 0; i < count; i++) {\n      check_mem_is_addressable_untyped(&statuses[i], sizeof(MPI_Status));\n      check_mem_is_defined_untyped(&requests[i], sizeof(MPI_Request));\n   }\n   requests_before = clone_Request_array( count, requests );\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WWW(err, fn, count,requests,statuses);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   if (err == MPI_SUCCESS /*complete success*/\n       || err == MPI_ERR_IN_STATUS /* partial success */) {\n      Bool e_i_s = err == MPI_ERR_IN_STATUS;\n      for (i = 0; i < count; i++) {\n         maybe_complete(e_i_s, requests_before[i], requests[i], \n                               &statuses[i]);\n         make_mem_defined_if_addressable_untyped(&statuses[i],\n                                                 sizeof(MPI_Status));\n      }\n   }\n   if (requests_before)\n      free(requests_before);\n   if (free_sta)\n      free(statuses);\n   after(\"Waitall\", err);\n   return err;\n}\n\n/* --- Test --- */\n/* nonblocking version of Wait */\nint WRAPPER_FOR(PMPI_Test)( MPI_Request* request, int* flag, \n                            MPI_Status* status )\n{\n   MPI_Request  request_before;\n   MPI_Status   fake_status;\n   OrigFn       fn;\n   int          err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Test\");\n   if (isMSI(status))\n      status = &fake_status;\n   check_mem_is_addressable_untyped(status, sizeof(MPI_Status));\n   check_mem_is_addressable_untyped(flag, sizeof(int));\n   check_mem_is_defined_untyped(request, sizeof(MPI_Request));\n   request_before = *request;\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WWW(err, fn, request,flag,status);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   if (err == MPI_SUCCESS && *flag) {\n      maybe_complete(False/*err in status?*/, \n                     request_before, *request, status);\n      make_mem_defined_if_addressable_untyped(status, sizeof(MPI_Status));\n   }\n   after(\"Test\", err);\n   return err;\n}\n\n/* --- Testall --- */\n/* nonblocking version of Waitall */\nint WRAPPER_FOR(PMPI_Testall)( int count, MPI_Request* requests,\n                               int* flag, MPI_Status* statuses )\n{\n   MPI_Request* requests_before = NULL;\n   OrigFn       fn;\n   int          err, i;\n   Bool         free_sta = False;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Testall\");\n   if (0) fprintf(stderr, \"Testall: %d\\n\", count);\n   if (isMSI(statuses)) {\n      free_sta = True;\n      statuses = malloc( (count < 0 ? 0 : count) * sizeof(MPI_Status) );\n   }\n   check_mem_is_addressable_untyped(flag, sizeof(int));\n   for (i = 0; i < count; i++) {\n      check_mem_is_addressable_untyped(&statuses[i], sizeof(MPI_Status));\n      check_mem_is_defined_untyped(&requests[i], sizeof(MPI_Request));\n   }\n   requests_before = clone_Request_array( count, requests );\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WWWW(err, fn, count,requests,flag,statuses);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   /* Urk.  Is the following \"if (...)\" really right?  I don't know. */\n   if (*flag\n       && (err == MPI_SUCCESS /*complete success*/\n           || err == MPI_ERR_IN_STATUS /* partial success */)) {\n      Bool e_i_s = err == MPI_ERR_IN_STATUS;\n      for (i = 0; i < count; i++) {\n         maybe_complete(e_i_s, requests_before[i], requests[i], \n                               &statuses[i]);\n         make_mem_defined_if_addressable_untyped(&statuses[i],\n                                                 sizeof(MPI_Status));\n      }\n   }\n   if (requests_before)\n      free(requests_before);\n   if (free_sta)\n      free(statuses);\n   after(\"Testall\", err);\n   return err;\n}\n\n/* --- Iprobe --- */\n/* pre:  must-be-writable: *flag, *status */\n/* post: make-readable *flag\n         if *flag==True  make-defined *status */\nint WRAPPER_FOR(PMPI_Iprobe)(int source, int tag, \n                             MPI_Comm comm, \n                             int* flag, MPI_Status* status)\n{\n   MPI_Status fake_status;\n   OrigFn     fn;\n   int        err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Iprobe\");\n   if (isMSI(status))\n      status = &fake_status;\n   check_mem_is_addressable_untyped(flag, sizeof(*flag));\n   check_mem_is_addressable_untyped(status, sizeof(*status));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_5W(err, fn, source,tag,comm,flag,status);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   if (err == MPI_SUCCESS) {\n      make_mem_defined_if_addressable_untyped(flag, sizeof(*flag));\n      if (*flag)\n         make_mem_defined_if_addressable_untyped(status, sizeof(*status));\n   }\n   after(\"Iprobe\", err);\n   return err;\n}\n\n/* --- Probe --- */\n/* pre:  must-be-writable *status */\n/* post: make-defined *status */\nint WRAPPER_FOR(PMPI_Probe)(int source, int tag,\n                            MPI_Comm comm, MPI_Status* status)\n{\n   MPI_Status fake_status;\n   OrigFn     fn;\n   int        err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Probe\");\n   if (isMSI(status))\n      status = &fake_status;\n   check_mem_is_addressable_untyped(status, sizeof(*status));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WWWW(err, fn, source,tag,comm,status);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success_untyped(err, status, sizeof(*status));\n   after(\"Probe\", err);\n   return err;\n}\n\n/* --- Cancel --- */\n/* Wrapping PMPI_Cancel is interesting only to the extent that we need\n   to be able to detect when a request should be removed from our\n   shadow table due to cancellation. */\nint WRAPPER_FOR(PMPI_Cancel)(MPI_Request* request)\n{\n   OrigFn      fn;\n   int         err;\n   MPI_Request tmp;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Cancel\");\n   check_mem_is_addressable_untyped(request, sizeof(*request));\n   tmp = *request;\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_W(err, fn, request);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   if (err == MPI_SUCCESS)\n      delete_shadow_Request(tmp);\n   after(\"Cancel\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 3.10, Send-receive                               ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* --- Sendrecv --- */\n/* pre: must be readable: (sendbuf,sendcount,sendtype)\n        must be writable: (recvbuf,recvcount,recvtype)\n   post: make readable: (recvbuf,recvcount_actual,datatype)\n         where recvcount_actual is determined from *status\n*/\nint WRAPPER_FOR(PMPI_Sendrecv)(\n       void *sendbuf, int sendcount, MPI_Datatype sendtype,\n       int dest, int sendtag, \n       void *recvbuf, int recvcount, MPI_Datatype recvtype, \n       int source, int recvtag,\n       MPI_Comm comm,  MPI_Status *status)\n{\n   MPI_Status fake_status;\n   OrigFn     fn;\n   int        err, recvcount_actual = 0;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Sendrecv\");\n   if (isMSI(status))\n      status = &fake_status;\n   check_mem_is_defined(sendbuf, sendcount, sendtype);\n   check_mem_is_addressable(recvbuf, recvcount, recvtype);\n   check_mem_is_addressable_untyped(status, sizeof(*status));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_12W(err, fn, sendbuf,sendcount,sendtype,dest,sendtag,\n                          recvbuf,recvcount,recvtype,source,recvtag,\n                          comm,status);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success_untyped(err, status, sizeof(*status));\n   if (err == MPI_SUCCESS \n       && count_from_Status(&recvcount_actual,recvtype,status)) {\n      make_mem_defined_if_addressable(recvbuf, recvcount_actual, recvtype);\n   }\n   after(\"Sendrecv\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 3.12, Derived datatypes                          ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* --- Address --- */\n/* Does this have anything worth checking? */\nHAS_NO_WRAPPER(Address)\n\n/* --- MPI 2 stuff --- */\n/* Type_extent, Type_get_contents and Type_get_envelope sometimes get\n   used intensively by the type walker (walk_type).  There's no reason\n   why they couldn't be properly wrapped if needed, but doing so slows\n   everything down, so don't bother until needed. */\nHAS_NO_WRAPPER(Type_extent)\nHAS_NO_WRAPPER(Type_get_contents)\nHAS_NO_WRAPPER(Type_get_envelope)\n\n/* --- Type_commit --- */\nint WRAPPER_FOR(PMPI_Type_commit)( MPI_Datatype* ty )\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Type_commit\");\n   check_mem_is_defined_untyped(ty, sizeof(*ty));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_W(err, fn, ty);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   after(\"Type_commit\", err);\n   return err;\n}\n\n/* --- Type_free --- */\nint WRAPPER_FOR(PMPI_Type_free)( MPI_Datatype* ty )\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Type_free\");\n   check_mem_is_defined_untyped(ty, sizeof(*ty));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_W(err, fn, ty);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   after(\"Type_free\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 3.13, Pack and unpack                            ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* --- Pack --- */\n/* pre: must be readable: position\n        must be readable: (inbuf,incount,datatype)\n        must be writable: outbuf[0 .. outsize-1]\n        must be writable: outbuf[*position .. \n                                 *position - 1 \n                                 + however much space PMPI_Pack_size \n                                   says we will need]\n   post: make readable: outbuf[old *position .. new *position]\n*/\nint WRAPPER_FOR(PMPI_Pack)( void* inbuf, int incount, MPI_Datatype datatype, \n                            void* outbuf, int outsize, \n                            int* position, MPI_Comm comm ) \n{\n   OrigFn fn;\n   int    err, szB = 0;\n   int    position_ORIG = *position;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Pack\");\n   /* stay sane */\n   check_mem_is_defined_untyped(position, sizeof(*position));\n   /* check input */\n   check_mem_is_defined(inbuf, incount, datatype);\n   /* check output area's stated bounds make sense */\n   check_mem_is_addressable_untyped(outbuf, outsize);\n   /* check output area's actual used size properly */\n   err = PMPI_Pack_size( incount, datatype, comm, &szB );\n   if (err == MPI_SUCCESS && szB > 0) {\n      check_mem_is_addressable_untyped( \n         ((char*)outbuf) + position_ORIG, szB\n      );\n   }\n\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_7W(err, fn, inbuf,incount,datatype, outbuf,outsize,position, comm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n\n   if (err == MPI_SUCCESS && (*position) > position_ORIG) {\n      /* paint output */\n      make_mem_defined_if_addressable_untyped( \n         ((char*)outbuf) + position_ORIG, *position - position_ORIG\n      );\n   }\n   after(\"Pack\", err);\n   return err;\n}\n\n/* --- Unpack --- */\n/* pre: must be readable: position\n        must be writable: (outbuf,outcount,datatype)\n        must be writable: outbuf[0 .. outsize-1]\n        must be writable: outbuf[*position .. \n                                 *position - 1 \n                                 + however much space PMPI_Pack_size \n                                   says we will need]\n   post: make readable: (outbuf,outcount,datatype)\n         and also do a readability check of\n         inbuf[old *position .. new *position]\n*/\nint WRAPPER_FOR(PMPI_Unpack)( void* inbuf, int insize, int* position,\n                              void* outbuf, int outcount, MPI_Datatype datatype, \n                              MPI_Comm comm )\n{\n   OrigFn fn;\n   int    err, szB = 0;\n   int    position_ORIG = *position;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Unpack\");\n   /* stay sane */\n   check_mem_is_defined_untyped(position, sizeof(*position));\n   /* check output area is accessible */\n   check_mem_is_addressable(outbuf, outcount, datatype);\n   /* check input area's stated bounds make sense */\n   check_mem_is_addressable_untyped(inbuf, insize);\n   /* check input area's actual used size properly */\n   err = PMPI_Pack_size( outcount, datatype, comm, &szB );\n   if (err == MPI_SUCCESS && szB > 0) {\n      check_mem_is_addressable_untyped( \n         ((char*)inbuf) + position_ORIG, szB\n      );\n   }\n\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_7W(err, fn, inbuf,insize,position, outbuf,outcount,datatype, comm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n\n   if (err == MPI_SUCCESS && (*position) > position_ORIG) {\n      /* recheck input more carefully */\n      check_mem_is_defined_untyped( \n         ((char*)inbuf) + position_ORIG, *position - position_ORIG\n      );\n      /* paint output */\n      make_mem_defined_if_addressable( outbuf, outcount, datatype );\n   }\n   after(\"Unpack\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 4.4, Broadcast                                   ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* --- Bcast --- */\n/* pre:  must-be-readable (buffer,count,datatype) for rank==root\n         must-be-writable (buffer,count,datatype) for rank!=root\n   post: make-readable (buffer,count,datatype) for all\n\n   Resulting behaviour is: if root sends uninitialised stuff, then\n   V complains, but then all ranks, including itself, see the buffer\n   as initialised after that.\n*/\nint WRAPPER_FOR(PMPI_Bcast)(void *buffer, int count, \n                            MPI_Datatype datatype,\n                            int root, MPI_Comm comm)\n{\n   OrigFn fn;\n   int    err;\n   Bool  i_am_sender;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Bcast\");\n   i_am_sender = root == comm_rank(comm);\n   if (i_am_sender) {\n      check_mem_is_defined(buffer, count, datatype);\n   } else {\n      check_mem_is_addressable(buffer, count, datatype);\n   }\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_5W(err, fn, buffer,count,datatype,root,comm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success(err, buffer, count, datatype);\n   after(\"Bcast\", err);\n   return err; \n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 4.5, Gather                                      ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* --- Gather --- */\n/* JRS 20060217: I don't really understand this.  Each process is\n   going to send sendcount items of type sendtype to the root.  So\n   the root is going to receive comm_size*sendcount items of type\n   sendtype (right?)  So why specify recvcount and recvtype?\n\n   Anyway, assuming the MPI Spec is correct (seems likely :-) we have:\n\n   pre:  (all)        must be readable: (sendbuf,sendcount,sendtype)\n         (root only): must be writable: (recvbuf,recvcount * comm_size,recvtype)\n   post: (root only): make readable: (recvbuf,recvcount * comm_size,recvtype)\n*/\nint WRAPPER_FOR(PMPI_Gather)(\n       void *sendbuf, int sendcount, MPI_Datatype sendtype,\n       void *recvbuf, int recvcount, MPI_Datatype recvtype,\n       int root, MPI_Comm comm)\n{\n   OrigFn fn;\n   int    err, me, sz;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Gather\");\n   me = comm_rank(comm);\n   sz = comm_size(comm);\n   check_mem_is_defined(sendbuf, sendcount, sendtype);\n   if (me == root)\n      check_mem_is_addressable(recvbuf, recvcount * sz, recvtype);\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_8W(err, fn, sendbuf,sendcount,sendtype,\n                         recvbuf,recvcount,recvtype,\n                         root,comm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   if (me == root)\n      make_mem_defined_if_addressable_if_success(err, recvbuf, recvcount * sz, recvtype);\n   after(\"Gather\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 4.6, Scatter                                     ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* pre:  (root only): must be readable: (sendbuf,sendcount * comm_size,sendtype)\n         (all):       must be writable: (recvbuf,recvbuf,recvtype)\n   post: (all):       make defined: (recvbuf,recvbuf,recvtype)\n*/\nint WRAPPER_FOR(PMPI_Scatter)(\n       void* sendbuf, int sendcount, MPI_Datatype sendtype,\n       void* recvbuf, int recvcount, MPI_Datatype recvtype,\n       int root, MPI_Comm comm)\n{\n   OrigFn fn;\n   int    err, me, sz;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Scatter\");\n   me = comm_rank(comm);\n   sz = comm_size(comm);\n   check_mem_is_addressable(recvbuf, recvcount, recvtype);\n   if (me == root)\n      check_mem_is_defined(sendbuf, sendcount * sz, sendtype);\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_8W(err, fn, sendbuf,sendcount,sendtype,\n                         recvbuf,recvcount,recvtype,\n                         root,comm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success(err, recvbuf, recvcount, recvtype);\n   after(\"Scatter\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 4.8, All-to-All Scatter/Gather                   ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* pre:  (all) must be readable: (sendbuf,sendcount * comm_size,sendtype)\n         (all) must be writable: (recvbuf,recvcount * comm_size,recvtype)\n   post: (all) make defined:     (recvbuf,recvcount * comm_size,recvtype)\n*/\nint WRAPPER_FOR(PMPI_Alltoall)(\n       void* sendbuf, int sendcount, MPI_Datatype sendtype,\n       void* recvbuf, int recvcount, MPI_Datatype recvtype,\n       MPI_Comm comm)\n{\n   OrigFn fn;\n   int    err, sz;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Alltoall\");\n   sz = comm_size(comm);\n   check_mem_is_defined(sendbuf, sendcount * sz, sendtype);\n   check_mem_is_addressable(recvbuf, recvcount * sz, recvtype);\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_7W(err, fn, sendbuf,sendcount,sendtype,\n                         recvbuf,recvcount,recvtype,\n                         comm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success(err, recvbuf, recvcount * sz, recvtype);\n   after(\"Alltoall\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 4.9, Global Reduction Operations                 ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* --- Reduce --- */\n/* rd: (sendbuf,count,datatype) for all\n   wr: (recvbuf,count,datatype) but only for rank == root\n*/\nint WRAPPER_FOR(PMPI_Reduce)(void *sendbuf, void *recvbuf, \n                             int count,\n                             MPI_Datatype datatype, MPI_Op op, \n                             int root, MPI_Comm comm)\n{\n   OrigFn fn;\n   int    err;\n   Bool  i_am_root;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Reduce\");\n   i_am_root = root == comm_rank(comm);\n   check_mem_is_defined(sendbuf, count, datatype);\n   if (i_am_root)\n      check_mem_is_addressable(recvbuf, count, datatype);\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_7W(err, fn, sendbuf,recvbuf,count,datatype,op,root,comm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   if (i_am_root)\n      make_mem_defined_if_addressable_if_success(err, recvbuf, count, datatype);\n   after(\"Reduce\", err);\n   return err;\n}\n\n\n/* --- Allreduce --- */\n/* rd: (sendbuf,count,datatype) for all\n   wr: (recvbuf,count,datatype) for all\n*/\nint WRAPPER_FOR(PMPI_Allreduce)(void *sendbuf, void *recvbuf, \n                                int count,\n                                MPI_Datatype datatype, MPI_Op op, \n                                MPI_Comm comm)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Allreduce\");\n   check_mem_is_defined(sendbuf, count, datatype);\n   check_mem_is_addressable(recvbuf, count, datatype);\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_6W(err, fn, sendbuf,recvbuf,count,datatype,op,comm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success(err, recvbuf, count, datatype);\n   after(\"Allreduce\", err);\n   return err;\n}\n\n\n/* --- Op_create --- */\n/* This is a bit dubious.  I suppose it takes 'function' and \n   writes something at *op, but who knows what an MPI_Op is? \n   Can we safely do 'sizeof' on it? */\nint WRAPPER_FOR(PMPI_Op_create)( MPI_User_function* function,\n                                 int commute, \n                                 MPI_Op* op )\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Op_create\");\n   check_mem_is_addressable_untyped(op, sizeof(*op));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WWW(err, fn, function,commute,op);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success_untyped(err, op, sizeof(*op));\n   after(\"Op_create\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 5.4, Communicator management                     ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* Hardly seems worth wrapping Comm_rank and Comm_size, but\n   since it's done now .. */\n\n/* --- Comm_create --- */\n/* Let normal memcheck tracking handle this. */\nint WRAPPER_FOR(PMPI_Comm_create)(MPI_Comm comm, MPI_Group group,\n                                  MPI_Comm* newcomm)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Comm_create\");\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WWW(err, fn, comm,group,newcomm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   after(\"Comm_create\", err);\n   return err;\n}\n\n/* --- Comm_dup --- */\n/* Let normal memcheck tracking handle this. */\nint WRAPPER_FOR(PMPI_Comm_dup)(MPI_Comm comm, MPI_Comm* newcomm)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Comm_dup\");\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WW(err, fn, comm,newcomm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   after(\"Comm_dup\", err);\n   return err;\n}\n\n/* --- Comm_free --- */\n/* Let normal memcheck tracking handle this. */\nint WRAPPER_FOR(PMPI_Comm_free)(MPI_Comm* comm)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Comm_free\");\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_W(err, fn, comm);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   after(\"Comm_free\", err);\n   return err;\n}\n\n/* --- Comm_rank --- */\n/* wr: (rank, sizeof(*rank)) */\nint WRAPPER_FOR(PMPI_Comm_rank)(MPI_Comm comm, int *rank)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Comm_rank\");\n   check_mem_is_addressable_untyped(rank, sizeof(*rank));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WW(err, fn, comm,rank);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success_untyped(err, rank, sizeof(*rank));\n   after(\"Comm_rank\", err);\n   return err;\n}\n\n/* --- Comm_size --- */\n/* wr: (size, sizeof(*size)) */\nint WRAPPER_FOR(PMPI_Comm_size)(MPI_Comm comm, int *size)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Comm_size\");\n   check_mem_is_addressable_untyped(size, sizeof(*size));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WW(err, fn, comm,size);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success_untyped(err, size, sizeof(*size));\n   after(\"Comm_size\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 5.7, Caching                                     ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 7.3, Error codes and classes                     ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* --- Error_string --- */\nint WRAPPER_FOR(PMPI_Error_string)( int errorcode, char* string, \n                                    int* resultlen )\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Error_string\");\n   check_mem_is_addressable_untyped(resultlen, sizeof(int));\n   check_mem_is_addressable_untyped(string, MPI_MAX_ERROR_STRING);\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WWW(err, fn, errorcode,string,resultlen);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   /* Don't bother to paint the result; we assume the real function\n      will have filled it with defined characters :-) */\n   after(\"Error_string\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Sec 7.5, Startup                                     ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* --- Init --- */\n/* rd: *argc, *argv[0 .. *argc-1] */\nlong WRAPPER_FOR(PMPI_Init)(int *argc, char ***argv)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Init\");\n   if (argc) {\n      check_mem_is_defined_untyped(argc, sizeof(int));\n   }\n   if (argc && argv) {\n      check_mem_is_defined_untyped(*argv, *argc * sizeof(char**));\n   }\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_WW(err, fn, argc,argv);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   after(\"Init\", err);\n   if (opt_initkludge)\n      return (long)(void*)&mpiwrap_walk_type_EXTERNALLY_VISIBLE;\n   else\n      return (long)err;\n}\n\n/* --- Initialized --- */\nint WRAPPER_FOR(PMPI_Initialized)(int* flag)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Initialized\");\n   check_mem_is_addressable_untyped(flag, sizeof(int));\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_W(err, fn, flag);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   make_mem_defined_if_addressable_if_success_untyped(err, flag, sizeof(int));\n   after(\"Initialized\", err);\n   return err;\n}\n\n/* --- Finalize --- */\nint WRAPPER_FOR(PMPI_Finalize)(void)\n{\n   OrigFn fn;\n   int    err;\n   VALGRIND_GET_ORIG_FN(fn);\n   before(\"Finalize\");\n   if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;\n   CALL_FN_W_v(err, fn);\n   if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;\n   after(\"Finalize\", err);\n   return err;\n}\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*--- Default wrappers for all remaining functions         ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/* Boilerplate for default wrappers. */\n#define DEFAULT_WRAPPER_PREAMBLE(basename)                        \\\n      OrigFn fn;                                                  \\\n      UWord  res;                                                 \\\n      static int complaints = 1;                                  \\\n      VALGRIND_GET_ORIG_FN(fn);                                   \\\n      before(#basename);                                          \\\n      if (opt_missing >= 2) {                                     \\\n         barf(\"no wrapper for PMPI_\" #basename                    \\\n              \",\\n\\t\\t\\t     and you have \"                       \\\n              \"requested strict checking\");                       \\\n      }                                                           \\\n      if (opt_missing == 1 && complaints > 0) {                   \\\n         fprintf(stderr, \"%s %5d: warning: no wrapper \"           \\\n                         \"for PMPI_\" #basename \"\\n\",              \\\n                 preamble, my_pid);                               \\\n         complaints--;                                            \\\n      }                                                           \\\n\n#define DEFAULT_WRAPPER_W_0W(basename)                            \\\n   UWord WRAPPER_FOR(PMPI_##basename)( void )                     \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_v(res, fn);                                       \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_1W(basename)                            \\\n   UWord WRAPPER_FOR(PMPI_##basename)( UWord a1 )                 \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_W(res, fn, a1);                                   \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_2W(basename)                            \\\n   UWord WRAPPER_FOR(PMPI_##basename)( UWord a1, UWord a2 )       \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_WW(res, fn, a1,a2);                               \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_3W(basename)                            \\\n   UWord WRAPPER_FOR(PMPI_##basename)                             \\\n      ( UWord a1, UWord a2, UWord a3 )                            \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_WWW(res, fn, a1,a2,a3);                           \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_4W(basename)                            \\\n   UWord WRAPPER_FOR(PMPI_##basename)                             \\\n      ( UWord a1, UWord a2, UWord a3, UWord a4 )                  \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_WWWW(res, fn, a1,a2,a3,a4);                       \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_5W(basename)                            \\\n   UWord WRAPPER_FOR(PMPI_##basename)                             \\\n      ( UWord a1, UWord a2, UWord a3, UWord a4, UWord a5 )        \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_5W(res, fn, a1,a2,a3,a4,a5);                      \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_6W(basename)                            \\\n   UWord WRAPPER_FOR(PMPI_##basename)                             \\\n      ( UWord a1, UWord a2, UWord a3, UWord a4, UWord a5,         \\\n        UWord a6 )                                                \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_6W(res, fn, a1,a2,a3,a4,a5,a6);                   \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_7W(basename)                            \\\n   UWord WRAPPER_FOR(PMPI_##basename)                             \\\n      ( UWord a1, UWord a2, UWord a3, UWord a4, UWord a5,         \\\n        UWord a6, UWord a7 )                                      \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_7W(res, fn, a1,a2,a3,a4,a5,a6,a7);                \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_8W(basename)                            \\\n   UWord WRAPPER_FOR(PMPI_##basename)                             \\\n      ( UWord a1, UWord a2, UWord a3, UWord a4, UWord a5,         \\\n        UWord a6, UWord a7, UWord a8 )                            \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_8W(res, fn, a1,a2,a3,a4,a5,a6,a7,a8);             \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_9W(basename)                            \\\n   UWord WRAPPER_FOR(PMPI_##basename)                             \\\n      ( UWord a1, UWord a2, UWord a3, UWord a4, UWord a5,         \\\n        UWord a6, UWord a7, UWord a8, UWord a9 )                  \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_9W(res, fn, a1,a2,a3,a4,a5,a6,a7,a8,a9);          \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_10W(basename)                           \\\n   UWord WRAPPER_FOR(PMPI_##basename)                             \\\n      ( UWord a1, UWord a2, UWord a3, UWord a4, UWord a5,         \\\n        UWord a6, UWord a7, UWord a8, UWord a9, UWord a10 )       \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_10W(res, fn, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);     \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n#define DEFAULT_WRAPPER_W_12W(basename)                           \\\n   UWord WRAPPER_FOR(PMPI_##basename)                             \\\n      ( UWord a1, UWord a2, UWord a3, UWord a4, UWord a5,         \\\n        UWord a6, UWord a7, UWord a8, UWord a9, UWord a10,        \\\n        UWord a11, UWord a12 )                                    \\\n   {                                                              \\\n      DEFAULT_WRAPPER_PREAMBLE(basename)                          \\\n      if (cONFIG_DER) VALGRIND_DISABLE_ERROR_REPORTING;           \\\n      CALL_FN_W_12W(res, fn, a1,a2,a3,a4,a5,a6,                   \\\n                             a7,a8,a9,a10,a11,a12);               \\\n      if (cONFIG_DER) VALGRIND_ENABLE_ERROR_REPORTING;            \\\n      return res;                                                 \\\n   }\n\n\n/* Canned summary of MPI-1.1/MPI-2 entry points, as derived from mpi.h\n   from Open MPI svn rev 9191 (somewhere between Open MPI versions\n   1.0.1 and 1.1.0). */\n\n/* If a function is commented out in this list, it's because it has a\n   proper wrapper written elsewhere (above here). */\n\nDEFAULT_WRAPPER_W_2W(Abort)\nDEFAULT_WRAPPER_W_9W(Accumulate)\nDEFAULT_WRAPPER_W_1W(Add_error_class)\nDEFAULT_WRAPPER_W_2W(Add_error_code)\nDEFAULT_WRAPPER_W_2W(Add_error_string)\n/* DEFAULT_WRAPPER_W_2W(Address) */\nDEFAULT_WRAPPER_W_7W(Allgather)\nDEFAULT_WRAPPER_W_8W(Allgatherv)\nDEFAULT_WRAPPER_W_3W(Alloc_mem)\n/* DEFAULT_WRAPPER_W_6W(Allreduce) */\n/* DEFAULT_WRAPPER_W_7W(Alltoall) */\nDEFAULT_WRAPPER_W_9W(Alltoallv)\nDEFAULT_WRAPPER_W_9W(Alltoallw)\nDEFAULT_WRAPPER_W_2W(Attr_delete)\nDEFAULT_WRAPPER_W_4W(Attr_get)\nDEFAULT_WRAPPER_W_3W(Attr_put)\nDEFAULT_WRAPPER_W_1W(Barrier)\n/* DEFAULT_WRAPPER_W_5W(Bcast) */\n/* DEFAULT_WRAPPER_W_6W(Bsend) */\nDEFAULT_WRAPPER_W_7W(Bsend_init)\nDEFAULT_WRAPPER_W_2W(Buffer_attach)\nDEFAULT_WRAPPER_W_2W(Buffer_detach)\n/* DEFAULT_WRAPPER_W_1W(Cancel) */\nDEFAULT_WRAPPER_W_4W(Cart_coords)\nDEFAULT_WRAPPER_W_6W(Cart_create)\nDEFAULT_WRAPPER_W_5W(Cart_get)\nDEFAULT_WRAPPER_W_5W(Cart_map)\nDEFAULT_WRAPPER_W_3W(Cart_rank)\nDEFAULT_WRAPPER_W_5W(Cart_shift)\nDEFAULT_WRAPPER_W_3W(Cart_sub)\nDEFAULT_WRAPPER_W_2W(Cartdim_get)\nDEFAULT_WRAPPER_W_1W(Close_port)\nDEFAULT_WRAPPER_W_5W(Comm_accept)\nDEFAULT_WRAPPER_W_1W(Comm_c2f)\nDEFAULT_WRAPPER_W_2W(Comm_call_errhandler)\nDEFAULT_WRAPPER_W_3W(Comm_compare)\nDEFAULT_WRAPPER_W_5W(Comm_connect)\nDEFAULT_WRAPPER_W_2W(Comm_create_errhandler)\nDEFAULT_WRAPPER_W_4W(Comm_create_keyval)\n/* DEFAULT_WRAPPER_W_3W(Comm_create) */\nDEFAULT_WRAPPER_W_2W(Comm_delete_attr)\nDEFAULT_WRAPPER_W_1W(Comm_disconnect)\n/* DEFAULT_WRAPPER_W_2W(Comm_dup) */\nDEFAULT_WRAPPER_W_1W(Comm_f2c)\nDEFAULT_WRAPPER_W_1W(Comm_free_keyval)\n/* DEFAULT_WRAPPER_W_1W(Comm_free) */\nDEFAULT_WRAPPER_W_4W(Comm_get_attr)\nDEFAULT_WRAPPER_W_2W(Comm_get_errhandler)\nDEFAULT_WRAPPER_W_3W(Comm_get_name)\nDEFAULT_WRAPPER_W_1W(Comm_get_parent)\nDEFAULT_WRAPPER_W_2W(Comm_group)\nDEFAULT_WRAPPER_W_2W(Comm_join)\n/* DEFAULT_WRAPPER_W_2W(Comm_rank) */\nDEFAULT_WRAPPER_W_2W(Comm_remote_group)\nDEFAULT_WRAPPER_W_2W(Comm_remote_size)\nDEFAULT_WRAPPER_W_3W(Comm_set_attr)\nDEFAULT_WRAPPER_W_2W(Comm_set_errhandler)\nDEFAULT_WRAPPER_W_2W(Comm_set_name)\n/* DEFAULT_WRAPPER_W_2W(Comm_size) */\nDEFAULT_WRAPPER_W_8W(Comm_spawn)\nDEFAULT_WRAPPER_W_9W(Comm_spawn_multiple)\nDEFAULT_WRAPPER_W_4W(Comm_split)\nDEFAULT_WRAPPER_W_2W(Comm_test_inter)\nDEFAULT_WRAPPER_W_3W(Dims_create)\nDEFAULT_WRAPPER_W_1W(Errhandler_c2f)\nDEFAULT_WRAPPER_W_2W(Errhandler_create)\nDEFAULT_WRAPPER_W_1W(Errhandler_f2c)\nDEFAULT_WRAPPER_W_1W(Errhandler_free)\nDEFAULT_WRAPPER_W_2W(Errhandler_get)\nDEFAULT_WRAPPER_W_2W(Errhandler_set)\nDEFAULT_WRAPPER_W_2W(Error_class)\n/* DEFAULT_WRAPPER_W_3W(Error_string) */\nDEFAULT_WRAPPER_W_6W(Exscan)\nDEFAULT_WRAPPER_W_1W(File_c2f)\nDEFAULT_WRAPPER_W_1W(File_f2c)\nDEFAULT_WRAPPER_W_2W(File_call_errhandler)\nDEFAULT_WRAPPER_W_2W(File_create_errhandler)\nDEFAULT_WRAPPER_W_2W(File_set_errhandler)\nDEFAULT_WRAPPER_W_2W(File_get_errhandler)\nDEFAULT_WRAPPER_W_5W(File_open)\nDEFAULT_WRAPPER_W_1W(File_close)\nDEFAULT_WRAPPER_W_2W(File_delete)\nDEFAULT_WRAPPER_W_2W(File_set_size)\nDEFAULT_WRAPPER_W_2W(File_preallocate)\nDEFAULT_WRAPPER_W_2W(File_get_size)\nDEFAULT_WRAPPER_W_2W(File_get_group)\nDEFAULT_WRAPPER_W_2W(File_get_amode)\nDEFAULT_WRAPPER_W_2W(File_set_info)\nDEFAULT_WRAPPER_W_2W(File_get_info)\nDEFAULT_WRAPPER_W_6W(File_set_view)\nDEFAULT_WRAPPER_W_5W(File_get_view)\nDEFAULT_WRAPPER_W_6W(File_read_at)\nDEFAULT_WRAPPER_W_6W(File_read_at_all)\nDEFAULT_WRAPPER_W_6W(File_write_at)\nDEFAULT_WRAPPER_W_6W(File_write_at_all)\nDEFAULT_WRAPPER_W_6W(File_iread_at)\nDEFAULT_WRAPPER_W_6W(File_iwrite_at)\nDEFAULT_WRAPPER_W_5W(File_read)\nDEFAULT_WRAPPER_W_5W(File_read_all)\nDEFAULT_WRAPPER_W_5W(File_write)\nDEFAULT_WRAPPER_W_5W(File_write_all)\nDEFAULT_WRAPPER_W_5W(File_iread)\nDEFAULT_WRAPPER_W_5W(File_iwrite)\nDEFAULT_WRAPPER_W_3W(File_seek)\nDEFAULT_WRAPPER_W_2W(File_get_position)\nDEFAULT_WRAPPER_W_3W(File_get_byte_offset)\nDEFAULT_WRAPPER_W_5W(File_read_shared)\nDEFAULT_WRAPPER_W_5W(File_write_shared)\nDEFAULT_WRAPPER_W_5W(File_iread_shared)\nDEFAULT_WRAPPER_W_5W(File_iwrite_shared)\nDEFAULT_WRAPPER_W_5W(File_read_ordered)\nDEFAULT_WRAPPER_W_5W(File_write_ordered)\nDEFAULT_WRAPPER_W_3W(File_seek_shared)\nDEFAULT_WRAPPER_W_2W(File_get_position_shared)\nDEFAULT_WRAPPER_W_5W(File_read_at_all_begin)\nDEFAULT_WRAPPER_W_3W(File_read_at_all_end)\nDEFAULT_WRAPPER_W_5W(File_write_at_all_begin)\nDEFAULT_WRAPPER_W_3W(File_write_at_all_end)\nDEFAULT_WRAPPER_W_4W(File_read_all_begin)\nDEFAULT_WRAPPER_W_3W(File_read_all_end)\nDEFAULT_WRAPPER_W_4W(File_write_all_begin)\nDEFAULT_WRAPPER_W_3W(File_write_all_end)\nDEFAULT_WRAPPER_W_4W(File_read_ordered_begin)\nDEFAULT_WRAPPER_W_3W(File_read_ordered_end)\nDEFAULT_WRAPPER_W_4W(File_write_ordered_begin)\nDEFAULT_WRAPPER_W_3W(File_write_ordered_end)\nDEFAULT_WRAPPER_W_3W(File_get_type_extent)\nDEFAULT_WRAPPER_W_2W(File_set_atomicity)\nDEFAULT_WRAPPER_W_2W(File_get_atomicity)\nDEFAULT_WRAPPER_W_1W(File_sync)\n/* DEFAULT_WRAPPER_W_0W(Finalize) */\nDEFAULT_WRAPPER_W_1W(Finalized)\nDEFAULT_WRAPPER_W_1W(Free_mem)\n/* DEFAULT_WRAPPER_W_8W(Gather) */\nDEFAULT_WRAPPER_W_9W(Gatherv)\nDEFAULT_WRAPPER_W_2W(Get_address)\n/* DEFAULT_WRAPPER_W_3W(Get_count) */\nDEFAULT_WRAPPER_W_3W(Get_elements)\nDEFAULT_WRAPPER_W_8W(Get)\nDEFAULT_WRAPPER_W_2W(Get_processor_name)\nDEFAULT_WRAPPER_W_2W(Get_version)\nDEFAULT_WRAPPER_W_6W(Graph_create)\nDEFAULT_WRAPPER_W_5W(Graph_get)\nDEFAULT_WRAPPER_W_5W(Graph_map)\nDEFAULT_WRAPPER_W_3W(Graph_neighbors_count)\nDEFAULT_WRAPPER_W_4W(Graph_neighbors)\nDEFAULT_WRAPPER_W_3W(Graphdims_get)\nDEFAULT_WRAPPER_W_1W(Grequest_complete)\nDEFAULT_WRAPPER_W_5W(Grequest_start)\nDEFAULT_WRAPPER_W_1W(Group_c2f)\nDEFAULT_WRAPPER_W_3W(Group_compare)\nDEFAULT_WRAPPER_W_3W(Group_difference)\nDEFAULT_WRAPPER_W_4W(Group_excl)\nDEFAULT_WRAPPER_W_1W(Group_f2c)\nDEFAULT_WRAPPER_W_1W(Group_free)\nDEFAULT_WRAPPER_W_4W(Group_incl)\nDEFAULT_WRAPPER_W_3W(Group_intersection)\nDEFAULT_WRAPPER_W_4W(Group_range_excl)\nDEFAULT_WRAPPER_W_4W(Group_range_incl)\nDEFAULT_WRAPPER_W_2W(Group_rank)\nDEFAULT_WRAPPER_W_2W(Group_size)\nDEFAULT_WRAPPER_W_5W(Group_translate_ranks)\nDEFAULT_WRAPPER_W_3W(Group_union)\n/* DEFAULT_WRAPPER_W_7W(Ibsend) */\nDEFAULT_WRAPPER_W_1W(Info_c2f)\nDEFAULT_WRAPPER_W_1W(Info_create)\nDEFAULT_WRAPPER_W_2W(Info_delete)\nDEFAULT_WRAPPER_W_2W(Info_dup)\nDEFAULT_WRAPPER_W_1W(Info_f2c)\nDEFAULT_WRAPPER_W_1W(Info_free)\nDEFAULT_WRAPPER_W_5W(Info_get)\nDEFAULT_WRAPPER_W_2W(Info_get_nkeys)\nDEFAULT_WRAPPER_W_3W(Info_get_nthkey)\nDEFAULT_WRAPPER_W_4W(Info_get_valuelen)\nDEFAULT_WRAPPER_W_3W(Info_set)\n/* DEFAULT_WRAPPER_W_2W(Init) */\n/* DEFAULT_WRAPPER_W_1W(Initialized) */\nDEFAULT_WRAPPER_W_4W(Init_thread)\nDEFAULT_WRAPPER_W_6W(Intercomm_create)\nDEFAULT_WRAPPER_W_3W(Intercomm_merge)\n/* DEFAULT_WRAPPER_W_5W(Iprobe) */\n/* DEFAULT_WRAPPER_W_7W(Irecv) */\n/* DEFAULT_WRAPPER_W_7W(Irsend) */\n/* DEFAULT_WRAPPER_W_7W(Isend) */\n/* DEFAULT_WRAPPER_W_7W(Issend) */\nDEFAULT_WRAPPER_W_1W(Is_thread_main)\nDEFAULT_WRAPPER_W_4W(Keyval_create)\nDEFAULT_WRAPPER_W_1W(Keyval_free)\nDEFAULT_WRAPPER_W_3W(Lookup_name)\nDEFAULT_WRAPPER_W_1W(Op_c2f)\n/* DEFAULT_WRAPPER_W_3W(Op_create) */\nDEFAULT_WRAPPER_W_2W(Open_port)\nDEFAULT_WRAPPER_W_1W(Op_f2c)\nDEFAULT_WRAPPER_W_1W(Op_free)\nDEFAULT_WRAPPER_W_7W(Pack_external)\nDEFAULT_WRAPPER_W_4W(Pack_external_size)\n/* DEFAULT_WRAPPER_W_7W(Pack) */\nDEFAULT_WRAPPER_W_4W(Pack_size)\n/* int MPI_Pcontrol(const int level, ...) */\n/* DEFAULT_WRAPPER_W_4W(Probe) */\nDEFAULT_WRAPPER_W_3W(Publish_name)\nDEFAULT_WRAPPER_W_8W(Put)\nDEFAULT_WRAPPER_W_1W(Query_thread)\nDEFAULT_WRAPPER_W_7W(Recv_init)\n/* DEFAULT_WRAPPER_W_7W(Recv) */\n/* DEFAULT_WRAPPER_W_7W(Reduce) */\nDEFAULT_WRAPPER_W_6W(Reduce_scatter)\nDEFAULT_WRAPPER_W_5W(Register_datarep)\nDEFAULT_WRAPPER_W_1W(Request_c2f)\nDEFAULT_WRAPPER_W_1W(Request_f2c)\nDEFAULT_WRAPPER_W_1W(Request_free)\nDEFAULT_WRAPPER_W_3W(Request_get_status)\n/* DEFAULT_WRAPPER_W_6W(Rsend) */\nDEFAULT_WRAPPER_W_7W(Rsend_init)\nDEFAULT_WRAPPER_W_6W(Scan)\n/* DEFAULT_WRAPPER_W_8W(Scatter) */\nDEFAULT_WRAPPER_W_9W(Scatterv)\nDEFAULT_WRAPPER_W_7W(Send_init)\n/* DEFAULT_WRAPPER_W_6W(Send) */\n/* DEFAULT_WRAPPER_W_12W(Sendrecv) */\nDEFAULT_WRAPPER_W_9W(Sendrecv_replace)\nDEFAULT_WRAPPER_W_7W(Ssend_init)\n/* DEFAULT_WRAPPER_W_6W(Ssend) */\nDEFAULT_WRAPPER_W_1W(Start)\nDEFAULT_WRAPPER_W_2W(Startall)\nDEFAULT_WRAPPER_W_2W(Status_c2f)\nDEFAULT_WRAPPER_W_2W(Status_f2c)\nDEFAULT_WRAPPER_W_2W(Status_set_cancelled)\nDEFAULT_WRAPPER_W_3W(Status_set_elements)\n/* DEFAULT_WRAPPER_W_4W(Testall) */\nDEFAULT_WRAPPER_W_5W(Testany)\n/* DEFAULT_WRAPPER_W_3W(Test) */\nDEFAULT_WRAPPER_W_2W(Test_cancelled)\nDEFAULT_WRAPPER_W_5W(Testsome)\nDEFAULT_WRAPPER_W_2W(Topo_test)\nDEFAULT_WRAPPER_W_1W(Type_c2f)\n/* DEFAULT_WRAPPER_W_1W(Type_commit) */\nDEFAULT_WRAPPER_W_3W(Type_contiguous)\nDEFAULT_WRAPPER_W_10W(Type_create_darray)\nDEFAULT_WRAPPER_W_3W(Type_create_f90_complex)\nDEFAULT_WRAPPER_W_2W(Type_create_f90_integer)\nDEFAULT_WRAPPER_W_3W(Type_create_f90_real)\nDEFAULT_WRAPPER_W_5W(Type_create_hindexed)\nDEFAULT_WRAPPER_W_5W(Type_create_hvector)\nDEFAULT_WRAPPER_W_4W(Type_create_keyval)\nDEFAULT_WRAPPER_W_5W(Type_create_indexed_block)\nDEFAULT_WRAPPER_W_5W(Type_create_struct)\nDEFAULT_WRAPPER_W_7W(Type_create_subarray)\nDEFAULT_WRAPPER_W_4W(Type_create_resized)\nDEFAULT_WRAPPER_W_2W(Type_delete_attr)\nDEFAULT_WRAPPER_W_2W(Type_dup)\n/* DEFAULT_WRAPPER_W_2W(Type_extent) */\n/* DEFAULT_WRAPPER_W_1W(Type_free) */\nDEFAULT_WRAPPER_W_1W(Type_free_keyval)\nDEFAULT_WRAPPER_W_1W(Type_f2c)\nDEFAULT_WRAPPER_W_4W(Type_get_attr)\n/* DEFAULT_WRAPPER_W_7W(Type_get_contents) */\n/* DEFAULT_WRAPPER_W_5W(Type_get_envelope) */\nDEFAULT_WRAPPER_W_3W(Type_get_extent)\nDEFAULT_WRAPPER_W_3W(Type_get_name)\nDEFAULT_WRAPPER_W_3W(Type_get_true_extent)\nDEFAULT_WRAPPER_W_5W(Type_hindexed)\nDEFAULT_WRAPPER_W_5W(Type_hvector)\nDEFAULT_WRAPPER_W_5W(Type_indexed)\nDEFAULT_WRAPPER_W_2W(Type_lb)\nDEFAULT_WRAPPER_W_3W(Type_match_size)\nDEFAULT_WRAPPER_W_3W(Type_set_attr)\nDEFAULT_WRAPPER_W_2W(Type_set_name)\nDEFAULT_WRAPPER_W_2W(Type_size)\nDEFAULT_WRAPPER_W_5W(Type_struct)\nDEFAULT_WRAPPER_W_2W(Type_ub)\nDEFAULT_WRAPPER_W_5W(Type_vector)\n/* DEFAULT_WRAPPER_W_7W(Unpack) */\nDEFAULT_WRAPPER_W_3W(Unpublish_name)\nDEFAULT_WRAPPER_W_7W(Unpack_external)\n/* DEFAULT_WRAPPER_W_3W(Waitall) */\n/* DEFAULT_WRAPPER_W_4W(Waitany) */\n/* DEFAULT_WRAPPER_W_2W(Wait) */\nDEFAULT_WRAPPER_W_5W(Waitsome)\nDEFAULT_WRAPPER_W_1W(Win_c2f)\nDEFAULT_WRAPPER_W_2W(Win_call_errhandler)\nDEFAULT_WRAPPER_W_1W(Win_complete)\nDEFAULT_WRAPPER_W_6W(Win_create)\nDEFAULT_WRAPPER_W_2W(Win_create_errhandler)\nDEFAULT_WRAPPER_W_4W(Win_create_keyval)\nDEFAULT_WRAPPER_W_2W(Win_delete_attr)\nDEFAULT_WRAPPER_W_1W(Win_f2c)\nDEFAULT_WRAPPER_W_2W(Win_fence)\nDEFAULT_WRAPPER_W_1W(Win_free)\nDEFAULT_WRAPPER_W_1W(Win_free_keyval)\nDEFAULT_WRAPPER_W_4W(Win_get_attr)\nDEFAULT_WRAPPER_W_2W(Win_get_errhandler)\nDEFAULT_WRAPPER_W_2W(Win_get_group)\nDEFAULT_WRAPPER_W_3W(Win_get_name)\nDEFAULT_WRAPPER_W_4W(Win_lock)\nDEFAULT_WRAPPER_W_3W(Win_post)\nDEFAULT_WRAPPER_W_3W(Win_set_attr)\nDEFAULT_WRAPPER_W_2W(Win_set_errhandler)\nDEFAULT_WRAPPER_W_2W(Win_set_name)\nDEFAULT_WRAPPER_W_3W(Win_start)\nDEFAULT_WRAPPER_W_2W(Win_test)\nDEFAULT_WRAPPER_W_2W(Win_unlock)\nDEFAULT_WRAPPER_W_1W(Win_wait)\n/* double MPI_Wtick(void) */\n/* double MPI_Wtime(void) */\n\n\n/*------------------------------------------------------------*/\n/*---                                                      ---*/\n/*---                                                      ---*/\n/*---                                                      ---*/\n/*------------------------------------------------------------*/\n\n/*---------------------------------------------------------------*/\n/*--- end                                           mpiwrap.c ---*/\n/*---------------------------------------------------------------*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/perf/tinycc.c": "/*\n *  TCC - Tiny C Compiler\n * \n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n#define _GNU_SOURCE\n\n// njn: inlined config.h\n//#include \"config.h\"\n//---------------------------------------------------------------------------\n/* Automatically generated by configure - do not modify */\n#define CONFIG_TCCDIR \"tinycc-extras\"\n#define GCC_MAJOR 3\n#define HOST_I386 1\n#define TCC_VERSION \"0.9.23\"\n//---------------------------------------------------------------------------\n\n// njn: comment out CONFIG_TCCBOOT branch\n//#ifdef CONFIG_TCCBOOT\n//\n//#include \"tccboot.h\"\n//#define CONFIG_TCC_STATIC\n//\n//#else\n\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <math.h>\n#include <unistd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <setjmp.h>\n#include <time.h>\n#ifdef WIN32\n#include <sys/timeb.h>\n#endif\n#ifndef WIN32\n#include <sys/time.h>\n#include <sys/ucontext.h>\n#endif\n\n//#endif /* !CONFIG_TCCBOOT */\n\n// Dummy variables used to avoid warnings like these: \n// warning: ignoring return value of \u2018fwrite\u2019, declared with attribute\n//    warn_unused_result\nchar* dummy_char_star;\nsize_t dummy_size_t;\n\n// njn: inlined elf.h\n//#include \"elf.h\"\n//---------------------------------------------------------------------------\n/* This file defines standard ELF types, structures, and macros.\n   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n   Contributed by Ian Lance Taylor <ian@cygnus.com>.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n#ifndef _ELF_H\n#define\t_ELF_H 1\n\n#ifndef WIN32\n#include <inttypes.h>\n#else\n#ifndef __int8_t_defined\n#define __int8_t_defined\ntypedef signed char int8_t;\ntypedef\tshort int int16_t;\ntypedef\tint int32_t;\ntypedef long long int int64_t;\n#endif\n\ntypedef unsigned char\t\tuint8_t;\ntypedef unsigned short int\tuint16_t;\ntypedef unsigned int\t\tuint32_t;\ntypedef unsigned long long int\tuint64_t;\n#endif\n\n/* Standard ELF types.  */\n\n/* Type for a 16-bit quantity.  */\ntypedef uint16_t Elf32_Half;\ntypedef uint16_t Elf64_Half;\n\n/* Types for signed and unsigned 32-bit quantities.  */\ntypedef uint32_t Elf32_Word;\ntypedef\tint32_t  Elf32_Sword;\ntypedef uint32_t Elf64_Word;\ntypedef\tint32_t  Elf64_Sword;\n\n/* Types for signed and unsigned 64-bit quantities.  */\ntypedef uint64_t Elf32_Xword;\ntypedef\tint64_t  Elf32_Sxword;\ntypedef uint64_t Elf64_Xword;\ntypedef\tint64_t  Elf64_Sxword;\n\n/* Type of addresses.  */\ntypedef uint32_t Elf32_Addr;\ntypedef uint64_t Elf64_Addr;\n\n/* Type of file offsets.  */\ntypedef uint32_t Elf32_Off;\ntypedef uint64_t Elf64_Off;\n\n/* Type for section indices, which are 16-bit quantities.  */\ntypedef uint16_t Elf32_Section;\ntypedef uint16_t Elf64_Section;\n\n/* Type of symbol indices.  */\ntypedef uint32_t Elf32_Symndx;\ntypedef uint64_t Elf64_Symndx;\n\n\n/* The ELF file header.  This appears at the start of every ELF file.  */\n\n#define EI_NIDENT (16)\n\ntypedef struct\n{\n  unsigned char\te_ident[EI_NIDENT];\t/* Magic number and other info */\n  Elf32_Half\te_type;\t\t\t/* Object file type */\n  Elf32_Half\te_machine;\t\t/* Architecture */\n  Elf32_Word\te_version;\t\t/* Object file version */\n  Elf32_Addr\te_entry;\t\t/* Entry point virtual address */\n  Elf32_Off\te_phoff;\t\t/* Program header table file offset */\n  Elf32_Off\te_shoff;\t\t/* Section header table file offset */\n  Elf32_Word\te_flags;\t\t/* Processor-specific flags */\n  Elf32_Half\te_ehsize;\t\t/* ELF header size in bytes */\n  Elf32_Half\te_phentsize;\t\t/* Program header table entry size */\n  Elf32_Half\te_phnum;\t\t/* Program header table entry count */\n  Elf32_Half\te_shentsize;\t\t/* Section header table entry size */\n  Elf32_Half\te_shnum;\t\t/* Section header table entry count */\n  Elf32_Half\te_shstrndx;\t\t/* Section header string table index */\n} Elf32_Ehdr;\n\ntypedef struct\n{\n  unsigned char\te_ident[EI_NIDENT];\t/* Magic number and other info */\n  Elf64_Half\te_type;\t\t\t/* Object file type */\n  Elf64_Half\te_machine;\t\t/* Architecture */\n  Elf64_Word\te_version;\t\t/* Object file version */\n  Elf64_Addr\te_entry;\t\t/* Entry point virtual address */\n  Elf64_Off\te_phoff;\t\t/* Program header table file offset */\n  Elf64_Off\te_shoff;\t\t/* Section header table file offset */\n  Elf64_Word\te_flags;\t\t/* Processor-specific flags */\n  Elf64_Half\te_ehsize;\t\t/* ELF header size in bytes */\n  Elf64_Half\te_phentsize;\t\t/* Program header table entry size */\n  Elf64_Half\te_phnum;\t\t/* Program header table entry count */\n  Elf64_Half\te_shentsize;\t\t/* Section header table entry size */\n  Elf64_Half\te_shnum;\t\t/* Section header table entry count */\n  Elf64_Half\te_shstrndx;\t\t/* Section header string table index */\n} Elf64_Ehdr;\n\n/* Fields in the e_ident array.  The EI_* macros are indices into the\n   array.  The macros under each EI_* macro are the values the byte\n   may have.  */\n\n#define EI_MAG0\t\t0\t\t/* File identification byte 0 index */\n#define ELFMAG0\t\t0x7f\t\t/* Magic number byte 0 */\n\n#define EI_MAG1\t\t1\t\t/* File identification byte 1 index */\n#define ELFMAG1\t\t'E'\t\t/* Magic number byte 1 */\n\n#define EI_MAG2\t\t2\t\t/* File identification byte 2 index */\n#define ELFMAG2\t\t'L'\t\t/* Magic number byte 2 */\n\n#define EI_MAG3\t\t3\t\t/* File identification byte 3 index */\n#define ELFMAG3\t\t'F'\t\t/* Magic number byte 3 */\n\n/* Conglomeration of the identification bytes, for easy testing as a word.  */\n#define\tELFMAG\t\t\"\\177ELF\"\n#define\tSELFMAG\t\t4\n\n#define EI_CLASS\t4\t\t/* File class byte index */\n#define ELFCLASSNONE\t0\t\t/* Invalid class */\n#define ELFCLASS32\t1\t\t/* 32-bit objects */\n#define ELFCLASS64\t2\t\t/* 64-bit objects */\n#define ELFCLASSNUM\t3\n\n#define EI_DATA\t\t5\t\t/* Data encoding byte index */\n#define ELFDATANONE\t0\t\t/* Invalid data encoding */\n#define ELFDATA2LSB\t1\t\t/* 2's complement, little endian */\n#define ELFDATA2MSB\t2\t\t/* 2's complement, big endian */\n#define ELFDATANUM\t3\n\n#define EI_VERSION\t6\t\t/* File version byte index */\n\t\t\t\t\t/* Value must be EV_CURRENT */\n\n#define EI_OSABI\t7\t\t/* OS ABI identification */\n#define ELFOSABI_SYSV\t\t0\t/* UNIX System V ABI */\n#define ELFOSABI_HPUX\t\t1\t/* HP-UX */\n#define ELFOSABI_FREEBSD        9       /* Free BSD */\n#define ELFOSABI_ARM\t\t97\t/* ARM */\n#define ELFOSABI_STANDALONE\t255\t/* Standalone (embedded) application */\n\n#define EI_ABIVERSION\t8\t\t/* ABI version */\n\n#define EI_PAD\t\t9\t\t/* Byte index of padding bytes */\n\n/* Legal values for e_type (object file type).  */\n\n#define ET_NONE\t\t0\t\t/* No file type */\n#define ET_REL\t\t1\t\t/* Relocatable file */\n#define ET_EXEC\t\t2\t\t/* Executable file */\n#define ET_DYN\t\t3\t\t/* Shared object file */\n#define ET_CORE\t\t4\t\t/* Core file */\n#define\tET_NUM\t\t5\t\t/* Number of defined types */\n#define ET_LOPROC\t0xff00\t\t/* Processor-specific */\n#define ET_HIPROC\t0xffff\t\t/* Processor-specific */\n\n/* Legal values for e_machine (architecture).  */\n\n#define EM_NONE\t\t 0\t\t/* No machine */\n#define EM_M32\t\t 1\t\t/* AT&T WE 32100 */\n#define EM_SPARC\t 2\t\t/* SUN SPARC */\n#define EM_386\t\t 3\t\t/* Intel 80386 */\n#define EM_68K\t\t 4\t\t/* Motorola m68k family */\n#define EM_88K\t\t 5\t\t/* Motorola m88k family */\n#define EM_486\t\t 6\t\t/* Intel 80486 */\n#define EM_860\t\t 7\t\t/* Intel 80860 */\n#define EM_MIPS\t\t 8\t\t/* MIPS R3000 big-endian */\n#define EM_S370\t\t 9\t\t/* Amdahl */\n#define EM_MIPS_RS4_BE\t10\t\t/* MIPS R4000 big-endian */\n#define EM_RS6000\t11\t\t/* RS6000 */\n\n#define EM_PARISC\t15\t\t/* HPPA */\n#define EM_nCUBE\t16\t\t/* nCUBE */\n#define EM_VPP500\t17\t\t/* Fujitsu VPP500 */\n#define EM_SPARC32PLUS\t18\t\t/* Sun's \"v8plus\" */\n#define EM_960\t\t19\t\t/* Intel 80960 */\n#define EM_PPC\t\t20\t\t/* PowerPC */\n\n#define EM_V800\t\t36\t\t/* NEC V800 series */\n#define EM_FR20\t\t37\t\t/* Fujitsu FR20 */\n#define EM_RH32\t\t38\t\t/* TRW RH32 */\n#define EM_MMA\t\t39\t\t/* Fujitsu MMA */\n#define EM_ARM\t\t40\t\t/* ARM */\n#define EM_FAKE_ALPHA\t41\t\t/* Digital Alpha */\n#define EM_SH\t\t42\t\t/* Hitachi SH */\n#define EM_SPARCV9\t43\t\t/* SPARC v9 64-bit */\n#define EM_TRICORE\t44\t\t/* Siemens Tricore */\n#define EM_ARC\t\t45\t\t/* Argonaut RISC Core */\n#define EM_H8_300\t46\t\t/* Hitachi H8/300 */\n#define EM_H8_300H\t47\t\t/* Hitachi H8/300H */\n#define EM_H8S\t\t48\t\t/* Hitachi H8S */\n#define EM_H8_500\t49\t\t/* Hitachi H8/500 */\n#define EM_IA_64\t50\t\t/* Intel Merced */\n#define EM_MIPS_X\t51\t\t/* Stanford MIPS-X */\n#define EM_COLDFIRE\t52\t\t/* Motorola Coldfire */\n#define EM_68HC12\t53\t\t/* Motorola M68HC12 */\n#define EM_NUM\t\t54\n\n/* If it is necessary to assign new unofficial EM_* values, please\n   pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the\n   chances of collision with official or non-GNU unofficial values.  */\n\n#define EM_ALPHA\t0x9026\n#define EM_C60          0x9c60\n\n/* Legal values for e_version (version).  */\n\n#define EV_NONE\t\t0\t\t/* Invalid ELF version */\n#define EV_CURRENT\t1\t\t/* Current version */\n#define EV_NUM\t\t2\n\n/* Section header.  */\n\ntypedef struct\n{\n  Elf32_Word\tsh_name;\t\t/* Section name (string tbl index) */\n  Elf32_Word\tsh_type;\t\t/* Section type */\n  Elf32_Word\tsh_flags;\t\t/* Section flags */\n  Elf32_Addr\tsh_addr;\t\t/* Section virtual addr at execution */\n  Elf32_Off\tsh_offset;\t\t/* Section file offset */\n  Elf32_Word\tsh_size;\t\t/* Section size in bytes */\n  Elf32_Word\tsh_link;\t\t/* Link to another section */\n  Elf32_Word\tsh_info;\t\t/* Additional section information */\n  Elf32_Word\tsh_addralign;\t\t/* Section alignment */\n  Elf32_Word\tsh_entsize;\t\t/* Entry size if section holds table */\n} Elf32_Shdr;\n\ntypedef struct\n{\n  Elf64_Word\tsh_name;\t\t/* Section name (string tbl index) */\n  Elf64_Word\tsh_type;\t\t/* Section type */\n  Elf64_Xword\tsh_flags;\t\t/* Section flags */\n  Elf64_Addr\tsh_addr;\t\t/* Section virtual addr at execution */\n  Elf64_Off\tsh_offset;\t\t/* Section file offset */\n  Elf64_Xword\tsh_size;\t\t/* Section size in bytes */\n  Elf64_Word\tsh_link;\t\t/* Link to another section */\n  Elf64_Word\tsh_info;\t\t/* Additional section information */\n  Elf64_Xword\tsh_addralign;\t\t/* Section alignment */\n  Elf64_Xword\tsh_entsize;\t\t/* Entry size if section holds table */\n} Elf64_Shdr;\n\n/* Special section indices.  */\n\n#define SHN_UNDEF\t0\t\t/* Undefined section */\n#define SHN_LORESERVE\t0xff00\t\t/* Start of reserved indices */\n#define SHN_LOPROC\t0xff00\t\t/* Start of processor-specific */\n#define SHN_HIPROC\t0xff1f\t\t/* End of processor-specific */\n#define SHN_ABS\t\t0xfff1\t\t/* Associated symbol is absolute */\n#define SHN_COMMON\t0xfff2\t\t/* Associated symbol is common */\n#define SHN_HIRESERVE\t0xffff\t\t/* End of reserved indices */\n\n/* Legal values for sh_type (section type).  */\n\n#define SHT_NULL\t 0\t\t/* Section header table entry unused */\n#define SHT_PROGBITS\t 1\t\t/* Program data */\n#define SHT_SYMTAB\t 2\t\t/* Symbol table */\n#define SHT_STRTAB\t 3\t\t/* String table */\n#define SHT_RELA\t 4\t\t/* Relocation entries with addends */\n#define SHT_HASH\t 5\t\t/* Symbol hash table */\n#define SHT_DYNAMIC\t 6\t\t/* Dynamic linking information */\n#define SHT_NOTE\t 7\t\t/* Notes */\n#define SHT_NOBITS\t 8\t\t/* Program space with no data (bss) */\n#define SHT_REL\t\t 9\t\t/* Relocation entries, no addends */\n#define SHT_SHLIB\t 10\t\t/* Reserved */\n#define SHT_DYNSYM\t 11\t\t/* Dynamic linker symbol table */\n#define\tSHT_NUM\t\t 12\t\t/* Number of defined types.  */\n#define SHT_LOOS\t 0x60000000\t/* Start OS-specific */\n#define SHT_LOSUNW\t 0x6ffffffb\t/* Sun-specific low bound.  */\n#define SHT_SUNW_COMDAT  0x6ffffffb\n#define SHT_SUNW_syminfo 0x6ffffffc\n#define SHT_GNU_verdef\t 0x6ffffffd\t/* Version definition section.  */\n#define SHT_GNU_verneed\t 0x6ffffffe\t/* Version needs section.  */\n#define SHT_GNU_versym\t 0x6fffffff\t/* Version symbol table.  */\n#define SHT_HISUNW\t 0x6fffffff\t/* Sun-specific high bound.  */\n#define SHT_HIOS\t 0x6fffffff\t/* End OS-specific type */\n#define SHT_LOPROC\t 0x70000000\t/* Start of processor-specific */\n#define SHT_HIPROC\t 0x7fffffff\t/* End of processor-specific */\n#define SHT_LOUSER\t 0x80000000\t/* Start of application-specific */\n#define SHT_HIUSER\t 0x8fffffff\t/* End of application-specific */\n\n/* Legal values for sh_flags (section flags).  */\n\n#define SHF_WRITE\t(1 << 0)\t/* Writable */\n#define SHF_ALLOC\t(1 << 1)\t/* Occupies memory during execution */\n#define SHF_EXECINSTR\t(1 << 2)\t/* Executable */\n#define SHF_MASKPROC\t0xf0000000\t/* Processor-specific */\n\n/* Symbol table entry.  */\n\ntypedef struct\n{\n  Elf32_Word\tst_name;\t\t/* Symbol name (string tbl index) */\n  Elf32_Addr\tst_value;\t\t/* Symbol value */\n  Elf32_Word\tst_size;\t\t/* Symbol size */\n  unsigned char\tst_info;\t\t/* Symbol type and binding */\n  unsigned char\tst_other;\t\t/* No defined meaning, 0 */\n  Elf32_Section\tst_shndx;\t\t/* Section index */\n} Elf32_Sym;\n\ntypedef struct\n{\n  Elf64_Word\tst_name;\t\t/* Symbol name (string tbl index) */\n  unsigned char\tst_info;\t\t/* Symbol type and binding */\n  unsigned char st_other;\t\t/* No defined meaning, 0 */\n  Elf64_Section\tst_shndx;\t\t/* Section index */\n  Elf64_Addr\tst_value;\t\t/* Symbol value */\n  Elf64_Xword\tst_size;\t\t/* Symbol size */\n} Elf64_Sym;\n\n/* The syminfo section if available contains additional information about\n   every dynamic symbol.  */\n\ntypedef struct\n{\n  Elf32_Half si_boundto;\t\t/* Direct bindings, symbol bound to */\n  Elf32_Half si_flags;\t\t\t/* Per symbol flags */\n} Elf32_Syminfo;\n\ntypedef struct\n{\n  Elf64_Half si_boundto;\t\t/* Direct bindings, symbol bound to */\n  Elf64_Half si_flags;\t\t\t/* Per symbol flags */\n} Elf64_Syminfo;\n\n/* Possible values for si_boundto.  */\n#define SYMINFO_BT_SELF\t\t0xffff\t/* Symbol bound to self */\n#define SYMINFO_BT_PARENT\t0xfffe\t/* Symbol bound to parent */\n#define SYMINFO_BT_LOWRESERVE\t0xff00\t/* Beginning of reserved entries */\n\n/* Possible bitmasks for si_flags.  */\n#define SYMINFO_FLG_DIRECT\t0x0001\t/* Direct bound symbol */\n#define SYMINFO_FLG_PASSTHRU\t0x0002\t/* Pass-thru symbol for translator */\n#define SYMINFO_FLG_COPY\t0x0004\t/* Symbol is a copy-reloc */\n#define SYMINFO_FLG_LAZYLOAD\t0x0008\t/* Symbol bound to object to be lazy\n\t\t\t\t\t   loaded */\n/* Syminfo version values.  */\n#define SYMINFO_NONE\t\t0\n#define SYMINFO_CURRENT\t\t1\n#define SYMINFO_NUM\t\t2\n\n\n/* Special section index.  */\n\n#define SHN_UNDEF\t0\t\t/* No section, undefined symbol.  */\n\n/* How to extract and insert information held in the st_info field.  */\n\n#define ELF32_ST_BIND(val)\t\t(((unsigned char) (val)) >> 4)\n#define ELF32_ST_TYPE(val)\t\t((val) & 0xf)\n#define ELF32_ST_INFO(bind, type)\t(((bind) << 4) + ((type) & 0xf))\n\n/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */\n#define ELF64_ST_BIND(val)\t\tELF32_ST_BIND (val)\n#define ELF64_ST_TYPE(val)\t\tELF32_ST_TYPE (val)\n#define ELF64_ST_INFO(bind, type)\tELF32_ST_INFO ((bind), (type))\n\n/* Legal values for ST_BIND subfield of st_info (symbol binding).  */\n\n#define STB_LOCAL\t0\t\t/* Local symbol */\n#define STB_GLOBAL\t1\t\t/* Global symbol */\n#define STB_WEAK\t2\t\t/* Weak symbol */\n#define\tSTB_NUM\t\t3\t\t/* Number of defined types.  */\n#define STB_LOOS\t10\t\t/* Start of OS-specific */\n#define STB_HIOS\t12\t\t/* End of OS-specific */\n#define STB_LOPROC\t13\t\t/* Start of processor-specific */\n#define STB_HIPROC\t15\t\t/* End of processor-specific */\n\n/* Legal values for ST_TYPE subfield of st_info (symbol type).  */\n\n#define STT_NOTYPE\t0\t\t/* Symbol type is unspecified */\n#define STT_OBJECT\t1\t\t/* Symbol is a data object */\n#define STT_FUNC\t2\t\t/* Symbol is a code object */\n#define STT_SECTION\t3\t\t/* Symbol associated with a section */\n#define STT_FILE\t4\t\t/* Symbol's name is file name */\n#define\tSTT_NUM\t\t5\t\t/* Number of defined types.  */\n#define STT_LOOS\t11\t\t/* Start of OS-specific */\n#define STT_HIOS\t12\t\t/* End of OS-specific */\n#define STT_LOPROC\t13\t\t/* Start of processor-specific */\n#define STT_HIPROC\t15\t\t/* End of processor-specific */\n\n\n/* Symbol table indices are found in the hash buckets and chain table\n   of a symbol hash table section.  This special index value indicates\n   the end of a chain, meaning no further symbols are found in that bucket.  */\n\n#define STN_UNDEF\t0\t\t/* End of a chain.  */\n\n\n/* How to extract and insert information held in the st_other field.  */\n\n#define ELF32_ST_VISIBILITY(o)\t((o) & 0x03)\n\n/* For ELF64 the definitions are the same.  */\n#define ELF64_ST_VISIBILITY(o)\tELF32_ST_VISIBILITY (o)\n\n/* Symbol visibility specification encoded in the st_other field.  */\n#define STV_DEFAULT\t0\t\t/* Default symbol visibility rules */\n#define STV_INTERNAL\t1\t\t/* Processor specific hidden class */\n#define STV_HIDDEN\t2\t\t/* Sym unavailable in other modules */\n#define STV_PROTECTED\t3\t\t/* Not preemptible, not exported */\n\n\n/* Relocation table entry without addend (in section of type SHT_REL).  */\n\ntypedef struct\n{\n  Elf32_Addr\tr_offset;\t\t/* Address */\n  Elf32_Word\tr_info;\t\t\t/* Relocation type and symbol index */\n} Elf32_Rel;\n\n/* I have seen two different definitions of the Elf64_Rel and\n   Elf64_Rela structures, so we'll leave them out until Novell (or\n   whoever) gets their act together.  */\n/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */\n\ntypedef struct\n{\n  Elf64_Addr\tr_offset;\t\t/* Address */\n  Elf64_Xword\tr_info;\t\t\t/* Relocation type and symbol index */\n} Elf64_Rel;\n\n/* Relocation table entry with addend (in section of type SHT_RELA).  */\n\ntypedef struct\n{\n  Elf32_Addr\tr_offset;\t\t/* Address */\n  Elf32_Word\tr_info;\t\t\t/* Relocation type and symbol index */\n  Elf32_Sword\tr_addend;\t\t/* Addend */\n} Elf32_Rela;\n\ntypedef struct\n{\n  Elf64_Addr\tr_offset;\t\t/* Address */\n  Elf64_Xword\tr_info;\t\t\t/* Relocation type and symbol index */\n  Elf64_Sxword\tr_addend;\t\t/* Addend */\n} Elf64_Rela;\n\n/* How to extract and insert information held in the r_info field.  */\n\n#define ELF32_R_SYM(val)\t\t((val) >> 8)\n#define ELF32_R_TYPE(val)\t\t((val) & 0xff)\n#define ELF32_R_INFO(sym, type)\t\t(((sym) << 8) + ((type) & 0xff))\n\n#define ELF64_R_SYM(i)\t\t\t((i) >> 32)\n#define ELF64_R_TYPE(i)\t\t\t((i) & 0xffffffff)\n#define ELF64_R_INFO(sym,type)\t\t(((sym) << 32) + (type))\n\n/* Program segment header.  */\n\ntypedef struct\n{\n  Elf32_Word\tp_type;\t\t\t/* Segment type */\n  Elf32_Off\tp_offset;\t\t/* Segment file offset */\n  Elf32_Addr\tp_vaddr;\t\t/* Segment virtual address */\n  Elf32_Addr\tp_paddr;\t\t/* Segment physical address */\n  Elf32_Word\tp_filesz;\t\t/* Segment size in file */\n  Elf32_Word\tp_memsz;\t\t/* Segment size in memory */\n  Elf32_Word\tp_flags;\t\t/* Segment flags */\n  Elf32_Word\tp_align;\t\t/* Segment alignment */\n} Elf32_Phdr;\n\ntypedef struct\n{\n  Elf64_Word\tp_type;\t\t\t/* Segment type */\n  Elf64_Word\tp_flags;\t\t/* Segment flags */\n  Elf64_Off\tp_offset;\t\t/* Segment file offset */\n  Elf64_Addr\tp_vaddr;\t\t/* Segment virtual address */\n  Elf64_Addr\tp_paddr;\t\t/* Segment physical address */\n  Elf64_Xword\tp_filesz;\t\t/* Segment size in file */\n  Elf64_Xword\tp_memsz;\t\t/* Segment size in memory */\n  Elf64_Xword\tp_align;\t\t/* Segment alignment */\n} Elf64_Phdr;\n\n/* Legal values for p_type (segment type).  */\n\n#define\tPT_NULL\t\t0\t\t/* Program header table entry unused */\n#define PT_LOAD\t\t1\t\t/* Loadable program segment */\n#define PT_DYNAMIC\t2\t\t/* Dynamic linking information */\n#define PT_INTERP\t3\t\t/* Program interpreter */\n#define PT_NOTE\t\t4\t\t/* Auxiliary information */\n#define PT_SHLIB\t5\t\t/* Reserved */\n#define PT_PHDR\t\t6\t\t/* Entry for header table itself */\n#define\tPT_NUM\t\t7\t\t/* Number of defined types.  */\n#define PT_LOOS\t\t0x60000000\t/* Start of OS-specific */\n#define PT_HIOS\t\t0x6fffffff\t/* End of OS-specific */\n#define PT_LOPROC\t0x70000000\t/* Start of processor-specific */\n#define PT_HIPROC\t0x7fffffff\t/* End of processor-specific */\n\n/* Legal values for p_flags (segment flags).  */\n\n#define PF_X\t\t(1 << 0)\t/* Segment is executable */\n#define PF_W\t\t(1 << 1)\t/* Segment is writable */\n#define PF_R\t\t(1 << 2)\t/* Segment is readable */\n#define PF_MASKPROC\t0xf0000000\t/* Processor-specific */\n\n/* Legal values for note segment descriptor types for core files. */\n\n#define NT_PRSTATUS\t1\t\t/* Contains copy of prstatus struct */\n#define NT_FPREGSET\t2\t\t/* Contains copy of fpregset struct */\n#define NT_PRPSINFO\t3\t\t/* Contains copy of prpsinfo struct */\n#define NT_PRXREG\t4\t\t/* Contains copy of prxregset struct */\n#define NT_PLATFORM\t5\t\t/* String from sysinfo(SI_PLATFORM) */\n#define NT_AUXV\t\t6\t\t/* Contains copy of auxv array */\n#define NT_GWINDOWS\t7\t\t/* Contains copy of gwindows struct */\n#define NT_PSTATUS\t10\t\t/* Contains copy of pstatus struct */\n#define NT_PSINFO\t13\t\t/* Contains copy of psinfo struct */\n#define NT_PRCRED\t14\t\t/* Contains copy of prcred struct */\n#define NT_UTSNAME\t15\t\t/* Contains copy of utsname struct */\n#define NT_LWPSTATUS\t16\t\t/* Contains copy of lwpstatus struct */\n#define NT_LWPSINFO\t17\t\t/* Contains copy of lwpinfo struct */\n\n/* Legal values for the  note segment descriptor types for object files.  */\n\n#define NT_VERSION\t1\t\t/* Contains a version string.  */\n\n\n/* Dynamic section entry.  */\n\ntypedef struct\n{\n  Elf32_Sword\td_tag;\t\t\t/* Dynamic entry type */\n  union\n    {\n      Elf32_Word d_val;\t\t\t/* Integer value */\n      Elf32_Addr d_ptr;\t\t\t/* Address value */\n    } d_un;\n} Elf32_Dyn;\n\ntypedef struct\n{\n  Elf64_Sxword\td_tag;\t\t\t/* Dynamic entry type */\n  union\n    {\n      Elf64_Xword d_val;\t\t/* Integer value */\n      Elf64_Addr d_ptr;\t\t\t/* Address value */\n    } d_un;\n} Elf64_Dyn;\n\n/* Legal values for d_tag (dynamic entry type).  */\n\n#define DT_NULL\t\t0\t\t/* Marks end of dynamic section */\n#define DT_NEEDED\t1\t\t/* Name of needed library */\n#define DT_PLTRELSZ\t2\t\t/* Size in bytes of PLT relocs */\n#define DT_PLTGOT\t3\t\t/* Processor defined value */\n#define DT_HASH\t\t4\t\t/* Address of symbol hash table */\n#define DT_STRTAB\t5\t\t/* Address of string table */\n#define DT_SYMTAB\t6\t\t/* Address of symbol table */\n#define DT_RELA\t\t7\t\t/* Address of Rela relocs */\n#define DT_RELASZ\t8\t\t/* Total size of Rela relocs */\n#define DT_RELAENT\t9\t\t/* Size of one Rela reloc */\n#define DT_STRSZ\t10\t\t/* Size of string table */\n#define DT_SYMENT\t11\t\t/* Size of one symbol table entry */\n#define DT_INIT\t\t12\t\t/* Address of init function */\n#define DT_FINI\t\t13\t\t/* Address of termination function */\n#define DT_SONAME\t14\t\t/* Name of shared object */\n#define DT_RPATH\t15\t\t/* Library search path */\n#define DT_SYMBOLIC\t16\t\t/* Start symbol search here */\n#define DT_REL\t\t17\t\t/* Address of Rel relocs */\n#define DT_RELSZ\t18\t\t/* Total size of Rel relocs */\n#define DT_RELENT\t19\t\t/* Size of one Rel reloc */\n#define DT_PLTREL\t20\t\t/* Type of reloc in PLT */\n#define DT_DEBUG\t21\t\t/* For debugging; unspecified */\n#define DT_TEXTREL\t22\t\t/* Reloc might modify .text */\n#define DT_JMPREL\t23\t\t/* Address of PLT relocs */\n#define\tDT_BIND_NOW\t24\t\t/* Process relocations of object */\n#define\tDT_INIT_ARRAY\t25\t\t/* Array with addresses of init fct */\n#define\tDT_FINI_ARRAY\t26\t\t/* Array with addresses of fini fct */\n#define\tDT_INIT_ARRAYSZ\t27\t\t/* Size in bytes of DT_INIT_ARRAY */\n#define\tDT_FINI_ARRAYSZ\t28\t\t/* Size in bytes of DT_FINI_ARRAY */\n#define\tDT_NUM\t\t29\t\t/* Number used */\n#define DT_LOOS\t\t0x60000000\t/* Start of OS-specific */\n#define DT_HIOS\t\t0x6fffffff\t/* End of OS-specific */\n#define DT_LOPROC\t0x70000000\t/* Start of processor-specific */\n#define DT_HIPROC\t0x7fffffff\t/* End of processor-specific */\n#define\tDT_PROCNUM\tDT_MIPS_NUM\t/* Most used by any processor */\n\n/* DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the\n   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's\n   approach.  */\n#define DT_VALRNGLO\t0x6ffffd00\n#define DT_POSFLAG_1\t0x6ffffdfd\t/* Flags for DT_* entries, effecting\n\t\t\t\t\t   the following DT_* entry.  */\n#define DT_SYMINSZ\t0x6ffffdfe\t/* Size of syminfo table (in bytes) */\n#define DT_SYMINENT\t0x6ffffdff\t/* Entry size of syminfo */\n#define DT_VALRNGHI\t0x6ffffdff\n\n/* DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the\n   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.\n\n   If any adjustment is made to the ELF object after it has been\n   built these entries will need to be adjusted.  */\n#define DT_ADDRRNGLO\t0x6ffffe00\n#define DT_SYMINFO\t0x6ffffeff\t/* syminfo table */\n#define DT_ADDRRNGHI\t0x6ffffeff\n\n/* The versioning entry types.  The next are defined as part of the\n   GNU extension.  */\n#define DT_VERSYM\t0x6ffffff0\n\n/* These were chosen by Sun.  */\n#define DT_FLAGS_1\t0x6ffffffb\t/* State flags, see DF_1_* below.  */\n#define\tDT_VERDEF\t0x6ffffffc\t/* Address of version definition\n\t\t\t\t\t   table */\n#define\tDT_VERDEFNUM\t0x6ffffffd\t/* Number of version definitions */\n#define\tDT_VERNEED\t0x6ffffffe\t/* Address of table with needed\n\t\t\t\t\t   versions */\n#define\tDT_VERNEEDNUM\t0x6fffffff\t/* Number of needed versions */\n#define DT_VERSIONTAGIDX(tag)\t(DT_VERNEEDNUM - (tag))\t/* Reverse order! */\n#define DT_VERSIONTAGNUM 16\n\n/* Sun added these machine-independent extensions in the \"processor-specific\"\n   range.  Be compatible.  */\n#define DT_AUXILIARY    0x7ffffffd      /* Shared object to load before self */\n#define DT_FILTER       0x7fffffff      /* Shared object to get values from */\n#define DT_EXTRATAGIDX(tag)\t((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)\n#define DT_EXTRANUM\t3\n\n/* State flags selectable in the `d_un.d_val' element of the DT_FLAGS_1\n   entry in the dynamic section.  */\n#define DF_1_NOW\t0x00000001\t/* Set RTLD_NOW for this object.  */\n#define DF_1_GLOBAL\t0x00000002\t/* Set RTLD_GLOBAL for this object.  */\n#define DF_1_GROUP\t0x00000004\t/* Set RTLD_GROUP for this object.  */\n#define DF_1_NODELETE\t0x00000008\t/* Set RTLD_NODELETE for this object.*/\n#define DF_1_LOADFLTR\t0x00000010\t/* Trigger filtee loading at runtime.*/\n#define DF_1_INITFIRST\t0x00000020\t/* Set RTLD_INITFIRST for this object*/\n#define DF_1_NOOPEN\t0x00000040\t/* Set RTLD_NOOPEN for this object.  */\n\n/* Version definition sections.  */\n\ntypedef struct\n{\n  Elf32_Half\tvd_version;\t\t/* Version revision */\n  Elf32_Half\tvd_flags;\t\t/* Version information */\n  Elf32_Half\tvd_ndx;\t\t\t/* Version Index */\n  Elf32_Half\tvd_cnt;\t\t\t/* Number of associated aux entries */\n  Elf32_Word\tvd_hash;\t\t/* Version name hash value */\n  Elf32_Word\tvd_aux;\t\t\t/* Offset in bytes to verdaux array */\n  Elf32_Word\tvd_next;\t\t/* Offset in bytes to next verdef\n\t\t\t\t\t   entry */\n} Elf32_Verdef;\n\ntypedef struct\n{\n  Elf64_Half\tvd_version;\t\t/* Version revision */\n  Elf64_Half\tvd_flags;\t\t/* Version information */\n  Elf64_Half\tvd_ndx;\t\t\t/* Version Index */\n  Elf64_Half\tvd_cnt;\t\t\t/* Number of associated aux entries */\n  Elf64_Word\tvd_hash;\t\t/* Version name hash value */\n  Elf64_Word\tvd_aux;\t\t\t/* Offset in bytes to verdaux array */\n  Elf64_Word\tvd_next;\t\t/* Offset in bytes to next verdef\n\t\t\t\t\t   entry */\n} Elf64_Verdef;\n\n\n/* Legal values for vd_version (version revision).  */\n#define VER_DEF_NONE\t0\t\t/* No version */\n#define VER_DEF_CURRENT\t1\t\t/* Current version */\n#define VER_DEF_NUM\t2\t\t/* Given version number */\n\n/* Legal values for vd_flags (version information flags).  */\n#define VER_FLG_BASE\t0x1\t\t/* Version definition of file itself */\n#define VER_FLG_WEAK\t0x2\t\t/* Weak version identifier */\n\n/* Auxialiary version information.  */\n\ntypedef struct\n{\n  Elf32_Word\tvda_name;\t\t/* Version or dependency names */\n  Elf32_Word\tvda_next;\t\t/* Offset in bytes to next verdaux\n\t\t\t\t\t   entry */\n} Elf32_Verdaux;\n\ntypedef struct\n{\n  Elf64_Word\tvda_name;\t\t/* Version or dependency names */\n  Elf64_Word\tvda_next;\t\t/* Offset in bytes to next verdaux\n\t\t\t\t\t   entry */\n} Elf64_Verdaux;\n\n\n/* Version dependency section.  */\n\ntypedef struct\n{\n  Elf32_Half\tvn_version;\t\t/* Version of structure */\n  Elf32_Half\tvn_cnt;\t\t\t/* Number of associated aux entries */\n  Elf32_Word\tvn_file;\t\t/* Offset of filename for this\n\t\t\t\t\t   dependency */\n  Elf32_Word\tvn_aux;\t\t\t/* Offset in bytes to vernaux array */\n  Elf32_Word\tvn_next;\t\t/* Offset in bytes to next verneed\n\t\t\t\t\t   entry */\n} Elf32_Verneed;\n\ntypedef struct\n{\n  Elf64_Half\tvn_version;\t\t/* Version of structure */\n  Elf64_Half\tvn_cnt;\t\t\t/* Number of associated aux entries */\n  Elf64_Word\tvn_file;\t\t/* Offset of filename for this\n\t\t\t\t\t   dependency */\n  Elf64_Word\tvn_aux;\t\t\t/* Offset in bytes to vernaux array */\n  Elf64_Word\tvn_next;\t\t/* Offset in bytes to next verneed\n\t\t\t\t\t   entry */\n} Elf64_Verneed;\n\n\n/* Legal values for vn_version (version revision).  */\n#define VER_NEED_NONE\t 0\t\t/* No version */\n#define VER_NEED_CURRENT 1\t\t/* Current version */\n#define VER_NEED_NUM\t 2\t\t/* Given version number */\n\n/* Auxiliary needed version information.  */\n\ntypedef struct\n{\n  Elf32_Word\tvna_hash;\t\t/* Hash value of dependency name */\n  Elf32_Half\tvna_flags;\t\t/* Dependency specific information */\n  Elf32_Half\tvna_other;\t\t/* Unused */\n  Elf32_Word\tvna_name;\t\t/* Dependency name string offset */\n  Elf32_Word\tvna_next;\t\t/* Offset in bytes to next vernaux\n\t\t\t\t\t   entry */\n} Elf32_Vernaux;\n\ntypedef struct\n{\n  Elf64_Word\tvna_hash;\t\t/* Hash value of dependency name */\n  Elf64_Half\tvna_flags;\t\t/* Dependency specific information */\n  Elf64_Half\tvna_other;\t\t/* Unused */\n  Elf64_Word\tvna_name;\t\t/* Dependency name string offset */\n  Elf64_Word\tvna_next;\t\t/* Offset in bytes to next vernaux\n\t\t\t\t\t   entry */\n} Elf64_Vernaux;\n\n\n/* Legal values for vna_flags.  */\n#define VER_FLG_WEAK\t0x2\t\t/* Weak version identifier */\n\n\n/* Auxiliary vector.  */\n\n/* This vector is normally only used by the program interpreter.  The\n   usual definition in an ABI supplement uses the name auxv_t.  The\n   vector is not usually defined in a standard <elf.h> file, but it\n   can't hurt.  We rename it to avoid conflicts.  The sizes of these\n   types are an arrangement between the exec server and the program\n   interpreter, so we don't fully specify them here.  */\n\ntypedef struct\n{\n  int a_type;\t\t\t/* Entry type */\n  union\n    {\n      long int a_val;\t\t/* Integer value */\n      void *a_ptr;\t\t/* Pointer value */\n      void (*a_fcn) (void);\t/* Function pointer value */\n    } a_un;\n} Elf32_auxv_t;\n\ntypedef struct\n{\n  long int a_type;\t\t/* Entry type */\n  union\n    {\n      long int a_val;\t\t/* Integer value */\n      void *a_ptr;\t\t/* Pointer value */\n      void (*a_fcn) (void);\t/* Function pointer value */\n    } a_un;\n} Elf64_auxv_t;\n\n/* Legal values for a_type (entry type).  */\n\n#define AT_NULL\t\t0\t\t/* End of vector */\n#define AT_IGNORE\t1\t\t/* Entry should be ignored */\n#define AT_EXECFD\t2\t\t/* File descriptor of program */\n#define AT_PHDR\t\t3\t\t/* Program headers for program */\n#define AT_PHENT\t4\t\t/* Size of program header entry */\n#define AT_PHNUM\t5\t\t/* Number of program headers */\n#define AT_PAGESZ\t6\t\t/* System page size */\n#define AT_BASE\t\t7\t\t/* Base address of interpreter */\n#define AT_FLAGS\t8\t\t/* Flags */\n#define AT_ENTRY\t9\t\t/* Entry point of program */\n#define AT_NOTELF\t10\t\t/* Program is not ELF */\n#define AT_UID\t\t11\t\t/* Real uid */\n#define AT_EUID\t\t12\t\t/* Effective uid */\n#define AT_GID\t\t13\t\t/* Real gid */\n#define AT_EGID\t\t14\t\t/* Effective gid */\n\n/* Some more special a_type values describing the hardware.  */\n#define AT_PLATFORM\t15\t\t/* String identifying platform.  */\n#define AT_HWCAP\t16\t\t/* Machine dependent hints about\n\t\t\t\t\t   processor capabilities.  */\n\n/* This entry gives some information about the FPU initialization\n   performed by the kernel.  */\n#define AT_FPUCW\t17\t\t/* Used FPU control word.  */\n\n\n/* Note section contents.  Each entry in the note section begins with\n   a header of a fixed form.  */\n\ntypedef struct\n{\n  Elf32_Word n_namesz;\t\t\t/* Length of the note's name.  */\n  Elf32_Word n_descsz;\t\t\t/* Length of the note's descriptor.  */\n  Elf32_Word n_type;\t\t\t/* Type of the note.  */\n} Elf32_Nhdr;\n\ntypedef struct\n{\n  Elf64_Word n_namesz;\t\t\t/* Length of the note's name.  */\n  Elf64_Word n_descsz;\t\t\t/* Length of the note's descriptor.  */\n  Elf64_Word n_type;\t\t\t/* Type of the note.  */\n} Elf64_Nhdr;\n\n/* Known names of notes.  */\n\n/* Solaris entries in the note section have this name.  */\n#define ELF_NOTE_SOLARIS\t\"SUNW Solaris\"\n\n/* Note entries for GNU systems have this name.  */\n#define ELF_NOTE_GNU\t\t\"GNU\"\n\n\n/* Defined types of notes for Solaris.  */\n\n/* Value of descriptor (one word) is desired pagesize for the binary.  */\n#define ELF_NOTE_PAGESIZE_HINT\t1\n\n\n/* Defined note types for GNU systems.  */\n\n/* ABI information.  The descriptor consists of words:\n   word 0: OS descriptor\n   word 1: major version of the ABI\n   word 2: minor version of the ABI\n   word 3: subminor version of the ABI\n*/\n#define ELF_NOTE_ABI\t\t1\n\n/* Known OSes.  These value can appear in word 0 of an ELF_NOTE_ABI\n   note section entry.  */\n#define ELF_NOTE_OS_LINUX\t0\n#define ELF_NOTE_OS_GNU\t\t1\n#define ELF_NOTE_OS_SOLARIS2\t2\n\n\n/* Motorola 68k specific definitions.  */\n\n/* m68k relocs.  */\n\n#define R_68K_NONE\t0\t\t/* No reloc */\n#define R_68K_32\t1\t\t/* Direct 32 bit  */\n#define R_68K_16\t2\t\t/* Direct 16 bit  */\n#define R_68K_8\t\t3\t\t/* Direct 8 bit  */\n#define R_68K_PC32\t4\t\t/* PC relative 32 bit */\n#define R_68K_PC16\t5\t\t/* PC relative 16 bit */\n#define R_68K_PC8\t6\t\t/* PC relative 8 bit */\n#define R_68K_GOT32\t7\t\t/* 32 bit PC relative GOT entry */\n#define R_68K_GOT16\t8\t\t/* 16 bit PC relative GOT entry */\n#define R_68K_GOT8\t9\t\t/* 8 bit PC relative GOT entry */\n#define R_68K_GOT32O\t10\t\t/* 32 bit GOT offset */\n#define R_68K_GOT16O\t11\t\t/* 16 bit GOT offset */\n#define R_68K_GOT8O\t12\t\t/* 8 bit GOT offset */\n#define R_68K_PLT32\t13\t\t/* 32 bit PC relative PLT address */\n#define R_68K_PLT16\t14\t\t/* 16 bit PC relative PLT address */\n#define R_68K_PLT8\t15\t\t/* 8 bit PC relative PLT address */\n#define R_68K_PLT32O\t16\t\t/* 32 bit PLT offset */\n#define R_68K_PLT16O\t17\t\t/* 16 bit PLT offset */\n#define R_68K_PLT8O\t18\t\t/* 8 bit PLT offset */\n#define R_68K_COPY\t19\t\t/* Copy symbol at runtime */\n#define R_68K_GLOB_DAT\t20\t\t/* Create GOT entry */\n#define R_68K_JMP_SLOT\t21\t\t/* Create PLT entry */\n#define R_68K_RELATIVE\t22\t\t/* Adjust by program base */\n/* Keep this the last entry.  */\n#define R_68K_NUM\t23\n\n/* Intel 80386 specific definitions.  */\n\n/* i386 relocs.  */\n\n#define R_386_NONE\t0\t\t/* No reloc */\n#define R_386_32\t1\t\t/* Direct 32 bit  */\n#define R_386_PC32\t2\t\t/* PC relative 32 bit */\n#define R_386_GOT32\t3\t\t/* 32 bit GOT entry */\n#define R_386_PLT32\t4\t\t/* 32 bit PLT address */\n#define R_386_COPY\t5\t\t/* Copy symbol at runtime */\n#define R_386_GLOB_DAT\t6\t\t/* Create GOT entry */\n#define R_386_JMP_SLOT\t7\t\t/* Create PLT entry */\n#define R_386_RELATIVE\t8\t\t/* Adjust by program base */\n#define R_386_GOTOFF\t9\t\t/* 32 bit offset to GOT */\n#define R_386_GOTPC\t10\t\t/* 32 bit PC relative offset to GOT */\n/* Keep this the last entry.  */\n#define R_386_NUM\t11\n\n/* SUN SPARC specific definitions.  */\n\n/* Values for Elf64_Ehdr.e_flags.  */\n\n#define EF_SPARCV9_MM\t\t3\n#define EF_SPARCV9_TSO\t\t0\n#define EF_SPARCV9_PSO\t\t1\n#define EF_SPARCV9_RMO\t\t2\n#define EF_SPARC_EXT_MASK\t0xFFFF00\n#define EF_SPARC_SUN_US1\t0x000200\n#define EF_SPARC_HAL_R1\t\t0x000400\n\n/* SPARC relocs.  */\n\n#define R_SPARC_NONE\t0\t\t/* No reloc */\n#define R_SPARC_8\t1\t\t/* Direct 8 bit */\n#define R_SPARC_16\t2\t\t/* Direct 16 bit */\n#define R_SPARC_32\t3\t\t/* Direct 32 bit */\n#define R_SPARC_DISP8\t4\t\t/* PC relative 8 bit */\n#define R_SPARC_DISP16\t5\t\t/* PC relative 16 bit */\n#define R_SPARC_DISP32\t6\t\t/* PC relative 32 bit */\n#define R_SPARC_WDISP30\t7\t\t/* PC relative 30 bit shifted */\n#define R_SPARC_WDISP22\t8\t\t/* PC relative 22 bit shifted */\n#define R_SPARC_HI22\t9\t\t/* High 22 bit */\n#define R_SPARC_22\t10\t\t/* Direct 22 bit */\n#define R_SPARC_13\t11\t\t/* Direct 13 bit */\n#define R_SPARC_LO10\t12\t\t/* Truncated 10 bit */\n#define R_SPARC_GOT10\t13\t\t/* Truncated 10 bit GOT entry */\n#define R_SPARC_GOT13\t14\t\t/* 13 bit GOT entry */\n#define R_SPARC_GOT22\t15\t\t/* 22 bit GOT entry shifted */\n#define R_SPARC_PC10\t16\t\t/* PC relative 10 bit truncated */\n#define R_SPARC_PC22\t17\t\t/* PC relative 22 bit shifted */\n#define R_SPARC_WPLT30\t18\t\t/* 30 bit PC relative PLT address */\n#define R_SPARC_COPY\t19\t\t/* Copy symbol at runtime */\n#define R_SPARC_GLOB_DAT 20\t\t/* Create GOT entry */\n#define R_SPARC_JMP_SLOT 21\t\t/* Create PLT entry */\n#define R_SPARC_RELATIVE 22\t\t/* Adjust by program base */\n#define R_SPARC_UA32\t23\t\t/* Direct 32 bit unaligned */\n\n/* Additional Sparc64 relocs.  */\n\n#define R_SPARC_PLT32\t24\t\t/* Direct 32 bit ref to PLT entry */\n#define R_SPARC_HIPLT22\t25\t\t/* High 22 bit PLT entry */\n#define R_SPARC_LOPLT10\t26\t\t/* Truncated 10 bit PLT entry */\n#define R_SPARC_PCPLT32\t27\t\t/* PC rel 32 bit ref to PLT entry */\n#define R_SPARC_PCPLT22\t28\t\t/* PC rel high 22 bit PLT entry */\n#define R_SPARC_PCPLT10\t29\t\t/* PC rel trunc 10 bit PLT entry */\n#define R_SPARC_10\t30\t\t/* Direct 10 bit */\n#define R_SPARC_11\t31\t\t/* Direct 11 bit */\n#define R_SPARC_64\t32\t\t/* Direct 64 bit */\n#define R_SPARC_OLO10\t33\t\t/* ?? */\n#define R_SPARC_HH22\t34\t\t/* Top 22 bits of direct 64 bit */\n#define R_SPARC_HM10\t35\t\t/* High middle 10 bits of ... */\n#define R_SPARC_LM22\t36\t\t/* Low middle 22 bits of ... */\n#define R_SPARC_PC_HH22\t37\t\t/* Top 22 bits of pc rel 64 bit */\n#define R_SPARC_PC_HM10\t38\t\t/* High middle 10 bit of ... */\n#define R_SPARC_PC_LM22\t39\t\t/* Low miggle 22 bits of ... */\n#define R_SPARC_WDISP16\t40\t\t/* PC relative 16 bit shifted */\n#define R_SPARC_WDISP19\t41\t\t/* PC relative 19 bit shifted */\n#define R_SPARC_7\t43\t\t/* Direct 7 bit */\n#define R_SPARC_5\t44\t\t/* Direct 5 bit */\n#define R_SPARC_6\t45\t\t/* Direct 6 bit */\n#define R_SPARC_DISP64\t46\t\t/* PC relative 64 bit */\n#define R_SPARC_PLT64\t47\t\t/* Direct 64 bit ref to PLT entry */\n#define R_SPARC_HIX22\t48\t\t/* High 22 bit complemented */\n#define R_SPARC_LOX10\t49\t\t/* Truncated 11 bit complemented */\n#define R_SPARC_H44\t50\t\t/* Direct high 12 of 44 bit */\n#define R_SPARC_M44\t51\t\t/* Direct mid 22 of 44 bit */\n#define R_SPARC_L44\t52\t\t/* Direct low 10 of 44 bit */\n#define R_SPARC_REGISTER 53\t\t/* Global register usage */\n#define R_SPARC_UA64\t54\t\t/* Direct 64 bit unaligned */\n#define R_SPARC_UA16\t55\t\t/* Direct 16 bit unaligned */\n/* Keep this the last entry.  */\n#define R_SPARC_NUM\t56\n\n/* For Sparc64, legal values for d_tag of Elf64_Dyn.  */\n\n#define DT_SPARC_REGISTER 0x70000001\n#define DT_SPARC_NUM\t2\n\n/* Bits present in AT_HWCAP, primarily for Sparc32.  */\n\n#define HWCAP_SPARC_FLUSH\t1\t/* The cpu supports flush insn.  */\n#define HWCAP_SPARC_STBAR\t2\n#define HWCAP_SPARC_SWAP\t4\n#define HWCAP_SPARC_MULDIV\t8\n#define HWCAP_SPARC_V9\t\t16\t/* The cpu is v9, so v8plus is ok.  */\n\n/* MIPS R3000 specific definitions.  */\n\n/* Legal values for e_flags field of Elf32_Ehdr.  */\n\n#define EF_MIPS_NOREORDER   1\t\t/* A .noreorder directive was used */\n#define EF_MIPS_PIC\t    2\t\t/* Contains PIC code */\n#define EF_MIPS_CPIC\t    4\t\t/* Uses PIC calling sequence */\n#define EF_MIPS_XGOT\t    8\n#define EF_MIPS_64BIT_WHIRL 16\n#define EF_MIPS_ABI2\t    32\n#define EF_MIPS_ABI_ON32    64\n#define EF_MIPS_ARCH\t    0xf0000000\t/* MIPS architecture level */\n\n/* Legal values for MIPS architecture level.  */\n\n#define EF_MIPS_ARCH_1\t    0x00000000\t/* -mips1 code.  */\n#define EF_MIPS_ARCH_2\t    0x10000000\t/* -mips2 code.  */\n#define EF_MIPS_ARCH_3\t    0x20000000\t/* -mips3 code.  */\n#define EF_MIPS_ARCH_4\t    0x30000000\t/* -mips4 code.  */\n#define EF_MIPS_ARCH_5\t    0x40000000\t/* -mips5 code.  */\n\n/* The following are non-official names and should not be used.  */\n\n#define E_MIPS_ARCH_1\t  0x00000000\t/* -mips1 code.  */\n#define E_MIPS_ARCH_2\t  0x10000000\t/* -mips2 code.  */\n#define E_MIPS_ARCH_3\t  0x20000000\t/* -mips3 code.  */\n#define E_MIPS_ARCH_4\t  0x30000000\t/* -mips4 code.  */\n#define E_MIPS_ARCH_5\t  0x40000000\t/* -mips5 code.  */\n\n/* Special section indices.  */\n\n#define SHN_MIPS_ACOMMON 0xff00\t\t/* Allocated common symbols */\n#define SHN_MIPS_TEXT\t 0xff01\t\t/* Allocated test symbols.  */\n#define SHN_MIPS_DATA\t 0xff02\t\t/* Allocated data symbols.  */\n#define SHN_MIPS_SCOMMON 0xff03\t\t/* Small common symbols */\n#define SHN_MIPS_SUNDEFINED 0xff04\t/* Small undefined symbols */\n\n/* Legal values for sh_type field of Elf32_Shdr.  */\n\n#define SHT_MIPS_LIBLIST       0x70000000 /* Shared objects used in link */\n#define SHT_MIPS_MSYM\t       0x70000001\n#define SHT_MIPS_CONFLICT      0x70000002 /* Conflicting symbols */\n#define SHT_MIPS_GPTAB\t       0x70000003 /* Global data area sizes */\n#define SHT_MIPS_UCODE\t       0x70000004 /* Reserved for SGI/MIPS compilers */\n#define SHT_MIPS_DEBUG\t       0x70000005 /* MIPS ECOFF debugging information*/\n#define SHT_MIPS_REGINFO       0x70000006 /* Register usage information */\n#define SHT_MIPS_PACKAGE       0x70000007\n#define SHT_MIPS_PACKSYM       0x70000008\n#define SHT_MIPS_RELD\t       0x70000009\n#define SHT_MIPS_IFACE         0x7000000b\n#define SHT_MIPS_CONTENT       0x7000000c\n#define SHT_MIPS_OPTIONS       0x7000000d /* Miscellaneous options.  */\n#define SHT_MIPS_SHDR\t       0x70000010\n#define SHT_MIPS_FDESC\t       0x70000011\n#define SHT_MIPS_EXTSYM\t       0x70000012\n#define SHT_MIPS_DENSE\t       0x70000013\n#define SHT_MIPS_PDESC\t       0x70000014\n#define SHT_MIPS_LOCSYM\t       0x70000015\n#define SHT_MIPS_AUXSYM\t       0x70000016\n#define SHT_MIPS_OPTSYM\t       0x70000017\n#define SHT_MIPS_LOCSTR\t       0x70000018\n#define SHT_MIPS_LINE\t       0x70000019\n#define SHT_MIPS_RFDESC\t       0x7000001a\n#define SHT_MIPS_DELTASYM      0x7000001b\n#define SHT_MIPS_DELTAINST     0x7000001c\n#define SHT_MIPS_DELTACLASS    0x7000001d\n#define SHT_MIPS_DWARF         0x7000001e /* DWARF debugging information.  */\n#define SHT_MIPS_DELTADECL     0x7000001f\n#define SHT_MIPS_SYMBOL_LIB    0x70000020\n#define SHT_MIPS_EVENTS\t       0x70000021 /* Event section.  */\n#define SHT_MIPS_TRANSLATE     0x70000022\n#define SHT_MIPS_PIXIE\t       0x70000023\n#define SHT_MIPS_XLATE\t       0x70000024\n#define SHT_MIPS_XLATE_DEBUG   0x70000025\n#define SHT_MIPS_WHIRL\t       0x70000026\n#define SHT_MIPS_EH_REGION     0x70000027\n#define SHT_MIPS_XLATE_OLD     0x70000028\n#define SHT_MIPS_PDR_EXCEPTION 0x70000029\n\n/* Legal values for sh_flags field of Elf32_Shdr.  */\n\n#define SHF_MIPS_GPREL\t 0x10000000\t/* Must be part of global data area */\n#define SHF_MIPS_MERGE\t 0x20000000\n#define SHF_MIPS_ADDR\t 0x40000000\n#define SHF_MIPS_STRINGS 0x80000000\n#define SHF_MIPS_NOSTRIP 0x08000000\n#define SHF_MIPS_LOCAL\t 0x04000000\n#define SHF_MIPS_NAMES\t 0x02000000\n#define SHF_MIPS_NODUPE\t 0x01000000\n\n\n/* Symbol tables.  */\n\n/* MIPS specific values for `st_other'.  */\n#define STO_MIPS_DEFAULT\t\t0x0\n#define STO_MIPS_INTERNAL\t\t0x1\n#define STO_MIPS_HIDDEN\t\t\t0x2\n#define STO_MIPS_PROTECTED\t\t0x3\n#define STO_MIPS_SC_ALIGN_UNUSED\t0xff\n\n/* MIPS specific values for `st_info'.  */\n#define STB_MIPS_SPLIT_COMMON\t\t13\n\n/* Entries found in sections of type SHT_MIPS_GPTAB.  */\n\ntypedef union\n{\n  struct\n    {\n      Elf32_Word gt_current_g_value;\t/* -G value used for compilation */\n      Elf32_Word gt_unused;\t\t/* Not used */\n    } gt_header;\t\t\t/* First entry in section */\n  struct\n    {\n      Elf32_Word gt_g_value;\t\t/* If this value were used for -G */\n      Elf32_Word gt_bytes;\t\t/* This many bytes would be used */\n    } gt_entry;\t\t\t\t/* Subsequent entries in section */\n} Elf32_gptab;\n\n/* Entry found in sections of type SHT_MIPS_REGINFO.  */\n\ntypedef struct\n{\n  Elf32_Word\tri_gprmask;\t\t/* General registers used */\n  Elf32_Word\tri_cprmask[4];\t\t/* Coprocessor registers used */\n  Elf32_Sword\tri_gp_value;\t\t/* $gp register value */\n} Elf32_RegInfo;\n\n/* Entries found in sections of type SHT_MIPS_OPTIONS.  */\n\ntypedef struct\n{\n  unsigned char kind;\t\t/* Determines interpretation of the\n\t\t\t\t   variable part of descriptor.  */\n  unsigned char size;\t\t/* Size of descriptor, including header.  */\n  Elf32_Section section;\t/* Section header index of section affected,\n\t\t\t\t   0 for global options.  */\n  Elf32_Word info;\t\t/* Kind-specific information.  */\n} Elf_Options;\n\n/* Values for `kind' field in Elf_Options.  */\n\n#define ODK_NULL\t0\t/* Undefined.  */\n#define ODK_REGINFO\t1\t/* Register usage information.  */\n#define ODK_EXCEPTIONS\t2\t/* Exception processing options.  */\n#define ODK_PAD\t\t3\t/* Section padding options.  */\n#define ODK_HWPATCH\t4\t/* Hardware workarounds performed */\n#define ODK_FILL\t5\t/* record the fill value used by the linker. */\n#define ODK_TAGS\t6\t/* reserve space for desktop tools to write. */\n#define ODK_HWAND\t7\t/* HW workarounds.  'AND' bits when merging. */\n#define ODK_HWOR\t8\t/* HW workarounds.  'OR' bits when merging.  */\n\n/* Values for `info' in Elf_Options for ODK_EXCEPTIONS entries.  */\n\n#define OEX_FPU_MIN\t0x1f\t/* FPE's which MUST be enabled.  */\n#define OEX_FPU_MAX\t0x1f00\t/* FPE's which MAY be enabled.  */\n#define OEX_PAGE0\t0x10000\t/* page zero must be mapped.  */\n#define OEX_SMM\t\t0x20000\t/* Force sequential memory mode?  */\n#define OEX_FPDBUG\t0x40000\t/* Force floating point debug mode?  */\n#define OEX_PRECISEFP\tOEX_FPDBUG\n#define OEX_DISMISS\t0x80000\t/* Dismiss invalid address faults?  */\n\n#define OEX_FPU_INVAL\t0x10\n#define OEX_FPU_DIV0\t0x08\n#define OEX_FPU_OFLO\t0x04\n#define OEX_FPU_UFLO\t0x02\n#define OEX_FPU_INEX\t0x01\n\n/* Masks for `info' in Elf_Options for an ODK_HWPATCH entry.  */\n\n#define OHW_R4KEOP\t0x1\t/* R4000 end-of-page patch.  */\n#define OHW_R8KPFETCH\t0x2\t/* may need R8000 prefetch patch.  */\n#define OHW_R5KEOP\t0x4\t/* R5000 end-of-page patch.  */\n#define OHW_R5KCVTL\t0x8\t/* R5000 cvt.[ds].l bug.  clean=1.  */\n\n#define OPAD_PREFIX\t0x1\n#define OPAD_POSTFIX\t0x2\n#define OPAD_SYMBOL\t0x4\n\n/* Entry found in `.options' section.  */\n\ntypedef struct\n{\n  Elf32_Word hwp_flags1;\t/* Extra flags.  */\n  Elf32_Word hwp_flags2;\t/* Extra flags.  */\n} Elf_Options_Hw;\n\n/* Masks for `info' in ElfOptions for ODK_HWAND and ODK_HWOR entries.  */\n\n#define OHWA0_R4KEOP_CHECKED\t0x00000001\n#define OHWA1_R4KEOP_CLEAN\t0x00000002\n\n/* MIPS relocs.  */\n\n#define R_MIPS_NONE\t\t0\t/* No reloc */\n#define R_MIPS_16\t\t1\t/* Direct 16 bit */\n#define R_MIPS_32\t\t2\t/* Direct 32 bit */\n#define R_MIPS_REL32\t\t3\t/* PC relative 32 bit */\n#define R_MIPS_26\t\t4\t/* Direct 26 bit shifted */\n#define R_MIPS_HI16\t\t5\t/* High 16 bit */\n#define R_MIPS_LO16\t\t6\t/* Low 16 bit */\n#define R_MIPS_GPREL16\t\t7\t/* GP relative 16 bit */\n#define R_MIPS_LITERAL\t\t8\t/* 16 bit literal entry */\n#define R_MIPS_GOT16\t\t9\t/* 16 bit GOT entry */\n#define R_MIPS_PC16\t\t10\t/* PC relative 16 bit */\n#define R_MIPS_CALL16\t\t11\t/* 16 bit GOT entry for function */\n#define R_MIPS_GPREL32\t\t12\t/* GP relative 32 bit */\n\n#define R_MIPS_SHIFT5\t\t16\n#define R_MIPS_SHIFT6\t\t17\n#define R_MIPS_64\t\t18\n#define R_MIPS_GOT_DISP\t\t19\n#define R_MIPS_GOT_PAGE\t\t20\n#define R_MIPS_GOT_OFST\t\t21\n#define R_MIPS_GOT_HI16\t\t22\n#define R_MIPS_GOT_LO16\t\t23\n#define R_MIPS_SUB\t\t24\n#define R_MIPS_INSERT_A\t\t25\n#define R_MIPS_INSERT_B\t\t26\n#define R_MIPS_DELETE\t\t27\n#define R_MIPS_HIGHER\t\t28\n#define R_MIPS_HIGHEST\t\t29\n#define R_MIPS_CALL_HI16\t30\n#define R_MIPS_CALL_LO16\t31\n#define R_MIPS_SCN_DISP\t\t32\n#define R_MIPS_REL16\t\t33\n#define R_MIPS_ADD_IMMEDIATE\t34\n#define R_MIPS_PJUMP\t\t35\n#define R_MIPS_RELGOT\t\t36\n#define R_MIPS_JALR\t\t37\n/* Keep this the last entry.  */\n#define R_MIPS_NUM\t\t38\n\n/* Legal values for p_type field of Elf32_Phdr.  */\n\n#define PT_MIPS_REGINFO\t0x70000000\t/* Register usage information */\n#define PT_MIPS_RTPROC  0x70000001\t/* Runtime procedure table. */\n#define PT_MIPS_OPTIONS 0x70000002\n\n/* Special program header types.  */\n\n#define PF_MIPS_LOCAL\t0x10000000\n\n/* Legal values for d_tag field of Elf32_Dyn.  */\n\n#define DT_MIPS_RLD_VERSION  0x70000001\t/* Runtime linker interface version */\n#define DT_MIPS_TIME_STAMP   0x70000002\t/* Timestamp */\n#define DT_MIPS_ICHECKSUM    0x70000003\t/* Checksum */\n#define DT_MIPS_IVERSION     0x70000004\t/* Version string (string tbl index) */\n#define DT_MIPS_FLAGS\t     0x70000005\t/* Flags */\n#define DT_MIPS_BASE_ADDRESS 0x70000006\t/* Base address */\n#define DT_MIPS_MSYM\t     0x70000007\n#define DT_MIPS_CONFLICT     0x70000008\t/* Address of CONFLICT section */\n#define DT_MIPS_LIBLIST\t     0x70000009\t/* Address of LIBLIST section */\n#define DT_MIPS_LOCAL_GOTNO  0x7000000a\t/* Number of local GOT entries */\n#define DT_MIPS_CONFLICTNO   0x7000000b\t/* Number of CONFLICT entries */\n#define DT_MIPS_LIBLISTNO    0x70000010\t/* Number of LIBLIST entries */\n#define DT_MIPS_SYMTABNO     0x70000011\t/* Number of DYNSYM entries */\n#define DT_MIPS_UNREFEXTNO   0x70000012\t/* First external DYNSYM */\n#define DT_MIPS_GOTSYM\t     0x70000013\t/* First GOT entry in DYNSYM */\n#define DT_MIPS_HIPAGENO     0x70000014\t/* Number of GOT page table entries */\n#define DT_MIPS_RLD_MAP\t     0x70000016\t/* Address of run time loader map.  */\n#define DT_MIPS_DELTA_CLASS  0x70000017\t/* Delta C++ class definition.  */\n#define DT_MIPS_DELTA_CLASS_NO    0x70000018 /* Number of entries in\n\t\t\t\t\t\tDT_MIPS_DELTA_CLASS.  */\n#define DT_MIPS_DELTA_INSTANCE    0x70000019 /* Delta C++ class instances.  */\n#define DT_MIPS_DELTA_INSTANCE_NO 0x7000001a /* Number of entries in\n\t\t\t\t\t\tDT_MIPS_DELTA_INSTANCE.  */\n#define DT_MIPS_DELTA_RELOC  0x7000001b /* Delta relocations.  */\n#define DT_MIPS_DELTA_RELOC_NO 0x7000001c /* Number of entries in\n\t\t\t\t\t     DT_MIPS_DELTA_RELOC.  */\n#define DT_MIPS_DELTA_SYM    0x7000001d /* Delta symbols that Delta\n\t\t\t\t\t   relocations refer to.  */\n#define DT_MIPS_DELTA_SYM_NO 0x7000001e /* Number of entries in\n\t\t\t\t\t   DT_MIPS_DELTA_SYM.  */\n#define DT_MIPS_DELTA_CLASSSYM 0x70000020 /* Delta symbols that hold the\n\t\t\t\t\t     class declaration.  */\n#define DT_MIPS_DELTA_CLASSSYM_NO 0x70000021 /* Number of entries in\n\t\t\t\t\t\tDT_MIPS_DELTA_CLASSSYM.  */\n#define DT_MIPS_CXX_FLAGS    0x70000022 /* Flags indicating for C++ flavor.  */\n#define DT_MIPS_PIXIE_INIT   0x70000023\n#define DT_MIPS_SYMBOL_LIB   0x70000024\n#define DT_MIPS_LOCALPAGE_GOTIDX 0x70000025\n#define DT_MIPS_LOCAL_GOTIDX 0x70000026\n#define DT_MIPS_HIDDEN_GOTIDX 0x70000027\n#define DT_MIPS_PROTECTED_GOTIDX 0x70000028\n#define DT_MIPS_OPTIONS\t     0x70000029 /* Address of .options.  */\n#define DT_MIPS_INTERFACE    0x7000002a /* Address of .interface.  */\n#define DT_MIPS_DYNSTR_ALIGN 0x7000002b\n#define DT_MIPS_INTERFACE_SIZE 0x7000002c /* Size of the .interface section. */\n#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR 0x7000002d /* Address of rld_text_rsolve\n\t\t\t\t\t\t    function stored in GOT.  */\n#define DT_MIPS_PERF_SUFFIX  0x7000002e /* Default suffix of dso to be added\n\t\t\t\t\t   by rld on dlopen() calls.  */\n#define DT_MIPS_COMPACT_SIZE 0x7000002f /* (O32)Size of compact rel section. */\n#define DT_MIPS_GP_VALUE     0x70000030 /* GP value for aux GOTs.  */\n#define DT_MIPS_AUX_DYNAMIC  0x70000031 /* Address of aux .dynamic.  */\n#define DT_MIPS_NUM\t     0x32\n\n/* Legal values for DT_MIPS_FLAGS Elf32_Dyn entry.  */\n\n#define RHF_NONE\t\t   0\t\t/* No flags */\n#define RHF_QUICKSTART\t\t   (1 << 0)\t/* Use quickstart */\n#define RHF_NOTPOT\t\t   (1 << 1)\t/* Hash size not power of 2 */\n#define RHF_NO_LIBRARY_REPLACEMENT (1 << 2)\t/* Ignore LD_LIBRARY_PATH */\n#define RHF_NO_MOVE\t\t   (1 << 3)\n#define RHF_SGI_ONLY\t\t   (1 << 4)\n#define RHF_GUARANTEE_INIT\t   (1 << 5)\n#define RHF_DELTA_C_PLUS_PLUS\t   (1 << 6)\n#define RHF_GUARANTEE_START_INIT   (1 << 7)\n#define RHF_PIXIE\t\t   (1 << 8)\n#define RHF_DEFAULT_DELAY_LOAD\t   (1 << 9)\n#define RHF_REQUICKSTART\t   (1 << 10)\n#define RHF_REQUICKSTARTED\t   (1 << 11)\n#define RHF_CORD\t\t   (1 << 12)\n#define RHF_NO_UNRES_UNDEF\t   (1 << 13)\n#define RHF_RLD_ORDER_SAFE\t   (1 << 14)\n\n/* Entries found in sections of type SHT_MIPS_LIBLIST.  */\n\ntypedef struct\n{\n  Elf32_Word l_name;\t\t/* Name (string table index) */\n  Elf32_Word l_time_stamp;\t/* Timestamp */\n  Elf32_Word l_checksum;\t/* Checksum */\n  Elf32_Word l_version;\t\t/* Interface version */\n  Elf32_Word l_flags;\t\t/* Flags */\n} Elf32_Lib;\n\ntypedef struct\n{\n  Elf64_Word l_name;\t\t/* Name (string table index) */\n  Elf64_Word l_time_stamp;\t/* Timestamp */\n  Elf64_Word l_checksum;\t/* Checksum */\n  Elf64_Word l_version;\t\t/* Interface version */\n  Elf64_Word l_flags;\t\t/* Flags */\n} Elf64_Lib;\n\n\n/* Legal values for l_flags.  */\n\n#define LL_NONE\t\t  0\n#define LL_EXACT_MATCH\t  (1 << 0)\t/* Require exact match */\n#define LL_IGNORE_INT_VER (1 << 1)\t/* Ignore interface version */\n#define LL_REQUIRE_MINOR  (1 << 2)\n#define LL_EXPORTS\t  (1 << 3)\n#define LL_DELAY_LOAD\t  (1 << 4)\n#define LL_DELTA\t  (1 << 5)\n\n/* Entries found in sections of type SHT_MIPS_CONFLICT.  */\n\ntypedef Elf32_Addr Elf32_Conflict;\n\n\n/* HPPA specific definitions.  */\n\n/* Legal values for e_flags field of Elf32_Ehdr.  */\n\n#define EF_PARISC_TRAPNL\t1\t/* Trap nil pointer dereference.  */\n#define EF_PARISC_EXT\t\t2\t/* Program uses arch. extensions.  */\n#define EF_PARISC_ARCH\t\t0xffff0000 /* Architecture version.  */\n/* Defined values are:\n\t\t\t\t0x020b\tPA-RISC 1.0 big-endian\n\t\t\t\t0x0210\tPA-RISC 1.1 big-endian\n\t\t\t\t0x028b\tPA-RISC 1.0 little-endian\n\t\t\t\t0x0290\tPA-RISC 1.1 little-endian\n*/\n\n/* Legal values for sh_type field of Elf32_Shdr.  */\n\n#define SHT_PARISC_GOT\t\t0x70000000 /* GOT for external data.  */\n#define SHT_PARISC_ARCH\t\t0x70000001 /* Architecture extensions.  */\n#define SHT_PARISC_GLOBAL\t0x70000002 /* Definition of $global$.  */\n#define SHT_PARISC_MILLI\t0x70000003 /* Millicode routines.  */\n#define SHT_PARISC_UNWIND\t0x70000004 /* Unwind information.  */\n#define SHT_PARISC_PLT\t\t0x70000005 /* Procedure linkage table.  */\n#define SHT_PARISC_SDATA\t0x70000006 /* Short initialized data.  */\n#define SHT_PARISC_SBSS\t\t0x70000007 /* Short uninitialized data.  */\n#define SHT_PARISC_SYMEXTN\t0x70000008 /* Argument/relocation info.  */\n#define SHT_PARISC_STUBS\t0x70000009 /* Linker stubs.  */\n\n/* Legal values for sh_flags field of Elf32_Shdr.  */\n\n#define SHF_PARISC_GLOBAL\t0x10000000 /* Section defines dp.  */\n#define SHF_PARISC_SHORT\t0x20000000 /* Section with short addressing. */\n\n/* Legal values for ST_TYPE subfield of st_info (symbol type).  */\n\n#define STT_PARISC_MILLICODE\t13\t/* Millicode function entry point.  */\n\n/* HPPA relocs.  */\n\n#define R_PARISC_NONE\t\t0\t/* No reloc.  */\n#define R_PARISC_DIR32\t\t1\t/* Direct 32-bit reference.  */\n#define R_PARISC_DIR21L\t\t2\t/* Left 21 bits of eff. address.  */\n#define R_PARISC_DIR17R\t\t3\t/* Right 17 bits of eff. address.  */\n#define R_PARISC_DIR14R\t\t4\t/* Right 14 bits of eff. address.  */\n#define R_PARISC_PCREL21L\t5\t/* PC-relative, left 21 bits.  */\n#define R_PARISC_PCREL14R\t6\t/* PC-relative, right 14 bits.  */\n#define R_PARISC_PCREL17C\t7\t/* Conditional PC-relative, ignore\n\t\t\t\t\t   if displacement > 17bits.  */\n#define R_PARISC_PCREL17F\t8\t/* Conditional PC-relative, must\n\t\t\t\t\t   fit in 17bits.  */\n#define R_PARISC_DPREL21L\t9\t/* DP-relative, left 21 bits.  */\n#define R_PARISC_DPREL14R\t10\t/* DP-relative, right 14 bits.  */\n#define R_PARISC_DPREL14F\t11\t/* DP-relative, must bit in 14 bits. */\n#define R_PARISC_DLTREL21L\t12\t/* DLT-relative, left 21 bits.  */\n#define R_PARISC_DLTREL14R\t13\t/* DLT-relative, right 14 bits.  */\n#define R_PARISC_DLTREL14F\t14\t/* DLT-relative, must fit in 14 bits.*/\n#define R_PARISC_DLTIND21L\t15\t/* DLT-relative indirect, left\n\t\t\t\t\t   21 bits.  */\n#define R_PARISC_DLTIND14R\t16\t/* DLT-relative indirect, right\n\t\t\t\t\t   14 bits.  */\n#define R_PARISC_DLTIND14F\t17\t/* DLT-relative indirect, must fit\n\t\t\t\t\t   int 14 bits.  */\n#define R_PARISC_PLABEL32\t18\t/* Direct 32-bit reference to proc.  */\n\n/* Alpha specific definitions.  */\n\n/* Legal values for e_flags field of Elf64_Ehdr.  */\n\n#define EF_ALPHA_32BIT\t\t1\t/* All addresses must be < 2GB.  */\n#define EF_ALPHA_CANRELAX\t2\t/* Relocations for relaxing exist.  */\n\n/* Legal values for sh_type field of Elf64_Shdr.  */\n\n/* These two are primerily concerned with ECOFF debugging info.  */\n#define SHT_ALPHA_DEBUG\t\t0x70000001\n#define SHT_ALPHA_REGINFO\t0x70000002\n\n/* Legal values for sh_flags field of Elf64_Shdr.  */\n\n#define SHF_ALPHA_GPREL\t\t0x10000000\n\n/* Legal values for st_other field of Elf64_Sym.  */\n#define STO_ALPHA_NOPV\t\t0x80\t/* No PV required.  */\n#define STO_ALPHA_STD_GPLOAD\t0x88\t/* PV only used for initial ldgp.  */\n\n/* Alpha relocs.  */\n\n#define R_ALPHA_NONE\t\t0\t/* No reloc */\n#define R_ALPHA_REFLONG\t\t1\t/* Direct 32 bit */\n#define R_ALPHA_REFQUAD\t\t2\t/* Direct 64 bit */\n#define R_ALPHA_GPREL32\t\t3\t/* GP relative 32 bit */\n#define R_ALPHA_LITERAL\t\t4\t/* GP relative 16 bit w/optimization */\n#define R_ALPHA_LITUSE\t\t5\t/* Optimization hint for LITERAL */\n#define R_ALPHA_GPDISP\t\t6\t/* Add displacement to GP */\n#define R_ALPHA_BRADDR\t\t7\t/* PC+4 relative 23 bit shifted */\n#define R_ALPHA_HINT\t\t8\t/* PC+4 relative 16 bit shifted */\n#define R_ALPHA_SREL16\t\t9\t/* PC relative 16 bit */\n#define R_ALPHA_SREL32\t\t10\t/* PC relative 32 bit */\n#define R_ALPHA_SREL64\t\t11\t/* PC relative 64 bit */\n#define R_ALPHA_OP_PUSH\t\t12\t/* OP stack push */\n#define R_ALPHA_OP_STORE\t13\t/* OP stack pop and store */\n#define R_ALPHA_OP_PSUB\t\t14\t/* OP stack subtract */\n#define R_ALPHA_OP_PRSHIFT\t15\t/* OP stack right shift */\n#define R_ALPHA_GPVALUE\t\t16\n#define R_ALPHA_GPRELHIGH\t17\n#define R_ALPHA_GPRELLOW\t18\n#define R_ALPHA_IMMED_GP_16\t19\n#define R_ALPHA_IMMED_GP_HI32\t20\n#define R_ALPHA_IMMED_SCN_HI32\t21\n#define R_ALPHA_IMMED_BR_HI32\t22\n#define R_ALPHA_IMMED_LO32\t23\n#define R_ALPHA_COPY\t\t24\t/* Copy symbol at runtime */\n#define R_ALPHA_GLOB_DAT\t25\t/* Create GOT entry */\n#define R_ALPHA_JMP_SLOT\t26\t/* Create PLT entry */\n#define R_ALPHA_RELATIVE\t27\t/* Adjust by program base */\n/* Keep this the last entry.  */\n#define R_ALPHA_NUM\t\t28\n\n\n/* PowerPC specific declarations */\n\n/* PowerPC relocations defined by the ABIs */\n#define R_PPC_NONE\t\t0\n#define R_PPC_ADDR32\t\t1\t/* 32bit absolute address */\n#define R_PPC_ADDR24\t\t2\t/* 26bit address, 2 bits ignored.  */\n#define R_PPC_ADDR16\t\t3\t/* 16bit absolute address */\n#define R_PPC_ADDR16_LO\t\t4\t/* lower 16bit of absolute address */\n#define R_PPC_ADDR16_HI\t\t5\t/* high 16bit of absolute address */\n#define R_PPC_ADDR16_HA\t\t6\t/* adjusted high 16bit */\n#define R_PPC_ADDR14\t\t7\t/* 16bit address, 2 bits ignored */\n#define R_PPC_ADDR14_BRTAKEN\t8\n#define R_PPC_ADDR14_BRNTAKEN\t9\n#define R_PPC_REL24\t\t10\t/* PC relative 26 bit */\n#define R_PPC_REL14\t\t11\t/* PC relative 16 bit */\n#define R_PPC_REL14_BRTAKEN\t12\n#define R_PPC_REL14_BRNTAKEN\t13\n#define R_PPC_GOT16\t\t14\n#define R_PPC_GOT16_LO\t\t15\n#define R_PPC_GOT16_HI\t\t16\n#define R_PPC_GOT16_HA\t\t17\n#define R_PPC_PLTREL24\t\t18\n#define R_PPC_COPY\t\t19\n#define R_PPC_GLOB_DAT\t\t20\n#define R_PPC_JMP_SLOT\t\t21\n#define R_PPC_RELATIVE\t\t22\n#define R_PPC_LOCAL24PC\t\t23\n#define R_PPC_UADDR32\t\t24\n#define R_PPC_UADDR16\t\t25\n#define R_PPC_REL32\t\t26\n#define R_PPC_PLT32\t\t27\n#define R_PPC_PLTREL32\t\t28\n#define R_PPC_PLT16_LO\t\t29\n#define R_PPC_PLT16_HI\t\t30\n#define R_PPC_PLT16_HA\t\t31\n#define R_PPC_SDAREL16\t\t32\n#define R_PPC_SECTOFF\t\t33\n#define R_PPC_SECTOFF_LO\t34\n#define R_PPC_SECTOFF_HI\t35\n#define R_PPC_SECTOFF_HA\t36\n/* Keep this the last entry.  */\n#define R_PPC_NUMm\t\t37\n\n/* The remaining relocs are from the Embedded ELF ABI, and are not\n   in the SVR4 ELF ABI.  */\n#define R_PPC_EMB_NADDR32\t101\n#define R_PPC_EMB_NADDR16\t102\n#define R_PPC_EMB_NADDR16_LO\t103\n#define R_PPC_EMB_NADDR16_HI\t104\n#define R_PPC_EMB_NADDR16_HA\t105\n#define R_PPC_EMB_SDAI16\t106\n#define R_PPC_EMB_SDA2I16\t107\n#define R_PPC_EMB_SDA2REL\t108\n#define R_PPC_EMB_SDA21\t\t109\t/* 16 bit offset in SDA */\n#define R_PPC_EMB_MRKREF\t110\n#define R_PPC_EMB_RELSEC16\t111\n#define R_PPC_EMB_RELST_LO\t112\n#define R_PPC_EMB_RELST_HI\t113\n#define R_PPC_EMB_RELST_HA\t114\n#define R_PPC_EMB_BIT_FLD\t115\n#define R_PPC_EMB_RELSDA\t116\t/* 16 bit relative offset in SDA */\n\n/* Diab tool relocations.  */\n#define R_PPC_DIAB_SDA21_LO\t180\t/* like EMB_SDA21, but lower 16 bit */\n#define R_PPC_DIAB_SDA21_HI\t181\t/* like EMB_SDA21, but high 16 bit */\n#define R_PPC_DIAB_SDA21_HA\t182\t/* like EMB_SDA21, adjusted high 16 */\n#define R_PPC_DIAB_RELSDA_LO\t183\t/* like EMB_RELSDA, but lower 16 bit */\n#define R_PPC_DIAB_RELSDA_HI\t184\t/* like EMB_RELSDA, but high 16 bit */\n#define R_PPC_DIAB_RELSDA_HA\t185\t/* like EMB_RELSDA, adjusted high 16 */\n\n/* This is a phony reloc to handle any old fashioned TOC16 references\n   that may still be in object files.  */\n#define R_PPC_TOC16\t\t255\n\n\n/* ARM specific declarations */\n\n/* Processor specific flags for the ELF header e_flags field.  */\n#define EF_ARM_RELEXEC     0x01\n#define EF_ARM_HASENTRY    0x02\n#define EF_ARM_INTERWORK   0x04\n#define EF_ARM_APCS_26     0x08\n#define EF_ARM_APCS_FLOAT  0x10\n#define EF_ARM_PIC         0x20\n#define EF_ALIGN8          0x40\t\t/* 8-bit structure alignment is in use */\n#define EF_NEW_ABI         0x80\n#define EF_OLD_ABI         0x100\n\n/* Additional symbol types for Thumb */\n#define STT_ARM_TFUNC      0xd\n\n/* ARM-specific values for sh_flags */\n#define SHF_ARM_ENTRYSECT  0x10000000   /* Section contains an entry point */\n#define SHF_ARM_COMDEF     0x80000000   /* Section may be multiply defined\n\t\t\t\t\t   in the input to a link step */\n\n/* ARM-specific program header flags */\n#define PF_ARM_SB          0x10000000   /* Segment contains the location\n\t\t\t\t\t   addressed by the static base */\n\n/* ARM relocs.  */\n#define R_ARM_NONE\t\t0\t/* No reloc */\n#define R_ARM_PC24\t\t1\t/* PC relative 26 bit branch */\n#define R_ARM_ABS32\t\t2\t/* Direct 32 bit  */\n#define R_ARM_REL32\t\t3\t/* PC relative 32 bit */\n#define R_ARM_PC13\t\t4\n#define R_ARM_ABS16\t\t5\t/* Direct 16 bit */\n#define R_ARM_ABS12\t\t6\t/* Direct 12 bit */\n#define R_ARM_THM_ABS5\t\t7\n#define R_ARM_ABS8\t\t8\t/* Direct 8 bit */\n#define R_ARM_SBREL32\t\t9\n#define R_ARM_THM_PC22\t\t10\n#define R_ARM_THM_PC8\t\t11\n#define R_ARM_AMP_VCALL9\t12\n#define R_ARM_SWI24\t\t13\n#define R_ARM_THM_SWI8\t\t14\n#define R_ARM_XPC25\t\t15\n#define R_ARM_THM_XPC22\t\t16\n#define R_ARM_COPY\t\t20\t/* Copy symbol at runtime */\n#define R_ARM_GLOB_DAT\t\t21\t/* Create GOT entry */\n#define R_ARM_JUMP_SLOT\t\t22\t/* Create PLT entry */\n#define R_ARM_RELATIVE\t\t23\t/* Adjust by program base */\n#define R_ARM_GOTOFF\t\t24\t/* 32 bit offset to GOT */\n#define R_ARM_GOTPC\t\t25\t/* 32 bit PC relative offset to GOT */\n#define R_ARM_GOT32\t\t26\t/* 32 bit GOT entry */\n#define R_ARM_PLT32\t\t27\t/* 32 bit PLT address */\n#define R_ARM_GNU_VTENTRY\t100\n#define R_ARM_GNU_VTINHERIT\t101\n#define R_ARM_THM_PC11\t\t102\t/* thumb unconditional branch */\n#define R_ARM_THM_PC9\t\t103\t/* thumb conditional branch */\n#define R_ARM_RXPC25\t\t249\n#define R_ARM_RSBREL32\t\t250\n#define R_ARM_THM_RPC22\t\t251\n#define R_ARM_RREL32\t\t252\n#define R_ARM_RABS22\t\t253\n#define R_ARM_RPC24\t\t254\n#define R_ARM_RBASE\t\t255\n/* Keep this the last entry.  */\n#define R_ARM_NUM\t\t256\n\n/* TMS320C67xx specific declarations */\n/* XXX: no ELF standard yet */\n\n/* TMS320C67xx relocs. */\n#define R_C60_32       1\n#define R_C60_GOT32\t3\t\t/* 32 bit GOT entry */\n#define R_C60_PLT32\t4\t\t/* 32 bit PLT address */\n#define R_C60_COPY\t5\t\t/* Copy symbol at runtime */\n#define R_C60_GLOB_DAT\t6\t\t/* Create GOT entry */\n#define R_C60_JMP_SLOT\t7\t\t/* Create PLT entry */\n#define R_C60_RELATIVE\t8\t\t/* Adjust by program base */\n#define R_C60_GOTOFF\t9\t\t/* 32 bit offset to GOT */\n#define R_C60_GOTPC\t10\t\t/* 32 bit PC relative offset to GOT */\n\n#define R_C60HI16      0x55       // high 16 bit MVKH embedded\n#define R_C60LO16      0x54       // low 16 bit MVKL embedded\n\n#endif\t/* elf.h */\n//---------------------------------------------------------------------------\n\n\n// njn: inlined stab.h\n//#include \"stab.h\"\n//---------------------------------------------------------------------------\n#ifndef __GNU_STAB__\n\n/* Indicate the GNU stab.h is in use.  */\n\n#define __GNU_STAB__\n\n#define __define_stab(NAME, CODE, STRING) NAME=CODE,\n\nenum __stab_debug_code\n{\n// njn: inlined stab.def\n//#include \"stab.def\"\n//---------------------------------------------------------------------------\n/* Table of DBX symbol codes for the GNU system.\n   Copyright (C) 1988, 1997 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* This contains contribution from Cygnus Support.  */\n\f\n/* Global variable.  Only the name is significant.\n   To find the address, look in the corresponding external symbol.  */\n__define_stab (N_GSYM, 0x20, \"GSYM\")\n\n/* Function name for BSD Fortran.  Only the name is significant.\n   To find the address, look in the corresponding external symbol.  */\n__define_stab (N_FNAME, 0x22, \"FNAME\")\n\n/* Function name or text-segment variable for C.  Value is its address.\n   Desc is supposedly starting line number, but GCC doesn't set it\n   and DBX seems not to miss it.  */\n__define_stab (N_FUN, 0x24, \"FUN\")\n\n/* Data-segment variable with internal linkage.  Value is its address.\n   \"Static Sym\".  */\n__define_stab (N_STSYM, 0x26, \"STSYM\")\n\n/* BSS-segment variable with internal linkage.  Value is its address.  */\n__define_stab (N_LCSYM, 0x28, \"LCSYM\")\n\n/* Name of main routine.  Only the name is significant.\n   This is not used in C.  */\n__define_stab (N_MAIN, 0x2a, \"MAIN\")\n\n/* Global symbol in Pascal.\n   Supposedly the value is its line number; I'm skeptical.  */\n__define_stab (N_PC, 0x30, \"PC\")\n\n/* Number of symbols:  0, files,,funcs,lines according to Ultrix V4.0. */\n__define_stab (N_NSYMS, 0x32, \"NSYMS\")\n\n/* \"No DST map for sym: name, ,0,type,ignored\"  according to Ultrix V4.0. */\n__define_stab (N_NOMAP, 0x34, \"NOMAP\")\n\n/* New stab from Solaris.  I don't know what it means, but it\n   don't seem to contain useful information.  */\n__define_stab (N_OBJ, 0x38, \"OBJ\")\n\n/* New stab from Solaris.  I don't know what it means, but it\n   don't seem to contain useful information.  Possibly related to the\n   optimization flags used in this module.  */\n__define_stab (N_OPT, 0x3c, \"OPT\")\n\n/* Register variable.  Value is number of register.  */\n__define_stab (N_RSYM, 0x40, \"RSYM\")\n\n/* Modula-2 compilation unit.  Can someone say what info it contains?  */\n__define_stab (N_M2C, 0x42, \"M2C\")\n\n/* Line number in text segment.  Desc is the line number;\n   value is corresponding address.  */\n__define_stab (N_SLINE, 0x44, \"SLINE\")\n\n/* Similar, for data segment.  */\n__define_stab (N_DSLINE, 0x46, \"DSLINE\")\n\n/* Similar, for bss segment.  */\n__define_stab (N_BSLINE, 0x48, \"BSLINE\")\n\n/* Sun's source-code browser stabs.  ?? Don't know what the fields are.\n   Supposedly the field is \"path to associated .cb file\".  THIS VALUE\n   OVERLAPS WITH N_BSLINE!  */\n__define_stab (N_BROWS, 0x48, \"BROWS\")\n\n/* GNU Modula-2 definition module dependency.  Value is the modification time\n   of the definition file.  Other is non-zero if it is imported with the\n   GNU M2 keyword %INITIALIZE.  Perhaps N_M2C can be used if there\n   are enough empty fields? */\n__define_stab(N_DEFD, 0x4a, \"DEFD\")\n\n/* THE FOLLOWING TWO STAB VALUES CONFLICT.  Happily, one is for Modula-2\n   and one is for C++.   Still,... */\n/* GNU C++ exception variable.  Name is variable name.  */\n__define_stab (N_EHDECL, 0x50, \"EHDECL\")\n/* Modula2 info \"for imc\":  name,,0,0,0  according to Ultrix V4.0.  */\n__define_stab (N_MOD2, 0x50, \"MOD2\")\n\n/* GNU C++ `catch' clause.  Value is its address.  Desc is nonzero if\n   this entry is immediately followed by a CAUGHT stab saying what exception\n   was caught.  Multiple CAUGHT stabs means that multiple exceptions\n   can be caught here.  If Desc is 0, it means all exceptions are caught\n   here.  */\n__define_stab (N_CATCH, 0x54, \"CATCH\")\n\n/* Structure or union element.  Value is offset in the structure.  */\n__define_stab (N_SSYM, 0x60, \"SSYM\")\n\n/* Name of main source file.\n   Value is starting text address of the compilation.  */\n__define_stab (N_SO, 0x64, \"SO\")\n\n/* Automatic variable in the stack.  Value is offset from frame pointer.\n   Also used for type descriptions.  */\n__define_stab (N_LSYM, 0x80, \"LSYM\")\n\n/* Beginning of an include file.  Only Sun uses this.\n   In an object file, only the name is significant.\n   The Sun linker puts data into some of the other fields.  */\n__define_stab (N_BINCL, 0x82, \"BINCL\")\n\n/* Name of sub-source file (#include file).\n   Value is starting text address of the compilation.  */\n__define_stab (N_SOL, 0x84, \"SOL\")\n\n/* Parameter variable.  Value is offset from argument pointer.\n   (On most machines the argument pointer is the same as the frame pointer.  */\n__define_stab (N_PSYM, 0xa0, \"PSYM\")\n\n/* End of an include file.  No name.\n   This and N_BINCL act as brackets around the file's output.\n   In an object file, there is no significant data in this entry.\n   The Sun linker puts data into some of the fields.  */\n__define_stab (N_EINCL, 0xa2, \"EINCL\")\n\n/* Alternate entry point.  Value is its address.  */\n__define_stab (N_ENTRY, 0xa4, \"ENTRY\")\n\n/* Beginning of lexical block.\n   The desc is the nesting level in lexical blocks.\n   The value is the address of the start of the text for the block.\n   The variables declared inside the block *precede* the N_LBRAC symbol.  */\n__define_stab (N_LBRAC, 0xc0, \"LBRAC\")\n\n/* Place holder for deleted include file.  Replaces a N_BINCL and everything\n   up to the corresponding N_EINCL.  The Sun linker generates these when\n   it finds multiple identical copies of the symbols from an include file.\n   This appears only in output from the Sun linker.  */\n__define_stab (N_EXCL, 0xc2, \"EXCL\")\n\n/* Modula-2 scope information.  Can someone say what info it contains?  */\n__define_stab (N_SCOPE, 0xc4, \"SCOPE\")\n\n/* End of a lexical block.  Desc matches the N_LBRAC's desc.\n   The value is the address of the end of the text for the block.  */\n__define_stab (N_RBRAC, 0xe0, \"RBRAC\")\n\n/* Begin named common block.  Only the name is significant.  */\n__define_stab (N_BCOMM, 0xe2, \"BCOMM\")\n\n/* End named common block.  Only the name is significant\n   (and it should match the N_BCOMM).  */\n__define_stab (N_ECOMM, 0xe4, \"ECOMM\")\n\n/* End common (local name): value is address.\n   I'm not sure how this is used.  */\n__define_stab (N_ECOML, 0xe8, \"ECOML\")\n\n/* These STAB's are used on Gould systems for Non-Base register symbols\n   or something like that.  FIXME.  I have assigned the values at random\n   since I don't have a Gould here.  Fixups from Gould folk welcome... */\n__define_stab (N_NBTEXT, 0xF0, \"NBTEXT\")\n__define_stab (N_NBDATA, 0xF2, \"NBDATA\")\n__define_stab (N_NBBSS,  0xF4, \"NBBSS\")\n__define_stab (N_NBSTS,  0xF6, \"NBSTS\")\n__define_stab (N_NBLCS,  0xF8, \"NBLCS\")\n\n/* Second symbol entry containing a length-value for the preceding entry.\n   The value is the length.  */\n__define_stab (N_LENG, 0xfe, \"LENG\")\n\f\n/* The above information, in matrix format.\n\n\t\t\tSTAB MATRIX\n\t_________________________________________________\n\t| 00 - 1F are not dbx stab symbols\t\t|\n\t| In most cases, the low bit is the EXTernal bit|\n\n\t| 00 UNDEF  | 02 ABS\t| 04 TEXT   | 06 DATA\t|\n\t| 01  |EXT  | 03  |EXT\t| 05  |EXT  | 07  |EXT\t|\n\n\t| 08 BSS    | 0A INDR\t| 0C FN_SEQ | 0E   \t|\n\t| 09  |EXT  | 0B \t| 0D\t    | 0F\t|\n\n\t| 10 \t    | 12 COMM\t| 14 SETA   | 16 SETT\t|\n\t| 11\t    | 13\t| 15 \t    | 17\t|\n\n\t| 18 SETD   | 1A SETB\t| 1C SETV   | 1E WARNING|\n\t| 19\t    | 1B\t| 1D \t    | 1F FN\t|\n\n\t|_______________________________________________|\n\t| Debug entries with bit 01 set are unused.\t|\n\t| 20 GSYM   | 22 FNAME\t| 24 FUN    | 26 STSYM\t|\n\t| 28 LCSYM  | 2A MAIN\t| 2C\t    | 2E\t|\n\t| 30 PC\t    | 32 NSYMS\t| 34 NOMAP  | 36\t|\n\t| 38 OBJ    | 3A\t| 3C OPT    | 3E\t|\n\t| 40 RSYM   | 42 M2C\t| 44 SLINE  | 46 DSLINE |\n\t| 48 BSLINE*| 4A DEFD\t| 4C        | 4E\t|\n\t| 50 EHDECL*| 52\t| 54 CATCH  | 56        |\n\t| 58        | 5A        | 5C        | 5E\t|\n\t| 60 SSYM   | 62\t| 64 SO\t    | 66 \t|\n\t| 68 \t    | 6A\t| 6C\t    | 6E\t|\n\t| 70\t    | 72\t| 74\t    | 76\t|\n\t| 78\t    | 7A\t| 7C\t    | 7E\t|\n\t| 80 LSYM   | 82 BINCL\t| 84 SOL    | 86\t|\n\t| 88\t    | 8A\t| 8C\t    | 8E\t|\n\t| 90\t    | 92\t| 94\t    | 96\t|\n\t| 98\t    | 9A\t| 9C\t    | 9E\t|\n\t| A0 PSYM   | A2 EINCL\t| A4 ENTRY  | A6\t|\n\t| A8\t    | AA\t| AC\t    | AE\t|\n\t| B0\t    | B2\t| B4\t    | B6\t|\n\t| B8\t    | BA\t| BC\t    | BE\t|\n\t| C0 LBRAC  | C2 EXCL\t| C4 SCOPE  | C6\t|\n\t| C8\t    | CA\t| CC\t    | CE\t|\n\t| D0\t    | D2\t| D4\t    | D6\t|\n\t| D8\t    | DA\t| DC\t    | DE\t|\n\t| E0 RBRAC  | E2 BCOMM\t| E4 ECOMM  | E6\t|\n\t| E8 ECOML  | EA\t| EC\t    | EE\t|\n\t| F0\t    | F2\t| F4\t    | F6\t|\n\t| F8\t    | FA\t| FC\t    | FE LENG\t|\n\t+-----------------------------------------------+\n * 50 EHDECL is also MOD2.\n * 48 BSLINE is also BROWS.\n */\n//---------------------------------------------------------------------------\nLAST_UNUSED_STAB_CODE\n};\n\n#undef __define_stab\n\n#endif /* __GNU_STAB_ */\n//---------------------------------------------------------------------------\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\n// njn: inlined libtcc.h\n//#include \"libtcc.h\"\n//---------------------------------------------------------------------------\n#ifndef LIBTCC_H\n#define LIBTCC_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct TCCState;\n\ntypedef struct TCCState TCCState;\n\n/* create a new TCC compilation context */\nTCCState *tcc_new(void);\n\n/* free a TCC compilation context */\nvoid tcc_delete(TCCState *s);\n\n/* add debug information in the generated code */\nvoid tcc_enable_debug(TCCState *s);\n\n/* set error/warning display callback */\nvoid tcc_set_error_func(TCCState *s, void *error_opaque,\n                        void (*error_func)(void *opaque, const char *msg));\n\n/* set/reset a warning */\nint tcc_set_warning(TCCState *s, const char *warning_name, int value);\n\n/*****************************/\n/* preprocessor */\n\n/* add include path */\nint tcc_add_include_path(TCCState *s, const char *pathname);\n\n/* add in system include path */\nint tcc_add_sysinclude_path(TCCState *s, const char *pathname);\n\n/* define preprocessor symbol 'sym'. Can put optional value */\nvoid tcc_define_symbol(TCCState *s, const char *sym, const char *value);\n\n/* undefine preprocess symbol 'sym' */\nvoid tcc_undefine_symbol(TCCState *s, const char *sym);\n\n/*****************************/\n/* compiling */\n\n/* add a file (either a C file, dll, an object, a library or an ld\n   script). Return -1 if error. */\nint tcc_add_file(TCCState *s, const char *filename);\n\n/* compile a string containing a C source. Return non zero if\n   error. */\nint tcc_compile_string(TCCState *s, const char *buf);\n\n/*****************************/\n/* linking commands */\n\n/* set output type. MUST BE CALLED before any compilation */\n#define TCC_OUTPUT_MEMORY   0 /* output will be ran in memory (no\n                                 output file) (default) */\n#define TCC_OUTPUT_EXE      1 /* executable file */\n#define TCC_OUTPUT_DLL      2 /* dynamic library */\n#define TCC_OUTPUT_OBJ      3 /* object file */\nint tcc_set_output_type(TCCState *s, int output_type);\n\n#define TCC_OUTPUT_FORMAT_ELF    0 /* default output format: ELF */\n#define TCC_OUTPUT_FORMAT_BINARY 1 /* binary image output */\n#define TCC_OUTPUT_FORMAT_COFF   2 /* COFF */\n\n/* equivalent to -Lpath option */\nint tcc_add_library_path(TCCState *s, const char *pathname);\n\n/* the library name is the same as the argument of the '-l' option */\nint tcc_add_library(TCCState *s, const char *libraryname);\n\n/* add a symbol to the compiled program */\nint tcc_add_symbol(TCCState *s, const char *name, unsigned long val);\n\n/* output an executable, library or object file. DO NOT call\n   tcc_relocate() before. */\nint tcc_output_file(TCCState *s, const char *filename);\n\n/* link and run main() function and return its value. DO NOT call\n   tcc_relocate() before. */\nint tcc_run(TCCState *s, int argc, char **argv);\n\n/* do all relocations (needed before using tcc_get_symbol()). Return\n   non zero if link error. */\nint tcc_relocate(TCCState *s);\n\n/* return symbol value. return 0 if OK, -1 if symbol not found */\nint tcc_get_symbol(TCCState *s, unsigned long *pval, const char *name);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n//---------------------------------------------------------------------------\n\n/* parser debug */\n//#define PARSE_DEBUG\n/* preprocessor debug */\n//#define PP_DEBUG\n/* include file debug */\n//#define INC_DEBUG\n\n//#define MEM_DEBUG\n\n/* assembler debug */\n//#define ASM_DEBUG\n\n/* target selection */\n//#define TCC_TARGET_I386   /* i386 code generator */\n//#define TCC_TARGET_ARM    /* ARMv4 code generator */\n//#define TCC_TARGET_C67    /* TMS320C67xx code generator */\n\n/* default target is I386 */\n#if !defined(TCC_TARGET_I386) && !defined(TCC_TARGET_ARM) && \\\n    !defined(TCC_TARGET_C67)\n#define TCC_TARGET_I386\n#endif\n\n#if !defined(WIN32) && !defined(TCC_UCLIBC) && !defined(TCC_TARGET_ARM) && \\\n    !defined(TCC_TARGET_C67)\n#define CONFIG_TCC_BCHECK /* enable bound checking code */\n#endif\n\n#if defined(WIN32) && !defined(TCC_TARGET_PE)\n#define CONFIG_TCC_STATIC\n#endif\n\n/* define it to include assembler support */\n#if !defined(TCC_TARGET_ARM) && !defined(TCC_TARGET_C67)\n#define CONFIG_TCC_ASM\n#endif\n\n/* object format selection */\n#if defined(TCC_TARGET_C67)\n#define TCC_TARGET_COFF\n#endif\n\n#define FALSE 0\n#define false 0\n#define TRUE 1\n#define true 1\ntypedef int BOOL;\n\n/* path to find crt1.o, crti.o and crtn.o. Only needed when generating\n   executables or dlls */\n#define CONFIG_TCC_CRT_PREFIX \"/usr/lib\"\n\n#define INCLUDE_STACK_SIZE  32\n#define IFDEF_STACK_SIZE    64\n#define VSTACK_SIZE         256\n#define STRING_MAX_SIZE     1024\n#define PACK_STACK_SIZE     8\n\n#define TOK_HASH_SIZE       8192 /* must be a power of two */\n#define TOK_ALLOC_INCR      512  /* must be a power of two */\n#define TOK_MAX_SIZE        4 /* token max size in int unit when stored in string */\n\n/* token symbol management */\ntypedef struct TokenSym {\n    struct TokenSym *hash_next;\n    struct Sym *sym_define; /* direct pointer to define */\n    struct Sym *sym_label; /* direct pointer to label */\n    struct Sym *sym_struct; /* direct pointer to structure */\n    struct Sym *sym_identifier; /* direct pointer to identifier */\n    int tok; /* token number */\n    int len;\n    char str[1];\n} TokenSym;\n\ntypedef struct CString {\n    int size; /* size in bytes */\n    void *data; /* either 'char *' or 'int *' */\n    int size_allocated;\n    void *data_allocated; /* if non NULL, data has been malloced */\n} CString;\n\n/* type definition */\ntypedef struct CType {\n    int t;\n    struct Sym *ref;\n} CType;\n\n/* constant value */\ntypedef union CValue {\n    long double ld;\n    double d;\n    float f;\n    int i;\n    unsigned int ui;\n    unsigned int ul; /* address (should be unsigned long on 64 bit cpu) */\n    long long ll;\n    unsigned long long ull;\n    struct CString *cstr;\n    void *ptr;\n    int tab[sizeof(long double) / sizeof(int)];\n} CValue;\n\n/* value on stack */\ntypedef struct SValue {\n    CType type;      /* type */\n    unsigned short r;      /* register + flags */\n    unsigned short r2;     /* second register, used for 'long long'\n                              type. If not used, set to VT_CONST */\n    CValue c;              /* constant, if VT_CONST */\n    struct Sym *sym;       /* symbol, if (VT_SYM | VT_CONST) */\n} SValue;\n\n/* symbol management */\ntypedef struct Sym {\n    long v;    /* symbol token */\n    long r;    /* associated register */\n    long c;    /* associated number */\n    CType type;    /* associated type */\n    struct Sym *next; /* next related symbol */\n    struct Sym *prev; /* prev symbol in stack */\n    struct Sym *prev_tok; /* previous symbol for this token */\n} Sym;\n\n/* section definition */\n/* XXX: use directly ELF structure for parameters ? */\n/* special flag to indicate that the section should not be linked to\n   the other ones */\n#define SHF_PRIVATE 0x80000000\n\ntypedef struct Section {\n    unsigned long data_offset; /* current data offset */\n    unsigned char *data;       /* section data */\n    unsigned long data_allocated; /* used for realloc() handling */\n    int sh_name;             /* elf section name (only used during output) */\n    int sh_num;              /* elf section number */\n    int sh_type;             /* elf section type */\n    int sh_flags;            /* elf section flags */\n    int sh_info;             /* elf section info */\n    int sh_addralign;        /* elf section alignment */\n    int sh_entsize;          /* elf entry size */\n    unsigned long sh_size;   /* section size (only used during output) */\n    unsigned long sh_addr;      /* address at which the section is relocated */\n    unsigned long sh_offset;      /* address at which the section is relocated */\n    int nb_hashed_syms;      /* used to resize the hash table */\n    struct Section *link;    /* link to another section */\n    struct Section *reloc;   /* corresponding section for relocation, if any */\n    struct Section *hash;     /* hash table for symbols */\n    struct Section *next;\n    char name[1];           /* section name */\n} Section;\n\ntypedef struct DLLReference {\n    int level;\n    char name[1];\n} DLLReference;\n\n/* GNUC attribute definition */\ntypedef struct AttributeDef {\n    int aligned;\n    int packed; \n    Section *section;\n    unsigned char func_call; /* FUNC_CDECL, FUNC_STDCALL, FUNC_FASTCALLx */\n    unsigned char dllexport; \n} AttributeDef;\n\n#define SYM_STRUCT     0x40000000 /* struct/union/enum symbol space */\n#define SYM_FIELD      0x20000000 /* struct/union field symbol space */\n#define SYM_FIRST_ANOM 0x10000000 /* first anonymous sym */\n\n/* stored in 'Sym.c' field */\n#define FUNC_NEW       1 /* ansi function prototype */\n#define FUNC_OLD       2 /* old function prototype */\n#define FUNC_ELLIPSIS  3 /* ansi function prototype with ... */\n\n/* stored in 'Sym.r' field */\n#define FUNC_CDECL     0 /* standard c call */\n#define FUNC_STDCALL   1 /* pascal c call */\n#define FUNC_FASTCALL1 2 /* first param in %eax */\n#define FUNC_FASTCALL2 3 /* first parameters in %eax, %edx */\n#define FUNC_FASTCALL3 4 /* first parameter in %eax, %edx, %ecx */\n\n/* field 'Sym.t' for macros */\n#define MACRO_OBJ      0 /* object like macro */\n#define MACRO_FUNC     1 /* function like macro */\n\n/* field 'Sym.r' for C labels */\n#define LABEL_DEFINED  0 /* label is defined */\n#define LABEL_FORWARD  1 /* label is forward defined */\n#define LABEL_DECLARED 2 /* label is declared but never used */\n\n/* type_decl() types */\n#define TYPE_ABSTRACT  1 /* type without variable */\n#define TYPE_DIRECT    2 /* type with variable */\n\n#define IO_BUF_SIZE 8192\n\ntypedef struct BufferedFile {\n    uint8_t *buf_ptr;\n    uint8_t *buf_end;\n    int fd;\n    int line_num;    /* current line number - here to simplify code */\n    int ifndef_macro;  /* #ifndef macro / #endif search */\n    int ifndef_macro_saved; /* saved ifndef_macro */\n    int *ifdef_stack_ptr; /* ifdef_stack value at the start of the file */\n    char inc_type;          /* type of include */\n    char inc_filename[512]; /* filename specified by the user */\n    char filename[1024];    /* current filename - here to simplify code */\n    unsigned char buffer[IO_BUF_SIZE + 1]; /* extra size for CH_EOB char */\n} BufferedFile;\n\n#define CH_EOB   '\\\\'       /* end of buffer or '\\0' char in file */\n#define CH_EOF   (-1)   /* end of file */\n\n/* parsing state (used to save parser state to reparse part of the\n   source several times) */\ntypedef struct ParseState {\n    int *macro_ptr;\n    int line_num;\n    int tok;\n    CValue tokc;\n} ParseState;\n\n/* used to record tokens */\ntypedef struct TokenString {\n    int *str;\n    int len;\n    int allocated_len;\n    int last_line_num;\n} TokenString;\n\n/* include file cache, used to find files faster and also to eliminate\n   inclusion if the include file is protected by #ifndef ... #endif */\ntypedef struct CachedInclude {\n    int ifndef_macro;\n    int hash_next; /* -1 if none */\n    char type; /* '\"' or '>' to give include type */\n    char filename[1]; /* path specified in #include */\n} CachedInclude;\n\n#define CACHED_INCLUDES_HASH_SIZE 512\n\n/* parser */\nstatic struct BufferedFile *file;\nstatic int ch, tok;\nstatic CValue tokc;\nstatic CString tokcstr; /* current parsed string, if any */\n/* additional information about token */\nstatic int tok_flags;\n#define TOK_FLAG_BOL   0x0001 /* beginning of line before */\n#define TOK_FLAG_BOF   0x0002 /* beginning of file before */\n#define TOK_FLAG_ENDIF 0x0004 /* a endif was found matching starting #ifdef */\n\nstatic int *macro_ptr, *macro_ptr_allocated;\nstatic int *unget_saved_macro_ptr;\nstatic int unget_saved_buffer[TOK_MAX_SIZE + 1];\nstatic int unget_buffer_enabled;\nstatic int parse_flags;\n#define PARSE_FLAG_PREPROCESS 0x0001 /* activate preprocessing */\n#define PARSE_FLAG_TOK_NUM    0x0002 /* return numbers instead of TOK_PPNUM */\n#define PARSE_FLAG_LINEFEED   0x0004 /* line feed is returned as a\n                                        token. line feed is also\n                                        returned at eof */\n#define PARSE_FLAG_ASM_COMMENTS 0x0008 /* '#' can be used for line comment */\n \nstatic Section *text_section, *data_section, *bss_section; /* predefined sections */\nstatic Section *cur_text_section; /* current section where function code is\n                              generated */\n#ifdef CONFIG_TCC_ASM\nstatic Section *last_text_section; /* to handle .previous asm directive */\n#endif\n/* bound check related sections */\nstatic Section *bounds_section; /* contains global data bound description */\nstatic Section *lbounds_section; /* contains local data bound description */\n/* symbol sections */\nstatic Section *symtab_section, *strtab_section;\n\n/* debug sections */\nstatic Section *stab_section, *stabstr_section;\n\n/* loc : local variable index\n   ind : output code index\n   rsym: return symbol\n   anon_sym: anonymous symbol index\n*/\nstatic long rsym, anon_sym, ind, loc;\n/* expression generation modifiers */\nstatic int const_wanted; /* true if constant wanted */\nstatic int nocode_wanted; /* true if no code generation wanted for an expression */\nstatic int global_expr;  /* true if compound literals must be allocated\n                            globally (used during initializers parsing */\nstatic CType func_vt; /* current function return type (used by return\n                         instruction) */\nstatic int func_vc;\nstatic long last_line_num, last_ind, func_ind; /* debug last line number and pc */\nstatic int tok_ident;\nstatic TokenSym **table_ident;\nstatic TokenSym *hash_ident[TOK_HASH_SIZE];\nstatic char token_buf[STRING_MAX_SIZE + 1];\nstatic char *funcname;\nstatic Sym *global_stack, *local_stack;\nstatic Sym *define_stack;\nstatic Sym *global_label_stack, *local_label_stack;\n/* symbol allocator */\n#define SYM_POOL_NB (8192 / sizeof(Sym))\nstatic Sym *sym_free_first;\n\nstatic SValue vstack[VSTACK_SIZE], *vtop;\n/* some predefined types */\nstatic CType char_pointer_type, func_old_type, int_type;\n/* true if isid(c) || isnum(c) */\nstatic unsigned char isidnum_table[256];\n\n/* compile with debug symbol (and use them if error during execution) */\nstatic int do_debug = 0;\n\n/* compile with built-in memory and bounds checker */\nstatic int do_bounds_check = 0;\n\n/* display benchmark infos */\n#if !defined(LIBTCC)\nstatic int do_bench = 0;\n#endif\nstatic int total_lines;\nstatic int total_bytes;\n\n/* use GNU C extensions */\nstatic int gnu_ext = 1;\n\n/* use Tiny C extensions */\nstatic int tcc_ext = 1;\n\n/* max number of callers shown if error */\nstatic int num_callers = 6;\nstatic const char **rt_bound_error_msg;\n\n/* XXX: get rid of this ASAP */\nstatic struct TCCState *tcc_state;\n\n/* give the path of the tcc libraries */\nstatic const char *tcc_lib_path = CONFIG_TCCDIR;\n\nstruct TCCState {\n    int output_type;\n \n    BufferedFile **include_stack_ptr;\n    int *ifdef_stack_ptr;\n\n    /* include file handling */\n    char **include_paths;\n    int nb_include_paths;\n    char **sysinclude_paths;\n    int nb_sysinclude_paths;\n    CachedInclude **cached_includes;\n    int nb_cached_includes;\n\n    char **library_paths;\n    int nb_library_paths;\n\n    /* array of all loaded dlls (including those referenced by loaded\n       dlls) */\n    DLLReference **loaded_dlls;\n    int nb_loaded_dlls;\n\n    /* sections */\n    Section **sections;\n    int nb_sections; /* number of sections, including first dummy section */\n\n    /* got handling */\n    Section *got;\n    Section *plt;\n    unsigned long *got_offsets;\n    int nb_got_offsets;\n    /* give the correspondence from symtab indexes to dynsym indexes */\n    int *symtab_to_dynsym;\n\n    /* temporary dynamic symbol sections (for dll loading) */\n    Section *dynsymtab_section;\n    /* exported dynamic symbol section */\n    Section *dynsym;\n\n    int nostdinc; /* if true, no standard headers are added */\n    int nostdlib; /* if true, no standard libraries are added */\n\n    int nocommon; /* if true, do not use common symbols for .bss data */\n\n    /* if true, static linking is performed */\n    int static_link;\n\n    /* if true, all symbols are exported */\n    int rdynamic;\n\n    /* if true, only link in referenced objects from archive */\n    int alacarte_link;\n\n    /* address of text section */\n    unsigned long text_addr;\n    int has_text_addr;\n    \n    /* output format, see TCC_OUTPUT_FORMAT_xxx */\n    int output_format;\n\n    /* C language options */\n    int char_is_unsigned;\n    int leading_underscore;\n    \n    /* warning switches */\n    int warn_write_strings;\n    int warn_unsupported;\n    int warn_error;\n    int warn_none;\n    int warn_implicit_function_declaration;\n\n    /* error handling */\n    void *error_opaque;\n    void (*error_func)(void *opaque, const char *msg);\n    int error_set_jmp_enabled;\n    jmp_buf error_jmp_buf;\n    int nb_errors;\n\n    /* tiny assembler state */\n    Sym *asm_labels;\n\n    /* see include_stack_ptr */\n    BufferedFile *include_stack[INCLUDE_STACK_SIZE];\n\n    /* see ifdef_stack_ptr */\n    int ifdef_stack[IFDEF_STACK_SIZE];\n\n    /* see cached_includes */\n    int cached_includes_hash[CACHED_INCLUDES_HASH_SIZE];\n\n    /* pack stack */\n    int pack_stack[PACK_STACK_SIZE];\n    int *pack_stack_ptr;\n};\n\n/* The current value can be: */\n#define VT_VALMASK   0x00ff\n#define VT_CONST     0x00f0  /* constant in vc \n                              (must be first non register value) */\n#define VT_LLOCAL    0x00f1  /* lvalue, offset on stack */\n#define VT_LOCAL     0x00f2  /* offset on stack */\n#define VT_CMP       0x00f3  /* the value is stored in processor flags (in vc) */\n#define VT_JMP       0x00f4  /* value is the consequence of jmp true (even) */\n#define VT_JMPI      0x00f5  /* value is the consequence of jmp false (odd) */\n#define VT_LVAL      0x0100  /* var is an lvalue */\n#define VT_SYM       0x0200  /* a symbol value is added */\n#define VT_MUSTCAST  0x0400  /* value must be casted to be correct (used for\n                                char/short stored in integer registers) */\n#define VT_MUSTBOUND 0x0800  /* bound checking must be done before\n                                dereferencing value */\n#define VT_BOUNDED   0x8000  /* value is bounded. The address of the\n                                bounding function call point is in vc */\n#define VT_LVAL_BYTE     0x1000  /* lvalue is a byte */\n#define VT_LVAL_SHORT    0x2000  /* lvalue is a short */\n#define VT_LVAL_UNSIGNED 0x4000  /* lvalue is unsigned */\n#define VT_LVAL_TYPE     (VT_LVAL_BYTE | VT_LVAL_SHORT | VT_LVAL_UNSIGNED)\n\n/* types */\n#define VT_INT        0  /* integer type */\n#define VT_BYTE       1  /* signed byte type */\n#define VT_SHORT      2  /* short type */\n#define VT_VOID       3  /* void type */\n#define VT_PTR        4  /* pointer */\n#define VT_ENUM       5  /* enum definition */\n#define VT_FUNC       6  /* function type */\n#define VT_STRUCT     7  /* struct/union definition */\n#define VT_FLOAT      8  /* IEEE float */\n#define VT_DOUBLE     9  /* IEEE double */\n#define VT_LDOUBLE   10  /* IEEE long double */\n#define VT_BOOL      11  /* ISOC99 boolean type */\n#define VT_LLONG     12  /* 64 bit integer */\n#define VT_LONG      13  /* long integer (NEVER USED as type, only\n                            during parsing) */\n#define VT_BTYPE      0x000f /* mask for basic type */\n#define VT_UNSIGNED   0x0010  /* unsigned type */\n#define VT_ARRAY      0x0020  /* array type (also has VT_PTR) */\n#define VT_BITFIELD   0x0040  /* bitfield modifier */\n#define VT_CONSTANT   0x0800  /* const modifier */\n#define VT_VOLATILE   0x1000  /* volatile modifier */\n#define VT_SIGNED     0x2000  /* signed type */\n\n/* storage */\n#define VT_EXTERN  0x00000080  /* extern definition */\n#define VT_STATIC  0x00000100  /* static variable */\n#define VT_TYPEDEF 0x00000200  /* typedef definition */\n#define VT_INLINE  0x00000400  /* inline definition */\n\n#define VT_STRUCT_SHIFT 16   /* shift for bitfield shift values */\n\n/* type mask (except storage) */\n#define VT_STORAGE (VT_EXTERN | VT_STATIC | VT_TYPEDEF | VT_INLINE)\n#define VT_TYPE    (~(VT_STORAGE))\n\n/* token values */\n\n/* warning: the following compare tokens depend on i386 asm code */\n#define TOK_ULT 0x92\n#define TOK_UGE 0x93\n#define TOK_EQ  0x94\n#define TOK_NE  0x95\n#define TOK_ULE 0x96\n#define TOK_UGT 0x97\n#define TOK_LT  0x9c\n#define TOK_GE  0x9d\n#define TOK_LE  0x9e\n#define TOK_GT  0x9f\n\n#define TOK_LAND  0xa0\n#define TOK_LOR   0xa1\n\n#define TOK_DEC   0xa2\n#define TOK_MID   0xa3 /* inc/dec, to void constant */\n#define TOK_INC   0xa4\n#define TOK_UDIV  0xb0 /* unsigned division */\n#define TOK_UMOD  0xb1 /* unsigned modulo */\n#define TOK_PDIV  0xb2 /* fast division with undefined rounding for pointers */\n#define TOK_CINT   0xb3 /* number in tokc */\n#define TOK_CCHAR 0xb4 /* char constant in tokc */\n#define TOK_STR   0xb5 /* pointer to string in tokc */\n#define TOK_TWOSHARPS 0xb6 /* ## preprocessing token */\n#define TOK_LCHAR    0xb7\n#define TOK_LSTR     0xb8\n#define TOK_CFLOAT   0xb9 /* float constant */\n#define TOK_LINENUM  0xba /* line number info */\n#define TOK_CDOUBLE  0xc0 /* double constant */\n#define TOK_CLDOUBLE 0xc1 /* long double constant */\n#define TOK_UMULL    0xc2 /* unsigned 32x32 -> 64 mul */\n#define TOK_ADDC1    0xc3 /* add with carry generation */\n#define TOK_ADDC2    0xc4 /* add with carry use */\n#define TOK_SUBC1    0xc5 /* add with carry generation */\n#define TOK_SUBC2    0xc6 /* add with carry use */\n#define TOK_CUINT    0xc8 /* unsigned int constant */\n#define TOK_CLLONG   0xc9 /* long long constant */\n#define TOK_CULLONG  0xca /* unsigned long long constant */\n#define TOK_ARROW    0xcb\n#define TOK_DOTS     0xcc /* three dots */\n#define TOK_SHR      0xcd /* unsigned shift right */\n#define TOK_PPNUM    0xce /* preprocessor number */\n\n#define TOK_SHL   0x01 /* shift left */\n#define TOK_SAR   0x02 /* signed shift right */\n  \n/* assignement operators : normal operator or 0x80 */\n#define TOK_A_MOD 0xa5\n#define TOK_A_AND 0xa6\n#define TOK_A_MUL 0xaa\n#define TOK_A_ADD 0xab\n#define TOK_A_SUB 0xad\n#define TOK_A_DIV 0xaf\n#define TOK_A_XOR 0xde\n#define TOK_A_OR  0xfc\n#define TOK_A_SHL 0x81\n#define TOK_A_SAR 0x82\n\n#ifndef offsetof\n#define offsetof(type, field) ((size_t) &((type *)0)->field)\n#endif\n\n#ifndef countof\n#define countof(tab) (sizeof(tab) / sizeof((tab)[0]))\n#endif\n\n/* WARNING: the content of this string encodes token numbers */\nstatic char tok_two_chars[] = \"<=\\236>=\\235!=\\225&&\\240||\\241++\\244--\\242==\\224<<\\1>>\\2+=\\253-=\\255*=\\252/=\\257%=\\245&=\\246^=\\336|=\\374->\\313..\\250##\\266\";\n\n#define TOK_EOF       (-1)  /* end of file */\n#define TOK_LINEFEED  10    /* line feed */\n\n/* all identificators and strings have token above that */\n#define TOK_IDENT 256\n\n/* only used for i386 asm opcodes definitions */\n#define DEF_ASM(x) DEF(TOK_ASM_ ## x, #x)\n\n#define DEF_BWL(x) \\\n DEF(TOK_ASM_ ## x ## b, #x \"b\") \\\n DEF(TOK_ASM_ ## x ## w, #x \"w\") \\\n DEF(TOK_ASM_ ## x ## l, #x \"l\") \\\n DEF(TOK_ASM_ ## x, #x)\n\n#define DEF_WL(x) \\\n DEF(TOK_ASM_ ## x ## w, #x \"w\") \\\n DEF(TOK_ASM_ ## x ## l, #x \"l\") \\\n DEF(TOK_ASM_ ## x, #x)\n\n#define DEF_FP1(x) \\\n DEF(TOK_ASM_ ## f ## x ## s, \"f\" #x \"s\") \\\n DEF(TOK_ASM_ ## fi ## x ## l, \"fi\" #x \"l\") \\\n DEF(TOK_ASM_ ## f ## x ## l, \"f\" #x \"l\") \\\n DEF(TOK_ASM_ ## fi ## x ## s, \"fi\" #x \"s\")\n\n#define DEF_FP(x) \\\n DEF(TOK_ASM_ ## f ## x, \"f\" #x ) \\\n DEF(TOK_ASM_ ## f ## x ## p, \"f\" #x \"p\") \\\n DEF_FP1(x)\n\n#define DEF_ASMTEST(x) \\\n DEF_ASM(x ## o) \\\n DEF_ASM(x ## no) \\\n DEF_ASM(x ## b) \\\n DEF_ASM(x ## c) \\\n DEF_ASM(x ## nae) \\\n DEF_ASM(x ## nb) \\\n DEF_ASM(x ## nc) \\\n DEF_ASM(x ## ae) \\\n DEF_ASM(x ## e) \\\n DEF_ASM(x ## z) \\\n DEF_ASM(x ## ne) \\\n DEF_ASM(x ## nz) \\\n DEF_ASM(x ## be) \\\n DEF_ASM(x ## na) \\\n DEF_ASM(x ## nbe) \\\n DEF_ASM(x ## a) \\\n DEF_ASM(x ## s) \\\n DEF_ASM(x ## ns) \\\n DEF_ASM(x ## p) \\\n DEF_ASM(x ## pe) \\\n DEF_ASM(x ## np) \\\n DEF_ASM(x ## po) \\\n DEF_ASM(x ## l) \\\n DEF_ASM(x ## nge) \\\n DEF_ASM(x ## nl) \\\n DEF_ASM(x ## ge) \\\n DEF_ASM(x ## le) \\\n DEF_ASM(x ## ng) \\\n DEF_ASM(x ## nle) \\\n DEF_ASM(x ## g)\n\n#define TOK_ASM_int TOK_INT\n\nenum tcc_token {\n    TOK_LAST = TOK_IDENT - 1,\n#define DEF(id, str) id,\n// njn: inlined tcctok.h\n//#include \"tcctok.h\"\n//---------------------------------------------------------------------------\n/* keywords */\n     DEF(TOK_INT, \"int\")\n     DEF(TOK_VOID, \"void\")\n     DEF(TOK_CHAR, \"char\")\n     DEF(TOK_IF, \"if\")\n     DEF(TOK_ELSE, \"else\")\n     DEF(TOK_WHILE, \"while\")\n     DEF(TOK_BREAK, \"break\")\n     DEF(TOK_RETURN, \"return\")\n     DEF(TOK_FOR, \"for\")\n     DEF(TOK_EXTERN, \"extern\")\n     DEF(TOK_STATIC, \"static\")\n     DEF(TOK_UNSIGNED, \"unsigned\")\n     DEF(TOK_GOTO, \"goto\")\n     DEF(TOK_DO, \"do\")\n     DEF(TOK_CONTINUE, \"continue\")\n     DEF(TOK_SWITCH, \"switch\")\n     DEF(TOK_CASE, \"case\")\n\n     DEF(TOK_CONST1, \"const\")\n     DEF(TOK_CONST2, \"__const\") /* gcc keyword */\n     DEF(TOK_CONST3, \"__const__\") /* gcc keyword */\n     DEF(TOK_VOLATILE1, \"volatile\")\n     DEF(TOK_VOLATILE2, \"__volatile\") /* gcc keyword */\n     DEF(TOK_VOLATILE3, \"__volatile__\") /* gcc keyword */\n     DEF(TOK_LONG, \"long\")\n     DEF(TOK_REGISTER, \"register\")\n     DEF(TOK_SIGNED1, \"signed\")\n     DEF(TOK_SIGNED2, \"__signed\") /* gcc keyword */\n     DEF(TOK_SIGNED3, \"__signed__\") /* gcc keyword */\n     DEF(TOK_AUTO, \"auto\")\n     DEF(TOK_INLINE1, \"inline\")\n     DEF(TOK_INLINE2, \"__inline\") /* gcc keyword */\n     DEF(TOK_INLINE3, \"__inline__\") /* gcc keyword */\n     DEF(TOK_RESTRICT1, \"restrict\")\n     DEF(TOK_RESTRICT2, \"__restrict\")\n     DEF(TOK_RESTRICT3, \"__restrict__\")\n     DEF(TOK_EXTENSION, \"__extension__\") /* gcc keyword */\n     \n     DEF(TOK_FLOAT, \"float\")\n     DEF(TOK_DOUBLE, \"double\")\n     DEF(TOK_BOOL, \"_Bool\")\n     DEF(TOK_SHORT, \"short\")\n     DEF(TOK_STRUCT, \"struct\")\n     DEF(TOK_UNION, \"union\")\n     DEF(TOK_TYPEDEF, \"typedef\")\n     DEF(TOK_DEFAULT, \"default\")\n     DEF(TOK_ENUM, \"enum\")\n     DEF(TOK_SIZEOF, \"sizeof\")\n     DEF(TOK_ATTRIBUTE1, \"__attribute\")\n     DEF(TOK_ATTRIBUTE2, \"__attribute__\")\n     DEF(TOK_ALIGNOF1, \"__alignof\")\n     DEF(TOK_ALIGNOF2, \"__alignof__\")\n     DEF(TOK_TYPEOF1, \"typeof\")\n     DEF(TOK_TYPEOF2, \"__typeof\")\n     DEF(TOK_TYPEOF3, \"__typeof__\")\n     DEF(TOK_LABEL, \"__label__\")\n     DEF(TOK_ASM1, \"asm\")\n     DEF(TOK_ASM2, \"__asm\")\n     DEF(TOK_ASM3, \"__asm__\")\n\n/*********************************************************************/\n/* the following are not keywords. They are included to ease parsing */\n/* preprocessor only */\n     DEF(TOK_DEFINE, \"define\")\n     DEF(TOK_INCLUDE, \"include\")\n     DEF(TOK_INCLUDE_NEXT, \"include_next\")\n     DEF(TOK_IFDEF, \"ifdef\")\n     DEF(TOK_IFNDEF, \"ifndef\")\n     DEF(TOK_ELIF, \"elif\")\n     DEF(TOK_ENDIF, \"endif\")\n     DEF(TOK_DEFINED, \"defined\")\n     DEF(TOK_UNDEF, \"undef\")\n     DEF(TOK_ERROR, \"error\")\n     DEF(TOK_WARNING, \"warning\")\n     DEF(TOK_LINE, \"line\")\n     DEF(TOK_PRAGMA, \"pragma\")\n     DEF(TOK___LINE__, \"__LINE__\")\n     DEF(TOK___FILE__, \"__FILE__\")\n     DEF(TOK___DATE__, \"__DATE__\")\n     DEF(TOK___TIME__, \"__TIME__\")\n     DEF(TOK___FUNCTION__, \"__FUNCTION__\")\n     DEF(TOK___VA_ARGS__, \"__VA_ARGS__\")\n     \n/* special identifiers */\n     DEF(TOK___FUNC__, \"__func__\")\n     \n/* attribute identifiers */\n/* XXX: handle all tokens generically since speed is not critical */\n     DEF(TOK_SECTION1, \"section\")\n     DEF(TOK_SECTION2, \"__section__\")\n     DEF(TOK_ALIGNED1, \"aligned\")\n     DEF(TOK_ALIGNED2, \"__aligned__\")\n     DEF(TOK_PACKED1, \"packed\")\n     DEF(TOK_PACKED2, \"__packed__\")\n     DEF(TOK_UNUSED1, \"unused\")\n     DEF(TOK_UNUSED2, \"__unused__\")\n     DEF(TOK_CDECL1, \"cdecl\")\n     DEF(TOK_CDECL2, \"__cdecl\")\n     DEF(TOK_CDECL3, \"__cdecl__\")\n     DEF(TOK_STDCALL1, \"stdcall\")\n     DEF(TOK_STDCALL2, \"__stdcall\")\n     DEF(TOK_STDCALL3, \"__stdcall__\")\n     DEF(TOK_DLLEXPORT, \"dllexport\")\n     DEF(TOK_NORETURN1, \"noreturn\")\n     DEF(TOK_NORETURN2, \"__noreturn__\")\n     DEF(TOK_builtin_types_compatible_p, \"__builtin_types_compatible_p\")\n     DEF(TOK_builtin_constant_p, \"__builtin_constant_p\")\n     DEF(TOK_REGPARM1, \"regparm\")\n     DEF(TOK_REGPARM2, \"__regparm__\")\n\n/* pragma */\n     DEF(TOK_pack, \"pack\")\n#if !defined(TCC_TARGET_I386)\n     /* already defined for assembler */\n     DEF(TOK_ASM_push, \"push\")\n     DEF(TOK_ASM_pop, \"pop\")\n#endif\n\n/* builtin functions or variables */\n     DEF(TOK_memcpy, \"memcpy\")\n     DEF(TOK_memset, \"memset\")\n     DEF(TOK_alloca, \"alloca\")\n     DEF(TOK___divdi3, \"__divdi3\")\n     DEF(TOK___moddi3, \"__moddi3\")\n     DEF(TOK___udivdi3, \"__udivdi3\")\n     DEF(TOK___umoddi3, \"__umoddi3\")\n#if defined(TCC_TARGET_ARM)\n     DEF(TOK___divsi3, \"__divsi3\")\n     DEF(TOK___modsi3, \"__modsi3\")\n     DEF(TOK___udivsi3, \"__udivsi3\")\n     DEF(TOK___umodsi3, \"__umodsi3\")\n     DEF(TOK___sardi3, \"__ashrdi3\")\n     DEF(TOK___shrdi3, \"__lshrdi3\")\n     DEF(TOK___shldi3, \"__ashldi3\")\n     DEF(TOK___slltold, \"__slltold\")\n     DEF(TOK___fixunssfsi, \"__fixunssfsi\")\n     DEF(TOK___fixunsdfsi, \"__fixunsdfsi\")\n     DEF(TOK___fixunsxfsi, \"__fixunsxfsi\")\n     DEF(TOK___fixsfdi, \"__fixsfdi\")\n     DEF(TOK___fixdfdi, \"__fixdfdi\")\n     DEF(TOK___fixxfdi, \"__fixxfdi\")\n#elif defined(TCC_TARGET_C67)\n     DEF(TOK__divi, \"_divi\")\n     DEF(TOK__divu, \"_divu\")\n     DEF(TOK__divf, \"_divf\")\n     DEF(TOK__divd, \"_divd\")\n     DEF(TOK__remi, \"_remi\")\n     DEF(TOK__remu, \"_remu\")\n     DEF(TOK___sardi3, \"__sardi3\")\n     DEF(TOK___shrdi3, \"__shrdi3\")\n     DEF(TOK___shldi3, \"__shldi3\")\n#else\n     /* XXX: same names on i386 ? */\n     DEF(TOK___sardi3, \"__sardi3\")\n     DEF(TOK___shrdi3, \"__shrdi3\")\n     DEF(TOK___shldi3, \"__shldi3\")\n#endif\n     DEF(TOK___tcc_int_fpu_control, \"__tcc_int_fpu_control\")\n     DEF(TOK___tcc_fpu_control, \"__tcc_fpu_control\")\n     DEF(TOK___ulltof, \"__ulltof\")\n     DEF(TOK___ulltod, \"__ulltod\")\n     DEF(TOK___ulltold, \"__ulltold\")\n     DEF(TOK___fixunssfdi, \"__fixunssfdi\")\n     DEF(TOK___fixunsdfdi, \"__fixunsdfdi\")\n     DEF(TOK___fixunsxfdi, \"__fixunsxfdi\")\n     DEF(TOK___chkstk, \"__chkstk\")\n\n/* bound checking symbols */\n#ifdef CONFIG_TCC_BCHECK\n     DEF(TOK___bound_ptr_add, \"__bound_ptr_add\")\n     DEF(TOK___bound_ptr_indir1, \"__bound_ptr_indir1\")\n     DEF(TOK___bound_ptr_indir2, \"__bound_ptr_indir2\")\n     DEF(TOK___bound_ptr_indir4, \"__bound_ptr_indir4\")\n     DEF(TOK___bound_ptr_indir8, \"__bound_ptr_indir8\")\n     DEF(TOK___bound_ptr_indir12, \"__bound_ptr_indir12\")\n     DEF(TOK___bound_ptr_indir16, \"__bound_ptr_indir16\")\n     DEF(TOK___bound_local_new, \"__bound_local_new\")\n     DEF(TOK___bound_local_delete, \"__bound_local_delete\")\n     DEF(TOK_malloc, \"malloc\")\n     DEF(TOK_free, \"free\")\n     DEF(TOK_realloc, \"realloc\")\n     DEF(TOK_memalign, \"memalign\")\n     DEF(TOK_calloc, \"calloc\")\n     DEF(TOK_memmove, \"memmove\")\n     DEF(TOK_strlen, \"strlen\")\n     DEF(TOK_strcpy, \"strcpy\")\n#endif\n\n/* Tiny Assembler */\n\n DEF_ASM(byte)\n DEF_ASM(align)\n DEF_ASM(skip)\n DEF_ASM(space)\n DEF_ASM(string)\n DEF_ASM(asciz)\n DEF_ASM(ascii)\n DEF_ASM(globl)\n DEF_ASM(global)\n DEF_ASM(text)\n DEF_ASM(data)\n DEF_ASM(bss)\n DEF_ASM(previous)\n DEF_ASM(fill)\n DEF_ASM(org)\n DEF_ASM(quad)\n\n#ifdef TCC_TARGET_I386\n\n/* WARNING: relative order of tokens is important. */\n DEF_ASM(al)\n DEF_ASM(cl)\n DEF_ASM(dl)\n DEF_ASM(bl)\n DEF_ASM(ah)\n DEF_ASM(ch)\n DEF_ASM(dh)\n DEF_ASM(bh)\n DEF_ASM(ax)\n DEF_ASM(cx)\n DEF_ASM(dx)\n DEF_ASM(bx)\n DEF_ASM(sp)\n DEF_ASM(bp)\n DEF_ASM(si)\n DEF_ASM(di)\n DEF_ASM(eax)\n DEF_ASM(ecx)\n DEF_ASM(edx)\n DEF_ASM(ebx)\n DEF_ASM(esp)\n DEF_ASM(ebp)\n DEF_ASM(esi)\n DEF_ASM(edi)\n DEF_ASM(mm0)\n DEF_ASM(mm1)\n DEF_ASM(mm2)\n DEF_ASM(mm3)\n DEF_ASM(mm4)\n DEF_ASM(mm5)\n DEF_ASM(mm6)\n DEF_ASM(mm7)\n DEF_ASM(xmm0)\n DEF_ASM(xmm1)\n DEF_ASM(xmm2)\n DEF_ASM(xmm3)\n DEF_ASM(xmm4)\n DEF_ASM(xmm5)\n DEF_ASM(xmm6)\n DEF_ASM(xmm7)\n DEF_ASM(cr0)\n DEF_ASM(cr1)\n DEF_ASM(cr2)\n DEF_ASM(cr3)\n DEF_ASM(cr4)\n DEF_ASM(cr5)\n DEF_ASM(cr6)\n DEF_ASM(cr7)\n DEF_ASM(tr0)\n DEF_ASM(tr1)\n DEF_ASM(tr2)\n DEF_ASM(tr3)\n DEF_ASM(tr4)\n DEF_ASM(tr5)\n DEF_ASM(tr6)\n DEF_ASM(tr7)\n DEF_ASM(db0)\n DEF_ASM(db1)\n DEF_ASM(db2)\n DEF_ASM(db3)\n DEF_ASM(db4)\n DEF_ASM(db5)\n DEF_ASM(db6)\n DEF_ASM(db7)\n DEF_ASM(dr0)\n DEF_ASM(dr1)\n DEF_ASM(dr2)\n DEF_ASM(dr3)\n DEF_ASM(dr4)\n DEF_ASM(dr5)\n DEF_ASM(dr6)\n DEF_ASM(dr7)\n DEF_ASM(es)\n DEF_ASM(cs)\n DEF_ASM(ss)\n DEF_ASM(ds)\n DEF_ASM(fs)\n DEF_ASM(gs)\n DEF_ASM(st)\n\n DEF_BWL(mov)\n\n /* generic two operands */\n DEF_BWL(add)\n DEF_BWL(or)\n DEF_BWL(adc)\n DEF_BWL(sbb)\n DEF_BWL(and)\n DEF_BWL(sub)\n DEF_BWL(xor)\n DEF_BWL(cmp)\n\n /* unary ops */\n DEF_BWL(inc)\n DEF_BWL(dec)\n DEF_BWL(not)\n DEF_BWL(neg)\n DEF_BWL(mul)\n DEF_BWL(imul)\n DEF_BWL(div)\n DEF_BWL(idiv)\n\n DEF_BWL(xchg)\n DEF_BWL(test)\n\n /* shifts */\n DEF_BWL(rol)\n DEF_BWL(ror)\n DEF_BWL(rcl)\n DEF_BWL(rcr)\n DEF_BWL(shl)\n DEF_BWL(shr)\n DEF_BWL(sar)\n\n DEF_ASM(shldw)\n DEF_ASM(shldl)\n DEF_ASM(shld)\n DEF_ASM(shrdw)\n DEF_ASM(shrdl)\n DEF_ASM(shrd)\n\n DEF_ASM(pushw)\n DEF_ASM(pushl)\n DEF_ASM(push)\n DEF_ASM(popw)\n DEF_ASM(popl)\n DEF_ASM(pop)\n DEF_BWL(in)\n DEF_BWL(out)\n\n DEF_WL(movzb)\n\n DEF_ASM(movzwl)\n DEF_ASM(movsbw)\n DEF_ASM(movsbl)\n DEF_ASM(movswl)\n\n DEF_WL(lea) \n\n DEF_ASM(les) \n DEF_ASM(lds) \n DEF_ASM(lss) \n DEF_ASM(lfs) \n DEF_ASM(lgs) \n\n DEF_ASM(call)\n DEF_ASM(jmp)\n DEF_ASM(lcall)\n DEF_ASM(ljmp)\n \n DEF_ASMTEST(j)\n\n DEF_ASMTEST(set)\n DEF_ASMTEST(cmov)\n\n DEF_WL(bsf)\n DEF_WL(bsr)\n DEF_WL(bt)\n DEF_WL(bts)\n DEF_WL(btr)\n DEF_WL(btc)\n\n DEF_WL(lsl)\n\n /* generic FP ops */\n DEF_FP(add)\n DEF_FP(mul)\n\n DEF_ASM(fcom)\n DEF_ASM(fcom_1) /* non existent op, just to have a regular table */\n DEF_FP1(com)\n\n DEF_FP(comp)\n DEF_FP(sub)\n DEF_FP(subr)\n DEF_FP(div)\n DEF_FP(divr)\n\n DEF_BWL(xadd)\n DEF_BWL(cmpxchg)\n\n /* string ops */\n DEF_BWL(cmps)\n DEF_BWL(scmp)\n DEF_BWL(ins)\n DEF_BWL(outs)\n DEF_BWL(lods)\n DEF_BWL(slod)\n DEF_BWL(movs)\n DEF_BWL(smov)\n DEF_BWL(scas)\n DEF_BWL(ssca)\n DEF_BWL(stos)\n DEF_BWL(ssto)\n\n /* generic asm ops */\n\n#define ALT(x)\n#define DEF_ASM_OP0(name, opcode) DEF_ASM(name)\n#define DEF_ASM_OP0L(name, opcode, group, instr_type)\n#define DEF_ASM_OP1(name, opcode, group, instr_type, op0)\n#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1)\n#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2)\n// njn: inlined i386-asm.h\n//#include \"i386-asm.h\"\n//---------------------------------------------------------------------------\n     DEF_ASM_OP0(pusha, 0x60) /* must be first OP0 */\n     DEF_ASM_OP0(popa, 0x61)\n     DEF_ASM_OP0(clc, 0xf8)\n     DEF_ASM_OP0(cld, 0xfc)\n     DEF_ASM_OP0(cli, 0xfa)\n     DEF_ASM_OP0(clts, 0x0f06)\n     DEF_ASM_OP0(cmc, 0xf5)\n     DEF_ASM_OP0(lahf, 0x9f)\n     DEF_ASM_OP0(sahf, 0x9e)\n     DEF_ASM_OP0(pushfl, 0x9c)\n     DEF_ASM_OP0(popfl, 0x9d)\n     DEF_ASM_OP0(pushf, 0x9c)\n     DEF_ASM_OP0(popf, 0x9d)\n     DEF_ASM_OP0(stc, 0xf9)\n     DEF_ASM_OP0(std, 0xfd)\n     DEF_ASM_OP0(sti, 0xfb)\n     DEF_ASM_OP0(aaa, 0x37)\n     DEF_ASM_OP0(aas, 0x3f)\n     DEF_ASM_OP0(daa, 0x27)\n     DEF_ASM_OP0(das, 0x2f)\n     DEF_ASM_OP0(aad, 0xd50a)\n     DEF_ASM_OP0(aam, 0xd40a)\n     DEF_ASM_OP0(cbw, 0x6698)\n     DEF_ASM_OP0(cwd, 0x6699)\n     DEF_ASM_OP0(cwde, 0x98)\n     DEF_ASM_OP0(cdq, 0x99)\n     DEF_ASM_OP0(cbtw, 0x6698)\n     DEF_ASM_OP0(cwtl, 0x98)\n     DEF_ASM_OP0(cwtd, 0x6699)\n     DEF_ASM_OP0(cltd, 0x99)\n     DEF_ASM_OP0(int3, 0xcc)\n     DEF_ASM_OP0(into, 0xce)\n     DEF_ASM_OP0(iret, 0xcf)\n     DEF_ASM_OP0(rsm, 0x0faa)\n     DEF_ASM_OP0(hlt, 0xf4)\n     DEF_ASM_OP0(wait, 0x9b)\n     DEF_ASM_OP0(nop, 0x90)\n     DEF_ASM_OP0(xlat, 0xd7)\n\n     /* strings */\nALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(insb, 0x6c, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(outsb, 0x6e, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(lodsb, 0xac, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(slodb, 0xac, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(movsb, 0xa4, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(smovb, 0xa4, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(scasb, 0xae, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sscab, 0xae, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(stosb, 0xaa, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sstob, 0xaa, 0, OPC_BWL))\n\n     /* bits */\n     \nALT(DEF_ASM_OP2(bsfw, 0x0fbc, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(bsrw, 0x0fbd, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\n\nALT(DEF_ASM_OP2(btw, 0x0fa3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btw, 0x0fba, 4, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btsw, 0x0fab, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btsw, 0x0fba, 5, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btrw, 0x0fb3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btrw, 0x0fba, 6, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btcw, 0x0fbb, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btcw, 0x0fba, 7, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\n     /* prefixes */\n     DEF_ASM_OP0(aword, 0x67)\n     DEF_ASM_OP0(addr16, 0x67)\n     DEF_ASM_OP0(word, 0x66)\n     DEF_ASM_OP0(data16, 0x66)\n     DEF_ASM_OP0(lock, 0xf0)\n     DEF_ASM_OP0(rep, 0xf3)\n     DEF_ASM_OP0(repe, 0xf3)\n     DEF_ASM_OP0(repz, 0xf3)\n     DEF_ASM_OP0(repne, 0xf2)\n     DEF_ASM_OP0(repnz, 0xf2)\n             \n     DEF_ASM_OP0(invd, 0x0f08)\n     DEF_ASM_OP0(wbinvd, 0x0f09)\n     DEF_ASM_OP0(cpuid, 0x0fa2)\n     DEF_ASM_OP0(wrmsr, 0x0f30)\n     DEF_ASM_OP0(rdtsc, 0x0f31)\n     DEF_ASM_OP0(rdmsr, 0x0f32)\n     DEF_ASM_OP0(rdpmc, 0x0f33)\n     DEF_ASM_OP0(ud2, 0x0f0b)\n\n     /* NOTE: we took the same order as gas opcode definition order */\nALT(DEF_ASM_OP2(movb, 0xa0, 0, OPC_BWL, OPT_ADDR, OPT_EAX))\nALT(DEF_ASM_OP2(movb, 0xa2, 0, OPC_BWL, OPT_EAX, OPT_ADDR))\nALT(DEF_ASM_OP2(movb, 0x88, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movb, 0x8a, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xb0, 0, OPC_REG | OPC_BWL, OPT_IM, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xc6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(movw, 0x8c, 0, OPC_MODRM | OPC_WL, OPT_SEG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movw, 0x8e, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_SEG))\n\nALT(DEF_ASM_OP2(movw, 0x0f20, 0, OPC_MODRM | OPC_WL, OPT_CR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f21, 0, OPC_MODRM | OPC_WL, OPT_DB, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f24, 0, OPC_MODRM | OPC_WL, OPT_TR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f22, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_CR))\nALT(DEF_ASM_OP2(movw, 0x0f23, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_DB))\nALT(DEF_ASM_OP2(movw, 0x0f26, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_TR))\n\nALT(DEF_ASM_OP2(movsbl, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movsbw, 0x0fbe, 0, OPC_MODRM | OPC_D16, OPT_REG8 | OPT_EA, OPT_REG16))\nALT(DEF_ASM_OP2(movswl, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movzbw, 0x0fb6, 0, OPC_MODRM | OPC_WL, OPT_REG8 | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(movzwl, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\n\nALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(pushw, 0xff, 6, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(pushw, 0x6a, 0, OPC_WL, OPT_IM8S))\nALT(DEF_ASM_OP1(pushw, 0x68, 0, OPC_WL, OPT_IM32))\nALT(DEF_ASM_OP1(pushw, 0x06, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(popw, 0x8f, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(popw, 0x07, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_REG, OPT_EAX))\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_EAX, OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\n\nALT(DEF_ASM_OP2(inb, 0xe4, 0, OPC_BWL, OPT_IM8, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xe4, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(inb, 0xec, 0, OPC_BWL, OPT_DX, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xec, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(outb, 0xe6, 0, OPC_BWL, OPT_EAX, OPT_IM8))\nALT(DEF_ASM_OP1(outb, 0xe6, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(outb, 0xee, 0, OPC_BWL, OPT_EAX, OPT_DX))\nALT(DEF_ASM_OP1(outb, 0xee, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(leaw, 0x8d, 0, OPC_MODRM | OPC_WL, OPT_EA, OPT_REG))\n\nALT(DEF_ASM_OP2(les, 0xc4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lds, 0xc5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lss, 0x0fb2, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lfs, 0x0fb4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lgs, 0x0fb5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\n\n     /* arith */\nALT(DEF_ASM_OP2(addb, 0x00, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG)) /* XXX: use D bit ? */\nALT(DEF_ASM_OP2(addb, 0x02, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(addb, 0x04, 0, OPC_ARITH | OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(addb, 0x80, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(addw, 0x83, 0, OPC_ARITH | OPC_MODRM | OPC_WL, OPT_IM8S, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(testb, 0xa8, 0, OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(testb, 0xf6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP1(incw, 0x40, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(incb, 0xfe, 0, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(decw, 0x48, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(decb, 0xfe, 1, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(notb, 0xf6, 2, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(negb, 0xf6, 3, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(mulb, 0xf6, 4, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(imulb, 0xf6, 5, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(imulw, 0x0faf, 0, OPC_MODRM | OPC_WL, OPT_REG | OPT_EA, OPT_REG))\nALT(DEF_ASM_OP3(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW))\nALT(DEF_ASM_OP3(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW))\n\nALT(DEF_ASM_OP1(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\nALT(DEF_ASM_OP1(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\n\n     /* shifts */\nALT(DEF_ASM_OP2(rolb, 0xc0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_IM8, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(rolb, 0xd2, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_CL, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP1(rolb, 0xd0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP3(shldw, 0x0fa4, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fac, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\n\nALT(DEF_ASM_OP1(call, 0xff, 2, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(call, 0xe8, 0, OPC_JMP, OPT_ADDR))\nALT(DEF_ASM_OP1(jmp, 0xff, 4, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(jmp, 0xeb, 0, OPC_SHORTJMP | OPC_JMP, OPT_ADDR))\n\nALT(DEF_ASM_OP2(lcall, 0x9a, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(lcall, 0xff, 3, 0, OPT_EA))\nALT(DEF_ASM_OP2(ljmp, 0xea, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(ljmp, 0xff, 5, 0, OPT_EA))\n\nALT(DEF_ASM_OP1(int, 0xcd, 0, 0, OPT_IM8))\nALT(DEF_ASM_OP1(seto, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))\n    DEF_ASM_OP2(enter, 0xc8, 0, 0, OPT_IM16, OPT_IM8)\n    DEF_ASM_OP0(leave, 0xc9)\n    DEF_ASM_OP0(ret, 0xc3)\nALT(DEF_ASM_OP1(ret, 0xc2, 0, 0, OPT_IM16))\n    DEF_ASM_OP0(lret, 0xcb)\nALT(DEF_ASM_OP1(lret, 0xca, 0, 0, OPT_IM16))\n\nALT(DEF_ASM_OP1(jo, 0x70, 0, OPC_SHORTJMP | OPC_JMP | OPC_TEST, OPT_ADDR))\n    DEF_ASM_OP1(loopne, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopnz, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loope, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopz, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loop, 0xe2, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(jecxz, 0xe3, 0, OPC_SHORTJMP, OPT_ADDR)\n     \n     /* float */\n     /* specific fcomp handling */\nALT(DEF_ASM_OP0L(fcomp, 0xd8d9, 0, 0))\n\nALT(DEF_ASM_OP1(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP0L(fadd, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP0L(faddp, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(fadds, 0xd8, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiaddl, 0xda, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(faddl, 0xdc, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiadds, 0xde, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\n\n     DEF_ASM_OP0(fucompp, 0xdae9)\n     DEF_ASM_OP0(ftst, 0xd9e4)\n     DEF_ASM_OP0(fxam, 0xd9e5)\n     DEF_ASM_OP0(fld1, 0xd9e8)\n     DEF_ASM_OP0(fldl2t, 0xd9e9)\n     DEF_ASM_OP0(fldl2e, 0xd9ea)\n     DEF_ASM_OP0(fldpi, 0xd9eb)\n     DEF_ASM_OP0(fldlg2, 0xd9ec)\n     DEF_ASM_OP0(fldln2, 0xd9ed)\n     DEF_ASM_OP0(fldz, 0xd9ee)\n\n     DEF_ASM_OP0(f2xm1, 0xd9f0)\n     DEF_ASM_OP0(fyl2x, 0xd9f1)\n     DEF_ASM_OP0(fptan, 0xd9f2)\n     DEF_ASM_OP0(fpatan, 0xd9f3)\n     DEF_ASM_OP0(fxtract, 0xd9f4)\n     DEF_ASM_OP0(fprem1, 0xd9f5)\n     DEF_ASM_OP0(fdecstp, 0xd9f6)\n     DEF_ASM_OP0(fincstp, 0xd9f7)\n     DEF_ASM_OP0(fprem, 0xd9f8)\n     DEF_ASM_OP0(fyl2xp1, 0xd9f9)\n     DEF_ASM_OP0(fsqrt, 0xd9fa)\n     DEF_ASM_OP0(fsincos, 0xd9fb)\n     DEF_ASM_OP0(frndint, 0xd9fc)\n     DEF_ASM_OP0(fscale, 0xd9fd)\n     DEF_ASM_OP0(fsin, 0xd9fe)\n     DEF_ASM_OP0(fcos, 0xd9ff)\n     DEF_ASM_OP0(fchs, 0xd9e0)\n     DEF_ASM_OP0(fabs, 0xd9e1)\n     DEF_ASM_OP0(fninit, 0xdbe3)\n     DEF_ASM_OP0(fnclex, 0xdbe2)\n     DEF_ASM_OP0(fnop, 0xd9d0)\n     DEF_ASM_OP0(fwait, 0x9b)\n\n    /* fp load */\n    DEF_ASM_OP1(fld, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fldl, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(flds, 0xd9, 0, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fldl, 0xdd, 0, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fildl, 0xdb, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildq, 0xdf, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildll, 0xdf, 5, OPC_MODRM,OPT_EA)\n    DEF_ASM_OP1(fldt, 0xdb, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbld, 0xdf, 4, OPC_MODRM, OPT_EA)\n    \n    /* fp store */\n    DEF_ASM_OP1(fst, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fstl, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fsts, 0xd9, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstps, 0xd9, 3, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fstl, 0xdd, 2, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fstpl, 0xdd, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fist, 0xdf, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistp, 0xdf, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistl, 0xdb, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpl, 0xdb, 3, OPC_MODRM, OPT_EA)\n\n    DEF_ASM_OP1(fstp, 0xddd8, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fistpq, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpll, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstpt, 0xdb, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbstp, 0xdf, 6, OPC_MODRM, OPT_EA)\n\n    /* exchange */\n    DEF_ASM_OP0(fxch, 0xd9c9)\nALT(DEF_ASM_OP1(fxch, 0xd9c8, 0, OPC_REG, OPT_ST))\n\n    /* misc FPU */\n    DEF_ASM_OP1(fucom, 0xdde0, 0, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fucomp, 0xdde8, 0, OPC_REG, OPT_ST )\n\n    DEF_ASM_OP0L(finit, 0xdbe3, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fldcw, 0xd9, 5, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnstcw, 0xd9, 7, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstcw, 0xd9, 7, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP0(fnstsw, 0xdfe0)\nALT(DEF_ASM_OP1(fnstsw, 0xdfe0, 0, 0, OPT_EAX ))\nALT(DEF_ASM_OP1(fnstsw, 0xdd, 7, OPC_MODRM, OPT_EA ))\n    DEF_ASM_OP1(fstsw, 0xdfe0, 0, OPC_FWAIT, OPT_EAX )\nALT(DEF_ASM_OP0L(fstsw, 0xdfe0, 0, OPC_FWAIT))\nALT(DEF_ASM_OP1(fstsw, 0xdd, 7, OPC_MODRM | OPC_FWAIT, OPT_EA ))\n    DEF_ASM_OP0L(fclex, 0xdbe2, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fnstenv, 0xd9, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstenv, 0xd9, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(fldenv, 0xd9, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnsave, 0xdd, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fsave, 0xdd, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(frstor, 0xdd, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(ffree, 0xddc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(ffreep, 0xdfc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fxsave, 0x0fae, 0, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fxrstor, 0x0fae, 1, OPC_MODRM, OPT_EA )\n\n    /* segments */\n    DEF_ASM_OP2(arpl, 0x63, 0, OPC_MODRM, OPT_REG16, OPT_REG16 | OPT_EA)\n    DEF_ASM_OP2(lar, 0x0f02, 0, OPC_MODRM, OPT_REG32 | OPT_EA, OPT_REG32)\n    DEF_ASM_OP1(lgdt, 0x0f01, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lidt, 0x0f01, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lldt, 0x0f00, 2, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(lmsw, 0x0f01, 6, OPC_MODRM, OPT_EA | OPT_REG)\nALT(DEF_ASM_OP2(lslw, 0x0f03, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_REG))\n    DEF_ASM_OP1(ltr, 0x0f00, 3, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(sgdt, 0x0f01, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sidt, 0x0f01, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sldt, 0x0f00, 0, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(smsw, 0x0f01, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM, OPT_REG16| OPT_EA)\n    DEF_ASM_OP1(verr, 0x0f00, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(verw, 0x0f00, 5, OPC_MODRM, OPT_REG | OPT_EA)\n\n    /* 486 */\n    DEF_ASM_OP1(bswap, 0x0fc8, 0, OPC_REG, OPT_REG32 )\nALT(DEF_ASM_OP2(xaddb, 0x0fc0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\nALT(DEF_ASM_OP2(cmpxchgb, 0x0fb0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\n    DEF_ASM_OP1(invlpg, 0x0f01, 7, OPC_MODRM, OPT_EA )\n\n    DEF_ASM_OP2(boundl, 0x62, 0, OPC_MODRM, OPT_REG32, OPT_EA)\n    DEF_ASM_OP2(boundw, 0x62, 0, OPC_MODRM | OPC_D16, OPT_REG16, OPT_EA)\n\n    /* pentium */\n    DEF_ASM_OP1(cmpxchg8b, 0x0fc7, 1, OPC_MODRM, OPT_EA )\n    \n    /* pentium pro */\n    ALT(DEF_ASM_OP2(cmovo, 0x0f40, 0, OPC_MODRM | OPC_TEST, OPT_REG32 | OPT_EA, OPT_REG32))\n\n    DEF_ASM_OP2(fcmovb, 0xdac0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmove, 0xdac8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovbe, 0xdad0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovu, 0xdad8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnb, 0xdbc0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovne, 0xdbc8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnbe, 0xdbd0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnu, 0xdbd8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    DEF_ASM_OP2(fucomi, 0xdbe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomi, 0xdbf0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fucomip, 0xdfe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomip, 0xdff0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    /* mmx */\n    DEF_ASM_OP0(emms, 0x0f77) /* must be last OP0 */\n    DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_MMX )\nALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(movq, 0x0f6f, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(movq, 0x0f7f, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_MMX ))\n    DEF_ASM_OP2(packssdw, 0x0f6b, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packsswb, 0x0f63, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packuswb, 0x0f67, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddb, 0x0ffc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddw, 0x0ffd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddd, 0x0ffe, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsb, 0x0fec, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsw, 0x0fed, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusb, 0x0fdc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusw, 0x0fdd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pand, 0x0fdb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pandn, 0x0fdf, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqb, 0x0f74, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqw, 0x0f75, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqd, 0x0f76, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtb, 0x0f64, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtw, 0x0f65, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtd, 0x0f66, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmaddwd, 0x0ff5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmulhw, 0x0fe5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmullw, 0x0fd5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(por, 0x0feb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psllw, 0x0ff1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllw, 0x0f71, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(pslld, 0x0ff2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(pslld, 0x0f72, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psllq, 0x0ff3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllq, 0x0f73, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psraw, 0x0fe1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psraw, 0x0f71, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrad, 0x0fe2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrad, 0x0f72, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlw, 0x0fd1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlw, 0x0f71, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrld, 0x0fd2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrld, 0x0f72, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlq, 0x0fd3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlq, 0x0f73, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psubb, 0x0ff8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubw, 0x0ff9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubd, 0x0ffa, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsb, 0x0fe8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsw, 0x0fe9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusb, 0x0fd8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusw, 0x0fd9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhbw, 0x0f68, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhwd, 0x0f69, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhdq, 0x0f6a, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklbw, 0x0f60, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklwd, 0x0f61, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckldq, 0x0f62, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pxor, 0x0fef, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n\n#undef ALT\n#undef DEF_ASM_OP0\n#undef DEF_ASM_OP0L\n#undef DEF_ASM_OP1\n#undef DEF_ASM_OP2\n#undef DEF_ASM_OP3\n//---------------------------------------------------------------------------\n\n#define ALT(x)\n#define DEF_ASM_OP0(name, opcode)\n#define DEF_ASM_OP0L(name, opcode, group, instr_type) DEF_ASM(name)\n#define DEF_ASM_OP1(name, opcode, group, instr_type, op0) DEF_ASM(name)\n#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1) DEF_ASM(name)\n#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2) DEF_ASM(name)\n// njn: inlined i386-asm.h\n//#include \"i386-asm.h\"\n//---------------------------------------------------------------------------\n     DEF_ASM_OP0(pusha, 0x60) /* must be first OP0 */\n     DEF_ASM_OP0(popa, 0x61)\n     DEF_ASM_OP0(clc, 0xf8)\n     DEF_ASM_OP0(cld, 0xfc)\n     DEF_ASM_OP0(cli, 0xfa)\n     DEF_ASM_OP0(clts, 0x0f06)\n     DEF_ASM_OP0(cmc, 0xf5)\n     DEF_ASM_OP0(lahf, 0x9f)\n     DEF_ASM_OP0(sahf, 0x9e)\n     DEF_ASM_OP0(pushfl, 0x9c)\n     DEF_ASM_OP0(popfl, 0x9d)\n     DEF_ASM_OP0(pushf, 0x9c)\n     DEF_ASM_OP0(popf, 0x9d)\n     DEF_ASM_OP0(stc, 0xf9)\n     DEF_ASM_OP0(std, 0xfd)\n     DEF_ASM_OP0(sti, 0xfb)\n     DEF_ASM_OP0(aaa, 0x37)\n     DEF_ASM_OP0(aas, 0x3f)\n     DEF_ASM_OP0(daa, 0x27)\n     DEF_ASM_OP0(das, 0x2f)\n     DEF_ASM_OP0(aad, 0xd50a)\n     DEF_ASM_OP0(aam, 0xd40a)\n     DEF_ASM_OP0(cbw, 0x6698)\n     DEF_ASM_OP0(cwd, 0x6699)\n     DEF_ASM_OP0(cwde, 0x98)\n     DEF_ASM_OP0(cdq, 0x99)\n     DEF_ASM_OP0(cbtw, 0x6698)\n     DEF_ASM_OP0(cwtl, 0x98)\n     DEF_ASM_OP0(cwtd, 0x6699)\n     DEF_ASM_OP0(cltd, 0x99)\n     DEF_ASM_OP0(int3, 0xcc)\n     DEF_ASM_OP0(into, 0xce)\n     DEF_ASM_OP0(iret, 0xcf)\n     DEF_ASM_OP0(rsm, 0x0faa)\n     DEF_ASM_OP0(hlt, 0xf4)\n     DEF_ASM_OP0(wait, 0x9b)\n     DEF_ASM_OP0(nop, 0x90)\n     DEF_ASM_OP0(xlat, 0xd7)\n\n     /* strings */\nALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(insb, 0x6c, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(outsb, 0x6e, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(lodsb, 0xac, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(slodb, 0xac, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(movsb, 0xa4, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(smovb, 0xa4, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(scasb, 0xae, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sscab, 0xae, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(stosb, 0xaa, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sstob, 0xaa, 0, OPC_BWL))\n\n     /* bits */\n     \nALT(DEF_ASM_OP2(bsfw, 0x0fbc, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(bsrw, 0x0fbd, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\n\nALT(DEF_ASM_OP2(btw, 0x0fa3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btw, 0x0fba, 4, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btsw, 0x0fab, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btsw, 0x0fba, 5, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btrw, 0x0fb3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btrw, 0x0fba, 6, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btcw, 0x0fbb, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btcw, 0x0fba, 7, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\n     /* prefixes */\n     DEF_ASM_OP0(aword, 0x67)\n     DEF_ASM_OP0(addr16, 0x67)\n     DEF_ASM_OP0(word, 0x66)\n     DEF_ASM_OP0(data16, 0x66)\n     DEF_ASM_OP0(lock, 0xf0)\n     DEF_ASM_OP0(rep, 0xf3)\n     DEF_ASM_OP0(repe, 0xf3)\n     DEF_ASM_OP0(repz, 0xf3)\n     DEF_ASM_OP0(repne, 0xf2)\n     DEF_ASM_OP0(repnz, 0xf2)\n             \n     DEF_ASM_OP0(invd, 0x0f08)\n     DEF_ASM_OP0(wbinvd, 0x0f09)\n     DEF_ASM_OP0(cpuid, 0x0fa2)\n     DEF_ASM_OP0(wrmsr, 0x0f30)\n     DEF_ASM_OP0(rdtsc, 0x0f31)\n     DEF_ASM_OP0(rdmsr, 0x0f32)\n     DEF_ASM_OP0(rdpmc, 0x0f33)\n     DEF_ASM_OP0(ud2, 0x0f0b)\n\n     /* NOTE: we took the same order as gas opcode definition order */\nALT(DEF_ASM_OP2(movb, 0xa0, 0, OPC_BWL, OPT_ADDR, OPT_EAX))\nALT(DEF_ASM_OP2(movb, 0xa2, 0, OPC_BWL, OPT_EAX, OPT_ADDR))\nALT(DEF_ASM_OP2(movb, 0x88, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movb, 0x8a, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xb0, 0, OPC_REG | OPC_BWL, OPT_IM, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xc6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(movw, 0x8c, 0, OPC_MODRM | OPC_WL, OPT_SEG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movw, 0x8e, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_SEG))\n\nALT(DEF_ASM_OP2(movw, 0x0f20, 0, OPC_MODRM | OPC_WL, OPT_CR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f21, 0, OPC_MODRM | OPC_WL, OPT_DB, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f24, 0, OPC_MODRM | OPC_WL, OPT_TR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f22, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_CR))\nALT(DEF_ASM_OP2(movw, 0x0f23, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_DB))\nALT(DEF_ASM_OP2(movw, 0x0f26, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_TR))\n\nALT(DEF_ASM_OP2(movsbl, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movsbw, 0x0fbe, 0, OPC_MODRM | OPC_D16, OPT_REG8 | OPT_EA, OPT_REG16))\nALT(DEF_ASM_OP2(movswl, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movzbw, 0x0fb6, 0, OPC_MODRM | OPC_WL, OPT_REG8 | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(movzwl, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\n\nALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(pushw, 0xff, 6, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(pushw, 0x6a, 0, OPC_WL, OPT_IM8S))\nALT(DEF_ASM_OP1(pushw, 0x68, 0, OPC_WL, OPT_IM32))\nALT(DEF_ASM_OP1(pushw, 0x06, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(popw, 0x8f, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(popw, 0x07, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_REG, OPT_EAX))\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_EAX, OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\n\nALT(DEF_ASM_OP2(inb, 0xe4, 0, OPC_BWL, OPT_IM8, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xe4, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(inb, 0xec, 0, OPC_BWL, OPT_DX, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xec, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(outb, 0xe6, 0, OPC_BWL, OPT_EAX, OPT_IM8))\nALT(DEF_ASM_OP1(outb, 0xe6, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(outb, 0xee, 0, OPC_BWL, OPT_EAX, OPT_DX))\nALT(DEF_ASM_OP1(outb, 0xee, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(leaw, 0x8d, 0, OPC_MODRM | OPC_WL, OPT_EA, OPT_REG))\n\nALT(DEF_ASM_OP2(les, 0xc4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lds, 0xc5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lss, 0x0fb2, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lfs, 0x0fb4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lgs, 0x0fb5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\n\n     /* arith */\nALT(DEF_ASM_OP2(addb, 0x00, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG)) /* XXX: use D bit ? */\nALT(DEF_ASM_OP2(addb, 0x02, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(addb, 0x04, 0, OPC_ARITH | OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(addb, 0x80, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(addw, 0x83, 0, OPC_ARITH | OPC_MODRM | OPC_WL, OPT_IM8S, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(testb, 0xa8, 0, OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(testb, 0xf6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP1(incw, 0x40, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(incb, 0xfe, 0, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(decw, 0x48, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(decb, 0xfe, 1, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(notb, 0xf6, 2, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(negb, 0xf6, 3, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(mulb, 0xf6, 4, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(imulb, 0xf6, 5, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(imulw, 0x0faf, 0, OPC_MODRM | OPC_WL, OPT_REG | OPT_EA, OPT_REG))\nALT(DEF_ASM_OP3(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW))\nALT(DEF_ASM_OP3(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW))\n\nALT(DEF_ASM_OP1(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\nALT(DEF_ASM_OP1(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\n\n     /* shifts */\nALT(DEF_ASM_OP2(rolb, 0xc0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_IM8, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(rolb, 0xd2, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_CL, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP1(rolb, 0xd0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP3(shldw, 0x0fa4, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fac, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\n\nALT(DEF_ASM_OP1(call, 0xff, 2, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(call, 0xe8, 0, OPC_JMP, OPT_ADDR))\nALT(DEF_ASM_OP1(jmp, 0xff, 4, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(jmp, 0xeb, 0, OPC_SHORTJMP | OPC_JMP, OPT_ADDR))\n\nALT(DEF_ASM_OP2(lcall, 0x9a, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(lcall, 0xff, 3, 0, OPT_EA))\nALT(DEF_ASM_OP2(ljmp, 0xea, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(ljmp, 0xff, 5, 0, OPT_EA))\n\nALT(DEF_ASM_OP1(int, 0xcd, 0, 0, OPT_IM8))\nALT(DEF_ASM_OP1(seto, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))\n    DEF_ASM_OP2(enter, 0xc8, 0, 0, OPT_IM16, OPT_IM8)\n    DEF_ASM_OP0(leave, 0xc9)\n    DEF_ASM_OP0(ret, 0xc3)\nALT(DEF_ASM_OP1(ret, 0xc2, 0, 0, OPT_IM16))\n    DEF_ASM_OP0(lret, 0xcb)\nALT(DEF_ASM_OP1(lret, 0xca, 0, 0, OPT_IM16))\n\nALT(DEF_ASM_OP1(jo, 0x70, 0, OPC_SHORTJMP | OPC_JMP | OPC_TEST, OPT_ADDR))\n    DEF_ASM_OP1(loopne, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopnz, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loope, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopz, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loop, 0xe2, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(jecxz, 0xe3, 0, OPC_SHORTJMP, OPT_ADDR)\n     \n     /* float */\n     /* specific fcomp handling */\nALT(DEF_ASM_OP0L(fcomp, 0xd8d9, 0, 0))\n\nALT(DEF_ASM_OP1(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP0L(fadd, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP0L(faddp, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(fadds, 0xd8, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiaddl, 0xda, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(faddl, 0xdc, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiadds, 0xde, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\n\n     DEF_ASM_OP0(fucompp, 0xdae9)\n     DEF_ASM_OP0(ftst, 0xd9e4)\n     DEF_ASM_OP0(fxam, 0xd9e5)\n     DEF_ASM_OP0(fld1, 0xd9e8)\n     DEF_ASM_OP0(fldl2t, 0xd9e9)\n     DEF_ASM_OP0(fldl2e, 0xd9ea)\n     DEF_ASM_OP0(fldpi, 0xd9eb)\n     DEF_ASM_OP0(fldlg2, 0xd9ec)\n     DEF_ASM_OP0(fldln2, 0xd9ed)\n     DEF_ASM_OP0(fldz, 0xd9ee)\n\n     DEF_ASM_OP0(f2xm1, 0xd9f0)\n     DEF_ASM_OP0(fyl2x, 0xd9f1)\n     DEF_ASM_OP0(fptan, 0xd9f2)\n     DEF_ASM_OP0(fpatan, 0xd9f3)\n     DEF_ASM_OP0(fxtract, 0xd9f4)\n     DEF_ASM_OP0(fprem1, 0xd9f5)\n     DEF_ASM_OP0(fdecstp, 0xd9f6)\n     DEF_ASM_OP0(fincstp, 0xd9f7)\n     DEF_ASM_OP0(fprem, 0xd9f8)\n     DEF_ASM_OP0(fyl2xp1, 0xd9f9)\n     DEF_ASM_OP0(fsqrt, 0xd9fa)\n     DEF_ASM_OP0(fsincos, 0xd9fb)\n     DEF_ASM_OP0(frndint, 0xd9fc)\n     DEF_ASM_OP0(fscale, 0xd9fd)\n     DEF_ASM_OP0(fsin, 0xd9fe)\n     DEF_ASM_OP0(fcos, 0xd9ff)\n     DEF_ASM_OP0(fchs, 0xd9e0)\n     DEF_ASM_OP0(fabs, 0xd9e1)\n     DEF_ASM_OP0(fninit, 0xdbe3)\n     DEF_ASM_OP0(fnclex, 0xdbe2)\n     DEF_ASM_OP0(fnop, 0xd9d0)\n     DEF_ASM_OP0(fwait, 0x9b)\n\n    /* fp load */\n    DEF_ASM_OP1(fld, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fldl, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(flds, 0xd9, 0, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fldl, 0xdd, 0, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fildl, 0xdb, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildq, 0xdf, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildll, 0xdf, 5, OPC_MODRM,OPT_EA)\n    DEF_ASM_OP1(fldt, 0xdb, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbld, 0xdf, 4, OPC_MODRM, OPT_EA)\n    \n    /* fp store */\n    DEF_ASM_OP1(fst, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fstl, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fsts, 0xd9, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstps, 0xd9, 3, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fstl, 0xdd, 2, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fstpl, 0xdd, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fist, 0xdf, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistp, 0xdf, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistl, 0xdb, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpl, 0xdb, 3, OPC_MODRM, OPT_EA)\n\n    DEF_ASM_OP1(fstp, 0xddd8, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fistpq, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpll, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstpt, 0xdb, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbstp, 0xdf, 6, OPC_MODRM, OPT_EA)\n\n    /* exchange */\n    DEF_ASM_OP0(fxch, 0xd9c9)\nALT(DEF_ASM_OP1(fxch, 0xd9c8, 0, OPC_REG, OPT_ST))\n\n    /* misc FPU */\n    DEF_ASM_OP1(fucom, 0xdde0, 0, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fucomp, 0xdde8, 0, OPC_REG, OPT_ST )\n\n    DEF_ASM_OP0L(finit, 0xdbe3, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fldcw, 0xd9, 5, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnstcw, 0xd9, 7, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstcw, 0xd9, 7, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP0(fnstsw, 0xdfe0)\nALT(DEF_ASM_OP1(fnstsw, 0xdfe0, 0, 0, OPT_EAX ))\nALT(DEF_ASM_OP1(fnstsw, 0xdd, 7, OPC_MODRM, OPT_EA ))\n    DEF_ASM_OP1(fstsw, 0xdfe0, 0, OPC_FWAIT, OPT_EAX )\nALT(DEF_ASM_OP0L(fstsw, 0xdfe0, 0, OPC_FWAIT))\nALT(DEF_ASM_OP1(fstsw, 0xdd, 7, OPC_MODRM | OPC_FWAIT, OPT_EA ))\n    DEF_ASM_OP0L(fclex, 0xdbe2, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fnstenv, 0xd9, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstenv, 0xd9, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(fldenv, 0xd9, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnsave, 0xdd, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fsave, 0xdd, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(frstor, 0xdd, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(ffree, 0xddc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(ffreep, 0xdfc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fxsave, 0x0fae, 0, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fxrstor, 0x0fae, 1, OPC_MODRM, OPT_EA )\n\n    /* segments */\n    DEF_ASM_OP2(arpl, 0x63, 0, OPC_MODRM, OPT_REG16, OPT_REG16 | OPT_EA)\n    DEF_ASM_OP2(lar, 0x0f02, 0, OPC_MODRM, OPT_REG32 | OPT_EA, OPT_REG32)\n    DEF_ASM_OP1(lgdt, 0x0f01, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lidt, 0x0f01, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lldt, 0x0f00, 2, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(lmsw, 0x0f01, 6, OPC_MODRM, OPT_EA | OPT_REG)\nALT(DEF_ASM_OP2(lslw, 0x0f03, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_REG))\n    DEF_ASM_OP1(ltr, 0x0f00, 3, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(sgdt, 0x0f01, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sidt, 0x0f01, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sldt, 0x0f00, 0, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(smsw, 0x0f01, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM, OPT_REG16| OPT_EA)\n    DEF_ASM_OP1(verr, 0x0f00, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(verw, 0x0f00, 5, OPC_MODRM, OPT_REG | OPT_EA)\n\n    /* 486 */\n    DEF_ASM_OP1(bswap, 0x0fc8, 0, OPC_REG, OPT_REG32 )\nALT(DEF_ASM_OP2(xaddb, 0x0fc0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\nALT(DEF_ASM_OP2(cmpxchgb, 0x0fb0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\n    DEF_ASM_OP1(invlpg, 0x0f01, 7, OPC_MODRM, OPT_EA )\n\n    DEF_ASM_OP2(boundl, 0x62, 0, OPC_MODRM, OPT_REG32, OPT_EA)\n    DEF_ASM_OP2(boundw, 0x62, 0, OPC_MODRM | OPC_D16, OPT_REG16, OPT_EA)\n\n    /* pentium */\n    DEF_ASM_OP1(cmpxchg8b, 0x0fc7, 1, OPC_MODRM, OPT_EA )\n    \n    /* pentium pro */\n    ALT(DEF_ASM_OP2(cmovo, 0x0f40, 0, OPC_MODRM | OPC_TEST, OPT_REG32 | OPT_EA, OPT_REG32))\n\n    DEF_ASM_OP2(fcmovb, 0xdac0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmove, 0xdac8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovbe, 0xdad0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovu, 0xdad8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnb, 0xdbc0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovne, 0xdbc8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnbe, 0xdbd0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnu, 0xdbd8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    DEF_ASM_OP2(fucomi, 0xdbe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomi, 0xdbf0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fucomip, 0xdfe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomip, 0xdff0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    /* mmx */\n    DEF_ASM_OP0(emms, 0x0f77) /* must be last OP0 */\n    DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_MMX )\nALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(movq, 0x0f6f, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(movq, 0x0f7f, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_MMX ))\n    DEF_ASM_OP2(packssdw, 0x0f6b, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packsswb, 0x0f63, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packuswb, 0x0f67, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddb, 0x0ffc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddw, 0x0ffd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddd, 0x0ffe, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsb, 0x0fec, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsw, 0x0fed, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusb, 0x0fdc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusw, 0x0fdd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pand, 0x0fdb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pandn, 0x0fdf, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqb, 0x0f74, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqw, 0x0f75, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqd, 0x0f76, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtb, 0x0f64, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtw, 0x0f65, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtd, 0x0f66, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmaddwd, 0x0ff5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmulhw, 0x0fe5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmullw, 0x0fd5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(por, 0x0feb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psllw, 0x0ff1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllw, 0x0f71, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(pslld, 0x0ff2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(pslld, 0x0f72, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psllq, 0x0ff3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllq, 0x0f73, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psraw, 0x0fe1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psraw, 0x0f71, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrad, 0x0fe2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrad, 0x0f72, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlw, 0x0fd1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlw, 0x0f71, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrld, 0x0fd2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrld, 0x0f72, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlq, 0x0fd3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlq, 0x0f73, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psubb, 0x0ff8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubw, 0x0ff9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubd, 0x0ffa, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsb, 0x0fe8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsw, 0x0fe9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusb, 0x0fd8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusw, 0x0fd9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhbw, 0x0f68, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhwd, 0x0f69, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhdq, 0x0f6a, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklbw, 0x0f60, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklwd, 0x0f61, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckldq, 0x0f62, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pxor, 0x0fef, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n\n#undef ALT\n#undef DEF_ASM_OP0\n#undef DEF_ASM_OP0L\n#undef DEF_ASM_OP1\n#undef DEF_ASM_OP2\n#undef DEF_ASM_OP3\n//---------------------------------------------------------------------------\n\n#endif\n//---------------------------------------------------------------------------\n#undef DEF\n};\n\nstatic const char tcc_keywords[] = \n#define DEF(id, str) str \"\\0\"\n// njn: inlined tcctok.h\n//#include \"tcctok.h\"\n//---------------------------------------------------------------------------\n/* keywords */\n     DEF(TOK_INT, \"int\")\n     DEF(TOK_VOID, \"void\")\n     DEF(TOK_CHAR, \"char\")\n     DEF(TOK_IF, \"if\")\n     DEF(TOK_ELSE, \"else\")\n     DEF(TOK_WHILE, \"while\")\n     DEF(TOK_BREAK, \"break\")\n     DEF(TOK_RETURN, \"return\")\n     DEF(TOK_FOR, \"for\")\n     DEF(TOK_EXTERN, \"extern\")\n     DEF(TOK_STATIC, \"static\")\n     DEF(TOK_UNSIGNED, \"unsigned\")\n     DEF(TOK_GOTO, \"goto\")\n     DEF(TOK_DO, \"do\")\n     DEF(TOK_CONTINUE, \"continue\")\n     DEF(TOK_SWITCH, \"switch\")\n     DEF(TOK_CASE, \"case\")\n\n     DEF(TOK_CONST1, \"const\")\n     DEF(TOK_CONST2, \"__const\") /* gcc keyword */\n     DEF(TOK_CONST3, \"__const__\") /* gcc keyword */\n     DEF(TOK_VOLATILE1, \"volatile\")\n     DEF(TOK_VOLATILE2, \"__volatile\") /* gcc keyword */\n     DEF(TOK_VOLATILE3, \"__volatile__\") /* gcc keyword */\n     DEF(TOK_LONG, \"long\")\n     DEF(TOK_REGISTER, \"register\")\n     DEF(TOK_SIGNED1, \"signed\")\n     DEF(TOK_SIGNED2, \"__signed\") /* gcc keyword */\n     DEF(TOK_SIGNED3, \"__signed__\") /* gcc keyword */\n     DEF(TOK_AUTO, \"auto\")\n     DEF(TOK_INLINE1, \"inline\")\n     DEF(TOK_INLINE2, \"__inline\") /* gcc keyword */\n     DEF(TOK_INLINE3, \"__inline__\") /* gcc keyword */\n     DEF(TOK_RESTRICT1, \"restrict\")\n     DEF(TOK_RESTRICT2, \"__restrict\")\n     DEF(TOK_RESTRICT3, \"__restrict__\")\n     DEF(TOK_EXTENSION, \"__extension__\") /* gcc keyword */\n     \n     DEF(TOK_FLOAT, \"float\")\n     DEF(TOK_DOUBLE, \"double\")\n     DEF(TOK_BOOL, \"_Bool\")\n     DEF(TOK_SHORT, \"short\")\n     DEF(TOK_STRUCT, \"struct\")\n     DEF(TOK_UNION, \"union\")\n     DEF(TOK_TYPEDEF, \"typedef\")\n     DEF(TOK_DEFAULT, \"default\")\n     DEF(TOK_ENUM, \"enum\")\n     DEF(TOK_SIZEOF, \"sizeof\")\n     DEF(TOK_ATTRIBUTE1, \"__attribute\")\n     DEF(TOK_ATTRIBUTE2, \"__attribute__\")\n     DEF(TOK_ALIGNOF1, \"__alignof\")\n     DEF(TOK_ALIGNOF2, \"__alignof__\")\n     DEF(TOK_TYPEOF1, \"typeof\")\n     DEF(TOK_TYPEOF2, \"__typeof\")\n     DEF(TOK_TYPEOF3, \"__typeof__\")\n     DEF(TOK_LABEL, \"__label__\")\n     DEF(TOK_ASM1, \"asm\")\n     DEF(TOK_ASM2, \"__asm\")\n     DEF(TOK_ASM3, \"__asm__\")\n\n/*********************************************************************/\n/* the following are not keywords. They are included to ease parsing */\n/* preprocessor only */\n     DEF(TOK_DEFINE, \"define\")\n     DEF(TOK_INCLUDE, \"include\")\n     DEF(TOK_INCLUDE_NEXT, \"include_next\")\n     DEF(TOK_IFDEF, \"ifdef\")\n     DEF(TOK_IFNDEF, \"ifndef\")\n     DEF(TOK_ELIF, \"elif\")\n     DEF(TOK_ENDIF, \"endif\")\n     DEF(TOK_DEFINED, \"defined\")\n     DEF(TOK_UNDEF, \"undef\")\n     DEF(TOK_ERROR, \"error\")\n     DEF(TOK_WARNING, \"warning\")\n     DEF(TOK_LINE, \"line\")\n     DEF(TOK_PRAGMA, \"pragma\")\n     DEF(TOK___LINE__, \"__LINE__\")\n     DEF(TOK___FILE__, \"__FILE__\")\n     DEF(TOK___DATE__, \"__DATE__\")\n     DEF(TOK___TIME__, \"__TIME__\")\n     DEF(TOK___FUNCTION__, \"__FUNCTION__\")\n     DEF(TOK___VA_ARGS__, \"__VA_ARGS__\")\n     \n/* special identifiers */\n     DEF(TOK___FUNC__, \"__func__\")\n     \n/* attribute identifiers */\n/* XXX: handle all tokens generically since speed is not critical */\n     DEF(TOK_SECTION1, \"section\")\n     DEF(TOK_SECTION2, \"__section__\")\n     DEF(TOK_ALIGNED1, \"aligned\")\n     DEF(TOK_ALIGNED2, \"__aligned__\")\n     DEF(TOK_PACKED1, \"packed\")\n     DEF(TOK_PACKED2, \"__packed__\")\n     DEF(TOK_UNUSED1, \"unused\")\n     DEF(TOK_UNUSED2, \"__unused__\")\n     DEF(TOK_CDECL1, \"cdecl\")\n     DEF(TOK_CDECL2, \"__cdecl\")\n     DEF(TOK_CDECL3, \"__cdecl__\")\n     DEF(TOK_STDCALL1, \"stdcall\")\n     DEF(TOK_STDCALL2, \"__stdcall\")\n     DEF(TOK_STDCALL3, \"__stdcall__\")\n     DEF(TOK_DLLEXPORT, \"dllexport\")\n     DEF(TOK_NORETURN1, \"noreturn\")\n     DEF(TOK_NORETURN2, \"__noreturn__\")\n     DEF(TOK_builtin_types_compatible_p, \"__builtin_types_compatible_p\")\n     DEF(TOK_builtin_constant_p, \"__builtin_constant_p\")\n     DEF(TOK_REGPARM1, \"regparm\")\n     DEF(TOK_REGPARM2, \"__regparm__\")\n\n/* pragma */\n     DEF(TOK_pack, \"pack\")\n#if !defined(TCC_TARGET_I386)\n     /* already defined for assembler */\n     DEF(TOK_ASM_push, \"push\")\n     DEF(TOK_ASM_pop, \"pop\")\n#endif\n\n/* builtin functions or variables */\n     DEF(TOK_memcpy, \"memcpy\")\n     DEF(TOK_memset, \"memset\")\n     DEF(TOK_alloca, \"alloca\")\n     DEF(TOK___divdi3, \"__divdi3\")\n     DEF(TOK___moddi3, \"__moddi3\")\n     DEF(TOK___udivdi3, \"__udivdi3\")\n     DEF(TOK___umoddi3, \"__umoddi3\")\n#if defined(TCC_TARGET_ARM)\n     DEF(TOK___divsi3, \"__divsi3\")\n     DEF(TOK___modsi3, \"__modsi3\")\n     DEF(TOK___udivsi3, \"__udivsi3\")\n     DEF(TOK___umodsi3, \"__umodsi3\")\n     DEF(TOK___sardi3, \"__ashrdi3\")\n     DEF(TOK___shrdi3, \"__lshrdi3\")\n     DEF(TOK___shldi3, \"__ashldi3\")\n     DEF(TOK___slltold, \"__slltold\")\n     DEF(TOK___fixunssfsi, \"__fixunssfsi\")\n     DEF(TOK___fixunsdfsi, \"__fixunsdfsi\")\n     DEF(TOK___fixunsxfsi, \"__fixunsxfsi\")\n     DEF(TOK___fixsfdi, \"__fixsfdi\")\n     DEF(TOK___fixdfdi, \"__fixdfdi\")\n     DEF(TOK___fixxfdi, \"__fixxfdi\")\n#elif defined(TCC_TARGET_C67)\n     DEF(TOK__divi, \"_divi\")\n     DEF(TOK__divu, \"_divu\")\n     DEF(TOK__divf, \"_divf\")\n     DEF(TOK__divd, \"_divd\")\n     DEF(TOK__remi, \"_remi\")\n     DEF(TOK__remu, \"_remu\")\n     DEF(TOK___sardi3, \"__sardi3\")\n     DEF(TOK___shrdi3, \"__shrdi3\")\n     DEF(TOK___shldi3, \"__shldi3\")\n#else\n     /* XXX: same names on i386 ? */\n     DEF(TOK___sardi3, \"__sardi3\")\n     DEF(TOK___shrdi3, \"__shrdi3\")\n     DEF(TOK___shldi3, \"__shldi3\")\n#endif\n     DEF(TOK___tcc_int_fpu_control, \"__tcc_int_fpu_control\")\n     DEF(TOK___tcc_fpu_control, \"__tcc_fpu_control\")\n     DEF(TOK___ulltof, \"__ulltof\")\n     DEF(TOK___ulltod, \"__ulltod\")\n     DEF(TOK___ulltold, \"__ulltold\")\n     DEF(TOK___fixunssfdi, \"__fixunssfdi\")\n     DEF(TOK___fixunsdfdi, \"__fixunsdfdi\")\n     DEF(TOK___fixunsxfdi, \"__fixunsxfdi\")\n     DEF(TOK___chkstk, \"__chkstk\")\n\n/* bound checking symbols */\n#ifdef CONFIG_TCC_BCHECK\n     DEF(TOK___bound_ptr_add, \"__bound_ptr_add\")\n     DEF(TOK___bound_ptr_indir1, \"__bound_ptr_indir1\")\n     DEF(TOK___bound_ptr_indir2, \"__bound_ptr_indir2\")\n     DEF(TOK___bound_ptr_indir4, \"__bound_ptr_indir4\")\n     DEF(TOK___bound_ptr_indir8, \"__bound_ptr_indir8\")\n     DEF(TOK___bound_ptr_indir12, \"__bound_ptr_indir12\")\n     DEF(TOK___bound_ptr_indir16, \"__bound_ptr_indir16\")\n     DEF(TOK___bound_local_new, \"__bound_local_new\")\n     DEF(TOK___bound_local_delete, \"__bound_local_delete\")\n     DEF(TOK_malloc, \"malloc\")\n     DEF(TOK_free, \"free\")\n     DEF(TOK_realloc, \"realloc\")\n     DEF(TOK_memalign, \"memalign\")\n     DEF(TOK_calloc, \"calloc\")\n     DEF(TOK_memmove, \"memmove\")\n     DEF(TOK_strlen, \"strlen\")\n     DEF(TOK_strcpy, \"strcpy\")\n#endif\n\n/* Tiny Assembler */\n\n DEF_ASM(byte)\n DEF_ASM(align)\n DEF_ASM(skip)\n DEF_ASM(space)\n DEF_ASM(string)\n DEF_ASM(asciz)\n DEF_ASM(ascii)\n DEF_ASM(globl)\n DEF_ASM(global)\n DEF_ASM(text)\n DEF_ASM(data)\n DEF_ASM(bss)\n DEF_ASM(previous)\n DEF_ASM(fill)\n DEF_ASM(org)\n DEF_ASM(quad)\n\n#ifdef TCC_TARGET_I386\n\n/* WARNING: relative order of tokens is important. */\n DEF_ASM(al)\n DEF_ASM(cl)\n DEF_ASM(dl)\n DEF_ASM(bl)\n DEF_ASM(ah)\n DEF_ASM(ch)\n DEF_ASM(dh)\n DEF_ASM(bh)\n DEF_ASM(ax)\n DEF_ASM(cx)\n DEF_ASM(dx)\n DEF_ASM(bx)\n DEF_ASM(sp)\n DEF_ASM(bp)\n DEF_ASM(si)\n DEF_ASM(di)\n DEF_ASM(eax)\n DEF_ASM(ecx)\n DEF_ASM(edx)\n DEF_ASM(ebx)\n DEF_ASM(esp)\n DEF_ASM(ebp)\n DEF_ASM(esi)\n DEF_ASM(edi)\n DEF_ASM(mm0)\n DEF_ASM(mm1)\n DEF_ASM(mm2)\n DEF_ASM(mm3)\n DEF_ASM(mm4)\n DEF_ASM(mm5)\n DEF_ASM(mm6)\n DEF_ASM(mm7)\n DEF_ASM(xmm0)\n DEF_ASM(xmm1)\n DEF_ASM(xmm2)\n DEF_ASM(xmm3)\n DEF_ASM(xmm4)\n DEF_ASM(xmm5)\n DEF_ASM(xmm6)\n DEF_ASM(xmm7)\n DEF_ASM(cr0)\n DEF_ASM(cr1)\n DEF_ASM(cr2)\n DEF_ASM(cr3)\n DEF_ASM(cr4)\n DEF_ASM(cr5)\n DEF_ASM(cr6)\n DEF_ASM(cr7)\n DEF_ASM(tr0)\n DEF_ASM(tr1)\n DEF_ASM(tr2)\n DEF_ASM(tr3)\n DEF_ASM(tr4)\n DEF_ASM(tr5)\n DEF_ASM(tr6)\n DEF_ASM(tr7)\n DEF_ASM(db0)\n DEF_ASM(db1)\n DEF_ASM(db2)\n DEF_ASM(db3)\n DEF_ASM(db4)\n DEF_ASM(db5)\n DEF_ASM(db6)\n DEF_ASM(db7)\n DEF_ASM(dr0)\n DEF_ASM(dr1)\n DEF_ASM(dr2)\n DEF_ASM(dr3)\n DEF_ASM(dr4)\n DEF_ASM(dr5)\n DEF_ASM(dr6)\n DEF_ASM(dr7)\n DEF_ASM(es)\n DEF_ASM(cs)\n DEF_ASM(ss)\n DEF_ASM(ds)\n DEF_ASM(fs)\n DEF_ASM(gs)\n DEF_ASM(st)\n\n DEF_BWL(mov)\n\n /* generic two operands */\n DEF_BWL(add)\n DEF_BWL(or)\n DEF_BWL(adc)\n DEF_BWL(sbb)\n DEF_BWL(and)\n DEF_BWL(sub)\n DEF_BWL(xor)\n DEF_BWL(cmp)\n\n /* unary ops */\n DEF_BWL(inc)\n DEF_BWL(dec)\n DEF_BWL(not)\n DEF_BWL(neg)\n DEF_BWL(mul)\n DEF_BWL(imul)\n DEF_BWL(div)\n DEF_BWL(idiv)\n\n DEF_BWL(xchg)\n DEF_BWL(test)\n\n /* shifts */\n DEF_BWL(rol)\n DEF_BWL(ror)\n DEF_BWL(rcl)\n DEF_BWL(rcr)\n DEF_BWL(shl)\n DEF_BWL(shr)\n DEF_BWL(sar)\n\n DEF_ASM(shldw)\n DEF_ASM(shldl)\n DEF_ASM(shld)\n DEF_ASM(shrdw)\n DEF_ASM(shrdl)\n DEF_ASM(shrd)\n\n DEF_ASM(pushw)\n DEF_ASM(pushl)\n DEF_ASM(push)\n DEF_ASM(popw)\n DEF_ASM(popl)\n DEF_ASM(pop)\n DEF_BWL(in)\n DEF_BWL(out)\n\n DEF_WL(movzb)\n\n DEF_ASM(movzwl)\n DEF_ASM(movsbw)\n DEF_ASM(movsbl)\n DEF_ASM(movswl)\n\n DEF_WL(lea) \n\n DEF_ASM(les) \n DEF_ASM(lds) \n DEF_ASM(lss) \n DEF_ASM(lfs) \n DEF_ASM(lgs) \n\n DEF_ASM(call)\n DEF_ASM(jmp)\n DEF_ASM(lcall)\n DEF_ASM(ljmp)\n \n DEF_ASMTEST(j)\n\n DEF_ASMTEST(set)\n DEF_ASMTEST(cmov)\n\n DEF_WL(bsf)\n DEF_WL(bsr)\n DEF_WL(bt)\n DEF_WL(bts)\n DEF_WL(btr)\n DEF_WL(btc)\n\n DEF_WL(lsl)\n\n /* generic FP ops */\n DEF_FP(add)\n DEF_FP(mul)\n\n DEF_ASM(fcom)\n DEF_ASM(fcom_1) /* non existent op, just to have a regular table */\n DEF_FP1(com)\n\n DEF_FP(comp)\n DEF_FP(sub)\n DEF_FP(subr)\n DEF_FP(div)\n DEF_FP(divr)\n\n DEF_BWL(xadd)\n DEF_BWL(cmpxchg)\n\n /* string ops */\n DEF_BWL(cmps)\n DEF_BWL(scmp)\n DEF_BWL(ins)\n DEF_BWL(outs)\n DEF_BWL(lods)\n DEF_BWL(slod)\n DEF_BWL(movs)\n DEF_BWL(smov)\n DEF_BWL(scas)\n DEF_BWL(ssca)\n DEF_BWL(stos)\n DEF_BWL(ssto)\n\n /* generic asm ops */\n\n#define ALT(x)\n#define DEF_ASM_OP0(name, opcode) DEF_ASM(name)\n#define DEF_ASM_OP0L(name, opcode, group, instr_type)\n#define DEF_ASM_OP1(name, opcode, group, instr_type, op0)\n#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1)\n#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2)\n// njn: inlined i386-asm.h\n//#include \"i386-asm.h\"\n//---------------------------------------------------------------------------\n     DEF_ASM_OP0(pusha, 0x60) /* must be first OP0 */\n     DEF_ASM_OP0(popa, 0x61)\n     DEF_ASM_OP0(clc, 0xf8)\n     DEF_ASM_OP0(cld, 0xfc)\n     DEF_ASM_OP0(cli, 0xfa)\n     DEF_ASM_OP0(clts, 0x0f06)\n     DEF_ASM_OP0(cmc, 0xf5)\n     DEF_ASM_OP0(lahf, 0x9f)\n     DEF_ASM_OP0(sahf, 0x9e)\n     DEF_ASM_OP0(pushfl, 0x9c)\n     DEF_ASM_OP0(popfl, 0x9d)\n     DEF_ASM_OP0(pushf, 0x9c)\n     DEF_ASM_OP0(popf, 0x9d)\n     DEF_ASM_OP0(stc, 0xf9)\n     DEF_ASM_OP0(std, 0xfd)\n     DEF_ASM_OP0(sti, 0xfb)\n     DEF_ASM_OP0(aaa, 0x37)\n     DEF_ASM_OP0(aas, 0x3f)\n     DEF_ASM_OP0(daa, 0x27)\n     DEF_ASM_OP0(das, 0x2f)\n     DEF_ASM_OP0(aad, 0xd50a)\n     DEF_ASM_OP0(aam, 0xd40a)\n     DEF_ASM_OP0(cbw, 0x6698)\n     DEF_ASM_OP0(cwd, 0x6699)\n     DEF_ASM_OP0(cwde, 0x98)\n     DEF_ASM_OP0(cdq, 0x99)\n     DEF_ASM_OP0(cbtw, 0x6698)\n     DEF_ASM_OP0(cwtl, 0x98)\n     DEF_ASM_OP0(cwtd, 0x6699)\n     DEF_ASM_OP0(cltd, 0x99)\n     DEF_ASM_OP0(int3, 0xcc)\n     DEF_ASM_OP0(into, 0xce)\n     DEF_ASM_OP0(iret, 0xcf)\n     DEF_ASM_OP0(rsm, 0x0faa)\n     DEF_ASM_OP0(hlt, 0xf4)\n     DEF_ASM_OP0(wait, 0x9b)\n     DEF_ASM_OP0(nop, 0x90)\n     DEF_ASM_OP0(xlat, 0xd7)\n\n     /* strings */\nALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(insb, 0x6c, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(outsb, 0x6e, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(lodsb, 0xac, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(slodb, 0xac, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(movsb, 0xa4, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(smovb, 0xa4, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(scasb, 0xae, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sscab, 0xae, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(stosb, 0xaa, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sstob, 0xaa, 0, OPC_BWL))\n\n     /* bits */\n     \nALT(DEF_ASM_OP2(bsfw, 0x0fbc, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(bsrw, 0x0fbd, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\n\nALT(DEF_ASM_OP2(btw, 0x0fa3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btw, 0x0fba, 4, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btsw, 0x0fab, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btsw, 0x0fba, 5, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btrw, 0x0fb3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btrw, 0x0fba, 6, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btcw, 0x0fbb, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btcw, 0x0fba, 7, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\n     /* prefixes */\n     DEF_ASM_OP0(aword, 0x67)\n     DEF_ASM_OP0(addr16, 0x67)\n     DEF_ASM_OP0(word, 0x66)\n     DEF_ASM_OP0(data16, 0x66)\n     DEF_ASM_OP0(lock, 0xf0)\n     DEF_ASM_OP0(rep, 0xf3)\n     DEF_ASM_OP0(repe, 0xf3)\n     DEF_ASM_OP0(repz, 0xf3)\n     DEF_ASM_OP0(repne, 0xf2)\n     DEF_ASM_OP0(repnz, 0xf2)\n             \n     DEF_ASM_OP0(invd, 0x0f08)\n     DEF_ASM_OP0(wbinvd, 0x0f09)\n     DEF_ASM_OP0(cpuid, 0x0fa2)\n     DEF_ASM_OP0(wrmsr, 0x0f30)\n     DEF_ASM_OP0(rdtsc, 0x0f31)\n     DEF_ASM_OP0(rdmsr, 0x0f32)\n     DEF_ASM_OP0(rdpmc, 0x0f33)\n     DEF_ASM_OP0(ud2, 0x0f0b)\n\n     /* NOTE: we took the same order as gas opcode definition order */\nALT(DEF_ASM_OP2(movb, 0xa0, 0, OPC_BWL, OPT_ADDR, OPT_EAX))\nALT(DEF_ASM_OP2(movb, 0xa2, 0, OPC_BWL, OPT_EAX, OPT_ADDR))\nALT(DEF_ASM_OP2(movb, 0x88, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movb, 0x8a, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xb0, 0, OPC_REG | OPC_BWL, OPT_IM, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xc6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(movw, 0x8c, 0, OPC_MODRM | OPC_WL, OPT_SEG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movw, 0x8e, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_SEG))\n\nALT(DEF_ASM_OP2(movw, 0x0f20, 0, OPC_MODRM | OPC_WL, OPT_CR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f21, 0, OPC_MODRM | OPC_WL, OPT_DB, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f24, 0, OPC_MODRM | OPC_WL, OPT_TR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f22, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_CR))\nALT(DEF_ASM_OP2(movw, 0x0f23, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_DB))\nALT(DEF_ASM_OP2(movw, 0x0f26, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_TR))\n\nALT(DEF_ASM_OP2(movsbl, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movsbw, 0x0fbe, 0, OPC_MODRM | OPC_D16, OPT_REG8 | OPT_EA, OPT_REG16))\nALT(DEF_ASM_OP2(movswl, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movzbw, 0x0fb6, 0, OPC_MODRM | OPC_WL, OPT_REG8 | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(movzwl, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\n\nALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(pushw, 0xff, 6, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(pushw, 0x6a, 0, OPC_WL, OPT_IM8S))\nALT(DEF_ASM_OP1(pushw, 0x68, 0, OPC_WL, OPT_IM32))\nALT(DEF_ASM_OP1(pushw, 0x06, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(popw, 0x8f, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(popw, 0x07, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_REG, OPT_EAX))\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_EAX, OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\n\nALT(DEF_ASM_OP2(inb, 0xe4, 0, OPC_BWL, OPT_IM8, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xe4, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(inb, 0xec, 0, OPC_BWL, OPT_DX, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xec, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(outb, 0xe6, 0, OPC_BWL, OPT_EAX, OPT_IM8))\nALT(DEF_ASM_OP1(outb, 0xe6, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(outb, 0xee, 0, OPC_BWL, OPT_EAX, OPT_DX))\nALT(DEF_ASM_OP1(outb, 0xee, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(leaw, 0x8d, 0, OPC_MODRM | OPC_WL, OPT_EA, OPT_REG))\n\nALT(DEF_ASM_OP2(les, 0xc4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lds, 0xc5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lss, 0x0fb2, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lfs, 0x0fb4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lgs, 0x0fb5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\n\n     /* arith */\nALT(DEF_ASM_OP2(addb, 0x00, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG)) /* XXX: use D bit ? */\nALT(DEF_ASM_OP2(addb, 0x02, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(addb, 0x04, 0, OPC_ARITH | OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(addb, 0x80, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(addw, 0x83, 0, OPC_ARITH | OPC_MODRM | OPC_WL, OPT_IM8S, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(testb, 0xa8, 0, OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(testb, 0xf6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP1(incw, 0x40, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(incb, 0xfe, 0, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(decw, 0x48, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(decb, 0xfe, 1, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(notb, 0xf6, 2, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(negb, 0xf6, 3, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(mulb, 0xf6, 4, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(imulb, 0xf6, 5, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(imulw, 0x0faf, 0, OPC_MODRM | OPC_WL, OPT_REG | OPT_EA, OPT_REG))\nALT(DEF_ASM_OP3(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW))\nALT(DEF_ASM_OP3(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW))\n\nALT(DEF_ASM_OP1(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\nALT(DEF_ASM_OP1(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\n\n     /* shifts */\nALT(DEF_ASM_OP2(rolb, 0xc0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_IM8, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(rolb, 0xd2, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_CL, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP1(rolb, 0xd0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP3(shldw, 0x0fa4, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fac, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\n\nALT(DEF_ASM_OP1(call, 0xff, 2, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(call, 0xe8, 0, OPC_JMP, OPT_ADDR))\nALT(DEF_ASM_OP1(jmp, 0xff, 4, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(jmp, 0xeb, 0, OPC_SHORTJMP | OPC_JMP, OPT_ADDR))\n\nALT(DEF_ASM_OP2(lcall, 0x9a, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(lcall, 0xff, 3, 0, OPT_EA))\nALT(DEF_ASM_OP2(ljmp, 0xea, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(ljmp, 0xff, 5, 0, OPT_EA))\n\nALT(DEF_ASM_OP1(int, 0xcd, 0, 0, OPT_IM8))\nALT(DEF_ASM_OP1(seto, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))\n    DEF_ASM_OP2(enter, 0xc8, 0, 0, OPT_IM16, OPT_IM8)\n    DEF_ASM_OP0(leave, 0xc9)\n    DEF_ASM_OP0(ret, 0xc3)\nALT(DEF_ASM_OP1(ret, 0xc2, 0, 0, OPT_IM16))\n    DEF_ASM_OP0(lret, 0xcb)\nALT(DEF_ASM_OP1(lret, 0xca, 0, 0, OPT_IM16))\n\nALT(DEF_ASM_OP1(jo, 0x70, 0, OPC_SHORTJMP | OPC_JMP | OPC_TEST, OPT_ADDR))\n    DEF_ASM_OP1(loopne, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopnz, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loope, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopz, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loop, 0xe2, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(jecxz, 0xe3, 0, OPC_SHORTJMP, OPT_ADDR)\n     \n     /* float */\n     /* specific fcomp handling */\nALT(DEF_ASM_OP0L(fcomp, 0xd8d9, 0, 0))\n\nALT(DEF_ASM_OP1(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP0L(fadd, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP0L(faddp, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(fadds, 0xd8, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiaddl, 0xda, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(faddl, 0xdc, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiadds, 0xde, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\n\n     DEF_ASM_OP0(fucompp, 0xdae9)\n     DEF_ASM_OP0(ftst, 0xd9e4)\n     DEF_ASM_OP0(fxam, 0xd9e5)\n     DEF_ASM_OP0(fld1, 0xd9e8)\n     DEF_ASM_OP0(fldl2t, 0xd9e9)\n     DEF_ASM_OP0(fldl2e, 0xd9ea)\n     DEF_ASM_OP0(fldpi, 0xd9eb)\n     DEF_ASM_OP0(fldlg2, 0xd9ec)\n     DEF_ASM_OP0(fldln2, 0xd9ed)\n     DEF_ASM_OP0(fldz, 0xd9ee)\n\n     DEF_ASM_OP0(f2xm1, 0xd9f0)\n     DEF_ASM_OP0(fyl2x, 0xd9f1)\n     DEF_ASM_OP0(fptan, 0xd9f2)\n     DEF_ASM_OP0(fpatan, 0xd9f3)\n     DEF_ASM_OP0(fxtract, 0xd9f4)\n     DEF_ASM_OP0(fprem1, 0xd9f5)\n     DEF_ASM_OP0(fdecstp, 0xd9f6)\n     DEF_ASM_OP0(fincstp, 0xd9f7)\n     DEF_ASM_OP0(fprem, 0xd9f8)\n     DEF_ASM_OP0(fyl2xp1, 0xd9f9)\n     DEF_ASM_OP0(fsqrt, 0xd9fa)\n     DEF_ASM_OP0(fsincos, 0xd9fb)\n     DEF_ASM_OP0(frndint, 0xd9fc)\n     DEF_ASM_OP0(fscale, 0xd9fd)\n     DEF_ASM_OP0(fsin, 0xd9fe)\n     DEF_ASM_OP0(fcos, 0xd9ff)\n     DEF_ASM_OP0(fchs, 0xd9e0)\n     DEF_ASM_OP0(fabs, 0xd9e1)\n     DEF_ASM_OP0(fninit, 0xdbe3)\n     DEF_ASM_OP0(fnclex, 0xdbe2)\n     DEF_ASM_OP0(fnop, 0xd9d0)\n     DEF_ASM_OP0(fwait, 0x9b)\n\n    /* fp load */\n    DEF_ASM_OP1(fld, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fldl, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(flds, 0xd9, 0, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fldl, 0xdd, 0, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fildl, 0xdb, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildq, 0xdf, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildll, 0xdf, 5, OPC_MODRM,OPT_EA)\n    DEF_ASM_OP1(fldt, 0xdb, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbld, 0xdf, 4, OPC_MODRM, OPT_EA)\n    \n    /* fp store */\n    DEF_ASM_OP1(fst, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fstl, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fsts, 0xd9, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstps, 0xd9, 3, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fstl, 0xdd, 2, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fstpl, 0xdd, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fist, 0xdf, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistp, 0xdf, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistl, 0xdb, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpl, 0xdb, 3, OPC_MODRM, OPT_EA)\n\n    DEF_ASM_OP1(fstp, 0xddd8, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fistpq, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpll, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstpt, 0xdb, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbstp, 0xdf, 6, OPC_MODRM, OPT_EA)\n\n    /* exchange */\n    DEF_ASM_OP0(fxch, 0xd9c9)\nALT(DEF_ASM_OP1(fxch, 0xd9c8, 0, OPC_REG, OPT_ST))\n\n    /* misc FPU */\n    DEF_ASM_OP1(fucom, 0xdde0, 0, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fucomp, 0xdde8, 0, OPC_REG, OPT_ST )\n\n    DEF_ASM_OP0L(finit, 0xdbe3, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fldcw, 0xd9, 5, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnstcw, 0xd9, 7, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstcw, 0xd9, 7, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP0(fnstsw, 0xdfe0)\nALT(DEF_ASM_OP1(fnstsw, 0xdfe0, 0, 0, OPT_EAX ))\nALT(DEF_ASM_OP1(fnstsw, 0xdd, 7, OPC_MODRM, OPT_EA ))\n    DEF_ASM_OP1(fstsw, 0xdfe0, 0, OPC_FWAIT, OPT_EAX )\nALT(DEF_ASM_OP0L(fstsw, 0xdfe0, 0, OPC_FWAIT))\nALT(DEF_ASM_OP1(fstsw, 0xdd, 7, OPC_MODRM | OPC_FWAIT, OPT_EA ))\n    DEF_ASM_OP0L(fclex, 0xdbe2, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fnstenv, 0xd9, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstenv, 0xd9, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(fldenv, 0xd9, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnsave, 0xdd, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fsave, 0xdd, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(frstor, 0xdd, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(ffree, 0xddc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(ffreep, 0xdfc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fxsave, 0x0fae, 0, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fxrstor, 0x0fae, 1, OPC_MODRM, OPT_EA )\n\n    /* segments */\n    DEF_ASM_OP2(arpl, 0x63, 0, OPC_MODRM, OPT_REG16, OPT_REG16 | OPT_EA)\n    DEF_ASM_OP2(lar, 0x0f02, 0, OPC_MODRM, OPT_REG32 | OPT_EA, OPT_REG32)\n    DEF_ASM_OP1(lgdt, 0x0f01, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lidt, 0x0f01, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lldt, 0x0f00, 2, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(lmsw, 0x0f01, 6, OPC_MODRM, OPT_EA | OPT_REG)\nALT(DEF_ASM_OP2(lslw, 0x0f03, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_REG))\n    DEF_ASM_OP1(ltr, 0x0f00, 3, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(sgdt, 0x0f01, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sidt, 0x0f01, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sldt, 0x0f00, 0, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(smsw, 0x0f01, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM, OPT_REG16| OPT_EA)\n    DEF_ASM_OP1(verr, 0x0f00, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(verw, 0x0f00, 5, OPC_MODRM, OPT_REG | OPT_EA)\n\n    /* 486 */\n    DEF_ASM_OP1(bswap, 0x0fc8, 0, OPC_REG, OPT_REG32 )\nALT(DEF_ASM_OP2(xaddb, 0x0fc0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\nALT(DEF_ASM_OP2(cmpxchgb, 0x0fb0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\n    DEF_ASM_OP1(invlpg, 0x0f01, 7, OPC_MODRM, OPT_EA )\n\n    DEF_ASM_OP2(boundl, 0x62, 0, OPC_MODRM, OPT_REG32, OPT_EA)\n    DEF_ASM_OP2(boundw, 0x62, 0, OPC_MODRM | OPC_D16, OPT_REG16, OPT_EA)\n\n    /* pentium */\n    DEF_ASM_OP1(cmpxchg8b, 0x0fc7, 1, OPC_MODRM, OPT_EA )\n    \n    /* pentium pro */\n    ALT(DEF_ASM_OP2(cmovo, 0x0f40, 0, OPC_MODRM | OPC_TEST, OPT_REG32 | OPT_EA, OPT_REG32))\n\n    DEF_ASM_OP2(fcmovb, 0xdac0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmove, 0xdac8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovbe, 0xdad0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovu, 0xdad8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnb, 0xdbc0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovne, 0xdbc8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnbe, 0xdbd0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnu, 0xdbd8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    DEF_ASM_OP2(fucomi, 0xdbe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomi, 0xdbf0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fucomip, 0xdfe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomip, 0xdff0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    /* mmx */\n    DEF_ASM_OP0(emms, 0x0f77) /* must be last OP0 */\n    DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_MMX )\nALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(movq, 0x0f6f, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(movq, 0x0f7f, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_MMX ))\n    DEF_ASM_OP2(packssdw, 0x0f6b, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packsswb, 0x0f63, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packuswb, 0x0f67, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddb, 0x0ffc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddw, 0x0ffd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddd, 0x0ffe, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsb, 0x0fec, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsw, 0x0fed, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusb, 0x0fdc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusw, 0x0fdd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pand, 0x0fdb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pandn, 0x0fdf, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqb, 0x0f74, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqw, 0x0f75, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqd, 0x0f76, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtb, 0x0f64, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtw, 0x0f65, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtd, 0x0f66, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmaddwd, 0x0ff5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmulhw, 0x0fe5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmullw, 0x0fd5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(por, 0x0feb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psllw, 0x0ff1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllw, 0x0f71, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(pslld, 0x0ff2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(pslld, 0x0f72, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psllq, 0x0ff3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllq, 0x0f73, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psraw, 0x0fe1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psraw, 0x0f71, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrad, 0x0fe2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrad, 0x0f72, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlw, 0x0fd1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlw, 0x0f71, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrld, 0x0fd2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrld, 0x0f72, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlq, 0x0fd3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlq, 0x0f73, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psubb, 0x0ff8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubw, 0x0ff9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubd, 0x0ffa, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsb, 0x0fe8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsw, 0x0fe9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusb, 0x0fd8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusw, 0x0fd9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhbw, 0x0f68, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhwd, 0x0f69, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhdq, 0x0f6a, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklbw, 0x0f60, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklwd, 0x0f61, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckldq, 0x0f62, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pxor, 0x0fef, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n\n#undef ALT\n#undef DEF_ASM_OP0\n#undef DEF_ASM_OP0L\n#undef DEF_ASM_OP1\n#undef DEF_ASM_OP2\n#undef DEF_ASM_OP3\n//---------------------------------------------------------------------------\n\n#define ALT(x)\n#define DEF_ASM_OP0(name, opcode)\n#define DEF_ASM_OP0L(name, opcode, group, instr_type) DEF_ASM(name)\n#define DEF_ASM_OP1(name, opcode, group, instr_type, op0) DEF_ASM(name)\n#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1) DEF_ASM(name)\n#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2) DEF_ASM(name)\n// njn: inlined i386-asm.h\n//#include \"i386-asm.h\"\n//---------------------------------------------------------------------------\n     DEF_ASM_OP0(pusha, 0x60) /* must be first OP0 */\n     DEF_ASM_OP0(popa, 0x61)\n     DEF_ASM_OP0(clc, 0xf8)\n     DEF_ASM_OP0(cld, 0xfc)\n     DEF_ASM_OP0(cli, 0xfa)\n     DEF_ASM_OP0(clts, 0x0f06)\n     DEF_ASM_OP0(cmc, 0xf5)\n     DEF_ASM_OP0(lahf, 0x9f)\n     DEF_ASM_OP0(sahf, 0x9e)\n     DEF_ASM_OP0(pushfl, 0x9c)\n     DEF_ASM_OP0(popfl, 0x9d)\n     DEF_ASM_OP0(pushf, 0x9c)\n     DEF_ASM_OP0(popf, 0x9d)\n     DEF_ASM_OP0(stc, 0xf9)\n     DEF_ASM_OP0(std, 0xfd)\n     DEF_ASM_OP0(sti, 0xfb)\n     DEF_ASM_OP0(aaa, 0x37)\n     DEF_ASM_OP0(aas, 0x3f)\n     DEF_ASM_OP0(daa, 0x27)\n     DEF_ASM_OP0(das, 0x2f)\n     DEF_ASM_OP0(aad, 0xd50a)\n     DEF_ASM_OP0(aam, 0xd40a)\n     DEF_ASM_OP0(cbw, 0x6698)\n     DEF_ASM_OP0(cwd, 0x6699)\n     DEF_ASM_OP0(cwde, 0x98)\n     DEF_ASM_OP0(cdq, 0x99)\n     DEF_ASM_OP0(cbtw, 0x6698)\n     DEF_ASM_OP0(cwtl, 0x98)\n     DEF_ASM_OP0(cwtd, 0x6699)\n     DEF_ASM_OP0(cltd, 0x99)\n     DEF_ASM_OP0(int3, 0xcc)\n     DEF_ASM_OP0(into, 0xce)\n     DEF_ASM_OP0(iret, 0xcf)\n     DEF_ASM_OP0(rsm, 0x0faa)\n     DEF_ASM_OP0(hlt, 0xf4)\n     DEF_ASM_OP0(wait, 0x9b)\n     DEF_ASM_OP0(nop, 0x90)\n     DEF_ASM_OP0(xlat, 0xd7)\n\n     /* strings */\nALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(insb, 0x6c, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(outsb, 0x6e, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(lodsb, 0xac, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(slodb, 0xac, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(movsb, 0xa4, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(smovb, 0xa4, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(scasb, 0xae, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sscab, 0xae, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(stosb, 0xaa, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sstob, 0xaa, 0, OPC_BWL))\n\n     /* bits */\n     \nALT(DEF_ASM_OP2(bsfw, 0x0fbc, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(bsrw, 0x0fbd, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\n\nALT(DEF_ASM_OP2(btw, 0x0fa3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btw, 0x0fba, 4, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btsw, 0x0fab, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btsw, 0x0fba, 5, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btrw, 0x0fb3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btrw, 0x0fba, 6, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btcw, 0x0fbb, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btcw, 0x0fba, 7, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\n     /* prefixes */\n     DEF_ASM_OP0(aword, 0x67)\n     DEF_ASM_OP0(addr16, 0x67)\n     DEF_ASM_OP0(word, 0x66)\n     DEF_ASM_OP0(data16, 0x66)\n     DEF_ASM_OP0(lock, 0xf0)\n     DEF_ASM_OP0(rep, 0xf3)\n     DEF_ASM_OP0(repe, 0xf3)\n     DEF_ASM_OP0(repz, 0xf3)\n     DEF_ASM_OP0(repne, 0xf2)\n     DEF_ASM_OP0(repnz, 0xf2)\n             \n     DEF_ASM_OP0(invd, 0x0f08)\n     DEF_ASM_OP0(wbinvd, 0x0f09)\n     DEF_ASM_OP0(cpuid, 0x0fa2)\n     DEF_ASM_OP0(wrmsr, 0x0f30)\n     DEF_ASM_OP0(rdtsc, 0x0f31)\n     DEF_ASM_OP0(rdmsr, 0x0f32)\n     DEF_ASM_OP0(rdpmc, 0x0f33)\n     DEF_ASM_OP0(ud2, 0x0f0b)\n\n     /* NOTE: we took the same order as gas opcode definition order */\nALT(DEF_ASM_OP2(movb, 0xa0, 0, OPC_BWL, OPT_ADDR, OPT_EAX))\nALT(DEF_ASM_OP2(movb, 0xa2, 0, OPC_BWL, OPT_EAX, OPT_ADDR))\nALT(DEF_ASM_OP2(movb, 0x88, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movb, 0x8a, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xb0, 0, OPC_REG | OPC_BWL, OPT_IM, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xc6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(movw, 0x8c, 0, OPC_MODRM | OPC_WL, OPT_SEG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movw, 0x8e, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_SEG))\n\nALT(DEF_ASM_OP2(movw, 0x0f20, 0, OPC_MODRM | OPC_WL, OPT_CR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f21, 0, OPC_MODRM | OPC_WL, OPT_DB, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f24, 0, OPC_MODRM | OPC_WL, OPT_TR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f22, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_CR))\nALT(DEF_ASM_OP2(movw, 0x0f23, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_DB))\nALT(DEF_ASM_OP2(movw, 0x0f26, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_TR))\n\nALT(DEF_ASM_OP2(movsbl, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movsbw, 0x0fbe, 0, OPC_MODRM | OPC_D16, OPT_REG8 | OPT_EA, OPT_REG16))\nALT(DEF_ASM_OP2(movswl, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movzbw, 0x0fb6, 0, OPC_MODRM | OPC_WL, OPT_REG8 | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(movzwl, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\n\nALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(pushw, 0xff, 6, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(pushw, 0x6a, 0, OPC_WL, OPT_IM8S))\nALT(DEF_ASM_OP1(pushw, 0x68, 0, OPC_WL, OPT_IM32))\nALT(DEF_ASM_OP1(pushw, 0x06, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(popw, 0x8f, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(popw, 0x07, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_REG, OPT_EAX))\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_EAX, OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\n\nALT(DEF_ASM_OP2(inb, 0xe4, 0, OPC_BWL, OPT_IM8, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xe4, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(inb, 0xec, 0, OPC_BWL, OPT_DX, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xec, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(outb, 0xe6, 0, OPC_BWL, OPT_EAX, OPT_IM8))\nALT(DEF_ASM_OP1(outb, 0xe6, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(outb, 0xee, 0, OPC_BWL, OPT_EAX, OPT_DX))\nALT(DEF_ASM_OP1(outb, 0xee, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(leaw, 0x8d, 0, OPC_MODRM | OPC_WL, OPT_EA, OPT_REG))\n\nALT(DEF_ASM_OP2(les, 0xc4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lds, 0xc5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lss, 0x0fb2, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lfs, 0x0fb4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lgs, 0x0fb5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\n\n     /* arith */\nALT(DEF_ASM_OP2(addb, 0x00, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG)) /* XXX: use D bit ? */\nALT(DEF_ASM_OP2(addb, 0x02, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(addb, 0x04, 0, OPC_ARITH | OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(addb, 0x80, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(addw, 0x83, 0, OPC_ARITH | OPC_MODRM | OPC_WL, OPT_IM8S, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(testb, 0xa8, 0, OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(testb, 0xf6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP1(incw, 0x40, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(incb, 0xfe, 0, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(decw, 0x48, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(decb, 0xfe, 1, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(notb, 0xf6, 2, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(negb, 0xf6, 3, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(mulb, 0xf6, 4, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(imulb, 0xf6, 5, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(imulw, 0x0faf, 0, OPC_MODRM | OPC_WL, OPT_REG | OPT_EA, OPT_REG))\nALT(DEF_ASM_OP3(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW))\nALT(DEF_ASM_OP3(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW))\n\nALT(DEF_ASM_OP1(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\nALT(DEF_ASM_OP1(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\n\n     /* shifts */\nALT(DEF_ASM_OP2(rolb, 0xc0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_IM8, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(rolb, 0xd2, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_CL, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP1(rolb, 0xd0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP3(shldw, 0x0fa4, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fac, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\n\nALT(DEF_ASM_OP1(call, 0xff, 2, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(call, 0xe8, 0, OPC_JMP, OPT_ADDR))\nALT(DEF_ASM_OP1(jmp, 0xff, 4, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(jmp, 0xeb, 0, OPC_SHORTJMP | OPC_JMP, OPT_ADDR))\n\nALT(DEF_ASM_OP2(lcall, 0x9a, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(lcall, 0xff, 3, 0, OPT_EA))\nALT(DEF_ASM_OP2(ljmp, 0xea, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(ljmp, 0xff, 5, 0, OPT_EA))\n\nALT(DEF_ASM_OP1(int, 0xcd, 0, 0, OPT_IM8))\nALT(DEF_ASM_OP1(seto, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))\n    DEF_ASM_OP2(enter, 0xc8, 0, 0, OPT_IM16, OPT_IM8)\n    DEF_ASM_OP0(leave, 0xc9)\n    DEF_ASM_OP0(ret, 0xc3)\nALT(DEF_ASM_OP1(ret, 0xc2, 0, 0, OPT_IM16))\n    DEF_ASM_OP0(lret, 0xcb)\nALT(DEF_ASM_OP1(lret, 0xca, 0, 0, OPT_IM16))\n\nALT(DEF_ASM_OP1(jo, 0x70, 0, OPC_SHORTJMP | OPC_JMP | OPC_TEST, OPT_ADDR))\n    DEF_ASM_OP1(loopne, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopnz, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loope, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopz, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loop, 0xe2, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(jecxz, 0xe3, 0, OPC_SHORTJMP, OPT_ADDR)\n     \n     /* float */\n     /* specific fcomp handling */\nALT(DEF_ASM_OP0L(fcomp, 0xd8d9, 0, 0))\n\nALT(DEF_ASM_OP1(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP0L(fadd, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP0L(faddp, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(fadds, 0xd8, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiaddl, 0xda, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(faddl, 0xdc, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiadds, 0xde, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\n\n     DEF_ASM_OP0(fucompp, 0xdae9)\n     DEF_ASM_OP0(ftst, 0xd9e4)\n     DEF_ASM_OP0(fxam, 0xd9e5)\n     DEF_ASM_OP0(fld1, 0xd9e8)\n     DEF_ASM_OP0(fldl2t, 0xd9e9)\n     DEF_ASM_OP0(fldl2e, 0xd9ea)\n     DEF_ASM_OP0(fldpi, 0xd9eb)\n     DEF_ASM_OP0(fldlg2, 0xd9ec)\n     DEF_ASM_OP0(fldln2, 0xd9ed)\n     DEF_ASM_OP0(fldz, 0xd9ee)\n\n     DEF_ASM_OP0(f2xm1, 0xd9f0)\n     DEF_ASM_OP0(fyl2x, 0xd9f1)\n     DEF_ASM_OP0(fptan, 0xd9f2)\n     DEF_ASM_OP0(fpatan, 0xd9f3)\n     DEF_ASM_OP0(fxtract, 0xd9f4)\n     DEF_ASM_OP0(fprem1, 0xd9f5)\n     DEF_ASM_OP0(fdecstp, 0xd9f6)\n     DEF_ASM_OP0(fincstp, 0xd9f7)\n     DEF_ASM_OP0(fprem, 0xd9f8)\n     DEF_ASM_OP0(fyl2xp1, 0xd9f9)\n     DEF_ASM_OP0(fsqrt, 0xd9fa)\n     DEF_ASM_OP0(fsincos, 0xd9fb)\n     DEF_ASM_OP0(frndint, 0xd9fc)\n     DEF_ASM_OP0(fscale, 0xd9fd)\n     DEF_ASM_OP0(fsin, 0xd9fe)\n     DEF_ASM_OP0(fcos, 0xd9ff)\n     DEF_ASM_OP0(fchs, 0xd9e0)\n     DEF_ASM_OP0(fabs, 0xd9e1)\n     DEF_ASM_OP0(fninit, 0xdbe3)\n     DEF_ASM_OP0(fnclex, 0xdbe2)\n     DEF_ASM_OP0(fnop, 0xd9d0)\n     DEF_ASM_OP0(fwait, 0x9b)\n\n    /* fp load */\n    DEF_ASM_OP1(fld, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fldl, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(flds, 0xd9, 0, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fldl, 0xdd, 0, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fildl, 0xdb, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildq, 0xdf, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildll, 0xdf, 5, OPC_MODRM,OPT_EA)\n    DEF_ASM_OP1(fldt, 0xdb, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbld, 0xdf, 4, OPC_MODRM, OPT_EA)\n    \n    /* fp store */\n    DEF_ASM_OP1(fst, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fstl, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fsts, 0xd9, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstps, 0xd9, 3, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fstl, 0xdd, 2, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fstpl, 0xdd, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fist, 0xdf, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistp, 0xdf, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistl, 0xdb, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpl, 0xdb, 3, OPC_MODRM, OPT_EA)\n\n    DEF_ASM_OP1(fstp, 0xddd8, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fistpq, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpll, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstpt, 0xdb, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbstp, 0xdf, 6, OPC_MODRM, OPT_EA)\n\n    /* exchange */\n    DEF_ASM_OP0(fxch, 0xd9c9)\nALT(DEF_ASM_OP1(fxch, 0xd9c8, 0, OPC_REG, OPT_ST))\n\n    /* misc FPU */\n    DEF_ASM_OP1(fucom, 0xdde0, 0, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fucomp, 0xdde8, 0, OPC_REG, OPT_ST )\n\n    DEF_ASM_OP0L(finit, 0xdbe3, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fldcw, 0xd9, 5, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnstcw, 0xd9, 7, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstcw, 0xd9, 7, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP0(fnstsw, 0xdfe0)\nALT(DEF_ASM_OP1(fnstsw, 0xdfe0, 0, 0, OPT_EAX ))\nALT(DEF_ASM_OP1(fnstsw, 0xdd, 7, OPC_MODRM, OPT_EA ))\n    DEF_ASM_OP1(fstsw, 0xdfe0, 0, OPC_FWAIT, OPT_EAX )\nALT(DEF_ASM_OP0L(fstsw, 0xdfe0, 0, OPC_FWAIT))\nALT(DEF_ASM_OP1(fstsw, 0xdd, 7, OPC_MODRM | OPC_FWAIT, OPT_EA ))\n    DEF_ASM_OP0L(fclex, 0xdbe2, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fnstenv, 0xd9, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstenv, 0xd9, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(fldenv, 0xd9, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnsave, 0xdd, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fsave, 0xdd, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(frstor, 0xdd, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(ffree, 0xddc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(ffreep, 0xdfc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fxsave, 0x0fae, 0, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fxrstor, 0x0fae, 1, OPC_MODRM, OPT_EA )\n\n    /* segments */\n    DEF_ASM_OP2(arpl, 0x63, 0, OPC_MODRM, OPT_REG16, OPT_REG16 | OPT_EA)\n    DEF_ASM_OP2(lar, 0x0f02, 0, OPC_MODRM, OPT_REG32 | OPT_EA, OPT_REG32)\n    DEF_ASM_OP1(lgdt, 0x0f01, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lidt, 0x0f01, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lldt, 0x0f00, 2, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(lmsw, 0x0f01, 6, OPC_MODRM, OPT_EA | OPT_REG)\nALT(DEF_ASM_OP2(lslw, 0x0f03, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_REG))\n    DEF_ASM_OP1(ltr, 0x0f00, 3, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(sgdt, 0x0f01, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sidt, 0x0f01, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sldt, 0x0f00, 0, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(smsw, 0x0f01, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM, OPT_REG16| OPT_EA)\n    DEF_ASM_OP1(verr, 0x0f00, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(verw, 0x0f00, 5, OPC_MODRM, OPT_REG | OPT_EA)\n\n    /* 486 */\n    DEF_ASM_OP1(bswap, 0x0fc8, 0, OPC_REG, OPT_REG32 )\nALT(DEF_ASM_OP2(xaddb, 0x0fc0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\nALT(DEF_ASM_OP2(cmpxchgb, 0x0fb0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\n    DEF_ASM_OP1(invlpg, 0x0f01, 7, OPC_MODRM, OPT_EA )\n\n    DEF_ASM_OP2(boundl, 0x62, 0, OPC_MODRM, OPT_REG32, OPT_EA)\n    DEF_ASM_OP2(boundw, 0x62, 0, OPC_MODRM | OPC_D16, OPT_REG16, OPT_EA)\n\n    /* pentium */\n    DEF_ASM_OP1(cmpxchg8b, 0x0fc7, 1, OPC_MODRM, OPT_EA )\n    \n    /* pentium pro */\n    ALT(DEF_ASM_OP2(cmovo, 0x0f40, 0, OPC_MODRM | OPC_TEST, OPT_REG32 | OPT_EA, OPT_REG32))\n\n    DEF_ASM_OP2(fcmovb, 0xdac0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmove, 0xdac8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovbe, 0xdad0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovu, 0xdad8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnb, 0xdbc0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovne, 0xdbc8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnbe, 0xdbd0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnu, 0xdbd8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    DEF_ASM_OP2(fucomi, 0xdbe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomi, 0xdbf0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fucomip, 0xdfe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomip, 0xdff0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    /* mmx */\n    DEF_ASM_OP0(emms, 0x0f77) /* must be last OP0 */\n    DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_MMX )\nALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(movq, 0x0f6f, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(movq, 0x0f7f, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_MMX ))\n    DEF_ASM_OP2(packssdw, 0x0f6b, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packsswb, 0x0f63, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packuswb, 0x0f67, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddb, 0x0ffc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddw, 0x0ffd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddd, 0x0ffe, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsb, 0x0fec, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsw, 0x0fed, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusb, 0x0fdc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusw, 0x0fdd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pand, 0x0fdb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pandn, 0x0fdf, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqb, 0x0f74, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqw, 0x0f75, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqd, 0x0f76, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtb, 0x0f64, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtw, 0x0f65, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtd, 0x0f66, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmaddwd, 0x0ff5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmulhw, 0x0fe5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmullw, 0x0fd5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(por, 0x0feb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psllw, 0x0ff1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllw, 0x0f71, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(pslld, 0x0ff2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(pslld, 0x0f72, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psllq, 0x0ff3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllq, 0x0f73, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psraw, 0x0fe1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psraw, 0x0f71, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrad, 0x0fe2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrad, 0x0f72, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlw, 0x0fd1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlw, 0x0f71, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrld, 0x0fd2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrld, 0x0f72, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlq, 0x0fd3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlq, 0x0f73, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psubb, 0x0ff8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubw, 0x0ff9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubd, 0x0ffa, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsb, 0x0fe8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsw, 0x0fe9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusb, 0x0fd8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusw, 0x0fd9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhbw, 0x0f68, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhwd, 0x0f69, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhdq, 0x0f6a, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklbw, 0x0f60, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklwd, 0x0f61, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckldq, 0x0f62, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pxor, 0x0fef, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n\n#undef ALT\n#undef DEF_ASM_OP0\n#undef DEF_ASM_OP0L\n#undef DEF_ASM_OP1\n#undef DEF_ASM_OP2\n#undef DEF_ASM_OP3\n//---------------------------------------------------------------------------\n\n#endif\n//---------------------------------------------------------------------------\n#undef DEF\n;\n\n#define TOK_UIDENT TOK_DEFINE\n\n#ifdef WIN32\nint __stdcall GetModuleFileNameA(void *, char *, int);\nvoid *__stdcall GetProcAddress(void *, const char *);\nvoid *__stdcall GetModuleHandleA(const char *);\nvoid *__stdcall LoadLibraryA(const char *);\nint __stdcall FreeConsole(void);\n\n#define snprintf _snprintf\n#define vsnprintf _vsnprintf\n#ifndef __GNUC__\n  #define strtold (long double)strtod\n  #define strtof (float)strtod\n  #define strtoll (long long)strtol\n#endif\n#elif defined(TCC_UCLIBC) || defined(__FreeBSD__)\n/* currently incorrect */\nlong double strtold(const char *nptr, char **endptr)\n{\n    return (long double)strtod(nptr, endptr);\n}\nfloat strtof(const char *nptr, char **endptr)\n{\n    return (float)strtod(nptr, endptr);\n}\n#else\n/* XXX: need to define this to use them in non ISOC99 context */\nextern float strtof (const char *__nptr, char **__endptr);\nextern long double strtold (const char *__nptr, char **__endptr);\n#endif\n\nstatic char *pstrcpy(char *buf, int buf_size, const char *s);\nstatic char *pstrcat(char *buf, int buf_size, const char *s);\nstatic const char *tcc_basename(const char *name);\n\nstatic void next(void);\nstatic void next_nomacro(void);\nstatic void parse_expr_type(CType *type);\nstatic void expr_type(CType *type);\nstatic void unary_type(CType *type);\nstatic void block(int *bsym, int *csym, int *case_sym, int *def_sym, \n                  int case_reg, int is_expr);\nstatic int expr_const(void);\nstatic void expr_eq(void);\nstatic void gexpr(void);\nstatic void gen_inline_functions(void);\nstatic void decl(int l);\nstatic void decl_initializer(CType *type, Section *sec, unsigned long c, \n                             int first, int size_only);\nstatic void decl_initializer_alloc(CType *type, AttributeDef *ad, int r, \n                                   int has_init, int v, int scope);\nint gv(int rc);\nvoid gv2(int rc1, int rc2);\nvoid move_reg(int r, int s);\nvoid save_regs(int n);\nvoid save_reg(int r);\nvoid vpop(void);\nvoid vswap(void);\nvoid vdup(void);\nint get_reg(int rc);\nint get_reg_ex(int rc,int rc2);\n\nstruct macro_level {\n    struct macro_level *prev;\n    int *p;\n};\n\nstatic void macro_subst(TokenString *tok_str, Sym **nested_list, \n                        const int *macro_str, struct macro_level **can_read_stream);\nvoid gen_op(int op);\nvoid force_charshort_cast(int t);\nstatic void gen_cast(CType *type);\nvoid vstore(void);\nstatic Sym *sym_find(int v);\nstatic Sym *sym_push(int v, CType *type, int r, int c);\n\n/* type handling */\nstatic int type_size(CType *type, int *a);\nstatic inline CType *pointed_type(CType *type);\nstatic int pointed_size(CType *type);\nstatic int lvalue_type(int t);\nstatic int parse_btype(CType *type, AttributeDef *ad);\nstatic void type_decl(CType *type, AttributeDef *ad, int *v, int td);\nstatic int is_compatible_types(CType *type1, CType *type2);\n\nint ieee_finite(double d);\nvoid error(const char *fmt, ...);\nvoid vpushi(int v);\nvoid vrott(int n);\nvoid vnrott(int n);\nvoid lexpand_nr(void);\nstatic void vpush_global_sym(CType *type, int v);\nvoid vset(CType *type, int r, int v);\nvoid type_to_str(char *buf, int buf_size, \n                 CType *type, const char *varstr);\nchar *get_tok_str(int v, CValue *cv);\nstatic Sym *get_sym_ref(CType *type, Section *sec, \n                        unsigned long offset, unsigned long size);\nstatic Sym *external_global_sym(int v, CType *type, int r);\n\n/* section generation */\nstatic void section_realloc(Section *sec, unsigned long new_size);\nstatic void *section_ptr_add(Section *sec, unsigned long size);\nstatic void put_extern_sym(Sym *sym, Section *section, \n                           unsigned long value, unsigned long size);\nstatic void greloc(Section *s, Sym *sym, unsigned long addr, int type);\nstatic int put_elf_str(Section *s, const char *sym);\nstatic int put_elf_sym(Section *s, \n                       unsigned long value, unsigned long size,\n                       int info, int other, int shndx, const char *name);\nstatic int add_elf_sym(Section *s, unsigned long value, unsigned long size,\n                       int info, int other, int sh_num, const char *name);\nstatic void put_elf_reloc(Section *symtab, Section *s, unsigned long offset,\n                          int type, int symbol);\nstatic void put_stabs(const char *str, int type, int other, int desc, \n                      unsigned long value);\nstatic void put_stabs_r(const char *str, int type, int other, int desc, \n                        unsigned long value, Section *sec, int sym_index);\nstatic void put_stabn(int type, int other, int desc, int value);\nstatic void put_stabd(int type, int other, int desc);\nstatic int tcc_add_dll(TCCState *s, const char *filename, int flags);\n\n#define AFF_PRINT_ERROR     0x0001 /* print error if file not found */\n#define AFF_REFERENCED_DLL  0x0002 /* load a referenced dll from another dll */\nstatic int tcc_add_file_internal(TCCState *s, const char *filename, int flags);\n\n/* tcccoff.c */\nint tcc_output_coff(TCCState *s1, FILE *f);\n\n/* tccpe.c */\nvoid *resolve_sym(TCCState *s1, const char *sym, int type);\nint pe_load_def_file(struct TCCState *s1, FILE *fp);\nvoid pe_setup_paths(struct TCCState *s1, int *p_output_type, const char **p_outfile, char *first_file);\nunsigned long pe_add_runtime(struct TCCState *s1);\nint tcc_output_pe(struct TCCState *s1, const char *filename);\n\n/* tccasm.c */\n\n#ifdef CONFIG_TCC_ASM\n\ntypedef struct ExprValue {\n    uint32_t v;\n    Sym *sym;\n} ExprValue;\n\n#define MAX_ASM_OPERANDS 30\n\ntypedef struct ASMOperand {\n    int id; /* GCC 3 optional identifier (0 if number only supported */\n    char *constraint;\n    char asm_str[16]; /* computed asm string for operand */\n    SValue *vt; /* C value of the expression */\n    int ref_index; /* if >= 0, gives reference to a output constraint */\n    int input_index; /* if >= 0, gives reference to an input constraint */\n    int priority; /* priority, used to assign registers */\n    int reg; /* if >= 0, register number used for this operand */\n    int is_llong; /* true if double register value */\n    int is_memory; /* true if memory operand */\n    int is_rw;     /* for '+' modifier */\n} ASMOperand;\n\nstatic void asm_expr(TCCState *s1, ExprValue *pe);\nstatic int asm_int_expr(TCCState *s1);\nstatic int find_constraint(ASMOperand *operands, int nb_operands, \n                           const char *name, const char **pp);\n\nstatic int tcc_assemble(TCCState *s1, int do_preprocess);\n\n#endif\n\nstatic void asm_instr(void);\nstatic void asm_global_instr(void);\n\n/* true if float/double/long double type */\nstatic inline int is_float(int t)\n{\n    int bt;\n    bt = t & VT_BTYPE;\n    return bt == VT_LDOUBLE || bt == VT_DOUBLE || bt == VT_FLOAT;\n}\n\n#ifdef TCC_TARGET_I386\n// njn: inlined i386-gen.c\n//#include \"i386-gen.c\"\n//---------------------------------------------------------------------------\n/*\n *  X86 code generator for TCC\n * \n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/* number of available registers */\n#define NB_REGS             4\n\n/* a register can belong to several classes. The classes must be\n   sorted from more general to more precise (see gv2() code which does\n   assumptions on it). */\n#define RC_INT     0x0001 /* generic integer register */\n#define RC_FLOAT   0x0002 /* generic float register */\n#define RC_EAX     0x0004\n#define RC_ST0     0x0008 \n#define RC_ECX     0x0010\n#define RC_EDX     0x0020\n#define RC_IRET    RC_EAX /* function return: integer register */\n#define RC_LRET    RC_EDX /* function return: second integer register */\n#define RC_FRET    RC_ST0 /* function return: float register */\n\n/* pretty names for the registers */\nenum {\n    TREG_EAX = 0,\n    TREG_ECX,\n    TREG_EDX,\n    TREG_ST0,\n};\n\nint reg_classes[NB_REGS] = {\n    /* eax */ RC_INT | RC_EAX,\n    /* ecx */ RC_INT | RC_ECX,\n    /* edx */ RC_INT | RC_EDX,\n    /* st0 */ RC_FLOAT | RC_ST0,\n};\n\n/* return registers for function */\n#define REG_IRET TREG_EAX /* single word int return register */\n#define REG_LRET TREG_EDX /* second word return register (for long long) */\n#define REG_FRET TREG_ST0 /* float return register */\n\n/* defined if function parameters must be evaluated in reverse order */\n#define INVERT_FUNC_PARAMS\n\n/* defined if structures are passed as pointers. Otherwise structures\n   are directly pushed on stack. */\n//#define FUNC_STRUCT_PARAM_AS_PTR\n\n/* pointer size, in bytes */\n#define PTR_SIZE 4\n\n/* long double size and alignment, in bytes */\n#define LDOUBLE_SIZE  12\n#define LDOUBLE_ALIGN 4\n/* maximum alignment (for aligned attribute support) */\n#define MAX_ALIGN     8\n\n/******************************************************/\n/* ELF defines */\n\n#define EM_TCC_TARGET EM_386\n\n/* relocation type for 32 bit data relocation */\n#define R_DATA_32   R_386_32\n#define R_JMP_SLOT  R_386_JMP_SLOT\n#define R_COPY      R_386_COPY\n\n#define ELF_START_ADDR 0x08048000\n#define ELF_PAGE_SIZE  0x1000\n\n/******************************************************/\n\nstatic unsigned long func_sub_sp_offset;\nstatic unsigned long func_bound_offset;\nstatic int func_ret_sub;\n\n/* XXX: make it faster ? */\nvoid g(int c)\n{\n    int ind1;\n    ind1 = ind + 1;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    cur_text_section->data[ind] = c;\n    ind = ind1;\n}\n\nvoid o(unsigned int c)\n{\n    while (c) {\n        g(c);\n        c = c >> 8;\n    }\n}\n\nvoid gen_le32(int c)\n{\n    g(c);\n    g(c >> 8);\n    g(c >> 16);\n    g(c >> 24);\n}\n\n/* output a symbol and patch all calls to it */\nvoid gsym_addr(int t, int a)\n{\n    int n, *ptr;\n    while (t) {\n        ptr = (int *)(cur_text_section->data + t);\n        n = *ptr; /* next value */\n        *ptr = a - t - 4;\n        t = n;\n    }\n}\n\nvoid gsym(int t)\n{\n    gsym_addr(t, ind);\n}\n\n/* psym is used to put an instruction with a data field which is a\n   reference to a symbol. It is in fact the same as oad ! */\n#define psym oad\n\n/* instruction + 4 bytes data. Return the address of the data */\nstatic int oad(int c, int s)\n{\n    int ind1;\n\n    o(c);\n    ind1 = ind + 4;\n    if (ind1 > cur_text_section->data_allocated)\n        section_realloc(cur_text_section, ind1);\n    *(int *)(cur_text_section->data + ind) = s;\n    s = ind;\n    ind = ind1;\n    return s;\n}\n\n/* output constant with relocation if 'r & VT_SYM' is true */\nstatic void gen_addr32(int r, Sym *sym, int c)\n{\n    if (r & VT_SYM)\n        greloc(cur_text_section, sym, ind, R_386_32);\n    gen_le32(c);\n}\n\n/* generate a modrm reference. 'op_reg' contains the addtionnal 3\n   opcode bits */\nstatic void gen_modrm(int op_reg, int r, Sym *sym, int c)\n{\n    op_reg = op_reg << 3;\n    if ((r & VT_VALMASK) == VT_CONST) {\n        /* constant memory reference */\n        o(0x05 | op_reg);\n        gen_addr32(r, sym, c);\n    } else if ((r & VT_VALMASK) == VT_LOCAL) {\n        /* currently, we use only ebp as base */\n        if (c == (char)c) {\n            /* short reference */\n            o(0x45 | op_reg);\n            g(c);\n        } else {\n            oad(0x85 | op_reg, c);\n        }\n    } else {\n        g(0x00 | op_reg | (r & VT_VALMASK));\n    }\n}\n\n\n/* load 'r' from value 'sv' */\nvoid load(int r, SValue *sv)\n{\n    int v, t, ft, fc, fr;\n    SValue v1;\n\n    fr = sv->r;\n    ft = sv->type.t;\n    fc = sv->c.ul;\n\n    v = fr & VT_VALMASK;\n    if (fr & VT_LVAL) {\n        if (v == VT_LLOCAL) {\n            v1.type.t = VT_INT;\n            v1.r = VT_LOCAL | VT_LVAL;\n            v1.c.ul = fc;\n            load(r, &v1);\n            fr = r;\n        }\n        if ((ft & VT_BTYPE) == VT_FLOAT) {\n            o(0xd9); /* flds */\n            r = 0;\n        } else if ((ft & VT_BTYPE) == VT_DOUBLE) {\n            o(0xdd); /* fldl */\n            r = 0;\n        } else if ((ft & VT_BTYPE) == VT_LDOUBLE) {\n            o(0xdb); /* fldt */\n            r = 5;\n        } else if ((ft & VT_TYPE) == VT_BYTE) {\n            o(0xbe0f);   /* movsbl */\n        } else if ((ft & VT_TYPE) == (VT_BYTE | VT_UNSIGNED)) {\n            o(0xb60f);   /* movzbl */\n        } else if ((ft & VT_TYPE) == VT_SHORT) {\n            o(0xbf0f);   /* movswl */\n        } else if ((ft & VT_TYPE) == (VT_SHORT | VT_UNSIGNED)) {\n            o(0xb70f);   /* movzwl */\n        } else {\n            o(0x8b);     /* movl */\n        }\n        gen_modrm(r, fr, sv->sym, fc);\n    } else {\n        if (v == VT_CONST) {\n            o(0xb8 + r); /* mov $xx, r */\n            gen_addr32(fr, sv->sym, fc);\n        } else if (v == VT_LOCAL) {\n            o(0x8d); /* lea xxx(%ebp), r */\n            gen_modrm(r, VT_LOCAL, sv->sym, fc);\n        } else if (v == VT_CMP) {\n            oad(0xb8 + r, 0); /* mov $0, r */\n            o(0x0f); /* setxx %br */\n            o(fc);\n            o(0xc0 + r);\n        } else if (v == VT_JMP || v == VT_JMPI) {\n            t = v & 1;\n            oad(0xb8 + r, t); /* mov $1, r */\n            o(0x05eb); /* jmp after */\n            gsym(fc);\n            oad(0xb8 + r, t ^ 1); /* mov $0, r */\n        } else if (v != r) {\n            o(0x89);\n            o(0xc0 + r + v * 8); /* mov v, r */\n        }\n    }\n}\n\n/* store register 'r' in lvalue 'v' */\nvoid store(int r, SValue *v)\n{\n    int fr, bt, ft, fc;\n\n    ft = v->type.t;\n    fc = v->c.ul;\n    fr = v->r & VT_VALMASK;\n    bt = ft & VT_BTYPE;\n    /* XXX: incorrect if float reg to reg */\n    if (bt == VT_FLOAT) {\n        o(0xd9); /* fsts */\n        r = 2;\n    } else if (bt == VT_DOUBLE) {\n        o(0xdd); /* fstpl */\n        r = 2;\n    } else if (bt == VT_LDOUBLE) {\n        o(0xc0d9); /* fld %st(0) */\n        o(0xdb); /* fstpt */\n        r = 7;\n    } else {\n        if (bt == VT_SHORT)\n            o(0x66);\n        if (bt == VT_BYTE || bt == VT_BOOL)\n            o(0x88);\n        else\n            o(0x89);\n    }\n    if (fr == VT_CONST ||\n        fr == VT_LOCAL ||\n        (v->r & VT_LVAL)) {\n        gen_modrm(r, v->r, v->sym, fc);\n    } else if (fr != r) {\n        o(0xc0 + fr + r * 8); /* mov r, fr */\n    }\n}\n\nstatic void gadd_sp(int val)\n{\n    if (val == (char)val) {\n        o(0xc483);\n        g(val);\n    } else {\n        oad(0xc481, val); /* add $xxx, %esp */\n    }\n}\n\n/* 'is_jmp' is '1' if it is a jump */\nstatic void gcall_or_jmp(int is_jmp)\n{\n    int r;\n    if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n        /* constant case */\n        if (vtop->r & VT_SYM) {\n            /* relocation case */\n            greloc(cur_text_section, vtop->sym, \n                   ind + 1, R_386_PC32);\n        } else {\n            /* put an empty PC32 relocation */\n            put_elf_reloc(symtab_section, cur_text_section, \n                          ind + 1, R_386_PC32, 0);\n        }\n        oad(0xe8 + is_jmp, vtop->c.ul - 4); /* call/jmp im */\n    } else {\n        /* otherwise, indirect call */\n        r = gv(RC_INT);\n        o(0xff); /* call/jmp *r */\n        o(0xd0 + r + (is_jmp << 4));\n    }\n}\n\nstatic uint8_t fastcall_regs[3] = { TREG_EAX, TREG_EDX, TREG_ECX };\n\n/* Generate function call. The function address is pushed first, then\n   all the parameters in call order. This functions pops all the\n   parameters and the function address. */\nvoid gfunc_call(int nb_args)\n{\n    int size, align, r, args_size, i, func_call;\n    Sym *func_sym;\n    \n    args_size = 0;\n    for(i = 0;i < nb_args; i++) {\n        if ((vtop->type.t & VT_BTYPE) == VT_STRUCT) {\n            size = type_size(&vtop->type, &align);\n            /* align to stack align size */\n            size = (size + 3) & ~3;\n            /* allocate the necessary size on stack */\n            oad(0xec81, size); /* sub $xxx, %esp */\n            /* generate structure store */\n            r = get_reg(RC_INT);\n            o(0x89); /* mov %esp, r */\n            o(0xe0 + r);\n            vset(&vtop->type, r | VT_LVAL, 0);\n            vswap();\n            vstore();\n            args_size += size;\n        } else if (is_float(vtop->type.t)) {\n            gv(RC_FLOAT); /* only one float register */\n            if ((vtop->type.t & VT_BTYPE) == VT_FLOAT)\n                size = 4;\n            else if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE)\n                size = 8;\n            else\n                size = 12;\n            oad(0xec81, size); /* sub $xxx, %esp */\n            if (size == 12)\n                o(0x7cdb);\n            else\n                o(0x5cd9 + size - 4); /* fstp[s|l] 0(%esp) */\n            g(0x24);\n            g(0x00);\n            args_size += size;\n        } else {\n            /* simple type (currently always same size) */\n            /* XXX: implicit cast ? */\n            r = gv(RC_INT);\n            if ((vtop->type.t & VT_BTYPE) == VT_LLONG) {\n                size = 8;\n                o(0x50 + vtop->r2); /* push r */\n            } else {\n                size = 4;\n            }\n            o(0x50 + r); /* push r */\n            args_size += size;\n        }\n        vtop--;\n    }\n    save_regs(0); /* save used temporary registers */\n    func_sym = vtop->type.ref;\n    func_call = func_sym->r;\n    /* fast call case */\n    if (func_call >= FUNC_FASTCALL1 && func_call <= FUNC_FASTCALL3) {\n        int fastcall_nb_regs;\n        fastcall_nb_regs = func_call - FUNC_FASTCALL1 + 1;\n        for(i = 0;i < fastcall_nb_regs; i++) {\n            if (args_size <= 0)\n                break;\n            o(0x58 + fastcall_regs[i]); /* pop r */\n            /* XXX: incorrect for struct/floats */\n            args_size -= 4;\n        }\n    }\n    gcall_or_jmp(0);\n    if (args_size && func_sym->r != FUNC_STDCALL)\n        gadd_sp(args_size);\n    vtop--;\n}\n\n#ifdef TCC_TARGET_PE\n#define FUNC_PROLOG_SIZE 10\n#else\n#define FUNC_PROLOG_SIZE 9\n#endif\n\n/* generate function prolog of type 't' */\nvoid gfunc_prolog(CType *func_type)\n{\n    int addr, align, size, func_call, fastcall_nb_regs;\n    int param_index, param_addr;\n    Sym *sym;\n    CType *type;\n\n    sym = func_type->ref;\n    func_call = sym->r;\n    addr = 8;\n    loc = 0;\n    if (func_call >= FUNC_FASTCALL1 && func_call <= FUNC_FASTCALL3) {\n        fastcall_nb_regs = func_call - FUNC_FASTCALL1 + 1;\n    } else {\n        fastcall_nb_regs = 0;\n    }\n    param_index = 0;\n\n    ind += FUNC_PROLOG_SIZE;\n    func_sub_sp_offset = ind;\n    /* if the function returns a structure, then add an\n       implicit pointer parameter */\n    func_vt = sym->type;\n    if ((func_vt.t & VT_BTYPE) == VT_STRUCT) {\n        /* XXX: fastcall case ? */\n        func_vc = addr;\n        addr += 4;\n        param_index++;\n    }\n    /* define parameters */\n    while ((sym = sym->next) != NULL) {\n        type = &sym->type;\n        size = type_size(type, &align);\n        size = (size + 3) & ~3;\n#ifdef FUNC_STRUCT_PARAM_AS_PTR\n        /* structs are passed as pointer */\n        if ((type->t & VT_BTYPE) == VT_STRUCT) {\n            size = 4;\n        }\n#endif\n        if (param_index < fastcall_nb_regs) {\n            /* save FASTCALL register */\n            loc -= 4;\n            o(0x89);     /* movl */\n            gen_modrm(fastcall_regs[param_index], VT_LOCAL, NULL, loc);\n            param_addr = loc;\n        } else {\n            param_addr = addr;\n            addr += size;\n        }\n        sym_push(sym->v & ~SYM_FIELD, type,\n                 VT_LOCAL | VT_LVAL, param_addr);\n        param_index++;\n    }\n    func_ret_sub = 0;\n    /* pascal type call ? */\n    if (func_call == FUNC_STDCALL)\n        func_ret_sub = addr - 8;\n\n    /* leave some room for bound checking code */\n    if (do_bounds_check) {\n        oad(0xb8, 0); /* lbound section pointer */\n        oad(0xb8, 0); /* call to function */\n        func_bound_offset = lbounds_section->data_offset;\n    }\n}\n\n/* generate function epilog */\nvoid gfunc_epilog(void)\n{\n    int v, saved_ind;\n\n#ifdef CONFIG_TCC_BCHECK\n    if (do_bounds_check && func_bound_offset != lbounds_section->data_offset) {\n        int saved_ind;\n        int *bounds_ptr;\n        Sym *sym, *sym_data;\n        /* add end of table info */\n        bounds_ptr = section_ptr_add(lbounds_section, sizeof(int));\n        *bounds_ptr = 0;\n        /* generate bound local allocation */\n        saved_ind = ind;\n        ind = func_sub_sp_offset;\n        sym_data = get_sym_ref(&char_pointer_type, lbounds_section, \n                               func_bound_offset, lbounds_section->data_offset);\n        greloc(cur_text_section, sym_data,\n               ind + 1, R_386_32);\n        oad(0xb8, 0); /* mov %eax, xxx */\n        sym = external_global_sym(TOK___bound_local_new, &func_old_type, 0);\n        greloc(cur_text_section, sym, \n               ind + 1, R_386_PC32);\n        oad(0xe8, -4);\n        ind = saved_ind;\n        /* generate bound check local freeing */\n        o(0x5250); /* save returned value, if any */\n        greloc(cur_text_section, sym_data,\n               ind + 1, R_386_32);\n        oad(0xb8, 0); /* mov %eax, xxx */\n        sym = external_global_sym(TOK___bound_local_delete, &func_old_type, 0);\n        greloc(cur_text_section, sym, \n               ind + 1, R_386_PC32);\n        oad(0xe8, -4);\n        o(0x585a); /* restore returned value, if any */\n    }\n#endif\n    o(0xc9); /* leave */\n    if (func_ret_sub == 0) {\n        o(0xc3); /* ret */\n    } else {\n        o(0xc2); /* ret n */\n        g(func_ret_sub);\n        g(func_ret_sub >> 8);\n    }\n    /* align local size to word & save local variables */\n    \n    v = (-loc + 3) & -4; \n    saved_ind = ind;\n    ind = func_sub_sp_offset - FUNC_PROLOG_SIZE;\n#ifdef TCC_TARGET_PE\n    if (v >= 4096) {\n        Sym *sym = external_global_sym(TOK___chkstk, &func_old_type, 0);\n        oad(0xb8, v); /* mov stacksize, %eax */\n        oad(0xe8, -4); /* call __chkstk, (does the stackframe too) */\n        greloc(cur_text_section, sym, ind-4, R_386_PC32);\n    } else\n#endif\n    {\n        o(0xe58955);  /* push %ebp, mov %esp, %ebp */\n        o(0xec81);  /* sub esp, stacksize */\n        gen_le32(v);\n#if FUNC_PROLOG_SIZE == 10\n        o(0x90);  /* adjust to FUNC_PROLOG_SIZE */\n#endif\n    }\n    ind = saved_ind;\n}\n\n/* generate a jump to a label */\nlong gjmp(int t)\n{\n    return psym(0xe9, t);\n}\n\n/* generate a jump to a fixed address */\nvoid gjmp_addr(int a)\n{\n    int r;\n    r = a - ind - 2;\n    if (r == (char)r) {\n        g(0xeb);\n        g(r);\n    } else {\n        oad(0xe9, a - ind - 5);\n    }\n}\n\n/* generate a test. set 'inv' to invert test. Stack entry is popped */\nint gtst(int inv, int t)\n{\n    int v, *p;\n\n    v = vtop->r & VT_VALMASK;\n    if (v == VT_CMP) {\n        /* fast case : can jump directly since flags are set */\n        g(0x0f);\n        t = psym((vtop->c.i - 16) ^ inv, t);\n    } else if (v == VT_JMP || v == VT_JMPI) {\n        /* && or || optimization */\n        if ((v & 1) == inv) {\n            /* insert vtop->c jump list in t */\n            p = &vtop->c.i;\n            while (*p != 0)\n                p = (int *)(cur_text_section->data + *p);\n            *p = t;\n            t = vtop->c.i;\n        } else {\n            t = gjmp(t);\n            gsym(vtop->c.i);\n        }\n    } else {\n        if (is_float(vtop->type.t)) {\n            vpushi(0);\n            gen_op(TOK_NE);\n        }\n        if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n            /* constant jmp optimization */\n            if ((vtop->c.i != 0) != inv) \n                t = gjmp(t);\n        } else {\n            v = gv(RC_INT);\n            o(0x85);\n            o(0xc0 + v * 9);\n            g(0x0f);\n            t = psym(0x85 ^ inv, t);\n        }\n    }\n    vtop--;\n    return t;\n}\n\n/* generate an integer binary operation */\nvoid gen_opi(int op)\n{\n    int r, fr, opc, c;\n\n    switch(op) {\n    case '+':\n    case TOK_ADDC1: /* add with carry generation */\n        opc = 0;\n    gen_op8:\n        if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n            /* constant case */\n            vswap();\n            r = gv(RC_INT);\n            vswap();\n            c = vtop->c.i;\n            if (c == (char)c) {\n                /* XXX: generate inc and dec for smaller code ? */\n                o(0x83);\n                o(0xc0 | (opc << 3) | r);\n                g(c);\n            } else {\n                o(0x81);\n                oad(0xc0 | (opc << 3) | r, c);\n            }\n        } else {\n            gv2(RC_INT, RC_INT);\n            r = vtop[-1].r;\n            fr = vtop[0].r;\n            o((opc << 3) | 0x01);\n            o(0xc0 + r + fr * 8); \n        }\n        vtop--;\n        if (op >= TOK_ULT && op <= TOK_GT) {\n            vtop->r = VT_CMP;\n            vtop->c.i = op;\n        }\n        break;\n    case '-':\n    case TOK_SUBC1: /* sub with carry generation */\n        opc = 5;\n        goto gen_op8;\n    case TOK_ADDC2: /* add with carry use */\n        opc = 2;\n        goto gen_op8;\n    case TOK_SUBC2: /* sub with carry use */\n        opc = 3;\n        goto gen_op8;\n    case '&':\n        opc = 4;\n        goto gen_op8;\n    case '^':\n        opc = 6;\n        goto gen_op8;\n    case '|':\n        opc = 1;\n        goto gen_op8;\n    case '*':\n        gv2(RC_INT, RC_INT);\n        r = vtop[-1].r;\n        fr = vtop[0].r;\n        vtop--;\n        o(0xaf0f); /* imul fr, r */\n        o(0xc0 + fr + r * 8);\n        break;\n    case TOK_SHL:\n        opc = 4;\n        goto gen_shift;\n    case TOK_SHR:\n        opc = 5;\n        goto gen_shift;\n    case TOK_SAR:\n        opc = 7;\n    gen_shift:\n        opc = 0xc0 | (opc << 3);\n        if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n            /* constant case */\n            vswap();\n            r = gv(RC_INT);\n            vswap();\n            c = vtop->c.i & 0x1f;\n            o(0xc1); /* shl/shr/sar $xxx, r */\n            o(opc | r);\n            g(c);\n        } else {\n            /* we generate the shift in ecx */\n            gv2(RC_INT, RC_ECX);\n            r = vtop[-1].r;\n            o(0xd3); /* shl/shr/sar %cl, r */\n            o(opc | r);\n        }\n        vtop--;\n        break;\n    case '/':\n    case TOK_UDIV:\n    case TOK_PDIV:\n    case '%':\n    case TOK_UMOD:\n    case TOK_UMULL:\n        /* first operand must be in eax */\n        /* XXX: need better constraint for second operand */\n        gv2(RC_EAX, RC_ECX);\n        r = vtop[-1].r;\n        fr = vtop[0].r;\n        vtop--;\n        save_reg(TREG_EDX);\n        if (op == TOK_UMULL) {\n            o(0xf7); /* mul fr */\n            o(0xe0 + fr);\n            vtop->r2 = TREG_EDX;\n            r = TREG_EAX;\n        } else {\n            if (op == TOK_UDIV || op == TOK_UMOD) {\n                o(0xf7d231); /* xor %edx, %edx, div fr, %eax */\n                o(0xf0 + fr);\n            } else {\n                o(0xf799); /* cltd, idiv fr, %eax */\n                o(0xf8 + fr);\n            }\n            if (op == '%' || op == TOK_UMOD)\n                r = TREG_EDX;\n            else\n                r = TREG_EAX;\n        }\n        vtop->r = r;\n        break;\n    default:\n        opc = 7;\n        goto gen_op8;\n    }\n}\n\n/* generate a floating point operation 'v = t1 op t2' instruction. The\n   two operands are guaranted to have the same floating point type */\n/* XXX: need to use ST1 too */\nvoid gen_opf(int op)\n{\n    int a, ft, fc, swapped, r;\n\n    /* convert constants to memory references */\n    if ((vtop[-1].r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n        vswap();\n        gv(RC_FLOAT);\n        vswap();\n    }\n    if ((vtop[0].r & (VT_VALMASK | VT_LVAL)) == VT_CONST)\n        gv(RC_FLOAT);\n\n    /* must put at least one value in the floating point register */\n    if ((vtop[-1].r & VT_LVAL) &&\n        (vtop[0].r & VT_LVAL)) {\n        vswap();\n        gv(RC_FLOAT);\n        vswap();\n    }\n    swapped = 0;\n    /* swap the stack if needed so that t1 is the register and t2 is\n       the memory reference */\n    if (vtop[-1].r & VT_LVAL) {\n        vswap();\n        swapped = 1;\n    }\n    if (op >= TOK_ULT && op <= TOK_GT) {\n        /* load on stack second operand */\n        load(TREG_ST0, vtop);\n        save_reg(TREG_EAX); /* eax is used by FP comparison code */\n        if (op == TOK_GE || op == TOK_GT)\n            swapped = !swapped;\n        else if (op == TOK_EQ || op == TOK_NE)\n            swapped = 0;\n        if (swapped)\n            o(0xc9d9); /* fxch %st(1) */\n        o(0xe9da); /* fucompp */\n        o(0xe0df); /* fnstsw %ax */\n        if (op == TOK_EQ) {\n            o(0x45e480); /* and $0x45, %ah */\n            o(0x40fC80); /* cmp $0x40, %ah */\n        } else if (op == TOK_NE) {\n            o(0x45e480); /* and $0x45, %ah */\n            o(0x40f480); /* xor $0x40, %ah */\n            op = TOK_NE;\n        } else if (op == TOK_GE || op == TOK_LE) {\n            o(0x05c4f6); /* test $0x05, %ah */\n            op = TOK_EQ;\n        } else {\n            o(0x45c4f6); /* test $0x45, %ah */\n            op = TOK_EQ;\n        }\n        vtop--;\n        vtop->r = VT_CMP;\n        vtop->c.i = op;\n    } else {\n        /* no memory reference possible for long double operations */\n        if ((vtop->type.t & VT_BTYPE) == VT_LDOUBLE) {\n            load(TREG_ST0, vtop);\n            swapped = !swapped;\n        }\n        \n        switch(op) {\n        default:\n        case '+':\n            a = 0;\n            break;\n        case '-':\n            a = 4;\n            if (swapped)\n                a++;\n            break;\n        case '*':\n            a = 1;\n            break;\n        case '/':\n            a = 6;\n            if (swapped)\n                a++;\n            break;\n        }\n        ft = vtop->type.t;\n        fc = vtop->c.ul;\n        if ((ft & VT_BTYPE) == VT_LDOUBLE) {\n            o(0xde); /* fxxxp %st, %st(1) */\n            o(0xc1 + (a << 3));\n        } else {\n            /* if saved lvalue, then we must reload it */\n            r = vtop->r;\n            if ((r & VT_VALMASK) == VT_LLOCAL) {\n                SValue v1;\n                r = get_reg(RC_INT);\n                v1.type.t = VT_INT;\n                v1.r = VT_LOCAL | VT_LVAL;\n                v1.c.ul = fc;\n                load(r, &v1);\n                fc = 0;\n            }\n\n            if ((ft & VT_BTYPE) == VT_DOUBLE)\n                o(0xdc);\n            else\n                o(0xd8);\n            gen_modrm(a, r, vtop->sym, fc);\n        }\n        vtop--;\n    }\n}\n\n/* convert integers to fp 't' type. Must handle 'int', 'unsigned int'\n   and 'long long' cases. */\nvoid gen_cvt_itof(int t)\n{\n    save_reg(TREG_ST0);\n    gv(RC_INT);\n    if ((vtop->type.t & VT_BTYPE) == VT_LLONG) {\n        /* signed long long to float/double/long double (unsigned case\n           is handled generically) */\n        o(0x50 + vtop->r2); /* push r2 */\n        o(0x50 + (vtop->r & VT_VALMASK)); /* push r */\n        o(0x242cdf); /* fildll (%esp) */\n        o(0x08c483); /* add $8, %esp */\n    } else if ((vtop->type.t & (VT_BTYPE | VT_UNSIGNED)) == \n               (VT_INT | VT_UNSIGNED)) {\n        /* unsigned int to float/double/long double */\n        o(0x6a); /* push $0 */\n        g(0x00);\n        o(0x50 + (vtop->r & VT_VALMASK)); /* push r */\n        o(0x242cdf); /* fildll (%esp) */\n        o(0x08c483); /* add $8, %esp */\n    } else {\n        /* int to float/double/long double */\n        o(0x50 + (vtop->r & VT_VALMASK)); /* push r */\n        o(0x2404db); /* fildl (%esp) */\n        o(0x04c483); /* add $4, %esp */\n    }\n    vtop->r = TREG_ST0;\n}\n\n/* convert fp to int 't' type */\n/* XXX: handle long long case */\nvoid gen_cvt_ftoi(int t)\n{\n    int r, r2, size;\n    Sym *sym;\n    CType ushort_type;\n\n    ushort_type.t = VT_SHORT | VT_UNSIGNED;\n\n    gv(RC_FLOAT);\n    if (t != VT_INT)\n        size = 8;\n    else \n        size = 4;\n    \n    o(0x2dd9); /* ldcw xxx */\n    sym = external_global_sym(TOK___tcc_int_fpu_control, \n                              &ushort_type, VT_LVAL);\n    greloc(cur_text_section, sym, \n           ind, R_386_32);\n    gen_le32(0);\n    \n    oad(0xec81, size); /* sub $xxx, %esp */\n    if (size == 4)\n        o(0x1cdb); /* fistpl */\n    else\n        o(0x3cdf); /* fistpll */\n    o(0x24);\n    o(0x2dd9); /* ldcw xxx */\n    sym = external_global_sym(TOK___tcc_fpu_control, \n                              &ushort_type, VT_LVAL);\n    greloc(cur_text_section, sym, \n           ind, R_386_32);\n    gen_le32(0);\n\n    r = get_reg(RC_INT);\n    o(0x58 + r); /* pop r */\n    if (size == 8) {\n        if (t == VT_LLONG) {\n            vtop->r = r; /* mark reg as used */\n            r2 = get_reg(RC_INT);\n            o(0x58 + r2); /* pop r2 */\n            vtop->r2 = r2;\n        } else {\n            o(0x04c483); /* add $4, %esp */\n        }\n    }\n    vtop->r = r;\n}\n\n/* convert from one floating point type to another */\nvoid gen_cvt_ftof(int t)\n{\n    /* all we have to do on i386 is to put the float in a register */\n    gv(RC_FLOAT);\n}\n\n/* computed goto support */\nvoid ggoto(void)\n{\n    gcall_or_jmp(1);\n    vtop--;\n}\n\n/* bound check support functions */\n#ifdef CONFIG_TCC_BCHECK\n\n/* generate a bounded pointer addition */\nvoid gen_bounded_ptr_add(void)\n{\n    Sym *sym;\n\n    /* prepare fast i386 function call (args in eax and edx) */\n    gv2(RC_EAX, RC_EDX);\n    /* save all temporary registers */\n    vtop -= 2;\n    save_regs(0);\n    /* do a fast function call */\n    sym = external_global_sym(TOK___bound_ptr_add, &func_old_type, 0);\n    greloc(cur_text_section, sym, \n           ind + 1, R_386_PC32);\n    oad(0xe8, -4);\n    /* returned pointer is in eax */\n    vtop++;\n    vtop->r = TREG_EAX | VT_BOUNDED;\n    /* address of bounding function call point */\n    vtop->c.ul = (cur_text_section->reloc->data_offset - sizeof(Elf32_Rel)); \n}\n\n/* patch pointer addition in vtop so that pointer dereferencing is\n   also tested */\nvoid gen_bounded_ptr_deref(void)\n{\n    int func;\n    int size, align;\n    Elf32_Rel *rel;\n    Sym *sym;\n\n    size = 0;\n    /* XXX: put that code in generic part of tcc */\n    if (!is_float(vtop->type.t)) {\n        if (vtop->r & VT_LVAL_BYTE)\n            size = 1;\n        else if (vtop->r & VT_LVAL_SHORT)\n            size = 2;\n    }\n    if (!size)\n        size = type_size(&vtop->type, &align);\n    switch(size) {\n    case  1: func = TOK___bound_ptr_indir1; break;\n    case  2: func = TOK___bound_ptr_indir2; break;\n    case  4: func = TOK___bound_ptr_indir4; break;\n    case  8: func = TOK___bound_ptr_indir8; break;\n    case 12: func = TOK___bound_ptr_indir12; break;\n    case 16: func = TOK___bound_ptr_indir16; break;\n    default:\n        error(\"unhandled size when derefencing bounded pointer\");\n        func = 0;\n        break;\n    }\n\n    /* patch relocation */\n    /* XXX: find a better solution ? */\n    rel = (Elf32_Rel *)(cur_text_section->reloc->data + vtop->c.ul);\n    sym = external_global_sym(func, &func_old_type, 0);\n    if (!sym->c)\n        put_extern_sym(sym, NULL, 0, 0);\n    rel->r_info = ELF32_R_INFO(sym->c, ELF32_R_TYPE(rel->r_info));\n}\n#endif\n\n/* end of X86 code generator */\n/*************************************************************/\n\n//---------------------------------------------------------------------------\n#endif\n\n// njn: commented these out\n//#ifdef TCC_TARGET_ARM\n//#include \"arm-gen.c\"\n//#endif\n//\n//#ifdef TCC_TARGET_C67\n//#include \"c67-gen.c\"\n//#endif\n\n#ifdef CONFIG_TCC_STATIC\n\n#define RTLD_LAZY       0x001\n#define RTLD_NOW        0x002\n#define RTLD_GLOBAL     0x100\n#define RTLD_DEFAULT    NULL\n\n/* dummy function for profiling */\nvoid *dlopen(const char *filename, int flag)\n{\n    return NULL;\n}\n\nconst char *dlerror(void)\n{\n    return \"error\";\n}\n\ntypedef struct TCCSyms {\n    char *str;\n    void *ptr;\n} TCCSyms;\n\n#define TCCSYM(a) { #a, &a, },\n\n/* add the symbol you want here if no dynamic linking is done */\nstatic TCCSyms tcc_syms[] = {\n#if !defined(CONFIG_TCCBOOT)\n    TCCSYM(printf)\n    TCCSYM(fprintf)\n    TCCSYM(fopen)\n    TCCSYM(fclose)\n#endif\n    { NULL, NULL },\n};\n\nvoid *resolve_sym(TCCState *s1, const char *symbol, int type)\n{\n    TCCSyms *p;\n    p = tcc_syms;\n    while (p->str != NULL) {\n        if (!strcmp(p->str, symbol))\n            return p->ptr;\n        p++;\n    }\n    return NULL;\n}\n\n#elif !defined(WIN32)\n\n#include <dlfcn.h>\n\nvoid *resolve_sym(TCCState *s1, const char *sym, int type)\n{\n  assert(0);\n  return 0; //dlsym(RTLD_DEFAULT, sym);\n  // jrs: remove need for dlsym\n}\n\n#endif\n\n/********************************************************/\n\n/* we use our own 'finite' function to avoid potential problems with\n   non standard math libs */\n/* XXX: endianness dependent */\nint ieee_finite(double d)\n{\n    int *p = (int *)&d;\n    return ((unsigned)((p[1] | 0x800fffff) + 1)) >> 31;\n}\n\n/* copy a string and truncate it. */\nstatic char *pstrcpy(char *buf, int buf_size, const char *s)\n{\n    char *q, *q_end;\n    int c;\n\n    if (buf_size > 0) {\n        q = buf;\n        q_end = buf + buf_size - 1;\n        while (q < q_end) {\n            c = *s++;\n            if (c == '\\0')\n                break;\n            *q++ = c;\n        }\n        *q = '\\0';\n    }\n    return buf;\n}\n\n/* strcat and truncate. */\nstatic char *pstrcat(char *buf, int buf_size, const char *s)\n{\n    int len;\n    len = strlen(buf);\n    if (len < buf_size) \n        pstrcpy(buf + len, buf_size - len, s);\n    return buf;\n}\n\nstatic int strstart(const char *str, const char *val, const char **ptr)\n{\n    const char *p, *q;\n    p = str;\n    q = val;\n    while (*q != '\\0') {\n        if (*p != *q)\n            return 0;\n        p++;\n        q++;\n    }\n    if (ptr)\n        *ptr = p;\n    return 1;\n}\n\n/* memory management */\n#ifdef MEM_DEBUG\nint mem_cur_size;\nint mem_max_size;\n#endif\n\nstatic inline void tcc_free(void *ptr)\n{\n#ifdef MEM_DEBUG\n    mem_cur_size -= malloc_usable_size(ptr);\n#endif\n    free(ptr);\n}\n\nstatic void *tcc_malloc(unsigned long size)\n{\n    void *ptr;\n    ptr = malloc(size);\n    if (!ptr && size)\n        error(\"memory full\");\n#ifdef MEM_DEBUG\n    mem_cur_size += malloc_usable_size(ptr);\n    if (mem_cur_size > mem_max_size)\n        mem_max_size = mem_cur_size;\n#endif\n    return ptr;\n}\n\nstatic void *tcc_mallocz(unsigned long size)\n{\n    void *ptr;\n    ptr = tcc_malloc(size);\n    memset(ptr, 0, size);\n    return ptr;\n}\n\nstatic inline void *tcc_realloc(void *ptr, unsigned long size)\n{\n    void *ptr1;\n#ifdef MEM_DEBUG\n    mem_cur_size -= malloc_usable_size(ptr);\n#endif\n    ptr1 = realloc(ptr, size);\n#ifdef MEM_DEBUG\n    /* NOTE: count not correct if alloc error, but not critical */\n    mem_cur_size += malloc_usable_size(ptr1);\n    if (mem_cur_size > mem_max_size)\n        mem_max_size = mem_cur_size;\n#endif\n    return ptr1;\n}\n\nstatic char *tcc_strdup(const char *str)\n{\n    char *ptr;\n    ptr = tcc_malloc(strlen(str) + 1);\n    strcpy(ptr, str);\n    return ptr;\n}\n\n#define free(p) use_tcc_free(p)\n#define malloc(s) use_tcc_malloc(s)\n#define realloc(p, s) use_tcc_realloc(p, s)\n\nstatic void dynarray_add(void ***ptab, int *nb_ptr, void *data)\n{\n    int nb, nb_alloc;\n    void **pp;\n    \n    nb = *nb_ptr;\n    pp = *ptab;\n    /* every power of two we double array size */\n    if ((nb & (nb - 1)) == 0) {\n        if (!nb)\n            nb_alloc = 1;\n        else\n            nb_alloc = nb * 2;\n        pp = tcc_realloc(pp, nb_alloc * sizeof(void *));\n        if (!pp)\n            error(\"memory full\");\n        *ptab = pp;\n    }\n    pp[nb++] = data;\n    *nb_ptr = nb;\n}\n\n/* symbol allocator */\nstatic Sym *__sym_malloc(void)\n{\n    Sym *sym_pool, *sym, *last_sym;\n    int i;\n\n    sym_pool = tcc_malloc(SYM_POOL_NB * sizeof(Sym));\n\n    last_sym = sym_free_first;\n    sym = sym_pool;\n    for(i = 0; i < SYM_POOL_NB; i++) {\n        sym->next = last_sym;\n        last_sym = sym;\n        sym++;\n    }\n    sym_free_first = last_sym;\n    return last_sym;\n}\n\nstatic inline Sym *sym_malloc(void)\n{\n    Sym *sym;\n    sym = sym_free_first;\n    if (!sym)\n        sym = __sym_malloc();\n    sym_free_first = sym->next;\n    return sym;\n}\n\nstatic inline void sym_free(Sym *sym)\n{\n    sym->next = sym_free_first;\n    sym_free_first = sym;\n}\n\nSection *new_section(TCCState *s1, const char *name, int sh_type, int sh_flags)\n{\n    Section *sec;\n\n    sec = tcc_mallocz(sizeof(Section) + strlen(name));\n    strcpy(sec->name, name);\n    sec->sh_type = sh_type;\n    sec->sh_flags = sh_flags;\n    switch(sh_type) {\n    case SHT_HASH:\n    case SHT_REL:\n    case SHT_DYNSYM:\n    case SHT_SYMTAB:\n    case SHT_DYNAMIC:\n        sec->sh_addralign = 4;\n        break;\n    case SHT_STRTAB:\n        sec->sh_addralign = 1;\n        break;\n    default:\n        sec->sh_addralign = 32; /* default conservative alignment */\n        break;\n    }\n\n    /* only add section if not private */\n    if (!(sh_flags & SHF_PRIVATE)) {\n        sec->sh_num = s1->nb_sections;\n        dynarray_add((void ***)&s1->sections, &s1->nb_sections, sec);\n    }\n    return sec;\n}\n\nstatic void free_section(Section *s)\n{\n    tcc_free(s->data);\n    tcc_free(s);\n}\n\n/* realloc section and set its content to zero */\nstatic void section_realloc(Section *sec, unsigned long new_size)\n{\n    unsigned long size;\n    unsigned char *data;\n    \n    size = sec->data_allocated;\n    if (size == 0)\n        size = 1;\n    while (size < new_size)\n        size = size * 2;\n    data = tcc_realloc(sec->data, size);\n    if (!data)\n        error(\"memory full\");\n    memset(data + sec->data_allocated, 0, size - sec->data_allocated);\n    sec->data = data;\n    sec->data_allocated = size;\n}\n\n/* reserve at least 'size' bytes in section 'sec' from\n   sec->data_offset. */\nstatic void *section_ptr_add(Section *sec, unsigned long size)\n{\n    unsigned long offset, offset1;\n\n    offset = sec->data_offset;\n    offset1 = offset + size;\n    if (offset1 > sec->data_allocated)\n        section_realloc(sec, offset1);\n    sec->data_offset = offset1;\n    return sec->data + offset;\n}\n\n/* return a reference to a section, and create it if it does not\n   exists */\nSection *find_section(TCCState *s1, const char *name)\n{\n    Section *sec;\n    int i;\n    for(i = 1; i < s1->nb_sections; i++) {\n        sec = s1->sections[i];\n        if (!strcmp(name, sec->name)) \n            return sec;\n    }\n    /* sections are created as PROGBITS */\n    return new_section(s1, name, SHT_PROGBITS, SHF_ALLOC);\n}\n\n#define SECTION_ABS ((void *)1)\n\n/* update sym->c so that it points to an external symbol in section\n   'section' with value 'value' */\nstatic void put_extern_sym2(Sym *sym, Section *section, \n                            unsigned long value, unsigned long size,\n                            int can_add_underscore)\n{\n    int sym_type, sym_bind, sh_num, info;\n    Elf32_Sym *esym;\n    const char *name;\n    char buf1[256];\n\n    if (section == NULL)\n        sh_num = SHN_UNDEF;\n    else if (section == SECTION_ABS) \n        sh_num = SHN_ABS;\n    else\n        sh_num = section->sh_num;\n    if (!sym->c) {\n        if ((sym->type.t & VT_BTYPE) == VT_FUNC)\n            sym_type = STT_FUNC;\n        else\n            sym_type = STT_OBJECT;\n        if (sym->type.t & VT_STATIC)\n            sym_bind = STB_LOCAL;\n        else\n            sym_bind = STB_GLOBAL;\n        \n        name = get_tok_str(sym->v, NULL);\n#ifdef CONFIG_TCC_BCHECK\n        if (do_bounds_check) {\n            char buf[32];\n\n            /* XXX: avoid doing that for statics ? */\n            /* if bound checking is activated, we change some function\n               names by adding the \"__bound\" prefix */\n            switch(sym->v) {\n#if 0\n            /* XXX: we rely only on malloc hooks */\n            case TOK_malloc: \n            case TOK_free: \n            case TOK_realloc: \n            case TOK_memalign: \n            case TOK_calloc: \n#endif\n            case TOK_memcpy: \n            case TOK_memmove:\n            case TOK_memset:\n            case TOK_strlen:\n            case TOK_strcpy:\n                strcpy(buf, \"__bound_\");\n                strcat(buf, name);\n                name = buf;\n                break;\n            }\n        }\n#endif\n        if (tcc_state->leading_underscore && can_add_underscore) {\n            buf1[0] = '_';\n            pstrcpy(buf1 + 1, sizeof(buf1) - 1, name);\n            name = buf1;\n        }\n        info = ELF32_ST_INFO(sym_bind, sym_type);\n        sym->c = add_elf_sym(symtab_section, value, size, info, 0, sh_num, name);\n    } else {\n        esym = &((Elf32_Sym *)symtab_section->data)[sym->c];\n        esym->st_value = value;\n        esym->st_size = size;\n        esym->st_shndx = sh_num;\n    }\n}\n\nstatic void put_extern_sym(Sym *sym, Section *section, \n                           unsigned long value, unsigned long size)\n{\n    put_extern_sym2(sym, section, value, size, 1);\n}\n\n/* add a new relocation entry to symbol 'sym' in section 's' */\nstatic void greloc(Section *s, Sym *sym, unsigned long offset, int type)\n{\n    if (!sym->c) \n        put_extern_sym(sym, NULL, 0, 0);\n    /* now we can add ELF relocation info */\n    put_elf_reloc(symtab_section, s, offset, type, sym->c);\n}\n\nstatic inline int isid(int c)\n{\n    return (c >= 'a' && c <= 'z') ||\n        (c >= 'A' && c <= 'Z') ||\n        c == '_';\n}\n\nstatic inline int isnum(int c)\n{\n    return c >= '0' && c <= '9';\n}\n\nstatic inline int isoct(int c)\n{\n    return c >= '0' && c <= '7';\n}\n\nstatic inline int toup(int c)\n{\n    if (c >= 'a' && c <= 'z')\n        return c - 'a' + 'A';\n    else\n        return c;\n}\n\nstatic void strcat_vprintf(char *buf, int buf_size, const char *fmt, va_list ap)\n{\n    int len;\n    len = strlen(buf);\n    vsnprintf(buf + len, buf_size - len, fmt, ap);\n}\n\nstatic void strcat_printf(char *buf, int buf_size, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    strcat_vprintf(buf, buf_size, fmt, ap);\n    va_end(ap);\n}\n\nvoid error1(TCCState *s1, int is_warning, const char *fmt, va_list ap)\n{\n    char buf[2048];\n    BufferedFile **f;\n    \n    buf[0] = '\\0';\n    if (file) {\n        for(f = s1->include_stack; f < s1->include_stack_ptr; f++)\n            strcat_printf(buf, sizeof(buf), \"In file included from %s:%d:\\n\", \n                          (*f)->filename, (*f)->line_num);\n        if (file->line_num > 0) {\n            strcat_printf(buf, sizeof(buf), \n                          \"%s:%d: \", file->filename, file->line_num);\n        } else {\n            strcat_printf(buf, sizeof(buf),\n                          \"%s: \", file->filename);\n        }\n    } else {\n        strcat_printf(buf, sizeof(buf),\n                      \"tcc: \");\n    }\n    if (is_warning)\n        strcat_printf(buf, sizeof(buf), \"warning: \");\n    strcat_vprintf(buf, sizeof(buf), fmt, ap);\n\n    if (!s1->error_func) {\n        /* default case: stderr */\n        fprintf(stderr, \"%s\\n\", buf);\n    } else {\n        s1->error_func(s1->error_opaque, buf);\n    }\n    if (!is_warning || s1->warn_error)\n        s1->nb_errors++;\n}\n\n#ifdef LIBTCC\nvoid tcc_set_error_func(TCCState *s, void *error_opaque,\n                        void (*error_func)(void *opaque, const char *msg))\n{\n    s->error_opaque = error_opaque;\n    s->error_func = error_func;\n}\n#endif\n\n/* error without aborting current compilation */\nvoid error_noabort(const char *fmt, ...)\n{\n    TCCState *s1 = tcc_state;\n    va_list ap;\n\n    va_start(ap, fmt);\n    error1(s1, 0, fmt, ap);\n    va_end(ap);\n}\n\nvoid error(const char *fmt, ...)\n{\n    TCCState *s1 = tcc_state;\n    va_list ap;\n\n    va_start(ap, fmt);\n    error1(s1, 0, fmt, ap);\n    va_end(ap);\n    /* better than nothing: in some cases, we accept to handle errors */\n    if (s1->error_set_jmp_enabled) {\n        longjmp(s1->error_jmp_buf, 1);\n    } else {\n        /* XXX: eliminate this someday */\n        exit(1);\n    }\n}\n\nvoid expect(const char *msg)\n{\n    error(\"%s expected\", msg);\n}\n\nvoid warning(const char *fmt, ...)\n{\n    TCCState *s1 = tcc_state;\n    va_list ap;\n\n    if (s1->warn_none)\n        return;\n\n    va_start(ap, fmt);\n    error1(s1, 1, fmt, ap);\n    va_end(ap);\n}\n\nvoid skip(int c)\n{\n    if (tok != c)\n        error(\"'%c' expected\", c);\n    next();\n}\n\nstatic void test_lvalue(void)\n{\n    if (!(vtop->r & VT_LVAL))\n        expect(\"lvalue\");\n}\n\n/* allocate a new token */\nstatic TokenSym *tok_alloc_new(TokenSym **pts, const char *str, int len)\n{\n    TokenSym *ts, **ptable;\n    int i;\n\n    if (tok_ident >= SYM_FIRST_ANOM) \n        error(\"memory full\");\n\n    /* expand token table if needed */\n    i = tok_ident - TOK_IDENT;\n    if ((i % TOK_ALLOC_INCR) == 0) {\n        ptable = tcc_realloc(table_ident, (i + TOK_ALLOC_INCR) * sizeof(TokenSym *));\n        if (!ptable)\n            error(\"memory full\");\n        table_ident = ptable;\n    }\n\n    ts = tcc_malloc(sizeof(TokenSym) + len);\n    table_ident[i] = ts;\n    ts->tok = tok_ident++;\n    ts->sym_define = NULL;\n    ts->sym_label = NULL;\n    ts->sym_struct = NULL;\n    ts->sym_identifier = NULL;\n    ts->len = len;\n    ts->hash_next = NULL;\n    memcpy(ts->str, str, len);\n    ts->str[len] = '\\0';\n    *pts = ts;\n    return ts;\n}\n\n#define TOK_HASH_INIT 1\n#define TOK_HASH_FUNC(h, c) ((h) * 263 + (c))\n\n/* find a token and add it if not found */\nstatic TokenSym *tok_alloc(const char *str, int len)\n{\n    TokenSym *ts, **pts;\n    int i;\n    unsigned int h;\n    \n    h = TOK_HASH_INIT;\n    for(i=0;i<len;i++)\n        h = TOK_HASH_FUNC(h, ((unsigned char *)str)[i]);\n    h &= (TOK_HASH_SIZE - 1);\n\n    pts = &hash_ident[h];\n    for(;;) {\n        ts = *pts;\n        if (!ts)\n            break;\n        if (ts->len == len && !memcmp(ts->str, str, len))\n            return ts;\n        pts = &(ts->hash_next);\n    }\n    return tok_alloc_new(pts, str, len);\n}\n\n/* CString handling */\n\nstatic void cstr_realloc(CString *cstr, int new_size)\n{\n    int size;\n    void *data;\n\n    size = cstr->size_allocated;\n    if (size == 0)\n        size = 8; /* no need to allocate a too small first string */\n    while (size < new_size)\n        size = size * 2;\n    data = tcc_realloc(cstr->data_allocated, size);\n    if (!data)\n        error(\"memory full\");\n    cstr->data_allocated = data;\n    cstr->size_allocated = size;\n    cstr->data = data;\n}\n\n/* add a byte */\nstatic inline void cstr_ccat(CString *cstr, int ch)\n{\n    int size;\n    size = cstr->size + 1;\n    if (size > cstr->size_allocated)\n        cstr_realloc(cstr, size);\n    ((unsigned char *)cstr->data)[size - 1] = ch;\n    cstr->size = size;\n}\n\nstatic void cstr_cat(CString *cstr, const char *str)\n{\n    int c;\n    for(;;) {\n        c = *str;\n        if (c == '\\0')\n            break;\n        cstr_ccat(cstr, c);\n        str++;\n    }\n}\n\n/* add a wide char */\nstatic void cstr_wccat(CString *cstr, int ch)\n{\n    int size;\n    size = cstr->size + sizeof(int);\n    if (size > cstr->size_allocated)\n        cstr_realloc(cstr, size);\n    *(int *)(((unsigned char *)cstr->data) + size - sizeof(int)) = ch;\n    cstr->size = size;\n}\n\nstatic void cstr_new(CString *cstr)\n{\n    memset(cstr, 0, sizeof(CString));\n}\n\n/* free string and reset it to NULL */\nstatic void cstr_free(CString *cstr)\n{\n    tcc_free(cstr->data_allocated);\n    cstr_new(cstr);\n}\n\n#define cstr_reset(cstr) cstr_free(cstr)\n\n/* XXX: unicode ? */\nstatic void add_char(CString *cstr, int c)\n{\n    if (c == '\\'' || c == '\\\"' || c == '\\\\') {\n        /* XXX: could be more precise if char or string */\n        cstr_ccat(cstr, '\\\\');\n    }\n    if (c >= 32 && c <= 126) {\n        cstr_ccat(cstr, c);\n    } else {\n        cstr_ccat(cstr, '\\\\');\n        if (c == '\\n') {\n            cstr_ccat(cstr, 'n');\n        } else {\n            cstr_ccat(cstr, '0' + ((c >> 6) & 7));\n            cstr_ccat(cstr, '0' + ((c >> 3) & 7));\n            cstr_ccat(cstr, '0' + (c & 7));\n        }\n    }\n}\n\n/* XXX: buffer overflow */\n/* XXX: float tokens */\nchar *get_tok_str(int v, CValue *cv)\n{\n    static char buf[STRING_MAX_SIZE + 1];\n    static CString cstr_buf;\n    CString *cstr;\n    unsigned char *q;\n    char *p;\n    int i, len;\n\n    /* NOTE: to go faster, we give a fixed buffer for small strings */\n    cstr_reset(&cstr_buf);\n    cstr_buf.data = buf;\n    cstr_buf.size_allocated = sizeof(buf);\n    p = buf;\n\n    switch(v) {\n    case TOK_CINT:\n    case TOK_CUINT:\n        /* XXX: not quite exact, but only useful for testing */\n        sprintf(p, \"%u\", cv->ui);\n        break;\n    case TOK_CLLONG:\n    case TOK_CULLONG:\n        /* XXX: not quite exact, but only useful for testing  */\n        sprintf(p, \"%llu\", cv->ull);\n        break;\n    case TOK_CCHAR:\n    case TOK_LCHAR:\n        cstr_ccat(&cstr_buf, '\\'');\n        add_char(&cstr_buf, cv->i);\n        cstr_ccat(&cstr_buf, '\\'');\n        cstr_ccat(&cstr_buf, '\\0');\n        break;\n    case TOK_PPNUM:\n        cstr = cv->cstr;\n        len = cstr->size - 1;\n        for(i=0;i<len;i++)\n            add_char(&cstr_buf, ((unsigned char *)cstr->data)[i]);\n        cstr_ccat(&cstr_buf, '\\0');\n        break;\n    case TOK_STR:\n    case TOK_LSTR:\n        cstr = cv->cstr;\n        cstr_ccat(&cstr_buf, '\\\"');\n        if (v == TOK_STR) {\n            len = cstr->size - 1;\n            for(i=0;i<len;i++)\n                add_char(&cstr_buf, ((unsigned char *)cstr->data)[i]);\n        } else {\n            len = (cstr->size / sizeof(int)) - 1;\n            for(i=0;i<len;i++)\n                add_char(&cstr_buf, ((int *)cstr->data)[i]);\n        }\n        cstr_ccat(&cstr_buf, '\\\"');\n        cstr_ccat(&cstr_buf, '\\0');\n        break;\n    case TOK_LT:\n        v = '<';\n        goto addv;\n    case TOK_GT:\n        v = '>';\n        goto addv;\n    case TOK_A_SHL:\n        return strcpy(p, \"<<=\");\n    case TOK_A_SAR:\n        return strcpy(p, \">>=\");\n    default:\n        if (v < TOK_IDENT) {\n            /* search in two bytes table */\n            q = tok_two_chars;\n            while (*q) {\n                if (q[2] == v) {\n                    *p++ = q[0];\n                    *p++ = q[1];\n                    *p = '\\0';\n                    return buf;\n                }\n                q += 3;\n            }\n        addv:\n            *p++ = v;\n            *p = '\\0';\n        } else if (v < tok_ident) {\n            return table_ident[v - TOK_IDENT]->str;\n        } else if (v >= SYM_FIRST_ANOM) {\n            /* special name for anonymous symbol */\n            sprintf(p, \"L.%u\", v - SYM_FIRST_ANOM);\n        } else {\n            /* should never happen */\n            return NULL;\n        }\n        break;\n    }\n    return cstr_buf.data;\n}\n\n/* push, without hashing */\nstatic Sym *sym_push2(Sym **ps, long v, long t, long c)\n{\n    Sym *s;\n    s = sym_malloc();\n    s->v = v;\n    s->type.t = t;\n    s->c = c;\n    s->next = NULL;\n    /* add in stack */\n    s->prev = *ps;\n    *ps = s;\n    return s;\n}\n\n/* find a symbol and return its associated structure. 's' is the top\n   of the symbol stack */\nstatic Sym *sym_find2(Sym *s, int v)\n{\n    while (s) {\n        if (s->v == v)\n            return s;\n        s = s->prev;\n    }\n    return NULL;\n}\n\n/* structure lookup */\nstatic inline Sym *struct_find(int v)\n{\n    v -= TOK_IDENT;\n    if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))\n        return NULL;\n    return table_ident[v]->sym_struct;\n}\n\n/* find an identifier */\nstatic inline Sym *sym_find(int v)\n{\n    v -= TOK_IDENT;\n    if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))\n        return NULL;\n    return table_ident[v]->sym_identifier;\n}\n\n/* push a given symbol on the symbol stack */\nstatic Sym *sym_push(int v, CType *type, int r, int c)\n{\n    Sym *s, **ps;\n    TokenSym *ts;\n\n    if (local_stack)\n        ps = &local_stack;\n    else\n        ps = &global_stack;\n    s = sym_push2(ps, v, type->t, c);\n    s->type.ref = type->ref;\n    s->r = r;\n    /* don't record fields or anonymous symbols */\n    /* XXX: simplify */\n    if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {\n        /* record symbol in token array */\n        ts = table_ident[(v & ~SYM_STRUCT) - TOK_IDENT];\n        if (v & SYM_STRUCT)\n            ps = &ts->sym_struct;\n        else\n            ps = &ts->sym_identifier;\n        s->prev_tok = *ps;\n        *ps = s;\n    }\n    return s;\n}\n\n/* push a global identifier */\nstatic Sym *global_identifier_push(int v, int t, int c)\n{\n    Sym *s, **ps;\n    s = sym_push2(&global_stack, v, t, c);\n    /* don't record anonymous symbol */\n    if (v < SYM_FIRST_ANOM) {\n        ps = &table_ident[v - TOK_IDENT]->sym_identifier;\n        /* modify the top most local identifier, so that\n           sym_identifier will point to 's' when popped */\n        while (*ps != NULL)\n            ps = &(*ps)->prev_tok;\n        s->prev_tok = NULL;\n        *ps = s;\n    }\n    return s;\n}\n\n/* pop symbols until top reaches 'b' */\nstatic void sym_pop(Sym **ptop, Sym *b)\n{\n    Sym *s, *ss, **ps;\n    TokenSym *ts;\n    int v;\n\n    s = *ptop;\n    while(s != b) {\n        ss = s->prev;\n        v = s->v;\n        /* remove symbol in token array */\n        /* XXX: simplify */\n        if (!(v & SYM_FIELD) && (v & ~SYM_STRUCT) < SYM_FIRST_ANOM) {\n            ts = table_ident[(v & ~SYM_STRUCT) - TOK_IDENT];\n            if (v & SYM_STRUCT)\n                ps = &ts->sym_struct;\n            else\n                ps = &ts->sym_identifier;\n            *ps = s->prev_tok;\n        }\n        sym_free(s);\n        s = ss;\n    }\n    *ptop = b;\n}\n\n/* I/O layer */\n\nBufferedFile *tcc_open(TCCState *s1, const char *filename)\n{\n    int fd;\n    BufferedFile *bf;\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0)\n        return NULL;\n    bf = tcc_malloc(sizeof(BufferedFile));\n    if (!bf) {\n        close(fd);\n        return NULL;\n    }\n    bf->fd = fd;\n    bf->buf_ptr = bf->buffer;\n    bf->buf_end = bf->buffer;\n    bf->buffer[0] = CH_EOB; /* put eob symbol */\n    pstrcpy(bf->filename, sizeof(bf->filename), filename);\n    bf->line_num = 1;\n    bf->ifndef_macro = 0;\n    bf->ifdef_stack_ptr = s1->ifdef_stack_ptr;\n    //    printf(\"opening '%s'\\n\", filename);\n    return bf;\n}\n\nvoid tcc_close(BufferedFile *bf)\n{\n    total_lines += bf->line_num;\n    close(bf->fd);\n    tcc_free(bf);\n}\n\n/* fill input buffer and peek next char */\nstatic int tcc_peekc_slow(BufferedFile *bf)\n{\n    int len;\n    /* only tries to read if really end of buffer */\n    if (bf->buf_ptr >= bf->buf_end) {\n        if (bf->fd != -1) {\n#if defined(PARSE_DEBUG)\n            len = 8;\n#else\n            len = IO_BUF_SIZE;\n#endif\n            len = read(bf->fd, bf->buffer, len);\n            if (len < 0)\n                len = 0;\n        } else {\n            len = 0;\n        }\n        total_bytes += len;\n        bf->buf_ptr = bf->buffer;\n        bf->buf_end = bf->buffer + len;\n        *bf->buf_end = CH_EOB;\n    }\n    if (bf->buf_ptr < bf->buf_end) {\n        return bf->buf_ptr[0];\n    } else {\n        bf->buf_ptr = bf->buf_end;\n        return CH_EOF;\n    }\n}\n\n/* return the current character, handling end of block if necessary\n   (but not stray) */\nstatic int handle_eob(void)\n{\n    return tcc_peekc_slow(file);\n}\n\n/* read next char from current input file and handle end of input buffer */\nstatic inline void inp(void)\n{\n    ch = *(++(file->buf_ptr));\n    /* end of buffer/file handling */\n    if (ch == CH_EOB)\n        ch = handle_eob();\n}\n\n/* handle '\\[\\r]\\n' */\nstatic void handle_stray(void)\n{\n    while (ch == '\\\\') {\n        inp();\n        if (ch == '\\n') {\n            file->line_num++;\n            inp();\n        } else if (ch == '\\r') {\n            inp();\n            if (ch != '\\n')\n                goto fail;\n            file->line_num++;\n            inp();\n        } else {\n        fail:\n            error(\"stray '\\\\' in program\");\n        }\n    }\n}\n\n/* skip the stray and handle the \\\\n case. Output an error if\n   incorrect char after the stray */\nstatic int handle_stray1(uint8_t *p)\n{\n    int c;\n\n    if (p >= file->buf_end) {\n        file->buf_ptr = p;\n        c = handle_eob();\n        p = file->buf_ptr;\n        if (c == '\\\\')\n            goto parse_stray;\n    } else {\n    parse_stray:\n        file->buf_ptr = p;\n        ch = *p;\n        handle_stray();\n        p = file->buf_ptr;\n        c = *p;\n    }\n    return c;\n}\n\n/* handle just the EOB case, but not stray */\n#define PEEKC_EOB(c, p)\\\n{\\\n    p++;\\\n    c = *p;\\\n    if (c == '\\\\') {\\\n        file->buf_ptr = p;\\\n        c = handle_eob();\\\n        p = file->buf_ptr;\\\n    }\\\n}\n\n/* handle the complicated stray case */\n#define PEEKC(c, p)\\\n{\\\n    p++;\\\n    c = *p;\\\n    if (c == '\\\\') {\\\n        c = handle_stray1(p);\\\n        p = file->buf_ptr;\\\n    }\\\n}\n\n/* input with '\\[\\r]\\n' handling. Note that this function cannot\n   handle other characters after '\\', so you cannot call it inside\n   strings or comments */\nstatic void minp(void)\n{\n    inp();\n    if (ch == '\\\\') \n        handle_stray();\n}\n\n\n/* single line C++ comments */\nstatic uint8_t *parse_line_comment(uint8_t *p)\n{\n    int c;\n\n    p++;\n    for(;;) {\n        c = *p;\n    redo:\n        if (c == '\\n' || c == CH_EOF) {\n            break;\n        } else if (c == '\\\\') {\n            file->buf_ptr = p;\n            c = handle_eob();\n            p = file->buf_ptr;\n            if (c == '\\\\') {\n                PEEKC_EOB(c, p);\n                if (c == '\\n') {\n                    file->line_num++;\n                    PEEKC_EOB(c, p);\n                } else if (c == '\\r') {\n                    PEEKC_EOB(c, p);\n                    if (c == '\\n') {\n                        file->line_num++;\n                        PEEKC_EOB(c, p);\n                    }\n                }\n            } else {\n                goto redo;\n            }\n        } else {\n            p++;\n        }\n    }\n    return p;\n}\n\n/* C comments */\nstatic uint8_t *parse_comment(uint8_t *p)\n{\n    int c;\n    \n    p++;\n    for(;;) {\n        /* fast skip loop */\n        for(;;) {\n            c = *p;\n            if (c == '\\n' || c == '*' || c == '\\\\')\n                break;\n            p++;\n            c = *p;\n            if (c == '\\n' || c == '*' || c == '\\\\')\n                break;\n            p++;\n        }\n        /* now we can handle all the cases */\n        if (c == '\\n') {\n            file->line_num++;\n            p++;\n        } else if (c == '*') {\n            p++;\n            for(;;) {\n                c = *p;\n                if (c == '*') {\n                    p++;\n                } else if (c == '/') {\n                    goto end_of_comment;\n                } else if (c == '\\\\') {\n                    file->buf_ptr = p;\n                    c = handle_eob();\n                    p = file->buf_ptr;\n                    if (c == '\\\\') {\n                        /* skip '\\[\\r]\\n', otherwise just skip the stray */\n                        while (c == '\\\\') {\n                            PEEKC_EOB(c, p);\n                            if (c == '\\n') {\n                                file->line_num++;\n                                PEEKC_EOB(c, p);\n                            } else if (c == '\\r') {\n                                PEEKC_EOB(c, p);\n                                if (c == '\\n') {\n                                    file->line_num++;\n                                    PEEKC_EOB(c, p);\n                                }\n                            } else {\n                                goto after_star;\n                            }\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n        after_star: ;\n        } else {\n            /* stray, eob or eof */\n            file->buf_ptr = p;\n            c = handle_eob();\n            p = file->buf_ptr;\n            if (c == CH_EOF) {\n                error(\"unexpected end of file in comment\");\n            } else if (c == '\\\\') {\n                p++;\n            }\n        }\n    }\n end_of_comment:\n    p++;\n    return p;\n}\n\n#define cinp minp\n\n/* space exlcuding newline */\nstatic inline int is_space(int ch)\n{\n    return ch == ' ' || ch == '\\t' || ch == '\\v' || ch == '\\f' || ch == '\\r';\n}\n\nstatic inline void skip_spaces(void)\n{\n    while (is_space(ch))\n        cinp();\n}\n\n/* parse a string without interpreting escapes */\nstatic uint8_t *parse_pp_string(uint8_t *p,\n                                int sep, CString *str)\n{\n    int c;\n    p++;\n    for(;;) {\n        c = *p;\n        if (c == sep) {\n            break;\n        } else if (c == '\\\\') {\n            file->buf_ptr = p;\n            c = handle_eob();\n            p = file->buf_ptr;\n            if (c == CH_EOF) {\n            unterminated_string:\n                /* XXX: indicate line number of start of string */\n                error(\"missing terminating %c character\", sep);\n            } else if (c == '\\\\') {\n                /* escape : just skip \\[\\r]\\n */\n                PEEKC_EOB(c, p);\n                if (c == '\\n') {\n                    file->line_num++;\n                    p++;\n                } else if (c == '\\r') {\n                    PEEKC_EOB(c, p);\n                    if (c != '\\n')\n                        expect(\"'\\n' after '\\r'\");\n                    file->line_num++;\n                    p++;\n                } else if (c == CH_EOF) {\n                    goto unterminated_string;\n                } else {\n                    if (str) {\n                        cstr_ccat(str, '\\\\');\n                        cstr_ccat(str, c);\n                    }\n                    p++;\n                }\n            }\n        } else if (c == '\\n') {\n            file->line_num++;\n            goto add_char;\n        } else if (c == '\\r') {\n            PEEKC_EOB(c, p);\n            if (c != '\\n') {\n                if (str)\n                    cstr_ccat(str, '\\r');\n            } else {\n                file->line_num++;\n                goto add_char;\n            }\n        } else {\n        add_char:\n            if (str)\n                cstr_ccat(str, c);\n            p++;\n        }\n    }\n    p++;\n    return p;\n}\n\n/* skip block of text until #else, #elif or #endif. skip also pairs of\n   #if/#endif */\nvoid preprocess_skip(void)\n{\n    int a, start_of_line, c;\n    uint8_t *p;\n\n    p = file->buf_ptr;\n    start_of_line = 1;\n    a = 0;\n    for(;;) {\n    redo_no_start:\n        c = *p;\n        switch(c) {\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\v':\n        case '\\r':\n            p++;\n            goto redo_no_start;\n        case '\\n':\n            start_of_line = 1;\n            file->line_num++;\n            p++;\n            goto redo_no_start;\n        case '\\\\':\n            file->buf_ptr = p;\n            c = handle_eob();\n            if (c == CH_EOF) {\n                expect(\"#endif\");\n            } else if (c == '\\\\') {\n                /* XXX: incorrect: should not give an error */\n                ch = file->buf_ptr[0];\n                handle_stray();\n            }\n            p = file->buf_ptr;\n            goto redo_no_start;\n            /* skip strings */\n        case '\\\"':\n        case '\\'':\n            p = parse_pp_string(p, c, NULL);\n            break;\n            /* skip comments */\n        case '/':\n            file->buf_ptr = p;\n            ch = *p;\n            minp();\n            p = file->buf_ptr;\n            if (ch == '*') {\n                p = parse_comment(p);\n            } else if (ch == '/') {\n                p = parse_line_comment(p);\n            }\n            break;\n\n        case '#':\n            p++;\n            if (start_of_line) {\n                file->buf_ptr = p;\n                next_nomacro();\n                p = file->buf_ptr;\n                if (a == 0 && \n                    (tok == TOK_ELSE || tok == TOK_ELIF || tok == TOK_ENDIF))\n                    goto the_end;\n                if (tok == TOK_IF || tok == TOK_IFDEF || tok == TOK_IFNDEF)\n                    a++;\n                else if (tok == TOK_ENDIF)\n                    a--;\n            }\n            break;\n        default:\n            p++;\n            break;\n        }\n        start_of_line = 0;\n    }\n the_end: ;\n    file->buf_ptr = p;\n}\n\n/* ParseState handling */\n\n/* XXX: currently, no include file info is stored. Thus, we cannot display\n   accurate messages if the function or data definition spans multiple\n   files */\n\n/* save current parse state in 's' */\nvoid save_parse_state(ParseState *s)\n{\n    s->line_num = file->line_num;\n    s->macro_ptr = macro_ptr;\n    s->tok = tok;\n    s->tokc = tokc;\n}\n\n/* restore parse state from 's' */\nvoid restore_parse_state(ParseState *s)\n{\n    file->line_num = s->line_num;\n    macro_ptr = s->macro_ptr;\n    tok = s->tok;\n    tokc = s->tokc;\n}\n\n/* return the number of additional 'ints' necessary to store the\n   token */\nstatic inline int tok_ext_size(int t)\n{\n    switch(t) {\n        /* 4 bytes */\n    case TOK_CINT:\n    case TOK_CUINT:\n    case TOK_CCHAR:\n    case TOK_LCHAR:\n    case TOK_CFLOAT:\n    case TOK_LINENUM:\n        return 1;\n    case TOK_STR:\n    case TOK_LSTR:\n    case TOK_PPNUM:\n        error(\"unsupported token\");\n        return 1;\n    case TOK_CDOUBLE:\n    case TOK_CLLONG:\n    case TOK_CULLONG:\n        return 2;\n    case TOK_CLDOUBLE:\n        return LDOUBLE_SIZE / 4;\n    default:\n        return 0;\n    }\n}\n\n/* token string handling */\n\nstatic inline void tok_str_new(TokenString *s)\n{\n    s->str = NULL;\n    s->len = 0;\n    s->allocated_len = 0;\n    s->last_line_num = -1;\n}\n\nstatic void tok_str_free(int *str)\n{\n    tcc_free(str);\n}\n\nstatic int *tok_str_realloc(TokenString *s)\n{\n    int *str, len;\n\n    if (s->allocated_len == 0) {\n        len = 8;\n    } else {\n        len = s->allocated_len * 2;\n    }\n    str = tcc_realloc(s->str, len * sizeof(int));\n    if (!str)\n        error(\"memory full\");\n    s->allocated_len = len;\n    s->str = str;\n    return str;\n}\n\nstatic void tok_str_add(TokenString *s, int t)\n{\n    int len, *str;\n\n    len = s->len;\n    str = s->str;\n    if (len >= s->allocated_len)\n        str = tok_str_realloc(s);\n    str[len++] = t;\n    s->len = len;\n}\n\nstatic void tok_str_add2(TokenString *s, int t, CValue *cv)\n{\n    int len, *str;\n\n    len = s->len;\n    str = s->str;\n\n    /* allocate space for worst case */\n    if (len + TOK_MAX_SIZE > s->allocated_len)\n        str = tok_str_realloc(s);\n    str[len++] = t;\n    switch(t) {\n    case TOK_CINT:\n    case TOK_CUINT:\n    case TOK_CCHAR:\n    case TOK_LCHAR:\n    case TOK_CFLOAT:\n    case TOK_LINENUM:\n        str[len++] = cv->tab[0];\n        break;\n    case TOK_PPNUM:\n    case TOK_STR:\n    case TOK_LSTR:\n        {\n            int nb_words;\n            CString *cstr;\n\n            nb_words = (sizeof(CString) + cv->cstr->size + 3) >> 2;\n            while ((len + nb_words) > s->allocated_len)\n                str = tok_str_realloc(s);\n            cstr = (CString *)(str + len);\n            cstr->data = NULL;\n            cstr->size = cv->cstr->size;\n            cstr->data_allocated = NULL;\n            cstr->size_allocated = cstr->size;\n            memcpy((char *)cstr + sizeof(CString), \n                   cv->cstr->data, cstr->size);\n            len += nb_words;\n        }\n        break;\n    case TOK_CDOUBLE:\n    case TOK_CLLONG:\n    case TOK_CULLONG:\n#if LDOUBLE_SIZE == 8\n    case TOK_CLDOUBLE:\n#endif\n        str[len++] = cv->tab[0];\n        str[len++] = cv->tab[1];\n        break;\n#if LDOUBLE_SIZE == 12\n    case TOK_CLDOUBLE:\n        str[len++] = cv->tab[0];\n        str[len++] = cv->tab[1];\n        str[len++] = cv->tab[2];\n#elif LDOUBLE_SIZE != 8\n#error add long double size support\n#endif\n        break;\n    default:\n        break;\n    }\n    s->len = len;\n}\n\n/* add the current parse token in token string 's' */\nstatic void tok_str_add_tok(TokenString *s)\n{\n    CValue cval;\n\n    /* save line number info */\n    if (file->line_num != s->last_line_num) {\n        s->last_line_num = file->line_num;\n        cval.i = s->last_line_num;\n        tok_str_add2(s, TOK_LINENUM, &cval);\n    }\n    tok_str_add2(s, tok, &tokc);\n}\n\n#if LDOUBLE_SIZE == 12\n#define LDOUBLE_GET(p, cv)                      \\\n        cv.tab[0] = p[0];                       \\\n        cv.tab[1] = p[1];                       \\\n        cv.tab[2] = p[2];\n#elif LDOUBLE_SIZE == 8\n#define LDOUBLE_GET(p, cv)                      \\\n        cv.tab[0] = p[0];                       \\\n        cv.tab[1] = p[1];\n#else\n#error add long double size support\n#endif\n\n\n/* get a token from an integer array and increment pointer\n   accordingly. we code it as a macro to avoid pointer aliasing. */\n#define TOK_GET(t, p, cv)                       \\\n{                                               \\\n    t = *p++;                                   \\\n    switch(t) {                                 \\\n    case TOK_CINT:                              \\\n    case TOK_CUINT:                             \\\n    case TOK_CCHAR:                             \\\n    case TOK_LCHAR:                             \\\n    case TOK_CFLOAT:                            \\\n    case TOK_LINENUM:                           \\\n        cv.tab[0] = *p++;                       \\\n        break;                                  \\\n    case TOK_STR:                               \\\n    case TOK_LSTR:                              \\\n    case TOK_PPNUM:                             \\\n        cv.cstr = (CString *)p;                 \\\n        cv.cstr->data = (char *)p + sizeof(CString);\\\n        p += (sizeof(CString) + cv.cstr->size + 3) >> 2;\\\n        break;                                  \\\n    case TOK_CDOUBLE:                           \\\n    case TOK_CLLONG:                            \\\n    case TOK_CULLONG:                           \\\n        cv.tab[0] = p[0];                       \\\n        cv.tab[1] = p[1];                       \\\n        p += 2;                                 \\\n        break;                                  \\\n    case TOK_CLDOUBLE:                          \\\n        LDOUBLE_GET(p, cv);                     \\\n        p += LDOUBLE_SIZE / 4;                  \\\n        break;                                  \\\n    default:                                    \\\n        break;                                  \\\n    }                                           \\\n}\n\n/* defines handling */\nstatic inline void define_push(int v, int macro_type, int *str, Sym *first_arg)\n{\n    Sym *s;\n\n    s = sym_push2(&define_stack, v, macro_type, (long)str);\n    s->next = first_arg;\n    table_ident[v - TOK_IDENT]->sym_define = s;\n}\n\n/* undefined a define symbol. Its name is just set to zero */\nstatic void define_undef(Sym *s)\n{\n    int v;\n    v = s->v;\n    if (v >= TOK_IDENT && v < tok_ident)\n        table_ident[v - TOK_IDENT]->sym_define = NULL;\n    s->v = 0;\n}\n\nstatic inline Sym *define_find(int v)\n{\n    v -= TOK_IDENT;\n    if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))\n        return NULL;\n    return table_ident[v]->sym_define;\n}\n\n/* free define stack until top reaches 'b' */\nstatic void free_defines(Sym *b)\n{\n    Sym *top, *top1;\n    int v;\n\n    top = define_stack;\n    while (top != b) {\n        top1 = top->prev;\n        /* do not free args or predefined defines */\n        if (top->c)\n            tok_str_free((int *)top->c);\n        v = top->v;\n        if (v >= TOK_IDENT && v < tok_ident)\n            table_ident[v - TOK_IDENT]->sym_define = NULL;\n        sym_free(top);\n        top = top1;\n    }\n    define_stack = b;\n}\n\n/* label lookup */\nstatic Sym *label_find(int v)\n{\n    v -= TOK_IDENT;\n    if ((unsigned)v >= (unsigned)(tok_ident - TOK_IDENT))\n        return NULL;\n    return table_ident[v]->sym_label;\n}\n\nstatic Sym *label_push(Sym **ptop, int v, int flags)\n{\n    Sym *s, **ps;\n    s = sym_push2(ptop, v, 0, 0);\n    s->r = flags;\n    ps = &table_ident[v - TOK_IDENT]->sym_label;\n    if (ptop == &global_label_stack) {\n        /* modify the top most local identifier, so that\n           sym_identifier will point to 's' when popped */\n        while (*ps != NULL)\n            ps = &(*ps)->prev_tok;\n    }\n    s->prev_tok = *ps;\n    *ps = s;\n    return s;\n}\n\n/* pop labels until element last is reached. Look if any labels are\n   undefined. Define symbols if '&&label' was used. */\nstatic void label_pop(Sym **ptop, Sym *slast)\n{\n    Sym *s, *s1;\n    for(s = *ptop; s != slast; s = s1) {\n        s1 = s->prev;\n        if (s->r == LABEL_DECLARED) {\n            warning(\"label '%s' declared but not used\", get_tok_str(s->v, NULL));\n        } else if (s->r == LABEL_FORWARD) {\n                error(\"label '%s' used but not defined\",\n                      get_tok_str(s->v, NULL));\n        } else {\n            if (s->c) {\n                /* define corresponding symbol. A size of\n                   1 is put. */\n                put_extern_sym(s, cur_text_section, (long)s->next, 1);\n            }\n        }\n        /* remove label */\n        table_ident[s->v - TOK_IDENT]->sym_label = s->prev_tok;\n        sym_free(s);\n    }\n    *ptop = slast;\n}\n\n/* eval an expression for #if/#elif */\nstatic int expr_preprocess(void)\n{\n    int c, t;\n    TokenString str;\n    \n    tok_str_new(&str);\n    while (tok != TOK_LINEFEED && tok != TOK_EOF) {\n        next(); /* do macro subst */\n        if (tok == TOK_DEFINED) {\n            next_nomacro();\n            t = tok;\n            if (t == '(') \n                next_nomacro();\n            c = define_find(tok) != 0;\n            if (t == '(')\n                next_nomacro();\n            tok = TOK_CINT;\n            tokc.i = c;\n        } else if (tok >= TOK_IDENT) {\n            /* if undefined macro */\n            tok = TOK_CINT;\n            tokc.i = 0;\n        }\n        tok_str_add_tok(&str);\n    }\n    tok_str_add(&str, -1); /* simulate end of file */\n    tok_str_add(&str, 0);\n    /* now evaluate C constant expression */\n    macro_ptr = str.str;\n    next();\n    c = expr_const();\n    macro_ptr = NULL;\n    tok_str_free(str.str);\n    return c != 0;\n}\n\n#if defined(PARSE_DEBUG) || defined(PP_DEBUG)\nstatic void tok_print(int *str)\n{\n    int t;\n    CValue cval;\n\n    while (1) {\n        TOK_GET(t, str, cval);\n        if (!t)\n            break;\n        printf(\" %s\", get_tok_str(t, &cval));\n    }\n    printf(\"\\n\");\n}\n#endif\n\n/* parse after #define */\nstatic void parse_define(void)\n{\n    Sym *s, *first, **ps;\n    int v, t, varg, is_vaargs, c;\n    TokenString str;\n    \n    v = tok;\n    if (v < TOK_IDENT)\n        error(\"invalid macro name '%s'\", get_tok_str(tok, &tokc));\n    /* XXX: should check if same macro (ANSI) */\n    first = NULL;\n    t = MACRO_OBJ;\n    /* '(' must be just after macro definition for MACRO_FUNC */\n    c = file->buf_ptr[0];\n    if (c == '\\\\')\n        c = handle_stray1(file->buf_ptr);\n    if (c == '(') {\n        next_nomacro();\n        next_nomacro();\n        ps = &first;\n        while (tok != ')') {\n            varg = tok;\n            next_nomacro();\n            is_vaargs = 0;\n            if (varg == TOK_DOTS) {\n                varg = TOK___VA_ARGS__;\n                is_vaargs = 1;\n            } else if (tok == TOK_DOTS && gnu_ext) {\n                is_vaargs = 1;\n                next_nomacro();\n            }\n            if (varg < TOK_IDENT)\n                error(\"badly punctuated parameter list\");\n            s = sym_push2(&define_stack, varg | SYM_FIELD, is_vaargs, 0);\n            *ps = s;\n            ps = &s->next;\n            if (tok != ',')\n                break;\n            next_nomacro();\n        }\n        t = MACRO_FUNC;\n    }\n    tok_str_new(&str);\n    next_nomacro();\n    /* EOF testing necessary for '-D' handling */\n    while (tok != TOK_LINEFEED && tok != TOK_EOF) {\n        tok_str_add2(&str, tok, &tokc);\n        next_nomacro();\n    }\n    tok_str_add(&str, 0);\n#ifdef PP_DEBUG\n    printf(\"define %s %d: \", get_tok_str(v, NULL), t);\n    tok_print(str.str);\n#endif\n    define_push(v, t, str.str, first);\n}\n\nstatic inline int hash_cached_include(int type, const char *filename)\n{\n    const unsigned char *s;\n    unsigned int h;\n\n    h = TOK_HASH_INIT;\n    h = TOK_HASH_FUNC(h, type);\n    s = filename;\n    while (*s) {\n        h = TOK_HASH_FUNC(h, *s);\n        s++;\n    }\n    h &= (CACHED_INCLUDES_HASH_SIZE - 1);\n    return h;\n}\n\n/* XXX: use a token or a hash table to accelerate matching ? */\nstatic CachedInclude *search_cached_include(TCCState *s1,\n                                            int type, const char *filename)\n{\n    CachedInclude *e;\n    int i, h;\n    h = hash_cached_include(type, filename);\n    i = s1->cached_includes_hash[h];\n    for(;;) {\n        if (i == 0)\n            break;\n        e = s1->cached_includes[i - 1];\n        if (e->type == type && !strcmp(e->filename, filename))\n            return e;\n        i = e->hash_next;\n    }\n    return NULL;\n}\n\nstatic inline void add_cached_include(TCCState *s1, int type, \n                                      const char *filename, int ifndef_macro)\n{\n    CachedInclude *e;\n    int h;\n\n    if (search_cached_include(s1, type, filename))\n        return;\n#ifdef INC_DEBUG\n    printf(\"adding cached '%s' %s\\n\", filename, get_tok_str(ifndef_macro, NULL));\n#endif\n    e = tcc_malloc(sizeof(CachedInclude) + strlen(filename));\n    if (!e)\n        return;\n    e->type = type;\n    strcpy(e->filename, filename);\n    e->ifndef_macro = ifndef_macro;\n    dynarray_add((void ***)&s1->cached_includes, &s1->nb_cached_includes, e);\n    /* add in hash table */\n    h = hash_cached_include(type, filename);\n    e->hash_next = s1->cached_includes_hash[h];\n    s1->cached_includes_hash[h] = s1->nb_cached_includes;\n}\n\nstatic void pragma_parse(TCCState *s1)\n{\n    int val;\n\n    next();\n    if (tok == TOK_pack) {\n        /*\n          This may be:\n          #pragma pack(1) // set\n          #pragma pack() // reset to default\n          #pragma pack(push,1) // push & set\n          #pragma pack(pop) // restore previous\n        */\n        next();\n        skip('(');\n        if (tok == TOK_ASM_pop) {\n            next();\n            if (s1->pack_stack_ptr <= s1->pack_stack) {\n            stk_error:\n                error(\"out of pack stack\");\n            }\n            s1->pack_stack_ptr--;\n        } else {\n            val = 0;\n            if (tok != ')') {\n                if (tok == TOK_ASM_push) {\n                    next();\n                    if (s1->pack_stack_ptr >= s1->pack_stack + PACK_STACK_SIZE - 1)\n                        goto stk_error;\n                    s1->pack_stack_ptr++;\n                    skip(',');\n                }\n                if (tok != TOK_CINT) {\n                pack_error:\n                    error(\"invalid pack pragma\");\n                }\n                val = tokc.i;\n                if (val < 1 || val > 16 || (val & (val - 1)) != 0)\n                    goto pack_error;\n                next();\n            }\n            *s1->pack_stack_ptr = val;\n            skip(')');\n        }\n    }\n}\n\n/* is_bof is true if first non space token at beginning of file */\nstatic void preprocess(int is_bof)\n{\n    TCCState *s1 = tcc_state;\n    int size, i, c, n, saved_parse_flags;\n    char buf[1024], *q, *p;\n    char buf1[1024];\n    BufferedFile *f;\n    Sym *s;\n    CachedInclude *e;\n    \n    saved_parse_flags = parse_flags;\n    parse_flags = PARSE_FLAG_PREPROCESS | PARSE_FLAG_TOK_NUM | \n        PARSE_FLAG_LINEFEED;\n    next_nomacro();\n redo:\n    switch(tok) {\n    case TOK_DEFINE:\n        next_nomacro();\n        parse_define();\n        break;\n    case TOK_UNDEF:\n        next_nomacro();\n        s = define_find(tok);\n        /* undefine symbol by putting an invalid name */\n        if (s)\n            define_undef(s);\n        break;\n    case TOK_INCLUDE:\n    case TOK_INCLUDE_NEXT:\n        ch = file->buf_ptr[0];\n        /* XXX: incorrect if comments : use next_nomacro with a special mode */\n        skip_spaces();\n        if (ch == '<') {\n            c = '>';\n            goto read_name;\n        } else if (ch == '\\\"') {\n            c = ch;\n        read_name:\n            /* XXX: better stray handling */\n            minp();\n            q = buf;\n            while (ch != c && ch != '\\n' && ch != CH_EOF) {\n                if ((q - buf) < sizeof(buf) - 1)\n                    *q++ = ch;\n                minp();\n            }\n            *q = '\\0';\n            minp();\n#if 0\n            /* eat all spaces and comments after include */\n            /* XXX: slightly incorrect */\n            while (ch1 != '\\n' && ch1 != CH_EOF)\n                inp();\n#endif\n        } else {\n            /* computed #include : either we have only strings or\n               we have anything enclosed in '<>' */\n            next();\n            buf[0] = '\\0';\n            if (tok == TOK_STR) {\n                while (tok != TOK_LINEFEED) {\n                    if (tok != TOK_STR) {\n                    include_syntax:\n                        error(\"'#include' expects \\\"FILENAME\\\" or <FILENAME>\");\n                    }\n                    pstrcat(buf, sizeof(buf), (char *)tokc.cstr->data);\n                    next();\n                }\n                c = '\\\"';\n            } else {\n                int len;\n                while (tok != TOK_LINEFEED) {\n                    pstrcat(buf, sizeof(buf), get_tok_str(tok, &tokc));\n                    next();\n                }\n                len = strlen(buf);\n                /* check syntax and remove '<>' */\n                if (len < 2 || buf[0] != '<' || buf[len - 1] != '>')\n                    goto include_syntax;\n                memmove(buf, buf + 1, len - 2);\n                buf[len - 2] = '\\0';\n                c = '>';\n            }\n        }\n\n        e = search_cached_include(s1, c, buf);\n        if (e && define_find(e->ifndef_macro)) {\n            /* no need to parse the include because the 'ifndef macro'\n               is defined */\n#ifdef INC_DEBUG\n            printf(\"%s: skipping %s\\n\", file->filename, buf);\n#endif\n        } else {\n            if (c == '\\\"') {\n                /* first search in current dir if \"header.h\" */\n                size = 0;\n                p = strrchr(file->filename, '/');\n                if (p) \n                    size = p + 1 - file->filename;\n                if (size > sizeof(buf1) - 1)\n                    size = sizeof(buf1) - 1;\n                memcpy(buf1, file->filename, size);\n                buf1[size] = '\\0';\n                pstrcat(buf1, sizeof(buf1), buf);\n                f = tcc_open(s1, buf1);\n                if (f) {\n                    if (tok == TOK_INCLUDE_NEXT)\n                        tok = TOK_INCLUDE;\n                    else\n                        goto found;\n                }\n            }\n            if (s1->include_stack_ptr >= s1->include_stack + INCLUDE_STACK_SIZE)\n                error(\"#include recursion too deep\");\n            /* now search in all the include paths */\n            n = s1->nb_include_paths + s1->nb_sysinclude_paths;\n            for(i = 0; i < n; i++) {\n                const char *path;\n                if (i < s1->nb_include_paths)\n                    path = s1->include_paths[i];\n                else\n                    path = s1->sysinclude_paths[i - s1->nb_include_paths];\n                pstrcpy(buf1, sizeof(buf1), path);\n                pstrcat(buf1, sizeof(buf1), \"/\");\n                pstrcat(buf1, sizeof(buf1), buf);\n                f = tcc_open(s1, buf1);\n                if (f) {\n                    if (tok == TOK_INCLUDE_NEXT)\n                        tok = TOK_INCLUDE;\n                    else\n                        goto found;\n                }\n            }\n            error(\"include file '%s' not found\", buf);\n            f = NULL;\n        found:\n#ifdef INC_DEBUG\n            printf(\"%s: including %s\\n\", file->filename, buf1);\n#endif\n            f->inc_type = c;\n            pstrcpy(f->inc_filename, sizeof(f->inc_filename), buf);\n            /* push current file in stack */\n            /* XXX: fix current line init */\n            *s1->include_stack_ptr++ = file;\n            file = f;\n            /* add include file debug info */\n            if (do_debug) {\n                put_stabs(file->filename, N_BINCL, 0, 0, 0);\n            }\n            tok_flags |= TOK_FLAG_BOF | TOK_FLAG_BOL;\n            ch = file->buf_ptr[0];\n            goto the_end;\n        }\n        break;\n    case TOK_IFNDEF:\n        c = 1;\n        goto do_ifdef;\n    case TOK_IF:\n        c = expr_preprocess();\n        goto do_if;\n    case TOK_IFDEF:\n        c = 0;\n    do_ifdef:\n        next_nomacro();\n        if (tok < TOK_IDENT)\n            error(\"invalid argument for '#if%sdef'\", c ? \"n\" : \"\");\n        if (is_bof) {\n            if (c) {\n#ifdef INC_DEBUG\n                printf(\"#ifndef %s\\n\", get_tok_str(tok, NULL));\n#endif\n                file->ifndef_macro = tok;\n            }\n        }\n        c = (define_find(tok) != 0) ^ c;\n    do_if:\n        if (s1->ifdef_stack_ptr >= s1->ifdef_stack + IFDEF_STACK_SIZE)\n            error(\"memory full\");\n        *s1->ifdef_stack_ptr++ = c;\n        goto test_skip;\n    case TOK_ELSE:\n        if (s1->ifdef_stack_ptr == s1->ifdef_stack)\n            error(\"#else without matching #if\");\n        if (s1->ifdef_stack_ptr[-1] & 2)\n            error(\"#else after #else\");\n        c = (s1->ifdef_stack_ptr[-1] ^= 3);\n        goto test_skip;\n    case TOK_ELIF:\n        if (s1->ifdef_stack_ptr == s1->ifdef_stack)\n            error(\"#elif without matching #if\");\n        c = s1->ifdef_stack_ptr[-1];\n        if (c > 1)\n            error(\"#elif after #else\");\n        /* last #if/#elif expression was true: we skip */\n        if (c == 1)\n            goto skip;\n        c = expr_preprocess();\n        s1->ifdef_stack_ptr[-1] = c;\n    test_skip:\n        if (!(c & 1)) {\n        skip:\n            preprocess_skip();\n            is_bof = 0;\n            goto redo;\n        }\n        break;\n    case TOK_ENDIF:\n        if (s1->ifdef_stack_ptr <= file->ifdef_stack_ptr)\n            error(\"#endif without matching #if\");\n        s1->ifdef_stack_ptr--;\n        /* '#ifndef macro' was at the start of file. Now we check if\n           an '#endif' is exactly at the end of file */\n        if (file->ifndef_macro &&\n            s1->ifdef_stack_ptr == file->ifdef_stack_ptr) {\n            file->ifndef_macro_saved = file->ifndef_macro;\n            /* need to set to zero to avoid false matches if another\n               #ifndef at middle of file */\n            file->ifndef_macro = 0;\n            while (tok != TOK_LINEFEED)\n                next_nomacro();\n            tok_flags |= TOK_FLAG_ENDIF;\n            goto the_end;\n        }\n        break;\n    case TOK_LINE:\n        next();\n        if (tok != TOK_CINT)\n            error(\"#line\");\n        file->line_num = tokc.i - 1; /* the line number will be incremented after */\n        next();\n        if (tok != TOK_LINEFEED) {\n            if (tok != TOK_STR)\n                error(\"#line\");\n            pstrcpy(file->filename, sizeof(file->filename), \n                    (char *)tokc.cstr->data);\n        }\n        break;\n    case TOK_ERROR:\n    case TOK_WARNING:\n        c = tok;\n        ch = file->buf_ptr[0];\n        skip_spaces();\n        q = buf;\n        while (ch != '\\n' && ch != CH_EOF) {\n            if ((q - buf) < sizeof(buf) - 1)\n                *q++ = ch;\n            minp();\n        }\n        *q = '\\0';\n        if (c == TOK_ERROR)\n            error(\"#error %s\", buf);\n        else\n            warning(\"#warning %s\", buf);\n        break;\n    case TOK_PRAGMA:\n        pragma_parse(s1);\n        break;\n    default:\n        if (tok == TOK_LINEFEED || tok == '!' || tok == TOK_CINT) {\n            /* '!' is ignored to allow C scripts. numbers are ignored\n               to emulate cpp behaviour */\n        } else {\n            if (!(saved_parse_flags & PARSE_FLAG_ASM_COMMENTS))\n                error(\"invalid preprocessing directive #%s\", get_tok_str(tok, &tokc));\n        }\n        break;\n    }\n    /* ignore other preprocess commands or #! for C scripts */\n    while (tok != TOK_LINEFEED)\n        next_nomacro();\n the_end:\n    parse_flags = saved_parse_flags;\n}\n\n/* evaluate escape codes in a string. */\nstatic void parse_escape_string(CString *outstr, const uint8_t *buf, int is_long)\n{\n    int c, n;\n    const uint8_t *p;\n\n    p = buf;\n    for(;;) {\n        c = *p;\n        if (c == '\\0')\n            break;\n        if (c == '\\\\') {\n            p++;\n            /* escape */\n            c = *p;\n            switch(c) {\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n                /* at most three octal digits */\n                n = c - '0';\n                p++;\n                c = *p;\n                if (isoct(c)) {\n                    n = n * 8 + c - '0';\n                    p++;\n                    c = *p;\n                    if (isoct(c)) {\n                        n = n * 8 + c - '0';\n                        p++;\n                    }\n                }\n                c = n;\n                goto add_char_nonext;\n            case 'x':\n                p++;\n                n = 0;\n                for(;;) {\n                    c = *p;\n                    if (c >= 'a' && c <= 'f')\n                        c = c - 'a' + 10;\n                    else if (c >= 'A' && c <= 'F')\n                        c = c - 'A' + 10;\n                    else if (isnum(c))\n                        c = c - '0';\n                    else\n                        break;\n                    n = n * 16 + c;\n                    p++;\n                }\n                c = n;\n                goto add_char_nonext;\n            case 'a':\n                c = '\\a';\n                break;\n            case 'b':\n                c = '\\b';\n                break;\n            case 'f':\n                c = '\\f';\n                break;\n            case 'n':\n                c = '\\n';\n                break;\n            case 'r':\n                c = '\\r';\n                break;\n            case 't':\n                c = '\\t';\n                break;\n            case 'v':\n                c = '\\v';\n                break;\n            case 'e':\n                if (!gnu_ext)\n                    goto invalid_escape;\n                c = 27;\n                break;\n            case '\\'':\n            case '\\\"':\n            case '\\\\': \n            case '?':\n                break;\n            default:\n            invalid_escape:\n                if (c >= '!' && c <= '~')\n                    warning(\"unknown escape sequence: \\'\\\\%c\\'\", c);\n                else\n                    warning(\"unknown escape sequence: \\'\\\\x%x\\'\", c);\n                break;\n            }\n        }\n        p++;\n    add_char_nonext:\n        if (!is_long)\n            cstr_ccat(outstr, c);\n        else\n            cstr_wccat(outstr, c);\n    }\n    /* add a trailing '\\0' */\n    if (!is_long)\n        cstr_ccat(outstr, '\\0');\n    else\n        cstr_wccat(outstr, '\\0');\n}\n\n/* we use 64 bit numbers */\n#define BN_SIZE 2\n\n/* bn = (bn << shift) | or_val */\nvoid bn_lshift(unsigned int *bn, int shift, int or_val)\n{\n    int i;\n    unsigned int v;\n    for(i=0;i<BN_SIZE;i++) {\n        v = bn[i];\n        bn[i] = (v << shift) | or_val;\n        or_val = v >> (32 - shift);\n    }\n}\n\nvoid bn_zero(unsigned int *bn)\n{\n    int i;\n    for(i=0;i<BN_SIZE;i++) {\n        bn[i] = 0;\n    }\n}\n\n/* parse number in null terminated string 'p' and return it in the\n   current token */\nvoid parse_number(const char *p)\n{\n    int b, t, shift, frac_bits, s, exp_val, ch;\n    char *q;\n    unsigned int bn[BN_SIZE];\n    double d;\n\n    /* number */\n    q = token_buf;\n    ch = *p++;\n    t = ch;\n    ch = *p++;\n    *q++ = t;\n    b = 10;\n    if (t == '.') {\n        goto float_frac_parse;\n    } else if (t == '0') {\n        if (ch == 'x' || ch == 'X') {\n            q--;\n            ch = *p++;\n            b = 16;\n        } else if (tcc_ext && (ch == 'b' || ch == 'B')) {\n            q--;\n            ch = *p++;\n            b = 2;\n        }\n    }\n    /* parse all digits. cannot check octal numbers at this stage\n       because of floating point constants */\n    while (1) {\n        if (ch >= 'a' && ch <= 'f')\n            t = ch - 'a' + 10;\n        else if (ch >= 'A' && ch <= 'F')\n            t = ch - 'A' + 10;\n        else if (isnum(ch))\n            t = ch - '0';\n        else\n            break;\n        if (t >= b)\n            break;\n        if (q >= token_buf + STRING_MAX_SIZE) {\n        num_too_long:\n            error(\"number too long\");\n        }\n        *q++ = ch;\n        ch = *p++;\n    }\n    if (ch == '.' ||\n        ((ch == 'e' || ch == 'E') && b == 10) ||\n        ((ch == 'p' || ch == 'P') && (b == 16 || b == 2))) {\n        if (b != 10) {\n            /* NOTE: strtox should support that for hexa numbers, but\n               non ISOC99 libcs do not support it, so we prefer to do\n               it by hand */\n            /* hexadecimal or binary floats */\n            /* XXX: handle overflows */\n            *q = '\\0';\n            if (b == 16)\n                shift = 4;\n            else \n                shift = 2;\n            bn_zero(bn);\n            q = token_buf;\n            while (1) {\n                t = *q++;\n                if (t == '\\0') {\n                    break;\n                } else if (t >= 'a') {\n                    t = t - 'a' + 10;\n                } else if (t >= 'A') {\n                    t = t - 'A' + 10;\n                } else {\n                    t = t - '0';\n                }\n                bn_lshift(bn, shift, t);\n            }\n            frac_bits = 0;\n            if (ch == '.') {\n                ch = *p++;\n                while (1) {\n                    t = ch;\n                    if (t >= 'a' && t <= 'f') {\n                        t = t - 'a' + 10;\n                    } else if (t >= 'A' && t <= 'F') {\n                        t = t - 'A' + 10;\n                    } else if (t >= '0' && t <= '9') {\n                        t = t - '0';\n                    } else {\n                        break;\n                    }\n                    if (t >= b)\n                        error(\"invalid digit\");\n                    bn_lshift(bn, shift, t);\n                    frac_bits += shift;\n                    ch = *p++;\n                }\n            }\n            if (ch != 'p' && ch != 'P')\n                expect(\"exponent\");\n            ch = *p++;\n            s = 1;\n            exp_val = 0;\n            if (ch == '+') {\n                ch = *p++;\n            } else if (ch == '-') {\n                s = -1;\n                ch = *p++;\n            }\n            if (ch < '0' || ch > '9')\n                expect(\"exponent digits\");\n            while (ch >= '0' && ch <= '9') {\n                exp_val = exp_val * 10 + ch - '0';\n                ch = *p++;\n            }\n            exp_val = exp_val * s;\n            \n            /* now we can generate the number */\n            /* XXX: should patch directly float number */\n            d = (double)bn[1] * 4294967296.0 + (double)bn[0];\n            d = ldexp(d, exp_val - frac_bits);\n            t = toup(ch);\n            if (t == 'F') {\n                ch = *p++;\n                tok = TOK_CFLOAT;\n                /* float : should handle overflow */\n                tokc.f = (float)d;\n            } else if (t == 'L') {\n                ch = *p++;\n                tok = TOK_CLDOUBLE;\n                /* XXX: not large enough */\n                tokc.ld = (long double)d;\n            } else {\n                tok = TOK_CDOUBLE;\n                tokc.d = d;\n            }\n        } else {\n            /* decimal floats */\n            if (ch == '.') {\n                if (q >= token_buf + STRING_MAX_SIZE)\n                    goto num_too_long;\n                *q++ = ch;\n                ch = *p++;\n            float_frac_parse:\n                while (ch >= '0' && ch <= '9') {\n                    if (q >= token_buf + STRING_MAX_SIZE)\n                        goto num_too_long;\n                    *q++ = ch;\n                    ch = *p++;\n                }\n            }\n            if (ch == 'e' || ch == 'E') {\n                if (q >= token_buf + STRING_MAX_SIZE)\n                    goto num_too_long;\n                *q++ = ch;\n                ch = *p++;\n                if (ch == '-' || ch == '+') {\n                    if (q >= token_buf + STRING_MAX_SIZE)\n                        goto num_too_long;\n                    *q++ = ch;\n                    ch = *p++;\n                }\n                if (ch < '0' || ch > '9')\n                    expect(\"exponent digits\");\n                while (ch >= '0' && ch <= '9') {\n                    if (q >= token_buf + STRING_MAX_SIZE)\n                        goto num_too_long;\n                    *q++ = ch;\n                    ch = *p++;\n                }\n            }\n            *q = '\\0';\n            t = toup(ch);\n            errno = 0;\n            if (t == 'F') {\n                ch = *p++;\n                tok = TOK_CFLOAT;\n                tokc.f = strtof(token_buf, NULL);\n            } else if (t == 'L') {\n                ch = *p++;\n                tok = TOK_CLDOUBLE;\n                tokc.ld = strtold(token_buf, NULL);\n            } else {\n                tok = TOK_CDOUBLE;\n                tokc.d = strtod(token_buf, NULL);\n            }\n        }\n    } else {\n        unsigned long long n, n1;\n        int lcount, ucount;\n\n        /* integer number */\n        *q = '\\0';\n        q = token_buf;\n        if (b == 10 && *q == '0') {\n            b = 8;\n            q++;\n        }\n        n = 0;\n        while(1) {\n            t = *q++;\n            /* no need for checks except for base 10 / 8 errors */\n            if (t == '\\0') {\n                break;\n            } else if (t >= 'a') {\n                t = t - 'a' + 10;\n            } else if (t >= 'A') {\n                t = t - 'A' + 10;\n            } else {\n                t = t - '0';\n                if (t >= b)\n                    error(\"invalid digit\");\n            }\n            n1 = n;\n            n = n * b + t;\n            /* detect overflow */\n            /* XXX: this test is not reliable */\n            if (n < n1)\n                error(\"integer constant overflow\");\n        }\n        \n        /* XXX: not exactly ANSI compliant */\n        if ((n & 0xffffffff00000000LL) != 0) {\n            if ((n >> 63) != 0)\n                tok = TOK_CULLONG;\n            else\n                tok = TOK_CLLONG;\n        } else if (n > 0x7fffffff) {\n            tok = TOK_CUINT;\n        } else {\n            tok = TOK_CINT;\n        }\n        lcount = 0;\n        ucount = 0;\n        for(;;) {\n            t = toup(ch);\n            if (t == 'L') {\n                if (lcount >= 2)\n                    error(\"three 'l's in integer constant\");\n                lcount++;\n                if (lcount == 2) {\n                    if (tok == TOK_CINT)\n                        tok = TOK_CLLONG;\n                    else if (tok == TOK_CUINT)\n                        tok = TOK_CULLONG;\n                }\n                ch = *p++;\n            } else if (t == 'U') {\n                if (ucount >= 1)\n                    error(\"two 'u's in integer constant\");\n                ucount++;\n                if (tok == TOK_CINT)\n                    tok = TOK_CUINT;\n                else if (tok == TOK_CLLONG)\n                    tok = TOK_CULLONG;\n                ch = *p++;\n            } else {\n                break;\n            }\n        }\n        if (tok == TOK_CINT || tok == TOK_CUINT)\n            tokc.ui = n;\n        else\n            tokc.ull = n;\n    }\n}\n\n\n#define PARSE2(c1, tok1, c2, tok2)              \\\n    case c1:                                    \\\n        PEEKC(c, p);                            \\\n        if (c == c2) {                          \\\n            p++;                                \\\n            tok = tok2;                         \\\n        } else {                                \\\n            tok = tok1;                         \\\n        }                                       \\\n        break;\n\n/* return next token without macro substitution */\nstatic /*inline*/ void next_nomacro1(void)\n{\n    int t, c, is_long;\n    TokenSym *ts;\n    uint8_t *p, *p1;\n    unsigned int h;\n\n    p = file->buf_ptr;\n redo_no_start:\n    c = *p;\n    switch(c) {\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\v':\n    case '\\r':\n        p++;\n        goto redo_no_start;\n        \n    case '\\\\':\n        /* first look if it is in fact an end of buffer */\n        if (p >= file->buf_end) {\n            file->buf_ptr = p;\n            handle_eob();\n            p = file->buf_ptr;\n            if (p >= file->buf_end)\n                goto parse_eof;\n            else\n                goto redo_no_start;\n        } else {\n            file->buf_ptr = p;\n            ch = *p;\n            handle_stray();\n            p = file->buf_ptr;\n            goto redo_no_start;\n        }\n    parse_eof:\n        {\n            TCCState *s1 = tcc_state;\n            if (parse_flags & PARSE_FLAG_LINEFEED) {\n                tok = TOK_LINEFEED;\n            } else if (s1->include_stack_ptr == s1->include_stack ||\n                       !(parse_flags & PARSE_FLAG_PREPROCESS)) {\n                /* no include left : end of file. */\n                tok = TOK_EOF;\n            } else {\n                /* pop include file */\n                \n                /* test if previous '#endif' was after a #ifdef at\n                   start of file */\n                if (tok_flags & TOK_FLAG_ENDIF) {\n#ifdef INC_DEBUG\n                    printf(\"#endif %s\\n\", get_tok_str(file->ifndef_macro_saved, NULL));\n#endif\n                    add_cached_include(s1, file->inc_type, file->inc_filename,\n                                       file->ifndef_macro_saved);\n                }\n\n                /* add end of include file debug info */\n                if (do_debug) {\n                    put_stabd(N_EINCL, 0, 0);\n                }\n                /* pop include stack */\n                tcc_close(file);\n                s1->include_stack_ptr--;\n                file = *s1->include_stack_ptr;\n                p = file->buf_ptr;\n                goto redo_no_start;\n            }\n        }\n        break;\n\n    case '\\n':\n        if (parse_flags & PARSE_FLAG_LINEFEED) {\n            tok = TOK_LINEFEED;\n        } else {\n            file->line_num++;\n            tok_flags |= TOK_FLAG_BOL;\n            p++;\n            goto redo_no_start;\n        }\n        break;\n\n    case '#':\n        /* XXX: simplify */\n        PEEKC(c, p);\n        if ((tok_flags & TOK_FLAG_BOL) && \n            (parse_flags & PARSE_FLAG_PREPROCESS)) {\n            file->buf_ptr = p;\n            preprocess(tok_flags & TOK_FLAG_BOF);\n            p = file->buf_ptr;\n            goto redo_no_start;\n        } else {\n            if (c == '#') {\n                p++;\n                tok = TOK_TWOSHARPS;\n            } else {\n                if (parse_flags & PARSE_FLAG_ASM_COMMENTS) {\n                    p = parse_line_comment(p - 1);\n                    goto redo_no_start;\n                } else {\n                    tok = '#';\n                }\n            }\n        }\n        break;\n\n    case 'a': case 'b': case 'c': case 'd':\n    case 'e': case 'f': case 'g': case 'h':\n    case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p':\n    case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z': \n    case 'A': case 'B': case 'C': case 'D':\n    case 'E': case 'F': case 'G': case 'H':\n    case 'I': case 'J': case 'K': \n    case 'M': case 'N': case 'O': case 'P':\n    case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z': \n    case '_':\n    parse_ident_fast:\n        p1 = p;\n        h = TOK_HASH_INIT;\n        h = TOK_HASH_FUNC(h, c);\n        p++;\n        for(;;) {\n            c = *p;\n            if (!isidnum_table[c])\n                break;\n            h = TOK_HASH_FUNC(h, c);\n            p++;\n        }\n        if (c != '\\\\') {\n            TokenSym **pts;\n            int len;\n\n            /* fast case : no stray found, so we have the full token\n               and we have already hashed it */\n            len = p - p1;\n            h &= (TOK_HASH_SIZE - 1);\n            pts = &hash_ident[h];\n            for(;;) {\n                ts = *pts;\n                if (!ts)\n                    break;\n                if (ts->len == len && !memcmp(ts->str, p1, len))\n                    goto token_found;\n                pts = &(ts->hash_next);\n            }\n            ts = tok_alloc_new(pts, p1, len);\n        token_found: ;\n        } else {\n            /* slower case */\n            cstr_reset(&tokcstr);\n\n            while (p1 < p) {\n                cstr_ccat(&tokcstr, *p1);\n                p1++;\n            }\n            p--;\n            PEEKC(c, p);\n        parse_ident_slow:\n            while (isidnum_table[c]) {\n                cstr_ccat(&tokcstr, c);\n                PEEKC(c, p);\n            }\n            ts = tok_alloc(tokcstr.data, tokcstr.size);\n        }\n        tok = ts->tok;\n        break;\n    case 'L':\n        t = p[1];\n        if (t != '\\\\' && t != '\\'' && t != '\\\"') {\n            /* fast case */\n            goto parse_ident_fast;\n        } else {\n            PEEKC(c, p);\n            if (c == '\\'' || c == '\\\"') {\n                is_long = 1;\n                goto str_const;\n            } else {\n                cstr_reset(&tokcstr);\n                cstr_ccat(&tokcstr, 'L');\n                goto parse_ident_slow;\n            }\n        }\n        break;\n    case '0': case '1': case '2': case '3':\n    case '4': case '5': case '6': case '7':\n    case '8': case '9':\n\n        cstr_reset(&tokcstr);\n        /* after the first digit, accept digits, alpha, '.' or sign if\n           prefixed by 'eEpP' */\n    parse_num:\n        for(;;) {\n            t = c;\n            cstr_ccat(&tokcstr, c);\n            PEEKC(c, p);\n            if (!(isnum(c) || isid(c) || c == '.' ||\n                  ((c == '+' || c == '-') && \n                   (t == 'e' || t == 'E' || t == 'p' || t == 'P'))))\n                break;\n        }\n        /* We add a trailing '\\0' to ease parsing */\n        cstr_ccat(&tokcstr, '\\0');\n        tokc.cstr = &tokcstr;\n        tok = TOK_PPNUM;\n        break;\n    case '.':\n        /* special dot handling because it can also start a number */\n        PEEKC(c, p);\n        if (isnum(c)) {\n            cstr_reset(&tokcstr);\n            cstr_ccat(&tokcstr, '.');\n            goto parse_num;\n        } else if (c == '.') {\n            PEEKC(c, p);\n            if (c != '.')\n                expect(\"'.'\");\n            PEEKC(c, p);\n            tok = TOK_DOTS;\n        } else {\n            tok = '.';\n        }\n        break;\n    case '\\'':\n    case '\\\"':\n        is_long = 0;\n    str_const:\n        {\n            CString str;\n            int sep;\n\n            sep = c;\n\n            /* parse the string */\n            cstr_new(&str);\n            p = parse_pp_string(p, sep, &str);\n            cstr_ccat(&str, '\\0');\n            \n            /* eval the escape (should be done as TOK_PPNUM) */\n            cstr_reset(&tokcstr);\n            parse_escape_string(&tokcstr, str.data, is_long);\n            cstr_free(&str);\n\n            if (sep == '\\'') {\n                int char_size;\n                /* XXX: make it portable */\n                if (!is_long)\n                    char_size = 1;\n                else\n                    char_size = sizeof(int);\n                if (tokcstr.size <= char_size)\n                    error(\"empty character constant\");\n                if (tokcstr.size > 2 * char_size)\n                    warning(\"multi-character character constant\");\n                if (!is_long) {\n                    tokc.i = *(int8_t *)tokcstr.data;\n                    tok = TOK_CCHAR;\n                } else {\n                    tokc.i = *(int *)tokcstr.data;\n                    tok = TOK_LCHAR;\n                }\n            } else {\n                tokc.cstr = &tokcstr;\n                if (!is_long)\n                    tok = TOK_STR;\n                else\n                    tok = TOK_LSTR;\n            }\n        }\n        break;\n\n    case '<':\n        PEEKC(c, p);\n        if (c == '=') {\n            p++;\n            tok = TOK_LE;\n        } else if (c == '<') {\n            PEEKC(c, p);\n            if (c == '=') {\n                p++;\n                tok = TOK_A_SHL;\n            } else {\n                tok = TOK_SHL;\n            }\n        } else {\n            tok = TOK_LT;\n        }\n        break;\n        \n    case '>':\n        PEEKC(c, p);\n        if (c == '=') {\n            p++;\n            tok = TOK_GE;\n        } else if (c == '>') {\n            PEEKC(c, p);\n            if (c == '=') {\n                p++;\n                tok = TOK_A_SAR;\n            } else {\n                tok = TOK_SAR;\n            }\n        } else {\n            tok = TOK_GT;\n        }\n        break;\n        \n    case '&':\n        PEEKC(c, p);\n        if (c == '&') {\n            p++;\n            tok = TOK_LAND;\n        } else if (c == '=') {\n            p++;\n            tok = TOK_A_AND;\n        } else {\n            tok = '&';\n        }\n        break;\n        \n    case '|':\n        PEEKC(c, p);\n        if (c == '|') {\n            p++;\n            tok = TOK_LOR;\n        } else if (c == '=') {\n            p++;\n            tok = TOK_A_OR;\n        } else {\n            tok = '|';\n        }\n        break;\n\n    case '+':\n        PEEKC(c, p);\n        if (c == '+') {\n            p++;\n            tok = TOK_INC;\n        } else if (c == '=') {\n            p++;\n            tok = TOK_A_ADD;\n        } else {\n            tok = '+';\n        }\n        break;\n        \n    case '-':\n        PEEKC(c, p);\n        if (c == '-') {\n            p++;\n            tok = TOK_DEC;\n        } else if (c == '=') {\n            p++;\n            tok = TOK_A_SUB;\n        } else if (c == '>') {\n            p++;\n            tok = TOK_ARROW;\n        } else {\n            tok = '-';\n        }\n        break;\n\n    PARSE2('!', '!', '=', TOK_NE)\n    PARSE2('=', '=', '=', TOK_EQ)\n    PARSE2('*', '*', '=', TOK_A_MUL)\n    PARSE2('%', '%', '=', TOK_A_MOD)\n    PARSE2('^', '^', '=', TOK_A_XOR)\n        \n        /* comments or operator */\n    case '/':\n        PEEKC(c, p);\n        if (c == '*') {\n            p = parse_comment(p);\n            goto redo_no_start;\n        } else if (c == '/') {\n            p = parse_line_comment(p);\n            goto redo_no_start;\n        } else if (c == '=') {\n            p++;\n            tok = TOK_A_DIV;\n        } else {\n            tok = '/';\n        }\n        break;\n        \n        /* simple tokens */\n    case '(':\n    case ')':\n    case '[':\n    case ']':\n    case '{':\n    case '}':\n    case ',':\n    case ';':\n    case ':':\n    case '?':\n    case '~':\n    case '$': /* only used in assembler */\n    case '@': /* dito */\n        tok = c;\n        p++;\n        break;\n    default:\n        error(\"unrecognized character \\\\x%02x\", c);\n        break;\n    }\n    file->buf_ptr = p;\n    tok_flags = 0;\n#if defined(PARSE_DEBUG)\n    printf(\"token = %s\\n\", get_tok_str(tok, &tokc));\n#endif\n}\n\n/* return next token without macro substitution. Can read input from\n   macro_ptr buffer */\nstatic void next_nomacro(void)\n{\n    if (macro_ptr) {\n    redo:\n        tok = *macro_ptr;\n        if (tok) {\n            TOK_GET(tok, macro_ptr, tokc);\n            if (tok == TOK_LINENUM) {\n                file->line_num = tokc.i;\n                goto redo;\n            }\n        }\n    } else {\n        next_nomacro1();\n    }\n}\n\n/* substitute args in macro_str and return allocated string */\nstatic int *macro_arg_subst(Sym **nested_list, int *macro_str, Sym *args)\n{\n    int *st, last_tok, t, notfirst;\n    Sym *s;\n    CValue cval;\n    TokenString str;\n    CString cstr;\n\n    tok_str_new(&str);\n    last_tok = 0;\n    while(1) {\n        TOK_GET(t, macro_str, cval);\n        if (!t)\n            break;\n        if (t == '#') {\n            /* stringize */\n            TOK_GET(t, macro_str, cval);\n            if (!t)\n                break;\n            s = sym_find2(args, t);\n            if (s) {\n                cstr_new(&cstr);\n                st = (int *)s->c;\n                notfirst = 0;\n                while (*st) {\n                    if (notfirst)\n                        cstr_ccat(&cstr, ' ');\n                    TOK_GET(t, st, cval);\n                    cstr_cat(&cstr, get_tok_str(t, &cval));\n                    notfirst = 1;\n                }\n                cstr_ccat(&cstr, '\\0');\n#ifdef PP_DEBUG\n                printf(\"stringize: %s\\n\", (char *)cstr.data);\n#endif\n                /* add string */\n                cval.cstr = &cstr;\n                tok_str_add2(&str, TOK_STR, &cval);\n                cstr_free(&cstr);\n            } else {\n                tok_str_add2(&str, t, &cval);\n            }\n        } else if (t >= TOK_IDENT) {\n            s = sym_find2(args, t);\n            if (s) {\n                st = (int *)s->c;\n                /* if '##' is present before or after, no arg substitution */\n                if (*macro_str == TOK_TWOSHARPS || last_tok == TOK_TWOSHARPS) {\n                    /* special case for var arg macros : ## eats the\n                       ',' if empty VA_ARGS variable. */\n                    /* XXX: test of the ',' is not 100%\n                       reliable. should fix it to avoid security\n                       problems */\n                    if (gnu_ext && s->type.t &&\n                        last_tok == TOK_TWOSHARPS && \n                        str.len >= 2 && str.str[str.len - 2] == ',') {\n                        if (*st == 0) {\n                            /* suppress ',' '##' */\n                            str.len -= 2;\n                        } else {\n                            /* suppress '##' and add variable */\n                            str.len--;\n                            goto add_var;\n                        }\n                    } else {\n                        int t1;\n                    add_var:\n                        for(;;) {\n                            TOK_GET(t1, st, cval);\n                            if (!t1)\n                                break;\n                            tok_str_add2(&str, t1, &cval);\n                        }\n                    }\n                } else {\n                    /* NOTE: the stream cannot be read when macro\n                       substituing an argument */\n                    macro_subst(&str, nested_list, st, NULL);\n                }\n            } else {\n                tok_str_add(&str, t);\n            }\n        } else {\n            tok_str_add2(&str, t, &cval);\n        }\n        last_tok = t;\n    }\n    tok_str_add(&str, 0);\n    return str.str;\n}\n\nstatic char const ab_month_name[12][4] =\n{\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\n/* do macro substitution of current token with macro 's' and add\n   result to (tok_str,tok_len). 'nested_list' is the list of all\n   macros we got inside to avoid recursing. Return non zero if no\n   substitution needs to be done */\nstatic int macro_subst_tok(TokenString *tok_str,\n                           Sym **nested_list, Sym *s, struct macro_level **can_read_stream)\n{\n    Sym *args, *sa, *sa1;\n    int mstr_allocated, parlevel, *mstr, t, t1;\n    TokenString str;\n    char *cstrval;\n    CValue cval;\n    CString cstr;\n    char buf[32];\n    \n    /* if symbol is a macro, prepare substitution */\n    /* special macros */\n    if (tok == TOK___LINE__) {\n        snprintf(buf, sizeof(buf), \"%d\", file->line_num);\n        cstrval = buf;\n        t1 = TOK_PPNUM;\n        goto add_cstr1;\n    } else if (tok == TOK___FILE__) {\n        cstrval = file->filename;\n        goto add_cstr;\n    } else if (tok == TOK___DATE__ || tok == TOK___TIME__) {\n        time_t ti;\n        struct tm *tm;\n\n        time(&ti);\n        tm = localtime(&ti);\n        if (tok == TOK___DATE__) {\n            snprintf(buf, sizeof(buf), \"%s %2d %d\", \n                     ab_month_name[tm->tm_mon], tm->tm_mday, tm->tm_year + 1900);\n        } else {\n            snprintf(buf, sizeof(buf), \"%02d:%02d:%02d\", \n                     tm->tm_hour, tm->tm_min, tm->tm_sec);\n        }\n        cstrval = buf;\n    add_cstr:\n        t1 = TOK_STR;\n    add_cstr1:\n        cstr_new(&cstr);\n        cstr_cat(&cstr, cstrval);\n        cstr_ccat(&cstr, '\\0');\n        cval.cstr = &cstr;\n        tok_str_add2(tok_str, t1, &cval);\n        cstr_free(&cstr);\n    } else {\n        mstr = (int *)s->c;\n        mstr_allocated = 0;\n        if (s->type.t == MACRO_FUNC) {\n            /* NOTE: we do not use next_nomacro to avoid eating the\n               next token. XXX: find better solution */\n        redo:\n            if (macro_ptr) {\n                t = *macro_ptr;\n                if (t == 0 && can_read_stream) {\n                    /* end of macro stream: we must look at the token\n                       after in the file */\n                    struct macro_level *ml = *can_read_stream;\n                    macro_ptr = NULL;\n                    if (ml)\n                    {\n                        macro_ptr = ml->p;\n                        ml->p = NULL;\n                        *can_read_stream = ml -> prev;\n                    }\n                    goto redo;\n                }\n            } else {\n                /* XXX: incorrect with comments */\n                ch = file->buf_ptr[0];\n                while (is_space(ch) || ch == '\\n')\n                    cinp();\n                t = ch;\n            }\n            if (t != '(') /* no macro subst */\n                return -1;\n                    \n            /* argument macro */\n            next_nomacro();\n            next_nomacro();\n            args = NULL;\n            sa = s->next;\n            /* NOTE: empty args are allowed, except if no args */\n            for(;;) {\n                /* handle '()' case */\n                if (!args && !sa && tok == ')')\n                    break;\n                if (!sa)\n                    error(\"macro '%s' used with too many args\",\n                          get_tok_str(s->v, 0));\n                tok_str_new(&str);\n                parlevel = 0;\n                /* NOTE: non zero sa->t indicates VA_ARGS */\n                while ((parlevel > 0 || \n                        (tok != ')' && \n                         (tok != ',' || sa->type.t))) && \n                       tok != -1) {\n                    if (tok == '(')\n                        parlevel++;\n                    else if (tok == ')')\n                        parlevel--;\n                    tok_str_add2(&str, tok, &tokc);\n                    next_nomacro();\n                }\n                tok_str_add(&str, 0);\n                sym_push2(&args, sa->v & ~SYM_FIELD, sa->type.t, (long)str.str);\n                sa = sa->next;\n                if (tok == ')') {\n                    /* special case for gcc var args: add an empty\n                       var arg argument if it is omitted */\n                    if (sa && sa->type.t && gnu_ext)\n                        continue;\n                    else\n                        break;\n                }\n                if (tok != ',')\n                    expect(\",\");\n                next_nomacro();\n            }\n            if (sa) {\n                error(\"macro '%s' used with too few args\",\n                      get_tok_str(s->v, 0));\n            }\n\n            /* now subst each arg */\n            mstr = macro_arg_subst(nested_list, mstr, args);\n            /* free memory */\n            sa = args;\n            while (sa) {\n                sa1 = sa->prev;\n                tok_str_free((int *)sa->c);\n                sym_free(sa);\n                sa = sa1;\n            }\n            mstr_allocated = 1;\n        }\n        sym_push2(nested_list, s->v, 0, 0);\n        macro_subst(tok_str, nested_list, mstr, can_read_stream);\n        /* pop nested defined symbol */\n        sa1 = *nested_list;\n        *nested_list = sa1->prev;\n        sym_free(sa1);\n        if (mstr_allocated)\n            tok_str_free(mstr);\n    }\n    return 0;\n}\n\n/* handle the '##' operator. Return NULL if no '##' seen. Otherwise\n   return the resulting string (which must be freed). */\nstatic /*inline*/ int *macro_twosharps(const int *macro_str)\n{\n    TokenSym *ts;\n    const int *macro_ptr1, *start_macro_ptr, *ptr, *saved_macro_ptr;\n    int t;\n    const char *p1, *p2;\n    CValue cval;\n    TokenString macro_str1;\n    CString cstr;\n    memset(&cval, 0, sizeof(cval));\n    start_macro_ptr = macro_str;\n    /* we search the first '##' */\n    for(;;) {\n        macro_ptr1 = macro_str;\n        TOK_GET(t, macro_str, cval);\n        /* nothing more to do if end of string */\n        if (t == 0)\n            return NULL;\n        if (*macro_str == TOK_TWOSHARPS)\n            break;\n    }\n\n    /* we saw '##', so we need more processing to handle it */\n    cstr_new(&cstr);\n    tok_str_new(&macro_str1);\n    tok = t;\n    tokc = cval;\n\n    /* add all tokens seen so far */\n    for(ptr = start_macro_ptr; ptr < macro_ptr1;) {\n        TOK_GET(t, ptr, cval);\n        tok_str_add2(&macro_str1, t, &cval);\n    }\n    saved_macro_ptr = macro_ptr;\n    /* XXX: get rid of the use of macro_ptr here */\n    macro_ptr = (int *)macro_str;\n    for(;;) {\n        while (*macro_ptr == TOK_TWOSHARPS) {\n            macro_ptr++;\n            macro_ptr1 = macro_ptr;\n            t = *macro_ptr;\n            if (t) {\n                TOK_GET(t, macro_ptr, cval);\n                /* We concatenate the two tokens if we have an\n                   identifier or a preprocessing number */\n                cstr_reset(&cstr);\n                p1 = get_tok_str(tok, &tokc);\n                cstr_cat(&cstr, p1);\n                p2 = get_tok_str(t, &cval);\n                cstr_cat(&cstr, p2);\n                cstr_ccat(&cstr, '\\0');\n                \n                if ((tok >= TOK_IDENT || tok == TOK_PPNUM) && \n                    (t >= TOK_IDENT || t == TOK_PPNUM)) {\n                    if (tok == TOK_PPNUM) {\n                        /* if number, then create a number token */\n                        /* NOTE: no need to allocate because\n                           tok_str_add2() does it */\n                        tokc.cstr = &cstr;\n                    } else {\n                        /* if identifier, we must do a test to\n                           validate we have a correct identifier */\n                        if (t == TOK_PPNUM) {\n                            const char *p;\n                            int c;\n\n                            p = p2;\n                            for(;;) {\n                                c = *p;\n                                if (c == '\\0')\n                                    break;\n                                p++;\n                                if (!isnum(c) && !isid(c))\n                                    goto error_pasting;\n                            }\n                        }\n                        ts = tok_alloc(cstr.data, strlen(cstr.data));\n                        tok = ts->tok; /* modify current token */\n                    }\n                } else {\n                    const char *str = cstr.data;\n                    const unsigned char *q;\n\n                    /* we look for a valid token */\n                    /* XXX: do more extensive checks */\n                    if (!strcmp(str, \">>=\")) {\n                        tok = TOK_A_SAR;\n                    } else if (!strcmp(str, \"<<=\")) {\n                        tok = TOK_A_SHL;\n                    } else if (strlen(str) == 2) {\n                        /* search in two bytes table */\n                        q = tok_two_chars;\n                        for(;;) {\n                            if (!*q)\n                                goto error_pasting;\n                            if (q[0] == str[0] && q[1] == str[1])\n                                break;\n                            q += 3;\n                        }\n                        tok = q[2];\n                    } else {\n                    error_pasting:\n                        /* NOTE: because get_tok_str use a static buffer,\n                           we must save it */\n                        cstr_reset(&cstr);\n                        p1 = get_tok_str(tok, &tokc);\n                        cstr_cat(&cstr, p1);\n                        cstr_ccat(&cstr, '\\0');\n                        p2 = get_tok_str(t, &cval);\n                        warning(\"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\", cstr.data, p2);\n                        /* cannot merge tokens: just add them separately */\n                        tok_str_add2(&macro_str1, tok, &tokc);\n                        /* XXX: free associated memory ? */\n                        tok = t;\n                        tokc = cval;\n                    }\n                }\n            }\n        }\n        tok_str_add2(&macro_str1, tok, &tokc);\n        next_nomacro();\n        if (tok == 0)\n            break;\n    }\n    macro_ptr = (int *)saved_macro_ptr;\n    cstr_free(&cstr);\n    tok_str_add(&macro_str1, 0);\n    return macro_str1.str;\n}\n\n\n/* do macro substitution of macro_str and add result to\n   (tok_str,tok_len). 'nested_list' is the list of all macros we got\n   inside to avoid recursing. */\nstatic void macro_subst(TokenString *tok_str, Sym **nested_list, \n                        const int *macro_str, struct macro_level ** can_read_stream)\n{\n    Sym *s;\n    int *macro_str1;\n    const int *ptr;\n    int t, ret;\n    CValue cval;\n    struct macro_level ml;\n    \n    /* first scan for '##' operator handling */\n    ptr = macro_str;\n    macro_str1 = macro_twosharps(ptr);\n    if (macro_str1) \n        ptr = macro_str1;\n    while (1) {\n        /* NOTE: ptr == NULL can only happen if tokens are read from\n           file stream due to a macro function call */\n        if (ptr == NULL)\n            break;\n        TOK_GET(t, ptr, cval);\n        if (t == 0)\n            break;\n        s = define_find(t);\n        if (s != NULL) {\n            /* if nested substitution, do nothing */\n            if (sym_find2(*nested_list, t))\n                goto no_subst;\n            ml.p = macro_ptr;\n            if (can_read_stream)\n                ml.prev = *can_read_stream, *can_read_stream = &ml;\n            macro_ptr = (int *)ptr;\n            tok = t;\n            ret = macro_subst_tok(tok_str, nested_list, s, can_read_stream);\n            ptr = (int *)macro_ptr;\n            macro_ptr = ml.p;\n            if (can_read_stream && *can_read_stream == &ml)\n                    *can_read_stream = ml.prev;\n            if (ret != 0)\n                goto no_subst;\n        } else {\n        no_subst:\n            tok_str_add2(tok_str, t, &cval);\n        }\n    }\n    if (macro_str1)\n        tok_str_free(macro_str1);\n}\n\n/* return next token with macro substitution */\nstatic void next(void)\n{\n    Sym *nested_list, *s;\n    TokenString str;\n    struct macro_level *ml;\n\n redo:\n    next_nomacro();\n    if (!macro_ptr) {\n        /* if not reading from macro substituted string, then try\n           to substitute macros */\n        if (tok >= TOK_IDENT &&\n            (parse_flags & PARSE_FLAG_PREPROCESS)) {\n            s = define_find(tok);\n            if (s) {\n                /* we have a macro: we try to substitute */\n                tok_str_new(&str);\n                nested_list = NULL;\n                ml = NULL;\n                if (macro_subst_tok(&str, &nested_list, s, &ml) == 0) {\n                    /* substitution done, NOTE: maybe empty */\n                    tok_str_add(&str, 0);\n                    macro_ptr = str.str;\n                    macro_ptr_allocated = str.str;\n                    goto redo;\n                }\n            }\n        }\n    } else {\n        if (tok == 0) {\n            /* end of macro or end of unget buffer */\n            if (unget_buffer_enabled) {\n                macro_ptr = unget_saved_macro_ptr;\n                unget_buffer_enabled = 0;\n            } else {\n                /* end of macro string: free it */\n                tok_str_free(macro_ptr_allocated);\n                macro_ptr = NULL;\n            }\n            goto redo;\n        }\n    }\n    \n    /* convert preprocessor tokens into C tokens */\n    if (tok == TOK_PPNUM &&\n        (parse_flags & PARSE_FLAG_TOK_NUM)) {\n        parse_number((char *)tokc.cstr->data);\n    }\n}\n\n/* push back current token and set current token to 'last_tok'. Only\n   identifier case handled for labels. */\nstatic inline void unget_tok(int last_tok)\n{\n    int i, n;\n    int *q;\n    unget_saved_macro_ptr = macro_ptr;\n    unget_buffer_enabled = 1;\n    q = unget_saved_buffer;\n    macro_ptr = q;\n    *q++ = tok;\n    n = tok_ext_size(tok) - 1;\n    for(i=0;i<n;i++)\n        *q++ = tokc.tab[i];\n    *q = 0; /* end of token string */\n    tok = last_tok;\n}\n\n\nvoid swap(int *p, int *q)\n{\n    int t;\n    t = *p;\n    *p = *q;\n    *q = t;\n}\n\nvoid vsetc(CType *type, int r, CValue *vc)\n{\n    int v;\n\n    if (vtop >= vstack + (VSTACK_SIZE - 1))\n        error(\"memory full\");\n    /* cannot let cpu flags if other instruction are generated. Also\n       avoid leaving VT_JMP anywhere except on the top of the stack\n       because it would complicate the code generator. */\n    if (vtop >= vstack) {\n        v = vtop->r & VT_VALMASK;\n        if (v == VT_CMP || (v & ~1) == VT_JMP)\n            gv(RC_INT);\n    }\n    vtop++;\n    vtop->type = *type;\n    vtop->r = r;\n    vtop->r2 = VT_CONST;\n    vtop->c = *vc;\n}\n\n/* push integer constant */\nvoid vpushi(int v)\n{\n    CValue cval;\n    cval.i = v;\n    vsetc(&int_type, VT_CONST, &cval);\n}\n\n/* Return a static symbol pointing to a section */\nstatic Sym *get_sym_ref(CType *type, Section *sec, \n                        unsigned long offset, unsigned long size)\n{\n    int v;\n    Sym *sym;\n\n    v = anon_sym++;\n    sym = global_identifier_push(v, type->t | VT_STATIC, 0);\n    sym->type.ref = type->ref;\n    sym->r = VT_CONST | VT_SYM;\n    put_extern_sym(sym, sec, offset, size);\n    return sym;\n}\n\n/* push a reference to a section offset by adding a dummy symbol */\nstatic void vpush_ref(CType *type, Section *sec, unsigned long offset, unsigned long size)\n{\n    CValue cval;\n\n    cval.ul = 0;\n    vsetc(type, VT_CONST | VT_SYM, &cval);\n    vtop->sym = get_sym_ref(type, sec, offset, size);\n}\n\n/* define a new external reference to a symbol 'v' of type 'u' */\nstatic Sym *external_global_sym(int v, CType *type, int r)\n{\n    Sym *s;\n\n    s = sym_find(v);\n    if (!s) {\n        /* push forward reference */\n        s = global_identifier_push(v, type->t | VT_EXTERN, 0);\n        s->type.ref = type->ref;\n        s->r = r | VT_CONST | VT_SYM;\n    }\n    return s;\n}\n\n/* define a new external reference to a symbol 'v' of type 'u' */\nstatic Sym *external_sym(int v, CType *type, int r)\n{\n    Sym *s;\n\n    s = sym_find(v);\n    if (!s) {\n        /* push forward reference */\n        s = sym_push(v, type, r | VT_CONST | VT_SYM, 0);\n        s->type.t |= VT_EXTERN;\n    } else {\n        if (!is_compatible_types(&s->type, type))\n            error(\"incompatible types for redefinition of '%s'\", \n                  get_tok_str(v, NULL));\n    }\n    return s;\n}\n\n/* push a reference to global symbol v */\nstatic void vpush_global_sym(CType *type, int v)\n{\n    Sym *sym;\n    CValue cval;\n\n    sym = external_global_sym(v, type, 0);\n    cval.ul = 0;\n    vsetc(type, VT_CONST | VT_SYM, &cval);\n    vtop->sym = sym;\n}\n\nvoid vset(CType *type, int r, int v)\n{\n    CValue cval;\n\n    cval.i = v;\n    vsetc(type, r, &cval);\n}\n\nvoid vseti(int r, int v)\n{\n    CType type;\n    type.t = VT_INT;\n    vset(&type, r, v);\n}\n\nvoid vswap(void)\n{\n    SValue tmp;\n\n    tmp = vtop[0];\n    vtop[0] = vtop[-1];\n    vtop[-1] = tmp;\n}\n\nvoid vpushv(SValue *v)\n{\n    if (vtop >= vstack + (VSTACK_SIZE - 1))\n        error(\"memory full\");\n    vtop++;\n    *vtop = *v;\n}\n\nvoid vdup(void)\n{\n    vpushv(vtop);\n}\n\n/* save r to the memory stack, and mark it as being free */\nvoid save_reg(int r)\n{\n    int l, saved, size, align;\n    SValue *p, sv;\n    CType *type;\n\n    /* modify all stack values */\n    saved = 0;\n    l = 0;\n    for(p=vstack;p<=vtop;p++) {\n        if ((p->r & VT_VALMASK) == r ||\n            (p->r2 & VT_VALMASK) == r) {\n            /* must save value on stack if not already done */\n            if (!saved) {\n                /* NOTE: must reload 'r' because r might be equal to r2 */\n                r = p->r & VT_VALMASK;\n                /* store register in the stack */\n                type = &p->type;\n                if ((p->r & VT_LVAL) || \n                    (!is_float(type->t) && (type->t & VT_BTYPE) != VT_LLONG))\n                    type = &int_type;\n                size = type_size(type, &align);\n                loc = (loc - size) & -align;\n                sv.type.t = type->t;\n                sv.r = VT_LOCAL | VT_LVAL;\n                sv.c.ul = loc;\n                store(r, &sv);\n#ifdef TCC_TARGET_I386\n                /* x86 specific: need to pop fp register ST0 if saved */\n                if (r == TREG_ST0) {\n                    o(0xd9dd); /* fstp %st(1) */\n                }\n#endif\n                /* special long long case */\n                if ((type->t & VT_BTYPE) == VT_LLONG) {\n                    sv.c.ul += 4;\n                    store(p->r2, &sv);\n                }\n                l = loc;\n                saved = 1;\n            }\n            /* mark that stack entry as being saved on the stack */\n            if (p->r & VT_LVAL) {\n                /* also clear the bounded flag because the\n                   relocation address of the function was stored in\n                   p->c.ul */\n                p->r = (p->r & ~(VT_VALMASK | VT_BOUNDED)) | VT_LLOCAL;\n            } else {\n                p->r = lvalue_type(p->type.t) | VT_LOCAL;\n            }\n            p->r2 = VT_CONST;\n            p->c.ul = l;\n        }\n    }\n}\n\n/* find a register of class 'rc2' with at most one reference on stack.\n * If none, call get_reg(rc) */\nint get_reg_ex(int rc, int rc2) \n{\n    int r;\n    SValue *p;\n    \n    for(r=0;r<NB_REGS;r++) {\n        if (reg_classes[r] & rc2) {\n            int n;\n            n=0;\n            for(p = vstack; p <= vtop; p++) {\n                if ((p->r & VT_VALMASK) == r ||\n                    (p->r2 & VT_VALMASK) == r)\n                    n++;\n            }\n            if (n <= 1)\n                return r;\n        }\n    }\n    return get_reg(rc);\n}\n\n/* find a free register of class 'rc'. If none, save one register */\nint get_reg(int rc)\n{\n    int r;\n    SValue *p;\n\n    /* find a free register */\n    for(r=0;r<NB_REGS;r++) {\n        if (reg_classes[r] & rc) {\n            for(p=vstack;p<=vtop;p++) {\n                if ((p->r & VT_VALMASK) == r ||\n                    (p->r2 & VT_VALMASK) == r)\n                    goto notfound;\n            }\n            return r;\n        }\n    notfound: ;\n    }\n    \n    /* no register left : free the first one on the stack (VERY\n       IMPORTANT to start from the bottom to ensure that we don't\n       spill registers used in gen_opi()) */\n    for(p=vstack;p<=vtop;p++) {\n        r = p->r & VT_VALMASK;\n        if (r < VT_CONST && (reg_classes[r] & rc))\n            goto save_found;\n        /* also look at second register (if long long) */\n        r = p->r2 & VT_VALMASK;\n        if (r < VT_CONST && (reg_classes[r] & rc)) {\n        save_found:\n            save_reg(r);\n            return r;\n        }\n    }\n    /* Should never comes here */\n    return -1;\n}\n\n/* save registers up to (vtop - n) stack entry */\nvoid save_regs(int n)\n{\n    int r;\n    SValue *p, *p1;\n    p1 = vtop - n;\n    for(p = vstack;p <= p1; p++) {\n        r = p->r & VT_VALMASK;\n        if (r < VT_CONST) {\n            save_reg(r);\n        }\n    }\n}\n\n/* move register 's' to 'r', and flush previous value of r to memory\n   if needed */\nvoid move_reg(int r, int s)\n{\n    SValue sv;\n\n    if (r != s) {\n        save_reg(r);\n        sv.type.t = VT_INT;\n        sv.r = s;\n        sv.c.ul = 0;\n        load(r, &sv);\n    }\n}\n\n/* get address of vtop (vtop MUST BE an lvalue) */\nvoid gaddrof(void)\n{\n    vtop->r &= ~VT_LVAL;\n    /* tricky: if saved lvalue, then we can go back to lvalue */\n    if ((vtop->r & VT_VALMASK) == VT_LLOCAL)\n        vtop->r = (vtop->r & ~(VT_VALMASK | VT_LVAL_TYPE)) | VT_LOCAL | VT_LVAL;\n}\n\n#ifdef CONFIG_TCC_BCHECK\n/* generate lvalue bound code */\nvoid gbound(void)\n{\n    int lval_type;\n    CType type1;\n\n    vtop->r &= ~VT_MUSTBOUND;\n    /* if lvalue, then use checking code before dereferencing */\n    if (vtop->r & VT_LVAL) {\n        /* if not VT_BOUNDED value, then make one */\n        if (!(vtop->r & VT_BOUNDED)) {\n            lval_type = vtop->r & (VT_LVAL_TYPE | VT_LVAL);\n            /* must save type because we must set it to int to get pointer */\n            type1 = vtop->type;\n            vtop->type.t = VT_INT;\n            gaddrof();\n            vpushi(0);\n            gen_bounded_ptr_add();\n            vtop->r |= lval_type;\n            vtop->type = type1;\n        }\n        /* then check for dereferencing */\n        gen_bounded_ptr_deref();\n    }\n}\n#endif\n\n/* store vtop a register belonging to class 'rc'. lvalues are\n   converted to values. Cannot be used if cannot be converted to\n   register value (such as structures). */\nint gv(int rc)\n{\n    int r, r2, rc2, bit_pos, bit_size, size, align, i;\n    unsigned long long ll;\n\n    /* NOTE: get_reg can modify vstack[] */\n    if (vtop->type.t & VT_BITFIELD) {\n        bit_pos = (vtop->type.t >> VT_STRUCT_SHIFT) & 0x3f;\n        bit_size = (vtop->type.t >> (VT_STRUCT_SHIFT + 6)) & 0x3f;\n        /* remove bit field info to avoid loops */\n        vtop->type.t &= ~(VT_BITFIELD | (~0U << VT_STRUCT_SHIFT));\n        /* generate shifts */\n        vpushi(32 - (bit_pos + bit_size));\n        gen_op(TOK_SHL);\n        vpushi(32 - bit_size);\n        /* NOTE: transformed to SHR if unsigned */\n        gen_op(TOK_SAR);\n        r = gv(rc);\n    } else {\n        if (is_float(vtop->type.t) && \n            (vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n            Sym *sym;\n            int *ptr;\n            unsigned long offset;\n            \n            /* XXX: unify with initializers handling ? */\n            /* CPUs usually cannot use float constants, so we store them\n               generically in data segment */\n            size = type_size(&vtop->type, &align);\n            offset = (data_section->data_offset + align - 1) & -align;\n            data_section->data_offset = offset;\n            /* XXX: not portable yet */\n            ptr = section_ptr_add(data_section, size);\n            size = size >> 2;\n            for(i=0;i<size;i++)\n                ptr[i] = vtop->c.tab[i];\n            sym = get_sym_ref(&vtop->type, data_section, offset, size << 2);\n            vtop->r |= VT_LVAL | VT_SYM;\n            vtop->sym = sym;\n            vtop->c.ul = 0;\n        }\n#ifdef CONFIG_TCC_BCHECK\n        if (vtop->r & VT_MUSTBOUND) \n            gbound();\n#endif\n\n        r = vtop->r & VT_VALMASK;\n        /* need to reload if:\n           - constant\n           - lvalue (need to dereference pointer)\n           - already a register, but not in the right class */\n        if (r >= VT_CONST || \n            (vtop->r & VT_LVAL) ||\n            !(reg_classes[r] & rc) ||\n            ((vtop->type.t & VT_BTYPE) == VT_LLONG && \n             !(reg_classes[vtop->r2] & rc))) {\n            r = get_reg(rc);\n            if ((vtop->type.t & VT_BTYPE) == VT_LLONG) {\n                /* two register type load : expand to two words\n                   temporarily */\n                if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {\n                    /* load constant */\n                    ll = vtop->c.ull;\n                    vtop->c.ui = ll; /* first word */\n                    load(r, vtop);\n                    vtop->r = r; /* save register value */\n                    vpushi(ll >> 32); /* second word */\n                } else if (r >= VT_CONST || /* XXX: test to VT_CONST incorrect ? */\n                           (vtop->r & VT_LVAL)) {\n                    /* We do not want to modifier the long long\n                       pointer here, so the safest (and less\n                       efficient) is to save all the other registers\n                       in the stack. XXX: totally inefficient. */\n                    save_regs(1);\n                    /* load from memory */\n                    load(r, vtop);\n                    vdup();\n                    vtop[-1].r = r; /* save register value */\n                    /* increment pointer to get second word */\n                    vtop->type.t = VT_INT;\n                    gaddrof();\n                    vpushi(4);\n                    gen_op('+');\n                    vtop->r |= VT_LVAL;\n                } else {\n                    /* move registers */\n                    load(r, vtop);\n                    vdup();\n                    vtop[-1].r = r; /* save register value */\n                    vtop->r = vtop[-1].r2;\n                }\n                /* allocate second register */\n                rc2 = RC_INT;\n                if (rc == RC_IRET)\n                    rc2 = RC_LRET;\n                r2 = get_reg(rc2);\n                load(r2, vtop);\n                vpop();\n                /* write second register */\n                vtop->r2 = r2;\n            } else if ((vtop->r & VT_LVAL) && !is_float(vtop->type.t)) {\n                int t1, t;\n                /* lvalue of scalar type : need to use lvalue type\n                   because of possible cast */\n                t = vtop->type.t;\n                t1 = t;\n                /* compute memory access type */\n                if (vtop->r & VT_LVAL_BYTE)\n                    t = VT_BYTE;\n                else if (vtop->r & VT_LVAL_SHORT)\n                    t = VT_SHORT;\n                if (vtop->r & VT_LVAL_UNSIGNED)\n                    t |= VT_UNSIGNED;\n                vtop->type.t = t;\n                load(r, vtop);\n                /* restore wanted type */\n                vtop->type.t = t1;\n            } else {\n                /* one register type load */\n                load(r, vtop);\n            }\n        }\n        vtop->r = r;\n#ifdef TCC_TARGET_C67\n        /* uses register pairs for doubles */\n        if ((vtop->type.t & VT_BTYPE) == VT_DOUBLE) \n            vtop->r2 = r+1;\n#endif\n    }\n    return r;\n}\n\n/* generate vtop[-1] and vtop[0] in resp. classes rc1 and rc2 */\nvoid gv2(int rc1, int rc2)\n{\n    int v;\n\n    /* generate more generic register first. But VT_JMP or VT_CMP\n       values must be generated first in all cases to avoid possible\n       reload errors */\n    v = vtop[0].r & VT_VALMASK;\n    if (v != VT_CMP && (v & ~1) != VT_JMP && rc1 <= rc2) {\n        vswap();\n        gv(rc1);\n        vswap();\n        gv(rc2);\n        /* test if reload is needed for first register */\n        if ((vtop[-1].r & VT_VALMASK) >= VT_CONST) {\n            vswap();\n            gv(rc1);\n            vswap();\n        }\n    } else {\n        gv(rc2);\n        vswap();\n        gv(rc1);\n        vswap();\n        /* test if reload is needed for first register */\n        if ((vtop[0].r & VT_VALMASK) >= VT_CONST) {\n            gv(rc2);\n        }\n    }\n}\n\n/* expand long long on stack in two int registers */\nvoid lexpand(void)\n{\n    int u;\n\n    u = vtop->type.t & VT_UNSIGNED;\n    gv(RC_INT);\n    vdup();\n    vtop[0].r = vtop[-1].r2;\n    vtop[0].r2 = VT_CONST;\n    vtop[-1].r2 = VT_CONST;\n    vtop[0].type.t = VT_INT | u;\n    vtop[-1].type.t = VT_INT | u;\n}\n\n#ifdef TCC_TARGET_ARM\n/* expand long long on stack */\nvoid lexpand_nr(void)\n{\n    int u,v;\n\n    u = vtop->type.t & VT_UNSIGNED;\n    vdup();\n    vtop->r2 = VT_CONST;\n    vtop->type.t = VT_INT | u;\n    v=vtop[-1].r & (VT_VALMASK | VT_LVAL);\n    if (v == VT_CONST) {\n      vtop[-1].c.ui = vtop->c.ull;\n      vtop->c.ui = vtop->c.ull >> 32;\n      vtop->r = VT_CONST;\n    } else if (v == (VT_LVAL|VT_CONST) || v == (VT_LVAL|VT_LOCAL)) {\n      vtop->c.ui += 4;\n      vtop->r = vtop[-1].r;\n    } else if (v > VT_CONST) {\n      vtop--;\n      lexpand();\n    } else\n      vtop->r = vtop[-1].r2;\n    vtop[-1].r2 = VT_CONST;\n    vtop[-1].type.t = VT_INT | u;\n}\n#endif\n\n/* build a long long from two ints */\nvoid lbuild(int t)\n{\n    gv2(RC_INT, RC_INT);\n    vtop[-1].r2 = vtop[0].r;\n    vtop[-1].type.t = t;\n    vpop();\n}\n\n/* rotate n first stack elements to the bottom \n   I1 ... In -> I2 ... In I1 [top is right]\n*/\nvoid vrotb(int n)\n{\n    int i;\n    SValue tmp;\n\n    tmp = vtop[-n + 1];\n    for(i=-n+1;i!=0;i++)\n        vtop[i] = vtop[i+1];\n    vtop[0] = tmp;\n}\n\n/* rotate n first stack elements to the top \n   I1 ... In -> In I1 ... I(n-1)  [top is right]\n */\nvoid vrott(int n)\n{\n    int i;\n    SValue tmp;\n\n    tmp = vtop[0];\n    for(i = 0;i < n - 1; i++)\n        vtop[-i] = vtop[-i - 1];\n    vtop[-n + 1] = tmp;\n}\n\n#ifdef TCC_TARGET_ARM\n/* like vrott but in other direction\n   In ... I1 -> I(n-1) ... I1 In  [top is right]\n */\nvoid vnrott(int n)\n{\n    int i;\n    SValue tmp;\n\n    tmp = vtop[-n + 1];\n    for(i = n - 1; i > 0; i--)\n        vtop[-i] = vtop[-i + 1];\n    vtop[0] = tmp;\n}\n#endif\n\n/* pop stack value */\nvoid vpop(void)\n{\n    int v;\n    v = vtop->r & VT_VALMASK;\n#ifdef TCC_TARGET_I386\n    /* for x86, we need to pop the FP stack */\n    if (v == TREG_ST0 && !nocode_wanted) {\n        o(0xd9dd); /* fstp %st(1) */\n    } else\n#endif\n    if (v == VT_JMP || v == VT_JMPI) {\n        /* need to put correct jump if && or || without test */\n        gsym(vtop->c.ul);\n    }\n    vtop--;\n}\n\n/* convert stack entry to register and duplicate its value in another\n   register */\nvoid gv_dup(void)\n{\n    int rc, t, r, r1;\n    SValue sv;\n\n    t = vtop->type.t;\n    if ((t & VT_BTYPE) == VT_LLONG) {\n        lexpand();\n        gv_dup();\n        vswap();\n        vrotb(3);\n        gv_dup();\n        vrotb(4);\n        /* stack: H L L1 H1 */\n        lbuild(t);\n        vrotb(3);\n        vrotb(3);\n        vswap();\n        lbuild(t);\n        vswap();\n    } else {\n        /* duplicate value */\n        rc = RC_INT;\n        sv.type.t = VT_INT;\n        if (is_float(t)) {\n            rc = RC_FLOAT;\n            sv.type.t = t;\n        }\n        r = gv(rc);\n        r1 = get_reg(rc);\n        sv.r = r;\n        sv.c.ul = 0;\n        load(r1, &sv); /* move r to r1 */\n        vdup();\n        /* duplicates value */\n        vtop->r = r1;\n    }\n}\n\n/* generate CPU independent (unsigned) long long operations */\nvoid gen_opl(int op)\n{\n    int t, a, b, op1, c, i;\n    int func;\n    SValue tmp;\n\n    switch(op) {\n    case '/':\n    case TOK_PDIV:\n        func = TOK___divdi3;\n        goto gen_func;\n    case TOK_UDIV:\n        func = TOK___udivdi3;\n        goto gen_func;\n    case '%':\n        func = TOK___moddi3;\n        goto gen_func;\n    case TOK_UMOD:\n        func = TOK___umoddi3;\n    gen_func:\n        /* call generic long long function */\n        vpush_global_sym(&func_old_type, func);\n        vrott(3);\n        gfunc_call(2);\n        vpushi(0);\n        vtop->r = REG_IRET;\n        vtop->r2 = REG_LRET;\n        break;\n    case '^':\n    case '&':\n    case '|':\n    case '*':\n    case '+':\n    case '-':\n        t = vtop->type.t;\n        vswap();\n        lexpand();\n        vrotb(3);\n        lexpand();\n        /* stack: L1 H1 L2 H2 */\n        tmp = vtop[0];\n        vtop[0] = vtop[-3];\n        vtop[-3] = tmp;\n        tmp = vtop[-2];\n        vtop[-2] = vtop[-3];\n        vtop[-3] = tmp;\n        vswap();\n        /* stack: H1 H2 L1 L2 */\n        if (op == '*') {\n            vpushv(vtop - 1);\n            vpushv(vtop - 1);\n            gen_op(TOK_UMULL);\n            lexpand();\n            /* stack: H1 H2 L1 L2 ML MH */\n            for(i=0;i<4;i++)\n                vrotb(6);\n            /* stack: ML MH H1 H2 L1 L2 */\n            tmp = vtop[0];\n            vtop[0] = vtop[-2];\n            vtop[-2] = tmp;\n            /* stack: ML MH H1 L2 H2 L1 */\n            gen_op('*');\n            vrotb(3);\n            vrotb(3);\n            gen_op('*');\n            /* stack: ML MH M1 M2 */\n            gen_op('+');\n            gen_op('+');\n        } else if (op == '+' || op == '-') {\n            /* XXX: add non carry method too (for MIPS or alpha) */\n            if (op == '+')\n                op1 = TOK_ADDC1;\n            else\n                op1 = TOK_SUBC1;\n            gen_op(op1);\n            /* stack: H1 H2 (L1 op L2) */\n            vrotb(3);\n            vrotb(3);\n            gen_op(op1 + 1); /* TOK_xxxC2 */\n        } else {\n            gen_op(op);\n            /* stack: H1 H2 (L1 op L2) */\n            vrotb(3);\n            vrotb(3);\n            /* stack: (L1 op L2) H1 H2 */\n            gen_op(op);\n            /* stack: (L1 op L2) (H1 op H2) */\n        }\n        /* stack: L H */\n        lbuild(t);\n        break;\n    case TOK_SAR:\n    case TOK_SHR:\n    case TOK_SHL:\n        if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {\n            t = vtop[-1].type.t;\n            vswap();\n            lexpand();\n            vrotb(3);\n            /* stack: L H shift */\n            c = (int)vtop->c.i;\n            /* constant: simpler */\n            /* NOTE: all comments are for SHL. the other cases are\n               done by swapping words */\n            vpop();\n            if (op != TOK_SHL)\n                vswap();\n            if (c >= 32) {\n                /* stack: L H */\n                vpop();\n                if (c > 32) {\n                    vpushi(c - 32);\n                    gen_op(op);\n                }\n                if (op != TOK_SAR) {\n                    vpushi(0);\n                } else {\n                    gv_dup();\n                    vpushi(31);\n                    gen_op(TOK_SAR);\n                }\n                vswap();\n            } else {\n                vswap();\n                gv_dup();\n                /* stack: H L L */\n                vpushi(c);\n                gen_op(op);\n                vswap();\n                vpushi(32 - c);\n                if (op == TOK_SHL)\n                    gen_op(TOK_SHR);\n                else\n                    gen_op(TOK_SHL);\n                vrotb(3);\n                /* stack: L L H */\n                vpushi(c);\n                if (op == TOK_SHL)\n                    gen_op(TOK_SHL);\n                else\n                    gen_op(TOK_SHR);\n                gen_op('|');\n            }\n            if (op != TOK_SHL)\n                vswap();\n            lbuild(t);\n        } else {\n            /* XXX: should provide a faster fallback on x86 ? */\n            switch(op) {\n            case TOK_SAR:\n                func = TOK___sardi3;\n                goto gen_func;\n            case TOK_SHR:\n                func = TOK___shrdi3;\n                goto gen_func;\n            case TOK_SHL:\n                func = TOK___shldi3;\n                goto gen_func;\n            }\n        }\n        break;\n    default:\n        /* compare operations */\n        t = vtop->type.t;\n        vswap();\n        lexpand();\n        vrotb(3);\n        lexpand();\n        /* stack: L1 H1 L2 H2 */\n        tmp = vtop[-1];\n        vtop[-1] = vtop[-2];\n        vtop[-2] = tmp;\n        /* stack: L1 L2 H1 H2 */\n        /* compare high */\n        op1 = op;\n        /* when values are equal, we need to compare low words. since\n           the jump is inverted, we invert the test too. */\n        if (op1 == TOK_LT)\n            op1 = TOK_LE;\n        else if (op1 == TOK_GT)\n            op1 = TOK_GE;\n        else if (op1 == TOK_ULT)\n            op1 = TOK_ULE;\n        else if (op1 == TOK_UGT)\n            op1 = TOK_UGE;\n        a = 0;\n        b = 0;\n        gen_op(op1);\n        if (op1 != TOK_NE) {\n            a = gtst(1, 0);\n        }\n        if (op != TOK_EQ) {\n            /* generate non equal test */\n            /* XXX: NOT PORTABLE yet */\n            if (a == 0) {\n                b = gtst(0, 0);\n            } else {\n#if defined(TCC_TARGET_I386)\n                b = psym(0x850f, 0);\n#elif defined(TCC_TARGET_ARM)\n\t\tb = ind;\n\t\to(0x1A000000 | encbranch(ind, 0, 1));\n#elif defined(TCC_TARGET_C67)\n                error(\"not implemented\");\n#else\n#error not supported\n#endif\n            }\n        }\n        /* compare low. Always unsigned */\n        op1 = op;\n        if (op1 == TOK_LT)\n            op1 = TOK_ULT;\n        else if (op1 == TOK_LE)\n            op1 = TOK_ULE;\n        else if (op1 == TOK_GT)\n            op1 = TOK_UGT;\n        else if (op1 == TOK_GE)\n            op1 = TOK_UGE;\n        gen_op(op1);\n        a = gtst(1, a);\n        gsym(b);\n        vseti(VT_JMPI, a);\n        break;\n    }\n}\n\n/* handle integer constant optimizations and various machine\n   independent opt */\nvoid gen_opic(int op)\n{\n    int fc, c1, c2, n;\n    SValue *v1, *v2;\n\n    v1 = vtop - 1;\n    v2 = vtop;\n    /* currently, we cannot do computations with forward symbols */\n    c1 = (v1->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n    c2 = (v2->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n    if (c1 && c2) {\n        fc = v2->c.i;\n        switch(op) {\n        case '+': v1->c.i += fc; break;\n        case '-': v1->c.i -= fc; break;\n        case '&': v1->c.i &= fc; break;\n        case '^': v1->c.i ^= fc; break;\n        case '|': v1->c.i |= fc; break;\n        case '*': v1->c.i *= fc; break;\n\n        case TOK_PDIV:\n        case '/':\n        case '%':\n        case TOK_UDIV:\n        case TOK_UMOD:\n            /* if division by zero, generate explicit division */\n            if (fc == 0) {\n                if (const_wanted)\n                    error(\"division by zero in constant\");\n                goto general_case;\n            }\n            switch(op) {\n            default: v1->c.i /= fc; break;\n            case '%': v1->c.i %= fc; break;\n            case TOK_UDIV: v1->c.i = (unsigned)v1->c.i / fc; break;\n            case TOK_UMOD: v1->c.i = (unsigned)v1->c.i % fc; break;\n            }\n            break;\n        case TOK_SHL: v1->c.i <<= fc; break;\n        case TOK_SHR: v1->c.i = (unsigned)v1->c.i >> fc; break;\n        case TOK_SAR: v1->c.i >>= fc; break;\n            /* tests */\n        case TOK_ULT: v1->c.i = (unsigned)v1->c.i < (unsigned)fc; break;\n        case TOK_UGE: v1->c.i = (unsigned)v1->c.i >= (unsigned)fc; break;\n        case TOK_EQ: v1->c.i = v1->c.i == fc; break;\n        case TOK_NE: v1->c.i = v1->c.i != fc; break;\n        case TOK_ULE: v1->c.i = (unsigned)v1->c.i <= (unsigned)fc; break;\n        case TOK_UGT: v1->c.i = (unsigned)v1->c.i > (unsigned)fc; break;\n        case TOK_LT: v1->c.i = v1->c.i < fc; break;\n        case TOK_GE: v1->c.i = v1->c.i >= fc; break;\n        case TOK_LE: v1->c.i = v1->c.i <= fc; break;\n        case TOK_GT: v1->c.i = v1->c.i > fc; break;\n            /* logical */\n        case TOK_LAND: v1->c.i = v1->c.i && fc; break;\n        case TOK_LOR: v1->c.i = v1->c.i || fc; break;\n        default:\n            goto general_case;\n        }\n        vtop--;\n    } else {\n        /* if commutative ops, put c2 as constant */\n        if (c1 && (op == '+' || op == '&' || op == '^' || \n                   op == '|' || op == '*')) {\n            vswap();\n            swap(&c1, &c2);\n        }\n        fc = vtop->c.i;\n        if (c2 && (((op == '*' || op == '/' || op == TOK_UDIV || \n                     op == TOK_PDIV) && \n                    fc == 1) ||\n                   ((op == '+' || op == '-' || op == '|' || op == '^' || \n                     op == TOK_SHL || op == TOK_SHR || op == TOK_SAR) && \n                    fc == 0) ||\n                   (op == '&' && \n                    fc == -1))) {\n            /* nothing to do */\n            vtop--;\n        } else if (c2 && (op == '*' || op == TOK_PDIV || op == TOK_UDIV)) {\n            /* try to use shifts instead of muls or divs */\n            if (fc > 0 && (fc & (fc - 1)) == 0) {\n                n = -1;\n                while (fc) {\n                    fc >>= 1;\n                    n++;\n                }\n                vtop->c.i = n;\n                if (op == '*')\n                    op = TOK_SHL;\n                else if (op == TOK_PDIV)\n                    op = TOK_SAR;\n                else\n                    op = TOK_SHR;\n            }\n            goto general_case;\n        } else if (c2 && (op == '+' || op == '-') &&\n                   (vtop[-1].r & (VT_VALMASK | VT_LVAL | VT_SYM)) == \n                   (VT_CONST | VT_SYM)) {\n            /* symbol + constant case */\n            if (op == '-')\n                fc = -fc;\n            vtop--;\n            vtop->c.i += fc;\n        } else {\n        general_case:\n            if (!nocode_wanted) {\n                /* call low level op generator */\n                gen_opi(op);\n            } else {\n                vtop--;\n            }\n        }\n    }\n}\n\n/* generate a floating point operation with constant propagation */\nvoid gen_opif(int op)\n{\n    int c1, c2;\n    SValue *v1, *v2;\n    long double f1, f2;\n\n    v1 = vtop - 1;\n    v2 = vtop;\n    /* currently, we cannot do computations with forward symbols */\n    c1 = (v1->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n    c2 = (v2->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n    if (c1 && c2) {\n        if (v1->type.t == VT_FLOAT) {\n            f1 = v1->c.f;\n            f2 = v2->c.f;\n        } else if (v1->type.t == VT_DOUBLE) {\n            f1 = v1->c.d;\n            f2 = v2->c.d;\n        } else {\n            f1 = v1->c.ld;\n            f2 = v2->c.ld;\n        }\n\n        /* NOTE: we only do constant propagation if finite number (not\n           NaN or infinity) (ANSI spec) */\n        if (!ieee_finite(f1) || !ieee_finite(f2))\n            goto general_case;\n\n        switch(op) {\n        case '+': f1 += f2; break;\n        case '-': f1 -= f2; break;\n        case '*': f1 *= f2; break;\n        case '/': \n            if (f2 == 0.0) {\n                if (const_wanted)\n                    error(\"division by zero in constant\");\n                goto general_case;\n            }\n            f1 /= f2; \n            break;\n            /* XXX: also handles tests ? */\n        default:\n            goto general_case;\n        }\n        /* XXX: overflow test ? */\n        if (v1->type.t == VT_FLOAT) {\n            v1->c.f = f1;\n        } else if (v1->type.t == VT_DOUBLE) {\n            v1->c.d = f1;\n        } else {\n            v1->c.ld = f1;\n        }\n        vtop--;\n    } else {\n    general_case:\n        if (!nocode_wanted) {\n            gen_opf(op);\n        } else {\n            vtop--;\n        }\n    }\n}\n\n/* return the pointed type of t */\nstatic inline CType *pointed_type(CType *type)\n{\n    return &type->ref->type;\n}\n\nstatic int pointed_size(CType *type)\n{\n    int align;\n    return type_size(pointed_type(type), &align);\n}\n\nstatic inline int is_null_pointer(SValue *p)\n{\n    if ((p->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)\n        return 0;\n    return ((p->type.t & VT_BTYPE) == VT_INT && p->c.i == 0) ||\n        ((p->type.t & VT_BTYPE) == VT_LLONG && p->c.ll == 0);\n}\n\nstatic inline int is_integer_btype(int bt)\n{\n    return (bt == VT_BYTE || bt == VT_SHORT || \n            bt == VT_INT || bt == VT_LLONG);\n}\n\n/* check types for comparison or substraction of pointers */\nstatic void check_comparison_pointer_types(SValue *p1, SValue *p2, int op)\n{\n    CType *type1, *type2, tmp_type1, tmp_type2;\n    int bt1, bt2;\n    \n    /* null pointers are accepted for all comparisons as gcc */\n    if (is_null_pointer(p1) || is_null_pointer(p2))\n        return;\n    type1 = &p1->type;\n    type2 = &p2->type;\n    bt1 = type1->t & VT_BTYPE;\n    bt2 = type2->t & VT_BTYPE;\n    /* accept comparison between pointer and integer with a warning */\n    if ((is_integer_btype(bt1) || is_integer_btype(bt2)) && op != '-') {\n        warning(\"comparison between pointer and integer\");\n        return;\n    }\n\n    /* both must be pointers or implicit function pointers */\n    if (bt1 == VT_PTR) {\n        type1 = pointed_type(type1);\n    } else if (bt1 != VT_FUNC) \n        goto invalid_operands;\n\n    if (bt2 == VT_PTR) {\n        type2 = pointed_type(type2);\n    } else if (bt2 != VT_FUNC) { \n    invalid_operands:\n        error(\"invalid operands to binary %s\", get_tok_str(op, NULL));\n    }\n    if ((type1->t & VT_BTYPE) == VT_VOID || \n        (type2->t & VT_BTYPE) == VT_VOID)\n        return;\n    tmp_type1 = *type1;\n    tmp_type2 = *type2;\n    tmp_type1.t &= ~(VT_UNSIGNED | VT_CONSTANT | VT_VOLATILE);\n    tmp_type2.t &= ~(VT_UNSIGNED | VT_CONSTANT | VT_VOLATILE);\n    if (!is_compatible_types(&tmp_type1, &tmp_type2)) {\n        /* gcc-like error if '-' is used */\n        if (op == '-')\n            goto invalid_operands;\n        else\n            warning(\"comparison of distinct pointer types lacks a cast\");\n    }\n}\n\n/* generic gen_op: handles types problems */\nvoid gen_op(int op)\n{\n    int u, t1, t2, bt1, bt2, t;\n    CType type1;\n\n    t1 = vtop[-1].type.t;\n    t2 = vtop[0].type.t;\n    bt1 = t1 & VT_BTYPE;\n    bt2 = t2 & VT_BTYPE;\n        \n    if (bt1 == VT_PTR || bt2 == VT_PTR) {\n        /* at least one operand is a pointer */\n        /* relationnal op: must be both pointers */\n        if (op >= TOK_ULT && op <= TOK_GT) {\n            check_comparison_pointer_types(vtop - 1, vtop, op);\n            /* pointers are handled are unsigned */\n            t = VT_INT | VT_UNSIGNED;\n            goto std_op;\n        }\n        /* if both pointers, then it must be the '-' op */\n        if (bt1 == VT_PTR && bt2 == VT_PTR) {\n            if (op != '-')\n                error(\"cannot use pointers here\");\n            check_comparison_pointer_types(vtop - 1, vtop, op);\n            /* XXX: check that types are compatible */\n            u = pointed_size(&vtop[-1].type);\n            gen_opic(op);\n            /* set to integer type */\n            vtop->type.t = VT_INT; \n            vpushi(u);\n            gen_op(TOK_PDIV);\n        } else {\n            /* exactly one pointer : must be '+' or '-'. */\n            if (op != '-' && op != '+')\n                error(\"cannot use pointers here\");\n            /* Put pointer as first operand */\n            if (bt2 == VT_PTR) {\n                vswap();\n                swap(&t1, &t2);\n            }\n            type1 = vtop[-1].type;\n            /* XXX: cast to int ? (long long case) */\n            vpushi(pointed_size(&vtop[-1].type));\n            gen_op('*');\n#ifdef CONFIG_TCC_BCHECK\n            /* if evaluating constant expression, no code should be\n               generated, so no bound check */\n            if (do_bounds_check && !const_wanted) {\n                /* if bounded pointers, we generate a special code to\n                   test bounds */\n                if (op == '-') {\n                    vpushi(0);\n                    vswap();\n                    gen_op('-');\n                }\n                gen_bounded_ptr_add();\n            } else\n#endif\n            {\n                gen_opic(op);\n            }\n            /* put again type if gen_opic() swaped operands */\n            vtop->type = type1;\n        }\n    } else if (is_float(bt1) || is_float(bt2)) {\n        /* compute bigger type and do implicit casts */\n        if (bt1 == VT_LDOUBLE || bt2 == VT_LDOUBLE) {\n            t = VT_LDOUBLE;\n        } else if (bt1 == VT_DOUBLE || bt2 == VT_DOUBLE) {\n            t = VT_DOUBLE;\n        } else {\n            t = VT_FLOAT;\n        }\n        /* floats can only be used for a few operations */\n        if (op != '+' && op != '-' && op != '*' && op != '/' &&\n            (op < TOK_ULT || op > TOK_GT))\n            error(\"invalid operands for binary operation\");\n        goto std_op;\n    } else if (bt1 == VT_LLONG || bt2 == VT_LLONG) {\n        /* cast to biggest op */\n        t = VT_LLONG;\n        /* convert to unsigned if it does not fit in a long long */\n        if ((t1 & (VT_BTYPE | VT_UNSIGNED)) == (VT_LLONG | VT_UNSIGNED) ||\n            (t2 & (VT_BTYPE | VT_UNSIGNED)) == (VT_LLONG | VT_UNSIGNED))\n            t |= VT_UNSIGNED;\n        goto std_op;\n    } else {\n        /* integer operations */\n        t = VT_INT;\n        /* convert to unsigned if it does not fit in an integer */\n        if ((t1 & (VT_BTYPE | VT_UNSIGNED)) == (VT_INT | VT_UNSIGNED) ||\n            (t2 & (VT_BTYPE | VT_UNSIGNED)) == (VT_INT | VT_UNSIGNED))\n            t |= VT_UNSIGNED;\n    std_op:\n        /* XXX: currently, some unsigned operations are explicit, so\n           we modify them here */\n        if (t & VT_UNSIGNED) {\n            if (op == TOK_SAR)\n                op = TOK_SHR;\n            else if (op == '/')\n                op = TOK_UDIV;\n            else if (op == '%')\n                op = TOK_UMOD;\n            else if (op == TOK_LT)\n                op = TOK_ULT;\n            else if (op == TOK_GT)\n                op = TOK_UGT;\n            else if (op == TOK_LE)\n                op = TOK_ULE;\n            else if (op == TOK_GE)\n                op = TOK_UGE;\n        }\n        vswap();\n        type1.t = t;\n        gen_cast(&type1);\n        vswap();\n        /* special case for shifts and long long: we keep the shift as\n           an integer */\n        if (op == TOK_SHR || op == TOK_SAR || op == TOK_SHL)\n            type1.t = VT_INT;\n        gen_cast(&type1);\n        if (is_float(t))\n            gen_opif(op);\n        else if ((t & VT_BTYPE) == VT_LLONG)\n            gen_opl(op);\n        else\n            gen_opic(op);\n        if (op >= TOK_ULT && op <= TOK_GT) {\n            /* relationnal op: the result is an int */\n            vtop->type.t = VT_INT;\n        } else {\n            vtop->type.t = t;\n        }\n    }\n}\n\n/* generic itof for unsigned long long case */\nvoid gen_cvt_itof1(int t)\n{\n    if ((vtop->type.t & (VT_BTYPE | VT_UNSIGNED)) == \n        (VT_LLONG | VT_UNSIGNED)) {\n\n        if (t == VT_FLOAT)\n            vpush_global_sym(&func_old_type, TOK___ulltof);\n        else if (t == VT_DOUBLE)\n            vpush_global_sym(&func_old_type, TOK___ulltod);\n        else\n            vpush_global_sym(&func_old_type, TOK___ulltold);\n        vrott(2);\n        gfunc_call(1);\n        vpushi(0);\n        vtop->r = REG_FRET;\n    } else {\n        gen_cvt_itof(t);\n    }\n}\n\n/* generic ftoi for unsigned long long case */\nvoid gen_cvt_ftoi1(int t)\n{\n    int st;\n\n    if (t == (VT_LLONG | VT_UNSIGNED)) {\n        /* not handled natively */\n        st = vtop->type.t & VT_BTYPE;\n        if (st == VT_FLOAT)\n            vpush_global_sym(&func_old_type, TOK___fixunssfdi);\n        else if (st == VT_DOUBLE)\n            vpush_global_sym(&func_old_type, TOK___fixunsdfdi);\n        else\n            vpush_global_sym(&func_old_type, TOK___fixunsxfdi);\n        vrott(2);\n        gfunc_call(1);\n        vpushi(0);\n        vtop->r = REG_IRET;\n        vtop->r2 = REG_LRET;\n    } else {\n        gen_cvt_ftoi(t);\n    }\n}\n\n/* force char or short cast */\nvoid force_charshort_cast(int t)\n{\n    int bits, dbt;\n    dbt = t & VT_BTYPE;\n    /* XXX: add optimization if lvalue : just change type and offset */\n    if (dbt == VT_BYTE)\n        bits = 8;\n    else\n        bits = 16;\n    if (t & VT_UNSIGNED) {\n        vpushi((1 << bits) - 1);\n        gen_op('&');\n    } else {\n        bits = 32 - bits;\n        vpushi(bits);\n        gen_op(TOK_SHL);\n        vpushi(bits);\n        gen_op(TOK_SAR);\n    }\n}\n\n/* cast 'vtop' to 'type'. Casting to bitfields is forbidden. */\nstatic void gen_cast(CType *type)\n{\n    int sbt, dbt, sf, df, c;\n\n    /* special delayed cast for char/short */\n    /* XXX: in some cases (multiple cascaded casts), it may still\n       be incorrect */\n    if (vtop->r & VT_MUSTCAST) {\n        vtop->r &= ~VT_MUSTCAST;\n        force_charshort_cast(vtop->type.t);\n    }\n\n    /* bitfields first get cast to ints */\n    if (vtop->type.t & VT_BITFIELD) {\n        gv(RC_INT);\n    }\n\n    dbt = type->t & (VT_BTYPE | VT_UNSIGNED);\n    sbt = vtop->type.t & (VT_BTYPE | VT_UNSIGNED);\n\n    if (sbt != dbt && !nocode_wanted) {\n        sf = is_float(sbt);\n        df = is_float(dbt);\n        c = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n        if (sf && df) {\n            /* convert from fp to fp */\n            if (c) {\n                /* constant case: we can do it now */\n                /* XXX: in ISOC, cannot do it if error in convert */\n                if (dbt == VT_FLOAT && sbt == VT_DOUBLE) \n                    vtop->c.f = (float)vtop->c.d;\n                else if (dbt == VT_FLOAT && sbt == VT_LDOUBLE) \n                    vtop->c.f = (float)vtop->c.ld;\n                else if (dbt == VT_DOUBLE && sbt == VT_FLOAT) \n                    vtop->c.d = (double)vtop->c.f;\n                else if (dbt == VT_DOUBLE && sbt == VT_LDOUBLE) \n                    vtop->c.d = (double)vtop->c.ld;\n                else if (dbt == VT_LDOUBLE && sbt == VT_FLOAT) \n                    vtop->c.ld = (long double)vtop->c.f;\n                else if (dbt == VT_LDOUBLE && sbt == VT_DOUBLE) \n                    vtop->c.ld = (long double)vtop->c.d;\n            } else {\n                /* non constant case: generate code */\n                gen_cvt_ftof(dbt);\n            }\n        } else if (df) {\n            /* convert int to fp */\n            if (c) {\n                switch(sbt) {\n                case VT_LLONG | VT_UNSIGNED:\n                case VT_LLONG:\n                    /* XXX: add const cases for long long */\n                    goto do_itof;\n                case VT_INT | VT_UNSIGNED:\n                    switch(dbt) {\n                    case VT_FLOAT: vtop->c.f = (float)vtop->c.ui; break;\n                    case VT_DOUBLE: vtop->c.d = (double)vtop->c.ui; break;\n                    case VT_LDOUBLE: vtop->c.ld = (long double)vtop->c.ui; break;\n                    }\n                    break;\n                default:\n                    switch(dbt) {\n                    case VT_FLOAT: vtop->c.f = (float)vtop->c.i; break;\n                    case VT_DOUBLE: vtop->c.d = (double)vtop->c.i; break;\n                    case VT_LDOUBLE: vtop->c.ld = (long double)vtop->c.i; break;\n                    }\n                    break;\n                }\n            } else {\n            do_itof:\n#if !defined(TCC_TARGET_ARM)\n                gen_cvt_itof1(dbt);\n#else\n                gen_cvt_itof(dbt);\n#endif\n            }\n        } else if (sf) {\n            /* convert fp to int */\n            /* we handle char/short/etc... with generic code */\n            if (dbt != (VT_INT | VT_UNSIGNED) &&\n                dbt != (VT_LLONG | VT_UNSIGNED) &&\n                dbt != VT_LLONG)\n                dbt = VT_INT;\n            if (c) {\n                switch(dbt) {\n                case VT_LLONG | VT_UNSIGNED:\n                case VT_LLONG:\n                    /* XXX: add const cases for long long */\n                    goto do_ftoi;\n                case VT_INT | VT_UNSIGNED:\n                    switch(sbt) {\n                    case VT_FLOAT: vtop->c.ui = (unsigned int)vtop->c.d; break;\n                    case VT_DOUBLE: vtop->c.ui = (unsigned int)vtop->c.d; break;\n                    case VT_LDOUBLE: vtop->c.ui = (unsigned int)vtop->c.d; break;\n                    }\n                    break;\n                default:\n                    /* int case */\n                    switch(sbt) {\n                    case VT_FLOAT: vtop->c.i = (int)vtop->c.d; break;\n                    case VT_DOUBLE: vtop->c.i = (int)vtop->c.d; break;\n                    case VT_LDOUBLE: vtop->c.i = (int)vtop->c.d; break;\n                    }\n                    break;\n                }\n            } else {\n            do_ftoi:\n                gen_cvt_ftoi1(dbt);\n            }\n            if (dbt == VT_INT && (type->t & (VT_BTYPE | VT_UNSIGNED)) != dbt) {\n                /* additional cast for char/short/bool... */\n                vtop->type.t = dbt;\n                gen_cast(type);\n            }\n        } else if ((dbt & VT_BTYPE) == VT_LLONG) {\n            if ((sbt & VT_BTYPE) != VT_LLONG) {\n                /* scalar to long long */\n                if (c) {\n                    if (sbt == (VT_INT | VT_UNSIGNED))\n                        vtop->c.ll = vtop->c.ui;\n                    else\n                        vtop->c.ll = vtop->c.i;\n                } else {\n                    /* machine independent conversion */\n                    gv(RC_INT);\n                    /* generate high word */\n                    if (sbt == (VT_INT | VT_UNSIGNED)) {\n                        vpushi(0);\n                        gv(RC_INT);\n                    } else {\n                        gv_dup();\n                        vpushi(31);\n                        gen_op(TOK_SAR);\n                    }\n                    /* patch second register */\n                    vtop[-1].r2 = vtop->r;\n                    vpop();\n                }\n            }\n        } else if (dbt == VT_BOOL) {\n            /* scalar to bool */\n            vpushi(0);\n            gen_op(TOK_NE);\n        } else if ((dbt & VT_BTYPE) == VT_BYTE || \n                   (dbt & VT_BTYPE) == VT_SHORT) {\n            force_charshort_cast(dbt);\n        } else if ((dbt & VT_BTYPE) == VT_INT) {\n            /* scalar to int */\n            if (sbt == VT_LLONG) {\n                /* from long long: just take low order word */\n                lexpand();\n                vpop();\n            } \n            /* if lvalue and single word type, nothing to do because\n               the lvalue already contains the real type size (see\n               VT_LVAL_xxx constants) */\n        }\n    }\n    vtop->type = *type;\n}\n\n/* return type size. Put alignment at 'a' */\nstatic int type_size(CType *type, int *a)\n{\n    Sym *s;\n    int bt;\n\n    bt = type->t & VT_BTYPE;\n    if (bt == VT_STRUCT) {\n        /* struct/union */\n        s = type->ref;\n        *a = s->r;\n        return s->c;\n    } else if (bt == VT_PTR) {\n        if (type->t & VT_ARRAY) {\n            s = type->ref;\n            return type_size(&s->type, a) * s->c;\n        } else {\n            *a = PTR_SIZE;\n            return PTR_SIZE;\n        }\n    } else if (bt == VT_LDOUBLE) {\n        *a = LDOUBLE_ALIGN;\n        return LDOUBLE_SIZE;\n    } else if (bt == VT_DOUBLE || bt == VT_LLONG) {\n#ifdef TCC_TARGET_I386\n        *a = 4;\n#else\n        *a = 8;\n#endif\n        return 8;\n    } else if (bt == VT_INT || bt == VT_ENUM || bt == VT_FLOAT) {\n        *a = 4;\n        return 4;\n    } else if (bt == VT_SHORT) {\n        *a = 2;\n        return 2;\n    } else {\n        /* char, void, function, _Bool */\n        *a = 1;\n        return 1;\n    }\n}\n\n/* modify type so that its it is a pointer to type. */\nstatic void mk_pointer(CType *type)\n{\n    Sym *s;\n    s = sym_push(SYM_FIELD, type, 0, -1);\n    type->t = VT_PTR | (type->t & ~VT_TYPE);\n    type->ref = s;\n}\n\n/* compare function types. OLD functions match any new functions */\nstatic int is_compatible_func(CType *type1, CType *type2)\n{\n    Sym *s1, *s2;\n\n    s1 = type1->ref;\n    s2 = type2->ref;\n    if (!is_compatible_types(&s1->type, &s2->type))\n        return 0;\n    /* check func_call */\n    if (s1->r != s2->r)\n        return 0;\n    /* XXX: not complete */\n    if (s1->c == FUNC_OLD || s2->c == FUNC_OLD)\n        return 1;\n    if (s1->c != s2->c)\n        return 0;\n    while (s1 != NULL) {\n        if (s2 == NULL)\n            return 0;\n        if (!is_compatible_types(&s1->type, &s2->type))\n            return 0;\n        s1 = s1->next;\n        s2 = s2->next;\n    }\n    if (s2)\n        return 0;\n    return 1;\n}\n\n/* return true if type1 and type2 are exactly the same (including\n   qualifiers). \n\n   - enums are not checked as gcc __builtin_types_compatible_p () \n */\nstatic int is_compatible_types(CType *type1, CType *type2)\n{\n    int bt1, t1, t2;\n\n    t1 = type1->t & VT_TYPE;\n    t2 = type2->t & VT_TYPE;\n    /* XXX: bitfields ? */\n    if (t1 != t2)\n        return 0;\n    /* test more complicated cases */\n    bt1 = t1 & VT_BTYPE;\n    if (bt1 == VT_PTR) {\n        type1 = pointed_type(type1);\n        type2 = pointed_type(type2);\n        return is_compatible_types(type1, type2);\n    } else if (bt1 == VT_STRUCT) {\n        return (type1->ref == type2->ref);\n    } else if (bt1 == VT_FUNC) {\n        return is_compatible_func(type1, type2);\n    } else {\n        return 1;\n    }\n}\n\n/* print a type. If 'varstr' is not NULL, then the variable is also\n   printed in the type */\n/* XXX: union */\n/* XXX: add array and function pointers */\nvoid type_to_str(char *buf, int buf_size, \n                 CType *type, const char *varstr)\n{\n    int bt, v, t;\n    Sym *s, *sa;\n    char buf1[256];\n    const char *tstr;\n\n    t = type->t & VT_TYPE;\n    bt = t & VT_BTYPE;\n    buf[0] = '\\0';\n    if (t & VT_CONSTANT)\n        pstrcat(buf, buf_size, \"const \");\n    if (t & VT_VOLATILE)\n        pstrcat(buf, buf_size, \"volatile \");\n    if (t & VT_UNSIGNED)\n        pstrcat(buf, buf_size, \"unsigned \");\n    switch(bt) {\n    case VT_VOID:\n        tstr = \"void\";\n        goto add_tstr;\n    case VT_BOOL:\n        tstr = \"_Bool\";\n        goto add_tstr;\n    case VT_BYTE:\n        tstr = \"char\";\n        goto add_tstr;\n    case VT_SHORT:\n        tstr = \"short\";\n        goto add_tstr;\n    case VT_INT:\n        tstr = \"int\";\n        goto add_tstr;\n    case VT_LONG:\n        tstr = \"long\";\n        goto add_tstr;\n    case VT_LLONG:\n        tstr = \"long long\";\n        goto add_tstr;\n    case VT_FLOAT:\n        tstr = \"float\";\n        goto add_tstr;\n    case VT_DOUBLE:\n        tstr = \"double\";\n        goto add_tstr;\n    case VT_LDOUBLE:\n        tstr = \"long double\";\n    add_tstr:\n        pstrcat(buf, buf_size, tstr);\n        break;\n    case VT_ENUM:\n    case VT_STRUCT:\n        if (bt == VT_STRUCT)\n            tstr = \"struct \";\n        else\n            tstr = \"enum \";\n        pstrcat(buf, buf_size, tstr);\n        v = type->ref->v & ~SYM_STRUCT;\n        if (v >= SYM_FIRST_ANOM)\n            pstrcat(buf, buf_size, \"<anonymous>\");\n        else\n            pstrcat(buf, buf_size, get_tok_str(v, NULL));\n        break;\n    case VT_FUNC:\n        s = type->ref;\n        type_to_str(buf, buf_size, &s->type, varstr);\n        pstrcat(buf, buf_size, \"(\");\n        sa = s->next;\n        while (sa != NULL) {\n            type_to_str(buf1, sizeof(buf1), &sa->type, NULL);\n            pstrcat(buf, buf_size, buf1);\n            sa = sa->next;\n            if (sa)\n                pstrcat(buf, buf_size, \", \");\n        }\n        pstrcat(buf, buf_size, \")\");\n        goto no_var;\n    case VT_PTR:\n        s = type->ref;\n        pstrcpy(buf1, sizeof(buf1), \"*\");\n        if (varstr)\n            pstrcat(buf1, sizeof(buf1), varstr);\n        type_to_str(buf, buf_size, &s->type, buf1);\n        goto no_var;\n    }\n    if (varstr) {\n        pstrcat(buf, buf_size, \" \");\n        pstrcat(buf, buf_size, varstr);\n    }\n no_var: ;\n}\n\n/* verify type compatibility to store vtop in 'dt' type, and generate\n   casts if needed. */\nstatic void gen_assign_cast(CType *dt)\n{\n    CType *st, *type1, *type2, tmp_type1, tmp_type2;\n    char buf1[256], buf2[256];\n    int dbt, sbt;\n\n    st = &vtop->type; /* source type */\n    dbt = dt->t & VT_BTYPE;\n    sbt = st->t & VT_BTYPE;\n    if (dt->t & VT_CONSTANT)\n        warning(\"assignment of read-only location\");\n    switch(dbt) {\n    case VT_PTR:\n        /* special cases for pointers */\n        /* '0' can also be a pointer */\n        if (is_null_pointer(vtop))\n            goto type_ok;\n        /* accept implicit pointer to integer cast with warning */\n        if (is_integer_btype(sbt)) {\n            warning(\"assignment makes pointer from integer without a cast\");\n            goto type_ok;\n        }\n        type1 = pointed_type(dt);\n        /* a function is implicitly a function pointer */\n        if (sbt == VT_FUNC) {\n            if ((type1->t & VT_BTYPE) != VT_VOID &&\n                !is_compatible_types(pointed_type(dt), st))\n                goto error;\n            else\n                goto type_ok;\n        }\n        if (sbt != VT_PTR)\n            goto error;\n        type2 = pointed_type(st);\n        if ((type1->t & VT_BTYPE) == VT_VOID || \n            (type2->t & VT_BTYPE) == VT_VOID) {\n            /* void * can match anything */\n        } else {\n            /* exact type match, except for unsigned */\n            tmp_type1 = *type1;\n            tmp_type2 = *type2;\n            tmp_type1.t &= ~(VT_UNSIGNED | VT_CONSTANT | VT_VOLATILE);\n            tmp_type2.t &= ~(VT_UNSIGNED | VT_CONSTANT | VT_VOLATILE);\n            if (!is_compatible_types(&tmp_type1, &tmp_type2))\n                goto error;\n        }\n        /* check const and volatile */\n        if ((!(type1->t & VT_CONSTANT) && (type2->t & VT_CONSTANT)) ||\n            (!(type1->t & VT_VOLATILE) && (type2->t & VT_VOLATILE)))\n            warning(\"assignment discards qualifiers from pointer target type\");\n        break;\n    case VT_BYTE:\n    case VT_SHORT:\n    case VT_INT:\n    case VT_LLONG:\n        if (sbt == VT_PTR || sbt == VT_FUNC) {\n            warning(\"assignment makes integer from pointer without a cast\");\n        }\n        /* XXX: more tests */\n        break;\n    case VT_STRUCT:\n        tmp_type1 = *dt;\n        tmp_type2 = *st;\n        tmp_type1.t &= ~(VT_CONSTANT | VT_VOLATILE);\n        tmp_type2.t &= ~(VT_CONSTANT | VT_VOLATILE);\n        if (!is_compatible_types(&tmp_type1, &tmp_type2)) {\n        error:\n            type_to_str(buf1, sizeof(buf1), st, NULL);\n            type_to_str(buf2, sizeof(buf2), dt, NULL);\n            error(\"cannot cast '%s' to '%s'\", buf1, buf2);\n        }\n        break;\n    }\n type_ok:\n    gen_cast(dt);\n}\n\n/* store vtop in lvalue pushed on stack */\nvoid vstore(void)\n{\n    int sbt, dbt, ft, r, t, size, align, bit_size, bit_pos, rc, delayed_cast;\n\n    ft = vtop[-1].type.t;\n    sbt = vtop->type.t & VT_BTYPE;\n    dbt = ft & VT_BTYPE;\n    if (((sbt == VT_INT || sbt == VT_SHORT) && dbt == VT_BYTE) ||\n        (sbt == VT_INT && dbt == VT_SHORT)) {\n        /* optimize char/short casts */\n        delayed_cast = VT_MUSTCAST;\n        vtop->type.t = ft & VT_TYPE;\n        /* XXX: factorize */\n        if (ft & VT_CONSTANT)\n            warning(\"assignment of read-only location\");\n    } else {\n        delayed_cast = 0;\n        if (!(ft & VT_BITFIELD))\n            gen_assign_cast(&vtop[-1].type);\n    }\n\n    if (sbt == VT_STRUCT) {\n        /* if structure, only generate pointer */\n        /* structure assignment : generate memcpy */\n        /* XXX: optimize if small size */\n        if (!nocode_wanted) {\n            size = type_size(&vtop->type, &align);\n\n            vpush_global_sym(&func_old_type, TOK_memcpy);\n\n            /* destination */\n            vpushv(vtop - 2);\n            vtop->type.t = VT_INT;\n            gaddrof();\n            /* source */\n            vpushv(vtop - 2);\n            vtop->type.t = VT_INT;\n            gaddrof();\n            /* type size */\n            vpushi(size);\n            gfunc_call(3);\n            \n            vswap();\n            vpop();\n        } else {\n            vswap();\n            vpop();\n        }\n        /* leave source on stack */\n    } else if (ft & VT_BITFIELD) {\n        /* bitfield store handling */\n        bit_pos = (ft >> VT_STRUCT_SHIFT) & 0x3f;\n        bit_size = (ft >> (VT_STRUCT_SHIFT + 6)) & 0x3f;\n        /* remove bit field info to avoid loops */\n        vtop[-1].type.t = ft & ~(VT_BITFIELD | (~0U << VT_STRUCT_SHIFT));\n\n        /* duplicate destination */\n        vdup();\n        vtop[-1] = vtop[-2];\n\n        /* mask and shift source */\n        vpushi((1 << bit_size) - 1);\n        gen_op('&');\n        vpushi(bit_pos);\n        gen_op(TOK_SHL);\n        /* load destination, mask and or with source */\n        vswap();\n        vpushi(~(((1 << bit_size) - 1) << bit_pos));\n        gen_op('&');\n        gen_op('|');\n        /* store result */\n        vstore();\n    } else {\n#ifdef CONFIG_TCC_BCHECK\n        /* bound check case */\n        if (vtop[-1].r & VT_MUSTBOUND) {\n            vswap();\n            gbound();\n            vswap();\n        }\n#endif\n        if (!nocode_wanted) {\n            rc = RC_INT;\n            if (is_float(ft))\n                rc = RC_FLOAT;\n            r = gv(rc);  /* generate value */\n            /* if lvalue was saved on stack, must read it */\n            if ((vtop[-1].r & VT_VALMASK) == VT_LLOCAL) {\n                SValue sv;\n                t = get_reg(RC_INT);\n                sv.type.t = VT_INT;\n                sv.r = VT_LOCAL | VT_LVAL;\n                sv.c.ul = vtop[-1].c.ul;\n                load(t, &sv);\n                vtop[-1].r = t | VT_LVAL;\n            }\n            store(r, vtop - 1);\n            /* two word case handling : store second register at word + 4 */\n            if ((ft & VT_BTYPE) == VT_LLONG) {\n                vswap();\n                /* convert to int to increment easily */\n                vtop->type.t = VT_INT;\n                gaddrof();\n                vpushi(4);\n                gen_op('+');\n                vtop->r |= VT_LVAL;\n                vswap();\n                /* XXX: it works because r2 is spilled last ! */\n                store(vtop->r2, vtop - 1);\n            }\n        }\n        vswap();\n        vtop--; /* NOT vpop() because on x86 it would flush the fp stack */\n        vtop->r |= delayed_cast;\n    }\n}\n\n/* post defines POST/PRE add. c is the token ++ or -- */\nvoid inc(int post, int c)\n{\n    test_lvalue();\n    vdup(); /* save lvalue */\n    if (post) {\n        gv_dup(); /* duplicate value */\n        vrotb(3);\n        vrotb(3);\n    }\n    /* add constant */\n    vpushi(c - TOK_MID); \n    gen_op('+');\n    vstore(); /* store value */\n    if (post)\n        vpop(); /* if post op, return saved value */\n}\n\n/* Parse GNUC __attribute__ extension. Currently, the following\n   extensions are recognized:\n   - aligned(n) : set data/function alignment.\n   - packed : force data alignment to 1\n   - section(x) : generate data/code in this section.\n   - unused : currently ignored, but may be used someday.\n   - regparm(n) : pass function parameters in registers (i386 only)\n */\nstatic void parse_attribute(AttributeDef *ad)\n{\n    int t, n;\n    \n    while (tok == TOK_ATTRIBUTE1 || tok == TOK_ATTRIBUTE2) {\n    next();\n    skip('(');\n    skip('(');\n    while (tok != ')') {\n        if (tok < TOK_IDENT)\n            expect(\"attribute name\");\n        t = tok;\n        next();\n        switch(t) {\n        case TOK_SECTION1:\n        case TOK_SECTION2:\n            skip('(');\n            if (tok != TOK_STR)\n                expect(\"section name\");\n            ad->section = find_section(tcc_state, (char *)tokc.cstr->data);\n            next();\n            skip(')');\n            break;\n        case TOK_ALIGNED1:\n        case TOK_ALIGNED2:\n            if (tok == '(') {\n                next();\n                n = expr_const();\n                if (n <= 0 || (n & (n - 1)) != 0) \n                    error(\"alignment must be a positive power of two\");\n                skip(')');\n            } else {\n                n = MAX_ALIGN;\n            }\n            ad->aligned = n;\n            break;\n        case TOK_PACKED1:\n        case TOK_PACKED2:\n            ad->packed = 1;\n            break;\n        case TOK_UNUSED1:\n        case TOK_UNUSED2:\n            /* currently, no need to handle it because tcc does not\n               track unused objects */\n            break;\n        case TOK_NORETURN1:\n        case TOK_NORETURN2:\n            /* currently, no need to handle it because tcc does not\n               track unused objects */\n            break;\n        case TOK_CDECL1:\n        case TOK_CDECL2:\n        case TOK_CDECL3:\n            ad->func_call = FUNC_CDECL;\n            break;\n        case TOK_STDCALL1:\n        case TOK_STDCALL2:\n        case TOK_STDCALL3:\n            ad->func_call = FUNC_STDCALL;\n            break;\n#ifdef TCC_TARGET_I386\n        case TOK_REGPARM1:\n        case TOK_REGPARM2:\n            skip('(');\n            n = expr_const();\n            if (n > 3) \n                n = 3;\n            else if (n < 0)\n                n = 0;\n            if (n > 0)\n                ad->func_call = FUNC_FASTCALL1 + n - 1;\n            skip(')');\n            break;\n#endif\n        case TOK_DLLEXPORT:\n            ad->dllexport = 1;\n            break;\n        default:\n            if (tcc_state->warn_unsupported)\n                warning(\"'%s' attribute ignored\", get_tok_str(t, NULL));\n            /* skip parameters */\n            /* XXX: skip parenthesis too */\n            if (tok == '(') {\n                next();\n                while (tok != ')' && tok != -1)\n                    next();\n                next();\n            }\n            break;\n        }\n        if (tok != ',')\n            break;\n        next();\n    }\n    skip(')');\n    skip(')');\n    }\n}\n\n/* enum/struct/union declaration. u is either VT_ENUM or VT_STRUCT */\nstatic void struct_decl(CType *type, int u)\n{\n    int a, v, size, align, maxalign, c, offset;\n    int bit_size, bit_pos, bsize, bt, lbit_pos;\n    Sym *s, *ss, **ps;\n    AttributeDef ad;\n    CType type1, btype;\n\n    a = tok; /* save decl type */\n    next();\n    if (tok != '{') {\n        v = tok;\n        next();\n        /* struct already defined ? return it */\n        if (v < TOK_IDENT)\n            expect(\"struct/union/enum name\");\n        s = struct_find(v);\n        if (s) {\n            if (s->type.t != a)\n                error(\"invalid type\");\n            goto do_decl;\n        }\n    } else {\n        v = anon_sym++;\n    }\n    type1.t = a;\n    /* we put an undefined size for struct/union */\n    s = sym_push(v | SYM_STRUCT, &type1, 0, -1);\n    s->r = 0; /* default alignment is zero as gcc */\n    /* put struct/union/enum name in type */\n do_decl:\n    type->t = u;\n    type->ref = s;\n    \n    if (tok == '{') {\n        next();\n        if (s->c != -1)\n            error(\"struct/union/enum already defined\");\n        /* cannot be empty */\n        c = 0;\n        /* non empty enums are not allowed */\n        if (a == TOK_ENUM) {\n            for(;;) {\n                v = tok;\n                if (v < TOK_UIDENT)\n                    expect(\"identifier\");\n                next();\n                if (tok == '=') {\n                    next();\n                    c = expr_const();\n                }\n                /* enum symbols have static storage */\n                ss = sym_push(v, &int_type, VT_CONST, c);\n                ss->type.t |= VT_STATIC;\n                if (tok != ',')\n                    break;\n                next();\n                c++;\n                /* NOTE: we accept a trailing comma */\n                if (tok == '}')\n                    break;\n            }\n            skip('}');\n        } else {\n            maxalign = 1;\n            ps = &s->next;\n            bit_pos = 0;\n            offset = 0;\n            while (tok != '}') {\n                parse_btype(&btype, &ad);\n                while (1) {\n                    bit_size = -1;\n                    v = 0;\n                    type1 = btype;\n                    if (tok != ':') {\n                        type_decl(&type1, &ad, &v, TYPE_DIRECT);\n                        if ((type1.t & VT_BTYPE) == VT_FUNC ||\n                            (type1.t & (VT_TYPEDEF | VT_STATIC | VT_EXTERN | VT_INLINE)))\n                            error(\"invalid type for '%s'\", \n                                  get_tok_str(v, NULL));\n                    }\n                    if (tok == ':') {\n                        next();\n                        bit_size = expr_const();\n                        /* XXX: handle v = 0 case for messages */\n                        if (bit_size < 0)\n                            error(\"negative width in bit-field '%s'\", \n                                  get_tok_str(v, NULL));\n                        if (v && bit_size == 0)\n                            error(\"zero width for bit-field '%s'\", \n                                  get_tok_str(v, NULL));\n                    }\n                    size = type_size(&type1, &align);\n                    if (ad.aligned) {\n                        if (align < ad.aligned)\n                            align = ad.aligned;\n                    } else if (ad.packed) {\n                        align = 1;\n                    } else if (*tcc_state->pack_stack_ptr) {\n                        if (align > *tcc_state->pack_stack_ptr)\n                            align = *tcc_state->pack_stack_ptr;\n                    }\n                    lbit_pos = 0;\n                    if (bit_size >= 0) {\n                        bt = type1.t & VT_BTYPE;\n                        if (bt != VT_INT && \n                            bt != VT_BYTE && \n                            bt != VT_SHORT &&\n                            bt != VT_BOOL &&\n                            bt != VT_ENUM)\n                            error(\"bitfields must have scalar type\");\n                        bsize = size * 8;\n                        if (bit_size > bsize) {\n                            error(\"width of '%s' exceeds its type\",\n                                  get_tok_str(v, NULL));\n                        } else if (bit_size == bsize) {\n                            /* no need for bit fields */\n                            bit_pos = 0;\n                        } else if (bit_size == 0) {\n                            /* XXX: what to do if only padding in a\n                               structure ? */\n                            /* zero size: means to pad */\n                            if (bit_pos > 0)\n                                bit_pos = bsize;\n                        } else {\n                            /* we do not have enough room ? */\n                            if ((bit_pos + bit_size) > bsize)\n                                bit_pos = 0;\n                            lbit_pos = bit_pos;\n                            /* XXX: handle LSB first */\n                            type1.t |= VT_BITFIELD | \n                                (bit_pos << VT_STRUCT_SHIFT) |\n                                (bit_size << (VT_STRUCT_SHIFT + 6));\n                            bit_pos += bit_size;\n                        }\n                    } else {\n                        bit_pos = 0;\n                    }\n                    if (v) {\n                        /* add new memory data only if starting\n                           bit field */\n                        if (lbit_pos == 0) {\n                            if (a == TOK_STRUCT) {\n                                c = (c + align - 1) & -align;\n                                offset = c;\n                                c += size;\n                            } else {\n                                offset = 0;\n                                if (size > c)\n                                    c = size;\n                            }\n                            if (align > maxalign)\n                                maxalign = align;\n                        }\n#if 0\n                        printf(\"add field %s offset=%d\", \n                               get_tok_str(v, NULL), offset);\n                        if (type1.t & VT_BITFIELD) {\n                            printf(\" pos=%d size=%d\", \n                                   (type1.t >> VT_STRUCT_SHIFT) & 0x3f,\n                                   (type1.t >> (VT_STRUCT_SHIFT + 6)) & 0x3f);\n                        }\n                        printf(\"\\n\");\n#endif\n                        ss = sym_push(v | SYM_FIELD, &type1, 0, offset);\n                        *ps = ss;\n                        ps = &ss->next;\n                    }\n                    if (tok == ';' || tok == TOK_EOF)\n                        break;\n                    skip(',');\n                }\n                skip(';');\n            }\n            skip('}');\n            /* store size and alignment */\n            s->c = (c + maxalign - 1) & -maxalign; \n            s->r = maxalign;\n        }\n    }\n}\n\n/* return 0 if no type declaration. otherwise, return the basic type\n   and skip it. \n */\nstatic int parse_btype(CType *type, AttributeDef *ad)\n{\n    int t, u, type_found, typespec_found;\n    Sym *s;\n    CType type1;\n\n    memset(ad, 0, sizeof(AttributeDef));\n    type_found = 0;\n    typespec_found = 0;\n    t = 0;\n    while(1) {\n        switch(tok) {\n        case TOK_EXTENSION:\n            /* currently, we really ignore extension */\n            next();\n            continue;\n\n            /* basic types */\n        case TOK_CHAR:\n            u = VT_BYTE;\n        basic_type:\n            next();\n        basic_type1:\n            if ((t & VT_BTYPE) != 0)\n                error(\"too many basic types\");\n            t |= u;\n            typespec_found = 1;\n            break;\n        case TOK_VOID:\n            u = VT_VOID;\n            goto basic_type;\n        case TOK_SHORT:\n            u = VT_SHORT;\n            goto basic_type;\n        case TOK_INT:\n            next();\n            typespec_found = 1;\n            break;\n        case TOK_LONG:\n            next();\n            if ((t & VT_BTYPE) == VT_DOUBLE) {\n                t = (t & ~VT_BTYPE) | VT_LDOUBLE;\n            } else if ((t & VT_BTYPE) == VT_LONG) {\n                t = (t & ~VT_BTYPE) | VT_LLONG;\n            } else {\n                u = VT_LONG;\n                goto basic_type1;\n            }\n            break;\n        case TOK_BOOL:\n            u = VT_BOOL;\n            goto basic_type;\n        case TOK_FLOAT:\n            u = VT_FLOAT;\n            goto basic_type;\n        case TOK_DOUBLE:\n            next();\n            if ((t & VT_BTYPE) == VT_LONG) {\n                t = (t & ~VT_BTYPE) | VT_LDOUBLE;\n            } else {\n                u = VT_DOUBLE;\n                goto basic_type1;\n            }\n            break;\n        case TOK_ENUM:\n            struct_decl(&type1, VT_ENUM);\n        basic_type2:\n            u = type1.t;\n            type->ref = type1.ref;\n            goto basic_type1;\n        case TOK_STRUCT:\n        case TOK_UNION:\n            struct_decl(&type1, VT_STRUCT);\n            goto basic_type2;\n\n            /* type modifiers */\n        case TOK_CONST1:\n        case TOK_CONST2:\n        case TOK_CONST3:\n            t |= VT_CONSTANT;\n            next();\n            break;\n        case TOK_VOLATILE1:\n        case TOK_VOLATILE2:\n        case TOK_VOLATILE3:\n            t |= VT_VOLATILE;\n            next();\n            break;\n        case TOK_SIGNED1:\n        case TOK_SIGNED2:\n        case TOK_SIGNED3:\n            typespec_found = 1;\n\t    t |= VT_SIGNED;\n\t    next();\n\t    break;\n        case TOK_REGISTER:\n        case TOK_AUTO:\n        case TOK_RESTRICT1:\n        case TOK_RESTRICT2:\n        case TOK_RESTRICT3:\n            next();\n            break;\n        case TOK_UNSIGNED:\n            t |= VT_UNSIGNED;\n            next();\n            typespec_found = 1;\n            break;\n\n            /* storage */\n        case TOK_EXTERN:\n            t |= VT_EXTERN;\n            next();\n            break;\n        case TOK_STATIC:\n            t |= VT_STATIC;\n            next();\n            break;\n        case TOK_TYPEDEF:\n            t |= VT_TYPEDEF;\n            next();\n            break;\n        case TOK_INLINE1:\n        case TOK_INLINE2:\n        case TOK_INLINE3:\n            t |= VT_INLINE;\n            next();\n            break;\n\n            /* GNUC attribute */\n        case TOK_ATTRIBUTE1:\n        case TOK_ATTRIBUTE2:\n            parse_attribute(ad);\n            break;\n            /* GNUC typeof */\n        case TOK_TYPEOF1:\n        case TOK_TYPEOF2:\n        case TOK_TYPEOF3:\n            next();\n            parse_expr_type(&type1);\n            goto basic_type2;\n        default:\n            if (typespec_found)\n                goto the_end;\n            s = sym_find(tok);\n            if (!s || !(s->type.t & VT_TYPEDEF))\n                goto the_end;\n            t |= (s->type.t & ~VT_TYPEDEF);\n            type->ref = s->type.ref;\n            next();\n            break;\n        }\n        type_found = 1;\n    }\nthe_end:\n    if ((t & (VT_SIGNED|VT_UNSIGNED)) == (VT_SIGNED|VT_UNSIGNED))\n      error(\"signed and unsigned modifier\");\n    if (tcc_state->char_is_unsigned) {\n        if ((t & (VT_SIGNED|VT_UNSIGNED|VT_BTYPE)) == VT_BYTE)\n            t |= VT_UNSIGNED;\n    }\n    t &= ~VT_SIGNED;\n\n    /* long is never used as type */\n    if ((t & VT_BTYPE) == VT_LONG)\n        t = (t & ~VT_BTYPE) | VT_INT;\n    type->t = t;\n    return type_found;\n}\n\n/* convert a function parameter type (array to pointer and function to\n   function pointer) */\nstatic inline void convert_parameter_type(CType *pt)\n{\n    /* remove const and volatile qualifiers (XXX: const could be used\n       to indicate a const function parameter */\n    pt->t &= ~(VT_CONSTANT | VT_VOLATILE);\n    /* array must be transformed to pointer according to ANSI C */\n    pt->t &= ~VT_ARRAY;\n    if ((pt->t & VT_BTYPE) == VT_FUNC) {\n        mk_pointer(pt);\n    }\n}\n\nstatic void post_type(CType *type, AttributeDef *ad)\n{\n    int n, l, t1;\n    Sym **plast, *s, *first;\n    AttributeDef ad1;\n    CType pt;\n\n    if (tok == '(') {\n        /* function declaration */\n        next();\n        l = 0;\n        first = NULL;\n        plast = &first;\n        while (tok != ')') {\n            /* read param name and compute offset */\n            if (l != FUNC_OLD) {\n                if (!parse_btype(&pt, &ad1)) {\n                    if (l) {\n                        error(\"invalid type\");\n                    } else {\n                        l = FUNC_OLD;\n                        goto old_proto;\n                    }\n                }\n                l = FUNC_NEW;\n                if ((pt.t & VT_BTYPE) == VT_VOID && tok == ')')\n                    break;\n                type_decl(&pt, &ad1, &n, TYPE_DIRECT | TYPE_ABSTRACT);\n                if ((pt.t & VT_BTYPE) == VT_VOID)\n                    error(\"parameter declared as void\");\n            } else {\n            old_proto:\n                n = tok;\n                pt.t = VT_INT;\n                next();\n            }\n            convert_parameter_type(&pt);\n            s = sym_push(n | SYM_FIELD, &pt, 0, 0);\n            *plast = s;\n            plast = &s->next;\n            if (tok == ',') {\n                next();\n                if (l == FUNC_NEW && tok == TOK_DOTS) {\n                    l = FUNC_ELLIPSIS;\n                    next();\n                    break;\n                }\n            }\n        }\n        /* if no parameters, then old type prototype */\n        if (l == 0)\n            l = FUNC_OLD;\n        skip(')');\n        t1 = type->t & VT_STORAGE;\n        /* NOTE: const is ignored in returned type as it has a special\n           meaning in gcc / C++ */\n        type->t &= ~(VT_STORAGE | VT_CONSTANT); \n        post_type(type, ad);\n        /* we push a anonymous symbol which will contain the function prototype */\n        s = sym_push(SYM_FIELD, type, ad->func_call, l);\n        s->next = first;\n        type->t = t1 | VT_FUNC;\n        type->ref = s;\n    } else if (tok == '[') {\n        /* array definition */\n        next();\n        n = -1;\n        if (tok != ']') {\n            n = expr_const();\n            if (n < 0)\n                error(\"invalid array size\");    \n        }\n        skip(']');\n        /* parse next post type */\n        t1 = type->t & VT_STORAGE;\n        type->t &= ~VT_STORAGE;\n        post_type(type, ad);\n        \n        /* we push a anonymous symbol which will contain the array\n           element type */\n        s = sym_push(SYM_FIELD, type, 0, n);\n        type->t = t1 | VT_ARRAY | VT_PTR;\n        type->ref = s;\n    }\n}\n\n/* Parse a type declaration (except basic type), and return the type\n   in 'type'. 'td' is a bitmask indicating which kind of type decl is\n   expected. 'type' should contain the basic type. 'ad' is the\n   attribute definition of the basic type. It can be modified by\n   type_decl(). \n */\nstatic void type_decl(CType *type, AttributeDef *ad, int *v, int td)\n{\n    Sym *s;\n    CType type1, *type2;\n    int qualifiers;\n    \n    while (tok == '*') {\n        qualifiers = 0;\n    redo:\n        next();\n        switch(tok) {\n        case TOK_CONST1:\n        case TOK_CONST2:\n        case TOK_CONST3:\n            qualifiers |= VT_CONSTANT;\n            goto redo;\n        case TOK_VOLATILE1:\n        case TOK_VOLATILE2:\n        case TOK_VOLATILE3:\n            qualifiers |= VT_VOLATILE;\n            goto redo;\n        case TOK_RESTRICT1:\n        case TOK_RESTRICT2:\n        case TOK_RESTRICT3:\n            goto redo;\n        }\n        mk_pointer(type);\n        type->t |= qualifiers;\n    }\n    \n    /* XXX: clarify attribute handling */\n    if (tok == TOK_ATTRIBUTE1 || tok == TOK_ATTRIBUTE2)\n        parse_attribute(ad);\n\n    /* recursive type */\n    /* XXX: incorrect if abstract type for functions (e.g. 'int ()') */\n    type1.t = 0; /* XXX: same as int */\n    if (tok == '(') {\n        next();\n        /* XXX: this is not correct to modify 'ad' at this point, but\n           the syntax is not clear */\n        if (tok == TOK_ATTRIBUTE1 || tok == TOK_ATTRIBUTE2)\n            parse_attribute(ad);\n        type_decl(&type1, ad, v, td);\n        skip(')');\n    } else {\n        /* type identifier */\n        if (tok >= TOK_IDENT && (td & TYPE_DIRECT)) {\n            *v = tok;\n            next();\n        } else {\n            if (!(td & TYPE_ABSTRACT))\n                expect(\"identifier\");\n            *v = 0;\n        }\n    }\n    post_type(type, ad);\n    if (tok == TOK_ATTRIBUTE1 || tok == TOK_ATTRIBUTE2)\n        parse_attribute(ad);\n    if (!type1.t)\n        return;\n    /* append type at the end of type1 */\n    type2 = &type1;\n    for(;;) {\n        s = type2->ref;\n        type2 = &s->type;\n        if (!type2->t) {\n            *type2 = *type;\n            break;\n        }\n    }\n    *type = type1;\n}\n\n/* compute the lvalue VT_LVAL_xxx needed to match type t. */\nstatic int lvalue_type(int t)\n{\n    int bt, r;\n    r = VT_LVAL;\n    bt = t & VT_BTYPE;\n    if (bt == VT_BYTE || bt == VT_BOOL)\n        r |= VT_LVAL_BYTE;\n    else if (bt == VT_SHORT)\n        r |= VT_LVAL_SHORT;\n    else\n        return r;\n    if (t & VT_UNSIGNED)\n        r |= VT_LVAL_UNSIGNED;\n    return r;\n}\n\n/* indirection with full error checking and bound check */\nstatic void indir(void)\n{\n    if ((vtop->type.t & VT_BTYPE) != VT_PTR)\n        expect(\"pointer\");\n    if ((vtop->r & VT_LVAL) && !nocode_wanted)\n        gv(RC_INT);\n    vtop->type = *pointed_type(&vtop->type);\n    /* an array is never an lvalue */\n    if (!(vtop->type.t & VT_ARRAY)) {\n        vtop->r |= lvalue_type(vtop->type.t);\n        /* if bound checking, the referenced pointer must be checked */\n        if (do_bounds_check) \n            vtop->r |= VT_MUSTBOUND;\n    }\n}\n\n/* pass a parameter to a function and do type checking and casting */\nstatic void gfunc_param_typed(Sym *func, Sym *arg)\n{\n    int func_type;\n    CType type;\n\n    func_type = func->c;\n    if (func_type == FUNC_OLD ||\n        (func_type == FUNC_ELLIPSIS && arg == NULL)) {\n        /* default casting : only need to convert float to double */\n        if ((vtop->type.t & VT_BTYPE) == VT_FLOAT) {\n            type.t = VT_DOUBLE;\n            gen_cast(&type);\n        }\n    } else if (arg == NULL) {\n        error(\"too many arguments to function\");\n    } else {\n        type = arg->type;\n        type.t &= ~VT_CONSTANT; /* need to do that to avoid false warning */\n        gen_assign_cast(&type);\n    }\n}\n\n/* parse an expression of the form '(type)' or '(expr)' and return its\n   type */\nstatic void parse_expr_type(CType *type)\n{\n    int n;\n    AttributeDef ad;\n\n    skip('(');\n    if (parse_btype(type, &ad)) {\n        type_decl(type, &ad, &n, TYPE_ABSTRACT);\n    } else {\n        expr_type(type);\n    }\n    skip(')');\n}\n\nstatic void parse_type(CType *type)\n{\n    AttributeDef ad;\n    int n;\n\n    if (!parse_btype(type, &ad)) {\n        expect(\"type\");\n    }\n    type_decl(type, &ad, &n, TYPE_ABSTRACT);\n}\n\nstatic void vpush_tokc(int t)\n{\n    CType type;\n    type.t = t;\n    vsetc(&type, VT_CONST, &tokc);\n}\n\nstatic void unary(void)\n{\n    int n, t, align, size, r;\n    CType type;\n    Sym *s;\n    AttributeDef ad;\n\n    /* XXX: GCC 2.95.3 does not generate a table although it should be\n       better here */\n tok_next:\n    switch(tok) {\n    case TOK_EXTENSION:\n        next();\n        goto tok_next;\n    case TOK_CINT:\n    case TOK_CCHAR: \n    case TOK_LCHAR:\n        vpushi(tokc.i);\n        next();\n        break;\n    case TOK_CUINT:\n        vpush_tokc(VT_INT | VT_UNSIGNED);\n        next();\n        break;\n    case TOK_CLLONG:\n        vpush_tokc(VT_LLONG);\n        next();\n        break;\n    case TOK_CULLONG:\n        vpush_tokc(VT_LLONG | VT_UNSIGNED);\n        next();\n        break;\n    case TOK_CFLOAT:\n        vpush_tokc(VT_FLOAT);\n        next();\n        break;\n    case TOK_CDOUBLE:\n        vpush_tokc(VT_DOUBLE);\n        next();\n        break;\n    case TOK_CLDOUBLE:\n        vpush_tokc(VT_LDOUBLE);\n        next();\n        break;\n    case TOK___FUNCTION__:\n        if (!gnu_ext)\n            goto tok_identifier;\n        /* fall thru */\n    case TOK___FUNC__:\n        {\n            void *ptr;\n            int len;\n            /* special function name identifier */\n            len = strlen(funcname) + 1;\n            /* generate char[len] type */\n            type.t = VT_BYTE;\n            mk_pointer(&type);\n            type.t |= VT_ARRAY;\n            type.ref->c = len;\n            vpush_ref(&type, data_section, data_section->data_offset, len);\n            ptr = section_ptr_add(data_section, len);\n            memcpy(ptr, funcname, len);\n            next();\n        }\n        break;\n    case TOK_LSTR:\n        t = VT_INT;\n        goto str_init;\n    case TOK_STR:\n        /* string parsing */\n        t = VT_BYTE;\n    str_init:\n        if (tcc_state->warn_write_strings)\n            t |= VT_CONSTANT;\n        type.t = t;\n        mk_pointer(&type);\n        type.t |= VT_ARRAY;\n        memset(&ad, 0, sizeof(AttributeDef));\n        decl_initializer_alloc(&type, &ad, VT_CONST, 2, 0, 0);\n        break;\n    case '(':\n        next();\n        /* cast ? */\n        if (parse_btype(&type, &ad)) {\n            type_decl(&type, &ad, &n, TYPE_ABSTRACT);\n            skip(')');\n            /* check ISOC99 compound literal */\n            if (tok == '{') {\n                    /* data is allocated locally by default */\n                if (global_expr)\n                    r = VT_CONST;\n                else\n                    r = VT_LOCAL;\n                /* all except arrays are lvalues */\n                if (!(type.t & VT_ARRAY))\n                    r |= lvalue_type(type.t);\n                memset(&ad, 0, sizeof(AttributeDef));\n                decl_initializer_alloc(&type, &ad, r, 1, 0, 0);\n            } else {\n                unary();\n                gen_cast(&type);\n            }\n        } else if (tok == '{') {\n            /* save all registers */\n            save_regs(0); \n            /* statement expression : we do not accept break/continue\n               inside as GCC does */\n            block(NULL, NULL, NULL, NULL, 0, 1);\n            skip(')');\n        } else {\n            gexpr();\n            skip(')');\n        }\n        break;\n    case '*':\n        next();\n        unary();\n        indir();\n        break;\n    case '&':\n        next();\n        unary();\n        /* functions names must be treated as function pointers,\n           except for unary '&' and sizeof. Since we consider that\n           functions are not lvalues, we only have to handle it\n           there and in function calls. */\n        /* arrays can also be used although they are not lvalues */\n        if ((vtop->type.t & VT_BTYPE) != VT_FUNC &&\n            !(vtop->type.t & VT_ARRAY))\n            test_lvalue();\n        mk_pointer(&vtop->type);\n        gaddrof();\n        break;\n    case '!':\n        next();\n        unary();\n        if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST)\n            vtop->c.i = !vtop->c.i;\n        else if ((vtop->r & VT_VALMASK) == VT_CMP)\n            vtop->c.i = vtop->c.i ^ 1;\n        else\n            vseti(VT_JMP, gtst(1, 0));\n        break;\n    case '~':\n        next();\n        unary();\n        vpushi(-1);\n        gen_op('^');\n        break;\n    case '+':\n        next();\n        /* in order to force cast, we add zero */\n        unary();\n        if ((vtop->type.t & VT_BTYPE) == VT_PTR)\n            error(\"pointer not accepted for unary plus\");\n        vpushi(0);\n        gen_op('+');\n        break;\n    case TOK_SIZEOF:\n    case TOK_ALIGNOF1:\n    case TOK_ALIGNOF2:\n        t = tok;\n        next();\n        if (tok == '(') {\n            parse_expr_type(&type);\n        } else {\n            unary_type(&type);\n        }\n        size = type_size(&type, &align);\n        if (t == TOK_SIZEOF) {\n            if (size < 0)\n                error(\"sizeof applied to an incomplete type\");\n            vpushi(size);\n        } else {\n            vpushi(align);\n        }\n        break;\n\n    case TOK_builtin_types_compatible_p:\n        {\n            CType type1, type2;\n            next();\n            skip('(');\n            parse_type(&type1);\n            skip(',');\n            parse_type(&type2);\n            skip(')');\n            type1.t &= ~(VT_CONSTANT | VT_VOLATILE);\n            type2.t &= ~(VT_CONSTANT | VT_VOLATILE);\n            vpushi(is_compatible_types(&type1, &type2));\n        }\n        break;\n    case TOK_builtin_constant_p:\n        {\n            int saved_nocode_wanted, res;\n            next();\n            skip('(');\n            saved_nocode_wanted = nocode_wanted;\n            nocode_wanted = 1;\n            gexpr();\n            res = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;\n            vpop();\n            nocode_wanted = saved_nocode_wanted;\n            skip(')');\n            vpushi(res);\n        }\n        break;\n    case TOK_INC:\n    case TOK_DEC:\n        t = tok;\n        next();\n        unary();\n        inc(0, t);\n        break;\n    case '-':\n        next();\n        vpushi(0);\n        unary();\n        gen_op('-');\n        break;\n    case TOK_LAND:\n        if (!gnu_ext)\n            goto tok_identifier;\n        next();\n        /* allow to take the address of a label */\n        if (tok < TOK_UIDENT)\n            expect(\"label identifier\");\n        s = label_find(tok);\n        if (!s) {\n            s = label_push(&global_label_stack, tok, LABEL_FORWARD);\n        } else {\n            if (s->r == LABEL_DECLARED)\n                s->r = LABEL_FORWARD;\n        }\n        if (!s->type.t) {\n            s->type.t = VT_VOID;\n            mk_pointer(&s->type);\n            s->type.t |= VT_STATIC;\n        }\n        vset(&s->type, VT_CONST | VT_SYM, 0);\n        vtop->sym = s;\n        next();\n        break;\n    default:\n    tok_identifier:\n        t = tok;\n        next();\n        if (t < TOK_UIDENT)\n            expect(\"identifier\");\n        s = sym_find(t);\n        if (!s) {\n            if (tok != '(')\n                error(\"'%s' undeclared\", get_tok_str(t, NULL));\n            /* for simple function calls, we tolerate undeclared\n               external reference to int() function */\n            if (tcc_state->warn_implicit_function_declaration)\n                warning(\"implicit declaration of function '%s'\",\n                        get_tok_str(t, NULL));\n            s = external_global_sym(t, &func_old_type, 0); \n        }\n        if ((s->type.t & (VT_STATIC | VT_INLINE | VT_BTYPE)) ==\n            (VT_STATIC | VT_INLINE | VT_FUNC)) {\n            /* if referencing an inline function, then we generate a\n               symbol to it if not already done. It will have the\n               effect to generate code for it at the end of the\n               compilation unit. Inline function as always\n               generated in the text section. */\n            if (!s->c)\n                put_extern_sym(s, text_section, 0, 0);\n            r = VT_SYM | VT_CONST;\n        } else {\n            r = s->r;\n        }\n        vset(&s->type, r, s->c);\n        /* if forward reference, we must point to s */\n        if (vtop->r & VT_SYM) {\n            vtop->sym = s;\n            vtop->c.ul = 0;\n        }\n        break;\n    }\n    \n    /* post operations */\n    while (1) {\n        if (tok == TOK_INC || tok == TOK_DEC) {\n            inc(1, tok);\n            next();\n        } else if (tok == '.' || tok == TOK_ARROW) {\n            /* field */ \n            if (tok == TOK_ARROW) \n                indir();\n            test_lvalue();\n            gaddrof();\n            next();\n            /* expect pointer on structure */\n            if ((vtop->type.t & VT_BTYPE) != VT_STRUCT)\n                expect(\"struct or union\");\n            s = vtop->type.ref;\n            /* find field */\n            tok |= SYM_FIELD;\n            while ((s = s->next) != NULL) {\n                if (s->v == tok)\n                    break;\n            }\n            if (!s)\n                error(\"field not found\");\n            /* add field offset to pointer */\n            vtop->type = char_pointer_type; /* change type to 'char *' */\n            vpushi(s->c);\n            gen_op('+');\n            /* change type to field type, and set to lvalue */\n            vtop->type = s->type;\n            /* an array is never an lvalue */\n            if (!(vtop->type.t & VT_ARRAY)) {\n                vtop->r |= lvalue_type(vtop->type.t);\n                /* if bound checking, the referenced pointer must be checked */\n                if (do_bounds_check) \n                    vtop->r |= VT_MUSTBOUND;\n            }\n            next();\n        } else if (tok == '[') {\n            next();\n            gexpr();\n            gen_op('+');\n            indir();\n            skip(']');\n        } else if (tok == '(') {\n            SValue ret;\n            Sym *sa;\n            int nb_args;\n\n            /* function call  */\n            if ((vtop->type.t & VT_BTYPE) != VT_FUNC) {\n                /* pointer test (no array accepted) */\n                if ((vtop->type.t & (VT_BTYPE | VT_ARRAY)) == VT_PTR) {\n                    vtop->type = *pointed_type(&vtop->type);\n                    if ((vtop->type.t & VT_BTYPE) != VT_FUNC)\n                        goto error_func;\n                } else {\n                error_func:\n                    expect(\"function pointer\");\n                }\n            } else {\n                vtop->r &= ~VT_LVAL; /* no lvalue */\n            }\n            /* get return type */\n            s = vtop->type.ref;\n            next();\n            sa = s->next; /* first parameter */\n            nb_args = 0;\n            /* compute first implicit argument if a structure is returned */\n            if ((s->type.t & VT_BTYPE) == VT_STRUCT) {\n                /* get some space for the returned structure */\n                size = type_size(&s->type, &align);\n                loc = (loc - size) & -align;\n                ret.type = s->type;\n                ret.r = VT_LOCAL | VT_LVAL;\n                /* pass it as 'int' to avoid structure arg passing\n                   problems */\n                vseti(VT_LOCAL, loc);\n                ret.c = vtop->c;\n                nb_args++;\n            } else {\n                ret.type = s->type; \n                ret.r2 = VT_CONST;\n                /* return in register */\n                if (is_float(ret.type.t)) {\n                    ret.r = REG_FRET; \n                } else {\n                    if ((ret.type.t & VT_BTYPE) == VT_LLONG)\n                        ret.r2 = REG_LRET;\n                    ret.r = REG_IRET;\n                }\n                ret.c.i = 0;\n            }\n            if (tok != ')') {\n                for(;;) {\n                    expr_eq();\n                    gfunc_param_typed(s, sa);\n                    nb_args++;\n                    if (sa)\n                        sa = sa->next;\n                    if (tok == ')')\n                        break;\n                    skip(',');\n                }\n            }\n            if (sa)\n                error(\"too few arguments to function\");\n            skip(')');\n            if (!nocode_wanted) {\n                gfunc_call(nb_args);\n            } else {\n                vtop -= (nb_args + 1);\n            }\n            /* return value */\n            vsetc(&ret.type, ret.r, &ret.c);\n            vtop->r2 = ret.r2;\n        } else {\n            break;\n        }\n    }\n}\n\nstatic void uneq(void)\n{\n    int t;\n    \n    unary();\n    if (tok == '=' ||\n        (tok >= TOK_A_MOD && tok <= TOK_A_DIV) ||\n        tok == TOK_A_XOR || tok == TOK_A_OR ||\n        tok == TOK_A_SHL || tok == TOK_A_SAR) {\n        test_lvalue();\n        t = tok;\n        next();\n        if (t == '=') {\n            expr_eq();\n        } else {\n            vdup();\n            expr_eq();\n            gen_op(t & 0x7f);\n        }\n        vstore();\n    }\n}\n\nstatic void expr_prod(void)\n{\n    int t;\n\n    uneq();\n    while (tok == '*' || tok == '/' || tok == '%') {\n        t = tok;\n        next();\n        uneq();\n        gen_op(t);\n    }\n}\n\nstatic void expr_sum(void)\n{\n    int t;\n\n    expr_prod();\n    while (tok == '+' || tok == '-') {\n        t = tok;\n        next();\n        expr_prod();\n        gen_op(t);\n    }\n}\n\nstatic void expr_shift(void)\n{\n    int t;\n\n    expr_sum();\n    while (tok == TOK_SHL || tok == TOK_SAR) {\n        t = tok;\n        next();\n        expr_sum();\n        gen_op(t);\n    }\n}\n\nstatic void expr_cmp(void)\n{\n    int t;\n\n    expr_shift();\n    while ((tok >= TOK_ULE && tok <= TOK_GT) ||\n           tok == TOK_ULT || tok == TOK_UGE) {\n        t = tok;\n        next();\n        expr_shift();\n        gen_op(t);\n    }\n}\n\nstatic void expr_cmpeq(void)\n{\n    int t;\n\n    expr_cmp();\n    while (tok == TOK_EQ || tok == TOK_NE) {\n        t = tok;\n        next();\n        expr_cmp();\n        gen_op(t);\n    }\n}\n\nstatic void expr_and(void)\n{\n    expr_cmpeq();\n    while (tok == '&') {\n        next();\n        expr_cmpeq();\n        gen_op('&');\n    }\n}\n\nstatic void expr_xor(void)\n{\n    expr_and();\n    while (tok == '^') {\n        next();\n        expr_and();\n        gen_op('^');\n    }\n}\n\nstatic void expr_or(void)\n{\n    expr_xor();\n    while (tok == '|') {\n        next();\n        expr_xor();\n        gen_op('|');\n    }\n}\n\n/* XXX: fix this mess */\nstatic void expr_land_const(void)\n{\n    expr_or();\n    while (tok == TOK_LAND) {\n        next();\n        expr_or();\n        gen_op(TOK_LAND);\n    }\n}\n\n/* XXX: fix this mess */\nstatic void expr_lor_const(void)\n{\n    expr_land_const();\n    while (tok == TOK_LOR) {\n        next();\n        expr_land_const();\n        gen_op(TOK_LOR);\n    }\n}\n\n/* only used if non constant */\nstatic void expr_land(void)\n{\n    int t;\n\n    expr_or();\n    if (tok == TOK_LAND) {\n        t = 0;\n        for(;;) {\n            t = gtst(1, t);\n            if (tok != TOK_LAND) {\n                vseti(VT_JMPI, t);\n                break;\n            }\n            next();\n            expr_or();\n        }\n    }\n}\n\nstatic void expr_lor(void)\n{\n    int t;\n\n    expr_land();\n    if (tok == TOK_LOR) {\n        t = 0;\n        for(;;) {\n            t = gtst(0, t);\n            if (tok != TOK_LOR) {\n                vseti(VT_JMP, t);\n                break;\n            }\n            next();\n            expr_land();\n        }\n    }\n}\n\n/* XXX: better constant handling */\nstatic void expr_eq(void)\n{\n    int tt, u, r1, r2, rc, t1, t2, bt1, bt2;\n    SValue sv;\n    CType type, type1, type2;\n\n    if (const_wanted) {\n        int c1, c;\n        expr_lor_const();\n        if (tok == '?') {\n            c = vtop->c.i;\n            vpop();\n            next();\n            if (tok == ':' && gnu_ext) {\n                c1 = c;\n            } else {\n                gexpr();\n                c1 = vtop->c.i;\n                vpop();\n            }\n            skip(':');\n            expr_eq();\n            if (c)\n                vtop->c.i = c1;\n        }\n    } else {\n        expr_lor();\n        if (tok == '?') {\n            next();\n            if (vtop != vstack) {\n                /* needed to avoid having different registers saved in\n                   each branch */\n                if (is_float(vtop->type.t))\n                    rc = RC_FLOAT;\n                else\n                    rc = RC_INT;\n                gv(rc);\n                save_regs(1);\n            }\n            if (tok == ':' && gnu_ext) {\n                gv_dup();\n                tt = gtst(1, 0);\n            } else {\n                tt = gtst(1, 0);\n                gexpr();\n            }\n            type1 = vtop->type;\n            sv = *vtop; /* save value to handle it later */\n            vtop--; /* no vpop so that FP stack is not flushed */\n            skip(':');\n            u = gjmp(0);\n            gsym(tt);\n            expr_eq();\n            type2 = vtop->type;\n\n            t1 = type1.t;\n            bt1 = t1 & VT_BTYPE;\n            t2 = type2.t;\n            bt2 = t2 & VT_BTYPE;\n            /* cast operands to correct type according to ISOC rules */\n            if (is_float(bt1) || is_float(bt2)) {\n                if (bt1 == VT_LDOUBLE || bt2 == VT_LDOUBLE) {\n                    type.t = VT_LDOUBLE;\n                } else if (bt1 == VT_DOUBLE || bt2 == VT_DOUBLE) {\n                    type.t = VT_DOUBLE;\n                } else {\n                    type.t = VT_FLOAT;\n                }\n            } else if (bt1 == VT_LLONG || bt2 == VT_LLONG) {\n                /* cast to biggest op */\n                type.t = VT_LLONG;\n                /* convert to unsigned if it does not fit in a long long */\n                if ((t1 & (VT_BTYPE | VT_UNSIGNED)) == (VT_LLONG | VT_UNSIGNED) ||\n                    (t2 & (VT_BTYPE | VT_UNSIGNED)) == (VT_LLONG | VT_UNSIGNED))\n                    type.t |= VT_UNSIGNED;\n            } else if (bt1 == VT_PTR || bt2 == VT_PTR) {\n                /* XXX: test pointer compatibility */\n                type = type1;\n            } else if (bt1 == VT_STRUCT || bt2 == VT_STRUCT) {\n                /* XXX: test structure compatibility */\n                type = type1;\n            } else if (bt1 == VT_VOID || bt2 == VT_VOID) {\n                /* NOTE: as an extension, we accept void on only one side */\n                type.t = VT_VOID;\n            } else {\n                /* integer operations */\n                type.t = VT_INT;\n                /* convert to unsigned if it does not fit in an integer */\n                if ((t1 & (VT_BTYPE | VT_UNSIGNED)) == (VT_INT | VT_UNSIGNED) ||\n                    (t2 & (VT_BTYPE | VT_UNSIGNED)) == (VT_INT | VT_UNSIGNED))\n                    type.t |= VT_UNSIGNED;\n            }\n                \n            /* now we convert second operand */\n            gen_cast(&type);\n            rc = RC_INT;\n            if (is_float(type.t)) {\n                rc = RC_FLOAT;\n            } else if ((type.t & VT_BTYPE) == VT_LLONG) {\n                /* for long longs, we use fixed registers to avoid having\n                   to handle a complicated move */\n                rc = RC_IRET; \n            }\n            \n            r2 = gv(rc);\n            /* this is horrible, but we must also convert first\n               operand */\n            tt = gjmp(0);\n            gsym(u);\n            /* put again first value and cast it */\n            *vtop = sv;\n            gen_cast(&type);\n            r1 = gv(rc);\n            move_reg(r2, r1);\n            vtop->r = r2;\n            gsym(tt);\n        }\n    }\n}\n\nstatic void gexpr(void)\n{\n    while (1) {\n        expr_eq();\n        if (tok != ',')\n            break;\n        vpop();\n        next();\n    }\n}\n\n/* parse an expression and return its type without any side effect. */\nstatic void expr_type(CType *type)\n{\n    int saved_nocode_wanted;\n\n    saved_nocode_wanted = nocode_wanted;\n    nocode_wanted = 1;\n    gexpr();\n    *type = vtop->type;\n    vpop();\n    nocode_wanted = saved_nocode_wanted;\n}\n\n/* parse a unary expression and return its type without any side\n   effect. */\nstatic void unary_type(CType *type)\n{\n    int a;\n\n    a = nocode_wanted;\n    nocode_wanted = 1;\n    unary();\n    *type = vtop->type;\n    vpop();\n    nocode_wanted = a;\n}\n\n/* parse a constant expression and return value in vtop.  */\nstatic void expr_const1(void)\n{\n    int a;\n    a = const_wanted;\n    const_wanted = 1;\n    expr_eq();\n    const_wanted = a;\n}\n\n/* parse an integer constant and return its value. */\nstatic int expr_const(void)\n{\n    int c;\n    expr_const1();\n    if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)\n        expect(\"constant expression\");\n    c = vtop->c.i;\n    vpop();\n    return c;\n}\n\n/* return the label token if current token is a label, otherwise\n   return zero */\nstatic int is_label(void)\n{\n    int last_tok;\n\n    /* fast test first */\n    if (tok < TOK_UIDENT)\n        return 0;\n    /* no need to save tokc because tok is an identifier */\n    last_tok = tok;\n    next();\n    if (tok == ':') {\n        next();\n        return last_tok;\n    } else {\n        unget_tok(last_tok);\n        return 0;\n    }\n}\n\nstatic void block(int *bsym, int *csym, int *case_sym, int *def_sym, \n                  int case_reg, int is_expr)\n{\n    int a, b, c, d;\n    Sym *s;\n\n    /* generate line number info */\n    if (do_debug && \n        (last_line_num != file->line_num || last_ind != ind)) {\n        put_stabn(N_SLINE, 0, file->line_num, ind - func_ind);\n        last_ind = ind;\n        last_line_num = file->line_num;\n    }\n\n    if (is_expr) {\n        /* default return value is (void) */\n        vpushi(0);\n        vtop->type.t = VT_VOID;\n    }\n\n    if (tok == TOK_IF) {\n        /* if test */\n        next();\n        skip('(');\n        gexpr();\n        skip(')');\n        a = gtst(1, 0);\n        block(bsym, csym, case_sym, def_sym, case_reg, 0);\n        c = tok;\n        if (c == TOK_ELSE) {\n            next();\n            d = gjmp(0);\n            gsym(a);\n            block(bsym, csym, case_sym, def_sym, case_reg, 0);\n            gsym(d); /* patch else jmp */\n        } else\n            gsym(a);\n    } else if (tok == TOK_WHILE) {\n        next();\n        d = ind;\n        skip('(');\n        gexpr();\n        skip(')');\n        a = gtst(1, 0);\n        b = 0;\n        block(&a, &b, case_sym, def_sym, case_reg, 0);\n        gjmp_addr(d);\n        gsym(a);\n        gsym_addr(b, d);\n    } else if (tok == '{') {\n        Sym *llabel;\n        \n        next();\n        /* record local declaration stack position */\n        s = local_stack;\n        llabel = local_label_stack;\n        /* handle local labels declarations */\n        if (tok == TOK_LABEL) {\n            next();\n            for(;;) {\n                if (tok < TOK_UIDENT)\n                    expect(\"label identifier\");\n                label_push(&local_label_stack, tok, LABEL_DECLARED);\n                next();\n                if (tok == ',') {\n                    next();\n                } else {\n                    skip(';');\n                    break;\n                }\n            }\n        }\n        while (tok != '}') {\n            decl(VT_LOCAL);\n            if (tok != '}') {\n                if (is_expr)\n                    vpop();\n                block(bsym, csym, case_sym, def_sym, case_reg, is_expr);\n            }\n        }\n        /* pop locally defined labels */\n        label_pop(&local_label_stack, llabel);\n        /* pop locally defined symbols */\n        sym_pop(&local_stack, s);\n        next();\n    } else if (tok == TOK_RETURN) {\n        next();\n        if (tok != ';') {\n            gexpr();\n            gen_assign_cast(&func_vt);\n            if ((func_vt.t & VT_BTYPE) == VT_STRUCT) {\n                CType type;\n                /* if returning structure, must copy it to implicit\n                   first pointer arg location */\n                type = func_vt;\n                mk_pointer(&type);\n                vset(&type, VT_LOCAL | VT_LVAL, func_vc);\n                indir();\n                vswap();\n                /* copy structure value to pointer */\n                vstore();\n            } else if (is_float(func_vt.t)) {\n                gv(RC_FRET);\n            } else {\n                gv(RC_IRET);\n            }\n            vtop--; /* NOT vpop() because on x86 it would flush the fp stack */\n        }\n        skip(';');\n        rsym = gjmp(rsym); /* jmp */\n    } else if (tok == TOK_BREAK) {\n        /* compute jump */\n        if (!bsym)\n            error(\"cannot break\");\n        *bsym = gjmp(*bsym);\n        next();\n        skip(';');\n    } else if (tok == TOK_CONTINUE) {\n        /* compute jump */\n        if (!csym)\n            error(\"cannot continue\");\n        *csym = gjmp(*csym);\n        next();\n        skip(';');\n    } else if (tok == TOK_FOR) {\n        int e;\n        next();\n        skip('(');\n        if (tok != ';') {\n            gexpr();\n            vpop();\n        }\n        skip(';');\n        d = ind;\n        c = ind;\n        a = 0;\n        b = 0;\n        if (tok != ';') {\n            gexpr();\n            a = gtst(1, 0);\n        }\n        skip(';');\n        if (tok != ')') {\n            e = gjmp(0);\n            c = ind;\n            gexpr();\n            vpop();\n            gjmp_addr(d);\n            gsym(e);\n        }\n        skip(')');\n        block(&a, &b, case_sym, def_sym, case_reg, 0);\n        gjmp_addr(c);\n        gsym(a);\n        gsym_addr(b, c);\n    } else \n    if (tok == TOK_DO) {\n        next();\n        a = 0;\n        b = 0;\n        d = ind;\n        block(&a, &b, case_sym, def_sym, case_reg, 0);\n        skip(TOK_WHILE);\n        skip('(');\n        gsym(b);\n        gexpr();\n        c = gtst(0, 0);\n        gsym_addr(c, d);\n        skip(')');\n        gsym(a);\n        skip(';');\n    } else\n    if (tok == TOK_SWITCH) {\n        next();\n        skip('(');\n        gexpr();\n        /* XXX: other types than integer */\n        case_reg = gv(RC_INT);\n        vpop();\n        skip(')');\n        a = 0;\n        b = gjmp(0); /* jump to first case */\n        c = 0;\n        block(&a, csym, &b, &c, case_reg, 0);\n        /* if no default, jmp after switch */\n        if (c == 0)\n            c = ind;\n        /* default label */\n        gsym_addr(b, c);\n        /* break label */\n        gsym(a);\n    } else\n    if (tok == TOK_CASE) {\n        int v1, v2;\n        if (!case_sym)\n            expect(\"switch\");\n        next();\n        v1 = expr_const();\n        v2 = v1;\n        if (gnu_ext && tok == TOK_DOTS) {\n            next();\n            v2 = expr_const();\n            if (v2 < v1)\n                warning(\"empty case range\");\n        }\n        /* since a case is like a label, we must skip it with a jmp */\n        b = gjmp(0);\n        gsym(*case_sym);\n        vseti(case_reg, 0);\n        vpushi(v1);\n        if (v1 == v2) {\n            gen_op(TOK_EQ);\n            *case_sym = gtst(1, 0);\n        } else {\n            gen_op(TOK_GE);\n            *case_sym = gtst(1, 0);\n            vseti(case_reg, 0);\n            vpushi(v2);\n            gen_op(TOK_LE);\n            *case_sym = gtst(1, *case_sym);\n        }\n        gsym(b);\n        skip(':');\n        is_expr = 0;\n        goto block_after_label;\n    } else \n    if (tok == TOK_DEFAULT) {\n        next();\n        skip(':');\n        if (!def_sym)\n            expect(\"switch\");\n        if (*def_sym)\n            error(\"too many 'default'\");\n        *def_sym = ind;\n        is_expr = 0;\n        goto block_after_label;\n    } else\n    if (tok == TOK_GOTO) {\n        next();\n        if (tok == '*' && gnu_ext) {\n            /* computed goto */\n            next();\n            gexpr();\n            if ((vtop->type.t & VT_BTYPE) != VT_PTR)\n                expect(\"pointer\");\n            ggoto();\n        } else if (tok >= TOK_UIDENT) {\n            s = label_find(tok);\n            /* put forward definition if needed */\n            if (!s) {\n                s = label_push(&global_label_stack, tok, LABEL_FORWARD);\n            } else {\n                if (s->r == LABEL_DECLARED)\n                    s->r = LABEL_FORWARD;\n            }\n            /* label already defined */\n            if (s->r & LABEL_FORWARD) \n                s->next = (void *)gjmp((long)s->next);\n            else\n                gjmp_addr((long)s->next);\n            next();\n        } else {\n            expect(\"label identifier\");\n        }\n        skip(';');\n    } else if (tok == TOK_ASM1 || tok == TOK_ASM2 || tok == TOK_ASM3) {\n        asm_instr();\n    } else {\n        b = is_label();\n        if (b) {\n            /* label case */\n            s = label_find(b);\n            if (s) {\n                if (s->r == LABEL_DEFINED)\n                    error(\"duplicate label '%s'\", get_tok_str(s->v, NULL));\n                gsym((long)s->next);\n                s->r = LABEL_DEFINED;\n            } else {\n                s = label_push(&global_label_stack, b, LABEL_DEFINED);\n            }\n            s->next = (void *)ind;\n            /* we accept this, but it is a mistake */\n        block_after_label:\n            if (tok == '}') {\n                warning(\"deprecated use of label at end of compound statement\");\n            } else {\n                if (is_expr)\n                    vpop();\n                block(bsym, csym, case_sym, def_sym, case_reg, is_expr);\n            }\n        } else {\n            /* expression case */\n            if (tok != ';') {\n                if (is_expr) {\n                    vpop();\n                    gexpr();\n                } else {\n                    gexpr();\n                    vpop();\n                }\n            }\n            skip(';');\n        }\n    }\n}\n\n/* t is the array or struct type. c is the array or struct\n   address. cur_index/cur_field is the pointer to the current\n   value. 'size_only' is true if only size info is needed (only used\n   in arrays) */\nstatic void decl_designator(CType *type, Section *sec, unsigned long c, \n                            int *cur_index, Sym **cur_field, \n                            int size_only)\n{\n    Sym *s, *f;\n    int notfirst, index, index_last, align, l, nb_elems, elem_size;\n    CType type1;\n\n    notfirst = 0;\n    elem_size = 0;\n    nb_elems = 1;\n    if (gnu_ext && (l = is_label()) != 0)\n        goto struct_field;\n    while (tok == '[' || tok == '.') {\n        if (tok == '[') {\n            if (!(type->t & VT_ARRAY))\n                expect(\"array type\");\n            s = type->ref;\n            next();\n            index = expr_const();\n            if (index < 0 || (s->c >= 0 && index >= s->c))\n                expect(\"invalid index\");\n            if (tok == TOK_DOTS && gnu_ext) {\n                next();\n                index_last = expr_const();\n                if (index_last < 0 || \n                    (s->c >= 0 && index_last >= s->c) ||\n                    index_last < index)\n                    expect(\"invalid index\");\n            } else {\n                index_last = index;\n            }\n            skip(']');\n            if (!notfirst)\n                *cur_index = index_last;\n            type = pointed_type(type);\n            elem_size = type_size(type, &align);\n            c += index * elem_size;\n            /* NOTE: we only support ranges for last designator */\n            nb_elems = index_last - index + 1;\n            if (nb_elems != 1) {\n                notfirst = 1;\n                break;\n            }\n        } else {\n            next();\n            l = tok;\n            next();\n        struct_field:\n            if ((type->t & VT_BTYPE) != VT_STRUCT)\n                expect(\"struct/union type\");\n            s = type->ref;\n            l |= SYM_FIELD;\n            f = s->next;\n            while (f) {\n                if (f->v == l)\n                    break;\n                f = f->next;\n            }\n            if (!f)\n                expect(\"field\");\n            if (!notfirst)\n                *cur_field = f;\n            /* XXX: fix this mess by using explicit storage field */\n            type1 = f->type;\n            type1.t |= (type->t & ~VT_TYPE);\n            type = &type1;\n            c += f->c;\n        }\n        notfirst = 1;\n    }\n    if (notfirst) {\n        if (tok == '=') {\n            next();\n        } else {\n            if (!gnu_ext)\n                expect(\"=\");\n        }\n    } else {\n        if (type->t & VT_ARRAY) {\n            index = *cur_index;\n            type = pointed_type(type);\n            c += index * type_size(type, &align);\n        } else {\n            f = *cur_field;\n            if (!f)\n                error(\"too many field init\");\n            /* XXX: fix this mess by using explicit storage field */\n            type1 = f->type;\n            type1.t |= (type->t & ~VT_TYPE);\n            type = &type1;\n            c += f->c;\n        }\n    }\n    decl_initializer(type, sec, c, 0, size_only);\n\n    /* XXX: make it more general */\n    if (!size_only && nb_elems > 1) {\n        unsigned long c_end;\n        uint8_t *src, *dst;\n        int i;\n\n        if (!sec)\n            error(\"range init not supported yet for dynamic storage\");\n        c_end = c + nb_elems * elem_size;\n        if (c_end > sec->data_allocated)\n            section_realloc(sec, c_end);\n        src = sec->data + c;\n        dst = src;\n        for(i = 1; i < nb_elems; i++) {\n            dst += elem_size;\n            memcpy(dst, src, elem_size);\n        }\n    }\n}\n\n#define EXPR_VAL   0\n#define EXPR_CONST 1\n#define EXPR_ANY   2\n\n/* store a value or an expression directly in global data or in local array */\nstatic void init_putv(CType *type, Section *sec, unsigned long c, \n                      int v, int expr_type)\n{\n    int saved_global_expr, bt, bit_pos, bit_size;\n    void *ptr;\n    unsigned long long bit_mask;\n    CType dtype;\n\n    switch(expr_type) {\n    case EXPR_VAL:\n        vpushi(v);\n        break;\n    case EXPR_CONST:\n        /* compound literals must be allocated globally in this case */\n        saved_global_expr = global_expr;\n        global_expr = 1;\n        expr_const1();\n        global_expr = saved_global_expr;\n        /* NOTE: symbols are accepted */\n        if ((vtop->r & (VT_VALMASK | VT_LVAL)) != VT_CONST)\n            error(\"initializer element is not constant\");\n        break;\n    case EXPR_ANY:\n        expr_eq();\n        break;\n    }\n    \n    dtype = *type;\n    dtype.t &= ~VT_CONSTANT; /* need to do that to avoid false warning */\n\n    if (sec) {\n        /* XXX: not portable */\n        /* XXX: generate error if incorrect relocation */\n        gen_assign_cast(&dtype);\n        bt = type->t & VT_BTYPE;\n        ptr = sec->data + c;\n        /* XXX: make code faster ? */\n        if (!(type->t & VT_BITFIELD)) {\n            bit_pos = 0;\n            bit_size = 32;\n            bit_mask = -1LL;\n        } else {\n            bit_pos = (vtop->type.t >> VT_STRUCT_SHIFT) & 0x3f;\n            bit_size = (vtop->type.t >> (VT_STRUCT_SHIFT + 6)) & 0x3f;\n            bit_mask = (1LL << bit_size) - 1;\n        }\n        if ((vtop->r & VT_SYM) &&\n            (bt == VT_BYTE ||\n             bt == VT_SHORT ||\n             bt == VT_DOUBLE ||\n             bt == VT_LDOUBLE ||\n             bt == VT_LLONG ||\n             (bt == VT_INT && bit_size != 32)))\n            error(\"initializer element is not computable at load time\");\n        switch(bt) {\n        case VT_BYTE:\n            *(char *)ptr |= (vtop->c.i & bit_mask) << bit_pos;\n            break;\n        case VT_SHORT:\n            *(short *)ptr |= (vtop->c.i & bit_mask) << bit_pos;\n            break;\n        case VT_DOUBLE:\n            *(double *)ptr = vtop->c.d;\n            break;\n        case VT_LDOUBLE:\n            *(long double *)ptr = vtop->c.ld;\n            break;\n        case VT_LLONG:\n            *(long long *)ptr |= (vtop->c.ll & bit_mask) << bit_pos;\n            break;\n        default:\n            if (vtop->r & VT_SYM) {\n                greloc(sec, vtop->sym, c, R_DATA_32);\n            }\n            *(int *)ptr |= (vtop->c.i & bit_mask) << bit_pos;\n            break;\n        }\n        vtop--;\n    } else {\n        vset(&dtype, VT_LOCAL, c);\n        vswap();\n        vstore();\n        vpop();\n    }\n}\n\n/* put zeros for variable based init */\nstatic void init_putz(CType *t, Section *sec, unsigned long c, int size)\n{\n    if (sec) {\n        /* nothing to do because globals are already set to zero */\n    } else {\n        vpush_global_sym(&func_old_type, TOK_memset);\n        vseti(VT_LOCAL, c);\n        vpushi(0);\n        vpushi(size);\n        gfunc_call(3);\n    }\n}\n\n/* 't' contains the type and storage info. 'c' is the offset of the\n   object in section 'sec'. If 'sec' is NULL, it means stack based\n   allocation. 'first' is true if array '{' must be read (multi\n   dimension implicit array init handling). 'size_only' is true if\n   size only evaluation is wanted (only for arrays). */\nstatic void decl_initializer(CType *type, Section *sec, unsigned long c, \n                             int first, int size_only)\n{\n    int index, array_length, n, no_oblock, nb, parlevel, i;\n    int size1, align1, expr_type;\n    Sym *s, *f;\n    CType *t1;\n\n    if (type->t & VT_ARRAY) {\n        s = type->ref;\n        n = s->c;\n        array_length = 0;\n        t1 = pointed_type(type);\n        size1 = type_size(t1, &align1);\n\n        no_oblock = 1;\n        if ((first && tok != TOK_LSTR && tok != TOK_STR) || \n            tok == '{') {\n            skip('{');\n            no_oblock = 0;\n        }\n\n        /* only parse strings here if correct type (otherwise: handle\n           them as ((w)char *) expressions */\n        if ((tok == TOK_LSTR && \n             (t1->t & VT_BTYPE) == VT_INT) ||\n            (tok == TOK_STR &&\n             (t1->t & VT_BTYPE) == VT_BYTE)) {\n            while (tok == TOK_STR || tok == TOK_LSTR) {\n                int cstr_len, ch;\n                CString *cstr;\n\n                cstr = tokc.cstr;\n                /* compute maximum number of chars wanted */\n                if (tok == TOK_STR)\n                    cstr_len = cstr->size;\n                else\n                    cstr_len = cstr->size / sizeof(int);\n                cstr_len--;\n                nb = cstr_len;\n                if (n >= 0 && nb > (n - array_length))\n                    nb = n - array_length;\n                if (!size_only) {\n                    if (cstr_len > nb)\n                        warning(\"initializer-string for array is too long\");\n                    /* in order to go faster for common case (char\n                       string in global variable, we handle it\n                       specifically */\n                    if (sec && tok == TOK_STR && size1 == 1) {\n                        memcpy(sec->data + c + array_length, cstr->data, nb);\n                    } else {\n                        for(i=0;i<nb;i++) {\n                            if (tok == TOK_STR)\n                                ch = ((unsigned char *)cstr->data)[i];\n                            else\n                                ch = ((int *)cstr->data)[i];\n                            init_putv(t1, sec, c + (array_length + i) * size1,\n                                      ch, EXPR_VAL);\n                        }\n                    }\n                }\n                array_length += nb;\n                next();\n            }\n            /* only add trailing zero if enough storage (no\n               warning in this case since it is standard) */\n            if (n < 0 || array_length < n) {\n                if (!size_only) {\n                    init_putv(t1, sec, c + (array_length * size1), 0, EXPR_VAL);\n                }\n                array_length++;\n            }\n        } else {\n            index = 0;\n            while (tok != '}') {\n                decl_designator(type, sec, c, &index, NULL, size_only);\n                if (n >= 0 && index >= n)\n                    error(\"index too large\");\n                /* must put zero in holes (note that doing it that way\n                   ensures that it even works with designators) */\n                if (!size_only && array_length < index) {\n                    init_putz(t1, sec, c + array_length * size1, \n                              (index - array_length) * size1);\n                }\n                index++;\n                if (index > array_length)\n                    array_length = index;\n                /* special test for multi dimensional arrays (may not\n                   be strictly correct if designators are used at the\n                   same time) */\n                if (index >= n && no_oblock)\n                    break;\n                if (tok == '}')\n                    break;\n                skip(',');\n            }\n        }\n        if (!no_oblock)\n            skip('}');\n        /* put zeros at the end */\n        if (!size_only && n >= 0 && array_length < n) {\n            init_putz(t1, sec, c + array_length * size1, \n                      (n - array_length) * size1);\n        }\n        /* patch type size if needed */\n        if (n < 0)\n            s->c = array_length;\n    } else if ((type->t & VT_BTYPE) == VT_STRUCT &&\n               (sec || !first || tok == '{')) {\n        int par_count;\n\n        /* NOTE: the previous test is a specific case for automatic\n           struct/union init */\n        /* XXX: union needs only one init */\n\n        /* XXX: this test is incorrect for local initializers\n           beginning with ( without {. It would be much more difficult\n           to do it correctly (ideally, the expression parser should\n           be used in all cases) */\n        par_count = 0;\n        if (tok == '(') {\n            AttributeDef ad1;\n            CType type1;\n            next();\n            while (tok == '(') {\n                par_count++;\n                next();\n            }\n            if (!parse_btype(&type1, &ad1))\n                expect(\"cast\");\n            type_decl(&type1, &ad1, &n, TYPE_ABSTRACT);\n#if 0\n            if (!is_assignable_types(type, &type1))\n                error(\"invalid type for cast\");\n#endif\n            skip(')');\n        }\n        no_oblock = 1;\n        if (first || tok == '{') {\n            skip('{');\n            no_oblock = 0;\n        }\n        s = type->ref;\n        f = s->next;\n        array_length = 0;\n        index = 0;\n        n = s->c;\n        while (tok != '}') {\n            decl_designator(type, sec, c, NULL, &f, size_only);\n            index = f->c;\n            if (!size_only && array_length < index) {\n                init_putz(type, sec, c + array_length, \n                          index - array_length);\n            }\n            index = index + type_size(&f->type, &align1);\n            if (index > array_length)\n                array_length = index;\n            f = f->next;\n            if (no_oblock && f == NULL)\n                break;\n            if (tok == '}')\n                break;\n            skip(',');\n        }\n        /* put zeros at the end */\n        if (!size_only && array_length < n) {\n            init_putz(type, sec, c + array_length, \n                      n - array_length);\n        }\n        if (!no_oblock)\n            skip('}');\n        while (par_count) {\n            skip(')');\n            par_count--;\n        }\n    } else if (tok == '{') {\n        next();\n        decl_initializer(type, sec, c, first, size_only);\n        skip('}');\n    } else if (size_only) {\n        /* just skip expression */\n        parlevel = 0;\n        while ((parlevel > 0 || (tok != '}' && tok != ',')) && \n               tok != -1) {\n            if (tok == '(')\n                parlevel++;\n            else if (tok == ')')\n                parlevel--;\n            next();\n        }\n    } else {\n        /* currently, we always use constant expression for globals\n           (may change for scripting case) */\n        expr_type = EXPR_CONST;\n        if (!sec)\n            expr_type = EXPR_ANY;\n        init_putv(type, sec, c, 0, expr_type);\n    }\n}\n\n/* parse an initializer for type 't' if 'has_init' is non zero, and\n   allocate space in local or global data space ('r' is either\n   VT_LOCAL or VT_CONST). If 'v' is non zero, then an associated\n   variable 'v' of scope 'scope' is declared before initializers are\n   parsed. If 'v' is zero, then a reference to the new object is put\n   in the value stack. If 'has_init' is 2, a special parsing is done\n   to handle string constants. */\nstatic void decl_initializer_alloc(CType *type, AttributeDef *ad, int r, \n                                   int has_init, int v, int scope)\n{\n    int size, align, addr, data_offset;\n    int level;\n    ParseState saved_parse_state;\n    TokenString init_str;\n    Section *sec;\n\n    size = type_size(type, &align);\n    /* If unknown size, we must evaluate it before\n       evaluating initializers because\n       initializers can generate global data too\n       (e.g. string pointers or ISOC99 compound\n       literals). It also simplifies local\n       initializers handling */\n    tok_str_new(&init_str);\n    if (size < 0) {\n        if (!has_init) \n            error(\"unknown type size\");\n        /* get all init string */\n        if (has_init == 2) {\n            /* only get strings */\n            while (tok == TOK_STR || tok == TOK_LSTR) {\n                tok_str_add_tok(&init_str);\n                next();\n            }\n        } else {\n            level = 0;\n            while (level > 0 || (tok != ',' && tok != ';')) {\n                if (tok < 0)\n                    error(\"unexpected end of file in initializer\");\n                tok_str_add_tok(&init_str);\n                if (tok == '{')\n                    level++;\n                else if (tok == '}') {\n                    if (level == 0)\n                        break;\n                    level--;\n                }\n                next();\n            }\n        }\n        tok_str_add(&init_str, -1);\n        tok_str_add(&init_str, 0);\n        \n        /* compute size */\n        save_parse_state(&saved_parse_state);\n\n        macro_ptr = init_str.str;\n        next();\n        decl_initializer(type, NULL, 0, 1, 1);\n        /* prepare second initializer parsing */\n        macro_ptr = init_str.str;\n        next();\n        \n        /* if still unknown size, error */\n        size = type_size(type, &align);\n        if (size < 0) \n            error(\"unknown type size\");\n    }\n    /* take into account specified alignment if bigger */\n    if (ad->aligned) {\n        if (ad->aligned > align)\n            align = ad->aligned;\n    } else if (ad->packed) {\n        align = 1;\n    }\n    if ((r & VT_VALMASK) == VT_LOCAL) {\n        sec = NULL;\n        if (do_bounds_check && (type->t & VT_ARRAY)) \n            loc--;\n        loc = (loc - size) & -align;\n        addr = loc;\n        /* handles bounds */\n        /* XXX: currently, since we do only one pass, we cannot track\n           '&' operators, so we add only arrays */\n        if (do_bounds_check && (type->t & VT_ARRAY)) {\n            unsigned long *bounds_ptr;\n            /* add padding between regions */\n            loc--;\n            /* then add local bound info */\n            bounds_ptr = section_ptr_add(lbounds_section, 2 * sizeof(unsigned long));\n            bounds_ptr[0] = addr;\n            bounds_ptr[1] = size;\n        }\n        if (v) {\n            /* local variable */\n            sym_push(v, type, r, addr);\n        } else {\n            /* push local reference */\n            vset(type, r, addr);\n        }\n    } else {\n        Sym *sym;\n\n        sym = NULL;\n        if (v && scope == VT_CONST) {\n            /* see if the symbol was already defined */\n            sym = sym_find(v);\n            if (sym) {\n                if (!is_compatible_types(&sym->type, type))\n                    error(\"incompatible types for redefinition of '%s'\", \n                          get_tok_str(v, NULL));\n                if (sym->type.t & VT_EXTERN) {\n                    /* if the variable is extern, it was not allocated */\n                    sym->type.t &= ~VT_EXTERN;\n                    /* set array size if it was ommited in extern\n                       declaration */\n                    if ((sym->type.t & VT_ARRAY) && \n                        sym->type.ref->c < 0 &&\n                        type->ref->c >= 0)\n                        sym->type.ref->c = type->ref->c;\n                } else {\n                    /* we accept several definitions of the same\n                       global variable. this is tricky, because we\n                       must play with the SHN_COMMON type of the symbol */\n                    /* XXX: should check if the variable was already\n                       initialized. It is incorrect to initialized it\n                       twice */\n                    /* no init data, we won't add more to the symbol */\n                    if (!has_init)\n                        goto no_alloc;\n                }\n            }\n        }\n\n        /* allocate symbol in corresponding section */\n        sec = ad->section;\n        if (!sec) {\n            if (has_init)\n                sec = data_section;\n            else if (tcc_state->nocommon)\n                sec = bss_section;\n        }\n        if (sec) {\n            data_offset = sec->data_offset;\n            data_offset = (data_offset + align - 1) & -align;\n            addr = data_offset;\n            /* very important to increment global pointer at this time\n               because initializers themselves can create new initializers */\n            data_offset += size;\n            /* add padding if bound check */\n            if (do_bounds_check)\n                data_offset++;\n            sec->data_offset = data_offset;\n            /* allocate section space to put the data */\n            if (sec->sh_type != SHT_NOBITS && \n                data_offset > sec->data_allocated)\n                section_realloc(sec, data_offset);\n            /* align section if needed */\n            if (align > sec->sh_addralign)\n                sec->sh_addralign = align;\n        } else {\n            addr = 0; /* avoid warning */\n        }\n\n        if (v) {\n            if (scope == VT_CONST) {\n                if (!sym)\n                    goto do_def;\n            } else {\n            do_def:\n                sym = sym_push(v, type, r | VT_SYM, 0);\n            }\n            /* update symbol definition */\n            if (sec) {\n                put_extern_sym(sym, sec, addr, size);\n            } else {\n                Elf32_Sym *esym;\n                /* put a common area */\n                put_extern_sym(sym, NULL, align, size);\n                /* XXX: find a nicer way */\n                esym = &((Elf32_Sym *)symtab_section->data)[sym->c];\n                esym->st_shndx = SHN_COMMON;\n            }\n        } else {\n            CValue cval;\n\n            /* push global reference */\n            sym = get_sym_ref(type, sec, addr, size);\n            cval.ul = 0;\n            vsetc(type, VT_CONST | VT_SYM, &cval);\n            vtop->sym = sym;\n        }\n\n        /* handles bounds now because the symbol must be defined\n           before for the relocation */\n        if (do_bounds_check) {\n            unsigned long *bounds_ptr;\n\n            greloc(bounds_section, sym, bounds_section->data_offset, R_DATA_32);\n            /* then add global bound info */\n            bounds_ptr = section_ptr_add(bounds_section, 2 * sizeof(long));\n            bounds_ptr[0] = 0; /* relocated */\n            bounds_ptr[1] = size;\n        }\n    }\n    if (has_init) {\n        decl_initializer(type, sec, addr, 1, 0);\n        /* restore parse state if needed */\n        if (init_str.str) {\n            tok_str_free(init_str.str);\n            restore_parse_state(&saved_parse_state);\n        }\n    }\n no_alloc: ;\n}\n\nvoid put_func_debug(Sym *sym)\n{\n    char buf[512];\n\n    /* stabs info */\n    /* XXX: we put here a dummy type */\n    snprintf(buf, sizeof(buf), \"%s:%c1\", \n             funcname, sym->type.t & VT_STATIC ? 'f' : 'F');\n    put_stabs_r(buf, N_FUN, 0, file->line_num, 0,\n                cur_text_section, sym->c);\n    last_ind = 0;\n    last_line_num = 0;\n}\n\n/* parse an old style function declaration list */\n/* XXX: check multiple parameter */\nstatic void func_decl_list(Sym *func_sym)\n{\n    AttributeDef ad;\n    int v;\n    Sym *s;\n    CType btype, type;\n\n    /* parse each declaration */\n    while (tok != '{' && tok != ';' && tok != ',' && tok != TOK_EOF) {\n        if (!parse_btype(&btype, &ad)) \n            expect(\"declaration list\");\n        if (((btype.t & VT_BTYPE) == VT_ENUM ||\n             (btype.t & VT_BTYPE) == VT_STRUCT) && \n            tok == ';') {\n            /* we accept no variable after */\n        } else {\n            for(;;) {\n                type = btype;\n                type_decl(&type, &ad, &v, TYPE_DIRECT);\n                /* find parameter in function parameter list */\n                s = func_sym->next;\n                while (s != NULL) {\n                    if ((s->v & ~SYM_FIELD) == v)\n                        goto found;\n                    s = s->next;\n                }\n                error(\"declaration for parameter '%s' but no such parameter\",\n                      get_tok_str(v, NULL));\n            found:\n                /* check that no storage specifier except 'register' was given */\n                if (type.t & VT_STORAGE)\n                    error(\"storage class specified for '%s'\", get_tok_str(v, NULL)); \n                convert_parameter_type(&type);\n                /* we can add the type (NOTE: it could be local to the function) */\n                s->type = type;\n                /* accept other parameters */\n                if (tok == ',')\n                    next();\n                else\n                    break;\n            }\n        }\n        skip(';');\n    }\n}\n\n/* parse a function defined by symbol 'sym' and generate its code in\n   'cur_text_section' */\nstatic void gen_function(Sym *sym)\n{\n    ind = cur_text_section->data_offset;\n    /* NOTE: we patch the symbol size later */\n    put_extern_sym(sym, cur_text_section, ind, 0);\n    funcname = get_tok_str(sym->v, NULL);\n    func_ind = ind;\n    /* put debug symbol */\n    if (do_debug)\n        put_func_debug(sym);\n    /* push a dummy symbol to enable local sym storage */\n    sym_push2(&local_stack, SYM_FIELD, 0, 0);\n    gfunc_prolog(&sym->type);\n    rsym = 0;\n    block(NULL, NULL, NULL, NULL, 0, 0);\n    gsym(rsym);\n    gfunc_epilog();\n    cur_text_section->data_offset = ind;\n    label_pop(&global_label_stack, NULL);\n    sym_pop(&local_stack, NULL); /* reset local stack */\n    /* end of function */\n    /* patch symbol size */\n    ((Elf32_Sym *)symtab_section->data)[sym->c].st_size = \n        ind - func_ind;\n    if (do_debug) {\n        put_stabn(N_FUN, 0, 0, ind - func_ind);\n    }\n    funcname = \"\"; /* for safety */\n    func_vt.t = VT_VOID; /* for safety */\n    ind = 0; /* for safety */\n}\n\nstatic void gen_inline_functions(void)\n{\n    Sym *sym;\n    CType *type;\n    int *str, inline_generated;\n\n    /* iterate while inline function are referenced */\n    for(;;) {\n        inline_generated = 0;\n        for(sym = global_stack; sym != NULL; sym = sym->prev) {\n            type = &sym->type;\n            if (((type->t & VT_BTYPE) == VT_FUNC) &&\n                (type->t & (VT_STATIC | VT_INLINE)) == \n                (VT_STATIC | VT_INLINE) &&\n                sym->c != 0) {\n                /* the function was used: generate its code and\n                   convert it to a normal function */\n                str = (int *)sym->r;\n                sym->r = VT_SYM | VT_CONST;\n                type->t &= ~VT_INLINE;\n\n                macro_ptr = str;\n                next();\n                cur_text_section = text_section;\n                gen_function(sym);\n                macro_ptr = NULL; /* fail safe */\n\n                tok_str_free(str);\n                inline_generated = 1;\n            }\n        }\n        if (!inline_generated)\n            break;\n    }\n\n    /* free all remaining inline function tokens */\n    for(sym = global_stack; sym != NULL; sym = sym->prev) {\n        type = &sym->type;\n        if (((type->t & VT_BTYPE) == VT_FUNC) &&\n            (type->t & (VT_STATIC | VT_INLINE)) == \n            (VT_STATIC | VT_INLINE)) {\n            str = (int *)sym->r;\n            tok_str_free(str);\n            sym->r = 0; /* fail safe */\n        }\n    }\n}\n\n/* 'l' is VT_LOCAL or VT_CONST to define default storage type */\nstatic void decl(int l)\n{\n    int v, has_init, r;\n    CType type, btype;\n    Sym *sym;\n    AttributeDef ad;\n    \n    while (1) {\n        if (!parse_btype(&btype, &ad)) {\n            /* skip redundant ';' */\n            /* XXX: find more elegant solution */\n            if (tok == ';') {\n                next();\n                continue;\n            }\n            if (l == VT_CONST &&\n                (tok == TOK_ASM1 || tok == TOK_ASM2 || tok == TOK_ASM3)) {\n                /* global asm block */\n                asm_global_instr();\n                continue;\n            }\n            /* special test for old K&R protos without explicit int\n               type. Only accepted when defining global data */\n            if (l == VT_LOCAL || tok < TOK_DEFINE)\n                break;\n            btype.t = VT_INT;\n        }\n        if (((btype.t & VT_BTYPE) == VT_ENUM ||\n             (btype.t & VT_BTYPE) == VT_STRUCT) && \n            tok == ';') {\n            /* we accept no variable after */\n            next();\n            continue;\n        }\n        while (1) { /* iterate thru each declaration */\n            type = btype;\n            type_decl(&type, &ad, &v, TYPE_DIRECT);\n#if 0\n            {\n                char buf[500];\n                type_to_str(buf, sizeof(buf), t, get_tok_str(v, NULL));\n                printf(\"type = '%s'\\n\", buf);\n            }\n#endif\n            if ((type.t & VT_BTYPE) == VT_FUNC) {\n                /* if old style function prototype, we accept a\n                   declaration list */\n                sym = type.ref;\n                if (sym->c == FUNC_OLD)\n                    func_decl_list(sym);\n            }\n\n            if (tok == '{') {\n                if (l == VT_LOCAL)\n                    error(\"cannot use local functions\");\n                if (!(type.t & VT_FUNC))\n                    expect(\"function definition\");\n\n                /* reject abstract declarators in function definition */\n                sym = type.ref;\n                while ((sym = sym->next) != NULL)\n                    if (!(sym->v & ~SYM_FIELD))\n                       expect(\"identifier\");\n                \n                /* XXX: cannot do better now: convert extern line to static inline */\n                if ((type.t & (VT_EXTERN | VT_INLINE)) == (VT_EXTERN | VT_INLINE))\n                    type.t = (type.t & ~VT_EXTERN) | VT_STATIC;\n                \n                sym = sym_find(v);\n                if (sym) {\n                    if ((sym->type.t & VT_BTYPE) != VT_FUNC)\n                        goto func_error1;\n                    /* specific case: if not func_call defined, we put\n                       the one of the prototype */\n                    /* XXX: should have default value */\n                    if (sym->type.ref->r != FUNC_CDECL &&\n                        type.ref->r == FUNC_CDECL)\n                        type.ref->r = sym->type.ref->r;\n                    if (!is_compatible_types(&sym->type, &type)) {\n                    func_error1:\n                        error(\"incompatible types for redefinition of '%s'\", \n                              get_tok_str(v, NULL));\n                    }\n                    /* if symbol is already defined, then put complete type */\n                    sym->type = type;\n                } else {\n                    /* put function symbol */\n                    sym = global_identifier_push(v, type.t, 0);\n                    sym->type.ref = type.ref;\n                }\n\n                /* static inline functions are just recorded as a kind\n                   of macro. Their code will be emitted at the end of\n                   the compilation unit only if they are used */\n                if ((type.t & (VT_INLINE | VT_STATIC)) == \n                    (VT_INLINE | VT_STATIC)) {\n                    TokenString func_str;\n                    int block_level;\n                           \n                    tok_str_new(&func_str);\n                    \n                    block_level = 0;\n                    for(;;) {\n                        int t;\n                        if (tok == TOK_EOF)\n                            error(\"unexpected end of file\");\n                        tok_str_add_tok(&func_str);\n                        t = tok;\n                        next();\n                        if (t == '{') {\n                            block_level++;\n                        } else if (t == '}') {\n                            block_level--;\n                            if (block_level == 0)\n                                break;\n                        }\n                    }\n                    tok_str_add(&func_str, -1);\n                    tok_str_add(&func_str, 0);\n                    sym->r = (long)func_str.str;\n                } else {\n                    /* compute text section */\n                    cur_text_section = ad.section;\n                    if (!cur_text_section)\n                        cur_text_section = text_section;\n                    sym->r = VT_SYM | VT_CONST;\n                    gen_function(sym);\n#ifdef TCC_TARGET_PE\n                    if (ad.dllexport) {\n                        ((Elf32_Sym *)symtab_section->data)[sym->c].st_other |= 1;\n                    }\n#endif\n                }\n                break;\n            } else {\n                if (btype.t & VT_TYPEDEF) {\n                    /* save typedefed type  */\n                    /* XXX: test storage specifiers ? */\n                    sym = sym_push(v, &type, 0, 0);\n                    sym->type.t |= VT_TYPEDEF;\n                } else if ((type.t & VT_BTYPE) == VT_FUNC) {\n                    /* external function definition */\n                    /* specific case for func_call attribute */\n                    if (ad.func_call)\n                        type.ref->r = ad.func_call;\n                    external_sym(v, &type, 0);\n                } else {\n                    /* not lvalue if array */\n                    r = 0;\n                    if (!(type.t & VT_ARRAY))\n                        r |= lvalue_type(type.t);\n                    has_init = (tok == '=');\n                    if ((btype.t & VT_EXTERN) || \n                        ((type.t & VT_ARRAY) && (type.t & VT_STATIC) &&\n                         !has_init && l == VT_CONST && type.ref->c < 0)) {\n                        /* external variable */\n                        /* NOTE: as GCC, uninitialized global static\n                           arrays of null size are considered as\n                           extern */\n                        external_sym(v, &type, r);\n                    } else {\n                        if (type.t & VT_STATIC)\n                            r |= VT_CONST;\n                        else\n                            r |= l;\n                        if (has_init)\n                            next();\n                        decl_initializer_alloc(&type, &ad, r, \n                                               has_init, v, l);\n                    }\n                }\n                if (tok != ',') {\n                    skip(';');\n                    break;\n                }\n                next();\n            }\n        }\n    }\n}\n\n/* better than nothing, but needs extension to handle '-E' option\n   correctly too */\nstatic void preprocess_init(TCCState *s1)\n{\n    s1->include_stack_ptr = s1->include_stack;\n    /* XXX: move that before to avoid having to initialize\n       file->ifdef_stack_ptr ? */\n    s1->ifdef_stack_ptr = s1->ifdef_stack;\n    file->ifdef_stack_ptr = s1->ifdef_stack_ptr;\n\n    /* XXX: not ANSI compliant: bound checking says error */\n    vtop = vstack - 1;\n    s1->pack_stack[0] = 0;\n    s1->pack_stack_ptr = s1->pack_stack;\n}\n\n/* compile the C file opened in 'file'. Return non zero if errors. */\nstatic int tcc_compile(TCCState *s1)\n{\n    Sym *define_start;\n    char buf[512];\n    volatile int section_sym;\n\n#ifdef INC_DEBUG\n    printf(\"%s: **** new file\\n\", file->filename);\n#endif\n    preprocess_init(s1);\n\n    funcname = \"\";\n    anon_sym = SYM_FIRST_ANOM; \n\n    /* file info: full path + filename */\n    section_sym = 0; /* avoid warning */\n    if (do_debug) {\n        section_sym = put_elf_sym(symtab_section, 0, 0, \n                                  ELF32_ST_INFO(STB_LOCAL, STT_SECTION), 0, \n                                  text_section->sh_num, NULL);\n        dummy_char_star = getcwd(buf, sizeof(buf));\n        pstrcat(buf, sizeof(buf), \"/\");\n        put_stabs_r(buf, N_SO, 0, 0, \n                    text_section->data_offset, text_section, section_sym);\n        put_stabs_r(file->filename, N_SO, 0, 0, \n                    text_section->data_offset, text_section, section_sym);\n    }\n    /* an elf symbol of type STT_FILE must be put so that STB_LOCAL\n       symbols can be safely used */\n    put_elf_sym(symtab_section, 0, 0, \n                ELF32_ST_INFO(STB_LOCAL, STT_FILE), 0, \n                SHN_ABS, file->filename);\n\n    /* define some often used types */\n    int_type.t = VT_INT;\n\n    char_pointer_type.t = VT_BYTE;\n    mk_pointer(&char_pointer_type);\n\n    func_old_type.t = VT_FUNC;\n    func_old_type.ref = sym_push(SYM_FIELD, &int_type, FUNC_CDECL, FUNC_OLD);\n\n#if 0\n    /* define 'void *alloca(unsigned int)' builtin function */\n    {\n        Sym *s1;\n\n        p = anon_sym++;\n        sym = sym_push(p, mk_pointer(VT_VOID), FUNC_CDECL, FUNC_NEW);\n        s1 = sym_push(SYM_FIELD, VT_UNSIGNED | VT_INT, 0, 0);\n        s1->next = NULL;\n        sym->next = s1;\n        sym_push(TOK_alloca, VT_FUNC | (p << VT_STRUCT_SHIFT), VT_CONST, 0);\n    }\n#endif\n\n    define_start = define_stack;\n\n    if (setjmp(s1->error_jmp_buf) == 0) {\n        s1->nb_errors = 0;\n        s1->error_set_jmp_enabled = 1;\n\n        ch = file->buf_ptr[0];\n        tok_flags = TOK_FLAG_BOL | TOK_FLAG_BOF;\n        parse_flags = PARSE_FLAG_PREPROCESS | PARSE_FLAG_TOK_NUM;\n        next();\n        decl(VT_CONST);\n        if (tok != TOK_EOF)\n            expect(\"declaration\");\n\n        /* end of translation unit info */\n        if (do_debug) {\n            put_stabs_r(NULL, N_SO, 0, 0, \n                        text_section->data_offset, text_section, section_sym);\n        }\n    }\n    s1->error_set_jmp_enabled = 0;\n\n    /* reset define stack, but leave -Dsymbols (may be incorrect if\n       they are undefined) */\n    free_defines(define_start); \n\n    gen_inline_functions();\n\n    sym_pop(&global_stack, NULL);\n\n    return s1->nb_errors != 0 ? -1 : 0;\n}\n\n#ifdef LIBTCC\nint tcc_compile_string(TCCState *s, const char *str)\n{\n    BufferedFile bf1, *bf = &bf1;\n    int ret, len;\n    char *buf;\n\n    /* init file structure */\n    bf->fd = -1;\n    /* XXX: avoid copying */\n    len = strlen(str);\n    buf = tcc_malloc(len + 1);\n    if (!buf)\n        return -1;\n    memcpy(buf, str, len);\n    buf[len] = CH_EOB;\n    bf->buf_ptr = buf;\n    bf->buf_end = buf + len;\n    pstrcpy(bf->filename, sizeof(bf->filename), \"<string>\");\n    bf->line_num = 1;\n    file = bf;\n    \n    ret = tcc_compile(s);\n    \n    tcc_free(buf);\n\n    /* currently, no need to close */\n    return ret;\n}\n#endif\n\n/* define a preprocessor symbol. A value can also be provided with the '=' operator */\nvoid tcc_define_symbol(TCCState *s1, const char *sym, const char *value)\n{\n    BufferedFile bf1, *bf = &bf1;\n\n    pstrcpy(bf->buffer, IO_BUF_SIZE, sym);\n    pstrcat(bf->buffer, IO_BUF_SIZE, \" \");\n    /* default value */\n    if (!value) \n        value = \"1\";\n    pstrcat(bf->buffer, IO_BUF_SIZE, value);\n    \n    /* init file structure */\n    bf->fd = -1;\n    bf->buf_ptr = bf->buffer;\n    bf->buf_end = bf->buffer + strlen(bf->buffer);\n    *bf->buf_end = CH_EOB;\n    bf->filename[0] = '\\0';\n    bf->line_num = 1;\n    file = bf;\n    \n    s1->include_stack_ptr = s1->include_stack;\n\n    /* parse with define parser */\n    ch = file->buf_ptr[0];\n    next_nomacro();\n    parse_define();\n    file = NULL;\n}\n\n/* undefine a preprocessor symbol */\nvoid tcc_undefine_symbol(TCCState *s1, const char *sym)\n{\n    TokenSym *ts;\n    Sym *s;\n    ts = tok_alloc(sym, strlen(sym));\n    s = define_find(ts->tok);\n    /* undefine symbol by putting an invalid name */\n    if (s)\n        define_undef(s);\n}\n\n#ifdef CONFIG_TCC_ASM\n\n#ifdef TCC_TARGET_I386\n// njn: inlined i386-asm.c\n//#include \"i386-asm.c\"\n//---------------------------------------------------------------------------\n/*\n *  i386 specific functions for TCC assembler\n * \n *  Copyright (c) 2001, 2002 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#define MAX_OPERANDS 3\n\ntypedef struct ASMInstr {\n    uint16_t sym;\n    uint16_t opcode;\n    uint16_t instr_type;\n#define OPC_JMP       0x01  /* jmp operand */\n#define OPC_B         0x02  /* only used zith OPC_WL */\n#define OPC_WL        0x04  /* accepts w, l or no suffix */\n#define OPC_BWL       (OPC_B | OPC_WL) /* accepts b, w, l or no suffix */\n#define OPC_REG       0x08 /* register is added to opcode */\n#define OPC_MODRM     0x10 /* modrm encoding */\n#define OPC_FWAIT     0x20 /* add fwait opcode */\n#define OPC_TEST      0x40 /* test opcodes */\n#define OPC_SHIFT     0x80 /* shift opcodes */\n#define OPC_D16      0x0100 /* generate data16 prefix */\n#define OPC_ARITH    0x0200 /* arithmetic opcodes */\n#define OPC_SHORTJMP 0x0400 /* short jmp operand */\n#define OPC_FARITH   0x0800 /* FPU arithmetic opcodes */\n#define OPC_GROUP_SHIFT 13\n\n/* in order to compress the operand type, we use specific operands and\n   we or only with EA  */ \n#define OPT_REG8  0 /* warning: value is hardcoded from TOK_ASM_xxx */\n#define OPT_REG16 1 /* warning: value is hardcoded from TOK_ASM_xxx */\n#define OPT_REG32 2 /* warning: value is hardcoded from TOK_ASM_xxx */\n#define OPT_MMX   3 /* warning: value is hardcoded from TOK_ASM_xxx */\n#define OPT_SSE   4 /* warning: value is hardcoded from TOK_ASM_xxx */\n#define OPT_CR    5 /* warning: value is hardcoded from TOK_ASM_xxx */\n#define OPT_TR    6 /* warning: value is hardcoded from TOK_ASM_xxx */\n#define OPT_DB    7 /* warning: value is hardcoded from TOK_ASM_xxx */\n#define OPT_SEG   8\n#define OPT_ST    9\n#define OPT_IM8   10\n#define OPT_IM8S  11\n#define OPT_IM16  12\n#define OPT_IM32  13\n#define OPT_EAX   14 /* %al, %ax or %eax register */\n#define OPT_ST0   15 /* %st(0) register */\n#define OPT_CL    16 /* %cl register */\n#define OPT_DX    17 /* %dx register */\n#define OPT_ADDR  18 /* OP_EA with only offset */\n#define OPT_INDIR 19 /* *(expr) */\n\n/* composite types */ \n#define OPT_COMPOSITE_FIRST   20\n#define OPT_IM       20 /* IM8 | IM16 | IM32 */\n#define OPT_REG      21 /* REG8 | REG16 | REG32 */ \n#define OPT_REGW     22 /* REG16 | REG32 */\n#define OPT_IMW      23 /* IM16 | IM32 */ \n\n/* can be ored with any OPT_xxx */\n#define OPT_EA    0x80\n\n    uint8_t nb_ops;\n    uint8_t op_type[MAX_OPERANDS]; /* see OP_xxx */\n} ASMInstr;\n\ntypedef struct Operand {\n    uint32_t type;\n#define OP_REG8   (1 << OPT_REG8)\n#define OP_REG16  (1 << OPT_REG16)\n#define OP_REG32  (1 << OPT_REG32)\n#define OP_MMX    (1 << OPT_MMX)\n#define OP_SSE    (1 << OPT_SSE)\n#define OP_CR     (1 << OPT_CR)\n#define OP_TR     (1 << OPT_TR)\n#define OP_DB     (1 << OPT_DB)\n#define OP_SEG    (1 << OPT_SEG)\n#define OP_ST     (1 << OPT_ST)\n#define OP_IM8    (1 << OPT_IM8)\n#define OP_IM8S   (1 << OPT_IM8S)\n#define OP_IM16   (1 << OPT_IM16)\n#define OP_IM32   (1 << OPT_IM32)\n#define OP_EAX    (1 << OPT_EAX)\n#define OP_ST0    (1 << OPT_ST0)\n#define OP_CL     (1 << OPT_CL)\n#define OP_DX     (1 << OPT_DX)\n#define OP_ADDR   (1 << OPT_ADDR)\n#define OP_INDIR  (1 << OPT_INDIR)\n\n#define OP_EA     0x40000000\n#define OP_REG    (OP_REG8 | OP_REG16 | OP_REG32)\n#define OP_IM     OP_IM32\n    int8_t  reg; /* register, -1 if none */\n    int8_t  reg2; /* second register, -1 if none */\n    uint8_t shift;\n    ExprValue e;\n} Operand;\n\nstatic const uint8_t reg_to_size[5] = {\n    [OP_REG8] = 0,\n    [OP_REG16] = 1,\n    [OP_REG32] = 2,\n};\n    \n#define WORD_PREFIX_OPCODE 0x66\n\n#define NB_TEST_OPCODES 30\n\nstatic const uint8_t test_bits[NB_TEST_OPCODES] = {\n 0x00, /* o */\n 0x01, /* no */\n 0x02, /* b */\n 0x02, /* c */\n 0x02, /* nae */\n 0x03, /* nb */\n 0x03, /* nc */\n 0x03, /* ae */\n 0x04, /* e */\n 0x04, /* z */\n 0x05, /* ne */\n 0x05, /* nz */\n 0x06, /* be */\n 0x06, /* na */\n 0x07, /* nbe */\n 0x07, /* a */\n 0x08, /* s */\n 0x09, /* ns */\n 0x0a, /* p */\n 0x0a, /* pe */\n 0x0b, /* np */\n 0x0b, /* po */\n 0x0c, /* l */\n 0x0c, /* nge */\n 0x0d, /* nl */\n 0x0d, /* ge */\n 0x0e, /* le */\n 0x0e, /* ng */\n 0x0f, /* nle */\n 0x0f, /* g */\n};\n\nstatic const ASMInstr asm_instrs[] = {\n#define ALT(x) x\n#define DEF_ASM_OP0(name, opcode)\n#define DEF_ASM_OP0L(name, opcode, group, instr_type) { TOK_ASM_ ## name, opcode, (instr_type | group << OPC_GROUP_SHIFT), 0 },\n#define DEF_ASM_OP1(name, opcode, group, instr_type, op0) { TOK_ASM_ ## name, opcode, (instr_type | group << OPC_GROUP_SHIFT), 1, { op0 }},\n#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1) { TOK_ASM_ ## name, opcode, (instr_type | group << OPC_GROUP_SHIFT), 2, { op0, op1 }},\n#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2) { TOK_ASM_ ## name, opcode, (instr_type | group << OPC_GROUP_SHIFT), 3, { op0, op1, op2 }},\n// njn: inlined i386-asm.h\n//#include \"i386-asm.h\"\n//---------------------------------------------------------------------------\n     DEF_ASM_OP0(pusha, 0x60) /* must be first OP0 */\n     DEF_ASM_OP0(popa, 0x61)\n     DEF_ASM_OP0(clc, 0xf8)\n     DEF_ASM_OP0(cld, 0xfc)\n     DEF_ASM_OP0(cli, 0xfa)\n     DEF_ASM_OP0(clts, 0x0f06)\n     DEF_ASM_OP0(cmc, 0xf5)\n     DEF_ASM_OP0(lahf, 0x9f)\n     DEF_ASM_OP0(sahf, 0x9e)\n     DEF_ASM_OP0(pushfl, 0x9c)\n     DEF_ASM_OP0(popfl, 0x9d)\n     DEF_ASM_OP0(pushf, 0x9c)\n     DEF_ASM_OP0(popf, 0x9d)\n     DEF_ASM_OP0(stc, 0xf9)\n     DEF_ASM_OP0(std, 0xfd)\n     DEF_ASM_OP0(sti, 0xfb)\n     DEF_ASM_OP0(aaa, 0x37)\n     DEF_ASM_OP0(aas, 0x3f)\n     DEF_ASM_OP0(daa, 0x27)\n     DEF_ASM_OP0(das, 0x2f)\n     DEF_ASM_OP0(aad, 0xd50a)\n     DEF_ASM_OP0(aam, 0xd40a)\n     DEF_ASM_OP0(cbw, 0x6698)\n     DEF_ASM_OP0(cwd, 0x6699)\n     DEF_ASM_OP0(cwde, 0x98)\n     DEF_ASM_OP0(cdq, 0x99)\n     DEF_ASM_OP0(cbtw, 0x6698)\n     DEF_ASM_OP0(cwtl, 0x98)\n     DEF_ASM_OP0(cwtd, 0x6699)\n     DEF_ASM_OP0(cltd, 0x99)\n     DEF_ASM_OP0(int3, 0xcc)\n     DEF_ASM_OP0(into, 0xce)\n     DEF_ASM_OP0(iret, 0xcf)\n     DEF_ASM_OP0(rsm, 0x0faa)\n     DEF_ASM_OP0(hlt, 0xf4)\n     DEF_ASM_OP0(wait, 0x9b)\n     DEF_ASM_OP0(nop, 0x90)\n     DEF_ASM_OP0(xlat, 0xd7)\n\n     /* strings */\nALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(insb, 0x6c, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(outsb, 0x6e, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(lodsb, 0xac, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(slodb, 0xac, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(movsb, 0xa4, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(smovb, 0xa4, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(scasb, 0xae, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sscab, 0xae, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(stosb, 0xaa, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sstob, 0xaa, 0, OPC_BWL))\n\n     /* bits */\n     \nALT(DEF_ASM_OP2(bsfw, 0x0fbc, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(bsrw, 0x0fbd, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\n\nALT(DEF_ASM_OP2(btw, 0x0fa3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btw, 0x0fba, 4, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btsw, 0x0fab, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btsw, 0x0fba, 5, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btrw, 0x0fb3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btrw, 0x0fba, 6, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btcw, 0x0fbb, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btcw, 0x0fba, 7, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\n     /* prefixes */\n     DEF_ASM_OP0(aword, 0x67)\n     DEF_ASM_OP0(addr16, 0x67)\n     DEF_ASM_OP0(word, 0x66)\n     DEF_ASM_OP0(data16, 0x66)\n     DEF_ASM_OP0(lock, 0xf0)\n     DEF_ASM_OP0(rep, 0xf3)\n     DEF_ASM_OP0(repe, 0xf3)\n     DEF_ASM_OP0(repz, 0xf3)\n     DEF_ASM_OP0(repne, 0xf2)\n     DEF_ASM_OP0(repnz, 0xf2)\n             \n     DEF_ASM_OP0(invd, 0x0f08)\n     DEF_ASM_OP0(wbinvd, 0x0f09)\n     DEF_ASM_OP0(cpuid, 0x0fa2)\n     DEF_ASM_OP0(wrmsr, 0x0f30)\n     DEF_ASM_OP0(rdtsc, 0x0f31)\n     DEF_ASM_OP0(rdmsr, 0x0f32)\n     DEF_ASM_OP0(rdpmc, 0x0f33)\n     DEF_ASM_OP0(ud2, 0x0f0b)\n\n     /* NOTE: we took the same order as gas opcode definition order */\nALT(DEF_ASM_OP2(movb, 0xa0, 0, OPC_BWL, OPT_ADDR, OPT_EAX))\nALT(DEF_ASM_OP2(movb, 0xa2, 0, OPC_BWL, OPT_EAX, OPT_ADDR))\nALT(DEF_ASM_OP2(movb, 0x88, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movb, 0x8a, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xb0, 0, OPC_REG | OPC_BWL, OPT_IM, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xc6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(movw, 0x8c, 0, OPC_MODRM | OPC_WL, OPT_SEG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movw, 0x8e, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_SEG))\n\nALT(DEF_ASM_OP2(movw, 0x0f20, 0, OPC_MODRM | OPC_WL, OPT_CR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f21, 0, OPC_MODRM | OPC_WL, OPT_DB, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f24, 0, OPC_MODRM | OPC_WL, OPT_TR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f22, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_CR))\nALT(DEF_ASM_OP2(movw, 0x0f23, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_DB))\nALT(DEF_ASM_OP2(movw, 0x0f26, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_TR))\n\nALT(DEF_ASM_OP2(movsbl, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movsbw, 0x0fbe, 0, OPC_MODRM | OPC_D16, OPT_REG8 | OPT_EA, OPT_REG16))\nALT(DEF_ASM_OP2(movswl, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movzbw, 0x0fb6, 0, OPC_MODRM | OPC_WL, OPT_REG8 | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(movzwl, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\n\nALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(pushw, 0xff, 6, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(pushw, 0x6a, 0, OPC_WL, OPT_IM8S))\nALT(DEF_ASM_OP1(pushw, 0x68, 0, OPC_WL, OPT_IM32))\nALT(DEF_ASM_OP1(pushw, 0x06, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(popw, 0x8f, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(popw, 0x07, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_REG, OPT_EAX))\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_EAX, OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\n\nALT(DEF_ASM_OP2(inb, 0xe4, 0, OPC_BWL, OPT_IM8, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xe4, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(inb, 0xec, 0, OPC_BWL, OPT_DX, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xec, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(outb, 0xe6, 0, OPC_BWL, OPT_EAX, OPT_IM8))\nALT(DEF_ASM_OP1(outb, 0xe6, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(outb, 0xee, 0, OPC_BWL, OPT_EAX, OPT_DX))\nALT(DEF_ASM_OP1(outb, 0xee, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(leaw, 0x8d, 0, OPC_MODRM | OPC_WL, OPT_EA, OPT_REG))\n\nALT(DEF_ASM_OP2(les, 0xc4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lds, 0xc5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lss, 0x0fb2, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lfs, 0x0fb4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lgs, 0x0fb5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\n\n     /* arith */\nALT(DEF_ASM_OP2(addb, 0x00, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG)) /* XXX: use D bit ? */\nALT(DEF_ASM_OP2(addb, 0x02, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(addb, 0x04, 0, OPC_ARITH | OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(addb, 0x80, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(addw, 0x83, 0, OPC_ARITH | OPC_MODRM | OPC_WL, OPT_IM8S, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(testb, 0xa8, 0, OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(testb, 0xf6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP1(incw, 0x40, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(incb, 0xfe, 0, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(decw, 0x48, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(decb, 0xfe, 1, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(notb, 0xf6, 2, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(negb, 0xf6, 3, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(mulb, 0xf6, 4, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(imulb, 0xf6, 5, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(imulw, 0x0faf, 0, OPC_MODRM | OPC_WL, OPT_REG | OPT_EA, OPT_REG))\nALT(DEF_ASM_OP3(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW))\nALT(DEF_ASM_OP3(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW))\n\nALT(DEF_ASM_OP1(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\nALT(DEF_ASM_OP1(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\n\n     /* shifts */\nALT(DEF_ASM_OP2(rolb, 0xc0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_IM8, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(rolb, 0xd2, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_CL, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP1(rolb, 0xd0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP3(shldw, 0x0fa4, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fac, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\n\nALT(DEF_ASM_OP1(call, 0xff, 2, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(call, 0xe8, 0, OPC_JMP, OPT_ADDR))\nALT(DEF_ASM_OP1(jmp, 0xff, 4, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(jmp, 0xeb, 0, OPC_SHORTJMP | OPC_JMP, OPT_ADDR))\n\nALT(DEF_ASM_OP2(lcall, 0x9a, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(lcall, 0xff, 3, 0, OPT_EA))\nALT(DEF_ASM_OP2(ljmp, 0xea, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(ljmp, 0xff, 5, 0, OPT_EA))\n\nALT(DEF_ASM_OP1(int, 0xcd, 0, 0, OPT_IM8))\nALT(DEF_ASM_OP1(seto, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))\n    DEF_ASM_OP2(enter, 0xc8, 0, 0, OPT_IM16, OPT_IM8)\n    DEF_ASM_OP0(leave, 0xc9)\n    DEF_ASM_OP0(ret, 0xc3)\nALT(DEF_ASM_OP1(ret, 0xc2, 0, 0, OPT_IM16))\n    DEF_ASM_OP0(lret, 0xcb)\nALT(DEF_ASM_OP1(lret, 0xca, 0, 0, OPT_IM16))\n\nALT(DEF_ASM_OP1(jo, 0x70, 0, OPC_SHORTJMP | OPC_JMP | OPC_TEST, OPT_ADDR))\n    DEF_ASM_OP1(loopne, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopnz, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loope, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopz, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loop, 0xe2, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(jecxz, 0xe3, 0, OPC_SHORTJMP, OPT_ADDR)\n     \n     /* float */\n     /* specific fcomp handling */\nALT(DEF_ASM_OP0L(fcomp, 0xd8d9, 0, 0))\n\nALT(DEF_ASM_OP1(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP0L(fadd, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP0L(faddp, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(fadds, 0xd8, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiaddl, 0xda, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(faddl, 0xdc, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiadds, 0xde, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\n\n     DEF_ASM_OP0(fucompp, 0xdae9)\n     DEF_ASM_OP0(ftst, 0xd9e4)\n     DEF_ASM_OP0(fxam, 0xd9e5)\n     DEF_ASM_OP0(fld1, 0xd9e8)\n     DEF_ASM_OP0(fldl2t, 0xd9e9)\n     DEF_ASM_OP0(fldl2e, 0xd9ea)\n     DEF_ASM_OP0(fldpi, 0xd9eb)\n     DEF_ASM_OP0(fldlg2, 0xd9ec)\n     DEF_ASM_OP0(fldln2, 0xd9ed)\n     DEF_ASM_OP0(fldz, 0xd9ee)\n\n     DEF_ASM_OP0(f2xm1, 0xd9f0)\n     DEF_ASM_OP0(fyl2x, 0xd9f1)\n     DEF_ASM_OP0(fptan, 0xd9f2)\n     DEF_ASM_OP0(fpatan, 0xd9f3)\n     DEF_ASM_OP0(fxtract, 0xd9f4)\n     DEF_ASM_OP0(fprem1, 0xd9f5)\n     DEF_ASM_OP0(fdecstp, 0xd9f6)\n     DEF_ASM_OP0(fincstp, 0xd9f7)\n     DEF_ASM_OP0(fprem, 0xd9f8)\n     DEF_ASM_OP0(fyl2xp1, 0xd9f9)\n     DEF_ASM_OP0(fsqrt, 0xd9fa)\n     DEF_ASM_OP0(fsincos, 0xd9fb)\n     DEF_ASM_OP0(frndint, 0xd9fc)\n     DEF_ASM_OP0(fscale, 0xd9fd)\n     DEF_ASM_OP0(fsin, 0xd9fe)\n     DEF_ASM_OP0(fcos, 0xd9ff)\n     DEF_ASM_OP0(fchs, 0xd9e0)\n     DEF_ASM_OP0(fabs, 0xd9e1)\n     DEF_ASM_OP0(fninit, 0xdbe3)\n     DEF_ASM_OP0(fnclex, 0xdbe2)\n     DEF_ASM_OP0(fnop, 0xd9d0)\n     DEF_ASM_OP0(fwait, 0x9b)\n\n    /* fp load */\n    DEF_ASM_OP1(fld, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fldl, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(flds, 0xd9, 0, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fldl, 0xdd, 0, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fildl, 0xdb, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildq, 0xdf, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildll, 0xdf, 5, OPC_MODRM,OPT_EA)\n    DEF_ASM_OP1(fldt, 0xdb, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbld, 0xdf, 4, OPC_MODRM, OPT_EA)\n    \n    /* fp store */\n    DEF_ASM_OP1(fst, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fstl, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fsts, 0xd9, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstps, 0xd9, 3, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fstl, 0xdd, 2, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fstpl, 0xdd, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fist, 0xdf, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistp, 0xdf, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistl, 0xdb, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpl, 0xdb, 3, OPC_MODRM, OPT_EA)\n\n    DEF_ASM_OP1(fstp, 0xddd8, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fistpq, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpll, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstpt, 0xdb, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbstp, 0xdf, 6, OPC_MODRM, OPT_EA)\n\n    /* exchange */\n    DEF_ASM_OP0(fxch, 0xd9c9)\nALT(DEF_ASM_OP1(fxch, 0xd9c8, 0, OPC_REG, OPT_ST))\n\n    /* misc FPU */\n    DEF_ASM_OP1(fucom, 0xdde0, 0, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fucomp, 0xdde8, 0, OPC_REG, OPT_ST )\n\n    DEF_ASM_OP0L(finit, 0xdbe3, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fldcw, 0xd9, 5, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnstcw, 0xd9, 7, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstcw, 0xd9, 7, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP0(fnstsw, 0xdfe0)\nALT(DEF_ASM_OP1(fnstsw, 0xdfe0, 0, 0, OPT_EAX ))\nALT(DEF_ASM_OP1(fnstsw, 0xdd, 7, OPC_MODRM, OPT_EA ))\n    DEF_ASM_OP1(fstsw, 0xdfe0, 0, OPC_FWAIT, OPT_EAX )\nALT(DEF_ASM_OP0L(fstsw, 0xdfe0, 0, OPC_FWAIT))\nALT(DEF_ASM_OP1(fstsw, 0xdd, 7, OPC_MODRM | OPC_FWAIT, OPT_EA ))\n    DEF_ASM_OP0L(fclex, 0xdbe2, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fnstenv, 0xd9, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstenv, 0xd9, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(fldenv, 0xd9, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnsave, 0xdd, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fsave, 0xdd, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(frstor, 0xdd, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(ffree, 0xddc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(ffreep, 0xdfc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fxsave, 0x0fae, 0, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fxrstor, 0x0fae, 1, OPC_MODRM, OPT_EA )\n\n    /* segments */\n    DEF_ASM_OP2(arpl, 0x63, 0, OPC_MODRM, OPT_REG16, OPT_REG16 | OPT_EA)\n    DEF_ASM_OP2(lar, 0x0f02, 0, OPC_MODRM, OPT_REG32 | OPT_EA, OPT_REG32)\n    DEF_ASM_OP1(lgdt, 0x0f01, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lidt, 0x0f01, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lldt, 0x0f00, 2, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(lmsw, 0x0f01, 6, OPC_MODRM, OPT_EA | OPT_REG)\nALT(DEF_ASM_OP2(lslw, 0x0f03, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_REG))\n    DEF_ASM_OP1(ltr, 0x0f00, 3, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(sgdt, 0x0f01, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sidt, 0x0f01, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sldt, 0x0f00, 0, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(smsw, 0x0f01, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM, OPT_REG16| OPT_EA)\n    DEF_ASM_OP1(verr, 0x0f00, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(verw, 0x0f00, 5, OPC_MODRM, OPT_REG | OPT_EA)\n\n    /* 486 */\n    DEF_ASM_OP1(bswap, 0x0fc8, 0, OPC_REG, OPT_REG32 )\nALT(DEF_ASM_OP2(xaddb, 0x0fc0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\nALT(DEF_ASM_OP2(cmpxchgb, 0x0fb0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\n    DEF_ASM_OP1(invlpg, 0x0f01, 7, OPC_MODRM, OPT_EA )\n\n    DEF_ASM_OP2(boundl, 0x62, 0, OPC_MODRM, OPT_REG32, OPT_EA)\n    DEF_ASM_OP2(boundw, 0x62, 0, OPC_MODRM | OPC_D16, OPT_REG16, OPT_EA)\n\n    /* pentium */\n    DEF_ASM_OP1(cmpxchg8b, 0x0fc7, 1, OPC_MODRM, OPT_EA )\n    \n    /* pentium pro */\n    ALT(DEF_ASM_OP2(cmovo, 0x0f40, 0, OPC_MODRM | OPC_TEST, OPT_REG32 | OPT_EA, OPT_REG32))\n\n    DEF_ASM_OP2(fcmovb, 0xdac0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmove, 0xdac8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovbe, 0xdad0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovu, 0xdad8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnb, 0xdbc0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovne, 0xdbc8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnbe, 0xdbd0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnu, 0xdbd8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    DEF_ASM_OP2(fucomi, 0xdbe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomi, 0xdbf0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fucomip, 0xdfe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomip, 0xdff0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    /* mmx */\n    DEF_ASM_OP0(emms, 0x0f77) /* must be last OP0 */\n    DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_MMX )\nALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(movq, 0x0f6f, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(movq, 0x0f7f, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_MMX ))\n    DEF_ASM_OP2(packssdw, 0x0f6b, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packsswb, 0x0f63, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packuswb, 0x0f67, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddb, 0x0ffc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddw, 0x0ffd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddd, 0x0ffe, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsb, 0x0fec, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsw, 0x0fed, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusb, 0x0fdc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusw, 0x0fdd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pand, 0x0fdb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pandn, 0x0fdf, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqb, 0x0f74, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqw, 0x0f75, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqd, 0x0f76, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtb, 0x0f64, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtw, 0x0f65, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtd, 0x0f66, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmaddwd, 0x0ff5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmulhw, 0x0fe5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmullw, 0x0fd5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(por, 0x0feb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psllw, 0x0ff1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllw, 0x0f71, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(pslld, 0x0ff2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(pslld, 0x0f72, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psllq, 0x0ff3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllq, 0x0f73, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psraw, 0x0fe1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psraw, 0x0f71, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrad, 0x0fe2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrad, 0x0f72, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlw, 0x0fd1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlw, 0x0f71, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrld, 0x0fd2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrld, 0x0f72, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlq, 0x0fd3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlq, 0x0f73, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psubb, 0x0ff8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubw, 0x0ff9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubd, 0x0ffa, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsb, 0x0fe8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsw, 0x0fe9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusb, 0x0fd8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusw, 0x0fd9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhbw, 0x0f68, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhwd, 0x0f69, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhdq, 0x0f6a, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklbw, 0x0f60, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklwd, 0x0f61, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckldq, 0x0f62, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pxor, 0x0fef, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n\n#undef ALT\n#undef DEF_ASM_OP0\n#undef DEF_ASM_OP0L\n#undef DEF_ASM_OP1\n#undef DEF_ASM_OP2\n#undef DEF_ASM_OP3\n//---------------------------------------------------------------------------\n\n    /* last operation */\n    { 0, },\n};\n\nstatic const uint16_t op0_codes[] = {\n#define ALT(x)\n#define DEF_ASM_OP0(x, opcode) opcode,\n#define DEF_ASM_OP0L(name, opcode, group, instr_type)\n#define DEF_ASM_OP1(name, opcode, group, instr_type, op0)\n#define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1)\n#define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2)\n// njn: inlined i386-asm.h\n//#include \"i386-asm.h\"\n//---------------------------------------------------------------------------\n     DEF_ASM_OP0(pusha, 0x60) /* must be first OP0 */\n     DEF_ASM_OP0(popa, 0x61)\n     DEF_ASM_OP0(clc, 0xf8)\n     DEF_ASM_OP0(cld, 0xfc)\n     DEF_ASM_OP0(cli, 0xfa)\n     DEF_ASM_OP0(clts, 0x0f06)\n     DEF_ASM_OP0(cmc, 0xf5)\n     DEF_ASM_OP0(lahf, 0x9f)\n     DEF_ASM_OP0(sahf, 0x9e)\n     DEF_ASM_OP0(pushfl, 0x9c)\n     DEF_ASM_OP0(popfl, 0x9d)\n     DEF_ASM_OP0(pushf, 0x9c)\n     DEF_ASM_OP0(popf, 0x9d)\n     DEF_ASM_OP0(stc, 0xf9)\n     DEF_ASM_OP0(std, 0xfd)\n     DEF_ASM_OP0(sti, 0xfb)\n     DEF_ASM_OP0(aaa, 0x37)\n     DEF_ASM_OP0(aas, 0x3f)\n     DEF_ASM_OP0(daa, 0x27)\n     DEF_ASM_OP0(das, 0x2f)\n     DEF_ASM_OP0(aad, 0xd50a)\n     DEF_ASM_OP0(aam, 0xd40a)\n     DEF_ASM_OP0(cbw, 0x6698)\n     DEF_ASM_OP0(cwd, 0x6699)\n     DEF_ASM_OP0(cwde, 0x98)\n     DEF_ASM_OP0(cdq, 0x99)\n     DEF_ASM_OP0(cbtw, 0x6698)\n     DEF_ASM_OP0(cwtl, 0x98)\n     DEF_ASM_OP0(cwtd, 0x6699)\n     DEF_ASM_OP0(cltd, 0x99)\n     DEF_ASM_OP0(int3, 0xcc)\n     DEF_ASM_OP0(into, 0xce)\n     DEF_ASM_OP0(iret, 0xcf)\n     DEF_ASM_OP0(rsm, 0x0faa)\n     DEF_ASM_OP0(hlt, 0xf4)\n     DEF_ASM_OP0(wait, 0x9b)\n     DEF_ASM_OP0(nop, 0x90)\n     DEF_ASM_OP0(xlat, 0xd7)\n\n     /* strings */\nALT(DEF_ASM_OP0L(cmpsb, 0xa6, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(scmpb, 0xa6, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(insb, 0x6c, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(outsb, 0x6e, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(lodsb, 0xac, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(slodb, 0xac, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(movsb, 0xa4, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(smovb, 0xa4, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(scasb, 0xae, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sscab, 0xae, 0, OPC_BWL))\n\nALT(DEF_ASM_OP0L(stosb, 0xaa, 0, OPC_BWL))\nALT(DEF_ASM_OP0L(sstob, 0xaa, 0, OPC_BWL))\n\n     /* bits */\n     \nALT(DEF_ASM_OP2(bsfw, 0x0fbc, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(bsrw, 0x0fbd, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA, OPT_REGW))\n\nALT(DEF_ASM_OP2(btw, 0x0fa3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btw, 0x0fba, 4, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btsw, 0x0fab, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btsw, 0x0fba, 5, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btrw, 0x0fb3, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btrw, 0x0fba, 6, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\nALT(DEF_ASM_OP2(btcw, 0x0fbb, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP2(btcw, 0x0fba, 7, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW | OPT_EA))\n\n     /* prefixes */\n     DEF_ASM_OP0(aword, 0x67)\n     DEF_ASM_OP0(addr16, 0x67)\n     DEF_ASM_OP0(word, 0x66)\n     DEF_ASM_OP0(data16, 0x66)\n     DEF_ASM_OP0(lock, 0xf0)\n     DEF_ASM_OP0(rep, 0xf3)\n     DEF_ASM_OP0(repe, 0xf3)\n     DEF_ASM_OP0(repz, 0xf3)\n     DEF_ASM_OP0(repne, 0xf2)\n     DEF_ASM_OP0(repnz, 0xf2)\n             \n     DEF_ASM_OP0(invd, 0x0f08)\n     DEF_ASM_OP0(wbinvd, 0x0f09)\n     DEF_ASM_OP0(cpuid, 0x0fa2)\n     DEF_ASM_OP0(wrmsr, 0x0f30)\n     DEF_ASM_OP0(rdtsc, 0x0f31)\n     DEF_ASM_OP0(rdmsr, 0x0f32)\n     DEF_ASM_OP0(rdpmc, 0x0f33)\n     DEF_ASM_OP0(ud2, 0x0f0b)\n\n     /* NOTE: we took the same order as gas opcode definition order */\nALT(DEF_ASM_OP2(movb, 0xa0, 0, OPC_BWL, OPT_ADDR, OPT_EAX))\nALT(DEF_ASM_OP2(movb, 0xa2, 0, OPC_BWL, OPT_EAX, OPT_ADDR))\nALT(DEF_ASM_OP2(movb, 0x88, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movb, 0x8a, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xb0, 0, OPC_REG | OPC_BWL, OPT_IM, OPT_REG))\nALT(DEF_ASM_OP2(movb, 0xc6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(movw, 0x8c, 0, OPC_MODRM | OPC_WL, OPT_SEG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(movw, 0x8e, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_SEG))\n\nALT(DEF_ASM_OP2(movw, 0x0f20, 0, OPC_MODRM | OPC_WL, OPT_CR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f21, 0, OPC_MODRM | OPC_WL, OPT_DB, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f24, 0, OPC_MODRM | OPC_WL, OPT_TR, OPT_REG32))\nALT(DEF_ASM_OP2(movw, 0x0f22, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_CR))\nALT(DEF_ASM_OP2(movw, 0x0f23, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_DB))\nALT(DEF_ASM_OP2(movw, 0x0f26, 0, OPC_MODRM | OPC_WL, OPT_REG32, OPT_TR))\n\nALT(DEF_ASM_OP2(movsbl, 0x0fbe, 0, OPC_MODRM, OPT_REG8 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movsbw, 0x0fbe, 0, OPC_MODRM | OPC_D16, OPT_REG8 | OPT_EA, OPT_REG16))\nALT(DEF_ASM_OP2(movswl, 0x0fbf, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(movzbw, 0x0fb6, 0, OPC_MODRM | OPC_WL, OPT_REG8 | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(movzwl, 0x0fb7, 0, OPC_MODRM, OPT_REG16 | OPT_EA, OPT_REG32))\n\nALT(DEF_ASM_OP1(pushw, 0x50, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(pushw, 0xff, 6, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(pushw, 0x6a, 0, OPC_WL, OPT_IM8S))\nALT(DEF_ASM_OP1(pushw, 0x68, 0, OPC_WL, OPT_IM32))\nALT(DEF_ASM_OP1(pushw, 0x06, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP1(popw, 0x58, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(popw, 0x8f, 0, OPC_MODRM | OPC_WL, OPT_REGW | OPT_EA))\nALT(DEF_ASM_OP1(popw, 0x07, 0, OPC_WL, OPT_SEG))\n\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_REG, OPT_EAX))\nALT(DEF_ASM_OP2(xchgw, 0x90, 0, OPC_REG | OPC_WL, OPT_EAX, OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(xchgb, 0x86, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\n\nALT(DEF_ASM_OP2(inb, 0xe4, 0, OPC_BWL, OPT_IM8, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xe4, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(inb, 0xec, 0, OPC_BWL, OPT_DX, OPT_EAX))\nALT(DEF_ASM_OP1(inb, 0xec, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(outb, 0xe6, 0, OPC_BWL, OPT_EAX, OPT_IM8))\nALT(DEF_ASM_OP1(outb, 0xe6, 0, OPC_BWL, OPT_IM8))\nALT(DEF_ASM_OP2(outb, 0xee, 0, OPC_BWL, OPT_EAX, OPT_DX))\nALT(DEF_ASM_OP1(outb, 0xee, 0, OPC_BWL, OPT_DX))\n\nALT(DEF_ASM_OP2(leaw, 0x8d, 0, OPC_MODRM | OPC_WL, OPT_EA, OPT_REG))\n\nALT(DEF_ASM_OP2(les, 0xc4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lds, 0xc5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lss, 0x0fb2, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lfs, 0x0fb4, 0, OPC_MODRM, OPT_EA, OPT_REG32))\nALT(DEF_ASM_OP2(lgs, 0x0fb5, 0, OPC_MODRM, OPT_EA, OPT_REG32))\n\n     /* arith */\nALT(DEF_ASM_OP2(addb, 0x00, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG)) /* XXX: use D bit ? */\nALT(DEF_ASM_OP2(addb, 0x02, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(addb, 0x04, 0, OPC_ARITH | OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(addb, 0x80, 0, OPC_ARITH | OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(addw, 0x83, 0, OPC_ARITH | OPC_MODRM | OPC_WL, OPT_IM8S, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_EA | OPT_REG, OPT_REG))\nALT(DEF_ASM_OP2(testb, 0x84, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(testb, 0xa8, 0, OPC_BWL, OPT_IM, OPT_EAX))\nALT(DEF_ASM_OP2(testb, 0xf6, 0, OPC_MODRM | OPC_BWL, OPT_IM, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP1(incw, 0x40, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(incb, 0xfe, 0, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(decw, 0x48, 0, OPC_REG | OPC_WL, OPT_REGW))\nALT(DEF_ASM_OP1(decb, 0xfe, 1, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(notb, 0xf6, 2, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(negb, 0xf6, 3, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP1(mulb, 0xf6, 4, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP1(imulb, 0xf6, 5, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\n\nALT(DEF_ASM_OP2(imulw, 0x0faf, 0, OPC_MODRM | OPC_WL, OPT_REG | OPT_EA, OPT_REG))\nALT(DEF_ASM_OP3(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x6b, 0, OPC_MODRM | OPC_WL, OPT_IM8S, OPT_REGW))\nALT(DEF_ASM_OP3(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW | OPT_EA, OPT_REGW))\nALT(DEF_ASM_OP2(imulw, 0x69, 0, OPC_MODRM | OPC_WL, OPT_IMW, OPT_REGW))\n\nALT(DEF_ASM_OP1(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(divb, 0xf6, 6, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\nALT(DEF_ASM_OP1(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA))\nALT(DEF_ASM_OP2(idivb, 0xf6, 7, OPC_MODRM | OPC_BWL, OPT_REG | OPT_EA, OPT_EAX))\n\n     /* shifts */\nALT(DEF_ASM_OP2(rolb, 0xc0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_IM8, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP2(rolb, 0xd2, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_CL, OPT_EA | OPT_REG))\nALT(DEF_ASM_OP1(rolb, 0xd0, 0, OPC_MODRM | OPC_BWL | OPC_SHIFT, OPT_EA | OPT_REG))\n\nALT(DEF_ASM_OP3(shldw, 0x0fa4, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shldw, 0x0fa5, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fac, 0, OPC_MODRM | OPC_WL, OPT_IM8, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP3(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_CL, OPT_REGW, OPT_EA | OPT_REGW))\nALT(DEF_ASM_OP2(shrdw, 0x0fad, 0, OPC_MODRM | OPC_WL, OPT_REGW, OPT_EA | OPT_REGW))\n\nALT(DEF_ASM_OP1(call, 0xff, 2, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(call, 0xe8, 0, OPC_JMP, OPT_ADDR))\nALT(DEF_ASM_OP1(jmp, 0xff, 4, OPC_MODRM, OPT_INDIR))\nALT(DEF_ASM_OP1(jmp, 0xeb, 0, OPC_SHORTJMP | OPC_JMP, OPT_ADDR))\n\nALT(DEF_ASM_OP2(lcall, 0x9a, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(lcall, 0xff, 3, 0, OPT_EA))\nALT(DEF_ASM_OP2(ljmp, 0xea, 0, 0, OPT_IM16, OPT_IM32))\nALT(DEF_ASM_OP1(ljmp, 0xff, 5, 0, OPT_EA))\n\nALT(DEF_ASM_OP1(int, 0xcd, 0, 0, OPT_IM8))\nALT(DEF_ASM_OP1(seto, 0x0f90, 0, OPC_MODRM | OPC_TEST, OPT_REG8 | OPT_EA))\n    DEF_ASM_OP2(enter, 0xc8, 0, 0, OPT_IM16, OPT_IM8)\n    DEF_ASM_OP0(leave, 0xc9)\n    DEF_ASM_OP0(ret, 0xc3)\nALT(DEF_ASM_OP1(ret, 0xc2, 0, 0, OPT_IM16))\n    DEF_ASM_OP0(lret, 0xcb)\nALT(DEF_ASM_OP1(lret, 0xca, 0, 0, OPT_IM16))\n\nALT(DEF_ASM_OP1(jo, 0x70, 0, OPC_SHORTJMP | OPC_JMP | OPC_TEST, OPT_ADDR))\n    DEF_ASM_OP1(loopne, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopnz, 0xe0, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loope, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loopz, 0xe1, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(loop, 0xe2, 0, OPC_SHORTJMP, OPT_ADDR)\n    DEF_ASM_OP1(jecxz, 0xe3, 0, OPC_SHORTJMP, OPT_ADDR)\n     \n     /* float */\n     /* specific fcomp handling */\nALT(DEF_ASM_OP0L(fcomp, 0xd8d9, 0, 0))\n\nALT(DEF_ASM_OP1(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(fadd, 0xd8c0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP0L(fadd, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST, OPT_ST0))\nALT(DEF_ASM_OP2(faddp, 0xdec0, 0, OPC_FARITH | OPC_REG, OPT_ST0, OPT_ST))\nALT(DEF_ASM_OP0L(faddp, 0xdec1, 0, OPC_FARITH))\nALT(DEF_ASM_OP1(fadds, 0xd8, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiaddl, 0xda, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(faddl, 0xdc, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\nALT(DEF_ASM_OP1(fiadds, 0xde, 0, OPC_FARITH | OPC_MODRM, OPT_EA))\n\n     DEF_ASM_OP0(fucompp, 0xdae9)\n     DEF_ASM_OP0(ftst, 0xd9e4)\n     DEF_ASM_OP0(fxam, 0xd9e5)\n     DEF_ASM_OP0(fld1, 0xd9e8)\n     DEF_ASM_OP0(fldl2t, 0xd9e9)\n     DEF_ASM_OP0(fldl2e, 0xd9ea)\n     DEF_ASM_OP0(fldpi, 0xd9eb)\n     DEF_ASM_OP0(fldlg2, 0xd9ec)\n     DEF_ASM_OP0(fldln2, 0xd9ed)\n     DEF_ASM_OP0(fldz, 0xd9ee)\n\n     DEF_ASM_OP0(f2xm1, 0xd9f0)\n     DEF_ASM_OP0(fyl2x, 0xd9f1)\n     DEF_ASM_OP0(fptan, 0xd9f2)\n     DEF_ASM_OP0(fpatan, 0xd9f3)\n     DEF_ASM_OP0(fxtract, 0xd9f4)\n     DEF_ASM_OP0(fprem1, 0xd9f5)\n     DEF_ASM_OP0(fdecstp, 0xd9f6)\n     DEF_ASM_OP0(fincstp, 0xd9f7)\n     DEF_ASM_OP0(fprem, 0xd9f8)\n     DEF_ASM_OP0(fyl2xp1, 0xd9f9)\n     DEF_ASM_OP0(fsqrt, 0xd9fa)\n     DEF_ASM_OP0(fsincos, 0xd9fb)\n     DEF_ASM_OP0(frndint, 0xd9fc)\n     DEF_ASM_OP0(fscale, 0xd9fd)\n     DEF_ASM_OP0(fsin, 0xd9fe)\n     DEF_ASM_OP0(fcos, 0xd9ff)\n     DEF_ASM_OP0(fchs, 0xd9e0)\n     DEF_ASM_OP0(fabs, 0xd9e1)\n     DEF_ASM_OP0(fninit, 0xdbe3)\n     DEF_ASM_OP0(fnclex, 0xdbe2)\n     DEF_ASM_OP0(fnop, 0xd9d0)\n     DEF_ASM_OP0(fwait, 0x9b)\n\n    /* fp load */\n    DEF_ASM_OP1(fld, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fldl, 0xd9c0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(flds, 0xd9, 0, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fldl, 0xdd, 0, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fildl, 0xdb, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildq, 0xdf, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fildll, 0xdf, 5, OPC_MODRM,OPT_EA)\n    DEF_ASM_OP1(fldt, 0xdb, 5, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbld, 0xdf, 4, OPC_MODRM, OPT_EA)\n    \n    /* fp store */\n    DEF_ASM_OP1(fst, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fstl, 0xddd0, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fsts, 0xd9, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstps, 0xd9, 3, OPC_MODRM, OPT_EA)\nALT(DEF_ASM_OP1(fstl, 0xdd, 2, OPC_MODRM, OPT_EA))\n    DEF_ASM_OP1(fstpl, 0xdd, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fist, 0xdf, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistp, 0xdf, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistl, 0xdb, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpl, 0xdb, 3, OPC_MODRM, OPT_EA)\n\n    DEF_ASM_OP1(fstp, 0xddd8, 0, OPC_REG, OPT_ST)\n    DEF_ASM_OP1(fistpq, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fistpll, 0xdf, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fstpt, 0xdb, 7, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(fbstp, 0xdf, 6, OPC_MODRM, OPT_EA)\n\n    /* exchange */\n    DEF_ASM_OP0(fxch, 0xd9c9)\nALT(DEF_ASM_OP1(fxch, 0xd9c8, 0, OPC_REG, OPT_ST))\n\n    /* misc FPU */\n    DEF_ASM_OP1(fucom, 0xdde0, 0, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fucomp, 0xdde8, 0, OPC_REG, OPT_ST )\n\n    DEF_ASM_OP0L(finit, 0xdbe3, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fldcw, 0xd9, 5, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnstcw, 0xd9, 7, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstcw, 0xd9, 7, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP0(fnstsw, 0xdfe0)\nALT(DEF_ASM_OP1(fnstsw, 0xdfe0, 0, 0, OPT_EAX ))\nALT(DEF_ASM_OP1(fnstsw, 0xdd, 7, OPC_MODRM, OPT_EA ))\n    DEF_ASM_OP1(fstsw, 0xdfe0, 0, OPC_FWAIT, OPT_EAX )\nALT(DEF_ASM_OP0L(fstsw, 0xdfe0, 0, OPC_FWAIT))\nALT(DEF_ASM_OP1(fstsw, 0xdd, 7, OPC_MODRM | OPC_FWAIT, OPT_EA ))\n    DEF_ASM_OP0L(fclex, 0xdbe2, 0, OPC_FWAIT)\n    DEF_ASM_OP1(fnstenv, 0xd9, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fstenv, 0xd9, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(fldenv, 0xd9, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fnsave, 0xdd, 6, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fsave, 0xdd, 6, OPC_MODRM | OPC_FWAIT, OPT_EA )\n    DEF_ASM_OP1(frstor, 0xdd, 4, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(ffree, 0xddc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(ffreep, 0xdfc0, 4, OPC_REG, OPT_ST )\n    DEF_ASM_OP1(fxsave, 0x0fae, 0, OPC_MODRM, OPT_EA )\n    DEF_ASM_OP1(fxrstor, 0x0fae, 1, OPC_MODRM, OPT_EA )\n\n    /* segments */\n    DEF_ASM_OP2(arpl, 0x63, 0, OPC_MODRM, OPT_REG16, OPT_REG16 | OPT_EA)\n    DEF_ASM_OP2(lar, 0x0f02, 0, OPC_MODRM, OPT_REG32 | OPT_EA, OPT_REG32)\n    DEF_ASM_OP1(lgdt, 0x0f01, 2, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lidt, 0x0f01, 3, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(lldt, 0x0f00, 2, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(lmsw, 0x0f01, 6, OPC_MODRM, OPT_EA | OPT_REG)\nALT(DEF_ASM_OP2(lslw, 0x0f03, 0, OPC_MODRM | OPC_WL, OPT_EA | OPT_REG, OPT_REG))\n    DEF_ASM_OP1(ltr, 0x0f00, 3, OPC_MODRM, OPT_EA | OPT_REG)\n    DEF_ASM_OP1(sgdt, 0x0f01, 0, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sidt, 0x0f01, 1, OPC_MODRM, OPT_EA)\n    DEF_ASM_OP1(sldt, 0x0f00, 0, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(smsw, 0x0f01, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(str, 0x0f00, 1, OPC_MODRM, OPT_REG16| OPT_EA)\n    DEF_ASM_OP1(verr, 0x0f00, 4, OPC_MODRM, OPT_REG | OPT_EA)\n    DEF_ASM_OP1(verw, 0x0f00, 5, OPC_MODRM, OPT_REG | OPT_EA)\n\n    /* 486 */\n    DEF_ASM_OP1(bswap, 0x0fc8, 0, OPC_REG, OPT_REG32 )\nALT(DEF_ASM_OP2(xaddb, 0x0fc0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\nALT(DEF_ASM_OP2(cmpxchgb, 0x0fb0, 0, OPC_MODRM | OPC_BWL, OPT_REG, OPT_REG | OPT_EA ))\n    DEF_ASM_OP1(invlpg, 0x0f01, 7, OPC_MODRM, OPT_EA )\n\n    DEF_ASM_OP2(boundl, 0x62, 0, OPC_MODRM, OPT_REG32, OPT_EA)\n    DEF_ASM_OP2(boundw, 0x62, 0, OPC_MODRM | OPC_D16, OPT_REG16, OPT_EA)\n\n    /* pentium */\n    DEF_ASM_OP1(cmpxchg8b, 0x0fc7, 1, OPC_MODRM, OPT_EA )\n    \n    /* pentium pro */\n    ALT(DEF_ASM_OP2(cmovo, 0x0f40, 0, OPC_MODRM | OPC_TEST, OPT_REG32 | OPT_EA, OPT_REG32))\n\n    DEF_ASM_OP2(fcmovb, 0xdac0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmove, 0xdac8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovbe, 0xdad0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovu, 0xdad8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnb, 0xdbc0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovne, 0xdbc8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnbe, 0xdbd0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcmovnu, 0xdbd8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    DEF_ASM_OP2(fucomi, 0xdbe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomi, 0xdbf0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fucomip, 0xdfe8, 0, OPC_REG, OPT_ST, OPT_ST0 )\n    DEF_ASM_OP2(fcomip, 0xdff0, 0, OPC_REG, OPT_ST, OPT_ST0 )\n\n    /* mmx */\n    DEF_ASM_OP0(emms, 0x0f77) /* must be last OP0 */\n    DEF_ASM_OP2(movd, 0x0f6e, 0, OPC_MODRM, OPT_EA | OPT_REG32, OPT_MMX )\nALT(DEF_ASM_OP2(movd, 0x0f7e, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_REG32 ))\n    DEF_ASM_OP2(movq, 0x0f6f, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(movq, 0x0f7f, 0, OPC_MODRM, OPT_MMX, OPT_EA | OPT_MMX ))\n    DEF_ASM_OP2(packssdw, 0x0f6b, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packsswb, 0x0f63, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(packuswb, 0x0f67, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddb, 0x0ffc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddw, 0x0ffd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddd, 0x0ffe, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsb, 0x0fec, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddsw, 0x0fed, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusb, 0x0fdc, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(paddusw, 0x0fdd, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pand, 0x0fdb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pandn, 0x0fdf, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqb, 0x0f74, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqw, 0x0f75, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpeqd, 0x0f76, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtb, 0x0f64, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtw, 0x0f65, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pcmpgtd, 0x0f66, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmaddwd, 0x0ff5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmulhw, 0x0fe5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pmullw, 0x0fd5, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(por, 0x0feb, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psllw, 0x0ff1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllw, 0x0f71, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(pslld, 0x0ff2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(pslld, 0x0f72, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psllq, 0x0ff3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psllq, 0x0f73, 6, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psraw, 0x0fe1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psraw, 0x0f71, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrad, 0x0fe2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrad, 0x0f72, 4, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlw, 0x0fd1, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlw, 0x0f71, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrld, 0x0fd2, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrld, 0x0f72, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psrlq, 0x0fd3, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\nALT(DEF_ASM_OP2(psrlq, 0x0f73, 2, OPC_MODRM, OPT_IM8, OPT_MMX ))\n    DEF_ASM_OP2(psubb, 0x0ff8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubw, 0x0ff9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubd, 0x0ffa, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsb, 0x0fe8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubsw, 0x0fe9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusb, 0x0fd8, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(psubusw, 0x0fd9, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhbw, 0x0f68, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhwd, 0x0f69, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckhdq, 0x0f6a, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklbw, 0x0f60, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpcklwd, 0x0f61, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(punpckldq, 0x0f62, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n    DEF_ASM_OP2(pxor, 0x0fef, 0, OPC_MODRM, OPT_EA | OPT_MMX, OPT_MMX )\n\n#undef ALT\n#undef DEF_ASM_OP0\n#undef DEF_ASM_OP0L\n#undef DEF_ASM_OP1\n#undef DEF_ASM_OP2\n#undef DEF_ASM_OP3\n//---------------------------------------------------------------------------\n};\n\nstatic inline int get_reg_shift(TCCState *s1)\n{\n    int shift, v;\n\n    v = asm_int_expr(s1);\n    switch(v) {\n    case 1:\n        shift = 0;\n        break;\n    case 2:\n        shift = 1;\n        break;\n    case 4:\n        shift = 2;\n        break;\n    case 8:\n        shift = 3;\n        break;\n    default:\n        expect(\"1, 2, 4 or 8 constant\");\n        shift = 0;\n        break;\n    }\n    return shift;\n}\n\nstatic int asm_parse_reg(void)\n{\n    int reg;\n    if (tok != '%')\n        goto error_32;\n    next();\n    if (tok >= TOK_ASM_eax && tok <= TOK_ASM_edi) {\n        reg = tok - TOK_ASM_eax;\n        next();\n        return reg;\n    } else {\n    error_32:\n        expect(\"32 bit register\");\n        return 0;\n    }\n}\n\nstatic void parse_operand(TCCState *s1, Operand *op)\n{\n    ExprValue e;\n    int reg, indir;\n    const char *p;\n\n    indir = 0;\n    if (tok == '*') {\n        next();\n        indir = OP_INDIR;\n    }\n\n    if (tok == '%') {\n        next();\n        if (tok >= TOK_ASM_al && tok <= TOK_ASM_db7) {\n            reg = tok - TOK_ASM_al;\n            op->type = 1 << (reg >> 3); /* WARNING: do not change constant order */\n            op->reg = reg & 7;\n            if ((op->type & OP_REG) && op->reg == TREG_EAX)\n                op->type |= OP_EAX;\n            else if (op->type == OP_REG8 && op->reg == TREG_ECX)\n                op->type |= OP_CL;\n            else if (op->type == OP_REG16 && op->reg == TREG_EDX)\n                op->type |= OP_DX;\n        } else if (tok >= TOK_ASM_dr0 && tok <= TOK_ASM_dr7) {\n            op->type = OP_DB;\n            op->reg = tok - TOK_ASM_dr0;\n        } else if (tok >= TOK_ASM_es && tok <= TOK_ASM_gs) {\n            op->type = OP_SEG;\n            op->reg = tok - TOK_ASM_es;\n        } else if (tok == TOK_ASM_st) {\n            op->type = OP_ST;\n            op->reg = 0;\n            next();\n            if (tok == '(') {\n                next();\n                if (tok != TOK_PPNUM)\n                    goto reg_error;\n                p = tokc.cstr->data;\n                reg = p[0] - '0';\n                if ((unsigned)reg >= 8 || p[1] != '\\0')\n                    goto reg_error;\n                op->reg = reg;\n                next();\n                skip(')');\n            }\n            if (op->reg == 0)\n                op->type |= OP_ST0;\n            goto no_skip;\n        } else {\n        reg_error:\n            error(\"unknown register\");\n        }\n        next();\n    no_skip: ;\n    } else if (tok == '$') {\n        /* constant value */\n        next();\n        asm_expr(s1, &e);\n        op->type = OP_IM32;\n        op->e.v = e.v;\n        op->e.sym = e.sym;\n        if (!op->e.sym) {\n            if (op->e.v == (uint8_t)op->e.v)\n                op->type |= OP_IM8;\n            if (op->e.v == (int8_t)op->e.v)\n                op->type |= OP_IM8S;\n            if (op->e.v == (uint16_t)op->e.v)\n                op->type |= OP_IM16;\n        }\n    } else {\n        /* address(reg,reg2,shift) with all variants */\n        op->type = OP_EA;\n        op->reg = -1;\n        op->reg2 = -1;\n        op->shift = 0;\n        if (tok != '(') {\n            asm_expr(s1, &e);\n            op->e.v = e.v;\n            op->e.sym = e.sym;\n        } else {\n            op->e.v = 0;\n            op->e.sym = NULL;\n        }\n        if (tok == '(') {\n            next();\n            if (tok != ',') {\n                op->reg = asm_parse_reg();\n            }\n            if (tok == ',') {\n                next();\n                if (tok != ',') {\n                    op->reg2 = asm_parse_reg();\n                } \n                skip(',');\n                op->shift = get_reg_shift(s1);\n            }\n            skip(')');\n        }\n        if (op->reg == -1 && op->reg2 == -1)\n            op->type |= OP_ADDR;\n    }\n    op->type |= indir;\n}\n\n/* XXX: unify with C code output ? */\nstatic void gen_expr32(ExprValue *pe)\n{\n    if (pe->sym)\n        greloc(cur_text_section, pe->sym, ind, R_386_32);\n    gen_le32(pe->v);\n}\n\n/* XXX: unify with C code output ? */\nstatic void gen_disp32(ExprValue *pe)\n{\n    Sym *sym;\n    sym = pe->sym;\n    if (sym) {\n        if (sym->r == cur_text_section->sh_num) {\n            /* same section: we can output an absolute value. Note\n               that the TCC compiler behaves differently here because\n               it always outputs a relocation to ease (future) code\n               elimination in the linker */\n            gen_le32(pe->v + (long)sym->next - ind - 4);\n        } else {\n            greloc(cur_text_section, sym, ind, R_386_PC32);\n            gen_le32(pe->v - 4);\n        }\n    } else {\n        /* put an empty PC32 relocation */\n        put_elf_reloc(symtab_section, cur_text_section, \n                      ind, R_386_PC32, 0);\n        gen_le32(pe->v - 4);\n    }\n}\n\n\nstatic void gen_le16(int v)\n{\n    g(v);\n    g(v >> 8);\n}\n\n/* generate the modrm operand */\nstatic inline void asm_modrm(int reg, Operand *op)\n{\n    int mod, reg1, reg2, sib_reg1;\n\n    if (op->type & (OP_REG | OP_MMX | OP_SSE)) {\n        g(0xc0 + (reg << 3) + op->reg);\n    } else if (op->reg == -1 && op->reg2 == -1) {\n        /* displacement only */\n        g(0x05 + (reg << 3));\n        gen_expr32(&op->e);\n    } else {\n        sib_reg1 = op->reg;\n        /* fist compute displacement encoding */\n        if (sib_reg1 == -1) {\n            sib_reg1 = 5;\n            mod = 0x00;\n        } else if (op->e.v == 0 && !op->e.sym && op->reg != 5) {\n            mod = 0x00;\n        } else if (op->e.v == (int8_t)op->e.v && !op->e.sym) {\n            mod = 0x40;\n        } else {\n            mod = 0x80;\n        }\n        /* compute if sib byte needed */\n        reg1 = op->reg;\n        if (op->reg2 != -1)\n            reg1 = 4;\n        g(mod + (reg << 3) + reg1);\n        if (reg1 == 4) {\n            /* add sib byte */\n            reg2 = op->reg2;\n            if (reg2 == -1)\n                reg2 = 4; /* indicate no index */\n            g((op->shift << 6) + (reg2 << 3) + sib_reg1);\n        }\n\n        /* add offset */\n        if (mod == 0x40) {\n            g(op->e.v);\n        } else if (mod == 0x80 || op->reg == -1) {\n            gen_expr32(&op->e);\n        }\n    }\n}\n\nstatic void asm_opcode(TCCState *s1, int opcode)\n{\n    const ASMInstr *pa;\n    int i, modrm_index, reg, v, op1, is_short_jmp;\n    int nb_ops, s, ss;\n    Operand ops[MAX_OPERANDS], *pop;\n    int op_type[3]; /* decoded op type */\n\n    /* get operands */\n    pop = ops;\n    nb_ops = 0;\n    for(;;) {\n        if (tok == ';' || tok == TOK_LINEFEED)\n            break;\n        if (nb_ops >= MAX_OPERANDS) {\n            error(\"incorrect number of operands\");\n        }\n        parse_operand(s1, pop);\n        pop++;\n        nb_ops++;\n        if (tok != ',')\n            break;\n        next();\n    }\n\n    is_short_jmp = 0;\n    s = 0; /* avoid warning */\n    \n    /* optimize matching by using a lookup table (no hashing is needed\n       !) */\n    for(pa = asm_instrs; pa->sym != 0; pa++) {\n        s = 0;\n        if (pa->instr_type & OPC_FARITH) {\n            v = opcode - pa->sym;\n            if (!((unsigned)v < 8 * 6 && (v % 6) == 0))\n                continue;\n        } else if (pa->instr_type & OPC_ARITH) {\n            if (!(opcode >= pa->sym && opcode < pa->sym + 8 * 4))\n                continue;\n            goto compute_size;\n        } else if (pa->instr_type & OPC_SHIFT) {\n            if (!(opcode >= pa->sym && opcode < pa->sym + 7 * 4))\n                continue;\n            goto compute_size;\n        } else if (pa->instr_type & OPC_TEST) {\n            if (!(opcode >= pa->sym && opcode < pa->sym + NB_TEST_OPCODES))\n                continue;\n        } else if (pa->instr_type & OPC_B) {\n            if (!(opcode >= pa->sym && opcode <= pa->sym + 3))\n                continue;\n        compute_size:\n            s = (opcode - pa->sym) & 3;\n        } else if (pa->instr_type & OPC_WL) {\n            if (!(opcode >= pa->sym && opcode <= pa->sym + 2))\n                continue;\n            s = opcode - pa->sym + 1;\n        } else {\n            if (pa->sym != opcode)\n                continue;\n        }\n        if (pa->nb_ops != nb_ops)\n            continue;\n        /* now decode and check each operand */\n        for(i = 0; i < nb_ops; i++) {\n            int op1, op2;\n            op1 = pa->op_type[i];\n            op2 = op1 & 0x1f;\n            switch(op2) {\n            case OPT_IM:\n                v = OP_IM8 | OP_IM16 | OP_IM32;\n                break;\n            case OPT_REG:\n                v = OP_REG8 | OP_REG16 | OP_REG32;\n                break;\n            case OPT_REGW:\n                v = OP_REG16 | OP_REG32;\n                break;\n            case OPT_IMW:\n                v = OP_IM16 | OP_IM32;\n                break;\n            default:\n                v = 1 << op2;\n                break;\n            }\n            if (op1 & OPT_EA)\n                v |= OP_EA;\n            op_type[i] = v;\n            if ((ops[i].type & v) == 0)\n                goto next;\n        }\n        /* all is matching ! */\n        break;\n    next: ;\n    }\n    if (pa->sym == 0) {\n        if (opcode >= TOK_ASM_pusha && opcode <= TOK_ASM_emms) {\n            int b;\n            b = op0_codes[opcode - TOK_ASM_pusha];\n            if (b & 0xff00) \n                g(b >> 8);\n            g(b);\n            return;\n        } else {\n            error(\"unknown opcode '%s'\", \n                  get_tok_str(opcode, NULL));\n        }\n    }\n    /* if the size is unknown, then evaluate it (OPC_B or OPC_WL case) */\n    if (s == 3) {\n        for(i = 0; s == 3 && i < nb_ops; i++) {\n            if ((ops[i].type & OP_REG) && !(op_type[i] & (OP_CL | OP_DX)))\n                s = reg_to_size[ops[i].type & OP_REG];\n        }\n        if (s == 3) {\n            if ((opcode == TOK_ASM_push || opcode == TOK_ASM_pop) && \n                (ops[0].type & (OP_SEG | OP_IM8S | OP_IM32)))\n                s = 2;\n            else\n                error(\"cannot infer opcode suffix\");\n        }\n    }\n\n    /* generate data16 prefix if needed */\n    ss = s;\n    if (s == 1 || (pa->instr_type & OPC_D16))\n        g(WORD_PREFIX_OPCODE);\n    else if (s == 2)\n        s = 1;\n    /* now generates the operation */\n    if (pa->instr_type & OPC_FWAIT)\n        g(0x9b);\n\n    v = pa->opcode;\n    if (v == 0x69 || v == 0x69) {\n        /* kludge for imul $im, %reg */\n        nb_ops = 3;\n        ops[2] = ops[1];\n    } else if (v == 0xcd && ops[0].e.v == 3 && !ops[0].e.sym) {\n        v--; /* int $3 case */\n        nb_ops = 0;\n    } else if ((v == 0x06 || v == 0x07)) {\n        if (ops[0].reg >= 4) {\n            /* push/pop %fs or %gs */\n            v = 0x0fa0 + (v - 0x06) + ((ops[0].reg - 4) << 3);\n        } else {\n            v += ops[0].reg << 3;\n        }\n        nb_ops = 0;\n    } else if (v <= 0x05) {\n        /* arith case */\n        v += ((opcode - TOK_ASM_addb) >> 2) << 3;\n    } else if ((pa->instr_type & (OPC_FARITH | OPC_MODRM)) == OPC_FARITH) {\n        /* fpu arith case */\n        v += ((opcode - pa->sym) / 6) << 3;\n    }\n    if (pa->instr_type & OPC_REG) {\n        for(i = 0; i < nb_ops; i++) {\n            if (op_type[i] & (OP_REG | OP_ST)) {\n                v += ops[i].reg;\n                break;\n            }\n        }\n        /* mov $im, %reg case */\n        if (pa->opcode == 0xb0 && s >= 1)\n            v += 7;\n    }\n    if (pa->instr_type & OPC_B)\n        v += s;\n    if (pa->instr_type & OPC_TEST)\n        v += test_bits[opcode - pa->sym]; \n    if (pa->instr_type & OPC_SHORTJMP) {\n        Sym *sym;\n        int jmp_disp;\n\n        /* see if we can really generate the jump with a byte offset */\n        sym = ops[0].e.sym;\n        if (!sym)\n            goto no_short_jump;\n        if (sym->r != cur_text_section->sh_num)\n            goto no_short_jump;\n        jmp_disp = ops[0].e.v + (long)sym->next - ind - 2;\n        if (jmp_disp == (int8_t)jmp_disp) {\n            /* OK to generate jump */\n            is_short_jmp = 1;\n            ops[0].e.v = jmp_disp;\n        } else {\n        no_short_jump:\n            if (pa->instr_type & OPC_JMP) {\n                /* long jump will be allowed. need to modify the\n                   opcode slightly */\n                if (v == 0xeb)\n                    v = 0xe9;\n                else \n                    v += 0x0f10;\n            } else {\n                error(\"invalid displacement\");\n            }\n        }\n    }\n    op1 = v >> 8;\n    if (op1)\n        g(op1);\n    g(v);\n        \n    /* search which operand will used for modrm */\n    modrm_index = 0;\n    if (pa->instr_type & OPC_SHIFT) {\n        reg = (opcode - pa->sym) >> 2; \n        if (reg == 6)\n            reg = 7;\n    } else if (pa->instr_type & OPC_ARITH) {\n        reg = (opcode - pa->sym) >> 2;\n    } else if (pa->instr_type & OPC_FARITH) {\n        reg = (opcode - pa->sym) / 6;\n    } else {\n        reg = (pa->instr_type >> OPC_GROUP_SHIFT) & 7;\n    }\n    if (pa->instr_type & OPC_MODRM) {\n        /* first look for an ea operand */\n        for(i = 0;i < nb_ops; i++) {\n            if (op_type[i] & OP_EA)\n                goto modrm_found;\n        }\n        /* then if not found, a register or indirection (shift instructions) */\n        for(i = 0;i < nb_ops; i++) {\n            if (op_type[i] & (OP_REG | OP_MMX | OP_SSE | OP_INDIR))\n                goto modrm_found;\n        }\n#ifdef ASM_DEBUG\n        error(\"bad op table\");\n#endif      \n    modrm_found:\n        modrm_index = i;\n        /* if a register is used in another operand then it is\n           used instead of group */\n        for(i = 0;i < nb_ops; i++) {\n            v = op_type[i];\n            if (i != modrm_index && \n                (v & (OP_REG | OP_MMX | OP_SSE | OP_CR | OP_TR | OP_DB | OP_SEG))) {\n                reg = ops[i].reg;\n                break;\n            }\n        }\n\n        asm_modrm(reg, &ops[modrm_index]);\n    }\n\n    /* emit constants */\n    if (pa->opcode == 0x9a || pa->opcode == 0xea) {\n        /* ljmp or lcall kludge */\n        gen_expr32(&ops[1].e);\n        if (ops[0].e.sym)\n            error(\"cannot relocate\");\n        gen_le16(ops[0].e.v);\n    } else {\n        for(i = 0;i < nb_ops; i++) {\n            v = op_type[i];\n            if (v & (OP_IM8 | OP_IM16 | OP_IM32 | OP_IM8S | OP_ADDR)) {\n                /* if multiple sizes are given it means we must look\n                   at the op size */\n                if (v == (OP_IM8 | OP_IM16 | OP_IM32) ||\n                    v == (OP_IM16 | OP_IM32)) {\n                    if (ss == 0)\n                        v = OP_IM8;\n                    else if (ss == 1)\n                        v = OP_IM16;\n                    else\n                        v = OP_IM32;\n                }\n                if (v & (OP_IM8 | OP_IM8S)) {\n                    if (ops[i].e.sym)\n                        goto error_relocate;\n                    g(ops[i].e.v);\n                } else if (v & OP_IM16) {\n                    if (ops[i].e.sym) {\n                    error_relocate:\n                        error(\"cannot relocate\");\n                    }\n                    gen_le16(ops[i].e.v);\n                } else {\n                    if (pa->instr_type & (OPC_JMP | OPC_SHORTJMP)) {\n                        if (is_short_jmp)\n                            g(ops[i].e.v);\n                        else\n                            gen_disp32(&ops[i].e);\n                    } else {\n                        gen_expr32(&ops[i].e);\n                    }\n                }\n            }\n        }\n    }\n}\n\n#define NB_SAVED_REGS 3\n#define NB_ASM_REGS 8\n\n/* return the constraint priority (we allocate first the lowest\n   numbered constraints) */\nstatic inline int constraint_priority(const char *str)\n{\n    int priority, c, pr;\n\n    /* we take the lowest priority */\n    priority = 0;\n    for(;;) {\n        c = *str;\n        if (c == '\\0')\n            break;\n        str++;\n        switch(c) {\n        case 'A':\n            pr = 0;\n            break;\n        case 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'S':\n        case 'D':\n            pr = 1;\n            break;\n        case 'q':\n            pr = 2;\n            break;\n        case 'r':\n            pr = 3;\n            break;\n        case 'N':\n        case 'M':\n        case 'I':\n        case 'i':\n        case 'm':\n        case 'g':\n            pr = 4;\n            break;\n        default:\n            error(\"unknown constraint '%c'\", c);\n            pr = 0;\n        }\n        if (pr > priority)\n            priority = pr;\n    }\n    return priority;\n}\n\nstatic const char *skip_constraint_modifiers(const char *p)\n{\n    while (*p == '=' || *p == '&' || *p == '+' || *p == '%')\n        p++;\n    return p;\n}\n\n#define REG_OUT_MASK 0x01\n#define REG_IN_MASK  0x02\n\n#define is_reg_allocated(reg) (regs_allocated[reg] & reg_mask)\n\nstatic void asm_compute_constraints(ASMOperand *operands, \n                                    int nb_operands, int nb_outputs, \n                                    const uint8_t *clobber_regs,\n                                    int *pout_reg)\n{\n    ASMOperand *op;\n    int sorted_op[MAX_ASM_OPERANDS];\n    int i, j, k, p1, p2, tmp, reg, c, reg_mask;\n    const char *str;\n    uint8_t regs_allocated[NB_ASM_REGS];\n    \n    /* init fields */\n    for(i=0;i<nb_operands;i++) {\n        op = &operands[i];\n        op->input_index = -1;\n        op->ref_index = -1;\n        op->reg = -1;\n        op->is_memory = 0;\n        op->is_rw = 0;\n    }\n    /* compute constraint priority and evaluate references to output\n       constraints if input constraints */\n    for(i=0;i<nb_operands;i++) {\n        op = &operands[i];\n        str = op->constraint;\n        str = skip_constraint_modifiers(str);\n        if (isnum(*str) || *str == '[') {\n            /* this is a reference to another constraint */\n            k = find_constraint(operands, nb_operands, str, NULL);\n            if ((unsigned)k >= i || i < nb_outputs)\n                error(\"invalid reference in constraint %d ('%s')\",\n                      i, str);\n            op->ref_index = k;\n            if (operands[k].input_index >= 0)\n                error(\"cannot reference twice the same operand\");\n            operands[k].input_index = i;\n            op->priority = 5;\n        } else {\n            op->priority = constraint_priority(str);\n        }\n    }\n    \n    /* sort operands according to their priority */\n    for(i=0;i<nb_operands;i++)\n        sorted_op[i] = i;\n    for(i=0;i<nb_operands - 1;i++) {\n        for(j=i+1;j<nb_operands;j++) {\n            p1 = operands[sorted_op[i]].priority; \n            p2 = operands[sorted_op[j]].priority;\n            if (p2 < p1) {\n                tmp = sorted_op[i];\n                sorted_op[i] = sorted_op[j];\n                sorted_op[j] = tmp;\n            }\n        }\n    }\n\n    for(i = 0;i < NB_ASM_REGS; i++) {\n        if (clobber_regs[i])\n            regs_allocated[i] = REG_IN_MASK | REG_OUT_MASK;\n        else\n            regs_allocated[i] = 0;\n    }\n    /* esp cannot be used */\n    regs_allocated[4] = REG_IN_MASK | REG_OUT_MASK; \n    /* ebp cannot be used yet */\n    regs_allocated[5] = REG_IN_MASK | REG_OUT_MASK; \n\n    /* allocate registers and generate corresponding asm moves */\n    for(i=0;i<nb_operands;i++) {\n        j = sorted_op[i];\n        op = &operands[j];\n        str = op->constraint;\n        /* no need to allocate references */\n        if (op->ref_index >= 0)\n            continue;\n        /* select if register is used for output, input or both */\n        if (op->input_index >= 0) {\n            reg_mask = REG_IN_MASK | REG_OUT_MASK;\n        } else if (j < nb_outputs) {\n            reg_mask = REG_OUT_MASK;\n        } else {\n            reg_mask = REG_IN_MASK;\n        }\n    try_next:\n        c = *str++;\n        switch(c) {\n        case '=':\n            goto try_next;\n        case '+':\n            op->is_rw = 1;\n            /* FALL THRU */\n        case '&':\n            if (j >= nb_outputs)\n                error(\"'%c' modifier can only be applied to outputs\", c);\n            reg_mask = REG_IN_MASK | REG_OUT_MASK;\n            goto try_next;\n        case 'A':\n            /* allocate both eax and edx */\n            if (is_reg_allocated(TREG_EAX) || \n                is_reg_allocated(TREG_EDX))\n                goto try_next;\n            op->is_llong = 1;\n            op->reg = TREG_EAX;\n            regs_allocated[TREG_EAX] |= reg_mask;\n            regs_allocated[TREG_EDX] |= reg_mask;\n            break;\n        case 'a':\n            reg = TREG_EAX;\n            goto alloc_reg;\n        case 'b':\n            reg = 3;\n            goto alloc_reg;\n        case 'c':\n            reg = TREG_ECX;\n            goto alloc_reg;\n        case 'd':\n            reg = TREG_EDX;\n            goto alloc_reg;\n        case 'S':\n            reg = 6;\n            goto alloc_reg;\n        case 'D':\n            reg = 7;\n        alloc_reg:\n            if (is_reg_allocated(reg))\n                goto try_next;\n            goto reg_found;\n        case 'q':\n            /* eax, ebx, ecx or edx */\n            for(reg = 0; reg < 4; reg++) {\n                if (!is_reg_allocated(reg))\n                    goto reg_found;\n            }\n            goto try_next;\n        case 'r':\n            /* any general register */\n            for(reg = 0; reg < 8; reg++) {\n                if (!is_reg_allocated(reg))\n                    goto reg_found;\n            }\n            goto try_next;\n        reg_found:\n            /* now we can reload in the register */\n            op->is_llong = 0;\n            op->reg = reg;\n            regs_allocated[reg] |= reg_mask;\n            break;\n        case 'i':\n            if (!((op->vt->r & (VT_VALMASK | VT_LVAL)) == VT_CONST))\n                goto try_next;\n            break;\n        case 'I':\n        case 'N':\n        case 'M':\n            if (!((op->vt->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST))\n                goto try_next;\n            break;\n        case 'm':\n        case 'g':\n            /* nothing special to do because the operand is already in\n               memory, except if the pointer itself is stored in a\n               memory variable (VT_LLOCAL case) */\n            /* XXX: fix constant case */\n            /* if it is a reference to a memory zone, it must lie\n               in a register, so we reserve the register in the\n               input registers and a load will be generated\n               later */\n            if (j < nb_outputs || c == 'm') {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL) {\n                    /* any general register */\n                    for(reg = 0; reg < 8; reg++) {\n                        if (!(regs_allocated[reg] & REG_IN_MASK))\n                            goto reg_found1;\n                    }\n                    goto try_next;\n                reg_found1:\n                    /* now we can reload in the register */\n                    regs_allocated[reg] |= REG_IN_MASK;\n                    op->reg = reg;\n                    op->is_memory = 1;\n                }\n            }\n            break;\n        default:\n            error(\"asm constraint %d ('%s') could not be satisfied\", \n                  j, op->constraint);\n            break;\n        }\n        /* if a reference is present for that operand, we assign it too */\n        if (op->input_index >= 0) {\n            operands[op->input_index].reg = op->reg;\n            operands[op->input_index].is_llong = op->is_llong;\n        }\n    }\n    \n    /* compute out_reg. It is used to store outputs registers to memory\n       locations references by pointers (VT_LLOCAL case) */\n    *pout_reg = -1;\n    for(i=0;i<nb_operands;i++) {\n        op = &operands[i];\n        if (op->reg >= 0 && \n            (op->vt->r & VT_VALMASK) == VT_LLOCAL  &&\n            !op->is_memory) {\n            for(reg = 0; reg < 8; reg++) {\n                if (!(regs_allocated[reg] & REG_OUT_MASK))\n                    goto reg_found2;\n            }\n            error(\"could not find free output register for reloading\");\n        reg_found2:\n            *pout_reg = reg;\n            break;\n        }\n    }\n    \n    /* print sorted constraints */\n#ifdef ASM_DEBUG\n    for(i=0;i<nb_operands;i++) {\n        j = sorted_op[i];\n        op = &operands[j];\n        printf(\"%%%d [%s]: \\\"%s\\\" r=0x%04x reg=%d\\n\", \n               j,                \n               op->id ? get_tok_str(op->id, NULL) : \"\", \n               op->constraint,\n               op->vt->r,\n               op->reg);\n    }\n    if (*pout_reg >= 0)\n        printf(\"out_reg=%d\\n\", *pout_reg);\n#endif\n}\n\nstatic void subst_asm_operand(CString *add_str, \n                              SValue *sv, int modifier)\n{\n    int r, reg, size, val;\n    char buf[64];\n\n    r = sv->r;\n    if ((r & VT_VALMASK) == VT_CONST) {\n        if (!(r & VT_LVAL) && modifier != 'c' && modifier != 'n')\n            cstr_ccat(add_str, '$');\n        if (r & VT_SYM) {\n            cstr_cat(add_str, get_tok_str(sv->sym->v, NULL));\n            if (sv->c.i != 0) {\n                cstr_ccat(add_str, '+');\n            } else {\n                return;\n            }\n        }\n        val = sv->c.i;\n        if (modifier == 'n')\n            val = -val;\n        snprintf(buf, sizeof(buf), \"%d\", sv->c.i);\n        cstr_cat(add_str, buf);\n    } else if ((r & VT_VALMASK) == VT_LOCAL) {\n        snprintf(buf, sizeof(buf), \"%d(%%ebp)\", sv->c.i);\n        cstr_cat(add_str, buf);\n    } else if (r & VT_LVAL) {\n        reg = r & VT_VALMASK;\n        if (reg >= VT_CONST)\n            error(\"internal compiler error\");\n        snprintf(buf, sizeof(buf), \"(%%%s)\", \n                 get_tok_str(TOK_ASM_eax + reg, NULL));\n        cstr_cat(add_str, buf);\n    } else {\n        /* register case */\n        reg = r & VT_VALMASK;\n        if (reg >= VT_CONST)\n            error(\"internal compiler error\");\n\n        /* choose register operand size */\n        if ((sv->type.t & VT_BTYPE) == VT_BYTE)\n            size = 1;\n        else if ((sv->type.t & VT_BTYPE) == VT_SHORT)\n            size = 2;\n        else\n            size = 4;\n        if (size == 1 && reg >= 4)\n            size = 4;\n\n        if (modifier == 'b') {\n            if (reg >= 4)\n                error(\"cannot use byte register\");\n            size = 1;\n        } else if (modifier == 'h') {\n            if (reg >= 4)\n                error(\"cannot use byte register\");\n            size = -1;\n        } else if (modifier == 'w') {\n            size = 2;\n        }\n\n        switch(size) {\n        case -1:\n            reg = TOK_ASM_ah + reg;\n            break;\n        case 1:\n            reg = TOK_ASM_al + reg;\n            break;\n        case 2:\n            reg = TOK_ASM_ax + reg;\n            break;\n        default:\n            reg = TOK_ASM_eax + reg;\n            break;\n        }\n        snprintf(buf, sizeof(buf), \"%%%s\", get_tok_str(reg, NULL));\n        cstr_cat(add_str, buf);\n    }\n}\n\n/* generate prolog and epilog code for asm statement */\nstatic void asm_gen_code(ASMOperand *operands, int nb_operands, \n                         int nb_outputs, int is_output,\n                         uint8_t *clobber_regs,\n                         int out_reg)\n{\n    uint8_t regs_allocated[NB_ASM_REGS];\n    ASMOperand *op;\n    int i, reg;\n    static uint8_t reg_saved[NB_SAVED_REGS] = { 3, 6, 7 };\n\n    /* mark all used registers */\n    memcpy(regs_allocated, clobber_regs, sizeof(regs_allocated));\n    for(i = 0; i < nb_operands;i++) {\n        op = &operands[i];\n        if (op->reg >= 0)\n            regs_allocated[op->reg] = 1;\n    }\n    if (!is_output) {\n        /* generate reg save code */\n        for(i = 0; i < NB_SAVED_REGS; i++) {\n            reg = reg_saved[i];\n            if (regs_allocated[reg]) \n                g(0x50 + reg);\n        }\n\n        /* generate load code */\n        for(i = 0; i < nb_operands; i++) {\n            op = &operands[i];\n            if (op->reg >= 0) {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL &&\n                    op->is_memory) {\n                    /* memory reference case (for both input and\n                       output cases) */\n                    SValue sv;\n                    sv = *op->vt;\n                    sv.r = (sv.r & ~VT_VALMASK) | VT_LOCAL;\n                    load(op->reg, &sv);\n                } else if (i >= nb_outputs || op->is_rw) {\n                    /* load value in register */\n                    load(op->reg, op->vt);\n                    if (op->is_llong) {\n                        SValue sv;\n                        sv = *op->vt;\n                        sv.c.ul += 4;\n                        load(TREG_EDX, &sv);\n                    }\n                }\n            }\n        }\n    } else {\n        /* generate save code */\n        for(i = 0 ; i < nb_outputs; i++) {\n            op = &operands[i];\n            if (op->reg >= 0) {\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL) {\n                    if (!op->is_memory) {\n                        SValue sv;\n                        sv = *op->vt;\n                        sv.r = (sv.r & ~VT_VALMASK) | VT_LOCAL;\n                        load(out_reg, &sv);\n\n                        sv.r = (sv.r & ~VT_VALMASK) | out_reg;\n                        store(op->reg, &sv);\n                    }\n                } else {\n                    store(op->reg, op->vt);\n                    if (op->is_llong) {\n                        SValue sv;\n                        sv = *op->vt;\n                        sv.c.ul += 4;\n                        store(TREG_EDX, &sv);\n                    }\n                }\n            }\n        }\n        /* generate reg restore code */\n        for(i = NB_SAVED_REGS - 1; i >= 0; i--) {\n            reg = reg_saved[i];\n            if (regs_allocated[reg]) \n                g(0x58 + reg);\n        }\n    }\n}\n\nstatic void asm_clobber(uint8_t *clobber_regs, const char *str)\n{\n    int reg;\n    TokenSym *ts;\n\n    if (!strcmp(str, \"memory\") || \n        !strcmp(str, \"cc\"))\n        return;\n    ts = tok_alloc(str, strlen(str));\n    reg = ts->tok;\n    if (reg >= TOK_ASM_eax && reg <= TOK_ASM_edi) {\n        reg -= TOK_ASM_eax;\n    } else if (reg >= TOK_ASM_ax && reg <= TOK_ASM_di) {\n        reg -= TOK_ASM_ax;\n    } else {\n        error(\"invalid clobber register '%s'\", str);\n    }\n    clobber_regs[reg] = 1;\n}\n//---------------------------------------------------------------------------\n#endif\n// njn: inlined tccasm.c\n//#include \"tccasm.c\"\n//---------------------------------------------------------------------------\n/*\n *  GAS like assembler for TCC\n * \n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nstatic int asm_get_local_label_name(TCCState *s1, unsigned int n)\n{\n    char buf[64];\n    TokenSym *ts;\n\n    snprintf(buf, sizeof(buf), \"L..%u\", n);\n    ts = tok_alloc(buf, strlen(buf));\n    return ts->tok;\n}\n\nstatic void asm_expr(TCCState *s1, ExprValue *pe);\n\n/* We do not use the C expression parser to handle symbols. Maybe the\n   C expression parser could be tweaked to do so. */\n\nstatic void asm_expr_unary(TCCState *s1, ExprValue *pe)\n{\n    Sym *sym;\n    int op, n, label;\n    const char *p;\n\n    switch(tok) {\n    case TOK_PPNUM:\n        p = tokc.cstr->data;\n        n = strtoul(p, (char **)&p, 0);\n        if (*p == 'b' || *p == 'f') {\n            /* backward or forward label */\n            label = asm_get_local_label_name(s1, n);\n            sym = label_find(label);\n            if (*p == 'b') {\n                /* backward : find the last corresponding defined label */\n                if (sym && sym->r == 0)\n                    sym = sym->prev_tok;\n                if (!sym)\n                    error(\"local label '%d' not found backward\", n);\n            } else {\n                /* forward */\n                if (!sym || sym->r) {\n                    /* if the last label is defined, then define a new one */\n                    sym = label_push(&s1->asm_labels, label, 0);\n                    sym->type.t = VT_STATIC | VT_VOID;\n                }\n            }\n            pe->v = 0;\n            pe->sym = sym;\n        } else if (*p == '\\0') {\n            pe->v = n;\n            pe->sym = NULL;\n        } else {\n            error(\"invalid number syntax\");\n        }\n        next();\n        break;\n    case '+':\n        next();\n        asm_expr_unary(s1, pe);\n        break;\n    case '-':\n    case '~':\n        op = tok;\n        next();\n        asm_expr_unary(s1, pe);\n        if (pe->sym)\n            error(\"invalid operation with label\");\n        if (op == '-')\n            pe->v = -pe->v;\n        else\n            pe->v = ~pe->v;\n        break;\n    case TOK_CCHAR:\n    case TOK_LCHAR:\n\tpe->v = tokc.i;\n\tpe->sym = NULL;\n\tnext();\n\tbreak;\n    case '(':\n        next();\n        asm_expr(s1, pe);\n        skip(')');\n        break;\n    default:\n        if (tok >= TOK_IDENT) {\n            /* label case : if the label was not found, add one */\n            sym = label_find(tok);\n            if (!sym) {\n                sym = label_push(&s1->asm_labels, tok, 0);\n                /* NOTE: by default, the symbol is global */\n                sym->type.t = VT_VOID;\n            }\n            if (sym->r == SHN_ABS) {\n                /* if absolute symbol, no need to put a symbol value */\n                pe->v = (long)sym->next;\n                pe->sym = NULL;\n            } else {\n                pe->v = 0;\n                pe->sym = sym;\n            }\n            next();\n        } else {\n            error(\"bad expression syntax [%s]\", get_tok_str(tok, &tokc));\n        }\n        break;\n    }\n}\n    \nstatic void asm_expr_prod(TCCState *s1, ExprValue *pe)\n{\n    int op;\n    ExprValue e2;\n\n    asm_expr_unary(s1, pe);\n    for(;;) {\n        op = tok;\n        if (op != '*' && op != '/' && op != '%' && \n            op != TOK_SHL && op != TOK_SAR)\n            break;\n        next();\n        asm_expr_unary(s1, &e2);\n        if (pe->sym || e2.sym)\n            error(\"invalid operation with label\");\n        switch(op) {\n        case '*':\n            pe->v *= e2.v;\n            break;\n        case '/':  \n            if (e2.v == 0) {\n            div_error:\n                error(\"division by zero\");\n            }\n            pe->v /= e2.v;\n            break;\n        case '%':  \n            if (e2.v == 0)\n                goto div_error;\n            pe->v %= e2.v;\n            break;\n        case TOK_SHL:\n            pe->v <<= e2.v;\n            break;\n        default:\n        case TOK_SAR:\n            pe->v >>= e2.v;\n            break;\n        }\n    }\n}\n\nstatic void asm_expr_logic(TCCState *s1, ExprValue *pe)\n{\n    int op;\n    ExprValue e2;\n\n    asm_expr_prod(s1, pe);\n    for(;;) {\n        op = tok;\n        if (op != '&' && op != '|' && op != '^')\n            break;\n        next();\n        asm_expr_prod(s1, &e2);\n        if (pe->sym || e2.sym)\n            error(\"invalid operation with label\");\n        switch(op) {\n        case '&':\n            pe->v &= e2.v;\n            break;\n        case '|':  \n            pe->v |= e2.v;\n            break;\n        default:\n        case '^':\n            pe->v ^= e2.v;\n            break;\n        }\n    }\n}\n\nstatic inline void asm_expr_sum(TCCState *s1, ExprValue *pe)\n{\n    int op;\n    ExprValue e2;\n\n    asm_expr_logic(s1, pe);\n    for(;;) {\n        op = tok;\n        if (op != '+' && op != '-')\n            break;\n        next();\n        asm_expr_logic(s1, &e2);\n        if (op == '+') {\n            if (pe->sym != NULL && e2.sym != NULL)\n                goto cannot_relocate;\n            pe->v += e2.v;\n            if (pe->sym == NULL && e2.sym != NULL)\n                pe->sym = e2.sym;\n        } else {\n            pe->v -= e2.v;\n            /* NOTE: we are less powerful than gas in that case\n               because we store only one symbol in the expression */\n            if (!pe->sym && !e2.sym) {\n                /* OK */\n            } else if (pe->sym && !e2.sym) {\n                /* OK */\n            } else if (pe->sym && e2.sym) {\n                if (pe->sym == e2.sym) { \n                    /* OK */\n                } else if (pe->sym->r == e2.sym->r && pe->sym->r != 0) {\n                    /* we also accept defined symbols in the same section */\n                    pe->v += (long)pe->sym->next - (long)e2.sym->next;\n                } else {\n                    goto cannot_relocate;\n                }\n                pe->sym = NULL; /* same symbols can be substracted to NULL */\n            } else {\n            cannot_relocate:\n                error(\"invalid operation with label\");\n            }\n        }\n    }\n}\n\nstatic void asm_expr(TCCState *s1, ExprValue *pe)\n{\n    asm_expr_sum(s1, pe);\n}\n\nstatic int asm_int_expr(TCCState *s1)\n{\n    ExprValue e;\n    asm_expr(s1, &e);\n    if (e.sym)\n        expect(\"constant\");\n    return e.v;\n}\n\n/* NOTE: the same name space as C labels is used to avoid using too\n   much memory when storing labels in TokenStrings */\nstatic void asm_new_label1(TCCState *s1, int label, int is_local,\n                           int sh_num, long value)\n{\n    Sym *sym;\n\n    sym = label_find(label);\n    if (sym) {\n        if (sym->r) {\n            /* the label is already defined */\n            if (!is_local) {\n                error(\"assembler label '%s' already defined\", \n                      get_tok_str(label, NULL));\n            } else {\n                /* redefinition of local labels is possible */\n                goto new_label;\n            }\n        }\n    } else {\n    new_label:\n        sym = label_push(&s1->asm_labels, label, 0);\n        sym->type.t = VT_STATIC | VT_VOID;\n    }\n    sym->r = sh_num;\n    sym->next = (void *)value;\n}\n\nstatic void asm_new_label(TCCState *s1, int label, int is_local)\n{\n    asm_new_label1(s1, label, is_local, cur_text_section->sh_num, ind);\n}\n\nstatic void asm_free_labels(TCCState *st)\n{\n    Sym *s, *s1;\n    Section *sec;\n    \n    for(s = st->asm_labels; s != NULL; s = s1) {\n        s1 = s->prev;\n        /* define symbol value in object file */\n        if (s->r) {\n            if (s->r == SHN_ABS)\n                sec = SECTION_ABS;\n            else\n                sec = st->sections[s->r];\n            put_extern_sym2(s, sec, (long)s->next, 0, 0);\n        }\n        /* remove label */\n        table_ident[s->v - TOK_IDENT]->sym_label = NULL;\n        sym_free(s);\n    }\n    st->asm_labels = NULL;\n}\n\nstatic void use_section1(TCCState *s1, Section *sec)\n{\n    cur_text_section->data_offset = ind;\n    cur_text_section = sec;\n    ind = cur_text_section->data_offset;\n}\n\nstatic void use_section(TCCState *s1, const char *name)\n{\n    Section *sec;\n    sec = find_section(s1, name);\n    use_section1(s1, sec);\n}\n\nstatic void asm_parse_directive(TCCState *s1)\n{\n    int n, offset, v, size, tok1;\n    Section *sec;\n    uint8_t *ptr;\n\n    /* assembler directive */\n    next();\n    sec = cur_text_section;\n    switch(tok) {\n    case TOK_ASM_align:\n    case TOK_ASM_skip:\n    case TOK_ASM_space:\n        tok1 = tok;\n        next();\n        n = asm_int_expr(s1);\n        if (tok1 == TOK_ASM_align) {\n            if (n < 0 || (n & (n-1)) != 0)\n                error(\"alignment must be a positive power of two\");\n            offset = (ind + n - 1) & -n;\n            size = offset - ind;\n            /* the section must have a compatible alignment */\n            if (sec->sh_addralign < n)\n                sec->sh_addralign = n;\n        } else {\n            size = n;\n        }\n        v = 0;\n        if (tok == ',') {\n            next();\n            v = asm_int_expr(s1);\n        }\n    zero_pad:\n        if (sec->sh_type != SHT_NOBITS) {\n            sec->data_offset = ind;\n            ptr = section_ptr_add(sec, size);\n            memset(ptr, v, size);\n        }\n        ind += size;\n        break;\n    case TOK_ASM_quad:\n        next();\n        for(;;) {\n            uint64_t vl;\n            const char *p;\n\n            p = tokc.cstr->data;\n            if (tok != TOK_PPNUM) {\n            error_constant:\n                error(\"64 bit constant\");\n            }\n            vl = strtoll(p, (char **)&p, 0);\n            if (*p != '\\0')\n                goto error_constant;\n            next();\n            if (sec->sh_type != SHT_NOBITS) {\n                /* XXX: endianness */\n                gen_le32(vl);\n                gen_le32(vl >> 32);\n            } else {\n                ind += 8;\n            }\n            if (tok != ',')\n                break;\n            next();\n        }\n        break;\n    case TOK_ASM_byte:\n        size = 1;\n        goto asm_data;\n    case TOK_ASM_word:\n    case TOK_SHORT:\n        size = 2;\n        goto asm_data;\n    case TOK_LONG:\n    case TOK_INT:\n        size = 4;\n    asm_data:\n        next();\n        for(;;) {\n            ExprValue e;\n            asm_expr(s1, &e);\n            if (sec->sh_type != SHT_NOBITS) {\n                if (size == 4) {\n                    gen_expr32(&e);\n                } else {\n                    if (e.sym)\n                        expect(\"constant\");\n                    if (size == 1)\n                        g(e.v);\n                    else\n                        gen_le16(e.v);\n                }\n            } else {\n                ind += size;\n            }\n            if (tok != ',')\n                break;\n            next();\n        }\n        break;\n    case TOK_ASM_fill:\n        {\n            int repeat, size, val, i, j;\n            uint8_t repeat_buf[8];\n            next();\n            repeat = asm_int_expr(s1);\n            if (repeat < 0) {\n                error(\"repeat < 0; .fill ignored\");\n                break;\n            }\n            size = 1;\n            val = 0;\n            if (tok == ',') {\n                next();\n                size = asm_int_expr(s1);\n                if (size < 0) {\n                    error(\"size < 0; .fill ignored\");\n                    break;\n                }\n                if (size > 8)\n                    size = 8;\n                if (tok == ',') {\n                    next();\n                    val = asm_int_expr(s1);\n                }\n            }\n            /* XXX: endianness */\n            repeat_buf[0] = val;\n            repeat_buf[1] = val >> 8;\n            repeat_buf[2] = val >> 16;\n            repeat_buf[3] = val >> 24;\n            repeat_buf[4] = 0;\n            repeat_buf[5] = 0;\n            repeat_buf[6] = 0;\n            repeat_buf[7] = 0;\n            for(i = 0; i < repeat; i++) {\n                for(j = 0; j < size; j++) {\n                    g(repeat_buf[j]);\n                }\n            }\n        }\n        break;\n    case TOK_ASM_org:\n        {\n            unsigned long n;\n            next();\n            /* XXX: handle section symbols too */\n            n = asm_int_expr(s1);\n            if (n < ind)\n                error(\"attempt to .org backwards\");\n            v = 0;\n            size = n - ind;\n            goto zero_pad;\n        }\n        break;\n    case TOK_ASM_globl:\n    case TOK_ASM_global:\n\t{ \n            Sym *sym;\n\n            next();\n            sym = label_find(tok);\n            if (!sym) {\n                sym = label_push(&s1->asm_labels, tok, 0);\n                sym->type.t = VT_VOID;\n            }\n            sym->type.t &= ~VT_STATIC;\n            next();\n\t}\n\tbreak;\n    case TOK_ASM_string:\n    case TOK_ASM_ascii:\n    case TOK_ASM_asciz:\n        {\n            const uint8_t *p;\n            int i, size, t;\n\n            t = tok;\n            next();\n            for(;;) {\n                if (tok != TOK_STR)\n                    expect(\"string constant\");\n                p = tokc.cstr->data;\n                size = tokc.cstr->size;\n                if (t == TOK_ASM_ascii && size > 0)\n                    size--;\n                for(i = 0; i < size; i++)\n                    g(p[i]);\n                next();\n                if (tok == ',') {\n                    next();\n                } else if (tok != TOK_STR) {\n                    break;\n                }\n            }\n\t}\n\tbreak;\n    case TOK_ASM_text:\n    case TOK_ASM_data:\n    case TOK_ASM_bss:\n\t{ \n            char sname[64];\n            tok1 = tok;\n            n = 0;\n            next();\n            if (tok != ';' && tok != TOK_LINEFEED) {\n\t\tn = asm_int_expr(s1);\n\t\tnext();\n            }\n            sprintf(sname, (n?\".%s%d\":\".%s\"), get_tok_str(tok1, NULL), n);\n            use_section(s1, sname);\n\t}\n\tbreak;\n    case TOK_SECTION1:\n        {\n            char sname[256];\n\n            /* XXX: support more options */\n            next();\n            sname[0] = '\\0';\n            while (tok != ';' && tok != TOK_LINEFEED && tok != ',') {\n                if (tok == TOK_STR)\n                    pstrcat(sname, sizeof(sname), tokc.cstr->data);\n                else\n                    pstrcat(sname, sizeof(sname), get_tok_str(tok, NULL));\n                next();\n            }\n            if (tok == ',') {\n                /* skip section options */\n                next();\n                if (tok != TOK_STR)\n                    expect(\"string constant\");\n                next();\n            }\n            last_text_section = cur_text_section;\n            use_section(s1, sname);\n        }\n        break;\n    case TOK_ASM_previous:\n        { \n            Section *sec;\n            next();\n            if (!last_text_section)\n                error(\"no previous section referenced\");\n            sec = cur_text_section;\n            use_section1(s1, last_text_section);\n            last_text_section = sec;\n        }\n        break;\n    default:\n        error(\"unknown assembler directive '.%s'\", get_tok_str(tok, NULL));\n        break;\n    }\n}\n\n\n/* assemble a file */\nstatic int tcc_assemble_internal(TCCState *s1, int do_preprocess)\n{\n    int opcode;\n\n#if 0\n    /* print stats about opcodes */\n    {\n        const ASMInstr *pa;\n        int freq[4];\n        int op_vals[500];\n        int nb_op_vals, i, j;\n\n        nb_op_vals = 0;\n        memset(freq, 0, sizeof(freq));\n        for(pa = asm_instrs; pa->sym != 0; pa++) {\n            freq[pa->nb_ops]++;\n            for(i=0;i<pa->nb_ops;i++) {\n                for(j=0;j<nb_op_vals;j++) {\n                    if (pa->op_type[i] == op_vals[j])\n                        goto found;\n                }\n                op_vals[nb_op_vals++] = pa->op_type[i];\n            found: ;\n            }\n        }\n        for(i=0;i<nb_op_vals;i++) {\n            int v = op_vals[i];\n            if ((v & (v - 1)) != 0)\n                printf(\"%3d: %08x\\n\", i, v);\n        }\n        printf(\"size=%d nb=%d f0=%d f1=%d f2=%d f3=%d\\n\",\n               sizeof(asm_instrs), sizeof(asm_instrs) / sizeof(ASMInstr),\n               freq[0], freq[1], freq[2], freq[3]);\n    }\n#endif\n\n    /* XXX: undefine C labels */\n\n    ch = file->buf_ptr[0];\n    tok_flags = TOK_FLAG_BOL | TOK_FLAG_BOF;\n    parse_flags = PARSE_FLAG_ASM_COMMENTS;\n    if (do_preprocess)\n        parse_flags |= PARSE_FLAG_PREPROCESS;\n    next();\n    for(;;) {\n        if (tok == TOK_EOF)\n            break;\n        parse_flags |= PARSE_FLAG_LINEFEED; /* XXX: suppress that hack */\n    redo:\n        if (tok == '#') {\n            /* horrible gas comment */\n            while (tok != TOK_LINEFEED)\n                next();\n        } else if (tok == '.') {\n            asm_parse_directive(s1);\n        } else if (tok == TOK_PPNUM) {\n            const char *p;\n            int n;\n            p = tokc.cstr->data;\n            n = strtoul(p, (char **)&p, 10);\n            if (*p != '\\0')\n                expect(\"':'\");\n            /* new local label */\n            asm_new_label(s1, asm_get_local_label_name(s1, n), 1);\n            next();\n            skip(':');\n            goto redo;\n        } else if (tok >= TOK_IDENT) {\n            /* instruction or label */\n            opcode = tok;\n            next();\n            if (tok == ':') {\n                /* new label */\n                asm_new_label(s1, opcode, 0);\n                next();\n                goto redo;\n            } else if (tok == '=') {\n                int n;\n                next();\n                n = asm_int_expr(s1);\n                asm_new_label1(s1, opcode, 0, SHN_ABS, n);\n                goto redo;\n            } else {\n                asm_opcode(s1, opcode);\n            }\n        }\n        /* end of line */\n        if (tok != ';' && tok != TOK_LINEFEED){\n            expect(\"end of line\");\n        }\n        parse_flags &= ~PARSE_FLAG_LINEFEED; /* XXX: suppress that hack */\n        next();\n    }\n\n    asm_free_labels(s1);\n\n    return 0;\n}\n\n/* Assemble the current file */\nstatic int tcc_assemble(TCCState *s1, int do_preprocess)\n{\n    Sym *define_start;\n    int ret;\n\n    preprocess_init(s1);\n\n    /* default section is text */\n    cur_text_section = text_section;\n    ind = cur_text_section->data_offset;\n\n    define_start = define_stack;\n\n    ret = tcc_assemble_internal(s1, do_preprocess);\n\n    cur_text_section->data_offset = ind;\n\n    free_defines(define_start); \n\n    return ret;\n}\n\n/********************************************************************/\n/* GCC inline asm support */\n\n/* assemble the string 'str' in the current C compilation unit without\n   C preprocessing. NOTE: str is modified by modifying the '\\0' at the\n   end */\nstatic void tcc_assemble_inline(TCCState *s1, char *str, int len)\n{\n    BufferedFile *bf, *saved_file;\n    int saved_parse_flags, *saved_macro_ptr;\n\n    bf = tcc_malloc(sizeof(BufferedFile));\n    memset(bf, 0, sizeof(BufferedFile));\n    bf->fd = -1;\n    bf->buf_ptr = str;\n    bf->buf_end = str + len;\n    str[len] = CH_EOB;\n    /* same name as current file so that errors are correctly\n       reported */\n    pstrcpy(bf->filename, sizeof(bf->filename), file->filename);\n    bf->line_num = file->line_num;\n    saved_file = file;\n    file = bf;\n    saved_parse_flags = parse_flags;\n    saved_macro_ptr = macro_ptr;\n    macro_ptr = NULL;\n    \n    tcc_assemble_internal(s1, 0);\n\n    parse_flags = saved_parse_flags;\n    macro_ptr = saved_macro_ptr;\n    file = saved_file;\n    tcc_free(bf);\n}\n\n/* find a constraint by its number or id (gcc 3 extended\n   syntax). return -1 if not found. Return in *pp in char after the\n   constraint */\nstatic int find_constraint(ASMOperand *operands, int nb_operands, \n                           const char *name, const char **pp)\n{\n    int index;\n    TokenSym *ts;\n    const char *p;\n\n    if (isnum(*name)) {\n        index = 0;\n        while (isnum(*name)) {\n            index = (index * 10) + (*name) - '0';\n            name++;\n        }\n        if ((unsigned)index >= nb_operands)\n            index = -1;\n    } else if (*name == '[') {\n        name++;\n        p = strchr(name, ']');\n        if (p) {\n            ts = tok_alloc(name, p - name);\n            for(index = 0; index < nb_operands; index++) {\n                if (operands[index].id == ts->tok)\n                    goto found;\n            }\n            index = -1;\n        found:\n            name = p + 1;\n        } else {\n            index = -1;\n        }\n    } else {\n        index = -1;\n    }\n    if (pp)\n        *pp = name;\n    return index;\n}\n\nstatic void subst_asm_operands(ASMOperand *operands, int nb_operands, \n                               int nb_outputs,\n                               CString *out_str, CString *in_str)\n{\n    int c, index, modifier;\n    const char *str;\n    ASMOperand *op;\n    SValue sv;\n\n    cstr_new(out_str);\n    str = in_str->data;\n    for(;;) {\n        c = *str++;\n        if (c == '%') {\n            if (*str == '%') {\n                str++;\n                goto add_char;\n            }\n            modifier = 0;\n            if (*str == 'c' || *str == 'n' ||\n                *str == 'b' || *str == 'w' || *str == 'h')\n                modifier = *str++;\n            index = find_constraint(operands, nb_operands, str, &str);\n            if (index < 0)\n                error(\"invalid operand reference after %%\");\n            op = &operands[index];\n            sv = *op->vt;\n            if (op->reg >= 0) {\n                sv.r = op->reg;\n                if ((op->vt->r & VT_VALMASK) == VT_LLOCAL)\n                    sv.r |= VT_LVAL;\n            }\n            subst_asm_operand(out_str, &sv, modifier);\n        } else {\n        add_char:\n            cstr_ccat(out_str, c);\n            if (c == '\\0')\n                break;\n        }\n    }\n}\n\n\nstatic void parse_asm_operands(ASMOperand *operands, int *nb_operands_ptr,\n                               int is_output)\n{\n    ASMOperand *op;\n    int nb_operands;\n\n    if (tok != ':') {\n        nb_operands = *nb_operands_ptr;\n        for(;;) {\n            if (nb_operands >= MAX_ASM_OPERANDS)\n                error(\"too many asm operands\");\n            op = &operands[nb_operands++];\n            op->id = 0;\n            if (tok == '[') {\n                next();\n                if (tok < TOK_IDENT)\n                    expect(\"identifier\");\n                op->id = tok;\n                next();\n                skip(']');\n            }\n            if (tok != TOK_STR)\n                expect(\"string constant\");\n            op->constraint = tcc_malloc(tokc.cstr->size);\n            strcpy(op->constraint, tokc.cstr->data);\n            next();\n            skip('(');\n            gexpr();\n            if (is_output) {\n                test_lvalue();\n            } else {\n                /* we want to avoid LLOCAL case, except when the 'm'\n                   constraint is used. Note that it may come from\n                   register storage, so we need to convert (reg)\n                   case */\n                if ((vtop->r & VT_LVAL) &&\n                    ((vtop->r & VT_VALMASK) == VT_LLOCAL ||\n                     (vtop->r & VT_VALMASK) < VT_CONST) &&\n                    !strchr(op->constraint, 'm')) {\n                    gv(RC_INT);\n                }\n            }\n            op->vt = vtop;\n            skip(')');\n            if (tok == ',') {\n                next();\n            } else {\n                break;\n            }\n        }\n        *nb_operands_ptr = nb_operands;\n    }\n}\n\nstatic void parse_asm_str(CString *astr)\n{\n    skip('(');\n    /* read the string */\n    if (tok != TOK_STR)\n        expect(\"string constant\");\n    cstr_new(astr);\n    while (tok == TOK_STR) {\n        /* XXX: add \\0 handling too ? */\n        cstr_cat(astr, tokc.cstr->data);\n        next();\n    }\n    cstr_ccat(astr, '\\0');\n}\n\n/* parse the GCC asm() instruction */\nstatic void asm_instr(void)\n{\n    CString astr, astr1;\n    ASMOperand operands[MAX_ASM_OPERANDS];\n    int nb_inputs __attribute__((unused));\n    int nb_outputs, nb_operands, i, must_subst, out_reg;\n    uint8_t clobber_regs[NB_ASM_REGS];\n\n    next();\n    /* since we always generate the asm() instruction, we can ignore\n       volatile */\n    if (tok == TOK_VOLATILE1 || tok == TOK_VOLATILE2 || tok == TOK_VOLATILE3) {\n        next();\n    }\n    parse_asm_str(&astr);\n    nb_operands = 0;\n    nb_outputs = 0;\n    must_subst = 0;\n    memset(clobber_regs, 0, sizeof(clobber_regs));\n    if (tok == ':') {\n        next();\n        must_subst = 1;\n        /* output args */\n        parse_asm_operands(operands, &nb_operands, 1);\n        nb_outputs = nb_operands;\n        if (tok == ':') {\n            next();\n            /* input args */\n            parse_asm_operands(operands, &nb_operands, 0);\n            if (tok == ':') {\n                /* clobber list */\n                /* XXX: handle registers */\n                next();\n                for(;;) {\n                    if (tok != TOK_STR)\n                        expect(\"string constant\");\n                    asm_clobber(clobber_regs, tokc.cstr->data);\n                    next();\n                    if (tok == ',') {\n                        next();\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    skip(')');\n    /* NOTE: we do not eat the ';' so that we can restore the current\n       token after the assembler parsing */\n    if (tok != ';')\n        expect(\"';'\");\n    nb_inputs = nb_operands - nb_outputs;\n    \n    /* save all values in the memory */\n    save_regs(0);\n\n    /* compute constraints */\n    asm_compute_constraints(operands, nb_operands, nb_outputs, \n                            clobber_regs, &out_reg);\n\n    /* substitute the operands in the asm string. No substitution is\n       done if no operands (GCC behaviour) */\n#ifdef ASM_DEBUG\n    printf(\"asm: \\\"%s\\\"\\n\", (char *)astr.data);\n#endif\n    if (must_subst) {\n        subst_asm_operands(operands, nb_operands, nb_outputs, &astr1, &astr);\n        cstr_free(&astr);\n    } else {\n        astr1 = astr;\n    }\n#ifdef ASM_DEBUG\n    printf(\"subst_asm: \\\"%s\\\"\\n\", (char *)astr1.data);\n#endif\n\n    /* generate loads */\n    asm_gen_code(operands, nb_operands, nb_outputs, 0, \n                 clobber_regs, out_reg);    \n\n    /* assemble the string with tcc internal assembler */\n    tcc_assemble_inline(tcc_state, astr1.data, astr1.size - 1);\n\n    /* restore the current C token */\n    next();\n\n    /* store the output values if needed */\n    asm_gen_code(operands, nb_operands, nb_outputs, 1, \n                 clobber_regs, out_reg);\n    \n    /* free everything */\n    for(i=0;i<nb_operands;i++) {\n        ASMOperand *op;\n        op = &operands[i];\n        tcc_free(op->constraint);\n        vpop();\n    }\n    cstr_free(&astr1);\n}\n\nstatic void asm_global_instr(void)\n{\n    CString astr;\n\n    next();\n    parse_asm_str(&astr);\n    skip(')');\n    /* NOTE: we do not eat the ';' so that we can restore the current\n       token after the assembler parsing */\n    if (tok != ';')\n        expect(\"';'\");\n    \n#ifdef ASM_DEBUG\n    printf(\"asm_global: \\\"%s\\\"\\n\", (char *)astr.data);\n#endif\n    cur_text_section = text_section;\n    ind = cur_text_section->data_offset;\n\n    /* assemble the string with tcc internal assembler */\n    tcc_assemble_inline(tcc_state, astr.data, astr.size - 1);\n    \n    cur_text_section->data_offset = ind;\n\n    /* restore the current C token */\n    next();\n\n    cstr_free(&astr);\n}\n//---------------------------------------------------------------------------\n\n#else\nstatic void asm_instr(void)\n{\n    error(\"inline asm() not supported\");\n}\nstatic void asm_global_instr(void)\n{\n    error(\"inline asm() not supported\");\n}\n#endif\n\n// njn: inlined tccelf.c\n//#include \"tccelf.c\"\n//---------------------------------------------------------------------------\n/*\n *  ELF file handling for TCC\n * \n *  Copyright (c) 2001-2004 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nstatic int put_elf_str(Section *s, const char *sym)\n{\n    int offset, len;\n    char *ptr;\n\n    len = strlen(sym) + 1;\n    offset = s->data_offset;\n    ptr = section_ptr_add(s, len);\n    memcpy(ptr, sym, len);\n    return offset;\n}\n\n/* elf symbol hashing function */\nstatic unsigned long elf_hash(const unsigned char *name)\n{\n    unsigned long h = 0, g;\n    \n    while (*name) {\n        h = (h << 4) + *name++;\n        g = h & 0xf0000000;\n        if (g)\n            h ^= g >> 24;\n        h &= ~g;\n    }\n    return h;\n}\n\n/* rebuild hash table of section s */\n/* NOTE: we do factorize the hash table code to go faster */\nstatic void rebuild_hash(Section *s, unsigned int nb_buckets)\n{\n    Elf32_Sym *sym;\n    int *ptr, *hash, nb_syms, sym_index, h;\n    char *strtab;\n\n    strtab = s->link->data;\n    nb_syms = s->data_offset / sizeof(Elf32_Sym);\n\n    s->hash->data_offset = 0;\n    ptr = section_ptr_add(s->hash, (2 + nb_buckets + nb_syms) * sizeof(int));\n    ptr[0] = nb_buckets;\n    ptr[1] = nb_syms;\n    ptr += 2;\n    hash = ptr;\n    memset(hash, 0, (nb_buckets + 1) * sizeof(int));\n    ptr += nb_buckets + 1;\n\n    sym = (Elf32_Sym *)s->data + 1;\n    for(sym_index = 1; sym_index < nb_syms; sym_index++) {\n        if (ELF32_ST_BIND(sym->st_info) != STB_LOCAL) {\n            h = elf_hash(strtab + sym->st_name) % nb_buckets;\n            *ptr = hash[h];\n            hash[h] = sym_index;\n        } else {\n            *ptr = 0;\n        }\n        ptr++;\n        sym++;\n    }\n}\n\n/* return the symbol number */\nstatic int put_elf_sym(Section *s, \n                       unsigned long value, unsigned long size,\n                       int info, int other, int shndx, const char *name)\n{\n    int name_offset, sym_index;\n    int nbuckets, h;\n    Elf32_Sym *sym;\n    Section *hs;\n    \n    sym = section_ptr_add(s, sizeof(Elf32_Sym));\n    if (name)\n        name_offset = put_elf_str(s->link, name);\n    else\n        name_offset = 0;\n    /* XXX: endianness */\n    sym->st_name = name_offset;\n    sym->st_value = value;\n    sym->st_size = size;\n    sym->st_info = info;\n    sym->st_other = other;\n    sym->st_shndx = shndx;\n    sym_index = sym - (Elf32_Sym *)s->data;\n    hs = s->hash;\n    if (hs) {\n        int *ptr, *base;\n        ptr = section_ptr_add(hs, sizeof(int));\n        base = (int *)hs->data;\n        /* only add global or weak symbols */\n        if (ELF32_ST_BIND(info) != STB_LOCAL) {\n            /* add another hashing entry */\n            nbuckets = base[0];\n            h = elf_hash(name) % nbuckets;\n            *ptr = base[2 + h];\n            base[2 + h] = sym_index;\n            base[1]++;\n            /* we resize the hash table */\n            hs->nb_hashed_syms++;\n            if (hs->nb_hashed_syms > 2 * nbuckets) {\n                rebuild_hash(s, 2 * nbuckets);\n            }\n        } else {\n            *ptr = 0;\n            base[1]++;\n        }\n    }\n    return sym_index;\n}\n\n/* find global ELF symbol 'name' and return its index. Return 0 if not\n   found. */\nstatic int find_elf_sym(Section *s, const char *name)\n{\n    Elf32_Sym *sym;\n    Section *hs;\n    int nbuckets, sym_index, h;\n    const char *name1;\n    \n    hs = s->hash;\n    if (!hs)\n        return 0;\n    nbuckets = ((int *)hs->data)[0];\n    h = elf_hash(name) % nbuckets;\n    sym_index = ((int *)hs->data)[2 + h];\n    while (sym_index != 0) {\n        sym = &((Elf32_Sym *)s->data)[sym_index];\n        name1 = s->link->data + sym->st_name;\n        if (!strcmp(name, name1))\n            return sym_index;\n        sym_index = ((int *)hs->data)[2 + nbuckets + sym_index];\n    }\n    return 0;\n}\n\n/* return elf symbol value or error */\nint tcc_get_symbol(TCCState *s, unsigned long *pval, const char *name)\n{\n    int sym_index;\n    Elf32_Sym *sym;\n    \n    sym_index = find_elf_sym(symtab_section, name);\n    if (!sym_index)\n        return -1;\n    sym = &((Elf32_Sym *)symtab_section->data)[sym_index];\n    *pval = sym->st_value;\n    return 0;\n}\n\nvoid *tcc_get_symbol_err(TCCState *s, const char *name)\n{\n    unsigned long val;\n    if (tcc_get_symbol(s, &val, name) < 0)\n        error(\"%s not defined\", name);\n    return (void *)val;\n}\n\n/* add an elf symbol : check if it is already defined and patch\n   it. Return symbol index. NOTE that sh_num can be SHN_UNDEF. */\nstatic int add_elf_sym(Section *s, unsigned long value, unsigned long size,\n                       int info, int other, int sh_num, const char *name)\n{\n    Elf32_Sym *esym;\n    int sym_bind, sym_index, sym_type, esym_bind;\n\n    sym_bind = ELF32_ST_BIND(info);\n    sym_type = ELF32_ST_TYPE(info);\n        \n    if (sym_bind != STB_LOCAL) {\n        /* we search global or weak symbols */\n        sym_index = find_elf_sym(s, name);\n        if (!sym_index)\n            goto do_def;\n        esym = &((Elf32_Sym *)s->data)[sym_index];\n        if (esym->st_shndx != SHN_UNDEF) {\n            esym_bind = ELF32_ST_BIND(esym->st_info);\n            if (sh_num == SHN_UNDEF) {\n                /* ignore adding of undefined symbol if the\n                   corresponding symbol is already defined */\n            } else if (sym_bind == STB_GLOBAL && esym_bind == STB_WEAK) {\n                /* global overrides weak, so patch */\n                goto do_patch;\n            } else if (sym_bind == STB_WEAK && esym_bind == STB_GLOBAL) {\n                /* weak is ignored if already global */\n            } else {\n#if 0\n                printf(\"new_bind=%d new_shndx=%d last_bind=%d old_shndx=%d\\n\",\n                       sym_bind, sh_num, esym_bind, esym->st_shndx);\n#endif\n                /* NOTE: we accept that two DLL define the same symbol */\n                if (s != tcc_state->dynsymtab_section)\n                    error_noabort(\"'%s' defined twice\", name);\n            }\n        } else {\n        do_patch:\n            esym->st_info = ELF32_ST_INFO(sym_bind, sym_type);\n            esym->st_shndx = sh_num;\n            esym->st_value = value;\n            esym->st_size = size;\n            esym->st_other = other;\n        }\n    } else {\n    do_def:\n        sym_index = put_elf_sym(s, value, size, \n                                ELF32_ST_INFO(sym_bind, sym_type), other, \n                                sh_num, name);\n    }\n    return sym_index;\n}\n\n/* put relocation */\nstatic void put_elf_reloc(Section *symtab, Section *s, unsigned long offset,\n                          int type, int symbol)\n{\n    char buf[256];\n    Section *sr;\n    Elf32_Rel *rel;\n\n    sr = s->reloc;\n    if (!sr) {\n        /* if no relocation section, create it */\n        snprintf(buf, sizeof(buf), \".rel%s\", s->name);\n        /* if the symtab is allocated, then we consider the relocation\n           are also */\n        sr = new_section(tcc_state, buf, SHT_REL, symtab->sh_flags);\n        sr->sh_entsize = sizeof(Elf32_Rel);\n        sr->link = symtab;\n        sr->sh_info = s->sh_num;\n        s->reloc = sr;\n    }\n    rel = section_ptr_add(sr, sizeof(Elf32_Rel));\n    rel->r_offset = offset;\n    rel->r_info = ELF32_R_INFO(symbol, type);\n}\n\n/* put stab debug information */\n\ntypedef struct {\n    unsigned long n_strx;         /* index into string table of name */\n    unsigned char n_type;         /* type of symbol */\n    unsigned char n_other;        /* misc info (usually empty) */\n    unsigned short n_desc;        /* description field */\n    unsigned long n_value;        /* value of symbol */\n} Stab_Sym;\n\nstatic void put_stabs(const char *str, int type, int other, int desc, \n                      unsigned long value)\n{\n    Stab_Sym *sym;\n\n    sym = section_ptr_add(stab_section, sizeof(Stab_Sym));\n    if (str) {\n        sym->n_strx = put_elf_str(stabstr_section, str);\n    } else {\n        sym->n_strx = 0;\n    }\n    sym->n_type = type;\n    sym->n_other = other;\n    sym->n_desc = desc;\n    sym->n_value = value;\n}\n\nstatic void put_stabs_r(const char *str, int type, int other, int desc, \n                        unsigned long value, Section *sec, int sym_index)\n{\n    put_stabs(str, type, other, desc, value);\n    put_elf_reloc(symtab_section, stab_section, \n                  stab_section->data_offset - sizeof(unsigned long),\n                  R_DATA_32, sym_index);\n}\n\nstatic void put_stabn(int type, int other, int desc, int value)\n{\n    put_stabs(NULL, type, other, desc, value);\n}\n\nstatic void put_stabd(int type, int other, int desc)\n{\n    put_stabs(NULL, type, other, desc, 0);\n}\n\n/* In an ELF file symbol table, the local symbols must appear below\n   the global and weak ones. Since TCC cannot sort it while generating\n   the code, we must do it after. All the relocation tables are also\n   modified to take into account the symbol table sorting */\nstatic void sort_syms(TCCState *s1, Section *s)\n{\n    int *old_to_new_syms;\n    Elf32_Sym *new_syms;\n    int nb_syms, i;\n    Elf32_Sym *p, *q;\n    Elf32_Rel *rel, *rel_end;\n    Section *sr;\n    int type, sym_index;\n\n    nb_syms = s->data_offset / sizeof(Elf32_Sym);\n    new_syms = tcc_malloc(nb_syms * sizeof(Elf32_Sym));\n    old_to_new_syms = tcc_malloc(nb_syms * sizeof(int));\n\n    /* first pass for local symbols */\n    p = (Elf32_Sym *)s->data;\n    q = new_syms;\n    for(i = 0; i < nb_syms; i++) {\n        if (ELF32_ST_BIND(p->st_info) == STB_LOCAL) {\n            old_to_new_syms[i] = q - new_syms;\n            *q++ = *p;\n        }\n        p++;\n    }\n    /* save the number of local symbols in section header */\n    s->sh_info = q - new_syms;\n\n    /* then second pass for non local symbols */\n    p = (Elf32_Sym *)s->data;\n    for(i = 0; i < nb_syms; i++) {\n        if (ELF32_ST_BIND(p->st_info) != STB_LOCAL) {\n            old_to_new_syms[i] = q - new_syms;\n            *q++ = *p;\n        }\n        p++;\n    }\n    \n    /* we copy the new symbols to the old */\n    memcpy(s->data, new_syms, nb_syms * sizeof(Elf32_Sym));\n    tcc_free(new_syms);\n\n    /* now we modify all the relocations */\n    for(i = 1; i < s1->nb_sections; i++) {\n        sr = s1->sections[i];\n        if (sr->sh_type == SHT_REL && sr->link == s) {\n            rel_end = (Elf32_Rel *)(sr->data + sr->data_offset);\n            for(rel = (Elf32_Rel *)sr->data;\n                rel < rel_end;\n                rel++) {\n                sym_index = ELF32_R_SYM(rel->r_info);\n                type = ELF32_R_TYPE(rel->r_info);\n                sym_index = old_to_new_syms[sym_index];\n                rel->r_info = ELF32_R_INFO(sym_index, type);\n            }\n        }\n    }\n    \n    tcc_free(old_to_new_syms);\n}\n\n/* relocate common symbols in the .bss section */\nstatic void relocate_common_syms(void)\n{\n    Elf32_Sym *sym, *sym_end;\n    unsigned long offset, align;\n    \n    sym_end = (Elf32_Sym *)(symtab_section->data + symtab_section->data_offset);\n    for(sym = (Elf32_Sym *)symtab_section->data + 1; \n        sym < sym_end;\n        sym++) {\n        if (sym->st_shndx == SHN_COMMON) {\n            /* align symbol */\n            align = sym->st_value;\n            offset = bss_section->data_offset;\n            offset = (offset + align - 1) & -align;\n            sym->st_value = offset;\n            sym->st_shndx = bss_section->sh_num;\n            offset += sym->st_size;\n            bss_section->data_offset = offset;\n        }\n    }\n}\n\n/* relocate symbol table, resolve undefined symbols if do_resolve is\n   true and output error if undefined symbol. */\nstatic void relocate_syms(TCCState *s1, int do_resolve)\n{\n    Elf32_Sym *sym, *esym, *sym_end;\n    int sym_bind, sh_num, sym_index;\n    const char *name;\n    unsigned long addr;\n\n    sym_end = (Elf32_Sym *)(symtab_section->data + symtab_section->data_offset);\n    for(sym = (Elf32_Sym *)symtab_section->data + 1; \n        sym < sym_end;\n        sym++) {\n        sh_num = sym->st_shndx;\n        if (sh_num == SHN_UNDEF) {\n            name = strtab_section->data + sym->st_name;\n            if (do_resolve) {\n                name = symtab_section->link->data + sym->st_name;\n                addr = (unsigned long)resolve_sym(s1, name, ELF32_ST_TYPE(sym->st_info));\n                if (addr) {\n                    sym->st_value = addr;\n                    goto found;\n                }\n            } else if (s1->dynsym) {\n                /* if dynamic symbol exist, then use it */\n                sym_index = find_elf_sym(s1->dynsym, name);\n                if (sym_index) {\n                    esym = &((Elf32_Sym *)s1->dynsym->data)[sym_index];\n                    sym->st_value = esym->st_value;\n                    goto found;\n                }\n            }\n            /* XXX: _fp_hw seems to be part of the ABI, so we ignore\n               it */\n            if (!strcmp(name, \"_fp_hw\"))\n                goto found;\n            /* only weak symbols are accepted to be undefined. Their\n               value is zero */\n            sym_bind = ELF32_ST_BIND(sym->st_info);\n            if (sym_bind == STB_WEAK) {\n                sym->st_value = 0;\n            } else {\n                error_noabort(\"undefined symbol '%s'\", name);\n            }\n        } else if (sh_num < SHN_LORESERVE) {\n            /* add section base */\n            sym->st_value += s1->sections[sym->st_shndx]->sh_addr;\n        }\n    found: ;\n    }\n}\n\n/* relocate a given section (CPU dependent) */\nstatic void relocate_section(TCCState *s1, Section *s)\n{\n    Section *sr;\n    Elf32_Rel *rel, *rel_end, *qrel;\n    Elf32_Sym *sym;\n    int type, sym_index;\n    unsigned char *ptr;\n    unsigned long val, addr;\n#if defined(TCC_TARGET_I386)\n    int esym_index;\n#endif\n\n    sr = s->reloc;\n    rel_end = (Elf32_Rel *)(sr->data + sr->data_offset);\n    qrel = (Elf32_Rel *)sr->data;\n    for(rel = qrel;\n        rel < rel_end;\n        rel++) {\n        ptr = s->data + rel->r_offset;\n\n        sym_index = ELF32_R_SYM(rel->r_info);\n        sym = &((Elf32_Sym *)symtab_section->data)[sym_index];\n        val = sym->st_value;\n        type = ELF32_R_TYPE(rel->r_info);\n        addr = s->sh_addr + rel->r_offset;\n\n        /* CPU specific */\n        switch(type) {\n#if defined(TCC_TARGET_I386)\n        case R_386_32:\n            if (s1->output_type == TCC_OUTPUT_DLL) {\n                esym_index = s1->symtab_to_dynsym[sym_index];\n                qrel->r_offset = rel->r_offset;\n                if (esym_index) {\n                    qrel->r_info = ELF32_R_INFO(esym_index, R_386_32);\n                    qrel++;\n                    break;\n                } else {\n                    qrel->r_info = ELF32_R_INFO(0, R_386_RELATIVE);\n                    qrel++;\n                }\n            }\n            *(int *)ptr += val;\n            break;\n        case R_386_PC32:\n            if (s1->output_type == TCC_OUTPUT_DLL) {\n                /* DLL relocation */\n                esym_index = s1->symtab_to_dynsym[sym_index];\n                if (esym_index) {\n                    qrel->r_offset = rel->r_offset;\n                    qrel->r_info = ELF32_R_INFO(esym_index, R_386_PC32);\n                    qrel++;\n                    break;\n                }\n            }\n            *(int *)ptr += val - addr;\n            break;\n        case R_386_PLT32:\n            *(int *)ptr += val - addr;\n            break;\n        case R_386_GLOB_DAT:\n        case R_386_JMP_SLOT:\n            *(int *)ptr = val;\n            break;\n        case R_386_GOTPC:\n            *(int *)ptr += s1->got->sh_addr - addr;\n            break;\n        case R_386_GOTOFF:\n            *(int *)ptr += val - s1->got->sh_addr;\n            break;\n        case R_386_GOT32:\n            /* we load the got offset */\n            *(int *)ptr += s1->got_offsets[sym_index];\n            break;\n#elif defined(TCC_TARGET_ARM)\n\tcase R_ARM_PC24:\n\tcase R_ARM_PLT32:\n\t    {\n                int x;\n                x = (*(int *)ptr)&0xffffff;\n                (*(int *)ptr) &= 0xff000000;\n                if (x & 0x800000)\n                    x -= 0x1000000;\n                x *= 4;\n                x += val - addr;\n                if((x & 3) != 0 || x >= 0x4000000 || x < -0x4000000)\n                    error(\"can't relocate value at %x\",addr);\n                x >>= 2;\n                x &= 0xffffff;\n                (*(int *)ptr) |= x;\n\t    }\n\t    break;\n\tcase R_ARM_ABS32:\n\t    *(int *)ptr += val;\n\t    break;\n\tcase R_ARM_GOTPC:\n\t    *(int *)ptr += s1->got->sh_addr - addr;\n\t    break;\n        case R_ARM_GOT32:\n            /* we load the got offset */\n            *(int *)ptr += s1->got_offsets[sym_index];\n            break;\n\tcase R_ARM_COPY:\n            break;\n\tdefault:\n\t    fprintf(stderr,\"FIXME: handle reloc type %x at %lx [%.8x] to %lx\\n\",\n                    type,addr,(unsigned int )ptr,val);\n            break;\n#elif defined(TCC_TARGET_C67)\n\tcase R_C60_32:\n\t    *(int *)ptr += val;\n\t    break;\n        case R_C60LO16:\n            {\n                uint32_t orig;\n                \n                /* put the low 16 bits of the absolute address */\n                // add to what is already there\n                \n                orig  =   ((*(int *)(ptr  )) >> 7) & 0xffff;\n                orig |=  (((*(int *)(ptr+4)) >> 7) & 0xffff) << 16;\n                \n                //patch both at once - assumes always in pairs Low - High\n                \n                *(int *) ptr    = (*(int *) ptr    & (~(0xffff << 7)) ) |  (((val+orig)      & 0xffff) << 7);\n                *(int *)(ptr+4) = (*(int *)(ptr+4) & (~(0xffff << 7)) ) | ((((val+orig)>>16) & 0xffff) << 7);\n            }\n            break;\n        case R_C60HI16:\n            break;\n        default:\n\t    fprintf(stderr,\"FIXME: handle reloc type %x at %lx [%.8x] to %lx\\n\",\n                    type,addr,(unsigned int )ptr,val);\n            break;\n#else\n#error unsupported processor\n#endif\n        }\n    }\n    /* if the relocation is allocated, we change its symbol table */\n    if (sr->sh_flags & SHF_ALLOC)\n        sr->link = s1->dynsym;\n}\n\n/* relocate relocation table in 'sr' */\nstatic void relocate_rel(TCCState *s1, Section *sr)\n{\n    Section *s;\n    Elf32_Rel *rel, *rel_end;\n    \n    s = s1->sections[sr->sh_info];\n    rel_end = (Elf32_Rel *)(sr->data + sr->data_offset);\n    for(rel = (Elf32_Rel *)sr->data;\n        rel < rel_end;\n        rel++) {\n        rel->r_offset += s->sh_addr;\n    }\n}\n\n/* count the number of dynamic relocations so that we can reserve\n   their space */\nstatic int prepare_dynamic_rel(TCCState *s1, Section *sr)\n{\n    Elf32_Rel *rel, *rel_end;\n    int sym_index, esym_index, type, count;\n\n    count = 0;\n    rel_end = (Elf32_Rel *)(sr->data + sr->data_offset);\n    for(rel = (Elf32_Rel *)sr->data; rel < rel_end; rel++) {\n        sym_index = ELF32_R_SYM(rel->r_info);\n        type = ELF32_R_TYPE(rel->r_info);\n        switch(type) {\n        case R_386_32:\n            count++;\n            break;\n        case R_386_PC32:\n            esym_index = s1->symtab_to_dynsym[sym_index];\n            if (esym_index)\n                count++;\n            break;\n        default:\n            break;\n        }\n    }\n    if (count) {\n        /* allocate the section */\n        sr->sh_flags |= SHF_ALLOC;\n        sr->sh_size = count * sizeof(Elf32_Rel);\n    }\n    return count;\n}\n\nstatic void put_got_offset(TCCState *s1, int index, unsigned long val)\n{\n    int n;\n    unsigned long *tab;\n\n    if (index >= s1->nb_got_offsets) {\n        /* find immediately bigger power of 2 and reallocate array */\n        n = 1;\n        while (index >= n)\n            n *= 2;\n        tab = tcc_realloc(s1->got_offsets, n * sizeof(unsigned long));\n        if (!tab)\n            error(\"memory full\");\n        s1->got_offsets = tab;\n        memset(s1->got_offsets + s1->nb_got_offsets, 0,\n               (n - s1->nb_got_offsets) * sizeof(unsigned long));\n        s1->nb_got_offsets = n;\n    }\n    s1->got_offsets[index] = val;\n}\n\n/* XXX: suppress that */\nstatic void put32(unsigned char *p, uint32_t val)\n{\n    p[0] = val;\n    p[1] = val >> 8;\n    p[2] = val >> 16;\n    p[3] = val >> 24;\n}\n\n#if defined(TCC_TARGET_I386) || defined(TCC_TARGET_ARM)\nstatic uint32_t get32(unsigned char *p)\n{\n    return p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);\n}\n#endif\n\nstatic void build_got(TCCState *s1)\n{\n    unsigned char *ptr;\n\n    /* if no got, then create it */\n    s1->got = new_section(s1, \".got\", SHT_PROGBITS, SHF_ALLOC | SHF_WRITE);\n    s1->got->sh_entsize = 4;\n    add_elf_sym(symtab_section, 0, 4, ELF32_ST_INFO(STB_GLOBAL, STT_OBJECT), \n                0, s1->got->sh_num, \"_GLOBAL_OFFSET_TABLE_\");\n    ptr = section_ptr_add(s1->got, 3 * sizeof(int));\n    /* keep space for _DYNAMIC pointer, if present */\n    put32(ptr, 0);\n    /* two dummy got entries */\n    put32(ptr + 4, 0);\n    put32(ptr + 8, 0);\n}\n\n/* put a got entry corresponding to a symbol in symtab_section. 'size'\n   and 'info' can be modified if more precise info comes from the DLL */\nstatic void put_got_entry(TCCState *s1,\n                          int reloc_type, unsigned long size, int info, \n                          int sym_index)\n{\n    int index;\n    const char *name;\n    Elf32_Sym *sym;\n    unsigned long offset;\n    int *ptr;\n\n    if (!s1->got)\n        build_got(s1);\n\n    /* if a got entry already exists for that symbol, no need to add one */\n    if (sym_index < s1->nb_got_offsets &&\n        s1->got_offsets[sym_index] != 0)\n        return;\n    \n    put_got_offset(s1, sym_index, s1->got->data_offset);\n\n    if (s1->dynsym) {\n        sym = &((Elf32_Sym *)symtab_section->data)[sym_index];\n        name = symtab_section->link->data + sym->st_name;\n        offset = sym->st_value;\n#ifdef TCC_TARGET_I386\n        if (reloc_type == R_386_JMP_SLOT) {\n            Section *plt;\n            uint8_t *p;\n            int modrm;\n\n            /* if we build a DLL, we add a %ebx offset */\n            if (s1->output_type == TCC_OUTPUT_DLL)\n                modrm = 0xa3;\n            else\n                modrm = 0x25;\n\n            /* add a PLT entry */\n            plt = s1->plt;\n            if (plt->data_offset == 0) {\n                /* first plt entry */\n                p = section_ptr_add(plt, 16);\n                p[0] = 0xff; /* pushl got + 4 */\n                p[1] = modrm + 0x10;\n                put32(p + 2, 4);\n                p[6] = 0xff; /* jmp *(got + 8) */\n                p[7] = modrm;\n                put32(p + 8, 8);\n            }\n\n            p = section_ptr_add(plt, 16);\n            p[0] = 0xff; /* jmp *(got + x) */\n            p[1] = modrm;\n            put32(p + 2, s1->got->data_offset);\n            p[6] = 0x68; /* push $xxx */\n            put32(p + 7, (plt->data_offset - 32) >> 1);\n            p[11] = 0xe9; /* jmp plt_start */\n            put32(p + 12, -(plt->data_offset));\n\n            /* the symbol is modified so that it will be relocated to\n               the PLT */\n            if (s1->output_type == TCC_OUTPUT_EXE)\n                offset = plt->data_offset - 16;\n        }\n#elif defined(TCC_TARGET_ARM)\n\tif (reloc_type == R_ARM_JUMP_SLOT) {\n            Section *plt;\n            uint8_t *p;\n            \n            /* if we build a DLL, we add a %ebx offset */\n            if (s1->output_type == TCC_OUTPUT_DLL)\n                error(\"DLLs unimplemented!\");\n\n            /* add a PLT entry */\n            plt = s1->plt;\n            if (plt->data_offset == 0) {\n                /* first plt entry */\n                p = section_ptr_add(plt, 16);\n\t\tput32(p     , 0xe52de004);\n\t\tput32(p +  4, 0xe59fe010);\n\t\tput32(p +  8, 0xe08fe00e);\n\t\tput32(p + 12, 0xe5bef008);\n            }\n\n            p = section_ptr_add(plt, 16);\n\t    put32(p  , 0xe59fc004);\n\t    put32(p+4, 0xe08fc00c);\n\t    put32(p+8, 0xe59cf000);\n\t    put32(p+12, s1->got->data_offset);\n\n            /* the symbol is modified so that it will be relocated to\n               the PLT */\n            if (s1->output_type == TCC_OUTPUT_EXE)\n                offset = plt->data_offset - 16;\n        }\n#elif defined(TCC_TARGET_C67)\n        error(\"C67 got not implemented\");\n#else\n#error unsupported CPU\n#endif\n        index = put_elf_sym(s1->dynsym, offset, \n                            size, info, 0, sym->st_shndx, name);\n        /* put a got entry */\n        put_elf_reloc(s1->dynsym, s1->got, \n                      s1->got->data_offset, \n                      reloc_type, index);\n    }\n    ptr = section_ptr_add(s1->got, sizeof(int));\n    *ptr = 0;\n}\n\n/* build GOT and PLT entries */\nstatic void build_got_entries(TCCState *s1)\n{\n    Section *s, *symtab __attribute__((unused));\n    Elf32_Rel *rel, *rel_end;\n    Elf32_Sym *sym;\n    int i, type, reloc_type, sym_index;\n\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (s->sh_type != SHT_REL)\n            continue;\n        /* no need to handle got relocations */\n        if (s->link != symtab_section)\n            continue;\n        symtab = s->link;\n        rel_end = (Elf32_Rel *)(s->data + s->data_offset);\n        for(rel = (Elf32_Rel *)s->data;\n            rel < rel_end;\n            rel++) {\n            type = ELF32_R_TYPE(rel->r_info);\n            switch(type) {\n#if defined(TCC_TARGET_I386)\n            case R_386_GOT32:\n            case R_386_GOTOFF:\n            case R_386_GOTPC:\n            case R_386_PLT32:\n                if (!s1->got)\n                    build_got(s1);\n                if (type == R_386_GOT32 || type == R_386_PLT32) {\n                    sym_index = ELF32_R_SYM(rel->r_info);\n                    sym = &((Elf32_Sym *)symtab_section->data)[sym_index];\n                    /* look at the symbol got offset. If none, then add one */\n                    if (type == R_386_GOT32)\n                        reloc_type = R_386_GLOB_DAT;\n                    else\n                        reloc_type = R_386_JMP_SLOT;\n                    put_got_entry(s1, reloc_type, sym->st_size, sym->st_info, \n                                  sym_index);\n                }\n                break;\n#elif defined(TCC_TARGET_ARM)\n\t    case R_ARM_GOT32:\n            case R_ARM_GOTOFF:\n            case R_ARM_GOTPC:\n            case R_ARM_PLT32:\n                if (!s1->got)\n                    build_got(s1);\n                if (type == R_ARM_GOT32 || type == R_ARM_PLT32) {\n                    sym_index = ELF32_R_SYM(rel->r_info);\n                    sym = &((Elf32_Sym *)symtab_section->data)[sym_index];\n                    /* look at the symbol got offset. If none, then add one */\n                    if (type == R_ARM_GOT32)\n                        reloc_type = R_ARM_GLOB_DAT;\n                    else\n                        reloc_type = R_ARM_JUMP_SLOT;\n                    put_got_entry(s1, reloc_type, sym->st_size, sym->st_info, \n                                  sym_index);\n                }\n                break;\n#elif defined(TCC_TARGET_C67)\n\t    case R_C60_GOT32:\n            case R_C60_GOTOFF:\n            case R_C60_GOTPC:\n            case R_C60_PLT32:\n                if (!s1->got)\n                    build_got(s1);\n                if (type == R_C60_GOT32 || type == R_C60_PLT32) {\n                    sym_index = ELF32_R_SYM(rel->r_info);\n                    sym = &((Elf32_Sym *)symtab_section->data)[sym_index];\n                    /* look at the symbol got offset. If none, then add one */\n                    if (type == R_C60_GOT32)\n                        reloc_type = R_C60_GLOB_DAT;\n                    else\n                        reloc_type = R_C60_JMP_SLOT;\n                    put_got_entry(s1, reloc_type, sym->st_size, sym->st_info, \n                                  sym_index);\n                }\n                break;\n#else\n#error unsupported CPU\n#endif\n            default:\n                break;\n            }\n        }\n    }\n}\n\nstatic Section *new_symtab(TCCState *s1,\n                           const char *symtab_name, int sh_type, int sh_flags,\n                           const char *strtab_name, \n                           const char *hash_name, int hash_sh_flags)\n{\n    Section *symtab, *strtab, *hash;\n    int *ptr, nb_buckets;\n\n    symtab = new_section(s1, symtab_name, sh_type, sh_flags);\n    symtab->sh_entsize = sizeof(Elf32_Sym);\n    strtab = new_section(s1, strtab_name, SHT_STRTAB, sh_flags);\n    put_elf_str(strtab, \"\");\n    symtab->link = strtab;\n    put_elf_sym(symtab, 0, 0, 0, 0, 0, NULL);\n    \n    nb_buckets = 1;\n\n    hash = new_section(s1, hash_name, SHT_HASH, hash_sh_flags);\n    hash->sh_entsize = sizeof(int);\n    symtab->hash = hash;\n    hash->link = symtab;\n\n    ptr = section_ptr_add(hash, (2 + nb_buckets + 1) * sizeof(int));\n    ptr[0] = nb_buckets;\n    ptr[1] = 1;\n    memset(ptr + 2, 0, (nb_buckets + 1) * sizeof(int));\n    return symtab;\n}\n\n/* put dynamic tag */\nstatic void put_dt(Section *dynamic, int dt, unsigned long val)\n{\n    Elf32_Dyn *dyn;\n    dyn = section_ptr_add(dynamic, sizeof(Elf32_Dyn));\n    dyn->d_tag = dt;\n    dyn->d_un.d_val = val;\n}\n\nstatic void add_init_array_defines(TCCState *s1, const char *section_name)\n{\n    Section *s;\n    long end_offset;\n    char sym_start[1024];\n    char sym_end[1024];\n    \n    snprintf(sym_start, sizeof(sym_start), \"__%s_start\", section_name + 1);\n    snprintf(sym_end, sizeof(sym_end), \"__%s_end\", section_name + 1);\n\n    s = find_section(s1, section_name);\n    if (!s) {\n        end_offset = 0;\n        s = data_section;\n    } else {\n        end_offset = s->data_offset;\n    }\n\n    add_elf_sym(symtab_section, \n                0, 0,\n                ELF32_ST_INFO(STB_GLOBAL, STT_NOTYPE), 0,\n                s->sh_num, sym_start);\n    add_elf_sym(symtab_section, \n                end_offset, 0,\n                ELF32_ST_INFO(STB_GLOBAL, STT_NOTYPE), 0,\n                s->sh_num, sym_end);\n}\n\n/* add tcc runtime libraries */\nstatic void tcc_add_runtime(TCCState *s1)\n{\n    char buf[1024];\n\n#ifdef CONFIG_TCC_BCHECK\n    if (do_bounds_check) {\n        unsigned long *ptr;\n        Section *init_section;\n        unsigned char *pinit;\n        int sym_index;\n\n        /* XXX: add an object file to do that */\n        ptr = section_ptr_add(bounds_section, sizeof(unsigned long));\n        *ptr = 0;\n        add_elf_sym(symtab_section, 0, 0, \n                    ELF32_ST_INFO(STB_GLOBAL, STT_NOTYPE), 0,\n                    bounds_section->sh_num, \"__bounds_start\");\n        /* add bound check code */\n        snprintf(buf, sizeof(buf), \"%s/%s\", tcc_lib_path, \"bcheck.o\");\n        tcc_add_file(s1, buf);\n#ifdef TCC_TARGET_I386\n        if (s1->output_type != TCC_OUTPUT_MEMORY) {\n            /* add 'call __bound_init()' in .init section */\n            init_section = find_section(s1, \".init\");\n            pinit = section_ptr_add(init_section, 5);\n            pinit[0] = 0xe8;\n            put32(pinit + 1, -4);\n            sym_index = find_elf_sym(symtab_section, \"__bound_init\");\n            put_elf_reloc(symtab_section, init_section, \n                          init_section->data_offset - 4, R_386_PC32, sym_index);\n        }\n#endif\n    }\n#endif\n    /* add libc */\n    if (!s1->nostdlib) {\n        tcc_add_library(s1, \"c\");\n\n        snprintf(buf, sizeof(buf), \"%s/%s\", tcc_lib_path, \"libtcc1.a\");\n        tcc_add_file(s1, buf);\n    }\n    /* add crt end if not memory output */\n    if (s1->output_type != TCC_OUTPUT_MEMORY && !s1->nostdlib) {\n        tcc_add_file(s1, CONFIG_TCC_CRT_PREFIX \"/crtn.o\");\n    }\n}\n\n/* add various standard linker symbols (must be done after the\n   sections are filled (for example after allocating common\n   symbols)) */\nstatic void tcc_add_linker_symbols(TCCState *s1)\n{\n    char buf[1024];\n    int i;\n    Section *s;\n\n    add_elf_sym(symtab_section, \n                text_section->data_offset, 0,\n                ELF32_ST_INFO(STB_GLOBAL, STT_NOTYPE), 0,\n                text_section->sh_num, \"_etext\");\n    add_elf_sym(symtab_section, \n                data_section->data_offset, 0,\n                ELF32_ST_INFO(STB_GLOBAL, STT_NOTYPE), 0,\n                data_section->sh_num, \"_edata\");\n    add_elf_sym(symtab_section, \n                bss_section->data_offset, 0,\n                ELF32_ST_INFO(STB_GLOBAL, STT_NOTYPE), 0,\n                bss_section->sh_num, \"_end\");\n    /* horrible new standard ldscript defines */\n    add_init_array_defines(s1, \".preinit_array\");\n    add_init_array_defines(s1, \".init_array\");\n    add_init_array_defines(s1, \".fini_array\");\n    \n    /* add start and stop symbols for sections whose name can be\n       expressed in C */\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (s->sh_type == SHT_PROGBITS &&\n            (s->sh_flags & SHF_ALLOC)) {\n            const char *p;\n            int ch;\n\n            /* check if section name can be expressed in C */\n            p = s->name;\n            for(;;) {\n                ch = *p;\n                if (!ch)\n                    break;\n                if (!isid(ch) && !isnum(ch))\n                    goto next_sec;\n                p++;\n            }\n            snprintf(buf, sizeof(buf), \"__start_%s\", s->name);\n            add_elf_sym(symtab_section, \n                        0, 0,\n                        ELF32_ST_INFO(STB_GLOBAL, STT_NOTYPE), 0,\n                        s->sh_num, buf);\n            snprintf(buf, sizeof(buf), \"__stop_%s\", s->name);\n            add_elf_sym(symtab_section,\n                        s->data_offset, 0,\n                        ELF32_ST_INFO(STB_GLOBAL, STT_NOTYPE), 0,\n                        s->sh_num, buf);\n        }\n    next_sec: ;\n    }\n}\n\n/* name of ELF interpreter */\n#ifdef __FreeBSD__\nstatic char elf_interp[] = \"/usr/libexec/ld-elf.so.1\";\n#else\nstatic char elf_interp[] = \"/lib/ld-linux.so.2\";\n#endif\n\nstatic void tcc_output_binary(TCCState *s1, FILE *f,\n                              const int *section_order)\n{\n    Section *s;\n    int i, offset, size;\n\n    offset = 0;\n    for(i=1;i<s1->nb_sections;i++) {\n        s = s1->sections[section_order[i]];\n        if (s->sh_type != SHT_NOBITS &&\n            (s->sh_flags & SHF_ALLOC)) {\n            while (offset < s->sh_offset) {\n                fputc(0, f);\n                offset++;\n            }\n            size = s->sh_size;\n            dummy_size_t = fwrite(s->data, 1, size, f);\n            offset += size;\n        }\n    }\n}\n\n/* output an ELF file */\n/* XXX: suppress unneeded sections */\nint tcc_output_file(TCCState *s1, const char *filename)\n{\n    Elf32_Ehdr ehdr;\n    FILE *f;\n    int fd, mode, ret;\n    int *section_order;\n    int shnum, i, phnum, file_offset, offset, size, j, tmp, sh_order_index, k;\n    unsigned long addr;\n    Section *strsec, *s;\n    Elf32_Shdr shdr, *sh;\n    Elf32_Phdr *phdr, *ph;\n    Section *interp, *dynamic, *dynstr;\n    unsigned long saved_dynamic_data_offset;\n    Elf32_Sym *sym;\n    int type, file_type;\n    unsigned long rel_addr, rel_size;\n    \n    file_type = s1->output_type;\n    s1->nb_errors = 0;\n\n    if (file_type != TCC_OUTPUT_OBJ) {\n        tcc_add_runtime(s1);\n    }\n\n    phdr = NULL;\n    section_order = NULL;\n    interp = NULL;\n    dynamic = NULL;\n    dynstr = NULL; /* avoid warning */\n    saved_dynamic_data_offset = 0; /* avoid warning */\n    \n    if (file_type != TCC_OUTPUT_OBJ) {\n        relocate_common_syms();\n\n        tcc_add_linker_symbols(s1);\n\n        if (!s1->static_link) {\n            const char *name;\n            int sym_index, index;\n            Elf32_Sym *esym, *sym_end;\n            \n            if (file_type == TCC_OUTPUT_EXE) {\n                char *ptr;\n                /* add interpreter section only if executable */\n                interp = new_section(s1, \".interp\", SHT_PROGBITS, SHF_ALLOC);\n                interp->sh_addralign = 1;\n                ptr = section_ptr_add(interp, sizeof(elf_interp));\n                strcpy(ptr, elf_interp);\n            }\n        \n            /* add dynamic symbol table */\n            s1->dynsym = new_symtab(s1, \".dynsym\", SHT_DYNSYM, SHF_ALLOC,\n                                    \".dynstr\", \n                                    \".hash\", SHF_ALLOC);\n            dynstr = s1->dynsym->link;\n            \n            /* add dynamic section */\n            dynamic = new_section(s1, \".dynamic\", SHT_DYNAMIC, \n                                  SHF_ALLOC | SHF_WRITE);\n            dynamic->link = dynstr;\n            dynamic->sh_entsize = sizeof(Elf32_Dyn);\n        \n            /* add PLT */\n            s1->plt = new_section(s1, \".plt\", SHT_PROGBITS, \n                                  SHF_ALLOC | SHF_EXECINSTR);\n            s1->plt->sh_entsize = 4;\n\n            build_got(s1);\n\n            /* scan for undefined symbols and see if they are in the\n               dynamic symbols. If a symbol STT_FUNC is found, then we\n               add it in the PLT. If a symbol STT_OBJECT is found, we\n               add it in the .bss section with a suitable relocation */\n            sym_end = (Elf32_Sym *)(symtab_section->data + \n                                    symtab_section->data_offset);\n            if (file_type == TCC_OUTPUT_EXE) {\n                for(sym = (Elf32_Sym *)symtab_section->data + 1; \n                    sym < sym_end;\n                    sym++) {\n                    if (sym->st_shndx == SHN_UNDEF) {\n                        name = symtab_section->link->data + sym->st_name;\n                        sym_index = find_elf_sym(s1->dynsymtab_section, name);\n                        if (sym_index) {\n                            esym = &((Elf32_Sym *)s1->dynsymtab_section->data)[sym_index];\n                            type = ELF32_ST_TYPE(esym->st_info);\n                            if (type == STT_FUNC) {\n                                put_got_entry(s1, R_JMP_SLOT, esym->st_size, \n                                              esym->st_info, \n                                              sym - (Elf32_Sym *)symtab_section->data);\n                            } else if (type == STT_OBJECT) {\n                                unsigned long offset;\n                                offset = bss_section->data_offset;\n                                /* XXX: which alignment ? */\n                                offset = (offset + 16 - 1) & -16;\n                                index = put_elf_sym(s1->dynsym, offset, esym->st_size, \n                                                    esym->st_info, 0, \n                                                    bss_section->sh_num, name);\n                                put_elf_reloc(s1->dynsym, bss_section, \n                                              offset, R_COPY, index);\n                                offset += esym->st_size;\n                                bss_section->data_offset = offset;\n                            }\n                        } else {\n                                /* STB_WEAK undefined symbols are accepted */\n                                /* XXX: _fp_hw seems to be part of the ABI, so we ignore\n                                   it */\n                            if (ELF32_ST_BIND(sym->st_info) == STB_WEAK ||\n                                !strcmp(name, \"_fp_hw\")) {\n                            } else {\n                                error_noabort(\"undefined symbol '%s'\", name);\n                            }\n                        }\n                    } else if (s1->rdynamic && \n                               ELF32_ST_BIND(sym->st_info) != STB_LOCAL) {\n                        /* if -rdynamic option, then export all non\n                           local symbols */\n                        name = symtab_section->link->data + sym->st_name;\n                        put_elf_sym(s1->dynsym, sym->st_value, sym->st_size, \n                                    sym->st_info, 0, \n                                    sym->st_shndx, name);\n                    }\n                }\n            \n                if (s1->nb_errors)\n                    goto fail;\n\n                /* now look at unresolved dynamic symbols and export\n                   corresponding symbol */\n                sym_end = (Elf32_Sym *)(s1->dynsymtab_section->data + \n                                        s1->dynsymtab_section->data_offset);\n                for(esym = (Elf32_Sym *)s1->dynsymtab_section->data + 1; \n                    esym < sym_end;\n                    esym++) {\n                    if (esym->st_shndx == SHN_UNDEF) {\n                        name = s1->dynsymtab_section->link->data + esym->st_name;\n                        sym_index = find_elf_sym(symtab_section, name);\n                        if (sym_index) {\n                            /* XXX: avoid adding a symbol if already\n                               present because of -rdynamic ? */\n                            sym = &((Elf32_Sym *)symtab_section->data)[sym_index];\n                            put_elf_sym(s1->dynsym, sym->st_value, sym->st_size, \n                                        sym->st_info, 0, \n                                        sym->st_shndx, name);\n                        } else {\n                            if (ELF32_ST_BIND(esym->st_info) == STB_WEAK) {\n                                /* weak symbols can stay undefined */\n                            } else {\n                                warning(\"undefined dynamic symbol '%s'\", name);\n                            }\n                        }\n                    }\n                }\n            } else {\n                int nb_syms;\n                /* shared library case : we simply export all the global symbols */\n                nb_syms = symtab_section->data_offset / sizeof(Elf32_Sym);\n                s1->symtab_to_dynsym = tcc_mallocz(sizeof(int) * nb_syms);\n                for(sym = (Elf32_Sym *)symtab_section->data + 1; \n                    sym < sym_end;\n                    sym++) {\n                    if (ELF32_ST_BIND(sym->st_info) != STB_LOCAL) {\n                        name = symtab_section->link->data + sym->st_name;\n                        index = put_elf_sym(s1->dynsym, sym->st_value, sym->st_size, \n                                            sym->st_info, 0, \n                                            sym->st_shndx, name);\n                        s1->symtab_to_dynsym[sym - \n                                            (Elf32_Sym *)symtab_section->data] = \n                            index;\n                    }\n                }\n            }\n\n            build_got_entries(s1);\n        \n            /* add a list of needed dlls */\n            for(i = 0; i < s1->nb_loaded_dlls; i++) {\n                DLLReference *dllref = s1->loaded_dlls[i];\n                if (dllref->level == 0)\n                    put_dt(dynamic, DT_NEEDED, put_elf_str(dynstr, dllref->name));\n            }\n            /* XXX: currently, since we do not handle PIC code, we\n               must relocate the readonly segments */\n            if (file_type == TCC_OUTPUT_DLL)\n                put_dt(dynamic, DT_TEXTREL, 0);\n\n            /* add necessary space for other entries */\n            saved_dynamic_data_offset = dynamic->data_offset;\n            dynamic->data_offset += 8 * 9;\n        } else {\n            /* still need to build got entries in case of static link */\n            build_got_entries(s1);\n        }\n    }\n\n    memset(&ehdr, 0, sizeof(ehdr));\n\n    /* we add a section for symbols */\n    strsec = new_section(s1, \".shstrtab\", SHT_STRTAB, 0);\n    put_elf_str(strsec, \"\");\n    \n    /* compute number of sections */\n    shnum = s1->nb_sections;\n\n    /* this array is used to reorder sections in the output file */\n    section_order = tcc_malloc(sizeof(int) * shnum);\n    section_order[0] = 0;\n    sh_order_index = 1;\n    \n    /* compute number of program headers */\n    switch(file_type) {\n    default:\n    case TCC_OUTPUT_OBJ:\n        phnum = 0;\n        break;\n    case TCC_OUTPUT_EXE:\n        if (!s1->static_link)\n            phnum = 4;\n        else\n            phnum = 2;\n        break;\n    case TCC_OUTPUT_DLL:\n        phnum = 3;\n        break;\n    }\n\n    /* allocate strings for section names and decide if an unallocated\n       section should be output */\n    /* NOTE: the strsec section comes last, so its size is also\n       correct ! */\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        s->sh_name = put_elf_str(strsec, s->name);\n        /* when generating a DLL, we include relocations but we may\n           patch them */\n        if (file_type == TCC_OUTPUT_DLL && \n            s->sh_type == SHT_REL && \n            !(s->sh_flags & SHF_ALLOC)) {\n            prepare_dynamic_rel(s1, s);\n        } else if (do_debug || \n            file_type == TCC_OUTPUT_OBJ || \n            (s->sh_flags & SHF_ALLOC) ||\n            i == (s1->nb_sections - 1)) {\n            /* we output all sections if debug or object file */\n            s->sh_size = s->data_offset;\n        }\n    }\n\n    /* allocate program segment headers */\n    phdr = tcc_mallocz(phnum * sizeof(Elf32_Phdr));\n        \n    if (s1->output_format == TCC_OUTPUT_FORMAT_ELF) {\n        file_offset = sizeof(Elf32_Ehdr) + phnum * sizeof(Elf32_Phdr);\n    } else {\n        file_offset = 0;\n    }\n    if (phnum > 0) {\n        /* compute section to program header mapping */\n        if (s1->has_text_addr) { \n            int a_offset, p_offset;\n            addr = s1->text_addr;\n            /* we ensure that (addr % ELF_PAGE_SIZE) == file_offset %\n               ELF_PAGE_SIZE */\n            a_offset = addr & (ELF_PAGE_SIZE - 1);\n            p_offset = file_offset & (ELF_PAGE_SIZE - 1);\n            if (a_offset < p_offset) \n                a_offset += ELF_PAGE_SIZE;\n            file_offset += (a_offset - p_offset);\n        } else {\n            if (file_type == TCC_OUTPUT_DLL)\n                addr = 0;\n            else\n                addr = ELF_START_ADDR;\n            /* compute address after headers */\n            addr += (file_offset & (ELF_PAGE_SIZE - 1));\n        }\n        \n        /* dynamic relocation table information, for .dynamic section */\n        rel_size = 0;\n        rel_addr = 0;\n\n        /* leave one program header for the program interpreter */\n        ph = &phdr[0];\n        if (interp)\n            ph++;\n\n        for(j = 0; j < 2; j++) {\n            ph->p_type = PT_LOAD;\n            if (j == 0)\n                ph->p_flags = PF_R | PF_X;\n            else\n                ph->p_flags = PF_R | PF_W;\n            ph->p_align = ELF_PAGE_SIZE;\n            \n            /* we do the following ordering: interp, symbol tables,\n               relocations, progbits, nobits */\n            /* XXX: do faster and simpler sorting */\n            for(k = 0; k < 5; k++) {\n                for(i = 1; i < s1->nb_sections; i++) {\n                    s = s1->sections[i];\n                    /* compute if section should be included */\n                    if (j == 0) {\n                        if ((s->sh_flags & (SHF_ALLOC | SHF_WRITE)) != \n                            SHF_ALLOC)\n                            continue;\n                    } else {\n                        if ((s->sh_flags & (SHF_ALLOC | SHF_WRITE)) != \n                            (SHF_ALLOC | SHF_WRITE))\n                            continue;\n                    }\n                    if (s == interp) {\n                        if (k != 0)\n                            continue;\n                    } else if (s->sh_type == SHT_DYNSYM ||\n                               s->sh_type == SHT_STRTAB ||\n                               s->sh_type == SHT_HASH) {\n                        if (k != 1)\n                            continue;\n                    } else if (s->sh_type == SHT_REL) {\n                        if (k != 2)\n                            continue;\n                    } else if (s->sh_type == SHT_NOBITS) {\n                        if (k != 4)\n                            continue;\n                    } else {\n                        if (k != 3)\n                            continue;\n                    }\n                    section_order[sh_order_index++] = i;\n\n                    /* section matches: we align it and add its size */\n                    tmp = addr;\n                    addr = (addr + s->sh_addralign - 1) & \n                        ~(s->sh_addralign - 1);\n                    file_offset += addr - tmp;\n                    s->sh_offset = file_offset;\n                    s->sh_addr = addr;\n                    \n                    /* update program header infos */\n                    if (ph->p_offset == 0) {\n                        ph->p_offset = file_offset;\n                        ph->p_vaddr = addr;\n                        ph->p_paddr = ph->p_vaddr;\n                    }\n                    /* update dynamic relocation infos */\n                    if (s->sh_type == SHT_REL) {\n                        if (rel_size == 0)\n                            rel_addr = addr;\n                        rel_size += s->sh_size;\n                    }\n                    addr += s->sh_size;\n                    if (s->sh_type != SHT_NOBITS)\n                        file_offset += s->sh_size;\n                }\n            }\n            ph->p_filesz = file_offset - ph->p_offset;\n            ph->p_memsz = addr - ph->p_vaddr;\n            ph++;\n            if (j == 0) {\n                if (s1->output_format == TCC_OUTPUT_FORMAT_ELF) {\n                    /* if in the middle of a page, we duplicate the page in\n                       memory so that one copy is RX and the other is RW */\n                    if ((addr & (ELF_PAGE_SIZE - 1)) != 0)\n                        addr += ELF_PAGE_SIZE;\n                } else {\n                    addr = (addr + ELF_PAGE_SIZE - 1) & ~(ELF_PAGE_SIZE - 1);\n                    file_offset = (file_offset + ELF_PAGE_SIZE - 1) & \n                        ~(ELF_PAGE_SIZE - 1);\n                }\n            }\n        }\n\n        /* if interpreter, then add corresponding program header */\n        if (interp) {\n            ph = &phdr[0];\n            \n            ph->p_type = PT_INTERP;\n            ph->p_offset = interp->sh_offset;\n            ph->p_vaddr = interp->sh_addr;\n            ph->p_paddr = ph->p_vaddr;\n            ph->p_filesz = interp->sh_size;\n            ph->p_memsz = interp->sh_size;\n            ph->p_flags = PF_R;\n            ph->p_align = interp->sh_addralign;\n        }\n        \n        /* if dynamic section, then add corresponding program header */\n        if (dynamic) {\n            Elf32_Sym *sym_end;\n\n            ph = &phdr[phnum - 1];\n            \n            ph->p_type = PT_DYNAMIC;\n            ph->p_offset = dynamic->sh_offset;\n            ph->p_vaddr = dynamic->sh_addr;\n            ph->p_paddr = ph->p_vaddr;\n            ph->p_filesz = dynamic->sh_size;\n            ph->p_memsz = dynamic->sh_size;\n            ph->p_flags = PF_R | PF_W;\n            ph->p_align = dynamic->sh_addralign;\n\n            /* put GOT dynamic section address */\n            put32(s1->got->data, dynamic->sh_addr);\n\n            /* relocate the PLT */\n            if (file_type == TCC_OUTPUT_EXE) {\n                uint8_t *p, *p_end;\n\n                p = s1->plt->data;\n                p_end = p + s1->plt->data_offset;\n                if (p < p_end) {\n#if defined(TCC_TARGET_I386)\n                    put32(p + 2, get32(p + 2) + s1->got->sh_addr);\n                    put32(p + 8, get32(p + 8) + s1->got->sh_addr);\n                    p += 16;\n                    while (p < p_end) {\n                        put32(p + 2, get32(p + 2) + s1->got->sh_addr);\n                        p += 16;\n                    }\n#elif defined(TCC_TARGET_ARM)\n\t\t    int x;\n\t\t    x=s1->got->sh_addr - s1->plt->sh_addr - 12;\n\t\t    p +=16;\n\t\t    while (p < p_end) {\n\t\t        put32(p + 12, x + get32(p + 12) + s1->plt->data - p);\n\t\t\tp += 16;\n\t\t    }\n#elif defined(TCC_TARGET_C67)\n                    /* XXX: TODO */\n#else\n#error unsupported CPU\n#endif\n                }\n            }\n\n            /* relocate symbols in .dynsym */\n            sym_end = (Elf32_Sym *)(s1->dynsym->data + s1->dynsym->data_offset);\n            for(sym = (Elf32_Sym *)s1->dynsym->data + 1; \n                sym < sym_end;\n                sym++) {\n                if (sym->st_shndx == SHN_UNDEF) {\n                    /* relocate to the PLT if the symbol corresponds\n                       to a PLT entry */\n                    if (sym->st_value)\n                        sym->st_value += s1->plt->sh_addr;\n                } else if (sym->st_shndx < SHN_LORESERVE) {\n                    /* do symbol relocation */\n                    sym->st_value += s1->sections[sym->st_shndx]->sh_addr;\n                }\n            }\n\n            /* put dynamic section entries */\n            dynamic->data_offset = saved_dynamic_data_offset;\n            put_dt(dynamic, DT_HASH, s1->dynsym->hash->sh_addr);\n            put_dt(dynamic, DT_STRTAB, dynstr->sh_addr);\n            put_dt(dynamic, DT_SYMTAB, s1->dynsym->sh_addr);\n            put_dt(dynamic, DT_STRSZ, dynstr->data_offset);\n            put_dt(dynamic, DT_SYMENT, sizeof(Elf32_Sym));\n            put_dt(dynamic, DT_REL, rel_addr);\n            put_dt(dynamic, DT_RELSZ, rel_size);\n            put_dt(dynamic, DT_RELENT, sizeof(Elf32_Rel));\n            put_dt(dynamic, DT_NULL, 0);\n        }\n\n        ehdr.e_phentsize = sizeof(Elf32_Phdr);\n        ehdr.e_phnum = phnum;\n        ehdr.e_phoff = sizeof(Elf32_Ehdr);\n    }\n\n    /* all other sections come after */\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (phnum > 0 && (s->sh_flags & SHF_ALLOC))\n            continue;\n        section_order[sh_order_index++] = i;\n        \n        file_offset = (file_offset + s->sh_addralign - 1) & \n            ~(s->sh_addralign - 1);\n        s->sh_offset = file_offset;\n        if (s->sh_type != SHT_NOBITS)\n            file_offset += s->sh_size;\n    }\n    \n    /* if building executable or DLL, then relocate each section\n       except the GOT which is already relocated */\n    if (file_type != TCC_OUTPUT_OBJ) {\n        relocate_syms(s1, 0);\n\n        if (s1->nb_errors != 0) {\n        fail:\n            ret = -1;\n            goto the_end;\n        }\n\n        /* relocate sections */\n        /* XXX: ignore sections with allocated relocations ? */\n        for(i = 1; i < s1->nb_sections; i++) {\n            s = s1->sections[i];\n            if (s->reloc && s != s1->got)\n                relocate_section(s1, s);\n        }\n\n        /* relocate relocation entries if the relocation tables are\n           allocated in the executable */\n        for(i = 1; i < s1->nb_sections; i++) {\n            s = s1->sections[i];\n            if ((s->sh_flags & SHF_ALLOC) &&\n                s->sh_type == SHT_REL) {\n                relocate_rel(s1, s);\n            }\n        }\n\n        /* get entry point address */\n        if (file_type == TCC_OUTPUT_EXE)\n            ehdr.e_entry = (unsigned long)tcc_get_symbol_err(s1, \"_start\");\n        else\n            ehdr.e_entry = text_section->sh_addr; /* XXX: is it correct ? */\n    }\n\n    /* write elf file */\n    if (file_type == TCC_OUTPUT_OBJ)\n        mode = 0666;\n    else\n        mode = 0777;\n    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, mode); \n    if (fd < 0) {\n        error_noabort(\"could not write '%s'\", filename);\n        goto fail;\n    }\n    f = fdopen(fd, \"wb\");\n\n#ifdef TCC_TARGET_COFF\n    if (s1->output_format == TCC_OUTPUT_FORMAT_COFF) {\n        tcc_output_coff(s1, f);\n    } else\n#endif\n    if (s1->output_format == TCC_OUTPUT_FORMAT_ELF) {\n        sort_syms(s1, symtab_section);\n        \n        /* align to 4 */\n        file_offset = (file_offset + 3) & -4;\n    \n        /* fill header */\n        ehdr.e_ident[0] = ELFMAG0;\n        ehdr.e_ident[1] = ELFMAG1;\n        ehdr.e_ident[2] = ELFMAG2;\n        ehdr.e_ident[3] = ELFMAG3;\n        ehdr.e_ident[4] = ELFCLASS32;\n        ehdr.e_ident[5] = ELFDATA2LSB;\n        ehdr.e_ident[6] = EV_CURRENT;\n#ifdef __FreeBSD__\n        ehdr.e_ident[EI_OSABI] = ELFOSABI_FREEBSD;\n#endif\n#ifdef TCC_TARGET_ARM\n        ehdr.e_ident[EI_OSABI] = ELFOSABI_ARM;\n#endif\n        switch(file_type) {\n        default:\n        case TCC_OUTPUT_EXE:\n            ehdr.e_type = ET_EXEC;\n            break;\n        case TCC_OUTPUT_DLL:\n            ehdr.e_type = ET_DYN;\n            break;\n        case TCC_OUTPUT_OBJ:\n            ehdr.e_type = ET_REL;\n            break;\n        }\n        ehdr.e_machine = EM_TCC_TARGET;\n        ehdr.e_version = EV_CURRENT;\n        ehdr.e_shoff = file_offset;\n        ehdr.e_ehsize = sizeof(Elf32_Ehdr);\n        ehdr.e_shentsize = sizeof(Elf32_Shdr);\n        ehdr.e_shnum = shnum;\n        ehdr.e_shstrndx = shnum - 1;\n        \n        dummy_size_t = fwrite(&ehdr, 1, sizeof(Elf32_Ehdr), f);\n        dummy_size_t = fwrite(phdr, 1, phnum * sizeof(Elf32_Phdr), f);\n        offset = sizeof(Elf32_Ehdr) + phnum * sizeof(Elf32_Phdr);\n\n        for(i=1;i<s1->nb_sections;i++) {\n            s = s1->sections[section_order[i]];\n            if (s->sh_type != SHT_NOBITS) {\n                while (offset < s->sh_offset) {\n                    fputc(0, f);\n                    offset++;\n                }\n                size = s->sh_size;\n                dummy_size_t = fwrite(s->data, 1, size, f);\n                offset += size;\n            }\n        }\n\n        /* output section headers */\n        while (offset < ehdr.e_shoff) {\n            fputc(0, f);\n            offset++;\n        }\n    \n        for(i=0;i<s1->nb_sections;i++) {\n            sh = &shdr;\n            memset(sh, 0, sizeof(Elf32_Shdr));\n            s = s1->sections[i];\n            if (s) {\n                sh->sh_name = s->sh_name;\n                sh->sh_type = s->sh_type;\n                sh->sh_flags = s->sh_flags;\n                sh->sh_entsize = s->sh_entsize;\n                sh->sh_info = s->sh_info;\n                if (s->link)\n                    sh->sh_link = s->link->sh_num;\n                sh->sh_addralign = s->sh_addralign;\n                sh->sh_addr = s->sh_addr;\n                sh->sh_offset = s->sh_offset;\n                sh->sh_size = s->sh_size;\n            }\n            dummy_size_t = fwrite(sh, 1, sizeof(Elf32_Shdr), f);\n        }\n    } else {\n        tcc_output_binary(s1, f, section_order);\n    }\n    fclose(f);\n\n    ret = 0;\n the_end:\n    tcc_free(s1->symtab_to_dynsym);\n    tcc_free(section_order);\n    tcc_free(phdr);\n    tcc_free(s1->got_offsets);\n    return ret;\n}\n\nstatic void *load_data(int fd, unsigned long file_offset, unsigned long size)\n{\n    void *data;\n\n    data = tcc_malloc(size);\n    lseek(fd, file_offset, SEEK_SET);\n    dummy_size_t = read(fd, data, size);\n    return data;\n}\n\ntypedef struct SectionMergeInfo {\n    Section *s;            /* corresponding existing section */\n    unsigned long offset;  /* offset of the new section in the existing section */\n    uint8_t new_section;       /* true if section 's' was added */\n    uint8_t link_once;         /* true if link once section */\n} SectionMergeInfo;\n\n/* load an object file and merge it with current files */\n/* XXX: handle correctly stab (debug) info */\nstatic int tcc_load_object_file(TCCState *s1, \n                                int fd, unsigned long file_offset)\n{ \n    Elf32_Ehdr ehdr;\n    Elf32_Shdr *shdr, *sh;\n    int size, i, j, offset, offseti, nb_syms, sym_index, ret;\n    unsigned char *strsec, *strtab;\n    int *old_to_new_syms;\n    char *sh_name, *name;\n    SectionMergeInfo *sm_table, *sm;\n    Elf32_Sym *sym, *symtab;\n    Elf32_Rel *rel, *rel_end;\n    Section *s;\n\n    if (read(fd, &ehdr, sizeof(ehdr)) != sizeof(ehdr))\n        goto fail1;\n    if (ehdr.e_ident[0] != ELFMAG0 ||\n        ehdr.e_ident[1] != ELFMAG1 ||\n        ehdr.e_ident[2] != ELFMAG2 ||\n        ehdr.e_ident[3] != ELFMAG3)\n        goto fail1;\n    /* test if object file */\n    if (ehdr.e_type != ET_REL)\n        goto fail1;\n    /* test CPU specific stuff */\n    if (ehdr.e_ident[5] != ELFDATA2LSB ||\n        ehdr.e_machine != EM_TCC_TARGET) {\n    fail1:\n        error_noabort(\"invalid object file\");\n        return -1;\n    }\n    /* read sections */\n    shdr = load_data(fd, file_offset + ehdr.e_shoff, \n                     sizeof(Elf32_Shdr) * ehdr.e_shnum);\n    sm_table = tcc_mallocz(sizeof(SectionMergeInfo) * ehdr.e_shnum);\n    \n    /* load section names */\n    sh = &shdr[ehdr.e_shstrndx];\n    strsec = load_data(fd, file_offset + sh->sh_offset, sh->sh_size);\n\n    /* load symtab and strtab */\n    old_to_new_syms = NULL;\n    symtab = NULL;\n    strtab = NULL;\n    nb_syms = 0;\n    for(i = 1; i < ehdr.e_shnum; i++) {\n        sh = &shdr[i];\n        if (sh->sh_type == SHT_SYMTAB) {\n            if (symtab) {\n                error_noabort(\"object must contain only one symtab\");\n            fail:\n                ret = -1;\n                goto the_end;\n            }\n            nb_syms = sh->sh_size / sizeof(Elf32_Sym);\n            symtab = load_data(fd, file_offset + sh->sh_offset, sh->sh_size);\n            sm_table[i].s = symtab_section;\n\n            /* now load strtab */\n            sh = &shdr[sh->sh_link];\n            strtab = load_data(fd, file_offset + sh->sh_offset, sh->sh_size);\n        }\n    }\n        \n    /* now examine each section and try to merge its content with the\n       ones in memory */\n    for(i = 1; i < ehdr.e_shnum; i++) {\n        /* no need to examine section name strtab */\n        if (i == ehdr.e_shstrndx)\n            continue;\n        sh = &shdr[i];\n        sh_name = strsec + sh->sh_name;\n        /* ignore sections types we do not handle */\n        if (sh->sh_type != SHT_PROGBITS &&\n            sh->sh_type != SHT_REL && \n            sh->sh_type != SHT_NOBITS)\n            continue;\n        if (sh->sh_addralign < 1)\n            sh->sh_addralign = 1;\n        /* find corresponding section, if any */\n        for(j = 1; j < s1->nb_sections;j++) {\n            s = s1->sections[j];\n            if (!strcmp(s->name, sh_name)) {\n                if (!strncmp(sh_name, \".gnu.linkonce\", \n                             sizeof(\".gnu.linkonce\") - 1)) {\n                    /* if a 'linkonce' section is already present, we\n                       do not add it again. It is a little tricky as\n                       symbols can still be defined in\n                       it. */\n                    sm_table[i].link_once = 1;\n                    goto next;\n                } else {\n                    goto found;\n                }\n            }\n        }\n        /* not found: create new section */\n        s = new_section(s1, sh_name, sh->sh_type, sh->sh_flags);\n        /* take as much info as possible from the section. sh_link and\n           sh_info will be updated later */\n        s->sh_addralign = sh->sh_addralign;\n        s->sh_entsize = sh->sh_entsize;\n        sm_table[i].new_section = 1;\n    found:\n        if (sh->sh_type != s->sh_type) {\n            error_noabort(\"invalid section type\");\n            goto fail;\n        }\n\n        /* align start of section */\n        offset = s->data_offset;\n        size = sh->sh_addralign - 1;\n        offset = (offset + size) & ~size;\n        if (sh->sh_addralign > s->sh_addralign)\n            s->sh_addralign = sh->sh_addralign;\n        s->data_offset = offset;\n        sm_table[i].offset = offset;\n        sm_table[i].s = s;\n        /* concatenate sections */\n        size = sh->sh_size;\n        if (sh->sh_type != SHT_NOBITS) {\n            unsigned char *ptr;\n            lseek(fd, file_offset + sh->sh_offset, SEEK_SET);\n            ptr = section_ptr_add(s, size);\n            dummy_size_t = read(fd, ptr, size);\n        } else {\n            s->data_offset += size;\n        }\n    next: ;\n    }\n\n    /* second short pass to update sh_link and sh_info fields of new\n       sections */\n    sm = sm_table;\n    for(i = 1; i < ehdr.e_shnum; i++) {\n        s = sm_table[i].s;\n        if (!s || !sm_table[i].new_section)\n            continue;\n        sh = &shdr[i];\n        if (sh->sh_link > 0)\n            s->link = sm_table[sh->sh_link].s;\n        if (sh->sh_type == SHT_REL) {\n            s->sh_info = sm_table[sh->sh_info].s->sh_num;\n            /* update backward link */\n            s1->sections[s->sh_info]->reloc = s;\n        }\n    }\n\n    /* resolve symbols */\n    old_to_new_syms = tcc_mallocz(nb_syms * sizeof(int));\n\n    sym = symtab + 1;\n    for(i = 1; i < nb_syms; i++, sym++) {\n        if (sym->st_shndx != SHN_UNDEF &&\n            sym->st_shndx < SHN_LORESERVE) {\n            sm = &sm_table[sym->st_shndx];\n            if (sm->link_once) {\n                /* if a symbol is in a link once section, we use the\n                   already defined symbol. It is very important to get\n                   correct relocations */\n                if (ELF32_ST_BIND(sym->st_info) != STB_LOCAL) {\n                    name = strtab + sym->st_name;\n                    sym_index = find_elf_sym(symtab_section, name);\n                    if (sym_index)\n                        old_to_new_syms[i] = sym_index;\n                }\n                continue;\n            }\n            /* if no corresponding section added, no need to add symbol */\n            if (!sm->s)\n                continue;\n            /* convert section number */\n            sym->st_shndx = sm->s->sh_num;\n            /* offset value */\n            sym->st_value += sm->offset;\n        }\n        /* add symbol */\n        name = strtab + sym->st_name;\n        sym_index = add_elf_sym(symtab_section, sym->st_value, sym->st_size, \n                                sym->st_info, sym->st_other, \n                                sym->st_shndx, name);\n        old_to_new_syms[i] = sym_index;\n    }\n\n    /* third pass to patch relocation entries */\n    for(i = 1; i < ehdr.e_shnum; i++) {\n        s = sm_table[i].s;\n        if (!s)\n            continue;\n        sh = &shdr[i];\n        offset = sm_table[i].offset;\n        switch(s->sh_type) {\n        case SHT_REL:\n            /* take relocation offset information */\n            offseti = sm_table[sh->sh_info].offset;\n            rel_end = (Elf32_Rel *)(s->data + s->data_offset);\n            for(rel = (Elf32_Rel *)(s->data + offset);\n                rel < rel_end;\n                rel++) {\n                int type;\n                unsigned sym_index;\n                /* convert symbol index */\n                type = ELF32_R_TYPE(rel->r_info);\n                sym_index = ELF32_R_SYM(rel->r_info);\n                /* NOTE: only one symtab assumed */\n                if (sym_index >= nb_syms)\n                    goto invalid_reloc;\n                sym_index = old_to_new_syms[sym_index];\n                if (!sym_index) {\n                invalid_reloc:\n                    error_noabort(\"Invalid relocation entry\");\n                    goto fail;\n                }\n                rel->r_info = ELF32_R_INFO(sym_index, type);\n                /* offset the relocation offset */\n                rel->r_offset += offseti;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n    \n    ret = 0;\n the_end:\n    tcc_free(symtab);\n    tcc_free(strtab);\n    tcc_free(old_to_new_syms);\n    tcc_free(sm_table);\n    tcc_free(strsec);\n    tcc_free(shdr);\n    return ret;\n}\n\n#define ARMAG  \"!<arch>\\012\"\t/* For COFF and a.out archives */\n\ntypedef struct ArchiveHeader {\n    char ar_name[16];\t\t/* name of this member */\n    char ar_date[12];\t\t/* file mtime */\n    char ar_uid[6];\t\t/* owner uid; printed as decimal */\n    char ar_gid[6];\t\t/* owner gid; printed as decimal */\n    char ar_mode[8];\t\t/* file mode, printed as octal   */\n    char ar_size[10];\t\t/* file size, printed as decimal */\n    char ar_fmag[2];\t\t/* should contain ARFMAG */\n} ArchiveHeader;\n\nstatic int get_be32(const uint8_t *b)\n{\n    return b[3] | (b[2] << 8) | (b[1] << 16) | (b[0] << 24);\n}\n\n/* load only the objects which resolve undefined symbols */\nstatic int tcc_load_alacarte(TCCState *s1, int fd, int size)\n{\n    int i, bound, nsyms, sym_index, off, ret;\n    uint8_t *data;\n    const char *ar_names, *p;\n    const uint8_t *ar_index;\n    Elf32_Sym *sym;\n\n    data = tcc_malloc(size);\n    if (read(fd, data, size) != size)\n        goto fail;\n    nsyms = get_be32(data);\n    ar_index = data + 4;\n    ar_names = ar_index + nsyms * 4;\n\n    do {\n\tbound = 0;\n\tfor(p = ar_names, i = 0; i < nsyms; i++, p += strlen(p)+1) {\n\t    sym_index = find_elf_sym(symtab_section, p);\n\t    if(sym_index) {\n\t\tsym = &((Elf32_Sym *)symtab_section->data)[sym_index];\n\t\tif(sym->st_shndx == SHN_UNDEF) {\n\t\t    off = get_be32(ar_index + i * 4) + sizeof(ArchiveHeader);\n#if 0\n\t\t    printf(\"%5d\\t%s\\t%08x\\n\", i, p, sym->st_shndx);\n#endif\n\t\t    ++bound;\n\t\t    lseek(fd, off, SEEK_SET);\n\t\t    if(tcc_load_object_file(s1, fd, off) < 0) {\n                    fail:\n                        ret = -1;\n                        goto the_end;\n                    }\n\t\t}\n\t    }\n\t}\n    } while(bound);\n    ret = 0;\n the_end:\n    tcc_free(data);\n    return ret;\n}\n\n/* load a '.a' file */\nstatic int tcc_load_archive(TCCState *s1, int fd)\n{\n    ArchiveHeader hdr;\n    char ar_size[11];\n    char ar_name[17];\n    char magic[8];\n    int size, len, i;\n    unsigned long file_offset;\n\n    /* skip magic which was already checked */\n    dummy_size_t = read(fd, magic, sizeof(magic));\n    \n    for(;;) {\n        len = read(fd, &hdr, sizeof(hdr));\n        if (len == 0)\n            break;\n        if (len != sizeof(hdr)) {\n            error_noabort(\"invalid archive\");\n            return -1;\n        }\n        memcpy(ar_size, hdr.ar_size, sizeof(hdr.ar_size));\n        ar_size[sizeof(hdr.ar_size)] = '\\0';\n        size = strtol(ar_size, NULL, 0);\n        memcpy(ar_name, hdr.ar_name, sizeof(hdr.ar_name));\n        for(i = sizeof(hdr.ar_name) - 1; i >= 0; i--) {\n            if (ar_name[i] != ' ')\n                break;\n        }\n        ar_name[i + 1] = '\\0';\n        //        printf(\"name='%s' size=%d %s\\n\", ar_name, size, ar_size);\n        file_offset = lseek(fd, 0, SEEK_CUR);\n        /* align to even */\n        size = (size + 1) & ~1;\n        if (!strcmp(ar_name, \"/\")) {\n            /* coff symbol table : we handle it */\n\t    if(s1->alacarte_link)\n\t\treturn tcc_load_alacarte(s1, fd, size);\n        } else if (!strcmp(ar_name, \"//\") ||\n                   !strcmp(ar_name, \"__.SYMDEF\") ||\n                   !strcmp(ar_name, \"__.SYMDEF/\") ||\n                   !strcmp(ar_name, \"ARFILENAMES/\")) {\n            /* skip symbol table or archive names */\n        } else {\n            if (tcc_load_object_file(s1, fd, file_offset) < 0)\n                return -1;\n        }\n        lseek(fd, file_offset + size, SEEK_SET);\n    }\n    return 0;\n}\n\n/* load a DLL and all referenced DLLs. 'level = 0' means that the DLL\n   is referenced by the user (so it should be added as DT_NEEDED in\n   the generated ELF file) */\nstatic int tcc_load_dll(TCCState *s1, int fd, const char *filename, int level)\n{ \n    Elf32_Ehdr ehdr;\n    Elf32_Shdr *shdr, *sh, *sh1;\n    int i, nb_syms, nb_dts, sym_bind, ret;\n    Elf32_Sym *sym, *dynsym;\n    Elf32_Dyn *dt, *dynamic;\n    unsigned char *dynstr;\n    const char *name, *soname, *p;\n    DLLReference *dllref;\n    \n    dummy_size_t = read(fd, &ehdr, sizeof(ehdr));\n\n    /* test CPU specific stuff */\n    if (ehdr.e_ident[5] != ELFDATA2LSB ||\n        ehdr.e_machine != EM_TCC_TARGET) {\n        error_noabort(\"bad architecture\");\n        return -1;\n    }\n\n    /* read sections */\n    shdr = load_data(fd, ehdr.e_shoff, sizeof(Elf32_Shdr) * ehdr.e_shnum);\n\n    /* load dynamic section and dynamic symbols */\n    nb_syms = 0;\n    nb_dts = 0;\n    dynamic = NULL;\n    dynsym = NULL; /* avoid warning */\n    dynstr = NULL; /* avoid warning */\n    for(i = 0, sh = shdr; i < ehdr.e_shnum; i++, sh++) {\n        switch(sh->sh_type) {\n        case SHT_DYNAMIC:\n            nb_dts = sh->sh_size / sizeof(Elf32_Dyn);\n            dynamic = load_data(fd, sh->sh_offset, sh->sh_size);\n            break;\n        case SHT_DYNSYM:\n            nb_syms = sh->sh_size / sizeof(Elf32_Sym);\n            dynsym = load_data(fd, sh->sh_offset, sh->sh_size);\n            sh1 = &shdr[sh->sh_link];\n            dynstr = load_data(fd, sh1->sh_offset, sh1->sh_size);\n            break;\n        default:\n            break;\n        }\n    }\n    \n    /* compute the real library name */\n    soname = filename;\n    p = strrchr(soname, '/');\n    if (p)\n        soname = p + 1;\n        \n    for(i = 0, dt = dynamic; i < nb_dts; i++, dt++) {\n        if (dt->d_tag == DT_SONAME) {\n            soname = dynstr + dt->d_un.d_val;\n        }\n    }\n\n    /* if the dll is already loaded, do not load it */\n    for(i = 0; i < s1->nb_loaded_dlls; i++) {\n        dllref = s1->loaded_dlls[i];\n        if (!strcmp(soname, dllref->name)) {\n            /* but update level if needed */\n            if (level < dllref->level)\n                dllref->level = level;\n            ret = 0;\n            goto the_end;\n        }\n    }\n    \n    //    printf(\"loading dll '%s'\\n\", soname);\n\n    /* add the dll and its level */\n    dllref = tcc_malloc(sizeof(DLLReference) + strlen(soname));\n    dllref->level = level;\n    strcpy(dllref->name, soname);\n    dynarray_add((void ***)&s1->loaded_dlls, &s1->nb_loaded_dlls, dllref);\n\n    /* add dynamic symbols in dynsym_section */\n    for(i = 1, sym = dynsym + 1; i < nb_syms; i++, sym++) {\n        sym_bind = ELF32_ST_BIND(sym->st_info);\n        if (sym_bind == STB_LOCAL)\n            continue;\n        name = dynstr + sym->st_name;\n        add_elf_sym(s1->dynsymtab_section, sym->st_value, sym->st_size,\n                    sym->st_info, sym->st_other, sym->st_shndx, name);\n    }\n\n    /* load all referenced DLLs */\n    for(i = 0, dt = dynamic; i < nb_dts; i++, dt++) {\n        switch(dt->d_tag) {\n        case DT_NEEDED:\n            name = dynstr + dt->d_un.d_val;\n            for(i = 0; i < s1->nb_loaded_dlls; i++) {\n                dllref = s1->loaded_dlls[i];\n                if (!strcmp(name, dllref->name))\n                    goto already_loaded;\n            }\n            if (tcc_add_dll(s1, name, AFF_REFERENCED_DLL) < 0) {\n                error_noabort(\"referenced dll '%s' not found\", name);\n                ret = -1;\n                goto the_end;\n            }\n        already_loaded:\n            break;\n        }\n    }\n    ret = 0;\n the_end:\n    tcc_free(dynstr);\n    tcc_free(dynsym);\n    tcc_free(dynamic);\n    tcc_free(shdr);\n    return ret;\n}\n\n#define LD_TOK_NAME 256\n#define LD_TOK_EOF  (-1)\n\n/* return next ld script token */\nstatic int ld_next(TCCState *s1, char *name, int name_size)\n{\n    int c;\n    char *q;\n\n redo:\n    switch(ch) {\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\v':\n    case '\\r':\n    case '\\n':\n        inp();\n        goto redo;\n    case '/':\n        minp();\n        if (ch == '*') {\n            file->buf_ptr = parse_comment(file->buf_ptr);\n            ch = file->buf_ptr[0];\n            goto redo;\n        } else {\n            q = name;\n            *q++ = '/';\n            goto parse_name;\n        }\n        break;\n    case 'a' ... 'z':\n    case 'A' ... 'Z':\n    case '_':\n    case '\\\\':\n    case '.':\n    case '$':\n    case '~':\n        q = name;\n    parse_name:\n        for(;;) {\n            if (!((ch >= 'a' && ch <= 'z') ||\n                  (ch >= 'A' && ch <= 'Z') ||\n                  (ch >= '0' && ch <= '9') ||\n                  strchr(\"/.-_+=$:\\\\,~\", ch)))\n                break;\n            if ((q - name) < name_size - 1) {\n                *q++ = ch;\n            }\n            minp();\n        }\n        *q = '\\0';\n        c = LD_TOK_NAME;\n        break;\n    case CH_EOF:\n        c = LD_TOK_EOF;\n        break;\n    default:\n        c = ch;\n        inp();\n        break;\n    }\n#if 0\n    printf(\"tok=%c %d\\n\", c, c);\n    if (c == LD_TOK_NAME)\n        printf(\"  name=%s\\n\", name);\n#endif\n    return c;\n}\n\n/* interpret a subset of GNU ldscripts to handle the dummy libc.so\n   files */\nstatic int tcc_load_ldscript(TCCState *s1)\n{\n    char cmd[64];\n    char filename[1024];\n    int t;\n    \n    ch = file->buf_ptr[0];\n    ch = handle_eob();\n    for(;;) {\n        t = ld_next(s1, cmd, sizeof(cmd));\n        if (t == LD_TOK_EOF)\n            return 0;\n        else if (t != LD_TOK_NAME)\n            return -1;\n        if (!strcmp(cmd, \"INPUT\") ||\n            !strcmp(cmd, \"GROUP\")) {\n            t = ld_next(s1, cmd, sizeof(cmd));\n            if (t != '(')\n                expect(\"(\");\n            t = ld_next(s1, filename, sizeof(filename));\n            for(;;) {\n                if (t == LD_TOK_EOF) {\n                    error_noabort(\"unexpected end of file\");\n                    return -1;\n                } else if (t == ')') {\n                    break;\n                } else if (t != LD_TOK_NAME) {\n                    error_noabort(\"filename expected\");\n                    return -1;\n                } \n                tcc_add_file(s1, filename);\n                t = ld_next(s1, filename, sizeof(filename));\n                if (t == ',') {\n                    t = ld_next(s1, filename, sizeof(filename));\n                }\n            }\n        } else if (!strcmp(cmd, \"OUTPUT_FORMAT\") ||\n                   !strcmp(cmd, \"TARGET\")) {\n            /* ignore some commands */\n            t = ld_next(s1, cmd, sizeof(cmd));\n            if (t != '(')\n                expect(\"(\");\n            for(;;) {\n                t = ld_next(s1, filename, sizeof(filename));\n                if (t == LD_TOK_EOF) {\n                    error_noabort(\"unexpected end of file\");\n                    return -1;\n                } else if (t == ')') {\n                    break;\n                }\n            }\n        } else {\n            return -1;\n        }\n    }\n    return 0;\n}\n//---------------------------------------------------------------------------\n\n#ifdef TCC_TARGET_COFF\n#include \"tcccoff.c\"\n#endif\n\n#ifdef TCC_TARGET_PE\n#include \"tccpe.c\"\n#endif\n\n/* print the position in the source file of PC value 'pc' by reading\n   the stabs debug information */\nstatic void rt_printline(unsigned long wanted_pc)\n{\n    Stab_Sym *sym, *sym_end;\n    char func_name[128], last_func_name[128];\n    unsigned long func_addr, last_pc, pc;\n    const char *incl_files[INCLUDE_STACK_SIZE];\n    int incl_index, len, last_line_num, i;\n    const char *str, *p;\n\n    fprintf(stderr, \"0x%08lx:\", wanted_pc);\n\n    func_name[0] = '\\0';\n    func_addr = 0;\n    incl_index = 0;\n    last_func_name[0] = '\\0';\n    last_pc = 0xffffffff;\n    last_line_num = 1;\n    sym = (Stab_Sym *)stab_section->data + 1;\n    sym_end = (Stab_Sym *)(stab_section->data + stab_section->data_offset);\n    while (sym < sym_end) {\n        switch(sym->n_type) {\n            /* function start or end */\n        case N_FUN:\n            if (sym->n_strx == 0) {\n                /* we test if between last line and end of function */\n                pc = sym->n_value + func_addr;\n                if (wanted_pc >= last_pc && wanted_pc < pc)\n                    goto found;\n                func_name[0] = '\\0';\n                func_addr = 0;\n            } else {\n                str = stabstr_section->data + sym->n_strx;\n                p = strchr(str, ':');\n                if (!p) {\n                    pstrcpy(func_name, sizeof(func_name), str);\n                } else {\n                    len = p - str;\n                    if (len > sizeof(func_name) - 1)\n                        len = sizeof(func_name) - 1;\n                    memcpy(func_name, str, len);\n                    func_name[len] = '\\0';\n                }\n                func_addr = sym->n_value;\n            }\n            break;\n            /* line number info */\n        case N_SLINE:\n            pc = sym->n_value + func_addr;\n            if (wanted_pc >= last_pc && wanted_pc < pc)\n                goto found;\n            last_pc = pc;\n            last_line_num = sym->n_desc;\n            /* XXX: slow! */\n            strcpy(last_func_name, func_name);\n            break;\n            /* include files */\n        case N_BINCL:\n            str = stabstr_section->data + sym->n_strx;\n        add_incl:\n            if (incl_index < INCLUDE_STACK_SIZE) {\n                incl_files[incl_index++] = str;\n            }\n            break;\n        case N_EINCL:\n            if (incl_index > 1)\n                incl_index--;\n            break;\n        case N_SO:\n            if (sym->n_strx == 0) {\n                incl_index = 0; /* end of translation unit */\n            } else {\n                str = stabstr_section->data + sym->n_strx;\n                /* do not add path */\n                len = strlen(str);\n                if (len > 0 && str[len - 1] != '/')\n                    goto add_incl;\n            }\n            break;\n        }\n        sym++;\n    }\n\n    /* second pass: we try symtab symbols (no line number info) */\n    incl_index = 0;\n    {\n        Elf32_Sym *sym, *sym_end;\n        int type;\n\n        sym_end = (Elf32_Sym *)(symtab_section->data + symtab_section->data_offset);\n        for(sym = (Elf32_Sym *)symtab_section->data + 1; \n            sym < sym_end;\n            sym++) {\n            type = ELF32_ST_TYPE(sym->st_info);\n            if (type == STT_FUNC) {\n                if (wanted_pc >= sym->st_value &&\n                    wanted_pc < sym->st_value + sym->st_size) {\n                    pstrcpy(last_func_name, sizeof(last_func_name),\n                            strtab_section->data + sym->st_name);\n                    goto found;\n                }\n            }\n        }\n    }\n    /* did not find any info: */\n    fprintf(stderr, \" ???\\n\");\n    return;\n found:\n    if (last_func_name[0] != '\\0') {\n        fprintf(stderr, \" %s()\", last_func_name);\n    }\n    if (incl_index > 0) {\n        fprintf(stderr, \" (%s:%d\", \n                incl_files[incl_index - 1], last_line_num);\n        for(i = incl_index - 2; i >= 0; i--)\n            fprintf(stderr, \", included from %s\", incl_files[i]);\n        fprintf(stderr, \")\");\n    }\n    fprintf(stderr, \"\\n\");\n}\n\n#if !defined(WIN32) && !defined(CONFIG_TCCBOOT)\n\n/* return the PC at frame level 'level'. Return non zero if not found */\nstatic int rt_get_caller_pc(unsigned long *paddr, \n                            ucontext_t *uc, int level)\n{\n    unsigned long fp __attribute__((unused));\n    //int i;\n\n    if (level == 0) {\n        *paddr = 12345; //uc->uc_mcontext.gregs[REG_EIP];\n        return 0;\n    } else {\n        fp = 23456; //uc->uc_mcontext.gregs[REG_EBP];\n        return 0;\n    }\n}\n\n/* emit a run time error at position 'pc' */\nvoid rt_error(ucontext_t *uc, const char *fmt, ...)\n{\n    va_list ap;\n    unsigned long pc = 0;  // shut gcc up\n    int i;\n\n    va_start(ap, fmt);\n    fprintf(stderr, \"Runtime error: \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \"\\n\");\n    for(i=0;i<num_callers;i++) {\n        if (rt_get_caller_pc(&pc, uc, i) < 0)\n            break;\n        if (i == 0)\n            fprintf(stderr, \"at \");\n        else\n            fprintf(stderr, \"by \");\n        rt_printline(pc);\n    }\n    exit(255);\n    va_end(ap);\n}\n\n/* signal handler for fatal errors */\nstatic void sig_error(int signum, siginfo_t *siginf, void *puc)\n{\n    ucontext_t *uc = puc;\n\n    switch(signum) {\n    case SIGFPE:\n        switch(siginf->si_code) {\n        case FPE_INTDIV:\n        case FPE_FLTDIV:\n            rt_error(uc, \"division by zero\");\n            break;\n        default:\n            rt_error(uc, \"floating point exception\");\n            break;\n        }\n        break;\n    case SIGBUS:\n    case SIGSEGV:\n        if (rt_bound_error_msg && *rt_bound_error_msg)\n            rt_error(uc, *rt_bound_error_msg);\n        else\n            rt_error(uc, \"dereferencing invalid pointer\");\n        break;\n    case SIGILL:\n        rt_error(uc, \"illegal instruction\");\n        break;\n    case SIGABRT:\n        rt_error(uc, \"abort() called\");\n        break;\n    default:\n        rt_error(uc, \"caught signal %d\", signum);\n        break;\n    }\n    exit(255);\n}\n#endif\n\n/* do all relocations (needed before using tcc_get_symbol()) */\nint tcc_relocate(TCCState *s1)\n{\n    Section *s;\n    int i;\n\n    s1->nb_errors = 0;\n    \n#ifdef TCC_TARGET_PE\n    pe_add_runtime(s1);\n#else\n    tcc_add_runtime(s1);\n#endif\n\n    relocate_common_syms();\n\n    tcc_add_linker_symbols(s1);\n\n    build_got_entries(s1);\n    \n    /* compute relocation address : section are relocated in place. We\n       also alloc the bss space */\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (s->sh_flags & SHF_ALLOC) {\n            if (s->sh_type == SHT_NOBITS)\n                s->data = tcc_mallocz(s->data_offset);\n            s->sh_addr = (unsigned long)s->data;\n        }\n    }\n\n    relocate_syms(s1, 1);\n\n    if (s1->nb_errors != 0)\n        return -1;\n\n    /* relocate each section */\n    for(i = 1; i < s1->nb_sections; i++) {\n        s = s1->sections[i];\n        if (s->reloc)\n            relocate_section(s1, s);\n    }\n    return 0;\n}\n\n/* launch the compiled program with the given arguments */\nint tcc_run(TCCState *s1, int argc, char **argv)\n{\n    int (*prog_main)(int, char **);\n\n    if (tcc_relocate(s1) < 0)\n        return -1;\n\n    prog_main = tcc_get_symbol_err(s1, \"main\");\n    \n    if (do_debug) {\n#if defined(WIN32) || defined(CONFIG_TCCBOOT)\n        error(\"debug mode currently not available for Windows\");\n#else        \n        struct sigaction sigact;\n        /* install TCC signal handlers to print debug info on fatal\n           runtime errors */\n        sigact.sa_flags = SA_SIGINFO | SA_RESETHAND;\n        sigact.sa_sigaction = sig_error;\n        sigemptyset(&sigact.sa_mask);\n        sigaction(SIGFPE, &sigact, NULL);\n        sigaction(SIGILL, &sigact, NULL);\n        sigaction(SIGSEGV, &sigact, NULL);\n        sigaction(SIGBUS, &sigact, NULL);\n        sigaction(SIGABRT, &sigact, NULL);\n#endif\n    }\n\n#ifdef CONFIG_TCC_BCHECK\n    if (do_bounds_check) {\n        void (*bound_init)(void);\n\n        /* set error function */\n        rt_bound_error_msg = (void *)tcc_get_symbol_err(s1, \n                                                        \"__bound_error_msg\");\n\n        /* XXX: use .init section so that it also work in binary ? */\n        bound_init = (void *)tcc_get_symbol_err(s1, \"__bound_init\");\n        bound_init();\n    }\n#endif\n    return (*prog_main)(argc, argv);\n}\n\nTCCState *tcc_new(void)\n{\n    const char *p, *r;\n    TCCState *s;\n    TokenSym *ts __attribute__((unused));\n    int i, c;\n\n    s = tcc_mallocz(sizeof(TCCState));\n    if (!s)\n        return NULL;\n    tcc_state = s;\n    s->output_type = TCC_OUTPUT_MEMORY;\n\n    /* init isid table */\n    for(i=0;i<256;i++)\n        isidnum_table[i] = isid(i) || isnum(i);\n\n    /* add all tokens */\n    table_ident = NULL;\n    memset(hash_ident, 0, TOK_HASH_SIZE * sizeof(TokenSym *));\n    \n    tok_ident = TOK_IDENT;\n    p = tcc_keywords;\n    while (*p) {\n        r = p;\n        for(;;) {\n            c = *r++;\n            if (c == '\\0')\n                break;\n        }\n        ts = tok_alloc(p, r - p - 1);\n        p = r;\n    }\n\n    /* we add dummy defines for some special macros to speed up tests\n       and to have working defined() */\n    define_push(TOK___LINE__, MACRO_OBJ, NULL, NULL);\n    define_push(TOK___FILE__, MACRO_OBJ, NULL, NULL);\n    define_push(TOK___DATE__, MACRO_OBJ, NULL, NULL);\n    define_push(TOK___TIME__, MACRO_OBJ, NULL, NULL);\n\n    /* standard defines */\n    tcc_define_symbol(s, \"__STDC__\", NULL);\n#if defined(TCC_TARGET_I386)\n    tcc_define_symbol(s, \"__i386__\", NULL);\n#endif\n#if defined(TCC_TARGET_ARM)\n    tcc_define_symbol(s, \"__ARM_ARCH_4__\", NULL);\n    tcc_define_symbol(s, \"__arm_elf__\", NULL);\n    tcc_define_symbol(s, \"__arm_elf\", NULL);\n    tcc_define_symbol(s, \"arm_elf\", NULL);\n    tcc_define_symbol(s, \"__arm__\", NULL);\n    tcc_define_symbol(s, \"__arm\", NULL);\n    tcc_define_symbol(s, \"arm\", NULL);\n    tcc_define_symbol(s, \"__APCS_32__\", NULL);\n#endif\n#if defined(linux)\n    tcc_define_symbol(s, \"__linux__\", NULL);\n    tcc_define_symbol(s, \"linux\", NULL);\n#endif\n    /* tiny C specific defines */\n    tcc_define_symbol(s, \"__TINYC__\", NULL);\n\n    /* tiny C & gcc defines */\n    tcc_define_symbol(s, \"__SIZE_TYPE__\", \"unsigned int\");\n    tcc_define_symbol(s, \"__PTRDIFF_TYPE__\", \"int\");\n    tcc_define_symbol(s, \"__WCHAR_TYPE__\", \"int\");\n    \n    /* default library paths */\n#ifdef TCC_TARGET_PE\n    {\n        char buf[1024];\n        snprintf(buf, sizeof(buf), \"%s/lib\", tcc_lib_path);\n        tcc_add_library_path(s, buf);\n    }\n#else\n    tcc_add_library_path(s, \"/usr/local/lib\");\n    tcc_add_library_path(s, \"/usr/lib\");\n    tcc_add_library_path(s, \"/lib\");\n#endif\n\n    /* no section zero */\n    dynarray_add((void ***)&s->sections, &s->nb_sections, NULL);\n\n    /* create standard sections */\n    text_section = new_section(s, \".text\", SHT_PROGBITS, SHF_ALLOC | SHF_EXECINSTR);\n    data_section = new_section(s, \".data\", SHT_PROGBITS, SHF_ALLOC | SHF_WRITE);\n    bss_section = new_section(s, \".bss\", SHT_NOBITS, SHF_ALLOC | SHF_WRITE);\n\n    /* symbols are always generated for linking stage */\n    symtab_section = new_symtab(s, \".symtab\", SHT_SYMTAB, 0,\n                                \".strtab\",\n                                \".hashtab\", SHF_PRIVATE); \n    strtab_section = symtab_section->link;\n    \n    /* private symbol table for dynamic symbols */\n    s->dynsymtab_section = new_symtab(s, \".dynsymtab\", SHT_SYMTAB, SHF_PRIVATE,\n                                      \".dynstrtab\", \n                                      \".dynhashtab\", SHF_PRIVATE);\n    s->alacarte_link = 1;\n\n#ifdef CHAR_IS_UNSIGNED\n    s->char_is_unsigned = 1;\n#endif\n#if defined(TCC_TARGET_PE) && 0\n    /* XXX: currently the PE linker is not ready to support that */\n    s->leading_underscore = 1;\n#endif\n    return s;\n}\n\nvoid tcc_delete(TCCState *s1)\n{\n    int i, n;\n\n    /* free -D defines */\n    free_defines(NULL);\n\n    /* free tokens */\n    n = tok_ident - TOK_IDENT;\n    for(i = 0; i < n; i++)\n        tcc_free(table_ident[i]);\n    tcc_free(table_ident);\n\n    /* free all sections */\n\n    free_section(symtab_section->hash);\n\n    free_section(s1->dynsymtab_section->hash);\n    free_section(s1->dynsymtab_section->link);\n    free_section(s1->dynsymtab_section);\n\n    for(i = 1; i < s1->nb_sections; i++)\n        free_section(s1->sections[i]);\n    tcc_free(s1->sections);\n    \n    /* free loaded dlls array */\n    for(i = 0; i < s1->nb_loaded_dlls; i++)\n        tcc_free(s1->loaded_dlls[i]);\n    tcc_free(s1->loaded_dlls);\n\n    /* library paths */\n    for(i = 0; i < s1->nb_library_paths; i++)\n        tcc_free(s1->library_paths[i]);\n    tcc_free(s1->library_paths);\n\n    /* cached includes */\n    for(i = 0; i < s1->nb_cached_includes; i++)\n        tcc_free(s1->cached_includes[i]);\n    tcc_free(s1->cached_includes);\n\n    for(i = 0; i < s1->nb_include_paths; i++)\n        tcc_free(s1->include_paths[i]);\n    tcc_free(s1->include_paths);\n\n    for(i = 0; i < s1->nb_sysinclude_paths; i++)\n        tcc_free(s1->sysinclude_paths[i]);\n    tcc_free(s1->sysinclude_paths);\n\n    tcc_free(s1);\n}\n\nint tcc_add_include_path(TCCState *s1, const char *pathname)\n{\n    char *pathname1;\n    \n    pathname1 = tcc_strdup(pathname);\n    dynarray_add((void ***)&s1->include_paths, &s1->nb_include_paths, pathname1);\n    return 0;\n}\n\nint tcc_add_sysinclude_path(TCCState *s1, const char *pathname)\n{\n    char *pathname1;\n    \n    pathname1 = tcc_strdup(pathname);\n    dynarray_add((void ***)&s1->sysinclude_paths, &s1->nb_sysinclude_paths, pathname1);\n    return 0;\n}\n\nstatic int tcc_add_file_internal(TCCState *s1, const char *filename, int flags)\n{\n    const char *ext, *filename1;\n    Elf32_Ehdr ehdr;\n    int fd, ret;\n    BufferedFile *saved_file;\n\n    /* find source file type with extension */\n    filename1 = strrchr(filename, '/');\n    if (filename1)\n        filename1++;\n    else\n        filename1 = filename;\n    ext = strrchr(filename1, '.');\n    if (ext)\n        ext++;\n\n    /* open the file */\n    saved_file = file;\n    file = tcc_open(s1, filename);\n    if (!file) {\n        if (flags & AFF_PRINT_ERROR) {\n            error_noabort(\"file '%s' not found\", filename);\n        }\n        ret = -1;\n        goto fail1;\n    }\n\n    if (!ext || !strcmp(ext, \"c\")) {\n        /* C file assumed */\n        ret = tcc_compile(s1);\n    } else \n#ifdef CONFIG_TCC_ASM\n    if (!strcmp(ext, \"S\")) {\n        /* preprocessed assembler */\n        ret = tcc_assemble(s1, 1);\n    } else if (!strcmp(ext, \"s\")) {\n        /* non preprocessed assembler */\n        ret = tcc_assemble(s1, 0);\n    } else \n#endif\n#ifdef TCC_TARGET_PE\n    if (!strcmp(ext, \"def\")) {\n        ret = pe_load_def_file(s1, fdopen(file->fd, \"rb\"));\n    } else\n#endif\n    {\n        fd = file->fd;\n        /* assume executable format: auto guess file type */\n        ret = read(fd, &ehdr, sizeof(ehdr));\n        lseek(fd, 0, SEEK_SET);\n        if (ret <= 0) {\n            error_noabort(\"could not read header\");\n            goto fail;\n        } else if (ret != sizeof(ehdr)) {\n            goto try_load_script;\n        }\n\n        if (ehdr.e_ident[0] == ELFMAG0 &&\n            ehdr.e_ident[1] == ELFMAG1 &&\n            ehdr.e_ident[2] == ELFMAG2 &&\n            ehdr.e_ident[3] == ELFMAG3) {\n            file->line_num = 0; /* do not display line number if error */\n            if (ehdr.e_type == ET_REL) {\n                ret = tcc_load_object_file(s1, fd, 0);\n            } else if (ehdr.e_type == ET_DYN) {\n                if (s1->output_type == TCC_OUTPUT_MEMORY) {\n#ifdef TCC_TARGET_PE\n                    ret = -1;\n#else\n                    void *h;\n\t\t    assert(0);\n\t\t    h = 0;\n                    //h = dlopen(filename, RTLD_GLOBAL | RTLD_LAZY);\n\t\t    // jrs: remove need for dlopen\n                    if (h)\n                        ret = 0;\n                    else\n                        ret = -1;\n#endif\n                } else {\n                    ret = tcc_load_dll(s1, fd, filename, \n                                       (flags & AFF_REFERENCED_DLL) != 0);\n                }\n            } else {\n                error_noabort(\"unrecognized ELF file\");\n                goto fail;\n            }\n        } else if (memcmp((char *)&ehdr, ARMAG, 8) == 0) {\n            file->line_num = 0; /* do not display line number if error */\n            ret = tcc_load_archive(s1, fd);\n        } else \n#ifdef TCC_TARGET_COFF\n        if (*(uint16_t *)(&ehdr) == COFF_C67_MAGIC) {\n            ret = tcc_load_coff(s1, fd);\n        } else\n#endif\n        {\n            /* as GNU ld, consider it is an ld script if not recognized */\n        try_load_script:\n            ret = tcc_load_ldscript(s1);\n            if (ret < 0) {\n                error_noabort(\"unrecognized file type\");\n                goto fail;\n            }\n        }\n    }\n the_end:\n    tcc_close(file);\n fail1:\n    file = saved_file;\n    return ret;\n fail:\n    ret = -1;\n    goto the_end;\n}\n\nint tcc_add_file(TCCState *s, const char *filename)\n{\n    return tcc_add_file_internal(s, filename, AFF_PRINT_ERROR);\n}\n\nint tcc_add_library_path(TCCState *s, const char *pathname)\n{\n    char *pathname1;\n    \n    pathname1 = tcc_strdup(pathname);\n    dynarray_add((void ***)&s->library_paths, &s->nb_library_paths, pathname1);\n    return 0;\n}\n\n/* find and load a dll. Return non zero if not found */\n/* XXX: add '-rpath' option support ? */\nstatic int tcc_add_dll(TCCState *s, const char *filename, int flags)\n{\n    char buf[1024];\n    int i;\n\n    for(i = 0; i < s->nb_library_paths; i++) {\n        snprintf(buf, sizeof(buf), \"%s/%s\", \n                 s->library_paths[i], filename);\n        if (tcc_add_file_internal(s, buf, flags) == 0)\n            return 0;\n    }\n    return -1;\n}\n\n/* the library name is the same as the argument of the '-l' option */\nint tcc_add_library(TCCState *s, const char *libraryname)\n{\n    char buf[1024];\n    int i;\n    \n    /* first we look for the dynamic library if not static linking */\n    if (!s->static_link) {\n#ifdef TCC_TARGET_PE\n        snprintf(buf, sizeof(buf), \"%s.def\", libraryname);\n#else\n        snprintf(buf, sizeof(buf), \"lib%s.so\", libraryname);\n#endif\n        if (tcc_add_dll(s, buf, 0) == 0)\n            return 0;\n    }\n\n    /* then we look for the static library */\n    for(i = 0; i < s->nb_library_paths; i++) {\n        snprintf(buf, sizeof(buf), \"%s/lib%s.a\", \n                 s->library_paths[i], libraryname);\n        if (tcc_add_file_internal(s, buf, 0) == 0)\n            return 0;\n    }\n    return -1;\n}\n\nint tcc_add_symbol(TCCState *s, const char *name, unsigned long val)\n{\n    add_elf_sym(symtab_section, val, 0, \n                ELF32_ST_INFO(STB_GLOBAL, STT_NOTYPE), 0,\n                SHN_ABS, name);\n    return 0;\n}\n\nint tcc_set_output_type(TCCState *s, int output_type)\n{\n    s->output_type = output_type;\n\n    if (!s->nostdinc) {\n        char buf[1024];\n\n        /* default include paths */\n        /* XXX: reverse order needed if -isystem support */\n#ifndef TCC_TARGET_PE\n        tcc_add_sysinclude_path(s, \"/usr/local/include\");\n        tcc_add_sysinclude_path(s, \"/usr/include\");\n#endif\n        snprintf(buf, sizeof(buf), \"%s/include\", tcc_lib_path);\n        tcc_add_sysinclude_path(s, buf);\n#ifdef TCC_TARGET_PE\n        snprintf(buf, sizeof(buf), \"%s/include/winapi\", tcc_lib_path);\n        tcc_add_sysinclude_path(s, buf);\n#endif\n    }\n\n    /* if bound checking, then add corresponding sections */\n#ifdef CONFIG_TCC_BCHECK\n    if (do_bounds_check) {\n        /* define symbol */\n        tcc_define_symbol(s, \"__BOUNDS_CHECKING_ON\", NULL);\n        /* create bounds sections */\n        bounds_section = new_section(s, \".bounds\", \n                                     SHT_PROGBITS, SHF_ALLOC);\n        lbounds_section = new_section(s, \".lbounds\", \n                                      SHT_PROGBITS, SHF_ALLOC);\n    }\n#endif\n\n    if (s->char_is_unsigned) {\n        tcc_define_symbol(s, \"__CHAR_UNSIGNED__\", NULL);\n    }\n\n    /* add debug sections */\n    if (do_debug) {\n        /* stab symbols */\n        stab_section = new_section(s, \".stab\", SHT_PROGBITS, 0);\n        stab_section->sh_entsize = sizeof(Stab_Sym);\n        stabstr_section = new_section(s, \".stabstr\", SHT_STRTAB, 0);\n        put_elf_str(stabstr_section, \"\");\n        stab_section->link = stabstr_section;\n        /* put first entry */\n        put_stabs(\"\", 0, 0, 0, 0);\n    }\n\n    /* add libc crt1/crti objects */\n#ifndef TCC_TARGET_PE\n    if ((output_type == TCC_OUTPUT_EXE || output_type == TCC_OUTPUT_DLL) &&\n        !s->nostdlib) {\n        if (output_type != TCC_OUTPUT_DLL)\n            tcc_add_file(s, CONFIG_TCC_CRT_PREFIX \"/crt1.o\");\n        tcc_add_file(s, CONFIG_TCC_CRT_PREFIX \"/crti.o\");\n    }\n#endif\n    return 0;\n}\n\n#define WD_ALL    0x0001 /* warning is activated when using -Wall */\n#define FD_INVERT 0x0002 /* invert value before storing */\n\ntypedef struct FlagDef {\n    uint16_t offset;\n    uint16_t flags;\n    const char *name;\n} FlagDef;\n\nstatic const FlagDef warning_defs[] = {\n    { offsetof(TCCState, warn_unsupported), 0, \"unsupported\" },\n    { offsetof(TCCState, warn_write_strings), 0, \"write-strings\" },\n    { offsetof(TCCState, warn_error), 0, \"error\" },\n    { offsetof(TCCState, warn_implicit_function_declaration), WD_ALL,\n      \"implicit-function-declaration\" },\n};\n\nstatic int set_flag(TCCState *s, const FlagDef *flags, int nb_flags,\n                    const char *name, int value)\n{\n    int i;\n    const FlagDef *p;\n    const char *r;\n\n    r = name;\n    if (r[0] == 'n' && r[1] == 'o' && r[2] == '-') {\n        r += 3;\n        value = !value;\n    }\n    for(i = 0, p = flags; i < nb_flags; i++, p++) {\n        if (!strcmp(r, p->name))\n            goto found;\n    }\n    return -1;\n found:\n    if (p->flags & FD_INVERT)\n        value = !value;\n    *(int *)((uint8_t *)s + p->offset) = value;\n    return 0;\n}\n\n\n/* set/reset a warning */\nint tcc_set_warning(TCCState *s, const char *warning_name, int value)\n{\n    int i;\n    const FlagDef *p;\n\n    if (!strcmp(warning_name, \"all\")) {\n        for(i = 0, p = warning_defs; i < countof(warning_defs); i++, p++) {\n            if (p->flags & WD_ALL)\n                *(int *)((uint8_t *)s + p->offset) = 1;\n        }\n        return 0;\n    } else {\n        return set_flag(s, warning_defs, countof(warning_defs),\n                        warning_name, value);\n    }\n}\n\nstatic const FlagDef flag_defs[] = {\n    { offsetof(TCCState, char_is_unsigned), 0, \"unsigned-char\" },\n    { offsetof(TCCState, char_is_unsigned), FD_INVERT, \"signed-char\" },\n    { offsetof(TCCState, nocommon), FD_INVERT, \"common\" },\n    { offsetof(TCCState, leading_underscore), 0, \"leading-underscore\" },\n};\n\n/* set/reset a flag */\nint tcc_set_flag(TCCState *s, const char *flag_name, int value)\n{\n    return set_flag(s, flag_defs, countof(flag_defs),\n                    flag_name, value);\n}\n\n#if !defined(LIBTCC)\n\n/* extract the basename of a file */\nstatic const char *tcc_basename(const char *name)\n{\n    const char *p;\n    p = strrchr(name, '/');\n#ifdef WIN32\n    if (!p)\n        p = strrchr(name, '\\\\');\n#endif    \n    if (!p)\n        p = name;\n    else \n        p++;\n    return p;\n}\n\nstatic int64_t getclock_us(void)\n{\n#ifdef WIN32\n    struct _timeb tb;\n    _ftime(&tb);\n    return (tb.time * 1000LL + tb.millitm) * 1000LL;\n#else\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return tv.tv_sec * 1000000LL + tv.tv_usec;\n#endif\n}\n\nvoid help(void)\n{\n    printf(\"tcc version \" TCC_VERSION \" - Tiny C Compiler - Copyright (C) 2001-2017 Fabrice Bellard\\n\"\n           \"usage: tcc [-v] [-c] [-o outfile] [-Bdir] [-bench] [-Idir] [-Dsym[=val]] [-Usym]\\n\"\n           \"           [-Wwarn] [-g] [-b] [-bt N] [-Ldir] [-llib] [-shared] [-static]\\n\"\n           \"           [infile1 infile2...] [-run infile args...]\\n\"\n           \"\\n\"\n           \"General options:\\n\"\n           \"  -v          display current version\\n\"\n           \"  -c          compile only - generate an object file\\n\"\n           \"  -o outfile  set output filename\\n\"\n           \"  -Bdir       set tcc internal library path\\n\"\n           \"  -bench      output compilation statistics\\n\"\n \t   \"  -run        run compiled source\\n\"\n           \"  -fflag      set or reset (with 'no-' prefix) 'flag' (see man page)\\n\"\n           \"  -Wwarning   set or reset (with 'no-' prefix) 'warning' (see man page)\\n\"\n           \"  -w          disable all warnings\\n\"\n           \"Preprocessor options:\\n\"\n           \"  -Idir       add include path 'dir'\\n\"\n           \"  -Dsym[=val] define 'sym' with value 'val'\\n\"\n           \"  -Usym       undefine 'sym'\\n\"\n           \"Linker options:\\n\"\n           \"  -Ldir       add library path 'dir'\\n\"\n           \"  -llib       link with dynamic or static library 'lib'\\n\"\n           \"  -shared     generate a shared library\\n\"\n           \"  -static     static linking\\n\"\n           \"  -rdynamic   export all global symbols to dynamic linker\\n\"\n           \"  -r          relocatable output\\n\"\n           \"Debugger options:\\n\"\n           \"  -g          generate runtime debug info\\n\"\n#ifdef CONFIG_TCC_BCHECK\n           \"  -b          compile with built-in memory and bounds checker (implies -g)\\n\"\n#endif\n           \"  -bt N       show N callers in stack traces\\n\"\n           );\n}\n\n#define TCC_OPTION_HAS_ARG 0x0001\n#define TCC_OPTION_NOSEP   0x0002 /* cannot have space before option and arg */\n\ntypedef struct TCCOption {\n    const char *name;\n    uint16_t index;\n    uint16_t flags;\n} TCCOption;\n\nenum {\n    TCC_OPTION_HELP,\n    TCC_OPTION_I,\n    TCC_OPTION_D,\n    TCC_OPTION_U,\n    TCC_OPTION_L,\n    TCC_OPTION_B,\n    TCC_OPTION_l,\n    TCC_OPTION_bench,\n    TCC_OPTION_bt,\n    TCC_OPTION_b,\n    TCC_OPTION_g,\n    TCC_OPTION_c,\n    TCC_OPTION_static,\n    TCC_OPTION_shared,\n    TCC_OPTION_o,\n    TCC_OPTION_r,\n    TCC_OPTION_Wl,\n    TCC_OPTION_W,\n    TCC_OPTION_O,\n    TCC_OPTION_m,\n    TCC_OPTION_f,\n    TCC_OPTION_nostdinc,\n    TCC_OPTION_nostdlib,\n    TCC_OPTION_print_search_dirs,\n    TCC_OPTION_rdynamic,\n    TCC_OPTION_run,\n    TCC_OPTION_v,\n    TCC_OPTION_w,\n    TCC_OPTION_pipe,\n};\n\nstatic const TCCOption tcc_options[] = {\n    { \"h\", TCC_OPTION_HELP, 0 },\n    { \"?\", TCC_OPTION_HELP, 0 },\n    { \"I\", TCC_OPTION_I, TCC_OPTION_HAS_ARG },\n    { \"D\", TCC_OPTION_D, TCC_OPTION_HAS_ARG },\n    { \"U\", TCC_OPTION_U, TCC_OPTION_HAS_ARG },\n    { \"L\", TCC_OPTION_L, TCC_OPTION_HAS_ARG },\n    { \"B\", TCC_OPTION_B, TCC_OPTION_HAS_ARG },\n    { \"l\", TCC_OPTION_l, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"bench\", TCC_OPTION_bench, 0 },\n    { \"bt\", TCC_OPTION_bt, TCC_OPTION_HAS_ARG },\n#ifdef CONFIG_TCC_BCHECK\n    { \"b\", TCC_OPTION_b, 0 },\n#endif\n    { \"g\", TCC_OPTION_g, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"c\", TCC_OPTION_c, 0 },\n    { \"static\", TCC_OPTION_static, 0 },\n    { \"shared\", TCC_OPTION_shared, 0 },\n    { \"o\", TCC_OPTION_o, TCC_OPTION_HAS_ARG },\n    { \"run\", TCC_OPTION_run, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"rdynamic\", TCC_OPTION_rdynamic, 0 },\n    { \"r\", TCC_OPTION_r, 0 },\n    { \"Wl,\", TCC_OPTION_Wl, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"W\", TCC_OPTION_W, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"O\", TCC_OPTION_O, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"m\", TCC_OPTION_m, TCC_OPTION_HAS_ARG },\n    { \"f\", TCC_OPTION_f, TCC_OPTION_HAS_ARG | TCC_OPTION_NOSEP },\n    { \"nostdinc\", TCC_OPTION_nostdinc, 0 },\n    { \"nostdlib\", TCC_OPTION_nostdlib, 0 },\n    { \"print-search-dirs\", TCC_OPTION_print_search_dirs, 0 }, \n    { \"v\", TCC_OPTION_v, 0 },\n    { \"w\", TCC_OPTION_w, 0 },\n    { \"pipe\", TCC_OPTION_pipe, 0},\n    { NULL },\n};\n\n/* convert 'str' into an array of space separated strings */\nstatic int expand_args(char ***pargv, const char *str)\n{\n    const char *s1;\n    char **argv, *arg;\n    int argc, len;\n\n    argc = 0;\n    argv = NULL;\n    for(;;) {\n        while (is_space(*str))\n            str++;\n        if (*str == '\\0')\n            break;\n        s1 = str;\n        while (*str != '\\0' && !is_space(*str))\n            str++;\n        len = str - s1;\n        arg = tcc_malloc(len + 1);\n        memcpy(arg, s1, len);\n        arg[len] = '\\0';\n        dynarray_add((void ***)&argv, &argc, arg);\n    }\n    *pargv = argv;\n    return argc;\n}\n\nstatic char **files;\nstatic int nb_files, nb_libraries;\nstatic int multiple_files;\nstatic int print_search_dirs;\nstatic int output_type;\nstatic int reloc_output;\nstatic const char *outfile;\n\nint parse_args(TCCState *s, int argc, char **argv)\n{\n    int optind;\n    const TCCOption *popt;\n    const char *optarg, *p1, *r1;\n    char *r;\n\n    optind = 0;\n    while (1) {\n        if (optind >= argc) {\n            if (nb_files == 0 && !print_search_dirs)\n                goto show_help;\n            else\n                break;\n        }\n        r = argv[optind++];\n        if (r[0] != '-') {\n            /* add a new file */\n            dynarray_add((void ***)&files, &nb_files, r);\n            if (!multiple_files) {\n                optind--;\n                /* argv[0] will be this file */\n                break;\n            }\n        } else {\n            /* find option in table (match only the first chars */\n            popt = tcc_options;\n            for(;;) {\n                p1 = popt->name;\n                if (p1 == NULL)\n                    error(\"invalid option -- '%s'\", r);\n                r1 = r + 1;\n                for(;;) {\n                    if (*p1 == '\\0')\n                        goto option_found;\n                    if (*r1 != *p1)\n                        break;\n                    p1++;\n                    r1++;\n                }\n                popt++;\n            }\n        option_found:\n            if (popt->flags & TCC_OPTION_HAS_ARG) {\n                if (*r1 != '\\0' || (popt->flags & TCC_OPTION_NOSEP)) {\n                    optarg = r1;\n                } else {\n                    if (optind >= argc)\n                        error(\"argument to '%s' is missing\", r);\n                    optarg = argv[optind++];\n                }\n            } else {\n                if (*r1 != '\\0')\n                    goto show_help;\n                optarg = NULL;\n            }\n                \n            switch(popt->index) {\n            case TCC_OPTION_HELP:\n            show_help:\n                help();\n                exit(1);\n            case TCC_OPTION_I:\n                if (tcc_add_include_path(s, optarg) < 0)\n                    error(\"too many include paths\");\n                break;\n            case TCC_OPTION_D:\n                {\n                    char *sym, *value;\n                    sym = (char *)optarg;\n                    value = strchr(sym, '=');\n                    if (value) {\n                        *value = '\\0';\n                        value++;\n                    }\n                    tcc_define_symbol(s, sym, value);\n                }\n                break;\n            case TCC_OPTION_U:\n                tcc_undefine_symbol(s, optarg);\n                break;\n            case TCC_OPTION_L:\n                tcc_add_library_path(s, optarg);\n                break;\n            case TCC_OPTION_B:\n                /* set tcc utilities path (mainly for tcc development) */\n                tcc_lib_path = optarg;\n                break;\n            case TCC_OPTION_l:\n                dynarray_add((void ***)&files, &nb_files, r);\n                nb_libraries++;\n                break;\n            case TCC_OPTION_bench:\n                do_bench = 1;\n                break;\n            case TCC_OPTION_bt:\n                num_callers = atoi(optarg);\n                break;\n#ifdef CONFIG_TCC_BCHECK\n            case TCC_OPTION_b:\n                do_bounds_check = 1;\n                do_debug = 1;\n                break;\n#endif\n            case TCC_OPTION_g:\n                do_debug = 1;\n                break;\n            case TCC_OPTION_c:\n                multiple_files = 1;\n                output_type = TCC_OUTPUT_OBJ;\n                break;\n            case TCC_OPTION_static:\n                s->static_link = 1;\n                break;\n            case TCC_OPTION_shared:\n                output_type = TCC_OUTPUT_DLL;\n                break;\n            case TCC_OPTION_o:\n                multiple_files = 1;\n                outfile = optarg;\n                break;\n            case TCC_OPTION_r:\n                /* generate a .o merging several output files */\n                reloc_output = 1;\n                output_type = TCC_OUTPUT_OBJ;\n                break;\n            case TCC_OPTION_nostdinc:\n                s->nostdinc = 1;\n                break;\n            case TCC_OPTION_nostdlib:\n                s->nostdlib = 1;\n                break;\n            case TCC_OPTION_print_search_dirs:\n                print_search_dirs = 1;\n                break;\n            case TCC_OPTION_run:\n                {\n                    int argc1;\n                    char **argv1;\n                    argc1 = expand_args(&argv1, optarg);\n                    if (argc1 > 0) {\n                        parse_args(s, argc1, argv1);\n                    }\n                    multiple_files = 0;\n                    output_type = TCC_OUTPUT_MEMORY;\n                }\n                break;\n            case TCC_OPTION_v:\n                printf(\"tcc version %s\\n\", TCC_VERSION);\n                exit(0);\n            case TCC_OPTION_f:\n                if (tcc_set_flag(s, optarg, 1) < 0 && s->warn_unsupported)\n                    goto unsupported_option;\n                break;\n            case TCC_OPTION_W:\n                if (tcc_set_warning(s, optarg, 1) < 0 && \n                    s->warn_unsupported)\n                    goto unsupported_option;\n                break;\n            case TCC_OPTION_w:\n                s->warn_none = 1;\n                break;\n            case TCC_OPTION_rdynamic:\n                s->rdynamic = 1;\n                break;\n            case TCC_OPTION_Wl:\n                {\n                    const char *p;\n                    if (strstart(optarg, \"-Ttext,\", &p)) {\n                        s->text_addr = strtoul(p, NULL, 16);\n                        s->has_text_addr = 1;\n                    } else if (strstart(optarg, \"--oformat,\", &p)) {\n                        if (strstart(p, \"elf32-\", NULL)) {\n                            s->output_format = TCC_OUTPUT_FORMAT_ELF;\n                        } else if (!strcmp(p, \"binary\")) {\n                            s->output_format = TCC_OUTPUT_FORMAT_BINARY;\n                        } else\n#ifdef TCC_TARGET_COFF\n                        if (!strcmp(p, \"coff\")) {\n                            s->output_format = TCC_OUTPUT_FORMAT_COFF;\n                        } else\n#endif\n                        {\n                            error(\"target %s not found\", p);\n                        }\n                    } else {\n                        error(\"unsupported linker option '%s'\", optarg);\n                    }\n                }\n                break;\n            default:\n                if (s->warn_unsupported) {\n                unsupported_option:\n                    warning(\"unsupported option '%s'\", r);\n                }\n                break;\n            }\n        }\n    }\n    return optind;\n}\n\n// njn: renamed main() as main2() in order to repeat it multiple times.\nint main2(int argc, char **argv)\n{\n    int i;\n    TCCState *s;\n    int nb_objfiles, ret, optind;\n    char objfilename[1024];\n    int64_t start_time = 0;\n\n#ifdef WIN32\n    /* on win32, we suppose the lib and includes are at the location\n       of 'tcc.exe' */\n    {\n        static char path[1024];\n        char *p, *d;\n        \n        GetModuleFileNameA(NULL, path, sizeof path);\n        p = d = strlwr(path);\n        while (*d)\n        {\n            if (*d == '\\\\') *d = '/', p = d;\n            ++d;\n        }\n        *p = '\\0';\n        tcc_lib_path = path;\n    }\n#endif\n\n    s = tcc_new();\n    output_type = TCC_OUTPUT_EXE;\n    outfile = NULL;\n    multiple_files = 1;\n    files = NULL;\n    nb_files = 0;\n    nb_libraries = 0;\n    reloc_output = 0;\n    print_search_dirs = 0;\n\n    optind = parse_args(s, argc - 1, argv + 1) + 1;\n\n    if (print_search_dirs) {\n        /* enough for Linux kernel */\n        printf(\"install: %s/\\n\", tcc_lib_path);\n        return 0;\n    }\n\n    nb_objfiles = nb_files - nb_libraries;\n\n    /* if outfile provided without other options, we output an\n       executable */\n    if (outfile && output_type == TCC_OUTPUT_MEMORY)\n        output_type = TCC_OUTPUT_EXE;\n\n    /* check -c consistency : only single file handled. XXX: checks file type */\n    if (output_type == TCC_OUTPUT_OBJ && !reloc_output) {\n        /* accepts only a single input file */\n        if (nb_objfiles != 1)\n            error(\"cannot specify multiple files with -c\");\n        if (nb_libraries != 0)\n            error(\"cannot specify libraries with -c\");\n    }\n    \n    if (output_type != TCC_OUTPUT_MEMORY) {\n        if (!outfile) {\n    /* compute default outfile name */\n            pstrcpy(objfilename, sizeof(objfilename) - 1, \n                    /* strip path */\n                    tcc_basename(files[0]));\n#ifdef TCC_TARGET_PE\n            pe_guess_outfile(objfilename, output_type);\n#else\n            if (output_type == TCC_OUTPUT_OBJ && !reloc_output) {\n                char *ext = strrchr(objfilename, '.');\n            if (!ext)\n                goto default_outfile;\n                /* add .o extension */\n            strcpy(ext + 1, \"o\");\n        } else {\n        default_outfile:\n            pstrcpy(objfilename, sizeof(objfilename), \"a.out\");\n        }\n#endif\n        outfile = objfilename;\n        }\n    }\n\n    if (do_bench) {\n        start_time = getclock_us();\n    }\n\n    tcc_set_output_type(s, output_type);\n\n    /* compile or add each files or library */\n    for(i = 0;i < nb_files; i++) {\n        const char *filename;\n\n        filename = files[i];\n        if (filename[0] == '-') {\n            if (tcc_add_library(s, filename + 2) < 0)\n                error(\"cannot find %s\", filename);\n        } else {\n            if (tcc_add_file(s, filename) < 0) {\n                ret = 1;\n                goto the_end;\n            }\n        }\n    }\n\n    /* free all files */\n    tcc_free(files);\n\n    if (do_bench) {\n        double total_time;\n        total_time = (double)(getclock_us() - start_time) / 1000000.0;\n        if (total_time < 0.001)\n            total_time = 0.001;\n        if (total_bytes < 1)\n            total_bytes = 1;\n        printf(\"%d idents, %d lines, %d bytes, %0.3f s, %d lines/s, %0.1f MB/s\\n\", \n               tok_ident - TOK_IDENT, total_lines, total_bytes,\n               total_time, (int)(total_lines / total_time), \n               total_bytes / total_time / 1000000.0); \n    }\n\n    if (s->output_type == TCC_OUTPUT_MEMORY) {\n        ret = tcc_run(s, argc - optind, argv + optind);\n    } else\n#ifdef TCC_TARGET_PE\n    if (s->output_type != TCC_OUTPUT_OBJ) {\n        ret = tcc_output_pe(s, outfile);\n    } else\n#endif\n    {\n        tcc_output_file(s, outfile);\n        ret = 0;\n    }\n the_end:\n    /* XXX: cannot do it with bound checking because of the malloc hooks */\n    if (!do_bounds_check)\n        tcc_delete(s);\n\n#ifdef MEM_DEBUG\n    if (do_bench) {\n        printf(\"memory: %d bytes, max = %d bytes\\n\", mem_cur_size, mem_max_size);\n    }\n#endif\n    return ret;\n}\n\n// njn: created this wrapper main() function to execute compilation multiple\n// times.  TinyCC is fast!\n// Nb: we get a link error, and TinyCC would normally return non-zero.  But\n// the link error is not a problem for benchmarking purposes, so we return\n// zero here (as required by vg_perf).\nint main(int argc, char **argv)\n{\n   #define REPS   30\n   int i;\n   for (i = 0; i < REPS; i++) {\n      main2(argc, argv);\n   }\n   return 0;\n}\n\n#endif\n\n// njn: copied these in from libtcc1.c to avoid link errors when libtcc1.a\n// is not present.\nunsigned short __tcc_fpu_control = 0x137f;\nunsigned short __tcc_int_fpu_control = 0x137f | 0x0c00;\n\n#if 0\nlong long __shldi3(long long a, int b)\n{\n#ifdef __TINYC__ \n    DWunion u;\n    u.ll = a;\n    if (b >= 32) {\n        u.s.high = (unsigned)u.s.low << (b - 32);\n        u.s.low = 0;\n    } else if (b != 0) {\n        u.s.high = ((unsigned)u.s.high << b) | (u.s.low >> (32 - b));\n        u.s.low = (unsigned)u.s.low << b;\n    }\n    return u.ll;\n#else\n    return a << b;\n#endif\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/cachegrind/tests/dlclose.c": "/* This exercises the code that was causing this bug:\n  \n     valgrind: vg_cachesim.c:389 (get_BBCC): Assertion `((Bool)0) == remove' \n     failed.\n\n   in Cachegrind 1.0.0 and 1.0.1, that was caused by unloading symbols before\n   invalidating translations.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n\nint main(int argc, char **argv) {\n   void *handle;\n   void (*myprint)(void);\n   char *error;\n\n   handle = dlopen (\"./myprint.so\", RTLD_LAZY);\n   if (!handle) {\n       fputs (dlerror(), stderr);\n       exit(1);\n   }\n\n   myprint = dlsym(handle, \"myprint\");\n   if ((error = dlerror()) != NULL)  {\n       fprintf (stderr, \"%s\\n\", error);\n       exit(1);\n   }\n\n   (*myprint)();\n\n   /* Assertion failure was happening here */\n   dlclose(handle);\n\n   return 0;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/exp-sgcheck/tests/preen_invars.c": "\n#include <stdio.h>\n#include <assert.h>\n#include <dlfcn.h>\n\n/* see comments in preen_invar_so.c for explanation of this */\n\n\nint main ( void )\n{\n  int i, r, sum = 0;\n  char* im_a_global_array;\n  void* hdl = dlopen(\"./preen_invars_so.so\", RTLD_NOW);\n  assert(hdl);\n  im_a_global_array = dlsym(hdl, \"im_a_global_array\");\n  assert(im_a_global_array);\n  /* printf(\"%p %p\\n\", im_a_global_array, me_too_me_too); */\n\n  /* poke around in the global array, so as to cause exp-ptrcheck\n     to generate an Inv_Global invar for it. */\n  for (i = 10/*ERROR*/; i >= 0; i--) {\n     sum += im_a_global_array[i];\n  }\n  /* iterating 10 .. 0 causes an Unknown->Global transition at i = 9.\n     We do it this way in order that at the end of a loop, there is a\n     Global invar in place for the memory read in the loop, so that\n     the subsequent dlclose (hence munmap) causes it to get preened.\n\n     Unfortunately there's nothing to show that the preen was\n     successful or happened at all.  The only way to see is from the\n     -v output:\n\n     --686--  sg_:  251 Invars preened, of which 1 changed\n\n     It's the \"1 changed\" bit which is significant.\n  */\n\n  /* let's hope gcc is not clever enough to optimise this away, since\n     if it does, then it will also nuke the preceding loop, and\n     thereby render this test program useless. */\n\n  if (sum & 1) printf(\"%s bar %d\\n\", \"foo\", sum & 1); else\n               printf(\"foo %s %d\\n\", \"bar\", 1 - (sum & 1));\n\n  /* Now close (== unmap) the array, so that exp-ptrcheck has to check\n     its collection of Inv_Global invars, and remove this one from\n     it. */\n  r = dlclose(hdl);\n  assert(r == 0);\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/drd/tests/dlopen_main.c": "#include <stdlib.h>\n#include <stdio.h>\n#include <dlfcn.h>\n#include \"dlopen_lib.h\"\n\nint main(int argc, char **argv)\n{\n  const char *lib = argc > 1 ? argv[1] : \"./libfoo.so\";\n  void *handle;\n  void (*function)();\n  const char *error;\n\n  handle = dlopen(lib, RTLD_NOW);\n  if (!handle) {\n    fputs (dlerror(), stderr);\n    exit(1);\n  }\n\n  function = dlsym(handle, \"foo\");\n  error = dlerror();\n  if (error)  {\n    fputs(error, stderr);\n    exit(1);\n  }\n\n  (*function)();\n  dlclose(handle);\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/internals/segments-seginfos.txt": "\n-----------------------------------------------------------------------------\nInfo about the relationship between Segments and SegInfos\n-----------------------------------------------------------------------------\n\nSegInfo is from the very original Valgrind code, and so it predates\nSegments.  It's poorly named now; its really just a container for all\nthe object file metadata (symbols, debug info, etc).\n\nSegments describe memory mapped into the address space, and so any\naddress-space chaging operation needs to update the Segment structure.\nAfter the process is initialized, this means one of:\n\n    * mmap\n    * munmap\n    * mprotect\n    * brk\n    * stack growth\n\nA piece of address space may or may not be mmaped from a file.\n\nA SegInfo specifically describes memory mmaped from an ELF object file.\nBecause a single ELF file may be mmaped with multiple Segments, multiple\nSegments can point to one Seginfo.  A SegInfo can relate to a memory\nrange which is not yet mmaped.  For example, if the process mmaps the\nfirst page of an ELF file (the one containing the header), a SegInfo\nwill be created for that ELF file's mappings, which will include memory\nwhich will be later mmaped by the client's ELF loader.  If a new mmap\nappears in the address range of an existing SegInfo, it will have that\nSegInfo attached to it, presumably because its part of a .so file.\nSimilarly, if a Segment gets split (by mprotect, for example), the two\npieces will still be associated with the same SegInfo.  For this reason,\nthe address/length info in a SegInfo is not a duplicate of the Segment\naddress/length.\n\nThis is complex for several reasons:\n\n   1. We assume that if a process is mmaping a file which contains an\n      ELF header, it intends to use it as an ELF object.  If a program\n      which just mmaps ELF files but just uses it as raw data (copy, for\n      example), we still treat it as a shared-library opening.\n   2. Even if it is being loaded as a shared library/other ELF object,\n      Valgrind doesn't control the mmaps.  It just observes the mmaps\n      being generated by the client and has to cope.  One of the reasons\n      that Valgrind has to make its own mmap of each .so for reading\n      symtab information is because the client won't necessary mmap the\n      right pieces, or do so in the wrong order for us.\n\nSegInfos are reference counted, and freed when no Segments point to them any\nmore.\n\n> Aha.  So the range of a SegInfo will always be equal to or greater\n> than the range of its parent Segment?  Or can you eg. mmap a whole\n> file plus some extra pages, and then the SegInfo won't cover the extra\n> part of the range?\n\nThat would be unusual, but possible.  You could imagine ld generating an\nELF file via a mapping this way (which would probably upset Valgrind no\nend).\n\n-----------------------------------------------------------------------------\nMore from John Reiser\n-----------------------------------------------------------------------------\n> Can a Segment get split (eg. by mprotect)?\n\nThis happens when a debugger inserts a breakpoint, or when ld-linux\nrelocates a module that has DT_TEXTREL, or when a co-resident monitor\nrewrites some instructions.  On x86, a shared lib with relocations to\n.text \"works\" just fine.  The modified pages are no longer sharable,\nbut the instruction stream is functional.  It's even rather common,\nwhen a builder forgets to use -fpic for one or more files.  It\ncan be done on purpose when the modularity is more important than\nthe page sharing.  Non-pic code is faster, too: register %ebx is\nnot dedicated to _GLOBAL_OFFSET_TABLE_ addressing, and global variables\ncan be accessed by [relocated] inline 32-bit offset rather than by\naddress fetched from the GOT.\n\n> Can a new mmap appear in the address range of an existing SegInfo?\n\nOn x86_64 the static linker ld inserts a 1MB \"hole\" between .text\nand .data.  This is on advice from the hardware performance mavens,\nbecause various caching+prefetching hardware can look ahead that far.\nCurrently ld-linux leaves this as PROT_NONE, but anybody else is\nfree to override that assignment.\n\n> From peering at various /proc/*/maps files, the following scheme\n> sounds plausible:\n>\n> Load symbols following an mmap if:\n>\n>   map is to a file\n>   map has r-x permissions\n>   file has a valid ELF header\n>   possibly: mapping is > 1 page (catches the case of mapping first\n>      page just to examine the header)\n>\n> If the client wants to subsequently chop up the mapping, or change its\n> permissions, we ignore that.  I have never seen any evidence in\n> proc/*/maps that ld.so does such things.\n\nglibc-2.3.5 ld-linux does.  It finds the minimum interval of pages which\ncovers the p_memsz of all PT_LOAD, mmap()s that much from the file [even if\nthis maps beyond EOF of the file], then munmap()s [or mprotect(,,PROT_NONE)]\neverything that is not covered by the first PT_LOAD, then\nmmap(,,,MAP_FIXED,,) each remaining PT_LOAD.  This is done to overcome the\npossibility that a kernel which randomizes the placement of mmap(0, ...)\nmight place the first PT_LOAD so that subsequent PT_LOAD [must maintain\nrelative addressing to other PT_LOAD from the same file] would evict\nsomething else.  Needless to say, ld-linux assumes that it is the only actor\n(well, dlopen() does try for mutual exclusion) and that any \"holes\" between\nPT_LOAD from the same module are ignorable as far as allocation is\nconcerned.  Also, there is nothing to stop a file from having PT_LOAD that\noverlap, or appear in non-ascending order, etc.  The results might depend on\norder of processing, but always it has been by order of appearance in the\nfile.  [Probably this is a good way to trigger \"bugs\" in ld-linux and/or the\nkernel.]\n\nSome algorithms and data structures internal to glibc-2.3.5 assume that\nmodules do not overlap.  In particular, ld-linux sometimes searches\nfor __builtin_return_address_(0) in a set of intervals in order to determine\nwhich shared lib called ld-linux.  This matters for dlsym(), dlmopen(),\netc., and assumes that the intervals are a disjoint cover of any\n\"legal\" callers.  ld-linux tries to hide all of this from the prying\neyes of anyone else [the internal version of struct link_map contains\nmuch more than specified in <link.h>].  Some of this is good because\nit changes very frequently, but some parts are bad because in the past\nld-linux has been slow to provide needed services [such as\ndl_iterate_phdr()] and even antagonistic towards anybody else\ntrying for peaceful co-existence without the blessing of ld-linux.\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/perf/fbench.c",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/perf/ffbench.c",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/memcheck/tests/vcpu_fbench.c",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/index.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/images/prev.png",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/images/next.png",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/images/home.png",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/images/kcachegrind_xtree.png",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/images/up.png",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dh-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.readme-s390.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/hg-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/sg-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/manual-core-adv.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.news.old.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.readme-packagers.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.readme-android.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/nl-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/manual-writing-tools.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/mc-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.readme-developers.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/design-impl.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/faq.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.readme-solaris.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/ms-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/cl-format.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/QuickStart.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/bbv-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.readme-missing.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/manual-intro.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/license.gfdl.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.readme-android_emulator.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/license.gpl.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.authors.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/lk-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/cg-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/cl-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.news.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.readme.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/tech-docs.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/index.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/quick-start.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/dist.readme-mips.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/licenses.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/FAQ.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/drd-manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/manual-core.html",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/images/prev.png",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/images/next.png",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/images/home.png",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/images/kcachegrind_xtree.png",
        "/tmp/vanessa/spack-stage/spack-stage-verrou-2.0.0-rssosr5jnx357bwvx3j4k74kj2a7oj5h/spack-src/valgrind-3.13.0/docs/html/images/up.png"
    ],
    "total_files": 5652
}