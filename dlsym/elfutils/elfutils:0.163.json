{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/libebl/eblopenbackend.c": "/* Generate ELF backend handle.\n   Copyright (C) 2000-2015 Red Hat, Inc.\n   This file is part of elfutils.\n\n   This file is free software; you can redistribute it and/or modify\n   it under the terms of either\n\n     * the GNU Lesser General Public License as published by the Free\n       Software Foundation; either version 3 of the License, or (at\n       your option) any later version\n\n   or\n\n     * the GNU General Public License as published by the Free\n       Software Foundation; either version 2 of the License, or (at\n       your option) any later version\n\n   or both in parallel, as here.\n\n   elfutils is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   General Public License for more details.\n\n   You should have received copies of the GNU General Public License and\n   the GNU Lesser General Public License along with this program.  If\n   not, see <http://www.gnu.org/licenses/>.  */\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <assert.h>\n#include <dlfcn.h>\n#include <error.h>\n#include <libelfP.h>\n#include <dwarf.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include <libeblP.h>\n\n\n/* This table should contain the complete list of architectures as far\n   as the ELF specification is concerned.  */\n/* XXX When things are stable replace the string pointers with char\n   arrays to avoid relocations.  */\nstatic const struct\n{\n  const char *dsoname;\n  const char *emulation;\n  const char *prefix;\n  int prefix_len;\n  int em;\n  int class;\n  int data;\n} machines[] =\n{\n  { \"i386\", \"elf_i386\", \"i386\", 4, EM_386, ELFCLASS32, ELFDATA2LSB },\n  { \"ia64\", \"elf_ia64\", \"ia64\", 4, EM_IA_64, ELFCLASS64, ELFDATA2LSB },\n  { \"alpha\", \"elf_alpha\", \"alpha\", 5, EM_ALPHA, ELFCLASS64, ELFDATA2LSB },\n  { \"x86_64\", \"elf_x86_64\", \"x86_64\", 6, EM_X86_64, ELFCLASS64, ELFDATA2LSB },\n  { \"ppc\", \"elf_ppc\", \"ppc\", 3, EM_PPC, ELFCLASS32, ELFDATA2MSB },\n  { \"ppc64\", \"elf_ppc64\", \"ppc64\", 5, EM_PPC64, ELFCLASS64, ELFDATA2MSB },\n  { \"tilegx\", \"elf_tilegx\", \"tilegx\", 6, EM_TILEGX, ELFCLASS64, ELFDATA2LSB },\n  // XXX class and machine fields need to be filled in for all archs.\n  { \"sh\", \"elf_sh\", \"sh\", 2, EM_SH, 0, 0 },\n  { \"arm\", \"ebl_arm\", \"arm\", 3, EM_ARM, 0, 0 },\n  { \"sparc\", \"elf_sparcv9\", \"sparc\", 5, EM_SPARCV9, 0, 0 },\n  { \"sparc\", \"elf_sparc\", \"sparc\", 5, EM_SPARC, 0, 0 },\n  { \"sparc\", \"elf_sparcv8plus\", \"sparc\", 5, EM_SPARC32PLUS, 0, 0 },\n  { \"s390\", \"ebl_s390\", \"s390\", 4, EM_S390, 0, 0 },\n\n  { \"m32\", \"elf_m32\", \"m32\", 3, EM_M32, 0, 0 },\n  { \"m68k\", \"elf_m68k\", \"m68k\", 4, EM_68K, 0, 0 },\n  { \"m88k\", \"elf_m88k\", \"m88k\", 4, EM_88K, 0, 0 },\n  { \"i860\", \"elf_i860\", \"i860\", 4, EM_860, 0, 0 },\n  { \"s370\", \"ebl_s370\", \"s370\", 4, EM_S370, 0, 0 },\n  { \"parisc\", \"elf_parisc\", \"parisc\", 6, EM_PARISC, 0, 0 },\n  { \"vpp500\", \"elf_vpp500\", \"vpp500\", 5, EM_VPP500, 0, 0 },\n  { \"sparc\", \"elf_v8plus\", \"v8plus\", 6, EM_SPARC32PLUS, 0, 0 },\n  { \"i960\", \"elf_i960\", \"i960\", 4, EM_960, 0, 0 },\n  { \"v800\", \"ebl_v800\", \"v800\", 4, EM_V800, 0, 0 },\n  { \"fr20\", \"ebl_fr20\", \"fr20\", 4, EM_FR20, 0, 0 },\n  { \"rh32\", \"ebl_rh32\", \"rh32\", 4, EM_RH32, 0, 0 },\n  { \"rce\", \"ebl_rce\", \"rce\", 3, EM_RCE, 0, 0 },\n  { \"tricore\", \"elf_tricore\", \"tricore\", 7, EM_TRICORE, 0, 0 },\n  { \"arc\", \"elf_arc\", \"arc\", 3, EM_ARC, 0, 0 },\n  { \"h8\", \"elf_h8_300\", \"h8_300\", 6, EM_H8_300, 0, 0 },\n  { \"h8\", \"elf_h8_300h\", \"h8_300h\", 6, EM_H8_300H, 0, 0 },\n  { \"h8\", \"elf_h8s\", \"h8s\", 6, EM_H8S, 0, 0 },\n  { \"h8\", \"elf_h8_500\", \"h8_500\", 6, EM_H8_500, 0, 0 },\n  { \"coldfire\", \"elf_coldfire\", \"coldfire\", 8, EM_COLDFIRE, 0, 0 },\n  { \"m68k\", \"elf_68hc12\", \"68hc12\", 6, EM_68HC12, 0, 0 },\n  { \"mma\", \"elf_mma\", \"mma\", 3, EM_MMA, 0, 0 },\n  { \"pcp\", \"elf_pcp\", \"pcp\", 3, EM_PCP, 0, 0 },\n  { \"ncpu\", \"elf_ncpu\", \"ncpu\", 4, EM_NCPU, 0, 0 },\n  { \"ndr1\", \"elf_ndr1\", \"ndr1\", 4, EM_NDR1, 0, 0 },\n  { \"starcore\", \"elf_starcore\", \"starcore\", 8, EM_STARCORE, 0, 0 },\n  { \"me16\", \"elf_me16\", \"em16\", 4, EM_ME16, 0, 0 },\n  { \"st100\", \"elf_st100\", \"st100\", 5, EM_ST100, 0, 0 },\n  { \"tinyj\", \"elf_tinyj\", \"tinyj\", 5, EM_TINYJ, 0, 0 },\n  { \"pdsp\", \"elf_pdsp\", \"pdsp\", 4, EM_PDSP, 0, 0 },\n  { \"fx66\", \"elf_fx66\", \"fx66\", 4, EM_FX66, 0, 0 },\n  { \"st9plus\", \"elf_st9plus\", \"st9plus\", 7, EM_ST9PLUS, 0, 0 },\n  { \"st7\", \"elf_st7\", \"st7\", 3, EM_ST7, 0, 0 },\n  { \"m68k\", \"elf_68hc16\", \"68hc16\", 6, EM_68HC16, 0, 0 },\n  { \"m68k\", \"elf_68hc11\", \"68hc11\", 6, EM_68HC11, 0, 0 },\n  { \"m68k\", \"elf_68hc08\", \"68hc08\", 6, EM_68HC08, 0, 0 },\n  { \"m68k\", \"elf_68hc05\", \"68hc05\", 6, EM_68HC05, 0, 0 },\n  { \"svx\", \"elf_svx\", \"svx\", 3, EM_SVX, 0, 0 },\n  { \"st19\", \"elf_st19\", \"st19\", 4, EM_ST19, 0, 0 },\n  { \"vax\", \"elf_vax\", \"vax\", 3, EM_VAX, 0, 0 },\n  { \"cris\", \"elf_cris\", \"cris\", 4, EM_CRIS, 0, 0 },\n  { \"javelin\", \"elf_javelin\", \"javelin\", 7, EM_JAVELIN, 0, 0 },\n  { \"firepath\", \"elf_firepath\", \"firepath\", 8, EM_FIREPATH, 0, 0 },\n  { \"zsp\", \"elf_zsp\", \"zsp\", 3, EM_ZSP, 0, 0 },\n  { \"mmix\", \"elf_mmix\", \"mmix\", 4, EM_MMIX, 0, 0 },\n  { \"hunay\", \"elf_huany\", \"huany\", 5, EM_HUANY, 0, 0 },\n  { \"prism\", \"elf_prism\", \"prism\", 5, EM_PRISM, 0, 0 },\n  { \"avr\", \"elf_avr\", \"avr\", 3, EM_AVR, 0, 0 },\n  { \"fr30\", \"elf_fr30\", \"fr30\", 4, EM_FR30, 0, 0 },\n  { \"dv10\", \"elf_dv10\", \"dv10\", 4, EM_D10V, 0, 0 },\n  { \"dv30\", \"elf_dv30\", \"dv30\", 4, EM_D30V, 0, 0 },\n  { \"v850\", \"elf_v850\", \"v850\", 4, EM_V850, 0, 0 },\n  { \"m32r\", \"elf_m32r\", \"m32r\", 4, EM_M32R, 0, 0 },\n  { \"mn10300\", \"elf_mn10300\", \"mn10300\", 7, EM_MN10300, 0, 0 },\n  { \"mn10200\", \"elf_mn10200\", \"mn10200\", 7, EM_MN10200, 0, 0 },\n  { \"pj\", \"elf_pj\", \"pj\", 2, EM_PJ, 0, 0 },\n  { \"openrisc\", \"elf_openrisc\", \"openrisc\", 8, EM_OPENRISC, 0, 0 },\n  { \"arc\", \"elf_arc_a5\", \"arc_a5\", 6, EM_ARC_A5, 0, 0 },\n  { \"xtensa\", \"elf_xtensa\", \"xtensa\", 6, EM_XTENSA, 0, 0 },\n  { \"aarch64\", \"elf_aarch64\", \"aarch64\", 7, EM_AARCH64, ELFCLASS64, 0 },\n};\n#define nmachines (sizeof (machines) / sizeof (machines[0]))\n\n/* No machine prefix should be larger than this.  */\n#define MAX_PREFIX_LEN 16\n\n/* Default callbacks.  Mostly they just return the error value.  */\nstatic const char *default_object_type_name (int ignore, char *buf,\n\t\t\t\t\t     size_t len);\nstatic const char *default_reloc_type_name (int ignore, char *buf, size_t len);\nstatic bool default_reloc_type_check (int ignore);\nstatic bool default_reloc_valid_use (Elf *elf, int ignore);\nstatic Elf_Type default_reloc_simple_type (Ebl *ebl, int ignore);\nstatic bool default_gotpc_reloc_check (Elf *elf, int ignore);\nstatic const char *default_segment_type_name (int ignore, char *buf,\n\t\t\t\t\t      size_t len);\nstatic const char *default_section_type_name (int ignore, char *buf,\n\t\t\t\t\t      size_t len);\nstatic const char *default_section_name (int ignore, int ignore2, char *buf,\n\t\t\t\t\t size_t len);\nstatic const char *default_machine_flag_name (Elf64_Word *ignore);\nstatic bool default_machine_flag_check (Elf64_Word flags);\nstatic bool default_machine_section_flag_check (GElf_Xword flags);\nstatic const char *default_symbol_type_name (int ignore, char *buf,\n\t\t\t\t\t     size_t len);\nstatic const char *default_symbol_binding_name (int ignore, char *buf,\n\t\t\t\t\t\tsize_t len);\nstatic const char *default_dynamic_tag_name (int64_t ignore, char *buf,\n\t\t\t\t\t     size_t len);\nstatic bool default_dynamic_tag_check (int64_t ignore);\nstatic GElf_Word default_sh_flags_combine (GElf_Word flags1, GElf_Word flags2);\nstatic const char *default_osabi_name (int ignore, char *buf, size_t len);\nstatic void default_destr (struct ebl *ignore);\nstatic const char *default_core_note_type_name (uint32_t, char *buf,\n\t\t\t\t\t\tsize_t len);\nstatic const char *default_object_note_type_name (const char *name, uint32_t,\n\t\t\t\t\t\t  char *buf, size_t len);\nstatic int default_core_note (const GElf_Nhdr *nhdr, const char *name,\n\t\t\t      GElf_Word *regs_offset, size_t *nregloc,\n\t\t\t      const Ebl_Register_Location **reglocs,\n\t\t\t      size_t *nitems, const Ebl_Core_Item **);\nstatic int default_auxv_info (GElf_Xword a_type,\n\t\t\t      const char **name, const char **format);\nstatic bool default_object_note (const char *name, uint32_t type,\n\t\t\t\t uint32_t descsz, const char *desc);\nstatic bool default_debugscn_p (const char *name);\nstatic bool default_copy_reloc_p (int reloc);\nstatic bool default_none_reloc_p (int reloc);\nstatic bool default_relative_reloc_p (int reloc);\nstatic bool default_check_special_symbol (Elf *elf, GElf_Ehdr *ehdr,\n\t\t\t\t\t  const GElf_Sym *sym,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  const GElf_Shdr *destshdr);\nstatic bool default_check_st_other_bits (unsigned char st_other);\nstatic bool default_check_special_section (Ebl *, int,\n\t\t\t\t\t   const GElf_Shdr *, const char *);\nstatic bool default_bss_plt_p (Elf *elf);\nstatic int default_return_value_location (Dwarf_Die *functypedie,\n\t\t\t\t\t  const Dwarf_Op **locops);\nstatic ssize_t default_register_info (Ebl *ebl,\n\t\t\t\t      int regno, char *name, size_t namelen,\n\t\t\t\t      const char **prefix,\n\t\t\t\t      const char **setname,\n\t\t\t\t      int *bits, int *type);\nstatic int default_syscall_abi (Ebl *ebl, int *sp, int *pc,\n\t\t\t\tint *callno, int args[6]);\nstatic bool default_check_object_attribute (Ebl *ebl, const char *vendor,\n\t\t\t\t\t    int tag, uint64_t value,\n\t\t\t\t\t    const char **tag_name,\n\t\t\t\t\t    const char **value_name);\nstatic bool default_check_reloc_target_type (Ebl *ebl, Elf64_Word sh_type);\nstatic int default_abi_cfi (Ebl *ebl, Dwarf_CIE *abi_info);\n\n\nstatic void\nfill_defaults (Ebl *result)\n{\n  result->object_type_name = default_object_type_name;\n  result->reloc_type_name = default_reloc_type_name;\n  result->reloc_type_check = default_reloc_type_check;\n  result->reloc_valid_use = default_reloc_valid_use;\n  result->reloc_simple_type = default_reloc_simple_type;\n  result->gotpc_reloc_check = default_gotpc_reloc_check;\n  result->segment_type_name = default_segment_type_name;\n  result->section_type_name = default_section_type_name;\n  result->section_name = default_section_name;\n  result->machine_flag_name = default_machine_flag_name;\n  result->machine_flag_check = default_machine_flag_check;\n  result->machine_section_flag_check = default_machine_section_flag_check;\n  result->check_special_section = default_check_special_section;\n  result->symbol_type_name = default_symbol_type_name;\n  result->symbol_binding_name = default_symbol_binding_name;\n  result->dynamic_tag_name = default_dynamic_tag_name;\n  result->dynamic_tag_check = default_dynamic_tag_check;\n  result->sh_flags_combine = default_sh_flags_combine;\n  result->osabi_name = default_osabi_name;\n  result->core_note_type_name = default_core_note_type_name;\n  result->object_note_type_name = default_object_note_type_name;\n  result->core_note = default_core_note;\n  result->auxv_info = default_auxv_info;\n  result->object_note = default_object_note;\n  result->debugscn_p = default_debugscn_p;\n  result->copy_reloc_p = default_copy_reloc_p;\n  result->none_reloc_p = default_none_reloc_p;\n  result->relative_reloc_p = default_relative_reloc_p;\n  result->check_special_symbol = default_check_special_symbol;\n  result->check_st_other_bits = default_check_st_other_bits;\n  result->bss_plt_p = default_bss_plt_p;\n  result->return_value_location = default_return_value_location;\n  result->register_info = default_register_info;\n  result->syscall_abi = default_syscall_abi;\n  result->check_object_attribute = default_check_object_attribute;\n  result->check_reloc_target_type = default_check_reloc_target_type;\n  result->disasm = NULL;\n  result->abi_cfi = default_abi_cfi;\n  result->destr = default_destr;\n  result->sysvhash_entrysize = sizeof (Elf32_Word);\n}\n\n\n/* Find an appropriate backend for the file associated with ELF.  */\nstatic Ebl *\nopenbackend (elf, emulation, machine)\n     Elf *elf;\n     const char *emulation;\n     GElf_Half machine;\n{\n  Ebl *result;\n  size_t cnt;\n\n  /* First allocate the data structure for the result.  We do this\n     here since this assures that the structure is always large\n     enough.  */\n  result = (Ebl *) calloc (1, sizeof (Ebl));\n  if (result == NULL)\n    {\n      // XXX uncomment\n      // __libebl_seterror (ELF_E_NOMEM);\n      return NULL;\n    }\n\n  /* Fill in the default callbacks.  The initializer for the machine\n     specific module can overwrite the values.  */\n  fill_defaults (result);\n\n  /* XXX Currently all we do is to look at 'e_machine' value in the\n     ELF header.  With an internal mapping table from EM_* value to\n     DSO name we try to load the appropriate module to handle this\n     binary type.\n\n     Multiple modules for the same machine type are possible and they\n     will be tried in sequence.  The lookup process will only stop\n     when a module which can handle the machine type is found or all\n     available matching modules are tried.  */\n  for (cnt = 0; cnt < nmachines; ++cnt)\n    if ((emulation != NULL && strcmp (emulation, machines[cnt].emulation) == 0)\n\t|| (emulation == NULL && machines[cnt].em == machine))\n      {\n\t/* Well, we know the emulation name now.  */\n\tresult->emulation = machines[cnt].emulation;\n\n\t/* We access some data structures directly.  Make sure the 32 and\n\t   64 bit variants are laid out the same.  */\n\tassert (offsetof (Elf32_Ehdr, e_machine)\n\t\t== offsetof (Elf64_Ehdr, e_machine));\n\tassert (sizeof (((Elf32_Ehdr *) 0)->e_machine)\n\t\t== sizeof (((Elf64_Ehdr *) 0)->e_machine));\n\tassert (offsetof (Elf, state.elf32.ehdr)\n\t\t== offsetof (Elf, state.elf64.ehdr));\n\n\t/* Prefer taking the information from the ELF file.  */\n\tif (elf == NULL)\n\t  {\n\t    result->machine = machines[cnt].em;\n\t    result->class = machines[cnt].class;\n\t    result->data = machines[cnt].data;\n\t  }\n\telse\n\t  {\n\t    result->machine = elf->state.elf32.ehdr->e_machine;\n\t    result->class = elf->state.elf32.ehdr->e_ident[EI_CLASS];\n\t    result->data = elf->state.elf32.ehdr->e_ident[EI_DATA];\n\t  }\n\n#ifndef LIBEBL_SUBDIR\n# define LIBEBL_SUBDIR PACKAGE\n#endif\n#define ORIGINDIR \"$ORIGIN/../$LIB/\" LIBEBL_SUBDIR \"/\"\n\n\t/* Give it a try.  At least the machine type matches.  First\n           try to load the module.  */\n\tchar dsoname[100];\n\tstrcpy (stpcpy (stpcpy (dsoname, ORIGINDIR \"libebl_\"),\n\t\t\tmachines[cnt].dsoname),\n\t\t\".so\");\n\n\tvoid *h = dlopen (dsoname, RTLD_LAZY);\n\tif (h == NULL)\n\t  {\n\t    strcpy (stpcpy (stpcpy (dsoname, \"libebl_\"),\n\t\t\t    machines[cnt].dsoname),\n\t\t    \".so\");\n\t    h = dlopen (dsoname, RTLD_LAZY);\n\t  }\n\n\t  /* Try without an explicit path.  */\n\tif (h != NULL)\n\t  {\n\t    /* We managed to load the object.  Now see whether the\n\t       initialization function likes our file.  */\n\t    static const char version[] = MODVERSION;\n\t    const char *modversion;\n\t    ebl_bhinit_t initp;\n\n\t    // We use a static number to help the compiler see we don't\n\t    // overflow the stack with an arbitrary number.\n\t    assert (machines[cnt].prefix_len <= MAX_PREFIX_LEN);\n\t    char symname[MAX_PREFIX_LEN + sizeof \"_init\"];\n\n\t    strcpy (mempcpy (symname, machines[cnt].prefix,\n\t\t\t     machines[cnt].prefix_len), \"_init\");\n\n\t    initp = (ebl_bhinit_t) dlsym (h, symname);\n\t    if (initp != NULL\n\t\t&& (modversion = initp (elf, machine, result, sizeof (Ebl)))\n\t\t&& strcmp (version, modversion) == 0)\n\t      {\n\t\t/* We found a module to handle our file.  */\n\t\tresult->dlhandle = h;\n\t\tresult->elf = elf;\n\n\t\t/* A few entries are mandatory.  */\n\t\tassert (result->name != NULL);\n\t\tassert (result->destr != NULL);\n\n\t\treturn result;\n\t      }\n\n\t    /* Not the module we need.  */\n\t    (void) dlclose (h);\n\t  }\n\n\t/* We cannot find a DSO but the emulation/machine ID matches.\n\t   Return that information.  */\n\tresult->dlhandle = NULL;\n\tresult->elf = elf;\n\tresult->name = machines[cnt].prefix;\n\tfill_defaults (result);\n\n\treturn result;\n      }\n\n  /* Nothing matched.  We use only the default callbacks.   */\n  result->dlhandle = NULL;\n  result->elf = elf;\n  result->emulation = \"<unknown>\";\n  result->name = \"<unknown>\";\n  fill_defaults (result);\n\n  return result;\n}\n\n\n/* Find an appropriate backend for the file associated with ELF.  */\nEbl *\nebl_openbackend (elf)\n     Elf *elf;\n{\n  GElf_Ehdr ehdr_mem;\n  GElf_Ehdr *ehdr;\n\n  /* Get the ELF header of the object.  */\n  ehdr = gelf_getehdr (elf, &ehdr_mem);\n  if (ehdr == NULL)\n    {\n      // XXX uncomment\n      // __libebl_seterror (elf_errno ());\n      return NULL;\n    }\n\n  return openbackend (elf, NULL, ehdr->e_machine);\n}\n\n\n/* Find backend without underlying ELF file.  */\nEbl *\nebl_openbackend_machine (machine)\n     GElf_Half machine;\n{\n  return openbackend (NULL, NULL, machine);\n}\n\n\n/* Find backend with given emulation name.  */\nEbl *\nebl_openbackend_emulation (const char *emulation)\n{\n  return openbackend (NULL, emulation, EM_NONE);\n}\n\n\n/* Default callbacks.  Mostly they just return the error value.  */\nstatic const char *\ndefault_object_type_name (int ignore __attribute__ ((unused)),\n\t\t\t  char *buf __attribute__ ((unused)),\n\t\t\t  size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic const char *\ndefault_reloc_type_name (int ignore __attribute__ ((unused)),\n\t\t\t char *buf __attribute__ ((unused)),\n\t\t\t size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic bool\ndefault_reloc_type_check (int ignore __attribute__ ((unused)))\n{\n  return false;\n}\n\nstatic bool\ndefault_reloc_valid_use (Elf *elf __attribute__ ((unused)),\n\t\t\t int ignore __attribute__ ((unused)))\n{\n  return false;\n}\n\nstatic Elf_Type\ndefault_reloc_simple_type (Ebl *eh __attribute__ ((unused)),\n\t\t\t   int ignore __attribute__ ((unused)))\n{\n  return ELF_T_NUM;\n}\n\nstatic bool\ndefault_gotpc_reloc_check (Elf *elf __attribute__ ((unused)),\n\t\t\t   int ignore __attribute__ ((unused)))\n{\n  return false;\n}\n\nstatic const char *\ndefault_segment_type_name (int ignore __attribute__ ((unused)),\n\t\t\t   char *buf __attribute__ ((unused)),\n\t\t\t   size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic const char *\ndefault_section_type_name (int ignore __attribute__ ((unused)),\n\t\t\t   char *buf __attribute__ ((unused)),\n\t\t\t   size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic const char *\ndefault_section_name (int ignore __attribute__ ((unused)),\n\t\t      int ignore2 __attribute__ ((unused)),\n\t\t      char *buf __attribute__ ((unused)),\n\t\t      size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic const char *\ndefault_machine_flag_name (Elf64_Word *ignore __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic bool\ndefault_machine_flag_check (Elf64_Word flags __attribute__ ((unused)))\n{\n  return flags == 0;\n}\n\nstatic bool\ndefault_machine_section_flag_check (GElf_Xword flags)\n{\n  return flags == 0;\n}\n\nstatic bool\ndefault_check_special_section (Ebl *ebl __attribute__ ((unused)),\n\t\t\t       int ndx __attribute__ ((unused)),\n\t\t\t       const GElf_Shdr *shdr __attribute__ ((unused)),\n\t\t\t       const char *sname __attribute__ ((unused)))\n{\n  return false;\n}\n\nstatic const char *\ndefault_symbol_type_name (int ignore __attribute__ ((unused)),\n\t\t\t  char *buf __attribute__ ((unused)),\n\t\t\t  size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic const char *\ndefault_symbol_binding_name (int ignore __attribute__ ((unused)),\n\t\t\t     char *buf __attribute__ ((unused)),\n\t\t\t     size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic const char *\ndefault_dynamic_tag_name (int64_t ignore __attribute__ ((unused)),\n\t\t\t  char *buf __attribute__ ((unused)),\n\t\t\t  size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic bool\ndefault_dynamic_tag_check (int64_t ignore __attribute__ ((unused)))\n{\n  return false;\n}\n\nstatic GElf_Word\ndefault_sh_flags_combine (GElf_Word flags1, GElf_Word flags2)\n{\n  return SH_FLAGS_COMBINE (flags1, flags2);\n}\n\nstatic void\ndefault_destr (struct ebl *ignore __attribute__ ((unused)))\n{\n}\n\nstatic const char *\ndefault_osabi_name (int ignore __attribute__ ((unused)),\n\t\t    char *buf __attribute__ ((unused)),\n\t\t    size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic const char *\ndefault_core_note_type_name (uint32_t ignore __attribute__ ((unused)),\n\t\t\t     char *buf __attribute__ ((unused)),\n\t\t\t     size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic int\ndefault_auxv_info (GElf_Xword a_type __attribute__ ((unused)),\n\t\t   const char **name __attribute__ ((unused)),\n\t\t   const char **format __attribute__ ((unused)))\n{\n  return 0;\n}\n\nstatic int\ndefault_core_note (const GElf_Nhdr *nhdr __attribute__ ((unused)),\n\t\t   const char *name __attribute__ ((unused)),\n\t\t   GElf_Word *ro __attribute__ ((unused)),\n\t\t   size_t *nregloc  __attribute__ ((unused)),\n\t\t   const Ebl_Register_Location **reglocs\n\t\t   __attribute__ ((unused)),\n\t\t   size_t *nitems __attribute__ ((unused)),\n\t\t   const Ebl_Core_Item **items __attribute__ ((unused)))\n{\n  return 0;\n}\n\nstatic const char *\ndefault_object_note_type_name (const char *name __attribute__ ((unused)),\n\t\t\t       uint32_t ignore __attribute__ ((unused)),\n\t\t\t       char *buf __attribute__ ((unused)),\n\t\t\t       size_t len __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic bool\ndefault_object_note (const char *name __attribute__ ((unused)),\n\t\t     uint32_t type __attribute__ ((unused)),\n\t\t     uint32_t descsz __attribute__ ((unused)),\n\t\t     const char *desc __attribute__ ((unused)))\n{\n  return NULL;\n}\n\nstatic bool\ndefault_debugscn_p (const char *name)\n{\n  /* We know by default only about the DWARF debug sections which have\n     fixed names.  */\n  static const char *dwarf_scn_names[] =\n    {\n      /* DWARF 1 */\n      \".debug\",\n      \".line\",\n      /* GNU DWARF 1 extensions */\n      \".debug_srcinfo\",\n      \".debug_sfnames\",\n      /* DWARF 1.1 and DWARF 2 */\n      \".debug_aranges\",\n      \".debug_pubnames\",\n      /* DWARF 2 */\n      \".debug_info\",\n      \".debug_abbrev\",\n      \".debug_line\",\n      \".debug_frame\",\n      \".debug_str\",\n      \".debug_loc\",\n      \".debug_macinfo\",\n      /* DWARF 3 */\n      \".debug_ranges\",\n      \".debug_pubtypes\",\n      /* DWARF 4 */\n      \".debug_types\",\n      /* GDB DWARF 4 extension */\n      \".gdb_index\",\n      /* GNU/DWARF 5 extension/proposal */\n      \".debug_macro\",\n      /* SGI/MIPS DWARF 2 extensions */\n      \".debug_weaknames\",\n      \".debug_funcnames\",\n      \".debug_typenames\",\n      \".debug_varnames\"\n    };\n  const size_t ndwarf_scn_names = (sizeof (dwarf_scn_names)\n\t\t\t\t   / sizeof (dwarf_scn_names[0]));\n  for (size_t cnt = 0; cnt < ndwarf_scn_names; ++cnt)\n    if (strcmp (name, dwarf_scn_names[cnt]) == 0)\n      return true;\n\n  return false;\n}\n\nstatic bool\ndefault_copy_reloc_p (int reloc __attribute__ ((unused)))\n{\n  return false;\n}\nstrong_alias (default_copy_reloc_p, default_none_reloc_p)\nstrong_alias (default_copy_reloc_p, default_relative_reloc_p)\n\nstatic bool\ndefault_check_special_symbol (Elf *elf __attribute__ ((unused)),\n\t\t\t      GElf_Ehdr *ehdr __attribute__ ((unused)),\n\t\t\t      const GElf_Sym *sym __attribute__ ((unused)),\n\t\t\t      const char *name __attribute__ ((unused)),\n\t\t\t      const GElf_Shdr *destshdr __attribute__ ((unused)))\n{\n  return false;\n}\n\nstatic bool\ndefault_check_st_other_bits (unsigned char st_other __attribute__ ((unused)))\n{\n  return false;\n}\n\n\nstatic bool\ndefault_bss_plt_p (Elf *elf __attribute__ ((unused)))\n{\n  return false;\n}\n\nstatic int\ndefault_return_value_location (Dwarf_Die *functypedie __attribute__ ((unused)),\n\t\t\t       const Dwarf_Op **locops __attribute__ ((unused)))\n{\n  return -2;\n}\n\nstatic ssize_t\ndefault_register_info (Ebl *ebl __attribute__ ((unused)),\n\t\t       int regno, char *name, size_t namelen,\n\t\t       const char **prefix,\n\t\t       const char **setname,\n\t\t       int *bits, int *type)\n{\n  if (name == NULL)\n    return 0;\n\n  *setname = \"???\";\n  *prefix = \"\";\n  *bits = -1;\n  *type = DW_ATE_void;\n  return snprintf (name, namelen, \"reg%d\", regno);\n}\n\nstatic int\ndefault_syscall_abi (Ebl *ebl __attribute__ ((unused)),\n\t\t     int *sp, int *pc, int *callno, int args[6])\n{\n  *sp = *pc = *callno = -1;\n  args[0] = -1;\n  args[1] = -1;\n  args[2] = -1;\n  args[3] = -1;\n  args[4] = -1;\n  args[5] = -1;\n  return -1;\n}\n\nstatic bool\ndefault_check_object_attribute (Ebl *ebl __attribute__ ((unused)),\n\t\t\t\tconst char *vendor  __attribute__ ((unused)),\n\t\t\t\tint tag __attribute__ ((unused)),\n\t\t\t\tuint64_t value __attribute__ ((unused)),\n\t\t\t\tconst char **tag_name, const char **value_name)\n{\n  *tag_name = NULL;\n  *value_name = NULL;\n  return false;\n}\n\nstatic bool\ndefault_check_reloc_target_type (Ebl *ebl __attribute__ ((unused)),\n\t\t\t\t Elf64_Word sh_type __attribute__ ((unused)))\n{\n  return false;\n}\n\nstatic int\ndefault_abi_cfi (Ebl *ebl __attribute__ ((unused)),\n\t\t Dwarf_CIE *abi_info __attribute__ ((unused)))\n{\n  return -1;\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/src/ldgeneric.c": "/* Copyright (C) 2001-2011 Red Hat, Inc.\n   This file is part of elfutils.\n   Written by Ulrich Drepper <drepper@redhat.com>, 2001.\n\n   This file is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3 of the License, or\n   (at your option) any later version.\n\n   elfutils is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <assert.h>\n#include <ctype.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <error.h>\n#include <fcntl.h>\n#include <fnmatch.h>\n#include <gelf.h>\n#include <inttypes.h>\n#include <libintl.h>\n#include <stdbool.h>\n#include <stdio_ext.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n\n#include <elf-knowledge.h>\n#include \"ld.h\"\n#include \"list.h\"\n#include <md5.h>\n#include <sha1.h>\n#include <system.h>\n\n\n/* Header of .eh_frame_hdr section.  */\nstruct unw_eh_frame_hdr\n{\n  unsigned char version;\n  unsigned char eh_frame_ptr_enc;\n  unsigned char fde_count_enc;\n  unsigned char table_enc;\n};\n#define EH_FRAME_HDR_VERSION 1\n\n\n/* Prototypes for local functions.  */\nstatic const char **ld_generic_lib_extensions (struct ld_state *)\n     __attribute__ ((__const__));\nstatic int ld_generic_file_close (struct usedfiles *fileinfo,\n\t\t\t\t  struct ld_state *statep);\nstatic int ld_generic_file_process (int fd, struct usedfiles *fileinfo,\n\t\t\t\t    struct ld_state *statep,\n\t\t\t\t    struct usedfiles **nextp);\nstatic void ld_generic_generate_sections (struct ld_state *statep);\nstatic void ld_generic_create_sections (struct ld_state *statep);\nstatic int ld_generic_flag_unresolved (struct ld_state *statep);\nstatic int ld_generic_open_outfile (struct ld_state *statep, int machine,\n\t\t\t\t    int class, int data);\nstatic int ld_generic_create_outfile (struct ld_state *statep);\nstatic void ld_generic_relocate_section (struct ld_state *statep,\n\t\t\t\t\t Elf_Scn *outscn,\n\t\t\t\t\t struct scninfo *firstp,\n\t\t\t\t\t const Elf32_Word *dblindirect);\nstatic int ld_generic_finalize (struct ld_state *statep);\nstatic bool ld_generic_special_section_number_p (struct ld_state *statep,\n\t\t\t\t\t\t size_t number);\nstatic bool ld_generic_section_type_p (struct ld_state *statep,\n\t\t\t\t       XElf_Word type);\nstatic XElf_Xword ld_generic_dynamic_section_flags (struct ld_state *statep);\nstatic void ld_generic_initialize_plt (struct ld_state *statep, Elf_Scn *scn);\nstatic void ld_generic_initialize_pltrel (struct ld_state *statep,\n\t\t\t\t\t  Elf_Scn *scn);\nstatic void ld_generic_initialize_got (struct ld_state *statep, Elf_Scn *scn);\nstatic void ld_generic_initialize_gotplt (struct ld_state *statep,\n\t\t\t\t\t  Elf_Scn *scn);\nstatic void ld_generic_finalize_plt (struct ld_state *statep, size_t nsym,\n\t\t\t\t     size_t nsym_dyn,\n\t\t\t\t     struct symbol **ndxtosymp);\nstatic int ld_generic_rel_type (struct ld_state *statep);\nstatic void ld_generic_count_relocations (struct ld_state *statep,\n\t\t\t\t\t  struct scninfo *scninfo);\nstatic void ld_generic_create_relocations (struct ld_state *statep,\n\t\t\t\t\t   const Elf32_Word *dblindirect);\n\nstatic int file_process2 (struct usedfiles *fileinfo);\nstatic void mark_section_used (struct scninfo *scninfo, Elf32_Word shndx,\n\t\t\t       struct scninfo **grpscnp);\n\n\n/* Map symbol index to struct symbol record.  */\nstatic struct symbol **ndxtosym;\n\n/* String table reference to all symbols in the symbol table.  */\nstatic struct Ebl_Strent **symstrent;\n\n\n/* Check whether file associated with FD is a DSO.  */\nstatic bool\nis_dso_p (int fd)\n{\n  /* We have to read the 'e_type' field.  It has the same size (16\n     bits) in 32- and 64-bit ELF.  */\n  XElf_Half e_type;\n\n  return (pread (fd, &e_type, sizeof (e_type), offsetof (XElf_Ehdr, e_type))\n\t  == sizeof (e_type)\n\t  && e_type == ET_DYN);\n}\n\n\n/* Print the complete name of a file, including the archive it is\n   contained in.  */\nstatic int\nprint_file_name (FILE *s, struct usedfiles *fileinfo, int first_level,\n\t\t int newline)\n{\n  int npar = 0;\n\n  if (fileinfo->archive_file != NULL)\n    {\n      npar = print_file_name (s, fileinfo->archive_file, 0, 0) + 1;\n      fputc_unlocked ('(', s);\n      fputs_unlocked (fileinfo->rfname, s);\n\n      if (first_level)\n\twhile (npar-- > 0)\n\t  fputc_unlocked (')', s);\n    }\n  else\n    fputs_unlocked (fileinfo->rfname, s);\n\n  if (first_level && newline)\n    fputc_unlocked ('\\n', s);\n\n  return npar;\n}\n\n\n/* Function to determine whether an object will be dynamically linked.  */\nbool\ndynamically_linked_p (void)\n{\n  return (ld_state.file_type == dso_file_type || ld_state.nplt > 0\n\t  || ld_state.ngot > 0);\n}\n\n\nbool\nlinked_from_dso_p (struct scninfo *scninfo, size_t symidx)\n{\n  struct usedfiles *file = scninfo->fileinfo;\n\n  /* If this symbol is not undefined in this file it cannot come from\n     a DSO.  */\n  if (symidx < file->nlocalsymbols)\n    return false;\n\n  struct symbol *sym = file->symref[symidx];\n\n  return sym->defined && sym->in_dso;\n}\n\n\n/* Initialize state object.  This callback function is called after the\n   parameters are parsed but before any file is searched for.  */\nint\nld_prepare_state (const char *emulation)\n{\n  /* When generating DSO we normally allow undefined symbols.  */\n  ld_state.nodefs = true;\n\n  /* To be able to detect problems we add a .comment section entry by\n     default.  */\n  ld_state.add_ld_comment = true;\n\n  /* XXX We probably should find a better place for this.  The index\n     of the first user-defined version is 2.  */\n  ld_state.nextveridx = 2;\n\n  /* Pick an not too small number for the initial size of the tables.  */\n  ld_symbol_tab_init (&ld_state.symbol_tab, 1027);\n  ld_section_tab_init (&ld_state.section_tab, 67);\n  ld_version_str_tab_init (&ld_state.version_str_tab, 67);\n\n  /* Initialize the section header string table.  */\n  ld_state.shstrtab = ebl_strtabinit (true);\n  if (ld_state.shstrtab == NULL)\n    error (EXIT_FAILURE, errno, gettext (\"cannot create string table\"));\n\n  /* Initialize the callbacks.  These are the defaults, the appropriate\n     backend can later install its own callbacks.  */\n  ld_state.callbacks.lib_extensions = ld_generic_lib_extensions;\n  ld_state.callbacks.file_process = ld_generic_file_process;\n  ld_state.callbacks.file_close = ld_generic_file_close;\n  ld_state.callbacks.generate_sections = ld_generic_generate_sections;\n  ld_state.callbacks.create_sections = ld_generic_create_sections;\n  ld_state.callbacks.flag_unresolved = ld_generic_flag_unresolved;\n  ld_state.callbacks.open_outfile = ld_generic_open_outfile;\n  ld_state.callbacks.create_outfile = ld_generic_create_outfile;\n  ld_state.callbacks.relocate_section = ld_generic_relocate_section;\n  ld_state.callbacks.finalize = ld_generic_finalize;\n  ld_state.callbacks.special_section_number_p =\n    ld_generic_special_section_number_p;\n  ld_state.callbacks.section_type_p = ld_generic_section_type_p;\n  ld_state.callbacks.dynamic_section_flags = ld_generic_dynamic_section_flags;\n  ld_state.callbacks.initialize_plt = ld_generic_initialize_plt;\n  ld_state.callbacks.initialize_pltrel = ld_generic_initialize_pltrel;\n  ld_state.callbacks.initialize_got = ld_generic_initialize_got;\n  ld_state.callbacks.initialize_gotplt = ld_generic_initialize_gotplt;\n  ld_state.callbacks.finalize_plt = ld_generic_finalize_plt;\n  ld_state.callbacks.rel_type = ld_generic_rel_type;\n  ld_state.callbacks.count_relocations = ld_generic_count_relocations;\n  ld_state.callbacks.create_relocations = ld_generic_create_relocations;\n\n#ifndef BASE_ELF_NAME\n  /* Find the ld backend library.  Use EBL to determine the name if\n     the user hasn't provided one on the command line.  */\n  if (emulation == NULL)\n    {\n      emulation = ebl_backend_name (ld_state.ebl);\n      assert (emulation != NULL);\n    }\n  size_t emulation_len = strlen (emulation);\n\n  /* Construct the file name.  */\n  char *fname = (char *) alloca (sizeof \"libld_\" - 1 + emulation_len\n\t\t\t\t + sizeof \".so\");\n  strcpy (mempcpy (stpcpy (fname, \"libld_\"), emulation, emulation_len), \".so\");\n\n  /* Try loading.  */\n  void *h = dlopen (fname, RTLD_LAZY);\n  if (h == NULL)\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot load ld backend library '%s': %s\"),\n\t   fname, dlerror ());\n\n  /* Find the initializer.  It must be present.  */\n  char *initname = (char *) alloca (emulation_len + sizeof \"_ld_init\");\n  strcpy (mempcpy (initname, emulation, emulation_len), \"_ld_init\");\n  int (*initfct) (struct ld_state *)\n    = (int (*) (struct ld_state *)) dlsym (h, initname);\n\n  if (initfct == NULL)\n    error (EXIT_FAILURE, 0, gettext (\"\\\ncannot find init function in ld backend library '%s': %s\"),\n\t   fname, dlerror ());\n\n  /* Store the handle.  */\n  ld_state.ldlib = h;\n\n  /* Call the init function.  */\n  return initfct (&ld_state);\n#else\n# define INIT_FCT_NAME(base) _INIT_FCT_NAME(base)\n# define _INIT_FCT_NAME(base) base##_ld_init\n  /* Declare and call the initialization function.  */\n  extern int INIT_FCT_NAME(BASE_ELF_NAME) (struct ld_state *);\n  return INIT_FCT_NAME(BASE_ELF_NAME) (&ld_state);\n#endif\n}\n\n\nstatic int\ncheck_for_duplicate2 (struct usedfiles *newp, struct usedfiles *list)\n{\n  struct usedfiles *first;\n\n  if (list == NULL)\n    return 0;\n\n  list = first = list->next;\n  do\n    {\n      /* When searching the needed list we might come across entries\n\t for files which are not yet opened.  Stop then, there is\n\t nothing more to test.  */\n      if (likely (list->status == not_opened))\n\tbreak;\n\n      if (unlikely (list->ino == newp->ino)\n\t  && unlikely (list->dev == newp->dev))\n\t{\n\t  close (newp->fd);\n\t  newp->fd = -1;\n\t  newp->status = closed;\n\t  if (newp->file_type == relocatable_file_type)\n\t    error (0, 0, gettext (\"%s listed more than once as input\"),\n\t\t   newp->rfname);\n\n\t  return 1;\n\t}\n      list = list->next;\n    }\n  while (likely (list != first));\n\n  return 0;\n}\n\n\nstatic int\ncheck_for_duplicate (struct usedfiles *newp)\n{\n  struct stat st;\n\n  if (unlikely (fstat (newp->fd, &st) < 0))\n    {\n      close (newp->fd);\n      return errno;\n    }\n\n  newp->dev = st.st_dev;\n  newp->ino = st.st_ino;\n\n  return (check_for_duplicate2 (newp, ld_state.relfiles)\n\t  || check_for_duplicate2 (newp, ld_state.dsofiles)\n\t  || check_for_duplicate2 (newp, ld_state.needed));\n}\n\n\n/* Find a file along the path described in the state.  */\nstatic int\nopen_along_path2 (struct usedfiles *fileinfo, struct pathelement *path)\n{\n  const char *fname = fileinfo->fname;\n  size_t fnamelen = strlen (fname);\n  int err = ENOENT;\n  struct pathelement *firstp = path;\n\n  if (path == NULL)\n    /* Cannot find anything since we have no path.  */\n    return ENOENT;\n\n  do\n    {\n      if (likely (path->exist >= 0))\n\t{\n\t  /* Create the file name.  */\n\t  char *rfname = NULL;\n\t  size_t dirlen = strlen (path->pname);\n\t  int fd = -1;\n\n\t  if (fileinfo->file_type == archive_file_type)\n\t    {\n\t      const char **exts = (ld_state.statically\n\t\t\t\t   ? (const char *[2]) { \".a\", NULL }\n\t\t\t\t   : LIB_EXTENSION (&ld_state));\n\n\t      /* We have to create the actual file name.  We prepend \"lib\"\n\t\t and add one of the extensions the platform has.  */\n\t      while (*exts != NULL)\n\t\t{\n\t\t  size_t extlen = strlen (*exts);\n\t\t  rfname = (char *) alloca (dirlen + 5 + fnamelen + extlen);\n\t\t  memcpy (mempcpy (stpcpy (mempcpy (rfname, path->pname,\n\t\t\t\t\t\t    dirlen),\n\t\t\t\t\t   \"/lib\"),\n\t\t\t\t   fname, fnamelen),\n\t\t\t  *exts, extlen + 1);\n\n\t\t  fd = open (rfname, O_RDONLY);\n\t\t  if (likely (fd != -1) || errno != ENOENT)\n\t\t    {\n\t\t      err = fd == -1 ? errno : 0;\n\t\t      break;\n\t\t    }\n\n\t\t  /* Next extension.  */\n\t\t  ++exts;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      assert (fileinfo->file_type == dso_file_type\n\t\t      || fileinfo->file_type == dso_needed_file_type);\n\n\t      rfname = (char *) alloca (dirlen + 1 + fnamelen + 1);\n\t      memcpy (stpcpy (mempcpy (rfname, path->pname, dirlen), \"/\"),\n\t\t      fname, fnamelen + 1);\n\n\t      fd = open (rfname, O_RDONLY);\n\t      if (unlikely (fd == -1))\n\t\terr = errno;\n\t    }\n\n\t  if (likely (fd != -1))\n\t    {\n\t      /* We found the file.  This also means the directory\n\t\t exists.  */\n\t      fileinfo->fd = fd;\n\t      path->exist = 1;\n\n\t      /* Check whether we have this file already loaded.  */\n\t      if (unlikely (check_for_duplicate (fileinfo) != 0))\n\t\treturn EAGAIN;\n\n\t      /* Make a copy of the name.  */\n\t      fileinfo->rfname = obstack_strdup (&ld_state.smem, rfname);\n\n\t      if (unlikely (ld_state.trace_files))\n\t\tprintf (fileinfo->file_type == archive_file_type\n\t\t\t? gettext (\"%s (for -l%s)\\n\")\n\t\t\t: gettext (\"%s (for DT_NEEDED %s)\\n\"),\n\t\t\trfname, fname);\n\n\t      return 0;\n\t    }\n\n\t  /* The file does not exist.  Maybe the whole directory doesn't.\n\t     Check it unless we know it exists.  */\n\t  if (unlikely (path->exist == 0))\n\t    {\n\t      struct stat st;\n\n\t      /* Keep only the directory name.  Note that the path\n\t\t might be relative.  This doesn't matter here.  We do\n\t\t the test in any case even if there is the chance that\n\t\t somebody wants to change the programs working\n\t\t directory at some point which would make the result\n\t\t of this test void.  Since changing the working\n\t\t directory is completely wrong we are not taking this\n\t\t case into account.  */\n\t      rfname[dirlen] = '\\0';\n\t      if (unlikely (stat (rfname, &st) < 0) || ! S_ISDIR (st.st_mode))\n\t\t/* The directory does not exist or the named file is no\n\t\t   directory.  */\n\t\tpath->exist = -1;\n\t      else\n\t\tpath->exist = 1;\n\t    }\n\t}\n\n      /* Next path element.  */\n      path = path->next;\n    }\n  while (likely (err == ENOENT && path != firstp));\n\n  return err;\n}\n\n\nstatic int\nopen_along_path (struct usedfiles *fileinfo)\n{\n  const char *fname = fileinfo->fname;\n  int err = ENOENT;\n\n  if (fileinfo->file_type == relocatable_file_type)\n    {\n      /* Only libraries are searched along the path.  */\n      fileinfo->fd = open (fname, O_RDONLY);\n\n      if (likely (fileinfo->fd != -1))\n\t{\n\t  /* We found the file.  */\n\t  if (unlikely (ld_state.trace_files))\n\t    print_file_name (stdout, fileinfo, 1, 1);\n\n\t  return check_for_duplicate (fileinfo);\n\t}\n\n      /* If the name is an absolute path we are done.  */\n      err = errno;\n    }\n  else\n    {\n      /* If the user specified two parts to the LD_LIBRARY_PATH variable\n\t try the first part now.  */\n      err = open_along_path2 (fileinfo, ld_state.ld_library_path1);\n\n      /* Try the user-specified path next.  */\n      if (err == ENOENT)\n\terr = open_along_path2 (fileinfo,\n\t\t\t\tfileinfo->file_type == archive_file_type\n\t\t\t\t? ld_state.paths : ld_state.rpath_link);\n\n      /* Then the second part of the LD_LIBRARY_PATH value.  */\n      if (unlikely (err == ENOENT))\n\t{\n\t  err = open_along_path2 (fileinfo, ld_state.ld_library_path2);\n\n\t  /* In case we look for a DSO handle now the RUNPATH.  */\n\t  if (err == ENOENT)\n\t    {\n\t      if (fileinfo->file_type == dso_file_type)\n\t\terr = open_along_path2 (fileinfo, ld_state.runpath_link);\n\n\t      /* Finally the path from the default linker script.  */\n\t      if (err == ENOENT)\n\t\terr = open_along_path2 (fileinfo, ld_state.default_paths);\n\t    }\n\t}\n    }\n\n  if (unlikely (err != 0)\n      && (err != EAGAIN || fileinfo->file_type == relocatable_file_type))\n    error (0, err, gettext (\"cannot open %s\"), fileinfo->fname);\n\n  return err;\n}\n\n\nstatic int\nmatching_group_comdat_scn (const XElf_Sym *sym, size_t shndx,\n\t\t\t   struct usedfiles *fileinfo, struct symbol *oldp)\n{\n  if ((shndx >= SHN_LORESERVE && shndx <= SHN_HIRESERVE)\n      || (oldp->scndx >= SHN_LORESERVE && oldp->scndx <= SHN_HIRESERVE))\n    /* Cannot be a group COMDAT section.  */\n    return 0;\n\n  size_t newgrpid = fileinfo->scninfo[shndx].grpid;\n  size_t oldgrpid = oldp->file->scninfo[oldp->scndx].grpid;\n  if (newgrpid == 0 || oldgrpid == 0)\n    return 0;\n\n  assert (SCNINFO_SHDR (fileinfo->scninfo[newgrpid].shdr).sh_type\n\t  == SHT_GROUP);\n  assert (SCNINFO_SHDR (oldp->file->scninfo[oldgrpid].shdr).sh_type\n\t  == SHT_GROUP);\n\n  if (! fileinfo->scninfo[newgrpid].comdat_group\n      || ! oldp->file->scninfo[oldgrpid].comdat_group)\n    return 0;\n\n  if (strcmp (fileinfo->scninfo[newgrpid].symbols->name,\n\t      oldp->file->scninfo[oldgrpid].symbols->name) != 0)\n    return 0;\n\n  /* This is a matching, duplicate COMDAT group section.  Ignore it.  */\n  return 1;\n}\n\n\nstatic void\ncheck_type_and_size (const XElf_Sym *sym, struct usedfiles *fileinfo,\n\t\t     struct symbol *oldp)\n{\n  /* We check the type and size of the symbols.  In both cases the\n     information can be missing (size is zero, type is STT_NOTYPE) in\n     which case we issue no warnings.  Otherwise everything must\n     match.  If the type does not match there is no point in checking\n     the size.  */\n\n  if (XELF_ST_TYPE (sym->st_info) != STT_NOTYPE && oldp->type != STT_NOTYPE\n      && unlikely (oldp->type != XELF_ST_TYPE (sym->st_info)))\n    {\n      char buf1[64];\n      char buf2[64];\n\n      error (0, 0, gettext (\"\\\nWarning: type of `%s' changed from %s in %s to %s in %s\"),\n\t     oldp->name,\n\t     ebl_symbol_type_name (ld_state.ebl, oldp->type,\n\t\t\t\t   buf1, sizeof (buf1)),\n\t     oldp->file->rfname,\n\t     ebl_symbol_type_name (ld_state.ebl, XELF_ST_TYPE (sym->st_info),\n\t\t\t\t   buf2, sizeof (buf2)),\n\t     fileinfo->rfname);\n    }\n  else if (XELF_ST_TYPE (sym->st_info) == STT_OBJECT\n\t   && oldp->size != 0\n\t   && unlikely (oldp->size != sym->st_size))\n    error (0, 0, gettext (\"\\\nWarning: size of `%s' changed from %\" PRIu64 \" in %s to %\" PRIu64 \" in %s\"),\n\t   oldp->name, (uint64_t) oldp->size, oldp->file->rfname,\n\t   (uint64_t) sym->st_size, fileinfo->rfname);\n}\n\n\nstatic int\ncheck_definition (const XElf_Sym *sym, size_t shndx, size_t symidx,\n\t\t  struct usedfiles *fileinfo, struct symbol *oldp)\n{\n  int result = 0;\n  bool old_in_dso = FILEINFO_EHDR (oldp->file->ehdr).e_type == ET_DYN;\n  bool new_in_dso = FILEINFO_EHDR (fileinfo->ehdr).e_type == ET_DYN;\n  bool use_new_def = false;\n\n  if (shndx != SHN_UNDEF\n      && (! oldp->defined\n\t  || (shndx != SHN_COMMON && oldp->common && ! new_in_dso)\n\t  || (old_in_dso && ! new_in_dso)))\n    {\n      /* We found a definition for a previously undefined symbol or a\n\t real definition for a previous common-only definition or a\n\t redefinition of a symbol definition in an object file\n\t previously defined in a DSO.  First perform some tests which\n\t will show whether the common is really matching the\n\t definition.  */\n      check_type_and_size (sym, fileinfo, oldp);\n\n      /* We leave the next element intact to not interrupt the list\n\t with the unresolved symbols.  Whoever walks the list will\n\t have to check the `defined' flag.  But we remember that this\n\t list element is not unresolved anymore.  */\n      if (! oldp->defined)\n\t{\n\t  /* Remove from the list.  */\n\t  --ld_state.nunresolved;\n\t  if (! oldp->weak)\n\t    --ld_state.nunresolved_nonweak;\n\t  CDBL_LIST_DEL (ld_state.unresolved, oldp);\n\t}\n      else if (oldp->common)\n\t/* Remove from the list.  */\n\tCDBL_LIST_DEL (ld_state.common_syms, oldp);\n\n      /* Use the values of the definition from now on.  */\n      use_new_def = true;\n    }\n  else if (shndx != SHN_UNDEF\n\t   && oldp->defined\n\t   && matching_group_comdat_scn (sym, shndx, fileinfo, oldp))\n    /* The duplicate symbol is in a group COMDAT section with the same\n       signature as the one containing the original definition.\n       Just ignore the second definition.  */\n    /* nothing */;\n  else if (shndx != SHN_UNDEF\n\t   && unlikely (! oldp->common)\n\t   && oldp->defined\n\t   && shndx != SHN_COMMON\n\t   /* Multiple definitions are no fatal errors if the -z muldefs flag\n\t      is used.  We don't warn about the multiple definition unless we\n\t      are told to be verbose.  */\n\t   && (!ld_state.muldefs || verbose)\n\t   && ! old_in_dso && fileinfo->file_type == relocatable_file_type)\n    {\n      /* We have a double definition.  This is a problem.  */\n      char buf[64];\n      XElf_Sym_vardef (oldsym);\n      struct usedfiles *oldfile;\n      const char *scnname;\n      Elf32_Word xndx;\n      size_t shnum;\n\n      if (elf_getshdrnum (fileinfo->elf, &shnum) < 0)\n\terror (EXIT_FAILURE, 0,\n\t       gettext (\"cannot determine number of sections: %s\"),\n\t       elf_errmsg (-1));\n\n      /* XXX Use only ebl_section_name.  */\n      if (shndx < SHN_LORESERVE || (shndx > SHN_HIRESERVE && shndx < shnum))\n\tscnname = elf_strptr (fileinfo->elf,\n\t\t\t      fileinfo->shstrndx,\n\t\t\t      SCNINFO_SHDR (fileinfo->scninfo[shndx].shdr).sh_name);\n      else\n\t// XXX extended section\n\tscnname = ebl_section_name (ld_state.ebl, shndx, 0, buf, sizeof (buf),\n\t\t\t\t    NULL, shnum);\n\n      /* XXX Print source file and line number.  */\n      print_file_name (stderr, fileinfo, 1, 0);\n      fprintf (stderr,\n\t       gettext (\"(%s+%#\" PRIx64 \"): multiple definition of %s `%s'\\n\"),\n\t       scnname,\n\t       (uint64_t) sym->st_value,\n\t       ebl_symbol_type_name (ld_state.ebl, XELF_ST_TYPE (sym->st_info),\n\t\t\t\t     buf, sizeof (buf)),\n\t       oldp->name);\n\n      oldfile = oldp->file;\n      xelf_getsymshndx (oldfile->symtabdata, oldfile->xndxdata, oldp->symidx,\n\t\t\toldsym, xndx);\n      assert (oldsym != NULL);\n\n      /* XXX Use only ebl_section_name.  */\n      if (oldp->scndx < SHN_LORESERVE || oldp->scndx > SHN_HIRESERVE)\n\tscnname = elf_strptr (oldfile->elf,\n\t\t\t      oldfile->shstrndx,\n\t\t\t      SCNINFO_SHDR (oldfile->scninfo[shndx].shdr).sh_name);\n      else\n\tscnname = ebl_section_name (ld_state.ebl, oldp->scndx, oldp->scndx,\n\t\t\t\t    buf, sizeof (buf), NULL, shnum);\n\n      /* XXX Print source file and line number.  */\n      print_file_name (stderr, oldfile, 1, 0);\n      fprintf (stderr, gettext (\"(%s+%#\" PRIx64 \"): first defined here\\n\"),\n\t       scnname, (uint64_t) oldsym->st_value);\n\n      if (likely (!ld_state.muldefs))\n\tresult = 1;\n    }\n  else if (old_in_dso && fileinfo->file_type == relocatable_file_type\n\t   && shndx != SHN_UNDEF)\n    /* We use the definition from a normal relocatable file over the\n       definition in a DSO.  This is what the dynamic linker would\n       do, too.  */\n    use_new_def = true;\n  else if (old_in_dso && !new_in_dso && oldp->defined && !oldp->on_dsolist)\n    {\n      CDBL_LIST_ADD_REAR (ld_state.from_dso, oldp);\n      ++ld_state.nfrom_dso;\n\n      /* If the object is a function we allocate a PLT entry,\n\t otherwise only a GOT entry.  */\n      if (oldp->type == STT_FUNC)\n\t++ld_state.nplt;\n      else\n\t++ld_state.ngot;\n\n      oldp->on_dsolist = 1;\n    }\n  else if (oldp->common && shndx == SHN_COMMON)\n    {\n      /* The symbol size is the largest of all common definitions.  */\n      oldp->size = MAX (oldp->size, sym->st_size);\n      /* Similarly for the alignment.  */\n      oldp->merge.value = MAX (oldp->merge.value, sym->st_value);\n    }\n\n  if (unlikely (use_new_def))\n    {\n      /* Adjust the symbol record appropriately and remove\n\t the symbol from the list of symbols which are taken from DSOs.  */\n      if (old_in_dso && fileinfo->file_type == relocatable_file_type)\n\t{\n\t  CDBL_LIST_DEL (ld_state.from_dso, oldp);\n\t  --ld_state.nfrom_dso;\n\n\t  if (likely (oldp->type == STT_FUNC))\n\t    --ld_state.nplt;\n\t  else\n\t    --ld_state.ngot;\n\n\t  oldp->on_dsolist = 0;\n\t}\n\n      /* Use the values of the definition from now on.  */\n      oldp->size = sym->st_size;\n      oldp->type = XELF_ST_TYPE (sym->st_info);\n      oldp->symidx = symidx;\n      oldp->scndx = shndx;\n      //oldp->symscndx = THESYMSCNDX must be passed;\n      oldp->file = fileinfo;\n      oldp->defined = 1;\n      oldp->in_dso = new_in_dso;\n      oldp->common = shndx == SHN_COMMON;\n      if (likely (fileinfo->file_type == relocatable_file_type))\n\t{\n\t  /* If the definition comes from a DSO we pertain the weak flag\n\t     and it's indicating whether the reference is weak or not.  */\n\t  oldp->weak = XELF_ST_BIND (sym->st_info) == STB_WEAK;\n\n\t  // XXX Really exclude SHN_ABS?\n\t  if (shndx != SHN_COMMON && shndx != SHN_ABS)\n\t    {\n\t      struct scninfo *ignore;\n\t      mark_section_used (&fileinfo->scninfo[shndx], shndx, &ignore);\n\t    }\n\t}\n\n      /* Add to the list of symbols used from DSOs if necessary.  */\n      if (new_in_dso && !old_in_dso)\n\t{\n\t  CDBL_LIST_ADD_REAR (ld_state.from_dso, oldp);\n\t  ++ld_state.nfrom_dso;\n\n\t  /* If the object is a function we allocate a PLT entry,\n\t     otherwise only a GOT entry.  */\n\t  if (oldp->type == STT_FUNC)\n\t    ++ld_state.nplt;\n\t  else\n\t    ++ld_state.ngot;\n\n\t  oldp->on_dsolist = 1;\n\t}\n      else if (shndx == SHN_COMMON)\n\t{\n\t  /* Store the alignment.  */\n\t  oldp->merge.value = sym->st_value;\n\n\t  CDBL_LIST_ADD_REAR (ld_state.common_syms, oldp);\n\t}\n    }\n\n  return result;\n}\n\n\nstatic struct scninfo *\nfind_section_group (struct usedfiles *fileinfo, Elf32_Word shndx,\n\t\t    Elf_Data **datap)\n{\n  struct scninfo *runp;\n\n  for (runp = fileinfo->groups; runp != NULL; runp = runp->next)\n    if (!runp->used)\n      {\n\tElf32_Word *grpref;\n\tsize_t cnt;\n\tElf_Data *data;\n\n\tdata = elf_getdata (runp->scn, NULL);\n\tif (data == NULL)\n\t  error (EXIT_FAILURE, 0,\n\t\t gettext (\"%s: cannot get section group data: %s\"),\n\t\t fileinfo->fname, elf_errmsg (-1));\n\n\t/* There cannot be another data block.  */\n\tassert (elf_getdata (runp->scn, data) == NULL);\n\n\tgrpref = (Elf32_Word *) data->d_buf;\n\tcnt = data->d_size / sizeof (Elf32_Word);\n\t/* Note that we stop after looking at index 1 since index 0\n\t   contains the flags for the section group.  */\n\twhile (cnt > 1)\n\t  if (grpref[--cnt] == shndx)\n\t    {\n\t      *datap = data;\n\t      return runp;\n\t    }\n      }\n\n  /* If we come here no section group contained the given section\n     despite the SHF_GROUP flag.  This is an error in the input\n     file.  */\n  error (EXIT_FAILURE, 0, gettext (\"\\\n%s: section '%s' with group flag set does not belong to any group\"),\n\t fileinfo->fname,\n\t elf_strptr (fileinfo->elf, fileinfo->shstrndx,\n\t\t     SCNINFO_SHDR (fileinfo->scninfo[shndx].shdr).sh_name));\n  return NULL;\n}\n\n\n/* Mark all sections which belong to the same group as section SHNDX\n   as used.  */\nstatic void\nmark_section_group (struct usedfiles *fileinfo, Elf32_Word shndx,\n\t\t    struct scninfo **grpscnp)\n{\n  /* First locate the section group.  There can be several (many) of\n     them.  */\n  size_t cnt;\n  Elf32_Word *grpref;\n  Elf_Data *data;\n  struct scninfo *grpscn = find_section_group (fileinfo, shndx, &data);\n  *grpscnp = grpscn;\n\n  /* Mark all the sections as used.\n\n     XXX Two possible problems here:\n\n     - the gABI says \"The section must be referenced by a section of type\n       SHT_GROUP\".  I hope everybody reads this as \"exactly one section\".\n\n     - section groups are also useful to mark the debugging section which\n       belongs to a text section.  Unconditionally adding debugging sections\n       is therefore probably not what is wanted if stripping is required.  */\n\n  /* Mark the section group as handled.  */\n  grpscn->used = true;\n\n  grpref = (Elf32_Word *) data->d_buf;\n  cnt = data->d_size / sizeof (Elf32_Word);\n  while (cnt > 1)\n    {\n      Elf32_Word idx = grpref[--cnt];\n      XElf_Shdr *shdr = &SCNINFO_SHDR (fileinfo->scninfo[idx].shdr);\n\n      if (fileinfo->scninfo[idx].grpid != grpscn->grpid)\n\terror (EXIT_FAILURE, 0, gettext (\"\\\n%s: section [%2d] '%s' is not in the correct section group\"),\n\t       fileinfo->fname, (int) idx,\n\t       elf_strptr (fileinfo->elf, fileinfo->shstrndx, shdr->sh_name));\n\n      if (ld_state.strip == strip_none\n\t  /* If we are stripping, remove debug sections.  */\n\t  || (!ebl_debugscn_p (ld_state.ebl,\n\t\t\t       elf_strptr (fileinfo->elf, fileinfo->shstrndx,\n\t\t\t\t\t   shdr->sh_name))\n\t      /* And the relocation sections for the debug sections.  */\n\t      && ((shdr->sh_type != SHT_RELA && shdr->sh_type != SHT_REL)\n\t\t  || !ebl_debugscn_p (ld_state.ebl,\n\t\t\t\t      elf_strptr (fileinfo->elf,\n\t\t\t\t\t\t  fileinfo->shstrndx,\n\t\t\t\t\t\t  SCNINFO_SHDR (fileinfo->scninfo[shdr->sh_info].shdr).sh_name)))))\n\t{\n\t  struct scninfo *ignore;\n\n\t  mark_section_used (&fileinfo->scninfo[idx], idx, &ignore);\n\t}\n    }\n}\n\n\nstatic void\nmark_section_used (struct scninfo *scninfo, Elf32_Word shndx,\n\t\t   struct scninfo **grpscnp)\n{\n  if (likely (scninfo->used))\n    /* Nothing to be done.  */\n    return;\n\n  /* We need this section.  */\n  scninfo->used = true;\n\n  /* Make sure the section header has been read from the file.  */\n  XElf_Shdr *shdr = &SCNINFO_SHDR (scninfo->shdr);\n#if NATIVE_ELF\n  if (unlikely (scninfo->shdr == NULL))\n#else\n  if (unlikely (scninfo->shdr.sh_type == SHT_NULL))\n#endif\n    {\n#if NATIVE_ELF != 0\n      shdr = xelf_getshdr (scninfo->scn, scninfo->shdr);\n#else\n      xelf_getshdr_copy (scninfo->scn, shdr, scninfo->shdr);\n#endif\n      if (unlikely (shdr == NULL))\n\t/* Something is very wrong.  The calling code will notice it\n\t   soon and print a message.  */\n\treturn;\n    }\n\n  /* Handle section linked by 'sh_link'.  */\n  if (unlikely (shdr->sh_link != 0))\n    {\n      struct scninfo *ignore;\n      mark_section_used (&scninfo->fileinfo->scninfo[shdr->sh_link],\n\t\t\t shdr->sh_link, &ignore);\n    }\n\n  /* Handle section linked by 'sh_info'.  */\n  if (unlikely (shdr->sh_info != 0) && (shdr->sh_flags & SHF_INFO_LINK))\n    {\n      struct scninfo *ignore;\n      mark_section_used (&scninfo->fileinfo->scninfo[shdr->sh_info],\n\t\t\t shdr->sh_info, &ignore);\n    }\n\n  if (unlikely (shdr->sh_flags & SHF_GROUP) && ld_state.gc_sections)\n    /* Find the section group which contains this section.  */\n    mark_section_group (scninfo->fileinfo, shndx, grpscnp);\n}\n\n\n/* We collect all sections in a hashing table.  All sections with the\n   same name are collected in a list.  Note that we do not determine\n   which sections are finally collected in the same output section\n   here.  This would be terribly inefficient.  It will be done later.  */\nstatic void\nadd_section (struct usedfiles *fileinfo, struct scninfo *scninfo)\n{\n  struct scnhead *queued;\n  struct scnhead search;\n  unsigned long int hval;\n  XElf_Shdr *shdr = &SCNINFO_SHDR (scninfo->shdr);\n  struct scninfo *grpscn = NULL;\n  Elf_Data *grpscndata = NULL;\n\n  /* See whether we can determine right away whether we need this\n     section in the output.\n\n     XXX I assume here that --gc-sections only affects extraction\n     from an archive.  If it also affects objects files given on\n     the command line then somebody must explain to me how the\n     dependency analysis should work.  Should the entry point be\n     the root?  What if it is a numeric value?  */\n  if (!scninfo->used\n      && (ld_state.strip == strip_none\n\t  || (shdr->sh_flags & SHF_ALLOC) != 0\n\t  || shdr->sh_type == SHT_NOTE\n\t  || (shdr->sh_type == SHT_PROGBITS\n\t      && strcmp (elf_strptr (fileinfo->elf,\n\t\t\t\t     fileinfo->shstrndx,\n\t\t\t\t     shdr->sh_name), \".comment\") == 0))\n      && (fileinfo->status != in_archive || !ld_state.gc_sections))\n    /* Mark as used and handle reference recursively if necessary.  */\n    mark_section_used (scninfo, elf_ndxscn (scninfo->scn), &grpscn);\n\n  if ((shdr->sh_flags & SHF_GROUP) && grpscn == NULL)\n    /* Determine the symbol which name constitutes the signature\n       for the section group.  */\n    grpscn = find_section_group (fileinfo, elf_ndxscn (scninfo->scn),\n\t\t\t\t &grpscndata);\n  assert (grpscn == NULL || grpscn->symbols->name != NULL);\n\n  /* Determine the section name.  */\n  search.name = elf_strptr (fileinfo->elf, fileinfo->shstrndx, shdr->sh_name);\n  search.type = shdr->sh_type;\n  search.flags = shdr->sh_flags;\n  search.entsize = shdr->sh_entsize;\n  search.grp_signature = grpscn != NULL ? grpscn->symbols->name : NULL;\n  search.kind = scn_normal;\n  hval = elf_hash (search.name);\n\n  /* Find already queued sections.  */\n  queued = ld_section_tab_find (&ld_state.section_tab, hval, &search);\n  if (queued != NULL)\n    {\n      bool is_comdat = false;\n\n      /* If this section is part of a COMDAT section group we simply\n\t ignore it since we already have a copy.  */\n      if (unlikely (shdr->sh_flags & SHF_GROUP))\n\t{\n\t  /* Get the data of the section group section.  */\n\t  if (grpscndata == NULL)\n\t    {\n\t      grpscndata = elf_getdata (grpscn->scn, NULL);\n\t      assert (grpscndata != NULL);\n\t    }\n\n\t  /* XXX Possibly unaligned memory access.  */\n\t  if ((((Elf32_Word *) grpscndata->d_buf)[0] & GRP_COMDAT) != 0)\n\t    {\n\t      /* We have to compare the group signatures.  There might\n\t\t be sections with the same name but belonging to\n\t\t groups with different signatures.  This means we have\n\t\t to compare the new group signature with all those\n\t\t already collected.  There might also be some\n\t\t non-group sections in the mix.  */\n\t      struct scninfo *runp = queued->last;\n\t      do\n\t\t{\n\t\t  if (SCNINFO_SHDR (runp->shdr).sh_flags & SHF_GROUP)\n\t\t    {\n\t\t      struct scninfo *grpscn2\n\t\t\t= find_section_group (runp->fileinfo,\n\t\t\t\t\t      elf_ndxscn (runp->scn),\n\t\t\t\t\t      &grpscndata);\n\n\t\t      if (strcmp (grpscn->symbols->name,\n\t\t\t\t  grpscn2->symbols->name) == 0)\n\t\t\t{\n\t\t\t  scninfo->unused_comdat = is_comdat = true;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\n\t\t  runp = runp->next;\n\t\t}\n\t      while (runp != queued->last);\n\t    }\n\t}\n\n      if (!is_comdat)\n\t{\n\t  /* No COMDAT section, we use the data.  */\n\t  scninfo->next = queued->last->next;\n\t  queued->last = queued->last->next = scninfo;\n\n\t  queued->flags = ebl_sh_flags_combine (ld_state.ebl, queued->flags,\n\t\t\t\t\t\tshdr->sh_flags);\n\t  queued->align = MAX (queued->align, shdr->sh_addralign);\n\t}\n    }\n  else\n    {\n      /* We do not use obstacks here since the memory might be\n\t deallocated.  */\n      queued = (struct scnhead *) xcalloc (sizeof (struct scnhead), 1);\n      queued->kind = scn_normal;\n      queued->name = search.name;\n      queued->type = shdr->sh_type;\n      queued->flags = shdr->sh_flags;\n      queued->align = shdr->sh_addralign;\n      queued->entsize = shdr->sh_entsize;\n      queued->grp_signature = grpscn != NULL ? grpscn->symbols->name : NULL;\n      queued->segment_nr = ~0;\n      queued->last = scninfo->next = scninfo;\n\n      /* Check whether we need a TLS segment.  */\n      ld_state.need_tls |= (shdr->sh_flags & SHF_TLS) != 0;\n\n      /* Add to the hash table and possibly overwrite existing value.  */\n      ld_section_tab_insert (&ld_state.section_tab, hval, queued);\n    }\n}\n\n\nstatic int\nadd_relocatable_file (struct usedfiles *fileinfo, GElf_Word secttype)\n{\n  size_t scncnt;\n  size_t cnt;\n  Elf_Data *symtabdata = NULL;\n  Elf_Data *xndxdata = NULL;\n  Elf_Data *versymdata = NULL;\n  Elf_Data *verdefdata = NULL;\n  Elf_Data *verneeddata = NULL;\n  size_t symstridx = 0;\n  size_t nsymbols = 0;\n  size_t nlocalsymbols = 0;\n  bool has_merge_sections = false;\n  bool has_tls_symbols = false;\n  /* Unless we have different information we assume the code needs\n     an executable stack.  */\n  enum execstack execstack = execstack_true;\n\n  /* Prerequisites.  */\n  assert (fileinfo->elf != NULL);\n\n  /* Allocate memory for the sections.  */\n  if (unlikely (elf_getshdrnum (fileinfo->elf, &scncnt) < 0))\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot determine number of sections: %s\"),\n\t   elf_errmsg (-1));\n\n  fileinfo->scninfo = (struct scninfo *)\n    obstack_calloc (&ld_state.smem, scncnt * sizeof (struct scninfo));\n\n  /* Read all the section headers and find the symbol table.  Note\n     that we don't skip the section with index zero.  Even though the\n     section itself is always empty the section header contains\n     informaton for the case when the section index for the section\n     header string table is too large to fit in the ELF header.  */\n  for (cnt = 0; cnt < scncnt; ++cnt)\n    {\n      /* Store the handle for the section.  */\n      fileinfo->scninfo[cnt].scn = elf_getscn (fileinfo->elf, cnt);\n\n      /* Get the ELF section header and data.  */\n      XElf_Shdr *shdr;\n#if NATIVE_ELF != 0\n      if (fileinfo->scninfo[cnt].shdr == NULL)\n#else\n      if (fileinfo->scninfo[cnt].shdr.sh_type == SHT_NULL)\n#endif\n\t{\n#if NATIVE_ELF != 0\n\t  shdr = xelf_getshdr (fileinfo->scninfo[cnt].scn,\n\t\t\t       fileinfo->scninfo[cnt].shdr);\n#else\n\t  xelf_getshdr_copy (fileinfo->scninfo[cnt].scn, shdr,\n\t\t\t     fileinfo->scninfo[cnt].shdr);\n#endif\n\t  if (shdr == NULL)\n\t    {\n\t      /* This should never happen.  */\n\t      fprintf (stderr, gettext (\"%s: invalid ELF file (%s:%d)\\n\"),\n\t\t       fileinfo->rfname, __FILE__, __LINE__);\n\t      return 1;\n\t    }\n\t}\n      else\n\tshdr = &SCNINFO_SHDR (fileinfo->scninfo[cnt].shdr);\n\n      Elf_Data *data = elf_getdata (fileinfo->scninfo[cnt].scn, NULL);\n\n      /* Check whether this section is marked as merge-able.  */\n      has_merge_sections |= (shdr->sh_flags & SHF_MERGE) != 0;\n      has_tls_symbols |= (shdr->sh_flags & SHF_TLS) != 0;\n\n      /* Get the ELF section header and data.  */\n      /* Make the file structure available.  */\n      fileinfo->scninfo[cnt].fileinfo = fileinfo;\n\n      if (unlikely (shdr->sh_type == SHT_SYMTAB)\n\t  || unlikely (shdr->sh_type == SHT_DYNSYM))\n\t{\n\t  if (shdr->sh_type == SHT_SYMTAB)\n\t    {\n\t      assert (fileinfo->symtabdata == NULL);\n\t      fileinfo->symtabdata = data;\n\t      fileinfo->nsymtab = shdr->sh_size / shdr->sh_entsize;\n\t      fileinfo->nlocalsymbols = shdr->sh_info;\n\t      fileinfo->symstridx = shdr->sh_link;\n\t    }\n\t  else\n\t    {\n\t      assert (fileinfo->dynsymtabdata == NULL);\n\t      fileinfo->dynsymtabdata = data;\n\t      fileinfo->ndynsymtab = shdr->sh_size / shdr->sh_entsize;\n\t      fileinfo->dynsymstridx = shdr->sh_link;\n\t    }\n\n\t  /* If we are looking for the normal symbol table we just\n\t     found it.  */\n\t  if (secttype == shdr->sh_type)\n\t    {\n\t      assert (symtabdata == NULL);\n\t      symtabdata = data;\n\t      symstridx = shdr->sh_link;\n\t      nsymbols = shdr->sh_size / shdr->sh_entsize;\n\t      nlocalsymbols = shdr->sh_info;\n\t    }\n\t}\n      else if (unlikely (shdr->sh_type == SHT_SYMTAB_SHNDX))\n\t{\n\t  assert (xndxdata == NULL);\n\t  fileinfo->xndxdata = xndxdata = data;\n\t}\n      else if (unlikely (shdr->sh_type == SHT_GNU_versym))\n\t{\n\t  assert (versymdata == 0);\n\t  fileinfo->versymdata = versymdata = data;\n\t}\n      else if (unlikely (shdr->sh_type == SHT_GNU_verdef))\n\t{\n\t  size_t nversions;\n\n\t  assert (verdefdata == 0);\n\t  fileinfo->verdefdata = verdefdata = data;\n\n\t  /* Allocate the arrays flagging the use of the version and\n\t     to track of allocated names.  */\n\t  fileinfo->nverdef = nversions = shdr->sh_info;\n\t  /* We have NVERSIONS + 1 because the indeces used to access the\n\t     sectino start with one; zero represents local binding.  */\n\t  fileinfo->verdefused = (XElf_Versym *)\n\t    obstack_calloc (&ld_state.smem,\n\t\t\t    sizeof (XElf_Versym) * (nversions + 1));\n\t  fileinfo->verdefent = (struct Ebl_Strent **)\n\t    obstack_alloc (&ld_state.smem,\n\t\t\t   sizeof (struct Ebl_Strent *) * (nversions + 1));\n\t}\n      else if (unlikely (shdr->sh_type == SHT_GNU_verneed))\n\t{\n\t  assert (verneeddata == 0);\n\t  fileinfo->verneeddata = verneeddata = data;\n\t}\n      else if (unlikely (shdr->sh_type == SHT_DYNAMIC))\n\t{\n\t  assert (fileinfo->dynscn == NULL);\n\t  fileinfo->dynscn = fileinfo->scninfo[cnt].scn;\n\t}\n      else if (unlikely (shdr->sh_type == SHT_GROUP))\n\t{\n\t  Elf_Scn *symscn;\n\t  XElf_Shdr_vardef (symshdr);\n\t  Elf_Data *symdata;\n\n\t  if (FILEINFO_EHDR (fileinfo->ehdr).e_type != ET_REL)\n\t    error (EXIT_FAILURE, 0, gettext (\"\\\n%s: only files of type ET_REL might contain section groups\"),\n\t\t   fileinfo->fname);\n\n\t  fileinfo->scninfo[cnt].next = fileinfo->groups;\n\t  fileinfo->scninfo[cnt].grpid = cnt;\n\t  fileinfo->groups = &fileinfo->scninfo[cnt];\n\n\t  /* Determine the signature.  We create a symbol record for\n\t     it.  Only the name element is important.  */\n\t  fileinfo->scninfo[cnt].symbols = (struct symbol *)\n\t    obstack_calloc (&ld_state.smem, sizeof (struct symbol));\n\n\t  symscn = elf_getscn (fileinfo->elf, shdr->sh_link);\n\t  xelf_getshdr (symscn, symshdr);\n\t  symdata = elf_getdata (symscn, NULL);\n\n\t  if (symshdr != NULL)\n\t    {\n\t      XElf_Sym_vardef (sym);\n\n\t      /* We don't need the section index and therefore we don't\n\t\t have to use 'xelf_getsymshndx'.  */\n\t      xelf_getsym (symdata, shdr->sh_info, sym);\n\t      if (sym != NULL)\n\t\t{\n\t\t  struct symbol *symbol = fileinfo->scninfo[cnt].symbols;\n\n#ifndef NO_HACKS\n\t\t  if (XELF_ST_TYPE (sym->st_info) == STT_SECTION)\n\t\t    {\n\t\t      XElf_Shdr_vardef (buggyshdr);\n\t\t      xelf_getshdr (elf_getscn (fileinfo->elf, sym->st_shndx),\n\t\t\t\t    buggyshdr);\n\n\t\t      symbol->name = elf_strptr (fileinfo->elf,\n\t\t\t\t\t\t FILEINFO_EHDR (fileinfo->ehdr).e_shstrndx,\n\t\t\t\t\t\t buggyshdr->sh_name);\n\t\t      symbol->symidx = -1;\n\t\t    }\n\t\t  else\n#endif\n\t\t    {\n\t\t      symbol->name = elf_strptr (fileinfo->elf,\n\t\t\t\t\t\t symshdr->sh_link,\n\t\t\t\t\t\t sym->st_name);\n\t\t      symbol->symidx = shdr->sh_info;\n\t\t    }\n\t\t  symbol->file = fileinfo;\n\t\t}\n\t    }\n\t  if (fileinfo->scninfo[cnt].symbols->name == NULL)\n\t    error (EXIT_FAILURE, 0, gettext (\"\\\n%s: cannot determine signature of section group [%2zd] '%s': %s\"),\n\t\t   fileinfo->fname,\n\t\t   elf_ndxscn (fileinfo->scninfo[cnt].scn),\n\t\t   elf_strptr (fileinfo->elf, fileinfo->shstrndx,\n\t\t\t       shdr->sh_name),\n\t\t   elf_errmsg (-1));\n\n\n\t  /* For all the sections which are part of this group, add\n\t     the reference.  */\n\t  if (data == NULL)\n\t    error (EXIT_FAILURE, 0, gettext (\"\\\n%s: cannot get content of section group [%2zd] '%s': %s'\"),\n\t\t   fileinfo->fname, elf_ndxscn (fileinfo->scninfo[cnt].scn),\n\t\t   elf_strptr (fileinfo->elf, fileinfo->shstrndx,\n\t\t\t       shdr->sh_name),\n\t\t   elf_errmsg (-1));\n\n\t  Elf32_Word *grpdata = (Elf32_Word *) data->d_buf;\n\t  if (grpdata[0] & GRP_COMDAT)\n\t    fileinfo->scninfo[cnt].comdat_group = true;\n\t  for (size_t inner = 1; inner < data->d_size / sizeof (Elf32_Word);\n\t       ++inner)\n\t    {\n\t      if (grpdata[inner] >= scncnt)\n\t\terror (EXIT_FAILURE, 0, gettext (\"\\\n%s: group member %zu of section group [%2zd] '%s' has too high index: %\" PRIu32),\n\t\t       fileinfo->fname,\n\t\t       inner, elf_ndxscn (fileinfo->scninfo[cnt].scn),\n\t\t       elf_strptr (fileinfo->elf, fileinfo->shstrndx,\n\t\t\t\t   shdr->sh_name),\n\t\t       grpdata[inner]);\n\n\t      fileinfo->scninfo[grpdata[inner]].grpid = cnt;\n\t    }\n\n\t  /* The 'used' flag is used to indicate when the information\n\t     in the section group is used to mark all other sections\n\t     as used.  So it must not be true yet.  */\n\t  assert (fileinfo->scninfo[cnt].used == false);\n\t}\n      else if (! SECTION_TYPE_P (&ld_state, shdr->sh_type)\n\t       && unlikely ((shdr->sh_flags & SHF_OS_NONCONFORMING) != 0))\n\t/* According to the gABI it is a fatal error if the file contains\n\t   a section with unknown type and the SHF_OS_NONCONFORMING flag\n\t   set.  */\n\terror (EXIT_FAILURE, 0,\n\t       gettext (\"%s: section '%s' has unknown type: %d\"),\n\t       fileinfo->fname,\n\t       elf_strptr (fileinfo->elf, fileinfo->shstrndx,\n\t\t\t   shdr->sh_name),\n\t       (int) shdr->sh_type);\n      /* We don't have to add a few section types here.  These will be\n\t generated from scratch for the new output file.  We also\n\t don't add the sections of DSOs here since these sections are\n\t not used in the resulting object file.  */\n      else if (likely (fileinfo->file_type == relocatable_file_type)\n\t       && likely (cnt > 0)\n\t       && likely (shdr->sh_type == SHT_PROGBITS\n\t\t\t  || shdr->sh_type == SHT_RELA\n\t\t\t  || shdr->sh_type == SHT_REL\n\t\t\t  || shdr->sh_type == SHT_NOTE\n\t\t\t  || shdr->sh_type == SHT_NOBITS\n\t\t\t  || shdr->sh_type == SHT_INIT_ARRAY\n\t\t\t  || shdr->sh_type == SHT_FINI_ARRAY\n\t\t\t  || shdr->sh_type == SHT_PREINIT_ARRAY))\n\t{\n\t  /* Check whether the section needs to be executable.  */\n\t  if (shdr->sh_type == SHT_PROGBITS\n\t      && (shdr->sh_flags & SHF_EXECINSTR) == 0\n\t      && strcmp (elf_strptr (fileinfo->elf, fileinfo->shstrndx,\n\t\t\t\t     shdr->sh_name),\n\t\t\t \".note.GNU-stack\") == 0)\n\t    execstack = execstack_false;\n\n\t  add_section (fileinfo, &fileinfo->scninfo[cnt]);\n\t}\n    }\n\n  /* Now we know more about the requirements for an executable stack\n     of the result.  */\n  if (fileinfo->file_type == relocatable_file_type\n      && execstack == execstack_true\n      && ld_state.execstack != execstack_false_force)\n    ld_state.execstack = execstack_true;\n\n  /* Handle the symbols.  Record defined and undefined symbols in the\n     hash table.  In theory there can be a file without any symbol\n     table.  */\n  if (likely (symtabdata != NULL))\n    {\n      /* In case this file contains merge-able sections we have to\n\t locate the symbols which are in these sections.  */\n      fileinfo->has_merge_sections = has_merge_sections;\n      if (likely (has_merge_sections || has_tls_symbols))\n\t{\n\t  fileinfo->symref = (struct symbol **)\n\t    obstack_calloc (&ld_state.smem,\n\t\t\t    nsymbols * sizeof (struct symbol *));\n\n\t  /* Only handle the local symbols here.  */\n\t  for (cnt = 0; cnt < nlocalsymbols; ++cnt)\n\t    {\n\t      Elf32_Word shndx;\n\t      XElf_Sym_vardef (sym);\n\n\t      xelf_getsymshndx (symtabdata, xndxdata, cnt, sym, shndx);\n\t      if (sym == NULL)\n\t\t{\n\t\t  /* This should never happen.  */\n\t\t  fprintf (stderr, gettext (\"%s: invalid ELF file (%s:%d)\\n\"),\n\t\t\t   fileinfo->rfname, __FILE__, __LINE__);\n\t\t  return 1;\n\t\t}\n\n\t      if (likely (shndx != SHN_XINDEX))\n\t\tshndx = sym->st_shndx;\n\t      else if (unlikely (shndx == 0))\n\t\t{\n\t\t  fprintf (stderr, gettext (\"%s: invalid ELF file (%s:%d)\\n\"),\n\t\t\t   fileinfo->rfname, __FILE__, __LINE__);\n\t\t  return 1;\n\t\t}\n\n\t      if (XELF_ST_TYPE (sym->st_info) != STT_SECTION\n\t\t  && (shndx < SHN_LORESERVE || shndx > SHN_HIRESERVE)\n\t\t  && ((SCNINFO_SHDR (fileinfo->scninfo[shndx].shdr).sh_flags\n\t\t       & SHF_MERGE)\n\t\t      || XELF_ST_TYPE (sym->st_info) == STT_TLS))\n\t\t{\n\t\t  /* Create a symbol record for this symbol and add it\n\t\t     to the list for this section.  */\n\t\t  struct symbol *newp;\n\n\t\t  newp = (struct symbol *)\n\t\t    obstack_calloc (&ld_state.smem, sizeof (struct symbol));\n\n\t\t  newp->symidx = cnt;\n\t\t  newp->scndx = shndx;\n\t\t  newp->file = fileinfo;\n\t\t  newp->defined = 1;\n\t\t  fileinfo->symref[cnt] = newp;\n\n\t\t  if (fileinfo->scninfo[shndx].symbols == NULL)\n\t\t    fileinfo->scninfo[shndx].symbols = newp->next_in_scn\n\t\t      = newp;\n\t\t  else\n\t\t    {\n\t\t      newp->next_in_scn\n\t\t\t= fileinfo->scninfo[shndx].symbols->next_in_scn;\n\t\t      fileinfo->scninfo[shndx].symbols\n\t\t\t= fileinfo->scninfo[shndx].symbols->next_in_scn = newp;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\t/* Create array with pointers to the symbol definitions.  Note\n\t   that we only allocate memory for the non-local symbols\n\t   since we have no merge-able sections.  But we store the\n\t   pointer as if it was for the whole symbol table.  This\n\t   saves some memory.  */\n\tfileinfo->symref = (struct symbol **)\n\t  obstack_calloc (&ld_state.smem, ((nsymbols - nlocalsymbols)\n\t\t\t\t\t   * sizeof (struct symbol *)))\n\t  - nlocalsymbols;\n\n      /* Don't handle local symbols here.  It's either not necessary\n\t at all or has already happened.  */\n      for (cnt = nlocalsymbols; cnt < nsymbols; ++cnt)\n\t{\n\t  XElf_Sym_vardef (sym);\n\t  Elf32_Word shndx;\n\t  xelf_getsymshndx (symtabdata, xndxdata, cnt, sym, shndx);\n\n\t  if (sym == NULL)\n\t    {\n\t      /* This should never happen.  */\n\t      fprintf (stderr, gettext (\"%s: invalid ELF file (%s:%d)\\n\"),\n\t\t       fileinfo->rfname, __FILE__, __LINE__);\n\t      return 1;\n\t    }\n\n\t  if (likely (shndx != SHN_XINDEX))\n\t    shndx = sym->st_shndx;\n\t  else if (unlikely (shndx == 0))\n\t    {\n\t      fprintf (stderr, gettext (\"%s: invalid ELF file (%s:%d)\\n\"),\n\t\t       fileinfo->rfname, __FILE__, __LINE__);\n\t      return 1;\n\t    }\n\n\t  /* We ignore ABS symbols from DSOs.  */\n\t  // XXX Is this correct?\n\t  if (unlikely (shndx == SHN_ABS) && secttype == SHT_DYNSYM)\n\t    continue;\n\n\t  if ((shndx < SHN_LORESERVE || shndx > SHN_HIRESERVE)\n\t      && fileinfo->scninfo[shndx].unused_comdat)\n\t    /* The symbol is not used.  */\n\t    continue;\n\n\t  /* If the DSO uses symbol versions determine whether this is\n\t     the default version.  Otherwise we'll ignore the symbol.  */\n\t  if (versymdata != NULL)\n\t    {\n\t      XElf_Versym versym;\n\n\t      if (xelf_getversym_copy (versymdata, cnt, versym) == NULL)\n\t\t/* XXX Should we handle faulty input files more graceful?  */\n\t\tassert (! \"xelf_getversym failed\");\n\n\t      if ((versym & 0x8000) != 0)\n\t\t/* Ignore the symbol, it's not the default version.  */\n\t\tcontinue;\n\t    }\n\n\t  /* See whether we know anything about this symbol.  */\n\t  struct symbol search;\n\t  search.name = elf_strptr (fileinfo->elf, symstridx, sym->st_name);\n\t  unsigned long int hval = elf_hash (search.name);\n\n\t  /* We ignore the symbols the linker generates.  This are\n\t     _GLOBAL_OFFSET_TABLE_, _DYNAMIC.  */\n\t  // XXX This loop is hot and the following tests hardly ever match.\n\t  // XXX Maybe move the tests somewhere they are executed less often.\n\t  if (((unlikely (hval == 165832675ul)\n\t\t&& strcmp (search.name, \"_DYNAMIC\") == 0)\n\t       || (unlikely (hval == 102264335ul)\n\t\t   && strcmp (search.name, \"_GLOBAL_OFFSET_TABLE_\") == 0))\n\t      && sym->st_shndx != SHN_UNDEF\n\t      /* If somebody defines such a variable in a relocatable we\n\t\t don't ignore it.  Let the user get what s/he deserves.  */\n\t      && fileinfo->file_type != relocatable_file_type)\n\t    continue;\n\n\t  struct symbol *oldp = ld_symbol_tab_find (&ld_state.symbol_tab,\n\t\t\t\t\t\t    hval, &search);\n\t  struct symbol *newp;\n\t  if (likely (oldp == NULL))\n\t    {\n\t      /* No symbol of this name known.  Add it.  */\n\t      newp = (struct symbol *) obstack_alloc (&ld_state.smem,\n\t\t\t\t\t\t      sizeof (*newp));\n\t      newp->name = search.name;\n\t      newp->size = sym->st_size;\n\t      newp->type = XELF_ST_TYPE (sym->st_info);\n\t      newp->symidx = cnt;\n\t      newp->outsymidx = 0;\n\t      newp->outdynsymidx = 0;\n\t      newp->scndx = shndx;\n\t      newp->file = fileinfo;\n\t      newp->defined = newp->scndx != SHN_UNDEF;\n\t      newp->common = newp->scndx == SHN_COMMON;\n\t      newp->weak = XELF_ST_BIND (sym->st_info) == STB_WEAK;\n\t      newp->added = 0;\n\t      newp->merged = 0;\n\t      newp->local = 0;\n\t      newp->hidden = 0;\n\t      newp->need_copy = 0;\n\t      newp->on_dsolist = 0;\n\t      newp->in_dso = secttype == SHT_DYNSYM;\n\t      newp->next_in_scn = NULL;\n#ifndef NDEBUG\n\t      newp->next = NULL;\n\t      newp->previous = NULL;\n#endif\n\n\t      if (newp->scndx == SHN_UNDEF)\n\t\t{\n\t\t  CDBL_LIST_ADD_REAR (ld_state.unresolved, newp);\n\t\t  ++ld_state.nunresolved;\n\t\t  if (! newp->weak)\n\t\t    ++ld_state.nunresolved_nonweak;\n\t\t}\n\t      else if (newp->scndx == SHN_COMMON)\n\t\t{\n\t\t  /* Store the alignment requirement.  */\n\t\t  newp->merge.value = sym->st_value;\n\n\t\t  CDBL_LIST_ADD_REAR (ld_state.common_syms, newp);\n\t\t}\n\n\t      /* Insert the new symbol.  */\n\t      if (unlikely (ld_symbol_tab_insert (&ld_state.symbol_tab,\n\t\t\t\t\t\t  hval, newp) != 0))\n\t\t/* This cannot happen.  */\n\t\tabort ();\n\n\t      fileinfo->symref[cnt] = newp;\n\n\t      /* We have a few special symbols to recognize.  The symbols\n\t\t _init and _fini are the initialization and finalization\n\t\t functions respectively.  They have to be made known in\n\t\t the dynamic section and therefore we have to find out\n\t\t now whether these functions exist or not.  */\n\t      if (hval == 6685956 && strcmp (newp->name, \"_init\") == 0)\n\t\tld_state.init_symbol = newp;\n\t      else if (hval == 6672457 && strcmp (newp->name, \"_fini\") == 0)\n\t\tld_state.fini_symbol = newp;\n\t    }\n\t  else if (unlikely (check_definition (sym, shndx, cnt, fileinfo, oldp)\n\t\t\t     != 0))\n\t    /* A fatal error (multiple definition of a symbol)\n\t       occurred, no need to continue.  */\n\t    return 1;\n\t  else\n\t    /* Use the previously allocated symbol record.  It has\n\t       been updated in check_definition(), if necessary.  */\n\t    newp = fileinfo->symref[cnt] = oldp;\n\n\t  /* Mark the section the symbol we need comes from as used.  */\n\t  if (shndx != SHN_UNDEF\n\t      && (shndx < SHN_LORESERVE || shndx > SHN_HIRESERVE))\n\t    {\n\t      struct scninfo *ignore;\n\n#ifndef NDEBUG\n\t      size_t shnum;\n\t      assert (elf_getshdrnum (fileinfo->elf, &shnum) == 0);\n\t      assert (shndx < shnum);\n#endif\n\n\t      /* Mark section (and all dependencies) as used.  */\n\t      mark_section_used (&fileinfo->scninfo[shndx], shndx, &ignore);\n\n\t      /* Check whether the section is merge-able.  In this case we\n\t\t have to record the symbol.  */\n\t      if (SCNINFO_SHDR (fileinfo->scninfo[shndx].shdr).sh_flags\n\t\t  & SHF_MERGE)\n\t\t{\n\t\t  if (fileinfo->scninfo[shndx].symbols == NULL)\n\t\t    fileinfo->scninfo[shndx].symbols = newp->next_in_scn\n\t\t      = newp;\n\t\t  else\n\t\t    {\n\t\t      newp->next_in_scn\n\t\t\t= fileinfo->scninfo[shndx].symbols->next_in_scn;\n\t\t      fileinfo->scninfo[shndx].symbols\n\t\t\t= fileinfo->scninfo[shndx].symbols->next_in_scn = newp;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n      /* This file is used.  */\n      if (likely (fileinfo->file_type == relocatable_file_type))\n\t{\n\t  if (unlikely (ld_state.relfiles == NULL))\n\t    ld_state.relfiles = fileinfo->next = fileinfo;\n\t  else\n\t    {\n\t      fileinfo->next = ld_state.relfiles->next;\n\t      ld_state.relfiles = ld_state.relfiles->next = fileinfo;\n\t    }\n\n\t  /* Update some summary information in the state structure.  */\n\t  ld_state.nsymtab += fileinfo->nsymtab;\n\t  ld_state.nlocalsymbols += fileinfo->nlocalsymbols;\n\t}\n      else if (likely (fileinfo->file_type == dso_file_type))\n\t{\n\t  CSNGL_LIST_ADD_REAR (ld_state.dsofiles, fileinfo);\n\t  ++ld_state.ndsofiles;\n\n\t  if (fileinfo->lazyload)\n\t    /* We have to create another dynamic section entry for the\n\t       DT_POSFLAG_1 entry.\n\n\t       XXX Once more functionality than the lazyloading flag\n\t       are suppported the test must be extended.  */\n\t    ++ld_state.ndsofiles;\n\t}\n    }\n\n  return 0;\n}\n\n\nint\nld_handle_filename_list (struct filename_list *fnames)\n{\n  struct filename_list *runp;\n  int res = 0;\n\n  for (runp = fnames; runp != NULL; runp = runp->next)\n    {\n      struct usedfiles *curp;\n\n      /* Create a record for the new file.  */\n      curp = runp->real = ld_new_inputfile (runp->name, relocatable_file_type);\n\n      /* Set flags for group handling.  */\n      curp->group_start = runp->group_start;\n      curp->group_end = runp->group_end;\n\n      /* Set as-needed flag from the file, not the command line.  */\n      curp->as_needed = runp->as_needed;\n\n      /* Read the file and everything else which comes up, including\n\t handling groups.  */\n      do\n\tres |= FILE_PROCESS (-1, curp, &ld_state, &curp);\n      while (curp != NULL);\n    }\n\n  /* Free the list.  */\n  while (fnames != NULL)\n    {\n      runp = fnames;\n      fnames = fnames->next;\n      free (runp);\n    }\n\n  return res;\n}\n\n\n/* Handle opening of the given file with ELF descriptor.  */\nstatic int\nopen_elf (struct usedfiles *fileinfo, Elf *elf)\n{\n  int res = 0;\n\n  if (elf == NULL)\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot get descriptor for ELF file (%s:%d): %s\\n\"),\n\t   __FILE__, __LINE__, elf_errmsg (-1));\n\n  if (unlikely (elf_kind (elf) == ELF_K_NONE))\n    {\n      struct filename_list *fnames;\n\n      /* We don't have to look at this file again.  */\n      fileinfo->status = closed;\n\n      /* Let's see whether this is a linker script.  */\n      if (fileinfo->fd != -1)\n\t/* Create a stream from the file handle we know.  */\n\tldin = fdopen (fileinfo->fd, \"r\");\n      else\n\t{\n\t  /* Get the memory for the archive member.  */\n\t  char *content;\n\t  size_t contentsize;\n\n\t  /* Get the content of the file.  */\n\t  content = elf_rawfile (elf, &contentsize);\n\t  if (content == NULL)\n\t    {\n\t      fprintf (stderr, gettext (\"%s: invalid ELF file (%s:%d)\\n\"),\n\t\t       fileinfo->rfname, __FILE__, __LINE__);\n\t      return 1;\n\t    }\n\n\t  /* The content of the file is available in memory.  Read the\n\t     memory region as a stream.  */\n\t  ldin = fmemopen (content, contentsize, \"r\");\n\t}\n\n      /* No need for locking.  */\n      __fsetlocking (ldin, FSETLOCKING_BYCALLER);\n\n      if (ldin == NULL)\n\terror (EXIT_FAILURE, errno, gettext (\"cannot open '%s'\"),\n\t       fileinfo->rfname);\n\n      /* Parse the file.  If it is a linker script no problems will be\n\t reported.  */\n      ld_state.srcfiles = NULL;\n      ldlineno = 1;\n      ld_scan_version_script = 0;\n      ldin_fname = fileinfo->rfname;\n      res = ldparse ();\n\n      fclose (ldin);\n      if (fileinfo->fd != -1 && !fileinfo->fd_passed)\n\t{\n\t  /* We won't need the file descriptor again.  */\n\t  close (fileinfo->fd);\n\t  fileinfo->fd = -1;\n\t}\n\n      elf_end (elf);\n\n      if (unlikely (res != 0))\n\t/* Something went wrong during parsing.  */\n\treturn 1;\n\n      /* This is no ELF file.  */\n      fileinfo->elf = NULL;\n\n      /* Now we have to handle eventual INPUT and GROUP statements in\n\t the script.  Read the files mentioned.  */\n      fnames = ld_state.srcfiles;\n      if (fnames != NULL)\n\t{\n\t  struct filename_list *oldp;\n\n\t  /* Convert the list into a normal single-linked list.  */\n\t  oldp = fnames;\n\t  fnames = fnames->next;\n\t  oldp->next = NULL;\n\n\t  /* Remove the list from the state structure.  */\n\t  ld_state.srcfiles = NULL;\n\n\t  if (unlikely (ld_handle_filename_list (fnames) != 0))\n\t    return 1;\n\t}\n\n      return 0;\n    }\n\n  /* Store the file info.  */\n  fileinfo->elf = elf;\n\n  /* The file is ready for action.  */\n  fileinfo->status = opened;\n\n  return 0;\n}\n\n\nstatic int\nadd_whole_archive (struct usedfiles *fileinfo)\n{\n  Elf *arelf;\n  Elf_Cmd cmd = ELF_C_READ_MMAP_PRIVATE;\n  int res = 0;\n\n  while ((arelf = elf_begin (fileinfo->fd, cmd, fileinfo->elf)) != NULL)\n    {\n      Elf_Arhdr *arhdr = elf_getarhdr (arelf);\n      struct usedfiles *newp;\n\n      if (arhdr == NULL)\n\tabort ();\n\n      /* Just to be sure; since these are no files in the archive\n\t these names should never be returned.  */\n      assert (strcmp (arhdr->ar_name, \"/\") != 0);\n      assert (strcmp (arhdr->ar_name, \"//\") != 0);\n\n      newp = ld_new_inputfile (arhdr->ar_name, relocatable_file_type);\n      newp->archive_file = fileinfo;\n\n      if (unlikely (ld_state.trace_files))\n\tprint_file_name (stdout, newp, 1, 1);\n\n      /* This shows that this file is contained in an archive.  */\n      newp->fd = -1;\n      /* Store the ELF descriptor.  */\n      newp->elf = arelf;\n      /* Show that we are open for business.  */\n      newp->status = opened;\n\n      /* Proces the file, add all the symbols etc.  */\n      res = file_process2 (newp);\n      if (unlikely (res != 0))\n\t    break;\n\n      /* Advance to the next archive element.  */\n      cmd = elf_next (arelf);\n    }\n\n  return res;\n}\n\n\nstatic int\nextract_from_archive (struct usedfiles *fileinfo)\n{\n  static int archive_seq;\n  int res = 0;\n\n  if (fileinfo->archive_seq == 0)\n    /* This is an archive we are not using completely.  Give it a\n       unique number.  */\n    fileinfo->archive_seq = ++archive_seq;\n\n  /* If there are no unresolved symbols don't do anything.  */\n  assert (ld_state.extract_rule == defaultextract\n\t  || ld_state.extract_rule == weakextract);\n  if ((likely (ld_state.extract_rule == defaultextract)\n       ? ld_state.nunresolved_nonweak : ld_state.nunresolved) == 0)\n    return 0;\n\n  Elf_Arsym *syms;\n  size_t nsyms;\n\n  /* Get all the symbols.  */\n  syms = elf_getarsym (fileinfo->elf, &nsyms);\n  if (syms == NULL)\n    {\n    cannot_read_archive:\n      error (0, 0, gettext (\"cannot read archive `%s': %s\"),\n\t     fileinfo->rfname, elf_errmsg (-1));\n\n      /* We cannot use this archive anymore.  */\n      fileinfo->status = closed;\n\n      return 1;\n    }\n\n  /* Now add all the symbols to the hash table.  Note that there\n     can potentially be duplicate definitions.  We'll always use\n     the first definition.  */\n  // XXX Is this a compatible behavior?\n  bool any_used;\n  do\n    {\n      any_used = false;\n\n      size_t cnt;\n      for (cnt = 0; cnt < nsyms; ++cnt)\n\t{\n\t  struct symbol search = { .name = syms[cnt].as_name };\n\t  struct symbol *sym = ld_symbol_tab_find (&ld_state.symbol_tab,\n\t\t\t\t\t\t   syms[cnt].as_hash, &search);\n\t  if (sym != NULL && ! sym->defined)\n\t    {\n\t      /* The symbol is referenced and not defined.  */\n\t      Elf *arelf;\n\t      Elf_Arhdr *arhdr;\n\t      struct usedfiles *newp;\n\n\t      /* Find the archive member for this symbol.  */\n\t      if (unlikely (elf_rand (fileinfo->elf, syms[cnt].as_off)\n\t\t\t    != syms[cnt].as_off))\n\t\tgoto cannot_read_archive;\n\n\t      /* Note: no test of a failing 'elf_begin' call.  That's fine\n\t\t since 'elf'getarhdr' will report the problem.  */\n\t      arelf = elf_begin (fileinfo->fd, ELF_C_READ_MMAP_PRIVATE,\n\t\t\t\t fileinfo->elf);\n\t      arhdr = elf_getarhdr (arelf);\n\t      if (arhdr == NULL)\n\t\tgoto cannot_read_archive;\n\n\t      /* We have all the information and an ELF handle for the\n\t\t archive member.  Create the normal data structure for\n\t\t a file now.  */\n\t      newp = ld_new_inputfile (obstack_strdup (&ld_state.smem,\n\t\t\t\t\t\t       arhdr->ar_name),\n\t\t\t\t       relocatable_file_type);\n\t      newp->archive_file = fileinfo;\n\n\t      if (unlikely (ld_state.trace_files))\n\t\tprint_file_name (stdout, newp, 1, 1);\n\n\t      /* This shows that this file is contained in an archive.  */\n\t      newp->fd = -1;\n\t      /* Store the ELF descriptor.  */\n\t      newp->elf = arelf;\n\t      /* Show that we are open for business.  */\n\t      newp->status = in_archive;\n\n\t      /* Now read the file and add all the symbols.  */\n\t      res = file_process2 (newp);\n\t      if (unlikely (res != 0))\n\t\treturn res;\n\n\t      any_used = true;\n\t    }\n\t}\n\n      if (any_used)\n\t{\n\t  /* This is an archive therefore it must have a number.  */\n\t  assert (fileinfo->archive_seq != 0);\n\t  ld_state.last_archive_used = fileinfo->archive_seq;\n\t}\n    }\n  while (any_used);\n\n  return res;\n}\n\n\nstatic int\nfile_process2 (struct usedfiles *fileinfo)\n{\n  int res;\n\n  if (likely (elf_kind (fileinfo->elf) == ELF_K_ELF))\n    {\n      /* The first time we get here we read the ELF header.  */\n#if NATIVE_ELF != 0\n      if (likely (fileinfo->ehdr == NULL))\n#else\n      if (likely (FILEINFO_EHDR (fileinfo->ehdr).e_type == ET_NONE))\n#endif\n\t{\n\t  XElf_Ehdr *ehdr;\n#if NATIVE_ELF != 0\n\t  ehdr = xelf_getehdr (fileinfo->elf, fileinfo->ehdr);\n#else\n\t  xelf_getehdr_copy (fileinfo->elf, ehdr, fileinfo->ehdr);\n#endif\n\t  if (ehdr == NULL)\n\t    {\n\t      fprintf (stderr, gettext (\"%s: invalid ELF file (%s:%d)\\n\"),\n\t\t       fileinfo->rfname, __FILE__, __LINE__);\n\t      fileinfo->status = closed;\n\t      return 1;\n\t    }\n\n\t  if (FILEINFO_EHDR (fileinfo->ehdr).e_type != ET_REL\n\t      && unlikely (FILEINFO_EHDR (fileinfo->ehdr).e_type != ET_DYN))\n\t    /* XXX Add ebl* function to query types which are allowed\n\t       to link in.  */\n\t    {\n\t      char buf[64];\n\n\t      print_file_name (stderr, fileinfo, 1, 0);\n\t      fprintf (stderr,\n\t\t       gettext (\"file of type %s cannot be linked in\\n\"),\n\t\t       ebl_object_type_name (ld_state.ebl,\n\t\t\t\t\t     FILEINFO_EHDR (fileinfo->ehdr).e_type,\n\t\t\t\t\t     buf, sizeof (buf)));\n\t      fileinfo->status = closed;\n\t      return 1;\n\t    }\n\n\t  /* Make sure the file type matches the backend.  */\n\t  if (FILEINFO_EHDR (fileinfo->ehdr).e_machine\n\t      != ebl_get_elfmachine (ld_state.ebl))\n\t    {\n\t      fprintf (stderr, gettext (\"\\\n%s: input file incompatible with ELF machine type %s\\n\"),\n\t\t       fileinfo->rfname,\n\t\t       ebl_backend_name (ld_state.ebl));\n\t      fileinfo->status = closed;\n\t      return 1;\n\t    }\n\n\t  /* Determine the section header string table section index.  */\n\t  if (unlikely (elf_getshdrstrndx (fileinfo->elf, &fileinfo->shstrndx)\n\t\t\t< 0))\n\t    {\n\t      fprintf (stderr, gettext (\"\\\n%s: cannot get section header string table index: %s\\n\"),\n\t\t       fileinfo->rfname, elf_errmsg (-1));\n\t      fileinfo->status = closed;\n\t      return 1;\n\t    }\n\t}\n\n      /* Now handle the different types of files.  */\n      if (FILEINFO_EHDR (fileinfo->ehdr).e_type == ET_REL)\n\t{\n\t  /* Add all the symbol.  Relocatable files have symbol\n\t     tables.  */\n\t  res = add_relocatable_file (fileinfo, SHT_SYMTAB);\n\t}\n      else\n\t{\n\t  bool has_l_name = fileinfo->file_type == archive_file_type;\n\n\t  assert (FILEINFO_EHDR (fileinfo->ehdr).e_type == ET_DYN);\n\n\t  /* If the file is a DT_NEEDED dependency then the type is\n\t     already correctly specified.  */\n\t  if (fileinfo->file_type != dso_needed_file_type)\n\t    fileinfo->file_type = dso_file_type;\n\n\t  /* We cannot use DSOs when generating relocatable objects.  */\n\t  if (ld_state.file_type == relocatable_file_type)\n\t    {\n\t      error (0, 0, gettext (\"\\\ncannot use DSO '%s' when generating relocatable object file\"),\n\t\t     fileinfo->fname);\n\t      return 1;\n\t    }\n\n\t  /* Add all the symbols.  For DSOs we are looking at the\n\t     dynamic symbol table.  */\n\t  res = add_relocatable_file (fileinfo, SHT_DYNSYM);\n\n\t  /* We always have to have a dynamic section.  */\n\t  assert (fileinfo->dynscn != NULL);\n\n\t  /* We have to remember the dependencies for this object.  It\n\t     is necessary to look them up.  */\n\t  XElf_Shdr_vardef (dynshdr);\n\t  xelf_getshdr (fileinfo->dynscn, dynshdr);\n\n\t  Elf_Data *dyndata = elf_getdata (fileinfo->dynscn, NULL);\n\t  /* XXX Should we flag the failure to get the dynamic section?  */\n\t  if (dynshdr != NULL)\n\t    {\n\t      int cnt = dynshdr->sh_size / dynshdr->sh_entsize;\n\t      XElf_Dyn_vardef (dyn);\n\n\t      while (--cnt >= 0)\n\t\t{\n\t\t  xelf_getdyn (dyndata, cnt, dyn);\n\t\t  if (dyn != NULL)\n\t\t    {\n\t\t      if(dyn->d_tag == DT_NEEDED)\n\t\t\t{\n\t\t\t  struct usedfiles *newp;\n\n\t\t\t  newp = ld_new_inputfile (elf_strptr (fileinfo->elf,\n\t\t\t\t\t\t\t       dynshdr->sh_link,\n\t\t\t\t\t\t\t       dyn->d_un.d_val),\n\t\t\t\t\t\t   dso_needed_file_type);\n\n\t\t\t  /* Enqueue the newly found dependencies.  */\n\t\t\t  // XXX Check that there not already a file with the\n\t\t\t  // same name.\n\t\t\t  CSNGL_LIST_ADD_REAR (ld_state.needed, newp);\n\t\t\t}\n\t\t      else if (dyn->d_tag == DT_SONAME)\n\t\t\t{\n\t\t\t  /* We use the DT_SONAME (this is what's there\n\t\t\t     for).  */\n\t\t\t  fileinfo->soname = elf_strptr (fileinfo->elf,\n\t\t\t\t\t\t\t dynshdr->sh_link,\n\t\t\t\t\t\t\t dyn->d_un.d_val);\n\t\t\t  has_l_name = false;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t  /* Construct the file name if the DSO has no SONAME and the\n\t     file name comes from a -lXX parameter on the comment\n\t     line.  */\n\t  if (unlikely (has_l_name))\n\t    {\n\t      /* The FNAME is the parameter the user specified on the\n\t\t command line.  We prepend \"lib\" and append \".so\".  */\n\t      size_t len = strlen (fileinfo->fname) + 7;\n\t      char *newp;\n\n\t      newp = (char *) obstack_alloc (&ld_state.smem, len);\n\t      strcpy (stpcpy (stpcpy (newp, \"lib\"), fileinfo->fname), \".so\");\n\n\t      fileinfo->soname = newp;\n\t    }\n\t}\n    }\n  else if (likely (elf_kind (fileinfo->elf) == ELF_K_AR))\n    {\n      if (unlikely (ld_state.extract_rule == allextract))\n\t/* Which this option enabled we have to add all the object\n\t   files in the archive.  */\n\tres = add_whole_archive (fileinfo);\n      else if (ld_state.file_type == relocatable_file_type)\n\t{\n\t  /* When generating a relocatable object we don't find files\n\t     in archives.  */\n\t  if (verbose)\n\t    error (0, 0, gettext (\"input file '%s' ignored\"), fileinfo->fname);\n\n\t  res = 0;\n\t}\n      else\n\t{\n\t  if (ld_state.group_start_requested\n\t      && ld_state.group_start_archive == NULL)\n\t    ld_state.group_start_archive = fileinfo;\n\n\t  if (ld_state.archives == NULL)\n\t    ld_state.archives = fileinfo;\n\n\t  if (ld_state.tailarchives != NULL)\n\t    ld_state.tailarchives->next = fileinfo;\n\t  ld_state.tailarchives = fileinfo;\n\n\t  /* Extract only the members from the archive which are\n\t     currently referenced by unresolved symbols.  */\n\t  res = extract_from_archive (fileinfo);\n\t}\n    }\n  else\n    /* This should never happen, we know about no other types.  */\n    abort ();\n\n  return res;\n}\n\n\n/* Process a given file.  The first parameter is a file descriptor for\n   the file which can be -1 to indicate the file has not yet been\n   found.  The second parameter describes the file to be opened, the\n   last one is the state of the linker which among other information\n   contain the paths we look at.  */\nstatic int\nld_generic_file_process (int fd, struct usedfiles *fileinfo,\n\t\t\t struct ld_state *statep, struct usedfiles **nextp)\n{\n  int res = 0;\n\n  /* By default we go to the next file in the list.  */\n  *nextp = fileinfo->next;\n\n  /* Set the flag to signal we are looking for a group start.  */\n  if (unlikely (fileinfo->group_start))\n    {\n      ld_state.group_start_requested = true;\n      fileinfo->group_start = false;\n    }\n\n  /* If the file isn't open yet, open it now.  */\n  if (likely (fileinfo->status == not_opened))\n    {\n      bool fd_passed = true;\n\n      if (likely (fd == -1))\n\t{\n\t  /* Find the file ourselves.  */\n\t  int err = open_along_path (fileinfo);\n\t  if (unlikely (err != 0))\n\t    /* We allow libraries and DSOs to be named more than once.\n\t       Don't report an error to the caller.  */\n\t    return err == EAGAIN ? 0 : err;\n\n\t  fd_passed = false;\n\t}\n      else\n\tfileinfo->fd = fd;\n\n      /* Remember where we got the descriptor from.  */\n      fileinfo->fd_passed = fd_passed;\n\n      /* We found the file.  Now test whether it is a file type we can\n\t handle.\n\n\t XXX Do we need to have the ability to start from a given\n\t position in the search path again to look for another file if\n\t the one found has not the right type?  */\n      res = open_elf (fileinfo, elf_begin (fileinfo->fd,\n\t\t\t\t\t   is_dso_p (fileinfo->fd)\n\t\t\t\t\t   ? ELF_C_READ_MMAP\n\t\t\t\t\t   : ELF_C_READ_MMAP_PRIVATE, NULL));\n      if (unlikely (res != 0))\n\treturn res;\n    }\n\n  /* Now that we have opened the file start processing it.  */\n  if (likely (fileinfo->status != closed))\n    res = file_process2 (fileinfo);\n\n  /* Determine which file to look at next.  */\n  if (unlikely (fileinfo->group_backref != NULL))\n    {\n      /* We only go back if an archive other than the one we would go\n\t back to has been used in the last round.  */\n      if (ld_state.last_archive_used > fileinfo->group_backref->archive_seq)\n\t{\n\t  *nextp = fileinfo->group_backref;\n\t  ld_state.last_archive_used = 0;\n\t}\n      else\n\t{\n\t  /* If we come here this means that the archives we read so\n\t     far are not needed anymore.  We can free some of the data\n\t     now.  */\n\t  struct usedfiles *runp = ld_state.archives;\n\n\t  do\n\t    {\n\t      /* We don't need the ELF descriptor anymore.  Unless there\n\t\t are no files from the archive used this will not free\n\t\t the whole file but only some data structures.  */\n\t      elf_end (runp->elf);\n\t      runp->elf = NULL;\n\n\t      runp = runp->next;\n\t    }\n\t  while (runp != fileinfo->next);\n\n\t  /* Do not do this again.  */\n\t  ld_state.archives = NULL;\n\n\t  /* Do not move on to the next archive.  */\n\t  *nextp = fileinfo->next = NULL;\n\t}\n    }\n  else if (unlikely (fileinfo->group_end))\n    {\n      /* This is the end of a group.  We possibly have to go back.\n\t Determine which file we would go back to and see whether it\n\t makes sense.  If there has not been an archive we don't have\n\t to do anything.  */\n      if (ld_state.group_start_requested)\n\t{\n\t  if (ld_state.group_start_archive != ld_state.tailarchives)\n\t    /* The loop includes more than one archive, add the pointer.  */\n\t    {\n\t      *nextp = ld_state.tailarchives->group_backref =\n\t\tld_state.group_start_archive;\n\t      ld_state.last_archive_used = 0;\n\t    }\n\t  else\n\t    /* We might still have to go back to the beginning of the\n\t       group if since the last archive other files have been\n\t       added.  But we go back exactly once.  */\n\t    if (ld_state.tailarchives != fileinfo)\n\t      {\n\t\t*nextp = ld_state.group_start_archive;\n\t\tld_state.last_archive_used = 0;\n\t      }\n\t}\n\n      /* Clear the flags.  */\n      ld_state.group_start_requested = false;\n      ld_state.group_start_archive = NULL;\n      fileinfo->group_end = false;\n    }\n\n  return res;\n}\n\n\n/* Library names passed to the linker as -lXX represent files named\n   libXX.YY.  The YY part can have different forms, depending on the\n   platform.  The generic set is .so and .a (in this order).  */\nstatic const char **\nld_generic_lib_extensions (struct ld_state *statep __attribute__ ((__unused__)))\n{\n  static const char *exts[] =\n    {\n      \".so\", \".a\", NULL\n    };\n\n  return exts;\n}\n\n\n/* Flag unresolved symbols.  */\nstatic int\nld_generic_flag_unresolved (struct ld_state *statep)\n{\n  int retval = 0;\n\n  if (ld_state.nunresolved_nonweak > 0)\n    {\n      /* Go through the list and determine the unresolved symbols.  */\n      struct symbol *first;\n      struct symbol *s;\n\n      s = first = ld_state.unresolved->next;\n      do\n\t{\n\t  if (! s->defined && ! s->weak)\n\t    {\n\t      /* Two special symbol we recognize: the symbol for the\n\t\t GOT and the dynamic section.  */\n\t      if (strcmp (s->name, \"_GLOBAL_OFFSET_TABLE_\") == 0\n\t\t  || strcmp (s->name, \"_DYNAMIC\") == 0)\n\t\t{\n\t\t  /* We will have to fill in more information later.  */\n\t\t  ld_state.need_got = true;\n\n\t\t  /* Remember that we found it.  */\n\t\t  if (s->name[1] == 'G')\n\t\t    ld_state.got_symbol = s;\n\t\t  else\n\t\t    ld_state.dyn_symbol = s;\n\t\t}\n\t      else if (ld_state.file_type != dso_file_type || !ld_state.nodefs)\n\t\t{\n\t\t  /* XXX The error message should get better.  It should use\n\t\t     the debugging information if present to tell where in the\n\t\t     sources the undefined reference is.  */\n\t\t  error (0, 0, gettext (\"undefined symbol `%s' in %s\"),\n\t\t\t s->name, s->file->fname);\n\n\t\t  retval = 1;\n\t\t}\n\t    }\n\n\t  /* We cannot decide here what to do with undefined\n\t     references which will come from DSO since we do not know\n\t     what kind of symbol we expect.  Only when looking at the\n\t     relocations we can see whether we need a PLT entry or\n\t     only a GOT entry.  */\n\n\t  s = s->next;\n\t}\n      while (s != first);\n    }\n\n  return retval;\n}\n\n\n/* Close the given file.  */\nstatic int\nld_generic_file_close (struct usedfiles *fileinfo, struct ld_state *statep)\n{\n  /* Close the ELF descriptor.  */\n  elf_end (fileinfo->elf);\n\n  /* If we have opened the file descriptor close it.  But we might\n     have done this already in which case FD is -1.  */\n  if (!fileinfo->fd_passed && fileinfo->fd != -1)\n    close (fileinfo->fd);\n\n  /* We allocated the resolved file name.  */\n  if (fileinfo->fname != fileinfo->rfname)\n    free ((char *) fileinfo->rfname);\n\n  return 0;\n}\n\n\nstatic void\nnew_generated_scn (enum scn_kind kind, const char *name, int type, int flags,\n\t\t   int entsize, int align)\n{\n  struct scnhead *newp;\n\n  newp = (struct scnhead *) obstack_calloc (&ld_state.smem,\n\t\t\t\t\t    sizeof (struct scnhead));\n  newp->kind = kind;\n  newp->name = name;\n  newp->nameent = ebl_strtabadd (ld_state.shstrtab, name, 0);\n  newp->type = type;\n  newp->flags = flags;\n  newp->entsize = entsize;\n  newp->align = align;\n  newp->grp_signature = NULL;\n  newp->used = true;\n\n  /* All is well.  Create now the data for the section and insert it\n     into the section table.  */\n  ld_section_tab_insert (&ld_state.section_tab, elf_hash (name), newp);\n}\n\n\n/* Create the sections which are generated by the linker and are not\n   present in the input file.  */\nstatic void\nld_generic_generate_sections (struct ld_state *statep)\n{\n  /* The relocation section type.  */\n  int rel_type = REL_TYPE (&ld_state) == DT_REL ? SHT_REL : SHT_RELA;\n\n  /* When requested, every output file will have a build ID section.  */\n  if (statep->build_id != NULL)\n    new_generated_scn (scn_dot_note_gnu_build_id, \".note.gnu.build-id\",\n\t\t       SHT_NOTE, SHF_ALLOC, 0, 4);\n\n  /* When building dynamically linked object we have to include a\n     section containing a string describing the interpreter.  This\n     should be at the very beginning of the file together with the\n     other information the ELF loader (kernel or wherever) has to look\n     at.  We put it as the first section in the file.\n\n     We also have to create the dynamic segment which is a special\n     section the dynamic linker locates through an entry in the\n     program header.  */\n  if (dynamically_linked_p ())\n    {\n      /* Use any versioning (defined or required)?  */\n      bool use_versioning = false;\n      /* Use version requirements?  */\n      bool need_version = false;\n\n      /* First the .interp section.  */\n      if (ld_state.interp != NULL || ld_state.file_type != dso_file_type)\n\tnew_generated_scn (scn_dot_interp, \".interp\", SHT_PROGBITS, SHF_ALLOC,\n\t\t\t   0, 1);\n\n      /* Now the .dynamic section.  */\n      new_generated_scn (scn_dot_dynamic, \".dynamic\", SHT_DYNAMIC,\n\t\t\t DYNAMIC_SECTION_FLAGS (&ld_state),\n\t\t\t xelf_fsize (ld_state.outelf, ELF_T_DYN, 1),\n\t\t\t xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1));\n\n      /* We will need in any case the dynamic symbol table (even in\n\t the unlikely case that no symbol is exported or referenced\n\t from a DSO).  */\n      ld_state.need_dynsym = true;\n      new_generated_scn (scn_dot_dynsym, \".dynsym\", SHT_DYNSYM, SHF_ALLOC,\n\t\t\t xelf_fsize (ld_state.outelf, ELF_T_SYM, 1),\n\t\t\t xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1));\n      /* It comes with a string table.  */\n      new_generated_scn (scn_dot_dynstr, \".dynstr\", SHT_STRTAB, SHF_ALLOC,\n\t\t\t 0, 1);\n      /* And a hashing table.  */\n      // XXX For Linux/Alpha we need other sizes unless they change...\n      if (GENERATE_SYSV_HASH)\n\tnew_generated_scn (scn_dot_hash, \".hash\", SHT_HASH, SHF_ALLOC,\n\t\t\t   sizeof (Elf32_Word), sizeof (Elf32_Word));\n      if (GENERATE_GNU_HASH)\n\tnew_generated_scn (scn_dot_gnu_hash, \".gnu.hash\", SHT_GNU_HASH,\n\t\t\t   SHF_ALLOC, sizeof (Elf32_Word),\n\t\t\t   sizeof (Elf32_Word));\n\n      /* Create the section associated with the PLT if necessary.  */\n      if (ld_state.nplt > 0)\n\t{\n\t  /* Create the .plt section.  */\n\t  /* XXX We might need a function which returns the section flags.  */\n\t  new_generated_scn (scn_dot_plt, \".plt\", SHT_PROGBITS,\n\t\t\t     SHF_ALLOC | SHF_EXECINSTR,\n\t\t\t     /* XXX Is the size correct?  */\n\t\t\t     xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1),\n\t\t\t     xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1));\n\n\t  /* Create the relocation section for the .plt.  This is always\n\t     separate even if the other relocation sections are combined.  */\n\t  new_generated_scn (scn_dot_pltrel, \".rel.plt\", rel_type, SHF_ALLOC,\n\t\t\t     rel_type == SHT_REL\n\t\t\t     ? xelf_fsize (ld_state.outelf, ELF_T_REL, 1)\n\t\t\t     : xelf_fsize (ld_state.outelf, ELF_T_RELA, 1),\n\t\t\t     xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1));\n\n\t  /* XXX We might need a function which returns the section flags.  */\n\t  new_generated_scn (scn_dot_gotplt, \".got.plt\", SHT_PROGBITS,\n\t\t\t     SHF_ALLOC | SHF_WRITE,\n\t\t\t     xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1),\n\t\t\t     xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1));\n\n\t  /* Mark all used DSOs as used.  Determine whether any referenced\n\t     object uses symbol versioning.  */\n\t  if (ld_state.from_dso != NULL)\n\t    {\n\t      struct symbol *srunp = ld_state.from_dso;\n\n\t      do\n\t\t{\n\t\t  srunp->file->used = true;\n\n\t\t  if (srunp->file->verdefdata != NULL)\n\t\t    {\n\t\t      XElf_Versym versym;\n\n\t\t      /* The input DSO uses versioning.  */\n\t\t      use_versioning = true;\n\t\t      /* We reference versions.  */\n\t\t      need_version = true;\n\n\t\t      if (xelf_getversym_copy (srunp->file->versymdata,\n\t\t\t\t\t       srunp->symidx, versym) == NULL)\n\t\t\tassert (! \"xelf_getversym failed\");\n\n\t\t      /* We cannot link explicitly with an older\n\t\t\t version of a symbol.  */\n\t\t      assert ((versym & 0x8000) == 0);\n\t\t      /* We cannot reference local (index 0) or plain\n\t\t\t global (index 1) versions.  */\n\t\t      assert (versym > 1);\n\n\t\t      /* Check whether we have already seen the\n\t\t\t version and if not add it to the referenced\n\t\t\t versions in the output file.  */\n\t\t      if (! srunp->file->verdefused[versym])\n\t\t\t{\n\t\t\t  srunp->file->verdefused[versym] = 1;\n\n\t\t\t  if (++srunp->file->nverdefused == 1)\n\t\t\t    /* Count the file if it is using versioning.  */\n\t\t\t    ++ld_state.nverdeffile;\n\t\t\t  ++ld_state.nverdefused;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      while ((srunp = srunp->next) != ld_state.from_dso);\n\t    }\n\n\t  /* Create the sections used to record version dependencies.  */\n\t  if (need_version)\n\t    new_generated_scn (scn_dot_version_r, \".gnu.version_r\",\n\t\t\t       SHT_GNU_verneed, SHF_ALLOC, 0,\n\t\t\t       xelf_fsize (ld_state.outelf, ELF_T_WORD, 1));\n\t}\n\n      /* Now count the used DSOs since this is what the user\n\t wants.  */\n      int ndt_needed = 0;\n      if (ld_state.ndsofiles > 0)\n\t{\n\t  struct usedfiles *frunp = ld_state.dsofiles;\n\n\t  do\n\t    if (! frunp->as_needed || frunp->used)\n\t      {\n\t\t++ndt_needed;\n\t\tif (frunp->lazyload)\n\t\t  /* We have to create another dynamic section\n\t\t     entry for the DT_POSFLAG_1 entry.\n\n\t\t     XXX Once more functionality than the lazyloading\n\t\t     flag are suppported the test must be\n\t\t     extended.  */\n\t\t  ++ndt_needed;\n\t      }\n\t  while ((frunp = frunp->next) != ld_state.dsofiles);\n\t}\n\n      if (use_versioning)\n\tnew_generated_scn (scn_dot_version, \".gnu.version\", SHT_GNU_versym,\n\t\t\t   SHF_ALLOC,\n\t\t\t   xelf_fsize (ld_state.outelf, ELF_T_HALF, 1),\n\t\t\t   xelf_fsize (ld_state.outelf, ELF_T_HALF, 1));\n\n      /* We need some entries all the time.  */\n      ld_state.ndynamic = (7 + (ld_state.runpath != NULL\n\t\t\t\t|| ld_state.rpath != NULL)\n\t\t\t   + ndt_needed\n\t\t\t   + (ld_state.init_symbol != NULL ? 1 : 0)\n\t\t\t   + (ld_state.fini_symbol != NULL ? 1 : 0)\n\t\t\t   + (use_versioning ? 1 : 0)\n\t\t\t   + (need_version ? 2 : 0)\n\t\t\t   + (ld_state.nplt > 0 ? 4 : 0)\n\t\t\t   + (ld_state.relsize_total > 0 ? 3 : 0));\n    }\n\n  /* When creating a relocatable file or when we are not stripping the\n     output file we create a symbol table.  */\n  ld_state.need_symtab = (ld_state.file_type == relocatable_file_type\n\t\t\t  || ld_state.strip == strip_none);\n\n  /* Add the .got section if needed.  */\n  if (ld_state.need_got)\n    /* XXX We might need a function which returns the section flags.  */\n    new_generated_scn (scn_dot_got, \".got\", SHT_PROGBITS,\n\t\t       SHF_ALLOC | SHF_WRITE,\n\t\t       xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1),\n\t\t       xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1));\n\n  /* Add the .rel.dyn section.  */\n  if (ld_state.relsize_total > 0)\n    new_generated_scn (scn_dot_dynrel, \".rel.dyn\", rel_type, SHF_ALLOC,\n\t\t       rel_type == SHT_REL\n\t\t       ? xelf_fsize (ld_state.outelf, ELF_T_REL, 1)\n\t\t       : xelf_fsize (ld_state.outelf, ELF_T_RELA, 1),\n\t\t       xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1));\n}\n\n\n/* Callback function registered with on_exit to make sure the temporary\n   files gets removed if something goes wrong.  */\nstatic void\nremove_tempfile (int status, void *arg)\n{\n  if (status != 0 && ld_state.tempfname != NULL)\n    unlink (ld_state.tempfname);\n}\n\n\n/* Create the output file.  The file name is given or \"a.out\".  We\n   create as much of the ELF structure as possible.  */\nstatic int\nld_generic_open_outfile (struct ld_state *statep, int machine, int klass,\n\t\t\t int data)\n{\n  /* We do not create the new file right away with the final name.\n     This would destroy an existing file with this name before a\n     replacement is finalized.  We create instead a temporary file in\n     the same directory.  */\n  if (ld_state.outfname == NULL)\n    ld_state.outfname = \"a.out\";\n\n  size_t outfname_len = strlen (ld_state.outfname);\n  char *tempfname = (char *) obstack_alloc (&ld_state.smem,\n\t\t\t\t\t    outfname_len + sizeof (\".XXXXXX\"));\n  ld_state.tempfname = tempfname;\n\n  int fd;\n  int try = 0;\n  while (1)\n    {\n      strcpy (mempcpy (tempfname, ld_state.outfname, outfname_len), \".XXXXXX\");\n\n      /* The use of mktemp() here is fine.  We do not want to use\n\t mkstemp() since then the umask isn't used.  And the output\n\t file will have these permissions anyhow.  Any intruder could\n\t change the file later if it would be possible now.  */\n      if (mktemp (tempfname) != NULL\n\t  && (fd = open (tempfname, O_RDWR | O_EXCL | O_CREAT | O_NOFOLLOW,\n\t\t\t ld_state.file_type == relocatable_file_type\n\t\t\t ? DEFFILEMODE : ACCESSPERMS)) != -1)\n\tbreak;\n\n      /* Failed this round.  We keep trying a number of times.  */\n      if (++try >= 10)\n\terror (EXIT_FAILURE, errno, gettext (\"cannot create output file\"));\n    }\n  ld_state.outfd = fd;\n\n  /* Make sure we remove the temporary file in case something goes\n     wrong.  */\n  on_exit (remove_tempfile, NULL);\n\n  /* Create the ELF file data for the output file.  */\n  Elf *elf = ld_state.outelf = elf_begin (fd,\n\t\t\t\t\t  conserve_memory\n\t\t\t\t\t  ? ELF_C_WRITE : ELF_C_WRITE_MMAP,\n\t\t\t\t\t  NULL);\n  if (elf == NULL)\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot create ELF descriptor for output file: %s\"),\n\t   elf_errmsg (-1));\n\n  /* Create the basic data structures.  */\n  if (! xelf_newehdr (elf, klass))\n    /* Couldn't create the ELF header.  Very bad.  */\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"could not create ELF header for output file: %s\"),\n\t   elf_errmsg (-1));\n\n  /* And get the current header so that we can modify it.  */\n  XElf_Ehdr_vardef (ehdr);\n  xelf_getehdr (elf, ehdr);\n  assert (ehdr != NULL);\n\n  /* Set the machine type.  */\n  ehdr->e_machine = machine;\n\n  /* Modify it according to the info we have here and now.  */\n  if (ld_state.file_type == executable_file_type)\n    ehdr->e_type = ET_EXEC;\n  else if (ld_state.file_type == dso_file_type)\n    ehdr->e_type = ET_DYN;\n  else\n    {\n      assert (ld_state.file_type == relocatable_file_type);\n      ehdr->e_type = ET_REL;\n    }\n\n  /* Set the ELF version.  */\n  ehdr->e_version = EV_CURRENT;\n\n  /* Set the endianness.  */\n  ehdr->e_ident[EI_DATA] = data;\n\n  /* Write the ELF header information back.  */\n  (void) xelf_update_ehdr (elf, ehdr);\n\n  return 0;\n}\n\n\n/* We compute the offsets of the various copied objects and the total\n   size of the memory needed.  */\n// XXX The method used here is simple: go from front to back and pack\n// the objects in this order.  A more space efficient way would\n// actually trying to pack the objects as dense as possible.  But this\n// is more expensive.\nstatic void\ncompute_copy_reloc_offset (XElf_Shdr *shdr)\n{\n  struct symbol *runp = ld_state.from_dso;\n  assert (runp != NULL);\n\n  XElf_Off maxalign = 1;\n  XElf_Off offset = 0;\n\n  do\n    if (runp->need_copy)\n      {\n\t/* Determine alignment for the symbol.  */\n\t// XXX The question is how?  The symbol record itself does not\n\t// have the information.  So we have to be conservative and\n\t// assume the alignment of the section the symbol is in.\n\n\t// XXX We can be more precise.  Use the offset from the beginning\n\t// of the section and determine the largest power of two with\n\t// module zero.\n\tXElf_Off symalign = MAX (SCNINFO_SHDR (runp->file->scninfo[runp->scndx].shdr).sh_addralign, 1);\n\t/* Keep track of the maximum alignment requirement.  */\n\tmaxalign = MAX (maxalign, symalign);\n\n\t/* Align current position.  */\n\toffset = (offset + symalign - 1) & ~(symalign - 1);\n\n\trunp->merge.value = offset;\n\n\toffset += runp->size;\n      }\n  while ((runp = runp->next) != ld_state.from_dso);\n\n  shdr->sh_type = SHT_NOBITS;\n  shdr->sh_size = offset;\n  shdr->sh_addralign = maxalign;\n}\n\n\nstatic void\ncompute_common_symbol_offset (XElf_Shdr *shdr)\n{\n  struct symbol *runp = ld_state.common_syms;\n  assert (runp != NULL);\n\n  XElf_Off maxalign = 1;\n  XElf_Off offset = 0;\n\n  do\n    {\n      /* Determine alignment for the symbol.  */\n      XElf_Off symalign = runp->merge.value;\n\n      /* Keep track of the maximum alignment requirement.  */\n      maxalign = MAX (maxalign, symalign);\n\n      /* Align current position.  */\n      offset = (offset + symalign - 1) & ~(symalign - 1);\n\n      runp->merge.value = offset;\n\n      offset += runp->size;\n    }\n  while ((runp = runp->next) != ld_state.common_syms);\n\n  shdr->sh_type = SHT_NOBITS;\n  shdr->sh_size = offset;\n  shdr->sh_addralign = maxalign;\n}\n\n\nstatic void\nsort_sections_generic (void)\n{\n  /* XXX TBI */\n  abort ();\n}\n\n\nstatic int\nmatch_section (const char *osectname, struct filemask_section_name *sectmask,\n\t       struct scnhead **scnhead, bool new_section, size_t segment_nr)\n{\n  struct scninfo *prevp;\n  struct scninfo *runp;\n  struct scninfo *notused;\n\n  if (fnmatch (sectmask->section_name->name, (*scnhead)->name, 0) != 0)\n    /* The section name does not match.  */\n    return new_section;\n\n  /* If this is a section generated by the linker it doesn't contain\n     the regular information (i.e., input section data etc) and must\n     be handle special.  */\n  if ((*scnhead)->kind != scn_normal)\n    {\n      (*scnhead)->name = osectname;\n      (*scnhead)->segment_nr = segment_nr;\n\n      /* We have to count note section since they get their own\n\t program header entry.  */\n      if ((*scnhead)->type == SHT_NOTE)\n\t++ld_state.nnotesections;\n\n      ld_state.allsections[ld_state.nallsections++] = (*scnhead);\n      return true;\n    }\n\n  /* Now we have to match the file names of the input files.  Some of\n     the sections here might not match.    */\n  runp = (*scnhead)->last->next;\n  prevp = (*scnhead)->last;\n  notused = NULL;\n\n  do\n    {\n      /* Base of the file name the section comes from.  */\n      const char *brfname = basename (runp->fileinfo->rfname);\n\n      /* If the section isn't used, the name doesn't match the positive\n\t inclusion list, or the name does match the negative inclusion\n\t list, ignore the section.  */\n      if (!runp->used\n\t  || (sectmask->filemask != NULL\n\t      && fnmatch (sectmask->filemask, brfname, 0) != 0)\n\t  || (sectmask->excludemask != NULL\n\t      && fnmatch (sectmask->excludemask, brfname, 0) == 0))\n\t{\n\t  /* This file does not match the file name masks.  */\n\t  if (notused == NULL)\n\t    notused = runp;\n\n\t  prevp = runp;\n\t  runp = runp->next;\n\t  if (runp == notused)\n\t    runp = NULL;\n\t}\n      /* The section fulfills all requirements, add it to the output\n\t file with the correct section name etc.  */\n      else\n\t{\n\t  struct scninfo *found = runp;\n\n\t  /* Remove this input section data buffer from the list.  */\n\t  if (prevp != runp)\n\t    runp = prevp->next = runp->next;\n\t  else\n\t    {\n\t      free (*scnhead);\n\t      *scnhead = NULL;\n\t      runp = NULL;\n\t    }\n\n\t  /* Create a new section for the output file if the 'new_section'\n\t     flag says so.  Otherwise append the buffer to the last\n\t     section which we created in one of the last calls.  */\n\t  if (new_section)\n\t    {\n\t      struct scnhead *newp;\n\n\t      newp = (struct scnhead *) obstack_calloc (&ld_state.smem,\n\t\t\t\t\t\t\tsizeof (*newp));\n\t      newp->kind = scn_normal;\n\t      newp->name = osectname;\n\t      newp->type = SCNINFO_SHDR (found->shdr).sh_type;\n\t      /* Executable or DSO do not have section groups.  Drop that\n\t\t information.  */\n\t      newp->flags = SCNINFO_SHDR (found->shdr).sh_flags & ~SHF_GROUP;\n\t      newp->segment_nr = segment_nr;\n\t      newp->last = found->next = found;\n\t      newp->used = true;\n\t      newp->relsize = found->relsize;\n\t      newp->entsize = SCNINFO_SHDR (found->shdr).sh_entsize;\n\n\t      /* We have to count note section since they get their own\n\t\t program header entry.  */\n\t      if (newp->type == SHT_NOTE)\n\t\t++ld_state.nnotesections;\n\n\t      ld_state.allsections[ld_state.nallsections++] = newp;\n\t      new_section = false;\n\t    }\n\t  else\n\t    {\n\t      struct scnhead *queued;\n\n\t      queued = ld_state.allsections[ld_state.nallsections - 1];\n\n\t      found->next = queued->last->next;\n\t      queued->last = queued->last->next = found;\n\n\t      /* If the linker script forces us to add incompatible\n\t\t sections together do so.  But reflect this in the\n\t\t type and flags of the resulting file.  */\n\t      if (queued->type != SCNINFO_SHDR (found->shdr).sh_type)\n\t\t/* XXX Any better choice?  */\n\t\tqueued->type = SHT_PROGBITS;\n\t      if (queued->flags != SCNINFO_SHDR (found->shdr).sh_flags)\n\t\t/* Executable or DSO do not have section groups.  Drop that\n\t\t   information.  */\n\t\tqueued->flags = ebl_sh_flags_combine (ld_state.ebl,\n\t\t\t\t\t\t      queued->flags,\n\t\t\t\t\t\t      SCNINFO_SHDR (found->shdr).sh_flags\n\t\t\t\t\t\t      & ~SHF_GROUP);\n\n\t      /* Accumulate the relocation section size.  */\n\t      queued->relsize += found->relsize;\n\t    }\n\t}\n    }\n  while (runp != NULL);\n\n  return new_section;\n}\n\n\nstatic void\nsort_sections_lscript (void)\n{\n  struct scnhead *temp[ld_state.nallsections];\n\n  /* Make a copy of the section head pointer array.  */\n  memcpy (temp, ld_state.allsections,\n\t  ld_state.nallsections * sizeof (temp[0]));\n  size_t nallsections = ld_state.nallsections;\n\n  /* Convert the output segment list in a single-linked list.  */\n  struct output_segment *segment = ld_state.output_segments->next;\n  ld_state.output_segments->next = NULL;\n  ld_state.output_segments = segment;\n\n  /* Put the sections in the correct order in the array in the state\n     structure.  This might involve merging of sections and also\n     renaming the containing section in the output file.  */\n  ld_state.nallsections = 0;\n  size_t segment_nr;\n  size_t last_writable = ~0ul;\n  for (segment_nr = 0; segment != NULL; segment = segment->next, ++segment_nr)\n    {\n      struct output_rule *orule;\n\n      for (orule = segment->output_rules; orule != NULL; orule = orule->next)\n\tif (orule->tag == output_section)\n\t  {\n\t    struct input_rule *irule;\n\t    bool new_section = true;\n\n\t    for (irule = orule->val.section.input; irule != NULL;\n\t\t irule = irule->next)\n\t      if (irule->tag == input_section)\n\t\t{\n\t\t  size_t cnt;\n\n\t\t  for (cnt = 0; cnt < nallsections; ++cnt)\n\t\t    if (temp[cnt] != NULL)\n\t\t      new_section =\n\t\t\tmatch_section (orule->val.section.name,\n\t\t\t\t       irule->val.section, &temp[cnt],\n\t\t\t\t       new_section, segment_nr);\n\t\t}\n\t  }\n\n      if ((segment->mode & PF_W) != 0)\n\tlast_writable = ld_state.nallsections - 1;\n    }\n\n  /* In case we have to create copy relocations or we have common\n     symbols, find the last writable segment and add one more data\n     block.  It will be a NOBITS block and take up no disk space.\n     This is why it is important to get the last block.  */\n  if (ld_state.ncopy > 0 || ld_state.common_syms !=  NULL)\n    {\n      if (last_writable == ~0ul)\n\terror (EXIT_FAILURE, 0, \"no writable segment\");\n\n      if (ld_state.allsections[last_writable]->type != SHT_NOBITS)\n\t{\n\t  /* Make room in the ALLSECTIONS array for a new section.\n\t     There is guaranteed room in the array.  We add the new\n\t     entry after the last writable section.  */\n\t  ++last_writable;\n\t  memmove (&ld_state.allsections[last_writable + 1],\n\t\t   &ld_state.allsections[last_writable],\n\t\t   (ld_state.nallsections - last_writable)\n\t\t   * sizeof (ld_state.allsections[0]));\n\n\t  ld_state.allsections[last_writable] = (struct scnhead *)\n\t    obstack_calloc (&ld_state.smem, sizeof (struct scnhead));\n\n\t  /* Name for the new section.  */\n\t  ld_state.allsections[last_writable]->name = \".bss\";\n\t  /* Type: NOBITS.  */\n\t  ld_state.allsections[last_writable]->type = SHT_NOBITS;\n\t  /* Same segment as the last writable section.  */\n\t  ld_state.allsections[last_writable]->segment_nr\n\t    = ld_state.allsections[last_writable - 1]->segment_nr;\n\t}\n    }\n\n  /* Create common symbol data block.  */\n  if (ld_state.ncopy > 0)\n    {\n#if NATIVE_ELF\n      struct scninfo *si = (struct scninfo *)\n\tobstack_calloc (&ld_state.smem, sizeof (*si) + sizeof (XElf_Shdr));\n      si->shdr = (XElf_Shdr *) (si + 1);\n#else\n      struct scninfo *si = (struct scninfo *) obstack_calloc (&ld_state.smem,\n\t\t\t\t\t\t\t      sizeof (*si));\n#endif\n\n      /* Get the information regarding the symbols with copy relocations.  */\n      compute_copy_reloc_offset (&SCNINFO_SHDR (si->shdr));\n\n      /* This section is needed.  */\n      si->used = true;\n      /* Remember for later the section data structure.  */\n      ld_state.copy_section = si;\n\n      if (likely (ld_state.allsections[last_writable]->last != NULL))\n\t{\n\t  si->next = ld_state.allsections[last_writable]->last->next;\n\t  ld_state.allsections[last_writable]->last->next = si;\n\t  ld_state.allsections[last_writable]->last = si;\n\t}\n      else\n\tld_state.allsections[last_writable]->last = si->next = si;\n    }\n\n  /* Create common symbol data block.  */\n  if (ld_state.common_syms != NULL)\n    {\n#if NATIVE_ELF\n      struct scninfo *si = (struct scninfo *)\n\tobstack_calloc (&ld_state.smem, sizeof (*si) + sizeof (XElf_Shdr));\n      si->shdr = (XElf_Shdr *) (si + 1);\n#else\n      struct scninfo *si = (struct scninfo *) obstack_calloc (&ld_state.smem,\n\t\t\t\t\t\t\t      sizeof (*si));\n#endif\n\n      /* Get the information regarding the symbols with copy relocations.  */\n      compute_common_symbol_offset (&SCNINFO_SHDR (si->shdr));\n\n      /* This section is needed.  */\n      si->used = true;\n      /* Remember for later the section data structure.  */\n      ld_state.common_section = si;\n\n      if (likely (ld_state.allsections[last_writable]->last != NULL))\n\t{\n\t  si->next = ld_state.allsections[last_writable]->last->next;\n\t  ld_state.allsections[last_writable]->last->next = si;\n\t  ld_state.allsections[last_writable]->last = si;\n\t}\n      else\n\tld_state.allsections[last_writable]->last = si->next = si;\n    }\n}\n\n\n/* Create the output sections now.  This requires knowledge about all\n   the sections we will need.  It may be necessary to sort sections in\n   the order they are supposed to appear in the executable.  The\n   sorting use many different kinds of information to optimize the\n   resulting binary.  Important is to respect segment boundaries and\n   the needed alignment.  The mode of the segments will be determined\n   afterwards automatically by the output routines.\n\n   The generic sorting routines work in one of two possible ways:\n\n   - if a linker script specifies the sections to be used in the\n     output and assigns them to a segment this information is used;\n\n   - otherwise the linker will order the sections based on permissions\n     and some special knowledge about section names.*/\nstatic void\nld_generic_create_sections (struct ld_state *statep)\n{\n  struct scngroup *groups;\n  size_t cnt;\n\n  /* For relocatable object we don't have to bother sorting the\n     sections and we do want to preserve the relocation sections as\n     they appear in the input files.  */\n  if (ld_state.file_type != relocatable_file_type)\n    {\n      /* Collect all the relocation sections.  They are handled\n\t separately.  */\n      struct scninfo *list = NULL;\n      for (cnt = 0; cnt < ld_state.nallsections; ++cnt)\n\tif ((ld_state.allsections[cnt]->type == SHT_REL\n\t     || ld_state.allsections[cnt]->type == SHT_RELA)\n\t    /* The generated relocation sections are not of any\n\t       interest here.  */\n\t    && ld_state.allsections[cnt]->last != NULL)\n\t  {\n\t    if (list == NULL)\n\t      list = ld_state.allsections[cnt]->last;\n\t    else\n\t      {\n\t\t/* Merge the sections list.  */\n\t\tstruct scninfo *first = list->next;\n\t\tlist->next = ld_state.allsections[cnt]->last->next;\n\t\tld_state.allsections[cnt]->last->next = first;\n\t\tlist = ld_state.allsections[cnt]->last;\n\t      }\n\n\t    /* Remove the entry from the section list.  */\n\t    ld_state.allsections[cnt] = NULL;\n\t  }\n      ld_state.rellist = list;\n\n      if (ld_state.output_segments == NULL)\n\t/* Sort using builtin rules.  */\n\tsort_sections_generic ();\n      else\n\tsort_sections_lscript ();\n    }\n\n  /* Now iterate over the input sections and create the sections in the\n     order they are required in the output file.  */\n  for (cnt = 0; cnt < ld_state.nallsections; ++cnt)\n    {\n      struct scnhead *head = ld_state.allsections[cnt];\n      Elf_Scn *scn;\n      XElf_Shdr_vardef (shdr);\n\n      /* Don't handle unused sections.  */\n      if (!head->used)\n\tcontinue;\n\n      /* We first have to create the section group if necessary.\n\t Section group sections must come (in section index order)\n\t before any of the section contained.  This all is necessary\n\t only for relocatable object as other object types are not\n\t allowed to contain section groups.  */\n      if (ld_state.file_type == relocatable_file_type\n\t  && unlikely (head->flags & SHF_GROUP))\n\t{\n\t  /* There is at least one section which is contained in a\n\t     section group in the input file.  This means we must\n\t     create a section group here as well.  The only problem is\n\t     that not all input files have to have to same kind of\n\t     partitioning of the sections.  I.e., sections A and B in\n\t     one input file and sections B and C in another input file\n\t     can be in one group.  That will result in a group\n\t     containing the sections A, B, and C in the output\n\t     file.  */\n\t  struct scninfo *runp;\n\t  Elf32_Word here_groupidx = 0;\n\t  struct scngroup *here_group;\n\t  struct member *newp;\n\n\t  /* First check whether any section is already in a group.\n\t     In this case we have to add this output section, too.  */\n\t  runp = head->last;\n\t  do\n\t    {\n\t      assert (runp->grpid != 0);\n\n\t      here_groupidx = runp->fileinfo->scninfo[runp->grpid].outscnndx;\n\t      if (here_groupidx != 0)\n\t\tbreak;\n\t    }\n\t  while ((runp = runp->next) != head->last);\n\n\t  if (here_groupidx == 0)\n\t    {\n\t      /* We need a new section group section.  */\n\t      scn = elf_newscn (ld_state.outelf);\n\t      xelf_getshdr (scn, shdr);\n\t      if (shdr == NULL)\n\t\terror (EXIT_FAILURE, 0,\n\t\t       gettext (\"cannot create section for output file: %s\"),\n\t\t       elf_errmsg (-1));\n\n\t      here_group = (struct scngroup *) xmalloc (sizeof (*here_group));\n\t      here_group->outscnidx = here_groupidx = elf_ndxscn (scn);\n\t      here_group->nscns = 0;\n\t      here_group->member = NULL;\n\t      here_group->next = ld_state.groups;\n\t      /* Pick a name for the section.  To keep it meaningful\n\t\t we use a name used in the input files.  If the\n\t\t section group in the output file should contain\n\t\t section which were in section groups of different\n\t\t names in the input files this is the users\n\t\t problem.  */\n\t      here_group->nameent\n\t\t= ebl_strtabadd (ld_state.shstrtab,\n\t\t\t\t elf_strptr (runp->fileinfo->elf,\n\t\t\t\t\t     runp->fileinfo->shstrndx,\n\t\t\t\t\t     SCNINFO_SHDR (runp->shdr).sh_name),\n\t\t\t\t 0);\n\t      /* Signature symbol.  */\n\t      here_group->symbol\n\t\t= runp->fileinfo->scninfo[runp->grpid].symbols;\n\n\t      ld_state.groups = here_group;\n\t    }\n\t  else\n\t    {\n\t      /* Search for the group with this index.  */\n\t      here_group = ld_state.groups;\n\t      while (here_group->outscnidx != here_groupidx)\n\t\there_group = here_group->next;\n\t    }\n\n\t  /* Add the new output section.  */\n\t  newp = (struct member *) alloca (sizeof (*newp));\n\t  newp->scn = head;\n#ifndef NDT_NEEDED\n\t  newp->next = NULL;\n#endif\n\t  CSNGL_LIST_ADD_REAR (here_group->member, newp);\n\t  ++here_group->nscns;\n\n\t  /* Store the section group index in all input files.  */\n\t  runp = head->last;\n\t  do\n\t    {\n\t      assert (runp->grpid != 0);\n\n\t      if (runp->fileinfo->scninfo[runp->grpid].outscnndx == 0)\n\t\trunp->fileinfo->scninfo[runp->grpid].outscnndx = here_groupidx;\n\t      else\n\t\tassert (runp->fileinfo->scninfo[runp->grpid].outscnndx\n\t\t\t== here_groupidx);\n\t    }\n\t  while ((runp = runp->next) != head->last);\n\t}\n\n      /* We'll use this section so get it's name in the section header\n\t string table.  */\n      if (head->kind == scn_normal)\n\thead->nameent = ebl_strtabadd (ld_state.shstrtab, head->name, 0);\n\n      /* Create a new section in the output file and add all data\n\t from all the sections we read.  */\n      scn = elf_newscn (ld_state.outelf);\n      head->scnidx = elf_ndxscn (scn);\n      xelf_getshdr (scn, shdr);\n      if (shdr == NULL)\n\terror (EXIT_FAILURE, 0,\n\t       gettext (\"cannot create section for output file: %s\"),\n\t       elf_errmsg (-1));\n\n      assert (head->type != SHT_NULL);\n      assert (head->type != SHT_SYMTAB);\n      assert (head->type != SHT_DYNSYM || head->kind != scn_normal);\n      assert (head->type != SHT_STRTAB || head->kind != scn_normal);\n      assert (head->type != SHT_GROUP);\n      shdr->sh_type = head->type;\n      shdr->sh_flags = head->flags;\n      shdr->sh_addralign = head->align;\n      shdr->sh_entsize = head->entsize;\n      assert (shdr->sh_entsize != 0 || (shdr->sh_flags & SHF_MERGE) == 0);\n      (void) xelf_update_shdr (scn, shdr);\n\n      /* We have to know the section index of the dynamic symbol table\n\t right away.  */\n      if (head->kind == scn_dot_dynsym)\n\tld_state.dynsymscnidx = elf_ndxscn (scn);\n    }\n\n  /* Actually create the section group sections.  */\n  groups = ld_state.groups;\n  while (groups != NULL)\n    {\n      Elf_Scn *scn;\n      Elf_Data *data;\n      Elf32_Word *grpdata;\n      struct member *runp;\n\n      scn = elf_getscn (ld_state.outelf, groups->outscnidx);\n      assert (scn != NULL);\n\n      data = elf_newdata (scn);\n      if (data == NULL)\n\terror (EXIT_FAILURE, 0,\n\t       gettext (\"cannot create section for output file: %s\"),\n\t       elf_errmsg (-1));\n\n      data->d_size = (groups->nscns + 1) * sizeof (Elf32_Word);\n      data->d_buf = grpdata = (Elf32_Word *) xmalloc (data->d_size);\n      data->d_type = ELF_T_WORD;\n      data->d_version = EV_CURRENT;\n      data->d_off = 0;\n      /* XXX What better to use?  */\n      data->d_align = sizeof (Elf32_Word);\n\n      /* The first word in the section is the flag word.  */\n      /* XXX Set COMDATA flag is necessary.  */\n      grpdata[0] = 0;\n\n      runp = groups->member->next;\n      cnt = 1;\n      do\n\t/* Fill in the index of the section.  */\n\tgrpdata[cnt++] = runp->scn->scnidx;\n      while ((runp = runp->next) != groups->member->next);\n\n      groups = groups->next;\n    }\n}\n\n\nstatic bool\nreduce_symbol_p (XElf_Sym *sym, struct Ebl_Strent *strent)\n{\n  const char *str;\n  const char *version;\n  struct id_list search;\n  struct id_list *verp;\n  bool result = ld_state.default_bind_local;\n\n  if (XELF_ST_BIND (sym->st_info) == STB_LOCAL || sym->st_shndx == SHN_UNDEF)\n    /* We don't have to do anything to local symbols here.  */\n    /* XXX Any section value in [SHN_LORESERVER,SHN_XINDEX) need\n       special treatment?  */\n    return false;\n\n  /* XXX Handle other symbol bindings.  */\n  assert (XELF_ST_BIND (sym->st_info) == STB_GLOBAL\n\t  || XELF_ST_BIND (sym->st_info) == STB_WEAK);\n\n  str = ebl_string (strent);\n  version = strchr (str, VER_CHR);\n  if (version != NULL)\n    {\n      search.id = strndupa (str, version - str);\n      if (*++version == VER_CHR)\n\t/* Skip the second '@' signaling a default definition.  */\n\t++version;\n    }\n  else\n    {\n      search.id = str;\n      version = \"\";\n    }\n\n  verp = ld_version_str_tab_find (&ld_state.version_str_tab,\n\t\t\t\t  elf_hash (search.id), &search);\n  while (verp != NULL)\n    {\n      /* We have this symbol in the version hash table.  Now match the\n\t version name.  */\n      if (strcmp (verp->u.s.versionname, version) == 0)\n\t/* Match!  */\n\treturn verp->u.s.local;\n\n      verp = verp->next;\n    }\n\n  /* XXX Add test for wildcard version symbols.  */\n\n  return result;\n}\n\n\nstatic XElf_Addr\neval_expression (struct expression *expr, XElf_Addr addr)\n{\n  XElf_Addr val = ~((XElf_Addr) 0);\n\n  switch (expr->tag)\n    {\n    case exp_num:\n      val = expr->val.num;\n      break;\n\n    case exp_sizeof_headers:\n      {\n\t/* The 'elf_update' call determine the offset of the first\n\t   section.  The the size of the header.  */\n\tXElf_Shdr_vardef (shdr);\n\n\txelf_getshdr (elf_getscn (ld_state.outelf, 1), shdr);\n\tassert (shdr != NULL);\n\n\tval = shdr->sh_offset;\n      }\n      break;\n\n    case exp_pagesize:\n      val = ld_state.pagesize;\n      break;\n\n    case exp_id:\n      /* We are here computing only address expressions.  It seems not\n\t to be necessary to handle any variable but \".\".  Let's avoid\n\t the complication.  If it turns up to be needed we can add\n\t it.  */\n      if (strcmp (expr->val.str, \".\") != 0)\n\terror (EXIT_FAILURE, 0, gettext (\"\\\naddress computation expression contains variable '%s'\"),\n\t       expr->val.str);\n\n      val = addr;\n      break;\n\n    case exp_mult:\n      val = (eval_expression (expr->val.binary.left, addr)\n\t     * eval_expression (expr->val.binary.right, addr));\n      break;\n\n    case exp_div:\n      val = (eval_expression (expr->val.binary.left, addr)\n\t     / eval_expression (expr->val.binary.right, addr));\n      break;\n\n    case exp_mod:\n      val = (eval_expression (expr->val.binary.left, addr)\n\t     % eval_expression (expr->val.binary.right, addr));\n      break;\n\n    case exp_plus:\n      val = (eval_expression (expr->val.binary.left, addr)\n\t     + eval_expression (expr->val.binary.right, addr));\n      break;\n\n    case exp_minus:\n      val = (eval_expression (expr->val.binary.left, addr)\n\t     - eval_expression (expr->val.binary.right, addr));\n      break;\n\n    case exp_and:\n      val = (eval_expression (expr->val.binary.left, addr)\n\t     & eval_expression (expr->val.binary.right, addr));\n      break;\n\n    case exp_or:\n      val = (eval_expression (expr->val.binary.left, addr)\n\t     | eval_expression (expr->val.binary.right, addr));\n      break;\n\n    case exp_align:\n      val = eval_expression (expr->val.child, addr);\n      if ((val & (val - 1)) != 0)\n\terror (EXIT_FAILURE, 0, gettext (\"argument '%\" PRIuMAX \"' of ALIGN in address computation expression is no power of two\"),\n\t       (uintmax_t) val);\n      val = (addr + val - 1) & ~(val - 1);\n      break;\n    }\n\n  return val;\n}\n\n\n/* Find a good as possible size for the hash table so that all the\n   non-zero entries in HASHCODES don't collide too much and the table\n   isn't too large.  There is no exact formular for this so we use a\n   heuristic.  Depending on the optimization level the search is\n   longer or shorter.  */\nstatic size_t\noptimal_bucket_size (Elf32_Word *hashcodes, size_t maxcnt, int optlevel)\n{\n  size_t minsize;\n  size_t maxsize;\n  size_t bestsize;\n  uint64_t bestcost;\n  size_t size;\n  uint32_t *counts;\n  uint32_t *lengths;\n\n  if (maxcnt == 0)\n    return 0;\n\n  /* When we are not optimizing we run only very few tests.  */\n  if (optlevel <= 0)\n    {\n      minsize = maxcnt;\n      maxsize = maxcnt + 10000 / maxcnt;\n    }\n  else\n    {\n      /* Does not make much sense to start with a smaller table than\n\t one which has at least four collisions.  */\n      minsize = MAX (1, maxcnt / 4);\n      /* We look for a best fit in the range of up to eigth times the\n\t number of elements.  */\n      maxsize = 2 * maxcnt + (6 * MIN (optlevel, 100) * maxcnt) / 100;\n    }\n  bestsize = maxcnt;\n  bestcost = UINT_MAX;\n\n  /* Array for counting the collisions and chain lengths.  */\n  counts = (uint32_t *) xmalloc ((maxcnt + 1 + maxsize) * sizeof (uint32_t));\n  lengths = &counts[maxcnt + 1];\n\n  for (size = minsize; size <= maxsize; ++size)\n    {\n      size_t inner;\n      uint64_t cost;\n      uint32_t maxlength;\n      uint64_t success;\n      uint32_t acc;\n      double factor;\n\n      memset (lengths, '\\0', size * sizeof (uint32_t));\n      memset (counts, '\\0', (maxcnt + 1) * sizeof (uint32_t));\n\n      /* Determine how often each hash bucket is used.  */\n      assert (hashcodes[0] == 0);\n      for (inner = 1; inner < maxcnt; ++inner)\n\t++lengths[hashcodes[inner] % size];\n\n      /* Determine the lengths.  */\n      maxlength = 0;\n      for (inner = 0; inner < size; ++inner)\n\t{\n\t  ++counts[lengths[inner]];\n\n\t  if (lengths[inner] > maxlength)\n\t    maxlength = lengths[inner];\n\t}\n\n      /* Determine successful lookup length.  */\n      acc = 0;\n      success = 0;\n      for (inner = 0; inner <= maxlength; ++inner)\n\t{\n\t  acc += inner;\n\t  success += counts[inner] * acc;\n\t}\n\n      /* We can compute two factors now: the average length of a\n\t positive search and the average length of a negative search.\n\t We count the number of comparisons which have to look at the\n\t names themselves.  Recognizing that the chain ended is not\n\t accounted for since it's almost for free.\n\n\t Which lookup is more important depends on the kind of DSO.\n\t If it is a system DSO like libc it is expected that most\n\t lookups succeed.  Otherwise most lookups fail.  */\n      if (ld_state.is_system_library)\n\tfactor = (1.0 * (double) success / (double) maxcnt\n\t\t  + 0.3 * (double) maxcnt / (double) size);\n      else\n\tfactor = (0.3 * (double) success / (double) maxcnt\n\t\t  + 1.0 * (double) maxcnt / (double) size);\n\n      /* Combine the lookup cost factor.  The 1/16th addend adds\n\t penalties for too large table sizes.  */\n      cost = (2 + maxcnt + size) * (factor + 1.0 / 16.0);\n\n#if 0\n      printf (\"maxcnt = %d, size = %d, cost = %Ld, success = %g, fail = %g, factor = %g\\n\",\n\t      maxcnt, size, cost, (double) success / (double) maxcnt, (double) maxcnt / (double) size, factor);\n#endif\n\n      /* Compare with current best results.  */\n      if (cost < bestcost)\n\t{\n\t  bestcost = cost;\n\t  bestsize = size;\n\t}\n    }\n\n  free (counts);\n\n  return bestsize;\n}\n\n\nstatic void\noptimal_gnu_hash_size (Elf32_Word *hashcodes, size_t maxcnt, int optlevel,\n\t\t       size_t *bitmask_nwords, size_t *shift, size_t *nbuckets)\n{\n  // XXX Implement something real\n  *bitmask_nwords = 256;\n  *shift = 6;\n  *nbuckets = 3 * maxcnt / 2;\n}\n\n\nstatic XElf_Addr\nfind_entry_point (void)\n{\n  XElf_Addr result;\n\n  if (ld_state.entry != NULL)\n    {\n      struct symbol search = { .name = ld_state.entry };\n      struct symbol *syment;\n\n      syment = ld_symbol_tab_find (&ld_state.symbol_tab,\n\t\t\t\t   elf_hash (ld_state.entry), &search);\n      if (syment != NULL && syment->defined)\n\t{\n\t  /* We found the symbol.  */\n\t  Elf_Data *data = elf_getdata (elf_getscn (ld_state.outelf,\n\t\t\t\t\t\t    ld_state.symscnidx), NULL);\n\n\t  XElf_Sym_vardef (sym);\n\n\t  sym = NULL;\n\t  if (data != NULL)\n\t    xelf_getsym (data, ld_state.dblindirect[syment->outsymidx], sym);\n\n\t  if (sym == NULL && ld_state.need_dynsym && syment->outdynsymidx != 0)\n\t    {\n\t      /* Use the dynamic symbol table if available.  */\n\t      data = elf_getdata (elf_getscn (ld_state.outelf,\n\t\t\t\t\t      ld_state.dynsymscnidx), NULL);\n\n\t      sym = NULL;\n\t      if (data != NULL)\n\t\txelf_getsym (data, syment->outdynsymidx, sym);\n\t    }\n\n\t  if (sym != NULL)\n\t    return sym->st_value;\n\n\t  /* XXX What to do if the output has no non-dynamic symbol\n\t     table and the dynamic symbol table does not contain the\n\t     symbol?  */\n\t  assert (ld_state.need_symtab);\n\t  assert (ld_state.symscnidx != 0);\n\t}\n    }\n\n  /* We couldn't find the symbol or none was given.  Use the first\n     address of the \".text\" section then.  */\n\n\n  result = 0;\n\n  /* In DSOs this is no fatal error.  They usually have no entry\n     points.  In this case we set the entry point to zero, which makes\n     sure it will always fail.  */\n  if (ld_state.file_type == executable_file_type)\n    {\n      if (ld_state.entry != NULL)\n\terror (0, 0, gettext (\"\\\ncannot find entry symbol '%s': defaulting to %#0*\" PRIx64),\n\t       ld_state.entry,\n\t       xelf_getclass (ld_state.outelf) == ELFCLASS32 ? 10 : 18,\n\t       (uint64_t) result);\n      else\n\terror (0, 0, gettext (\"\\\nno entry symbol specified: defaulting to %#0*\" PRIx64),\n\t       xelf_getclass (ld_state.outelf) == ELFCLASS32 ? 10 : 18,\n\t       (uint64_t) result);\n    }\n\n  return result;\n}\n\n\nstatic void\nfillin_special_symbol (struct symbol *symst, size_t scnidx, size_t nsym,\n\t\t       Elf_Data *symdata, struct Ebl_Strtab *strtab)\n{\n  assert (ld_state.file_type != relocatable_file_type);\n\n  XElf_Sym_vardef (sym);\n  xelf_getsym_ptr (symdata, nsym, sym);\n\n  /* The name offset will be filled in later.  */\n  sym->st_name = 0;\n  /* Traditionally: globally visible.  */\n  sym->st_info = XELF_ST_INFO (symst->local ? STB_LOCAL : STB_GLOBAL,\n\t\t\t       symst->type);\n  sym->st_other = symst->hidden ? STV_HIDDEN : STV_DEFAULT;\n  /* Reference to the GOT or dynamic section.  Since the GOT and\n     dynamic section are only created for executables and DSOs it\n     cannot be that the section index is too large.  */\n  assert (scnidx != 0);\n  assert (scnidx < SHN_LORESERVE || scnidx == SHN_ABS);\n  sym->st_shndx = scnidx;\n  /* We want the beginning of the section.  */\n  sym->st_value = 0;\n  // XXX What size?\n  sym->st_size = 0;\n\n  /* Determine the size of the section.  */\n  if (scnidx != SHN_ABS)\n    {\n      Elf_Data *data = elf_getdata (elf_getscn (ld_state.outelf, scnidx),\n\t\t\t\t    NULL);\n      assert (data != NULL);\n      sym->st_size = data->d_size;\n      /* Make sure there is no second data block.  */\n      assert (elf_getdata (elf_getscn (ld_state.outelf, scnidx), data)\n\t      == NULL);\n    }\n\n  /* Insert symbol into the symbol table.  Note that we do not have to\n     use xelf_update_symshdx.  */\n  (void) xelf_update_sym (symdata, nsym, sym);\n\n  /* Cross-references.  */\n  ndxtosym[nsym] = symst;\n  symst->outsymidx = nsym;\n\n  /* Add the name to the string table.  */\n  symstrent[nsym] = ebl_strtabadd (strtab, symst->name, 0);\n}\n\n\nstatic void\nnew_dynamic_entry (Elf_Data *data, int idx, XElf_Sxword tag, XElf_Addr val)\n{\n  XElf_Dyn_vardef (dyn);\n  xelf_getdyn_ptr (data, idx, dyn);\n  dyn->d_tag = tag;\n  dyn->d_un.d_ptr = val;\n  (void) xelf_update_dyn (data, idx, dyn);\n}\n\n\nstatic void\nallocate_version_names (struct usedfiles *runp, struct Ebl_Strtab *dynstrtab)\n{\n  /* If this DSO has no versions skip it.  */\n  if (runp->status != opened || runp->verdefdata == NULL)\n    return;\n\n  /* Add the object name.  */\n  int offset = 0;\n  while (1)\n    {\n      XElf_Verdef_vardef (def);\n      XElf_Verdaux_vardef (aux);\n\n      /* Get data at the next offset.  */\n      xelf_getverdef (runp->verdefdata, offset, def);\n      assert (def != NULL);\n      xelf_getverdaux (runp->verdefdata, offset + def->vd_aux, aux);\n      assert (aux != NULL);\n\n      assert (def->vd_ndx <= runp->nverdef);\n      if (def->vd_ndx == 1 || runp->verdefused[def->vd_ndx] != 0)\n\t{\n\t  runp->verdefent[def->vd_ndx]\n\t    = ebl_strtabadd (dynstrtab, elf_strptr (runp->elf,\n\t\t\t\t\t\t    runp->dynsymstridx,\n\t\t\t\t\t\t    aux->vda_name), 0);\n\n\t  if (def->vd_ndx > 1)\n\t    runp->verdefused[def->vd_ndx] = ld_state.nextveridx++;\n\t}\n\n      if (def->vd_next == 0)\n\t/* That were all versions.  */\n\tbreak;\n\n      offset += def->vd_next;\n    }\n}\n\n\nstatic XElf_Off\ncreate_verneed_data (XElf_Off offset, Elf_Data *verneeddata,\n\t\t     struct usedfiles *runp, int *ntotal)\n{\n  size_t verneed_size = xelf_fsize (ld_state.outelf, ELF_T_VNEED, 1);\n  size_t vernaux_size = xelf_fsize (ld_state.outelf, ELF_T_VNAUX, 1);\n  int need_offset;\n  bool filled = false;\n  GElf_Verneed verneed;\n  GElf_Vernaux vernaux;\n  int ndef = 0;\n  size_t cnt;\n\n  /* If this DSO has no versions skip it.  */\n  if (runp->nverdefused == 0)\n    return offset;\n\n  /* We fill in the Verneed record last.  Remember the offset.  */\n  need_offset = offset;\n  offset += verneed_size;\n\n  for (cnt = 2; cnt <= runp->nverdef; ++cnt)\n    if (runp->verdefused[cnt] != 0)\n      {\n\tassert (runp->verdefent[cnt] != NULL);\n\n\tif (filled)\n\t  {\n\t    vernaux.vna_next = vernaux_size;\n\t    (void) gelf_update_vernaux (verneeddata, offset, &vernaux);\n\t    offset += vernaux_size;\n\t  }\n\n\tvernaux.vna_hash = elf_hash (ebl_string (runp->verdefent[cnt]));\n\tvernaux.vna_flags = 0;\n\tvernaux.vna_other = runp->verdefused[cnt];\n\tvernaux.vna_name = ebl_strtaboffset (runp->verdefent[cnt]);\n\tfilled = true;\n\t++ndef;\n      }\n\n  assert (filled);\n  vernaux.vna_next = 0;\n  (void) gelf_update_vernaux (verneeddata, offset, &vernaux);\n  offset += vernaux_size;\n\n  verneed.vn_version = VER_NEED_CURRENT;\n  verneed.vn_cnt = ndef;\n  verneed.vn_file = ebl_strtaboffset (runp->verdefent[1]);\n  /* The first auxiliary entry is always found directly\n     after the verneed entry.  */\n  verneed.vn_aux = verneed_size;\n  verneed.vn_next = --*ntotal > 0 ? offset - need_offset : 0;\n  (void) gelf_update_verneed (verneeddata, need_offset, &verneed);\n\n  return offset;\n}\n\n\n/* Callback for qsort to sort dynamic string table.  */\nstatic Elf32_Word *global_hashcodes;\nstatic size_t global_nbuckets;\nstatic int\nsortfct_hashval (const void *p1, const void *p2)\n{\n  size_t idx1 = *(size_t *) p1;\n  size_t idx2 = *(size_t *) p2;\n\n  int def1 = ndxtosym[idx1]->defined && !ndxtosym[idx1]->in_dso;\n  int def2 = ndxtosym[idx2]->defined && !ndxtosym[idx2]->in_dso;\n\n  if (! def1 && def2)\n    return -1;\n  if (def1 && !def2)\n    return 1;\n  if (! def1)\n    return 0;\n\n  Elf32_Word hval1 = (global_hashcodes[ndxtosym[idx1]->outdynsymidx]\n\t\t      % global_nbuckets);\n  Elf32_Word hval2 = (global_hashcodes[ndxtosym[idx2]->outdynsymidx]\n\t\t      % global_nbuckets);\n\n  if (hval1 < hval2)\n    return -1;\n  if (hval1 > hval2)\n    return 1;\n  return 0;\n}\n\n\n/* Sort the dynamic symbol table.  The GNU hash table lookup assumes\n   that all symbols with the same hash value module the bucket table\n   size follow one another.  This avoids the extra hash chain table.\n   There is no need (and no way) to perform this operation if we do\n   not use the new hash table format.  */\nstatic void\ncreate_gnu_hash (size_t nsym_local, size_t nsym, size_t nsym_dyn,\n\t\t Elf32_Word *gnuhashcodes)\n{\n  size_t gnu_bitmask_nwords = 0;\n  size_t gnu_shift = 0;\n  size_t gnu_nbuckets = 0;\n  Elf32_Word *gnu_bitmask = NULL;\n  Elf32_Word *gnu_buckets = NULL;\n  Elf32_Word *gnu_chain = NULL;\n  XElf_Shdr_vardef (shdr);\n\n  /* Determine the \"optimal\" bucket size.  */\n  optimal_gnu_hash_size (gnuhashcodes, nsym_dyn, ld_state.optlevel,\n\t\t\t &gnu_bitmask_nwords, &gnu_shift, &gnu_nbuckets);\n\n  /* Create the .gnu.hash section data structures.  */\n  Elf_Scn *hashscn = elf_getscn (ld_state.outelf, ld_state.gnuhashscnidx);\n  xelf_getshdr (hashscn, shdr);\n  Elf_Data *hashdata = elf_newdata (hashscn);\n  if (shdr == NULL || hashdata == NULL)\n    error (EXIT_FAILURE, 0, gettext (\"\\\ncannot create GNU hash table section for output file: %s\"),\n\t   elf_errmsg (-1));\n\n  shdr->sh_link = ld_state.dynsymscnidx;\n  (void) xelf_update_shdr (hashscn, shdr);\n\n  hashdata->d_size = (xelf_fsize (ld_state.outelf, ELF_T_ADDR,\n\t\t\t\t  gnu_bitmask_nwords)\n\t\t      + (4 + gnu_nbuckets + nsym_dyn) * sizeof (Elf32_Word));\n  hashdata->d_buf = xcalloc (1, hashdata->d_size);\n  hashdata->d_align = sizeof (Elf32_Word);\n  hashdata->d_type = ELF_T_WORD;\n  hashdata->d_off = 0;\n\n  ((Elf32_Word *) hashdata->d_buf)[0] = gnu_nbuckets;\n  ((Elf32_Word *) hashdata->d_buf)[2] = gnu_bitmask_nwords;\n  ((Elf32_Word *) hashdata->d_buf)[3] = gnu_shift;\n  gnu_bitmask = &((Elf32_Word *) hashdata->d_buf)[4];\n  gnu_buckets = &gnu_bitmask[xelf_fsize (ld_state.outelf, ELF_T_ADDR,\n\t\t\t\t\t gnu_bitmask_nwords)\n\t\t\t     / sizeof (*gnu_buckets)];\n  gnu_chain = &gnu_buckets[gnu_nbuckets];\n#ifndef NDEBUG\n  void *endp = &gnu_chain[nsym_dyn];\n#endif\n  assert (endp == (void *) ((char *) hashdata->d_buf + hashdata->d_size));\n\n\n  size_t *remap = xmalloc (nsym_dyn * sizeof (size_t));\n#ifndef NDEBUG\n  size_t nsym_dyn_cnt = 1;\n#endif\n  for (size_t cnt = nsym_local; cnt < nsym; ++cnt)\n    if (symstrent[cnt] != NULL)\n      {\n\tassert (ndxtosym[cnt]->outdynsymidx > 0);\n\tassert (ndxtosym[cnt]->outdynsymidx < nsym_dyn);\n\tremap[ndxtosym[cnt]->outdynsymidx] = cnt;\n#ifndef NDEBUG\n\t++nsym_dyn_cnt;\n#endif\n      }\n  assert (nsym_dyn_cnt == nsym_dyn);\n\n  // XXX Until we can rely on qsort_r use global variables.\n  global_hashcodes = gnuhashcodes;\n  global_nbuckets = gnu_nbuckets;\n  qsort (remap + 1, nsym_dyn - 1, sizeof (size_t), sortfct_hashval);\n\n  bool bm32 = (xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1)\n\t       ==  sizeof (Elf32_Word));\n\n  size_t first_defined = 0;\n  Elf64_Word bitmask_idxbits = gnu_bitmask_nwords - 1;\n  Elf32_Word last_bucket = 0;\n  for (size_t cnt = 1; cnt < nsym_dyn; ++cnt)\n    {\n      if (first_defined == 0)\n\t{\n\t  if (! ndxtosym[remap[cnt]]->defined\n\t      || ndxtosym[remap[cnt]]->in_dso)\n\t    goto next;\n\n\t  ((Elf32_Word *) hashdata->d_buf)[1] = first_defined = cnt;\n\t}\n\n      Elf32_Word hval = gnuhashcodes[ndxtosym[remap[cnt]]->outdynsymidx];\n\n      if (bm32)\n\t{\n\t  Elf32_Word *bsw = &gnu_bitmask[(hval / 32) & bitmask_idxbits];\n\t  assert ((void *) gnu_bitmask <= (void *) bsw);\n\t  assert ((void *) bsw < (void *) gnu_buckets);\n\t  *bsw |= 1 << (hval & 31);\n\t  *bsw |= 1 << ((hval >> gnu_shift) & 31);\n\t}\n      else\n\t{\n\t  Elf64_Word *bsw = &((Elf64_Word *) gnu_bitmask)[(hval / 64)\n\t\t\t\t\t\t\t  & bitmask_idxbits];\n\t  assert ((void *) gnu_bitmask <= (void *) bsw);\n\t  assert ((void *) bsw < (void *) gnu_buckets);\n\t  *bsw |= 1 << (hval & 63);\n\t  *bsw |= 1 << ((hval >> gnu_shift) & 63);\n\t}\n\n      size_t this_bucket = hval % gnu_nbuckets;\n      if (cnt == first_defined || this_bucket != last_bucket)\n\t{\n\t  if (cnt != first_defined)\n\t    {\n\t      /* Terminate the previous chain.  */\n\t      assert ((void *) &gnu_chain[cnt - first_defined - 1] < endp);\n\t      gnu_chain[cnt - first_defined - 1] |= 1;\n\t    }\n\n\t  assert (this_bucket < gnu_nbuckets);\n\t  gnu_buckets[this_bucket] = cnt;\n\t  last_bucket = this_bucket;\n\t}\n\n      assert (cnt >= first_defined);\n      assert (cnt - first_defined < nsym_dyn);\n      gnu_chain[cnt - first_defined] = hval & ~1u;\n\n    next:\n      ndxtosym[remap[cnt]]->outdynsymidx = cnt;\n    }\n\n  /* Terminate the last chain.  */\n  if (first_defined != 0)\n    {\n      assert (nsym_dyn > first_defined);\n      assert (nsym_dyn - first_defined - 1 < nsym_dyn);\n      gnu_chain[nsym_dyn - first_defined - 1] |= 1;\n\n      hashdata->d_size -= first_defined * sizeof (Elf32_Word);\n    }\n  else\n    /* We do not need any hash table.  */\n    // XXX\n    do { } while (0);\n\n  free (remap);\n}\n\n\n/* Create the SysV-style hash table.  */\nstatic void\ncreate_hash (size_t nsym_local, size_t nsym, size_t nsym_dyn,\n\t     Elf32_Word *hashcodes)\n{\n  size_t nbucket = 0;\n  Elf32_Word *bucket = NULL;\n  Elf32_Word *chain = NULL;\n  XElf_Shdr_vardef (shdr);\n\n  /* Determine the \"optimal\" bucket size.  If we also generate the\n     new-style hash function there is no need to waste effort and\n     space on the old one which should not be used.  Make it as small\n     as possible.  */\n  if (GENERATE_GNU_HASH)\n    nbucket = 1;\n  else\n    nbucket = optimal_bucket_size (hashcodes, nsym_dyn, ld_state.optlevel);\n  /* Create the .hash section data structures.  */\n  Elf_Scn *hashscn = elf_getscn (ld_state.outelf, ld_state.hashscnidx);\n  xelf_getshdr (hashscn, shdr);\n  Elf_Data *hashdata = elf_newdata (hashscn);\n  if (shdr == NULL || hashdata == NULL)\n    error (EXIT_FAILURE, 0, gettext (\"\\\ncannot create hash table section for output file: %s\"),\n\t   elf_errmsg (-1));\n\n  shdr->sh_link = ld_state.dynsymscnidx;\n  (void) xelf_update_shdr (hashscn, shdr);\n\n  hashdata->d_size = (2 + nsym_dyn + nbucket) * sizeof (Elf32_Word);\n  hashdata->d_buf = xcalloc (1, hashdata->d_size);\n  hashdata->d_align = sizeof (Elf32_Word);\n  hashdata->d_type = ELF_T_WORD;\n  hashdata->d_off = 0;\n\n  ((Elf32_Word *) hashdata->d_buf)[0] = nbucket;\n  ((Elf32_Word *) hashdata->d_buf)[1] = nsym_dyn;\n  bucket = &((Elf32_Word *) hashdata->d_buf)[2];\n  chain = &((Elf32_Word *) hashdata->d_buf)[2 + nbucket];\n\n  for (size_t cnt = nsym_local; cnt < nsym; ++cnt)\n    if (symstrent[cnt] != NULL)\n      {\n\tsize_t dynidx = ndxtosym[cnt]->outdynsymidx;\n\tsize_t hashidx = hashcodes[dynidx] % nbucket;\n\tif (bucket[hashidx] == 0)\n\t  bucket[hashidx] = dynidx;\n\telse\n\t  {\n\t    hashidx = bucket[hashidx];\n\t    while (chain[hashidx] != 0)\n\t      hashidx = chain[hashidx];\n\n\t    chain[hashidx] = dynidx;\n\t  }\n      }\n}\n\n\nstatic void\ncreate_build_id_section (Elf_Scn *scn)\n{\n  /* We know how large the section will be so we can create it now.  */\n  Elf_Data *d = elf_newdata (scn);\n  if (d == NULL)\n    error (EXIT_FAILURE, 0, gettext (\"cannot create build ID section: %s\"),\n\t   elf_errmsg (-1));\n\n  d->d_type = ELF_T_BYTE;\n  d->d_version = EV_CURRENT;\n\n  /* The note section header.  */\n  assert (sizeof (Elf32_Nhdr) == sizeof (Elf64_Nhdr));\n  d->d_size = sizeof (GElf_Nhdr);\n  /* The string is four bytes long.  */\n  d->d_size += sizeof (ELF_NOTE_GNU);\n  assert (d->d_size % 4 == 0);\n\n  if (strcmp (ld_state.build_id, \"md5\") == 0\n      || strcmp (ld_state.build_id, \"uuid\") == 0)\n    d->d_size += 16;\n  else if (strcmp (ld_state.build_id, \"sha1\") == 0)\n    d->d_size += 20;\n  else\n    {\n      assert (ld_state.build_id[0] == '0' && ld_state.build_id[1] == 'x');\n      /* Use an upper limit of the possible number of bytes generated\n\t from the string.  */\n      d->d_size += strlen (ld_state.build_id) / 2;\n    }\n\n  d->d_buf = xcalloc (d->d_size, 1);\n  d->d_off = 0;\n  d->d_align = 0;\n}\n\n\nstatic void\ncompute_hash_sum (void (*hashfct) (const void *, size_t, void *), void *ctx)\n{\n  /* The call cannot fail.  */\n  size_t shstrndx;\n  (void) elf_getshdrstrndx (ld_state.outelf, &shstrndx);\n\n  const char *ident = elf_getident (ld_state.outelf, NULL);\n  bool same_byte_order = ((ident[EI_DATA] == ELFDATA2LSB\n\t\t\t   && __BYTE_ORDER == __LITTLE_ENDIAN)\n\t\t\t  || (ident[EI_DATA] == ELFDATA2MSB\n\t\t\t      && __BYTE_ORDER == __BIG_ENDIAN));\n\n  /* Iterate over all sections to find those which are not strippable.  */\n  Elf_Scn *scn = NULL;\n  while ((scn = elf_nextscn (ld_state.outelf, scn)) != NULL)\n    {\n      /* Get the section header.  */\n      GElf_Shdr shdr_mem;\n      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);\n      assert (shdr != NULL);\n\n      if (SECTION_STRIP_P (shdr, elf_strptr (ld_state.outelf, shstrndx,\n\t\t\t\t\t     shdr->sh_name), true))\n\t/* The section can be stripped.  Don't use it.  */\n\tcontinue;\n\n      /* Do not look at NOBITS sections.  */\n      if (shdr->sh_type == SHT_NOBITS)\n\tcontinue;\n\n      /* Iterate through the list of data blocks.  */\n      Elf_Data *data = NULL;\n      while ((data = INTUSE(elf_getdata) (scn, data)) != NULL)\n\t/* If the file byte order is the same as the host byte order\n\t   process the buffer directly.  If the data is just a stream\n\t   of bytes which the library will not convert we can use it\n\t   as well.  */\n\tif (likely (same_byte_order) || data->d_type == ELF_T_BYTE)\n\t  hashfct (data->d_buf, data->d_size, ctx);\n\telse\n\t  {\n\t    /* Convert the data to file byte order.  */\n\t    if (gelf_xlatetof (ld_state.outelf, data, data, ident[EI_DATA])\n\t\t== NULL)\n\t      error (EXIT_FAILURE, 0, gettext (\"\\\ncannot convert section data to file format: %s\"),\n\t\t     elf_errmsg (-1));\n\n\t    hashfct (data->d_buf, data->d_size, ctx);\n\n\t    /* And convert it back.  */\n\t    if (gelf_xlatetom (ld_state.outelf, data, data, ident[EI_DATA])\n\t\t== NULL)\n\t      error (EXIT_FAILURE, 0, gettext (\"\\\ncannot convert section data to memory format: %s\"),\n\t\t     elf_errmsg (-1));\n\t  }\n    }\n}\n\n\n/* Iterate over the sections */\nstatic void\ncompute_build_id (void)\n{\n  Elf_Data *d = elf_getdata (elf_getscn (ld_state.outelf,\n\t\t\t\t\t ld_state.buildidscnidx), NULL);\n  assert (d != NULL);\n\n  GElf_Nhdr *hdr = d->d_buf;\n  hdr->n_namesz = sizeof (ELF_NOTE_GNU);\n  hdr->n_type = NT_GNU_BUILD_ID;\n  char *dp = mempcpy (hdr + 1, ELF_NOTE_GNU, sizeof (ELF_NOTE_GNU));\n\n  if (strcmp (ld_state.build_id, \"sha1\") == 0)\n    {\n      /* Compute the SHA1 sum of various parts of the generated file.\n\t We compute the hash sum over the external representation.  */\n      struct sha1_ctx ctx;\n      sha1_init_ctx (&ctx);\n\n      /* Compute the hash sum by running over all sections.  */\n      compute_hash_sum ((void (*) (const void *, size_t, void *)) sha1_process_bytes,\n\t\t\t&ctx);\n\n      /* We are done computing the checksum.  */\n      (void) sha1_finish_ctx (&ctx, dp);\n\n      hdr->n_descsz = SHA1_DIGEST_SIZE;\n    }\n  else if (strcmp (ld_state.build_id, \"md5\") == 0)\n    {\n      /* Compute the MD5 sum of various parts of the generated file.\n\t We compute the hash sum over the external representation.  */\n      struct md5_ctx ctx;\n      md5_init_ctx (&ctx);\n\n      /* Compute the hash sum by running over all sections.  */\n      compute_hash_sum ((void (*) (const void *, size_t, void *)) md5_process_bytes,\n\t\t\t&ctx);\n\n      /* We are done computing the checksum.  */\n      (void) md5_finish_ctx (&ctx, dp);\n\n      hdr->n_descsz = MD5_DIGEST_SIZE;\n    }\n  else if (strcmp (ld_state.build_id, \"uuid\") == 0)\n    {\n      int fd = open (\"/dev/urandom\", O_RDONLY);\n      if (fd == -1)\n\terror (EXIT_FAILURE, errno, gettext (\"cannot open '%s'\"),\n\t       \"/dev/urandom\");\n\n      if (TEMP_FAILURE_RETRY (read (fd, dp, 16)) != 16)\n\terror (EXIT_FAILURE, 0, gettext (\"cannot read enough data for UUID\"));\n\n      close (fd);\n\n      hdr->n_descsz = 16;\n    }\n  else\n    {\n      const char *cp = ld_state.build_id + 2;\n\n      /* The form of the string has been verified before so here we can\n\t simplify the scanning.  */\n      do\n\t{\n\t  if (isxdigit (cp[0]))\n\t    {\n\t      char ch1 = tolower (cp[0]);\n\t      char ch2 = tolower (cp[1]);\n\n\t      *dp++ = (((isdigit (ch1) ? ch1 - '0' : ch1 - 'a' + 10) << 4)\n\t\t       | (isdigit (ch2) ? ch2 - '0' : ch2 - 'a' + 10));\n\t    }\n\t  else\n\t    ++cp;\n\t}\n      while (*cp != '\\0');\n    }\n}\n\n\n/* Create the output file.\n\n   For relocatable files what basically has to happen is that all\n   sections from all input files are written into the output file.\n   Sections with the same name are combined (offsets adjusted\n   accordingly).  The symbol tables are combined in one single table.\n   When stripping certain symbol table entries are omitted.\n\n   For executables (shared or not) we have to create the program header,\n   additional sections like the .interp, eventually (in addition) create\n   a dynamic symbol table and a dynamic section.  Also the relocations\n   have to be processed differently.  */\nstatic int\nld_generic_create_outfile (struct ld_state *statep)\n{\n  struct scnlist\n  {\n    size_t scnidx;\n    struct scninfo *scninfo;\n    struct scnlist *next;\n  };\n  struct scnlist *rellist = NULL;\n  size_t cnt;\n  Elf_Scn *symscn = NULL;\n  Elf_Scn *xndxscn = NULL;\n  Elf_Scn *strscn = NULL;\n  struct Ebl_Strtab *strtab = NULL;\n  struct Ebl_Strtab *dynstrtab = NULL;\n  XElf_Shdr_vardef (shdr);\n  Elf_Data *data;\n  Elf_Data *symdata = NULL;\n  Elf_Data *xndxdata = NULL;\n  struct usedfiles *file;\n  size_t nsym;\n  size_t nsym_local;\n  size_t nsym_allocated;\n  size_t nsym_dyn = 0;\n  Elf32_Word *dblindirect = NULL;\n#ifndef NDEBUG\n  bool need_xndx;\n#endif\n  Elf_Scn *shstrtab_scn;\n  size_t shstrtab_ndx;\n  XElf_Ehdr_vardef (ehdr);\n  struct Ebl_Strent *symtab_ent = NULL;\n  struct Ebl_Strent *xndx_ent = NULL;\n  struct Ebl_Strent *strtab_ent = NULL;\n  struct Ebl_Strent *shstrtab_ent;\n  struct scngroup *groups;\n  Elf_Scn *dynsymscn = NULL;\n  Elf_Data *dynsymdata = NULL;\n  Elf_Data *dynstrdata = NULL;\n  Elf32_Word *hashcodes = NULL;\n  Elf32_Word *gnuhashcodes = NULL;\n  size_t nsym_dyn_allocated = 0;\n  Elf_Scn *versymscn = NULL;\n  Elf_Data *versymdata = NULL;\n\n  if (ld_state.need_symtab)\n    {\n      /* First create the symbol table.  We need the symbol section itself\n\t and the string table for it.  */\n      symscn = elf_newscn (ld_state.outelf);\n      ld_state.symscnidx = elf_ndxscn (symscn);\n      symdata = elf_newdata (symscn);\n      if (symdata == NULL)\n\terror (EXIT_FAILURE, 0,\n\t       gettext (\"cannot create symbol table for output file: %s\"),\n\t       elf_errmsg (-1));\n\n      symdata->d_type = ELF_T_SYM;\n      /* This is an estimated size, but it will definitely cap the real value.\n\t We might have to adjust the number later.  */\n      nsym_allocated = (1 + ld_state.nsymtab + ld_state.nplt + ld_state.ngot\n\t\t\t+ ld_state.nusedsections + ld_state.nlscript_syms);\n      symdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_SYM,\n\t\t\t\t    nsym_allocated);\n\n      /* Optionally the extended section table.  */\n      /* XXX Is SHN_LORESERVE correct?  Do we need some other sections?  */\n      if (unlikely (ld_state.nusedsections >= SHN_LORESERVE))\n\t{\n\t  xndxscn = elf_newscn (ld_state.outelf);\n\t  ld_state.xndxscnidx = elf_ndxscn (xndxscn);\n\n\t  xndxdata = elf_newdata (xndxscn);\n\t  if (xndxdata == NULL)\n\t    error (EXIT_FAILURE, 0,\n\t\t   gettext (\"cannot create symbol table for output file: %s\"),\n\t\t   elf_errmsg (-1));\n\n\t  /* The following relies on the fact that Elf32_Word and Elf64_Word\n\t     have the same size.  */\n\t  xndxdata->d_type = ELF_T_WORD;\n\t  /* This is an estimated size, but it will definitely cap the\n\t     real value.  we might have to adjust the number later.  */\n\t  xndxdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_WORD,\n\t\t\t\t\t nsym_allocated);\n\t  /* The first entry is left empty, clear it here and now.  */\n\t  xndxdata->d_buf = memset (xmalloc (xndxdata->d_size), '\\0',\n\t\t\t\t    xelf_fsize (ld_state.outelf, ELF_T_WORD,\n\t\t\t\t\t\t1));\n\t  xndxdata->d_off = 0;\n\t  /* XXX Should use an ebl function.  */\n\t  xndxdata->d_align = sizeof (Elf32_Word);\n\t}\n    }\n  else\n    {\n      assert (ld_state.need_dynsym);\n\n      /* First create the symbol table.  We need the symbol section itself\n\t and the string table for it.  */\n      symscn = elf_getscn (ld_state.outelf, ld_state.dynsymscnidx);\n      symdata = elf_newdata (symscn);\n      if (symdata == NULL)\n\terror (EXIT_FAILURE, 0,\n\t       gettext (\"cannot create symbol table for output file: %s\"),\n\t       elf_errmsg (-1));\n\n      symdata->d_version = EV_CURRENT;\n      symdata->d_type = ELF_T_SYM;\n      /* This is an estimated size, but it will definitely cap the real value.\n\t We might have to adjust the number later.  */\n      nsym_allocated = (1 + ld_state.nsymtab + ld_state.nplt + ld_state.ngot\n\t\t\t- ld_state.nlocalsymbols + ld_state.nlscript_syms);\n      symdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_SYM,\n\t\t\t\t    nsym_allocated);\n    }\n\n  /* The first entry is left empty, clear it here and now.  */\n  symdata->d_buf = memset (xmalloc (symdata->d_size), '\\0',\n\t\t\t   xelf_fsize (ld_state.outelf, ELF_T_SYM, 1));\n  symdata->d_off = 0;\n  /* XXX This is ugly but how else can it be done.  */\n  symdata->d_align = xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1);\n\n  /* Allocate another array to keep track of the handles for the symbol\n     names.  */\n  symstrent = (struct Ebl_Strent **) xcalloc (nsym_allocated,\n\t\t\t\t\t      sizeof (struct Ebl_Strent *));\n\n  /* By starting at 1 we effectively add a null entry.  */\n  nsym = 1;\n\n  /* Iteration over all sections.  */\n  for (cnt = 0; cnt < ld_state.nallsections; ++cnt)\n    {\n      struct scnhead *head = ld_state.allsections[cnt];\n      Elf_Scn *scn;\n      struct scninfo *runp;\n      XElf_Off offset;\n      Elf32_Word xndx;\n\n      /* Don't handle unused sections at all.  */\n      if (!head->used)\n\tcontinue;\n\n      /* Get the section handle.  */\n      scn = elf_getscn (ld_state.outelf, head->scnidx);\n\n      if (unlikely (head->kind == scn_dot_interp))\n\t{\n\t  Elf_Data *outdata = elf_newdata (scn);\n\t  if (outdata == NULL)\n\t    error (EXIT_FAILURE, 0,\n\t\t   gettext (\"cannot create section for output file: %s\"),\n\t\t   elf_errmsg (-1));\n\n\t  /* This is the string we'll put in the section.  */\n\t  const char *interp = ld_state.interp ?: \"/lib/ld.so.1\";\n\n\t  /* Create the section data.  */\n\t  outdata->d_buf = (void *) interp;\n\t  outdata->d_size = strlen (interp) + 1;\n\t  outdata->d_type = ELF_T_BYTE;\n\t  outdata->d_off = 0;\n\t  outdata->d_align = 1;\n\t  outdata->d_version = EV_CURRENT;\n\n\t  /* Remember the index of this section.  */\n\t  ld_state.interpscnidx = head->scnidx;\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_got))\n\t{\n\t  /* Remember the index of this section.  */\n\t  ld_state.gotscnidx = elf_ndxscn (scn);\n\n\t  /* Give the backend the change to initialize the section.  */\n\t  INITIALIZE_GOT (&ld_state, scn);\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_gotplt))\n\t{\n\t  /* Remember the index of this section.  */\n\t  ld_state.gotpltscnidx = elf_ndxscn (scn);\n\n\t  /* Give the backend the change to initialize the section.  */\n\t  INITIALIZE_GOTPLT (&ld_state, scn);\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_dynrel))\n\t{\n\t  Elf_Data *outdata;\n\n\t  outdata = elf_newdata (scn);\n\t  if (outdata == NULL)\n\t    error (EXIT_FAILURE, 0,\n\t\t   gettext (\"cannot create section for output file: %s\"),\n\t\t   elf_errmsg (-1));\n\n\t  outdata->d_size = ld_state.relsize_total;\n\t  outdata->d_buf = xmalloc (outdata->d_size);\n\t  outdata->d_type = (REL_TYPE (&ld_state) == DT_REL\n\t\t\t     ? ELF_T_REL : ELF_T_RELA);\n\t  outdata->d_off = 0;\n\t  outdata->d_align = xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1);\n\n\t  /* Remember the index of this section.  */\n\t  ld_state.reldynscnidx = elf_ndxscn (scn);\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_dynamic))\n\t{\n\t  /* Only create the data for now.  */\n\t  Elf_Data *outdata;\n\n\t  /* Account for a few more entries we have to add.  */\n\t  if (ld_state.dt_flags != 0)\n\t    ++ld_state.ndynamic;\n\t  if (ld_state.dt_flags_1 != 0)\n\t    ++ld_state.ndynamic;\n\t  if (ld_state.dt_feature_1 != 0)\n\t    ++ld_state.ndynamic;\n\n\t  outdata = elf_newdata (scn);\n\t  if (outdata == NULL)\n\t    error (EXIT_FAILURE, 0,\n\t\t   gettext (\"cannot create section for output file: %s\"),\n\t\t   elf_errmsg (-1));\n\n\t  /* Create the section data.  */\n\t  outdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_DYN,\n\t\t\t\t\tld_state.ndynamic);\n\t  outdata->d_buf = xcalloc (1, outdata->d_size);\n\t  outdata->d_type = ELF_T_DYN;\n\t  outdata->d_off = 0;\n\t  outdata->d_align = xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1);\n\n\t  /* Remember the index of this section.  */\n\t  ld_state.dynamicscnidx = elf_ndxscn (scn);\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_dynsym))\n\t{\n\t  /* We already know the section index.  */\n\t  assert (ld_state.dynsymscnidx == elf_ndxscn (scn));\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_dynstr))\n\t{\n\t  /* Remember the index of this section.  */\n\t  ld_state.dynstrscnidx = elf_ndxscn (scn);\n\n\t  /* Create the string table.  */\n\t  dynstrtab = ebl_strtabinit (true);\n\n\t  /* XXX TBI\n\t     We have to add all the strings which are needed in the\n\t     dynamic section here.  This means DT_FILTER,\n\t     DT_AUXILIARY, ... entries.  */\n\t  if (ld_state.ndsofiles > 0)\n\t    {\n\t      struct usedfiles *frunp = ld_state.dsofiles;\n\n\t      do\n\t\tif (! frunp->as_needed || frunp->used)\n\t\t  frunp->sonameent = ebl_strtabadd (dynstrtab, frunp->soname,\n\t\t\t\t\t\t    0);\n\t      while ((frunp = frunp->next) != ld_state.dsofiles);\n\t    }\n\n\n\t  /* Add the runtime path information.  The strings are stored\n\t     in the .dynstr section.  If both rpath and runpath are defined\n\t     the runpath information is used.  */\n\t  if (ld_state.runpath != NULL || ld_state.rpath != NULL)\n\t    {\n\t      struct pathelement *startp;\n\t      struct pathelement *prunp;\n\t      int tag;\n\t      size_t len;\n\t      char *str;\n\t      char *cp;\n\n\t      if (ld_state.runpath != NULL)\n\t\t{\n\t\t  startp = ld_state.runpath;\n\t\t  tag = DT_RUNPATH;\n\t\t}\n\t      else\n\t\t{\n\t\t  startp = ld_state.rpath;\n\t\t  tag = DT_RPATH;\n\t\t}\n\n\t      /* Determine how long the string will be.  */\n\t      for (len = 0, prunp = startp; prunp != NULL; prunp = prunp->next)\n\t\tlen += strlen (prunp->pname) + 1;\n\n\t      cp = str = (char *) obstack_alloc (&ld_state.smem, len);\n\t      /* Copy the string.  */\n\t      for (prunp = startp; prunp != NULL; prunp = prunp->next)\n\t\t{\n\t\t  cp = stpcpy (cp, prunp->pname);\n\t\t  *cp++ = ':';\n\t\t}\n\t      /* Remove the last colon.  */\n\t      cp[-1] = '\\0';\n\n\t      /* Remember the values until we can generate the dynamic\n\t\t section.  */\n\t      ld_state.rxxpath_strent = ebl_strtabadd (dynstrtab, str, len);\n\t      ld_state.rxxpath_tag = tag;\n\t    }\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_hash))\n\t{\n\t  /* Remember the index of this section.  */\n\t  ld_state.hashscnidx = elf_ndxscn (scn);\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_gnu_hash))\n\t{\n\t  /* Remember the index of this section.  */\n\t  ld_state.gnuhashscnidx = elf_ndxscn (scn);\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_plt))\n\t{\n\t  /* Remember the index of this section.  */\n\t  ld_state.pltscnidx = elf_ndxscn (scn);\n\n\t  /* Give the backend the change to initialize the section.  */\n\t  INITIALIZE_PLT (&ld_state, scn);\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_pltrel))\n\t{\n\t  /* Remember the index of this section.  */\n\t  ld_state.pltrelscnidx = elf_ndxscn (scn);\n\n\t  /* Give the backend the change to initialize the section.  */\n\t  INITIALIZE_PLTREL (&ld_state, scn);\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_version))\n\t{\n\t  /* Remember the index of this section.  */\n\t  ld_state.versymscnidx = elf_ndxscn (scn);\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_version_r))\n\t{\n\t  /* Remember the index of this section.  */\n\t  ld_state.verneedscnidx = elf_ndxscn (scn);\n\n\t  continue;\n\t}\n\n      if (unlikely (head->kind == scn_dot_note_gnu_build_id))\n\t{\n\t  /* Remember the index of this section.  */\n\t  ld_state.buildidscnidx = elf_ndxscn (scn);\n\n\t  create_build_id_section (scn);\n\n\t  continue;\n\t}\n\n      /* If we come here we must be handling a normal section.  */\n      assert (head->kind == scn_normal);\n\n      /* Create an STT_SECTION entry in the symbol table.  But not for\n\t the symbolic symbol table.  */\n      if (ld_state.need_symtab)\n\t{\n\t  /* XXX Can we be cleverer and do this only if needed?  */\n\t  XElf_Sym_vardef (sym);\n\n\t  /* Optimization ahead: in the native linker we get a pointer\n\t     to the final location so that the following code writes\n\t     directly in the correct place.  Otherwise we write into\n\t     the local variable first.  */\n\t  xelf_getsym_ptr (symdata, nsym, sym);\n\n\t  /* Usual section symbol: local, no specific information,\n\t     except the section index.  The offset here is zero, the\n\t     start address will later be added.  */\n\t  sym->st_name = 0;\n\t  sym->st_info = XELF_ST_INFO (STB_LOCAL, STT_SECTION);\n\t  sym->st_other = 0;\n\t  sym->st_value = 0;\n\t  sym->st_size = 0;\n\t  /* In relocatable files the section index can be too big for\n\t     the ElfXX_Sym struct.  we have to deal with the extended\n\t     symbol table.  */\n\t  if (likely (head->scnidx < SHN_LORESERVE))\n\t    {\n\t      sym->st_shndx = head->scnidx;\n\t      xndx = 0;\n\t    }\n\t  else\n\t    {\n\t      sym->st_shndx = SHN_XINDEX;\n\t      xndx = head->scnidx;\n\t    }\n\t  /* Commit the change.  See the optimization above, this does\n\t     not change the symbol table entry.  But the extended\n\t     section index table entry is always written, if there is\n\t     such a table.  */\n\t  assert (nsym < nsym_allocated);\n\t  xelf_update_symshndx (symdata, xndxdata, nsym, sym, xndx, 0);\n\n\t  /* Remember the symbol's index in the symbol table.  */\n\t  head->scnsymidx = nsym++;\n\t}\n\n      if (head->type == SHT_REL || head->type == SHT_RELA)\n\t{\n\t  /* Remember that we have to fill in the symbol table section\n\t     index.  */\n\t  if (ld_state.file_type == relocatable_file_type)\n\t    {\n\t      struct scnlist *newp;\n\n\t      newp = (struct scnlist *) alloca (sizeof (*newp));\n\t      newp->scnidx = head->scnidx;\n\t      newp->scninfo = head->last->next;\n#ifndef NDEBUG\n\t      newp->next = NULL;\n#endif\n\t      SNGL_LIST_PUSH (rellist, newp);\n\t    }\n\t  else\n\t    {\n\t      /* When we create an executable or a DSO we don't simply\n\t\t copy the existing relocations.  Instead many will be\n\t\t resolved, others will be converted.  Create a data buffer\n\t\t large enough to contain the contents which we will fill\n\t\t in later.  */\n\t      int type = head->type == SHT_REL ? ELF_T_REL : ELF_T_RELA;\n\n\t      data = elf_newdata (scn);\n\t      if (data == NULL)\n\t\terror (EXIT_FAILURE, 0,\n\t\t       gettext (\"cannot create section for output file: %s\"),\n\t\t       elf_errmsg (-1));\n\n\t      data->d_size = xelf_fsize (ld_state.outelf, type, head->relsize);\n\t      data->d_buf = xcalloc (data->d_size, 1);\n\t      data->d_type = type;\n\t      data->d_align = xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1);\n\t      data->d_off = 0;\n\n\t      continue;\n\t    }\n\t}\n\n      /* Recognize string and merge flag and handle them.  */\n      if (head->flags & SHF_MERGE)\n\t{\n\t  /* We merge the contents of the sections.  For this we do\n\t     not look at the contents of section directly.  Instead we\n\t     look at the symbols of the section.  */\n\t  Elf_Data *outdata;\n\n\t  /* Concatenate the lists of symbols for all sections.\n\n\t     XXX In case any input section has no symbols associated\n\t     (this happens for debug sections) we cannot use this\n\t     method.  Implement parsing the other debug sections and\n\t     find the string pointers.  For now we don't merge.  */\n\t  runp = head->last->next;\n\t  if (runp->symbols == NULL)\n\t    {\n\t      head->flags &= ~SHF_MERGE;\n\t      goto no_merge;\n\t    }\n\t  head->symbols = runp->symbols;\n\n\t  while ((runp = runp->next) != head->last->next)\n\t    {\n\t      if (runp->symbols == NULL)\n\t\t{\n\t\t  head->flags &= ~SHF_MERGE;\n\t\t  head->symbols = NULL;\n\t\t  goto no_merge;\n\t\t}\n\n\t      struct symbol *oldhead = head->symbols->next_in_scn;\n\n\t      head->symbols->next_in_scn = runp->symbols->next_in_scn;\n\t      runp->symbols->next_in_scn = oldhead;\n\t      head->symbols = runp->symbols;\n\t    }\n\n\t  /* Create the output section.  */\n\t  outdata = elf_newdata (scn);\n\t  if (outdata == NULL)\n\t    error (EXIT_FAILURE, 0,\n\t\t   gettext (\"cannot create section for output file: %s\"),\n\t\t   elf_errmsg (-1));\n\n\t  /* We use different merging algorithms for performance\n\t     reasons.  We can easily handle single-byte and\n\t     wchar_t-wide character strings.  All other cases (which\n\t     really should happen in real life) are handled by the\n\t     generic code.  */\n\t  if (SCNINFO_SHDR (head->last->shdr).sh_entsize == 1\n\t      && (head->flags & SHF_STRINGS))\n\t    {\n\t      /* Simple, single-byte string matching.  */\n\t      struct Ebl_Strtab *mergestrtab;\n\t      struct symbol *symrunp;\n\t      Elf_Data *locsymdata = NULL;\n\t      Elf_Data *locdata = NULL;\n\n\t      mergestrtab = ebl_strtabinit (false);\n\n\t      symrunp = head->symbols->next_in_scn;\n\t      file = NULL;\n\t      do\n\t\t{\n\t\t  /* Accelarate the loop.  We cache the file\n\t\t     information since it might very well be the case\n\t\t     that the previous entry was from the same\n\t\t     file.  */\n\t\t  if (symrunp->file != file)\n\t\t    {\n\t\t      /* Remember the file.  */\n\t\t      file = symrunp->file;\n\t\t      /* Symbol table data from that file.  */\n\t\t      locsymdata = file->symtabdata;\n\t\t      /* String section data.  */\n\t\t      locdata = elf_rawdata (file->scninfo[symrunp->scndx].scn,\n\t\t\t\t\t     NULL);\n\t\t      assert (locdata != NULL);\n\t\t      /* While we are at it, remember the output\n\t\t\t section.  If we don't access the string data\n\t\t\t section the section won't be in the output\n\t\t\t file.  So it is sufficient to do the work\n\t\t\t here.  */\n\t\t      file->scninfo[symrunp->scndx].outscnndx = head->scnidx;\n\t\t    }\n\n\t\t  /* Get the symbol information.  This provides us the\n\t\t     offset into the string data section.  */\n\t\t  XElf_Sym_vardef (sym);\n\t\t  xelf_getsym (locsymdata, symrunp->symidx, sym);\n\t\t  assert (sym != NULL);\n\n\t\t  /* Get the data from the file.  Note that we access\n\t\t     the raw section data; no endian-ness issues with\n\t\t     single-byte strings.  */\n\t\t  symrunp->merge.handle\n\t\t    = ebl_strtabadd (mergestrtab,\n\t\t\t\t     (char *) locdata->d_buf + sym->st_value,\n\t\t\t\t     0);\n\t\t}\n\t      while ((symrunp = symrunp->next_in_scn)\n\t\t     != head->symbols->next_in_scn);\n\n\t      /* All strings have been added.  Create the final table.  */\n\t      ebl_strtabfinalize (mergestrtab, outdata);\n\n\t      /* Compute the final offsets in the section.  */\n\t      symrunp = runp->symbols;\n\t      do\n\t\t{\n\t\t  symrunp->merge.value\n\t\t    = ebl_strtaboffset (symrunp->merge.handle);\n\t\t  symrunp->merged = 1;\n\t\t}\n\t      while ((symrunp = symrunp->next_in_scn) != runp->symbols);\n\n\t      /* We don't need the string table anymore.  */\n\t      ebl_strtabfree (mergestrtab);\n\t    }\n\t  else if (likely (SCNINFO_SHDR (head->last->shdr).sh_entsize\n\t\t\t   == sizeof (wchar_t))\n\t\t   && likely (head->flags & SHF_STRINGS))\n\t    {\n\t      /* Simple, wchar_t string merging.  */\n\t      struct Ebl_WStrtab *mergestrtab;\n\t      struct symbol *symrunp;\n\t      Elf_Data *locsymdata = NULL;\n\t      Elf_Data *locdata = NULL;\n\n\t      mergestrtab = ebl_wstrtabinit (false);\n\n\t      symrunp = runp->symbols;\n\t      file = NULL;\n\t      do\n\t\t{\n\t\t  /* Accelarate the loop.  We cache the file\n\t\t     information since it might very well be the case\n\t\t     that the previous entry was from the same\n\t\t     file.  */\n\t\t  if (symrunp->file != file)\n\t\t    {\n\t\t      /* Remember the file.  */\n\t\t      file = symrunp->file;\n\t\t      /* Symbol table data from that file.  */\n\t\t      locsymdata = file->symtabdata;\n\t\t      /* String section data.  */\n\t\t      locdata = elf_rawdata (file->scninfo[symrunp->scndx].scn,\n\t\t\t\t\t     NULL);\n\t\t      assert (locdata != NULL);\n\n\t\t      /* While we are at it, remember the output\n\t\t\t section.  If we don't access the string data\n\t\t\t section the section won't be in the output\n\t\t\t file.  So it is sufficient to do the work\n\t\t\t here.  */\n\t\t      file->scninfo[symrunp->scndx].outscnndx = head->scnidx;\n\t\t    }\n\n\t\t  /* Get the symbol information.  This provides us the\n\t\t     offset into the string data section.  */\n\t\t  XElf_Sym_vardef (sym);\n\t\t  xelf_getsym (locsymdata, symrunp->symidx, sym);\n\t\t  assert (sym != NULL);\n\n\t\t  /* Get the data from the file.  Using the raw\n\t\t     section data here is possible since we don't\n\t\t     interpret the string themselves except for\n\t\t     looking for the wide NUL character.  The NUL\n\t\t     character has fortunately the same representation\n\t\t     regardless of the byte order.  */\n\t\t  symrunp->merge.handle\n\t\t    = ebl_wstrtabadd (mergestrtab,\n\t\t\t\t      (wchar_t *) ((char *) locdata->d_buf\n\t\t\t\t\t\t   + sym->st_value), 0);\n\t\t}\n\t      while ((symrunp = symrunp->next_in_scn) != runp->symbols);\n\n\t      /* All strings have been added.  Create the final table.  */\n\t      ebl_wstrtabfinalize (mergestrtab, outdata);\n\n\t      /* Compute the final offsets in the section.  */\n\t      symrunp = runp->symbols;\n\t      do\n\t\t{\n\t\t  symrunp->merge.value\n\t\t    = ebl_wstrtaboffset (symrunp->merge.handle);\n\t\t  symrunp->merged = 1;\n\t\t}\n\t      while ((symrunp = symrunp->next_in_scn) != runp->symbols);\n\n\t      /* We don't need the string table anymore.  */\n\t      ebl_wstrtabfree (mergestrtab);\n\t    }\n\t  else\n\t    {\n\t      /* Non-standard merging.  */\n\t      struct Ebl_GStrtab *mergestrtab;\n\t      struct symbol *symrunp;\n\t      Elf_Data *locsymdata = NULL;\n\t      Elf_Data *locdata = NULL;\n\t      /* If this is no string section the length of each \"string\"\n\t\t is always one.  */\n\t      unsigned int len = (head->flags & SHF_STRINGS) ? 0 : 1;\n\n\t      /* This is the generic string table functionality.  Much\n\t\t slower than the specialized code.  */\n\t      mergestrtab\n\t\t= ebl_gstrtabinit (SCNINFO_SHDR (head->last->shdr).sh_entsize,\n\t\t\t\t   false);\n\n\t      symrunp = runp->symbols;\n\t      file = NULL;\n\t      do\n\t\t{\n\t\t  /* Accelarate the loop.  We cache the file\n\t\t     information since it might very well be the case\n\t\t     that the previous entry was from the same\n\t\t     file.  */\n\t\t  if (symrunp->file != file)\n\t\t    {\n\t\t      /* Remember the file.  */\n\t\t      file = symrunp->file;\n\t\t      /* Symbol table data from that file.  */\n\t\t      locsymdata = file->symtabdata;\n\t\t      /* String section data.  */\n\t\t      locdata = elf_rawdata (file->scninfo[symrunp->scndx].scn,\n\t\t\t\t\t     NULL);\n\t\t      assert (locdata != NULL);\n\n\t\t      /* While we are at it, remember the output\n\t\t\t section.  If we don't access the string data\n\t\t\t section the section won't be in the output\n\t\t\t file.  So it is sufficient to do the work\n\t\t\t here.  */\n\t\t      file->scninfo[symrunp->scndx].outscnndx = head->scnidx;\n\t\t    }\n\n\t\t  /* Get the symbol information.  This provides us the\n\t\t     offset into the string data section.  */\n\t\t  XElf_Sym_vardef (sym);\n\t\t  xelf_getsym (locsymdata, symrunp->symidx, sym);\n\t\t  assert (sym != NULL);\n\n\t\t  /* Get the data from the file.  Using the raw\n\t\t     section data here is possible since we don't\n\t\t     interpret the string themselves except for\n\t\t     looking for the wide NUL character.  The NUL\n\t\t     character has fortunately the same representation\n\t\t     regardless of the byte order.  */\n\t\t  symrunp->merge.handle\n\t\t    = ebl_gstrtabadd (mergestrtab,\n\t\t\t\t      (char *) locdata->d_buf + sym->st_value,\n\t\t\t\t      len);\n\t\t}\n\t      while ((symrunp = symrunp->next_in_scn) != runp->symbols);\n\n\t      /* Create the final table.  */\n\t      ebl_gstrtabfinalize (mergestrtab, outdata);\n\n\t      /* Compute the final offsets in the section.  */\n\t      symrunp = runp->symbols;\n\t      do\n\t\t{\n\t\t  symrunp->merge.value\n\t\t    = ebl_gstrtaboffset (symrunp->merge.handle);\n\t\t  symrunp->merged = 1;\n\t\t}\n\t      while ((symrunp = symrunp->next_in_scn) != runp->symbols);\n\n\t      /* We don't need the string table anymore.  */\n\t      ebl_gstrtabfree (mergestrtab);\n\t    }\n\t}\n      else\n\t{\n\tno_merge:\n\t  assert (head->scnidx == elf_ndxscn (scn));\n\n\t  /* It is important to start with the first list entry (and\n\t     not just any one) to add the sections in the correct\n\t     order.  */\n\t  runp = head->last->next;\n\t  offset = 0;\n\t  do\n\t    {\n\t      Elf_Data *outdata = elf_newdata (scn);\n\t      if (outdata == NULL)\n\t\terror (EXIT_FAILURE, 0,\n\t\t       gettext (\"cannot create section for output file: %s\"),\n\t\t       elf_errmsg (-1));\n\n\t      /* Exceptional case: if we synthesize a data block SCN\n\t\t is NULL and the sectio header info must be for a\n\t\t SHT_NOBITS block and the size and alignment are\n\t\t filled in.  */\n\t      if (likely (runp->scn != NULL))\n\t\t{\n\t\t  data = elf_getdata (runp->scn, NULL);\n\t\t  assert (data != NULL);\n\n\t\t  /* We reuse the data buffer in the input file.  */\n\t\t  *outdata = *data;\n\n\t\t  /* Given that we read the input file from disk we know there\n\t\t     cannot be another data part.  */\n\t\t  assert (elf_getdata (runp->scn, data) == NULL);\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Must be a NOBITS section.  */\n\t\t  assert  (SCNINFO_SHDR (runp->shdr).sh_type == SHT_NOBITS);\n\n\t\t  outdata->d_buf = NULL;\t/* Not needed.  */\n\t\t  outdata->d_type = ELF_T_BYTE;\n\t\t  outdata->d_version = EV_CURRENT;\n\t\t  outdata->d_size = SCNINFO_SHDR (runp->shdr).sh_size;\n\t\t  outdata->d_align = SCNINFO_SHDR (runp->shdr).sh_addralign;\n\t\t}\n\n\t      XElf_Off align =  MAX (1, outdata->d_align);\n\t      assert (powerof2 (align));\n\t      offset = ((offset + align - 1) & ~(align - 1));\n\n\t      runp->offset = offset;\n\t      runp->outscnndx = head->scnidx;\n\t      runp->allsectionsidx = cnt;\n\n\t      outdata->d_off = offset;\n\n\t      offset += outdata->d_size;\n\t    }\n\t  while ((runp = runp->next) != head->last->next);\n\n\t  /* If necessary add the additional line to the .comment section.  */\n\t  if (ld_state.add_ld_comment\n\t      && head->flags == 0\n\t      && head->type == SHT_PROGBITS\n\t      && strcmp (head->name, \".comment\") == 0\n\t      && head->entsize == 0)\n\t    {\n\t      Elf_Data *outdata = elf_newdata (scn);\n\n\t      if (outdata == NULL)\n\t\terror (EXIT_FAILURE, 0,\n\t\t       gettext (\"cannot create section for output file: %s\"),\n\t\t       elf_errmsg (-1));\n\n\t      outdata->d_buf = (void *) \"\\0ld (\" PACKAGE_NAME \") \" PACKAGE_VERSION;\n\t      outdata->d_size = strlen ((char *) outdata->d_buf + 1) + 2;\n\t      outdata->d_off = offset;\n\t      outdata->d_type = ELF_T_BYTE;\n\t      outdata->d_align = 1;\n\t    }\n\t  /* XXX We should create a .comment section if none exists.\n\t     This requires that we early on detect that no such\n\t     section exists.  This should probably be implemented\n\t     together with some merging of the section contents.\n\t     Currently identical entries are not merged.  */\n\t}\n    }\n\n  /* The table we collect the strings in.  */\n  strtab = ebl_strtabinit (true);\n  if (strtab == NULL)\n    error (EXIT_FAILURE, errno, gettext (\"cannot create string table\"));\n\n\n#ifndef NDEBUG\n  /* Keep track of the use of the XINDEX.  */\n  need_xndx = false;\n#endif\n\n  /* We we generate a normal symbol table for an executable and the\n     --export-dynamic option is not given, we need an extra table\n     which keeps track of the symbol entry belonging to the symbol\n     table entry.  Note that EXPORT_ALL_DYNAMIC is always set if we\n     generate a DSO so we do not have to test this separately.  */\n  ndxtosym = (struct symbol **) xcalloc (nsym_allocated,\n\t\t\t\t\t sizeof (struct symbol));\n\n  /* Create the special symbol for the GOT section.  */\n  if (ld_state.got_symbol != NULL)\n    {\n      assert (nsym < nsym_allocated);\n      // XXX Fix so that it works even if no PLT is needed.\n      fillin_special_symbol (ld_state.got_symbol, ld_state.gotpltscnidx,\n\t\t\t     nsym++, symdata, strtab);\n    }\n\n  /* Similarly for the dynamic section symbol.  */\n  if (ld_state.dyn_symbol != NULL)\n    {\n      assert (nsym < nsym_allocated);\n      fillin_special_symbol (ld_state.dyn_symbol, ld_state.dynamicscnidx,\n\t\t\t     nsym++, symdata, strtab);\n    }\n\n  /* Create symbol table entries for the symbols defined in the linker\n     script.  */\n  if (ld_state.lscript_syms != NULL)\n    {\n      struct symbol *rsym = ld_state.lscript_syms;\n      do\n\t{\n\t  assert (nsym < nsym_allocated);\n\t  fillin_special_symbol (rsym, SHN_ABS, nsym++, symdata, strtab);\n\t}\n      while ((rsym = rsym->next) != NULL);\n    }\n\n  /* Iterate over all input files to collect the symbols.  */\n  file = ld_state.relfiles->next;\n  symdata = elf_getdata (elf_getscn (ld_state.outelf, ld_state.symscnidx),\n\t\t\t NULL);\n\n  do\n    {\n      size_t maxcnt;\n      Elf_Data *insymdata;\n      Elf_Data *inxndxdata;\n\n      /* There must be no dynamic symbol table when creating\n\t relocatable files.  */\n      assert (ld_state.file_type != relocatable_file_type\n\t      || file->dynsymtabdata == NULL);\n\n      insymdata = file->symtabdata;\n      assert (insymdata != NULL);\n      inxndxdata = file->xndxdata;\n\n      maxcnt = file->nsymtab;\n\n      file->symindirect = (Elf32_Word *) xcalloc (maxcnt, sizeof (Elf32_Word));\n\n      /* The dynamic symbol table does not contain local symbols.  So\n         we skip those entries.  */\n      for (cnt = ld_state.need_symtab ? 1 : file->nlocalsymbols; cnt < maxcnt;\n\t   ++cnt)\n\t{\n\t  XElf_Sym_vardef (sym);\n\t  Elf32_Word xndx;\n\t  struct symbol *defp = NULL;\n\n\t  xelf_getsymshndx (insymdata, inxndxdata, cnt, sym, xndx);\n\t  assert (sym != NULL);\n\n\t  if (unlikely (XELF_ST_TYPE (sym->st_info) == STT_SECTION))\n\t    {\n\t      /* Section symbols should always be local but who knows...  */\n\t      if (ld_state.need_symtab)\n\t\t{\n\t\t  /* Determine the real section index in the source file.\n\t\t     Use the XINDEX section content if necessary.  We don't\n\t\t     add this information to the dynamic symbol table.  */\n\t\t  if (sym->st_shndx != SHN_XINDEX)\n\t\t    xndx = sym->st_shndx;\n\n\t\t  assert (file->scninfo[xndx].allsectionsidx\n\t\t\t  < ld_state.nallsections);\n\t\t  file->symindirect[cnt] = ld_state.allsections[file->scninfo[xndx].allsectionsidx]->scnsymidx;\n\t\t  /* Note that the resulting index can be zero here.  There is\n\t\t     no guarantee that the output file will contain all the\n\t\t     sections the input file did.  */\n\t\t}\n\t      continue;\n\t    }\n\n\t  if ((ld_state.strip >= strip_all || !ld_state.need_symtab)\n\t      /* XXX Do we need these entries?  */\n\t      && XELF_ST_TYPE (sym->st_info) == STT_FILE)\n\t    continue;\n\n#if NATIVE_ELF != 0\n\t  /* Copy old data.  We create a temporary copy because the\n\t     symbol might still be discarded.  */\n\t  XElf_Sym sym_mem;\n\t  sym_mem = *sym;\n\t  sym = &sym_mem;\n#endif\n\n\t  if (sym->st_shndx != SHN_UNDEF\n\t      && (sym->st_shndx < SHN_LORESERVE\n\t\t  || sym->st_shndx == SHN_XINDEX))\n\t    {\n\t      /* If we are creating an executable with no normal\n\t\t symbol table and we do not export all symbols and\n\t\t this symbol is not defined in a DSO as well, ignore\n\t\t it.  */\n\t      if (!ld_state.export_all_dynamic && !ld_state.need_symtab)\n\t\t{\n\t\t  assert (cnt >= file->nlocalsymbols);\n\t\t  defp = file->symref[cnt];\n\t\t  assert (defp != NULL);\n\n\t\t  if (!defp->in_dso)\n\t\t    /* Ignore it.  */\n\t\t    continue;\n\t\t}\n\n\t      /* Determine the real section index in the source file.  Use\n\t\t the XINDEX section content if necessary.  */\n\t      if (sym->st_shndx != SHN_XINDEX)\n\t\txndx = sym->st_shndx;\n\n\t      sym->st_value += file->scninfo[xndx].offset;\n\n\t      assert (file->scninfo[xndx].outscnndx < SHN_LORESERVE\n\t\t      || file->scninfo[xndx].outscnndx > SHN_HIRESERVE);\n\t      if (unlikely (file->scninfo[xndx].outscnndx > SHN_LORESERVE))\n\t\t{\n\t\t  /* It is not possible to have an extended section index\n\t\t     table for the dynamic symbol table.  */\n\t\t  if (!ld_state.need_symtab)\n\t\t    error (EXIT_FAILURE, 0, gettext (\"\\\nsection index too large in dynamic symbol table\"));\n\n\t\t  assert (xndxdata != NULL);\n\t\t  sym->st_shndx = SHN_XINDEX;\n\t\t  xndx = file->scninfo[xndx].outscnndx;\n#ifndef NDEBUG\n\t\t  need_xndx = true;\n#endif\n\t\t}\n\t      else\n\t\t{\n\t\t  sym->st_shndx = file->scninfo[xndx].outscnndx;\n\t\t  xndx = 0;\n\t\t}\n\t    }\n\t  else if (sym->st_shndx == SHN_COMMON || sym->st_shndx == SHN_UNDEF)\n\t    {\n\t      /* Check whether we have a (real) definition for this\n\t\t symbol.  If this is the case we skip this symbol\n\t\t table entry.  */\n\t      assert (cnt >= file->nlocalsymbols);\n\t      defp = file->symref[cnt];\n\t      assert (defp != NULL);\n\n\t      assert (sym->st_shndx != SHN_COMMON || defp->defined);\n\n\t      if ((sym->st_shndx == SHN_COMMON && !defp->common)\n\t\t  || (sym->st_shndx == SHN_UNDEF && defp->defined)\n\t\t  || defp->added)\n\t\t/* Ignore this symbol table entry, there is a\n\t\t   \"better\" one or we already added it.  */\n\t\tcontinue;\n\n\t      /* Remember that we already added this symbol.  */\n\t      defp->added = 1;\n\n\t      /* Adjust the section number for common symbols.  */\n\t      if (sym->st_shndx == SHN_COMMON)\n\t\t{\n\t\t  sym->st_value = (ld_state.common_section->offset\n\t\t\t\t   + file->symref[cnt]->merge.value);\n\t\t  assert (ld_state.common_section->outscnndx < SHN_LORESERVE);\n\t\t  sym->st_shndx = ld_state.common_section->outscnndx;\n\t\t  xndx = 0;\n\t\t}\n\t    }\n\t  else if (unlikely (sym->st_shndx != SHN_ABS))\n\t    {\n\t      if (SPECIAL_SECTION_NUMBER_P (&ld_state, sym->st_shndx))\n\t\t/* XXX Add code to handle machine specific special\n\t\t   sections.  */\n\t\tabort ();\n\t    }\n\n\t  /* Add the symbol name to the string table.  If the user\n\t     chooses the highest level of stripping avoid adding names\n\t     for local symbols in the string table.  */\n\t  if (sym->st_name != 0\n\t      && (ld_state.strip < strip_everything\n\t\t  || XELF_ST_BIND (sym->st_info) != STB_LOCAL))\n\t    symstrent[nsym] = ebl_strtabadd (strtab,\n\t\t\t\t\t     elf_strptr (file->elf,\n\t\t\t\t\t\t\t file->symstridx,\n\t\t\t\t\t\t\t sym->st_name), 0);\n\n\t  /* Once we know the name this field will get the correct\n\t     offset.  For now set it to zero which means no name\n\t     associated.  */\n\t  GElf_Word st_name = sym->st_name;\n\t  sym->st_name = 0;\n\n\t  /* If we had to merge sections we have a completely new\n\t     offset for the symbol.  */\n\t  if (file->has_merge_sections && file->symref[cnt] != NULL\n\t      && file->symref[cnt]->merged)\n\t    sym->st_value = file->symref[cnt]->merge.value;\n\n\t  /* Create the record in the output sections.  */\n\t  assert (nsym < nsym_allocated);\n\t  xelf_update_symshndx (symdata, xndxdata, nsym, sym, xndx, 1);\n\n\t  /* Add the reference to the symbol record in case we need it.\n\t     Find the symbol if this has not happened yet.  We do\n\t     not need the information for local symbols.  */\n\t  if (defp == NULL && cnt >= file->nlocalsymbols)\n\t    {\n\t      defp = file->symref[cnt];\n\n\t      if (defp == NULL)\n\t\t{\n\t\t  /* This is a symbol in a discarded COMDAT section.\n\t\t     Find the definition we actually use.  */\n\t\t  // XXX The question is: do we have to do this here\n\t\t  // XXX or can we do it earlier when we discard the\n\t\t  // XXX section.\n\t\t  struct symbol search;\n\t\t  search.name = elf_strptr (file->elf, file->symstridx,\n\t\t\t\t\t    st_name);\n\t\t  struct symbol *realp\n\t\t    = ld_symbol_tab_find (&ld_state.symbol_tab,\n\t\t\t\t\t  elf_hash (search.name), &search);\n\t\t  if (realp == NULL)\n\t\t    // XXX What to do here?\n\t\t    error (EXIT_FAILURE, 0,\n\t\t\t   \"couldn't find symbol from COMDAT section\");\n\n\t\t  file->symref[cnt] = realp;\n\n\t\t  continue;\n\t\t}\n\t    }\n\n\t  /* Store the reference to the symbol record.  The sorting\n\t     code will have to keep this array in the correct order, too.  */\n\t  ndxtosym[nsym] = defp;\n\n\t  /* One more entry finished.  */\n\t  if (cnt >= file->nlocalsymbols)\n\t    {\n\t      assert (file->symref[cnt]->outsymidx == 0);\n\t      file->symref[cnt]->outsymidx = nsym;\n\t    }\n\t  file->symindirect[cnt] = nsym++;\n\t}\n    }\n  while ((file = file->next) != ld_state.relfiles->next);\n  /* Make sure we didn't create the extended section index table for\n     nothing.  */\n  assert (xndxdata == NULL || need_xndx);\n\n  /* Create the version related sections.  */\n  if (ld_state.verneedscnidx != 0)\n    {\n      /* We know the number of input files and total number of\n\t referenced versions.  This allows us to allocate the memory\n\t and then we iterate over the DSOs to get the version\n\t information.  */\n      struct usedfiles *runp;\n\n      runp = ld_state.dsofiles->next;\n      do\n\tallocate_version_names (runp, dynstrtab);\n      while ((runp = runp->next) != ld_state.dsofiles->next);\n\n      if (ld_state.needed != NULL)\n\t{\n\t  runp = ld_state.needed->next;\n\t  do\n\t    allocate_version_names (runp, dynstrtab);\n\t  while ((runp = runp->next) != ld_state.needed->next);\n\t}\n    }\n\n  /* At this point we should hide symbols and so on.  */\n  if (ld_state.default_bind_local || ld_state.version_str_tab.filled > 0)\n    /* XXX Add one more test when handling of wildcard symbol names\n       is supported.  */\n    {\n    /* Check all non-local symbols whether they are on the export list.  */\n      bool any_reduced = false;\n\n      for (cnt = 1; cnt < nsym; ++cnt)\n\t{\n\t  XElf_Sym_vardef (sym);\n\n\t  /* Note that we don't have to use 'xelf_getsymshndx' since we\n\t     only need the binding and the symbol name.  */\n\t  xelf_getsym (symdata, cnt, sym);\n\t  assert (sym != NULL);\n\n\t  if (reduce_symbol_p (sym, symstrent[cnt]))\n\t    {\n\t      // XXX Check whether this is correct...\n\t      assert (ndxtosym[cnt]->outdynsymidx != 0);\n\t      ndxtosym[cnt]->outdynsymidx = 0;\n\n\t      sym->st_info = XELF_ST_INFO (STB_LOCAL,\n\t\t\t\t\t   XELF_ST_TYPE (sym->st_info));\n\t      (void) xelf_update_sym (symdata, cnt, sym);\n\n\t      /* Show that we don't need this string anymore.  */\n\t      if (ld_state.strip == strip_everything)\n\t\t{\n\t\t  symstrent[cnt] = NULL;\n\t\t  any_reduced = true;\n\t\t}\n\t    }\n\t}\n\n      if (unlikely (any_reduced))\n\t{\n\t  /* Since we will not write names of local symbols in the\n\t     output file and we have reduced the binding of some\n\t     symbols the string table previously constructed contains\n\t     too many string.  Correct it.  */\n\t  struct Ebl_Strtab *newp = ebl_strtabinit (true);\n\n\t  for (cnt = 1; cnt < nsym; ++cnt)\n\t    if (symstrent[cnt] != NULL)\n\t      symstrent[cnt] = ebl_strtabadd (newp,\n\t\t\t\t\t      ebl_string (symstrent[cnt]), 0);\n\n\t  ebl_strtabfree (strtab);\n\t  strtab = newp;\n\t}\n    }\n\n  /* Add the references to DSOs.  We can add these entries this late\n     (after sorting out versioning) because references to DSOs are not\n     effected.  */\n  if (ld_state.from_dso != NULL)\n    {\n      struct symbol *runp;\n      size_t plt_base = nsym + ld_state.nfrom_dso - ld_state.nplt;\n      size_t plt_idx = 0;\n      size_t obj_idx = 0;\n\n      assert (ld_state.nfrom_dso >= ld_state.nplt);\n      runp = ld_state.from_dso;\n      do\n\t{\n\t  // XXX What about functions which are only referenced via\n\t  // pointers and not PLT entries?  Can we distinguish such uses?\n\t  size_t idx;\n\t  if (runp->type == STT_FUNC)\n\t    {\n\t      /* Store the PLT entry number.  */\n\t      runp->merge.value = plt_idx + 1;\n\t      idx = plt_base + plt_idx++;\n\t    }\n\t  else\n\t    idx = nsym + obj_idx++;\n\n\t  XElf_Sym_vardef (sym);\n\t  xelf_getsym_ptr (symdata, idx, sym);\n\n\t  sym->st_value = 0;\n\t  sym->st_size = runp->size;\n\t  sym->st_info = XELF_ST_INFO (runp->weak ? STB_WEAK : STB_GLOBAL,\n\t\t\t\t       runp->type);\n\t  sym->st_other = STV_DEFAULT;\n\t  sym->st_shndx = SHN_UNDEF;\n\n\t  /* Create the record in the output sections.  */\n\t  xelf_update_symshndx (symdata, xndxdata, idx, sym, 0, 0);\n\n\t  const char *name = runp->name;\n\t  size_t namelen = 0;\n\n\t  if (runp->file->verdefdata != NULL)\n\t    {\n\t      // XXX Is it useful to add the versym value to struct symbol?\n\t      XElf_Versym versym;\n\n\t      (void) xelf_getversym_copy (runp->file->versymdata, runp->symidx,\n\t\t\t\t\t  versym);\n\n\t      /* One can only link with the default version.  */\n\t      assert ((versym & 0x8000) == 0);\n\n\t      const char *versname\n\t\t= ebl_string (runp->file->verdefent[versym]);\n\n\t      size_t versname_len = strlen (versname) + 1;\n\t      namelen = strlen (name) + versname_len + 2;\n\t      char *newp = (char *) obstack_alloc (&ld_state.smem, namelen);\n\t      memcpy (stpcpy (stpcpy (newp, name), \"@@\"),\n\t\t      versname, versname_len);\n\t      name = newp;\n\t    }\n\n\t  symstrent[idx] = ebl_strtabadd (strtab, name, namelen);\n\n\t  /* Record the initial index in the symbol table.  */\n\t  runp->outsymidx = idx;\n\n\t  /* Remember the symbol record this ELF symbol came from.  */\n\t  ndxtosym[idx] = runp;\n\t}\n      while ((runp = runp->next) != ld_state.from_dso);\n\n      assert (nsym + obj_idx == plt_base);\n      assert (plt_idx == ld_state.nplt);\n      nsym = plt_base + plt_idx;\n    }\n\n  /* Now we know how many symbols will be in the output file.  Adjust\n     the count in the section data.  */\n  symdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_SYM, nsym);\n  if (unlikely (xndxdata != NULL))\n    xndxdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_WORD, nsym);\n\n  /* Create the symbol string table section.  */\n  strscn = elf_newscn (ld_state.outelf);\n  ld_state.strscnidx = elf_ndxscn (strscn);\n  data = elf_newdata (strscn);\n  xelf_getshdr (strscn, shdr);\n  if (data == NULL || shdr == NULL)\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot create section for output file: %s\"),\n\t   elf_errmsg (-1));\n\n  /* Create a compact string table, allocate the memory for it, and\n     fill in the section data information.  */\n  ebl_strtabfinalize (strtab, data);\n\n  shdr->sh_type = SHT_STRTAB;\n  assert (shdr->sh_entsize == 0);\n\n  if (unlikely (xelf_update_shdr (strscn, shdr) == 0))\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot create section for output file: %s\"),\n\t   elf_errmsg (-1));\n\n  /* Fill in the offsets of the symbol names.  */\n  for (cnt = 1; cnt < nsym; ++cnt)\n    if (symstrent[cnt] != NULL)\n      {\n\tXElf_Sym_vardef (sym);\n\n\t/* Note that we don't have to use 'xelf_getsymshndx' since we don't\n\t   modify the section index.  */\n\txelf_getsym (symdata, cnt, sym);\n\t/* This better worked, we did it before.  */\n\tassert (sym != NULL);\n\tsym->st_name = ebl_strtaboffset (symstrent[cnt]);\n\t(void) xelf_update_sym (symdata, cnt, sym);\n      }\n\n  /* Since we are going to reorder the symbol table but still have to\n     be able to find the new position based on the old one (since the\n     latter is stored in 'symindirect' information of the input file\n     data structure) we have to create yet another indirection\n     table.  */\n  ld_state.dblindirect = dblindirect\n    = (Elf32_Word *) xmalloc (nsym * sizeof (Elf32_Word));\n\n  /* Sort the symbol table so that the local symbols come first.  */\n  /* XXX We don't use stable sorting here.  It seems not necessary and\n     would be more expensive.  If it turns out to be necessary this can\n     be fixed easily.  */\n  nsym_local = 1;\n  cnt = nsym - 1;\n  while (nsym_local < cnt)\n    {\n      XElf_Sym_vardef (locsym);\n      Elf32_Word locxndx;\n      XElf_Sym_vardef (globsym);\n      Elf32_Word globxndx;\n\n      do\n\t{\n\t  xelf_getsymshndx (symdata, xndxdata, nsym_local, locsym, locxndx);\n\t  /* This better works.  */\n\t  assert (locsym != NULL);\n\n\t  if (XELF_ST_BIND (locsym->st_info) != STB_LOCAL\n\t      && (ld_state.need_symtab || ld_state.export_all_dynamic))\n\t    {\n\t      do\n\t\t{\n\t\t  xelf_getsymshndx (symdata, xndxdata, cnt, globsym, globxndx);\n\t\t  /* This better works.  */\n\t\t  assert (globsym != NULL);\n\n\t\t  if (unlikely (XELF_ST_BIND (globsym->st_info) == STB_LOCAL))\n\t\t    {\n\t\t      /* We swap the two entries.  */\n#if NATIVE_ELF != 0\n\t\t      /* Since we directly modify the data in the ELF\n\t\t\t data structure we have to make a copy of one\n\t\t\t of the entries.  */\n\t\t      XElf_Sym locsym_copy = *locsym;\n\t\t      locsym = &locsym_copy;\n#endif\n\t\t      xelf_update_symshndx (symdata, xndxdata, nsym_local,\n\t\t\t\t\t    globsym, globxndx, 1);\n\t\t      xelf_update_symshndx (symdata, xndxdata, cnt,\n\t\t\t\t\t    locsym, locxndx, 1);\n\n\t\t      /* Also swap the cross references.  */\n\t\t      dblindirect[nsym_local] = cnt;\n\t\t      dblindirect[cnt] = nsym_local;\n\n\t\t      /* And the entries for the symbol names.  */\n\t\t      struct Ebl_Strent *strtmp = symstrent[nsym_local];\n\t\t      symstrent[nsym_local] = symstrent[cnt];\n\t\t      symstrent[cnt] = strtmp;\n\n\t\t      /* And the mapping from symbol table entry to\n\t\t\t struct symbol record.  */\n\t\t      struct symbol *symtmp = ndxtosym[nsym_local];\n\t\t      ndxtosym[nsym_local] = ndxtosym[cnt];\n\t\t      ndxtosym[cnt] = symtmp;\n\n\t\t      /* Go to the next entry.  */\n\t\t      ++nsym_local;\n\t\t      --cnt;\n\n\t\t      break;\n\t\t    }\n\n\t\t  dblindirect[cnt] = cnt;\n\t\t}\n\t      while (nsym_local < --cnt);\n\n\t      break;\n\t    }\n\n\t  dblindirect[nsym_local] = nsym_local;\n\t}\n      while (++nsym_local < cnt);\n    }\n\n  /* The symbol 'nsym_local' is currently pointing to might be local,\n     too.  Check and increment the variable if this is the case.  */\n  if (likely (nsym_local < nsym))\n    {\n      XElf_Sym_vardef (locsym);\n\n      /* This entry isn't moved.  */\n      dblindirect[nsym_local] = nsym_local;\n\n      /* Note that it is OK to not use 'xelf_getsymshndx' here.  */\n      xelf_getsym (symdata, nsym_local, locsym);\n      /* This better works.  */\n      assert (locsym != NULL);\n\n      if (XELF_ST_BIND (locsym->st_info) == STB_LOCAL)\n\t++nsym_local;\n    }\n\n\n  /* We need the versym array right away to keep track of the version\n     symbols.  */\n  if (ld_state.versymscnidx != 0)\n    {\n      /* We allocate more memory than we need since the array is morroring\n\t the dynamic symbol table and not the normal symbol table.  I.e.,\n\t no local symbols are present.  */\n      versymscn = elf_getscn (ld_state.outelf, ld_state.versymscnidx);\n      versymdata = elf_newdata (versymscn);\n      if (versymdata == NULL)\n\terror (EXIT_FAILURE, 0,\n\t       gettext (\"cannot create versioning section: %s\"),\n\t       elf_errmsg (-1));\n\n      versymdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_HALF,\n\t\t\t\t       nsym - nsym_local + 1);\n      versymdata->d_buf = xcalloc (1, versymdata->d_size);\n      versymdata->d_align = xelf_fsize (ld_state.outelf, ELF_T_HALF, 1);\n      versymdata->d_off = 0;\n      versymdata->d_type = ELF_T_HALF;\n    }\n\n\n  /* If we have to construct the dynamic symbol table we must not include\n     the local symbols.  If the normal symbol has to be emitted as well\n     we haven't done anything else yet and we can construct it from\n     scratch now.  */\n  if (unlikely (!ld_state.need_symtab))\n    {\n      /* Note that the following code works even if there is no entry\n\t to remove since the zeroth entry is always local.  */\n      size_t reduce = xelf_fsize (ld_state.outelf, ELF_T_SYM, nsym_local - 1);\n\n      XElf_Sym_vardef (nullsym);\n      xelf_getsym_ptr (symdata, nsym_local - 1, nullsym);\n\n      /* Note that we don't have to use 'xelf_update_symshndx' since\n\t this is the dynamic symbol table we write.  */\n      (void) xelf_update_sym (symdata, nsym_local - 1,\n\t\t\t      memset (nullsym, '\\0', sizeof (*nullsym)));\n\n      /* Update the buffer pointer and size in the output data.  */\n      symdata->d_buf = (char *) symdata->d_buf + reduce;\n      symdata->d_size -= reduce;\n\n      /* Add the version symbol information.  */\n      if (versymdata != NULL)\n\t{\n\t  nsym_dyn = 1;\n\t  for (cnt = nsym_local; cnt < nsym; ++cnt, ++nsym_dyn)\n\t    {\n\t      struct symbol *symp = ndxtosym[cnt];\n\n\t      if (symp->file->versymdata != NULL)\n\t\t{\n\t\t  GElf_Versym versym;\n\n\t\t  gelf_getversym (symp->file->versymdata, symp->symidx,\n\t\t\t\t  &versym);\n\n\t\t  (void) gelf_update_versym (versymdata, symp->outdynsymidx,\n\t\t\t\t\t     &symp->file->verdefused[versym]);\n\t\t}\n\t      }\n\t}\n\n      /* Since we only created the dynamic symbol table the number of\n\t dynamic symbols is the total number of symbols.  */\n      nsym_dyn = nsym - nsym_local + 1;\n\n      /* XXX TBI.  Create whatever data structure is missing.  */\n      abort ();\n    }\n  else if (ld_state.need_dynsym)\n    {\n      /* Create the dynamic symbol table section data along with the\n\t string table.  We look at all non-local symbols we found for\n\t the normal symbol table and add those.  */\n      dynsymscn = elf_getscn (ld_state.outelf, ld_state.dynsymscnidx);\n      dynsymdata = elf_newdata (dynsymscn);\n\n      dynstrdata = elf_newdata (elf_getscn (ld_state.outelf,\n\t\t\t\t\t    ld_state.dynstrscnidx));\n      if (dynsymdata == NULL || dynstrdata == NULL)\n\terror (EXIT_FAILURE, 0, gettext (\"\\\ncannot create dynamic symbol table for output file: %s\"),\n\t       elf_errmsg (-1));\n\n      nsym_dyn_allocated = nsym - nsym_local + 1;\n      dynsymdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_SYM,\n\t\t\t\t       nsym_dyn_allocated);\n      dynsymdata->d_buf = memset (xmalloc (dynsymdata->d_size), '\\0',\n\t\t\t\t  xelf_fsize (ld_state.outelf, ELF_T_SYM, 1));\n      dynsymdata->d_type = ELF_T_SYM;\n      dynsymdata->d_off = 0;\n      dynsymdata->d_align = xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1);\n\n      /* We need one more array which contains the hash codes of the\n\t symbol names.  */\n      hashcodes = (Elf32_Word *) xcalloc (__builtin_popcount ((int) ld_state.hash_style)\n\t\t\t\t\t  * nsym_dyn_allocated,\n\t\t\t\t\t  sizeof (Elf32_Word));\n      gnuhashcodes = hashcodes;\n      if (GENERATE_SYSV_HASH)\n\tgnuhashcodes += nsym_dyn_allocated;\n\n      /* We have and empty entry at the beginning.  */\n      nsym_dyn = 1;\n\n      /* Populate the table.  */\n      for (cnt = nsym_local; cnt < nsym; ++cnt)\n\t{\n\t  XElf_Sym_vardef (sym);\n\n\t  xelf_getsym (symdata, cnt, sym);\n\t  assert (sym != NULL);\n\n\t  if (sym->st_shndx == SHN_XINDEX)\n\t    error (EXIT_FAILURE, 0, gettext (\"\\\nsection index too large in dynamic symbol table\"));\n\n\t  /* We do not add the symbol to the dynamic symbol table if\n\n\t     - the symbol is for a file\n\t     - it is not externally visible (internal, hidden)\n\t     - export_all_dynamic is not set and the symbol is only defined\n\t       in the executable (i.e., it is defined, but not (also) in DSO)\n\n\t     Set symstrent[cnt] to NULL in case an entry is ignored.  */\n\t  if (XELF_ST_TYPE (sym->st_info) == STT_FILE\n\t      || XELF_ST_VISIBILITY (sym->st_other) == STV_INTERNAL\n\t      || XELF_ST_VISIBILITY (sym->st_other) == STV_HIDDEN\n\t      || (!ld_state.export_all_dynamic\n\t\t  && !ndxtosym[cnt]->in_dso && ndxtosym[cnt]->defined))\n\t    {\n\t      symstrent[cnt] = NULL;\n\t      continue;\n\t    }\n\n\t  /* Store the index of the symbol in the dynamic symbol\n\t     table.  This is a preliminary value in case we use the\n\t     GNU-style hash table.  */\n\t  ndxtosym[cnt]->outdynsymidx = nsym_dyn;\n\n\t  /* Create a new string table entry.  */\n\t  const char *str = ndxtosym[cnt]->name;\n\t  symstrent[cnt] = ebl_strtabadd (dynstrtab, str, 0);\n\t  if (GENERATE_SYSV_HASH)\n\t    hashcodes[nsym_dyn] = elf_hash (str);\n\t  if (GENERATE_GNU_HASH)\n\t    gnuhashcodes[nsym_dyn] = elf_gnu_hash (str);\n\t  ++nsym_dyn;\n\t}\n\n      if (ld_state.file_type != relocatable_file_type)\n\t{\n\t  /* Finalize the dynamic string table.  */\n\t  ebl_strtabfinalize (dynstrtab, dynstrdata);\n\n\t  assert (ld_state.hashscnidx != 0 || ld_state.gnuhashscnidx != 0);\n\n\t  /* Create the GNU-style hash table.  */\n\t  if (GENERATE_GNU_HASH)\n\t    create_gnu_hash (nsym_local, nsym, nsym_dyn, gnuhashcodes);\n\n\t  /* Create the SysV-style hash table.  This has to happen\n\t     after the GNU-style table is created since\n\t     CREATE-GNU-HASH might reorder the dynamic symbol table.  */\n\t  if (GENERATE_SYSV_HASH)\n\t    create_hash (nsym_local, nsym, nsym_dyn, hashcodes);\n\t}\n\n\t  /* Add the version information.  */\n      if (versymdata != NULL)\n\tfor (cnt = nsym_local; cnt < nsym; ++cnt)\n\t  if (symstrent[cnt] != NULL)\n\t    {\n\t      struct symbol *symp = ndxtosym[cnt];\n\n\t      /* Synthetic symbols (i.e., those with no file attached)\n\t\t have no version information.  */\n\t      if (symp->file != NULL && symp->file->verdefdata != NULL)\n\t\t{\n\t\t  GElf_Versym versym;\n\n\t\t  gelf_getversym (symp->file->versymdata, symp->symidx,\n\t\t\t\t  &versym);\n\n\t\t  (void) gelf_update_versym (versymdata, symp->outdynsymidx,\n\t\t\t\t\t     &symp->file->verdefused[versym]);\n\t\t}\n\t      else\n\t\t{\n\t\t  /* XXX Add support for version definitions.  */\n\t\t  GElf_Versym global = VER_NDX_GLOBAL;\n\t\t  (void) gelf_update_versym (versymdata, nsym_dyn, &global);\n\t\t}\n\t    }\n\n      /* Update the information about the symbol section.  */\n      if (versymdata != NULL)\n\t{\n\t  /* Correct the size now that we know how many entries the\n\t     dynamic symbol table has.  */\n\t  versymdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_HALF,\n\t\t\t\t\t   nsym_dyn);\n\n\t  /* Add the reference to the symbol table.  */\n\t  xelf_getshdr (versymscn, shdr);\n\t  assert (shdr != NULL);\n\n\t  shdr->sh_link = ld_state.dynsymscnidx;\n\n\t  (void) xelf_update_shdr (versymscn, shdr);\n\t}\n    }\n\n  if (ld_state.file_type != relocatable_file_type)\n    {\n      /* Now put the names in.  */\n      for (cnt = nsym_local; cnt < nsym; ++cnt)\n\tif (symstrent[cnt] != NULL)\n\t  {\n\t    XElf_Sym_vardef (sym);\n\t    size_t dynidx = ndxtosym[cnt]->outdynsymidx;\n\n#if NATIVE_ELF != 0\n\t    XElf_Sym *osym;\n\t    memcpy (xelf_getsym (dynsymdata, dynidx, sym),\n\t\t    xelf_getsym (symdata, cnt, osym),\n\t\t    sizeof (XElf_Sym));\n#else\n\t    xelf_getsym (symdata, cnt, sym);\n\t    assert (sym != NULL);\n#endif\n\n\t    sym->st_name = ebl_strtaboffset (symstrent[cnt]);\n\n\t    (void) xelf_update_sym (dynsymdata, dynidx, sym);\n\t  }\n\n      free (hashcodes);\n\n      /* Create the required version section.  */\n      if (ld_state.verneedscnidx != 0)\n\t{\n\t  Elf_Scn *verneedscn;\n\t  Elf_Data *verneeddata;\n\t  struct usedfiles *runp;\n\t  size_t verneed_size = xelf_fsize (ld_state.outelf, ELF_T_VNEED, 1);\n\t  size_t vernaux_size = xelf_fsize (ld_state.outelf, ELF_T_VNAUX, 1);\n\t  size_t offset;\n\t  int ntotal;\n\n\t  verneedscn = elf_getscn (ld_state.outelf, ld_state.verneedscnidx);\n\t  xelf_getshdr (verneedscn, shdr);\n\t  verneeddata = elf_newdata (verneedscn);\n\t  if (shdr == NULL || verneeddata == NULL)\n\t    error (EXIT_FAILURE, 0,\n\t\t   gettext (\"cannot create versioning data: %s\"),\n\t\t   elf_errmsg (-1));\n\n\t  verneeddata->d_size = (ld_state.nverdeffile * verneed_size\n\t\t\t\t + ld_state.nverdefused * vernaux_size);\n\t  verneeddata->d_buf = xmalloc (verneeddata->d_size);\n\t  verneeddata->d_type = ELF_T_VNEED;\n\t  verneeddata->d_align = xelf_fsize (ld_state.outelf, ELF_T_WORD, 1);\n\t  verneeddata->d_off = 0;\n\n\t  offset = 0;\n\t  ntotal = ld_state.nverdeffile;\n\t  runp = ld_state.dsofiles->next;\n\t  do\n\t    {\n\t      offset = create_verneed_data (offset, verneeddata, runp,\n\t\t\t\t\t    &ntotal);\n\t      runp = runp->next;\n\t    }\n\t  while (ntotal > 0 && runp != ld_state.dsofiles->next);\n\n\t  if (ntotal > 0)\n\t    {\n\t      runp = ld_state.needed->next;\n\t      do\n\t\t{\n\t\t  offset = create_verneed_data (offset, verneeddata, runp,\n\t\t\t\t\t\t&ntotal);\n\t\t  runp = runp->next;\n\t\t}\n\t      while (ntotal > 0 && runp != ld_state.needed->next);\n\t    }\n\n\t  assert (offset == verneeddata->d_size);\n\n\t  /* Add the needed information to the section header.  */\n\t  shdr->sh_link = ld_state.dynstrscnidx;\n\t  shdr->sh_info = ld_state.nverdeffile;\n\t  (void) xelf_update_shdr (verneedscn, shdr);\n\t}\n\n      /* Adjust the section size.  */\n      dynsymdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_SYM, nsym_dyn);\n      if (versymdata != NULL)\n\tversymdata->d_size = xelf_fsize (ld_state.outelf, ELF_T_HALF,\n\t\t\t\t\t nsym_dyn);\n\n      /* Add the remaining information to the section header.  */\n      xelf_getshdr (dynsymscn, shdr);\n      /* There is always exactly one local symbol.  */\n      shdr->sh_info = 1;\n      /* Reference the string table.  */\n      shdr->sh_link = ld_state.dynstrscnidx;\n      /* Write the updated info back.  */\n      (void) xelf_update_shdr (dynsymscn, shdr);\n    }\n\n  /* We don't need the string table anymore.  */\n  free (symstrent);\n\n  /* Remember the total number of symbols in the dynamic symbol table.  */\n  ld_state.ndynsym = nsym_dyn;\n\n  /* Fill in the section header information.  */\n  symscn = elf_getscn (ld_state.outelf, ld_state.symscnidx);\n  xelf_getshdr (symscn, shdr);\n  if (shdr == NULL)\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot create symbol table for output file: %s\"),\n\t   elf_errmsg (-1));\n\n  shdr->sh_type = SHT_SYMTAB;\n  shdr->sh_link = ld_state.strscnidx;\n  shdr->sh_info = nsym_local;\n  shdr->sh_entsize = xelf_fsize (ld_state.outelf, ELF_T_SYM, 1);\n\n  (void) xelf_update_shdr (symscn, shdr);\n\n\n  /* Add names for the generated sections.  */\n  if (ld_state.symscnidx != 0)\n      symtab_ent = ebl_strtabadd (ld_state.shstrtab, \".symtab\", 8);\n  if (ld_state.xndxscnidx != 0)\n    xndx_ent = ebl_strtabadd (ld_state.shstrtab, \".symtab_shndx\", 14);\n  if (ld_state.strscnidx != 0)\n    strtab_ent = ebl_strtabadd (ld_state.shstrtab, \".strtab\", 8);\n  /* At this point we would have to test for failures in the\n     allocation.  But we skip this.  First, the problem will be caught\n     later when doing more allocations for the section header table.\n     Even if this would not be the case all that would happen is that\n     the section names are empty.  The binary would still be usable if\n     it is an executable or a DSO.  Not adding the test here saves\n     quite a bit of code.  */\n\n\n  /* Finally create the section for the section header string table.  */\n  shstrtab_scn = elf_newscn (ld_state.outelf);\n  shstrtab_ndx = elf_ndxscn (shstrtab_scn);\n  if (unlikely (shstrtab_ndx == SHN_UNDEF))\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot create section header string section: %s\"),\n\t   elf_errmsg (-1));\n\n  /* Add the name of the section to the string table.  */\n  shstrtab_ent = ebl_strtabadd (ld_state.shstrtab, \".shstrtab\", 10);\n  if (unlikely (shstrtab_ent == NULL))\n    error (EXIT_FAILURE, errno,\n\t   gettext (\"cannot create section header string section\"));\n\n  /* Finalize the section header string table.  */\n  data = elf_newdata (shstrtab_scn);\n  if (data == NULL)\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot create section header string section: %s\"),\n\t   elf_errmsg (-1));\n  ebl_strtabfinalize (ld_state.shstrtab, data);\n\n  /* Now we know the string offsets for all section names.  */\n  for (cnt = 0; cnt < ld_state.nallsections; ++cnt)\n    if (ld_state.allsections[cnt]->scnidx != 0)\n      {\n\tElf_Scn *scn;\n\n\tscn = elf_getscn (ld_state.outelf, ld_state.allsections[cnt]->scnidx);\n\n\txelf_getshdr (scn, shdr);\n\tassert (shdr != NULL);\n\n\tshdr->sh_name = ebl_strtaboffset (ld_state.allsections[cnt]->nameent);\n\n\tif (xelf_update_shdr (scn, shdr) == 0)\n\t  assert (0);\n      }\n\n  /* Add the names for the generated sections to the respective\n     section headers.  */\n  if (symtab_ent != NULL)\n    {\n      Elf_Scn *scn = elf_getscn (ld_state.outelf, ld_state.symscnidx);\n\n      xelf_getshdr (scn, shdr);\n      /* This cannot fail, we already accessed the header before.  */\n      assert (shdr != NULL);\n\n      shdr->sh_name = ebl_strtaboffset (symtab_ent);\n\n      (void) xelf_update_shdr (scn, shdr);\n    }\n  if (xndx_ent != NULL)\n    {\n      Elf_Scn *scn = elf_getscn (ld_state.outelf, ld_state.xndxscnidx);\n\n      xelf_getshdr (scn, shdr);\n      /* This cannot fail, we already accessed the header before.  */\n      assert (shdr != NULL);\n\n      shdr->sh_name = ebl_strtaboffset (xndx_ent);\n\n      (void) xelf_update_shdr (scn, shdr);\n    }\n  if (strtab_ent != NULL)\n    {\n      Elf_Scn *scn = elf_getscn (ld_state.outelf, ld_state.strscnidx);\n\n      xelf_getshdr (scn, shdr);\n      /* This cannot fail, we already accessed the header before.  */\n      assert (shdr != NULL);\n\n      shdr->sh_name = ebl_strtaboffset (strtab_ent);\n\n      (void) xelf_update_shdr (scn, shdr);\n    }\n\n  /* And the section header table section itself.  */\n  xelf_getshdr (shstrtab_scn, shdr);\n  if (shdr == NULL)\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot create section header string section: %s\"),\n\t   elf_errmsg (-1));\n\n  shdr->sh_name = ebl_strtaboffset (shstrtab_ent);\n  shdr->sh_type = SHT_STRTAB;\n\n  if (unlikely (xelf_update_shdr (shstrtab_scn, shdr) == 0))\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot create section header string section: %s\"),\n\t   elf_errmsg (-1));\n\n\n  /* Add the correct section header info to the section group sections.  */\n  groups = ld_state.groups;\n  while (groups != NULL)\n    {\n      Elf_Scn *scn = elf_getscn (ld_state.outelf, groups->outscnidx);\n      xelf_getshdr (scn, shdr);\n      assert (shdr != NULL);\n\n      shdr->sh_name = ebl_strtaboffset (groups->nameent);\n      shdr->sh_type = SHT_GROUP;\n      shdr->sh_flags = 0;\n      shdr->sh_link = ld_state.symscnidx;\n      shdr->sh_entsize = sizeof (Elf32_Word);\n\n      /* Determine the index for the signature symbol.  */\n      Elf32_Word si\n\t= groups->symbol->file->symindirect[groups->symbol->symidx];\n      if (si == 0)\n\t{\n\t  assert (groups->symbol->file->symref[groups->symbol->symidx]\n\t\t  != NULL);\n\t  si = groups->symbol->file->symref[groups->symbol->symidx]->outsymidx;\n\t  assert (si != 0);\n\t}\n      shdr->sh_info = ld_state.dblindirect[si];\n\n      (void) xelf_update_shdr (scn, shdr);\n\n      struct scngroup *oldp = groups;\n      groups = groups->next;\n      free (oldp);\n    }\n\n\n  if (ld_state.file_type != relocatable_file_type)\n    {\n      /* Every executable needs a program header.  The number of entries\n\t varies.  One exists for each segment.  Each SHT_NOTE section gets\n\t one, too.  For dynamically linked executables we have to create\n\t one for the program header, the interpreter, and the dynamic\n\t section.  First count the number of segments.\n\n\t XXX Determine whether the segment is non-empty.  */\n      size_t nphdr = 0;\n\n      /* We always add a PT_GNU_stack entry.  */\n      ++nphdr;\n\n      struct output_segment *segment = ld_state.output_segments;\n      while (segment != NULL)\n\t{\n\t  ++nphdr;\n\t  segment = segment->next;\n\t}\n\n      /* Add the number of SHT_NOTE sections.  We counted them earlier.  */\n      nphdr += ld_state.nnotesections;\n\n      /* If we create a DSO or the file is linked against DSOs we have\n\t at least one more entry: DYNAMIC.  If an interpreter is\n\t specified we add PHDR and INTERP, too.  */\n      if (dynamically_linked_p ())\n\t{\n\t  ++nphdr;\n\n\t  if (ld_state.interp != NULL || ld_state.file_type != dso_file_type)\n\t    nphdr += 2;\n\t}\n\n      /* If we need a TLS segment we need an entry for that.  */\n      if (ld_state.need_tls)\n\t++nphdr;\n\n      /* Create the program header structure.  */\n      XElf_Phdr_vardef (phdr);\n      if (xelf_newphdr (ld_state.outelf, nphdr) == 0)\n\terror (EXIT_FAILURE, 0, gettext (\"cannot create program header: %s\"),\n\t       elf_errmsg (-1));\n\n\n      /* Determine the section sizes and offsets.  We have to do this\n\t to be able to determine the memory layout (which normally\n\t differs from the file layout).  */\n      if (elf_update (ld_state.outelf, ELF_C_NULL) == -1)\n\terror (EXIT_FAILURE, 0, gettext (\"while determining file layout: %s\"),\n\t       elf_errmsg (-1));\n\n\n      /* Now determine the memory addresses of all the sections and\n\t segments.  */\n      Elf32_Word nsec = 0;\n      Elf_Scn *scn = elf_getscn (ld_state.outelf,\n\t\t\t\t ld_state.allsections[nsec]->scnidx);\n      xelf_getshdr (scn, shdr);\n      assert (shdr != NULL);\n\n      /* The address we start with is the offset of the first (not\n\t zeroth) section.  */\n      XElf_Addr addr = shdr->sh_offset;\n      XElf_Addr tls_offset = 0;\n      XElf_Addr tls_start = ~((XElf_Addr) 0);\n      XElf_Addr tls_end = 0;\n      XElf_Off tls_filesize = 0;\n      XElf_Addr tls_align = 0;\n\n      /* The index of the first loadable segment.  */\n      nphdr = 0;\n      if (dynamically_linked_p ())\n\t{\n\t  ++nphdr;\n\t  if (ld_state.interp != NULL\n\t      || ld_state.file_type != dso_file_type)\n\t    nphdr += 2;\n\t}\n\n      segment = ld_state.output_segments;\n      while (segment != NULL)\n\t{\n\t  struct output_rule *orule;\n\t  bool first_section = true;\n\t  XElf_Off nobits_size = 0;\n\t  XElf_Off memsize = 0;\n\n\t  /* The minimum alignment is a page size.  */\n\t  segment->align = ld_state.pagesize;\n\n\t  for (orule = segment->output_rules; orule != NULL;\n\t       orule = orule->next)\n\t    if (orule->tag == output_section)\n\t      {\n\t\t/* See whether this output rule corresponds to the next\n\t\t   section.  Yes, this is a pointer comparison.  */\n\t\tif (ld_state.allsections[nsec]->name\n\t\t    != orule->val.section.name)\n\t\t  /* No, ignore this output rule.  */\n\t\t  continue;\n\n\t\t/* We assign addresses only in segments which are actually\n\t\t   loaded.  */\n\t\tif (segment->mode != 0)\n\t\t  {\n\t\t    /* Adjust the offset of the input sections.  */\n\t\t    struct scninfo *isect;\n\t\t    struct scninfo *first;\n\n\t\t    isect = first = ld_state.allsections[nsec]->last;\n\t\t    if (isect != NULL)\n\t\t      do\n\t\t\tisect->offset += addr;\n\t\t      while ((isect = isect->next) != first);\n\n\t\t    /* Set the address of current section.  */\n\t\t    shdr->sh_addr = addr;\n\n\t\t    /* Write the result back.  */\n\t\t    (void) xelf_update_shdr (scn, shdr);\n\n\t\t    /* Remember the address.  */\n\t\t    ld_state.allsections[nsec]->addr = addr;\n\n\t\t    /* Handle TLS sections.  */\n\t\t    if (unlikely (shdr->sh_flags & SHF_TLS))\n\t\t      {\n\t\t\tif (tls_start > addr)\n\t\t\t  {\n\t\t\t    tls_start = addr;\n\t\t\t    tls_offset = shdr->sh_offset;\n\t\t\t  }\n\t\t\tif (tls_end < addr + shdr->sh_size)\n\t\t\t  tls_end = addr + shdr->sh_size;\n\t\t\tif (shdr->sh_type != SHT_NOBITS)\n\t\t\t  tls_filesize += shdr->sh_size;\n\t\t\tif (shdr->sh_addralign > tls_align)\n\t\t\t  tls_align = shdr->sh_addralign;\n\t\t      }\n\t\t  }\n\n\t\tif (first_section)\n\t\t  {\n\t\t    /* The first segment starts at offset zero.  */\n\t\t    if (segment == ld_state.output_segments)\n\t\t      {\n\t\t\tsegment->offset = 0;\n\t\t\tsegment->addr = addr - shdr->sh_offset;\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tsegment->offset = shdr->sh_offset;\n\t\t\tsegment->addr = addr;\n\t\t      }\n\n\t\t    /* Determine the maximum alignment requirement.  */\n\t\t    segment->align = MAX (segment->align, shdr->sh_addralign);\n\n\t\t    first_section = false;\n\t\t  }\n\n\t\t/* NOBITS TLS sections are not laid out in address space\n\t\t   along with the other sections.  */\n\t\tif (shdr->sh_type != SHT_NOBITS\n\t\t    || (shdr->sh_flags & SHF_TLS) == 0)\n\t\t  {\n\t\t    memsize = (shdr->sh_offset - segment->offset\n\t\t\t       + shdr->sh_size);\n\t\t    if (nobits_size != 0 && shdr->sh_type != SHT_NOTE)\n\t\t      error (EXIT_FAILURE, 0, gettext (\"\\\ninternal error: non-nobits section follows nobits section\"));\n\t\t    if (shdr->sh_type == SHT_NOBITS)\n\t\t      nobits_size += shdr->sh_size;\n\t\t  }\n\n\t\t/* Determine the new address which is computed using\n\t\t   the difference of the offsets on the sections.  Note\n\t\t   that this assumes that the sections following each\n\t\t   other in the section header table are also\n\t\t   consecutive in the file.  This is true here because\n\t\t   libelf constructs files this way.  */\n\t\tXElf_Off oldoff = shdr->sh_offset;\n\n\t\tif (++nsec >= ld_state.nallsections)\n\t\t  break;\n\n\t\tscn = elf_getscn (ld_state.outelf,\n\t\t\t\t  ld_state.allsections[nsec]->scnidx);\n\t\txelf_getshdr (scn, shdr);\n\t\tassert (shdr != NULL);\n\n\t\t/* This is the new address resulting from the offsets\n\t\t   in the file.  */\n\t\tassert (oldoff <= shdr->sh_offset);\n\t\taddr += shdr->sh_offset - oldoff;\n\t      }\n\t    else\n\t      {\n\t\tassert (orule->tag == output_assignment);\n\n\t\tif (strcmp (orule->val.assignment->variable, \".\") == 0)\n\t\t  /* This is a change of the address.  */\n\t\t  addr = eval_expression (orule->val.assignment->expression,\n\t\t\t\t\t  addr);\n\t\telse if (orule->val.assignment->sym != NULL)\n\t\t  {\n\t\t    /* This symbol is used.  Update the symbol table\n\t\t       entry.  */\n\t\t    XElf_Sym_vardef (sym);\n\t\t    size_t idx;\n\n\t\t    /* Note that we do not have to use\n\t\t       xelf_getsymshndx since we only update the\n\t\t       symbol address, not the section\n\t\t       information.  */\n\t\t    idx = dblindirect[orule->val.assignment->sym->outsymidx];\n\t\t    xelf_getsym (symdata, idx, sym);\n\t\t    sym->st_value = addr;\n\t\t    (void) xelf_update_sym (symdata, idx, sym);\n\n\t\t    idx = orule->val.assignment->sym->outdynsymidx;\n\t\t    if (idx != 0)\n\t\t      {\n\t\t\tassert (dynsymdata != NULL);\n\t\t\txelf_getsym (dynsymdata, idx, sym);\n\t\t\tsym->st_value = addr;\n\t\t\t(void) xelf_update_sym (dynsymdata, idx, sym);\n\t\t      }\n\t\t  }\n\t      }\n\n\t  /* Store the segment parameter for loadable segments.  */\n\t  if (segment->mode != 0)\n\t    {\n\t      xelf_getphdr_ptr (ld_state.outelf, nphdr, phdr);\n\n\t      phdr->p_type = PT_LOAD;\n\t      phdr->p_offset = segment->offset;\n\t      phdr->p_vaddr = segment->addr;\n\t      phdr->p_paddr = phdr->p_vaddr;\n\t      phdr->p_filesz = memsize - nobits_size;\n\t      phdr->p_memsz = memsize;\n\t      phdr->p_flags = segment->mode;\n\t      phdr->p_align = segment->align;\n\n\t      (void) xelf_update_phdr (ld_state.outelf, nphdr, phdr);\n\t      ++nphdr;\n\t    }\n\n\t  segment = segment->next;\n\t}\n\n      /* Create the other program header entries.  */\n      xelf_getehdr (ld_state.outelf, ehdr);\n      assert (ehdr != NULL);\n\n      /* Add the TLS information.  */\n      if (ld_state.need_tls)\n\t{\n\t  xelf_getphdr_ptr (ld_state.outelf, nphdr, phdr);\n\t  phdr->p_type = PT_TLS;\n\t  phdr->p_offset = tls_offset;\n\t  phdr->p_vaddr = tls_start;\n\t  phdr->p_paddr = tls_start;\n\t  phdr->p_filesz = tls_filesize;\n\t  phdr->p_memsz = tls_end - tls_start;\n\t  phdr->p_flags = PF_R;\n\t  phdr->p_align = tls_align;\n\t  ld_state.tls_tcb = tls_end;\n\t  ld_state.tls_start = tls_start;\n\n\t  (void) xelf_update_phdr (ld_state.outelf, nphdr, phdr);\n\t  ++nphdr;\n\t}\n\n      /* Add the stack information.  */\n      xelf_getphdr_ptr (ld_state.outelf, nphdr, phdr);\n      phdr->p_type = PT_GNU_STACK;\n      phdr->p_offset = 0;\n      phdr->p_vaddr = 0;\n      phdr->p_paddr = 0;\n      phdr->p_filesz = 0;\n      phdr->p_memsz = 0;\n      phdr->p_flags = (PF_R | PF_W\n\t\t       | (ld_state.execstack == execstack_true ? PF_X : 0));\n      phdr->p_align = xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1);\n\n      (void) xelf_update_phdr (ld_state.outelf, nphdr, phdr);\n      ++nphdr;\n\n\n      /* Adjust the addresses in the address fields of the symbol\n\t records according to the load addresses of the sections.  */\n      if (ld_state.need_symtab)\n\tfor (cnt = 1; cnt < nsym; ++cnt)\n\t  {\n\t    XElf_Sym_vardef (sym);\n\t    Elf32_Word shndx;\n\n\t    xelf_getsymshndx (symdata, xndxdata, cnt, sym, shndx);\n\t    assert (sym != NULL);\n\n\t    if (sym->st_shndx != SHN_XINDEX)\n\t      shndx = sym->st_shndx;\n\n\t    if ((shndx > SHN_UNDEF && shndx < SHN_LORESERVE)\n\t\t|| shndx > SHN_HIRESERVE)\n\t      {\n\t\t/* Note we subtract 1 from the section index since ALLSECTIONS\n\t\t   does not store the dummy section with offset zero.  */\n\t\tsym->st_value += ld_state.allsections[shndx - 1]->addr;\n\n\t\t/* We don't have to use 'xelf_update_symshndx' since the\n\t\t   section number doesn't change.  */\n\t\t(void) xelf_update_sym (symdata, cnt, sym);\n\t      }\n\t  }\n\n      if (ld_state.need_dynsym)\n\tfor (cnt = 1; cnt < nsym_dyn; ++cnt)\n\t  {\n\t    XElf_Sym_vardef (sym);\n\n\t    xelf_getsym (dynsymdata, cnt, sym);\n\t    assert (sym != NULL);\n\n\t    if (sym->st_shndx > SHN_UNDEF && sym->st_shndx < SHN_LORESERVE)\n\t      {\n\t\t/* Note we subtract 1 from the section index since ALLSECTIONS\n\t\t   does not store the dummy section with offset zero.  */\n\t\tsym->st_value += ld_state.allsections[sym->st_shndx - 1]->addr;\n\n\t\t/* We don't have to use 'xelf_update_symshndx' since the\n\t\t   section number doesn't change.  */\n\t\t(void) xelf_update_sym (dynsymdata, cnt, sym);\n\t      }\n\t  }\n\n      /* Now is a good time to determine the values of all the symbols\n\t we encountered.  */\n      // XXX This loop is very inefficient.  The hash tab iterator also\n      // returns all symbols in DSOs.\n      struct symbol *se;\n      void *p = NULL;\n      while ((se = ld_symbol_tab_iterate (&ld_state.symbol_tab, &p)) != NULL)\n\tif (! se->in_dso)\n\t  {\n\t    XElf_Sym_vardef (sym);\n\n\t    addr = 0;\n\n\t    if (se->outdynsymidx != 0)\n\t      {\n\t\txelf_getsym (dynsymdata, se->outdynsymidx, sym);\n\t\tassert (sym != NULL);\n\t\taddr = sym->st_value;\n\t      }\n\t    else if (se->outsymidx != 0)\n\t      {\n\t\tassert (dblindirect[se->outsymidx] != 0);\n\t\txelf_getsym (symdata, dblindirect[se->outsymidx], sym);\n\t\tassert (sym != NULL);\n\t\taddr = sym->st_value;\n\t      }\n\t    else\n\t      abort ();\n\n\t    se->merge.value = addr;\n\t  }\n\n      /* Complete the header of the .rel.dyn/.rela.dyn section.  Point\n\t to the symbol table.  The sh_info field is left zero since\n\t there is no specific section the contained relocations are\n\t for.  */\n      if (ld_state.reldynscnidx != 0)\n\t{\n\t  assert (ld_state.dynsymscnidx != 0);\n\t  scn = elf_getscn (ld_state.outelf, ld_state.reldynscnidx);\n\t  xelf_getshdr (scn, shdr);\n\t  assert (shdr != NULL);\n\n\t  shdr->sh_link = ld_state.dynsymscnidx;\n\n\t  (void) xelf_update_shdr (scn, shdr);\n\t}\n\n      /* Fill in the dynamic segment/section.  */\n      if (dynamically_linked_p ())\n\t{\n\t  Elf_Scn *outscn;\n\n\t  int idx = 0;\n\t  if (ld_state.interp != NULL || ld_state.file_type != dso_file_type)\n\t    {\n\t      assert (ld_state.interpscnidx != 0);\n\t      xelf_getshdr (elf_getscn (ld_state.outelf,\n\t\t\t\t\tld_state.interpscnidx), shdr);\n\t      assert (shdr != NULL);\n\n\t      xelf_getphdr_ptr (ld_state.outelf, idx, phdr);\n\t      phdr->p_type = PT_PHDR;\n\t      phdr->p_offset = ehdr->e_phoff;\n\t      phdr->p_vaddr = ld_state.output_segments->addr + phdr->p_offset;\n\t      phdr->p_paddr = phdr->p_vaddr;\n\t      phdr->p_filesz = ehdr->e_phnum * ehdr->e_phentsize;\n\t      phdr->p_memsz = phdr->p_filesz;\n\t      phdr->p_flags = 0;\t/* No need to set PF_R or so.  */\n\t      phdr->p_align = xelf_fsize (ld_state.outelf, ELF_T_ADDR, 1);\n\n\t      (void) xelf_update_phdr (ld_state.outelf, idx, phdr);\n\t      ++idx;\n\n\t      /* The interpreter string.  */\n\t      xelf_getphdr_ptr (ld_state.outelf, idx, phdr);\n\t      phdr->p_type = PT_INTERP;\n\t      phdr->p_offset = shdr->sh_offset;\n\t      phdr->p_vaddr = shdr->sh_addr;\n\t      phdr->p_paddr = phdr->p_vaddr;\n\t      phdr->p_filesz = shdr->sh_size;\n\t      phdr->p_memsz = phdr->p_filesz;\n\t      phdr->p_flags = 0;\t/* No need to set PF_R or so.  */\n\t      phdr->p_align = 1;\t/* It's a string.  */\n\n\t      (void) xelf_update_phdr (ld_state.outelf, idx, phdr);\n\t      ++idx;\n\t    }\n\n\t  /* The pointer to the dynamic section.  We this we need to\n\t     get the information for the dynamic section first.  */\n\t  assert (ld_state.dynamicscnidx);\n\t  outscn = elf_getscn (ld_state.outelf, ld_state.dynamicscnidx);\n\t  xelf_getshdr (outscn, shdr);\n\t  assert (shdr != NULL);\n\n\t  xelf_getphdr_ptr (ld_state.outelf, idx, phdr);\n\t  phdr->p_type = PT_DYNAMIC;\n\t  phdr->p_offset = shdr->sh_offset;\n\t  phdr->p_vaddr = shdr->sh_addr;\n\t  phdr->p_paddr = phdr->p_vaddr;\n\t  phdr->p_filesz = shdr->sh_size;\n\t  phdr->p_memsz = phdr->p_filesz;\n\t  phdr->p_flags = 0;\t\t/* No need to set PF_R or so.  */\n\t  phdr->p_align = shdr->sh_addralign;\n\n\t  (void) xelf_update_phdr (ld_state.outelf, idx, phdr);\n\n\t  /* Fill in the reference to the .dynstr section.  */\n\t  assert (ld_state.dynstrscnidx != 0);\n\t  shdr->sh_link = ld_state.dynstrscnidx;\n\t  (void) xelf_update_shdr (outscn, shdr);\n\n\t  /* And fill the remaining entries.  */\n\t  Elf_Data *dyndata = elf_getdata (outscn, NULL);\n\t  assert (dyndata != NULL);\n\n\t  /* Add the DT_NEEDED entries.  */\n\t  if (ld_state.ndsofiles > 0)\n\t    {\n\t      struct usedfiles *runp = ld_state.dsofiles->next;\n\n\t      do\n\t\tif (runp->used || !runp->as_needed)\n\t\t  {\n\t\t    /* Add the position-dependent flag if necessary.  */\n\t\t    if (runp->lazyload)\n\t\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t\t DT_POSFLAG_1, DF_P1_LAZYLOAD);\n\n\t\t    new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t       DT_NEEDED,\n\t\t\t\t       ebl_strtaboffset (runp->sonameent));\n\t\t  }\n\t      while ((runp = runp->next) != ld_state.dsofiles->next);\n\t    }\n\n\t  /* We can finish the DT_RUNPATH/DT_RPATH entries now.  */\n\t  if (ld_state.rxxpath_strent != NULL)\n\t    new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t       ld_state.rxxpath_tag,\n\t\t\t       ebl_strtaboffset (ld_state.rxxpath_strent));\n\n\t  /* Reference to initialization and finalization functions.  */\n\t  // XXX This code depends on symbol table being relocated.\n\t  if (ld_state.init_symbol != NULL)\n\t    {\n\t      XElf_Sym_vardef (sym);\n\n\t      if (ld_state.need_symtab)\n\t\txelf_getsym (symdata,\n\t\t\t     dblindirect[ld_state.init_symbol->outsymidx],\n\t\t\t     sym);\n\t      else\n\t\txelf_getsym (dynsymdata, ld_state.init_symbol->outdynsymidx,\n\t\t\t     sym);\n\t      assert (sym != NULL);\n\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t DT_INIT, sym->st_value);\n\t    }\n\t  if (ld_state.fini_symbol != NULL)\n\t    {\n\t      XElf_Sym_vardef (sym);\n\n\t      if (ld_state.need_symtab)\n\t\txelf_getsym (symdata,\n\t\t\t     dblindirect[ld_state.fini_symbol->outsymidx],\n\t\t\t     sym);\n\t      else\n\t\txelf_getsym (dynsymdata, ld_state.fini_symbol->outdynsymidx,\n\t\t\t     sym);\n\t      assert (sym != NULL);\n\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t DT_FINI, sym->st_value);\n\t    }\n\t  // XXX Support init,fini,preinit arrays\n\n\t  /* The hash table which comes with dynamic symbol table.  */\n\t  xelf_getshdr (elf_getscn (ld_state.outelf, ld_state.hashscnidx),\n\t\t\tshdr);\n\t  assert (shdr != NULL);\n\t  new_dynamic_entry (dyndata, ld_state.ndynamic_filled++, DT_HASH,\n\t\t\t     shdr->sh_addr);\n\n\t  /* Reference to the symbol table section.  */\n\t  assert (ld_state.dynsymscnidx != 0);\n\t  xelf_getshdr (elf_getscn (ld_state.outelf, ld_state.dynsymscnidx),\n\t\t\tshdr);\n\t  assert (shdr != NULL);\n\t  new_dynamic_entry (dyndata, ld_state.ndynamic_filled++, DT_SYMTAB,\n\t\t\t     shdr->sh_addr);\n\n\t  new_dynamic_entry (dyndata, ld_state.ndynamic_filled++, DT_SYMENT,\n\t\t\t     xelf_fsize (ld_state.outelf, ELF_T_SYM, 1));\n\n\t  /* And the string table which comes with it.  */\n\t  xelf_getshdr (elf_getscn (ld_state.outelf, ld_state.dynstrscnidx),\n\t\t\tshdr);\n\t  assert (shdr != NULL);\n\t  new_dynamic_entry (dyndata, ld_state.ndynamic_filled++, DT_STRTAB,\n\t\t\t     shdr->sh_addr);\n\n\t  new_dynamic_entry (dyndata, ld_state.ndynamic_filled++, DT_STRSZ,\n\t\t\t     shdr->sh_size);\n\n\t  /* Add the entries related to the .plt.  */\n\t  if (ld_state.nplt > 0)\n\t    {\n\t      // XXX Make this work if there is no PLT\n\t      xelf_getshdr (elf_getscn (ld_state.outelf,\n\t\t\t\t\tld_state.gotpltscnidx), shdr);\n\t      assert (shdr != NULL);\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t // XXX This should probably be machine\n\t\t\t\t // dependent.\n\t\t\t\t DT_PLTGOT, shdr->sh_addr);\n\n\t      xelf_getshdr (elf_getscn (ld_state.outelf,\n\t\t\t\t\tld_state.pltrelscnidx), shdr);\n\t      assert (shdr != NULL);\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t DT_PLTRELSZ, shdr->sh_size);\n\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t DT_JMPREL, shdr->sh_addr);\n\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t DT_PLTREL, REL_TYPE (statep));\n\t    }\n\n\t  if (ld_state.relsize_total > 0)\n\t    {\n\t      int rel = REL_TYPE (statep);\n\t      xelf_getshdr (elf_getscn (ld_state.outelf,\n\t\t\t\t\tld_state.reldynscnidx), shdr);\n\t      assert (shdr != NULL);\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t rel, shdr->sh_addr);\n\n\t      /* Trick ahead.  Use arithmetic to get the right tag.\n\t\t We check the validity of this assumption in the asserts.  */\n\t      assert (DT_RELASZ - DT_RELA == 1);\n\t      assert (DT_RELSZ - DT_REL == 1);\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t rel + 1, shdr->sh_size);\n\n\t      /* Similar for the entry size tag.  */\n\t      assert (DT_RELAENT - DT_RELA == 2);\n\t      assert (DT_RELENT - DT_REL == 2);\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t rel + 2,\n\t\t\t\t rel == DT_REL\n\t\t\t\t ? xelf_fsize (ld_state.outelf, ELF_T_REL, 1)\n\t\t\t\t : xelf_fsize (ld_state.outelf, ELF_T_RELA,\n\t\t\t\t\t       1));\n\t    }\n\n\t  if (ld_state.verneedscnidx != 0)\n\t    {\n\t      xelf_getshdr (elf_getscn (ld_state.outelf,\n\t\t\t\t\tld_state.verneedscnidx), shdr);\n\t      assert (shdr != NULL);\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t DT_VERNEED, shdr->sh_addr);\n\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t DT_VERNEEDNUM, ld_state.nverdeffile);\n\t    }\n\n\t  if (ld_state.versymscnidx != 0)\n\t    {\n\t      xelf_getshdr (elf_getscn (ld_state.outelf,\n\t\t\t\t\tld_state.versymscnidx), shdr);\n\t      assert (shdr != NULL);\n\t      new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t\t DT_VERSYM, shdr->sh_addr);\n\t    }\n\n\t  /* We always create the DT_DEBUG entry.  */\n\t  new_dynamic_entry (dyndata, ld_state.ndynamic_filled++, DT_DEBUG, 0);\n\t  assert (ld_state.ndynamic_filled < ld_state.ndynamic);\n\n\t  /* Add the flag words if necessary.  */\n\t  if (ld_state.dt_flags != 0)\n\t    new_dynamic_entry (dyndata, ld_state.ndynamic_filled++, DT_FLAGS,\n\t\t\t       ld_state.dt_flags);\n\n\t  /* Create entry for the DT_FLAGS_1 flag.  */\n\t  if (ld_state.dt_flags_1 != 0)\n\t    new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t       DT_FLAGS_1, ld_state.dt_flags_1);\n\n\t  /* Create entry for the DT_FEATURE_1 flag.  */\n\t  if (ld_state.dt_feature_1 != 0)\n\t    new_dynamic_entry (dyndata, ld_state.ndynamic_filled++,\n\t\t\t       DT_FEATURE_1, ld_state.dt_feature_1);\n\n\t  assert (ld_state.ndynamic_filled <= ld_state.ndynamic);\n\t}\n    }\n\n\n  // XXX The following code isn't nice.  We use two different\n  // mechanisms to handle relocations, one for relocatable files, one\n  // for executables and DSOs.  Maybe this is the best method but also\n  // maybe it can be somewhat unified.\n\n  /* Now that we created the symbol table we can add the reference to\n     it in the sh_link field of the section headers of the relocation\n     sections.  */\n  while (rellist != NULL)\n    {\n      assert (ld_state.file_type == relocatable_file_type);\n      Elf_Scn *outscn;\n\n      outscn = elf_getscn (ld_state.outelf, rellist->scnidx);\n      xelf_getshdr (outscn, shdr);\n      /* This must not fail since we did it before.  */\n      assert (shdr != NULL);\n\n      /* Remember the symbol table which belongs to the relocation section.  */\n      shdr->sh_link = ld_state.symscnidx;\n\n      /* And the reference to the section which is relocated by this\n\t relocation section.  We use the info from the first input\n\t section but all records should have the same information.  */\n      shdr->sh_info =\n\trellist->scninfo->fileinfo->scninfo[SCNINFO_SHDR (rellist->scninfo->shdr).sh_info].outscnndx;\n\n\n      /* Perform the actual relocations.  We only have to adjust\n\t offsets and symbol indices.  */\n      RELOCATE_SECTION (statep, outscn, rellist->scninfo, dblindirect);\n\n      /* Store the changes.  */\n      (void) xelf_update_shdr (outscn, shdr);\n\n      /* Up to the next relocation section.  */\n      rellist = rellist->next;\n    }\n\n  if (ld_state.rellist != NULL)\n    {\n      assert (ld_state.file_type != relocatable_file_type);\n      /* Create the relocations for the output file.  */\n      CREATE_RELOCATIONS (statep, dblindirect);\n    }\n\n\n  /* We need the ELF header once more.  */\n  xelf_getehdr (ld_state.outelf, ehdr);\n  assert (ehdr != NULL);\n\n  /* Set the section header string table index.  */\n  if (likely (shstrtab_ndx < SHN_HIRESERVE)\n      && likely (shstrtab_ndx != SHN_XINDEX))\n    ehdr->e_shstrndx = shstrtab_ndx;\n  else\n    {\n      /* We have to put the section index in the sh_link field of the\n\t zeroth section header.  */\n      Elf_Scn *scn = elf_getscn (ld_state.outelf, 0);\n\n      xelf_getshdr (scn, shdr);\n      if (unlikely (shdr == NULL))\n\terror (EXIT_FAILURE, 0,\n\t       gettext (\"cannot get header of 0th section: %s\"),\n\t       elf_errmsg (-1));\n\n      shdr->sh_link = shstrtab_ndx;\n\n      (void) xelf_update_shdr (scn, shdr);\n\n      ehdr->e_shstrndx = SHN_XINDEX;\n    }\n\n  if (ld_state.file_type != relocatable_file_type)\n    /* DSOs and executables have to define the entry point symbol.  */\n    ehdr->e_entry = find_entry_point ();\n\n  if (unlikely (xelf_update_ehdr (ld_state.outelf, ehdr) == 0))\n    error (EXIT_FAILURE, 0,\n\t   gettext (\"cannot update ELF header: %s\"),\n\t   elf_errmsg (-1));\n\n\n  /* Free the data which we don't need anymore.  */\n  free (ld_state.dblindirect);\n\n\n  /* Finalize the .plt section and what else belongs to it.  */\n  FINALIZE_PLT (statep, nsym, nsym_local, ndxtosym);\n\n\n  /* Finally, if we have to compute the build ID.  */\n  if (ld_state.build_id != NULL)\n    compute_build_id ();\n\n\n  /* We don't need the map from the symbol table index to the symbol\n     structure anymore.  */\n  free (ndxtosym);\n\n  return 0;\n}\n\n\n/* This is a function which must be specified in all backends.  */\nstatic void\nld_generic_relocate_section (struct ld_state *statep, Elf_Scn *outscn,\n\t\t\t     struct scninfo *firstp,\n\t\t\t     const Elf32_Word *dblindirect)\n{\n  error (EXIT_FAILURE, 0, gettext (\"\\\nlinker backend didn't specify function to relocate section\"));\n  /* NOTREACHED */\n}\n\n\n/* Finalize the output file.  */\nstatic int\nld_generic_finalize (struct ld_state *statep)\n{\n  /* Write out the ELF file data.  */\n  if (elf_update (ld_state.outelf, ELF_C_WRITE) == -1)\n      error (EXIT_FAILURE, 0, gettext (\"while writing output file: %s\"),\n\t     elf_errmsg (-1));\n\n  /* Free the resources.  */\n  if (elf_end (ld_state.outelf) != 0)\n    error (EXIT_FAILURE, 0, gettext (\"while finishing output file: %s\"),\n\t   elf_errmsg (-1));\n\n  /* Get the file status of the temporary file.  */\n  struct stat temp_st;\n  if (fstat (ld_state.outfd, &temp_st) != 0)\n    error (EXIT_FAILURE, errno, gettext (\"cannot stat output file\"));\n\n  /* Now it's time to rename the file.  Remove an old existing file\n     first.  */\n  if (rename (ld_state.tempfname, ld_state.outfname) != 0)\n    /* Something went wrong.  */\n    error (EXIT_FAILURE, errno, gettext (\"cannot rename output file\"));\n\n  /* Make sure the output file is really the one we created.  */\n  struct stat new_st;\n  if (stat (ld_state.outfname, &new_st) != 0\n      || new_st.st_ino != temp_st.st_ino\n      || new_st.st_dev != temp_st.st_dev)\n    {\n      /* Wow, somebody overwrote the output file, probably some intruder.  */\n      unlink (ld_state.outfname);\n      error (EXIT_FAILURE, 0, gettext (\"\\\nWARNING: temporary output file overwritten before linking finished\"));\n    }\n\n  /* Close the file descriptor.  */\n  (void) close (ld_state.outfd);\n\n  /* Signal the cleanup handler that the file is correctly created.  */\n  ld_state.tempfname = NULL;\n\n  return 0;\n}\n\n\nstatic bool\nld_generic_special_section_number_p (struct ld_state *statep, size_t number)\n{\n  /* There are no special section numbers in the gABI.  */\n  return false;\n}\n\n\nstatic bool\nld_generic_section_type_p (struct ld_state *statep, GElf_Word type)\n{\n  if (type < SHT_NUM\n      /* XXX Enable the following two when implemented.  */\n      // || type == SHT_GNU_LIBLIST\n      // || type == SHT_CHECKSUM\n      /* XXX Eventually include SHT_SUNW_move, SHT_SUNW_COMDAT, and\n\t SHT_SUNW_syminfo.  */\n      || (type >= SHT_GNU_verdef && type <= SHT_GNU_versym))\n    return true;\n\n  return false;\n}\n\n\nstatic XElf_Xword\nld_generic_dynamic_section_flags (struct ld_state *statep)\n{\n  /* By default the .dynamic section is writable (and is of course\n     loaded).  Few architecture differ from this.  */\n  return SHF_ALLOC | SHF_WRITE;\n}\n\n\nstatic void\nld_generic_initialize_plt (struct ld_state *statep, Elf_Scn *scn)\n{\n  /* This cannot be implemented generally.  There should have been a\n     machine dependent implementation and we should never have arrived\n     here.  */\n  error (EXIT_FAILURE, 0, gettext (\"no machine specific '%s' implementation\"),\n\t \"initialize_plt\");\n}\n\n\nstatic void\nld_generic_initialize_pltrel (struct ld_state *statep, Elf_Scn *scn)\n{\n  /* This cannot be implemented generally.  There should have been a\n     machine dependent implementation and we should never have arrived\n     here.  */\n  error (EXIT_FAILURE, 0, gettext (\"no machine specific '%s' implementation\"),\n\t \"initialize_pltrel\");\n}\n\n\nstatic void\nld_generic_initialize_got (struct ld_state *statep, Elf_Scn *scn)\n{\n  /* This cannot be implemented generally.  There should have been a\n     machine dependent implementation and we should never have arrived\n     here.  */\n  error (EXIT_FAILURE, 0, gettext (\"no machine specific '%s' implementation\"),\n\t \"initialize_got\");\n}\n\n\nstatic void\nld_generic_initialize_gotplt (struct ld_state *statep, Elf_Scn *scn)\n{\n  /* This cannot be implemented generally.  There should have been a\n     machine dependent implementation and we should never have arrived\n     here.  */\n  error (EXIT_FAILURE, 0, gettext (\"no machine specific '%s' implementation\"),\n\t \"initialize_gotplt\");\n}\n\n\nstatic void\nld_generic_finalize_plt (struct ld_state *statep, size_t nsym, size_t nsym_dyn,\n\t\t\t struct symbol **ndxtosymp)\n{\n  /* By default we assume that nothing has to be done.  */\n}\n\n\nstatic int\nld_generic_rel_type (struct ld_state *statep)\n{\n  /* This cannot be implemented generally.  There should have been a\n     machine dependent implementation and we should never have arrived\n     here.  */\n  error (EXIT_FAILURE, 0, gettext (\"no machine specific '%s' implementation\"),\n\t \"rel_type\");\n  /* Just to keep the compiler calm.  */\n  return 0;\n}\n\n\nstatic void\nld_generic_count_relocations (struct ld_state *statep, struct scninfo *scninfo)\n{\n  /* This cannot be implemented generally.  There should have been a\n     machine dependent implementation and we should never have arrived\n     here.  */\n  error (EXIT_FAILURE, 0, gettext (\"no machine specific '%s' implementation\"),\n\t \"count_relocations\");\n}\n\n\nstatic void\nld_generic_create_relocations (struct ld_state *statep,\n\t\t\t       const Elf32_Word *dblindirect)\n{\n  /* This cannot be implemented generally.  There should have been a\n     machine dependent implementation and we should never have arrived\n     here.  */\n  error (EXIT_FAILURE, 0, gettext (\"no machine specific '%s' implementation\"),\n\t \"create_relocations\");\n}\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile12.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/funcretval_test_aarch64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebaxmin.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile44.S.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile17.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile2.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile55-32.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-dwzstr.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazminppc64_plr.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/hello_i386.ko.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile61.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile35.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile69.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile8.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.aarch64.exec.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile42.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfileppc32.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazdbg.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-backtrace-demangle.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile68.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile54-32.noshdrs.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile70.exec.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebaztab.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile53-64.prelink.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile54-64.so.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile54-64.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile69.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile66.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/test-core-lib.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile55-64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.s390x.exec.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile18.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/libtestfile_multi_shared.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testcore-rtlib.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_aarch64_core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile20.index.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile5.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile28.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile21.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile44.expect.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-dwfl-report-elf-align-shlib.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/hello_aarch64.ko.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile24.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile52-64.prelink.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile63.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile67.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazdyn.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile37.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_implicit_pointer.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazdbg.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilefoobarbaz.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile4.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile52-64.noshdrs.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile66.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_entry_value.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile29.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.x32.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/linkmap-cut.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/test-offset-loop.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile48.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazmin_plr.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile65.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testarchive64.a.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilenolines.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-inlines.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile34.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile54-32.so.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilearm.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile40.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile15.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile40.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile53-32.prelink.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile52-32.so.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebasmin.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile35.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile62.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazdbgppc64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile36.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazdbg_pl.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile37.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile29.rdwr.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-sizes1.o.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile52-32.prelink.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile26.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile59.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile54-64.noshdrs.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile17.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-zdebug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testlib_dynseg.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile14.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile22.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile60.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile21.index.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazmin.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile7.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazminppc64_pl.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazdbgppc64.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilegdbindex7.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-macros-0xff.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile42_noshdrs.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile19.index.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile23.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfileloc.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/hello_ppc64.ko.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile45.S.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile28.rdwr.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/linkmap-cut.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_multi_main.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile55-64.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebaztabppc64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilemacro.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/test-core.exec.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile3.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-backtrace-demangle.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile13.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile9.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfileppc64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-x32-debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-dwzstr.multi.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile52-32.noshdrs.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-macinfo.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile54-32.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazmdb.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazdbgppc64_pl.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfiles390x.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-x32-s.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/test-offset-loop.alt.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.aarch64.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfileppc32attrs.o.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazdbgppc64_plr.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_i686_core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfiles390.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.s390.exec.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/hello_s390.ko.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazmin_pl.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile54-32.prelink.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_class_func.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/linkmap-cut-lib.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile58.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile56.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile47.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile71.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfiledwarfinlines.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazdynppc64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile51.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-lex-inlines.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile10.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-debug-types.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_low_high_pc.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile49.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-x32-core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-macros.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilegdbindex5.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile31.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile53-64.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-x32.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazminppc64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile53-32.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_implicit_value.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile11.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-x32-d.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfileaarch64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile38.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.i386.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile25.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile32.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile46.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile27.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_multi.dwz.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.x32.exec.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile30.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testcore-rtlib-ppc.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.ppc.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile55-64.prelink.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.x86_64.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile39.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile15.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile53-64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile70.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile50.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile52-32.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile52-64.so.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/debug-ranges-no-lowpc.o.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile41.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.s390x.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile54-64.prelink.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-sizes3.o.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.s390.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile16.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_parameter_ref.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/hello_x86_64.ko.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile55-32.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfiledwarfinlines.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile36.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.x86_64.exec.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_nested_funcs.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/test-core.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.i386.exec.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile20.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile19.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile33.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile55-32.prelink.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile16.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile52-64.so.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/backtrace.ppc.exec.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazdbg_plr.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile43.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile57.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfilebazmdbppc64.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile_const_type.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile53-32.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile45.expect.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile48.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile6.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/tests/testfile-sizes2.o.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/po/en@quot.gmo",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/po/ja.gmo",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/po/en@boldquot.gmo",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/po/uk.gmo",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/po/pl.gmo",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/po/de.gmo",
        "/var/tmp/sochat1/spack-stage/spack-stage-elfutils-0.163-accwjkjn4qtthjk2u3wnvdzvtcqmbhzc/spack-src/po/es.gmo"
    ],
    "total_files": 1082
}