{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/cpp/src/arrow/io/hdfs_internal.cc": "// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n// This shim interface to libhdfs (for runtime shared library loading) has been\n// adapted from the SFrame project, released under the ASF-compatible 3-clause\n// BSD license\n//\n// Using this required having the $JAVA_HOME and $HADOOP_HOME environment\n// variables set, so that libjvm and libhdfs can be located easily\n\n// Copyright (C) 2015 Dato, Inc.\n// All rights reserved.\n//\n// This software may be modified and distributed under the terms\n// of the BSD license. See the LICENSE file for details.\n\n#include \"arrow/io/hdfs_internal.h\"\n\n#include <cstdint>\n#include <cstdlib>\n#include <mutex>\n#include <sstream>  // IWYU pragma: keep\n#include <string>\n#include <vector>\n\n#ifndef _WIN32\n#include <dlfcn.h>\n#endif\n\n#include <boost/filesystem.hpp>  // NOLINT\n\n#include \"arrow/status.h\"\n#include \"arrow/util/logging.h\"\n\nnamespace fs = boost::filesystem;\n\n#ifndef _WIN32\nstatic void* libjvm_handle = NULL;\n#else\nstatic HINSTANCE libjvm_handle = NULL;\n#endif\n/*\n * All the shim pointers\n */\n\n// Helper functions for dlopens\nstatic std::vector<fs::path> get_potential_libjvm_paths();\nstatic std::vector<fs::path> get_potential_libhdfs_paths();\nstatic std::vector<fs::path> get_potential_libhdfs3_paths();\nstatic arrow::Status try_dlopen(std::vector<fs::path> potential_paths, const char* name,\n#ifndef _WIN32\n                                void*& out_handle);\n#else\n                                HINSTANCE& out_handle);\n#endif\n\nstatic std::vector<fs::path> get_potential_libhdfs_paths() {\n  std::vector<fs::path> libhdfs_potential_paths;\n  std::string file_name;\n\n// OS-specific file name\n#ifdef _WIN32\n  file_name = \"hdfs.dll\";\n#elif __APPLE__\n  file_name = \"libhdfs.dylib\";\n#else\n  file_name = \"libhdfs.so\";\n#endif\n\n  // Common paths\n  std::vector<fs::path> search_paths = {fs::path(\"\"), fs::path(\".\")};\n\n  // Path from environment variable\n  const char* hadoop_home = std::getenv(\"HADOOP_HOME\");\n  if (hadoop_home != nullptr) {\n    auto path = fs::path(hadoop_home) / \"lib/native\";\n    search_paths.push_back(path);\n  }\n\n  const char* libhdfs_dir = std::getenv(\"ARROW_LIBHDFS_DIR\");\n  if (libhdfs_dir != nullptr) {\n    search_paths.push_back(fs::path(libhdfs_dir));\n  }\n\n  // All paths with file name\n  for (auto& path : search_paths) {\n    libhdfs_potential_paths.push_back(path / file_name);\n  }\n\n  return libhdfs_potential_paths;\n}\n\nstatic std::vector<fs::path> get_potential_libhdfs3_paths() {\n  std::vector<fs::path> potential_paths;\n  std::string file_name;\n\n// OS-specific file name\n#ifdef _WIN32\n  file_name = \"hdfs3.dll\";\n#elif __APPLE__\n  file_name = \"libhdfs3.dylib\";\n#else\n  file_name = \"libhdfs3.so\";\n#endif\n\n  // Common paths\n  std::vector<fs::path> search_paths = {fs::path(\"\"), fs::path(\".\")};\n\n  const char* libhdfs3_dir = std::getenv(\"ARROW_LIBHDFS3_DIR\");\n  if (libhdfs3_dir != nullptr) {\n    search_paths.push_back(fs::path(libhdfs3_dir));\n  }\n\n  // All paths with file name\n  for (auto& path : search_paths) {\n    potential_paths.push_back(path / file_name);\n  }\n\n  return potential_paths;\n}\n\nstatic std::vector<fs::path> get_potential_libjvm_paths() {\n  std::vector<fs::path> libjvm_potential_paths;\n\n  std::vector<fs::path> search_prefixes;\n  std::vector<fs::path> search_suffixes;\n  std::string file_name;\n\n// From heuristics\n#ifdef __WIN32\n  search_prefixes = {\"\"};\n  search_suffixes = {\"/jre/bin/server\", \"/bin/server\"};\n  file_name = \"jvm.dll\";\n#elif __APPLE__\n  search_prefixes = {\"\"};\n  search_suffixes = {\"\", \"/jre/lib/server\", \"/lib/server\"};\n  file_name = \"libjvm.dylib\";\n\n// SFrame uses /usr/libexec/java_home to find JAVA_HOME; for now we are\n// expecting users to set an environment variable\n#else\n  search_prefixes = {\n      \"/usr/lib/jvm/default-java\",                // ubuntu / debian distros\n      \"/usr/lib/jvm/java\",                        // rhel6\n      \"/usr/lib/jvm\",                             // centos6\n      \"/usr/lib64/jvm\",                           // opensuse 13\n      \"/usr/local/lib/jvm/default-java\",          // alt ubuntu / debian distros\n      \"/usr/local/lib/jvm/java\",                  // alt rhel6\n      \"/usr/local/lib/jvm\",                       // alt centos6\n      \"/usr/local/lib64/jvm\",                     // alt opensuse 13\n      \"/usr/local/lib/jvm/java-8-openjdk-amd64\",  // alt ubuntu / debian distros\n      \"/usr/lib/jvm/java-8-openjdk-amd64\",        // alt ubuntu / debian distros\n      \"/usr/local/lib/jvm/java-7-openjdk-amd64\",  // alt ubuntu / debian distros\n      \"/usr/lib/jvm/java-7-openjdk-amd64\",        // alt ubuntu / debian distros\n      \"/usr/local/lib/jvm/java-6-openjdk-amd64\",  // alt ubuntu / debian distros\n      \"/usr/lib/jvm/java-6-openjdk-amd64\",        // alt ubuntu / debian distros\n      \"/usr/lib/jvm/java-7-oracle\",               // alt ubuntu\n      \"/usr/lib/jvm/java-8-oracle\",               // alt ubuntu\n      \"/usr/lib/jvm/java-6-oracle\",               // alt ubuntu\n      \"/usr/local/lib/jvm/java-7-oracle\",         // alt ubuntu\n      \"/usr/local/lib/jvm/java-8-oracle\",         // alt ubuntu\n      \"/usr/local/lib/jvm/java-6-oracle\",         // alt ubuntu\n      \"/usr/lib/jvm/default\",                     // alt centos\n      \"/usr/java/latest\",                         // alt centos\n  };\n  search_suffixes = {\"\", \"/jre/lib/amd64/server\", \"/lib/amd64/server\"};\n  file_name = \"libjvm.so\";\n#endif\n  // From direct environment variable\n  char* env_value = NULL;\n  if ((env_value = getenv(\"JAVA_HOME\")) != NULL) {\n    search_prefixes.insert(search_prefixes.begin(), env_value);\n  }\n\n  // Generate cross product between search_prefixes, search_suffixes, and file_name\n  for (auto& prefix : search_prefixes) {\n    for (auto& suffix : search_suffixes) {\n      auto path = (fs::path(prefix) / fs::path(suffix) / fs::path(file_name));\n      libjvm_potential_paths.push_back(path);\n    }\n  }\n\n  return libjvm_potential_paths;\n}\n\n#ifndef _WIN32\nstatic arrow::Status try_dlopen(std::vector<fs::path> potential_paths, const char* name,\n                                void*& out_handle) {\n  std::vector<std::string> error_messages;\n\n  for (auto& i : potential_paths) {\n    i.make_preferred();\n    out_handle = dlopen(i.native().c_str(), RTLD_NOW | RTLD_LOCAL);\n\n    if (out_handle != NULL) {\n      // std::cout << \"Loaded \" << i << std::endl;\n      break;\n    } else {\n      const char* err_msg = dlerror();\n      if (err_msg != NULL) {\n        error_messages.push_back(std::string(err_msg));\n      } else {\n        error_messages.push_back(std::string(\" returned NULL\"));\n      }\n    }\n  }\n\n  if (out_handle == NULL) {\n    return arrow::Status::IOError(\"Unable to load \", name);\n  }\n\n  return arrow::Status::OK();\n}\n\n#else\nstatic arrow::Status try_dlopen(std::vector<fs::path> potential_paths, const char* name,\n                                HINSTANCE& out_handle) {\n  std::vector<std::string> error_messages;\n\n  for (auto& i : potential_paths) {\n    i.make_preferred();\n    out_handle = LoadLibrary(i.string().c_str());\n\n    if (out_handle != NULL) {\n      break;\n    } else {\n      // error_messages.push_back(get_last_err_str(GetLastError()));\n    }\n  }\n\n  if (out_handle == NULL) {\n    return arrow::Status::IOError(\"Unable to load \", name);\n  }\n\n  return arrow::Status::OK();\n}\n#endif  // _WIN32\n\nstatic inline void* GetLibrarySymbol(void* handle, const char* symbol) {\n  if (handle == NULL) return NULL;\n#ifndef _WIN32\n  return dlsym(handle, symbol);\n#else\n\n  void* ret = reinterpret_cast<void*>(\n      GetProcAddress(reinterpret_cast<HINSTANCE>(handle), symbol));\n  if (ret == NULL) {\n    // logstream(LOG_INFO) << \"GetProcAddress error: \"\n    //                     << get_last_err_str(GetLastError()) << std::endl;\n  }\n  return ret;\n#endif\n}\n\n#define GET_SYMBOL_REQUIRED(SHIM, SYMBOL_NAME)                         \\\n  do {                                                                 \\\n    if (!SHIM->SYMBOL_NAME) {                                          \\\n      *reinterpret_cast<void**>(&SHIM->SYMBOL_NAME) =                  \\\n          GetLibrarySymbol(SHIM->handle, \"\" #SYMBOL_NAME);             \\\n    }                                                                  \\\n    if (!SHIM->SYMBOL_NAME)                                            \\\n      return Status::IOError(\"Getting symbol \" #SYMBOL_NAME \"failed\"); \\\n  } while (0)\n\n#define GET_SYMBOL(SHIM, SYMBOL_NAME)                    \\\n  if (!SHIM->SYMBOL_NAME) {                              \\\n    *reinterpret_cast<void**>(&SHIM->SYMBOL_NAME) =      \\\n        GetLibrarySymbol(SHIM->handle, \"\" #SYMBOL_NAME); \\\n  }\n\nnamespace arrow {\nnamespace io {\nnamespace internal {\n\nstatic LibHdfsShim libhdfs_shim;\nstatic LibHdfsShim libhdfs3_shim;\n\nhdfsBuilder* LibHdfsShim::NewBuilder(void) { return this->hdfsNewBuilder(); }\n\nvoid LibHdfsShim::BuilderSetNameNode(hdfsBuilder* bld, const char* nn) {\n  this->hdfsBuilderSetNameNode(bld, nn);\n}\n\nvoid LibHdfsShim::BuilderSetNameNodePort(hdfsBuilder* bld, tPort port) {\n  this->hdfsBuilderSetNameNodePort(bld, port);\n}\n\nvoid LibHdfsShim::BuilderSetUserName(hdfsBuilder* bld, const char* userName) {\n  this->hdfsBuilderSetUserName(bld, userName);\n}\n\nvoid LibHdfsShim::BuilderSetKerbTicketCachePath(hdfsBuilder* bld,\n                                                const char* kerbTicketCachePath) {\n  this->hdfsBuilderSetKerbTicketCachePath(bld, kerbTicketCachePath);\n}\n\nvoid LibHdfsShim::BuilderSetForceNewInstance(hdfsBuilder* bld) {\n  this->hdfsBuilderSetForceNewInstance(bld);\n}\n\nhdfsFS LibHdfsShim::BuilderConnect(hdfsBuilder* bld) {\n  return this->hdfsBuilderConnect(bld);\n}\n\nint LibHdfsShim::BuilderConfSetStr(hdfsBuilder* bld, const char* key, const char* val) {\n  return this->hdfsBuilderConfSetStr(bld, key, val);\n}\n\nint LibHdfsShim::Disconnect(hdfsFS fs) { return this->hdfsDisconnect(fs); }\n\nhdfsFile LibHdfsShim::OpenFile(hdfsFS fs, const char* path, int flags, int bufferSize,\n                               short replication, tSize blocksize) {  // NOLINT\n  return this->hdfsOpenFile(fs, path, flags, bufferSize, replication, blocksize);\n}\n\nint LibHdfsShim::CloseFile(hdfsFS fs, hdfsFile file) {\n  return this->hdfsCloseFile(fs, file);\n}\n\nint LibHdfsShim::Exists(hdfsFS fs, const char* path) {\n  return this->hdfsExists(fs, path);\n}\n\nint LibHdfsShim::Seek(hdfsFS fs, hdfsFile file, tOffset desiredPos) {\n  return this->hdfsSeek(fs, file, desiredPos);\n}\n\ntOffset LibHdfsShim::Tell(hdfsFS fs, hdfsFile file) { return this->hdfsTell(fs, file); }\n\ntSize LibHdfsShim::Read(hdfsFS fs, hdfsFile file, void* buffer, tSize length) {\n  return this->hdfsRead(fs, file, buffer, length);\n}\n\nbool LibHdfsShim::HasPread() {\n  GET_SYMBOL(this, hdfsPread);\n  return this->hdfsPread != nullptr;\n}\n\ntSize LibHdfsShim::Pread(hdfsFS fs, hdfsFile file, tOffset position, void* buffer,\n                         tSize length) {\n  GET_SYMBOL(this, hdfsPread);\n  DCHECK(this->hdfsPread);\n  return this->hdfsPread(fs, file, position, buffer, length);\n}\n\ntSize LibHdfsShim::Write(hdfsFS fs, hdfsFile file, const void* buffer, tSize length) {\n  return this->hdfsWrite(fs, file, buffer, length);\n}\n\nint LibHdfsShim::Flush(hdfsFS fs, hdfsFile file) { return this->hdfsFlush(fs, file); }\n\nint LibHdfsShim::Available(hdfsFS fs, hdfsFile file) {\n  GET_SYMBOL(this, hdfsAvailable);\n  if (this->hdfsAvailable)\n    return this->hdfsAvailable(fs, file);\n  else\n    return 0;\n}\n\nint LibHdfsShim::Copy(hdfsFS srcFS, const char* src, hdfsFS dstFS, const char* dst) {\n  GET_SYMBOL(this, hdfsCopy);\n  if (this->hdfsCopy)\n    return this->hdfsCopy(srcFS, src, dstFS, dst);\n  else\n    return 0;\n}\n\nint LibHdfsShim::Move(hdfsFS srcFS, const char* src, hdfsFS dstFS, const char* dst) {\n  GET_SYMBOL(this, hdfsMove);\n  if (this->hdfsMove)\n    return this->hdfsMove(srcFS, src, dstFS, dst);\n  else\n    return 0;\n}\n\nint LibHdfsShim::Delete(hdfsFS fs, const char* path, int recursive) {\n  return this->hdfsDelete(fs, path, recursive);\n}\n\nint LibHdfsShim::Rename(hdfsFS fs, const char* oldPath, const char* newPath) {\n  GET_SYMBOL(this, hdfsRename);\n  if (this->hdfsRename)\n    return this->hdfsRename(fs, oldPath, newPath);\n  else\n    return 0;\n}\n\nchar* LibHdfsShim::GetWorkingDirectory(hdfsFS fs, char* buffer, size_t bufferSize) {\n  GET_SYMBOL(this, hdfsGetWorkingDirectory);\n  if (this->hdfsGetWorkingDirectory) {\n    return this->hdfsGetWorkingDirectory(fs, buffer, bufferSize);\n  } else {\n    return NULL;\n  }\n}\n\nint LibHdfsShim::SetWorkingDirectory(hdfsFS fs, const char* path) {\n  GET_SYMBOL(this, hdfsSetWorkingDirectory);\n  if (this->hdfsSetWorkingDirectory) {\n    return this->hdfsSetWorkingDirectory(fs, path);\n  } else {\n    return 0;\n  }\n}\n\nint LibHdfsShim::MakeDirectory(hdfsFS fs, const char* path) {\n  return this->hdfsCreateDirectory(fs, path);\n}\n\nint LibHdfsShim::SetReplication(hdfsFS fs, const char* path, int16_t replication) {\n  GET_SYMBOL(this, hdfsSetReplication);\n  if (this->hdfsSetReplication) {\n    return this->hdfsSetReplication(fs, path, replication);\n  } else {\n    return 0;\n  }\n}\n\nhdfsFileInfo* LibHdfsShim::ListDirectory(hdfsFS fs, const char* path, int* numEntries) {\n  return this->hdfsListDirectory(fs, path, numEntries);\n}\n\nhdfsFileInfo* LibHdfsShim::GetPathInfo(hdfsFS fs, const char* path) {\n  return this->hdfsGetPathInfo(fs, path);\n}\n\nvoid LibHdfsShim::FreeFileInfo(hdfsFileInfo* hdfsFileInfo, int numEntries) {\n  this->hdfsFreeFileInfo(hdfsFileInfo, numEntries);\n}\n\nchar*** LibHdfsShim::GetHosts(hdfsFS fs, const char* path, tOffset start,\n                              tOffset length) {\n  GET_SYMBOL(this, hdfsGetHosts);\n  if (this->hdfsGetHosts) {\n    return this->hdfsGetHosts(fs, path, start, length);\n  } else {\n    return NULL;\n  }\n}\n\nvoid LibHdfsShim::FreeHosts(char*** blockHosts) {\n  GET_SYMBOL(this, hdfsFreeHosts);\n  if (this->hdfsFreeHosts) {\n    this->hdfsFreeHosts(blockHosts);\n  }\n}\n\ntOffset LibHdfsShim::GetDefaultBlockSize(hdfsFS fs) {\n  GET_SYMBOL(this, hdfsGetDefaultBlockSize);\n  if (this->hdfsGetDefaultBlockSize) {\n    return this->hdfsGetDefaultBlockSize(fs);\n  } else {\n    return 0;\n  }\n}\n\ntOffset LibHdfsShim::GetCapacity(hdfsFS fs) { return this->hdfsGetCapacity(fs); }\n\ntOffset LibHdfsShim::GetUsed(hdfsFS fs) { return this->hdfsGetUsed(fs); }\n\nint LibHdfsShim::Chown(hdfsFS fs, const char* path, const char* owner,\n                       const char* group) {\n  return this->hdfsChown(fs, path, owner, group);\n}\n\nint LibHdfsShim::Chmod(hdfsFS fs, const char* path, short mode) {  // NOLINT\n  return this->hdfsChmod(fs, path, mode);\n}\n\nint LibHdfsShim::Utime(hdfsFS fs, const char* path, tTime mtime, tTime atime) {\n  GET_SYMBOL(this, hdfsUtime);\n  if (this->hdfsUtime) {\n    return this->hdfsUtime(fs, path, mtime, atime);\n  } else {\n    return 0;\n  }\n}\n\nStatus LibHdfsShim::GetRequiredSymbols() {\n  GET_SYMBOL_REQUIRED(this, hdfsNewBuilder);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetNameNode);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetNameNodePort);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetUserName);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetKerbTicketCachePath);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderSetForceNewInstance);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderConfSetStr);\n  GET_SYMBOL_REQUIRED(this, hdfsBuilderConnect);\n  GET_SYMBOL_REQUIRED(this, hdfsCreateDirectory);\n  GET_SYMBOL_REQUIRED(this, hdfsDelete);\n  GET_SYMBOL_REQUIRED(this, hdfsDisconnect);\n  GET_SYMBOL_REQUIRED(this, hdfsExists);\n  GET_SYMBOL_REQUIRED(this, hdfsFreeFileInfo);\n  GET_SYMBOL_REQUIRED(this, hdfsGetCapacity);\n  GET_SYMBOL_REQUIRED(this, hdfsGetUsed);\n  GET_SYMBOL_REQUIRED(this, hdfsGetPathInfo);\n  GET_SYMBOL_REQUIRED(this, hdfsListDirectory);\n  GET_SYMBOL_REQUIRED(this, hdfsChown);\n  GET_SYMBOL_REQUIRED(this, hdfsChmod);\n\n  // File methods\n  GET_SYMBOL_REQUIRED(this, hdfsCloseFile);\n  GET_SYMBOL_REQUIRED(this, hdfsFlush);\n  GET_SYMBOL_REQUIRED(this, hdfsOpenFile);\n  GET_SYMBOL_REQUIRED(this, hdfsRead);\n  GET_SYMBOL_REQUIRED(this, hdfsSeek);\n  GET_SYMBOL_REQUIRED(this, hdfsTell);\n  GET_SYMBOL_REQUIRED(this, hdfsWrite);\n\n  return Status::OK();\n}\n\nStatus ConnectLibHdfs(LibHdfsShim** driver) {\n  static std::mutex lock;\n  std::lock_guard<std::mutex> guard(lock);\n\n  LibHdfsShim* shim = &libhdfs_shim;\n\n  static bool shim_attempted = false;\n  if (!shim_attempted) {\n    shim_attempted = true;\n\n    shim->Initialize();\n\n    std::vector<fs::path> libjvm_potential_paths = get_potential_libjvm_paths();\n    RETURN_NOT_OK(try_dlopen(libjvm_potential_paths, \"libjvm\", libjvm_handle));\n\n    std::vector<fs::path> libhdfs_potential_paths = get_potential_libhdfs_paths();\n    RETURN_NOT_OK(try_dlopen(libhdfs_potential_paths, \"libhdfs\", shim->handle));\n  } else if (shim->handle == nullptr) {\n    return Status::IOError(\"Prior attempt to load libhdfs failed\");\n  }\n\n  *driver = shim;\n  return shim->GetRequiredSymbols();\n}\n\nStatus ConnectLibHdfs3(LibHdfsShim** driver) {\n  static std::mutex lock;\n  std::lock_guard<std::mutex> guard(lock);\n\n  LibHdfsShim* shim = &libhdfs3_shim;\n\n  static bool shim_attempted = false;\n  if (!shim_attempted) {\n    shim_attempted = true;\n\n    shim->Initialize();\n\n    std::vector<fs::path> libhdfs3_potential_paths = get_potential_libhdfs3_paths();\n    RETURN_NOT_OK(try_dlopen(libhdfs3_potential_paths, \"libhdfs3\", shim->handle));\n  } else if (shim->handle == nullptr) {\n    return Status::IOError(\"Prior attempt to load libhdfs3 failed\");\n  }\n\n  *driver = shim;\n  return shim->GetRequiredSymbols();\n}\n\n}  // namespace internal\n}  // namespace io\n}  // namespace arrow\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/ruby/red-arrow/image/red-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/ruby/red-arrow/test/fixture/TestOrcFile.test1.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/c_glib/test/fixture/TestOrcFile.test1.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.testDate1900.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.emptyFile.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.testDate1900.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.test1.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.emptyFile.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/orc/TestOrcFile.test1.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/orc/decimal.orc",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/orc/decimal.jsn.gz",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.some-named-index.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.column-metadata-handling.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/python/pyarrow/tests/data/parquet/v0.7.1.all-named-index.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/r/inst/v0.7.1.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/docs/source/format/Arrow.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/docs/source/format/Arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-arrow-0.15.1-qrjsv2s66yiymqvlcfngdsgbjhdozxnj/spack-src/csharp/ApacheArrow.snk"
    ],
    "total_files": 3867
}