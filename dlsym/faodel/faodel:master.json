{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-faodel-master-nbn6fldiwnivfu4orgu7llac2343f6cb/spack-src/tpl/gperftools/src/malloc_hook_mmap_freebsd.h": "// -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*-\n// Copyright (c) 2011, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Override mmap/munmap/mremap/sbrk to provide support for calling the\n// related hooks (in addition, of course, to doing what these\n// functions normally do).\n\n#ifndef __FreeBSD__\n# error Should only be including malloc_hook_mmap_freebsd.h on FreeBSD systems.\n#endif\n\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <errno.h>\n#include <dlfcn.h>\n\n// Make sure mmap doesn't get #define'd away by <sys/mman.h>\n#undef mmap\n\n// According to the FreeBSD documentation, use syscall if you do not\n// need 64-bit alignment otherwise use __syscall. Indeed, syscall\n// doesn't work correctly in most situations on 64-bit. It's return\n// type is 'int' so for things like SYS_mmap, it actually truncates\n// the returned address to 32-bits.\n#if defined(__amd64__) || defined(__x86_64__)\n# define MALLOC_HOOK_SYSCALL __syscall\n#else\n# define MALLOC_HOOK_SYSCALL syscall\n#endif\n\n\nextern \"C\" {\n  void* mmap(void *start, size_t length,int prot, int flags,\n             int fd, off_t offset) __THROW\n    ATTRIBUTE_SECTION(malloc_hook);\n  int munmap(void* start, size_t length) __THROW\n    ATTRIBUTE_SECTION(malloc_hook);\n  void* sbrk(intptr_t increment) __THROW\n    ATTRIBUTE_SECTION(malloc_hook);\n}\n\nstatic inline void* do_mmap(void *start, size_t length,\n                            int prot, int flags,\n                            int fd, off_t offset) __THROW {\n  return (void *)MALLOC_HOOK_SYSCALL(SYS_mmap,\n                                     start, length, prot, flags, fd, offset);\n}\n\nstatic inline void* do_sbrk(intptr_t increment) {\n  static void *(*libc_sbrk)(intptr_t);\n  if (libc_sbrk == NULL)\n    libc_sbrk = (void *(*)(intptr_t))dlsym(RTLD_NEXT, \"sbrk\");\n\n  return libc_sbrk(increment);\n}\n\n\nextern \"C\" void* mmap(void *start, size_t length, int prot, int flags,\n                      int fd, off_t offset) __THROW {\n  MallocHook::InvokePreMmapHook(start, length, prot, flags, fd, offset);\n  void *result;\n  if (!MallocHook::InvokeMmapReplacement(\n          start, length, prot, flags, fd, offset, &result)) {\n    result = do_mmap(start, length, prot, flags, fd,\n                       static_cast<size_t>(offset)); // avoid sign extension\n  }\n  MallocHook::InvokeMmapHook(result, start, length, prot, flags, fd, offset);\n  return result;\n}\n\nextern \"C\" int munmap(void* start, size_t length) __THROW {\n  MallocHook::InvokeMunmapHook(start, length);\n  int result;\n  if (!MallocHook::InvokeMunmapReplacement(start, length, &result)) {\n    result = MALLOC_HOOK_SYSCALL(SYS_munmap, start, length);\n  }\n\n  return result;\n}\n\nextern \"C\" void* sbrk(intptr_t increment) __THROW {\n  MallocHook::InvokePreSbrkHook(increment);\n  void *result = do_sbrk(increment);\n  MallocHook::InvokeSbrkHook(result, increment);\n  return result;\n}\n\n/*static*/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,\n                                         int flags, int fd, off_t offset) {\n  void* result;\n  if (!MallocHook::InvokeMmapReplacement(\n\t  start, length, prot, flags, fd, offset, &result)) {\n    result = do_mmap(start, length, prot, flags, fd, offset);\n  }\n\n  return result;\n}\n\n/*static*/int MallocHook::UnhookedMUnmap(void *start, size_t length) {\n  int result;\n  if (!MallocHook::InvokeMunmapReplacement(start, length, &result)) {\n    result = MALLOC_HOOK_SYSCALL(SYS_munmap, start, length);\n  }\n  return result;\n}\n\n#undef MALLOC_HOOK_SYSCALL\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-faodel-master-nbn6fldiwnivfu4orgu7llac2343f6cb/spack-src/.git/objects/pack/pack-67cb45d051b30c9fa44cffc0cf37cb0c6beb8c2b.idx",
        "/tmp/vanessa/spack-stage/spack-stage-faodel-master-nbn6fldiwnivfu4orgu7llac2343f6cb/spack-src/.git/objects/pack/pack-67cb45d051b30c9fa44cffc0cf37cb0c6beb8c2b.pack"
    ],
    "total_files": 1118
}