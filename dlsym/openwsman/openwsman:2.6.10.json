{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.10-chdwbyn653qtqjlgbkkqerjcig3rssow/spack-src/src/lib/wsman-server-api.c": "/*******************************************************************************\n * Copyright (C) 2004-2006 Intel Corp. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  - Neither the name of Intel Corp. nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *******************************************************************************/\n\n/**\n * @author Vadim Revyakin\n */\n#ifdef HAVE_CONFIG_H\n#include <wsman_config.h>\n#endif\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n\n#include \"u/libu.h\"\n#include \"wsman-types.h\"\n#include \"wsman-faults.h\"\n#include \"wsman-soap-message.h\"\n#include \"wsman-server-api.h\"\n#include \"wsman-server.h\"\n#include \"wsman-dispatcher.h\"\n#include \"wsman-soap.h\"\n#include \"wsman-plugins.h\"\n#ifdef ENABLE_EVENTING_SUPPORT\n#include \"wsman-cimindication-processor.h\"\nstatic char *uri_subsRepository;\n#endif\n#if 0\nstatic void\ndebug_message_handler(const char *str,\n\t\t      debug_level_e level, void *user_data)\n{\n\n\tint log_pid = getpid();\n\n\tchar *log_name = u_strdup_printf(\"wsmand[%d]\", log_pid);\n\n\topenlog(log_name, 0, LOG_DAEMON);\n\tsyslog(LOG_INFO, \"%s\", str);\n\tcloselog();\n\tu_free(log_name);\n}\n#endif\n\nvoid wsman_server_read_plugin_config(void *arg, char *config_file)\n{\n\tlnode_t *node;\n\tSoapH soap = (SoapH) arg;\n\tWsManListenerH * listener = (WsManListenerH *)soap->listener;\n\tif (config_file) {\n\t\tdebug(\"reading config file 2\");\n\t\tdictionary *ini;\n\t\tini = iniparser_new(config_file);\n\t\tif (ini) {\n\t\t\tlistener->config = ini;\n\t\t}\n\t}\n\tnode = list_first(listener->plugins);\n\twhile (node) {\n\t\tWsManPlugin *p = (WsManPlugin *) node->list_data;\n\t\tp->set_config = dlsym(p->p_handle, \"set_config\");\n\t\tif (listener->config && p->set_config) {\n\t\t\tp->set_config(p->p_handle, listener->config);\n\t\t} else {\n\t\t\tdebug(\"no configuration available for plugin: %s\", p->p_name);\n\t\t}\n\t\tnode = list_next(listener->plugins, node);\n\t}\n}\n\n/*\n * Create server config (from ini-style config file)\n *\n * call wsman_server_destroy_config() to de-allocate the returned pointer\n *\n */\n\nServerConfig *wsman_server_create_config(char *config_file)\n{\n\tSoapH soap = NULL;\n\tdictionary *ini;\n\tWsManListenerH *listener = wsman_dispatch_list_new();\n\tWsContextH cntx;\n\n\tif (config_file) {\n\t\tdebug(\"reading config file 1\");\n\t\tini = iniparser_new(config_file);\n\t\tif (ini) {\n\t\t\tlistener->config = ini;\n\t\t}\n\t}\n\tcntx = wsman_init_plugins(listener);\n\tif (cntx != NULL) {\n\t\tsoap = ws_context_get_runtime(cntx);\n\t\tif (listener)\n\t\t\tsoap->listener = (WsManListenerH *)listener;\n\t} else {\n\t\tu_free(listener);\n\t}\n\t//debug_add_handler (debug_message_handler, DEBUG_LEVEL_ALWAYS, NULL);\n\treturn (ServerConfig *)soap;\n}\n\n\nvoid wsman_server_destroy_config(ServerConfig *config)\n{\n  SoapH soap = (SoapH)config;\n  if (soap == NULL)\n    return;\n  if (soap->listener) {\n#if 0\n    if (soap->listener->config) {\n      iniparser_free(soap->listener->config);\n    }\n#endif\n    u_free(soap->listener);\n  }\n  soap_destroy(soap);\n}\n\n\nvoid wsman_server_get_response(void *arg, void *msg)\n{\n\tSoapH soap = (SoapH) arg;\n\n\tdispatch_inbound_call(soap,(WsmanMessage *)msg, NULL);\n}\n#ifdef ENABLE_EVENTING_SUPPORT\nvoid wsman_server_set_subscription_repos(char *repos)\n{\n\turi_subsRepository = u_strdup(repos);\n}\n\nvoid *wsman_server_get_subscription_repos()\n{\n\treturn uri_subsRepository;\n}\n\nvoid wsman_event_init(void *arg)\n{\n\tSoapH soap = (SoapH)arg;\n\tWsContextH cntx = soap->cntx;\n\tSubsRepositoryOpSetH ops = wsman_init_subscription_repository(cntx, (char *)wsman_server_get_subscription_repos());\n\tlist_t *subs_list = list_create(-1);\n\tdebug(\"subscription_repository_uri = %s\", soap->uri_subsRepository);\n\tif(ops->load_subscription(soap->uri_subsRepository, subs_list) == 0) {\n\t\tlnode_t *node = list_first(subs_list);\n\t\twhile(node) {\n\t\t\tSubsRepositoryEntryH entry = (SubsRepositoryEntryH)node->list_data;\n\t\t\tif(wsman_clean_subsrepository(cntx->soap, entry) == 0) {\n\t\t\t\tdebug(\"load subscription %s\", entry->uuid);\n\t\t\t\twsman_repos_notification_dispatcher(cntx, entry, list_count(cntx->subscriptionMemList));\n\t\t\t}\n\t\t\telse\n\t\t\t\tu_free(entry->strdoc);\n\t\t\tu_free(entry->uuid);\n\t\t\tu_free(entry);\n\t\t\tlist_delete(subs_list, node);\n\t\t\tlnode_destroy(node);\n\t\t\tnode = list_first(subs_list);\n\t\t}\n\t}\n\tlist_destroy(subs_list);\n\twsman_init_event_pool(cntx, NULL);\n}\n\nvoid wsman_receive_cim_indication(void *arg, char *uuid, void *msg)\n{\n\tSoapH soap = (SoapH) arg;\n\tCimxmlMessage *cimxml_msg = msg;\n\tcimxml_context *cntx = NULL;\n\tcntx = u_malloc(sizeof(cimxml_context));\n\tcntx->soap = soap;\n\tcntx->uuid = uuid;\n\tCIM_Indication_call(cntx, cimxml_msg, NULL);\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.10-chdwbyn653qtqjlgbkkqerjcig3rssow/spack-src/src/lib/wsman-server.c": "/*******************************************************************************\n * Copyright (C) 2004-2006 Intel Corp. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  - Neither the name of Intel Corp. nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *******************************************************************************/\n\n/**\n * @author Anas Nashif\n * @author Liang Hou\n */\n#ifdef HAVE_CONFIG_H\n#include \"wsman_config.h\"\n#endif\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <string.h>\n#ifdef HAVE_PTHREAD_H\n#include <pthread.h>\n#endif\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n#include \"u/libu.h\"\n#if 0\n#include \"wsman-faults.h\"\n#include \"wsman-xml.h\"\n#include \"wsman-plugins.h\"\n#include \"wsman-server.h\"\n#include \"wsman-dispatcher.h\"\n#endif\n#include \"wsman-soap.h\"\n#include \"wsman-soap-envelope.h\"\n#include \"wsman-server.h\"\n#include \"wsman-xml.h\"\n#include \"wsman-dispatcher.h\"\n#include \"wsman-event-pool.h\"\n#include \"wsman-subscription-repository.h\"\n\n\nWsManListenerH *wsman_dispatch_list_new()\n{\n\tWsManListenerH *list =\n\t    (WsManListenerH *) u_malloc(sizeof(WsManListenerH));\n\treturn list;\n}\n\n\nstatic int wsman_server_verify_plugin(WsDispatchInterfaceInfo *ifcinfo)\n{\n\tdebug(\"Plugin '%s', version: %s\", (ifcinfo->displayName), (ifcinfo->version) );\n\tif (strcmp (OPENWSMAN_PLUGIN_API_VERSION, ifcinfo->version) == 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nWsContextH wsman_init_plugins(WsManListenerH * listener)\n{\n\tlist_t *list = list_create(LISTCOUNT_T_MAX);\n\tlnode_t *node;\n\tWsContextH cntx = NULL;\n\tWsDispatchInterfaceInfo *ifcinfo = NULL;\n\twsman_plugins_load(listener);\n\tnode = list_first(listener->plugins);\n\n\twhile (node) {\n\t\tWsManPlugin *p = (WsManPlugin *) node->list_data;\n\t        if (p->init == NULL\n\t\t    || p->init(p->p_handle, &(p->data)) == 0 ) {\n\t\t    error (\"Plugin %s fails init()\", p->p_name);\n\t\t    error(\"invalid plugin\");\n\t\t    goto next_plugin;\n\t\t}\n\t      \n                p->ifc = (WsDispatchInterfaceInfo *)\n                          malloc(sizeof(WsDispatchInterfaceInfo));\n                if (p->ifc == NULL) {\n                  error(\"Memory allocation error while loading plugin\");\n                  return NULL;\n                }\n\t\tifcinfo = p->ifc;\n\t        ifcinfo->extraData = p->data;\n\t\tp->set_config = dlsym(p->p_handle, \"set_config\");\n\n\t\tif (listener->config && p->set_config) {\n\t\t\tp->set_config(p->p_handle, listener->config);\n\t\t} else {\n\t\t\tdebug(\"no configuration available for plugin: %s\", p->p_name);\n\t\t}\n\n\t\tif (p->get_endpoints)\n\t\t\tp->get_endpoints(p->p_handle, p->ifc);\n\n\t\tif (p->ifc && wsman_server_verify_plugin(ifcinfo)) {\n\t\t\tlnode_t *i = lnode_create(p->ifc);\n\t\t\tlist_append(list, i);\n\t\t} else {\n\t\t\terror (\"Plugin '%s' is not compatible with version of the software or plugin is invalid\", p->p_name);\n\t\t\terror(\"invalid plugin\");\n\t\t}\nnext_plugin:\n\t\tnode = list_next(listener->plugins, node);\n\t}\n\tcntx = ws_create_runtime(list);\n\treturn cntx;\n}\n\n#ifdef ENABLE_EVENTING_SUPPORT\nSubsRepositoryOpSetH\nwsman_init_subscription_repository(WsContextH cntx, char *uri)\n{\n\tSoapH soap = ws_context_get_runtime(cntx);\n\tif(soap) {\n\t\tsoap->subscriptionOpSet = wsman_get_subsrepos_opset();\n\t\tif(uri) {\n\t\t\tsoap->uri_subsRepository = u_strdup(uri);\n\t\t\tsoap->subscriptionOpSet->init_subscription(uri, NULL);\n\t\t}\n\t}\n\treturn soap->subscriptionOpSet;\n}\n\nEventPoolOpSetH \nwsman_init_event_pool(WsContextH cntx, void*data)\n{\n\tSoapH soap = ws_context_get_runtime(cntx);\n\tif(soap) {\n\t\tsoap->eventpoolOpSet = wsman_get_eventpool_opset();\n\t\tsoap->eventpoolOpSet->init(NULL);\n\t}\n\treturn soap->eventpoolOpSet;\n}\n\nint wsman_clean_subsrepository(SoapH soap, SubsRepositoryEntryH entry)\n{\n\tint retVal = 0;\n\tWsXmlDocH doc = ws_xml_read_memory( (char *)entry->strdoc, entry->len, \"UTF-8\", 0);\n\tunsigned long expire;\n\tWsmanFaultCodeType fault_code;\n\tif(doc) {\n\t\tWsXmlNodeH node = ws_xml_get_soap_body(doc);\n\t\tif(node) {\n\t\t\tnode = ws_xml_get_child(node, 0, XML_NS_EVENTING, WSEVENT_SUBSCRIBE);\n\t\t\tnode = ws_xml_get_child(node, 0, XML_NS_EVENTING, WSEVENT_EXPIRES);\n\t\t\tif(node == NULL) { //No specified expiration, delete it\n\t\t\t\tdebug(\"subscription %s deleted from the repository\", entry->uuid);\n\t\t\t\tsoap->subscriptionOpSet->delete_subscription(soap->uri_subsRepository, entry->uuid+5);\n\t\t\t\tretVal = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twsman_set_expiretime(node, &expire, &fault_code);\n\t\t\t\tif(fault_code == WSMAN_RC_OK) {\n\t\t\t\t\tif(time_expired(expire)) {\n\t\t\t\t\t\tdebug(\"subscription %s deleted from the repository\", entry->uuid);\n\t\t\t\t\t\tsoap->subscriptionOpSet->delete_subscription(soap->uri_subsRepository, entry->uuid+5);\n\t\t\t\t\t\tretVal = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tws_xml_destroy_doc(doc);\n\t}\n\treturn retVal;\n}\n\nvoid wsman_repos_notification_dispatcher(WsContextH cntx, SubsRepositoryEntryH entry, int subsNum)\n{\n\tWsmanMessage *wsman_msg = wsman_soap_message_new();\n\tif(wsman_msg == NULL) return;\n\tunsigned char *strdoc = entry->strdoc;\n\tu_buf_construct(wsman_msg->request, strdoc, entry->len, entry->len);\n\tdispatch_inbound_call(cntx->soap, wsman_msg, NULL);\n\twsman_soap_message_destroy(wsman_msg);\n\tif(list_count(cntx->subscriptionMemList) > subsNum) {\n\t\tlnode_t *node = list_last(cntx->subscriptionMemList);\n\t\tWsSubscribeInfo *subs = (WsSubscribeInfo *)node->list_data;\n\t\t//Update UUID in the memory\n\t\tstrncpy(subs->subsId, entry->uuid+5, EUIDLEN);\n\t}\n}\n\nvoid *wsman_notification_manager(void *arg)\n{\n\tWsContextH cntx = (WsContextH) arg;\n\tint r;\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cond;\n\tstruct timespec timespec;\n\tstruct timeval tv;\n\n\tif ((r = pthread_cond_init(&cond, NULL)) != 0) {\n\t\terror(\"pthread_cond_init failed = %d\", r);\n\t\treturn NULL;\n\t}\n\tif ((r = pthread_mutex_init(&mutex, NULL)) != 0) {\n\t\terror(\"pthread_mutex_init failed = %d\", r);\n\t\treturn NULL;\n\t}\n\n\twhile (continue_working) {\n\t\tpthread_mutex_lock(&mutex);\n\t\tgettimeofday(&tv, NULL);\n\t\ttimespec.tv_sec = tv.tv_sec + 1;\n\t\ttimespec.tv_nsec = tv.tv_usec * 1000;\n\t\tpthread_cond_timedwait(&cond, &mutex, &timespec);\n\t\tpthread_mutex_unlock(&mutex);\n\t\twse_notification_manager(cntx);\n\t}\n\treturn NULL;\t\n}\n#endif\nvoid *wsman_server_auxiliary_loop_thread(void *arg)\n{\n\tWsContextH cntx = (WsContextH) arg;\n\tint r;\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cond;\n\tstruct timespec timespec;\n\tstruct timeval tv;\n\n\tif ((r = pthread_cond_init(&cond, NULL)) != 0) {\n\t\terror(\"pthread_cond_init failed = %d\", r);\n\t\treturn NULL;\n\t}\n\tif ((r = pthread_mutex_init(&mutex, NULL)) != 0) {\n\t\terror(\"pthread_mutex_init failed = %d\", r);\n\t\treturn NULL;\n\t}\n\n\twhile (continue_working) {\n\t\tpthread_mutex_lock(&mutex);\n\t\tgettimeofday(&tv, NULL);\n\t\ttimespec.tv_sec = tv.tv_sec + 1;\n\t\ttimespec.tv_nsec = tv.tv_usec * 1000;\n\t\tpthread_cond_timedwait(&cond, &mutex, &timespec);\n\t\tpthread_mutex_unlock(&mutex);\n\n\t\twsman_timeouts_manager(cntx, NULL);\n#ifdef ENABLE_EVENTING_SUPPORT\n\t\twsman_heartbeat_generator(cntx, NULL);\n#endif\n\t}\n\treturn NULL;\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.10-chdwbyn653qtqjlgbkkqerjcig3rssow/spack-src/src/lib/wsman-plugins.c": "/*******************************************************************************\n * Copyright (C) 2004-2006 Intel Corp. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  - Neither the name of Intel Corp. nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *******************************************************************************/\n\n/**\n * @author Anas Nashif\n */\n\n\n#ifdef HAVE_CONFIG_H\n#include <wsman_config.h>\n#endif\n\n#include \"stdlib.h\"\n#include \"stdio.h\"\n#include <string.h>\n#ifdef HAVE_DIRENT_H\n#include <dirent.h>\n#endif\n\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n#include \"u/libu.h\"\n#include \"wsman-plugins.h\"\n\n\n\nstatic list_t*\nscan_files_in_dir ( const char *dir, int (*select)(const struct dirent *))\n{\n    struct dirent **namelist;\n    int n;\n    list_t *files = list_create(LISTCOUNT_T_MAX);\n\n    if (0 > (n = scandir (dir, &namelist, 0, alphasort)))\n    {\n        return files;\n    } else {\n        while (n--)\n        {\n\t\t\tlnode_t *node;\n            char *tmp = u_strdup(namelist[n]->d_name);\n            node = lnode_create(tmp);\n            list_append(files, node );\n            //debug(\"plugin file found: %s\", namelist[n]->d_name );\n            u_free(namelist[n]);\n        }\n        u_free(namelist);\n    }\n    return files;\n}\n\n\nstatic WsManPlugin*\nplugin_new(void)\n{\n    WsManPlugin *self = u_malloc(sizeof(WsManPlugin));\n    if (self) {\n        memset(self, 0, sizeof(WsManPlugin));\n    }\n    return self ;\n}\n\nstatic void\nplugin_free(WsManPlugin *self)\n{\n    message( \"Un-loading plugins: %s\", self->p_name );\n\n    if( self->p_handle && self->cleanup ) {\n        (*self->cleanup)( self->p_handle, self->data );\n    }\n    if(self->p_name)\n        u_free(self->p_name);\n    if( self->p_handle )\n        dlclose( self->p_handle );\n}\n\nstatic WsManPluginError\nplugin_init(WsManPlugin *self, const char *p_name)\n{\n    WsManPluginError PluginError = PLUGIN_ERROR_OK ;\n    self->p_name = u_strdup(p_name) ;\n    if (NULL != (self->p_handle = dlopen(p_name, RTLD_LAZY))) {\n        self->init = dlsym(self->p_handle, \"init\");\n        self->get_endpoints = dlsym(self->p_handle, \"get_endpoints\");\n        if ( ! self->get_endpoints\n                && ! self->init)\n        {\n            self->init\t\t\t        = 0 ;\n\t    PluginError = PLUGIN_ERROR_SYMBOLSNOTFOUND ;\n        }\n    } else {\n        PluginError = PLUGIN_ERROR_NOTLOADED ;\n    }\n    return PluginError ;\n}\n\nstatic int\nload_plugin(WsManPlugin *self, const char *p_name)\n{\n    int retv = -1;\n    WsManPluginError err = plugin_init(self, p_name);\n    const char\t*plugin_err = dlerror();\n    message(\"Loading plugin: %s\", p_name );\n\n\tif( NULL == plugin_err )\n        plugin_err = \"\";\n    switch( err )\n    {\n    default:\n        debug(  \"Unable to load plugin %s. Error: %s\", p_name, plugin_err );\n        break;\n    case PLUGIN_ERROR_NOTLOADED:\n        debug( \"Unable to load plugin %s. Error: %s\", p_name, plugin_err );\n        break;\n    case PLUGIN_ERROR_SYMBOLSNOTFOUND:\n        debug( \"Plugin protocol %s unknown Error:%s\", p_name, plugin_err );\n        break;\n    case PLUGIN_ERROR_INITFAILED:\n        debug(\"Unable to start plugin %s\", p_name );\n        break;\n    case PLUGIN_ERROR_BADPARMS:\n        debug( \"Bad parameters to plugin %s. Error: %s\", p_name, plugin_err );\n        break;\n    case PLUGIN_ERROR_OK:\n        retv = 0 ;\n        break;\n    }\n    if( retv < 0  )\n        debug(\"Unable to load plugin %s.Error: %s\", p_name, plugin_err);\n    return retv ;\n}\n\nstatic void\nfree_plugins(list_t * plugin_list)\n{\n\tlnode_t *p;\n    if (plugin_list == NULL) {\n        return;\n    }\n    if (list_isempty(plugin_list)) {\n        return;\n    }\n    p = list_first(plugin_list);\n    while (p) {\n         WsManPlugin *plugin = (WsManPlugin *)p->list_data;\n         plugin_free(plugin);\n         p = list_next(plugin_list, p);\n    }\n    list_destroy_nodes(plugin_list);\n    list_destroy(plugin_list);\n}\n\nstatic int\nselect_all_files (const struct dirent *e)\n{\n    return 1;\n}\n\nstatic void\nscan_plugins_in_directory ( WsManListenerH *listener,\n                            const char *dir_name)\n{\n\tlist_t *files = scan_files_in_dir ( dir_name, select_all_files);\n\tlnode_t *node = list_first(files);\n    listener->plugins = list_create(LISTCOUNT_T_MAX);\n\n    while (node != NULL)\n    {\n        const char* entry_name;\n        int retv = -1;\n        entry_name = (const char*) node->list_data;\n        node = list_next(files, node);\n\n        if ((NULL != entry_name) && strlen (entry_name) > strlen(PLUGIN_EXT)\n                && (0 == strcmp (&entry_name[strlen(entry_name)-strlen(PLUGIN_EXT)], PLUGIN_EXT)))\n        {\n            char *plugin_path = u_strdup_printf (\"%s/%s\", dir_name, entry_name);\n            WsManPlugin *plugin = plugin_new();\n\n            if ((NULL != plugin) && (NULL != plugin_path))\n            {\n                if (load_plugin(plugin, plugin_path) == 0 )\n                {\n                    lnode_t *plg = lnode_create (plugin);\n                    list_append (listener->plugins, plg);\n                    retv = 0 ;\n                }\n            } else {\n                error(\"Out of memory scanning for plugins.\");\n            }\n            if (plugin_path)\n            \tu_free (plugin_path);\n            if (retv != 0  && (NULL != plugin))\n                plugin_free(plugin);\n        }\n    }\n    list_destroy_nodes(files);\n    list_destroy(files);\n    return;\n}\n\nint\nwsman_plugins_load(WsManListenerH *listener)\n{\n    char *plugin_dir = iniparser_getstring(listener->config, \"server:plugin_dir\", PACKAGE_PLUGIN_DIR);\n    debug(\"using plugin directory: %s\", plugin_dir);\n    scan_plugins_in_directory(listener, plugin_dir);\n    return 0;\n}\n\nint\nwsman_plugins_unload(WsManListenerH *listener)\n{\n\n    free_plugins(listener->plugins);\n    // list_destroy(listener->plugins);\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.10-chdwbyn653qtqjlgbkkqerjcig3rssow/spack-src/src/server/wsmand-listener.c": "/*******************************************************************************\n * Copyright (C) 2004-2006 Intel Corp. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  - Neither the name of Intel Corp. nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *******************************************************************************/\n\n/**\n * @author Anas Nashif\n * @author Vadim Revyakin\n * @author Liang Hou\n */\n\n#define _GNU_SOURCE\n#ifdef HAVE_CONFIG_H\n#include \"wsman_config.h\"\n#endif\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <assert.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n\n#include \"u/libu.h\"\n#include \"wsman-xml-api.h\"\n#include \"wsman-soap.h\"\n#include \"wsman-soap-envelope.h\"\n\n#include \"wsman-xml.h\"\n#include \"wsman-xml-serializer.h\"\n#include \"wsman-dispatcher.h\"\n\n\n#include \"shttpd.h\"\n#include \"shttpd/adapter.h\" /* shttpd_get_credentials() */\n#include \"wsman-plugins.h\"\n#include \"wsmand-listener.h\"\n#include \"wsmand-daemon.h\"\n#include \"wsman-server.h\"\n#include \"wsman-server-api.h\"\n#include \"wsman-plugins.h\"\n#ifdef ENABLE_EVENTING_SUPPORT\n#include \"wsman-cimindication-processor.h\"\n#endif\n\n\n#ifdef HAVE_PTHREAD_H\n#include <pthread.h>\n#endif\n#include <sys/socket.h>\n\n\nstatic pthread_mutex_t shttpd_mutex;\nstatic pthread_cond_t shttpd_cond;\nint continue_working = 1;\nstatic int (*basic_callback) (char *, char *) = NULL;\n\nstruct thread {\n    struct thread       *next;\n    struct shttpd_ctx   *ctx;\n};\n\nstatic struct thread    *threads;   /* List of worker threads */\n\ntypedef struct {\n\tchar *response;\n\tint length;\n\tint ind;\n} ShttpMessage;\n\n#ifdef SHTTPD_GSS\nchar * gss_decrypt(struct shttpd_arg *arg, char *data, int len);\nint gss_encrypt(struct shttpd_arg *arg, char *input, int inlen, char **output, int *outlen);\n#endif\n\n/* Check HTTP headers */\nstatic\nint check_request_content_type(struct shttpd_arg *arg) {\n\tconst char *content_type;\n\tint status = WSMAN_STATUS_OK;\n\n\tcontent_type = shttpd_get_header(arg, \"Content-Type\");\n\tif (content_type && strncmp(content_type,\n\t\t\t\t    SOAP_CONTENT_TYPE,\n\t\t\t\t    strlen(SOAP_CONTENT_TYPE)) != 0) {\n\t\tstatus = WSMAN_STATUS_UNSUPPORTED_MEDIA_TYPE;\n\t}\n\treturn status;\n}\n\nstatic\nchar *get_request_encoding(struct shttpd_arg *arg) {\n\tconst char *content_type;\n\tchar *p;\n\tchar *encoding = \"UTF-8\";\n\n\tcontent_type = shttpd_get_header(arg, \"Content-Type\");\n\tif(content_type ) {\n\t\tif(( p = strstr(content_type, \"charset\")) != NULL ) {\n\t\t\tp += strlen(\"charset\");\n\t\t\tp++;\n\t\t\tencoding = p;\n\t\t}\n\t}\n\treturn encoding;\n}\n\nstatic\nvoid server_callback(struct shttpd_arg *arg)\n{\n\tchar *encoding = \"UTF-8\";\n\tconst char  *s;\n\tSoapH soap;\n\tint k;\n\tint status = WSMAN_STATUS_OK;\n\tchar *request_uri;\n\n\tchar *fault_reason = NULL;\n\tstruct state {\n        \tsize_t  cl;     /* Content-Length   */\n\t        size_t  nread;      /* Number of bytes read */\n\t \tu_buf_t *request;\n\t \tchar    *response;\n\t\tsize_t  len;\n\t\tint     index;\n\t\tint     type;\n\t} *state;\n\n\n\t/* If the connection was broken prematurely, cleanup */\n\tif ( (arg->flags & SHTTPD_CONNECTION_ERROR ) && arg->state) {\n        \tfree(arg->state);\n\t\treturn;\n\t} else if ((s = shttpd_get_header(arg, \"Content-Length\")) == NULL) {\n        \tshttpd_printf(arg, \"HTTP/1.0 411 Length Required\\n\\n\");\n\t        arg->flags |= SHTTPD_END_OF_OUTPUT;\n\t\treturn;\n\t} else if (arg->state == NULL) {\n        \t/* New request. Allocate a state structure */\n        \targ->state = state = calloc(1, sizeof(*state));\n\t        state->cl = strtoul(s, NULL, 10);\n\t\tu_buf_create(&(state->request));\n\t}\n\n\tstate = arg->state;\n\tif ( state->response ) {\n\t\tgoto CONTINUE;\n\t}\n\n\tif (state->nread>0 )\n\t\tu_buf_append(state->request, arg->in.buf, arg->in.len);\n\telse\n\t\tu_buf_set(state->request, arg->in.buf, arg->in.len);\n\n\tstate->nread += arg->in.len;\n\targ->in.num_bytes = arg->in.len;\n\tif (state->nread >= state->cl) {\n\t\tdebug(\"Done reading request\");\n\t} else {\n\t\treturn;\n\t}\n#ifdef SHTTPD_GSS\n\tconst char *ct = shttpd_get_header(arg, \"Content-Type\");\n\tchar *payload = 0; // used for gss encrypt\n\n\tif (ct && !memcmp(ct, \"multipart/encrypted\", 19)) {\n\t        // we have a encrypted payload. decrypt it \n        \tpayload = gss_decrypt(arg, u_buf_ptr(state->request), u_buf_len(state->request));\n\t}\n#endif\n\trequest_uri = (char *)shttpd_get_env(arg, \"REQUEST_URI\");\n\tif (strcmp(request_uri, \"/wsman\") == 0 ) {\n\n\t\t/* Here we must handle the initial request */\n\t\tWsmanMessage *wsman_msg = wsman_soap_message_new();\n#ifdef SHTTPD_GSS\n\t        if(payload == 0) {\n#endif\n\t\t\tif ( (status = check_request_content_type(arg) ) != WSMAN_STATUS_OK ) {\n\t\t\t\twsman_soap_message_destroy(wsman_msg);\n\t\t\t\tgoto DONE;\n\t\t\t}\n\t\t\tencoding = get_request_encoding(arg);\n\n\t\t\tu_buf_set(wsman_msg->request, u_buf_ptr(state->request), u_buf_len(state->request));\n#ifdef SHTTPD_GSS\n\t        }\n\t\telse {\n\t\t\tu_buf_set(wsman_msg->request, payload, strlen(payload));\n\t\t}\n#endif\n\t        wsman_msg->charset = u_strdup(encoding);\n\t\tsoap = (SoapH) arg->user_data;\n\t\twsman_msg->status.fault_code = WSMAN_RC_OK;\n\n\t\t/*\n\t\t * some plugins can use credentials for their own authentication\n\t\t * works only with basic authentication\n\t\t */\n\t\tshttpd_get_credentials(arg, &wsman_msg->auth_data.username,\n\t\t\t\t&wsman_msg->auth_data.password);\n\n\t\t/* Call dispatcher. Real request handling */\n\t\tif (status == WSMAN_STATUS_OK) {\n\t\t\t/* dispatch if we didn't find out any error */\n\t\t\tchar *idfile = wsmand_options_get_identify_file();\n\t\t\tif (idfile && wsman_check_identify(wsman_msg) == 1) {\n\t\t\t\tif (u_buf_load(wsman_msg->response, idfile)) {\n\t\t\t\t\tdispatch_inbound_call(soap, wsman_msg, NULL);\n\t\t\t\t\tstatus = wsman_msg->http_code;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatch_inbound_call(soap, wsman_msg, NULL);\n\t\t\t\tstatus = wsman_msg->http_code;\n\t\t\t}\n\t\t}\n\t\tif (wsman_msg->request) {\n#ifdef SHTTPD_GSS\n\t\t\tif (payload) {\n\t\t\t\tfree(payload);\n\t\t\t\t/* note that payload is stiil set - this is used as a flag later */\n\t\t\t}\n\t\t\telse {\n#endif\n\t\t\t\tu_buf_free(wsman_msg->request);\n#ifdef SHTTPD_GSS\n\t\t\t}\n#endif\n\t\t\twsman_msg->request = NULL;\n\t\t}\n\n\t\tstate->len =  u_buf_len(wsman_msg->response);;\n\t\tstate->response = u_buf_steal(wsman_msg->response);\n\t\tstate->index = 0;\n\t\tstate->type = 0;\n\n\t\twsman_soap_message_destroy(wsman_msg);\n#ifdef ENABLE_EVENTING_SUPPORT\n\t} else if (strncmp(request_uri, DEFAULT_CIMINDICATION_PATH, strlen(DEFAULT_CIMINDICATION_PATH)) == 0 ) {\n\t\tstatus = CIMXML_STATUS_OK;\n\t\tint cim_error_code = 0;\n\t\tchar *cim_error = NULL;\n\t\tchar *fault_reason = NULL;\n\t\tchar *uuid = NULL, *tmp, *end;\n\t\tcimxml_context *cntx = NULL;\n\t\tSoapH soap = NULL;\n\t\tCimxmlMessage *cimxml_msg = cimxml_message_new();\n\t\ttmp = (char *)shttpd_get_env(arg, \"REQUEST_URI\");\n\t\tif (tmp && ( end = strrchr(tmp, '/')) != NULL ) {\n\t\t\tuuid = &end[1];\n\t\t}\n\t        encoding = get_request_encoding(arg);\n\t\tcimxml_msg->charset = u_strdup(encoding);\n\t\tconst char *cimexport = shttpd_get_header(arg, \"CIMExport\");\n\t\tconst char *cimexportmethod = shttpd_get_header(arg, \"CIMExportMethod\");\n\t\tif ( cimexportmethod && cimexport ) {\n\t\t\tif(strncmp(cimexport, \"MethodRequest\", strlen(\"MethodRequest\")) ||\n\t\t\t\t\tstrncmp(cimexportmethod, \"ExportIndication\", strlen(\"ExportIndication\"))) {\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = WSMAN_STATUS_FORBIDDEN;\n\t\t\tcim_error_code = CIMXML_STATUS_UNSUPPORTED_OPERATION;\n\t\t\tcim_error = \"unsupported-operation\";\n\t\t\tgoto DONE;\n\t\t}\n\t\tsoap = (SoapH) arg->user_data;\n\t\tu_buf_set(cimxml_msg->request, u_buf_ptr(state->request), u_buf_len(state->request));\n\t\tcntx = u_malloc(sizeof(cimxml_context));\n\t\tcntx->soap = soap;\n\t\tcntx->uuid = uuid;\n\t\tCIM_Indication_call(cntx, cimxml_msg, NULL);\n\t\tstatus = cimxml_msg->http_code;\n\t\tcim_error_code = cimxml_msg->status.code;\n\t\tcim_error = cimxml_msg->status.fault_msg;\n\t\tif (cim_error) {\n\t\t\tshttpd_printf(arg, \"HTTP/1.1 %d %s\\r\\n\", status, fault_reason);\n\t\t\tshttpd_printf(arg, \"CIMError:%d:%s\\r\\n\", cim_error_code, cim_error);\n\t\t\tcimxml_message_destroy(cimxml_msg);\n\t\t\tgoto CONTINUE;\n\t\t}\n\t\tstate->len =  u_buf_len(cimxml_msg->response);;\n\t\tstate->response = u_buf_steal(cimxml_msg->response);\n\t\tstate->index = 0;\n\t\tstate->type = 1;\n\t\tcimxml_message_destroy(cimxml_msg);\n#endif\n\n\t} else if (strcmp(request_uri, ANON_IDENTIFY_PATH) == 0 ) {\n\t\tchar *idfile = wsmand_options_get_anon_identify_file();\n\t\tu_buf_t *id;\n\t\tu_buf_create(&id);\n\t\tif (idfile && u_buf_load(id, idfile) == 0 ) {\n\t\t\tstate->len =  u_buf_len(id);;\n\t\t\tstate->response = u_buf_steal(id);\n\t\t\tstate->index = 0;\n\t\t\tu_buf_free(id);\n\t\t} else {\n\t\t\tshttpd_printf(arg, \"HTTP/1.0 404 Not foundn\\n\");\n\t\t\targ->flags |= SHTTPD_END_OF_OUTPUT;\n\t\t\tu_buf_free(id);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tshttpd_printf(arg, \"HTTP/1.0 404 Not foundn\\n\");\n\t\targ->flags |= SHTTPD_END_OF_OUTPUT;\n\t\treturn;\n\t}\n\nDONE:\n\n\tif (fault_reason == NULL) {\n\t\t// this is a way to segfault, investigate\n\t\t//fault_reason = shttpd_reason_phrase(status);\n\t}\n\tdebug(\"Response status=%d (%s)\", status, fault_reason);\n\n\t/*\n\t * Here we begin to create the http response.\n\t * Create the headers at first.\n\t */\n\n\tshttpd_printf(arg, \"HTTP/1.1 %d %s\\r\\n\", status, fault_reason);\n\tshttpd_printf(arg, \"Server: %s/%s\\r\\n\", PACKAGE_NAME, PACKAGE_VERSION);\n#ifdef SHTTPD_GSS\n\tif(payload) {\n\t\t// we had an encrypted message so now we have to encypt the reply\n\t\tchar *enc;\n\t\tint enclen;\n\t\tgss_encrypt(arg, state->response, state->len, &enc, &enclen);\n\t\tu_free(state->response);\n\t\tstate->response = enc;\n\t\tstate->len = enclen;\n\t\tpayload = 0; // and reset the indicator so that if we send in packates we dont do this again\n\t\tshttpd_printf(arg, \"Content-Type: multipart/encrypted;protocol=\\\"application/HTTP-Kerberos-session-encrypted\\\";boundary=\\\"Encrypted Boundary\\\"\\r\\n\");\n\t\tshttpd_printf(arg, \"Content-Length: %d\\r\\n\", state->len);\n\t}\n\telse {\n#endif\n\t\tif (state->type == 1) { /* eventing */\n\t\t\tshttpd_printf(arg, \"Content-Type: application/xml; charset=\\\"utf-8\\\"\\r\\n\");\n\t\t\tshttpd_printf(arg, \"CIMExport: MethodResponse\\r\\n\");\n\t\t} else {\n\t\t\tshttpd_printf(arg, \"Content-Type: application/soap+xml;charset=%s\\r\\n\", encoding);\n\t\t}\n    \t\tshttpd_printf(arg, \"Content-Length: %d\\r\\n\", state->len);\n#ifdef SHTTPD_GSS\n\t}\n#endif\n\tshttpd_printf(arg,\"Connection: Close\\r\\n\");\n  \n        /* separate header from message-body */\n\tshttpd_printf(arg, \"\\r\\n\");\n\n\t/* add response body to output buffer */\nCONTINUE:\n\n\n\tk = arg->out.len - arg->out.num_bytes;\n\tif (k <= state->len - state->index) {\n\t\t memcpy(arg->out.buf + arg->out.num_bytes, state->response + state->index, k );\n\t\t state->index += k ;\n\t\t arg->out.num_bytes += k;\n\t\t return;\n\t}\n\telse {\n\t         int l = state->len - state->index;\n\t\t memcpy(arg->out.buf + arg->out.num_bytes, state->response + state->index, l);\n\t\t state->index += l ;\n\t\t arg->out.num_bytes += l;\n\t}\n\n\tu_buf_free(state->request);\n\tu_free(state->response);\n\tu_free(state);\n\targ->flags |= SHTTPD_END_OF_OUTPUT;\n\treturn;\n}\n\nstatic void listener_shutdown_handler(void *p)\n{\n\tint *a = (int *) p;\n\tdebug(\"listener_shutdown_handler started\");\n\t*a = 0;\n}\n\nstatic void protect_uri(struct shttpd_ctx *ctx, char *uri)\n{\n\tif (wsmand_options_get_digest_password_file()) {\n\t\tshttpd_protect_uri(ctx, uri,\n                   wsmand_options_get_digest_password_file(),NULL, 1);\n\t\tdebug(\"Using Digest Authorization for %s:\", uri);\n\t}\n\tif (basic_callback) {\n\t\tshttpd_protect_uri(ctx, uri, wsmand_options_get_basic_password_file(),\n\t\t\t\t\t\tbasic_callback, 0);\n\t\tdebug(\"Using Basic Authorization %s for %s\",\n\t\t      wsmand_option_get_basic_authenticator()?\n\t\t      wsmand_option_get_basic_authenticator() :\n\t\t      wsmand_default_basic_authenticator(), uri);\n\t}\n}\n\nstatic struct shttpd_ctx *create_shttpd_context(SoapH soap, int port)\n{\n\tstruct shttpd_ctx *ctx;\n\tchar *tmps;\n\tint len;\n\n\tctx = shttpd_init(0, NULL);\n\tif (ctx == NULL) {\n\t\treturn NULL;\n\t}\n\tif (wsmand_options_get_use_ssl()) {\n\t\tmessage(\"ssl certificate: %s\", wsmand_options_get_ssl_cert_file());\n\t\tshttpd_set_option(ctx, \"ssl_cert\", wsmand_options_get_ssl_cert_file());\n\t}\n\tlen = snprintf(NULL, 0, \"%d%s\", port, wsmand_options_get_use_ssl() ? \"s\" : \"\");\n\ttmps = malloc((len+1) * sizeof(char));\n\tsnprintf(tmps, len+1, \"%d%s\", port, wsmand_options_get_use_ssl() ? \"s\" : \"\");\n\tshttpd_set_option(ctx, \"ports\", tmps);\n\tfree(tmps);\n\tshttpd_set_option(ctx, \"auth_realm\", AUTHENTICATION_REALM);\n\tshttpd_register_uri(ctx, wsmand_options_get_service_path(),\n\t\t\t    server_callback, (void *) soap);\n\tprotect_uri(ctx, wsmand_options_get_service_path());\n\tshttpd_register_uri(ctx, ANON_IDENTIFY_PATH,\n\t\t\t    server_callback, (void *) soap);\n\n#ifdef ENABLE_EVENTING_SUPPORT\n\tmessage(\"Registered CIM Indication Listener: %s\", DEFAULT_CIMINDICATION_PATH \"/*\");\n\tshttpd_register_uri(ctx, DEFAULT_CIMINDICATION_PATH \"/*\", server_callback,(void *)soap);\n\tprotect_uri( ctx, DEFAULT_CIMINDICATION_PATH );\n#endif\n\n\n\treturn ctx;\n}\n\n\nstatic int initialize_basic_authenticator(void)\n{\n\tchar *auth;\n\tchar *arg;\n\tvoid *hnd;\n\tint (*init) (char *);\n\tchar *name;\n\tint should_return = 0;\n\tint res = 0;\n\n\tif (wsmand_options_get_basic_password_file() != NULL) {\n\t\tif ((wsmand_option_get_basic_authenticator() &&\n\t\t     (strcmp(wsmand_default_basic_authenticator(),\n\t\t\t     wsmand_option_get_basic_authenticator()))) ||\n\t\t    wsmand_option_get_basic_authenticator_arg()) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"basic authentication is ambigious in config file\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tauth = wsmand_default_basic_authenticator();\n\t\targ = wsmand_options_get_basic_password_file();\n\t} else {\n\t\tauth = wsmand_option_get_basic_authenticator();\n\t\targ = wsmand_option_get_basic_authenticator_arg();\n\t}\n\n\tif (auth == NULL) {\n\t\t/* No basic authenticationame */\n\t\treturn 0;\n\t}\n\n\tif (auth[0] == '/') {\n\t\tname = auth;\n\t} else {\n\t\tname = u_strdup_printf(\"%s/%s\", PACKAGE_AUTH_DIR, auth);\n\t\tshould_return = 1;\n\t}\n\n\thnd = dlopen(name, RTLD_LAZY | RTLD_GLOBAL);\n\tif (hnd == NULL) {\n\t\tfprintf(stderr, \"Could not dlopen %s\\n\", name);\n\t\tres = 1;\n\t\tgoto DONE;\n\t}\n\tbasic_callback = dlsym(hnd, \"authorize\");\n\tif (basic_callback == NULL) {\n\t\tfprintf(stderr, \"Could not resolve authorize() in %s\\n\",\n\t\t\tname);\n\t\tres = 1;\n\t\tgoto DONE;\n\t}\n\n\tinit = dlsym(hnd, \"initialize\");\n\tif (init != NULL) {\n\t\tres = init(arg);\n\t}\n      DONE:\n\tif (should_return) {\n\t\tu_free(name);\n\t}\n\treturn res;\n}\n\n\nstatic int get_server_auth(void) {\n\tif (initialize_basic_authenticator()) {\n\t\treturn 0;\n\t}\n\n\tif (wsmand_options_get_digest_password_file()) {\n\t\tmessage(\"Using Digest Authorization\");\n\t}\n\tif (basic_callback) {\n\t\tmessage(\"Using Basic Authorization %s\",\n\t\t\twsmand_option_get_basic_authenticator()?\n\t\t\twsmand_option_get_basic_authenticator() :\n\t\t\twsmand_default_basic_authenticator());\n\t}\n\n\tif ((wsmand_options_get_digest_password_file() == NULL) &&\n\t\t    (basic_callback == NULL)) {\n\t\terror(\"Server does not work without authentication\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int get_server_port(void) {\n\tint port = 0;\n\tint use_ssl = wsmand_options_get_use_ssl();\n\tif (use_ssl) {\n\t\tmessage(\"Using SSL\");\n\t\tif (wsmand_options_get_ssl_cert_file() &&\n\t\t    wsmand_options_get_ssl_key_file() &&\n\t\t    (wsmand_options_get_server_ssl_port() > 0)) {\n\t\t\tport = wsmand_options_get_server_ssl_port();\n\t\t} else {\n\t\t\terror(\"Not enough data to use SSL port\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tport = wsmand_options_get_server_port();\n\t}\n\treturn port;\n}\n\n\nstatic int wsman_setup_thread(pthread_attr_t *pattrs) {\n\tint r;\n\tint ret = 0;\n\tif ((r = pthread_cond_init(&shttpd_cond, NULL)) != 0) {\n\t\tdebug(\"pthread_cond_init failed = %d\", r);\n\t\treturn ret;\n\t}\n\tif ((r = pthread_mutex_init(&shttpd_mutex, NULL)) != 0) {\n\t\tdebug(\"pthread_mutex_init failed = %d\", r);\n\t\treturn ret;\n\t}\n\n\tif ((r = pthread_attr_init(pattrs)) != 0) {\n\t\tdebug(\"pthread_attr_init failed = %d\", r);\n\t\treturn ret;\n\t}\n\n\tif ((r = pthread_attr_setdetachstate(pattrs, PTHREAD_CREATE_DETACHED)) != 0) {\n\t\tdebug(\"pthread_attr_setdetachstate = %d\", r);\n\t\treturn ret;\n\t}\n\treturn 1;\n        size_t thread_stack_size = wsmand_options_get_thread_stack_size();\n        if(thread_stack_size){\n                if(( r = pthread_attr_setstacksize(pattrs, thread_stack_size)) !=0) {\n                        debug(\"pthread_attr_setstacksize failed = %d\", r);\n                        return ret;\n                }\n        }\n}\n\n\nWsManListenerH *wsmand_start_server(dictionary * ini)\n{\n\tint lsn, port, sock;\n\tstruct thread       *thread;\n\tpthread_t tid;\n#ifdef ENABLE_EVENTING_SUPPORT\n\tpthread_t notificationManager_id;\n#endif\n\tpthread_attr_t pattrs;\n\tint use_ssl = wsmand_options_get_use_ssl();\n\tstruct shttpd_ctx   *httpd_ctx;\n\n\tWsManListenerH *listener = wsman_dispatch_list_new();\n\tlistener->config = ini;\n\tWsContextH cntx = wsman_init_plugins(listener);\n        int num_threads = 0;\n        int max_threads = wsmand_options_get_max_threads();\n        int max_connections_per_thread = wsmand_options_get_max_connections_per_thread();\n        if (max_threads && !max_connections_per_thread) {\n                error(\"max_threads: %d and max_connections_per_thread : %d\", max_threads, max_connections_per_thread);\n                return listener;\n        }\n\n\tif (cntx == NULL) {\n\t\treturn listener;\n\t}\n#ifdef ENABLE_EVENTING_SUPPORT\n\twsman_event_init(cntx->soap);\n#endif\n\n#ifndef HAVE_SSL\n\tif (use_ssl) {\n\t\terror(\"Server configured without SSL support\");\n\t\treturn listener;\n\t}\n#endif\n\tSoapH soap = ws_context_get_runtime(cntx);\n\tws_set_context_enumIdleTimeout(cntx,wsmand_options_get_enumIdleTimeout());\n\n\n\tif ((port = get_server_port()) == 0  )\n\t\treturn listener;\n#ifdef ENABLE_IPV6\n\tif (wsmand_options_get_use_ipv6()) {\n\t\tmessage(\"     Working on IPv6 port %d\", port);\n\t}\n\telse {\n#endif\n\t\tmessage(\"     Working on IPv4 port %d\", port);\n#ifdef ENABLE_IPV6\n\t}\n#endif\n\tif (!get_server_auth())\n\t\treturn listener;\n\n\twsmand_shutdown_add_handler(listener_shutdown_handler,\n\t\t\t\t    &continue_working);\n\n\thttpd_ctx = create_shttpd_context(soap, port);\n\n\tif (wsman_setup_thread(&pattrs) == 0 )\n\t\treturn listener;\n\tpthread_create(&tid, &pattrs, wsman_server_auxiliary_loop_thread, cntx);\n\n#ifdef ENABLE_EVENTING_SUPPORT\n\tpthread_create(&notificationManager_id, &pattrs, wsman_notification_manager, cntx);\n#endif\n\n\twhile (continue_working) {\n\t\tshttpd_poll(httpd_ctx, 1000);\n\t}\n\treturn listener;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.10-chdwbyn653qtqjlgbkkqerjcig3rssow/spack-src/src/server/shttpd/compat_win32.h": "/*\n * Copyright (c) 2004-2007 Sergey Lyubka <valenok@gmail.com>\n * All rights reserved\n *\n * \"THE BEER-WARE LICENSE\" (Revision 42):\n * Sergey Lyubka wrote this file.  As long as you retain this notice you\n * can do whatever you want with this stuff. If we meet some day, and you think\n * this stuff is worth it, you can buy me a beer in return.\n */\n\n/* Tip from Justin Maximilian, suppress errors from winsock2.h */\n#define _WINSOCKAPI_\n\n#include <windows.h>\n#include <winsock2.h>\n#include <commctrl.h>\n#include <winnls.h>\n#include <shlobj.h>\n#include <shellapi.h>\n\n#ifndef _WIN32_WCE\n\n#include <process.h>\n#include <direct.h>\n#include <io.h>\n\n#else /* _WIN32_WCE */\n\n/* Windows CE-specific definitions */\n#define NO_CGI\t/* WinCE has no pipes */\n#define NO_GUI\t/* temporarily until it is fixed */\n#pragma comment(lib,\"ws2\")\n/* WinCE has both Unicode and ANSI versions of GetProcAddress */\n#undef GetProcAddress\n#define GetProcAddress GetProcAddressA\n#include \"compat_wince.h\"\n\n#endif /* _WIN32_WCE */\n\n#define\tERRNO\t\t\tGetLastError()\n#define\tNO_SOCKLEN_T\n#define\tSSL_LIB\t\t\tL\"ssleay32.dll\"\n#define\tDIRSEP\t\t\t'\\\\'\n#define\tIS_DIRSEP_CHAR(c)\t((c) == '/' || (c) == '\\\\')\n#define\tO_NONBLOCK\t\t0\n#define\tEWOULDBLOCK\t\tWSAEWOULDBLOCK\n#define\tsnprintf\t\t_snprintf\n#define\tvsnprintf\t\t_vsnprintf\n#define\tmkdir(x,y)\t\t_mkdir(x)\n#define\tpopen(x,y)\t\t_popen(x, y)\n#define\tpclose(x)\t\t_pclose(x)\n#define\tdlopen(x,y)\t\tLoadLibraryW(x)\n#define\tdlsym(x,y)\t\t(void *) GetProcAddress(x,y)\n#define\t_POSIX_\n\n#ifdef __LCC__\n#include <stdint.h>\n#endif /* __LCC__ */\n\n#ifdef _MSC_VER /* MinGW already has these */\ntypedef unsigned int\t\tuint32_t;\ntypedef unsigned short\t\tuint16_t;\ntypedef __int64\t\t\tuint64_t;\n#define S_ISDIR(x)\t\t((x) & _S_IFDIR)\n#endif /* _MSC_VER */\n\n/*\n * POSIX dirent interface\n */\nstruct dirent {\n\tchar\td_name[FILENAME_MAX];\n};\n\ntypedef struct DIR {\n\tHANDLE\t\t\thandle;\n\tWIN32_FIND_DATAW\tinfo;\n\tstruct dirent\t\tresult;\n\tchar\t\t\t*name;\n} DIR;\n\nextern DIR *opendir(const char *name);\nextern int closedir(DIR *dir);\nextern struct dirent *readdir(DIR *dir);\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.10-chdwbyn653qtqjlgbkkqerjcig3rssow/spack-src/src/server/shttpd/shttpd.c": "/*\n * Copyright (c) 2004-2005 Sergey Lyubka <valenok@gmail.com>\n * All rights reserved\n *\n * \"THE BEER-WARE LICENSE\" (Revision 42):\n * Sergey Lyubka wrote this file.  As long as you retain this notice you\n * can do whatever you want with this stuff. If we meet some day, and you think\n * this stuff is worth it, you can buy me a beer in return.\n */\n\n/*\n * Small and portable HTTP server, http://shttpd.sourceforge.net\n * $Id: shttpd.c,v 1.57 2008/08/23 21:00:38 drozd Exp $\n */\n\n#include \"defs.h\"\n#include \"wsmand-daemon.h\"\n\ntime_t\t_shttpd_current_time;\t/* Current UTC time\t\t*/\nint\t_shttpd_tz_offset;\t/* Time zone offset from UTC\t*/\nint\t_shttpd_exit_flag;\t/* Program exit flag\t\t*/\n\nconst struct vec _shttpd_known_http_methods[] = {\n\t{\"POST\",\t4},\n\t{NULL,\t\t0}\n};\n\n/*\n * This structure tells how HTTP headers must be parsed.\n * Used by parse_headers() function.\n */\n#define\tOFFSET(x)\toffsetof(struct headers, x)\nstatic const struct http_header http_headers[] = {\n\t{16, HDR_INT,\t OFFSET(cl),\t\t\"Content-Length: \"\t},\n\t{14, HDR_STRING, OFFSET(ct),\t\t\"Content-Type: \"\t},\n\t{12, HDR_STRING, OFFSET(useragent),\t\"User-Agent: \"\t\t},\n\t{19, HDR_DATE,\t OFFSET(ims),\t\t\"If-Modified-Since: \"\t},\n\t{15, HDR_STRING, OFFSET(auth),\t\t\"Authorization: \"\t},\n\t{9,  HDR_STRING, OFFSET(referer),\t\"Referer: \"\t\t},\n\t{8,  HDR_STRING, OFFSET(cookie),\t\"Cookie: \"\t\t},\n\t{10, HDR_STRING, OFFSET(location),\t\"Location: \"\t\t},\n\t{8,  HDR_INT,\t OFFSET(status),\t\"Status: \"\t\t},\n\t{7,  HDR_STRING, OFFSET(range),\t\t\"Range: \"\t\t},\n\t{12, HDR_STRING, OFFSET(connection),\t\"Connection: \"\t\t},\n\t{19, HDR_STRING, OFFSET(transenc),\t\"Transfer-Encoding: \"\t},\n\t{0,  HDR_INT,\t 0,\t\t\tNULL\t\t\t}\n};\n\nstruct shttpd_ctx *init_ctx(const char *config_file, int argc, char *argv[]);\nstatic void process_connection(struct conn *, int, int);\n\nint\n_shttpd_is_true(const char *str)\n{\n\tstatic const char\t*trues[] = {\"1\", \"yes\", \"true\", \"jawohl\", NULL};\n\tconst char\t\t**p;\n\n\tfor (p = trues; *p != NULL; p++)\n\t\tif (str && !strcmp(str, *p))\n\t\t\treturn (TRUE);\n\n\treturn (FALSE);\n}\n\nstatic void\nfree_list(struct llhead *head, void (*dtor)(struct llhead *))\n{\n\tstruct llhead\t*lp, *tmp;\n\n\tLL_FOREACH_SAFE(head, lp, tmp) {\n\t\tLL_DEL(lp);\n\t\tdtor(lp);\n\t}\n}\n\nstatic void\nlistener_destructor(struct llhead *lp)\n{\n\tstruct listener\t*listener = LL_ENTRY(lp, struct listener, link);\n\n\t(void) closesocket(listener->sock);\n\tfree(listener);\n}\n\nstatic void\nregistered_uri_destructor(struct llhead *lp)\n{\n\tstruct registered_uri *ruri = LL_ENTRY(lp, struct registered_uri, link);\n\n\tfree((void *) ruri->uri);\n\tfree(ruri);\n}\n\nstatic void\nacl_destructor(struct llhead *lp)\n{\n\tstruct acl\t*acl = LL_ENTRY(lp, struct acl, link);\n\tfree(acl);\n}\n\nint\n_shttpd_url_decode(const char *src, int src_len, char *dst, int dst_len)\n{\n\tint\ti, j, a, b;\n#define\tHEXTOI(x)  (isdigit(x) ? x - '0' : x - 'W')\n\n\tfor (i = j = 0; i < src_len && j < dst_len - 1; i++, j++)\n\t\tswitch (src[i]) {\n\t\tcase '%':\n\t\t\tif (isxdigit(((unsigned char *) src)[i + 1]) &&\n\t\t\t    isxdigit(((unsigned char *) src)[i + 2])) {\n\t\t\t\ta = tolower(((unsigned char *)src)[i + 1]);\n\t\t\t\tb = tolower(((unsigned char *)src)[i + 2]);\n\t\t\t\tdst[j] = (HEXTOI(a) << 4) | HEXTOI(b);\n\t\t\t\ti += 2;\n\t\t\t} else {\n\t\t\t\tdst[j] = '%';\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdst[j] = src[i];\n\t\t\tbreak;\n\t\t}\n\n\tdst[j] = '\\0';\t/* Null-terminate the destination */\n\n\treturn (j);\n}\n\nstatic const char *\nis_alias(struct shttpd_ctx *ctx, const char *uri,\n\t\tstruct vec *a_uri, struct vec *a_path)\n{\n\tconst char\t*p, *s = ctx->options[OPT_ALIASES];\n\tsize_t\t\tlen;\n\n\tDBG((\"is_alias: aliases [%s]\", s == NULL ? \"\" : s));\n\n\tFOR_EACH_WORD_IN_LIST(s, len) {\n\n\t\tif ((p = memchr(s, '=', len)) == NULL || p >= s + len || p == s)\n\t\t\tcontinue;\n\n\t\tif (memcmp(uri, s, p - s) == 0) {\n\t\t\ta_uri->ptr = s;\n\t\t\ta_uri->len = p - s;\n\t\t\ta_path->ptr = ++p;\n\t\t\ta_path->len = (s + len) - p;\n\t\t\treturn (s);\n\t\t}\n\t}\n\n\treturn (NULL);\n}\n\nvoid\n_shttpd_stop_stream(struct stream *stream)\n{\n\tif (stream->io_class != NULL && stream->io_class->close != NULL)\n\t\tstream->io_class->close(stream);\n\n\tstream->io_class= NULL;\n\tstream->flags |= FLAG_CLOSED;\n\tstream->flags &= ~(FLAG_R | FLAG_W | FLAG_ALWAYS_READY);\n\n\tDBG((\"%d %s stopped. %lu of content data, %d now in a buffer\",\n\t    stream->conn->rem.chan.sock,\n\t    stream->io_class ? stream->io_class->name : \"(null)\",\n\t    (unsigned long) stream->io.total, (int) io_data_len(&stream->io)));\n}\n\n/*\n * Setup listening socket on given port, return socket\n */\nstatic int\nshttpd_open_listening_port(int port)\n{\n\tint\t\tsock, on = 1;\n\tstruct usa\tsa;\n\n#ifdef _WIN32\n\t{WSADATA data;\tWSAStartup(MAKEWORD(2,2), &data);}\n#endif /* _WIN32 */\n\n\tsa.len\t\t\t\t= sizeof(sa.u.sin);\n\tsa.u.sin.sin_family\t\t= AF_INET;\n\tsa.u.sin.sin_port\t\t= htons((uint16_t) port);\n\tsa.u.sin.sin_addr.s_addr\t= htonl(INADDR_ANY);\n\n\tif ((sock = socket(PF_INET, SOCK_STREAM, 6)) == -1)\n\t\tgoto fail;\n\tif (_shttpd_set_non_blocking_mode(sock) != 0)\n\t\tgoto fail;\n\tif (setsockopt(sock, SOL_SOCKET,\n\t    SO_REUSEADDR,(char *) &on, sizeof(on)) != 0)\n\t\tgoto fail;\n\tif (bind(sock, &sa.u.sa, sa.len) < 0)\n\t\tgoto fail;\n\tif (listen(sock, 128) != 0)\n\t\tgoto fail;\n\n#ifndef _WIN32\n\t(void) fcntl(sock, F_SETFD, FD_CLOEXEC);\n#endif /* !_WIN32 */\n\n\treturn (sock);\nfail:\n\tif (sock != -1)\n\t\t(void) closesocket(sock);\n\t_shttpd_elog(E_LOG, NULL, \"open_listening_port(%d): %s\", port, strerror(errno));\n\treturn (-1);\n}\n\n/*\n * Check whether full request is buffered Return headers length, or 0\n */\nint\n_shttpd_get_headers_len(const char *buf, size_t buflen)\n{\n\tconst char\t*s, *e;\n\tint\t\tlen = 0;\n\n\tfor (s = buf, e = s + buflen - 1; len == 0 && s < e; s++)\n\t\t/* Control characters are not allowed but >=128 is. */\n\t\tif (!isprint(* (unsigned char *) s) && *s != '\\r' &&\n\t\t    *s != '\\n' && * (unsigned char *) s < 128)\n\t\t\tlen = -1;\n\t\telse if (s[0] == '\\n' && s[1] == '\\n')\n\t\t\tlen = s - buf + 2;\n\t\telse if (s[0] == '\\n' && &s[1] < e &&\n\t\t    s[1] == '\\r' && s[2] == '\\n')\n\t\t\tlen = s - buf + 3;\n\n\treturn (len);\n}\n\n/*\n * Send error message back to a client.\n */\nvoid\n_shttpd_send_server_error(struct conn *c, int status, const char *reason)\n{\n\tstruct llhead\t\t*lp;\n\tstruct error_handler\t*e;\n\n\tLL_FOREACH(&c->ctx->error_handlers, lp) {\n\t\te = LL_ENTRY(lp, struct error_handler, link);\n\n\t\tif (e->code == status) {\n\t\t\tif (c->loc.io_class != NULL &&\n\t\t\t    c->loc.io_class->close != NULL)\n\t\t\t\tc->loc.io_class->close(&c->loc);\n\t\t\tio_clear(&c->loc.io);\n\t\t\t_shttpd_setup_embedded_stream(c,\n\t\t\t    e->callback, e->callback_data);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tio_clear(&c->loc.io);\n\tc->loc.io.head = _shttpd_snprintf(c->loc.io.buf, c->loc.io.size,\n\t    \"HTTP/1.1 %d %s\\r\\n\"\n\t    \"Content-Type: text/plain\\r\\n\"\n\t    \"Content-Length: 12\\r\\n\"\n\t    \"\\r\\n\"\n\t    \"Error: %03d\\r\\n\",\n\t    status, reason, status);\n\tc->loc.content_len = 10;\n\tc->status = status;\n\t_shttpd_stop_stream(&c->loc);\n}\n\n/*\n * Convert month to the month number. Return -1 on error, or month number\n */\nstatic int\nmontoi(const char *s)\n{\n\tstatic const char *ar[] = {\n\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\t\t\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n\t};\n\tsize_t\ti;\n\n\tfor (i = 0; i < sizeof(ar) / sizeof(ar[0]); i++)\n\t\tif (!strcmp(s, ar[i]))\n\t\t\treturn (i);\n\n\treturn (-1);\n}\n\n/*\n * Parse date-time string, and return the corresponding time_t value\n */\nstatic time_t\ndate_to_epoch(const char *s)\n{\n\tstruct tm\ttm, *tmp;\n\tchar\t\tmon[32];\n\tint\t\tsec, min, hour, mday, month, year;\n\n\t(void) memset(&tm, 0, sizeof(tm));\n\tsec = min = hour = mday = month = year = 0;\n\n\tif (((sscanf(s, \"%d/%3s/%d %d:%d:%d\",\n\t    &mday, mon, &year, &hour, &min, &sec) == 6) ||\n\t    (sscanf(s, \"%d %3s %d %d:%d:%d\",\n\t    &mday, mon, &year, &hour, &min, &sec) == 6) ||\n\t    (sscanf(s, \"%*3s, %d %3s %d %d:%d:%d\",\n\t    &mday, mon, &year, &hour, &min, &sec) == 6) ||\n\t    (sscanf(s, \"%d-%3s-%d %d:%d:%d\",\n\t    &mday, mon, &year, &hour, &min, &sec) == 6)) &&\n\t    (month = montoi(mon)) != -1) {\n\t\ttm.tm_mday\t= mday;\n\t\ttm.tm_mon\t= month;\n\t\ttm.tm_year\t= year;\n\t\ttm.tm_hour\t= hour;\n\t\ttm.tm_min\t= min;\n\t\ttm.tm_sec\t= sec;\n\t}\n\n\tif (tm.tm_year > 1900)\n\t\ttm.tm_year -= 1900;\n\telse if (tm.tm_year < 70)\n\t\ttm.tm_year += 100;\n\n\t/* Set Daylight Saving Time field */\n\ttmp = localtime(&_shttpd_current_time);\n\ttm.tm_isdst = tmp->tm_isdst;\n\n\treturn (mktime(&tm));\n}\n\nstatic void\nremove_all_leading_and_double_dots(char *s)\n{\n\tchar\t*p = s;\n\n\twhile (*s != '\\0' && *s == '.') s++;\n\n\twhile (*s != '\\0') {\n\t\t*p++ = *s++;\n\t\tif (s[-1] == '/' || s[-1] == '\\\\')\n\t\t\twhile (*s == '.' || *s == '/' || *s == '\\\\')\n\t\t\t\ts++;\n\t}\n\t*p = '\\0';\n}\n\nvoid\n_shttpd_parse_headers(const char *s, int len, struct headers *parsed)\n{\n\tconst struct http_header\t*h;\n\tunion variant\t\t\t*v;\n\tconst char\t\t\t*p, *e = s + len;\n\n\tDBG((\"parsing headers (len %d): [%.*s]\", len, len, s));\n\n\t/* Loop through all headers in the request */\n\twhile (s < e) {\n\n\t\t/* Find where this header ends */\n\t\tfor (p = s; p < e && *p != '\\n'; ) p++;\n\n\t\t/* Is this header known to us ? */\n\t\tfor (h = http_headers; h->len != 0; h++)\n\t\t\tif (e - s > h->len &&\n\t\t\t    !_shttpd_strncasecmp(s, h->name, h->len))\n\t\t\t\tbreak;\n\n\t\t/* If the header is known to us, store its value */\n\t\tif (h->len != 0) {\n\n\t\t\t/* Shift to where value starts */\n\t\t\ts += h->len;\n\n\t\t\t/* Find place to store the value */\n\t\t\tv = (union variant *) ((char *) parsed + h->offset);\n\n\t\t\t/* Fetch header value into the connection structure */\n\t\t\tif (h->type == HDR_STRING) {\n\t\t\t\tv->v_vec.ptr = s;\n\t\t\t\tv->v_vec.len = p - s;\n\t\t\t\tif (p[-1] == '\\r' && v->v_vec.len > 0)\n\t\t\t\t\tv->v_vec.len--;\n\t\t\t} else if (h->type == HDR_INT) {\n\t\t\t\tv->v_big_int = strtoul(s, NULL, 10);\n\t\t\t} else if (h->type == HDR_DATE) {\n\t\t\t\tv->v_time = date_to_epoch(s);\n\t\t\t}\n\t\t}\n\n\t\ts = p + 1;\t/* Shift to the next header */\n\t}\n}\n\nstatic const struct {\n\tconst char\t*extension;\n\tint\t\text_len;\n\tconst char\t*mime_type;\n} builtin_mime_types[] = {\n\t{\"html\",\t4,\t\"text/html\"\t\t\t},\n\t{\"htm\",\t\t3,\t\"text/html\"\t\t\t},\n\t{\"txt\",\t\t3,\t\"text/plain\"\t\t\t},\n\t{\"css\",\t\t3,\t\"text/css\"\t\t\t},\n\t{\"ico\",\t\t3,\t\"image/x-icon\"\t\t\t},\n\t{\"gif\",\t\t3,\t\"image/gif\"\t\t\t},\n\t{\"jpg\",\t\t3,\t\"image/jpeg\"\t\t\t},\n\t{\"jpeg\",\t4,\t\"image/jpeg\"\t\t\t},\n\t{\"png\",\t\t3,\t\"image/png\"\t\t\t},\n\t{\"svg\",\t\t3,\t\"image/svg+xml\"\t\t\t},\n\t{\"torrent\",\t7,\t\"application/x-bittorrent\"\t},\n\t{\"wav\",\t\t3,\t\"audio/x-wav\"\t\t\t},\n\t{\"mp3\",\t\t3,\t\"audio/x-mp3\"\t\t\t},\n\t{\"mid\",\t\t3,\t\"audio/mid\"\t\t\t},\n\t{\"m3u\",\t\t3,\t\"audio/x-mpegurl\"\t\t},\n\t{\"ram\",\t\t3,\t\"audio/x-pn-realaudio\"\t\t},\n\t{\"ra\",\t\t2,\t\"audio/x-pn-realaudio\"\t\t},\n\t{\"doc\",\t\t3,\t\"application/msword\",\t\t},\n\t{\"exe\",\t\t3,\t\"application/octet-stream\"\t},\n\t{\"zip\",\t\t3,\t\"application/x-zip-compressed\"\t},\n\t{\"xls\",\t\t3,\t\"application/excel\"\t\t},\n\t{\"tgz\",\t\t3,\t\"application/x-tar-gz\"\t\t},\n\t{\"tar.gz\",\t6,\t\"application/x-tar-gz\"\t\t},\n\t{\"tar\",\t\t3,\t\"application/x-tar\"\t\t},\n\t{\"gz\",\t\t2,\t\"application/x-gunzip\"\t\t},\n\t{\"arj\",\t\t3,\t\"application/x-arj-compressed\"\t},\n\t{\"rar\",\t\t3,\t\"application/x-arj-compressed\"\t},\n\t{\"rtf\",\t\t3,\t\"application/rtf\"\t\t},\n\t{\"pdf\",\t\t3,\t\"application/pdf\"\t\t},\n\t{\"swf\",\t\t3,\t\"application/x-shockwave-flash\"\t},\n\t{\"mpg\",\t\t3,\t\"video/mpeg\"\t\t\t},\n\t{\"mpeg\",\t4,\t\"video/mpeg\"\t\t\t},\n\t{\"asf\",\t\t3,\t\"video/x-ms-asf\"\t\t},\n\t{\"avi\",\t\t3,\t\"video/x-msvideo\"\t\t},\n\t{\"bmp\",\t\t3,\t\"image/bmp\"\t\t\t},\n\t{NULL,\t\t0,\tNULL\t\t\t\t}\n};\n\nvoid\n_shttpd_get_mime_type(struct shttpd_ctx *ctx,\n\t\tconst char *uri, int len, struct vec *vec)\n{\n\tconst char\t*eq, *p = ctx->options[OPT_MIME_TYPES];\n\tint\t\ti, n, ext_len;\n\n\t/* Firt, loop through the custom mime types if any */\n\tFOR_EACH_WORD_IN_LIST(p, n) {\n\t\tif ((eq = memchr(p, '=', n)) == NULL || eq >= p + n || eq == p)\n\t\t\tcontinue;\n\t\text_len = eq - p;\n\t\tif (len > ext_len && uri[len - ext_len - 1] == '.' &&\n\t\t    !_shttpd_strncasecmp(p, &uri[len - ext_len], ext_len)) {\n\t\t\tvec->ptr = eq + 1;\n\t\t\tvec->len = p + n - vec->ptr;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* If no luck, try built-in mime types */\n\tfor (i = 0; builtin_mime_types[i].extension != NULL; i++) {\n\t\text_len = builtin_mime_types[i].ext_len;\n\t\tif (len > ext_len && uri[len - ext_len - 1] == '.' &&\n\t\t    !_shttpd_strncasecmp(builtin_mime_types[i].extension,\n\t\t\t    &uri[len - ext_len], ext_len)) {\n\t\t\tvec->ptr = builtin_mime_types[i].mime_type;\n\t\t\tvec->len = strlen(vec->ptr);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Oops. This extension is unknown to us. Fallback to text/plain */\n\tvec->ptr = \"text/plain\";\n\tvec->len = strlen(vec->ptr);\n}\n\n/*\n * For given directory path, substitute it to valid index file.\n * Return 0 if index file has been found, -1 if not found\n */\nstatic int\nfind_index_file(struct conn *c, char *path, size_t maxpath, struct stat *stp)\n{\n\tchar\t\tbuf[FILENAME_MAX];\n\tconst char\t*s = c->ctx->options[OPT_INDEX_FILES];\n\tsize_t\t\tlen;\n\n\tFOR_EACH_WORD_IN_LIST(s, len) {\n\t\t/* path must end with '/' character */\n\t\t_shttpd_snprintf(buf, sizeof(buf), \"%s%.*s\", path, len, s);\n\t\tif (_shttpd_stat(buf, stp) == 0) {\n\t\t\t_shttpd_strlcpy(path, buf, maxpath);\n\t\t\t_shttpd_get_mime_type(c->ctx, s, len, &c->mime_type);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (-1);\n}\n\n/*\n * Try to open requested file, return 0 if OK, -1 if error.\n * If the file is given arguments using PATH_INFO mechanism,\n * initialize pathinfo pointer.\n */\nstatic int\nget_path_info(struct conn *c, char *path, struct stat *stp)\n{\n\tchar\t*p, *e;\n\n\tif (_shttpd_stat(path, stp) == 0)\n\t\treturn (0);\n\n\tp = path + strlen(path);\n\te = path + strlen(c->ctx->options[OPT_ROOT]) + 2;\n\n\t/* Strip directory parts of the path one by one */\n\tfor (; p > e; p--)\n\t\tif (*p == '/') {\n\t\t\t*p = '\\0';\n\t\t\tif (!_shttpd_stat(path, stp) && !S_ISDIR(stp->st_mode)) {\n\t\t\t\tc->path_info = p + 1;\n\t\t\t\treturn (0);\n\t\t\t} else {\n\t\t\t\t*p = '/';\n\t\t\t}\n\t\t}\n\n\treturn (-1);\n}\n\nstatic void\ndecide_what_to_do(struct conn *c)\n{\n\tchar\t\tpath[URI_MAX], buf[1024], *root;\n\tstruct vec\talias_uri, alias_path;\n\tstruct stat\tst;\n\tint\t\trc;\n\tstruct registered_uri\t*ruri;\n\n\tDBG((\"decide_what_to_do: [%s]\", c->uri));\n\n\tif ((c->query = strchr(c->uri, '?')) != NULL)\n\t\t*c->query++ = '\\0';\n\n\t_shttpd_url_decode(c->uri, strlen(c->uri), c->uri, strlen(c->uri) + 1);\n\tremove_all_leading_and_double_dots(c->uri);\n\n\troot = c->ctx->options[OPT_ROOT];\n\tif (strlen(c->uri) + strlen(root) >= sizeof(path)) {\n\t\t_shttpd_send_server_error(c, 400, \"URI is too long\");\n\t\treturn;\n\t}\n\n\t(void) _shttpd_snprintf(path, sizeof(path), \"%s%s\", root, c->uri);\n\n\tDBG((\"decide_what_to_do -> processed path: [%s]\", path));\n\t/* User may use the aliases - check URI for mount point */\n\tif (is_alias(c->ctx, c->uri, &alias_uri, &alias_path) != NULL) {\n\t\t(void) _shttpd_snprintf(path, sizeof(path), \"%.*s%s\",\n\t\t    alias_path.len, alias_path.ptr, c->uri + alias_uri.len);\n\t\tDBG((\"using alias %.*s -> %.*s\", alias_uri.len, alias_uri.ptr,\n\t\t    alias_path.len, alias_path.ptr));\n\t}\n\n#if !defined(NO_AUTH)\n\tif (_shttpd_check_authorization(c, path) != 1) {\n\t\t_shttpd_send_authorization_request(c);\n\t} else\n#endif /* NO_AUTH */\n\tif ((ruri = _shttpd_is_registered_uri(c->ctx, c->uri)) != NULL) {\n\t\t_shttpd_setup_embedded_stream(c,\n\t\t    ruri->callback, ruri->callback_data);\n\t} else {\n\t\t_shttpd_send_server_error(c, 403, \"Forbidden\");\n\t}\n#if 0\n\tif (strstr(path, HTPASSWD)) {\n\t\t/* Do not allow to view passwords files */\n\t\t_shttpd_send_server_error(c, 403, \"Forbidden\");\n\t} else\n#if !defined(NO_AUTH)\n\tif ((c->method == METHOD_PUT || c->method == METHOD_DELETE) &&\n\t    (c->ctx->options[OPT_AUTH_PUT] == NULL ||\n\t     !_shttpd_is_authorized_for_put(c))) {\n\t\t_shttpd_send_authorization_request(c);\n\t} else\n#endif /* NO_AUTH */\n\tif (c->method == METHOD_PUT) {\n\t\tc->status = _shttpd_stat(path, &st) == 0 ? 200 : 201;\n\n\t\tif (c->ch.range.v_vec.len > 0) {\n\t\t\t_shttpd_send_server_error(c, 501,\n\t\t\t    \"PUT Range Not Implemented\");\n\t\t} else if ((rc = _shttpd_put_dir(path)) == 0) {\n\t\t\t_shttpd_send_server_error(c, 200, \"OK\");\n\t\t} else if (rc == -1) {\n\t\t\t_shttpd_send_server_error(c, 500, \"PUT Directory Error\");\n\t\t} else if (c->rem.content_len == 0) {\n\t\t\t_shttpd_send_server_error(c, 411, \"Length Required\");\n\t\t} else if ((c->loc.chan.fd = _shttpd_open(path, O_WRONLY | O_BINARY |\n\t\t    O_CREAT | O_NONBLOCK | O_TRUNC, 0644)) == -1) {\n\t\t\t_shttpd_send_server_error(c, 500, \"PUT Error\");\n\t\t} else {\n\t\t\tDBG((\"PUT file [%s]\", c->uri));\n\t\t\tc->loc.io_class = &_shttpd_io_file;\n\t\t\tc->loc.flags |= FLAG_W | FLAG_ALWAYS_READY ;\n\t\t}\n\t} else if (c->method == METHOD_DELETE) {\n\t\tDBG((\"DELETE [%s]\", c->uri));\n\t\tif (_shttpd_remove(path) == 0)\n\t\t\t_shttpd_send_server_error(c, 200, \"OK\");\n\t\telse\n\t\t\t_shttpd_send_server_error(c, 500, \"DELETE Error\");\n\t} else if (get_path_info(c, path, &st) != 0) {\n\t\t_shttpd_send_server_error(c, 404, \"Not Found\");\n\t} else if (S_ISDIR(st.st_mode) && path[strlen(path) - 1] != '/') {\n\t\t(void) _shttpd_snprintf(buf, sizeof(buf),\n\t\t\t\"Moved Permanently\\r\\nLocation: %s/\", c->uri);\n\t\t_shttpd_send_server_error(c, 301, buf);\n\t} else if (S_ISDIR(st.st_mode) &&\n\t    find_index_file(c, path, sizeof(path) - 1, &st) == -1 &&\n\t    !IS_TRUE(c->ctx, OPT_DIR_LIST)) {\n\t\t_shttpd_send_server_error(c, 403, \"Directory Listing Denied\");\n\t} else if (S_ISDIR(st.st_mode) && IS_TRUE(c->ctx, OPT_DIR_LIST)) {\n\t\tif ((c->loc.chan.dir.path = _shttpd_strdup(path)) != NULL)\n\t\t\t_shttpd_get_dir(c);\n\t\telse\n\t\t\t_shttpd_send_server_error(c, 500, \"GET Directory Error\");\n\t} else if (S_ISDIR(st.st_mode) && !IS_TRUE(c->ctx, OPT_DIR_LIST)) {\n\t\t_shttpd_send_server_error(c, 403, \"Directory listing denied\");\n#if !defined(NO_CGI)\n\t} else if (_shttpd_match_extension(path,\n\t    c->ctx->options[OPT_CGI_EXTENSIONS])) {\n\t\tif (c->method != METHOD_POST && c->method != METHOD_GET) {\n\t\t\t_shttpd_send_server_error(c, 501, \"Bad method \");\n\t\t} else if ((_shttpd_run_cgi(c, path)) == -1) {\n\t\t\t_shttpd_send_server_error(c, 500, \"Cannot exec CGI\");\n\t\t} else {\n\t\t\t_shttpd_do_cgi(c);\n\t\t}\n#endif /* NO_CGI */\n#if !defined(NO_SSI)\n\t} else if (_shttpd_match_extension(path,\n\t    c->ctx->options[OPT_SSI_EXTENSIONS])) {\n\t\tif ((c->loc.chan.fd = _shttpd_open(path,\n\t\t    O_RDONLY | O_BINARY, 0644)) == -1) {\n\t\t\t_shttpd_send_server_error(c, 500, \"SSI open error\");\n\t\t} else {\n\t\t\t_shttpd_do_ssi(c);\n\t\t}\n#endif /* NO_CGI */\n\t} else if (c->ch.ims.v_time && st.st_mtime <= c->ch.ims.v_time) {\n\t\t_shttpd_send_server_error(c, 304, \"Not Modified\");\n\t} else if ((c->loc.chan.fd = _shttpd_open(path,\n\t    O_RDONLY | O_BINARY, 0644)) != -1) {\n\t\t_shttpd_get_file(c, &st);\n\t} else {\n\t\t_shttpd_send_server_error(c, 500, \"Internal Error\");\n\t}\n#endif //0\n  return;\n}\n\nstatic int\nset_request_method(struct conn *c)\n{\n\tconst struct vec\t*v;\n\n\t/* Set the request method */\n\tfor (v = _shttpd_known_http_methods; v->ptr != NULL; v++)\n\t\tif (!memcmp(c->rem.io.buf, v->ptr, v->len)) {\n\t\t\tc->method = v - _shttpd_known_http_methods;\n\t\t\tbreak;\n\t\t}\n\n\treturn (v->ptr == NULL);\n}\n\nstatic void\nparse_http_request(struct conn *c)\n{\n\tchar\t*s, *e, *p, *start;\n\tint\turi_len, req_len, n;\n\n\ts = io_data(&c->rem.io);;\n\treq_len = c->rem.headers_len =\n\t    _shttpd_get_headers_len(s, io_data_len(&c->rem.io));\n\n\tif (req_len == 0 && io_space_len(&c->rem.io) == 0) {\n\t\tio_clear(&c->rem.io);\n\t\t_shttpd_send_server_error(c, 400, \"Request is too big\");\n\t}\n\n\tif (req_len == 0) {\n\t\treturn;\n\t} else if (req_len < 16) {\t/* Minimal: \"GET / HTTP/1.0\\n\\n\" */\n\t\t_shttpd_send_server_error(c, 400, \"Bad request\");\n\t} else if (set_request_method(c)) {\n\t\t_shttpd_send_server_error(c, 501, \"Method Not Implemented\");\n\t} else if ((c->request = _shttpd_strndup(s, req_len)) == NULL) {\n\t\t_shttpd_send_server_error(c, 500, \"Cannot allocate request\");\n\t}\n\n\tio_inc_tail(&c->rem.io, req_len);\n\n\tif (c->loc.flags & FLAG_CLOSED)\n\t\treturn;\n\n\tDBG((\"Conn %d: parsing request: [%.*s]\", c->rem.chan.sock, req_len, s));\n\tc->rem.flags |= FLAG_HEADERS_PARSED;\n\n\t/* Set headers pointer. Headers follow the request line */\n\tc->headers = memchr(c->request, '\\n', req_len);\n\tassert(c->headers != NULL);\n\tassert(c->headers < c->request + req_len);\n\tif (c->headers > c->request && c->headers[-1] == '\\r')\n\t\tc->headers[-1] = '\\0';\n\t*c->headers++ = '\\0';\n\n\t/*\n\t * Now make a copy of the URI, because it will be URL-decoded,\n\t * and we need a copy of unmodified URI for the access log.\n\t * First, we skip the REQUEST_METHOD and shift to the URI.\n\t */\n\tfor (p = c->request, e = p + req_len; *p != ' ' && p < e; p++);\n\twhile (p < e && *p == ' ')\n\t\tp++;\n\n\t/* Now remember where URI starts, and shift to the end of URI */\n\tfor (start = p; p < e && !isspace((unsigned char)*p); ) p++;\n\turi_len = p - start;\n\n\t/* Skip space following the URI */\n\twhile (p < e && *p == ' ')\n\t\tp++;\n\n\t/* Now comes the HTTP-Version in the form HTTP/<major>.<minor> */\n\tif (sscanf(p, \"HTTP/%lu.%lu%n\",\n\t    &c->major_version, &c->minor_version, &n) != 2 || p[n] != '\\0') {\n\t\t_shttpd_send_server_error(c, 400, \"Bad HTTP version\");\n\t} else if (c->major_version > 1 ||\n\t    (c->major_version == 1 && c->minor_version > 1)) {\n\t\t_shttpd_send_server_error(c, 505, \"HTTP version not supported\");\n\t} else if (uri_len <= 0) {\n\t\t_shttpd_send_server_error(c, 400, \"Bad URI\");\n\t} else if ((c->uri = malloc(uri_len + 1)) == NULL) {\n\t\t_shttpd_send_server_error(c, 500, \"Cannot allocate URI\");\n\t} else {\n\t\t_shttpd_strlcpy(c->uri, (char *) start, uri_len + 1);\n\t\t_shttpd_parse_headers(c->headers,\n\t\t    (c->request + req_len) - c->headers, &c->ch);\n\n\t\t/* Remove the length of request from total, count only data */\n\t\tassert(c->rem.io.total >= (big_int_t) req_len);\n\t\tc->rem.io.total -= req_len;\n\t\tc->rem.content_len = c->ch.cl.v_big_int;\n\t\tdecide_what_to_do(c);\n\t}\n}\n\nstatic void\nadd_socket(struct worker *worker, int sock, int is_ssl)\n{\n\tstruct shttpd_ctx\t*ctx = worker->ctx;\n\tstruct conn\t\t*c;\n\tstruct usa\t\tsa;\n\tint\t\t\tl = IS_TRUE(ctx, OPT_INETD) ? E_FATAL : E_LOG;\n#if !defined(NO_SSL)\n\tSSL\t\t*ssl = NULL;\n#else\n\tis_ssl = is_ssl;\t/* supress warnings */\n#endif /* NO_SSL */\n\n\tsa.len = sizeof(sa.u.sin);\n\t(void) _shttpd_set_non_blocking_mode(sock);\n\n\tif (getpeername(sock, &sa.u.sa, &sa.len)) {\n\t\t_shttpd_elog(l, NULL, \"add_socket: %s\", strerror(errno));\n#if !defined(NO_SSL)\n\t} else if (is_ssl && (ssl = SSL_new(ctx->ssl_ctx)) == NULL) {\n\t\t_shttpd_elog(l, NULL, \"add_socket: SSL_new: %s\", strerror(ERRNO));\n\t\t(void) closesocket(sock);\n\t} else if (is_ssl && SSL_set_fd(ssl, sock) == 0) {\n\t\t_shttpd_elog(l, NULL, \"add_socket: SSL_set_fd: %s\", strerror(ERRNO));\n\t\t(void) closesocket(sock);\n\t\tSSL_free(ssl);\n#endif /* NO_SSL */\n\t} else if ((c = calloc(1, sizeof(*c) + 2 * URI_MAX)) == NULL) {\n#if !defined(NO_SSL)\n\t\tif (ssl)\n\t\t\tSSL_free(ssl);\n#endif /* NO_SSL */\n\t\t(void) closesocket(sock);\n\t\t_shttpd_elog(l, NULL, \"add_socket: calloc: %s\", strerror(ERRNO));\n\t} else {\n\t\tc->rem.conn\t= c->loc.conn = c;\n\t\tc->ctx\t\t= ctx;\n\t\tc->worker\t= worker;\n\t\tc->sa\t\t= sa;\n\t\tc->birth_time\t= _shttpd_current_time;\n\t\tc->expire_time\t= _shttpd_current_time + EXPIRE_TIME;\n\n\t\t(void) getsockname(sock, &sa.u.sa, &sa.len);\n\t\tc->loc_port = sa.u.sin.sin_port;\n\n\t\t_shttpd_set_close_on_exec(sock);\n\n\t\tc->loc.io_class\t= NULL;\n\n\t\tc->rem.io_class\t= &_shttpd_io_socket;\n\t\tc->rem.chan.sock = sock;\n\n\t\t/* Set IO buffers */\n\t\tc->loc.io.buf\t= (char *) (c + 1);\n\t\tc->rem.io.buf\t= c->loc.io.buf + URI_MAX;\n\t\tc->loc.io.size\t= c->rem.io.size = URI_MAX;\n\n#if !defined(NO_SSL)\n\t\tif (is_ssl) {\n\t\t\tc->rem.io_class\t= &_shttpd_io_ssl;\n\t\t\tc->rem.chan.ssl.sock = sock;\n\t\t\tc->rem.chan.ssl.ssl = ssl;\n\t\t\t_shttpd_ssl_handshake(&c->rem);\n\t\t}\n#endif /* NO_SSL */\n\n\t\tLL_TAIL(&worker->connections, &c->link);\n\t\tworker->num_conns++;\n\n\t\tDBG((\"%s:%hu connected (socket %d)\",\n\t\t    inet_ntoa(* (struct in_addr *) &sa.u.sin.sin_addr.s_addr),\n\t\t    ntohs(sa.u.sin.sin_port), sock));\n\t}\n}\n\nstatic struct worker *\nfirst_worker(struct shttpd_ctx *ctx)\n{\n\treturn (LL_ENTRY(ctx->workers.next, struct worker, link));\n}\n\nstatic void\npass_socket(struct shttpd_ctx *ctx, int sock, int is_ssl)\n{\n\tstruct llhead\t*lp;\n\tstruct worker\t*worker, *lazy;\n\tint\t\tbuf[3];\n\n\tlazy = first_worker(ctx);\n\n\t/* Find least busy worker */\n\tLL_FOREACH(&ctx->workers, lp) {\n\t\tworker = LL_ENTRY(lp, struct worker, link);\n\t\tif (worker->num_conns < lazy->num_conns)\n\t\t\tlazy = worker;\n\t}\n\n\tbuf[0] = CTL_PASS_SOCKET;\n\tbuf[1] = sock;\n\tbuf[2] = is_ssl;\n\n\t(void) send(lazy->ctl[1], (void *) buf, sizeof(buf), 0);\n}\n\nstatic int\nset_ports(struct shttpd_ctx *ctx, const char *p)\n{\n\tint\t\tsock, len, is_ssl, port;\n\tstruct listener\t*l;\n\n\n\tfree_list(&ctx->listeners, &listener_destructor);\n\n\tFOR_EACH_WORD_IN_LIST(p, len) {\n\n\t\tis_ssl\t= p[len - 1] == 's' ? 1 : 0;\n\t\tport\t= atoi(p);\n\n\t\tif ((sock = shttpd_open_listening_port(port)) == -1) {\n\t\t\t_shttpd_elog(E_LOG, NULL, \"cannot open port %d\", port);\n\t\t\tgoto fail;\n\t\t} else if (is_ssl && ctx->ssl_ctx == NULL) {\n\t\t\t(void) closesocket(sock);\n\t\t\t_shttpd_elog(E_LOG, NULL, \"cannot add SSL socket, \"\n\t\t\t    \"please specify certificate file\");\n\t\t\tgoto fail;\n\t\t} else if ((l = calloc(1, sizeof(*l))) == NULL) {\n\t\t\t(void) closesocket(sock);\n\t\t\t_shttpd_elog(E_LOG, NULL, \"cannot allocate listener\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tl->is_ssl = is_ssl;\n\t\t\tl->sock\t= sock;\n\t\t\tl->ctx\t= ctx;\n\t\t\tLL_TAIL(&ctx->listeners, &l->link);\n\t\t\tDBG((\"shttpd_listen: added socket %d\", sock));\n\t\t}\n\t}\n\n\treturn (TRUE);\nfail:\n\tfree_list(&ctx->listeners, &listener_destructor);\n\treturn (FALSE);\n}\n\nstatic void\nread_stream(struct stream *stream)\n{\n\tint\tn, len;\n\n\tlen = io_space_len(&stream->io);\n\tassert(len > 0);\n\n\t/* Do not read more that needed */\n\tif (stream->content_len > 0 &&\n\t    stream->io.total + len > stream->content_len)\n\t\tlen = stream->content_len - stream->io.total;\n\n\t/* Read from underlying channel */\n\tassert(stream->io_class != NULL);\n\tn = stream->io_class->read(stream, io_space(&stream->io), len);\n\n\tif (n > 0)\n\t\tio_inc_head(&stream->io, n);\n\telse if (n == -1 && (ERRNO == EINTR || ERRNO == EWOULDBLOCK))\n\t\tn = n;\t/* Ignore EINTR and EAGAIN */\n\telse if (!(stream->flags & FLAG_DONT_CLOSE))\n\t\t_shttpd_stop_stream(stream);\n\n\tDBG((\"read_stream (%d %s): read %d/%d/%lu bytes (errno %d)\",\n\t    stream->conn->rem.chan.sock,\n\t    stream->io_class ? stream->io_class->name : \"(null)\",\n\t    n, len, (unsigned long) stream->io.total, ERRNO));\n\n\t/*\n\t * Close the local stream if everything was read\n\t * XXX We do not close the remote stream though! It may be\n\t * a POST data completed transfer, we do not want the socket\n\t * to be closed.\n\t */\n\tif (stream->content_len > 0 && stream == &stream->conn->loc) {\n\t\tassert(stream->io.total <= stream->content_len);\n\t\tif (stream->io.total == stream->content_len)\n\t\t\t_shttpd_stop_stream(stream);\n\t}\n\n\tstream->conn->expire_time = _shttpd_current_time + EXPIRE_TIME;\n}\n\nstatic void\nwrite_stream(struct stream *from, struct stream *to)\n{\n\tint\tn, len;\n\n\tlen = io_data_len(&from->io);\n\tassert(len > 0);\n\n\t/* TODO: should be assert on CAN_WRITE flag */\n\tn = to->io_class->write(to, io_data(&from->io), len);\n\tto->conn->expire_time = _shttpd_current_time + EXPIRE_TIME;\n\tDBG((\"write_stream (%d %s): written %d/%d bytes (errno %d)\",\n\t    to->conn->rem.chan.sock,\n\t    to->io_class ? to->io_class->name : \"(null)\", n, len, ERRNO));\n\n\tif (n > 0)\n\t\tio_inc_tail(&from->io, n);\n\telse if (n == -1 && (ERRNO == EINTR || ERRNO == EWOULDBLOCK))\n\t\tn = n;\t/* Ignore EINTR and EAGAIN */\n\telse if (!(to->flags & FLAG_DONT_CLOSE))\n\t\t_shttpd_stop_stream(to);\n}\n\n\nstatic int\nconnection_desctructor(struct llhead *lp)\n{\n\tstruct conn\t\t*c = LL_ENTRY(lp, struct conn, link);\n\tstatic const struct vec\tvec = {\"close\", 5};\n\tint\t\t\tdo_close;\n\n\tDBG((\"Disconnecting %d (%.*s)\", c->rem.chan.sock,\n\t    c->ch.connection.v_vec.len, c->ch.connection.v_vec.ptr));\n\n\tif (c->request != NULL && c->ctx->access_log != NULL)\n\t\t_shttpd_log_access(c->ctx->access_log, c);\n\n\t/* In inetd mode, exit if request is finished. */\n\tif (IS_TRUE(c->ctx, OPT_INETD))\n\t\texit(0);\n\n\tif (c->loc.io_class != NULL && c->loc.io_class->close != NULL)\n\t\tc->loc.io_class->close(&c->loc);\n\n\t/*\n\t * Check the \"Connection: \" header before we free c->request\n\t * If it its 'keep-alive', then do not close the connection\n\t */\n\tdo_close = c->rem.flags & FLAG_CLOSED ||\n\t    (c->ch.connection.v_vec.len >= vec.len &&\n\t    !_shttpd_strncasecmp(vec.ptr,c->ch.connection.v_vec.ptr,vec.len)) ||\n\t    (c->major_version < 1 ||\n\t    (c->major_version >= 1 && c->minor_version < 1));\n\n\tif (c->request)\n\t\tfree(c->request);\n\tif (c->uri)\n\t\tfree(c->uri);\n\n\t/* Keep the connection open only if we have Content-Length set */\n\tif (!do_close && c->loc.content_len > 0) {\n\t\tc->loc.io_class = NULL;\n\t\tc->loc.flags = 0;\n\t\tc->loc.content_len = 0;\n\t\tc->rem.flags = FLAG_W | FLAG_R | FLAG_SSL_ACCEPTED;\n\t\tc->query = c->request = c->uri = c->path_info = NULL;\n\t\tc->mime_type.len = 0;\n\t\t(void) memset(&c->ch, 0, sizeof(c->ch));\n\t\tio_clear(&c->loc.io);\n\t\tc->birth_time = _shttpd_current_time;\n\t\tif (io_data_len(&c->rem.io) > 0)\n\t\t\treturn 1;\n\t} else {\n\t\tif (c->rem.io_class != NULL)\n\t\t\tc->rem.io_class->close(&c->rem);\n\n\t\tLL_DEL(&c->link);\n\t\tc->worker->num_conns--;\n\t\tassert(c->worker->num_conns >= 0);\n\n\t\tfree(c);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nworker_destructor(struct llhead *lp)\n{\n\tstruct worker\t*worker = LL_ENTRY(lp, struct worker, link);\n\n\tfree_list(&worker->connections, (void (*)(struct llhead *))connection_desctructor);\n\tfree(worker);\n}\n\nstatic int\nis_allowed(const struct shttpd_ctx *ctx, const struct usa *usa)\n{\n\tconst struct acl\t*acl;\n\tconst struct llhead\t*lp;\n\tint\t\t\tallowed = '+';\n\tuint32_t\t\tip;\n\n\tLL_FOREACH(&ctx->acl, lp) {\n\t\tacl = LL_ENTRY(lp, struct acl, link);\n\t\t(void) memcpy(&ip, &usa->u.sin.sin_addr, sizeof(ip));\n\t\tif (acl->ip == (ntohl(ip) & acl->mask))\n\t\t\tallowed = acl->flag;\n\t}\n\n\treturn (allowed == '+');\n}\n\nstatic void\nadd_to_set(int fd, fd_set *set, int *max_fd)\n{\n\tFD_SET(fd, set);\n\tif (fd > *max_fd)\n\t\t*max_fd = fd;\n}\n\nstatic void\nprocess_connection(struct conn *c, int remote_ready, int local_ready)\n{\nagain:\n\t/* Read from remote end if it is ready */\n\tif (remote_ready && io_space_len(&c->rem.io))\n\t\tread_stream(&c->rem);\n\n\t/* If the request is not parsed yet, do so */\n\tif (!(c->rem.flags & FLAG_HEADERS_PARSED))\n\t\tparse_http_request(c);\n\n\tDBG((\"loc: %d [%.*s]\", (int) io_data_len(&c->loc.io),\n\t    (int) io_data_len(&c->loc.io), io_data(&c->loc.io)));\n\tDBG((\"rem: %d [%.*s]\", (int) io_data_len(&c->rem.io),\n\t    (int) io_data_len(&c->rem.io), io_data(&c->rem.io)));\n\n\t/* Read from the local end if it is ready */\n\tif (local_ready && io_space_len(&c->loc.io))\n\t\tread_stream(&c->loc);\n\n\tif (io_data_len(&c->rem.io) > 0 && (c->loc.flags & FLAG_W) &&\n\t    c->loc.io_class != NULL && c->loc.io_class->write != NULL)\n\t\twrite_stream(&c->rem, &c->loc);\n\n\tif (io_data_len(&c->loc.io) > 0 && c->rem.io_class != NULL)\n\t\twrite_stream(&c->loc, &c->rem);\n\n\t/* Check whether we should close this connection */\n\tif ((_shttpd_current_time > c->expire_time) ||\n\t    (c->rem.flags & FLAG_CLOSED) ||\n\t    ((c->loc.flags & FLAG_CLOSED) && !io_data_len(&c->loc.io)))\n\t\tif (connection_desctructor(&c->link)) {\n\t\t\t// More data to read and process ...\n\t\t\tremote_ready = 0;\n\t\t\tlocal_ready = 0;\n\t\t\tgoto again;\n\t\t}\n}\n\nstatic int\nnum_workers(const struct shttpd_ctx *ctx)\n{\n\tchar\t*p = ctx->options[OPT_THREADS];\n\treturn (p ? atoi(p) : 1);\n}\n\nstatic void\nhandle_connected_socket(struct shttpd_ctx *ctx,\n\t\tstruct usa *sap, int sock, int is_ssl)\n{\n#if !defined(_WIN32)\n\tif (sock >= (int) FD_SETSIZE) {\n\t\t_shttpd_elog(E_LOG, NULL, \"ctx %p: discarding \"\n\t\t    \"socket %d, too busy\", ctx, sock);\n\t\t(void) closesocket(sock);\n\t} else\n#endif /* !_WIN32 */\n\t\tif (!is_allowed(ctx, sap)) {\n\t\t_shttpd_elog(E_LOG, NULL, \"%s is not allowed to connect\",\n\t\t    inet_ntoa(sap->u.sin.sin_addr));\n\t\t(void) closesocket(sock);\n\t} else if (num_workers(ctx) > 1) {\n\t\tpass_socket(ctx, sock, is_ssl);\n\t} else {\n\t\tadd_socket(first_worker(ctx), sock, is_ssl);\n\t}\n}\n\nstatic int\ndo_select(int max_fd, fd_set *read_set, fd_set *write_set, int milliseconds)\n{\n\tstruct timeval\ttv;\n\tint\t\tn;\n\n\ttv.tv_sec = milliseconds / 1000;\n\ttv.tv_usec = (milliseconds % 1000) * 1000;\n\n\t/* Check IO readiness */\n\tif ((n = select(max_fd + 1, read_set, write_set, NULL, &tv)) < 0) {\n#ifdef _WIN32\n\t\t/*\n\t\t * On windows, if read_set and write_set are empty,\n\t\t * select() returns \"Invalid parameter\" error\n\t\t * (at least on my Windows XP Pro). So in this case,\n\t\t * we sleep here.\n\t\t */\n\t\tSleep(milliseconds);\n#endif /* _WIN32 */\n\t\tDBG((\"select: %d\", ERRNO));\n\t}\n\n\treturn (n);\n}\n\nstatic int\nmultiplex_worker_sockets(const struct worker *worker, int *max_fd,\n\t\tfd_set *read_set, fd_set *write_set)\n{\n\tstruct llhead\t*lp;\n\tstruct conn\t*c;\n\tint\t\tnowait = FALSE;\n\n\t/* Add control socket */\n\tadd_to_set(worker->ctl[0], read_set, max_fd);\n\n\t/* Multiplex streams */\n\tLL_FOREACH(&worker->connections, lp) {\n\t\tc = LL_ENTRY(lp, struct conn, link);\n\n\t\t/* If there is a space in remote IO, check remote socket */\n\t\tif (io_space_len(&c->rem.io))\n\t\t\tadd_to_set(c->rem.chan.fd, read_set, max_fd);\n\n#if !defined(NO_CGI)\n\t\t/*\n\t\t * If there is a space in local IO, and local endpoint is\n\t\t * CGI, check local socket for read availability\n\t\t */\n\t\tif (io_space_len(&c->loc.io) && (c->loc.flags & FLAG_R) &&\n\t\t    c->loc.io_class == &_shttpd_io_cgi)\n\t\t\tadd_to_set(c->loc.chan.fd, read_set, max_fd);\n\n\t\t/*\n\t\t * If there is some data read from remote socket, and\n\t\t * local endpoint is CGI, check local for write availability\n\t\t */\n\t\tif (io_data_len(&c->rem.io) && (c->loc.flags & FLAG_W) &&\n\t\t    c->loc.io_class == &_shttpd_io_cgi)\n\t\t\tadd_to_set(c->loc.chan.fd, write_set, max_fd);\n#endif /* NO_CGI */\n\n\t\t/*\n\t\t * If there is some data read from local endpoint, check the\n\t\t * remote socket for write availability\n\t\t */\n\t\tif (io_data_len(&c->loc.io) && !(c->loc.flags & FLAG_SUSPEND))\n\t\t\tadd_to_set(c->rem.chan.fd, write_set, max_fd);\n\n\t\t/*\n\t\t * Set select wait interval to zero if FLAG_ALWAYS_READY set\n\t\t */\n\t\tif (io_space_len(&c->loc.io) && (c->loc.flags & FLAG_R) &&\n\t\t    (c->loc.flags & FLAG_ALWAYS_READY))\n\t\t\tnowait = TRUE;\n\n\t\tif (io_data_len(&c->rem.io) && (c->loc.flags & FLAG_W) &&\n\t\t    (c->loc.flags & FLAG_ALWAYS_READY))\n\t\t\tnowait = TRUE;\n\t}\n\n\treturn (nowait);\n}\n\nint\nshttpd_join(struct shttpd_ctx *ctx,\n\t\tfd_set *read_set, fd_set *write_set, int *max_fd)\n{\n\tstruct llhead\t*lp;\n\tstruct listener\t*l;\n\tint\t\tnowait = FALSE;\n\n\t/* Add listening sockets to the read set */\n\tLL_FOREACH(&ctx->listeners, lp) {\n\t\tl = LL_ENTRY(lp, struct listener, link);\n\t\tadd_to_set(l->sock, read_set, max_fd);\n\t\tDBG((\"FD_SET(%d) (listening)\", l->sock));\n\t}\n\n\tif (num_workers(ctx) == 1)\n\t\tnowait = multiplex_worker_sockets(first_worker(ctx), max_fd,\n\t\t    read_set, write_set);\n\n\treturn (nowait);\n}\n\n\nstatic void\nprocess_worker_sockets(struct worker *worker, fd_set *read_set)\n{\n\tstruct llhead\t*lp, *tmp;\n\tint\t\tcmd, skt[2], sock = worker->ctl[0];\n\tstruct conn\t*c;\n\n\t/* Check if new socket is passed to us over the control socket */\n\tif (FD_ISSET(worker->ctl[0], read_set))\n\t\twhile (recv(sock, (void *) &cmd, sizeof(cmd), 0) == sizeof(cmd))\n\t\t\tswitch (cmd) {\n\t\t\tcase CTL_PASS_SOCKET:\n\t\t\t\t(void)recv(sock, (void *) &skt, sizeof(skt), 0);\n\t\t\t\tadd_socket(worker, skt[0], skt[1]);\n\t\t\t\tbreak;\n\t\t\tcase CTL_WAKEUP:\n\t\t\t\t(void)recv(sock, (void *) &c, sizeof(c), 0);\n\t\t\t\tc->loc.flags &= FLAG_SUSPEND;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_shttpd_elog(E_FATAL, NULL, \"ctx %p: ctl cmd %d\",\n\t\t\t\t    worker->ctx, cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t/* Process all connections */\n\tLL_FOREACH_SAFE(&worker->connections, lp, tmp) {\n\t\tc = LL_ENTRY(lp, struct conn, link);\n\t\tprocess_connection(c, FD_ISSET(c->rem.chan.sock, read_set),\n\t\t    c->loc.io_class != NULL &&\n\t\t    ((c->loc.flags & FLAG_ALWAYS_READY)\n#if !defined(NO_CGI)\n\t\t    || (c->loc.io_class == &_shttpd_io_cgi &&\n\t\t     FD_ISSET(c->loc.chan.fd, read_set))\n#endif /* NO_CGI */\n\t\t    ));\n\t}\n}\n\n/*\n * One iteration of server loop. This is the core of the data exchange.\n */\nvoid\nshttpd_poll(struct shttpd_ctx *ctx, int milliseconds)\n{\n\tstruct llhead\t*lp;\n\tstruct listener\t*l;\n\tfd_set\t\tread_set, write_set;\n\tint\t\tsock, max_fd = -1;\n\tstruct usa\tsa;\n\n\t_shttpd_current_time = time(0);\n\tFD_ZERO(&read_set);\n\tFD_ZERO(&write_set);\n\n\tif (shttpd_join(ctx, &read_set, &write_set, &max_fd))\n\t\tmilliseconds = 0;\n\n\tif (do_select(max_fd, &read_set, &write_set, milliseconds) < 0)\n\t\treturn;;\n\n\t/* Check for incoming connections on listener sockets */\n\tLL_FOREACH(&ctx->listeners, lp) {\n\t\tl = LL_ENTRY(lp, struct listener, link);\n\t\tif (!FD_ISSET(l->sock, &read_set))\n\t\t\tcontinue;\n\t\tdo {\n\t\t\tsa.len = sizeof(sa.u.sin);\n\t\t\tif ((sock = accept(l->sock, &sa.u.sa, &sa.len)) != -1)\n\t\t\t\thandle_connected_socket(ctx,&sa,sock,l->is_ssl);\n\t\t} while (sock != -1);\n\t}\n\n\tif (num_workers(ctx) == 1)\n\t\tprocess_worker_sockets(first_worker(ctx), &read_set);\n}\n\n/*\n * Deallocate shttpd object, free up the resources\n */\nvoid\nshttpd_fini(struct shttpd_ctx *ctx)\n{\n\tsize_t\ti;\n\n\tfree_list(&ctx->workers, worker_destructor);\n\tfree_list(&ctx->registered_uris, registered_uri_destructor);\n\tfree_list(&ctx->acl, acl_destructor);\n\tfree_list(&ctx->listeners, listener_destructor);\n#if !defined(NO_SSI)\n\tfree_list(&ctx->ssi_funcs, _shttpd_ssi_func_destructor);\n#endif /* !NO_SSI */\n\n\tfor (i = 0; i < NELEMS(ctx->options); i++)\n\t\tif (ctx->options[i] != NULL)\n\t\t\tfree(ctx->options[i]);\n\n\tif (ctx->access_log)\t\t(void) fclose(ctx->access_log);\n\tif (ctx->error_log)\t\t(void) fclose(ctx->error_log);\n\n\t/* TODO: free SSL context */\n\n\tfree(ctx);\n}\n\n/*\n * UNIX socketpair() implementation. Why? Because Windows does not have it.\n * Return 0 on success, -1 on error.\n */\nint\nshttpd_socketpair(int sp[2])\n{\n\tstruct sockaddr_in\tsa;\n\tint\t\t\tsock, ret = -1;\n\tsocklen_t\t\tlen = sizeof(sa);\n\n\tsp[0] = sp[1] = -1;\n\n\t(void) memset(&sa, 0, sizeof(sa));\n\tsa.sin_family \t\t= AF_INET;\n\tsa.sin_port\t\t= htons(0);\n\tsa.sin_addr.s_addr\t= htonl(INADDR_LOOPBACK);\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) != -1 &&\n\t    !bind(sock, (struct sockaddr *) &sa, len) &&\n\t    !listen(sock, 1) &&\n\t    !getsockname(sock, (struct sockaddr *) &sa, &len) &&\n\t    (sp[0] = socket(AF_INET, SOCK_STREAM, 6)) != -1 &&\n\t    !connect(sp[0], (struct sockaddr *) &sa, len) &&\n\t    (sp[1] = accept(sock,(struct sockaddr *) &sa, &len)) != -1) {\n\n\t\t/* Success */\n\t\tret = 0;\n\t} else {\n\n\t\t/* Failure, close descriptors */\n\t\tif (sp[0] != -1)\n\t\t\t(void) closesocket(sp[0]);\n\t\tif (sp[1] != -1)\n\t\t\t(void) closesocket(sp[1]);\n\t}\n\n\t(void) closesocket(sock);\n\t(void) _shttpd_set_non_blocking_mode(sp[0]);\n\t(void) _shttpd_set_non_blocking_mode(sp[1]);\n\n#ifndef _WIN32\n\t(void) fcntl(sp[0], F_SETFD, FD_CLOEXEC);\n\t(void) fcntl(sp[1], F_SETFD, FD_CLOEXEC);\n#endif /* _WIN32*/\n\n\treturn (ret);\n}\n\nstatic int isbyte(int n) { return (n >= 0 && n <= 255); }\n\nstatic int\nset_inetd(struct shttpd_ctx *ctx, const char *flag)\n{\n\tctx = NULL; /* Unused */\n\n\tif (_shttpd_is_true(flag)) {\n\t\tshttpd_set_option(ctx, \"ports\", NULL);\n\t\t(void) freopen(\"/dev/null\", \"a\", stderr);\n\t\tadd_socket(first_worker(ctx), 0, 0);\n\t}\n\n\treturn (TRUE);\n}\n\nstatic int\nset_uid(struct shttpd_ctx *ctx, const char *uid)\n{\n\tstruct passwd\t*pw;\n\n\tctx = NULL; /* Unused */\n\n#if !defined(_WIN32)\n\tif ((pw = getpwnam(uid)) == NULL)\n\t\t_shttpd_elog(E_FATAL, 0, \"%s: unknown user [%s]\", __func__, uid);\n\telse if (setgid(pw->pw_gid) == -1)\n\t\t_shttpd_elog(E_FATAL, NULL, \"%s: setgid(%s): %s\",\n\t\t    __func__, uid, strerror(errno));\n\telse if (setuid(pw->pw_uid) == -1)\n\t\t_shttpd_elog(E_FATAL, NULL, \"%s: setuid(%s): %s\",\n\t\t    __func__, uid, strerror(errno));\n#endif /* !_WIN32 */\n\treturn (TRUE);\n}\n\nstatic int\nset_acl(struct shttpd_ctx *ctx, const char *s)\n{\n\tstruct acl\t*acl = NULL;\n\tchar\t\tflag;\n\tint\t\tlen, a, b, c, d, n, mask;\n\n\t/* Delete the old ACLs if any */\n\tfree_list(&ctx->acl, acl_destructor);\n\n\tFOR_EACH_WORD_IN_LIST(s, len) {\n\n\t\tmask = 32;\n\n\t\tif (sscanf(s, \"%c%d.%d.%d.%d%n\",&flag,&a,&b,&c,&d,&n) != 5) {\n\t\t\t_shttpd_elog(E_FATAL, NULL, \"[%s]: subnet must be \"\n\t\t\t    \"[+|-]x.x.x.x[/x]\", s);\n\t\t} else if (flag != '+' && flag != '-') {\n\t\t\t_shttpd_elog(E_FATAL, NULL, \"flag must be + or -: [%s]\", s);\n\t\t} else if (!isbyte(a)||!isbyte(b)||!isbyte(c)||!isbyte(d)) {\n\t\t\t_shttpd_elog(E_FATAL, NULL, \"bad ip address: [%s]\", s);\n\t\t} else\tif ((acl = malloc(sizeof(*acl))) == NULL) {\n\t\t\t_shttpd_elog(E_FATAL, NULL, \"%s\", \"cannot malloc subnet\");\n\t\t} else if (sscanf(s + n, \"/%d\", &mask) == 0) {\n\t\t\t/* Do nothing, no mask specified */\n\t\t} else if (mask < 0 || mask > 32) {\n\t\t\t_shttpd_elog(E_FATAL, NULL, \"bad subnet mask: %d [%s]\", n, s);\n\t\t}\n\n\t\tacl->ip = (a << 24) | (b << 16) | (c << 8) | d;\n\t\tacl->mask = mask ? 0xffffffffU << (32 - mask) : 0;\n\t\tacl->flag = flag;\n\t\tLL_TAIL(&ctx->acl, &acl->link);\n\t}\n\n\treturn (TRUE);\n}\n\n#ifndef NO_SSL\n/*\n * Dynamically load SSL library. Set up ctx->ssl_ctx pointer.\n */\nstatic int\nset_ssl(struct shttpd_ctx *ctx, const char *pem)\n{\n\tSSL_CTX\t\t*CTX;\n\tvoid\t\t*lib;\n\tstruct ssl_func\t*fp;\n\tchar *ssl_disabled_protocols = wsmand_options_get_ssl_disabled_protocols();\n\tchar *ssl_cipher_list = wsmand_options_get_ssl_cipher_list();\n\tint\t\tretval = FALSE;\n\tEC_KEY*\t\tkey;\n\n\t/* Load SSL library dynamically */\n\tif ((lib = dlopen(SSL_LIB, RTLD_LAZY)) == NULL) {\n\t\t_shttpd_elog(E_LOG, NULL, \"set_ssl: cannot load %s\", SSL_LIB);\n\t\treturn (FALSE);\n\t}\n\n\tfor (fp = ssl_sw; fp->name != NULL; fp++)\n\t\tif ((fp->ptr.v_void = dlsym(lib, fp->name)) == NULL) {\n\t\t\t_shttpd_elog(E_LOG, NULL,\"set_ssl: cannot find %s\", fp->name);\n\t\t\treturn (FALSE);\n\t\t}\n\n\t/* Initialize SSL crap */\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\tSSL_library_init();\n\tif ((CTX = SSL_CTX_new(SSLv23_server_method())) == NULL)\n#else\n        OPENSSL_init_ssl();\n\tif ((CTX = SSL_CTX_new(TLS_server_method())) == NULL)\n#endif\n\t\t_shttpd_elog(E_LOG, NULL, \"SSL_CTX_new error\");\n\telse if (SSL_CTX_use_certificate_file(CTX, wsmand_options_get_ssl_cert_file(), SSL_FILETYPE_PEM) != 1)\n\t\t_shttpd_elog(E_LOG, NULL, \"cannot open certificate file %s\", pem);\n\telse if (SSL_CTX_use_PrivateKey_file(CTX, wsmand_options_get_ssl_key_file(), SSL_FILETYPE_PEM) != 1)\n\t\t_shttpd_elog(E_LOG, NULL, \"cannot open PrivateKey %s\", pem);\n\telse\n\t\tretval = TRUE;\n\n\t/* This enables ECDH Perfect Forward secrecy. Currently with just the most generic p256 prime curve */\n\tkey = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tif (key != NULL) {\n\t\tSSL_CTX_set_tmp_ecdh(CTX, key);\n\t\tEC_KEY_free(key);\n\t}\n\n\twhile (ssl_disabled_protocols) {\n\t\tstruct ctx_opts_t {\n\t\t\tchar *name;\n\t\t\tlong opt;\n\t\t} protocols[] = {\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\t\t\t{ \"SSLv2\", SSL_OP_NO_SSLv2 },\n#endif\n\t\t\t{ \"SSLv3\", SSL_OP_NO_SSLv3 },\n\t\t\t{ \"TLSv1\", SSL_OP_NO_TLSv1 },\n# if OPENSSL_VERSION_NUMBER >= 0x10001000L\n\t\t\t{ \"TLSv1_1\", SSL_OP_NO_TLSv1_1 },\n\t\t\t{ \"TLSv1_2\", SSL_OP_NO_TLSv1_2 },\n# endif\n\t\t\t{ NULL, 0 }\n\t\t};\n\t\tchar *blank_ptr;\n\t\tint idx;\n\t\tif (*ssl_disabled_protocols == 0)\n\t\t\tbreak;\n\t\tblank_ptr = strchr(ssl_disabled_protocols, ' ');\n\t\tif (blank_ptr == NULL)\n\t\t\tblank_ptr = ssl_disabled_protocols + strlen(ssl_disabled_protocols);\n\t\tfor (idx = 0; protocols[idx].name ; ++idx) {\n\t\t\tif (strncasecmp(protocols[idx].name, ssl_disabled_protocols, blank_ptr-ssl_disabled_protocols) == 0) {\n\t\t\t\t//_shttpd_elog(E_LOG, NULL, \"SSL: disable %s protocol\", protocols[idx].name);\n\t\t\t\tdebug(\"SSL: disable %s protocol\", protocols[idx].name);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\t\tSSL_CTX_set_options(CTX, protocols[idx].opt);\n#else\n\t\t\t\tSSL_CTX_ctrl(CTX, SSL_CTRL_OPTIONS, protocols[idx].opt, NULL);\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*blank_ptr == 0)\n\t\t\tbreak;\n\t\tssl_disabled_protocols = blank_ptr + 1;\n\t}\n\n\tif (ssl_cipher_list) {\n          int rc = SSL_CTX_set_cipher_list(CTX, ssl_cipher_list);\n          if (rc != 1) {\n            _shttpd_elog(E_LOG, NULL, \"Failed to set SSL cipher list \\\"%s\\\"\", ssl_cipher_list);\n          }\n        }\n        else {\n          _shttpd_elog(E_LOG, NULL, \"Empty 'ssl_cipher_list' defaults to 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256'.\");\n          _shttpd_elog(E_LOG, NULL, \"Check openSSL documentation.\");\n        }\n\tctx->ssl_ctx = CTX;\n\n\treturn (retval);\n}\n#endif /* NO_SSL */\n\nstatic int\nopen_log_file(FILE **fpp, const char *path)\n{\n\tint\tretval = TRUE;\n\n\tif (*fpp != NULL)\n\t\t(void) fclose(*fpp);\n\n\tif (path == NULL) {\n\t\t*fpp = NULL;\n\t} else if ((*fpp = fopen(path, \"a\")) == NULL) {\n\t\t_shttpd_elog(E_LOG, NULL, \"cannot open log file %s: %s\",\n\t\t    path, strerror(errno));\n\t\tretval = FALSE;\n\t}\n\n\treturn (retval);\n}\n\nstatic int set_alog(struct shttpd_ctx *ctx, const char *path) {\n\treturn (open_log_file(&ctx->access_log, path));\n}\n\nstatic int set_elog(struct shttpd_ctx *ctx, const char *path) {\n\treturn (open_log_file(&ctx->error_log, path));\n}\n\nstatic void show_cfg_page(struct shttpd_arg *arg);\n\nstatic int\nset_cfg_uri(struct shttpd_ctx *ctx, const char *uri)\n{\n\tfree_list(&ctx->registered_uris, &registered_uri_destructor);\n\n\tif (uri != NULL)\n\t\tshttpd_register_uri(ctx, uri, &show_cfg_page, ctx);\n\n\treturn (TRUE);\n}\n\nstatic struct worker *\nadd_worker(struct shttpd_ctx *ctx)\n{\n\tstruct worker\t*worker;\n\n\tif ((worker = calloc(1, sizeof(*worker))) == NULL)\n\t\t_shttpd_elog(E_FATAL, NULL, \"Cannot allocate worker\");\n\tLL_INIT(&worker->connections);\n\tworker->ctx = ctx;\n\t(void) shttpd_socketpair(worker->ctl);\n\tLL_TAIL(&ctx->workers, &worker->link);\n\n\treturn (worker);\n}\n\n#if !defined(NO_THREADS)\nstatic void\npoll_worker(struct worker *worker, int milliseconds)\n{\n\tfd_set\t\tread_set, write_set;\n\tint\t\tmax_fd = -1;\n\n\tFD_ZERO(&read_set);\n\tFD_ZERO(&write_set);\n\n\tif (multiplex_worker_sockets(worker, &max_fd, &read_set, &write_set))\n\t\tmilliseconds = 0;\n\n\tif (do_select(max_fd, &read_set, &write_set, milliseconds) < 0)\n\t\treturn;;\n\n\tprocess_worker_sockets(worker, &read_set);\n}\n\nstatic void\nworker_function(void *param)\n{\n\tstruct worker *worker = param;\n\n\twhile (worker->exit_flag == 0)\n\t\tpoll_worker(worker, 1000 * 10);\n\n\tfree_list(&worker->connections, (void (*)(struct llhead *))connection_desctructor);\n\tfree(worker);\n}\n\nstatic int\nset_workers(struct shttpd_ctx *ctx, const char *value)\n{\n\tint\t\tnew_num, old_num;\n\tstruct llhead\t*lp, *tmp;\n\tstruct worker\t*worker;\n\n       \tnew_num = atoi(value);\n\told_num = 0;\n\tLL_FOREACH(&ctx->workers, lp)\n\t\told_num++;\n\n\tif (new_num == 1) {\n\t\tif (old_num > 1)\n\t\t\t/* Stop old threads */\n\t\t\tLL_FOREACH_SAFE(&ctx->workers, lp, tmp) {\n\t\t\t\tworker = LL_ENTRY(lp, struct worker, link);\n\t\t\t\tLL_DEL(&worker->link);\n\t\t\t\tworker = LL_ENTRY(lp, struct worker, link);\n\t\t\t\tworker->exit_flag = 1;\n\t\t\t}\n\t\t(void) add_worker(ctx);\n\t} else {\n\t\t/* FIXME: we cannot here reduce the number of threads */\n\t\twhile (new_num > 1 && new_num > old_num) {\n\t\t\tworker = add_worker(ctx);\n\t\t\t_beginthread(worker_function, 0, worker);\n\t\t\told_num++;\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n#endif /* NO_THREADS */\n\nstatic const struct opt {\n\tint\t\tindex;\t\t/* Index in shttpd_ctx\t\t*/\n\tconst char\t*name;\t\t/* Option name in config file\t*/\n\tconst char\t*description;\t/* Description\t\t\t*/\n\tconst char\t*default_value;\t/* Default option value\t\t*/\n\tint (*setter)(struct shttpd_ctx *, const char *);\n} known_options[] = {\n\t{OPT_ROOT, \"root\", \"\\tWeb root directory\", \".\", NULL},\n\t{OPT_INDEX_FILES, \"index_files\", \"Index files\", INDEX_FILES, NULL},\n#ifndef NO_SSL\n\t{OPT_SSL_CERTIFICATE, \"ssl_cert\", \"SSL certificate file\", NULL,set_ssl},\n#endif /* NO_SSL */\n\t{OPT_PORTS, \"ports\", \"Listening ports\", NULL, set_ports},\n\t{OPT_DIR_LIST, \"dir_list\", \"Directory listing\", \"no\", NULL},\n\t{OPT_CFG_URI, \"cfg_uri\", \"Config uri\", NULL, set_cfg_uri},\n\t{OPT_PROTECT, \"protect\", \"URI to htpasswd mapping\", NULL, NULL},\n#ifndef NO_CGI\n\t{OPT_CGI_EXTENSIONS, \"cgi_ext\", \"CGI extensions\", CGI_EXT, NULL},\n\t{OPT_CGI_INTERPRETER, \"cgi_interp\", \"CGI interpreter\", NULL, NULL},\n\t{OPT_CGI_ENVIRONMENT, \"cgi_env\", \"Additional CGI env vars\", NULL, NULL},\n#endif /* NO_CGI */\n\t{OPT_SSI_EXTENSIONS, \"ssi_ext\",\t\"SSI extensions\", SSI_EXT, NULL},\n#ifndef NO_AUTH\n\t{OPT_AUTH_REALM, \"auth_realm\", \"Authentication domain name\",REALM,NULL},\n\t{OPT_AUTH_GPASSWD, \"auth_gpass\", \"Global passwords file\", NULL, NULL},\n\t{OPT_AUTH_PUT, \"auth_PUT\", \"PUT,DELETE auth file\", NULL, NULL},\n#endif /* !NO_AUTH */\n#ifdef _WIN32\n\t{OPT_SERVICE, \"service\", \"Manage WinNNT service (install\"\n\t    \"|uninstall)\", NULL, _shttpd_set_nt_service},\n\t{OPT_HIDE, \"systray\", \"Hide console, show icon on systray\",\n\t\t\"no\", _shttpd_set_systray},\n#else\n\t{OPT_INETD, \"inetd\", \"Inetd mode\", \"no\", set_inetd},\n\t{OPT_UID, \"uid\", \"\\tRun as user\", NULL, set_uid},\n#endif /* _WIN32 */\n\t{OPT_ACCESS_LOG, \"access_log\", \"Access log file\", NULL, set_alog},\n\t{OPT_ERROR_LOG, \"error_log\", \"Error log file\", NULL, set_elog},\n\t{OPT_MIME_TYPES, \"mime_types\", \"Additional mime types list\", NULL,NULL},\n\t{OPT_ALIASES, \"aliases\", \"Path=URI mappings\", NULL, NULL},\n\t{OPT_ACL, \"acl\", \"\\tAllow/deny IP addresses/subnets\", NULL, set_acl},\n#if !defined(NO_THREADS)\n\t{OPT_THREADS, \"threads\", \"Number of worker threads\", \"1\", set_workers},\n#endif /* !NO_THREADS */\n\t{-1, NULL, NULL, NULL, NULL}\n};\n\nstatic const struct opt *\nfind_opt(const char *opt_name)\n{\n\tint\ti;\n\n\tfor (i = 0; known_options[i].name != NULL; i++)\n\t\tif (!strcmp(opt_name, known_options[i].name))\n\t\t\treturn (known_options + i);\n\n\t_shttpd_elog(E_FATAL, NULL, \"no such option: [%s]\", opt_name);\n\n\t/* UNREACHABLE */\n\treturn (NULL);\n}\n\nint\nshttpd_set_option(struct shttpd_ctx *ctx, const char *opt, const char *val)\n{\n\tconst struct opt\t*o = find_opt(opt);\n\tint\t\t\tretval = TRUE;\n\n\t/* Call option setter first, so it can use both new and old values */\n\tif (o->setter != NULL)\n\t\tretval = o->setter(ctx, val);\n\n\t/* Free old value if any */\n\tif (ctx->options[o->index] != NULL)\n\t\tfree(ctx->options[o->index]);\n\n\t/* Set new option value */\n\tctx->options[o->index] = val ? _shttpd_strdup(val) : NULL;\n\n\treturn (retval);\n}\n\nstatic void\nshow_cfg_page(struct shttpd_arg *arg)\n{\n\tstruct shttpd_ctx\t*ctx = arg->user_data;\n\tchar\t\t\topt_name[20], value[BUFSIZ];\n\tconst struct opt\t*o;\n\n\topt_name[0] = value[0] = '\\0';\n\n\tif (!strcmp(shttpd_get_env(arg, \"REQUEST_METHOD\"), \"POST\")) {\n\t\tif (arg->flags & SHTTPD_MORE_POST_DATA)\n\t\t\treturn;\n\t\t(void) shttpd_get_var(\"o\", arg->in.buf, arg->in.len,\n\t\t    opt_name, sizeof(opt_name));\n\t\t(void) shttpd_get_var(\"v\", arg->in.buf, arg->in.len,\n\t\t    value, sizeof(value));\n\t\tshttpd_set_option(ctx, opt_name, value[0] ? value : NULL);\n\t}\n\n\tshttpd_printf(arg, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n\"\n\t    \"<html><body><h1>SHTTPD v. %s</h1>\", shttpd_version());\n\n\tshttpd_printf(arg, \"%s\", \"<table border=1\"\n\t    \"<tr><th>Option</th><th>Description</th>\"\n\t    \"<th colspan=2>Value</th></tr>\");\n\n\tif (opt_name[0] != '\\0' && value[0] != '\\0')\n\t\tshttpd_printf(arg, \"<p style='color: green'>Saved: %s=%s</p>\",\n\t\t    opt_name, value[0] ? value : \"NULL\");\n\n\n\tfor (o = known_options; o->name != NULL; o++) {\n\t\tshttpd_printf(arg,\n\t\t    \"<form method=post><tr><td>%s</td><td>%s</td>\"\n\t\t    \"<input type=hidden name=o value='%s'>\"\n\t\t    \"<td><input type=text name=v value='%s'></td>\"\n\t\t    \"<td><input type=submit value=save></td></form></tr>\",\n\t\t    o->name, o->description, o->name,\n\t\t    ctx->options[o->index] ? ctx->options[o->index] : \"\");\n\t}\n\n\tshttpd_printf(arg, \"%s\", \"</table></body></html>\");\n\targ->flags |= SHTTPD_END_OF_OUTPUT;\n}\n\n/*\n * Show usage string and exit.\n */\nvoid\n_shttpd_usage(const char *prog)\n{\n\tconst struct opt\t*o;\n\n\t(void) fprintf(stderr,\n\t    \"SHTTPD version %s (c) Sergey Lyubka\\n\"\n\t    \"usage: %s [options] [config_file]\\n\", SHTTPD_VERSION, prog);\n\n#if !defined(NO_AUTH)\n\tfprintf(stderr, \"  -A <htpasswd_file> <realm> <user> <passwd>\\n\");\n#endif /* NO_AUTH */\n\n\tfor (o = known_options; o->name != NULL; o++) {\n\t\t(void) fprintf(stderr, \"  -%s\\t%s\", o->name, o->description);\n\t\tif (o->default_value != NULL)\n\t\t\tfprintf(stderr, \" (default: %s)\", o->default_value);\n\t\tfputc('\\n', stderr);\n\t}\n\n\texit(EXIT_FAILURE);\n}\n\nstatic void\nset_opt(struct shttpd_ctx *ctx, const char *opt, const char *value)\n{\n\tconst struct opt\t*o;\n\n\to = find_opt(opt);\n\tif (ctx->options[o->index] != NULL)\n\t\tfree(ctx->options[o->index]);\n\tctx->options[o->index] = _shttpd_strdup(value);\n}\n\nstatic void\nprocess_command_line_arguments(struct shttpd_ctx *ctx, char *argv[])\n{\n\tconst char\t\t*config_file = CONFIG_FILE;\n\tchar\t\t\tline[BUFSIZ], opt[BUFSIZ],\n\t\t\t\tval[BUFSIZ], path[FILENAME_MAX], *p;\n\tFILE\t\t\t*fp;\n\tsize_t\t\t\ti, line_no = 0;\n\n\t/* First find out, which config file to open */\n\tfor (i = 1; argv[i] != NULL && argv[i][0] == '-'; i += 2)\n\t\tif (argv[i + 1] == NULL)\n\t\t\t_shttpd_usage(argv[0]);\n\n\tif (argv[i] != NULL && argv[i + 1] != NULL) {\n\t\t/* More than one non-option arguments are given w*/\n\t\t_shttpd_usage(argv[0]);\n\t} else if (argv[i] != NULL) {\n\t\t/* Just one non-option argument is given, this is config file */\n\t\tconfig_file = argv[i];\n\t} else {\n\t\t/* No config file specified. Look for one where shttpd lives */\n\t\tif ((p = strrchr(argv[0], DIRSEP)) != 0) {\n\t\t\t_shttpd_snprintf(path, sizeof(path), \"%.*s%s\",\n\t\t\t    p - argv[0] + 1, argv[0], config_file);\n\t\t\tconfig_file = path;\n\t\t}\n\t}\n\n\tfp = fopen(config_file, \"r\");\n\n\t/* If config file was set in command line and open failed, exit */\n\tif (fp == NULL && argv[i] != NULL)\n\t\t_shttpd_elog(E_FATAL, NULL, \"cannot open config file %s: %s\",\n\t\t    config_file, strerror(errno));\n\n\tif (fp != NULL) {\n\n\t\t_shttpd_elog(E_LOG, NULL, \"Loading config file %s\", config_file);\n\n\t\t/* Loop over the lines in config file */\n\t\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\n\t\t\tline_no++;\n\n\t\t\t/* Ignore empty lines and comments */\n\t\t\tif (line[0] == '#' || line[0] == '\\n')\n\t\t\t\tcontinue;\n\n\t\t\tif (sscanf(line, \"%s %[^\\n#]\", opt, val) != 2)\n\t\t\t\t_shttpd_elog(E_FATAL, NULL, \"line %d in %s is invalid\",\n\t\t\t\t    line_no, config_file);\n\n\t\t\tset_opt(ctx, opt, val);\n\t\t}\n\n\t\t(void) fclose(fp);\n\t}\n\n\t/* Now pass through the command line options */\n\tfor (i = 1; argv[i] != NULL && argv[i][0] == '-'; i += 2)\n\t\tset_opt(ctx, &argv[i][1], argv[i + 1]);\n}\n\nstruct shttpd_ctx *\nshttpd_init(int argc, char *argv[])\n{\n\tstruct shttpd_ctx\t*ctx;\n\tstruct tm\t\t*tm;\n\tconst struct opt\t*o;\n\n\tif ((ctx = calloc(1, sizeof(*ctx))) == NULL)\n\t\t_shttpd_elog(E_FATAL, NULL, \"cannot allocate shttpd context\");\n\n\tLL_INIT(&ctx->registered_uris);\n\tLL_INIT(&ctx->uri_auths);\n\tLL_INIT(&ctx->error_handlers);\n\tLL_INIT(&ctx->acl);\n\tLL_INIT(&ctx->ssi_funcs);\n\tLL_INIT(&ctx->listeners);\n\tLL_INIT(&ctx->workers);\n\n\t/* Initialize options. First pass: set default option values */\n\tfor (o = known_options; o->name != NULL; o++)\n\t\tctx->options[o->index] = o->default_value ?\n\t\t\t_shttpd_strdup(o->default_value) : NULL;\n\n\t/* Second and third passes: config file and argv */\n\tif (argc > 0 && argv != NULL)\n\t\tprocess_command_line_arguments(ctx, argv);\n\n\t/* Call setter functions */\n\tfor (o = known_options; o->name != NULL; o++)\n\t\tif (o->setter && ctx->options[o->index] != NULL)\n\t\t\tif (o->setter(ctx, ctx->options[o->index]) == FALSE) {\n\t\t\t\tshttpd_fini(ctx);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\n\t_shttpd_current_time = time(NULL);\n\ttm = localtime(&_shttpd_current_time);\n\t_shttpd_tz_offset = 0;\n\n\tif (num_workers(ctx) == 1)\n\t\t(void) add_worker(ctx);\n#if 0\n\ttm->tm_gmtoff - 3600 * (tm->tm_isdst > 0 ? 1 : 0);\n#endif\n\n#ifdef _WIN32\n\t{WSADATA data;\tWSAStartup(MAKEWORD(2,2), &data);}\n#endif /* _WIN32 */\n\n\treturn (ctx);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openwsman-2.6.10-chdwbyn653qtqjlgbkkqerjcig3rssow/spack-src/src/authenticators/pam/pam_auth.c": "/*******************************************************************************\n * Copyright (C) 2004-2006 Intel Corp. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  - Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  - Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  - Neither the name of Intel Corp. nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL Intel Corp. OR THE CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *******************************************************************************/\n\n/**\n * @author Vadim Revyakin\n */\n#ifdef HAVE_CONFIG_H\n#include <wsman_config.h>\n#endif\n\n#define NO_DLLOAD\n\n#include <string.h>\n#include <stdlib.h>\n\n#if defined(HAVE_PAM_PAM_APPL_H)\n#include <pam/pam_appl.h>\n#elif defined(HAVE_SECURITY_PAM_APPL_H)\n#include <security/pam_appl.h>\n#endif\n\n#if defined(HAVE_PAM_PAM_MISC_H)\n#include <pam/pam_misc.h>\n#elif defined(HAVE_SECURITY_PAM_MISC_H)\n#include <security/pam_misc.h>\n#endif\n\n\n#ifndef STANDALONE\n#include \"u/libu.h\"\nint initialize(void *arg);\nint authorize(char *username, const char *password);\n#endif\n\n\nstatic char *service = \"openwsman\";\n\n\n#define debug_dlsym(sym) \\\n\tdebug(\"Could not dlsym %s\", sym)\n\n#ifdef STANDALONE\n\n#include <stdio.h>\n\n#define debug(frmt, ...) \\\n\tprintf(frmt, __VA_ARGS__); printf(\"\\n\")\n\n#define PAM_start pam_start\n#define PAM_authenticate pam_authenticate\n#define PAM_acct_mgmt pam_acct_mgmt\n#define PAM_end pam_end\n#define PAM_strerror pam_strerror\n\n#else\n#ifdef NO_DLLOAD\n\n#define PAM_start pam_start\n#define PAM_authenticate pam_authenticate\n#define PAM_acct_mgmt pam_acct_mgmt\n#define PAM_end pam_end\n#define PAM_strerror pam_strerror\n\nint\ninitialize(void *arg)\n{\n\treturn 0;\n}\n\n#else // !STANDALONE && !NO_DLLOAD\n\n#include <dlfcn.h>\n\n#define LIBPAM   \"libpam.so\"\n\n\nstatic int (*PAM_start)(const char *service_name,\n\t\tconst char *user,\n\t\tconst struct pam_conv *pam_conversation,\n\t\tpam_handle_t **pamh);\nstatic int (*PAM_authenticate)(pam_handle_t *pamh, int flags);\nstatic int (*PAM_acct_mgmt)(pam_handle_t *pamh, int flags);\nstatic int (*PAM_end)(pam_handle_t *pamh, int pam_status);\nstatic int (*PAM_strerror)(pam_handle_t *pamh, int errnum);\n\n\n\nint\ninitialize(void *arg)\n{\n\tvoid *hnd;\n\n\thnd = dlopen(LIBPAM, RTLD_LAZY | RTLD_GLOBAL);\n\tif (hnd == NULL) {\n\t\tdebug(\"Could not dlopen %s\", LIBPAM);\n\t\treturn 1;\n\t}\n\tPAM_start = dlsym(hnd, \"pam_start\");\n\tif (PAM_start == NULL) {\n\t\tdebug_dlsym(\"pam_start\");\n\t\tdlclose(hnd);\n\t\treturn 1;\n\t}\n\tPAM_authenticate = dlsym(hnd, \"pam_authenticate\");\n\tif (PAM_authenticate == NULL) {\n\t\tdebug_dlsym(\"pam_authenticate\");\n\t\tdlclose(hnd);\n\t\treturn 1;\n\t}\n\tPAM_acct_mgmt = dlsym(hnd, \"pam_acct_mgmt\");\n\tif (PAM_acct_mgmt == NULL) {\n\t\tdebug_dlsym(\"pam_acct_mgmt\");\n\t\tdlclose(hnd);\n\t\treturn 1;\n\t}\n\tPAM_end = dlsym(hnd, \"pam_end\");\n\tif (PAM_end == NULL) {\n\t\tdebug_dlsym(\"pam_end\");\n\t\tdlclose(hnd);\n\t\treturn 1;\n\t}\n\tPAM_strerror = dlsym(hnd, \"pam_strerror\");\n\tif (PAM_strerror == NULL) {\n\t\tdebug_dlsym(\"pam_strerror\");\n\t\tdlclose(hnd);\n\t\treturn 1;\n\t}\n\n\n\tif (arg != NULL) {\n\t\tservice = (char *)arg;\n\t}\n\t//    debug_level = dbg_lvl;\n\n\treturn 0;\n}\n\n\n#endif // NO_DLLOAD\n#endif // STANDALONE\n\n\nstatic int\n#if defined (__SVR4) && defined (__sun)\npwd_conv(int num_msg, struct pam_message **msgm,\n#else\npwd_conv(int num_msg, const struct pam_message **msgm,\n#endif\n\t\tstruct pam_response **response, void *appdata_ptr)\n{\n\tchar *pwd = (char *)appdata_ptr;\n\tint n;\n\tstruct pam_response *reply;\n\treply = (struct pam_response *) calloc(num_msg,\n\t\t\tsizeof(struct pam_response));\n\tif (reply == NULL) {\n\t\tdebug(\"No %s\", \"memory\");\n\t\treturn PAM_CONV_ERR;\n\t}\n\n\tfor (n = 0; n < num_msg; n++) {\n\t\tswitch (msgm[n]->msg_style) {\n\t\tcase PAM_PROMPT_ECHO_OFF:\n\t\tcase PAM_PROMPT_ECHO_ON:\n\t\t\treply[n].resp = strdup(pwd);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*response = reply;\n\treturn PAM_SUCCESS;\n}\n\n#ifdef STANDALONE\nstatic\n#endif\nint\nauthorize(char *username, const char *password)\n{\n\tstruct pam_conv conv = {\n\t\tpwd_conv,\n\t\t(void *)password\n\t};\n\tpam_handle_t   *pamh = NULL;\n\tint             r;\n\tint             res = 0;\n\t// printf(\"service = %s\\n\", service);\n\tr = PAM_start(service, username, &conv, &pamh);\n\tif (r != PAM_SUCCESS) {\n\t\tdebug(\"pam_start failed = %d(%s)\", r, PAM_strerror(pamh, r));\n\t\treturn 0;\n\t}\n\n\tr = PAM_authenticate(pamh, PAM_SILENT | PAM_DISALLOW_NULL_AUTHTOK);\n\tif (r != PAM_SUCCESS) {\n\t\tdebug(\"pam_authenticate failed = %d(%s)\", r, PAM_strerror(pamh, r));\n\t\tgoto DONE;\n\t}\n\tr = PAM_acct_mgmt(pamh, PAM_SILENT | PAM_DISALLOW_NULL_AUTHTOK);\n\tif (r != PAM_SUCCESS) {\n\t\tdebug(\"pam_ acct_mgmt failed = %d(%s)\", r, PAM_strerror(pamh, r));\n\t\tgoto DONE;\n\t}\n\tres = 1;\nDONE:\n\tr = PAM_end(pamh, r);\n\tif (r != PAM_SUCCESS) {\n\t\tdebug(\"pam_end failed = %d(%s)\", r, PAM_strerror(pamh, r));\n\t}\n\treturn res;\n}\n\n#ifdef STANDALONE\n\n/*\n *     run\n *   gcc -o wspam -DSTANDALONE wsmand_pam.c -lpam\n *     to build a program\n */\n\nint main(int argc, char **argv)\n{\n\tchar *user;\n\tchar *pwd;\n\tint res;\n\n\tif ((argc != 3) && (argc != 4)) {\n\t\tprintf(\"Usage: wsmand_pam <user> <password> [<service>]\\n\");\n\t\treturn 1;\n\t}\n\n\tif (argc == 4) {\n\t\tservice = argv[3];\n\t}\n\n\tif (authorize(argv[1], argv[2])) {\n\t\tprintf(\"Authenticated\\n\");\n\t} else {\n\t\tprintf(\"Not Authenticated\\n\");\n\t}\n\tif (authorize(argv[1], argv[2])) {\n\t\tprintf(\"Authenticated\\n\");\n\t} else {\n\t\tprintf(\"Not Authenticated\\n\");\n\t}\n\treturn 0;\n}\n\n#endif\n"
    },
    "skipped": [],
    "total_files": 490
}