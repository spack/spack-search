{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/include/openssl/dso.h": "/* dso.h -*- mode:C; c-file-style: \"eay\" -*- */\n/* Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL\n * project 2000.\n */\n/* ====================================================================\n * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n#ifndef HEADER_DSO_H\n#define HEADER_DSO_H\n\n#include <openssl/crypto.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* These values are used as commands to DSO_ctrl() */\n#define DSO_CTRL_GET_FLAGS\t1\n#define DSO_CTRL_SET_FLAGS\t2\n#define DSO_CTRL_OR_FLAGS\t3\n\n/* By default, DSO_load() will translate the provided filename into a form\n * typical for the platform (more specifically the DSO_METHOD) using the\n * dso_name_converter function of the method. Eg. win32 will transform \"blah\"\n * into \"blah.dll\", and dlfcn will transform it into \"libblah.so\". The\n * behaviour can be overriden by setting the name_converter callback in the DSO\n * object (using DSO_set_name_converter()). This callback could even utilise\n * the DSO_METHOD's converter too if it only wants to override behaviour for\n * one or two possible DSO methods. However, the following flag can be set in a\n * DSO to prevent *any* native name-translation at all - eg. if the caller has\n * prompted the user for a path to a driver library so the filename should be\n * interpreted as-is. */\n#define DSO_FLAG_NO_NAME_TRANSLATION\t\t0x01\n/* An extra flag to give if only the extension should be added as\n * translation.  This is obviously only of importance on Unix and\n * other operating systems where the translation also may prefix\n * the name with something, like 'lib', and ignored everywhere else.\n * This flag is also ignored if DSO_FLAG_NO_NAME_TRANSLATION is used\n * at the same time. */\n#define DSO_FLAG_NAME_TRANSLATION_EXT_ONLY\t0x02\n\n/* The following flag controls the translation of symbol names to upper\n * case.  This is currently only being implemented for OpenVMS.\n */\n#define DSO_FLAG_UPCASE_SYMBOL\t\t\t0x10\n\n/* This flag loads the library with public symbols.\n * Meaning: The exported symbols of this library are public\n * to all libraries loaded after this library.\n * At the moment only implemented in unix.\n */\n#define DSO_FLAG_GLOBAL_SYMBOLS\t\t\t0x20\n\n\ntypedef void (*DSO_FUNC_TYPE)(void);\n\ntypedef struct dso_st DSO;\n\n/* The function prototype used for method functions (or caller-provided\n * callbacks) that transform filenames. They are passed a DSO structure pointer\n * (or NULL if they are to be used independantly of a DSO object) and a\n * filename to transform. They should either return NULL (if there is an error\n * condition) or a newly allocated string containing the transformed form that\n * the caller will need to free with OPENSSL_free() when done. */\ntypedef char* (*DSO_NAME_CONVERTER_FUNC)(DSO *, const char *);\n/* The function prototype used for method functions (or caller-provided\n * callbacks) that merge two file specifications. They are passed a\n * DSO structure pointer (or NULL if they are to be used independantly of\n * a DSO object) and two file specifications to merge. They should\n * either return NULL (if there is an error condition) or a newly allocated\n * string containing the result of merging that the caller will need\n * to free with OPENSSL_free() when done.\n * Here, merging means that bits and pieces are taken from each of the\n * file specifications and added together in whatever fashion that is\n * sensible for the DSO method in question.  The only rule that really\n * applies is that if the two specification contain pieces of the same\n * type, the copy from the first string takes priority.  One could see\n * it as the first specification is the one given by the user and the\n * second being a bunch of defaults to add on if they're missing in the\n * first. */\ntypedef char* (*DSO_MERGER_FUNC)(DSO *, const char *, const char *);\n\ntypedef struct dso_meth_st\n\t{\n\tconst char *name;\n\t/* Loads a shared library, NB: new DSO_METHODs must ensure that a\n\t * successful load populates the loaded_filename field, and likewise a\n\t * successful unload OPENSSL_frees and NULLs it out. */\n\tint (*dso_load)(DSO *dso);\n\t/* Unloads a shared library */\n\tint (*dso_unload)(DSO *dso);\n\t/* Binds a variable */\n\tvoid *(*dso_bind_var)(DSO *dso, const char *symname);\n\t/* Binds a function - assumes a return type of DSO_FUNC_TYPE.\n\t * This should be cast to the real function prototype by the\n\t * caller. Platforms that don't have compatible representations\n\t * for different prototypes (this is possible within ANSI C)\n\t * are highly unlikely to have shared libraries at all, let\n\t * alone a DSO_METHOD implemented for them. */\n\tDSO_FUNC_TYPE (*dso_bind_func)(DSO *dso, const char *symname);\n\n/* I don't think this would actually be used in any circumstances. */\n#if 0\n\t/* Unbinds a variable */\n\tint (*dso_unbind_var)(DSO *dso, char *symname, void *symptr);\n\t/* Unbinds a function */\n\tint (*dso_unbind_func)(DSO *dso, char *symname, DSO_FUNC_TYPE symptr);\n#endif\n\t/* The generic (yuck) \"ctrl()\" function. NB: Negative return\n\t * values (rather than zero) indicate errors. */\n\tlong (*dso_ctrl)(DSO *dso, int cmd, long larg, void *parg);\n\t/* The default DSO_METHOD-specific function for converting filenames to\n\t * a canonical native form. */\n\tDSO_NAME_CONVERTER_FUNC dso_name_converter;\n\t/* The default DSO_METHOD-specific function for converting filenames to\n\t * a canonical native form. */\n\tDSO_MERGER_FUNC dso_merger;\n\n\t/* [De]Initialisation handlers. */\n\tint (*init)(DSO *dso);\n\tint (*finish)(DSO *dso);\n\n\t/* Return pathname of the module containing location */\n\tint (*pathbyaddr)(void *addr,char *path,int sz);\n\t/* Perform global symbol lookup, i.e. among *all* modules */\n\tvoid *(*globallookup)(const char *symname);\n\t} DSO_METHOD;\n\n/**********************************************************************/\n/* The low-level handle type used to refer to a loaded shared library */\n\nstruct dso_st\n\t{\n\tDSO_METHOD *meth;\n\t/* Standard dlopen uses a (void *). Win32 uses a HANDLE. VMS\n\t * doesn't use anything but will need to cache the filename\n\t * for use in the dso_bind handler. All in all, let each\n\t * method control its own destiny. \"Handles\" and such go in\n\t * a STACK. */\n\tSTACK_OF(void) *meth_data;\n\tint references;\n\tint flags;\n\t/* For use by applications etc ... use this for your bits'n'pieces,\n\t * don't touch meth_data! */\n\tCRYPTO_EX_DATA ex_data;\n\t/* If this callback function pointer is set to non-NULL, then it will\n\t * be used in DSO_load() in place of meth->dso_name_converter. NB: This\n\t * should normally set using DSO_set_name_converter(). */\n\tDSO_NAME_CONVERTER_FUNC name_converter;\n\t/* If this callback function pointer is set to non-NULL, then it will\n\t * be used in DSO_load() in place of meth->dso_merger. NB: This\n\t * should normally set using DSO_set_merger(). */\n\tDSO_MERGER_FUNC merger;\n\t/* This is populated with (a copy of) the platform-independant\n\t * filename used for this DSO. */\n\tchar *filename;\n\t/* This is populated with (a copy of) the translated filename by which\n\t * the DSO was actually loaded. It is NULL iff the DSO is not currently\n\t * loaded. NB: This is here because the filename translation process\n\t * may involve a callback being invoked more than once not only to\n\t * convert to a platform-specific form, but also to try different\n\t * filenames in the process of trying to perform a load. As such, this\n\t * variable can be used to indicate (a) whether this DSO structure\n\t * corresponds to a loaded library or not, and (b) the filename with\n\t * which it was actually loaded. */\n\tchar *loaded_filename;\n\t};\n\n\nDSO *\tDSO_new(void);\nDSO *\tDSO_new_method(DSO_METHOD *method);\nint\tDSO_free(DSO *dso);\nint\tDSO_flags(DSO *dso);\nint\tDSO_up_ref(DSO *dso);\nlong\tDSO_ctrl(DSO *dso, int cmd, long larg, void *parg);\n\n/* This function sets the DSO's name_converter callback. If it is non-NULL,\n * then it will be used instead of the associated DSO_METHOD's function. If\n * oldcb is non-NULL then it is set to the function pointer value being\n * replaced. Return value is non-zero for success. */\nint\tDSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb,\n\t\t\t\tDSO_NAME_CONVERTER_FUNC *oldcb);\n/* These functions can be used to get/set the platform-independant filename\n * used for a DSO. NB: set will fail if the DSO is already loaded. */\nconst char *DSO_get_filename(DSO *dso);\nint\tDSO_set_filename(DSO *dso, const char *filename);\n/* This function will invoke the DSO's name_converter callback to translate a\n * filename, or if the callback isn't set it will instead use the DSO_METHOD's\n * converter. If \"filename\" is NULL, the \"filename\" in the DSO itself will be\n * used. If the DSO_FLAG_NO_NAME_TRANSLATION flag is set, then the filename is\n * simply duplicated. NB: This function is usually called from within a\n * DSO_METHOD during the processing of a DSO_load() call, and is exposed so that\n * caller-created DSO_METHODs can do the same thing. A non-NULL return value\n * will need to be OPENSSL_free()'d. */\nchar\t*DSO_convert_filename(DSO *dso, const char *filename);\n/* This function will invoke the DSO's merger callback to merge two file\n * specifications, or if the callback isn't set it will instead use the\n * DSO_METHOD's merger.  A non-NULL return value will need to be\n * OPENSSL_free()'d. */\nchar\t*DSO_merge(DSO *dso, const char *filespec1, const char *filespec2);\n/* If the DSO is currently loaded, this returns the filename that it was loaded\n * under, otherwise it returns NULL. So it is also useful as a test as to\n * whether the DSO is currently loaded. NB: This will not necessarily return\n * the same value as DSO_convert_filename(dso, dso->filename), because the\n * DSO_METHOD's load function may have tried a variety of filenames (with\n * and/or without the aid of the converters) before settling on the one it\n * actually loaded. */\nconst char *DSO_get_loaded_filename(DSO *dso);\n\nvoid\tDSO_set_default_method(DSO_METHOD *meth);\nDSO_METHOD *DSO_get_default_method(void);\nDSO_METHOD *DSO_get_method(DSO *dso);\nDSO_METHOD *DSO_set_method(DSO *dso, DSO_METHOD *meth);\n\n/* The all-singing all-dancing load function, you normally pass NULL\n * for the first and third parameters. Use DSO_up and DSO_free for\n * subsequent reference count handling. Any flags passed in will be set\n * in the constructed DSO after its init() function but before the\n * load operation. If 'dso' is non-NULL, 'flags' is ignored. */\nDSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags);\n\n/* This function binds to a variable inside a shared library. */\nvoid *DSO_bind_var(DSO *dso, const char *symname);\n\n/* This function binds to a function inside a shared library. */\nDSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname);\n\n/* This method is the default, but will beg, borrow, or steal whatever\n * method should be the default on any particular platform (including\n * DSO_METH_null() if necessary). */\nDSO_METHOD *DSO_METHOD_openssl(void);\n\n/* This method is defined for all platforms - if a platform has no\n * DSO support then this will be the only method! */\nDSO_METHOD *DSO_METHOD_null(void);\n\n/* If DSO_DLFCN is defined, the standard dlfcn.h-style functions\n * (dlopen, dlclose, dlsym, etc) will be used and incorporated into\n * this method. If not, this method will return NULL. */\nDSO_METHOD *DSO_METHOD_dlfcn(void);\n\n/* If DSO_DL is defined, the standard dl.h-style functions (shl_load, \n * shl_unload, shl_findsym, etc) will be used and incorporated into\n * this method. If not, this method will return NULL. */\nDSO_METHOD *DSO_METHOD_dl(void);\n\n/* If WIN32 is defined, use DLLs. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_win32(void);\n\n/* If VMS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_vms(void);\n\n/* This function writes null-terminated pathname of DSO module\n * containing 'addr' into 'sz' large caller-provided 'path' and\n * returns the number of characters [including trailing zero]\n * written to it. If 'sz' is 0 or negative, 'path' is ignored and\n * required amount of charachers [including trailing zero] to\n * accomodate pathname is returned. If 'addr' is NULL, then\n * pathname of cryptolib itself is returned. Negative or zero\n * return value denotes error.\n */\nint DSO_pathbyaddr(void *addr,char *path,int sz);\n\n/* This function should be used with caution! It looks up symbols in\n * *all* loaded modules and if module gets unloaded by somebody else\n * attempt to dereference the pointer is doomed to have fatal\n * consequences. Primary usage for this function is to probe *core*\n * system functionality, e.g. check if getnameinfo(3) is available\n * at run-time without bothering about OS-specific details such as\n * libc.so.versioning or where does it actually reside: in libc\n * itself or libsocket. */\nvoid *DSO_global_lookup(const char *name);\n\n/* If BeOS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_beos(void);\n\n/* BEGIN ERROR CODES */\n/* The following lines are auto generated by the script mkerr.pl. Any changes\n * made after this point may be overwritten when the script is next run.\n */\nvoid ERR_load_DSO_strings(void);\n\n/* Error codes for the DSO functions. */\n\n/* Function codes. */\n#define DSO_F_BEOS_BIND_FUNC\t\t\t\t 144\n#define DSO_F_BEOS_BIND_VAR\t\t\t\t 145\n#define DSO_F_BEOS_LOAD\t\t\t\t\t 146\n#define DSO_F_BEOS_NAME_CONVERTER\t\t\t 147\n#define DSO_F_BEOS_UNLOAD\t\t\t\t 148\n#define DSO_F_DLFCN_BIND_FUNC\t\t\t\t 100\n#define DSO_F_DLFCN_BIND_VAR\t\t\t\t 101\n#define DSO_F_DLFCN_LOAD\t\t\t\t 102\n#define DSO_F_DLFCN_MERGER\t\t\t\t 130\n#define DSO_F_DLFCN_NAME_CONVERTER\t\t\t 123\n#define DSO_F_DLFCN_UNLOAD\t\t\t\t 103\n#define DSO_F_DL_BIND_FUNC\t\t\t\t 104\n#define DSO_F_DL_BIND_VAR\t\t\t\t 105\n#define DSO_F_DL_LOAD\t\t\t\t\t 106\n#define DSO_F_DL_MERGER\t\t\t\t\t 131\n#define DSO_F_DL_NAME_CONVERTER\t\t\t\t 124\n#define DSO_F_DL_UNLOAD\t\t\t\t\t 107\n#define DSO_F_DSO_BIND_FUNC\t\t\t\t 108\n#define DSO_F_DSO_BIND_VAR\t\t\t\t 109\n#define DSO_F_DSO_CONVERT_FILENAME\t\t\t 126\n#define DSO_F_DSO_CTRL\t\t\t\t\t 110\n#define DSO_F_DSO_FREE\t\t\t\t\t 111\n#define DSO_F_DSO_GET_FILENAME\t\t\t\t 127\n#define DSO_F_DSO_GET_LOADED_FILENAME\t\t\t 128\n#define DSO_F_DSO_GLOBAL_LOOKUP\t\t\t\t 139\n#define DSO_F_DSO_LOAD\t\t\t\t\t 112\n#define DSO_F_DSO_MERGE\t\t\t\t\t 132\n#define DSO_F_DSO_NEW_METHOD\t\t\t\t 113\n#define DSO_F_DSO_PATHBYADDR\t\t\t\t 140\n#define DSO_F_DSO_SET_FILENAME\t\t\t\t 129\n#define DSO_F_DSO_SET_NAME_CONVERTER\t\t\t 122\n#define DSO_F_DSO_UP_REF\t\t\t\t 114\n#define DSO_F_GLOBAL_LOOKUP_FUNC\t\t\t 138\n#define DSO_F_PATHBYADDR\t\t\t\t 137\n#define DSO_F_VMS_BIND_SYM\t\t\t\t 115\n#define DSO_F_VMS_LOAD\t\t\t\t\t 116\n#define DSO_F_VMS_MERGER\t\t\t\t 133\n#define DSO_F_VMS_UNLOAD\t\t\t\t 117\n#define DSO_F_WIN32_BIND_FUNC\t\t\t\t 118\n#define DSO_F_WIN32_BIND_VAR\t\t\t\t 119\n#define DSO_F_WIN32_GLOBALLOOKUP\t\t\t 142\n#define DSO_F_WIN32_GLOBALLOOKUP_FUNC\t\t\t 143\n#define DSO_F_WIN32_JOINER\t\t\t\t 135\n#define DSO_F_WIN32_LOAD\t\t\t\t 120\n#define DSO_F_WIN32_MERGER\t\t\t\t 134\n#define DSO_F_WIN32_NAME_CONVERTER\t\t\t 125\n#define DSO_F_WIN32_PATHBYADDR\t\t\t\t 141\n#define DSO_F_WIN32_SPLITTER\t\t\t\t 136\n#define DSO_F_WIN32_UNLOAD\t\t\t\t 121\n\n/* Reason codes. */\n#define DSO_R_CTRL_FAILED\t\t\t\t 100\n#define DSO_R_DSO_ALREADY_LOADED\t\t\t 110\n#define DSO_R_EMPTY_FILE_STRUCTURE\t\t\t 113\n#define DSO_R_FAILURE\t\t\t\t\t 114\n#define DSO_R_FILENAME_TOO_BIG\t\t\t\t 101\n#define DSO_R_FINISH_FAILED\t\t\t\t 102\n#define DSO_R_INCORRECT_FILE_SYNTAX\t\t\t 115\n#define DSO_R_LOAD_FAILED\t\t\t\t 103\n#define DSO_R_NAME_TRANSLATION_FAILED\t\t\t 109\n#define DSO_R_NO_FILENAME\t\t\t\t 111\n#define DSO_R_NO_FILE_SPECIFICATION\t\t\t 116\n#define DSO_R_NULL_HANDLE\t\t\t\t 104\n#define DSO_R_SET_FILENAME_FAILED\t\t\t 112\n#define DSO_R_STACK_ERROR\t\t\t\t 105\n#define DSO_R_SYM_FAILURE\t\t\t\t 106\n#define DSO_R_UNLOAD_FAILED\t\t\t\t 107\n#define DSO_R_UNSUPPORTED\t\t\t\t 108\n\n#ifdef  __cplusplus\n}\n#endif\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/sparcv9cap.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <sys/time.h>\n#include <openssl/bn.h>\n\n#define SPARCV9_TICK_PRIVILEGED\t(1<<0)\n#define SPARCV9_PREFER_FPU\t(1<<1)\n#define SPARCV9_VIS1\t\t(1<<2)\n#define SPARCV9_VIS2\t\t(1<<3)\t/* reserved */\n#define SPARCV9_FMADD\t\t(1<<4)\t/* reserved for SPARC64 V */\n\nstatic int OPENSSL_sparcv9cap_P=SPARCV9_TICK_PRIVILEGED;\n\nint bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0, int num)\n\t{\n\tint bn_mul_mont_fpu(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0, int num);\n\tint bn_mul_mont_int(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0, int num);\n\n\tif (num>=8 && !(num&1) &&\n\t    (OPENSSL_sparcv9cap_P&(SPARCV9_PREFER_FPU|SPARCV9_VIS1)) ==\n\t\t(SPARCV9_PREFER_FPU|SPARCV9_VIS1))\n\t\treturn bn_mul_mont_fpu(rp,ap,bp,np,n0,num);\n\telse\n\t\treturn bn_mul_mont_int(rp,ap,bp,np,n0,num);\n\t}\n\nunsigned long\t_sparcv9_rdtick(void);\nvoid\t\t_sparcv9_vis1_probe(void);\nunsigned long\t_sparcv9_vis1_instrument(void);\nvoid\t\t_sparcv9_vis2_probe(void);\nvoid\t\t_sparcv9_fmadd_probe(void);\n\nunsigned long OPENSSL_rdtsc(void)\n\t{\n\tif (OPENSSL_sparcv9cap_P&SPARCV9_TICK_PRIVILEGED)\n#if defined(__sun) && defined(__SVR4)\n\t\treturn gethrtime();\n#else\n\t\treturn 0;\n#endif\n\telse\n\t\treturn _sparcv9_rdtick();\n\t}\n\n#if 0 && defined(__sun) && defined(__SVR4)\n/* This code path is disabled, because of incompatibility of\n * libdevinfo.so.1 and libmalloc.so.1 (see below for details)\n */\n#include <malloc.h>\n#include <dlfcn.h>\n#include <libdevinfo.h>\n#include <sys/systeminfo.h>\n\ntypedef di_node_t (*di_init_t)(const char *,uint_t);\ntypedef void      (*di_fini_t)(di_node_t);\ntypedef char *    (*di_node_name_t)(di_node_t);\ntypedef int       (*di_walk_node_t)(di_node_t,uint_t,di_node_name_t,int (*)(di_node_t,di_node_name_t));\n\n#define DLLINK(h,name) (name=(name##_t)dlsym((h),#name))\n\nstatic int walk_nodename(di_node_t node, di_node_name_t di_node_name)\n\t{\n\tchar *name = (*di_node_name)(node);\n\n\t/* This is expected to catch all UltraSPARC flavors prior T1 */\n\tif (!strcmp (name,\"SUNW,UltraSPARC\") ||\n\t    !strncmp(name,\"SUNW,UltraSPARC-I\",17))  /* covers II,III,IV */\n\t\t{\n\t\tOPENSSL_sparcv9cap_P |= SPARCV9_PREFER_FPU|SPARCV9_VIS1;\n\n\t\t/* %tick is privileged only on UltraSPARC-I/II, but not IIe */\n\t\tif (name[14]!='\\0' && name[17]!='\\0' && name[18]!='\\0')\n\t\t\tOPENSSL_sparcv9cap_P &= ~SPARCV9_TICK_PRIVILEGED;\n\n\t\treturn DI_WALK_TERMINATE;\n\t\t}\n\t/* This is expected to catch remaining UltraSPARCs, such as T1 */\n\telse if (!strncmp(name,\"SUNW,UltraSPARC\",15))\n\t\t{\n\t\tOPENSSL_sparcv9cap_P &= ~SPARCV9_TICK_PRIVILEGED;\n\n\t\treturn DI_WALK_TERMINATE;\n\t\t}\n\n\treturn DI_WALK_CONTINUE;\n\t}\n\nvoid OPENSSL_cpuid_setup(void)\n\t{\n\tvoid *h;\n\tchar *e,si[256];\n\tstatic int trigger=0;\n\n\tif (trigger) return;\n\ttrigger=1;\n\n\tif ((e=getenv(\"OPENSSL_sparcv9cap\")))\n\t\t{\n\t\tOPENSSL_sparcv9cap_P=strtoul(e,NULL,0);\n\t\treturn;\n\t\t}\n\n\tif (sysinfo(SI_MACHINE,si,sizeof(si))>0)\n\t\t{\n\t\tif (strcmp(si,\"sun4v\"))\n\t\t\t/* FPU is preferred for all CPUs, but US-T1/2 */\n\t\t\tOPENSSL_sparcv9cap_P |= SPARCV9_PREFER_FPU;\n\t\t}\n\n\tif (sysinfo(SI_ISALIST,si,sizeof(si))>0)\n\t\t{\n\t\tif (strstr(si,\"+vis\"))\n\t\t\tOPENSSL_sparcv9cap_P |= SPARCV9_VIS1;\n\t\tif (strstr(si,\"+vis2\"))\n\t\t\t{\n\t\t\tOPENSSL_sparcv9cap_P |= SPARCV9_VIS2;\n\t\t\tOPENSSL_sparcv9cap_P &= ~SPARCV9_TICK_PRIVILEGED;\n\t\t\treturn;\n\t\t\t}\n\t\t}\n#ifdef M_KEEP\n\t/*\n\t * Solaris libdevinfo.so.1 is effectively incomatible with\n\t * libmalloc.so.1. Specifically, if application is linked with\n\t * -lmalloc, it crashes upon startup with SIGSEGV in\n\t * free(3LIBMALLOC) called by di_fini. Prior call to\n\t * mallopt(M_KEEP,0) somehow helps... But not always...\n\t */\n\tif ((h = dlopen(NULL,RTLD_LAZY)))\n\t\t{\n\t\tunion { void *p; int (*f)(int,int); } sym;\n\t\tif ((sym.p = dlsym(h,\"mallopt\"))) (*sym.f)(M_KEEP,0);\n\t\tdlclose(h);\n\t\t}\n#endif\n\tif ((h = dlopen(\"libdevinfo.so.1\",RTLD_LAZY))) do\n\t\t{\n\t\tdi_init_t\tdi_init;\n\t\tdi_fini_t\tdi_fini;\n\t\tdi_walk_node_t\tdi_walk_node;\n\t\tdi_node_name_t\tdi_node_name;\n\t\tdi_node_t\troot_node;\n\n\t\tif (!DLLINK(h,di_init))\t\tbreak;\n\t\tif (!DLLINK(h,di_fini))\t\tbreak;\n\t\tif (!DLLINK(h,di_walk_node))\tbreak;\n\t\tif (!DLLINK(h,di_node_name))\tbreak;\n\n\t\tif ((root_node = (*di_init)(\"/\",DINFOSUBTREE))!=DI_NODE_NIL)\n\t\t\t{\n\t\t\t(*di_walk_node)(root_node,DI_WALK_SIBFIRST,\n\t\t\t\t\tdi_node_name,walk_nodename);\n\t\t\t(*di_fini)(root_node);\n\t\t\t}\n\t\t} while(0);\n\n\tif (h) dlclose(h);\n\t}\n\n#else\n\nstatic sigjmp_buf common_jmp;\nstatic void common_handler(int sig) { siglongjmp(common_jmp,sig); }\n\nvoid OPENSSL_cpuid_setup(void)\n\t{\n\tchar *e;\n\tstruct sigaction\tcommon_act,ill_oact,bus_oact;\n\tsigset_t\t\tall_masked,oset;\n\tstatic int trigger=0;\n\n\tif (trigger) return;\n\ttrigger=1;\n \n\tif ((e=getenv(\"OPENSSL_sparcv9cap\")))\n\t\t{\n\t\tOPENSSL_sparcv9cap_P=strtoul(e,NULL,0);\n\t\treturn;\n\t\t}\n\n\t/* Initial value, fits UltraSPARC-I&II... */\n\tOPENSSL_sparcv9cap_P = SPARCV9_PREFER_FPU|SPARCV9_TICK_PRIVILEGED;\n\n\tsigfillset(&all_masked);\n\tsigdelset(&all_masked,SIGILL);\n\tsigdelset(&all_masked,SIGTRAP);\n#ifdef SIGEMT\n\tsigdelset(&all_masked,SIGEMT);\n#endif\n\tsigdelset(&all_masked,SIGFPE);\n\tsigdelset(&all_masked,SIGBUS);\n\tsigdelset(&all_masked,SIGSEGV);\n\tsigprocmask(SIG_SETMASK,&all_masked,&oset);\n\n\tmemset(&common_act,0,sizeof(common_act));\n\tcommon_act.sa_handler = common_handler;\n\tcommon_act.sa_mask    = all_masked;\n\n\tsigaction(SIGILL,&common_act,&ill_oact);\n\tsigaction(SIGBUS,&common_act,&bus_oact);/* T1 fails 16-bit ldda [on Linux] */\n\n\tif (sigsetjmp(common_jmp,1) == 0)\n\t\t{\n\t\t_sparcv9_rdtick();\n\t\tOPENSSL_sparcv9cap_P &= ~SPARCV9_TICK_PRIVILEGED;\n\t\t}\n\n\tif (sigsetjmp(common_jmp,1) == 0)\n\t\t{\n\t\t_sparcv9_vis1_probe();\n\t\tOPENSSL_sparcv9cap_P |= SPARCV9_VIS1;\n\t\t/* detect UltraSPARC-Tx, see sparccpud.S for details... */\n\t\tif (_sparcv9_vis1_instrument() >= 12)\n\t\t\tOPENSSL_sparcv9cap_P &= ~(SPARCV9_VIS1|SPARCV9_PREFER_FPU);\n\t\telse\n\t\t\t{\n\t\t\t_sparcv9_vis2_probe();\n\t\t\tOPENSSL_sparcv9cap_P |= SPARCV9_VIS2;\n\t\t\t}\n\t\t}\n\n\tif (sigsetjmp(common_jmp,1) == 0)\n\t\t{\n\t\t_sparcv9_fmadd_probe();\n\t\tOPENSSL_sparcv9cap_P |= SPARCV9_FMADD;\n\t\t}\n\n\tsigaction(SIGBUS,&bus_oact,NULL);\n\tsigaction(SIGILL,&ill_oact,NULL);\n\n\tsigprocmask(SIG_SETMASK,&oset,NULL);\n\t}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/dso/dso_dlfcn.c": "/* dso_dlfcn.c -*- mode:C; c-file-style: \"eay\" -*- */\n/* Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL\n * project 2000.\n */\n/* ====================================================================\n * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n/* We need to do this early, because stdio.h includes the header files\n   that handle _GNU_SOURCE and other similar macros.  Defining it later\n   is simply too late, because those headers are protected from re-\n   inclusion.  */\n#ifdef __linux\n# ifndef _GNU_SOURCE\n#  define _GNU_SOURCE\t/* make sure dladdr is declared */\n# endif\n#endif\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#include <openssl/dso.h>\n\n#ifndef DSO_DLFCN\nDSO_METHOD *DSO_METHOD_dlfcn(void)\n\t{\n\treturn NULL;\n\t}\n#else\n\n#ifdef HAVE_DLFCN_H\n# ifdef __osf__\n#  define __EXTENSIONS__\n# endif\n# include <dlfcn.h>\n# define HAVE_DLINFO 1\n# if defined(_AIX) || defined(__CYGWIN__) || \\\n     defined(__SCO_VERSION__) || defined(_SCO_ELF) || \\\n     (defined(__osf__) && !defined(RTLD_NEXT))     || \\\n     (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \\\n\tdefined(__ANDROID__)\n#  undef HAVE_DLINFO\n# endif\n#endif\n\n/* Part of the hack in \"dlfcn_load\" ... */\n#define DSO_MAX_TRANSLATED_SIZE 256\n\nstatic int dlfcn_load(DSO *dso);\nstatic int dlfcn_unload(DSO *dso);\nstatic void *dlfcn_bind_var(DSO *dso, const char *symname);\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname);\n#if 0\nstatic int dlfcn_unbind(DSO *dso, char *symname, void *symptr);\nstatic int dlfcn_init(DSO *dso);\nstatic int dlfcn_finish(DSO *dso);\nstatic long dlfcn_ctrl(DSO *dso, int cmd, long larg, void *parg);\n#endif\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename);\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n\tconst char *filespec2);\nstatic int dlfcn_pathbyaddr(void *addr,char *path,int sz);\nstatic void *dlfcn_globallookup(const char *name);\n\nstatic DSO_METHOD dso_meth_dlfcn = {\n\t\"OpenSSL 'dlfcn' shared library method\",\n\tdlfcn_load,\n\tdlfcn_unload,\n\tdlfcn_bind_var,\n\tdlfcn_bind_func,\n/* For now, \"unbind\" doesn't exist */\n#if 0\n\tNULL, /* unbind_var */\n\tNULL, /* unbind_func */\n#endif\n\tNULL, /* ctrl */\n\tdlfcn_name_converter,\n\tdlfcn_merger,\n\tNULL, /* init */\n\tNULL, /* finish */\n\tdlfcn_pathbyaddr,\n\tdlfcn_globallookup\n\t};\n\nDSO_METHOD *DSO_METHOD_dlfcn(void)\n\t{\n\treturn(&dso_meth_dlfcn);\n\t}\n\n/* Prior to using the dlopen() function, we should decide on the flag\n * we send. There's a few different ways of doing this and it's a\n * messy venn-diagram to match up which platforms support what. So\n * as we don't have autoconf yet, I'm implementing a hack that could\n * be hacked further relatively easily to deal with cases as we find\n * them. Initially this is to cope with OpenBSD. */\n#if defined(__OpenBSD__) || defined(__NetBSD__)\n#\tifdef DL_LAZY\n#\t\tdefine DLOPEN_FLAG DL_LAZY\n#\telse\n#\t\tifdef RTLD_NOW\n#\t\t\tdefine DLOPEN_FLAG RTLD_NOW\n#\t\telse\n#\t\t\tdefine DLOPEN_FLAG 0\n#\t\tendif\n#\tendif\n#else\n#\tifdef OPENSSL_SYS_SUNOS\n#\t\tdefine DLOPEN_FLAG 1\n#\telse\n#\t\tdefine DLOPEN_FLAG RTLD_NOW /* Hope this works everywhere else */\n#\tendif\n#endif\n\n/* For this DSO_METHOD, our meth_data STACK will contain;\n * (i) the handle (void*) returned from dlopen().\n */\n\nstatic int dlfcn_load(DSO *dso)\n\t{\n\tvoid *ptr = NULL;\n\t/* See applicable comments in dso_dl.c */\n\tchar *filename = DSO_convert_filename(dso, NULL);\n\tint flags = DLOPEN_FLAG;\n\n\tif(filename == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_LOAD,DSO_R_NO_FILENAME);\n\t\tgoto err;\n\t\t}\n\n#ifdef RTLD_GLOBAL\n\tif (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)\n\t\tflags |= RTLD_GLOBAL;\n#endif\n\tptr = dlopen(filename, flags);\n\tif(ptr == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_LOAD,DSO_R_LOAD_FAILED);\n\t\tERR_add_error_data(4, \"filename(\", filename, \"): \", dlerror());\n\t\tgoto err;\n\t\t}\n\tif(!sk_void_push(dso->meth_data, (char *)ptr))\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_LOAD,DSO_R_STACK_ERROR);\n\t\tgoto err;\n\t\t}\n\t/* Success */\n\tdso->loaded_filename = filename;\n\treturn(1);\nerr:\n\t/* Cleanup! */\n\tif(filename != NULL)\n\t\tOPENSSL_free(filename);\n\tif(ptr != NULL)\n\t\tdlclose(ptr);\n\treturn(0);\n}\n\nstatic int dlfcn_unload(DSO *dso)\n\t{\n\tvoid *ptr;\n\tif(dso == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_UNLOAD,ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn(0);\n\t\t}\n\tif(sk_void_num(dso->meth_data) < 1)\n\t\treturn(1);\n\tptr = sk_void_pop(dso->meth_data);\n\tif(ptr == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_UNLOAD,DSO_R_NULL_HANDLE);\n\t\t/* Should push the value back onto the stack in\n\t\t * case of a retry. */\n\t\tsk_void_push(dso->meth_data, ptr);\n\t\treturn(0);\n\t\t}\n\t/* For now I'm not aware of any errors associated with dlclose() */\n\tdlclose(ptr);\n\treturn(1);\n\t}\n\nstatic void *dlfcn_bind_var(DSO *dso, const char *symname)\n\t{\n\tvoid *ptr, *sym;\n\n\tif((dso == NULL) || (symname == NULL))\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_BIND_VAR,ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn(NULL);\n\t\t}\n\tif(sk_void_num(dso->meth_data) < 1)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_BIND_VAR,DSO_R_STACK_ERROR);\n\t\treturn(NULL);\n\t\t}\n\tptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\n\tif(ptr == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_BIND_VAR,DSO_R_NULL_HANDLE);\n\t\treturn(NULL);\n\t\t}\n\tsym = dlsym(ptr, symname);\n\tif(sym == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_BIND_VAR,DSO_R_SYM_FAILURE);\n\t\tERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\n\t\treturn(NULL);\n\t\t}\n\treturn(sym);\n\t}\n\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)\n\t{\n\tvoid *ptr;\n\tunion {\n\t\tDSO_FUNC_TYPE sym;\n\t\tvoid *dlret;\n\t} u;\n\n\tif((dso == NULL) || (symname == NULL))\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_BIND_FUNC,ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn(NULL);\n\t\t}\n\tif(sk_void_num(dso->meth_data) < 1)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_BIND_FUNC,DSO_R_STACK_ERROR);\n\t\treturn(NULL);\n\t\t}\n\tptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\n\tif(ptr == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_BIND_FUNC,DSO_R_NULL_HANDLE);\n\t\treturn(NULL);\n\t\t}\n\tu.dlret = dlsym(ptr, symname);\n\tif(u.dlret == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_BIND_FUNC,DSO_R_SYM_FAILURE);\n\t\tERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\n\t\treturn(NULL);\n\t\t}\n\treturn u.sym;\n\t}\n\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n\tconst char *filespec2)\n\t{\n\tchar *merged;\n\n\tif(!filespec1 && !filespec2)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_MERGER,\n\t\t\t\tERR_R_PASSED_NULL_PARAMETER);\n\t\treturn(NULL);\n\t\t}\n\t/* If the first file specification is a rooted path, it rules.\n\t   same goes if the second file specification is missing. */\n\tif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/'))\n\t\t{\n\t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1);\n\t\tif(!merged)\n\t\t\t{\n\t\t\tDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n\t\t\treturn(NULL);\n\t\t\t}\n\t\tstrcpy(merged, filespec1);\n\t\t}\n\t/* If the first file specification is missing, the second one rules. */\n\telse if (!filespec1)\n\t\t{\n\t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1);\n\t\tif(!merged)\n\t\t\t{\n\t\t\tDSOerr(DSO_F_DLFCN_MERGER,\n\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\treturn(NULL);\n\t\t\t}\n\t\tstrcpy(merged, filespec2);\n\t\t}\n\telse\n\t\t/* This part isn't as trivial as it looks.  It assumes that\n\t\t   the second file specification really is a directory, and\n\t\t   makes no checks whatsoever.  Therefore, the result becomes\n\t\t   the concatenation of filespec2 followed by a slash followed\n\t\t   by filespec1. */\n\t\t{\n\t\tint spec2len, len;\n\n\t\tspec2len = strlen(filespec2);\n\t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0);\n\n\t\tif(filespec2 && filespec2[spec2len - 1] == '/')\n\t\t\t{\n\t\t\tspec2len--;\n\t\t\tlen--;\n\t\t\t}\n\t\tmerged = OPENSSL_malloc(len + 2);\n\t\tif(!merged)\n\t\t\t{\n\t\t\tDSOerr(DSO_F_DLFCN_MERGER,\n\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\treturn(NULL);\n\t\t\t}\n\t\tstrcpy(merged, filespec2);\n\t\tmerged[spec2len] = '/';\n\t\tstrcpy(&merged[spec2len + 1], filespec1);\n\t\t}\n\treturn(merged);\n\t}\n\n#ifdef OPENSSL_SYS_MACOSX\n#define DSO_ext\t\".dylib\"\n#define DSO_extlen 6\n#else\n#define DSO_ext\t\".so\"\n#define DSO_extlen 3\n#endif\n\n\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename)\n\t{\n\tchar *translated;\n\tint len, rsize, transform;\n\n\tlen = strlen(filename);\n\trsize = len + 1;\n\ttransform = (strstr(filename, \"/\") == NULL);\n\tif(transform)\n\t\t{\n\t\t/* We will convert this to \"%s.so\" or \"lib%s.so\" etc */\n\t\trsize += DSO_extlen;\t/* The length of \".so\" */\n\t\tif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n\t\t\trsize += 3; /* The length of \"lib\" */\n\t\t}\n\ttranslated = OPENSSL_malloc(rsize);\n\tif(translated == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DLFCN_NAME_CONVERTER,\n\t\t\t\tDSO_R_NAME_TRANSLATION_FAILED);\n\t\treturn(NULL);\n\t\t}\n\tif(transform)\n\t\t{\n\t\tif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n\t\t\tsprintf(translated, \"lib%s\" DSO_ext, filename);\n\t\telse\n\t\t\tsprintf(translated, \"%s\" DSO_ext, filename);\n\t\t}\n\telse\n\t\tsprintf(translated, \"%s\", filename);\n\treturn(translated);\n\t}\n\n#ifdef __sgi\n/*\nThis is a quote from IRIX manual for dladdr(3c):\n\n     <dlfcn.h> does not contain a prototype for dladdr or definition of\n     Dl_info.  The #include <dlfcn.h>  in the SYNOPSIS line is traditional,\n     but contains no dladdr prototype and no IRIX library contains an\n     implementation.  Write your own declaration based on the code below.\n\n     The following code is dependent on internal interfaces that are not\n     part of the IRIX compatibility guarantee; however, there is no future\n     intention to change this interface, so on a practical level, the code\n     below is safe to use on IRIX.\n*/\n#include <rld_interface.h>\n#ifndef _RLD_INTERFACE_DLFCN_H_DLADDR\n#define _RLD_INTERFACE_DLFCN_H_DLADDR\ntypedef struct Dl_info {\n    const char * dli_fname;\n    void       * dli_fbase;\n    const char * dli_sname;\n    void       * dli_saddr;\n    int          dli_version;\n    int          dli_reserved1;\n    long         dli_reserved[4];\n} Dl_info;\n#else\ntypedef struct Dl_info Dl_info;\n#endif\n#define _RLD_DLADDR             14\n\nstatic int dladdr(void *address, Dl_info *dl)\n{\n\tvoid *v;\n\tv = _rld_new_interface(_RLD_DLADDR,address,dl);\n\treturn (int)v;\n}\n#endif /* __sgi */\n\nstatic int dlfcn_pathbyaddr(void *addr,char *path,int sz)\n\t{\n#ifdef HAVE_DLINFO\n\tDl_info dli;\n\tint len;\n\n\tif (addr == NULL)\n\t\t{\n\t\tunion\t{ int(*f)(void*,char*,int); void *p; } t =\n\t\t\t{ dlfcn_pathbyaddr };\n\t\taddr = t.p;\n\t\t}\n\n\tif (dladdr(addr,&dli))\n\t\t{\n\t\tlen = (int)strlen(dli.dli_fname);\n\t\tif (sz <= 0) return len+1;\n\t\tif (len >= sz) len=sz-1;\n\t\tmemcpy(path,dli.dli_fname,len);\n\t\tpath[len++]=0;\n\t\treturn len;\n\t\t}\n\n\tERR_add_error_data(2, \"dlfcn_pathbyaddr(): \", dlerror());\n#endif\n\treturn -1;\n\t}\n\nstatic void *dlfcn_globallookup(const char *name)\n\t{\n\tvoid *ret = NULL,*handle = dlopen(NULL,RTLD_LAZY);\n\t\n\tif (handle)\n\t\t{\n\t\tret = dlsym(handle,name);\n\t\tdlclose(handle);\n\t\t}\n\n\treturn ret;\n\t}\n#endif /* DSO_DLFCN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/dso/dso.h": "/* dso.h -*- mode:C; c-file-style: \"eay\" -*- */\n/* Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL\n * project 2000.\n */\n/* ====================================================================\n * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n#ifndef HEADER_DSO_H\n#define HEADER_DSO_H\n\n#include <openssl/crypto.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* These values are used as commands to DSO_ctrl() */\n#define DSO_CTRL_GET_FLAGS\t1\n#define DSO_CTRL_SET_FLAGS\t2\n#define DSO_CTRL_OR_FLAGS\t3\n\n/* By default, DSO_load() will translate the provided filename into a form\n * typical for the platform (more specifically the DSO_METHOD) using the\n * dso_name_converter function of the method. Eg. win32 will transform \"blah\"\n * into \"blah.dll\", and dlfcn will transform it into \"libblah.so\". The\n * behaviour can be overriden by setting the name_converter callback in the DSO\n * object (using DSO_set_name_converter()). This callback could even utilise\n * the DSO_METHOD's converter too if it only wants to override behaviour for\n * one or two possible DSO methods. However, the following flag can be set in a\n * DSO to prevent *any* native name-translation at all - eg. if the caller has\n * prompted the user for a path to a driver library so the filename should be\n * interpreted as-is. */\n#define DSO_FLAG_NO_NAME_TRANSLATION\t\t0x01\n/* An extra flag to give if only the extension should be added as\n * translation.  This is obviously only of importance on Unix and\n * other operating systems where the translation also may prefix\n * the name with something, like 'lib', and ignored everywhere else.\n * This flag is also ignored if DSO_FLAG_NO_NAME_TRANSLATION is used\n * at the same time. */\n#define DSO_FLAG_NAME_TRANSLATION_EXT_ONLY\t0x02\n\n/* The following flag controls the translation of symbol names to upper\n * case.  This is currently only being implemented for OpenVMS.\n */\n#define DSO_FLAG_UPCASE_SYMBOL\t\t\t0x10\n\n/* This flag loads the library with public symbols.\n * Meaning: The exported symbols of this library are public\n * to all libraries loaded after this library.\n * At the moment only implemented in unix.\n */\n#define DSO_FLAG_GLOBAL_SYMBOLS\t\t\t0x20\n\n\ntypedef void (*DSO_FUNC_TYPE)(void);\n\ntypedef struct dso_st DSO;\n\n/* The function prototype used for method functions (or caller-provided\n * callbacks) that transform filenames. They are passed a DSO structure pointer\n * (or NULL if they are to be used independantly of a DSO object) and a\n * filename to transform. They should either return NULL (if there is an error\n * condition) or a newly allocated string containing the transformed form that\n * the caller will need to free with OPENSSL_free() when done. */\ntypedef char* (*DSO_NAME_CONVERTER_FUNC)(DSO *, const char *);\n/* The function prototype used for method functions (or caller-provided\n * callbacks) that merge two file specifications. They are passed a\n * DSO structure pointer (or NULL if they are to be used independantly of\n * a DSO object) and two file specifications to merge. They should\n * either return NULL (if there is an error condition) or a newly allocated\n * string containing the result of merging that the caller will need\n * to free with OPENSSL_free() when done.\n * Here, merging means that bits and pieces are taken from each of the\n * file specifications and added together in whatever fashion that is\n * sensible for the DSO method in question.  The only rule that really\n * applies is that if the two specification contain pieces of the same\n * type, the copy from the first string takes priority.  One could see\n * it as the first specification is the one given by the user and the\n * second being a bunch of defaults to add on if they're missing in the\n * first. */\ntypedef char* (*DSO_MERGER_FUNC)(DSO *, const char *, const char *);\n\ntypedef struct dso_meth_st\n\t{\n\tconst char *name;\n\t/* Loads a shared library, NB: new DSO_METHODs must ensure that a\n\t * successful load populates the loaded_filename field, and likewise a\n\t * successful unload OPENSSL_frees and NULLs it out. */\n\tint (*dso_load)(DSO *dso);\n\t/* Unloads a shared library */\n\tint (*dso_unload)(DSO *dso);\n\t/* Binds a variable */\n\tvoid *(*dso_bind_var)(DSO *dso, const char *symname);\n\t/* Binds a function - assumes a return type of DSO_FUNC_TYPE.\n\t * This should be cast to the real function prototype by the\n\t * caller. Platforms that don't have compatible representations\n\t * for different prototypes (this is possible within ANSI C)\n\t * are highly unlikely to have shared libraries at all, let\n\t * alone a DSO_METHOD implemented for them. */\n\tDSO_FUNC_TYPE (*dso_bind_func)(DSO *dso, const char *symname);\n\n/* I don't think this would actually be used in any circumstances. */\n#if 0\n\t/* Unbinds a variable */\n\tint (*dso_unbind_var)(DSO *dso, char *symname, void *symptr);\n\t/* Unbinds a function */\n\tint (*dso_unbind_func)(DSO *dso, char *symname, DSO_FUNC_TYPE symptr);\n#endif\n\t/* The generic (yuck) \"ctrl()\" function. NB: Negative return\n\t * values (rather than zero) indicate errors. */\n\tlong (*dso_ctrl)(DSO *dso, int cmd, long larg, void *parg);\n\t/* The default DSO_METHOD-specific function for converting filenames to\n\t * a canonical native form. */\n\tDSO_NAME_CONVERTER_FUNC dso_name_converter;\n\t/* The default DSO_METHOD-specific function for converting filenames to\n\t * a canonical native form. */\n\tDSO_MERGER_FUNC dso_merger;\n\n\t/* [De]Initialisation handlers. */\n\tint (*init)(DSO *dso);\n\tint (*finish)(DSO *dso);\n\n\t/* Return pathname of the module containing location */\n\tint (*pathbyaddr)(void *addr,char *path,int sz);\n\t/* Perform global symbol lookup, i.e. among *all* modules */\n\tvoid *(*globallookup)(const char *symname);\n\t} DSO_METHOD;\n\n/**********************************************************************/\n/* The low-level handle type used to refer to a loaded shared library */\n\nstruct dso_st\n\t{\n\tDSO_METHOD *meth;\n\t/* Standard dlopen uses a (void *). Win32 uses a HANDLE. VMS\n\t * doesn't use anything but will need to cache the filename\n\t * for use in the dso_bind handler. All in all, let each\n\t * method control its own destiny. \"Handles\" and such go in\n\t * a STACK. */\n\tSTACK_OF(void) *meth_data;\n\tint references;\n\tint flags;\n\t/* For use by applications etc ... use this for your bits'n'pieces,\n\t * don't touch meth_data! */\n\tCRYPTO_EX_DATA ex_data;\n\t/* If this callback function pointer is set to non-NULL, then it will\n\t * be used in DSO_load() in place of meth->dso_name_converter. NB: This\n\t * should normally set using DSO_set_name_converter(). */\n\tDSO_NAME_CONVERTER_FUNC name_converter;\n\t/* If this callback function pointer is set to non-NULL, then it will\n\t * be used in DSO_load() in place of meth->dso_merger. NB: This\n\t * should normally set using DSO_set_merger(). */\n\tDSO_MERGER_FUNC merger;\n\t/* This is populated with (a copy of) the platform-independant\n\t * filename used for this DSO. */\n\tchar *filename;\n\t/* This is populated with (a copy of) the translated filename by which\n\t * the DSO was actually loaded. It is NULL iff the DSO is not currently\n\t * loaded. NB: This is here because the filename translation process\n\t * may involve a callback being invoked more than once not only to\n\t * convert to a platform-specific form, but also to try different\n\t * filenames in the process of trying to perform a load. As such, this\n\t * variable can be used to indicate (a) whether this DSO structure\n\t * corresponds to a loaded library or not, and (b) the filename with\n\t * which it was actually loaded. */\n\tchar *loaded_filename;\n\t};\n\n\nDSO *\tDSO_new(void);\nDSO *\tDSO_new_method(DSO_METHOD *method);\nint\tDSO_free(DSO *dso);\nint\tDSO_flags(DSO *dso);\nint\tDSO_up_ref(DSO *dso);\nlong\tDSO_ctrl(DSO *dso, int cmd, long larg, void *parg);\n\n/* This function sets the DSO's name_converter callback. If it is non-NULL,\n * then it will be used instead of the associated DSO_METHOD's function. If\n * oldcb is non-NULL then it is set to the function pointer value being\n * replaced. Return value is non-zero for success. */\nint\tDSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb,\n\t\t\t\tDSO_NAME_CONVERTER_FUNC *oldcb);\n/* These functions can be used to get/set the platform-independant filename\n * used for a DSO. NB: set will fail if the DSO is already loaded. */\nconst char *DSO_get_filename(DSO *dso);\nint\tDSO_set_filename(DSO *dso, const char *filename);\n/* This function will invoke the DSO's name_converter callback to translate a\n * filename, or if the callback isn't set it will instead use the DSO_METHOD's\n * converter. If \"filename\" is NULL, the \"filename\" in the DSO itself will be\n * used. If the DSO_FLAG_NO_NAME_TRANSLATION flag is set, then the filename is\n * simply duplicated. NB: This function is usually called from within a\n * DSO_METHOD during the processing of a DSO_load() call, and is exposed so that\n * caller-created DSO_METHODs can do the same thing. A non-NULL return value\n * will need to be OPENSSL_free()'d. */\nchar\t*DSO_convert_filename(DSO *dso, const char *filename);\n/* This function will invoke the DSO's merger callback to merge two file\n * specifications, or if the callback isn't set it will instead use the\n * DSO_METHOD's merger.  A non-NULL return value will need to be\n * OPENSSL_free()'d. */\nchar\t*DSO_merge(DSO *dso, const char *filespec1, const char *filespec2);\n/* If the DSO is currently loaded, this returns the filename that it was loaded\n * under, otherwise it returns NULL. So it is also useful as a test as to\n * whether the DSO is currently loaded. NB: This will not necessarily return\n * the same value as DSO_convert_filename(dso, dso->filename), because the\n * DSO_METHOD's load function may have tried a variety of filenames (with\n * and/or without the aid of the converters) before settling on the one it\n * actually loaded. */\nconst char *DSO_get_loaded_filename(DSO *dso);\n\nvoid\tDSO_set_default_method(DSO_METHOD *meth);\nDSO_METHOD *DSO_get_default_method(void);\nDSO_METHOD *DSO_get_method(DSO *dso);\nDSO_METHOD *DSO_set_method(DSO *dso, DSO_METHOD *meth);\n\n/* The all-singing all-dancing load function, you normally pass NULL\n * for the first and third parameters. Use DSO_up and DSO_free for\n * subsequent reference count handling. Any flags passed in will be set\n * in the constructed DSO after its init() function but before the\n * load operation. If 'dso' is non-NULL, 'flags' is ignored. */\nDSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags);\n\n/* This function binds to a variable inside a shared library. */\nvoid *DSO_bind_var(DSO *dso, const char *symname);\n\n/* This function binds to a function inside a shared library. */\nDSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname);\n\n/* This method is the default, but will beg, borrow, or steal whatever\n * method should be the default on any particular platform (including\n * DSO_METH_null() if necessary). */\nDSO_METHOD *DSO_METHOD_openssl(void);\n\n/* This method is defined for all platforms - if a platform has no\n * DSO support then this will be the only method! */\nDSO_METHOD *DSO_METHOD_null(void);\n\n/* If DSO_DLFCN is defined, the standard dlfcn.h-style functions\n * (dlopen, dlclose, dlsym, etc) will be used and incorporated into\n * this method. If not, this method will return NULL. */\nDSO_METHOD *DSO_METHOD_dlfcn(void);\n\n/* If DSO_DL is defined, the standard dl.h-style functions (shl_load, \n * shl_unload, shl_findsym, etc) will be used and incorporated into\n * this method. If not, this method will return NULL. */\nDSO_METHOD *DSO_METHOD_dl(void);\n\n/* If WIN32 is defined, use DLLs. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_win32(void);\n\n/* If VMS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_vms(void);\n\n/* This function writes null-terminated pathname of DSO module\n * containing 'addr' into 'sz' large caller-provided 'path' and\n * returns the number of characters [including trailing zero]\n * written to it. If 'sz' is 0 or negative, 'path' is ignored and\n * required amount of charachers [including trailing zero] to\n * accomodate pathname is returned. If 'addr' is NULL, then\n * pathname of cryptolib itself is returned. Negative or zero\n * return value denotes error.\n */\nint DSO_pathbyaddr(void *addr,char *path,int sz);\n\n/* This function should be used with caution! It looks up symbols in\n * *all* loaded modules and if module gets unloaded by somebody else\n * attempt to dereference the pointer is doomed to have fatal\n * consequences. Primary usage for this function is to probe *core*\n * system functionality, e.g. check if getnameinfo(3) is available\n * at run-time without bothering about OS-specific details such as\n * libc.so.versioning or where does it actually reside: in libc\n * itself or libsocket. */\nvoid *DSO_global_lookup(const char *name);\n\n/* If BeOS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_beos(void);\n\n/* BEGIN ERROR CODES */\n/* The following lines are auto generated by the script mkerr.pl. Any changes\n * made after this point may be overwritten when the script is next run.\n */\nvoid ERR_load_DSO_strings(void);\n\n/* Error codes for the DSO functions. */\n\n/* Function codes. */\n#define DSO_F_BEOS_BIND_FUNC\t\t\t\t 144\n#define DSO_F_BEOS_BIND_VAR\t\t\t\t 145\n#define DSO_F_BEOS_LOAD\t\t\t\t\t 146\n#define DSO_F_BEOS_NAME_CONVERTER\t\t\t 147\n#define DSO_F_BEOS_UNLOAD\t\t\t\t 148\n#define DSO_F_DLFCN_BIND_FUNC\t\t\t\t 100\n#define DSO_F_DLFCN_BIND_VAR\t\t\t\t 101\n#define DSO_F_DLFCN_LOAD\t\t\t\t 102\n#define DSO_F_DLFCN_MERGER\t\t\t\t 130\n#define DSO_F_DLFCN_NAME_CONVERTER\t\t\t 123\n#define DSO_F_DLFCN_UNLOAD\t\t\t\t 103\n#define DSO_F_DL_BIND_FUNC\t\t\t\t 104\n#define DSO_F_DL_BIND_VAR\t\t\t\t 105\n#define DSO_F_DL_LOAD\t\t\t\t\t 106\n#define DSO_F_DL_MERGER\t\t\t\t\t 131\n#define DSO_F_DL_NAME_CONVERTER\t\t\t\t 124\n#define DSO_F_DL_UNLOAD\t\t\t\t\t 107\n#define DSO_F_DSO_BIND_FUNC\t\t\t\t 108\n#define DSO_F_DSO_BIND_VAR\t\t\t\t 109\n#define DSO_F_DSO_CONVERT_FILENAME\t\t\t 126\n#define DSO_F_DSO_CTRL\t\t\t\t\t 110\n#define DSO_F_DSO_FREE\t\t\t\t\t 111\n#define DSO_F_DSO_GET_FILENAME\t\t\t\t 127\n#define DSO_F_DSO_GET_LOADED_FILENAME\t\t\t 128\n#define DSO_F_DSO_GLOBAL_LOOKUP\t\t\t\t 139\n#define DSO_F_DSO_LOAD\t\t\t\t\t 112\n#define DSO_F_DSO_MERGE\t\t\t\t\t 132\n#define DSO_F_DSO_NEW_METHOD\t\t\t\t 113\n#define DSO_F_DSO_PATHBYADDR\t\t\t\t 140\n#define DSO_F_DSO_SET_FILENAME\t\t\t\t 129\n#define DSO_F_DSO_SET_NAME_CONVERTER\t\t\t 122\n#define DSO_F_DSO_UP_REF\t\t\t\t 114\n#define DSO_F_GLOBAL_LOOKUP_FUNC\t\t\t 138\n#define DSO_F_PATHBYADDR\t\t\t\t 137\n#define DSO_F_VMS_BIND_SYM\t\t\t\t 115\n#define DSO_F_VMS_LOAD\t\t\t\t\t 116\n#define DSO_F_VMS_MERGER\t\t\t\t 133\n#define DSO_F_VMS_UNLOAD\t\t\t\t 117\n#define DSO_F_WIN32_BIND_FUNC\t\t\t\t 118\n#define DSO_F_WIN32_BIND_VAR\t\t\t\t 119\n#define DSO_F_WIN32_GLOBALLOOKUP\t\t\t 142\n#define DSO_F_WIN32_GLOBALLOOKUP_FUNC\t\t\t 143\n#define DSO_F_WIN32_JOINER\t\t\t\t 135\n#define DSO_F_WIN32_LOAD\t\t\t\t 120\n#define DSO_F_WIN32_MERGER\t\t\t\t 134\n#define DSO_F_WIN32_NAME_CONVERTER\t\t\t 125\n#define DSO_F_WIN32_PATHBYADDR\t\t\t\t 141\n#define DSO_F_WIN32_SPLITTER\t\t\t\t 136\n#define DSO_F_WIN32_UNLOAD\t\t\t\t 121\n\n/* Reason codes. */\n#define DSO_R_CTRL_FAILED\t\t\t\t 100\n#define DSO_R_DSO_ALREADY_LOADED\t\t\t 110\n#define DSO_R_EMPTY_FILE_STRUCTURE\t\t\t 113\n#define DSO_R_FAILURE\t\t\t\t\t 114\n#define DSO_R_FILENAME_TOO_BIG\t\t\t\t 101\n#define DSO_R_FINISH_FAILED\t\t\t\t 102\n#define DSO_R_INCORRECT_FILE_SYNTAX\t\t\t 115\n#define DSO_R_LOAD_FAILED\t\t\t\t 103\n#define DSO_R_NAME_TRANSLATION_FAILED\t\t\t 109\n#define DSO_R_NO_FILENAME\t\t\t\t 111\n#define DSO_R_NO_FILE_SPECIFICATION\t\t\t 116\n#define DSO_R_NULL_HANDLE\t\t\t\t 104\n#define DSO_R_SET_FILENAME_FAILED\t\t\t 112\n#define DSO_R_STACK_ERROR\t\t\t\t 105\n#define DSO_R_SYM_FAILURE\t\t\t\t 106\n#define DSO_R_UNLOAD_FAILED\t\t\t\t 107\n#define DSO_R_UNSUPPORTED\t\t\t\t 108\n\n#ifdef  __cplusplus\n}\n#endif\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/util/mkrc.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/sparccpuid.S",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/bn/asm/s390x-gf2m.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/bn/asm/armv4-gf2m.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/bn/asm/x86_64-gcc.c",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/bn/asm/ia64.S",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/bn/asm/x86-gf2m.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/bn/asm/x86_64-gf2m.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/modes/asm/ghash-armv4.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/modes/asm/ghash-x86.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/sha/asm/sha256-586.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/sha/asm/sha1-586.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/sha/asm/sha512-586.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/pkcs7/p7/smime.p7m",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/pkcs7/p7/smime.p7s",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/pkcs7/p7/cert.p7c",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/whrlpool/asm/wp-mmx.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/aes/asm/aes-586.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/x509v3/v3_pci.c",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/x509v3/v3_pcia.c",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/crypto/rc4/asm/rc4-x86_64.pl",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/ms/.rnd",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/doc/openssl_button.gif",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.1h-3kpevnvmxpnqb3mwxdm2s76lj73wlfg2/spack-src/doc/HOWTO/proxy_certificates.txt"
    ],
    "total_files": 2129
}