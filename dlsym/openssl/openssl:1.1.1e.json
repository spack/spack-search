{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/crypto/rand/rand_vms.c": "/*\n * Copyright 2001-2020 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include \"e_os.h\"\n\n#if defined(OPENSSL_SYS_VMS)\n# define __NEW_STARLET 1         /* New starlet definitions since VMS 7.0 */\n# include <unistd.h>\n# include \"internal/cryptlib.h\"\n# include <openssl/bio.h>\n# include <openssl/err.h>\n# include <openssl/rand.h>\n# include \"crypto/rand.h\"\n# include \"rand_local.h\"\n# include <descrip.h>\n# include <dvidef.h>\n# include <jpidef.h>\n# include <rmidef.h>\n# include <syidef.h>\n# include <ssdef.h>\n# include <starlet.h>\n# include <efndef.h>\n# include <gen64def.h>\n# include <iosbdef.h>\n# include <iledef.h>\n# include <lib$routines.h>\n# ifdef __DECC\n#  pragma message disable DOLLARID\n# endif\n\n# include <dlfcn.h>              /* SYS$GET_ENTROPY presence */\n\n# ifndef OPENSSL_RAND_SEED_OS\n#  error \"Unsupported seeding method configured; must be os\"\n# endif\n\n/*\n * DATA COLLECTION METHOD\n * ======================\n *\n * This is a method to get low quality entropy.\n * It works by collecting all kinds of statistical data that\n * VMS offers and using them as random seed.\n */\n\n/* We need to make sure we have the right size pointer in some cases */\n# if __INITIAL_POINTER_SIZE == 64\n#  pragma pointer_size save\n#  pragma pointer_size 32\n# endif\ntypedef uint32_t *uint32_t__ptr32;\n# if __INITIAL_POINTER_SIZE == 64\n#  pragma pointer_size restore\n# endif\n\nstruct item_st {\n    short length, code;         /* length is number of bytes */\n};\n\nstatic const struct item_st DVI_item_data[] = {\n    {4,   DVI$_ERRCNT},\n    {4,   DVI$_REFCNT},\n};\n\nstatic const struct item_st JPI_item_data[] = {\n    {4,   JPI$_BUFIO},\n    {4,   JPI$_CPUTIM},\n    {4,   JPI$_DIRIO},\n    {4,   JPI$_IMAGECOUNT},\n    {4,   JPI$_PAGEFLTS},\n    {4,   JPI$_PID},\n    {4,   JPI$_PPGCNT},\n    {4,   JPI$_WSPEAK},\n    /*\n     * Note: the direct result is just a 32-bit address.  However, it points\n     * to a list of 4 32-bit words, so we make extra space for them so we can\n     * do in-place replacement of values\n     */\n    {16,  JPI$_FINALEXC},\n};\n\nstatic const struct item_st JPI_item_data_64bit[] = {\n    {8,   JPI$_LAST_LOGIN_I},\n    {8,   JPI$_LOGINTIM},\n};\n\nstatic const struct item_st RMI_item_data[] = {\n    {4,   RMI$_COLPG},\n    {4,   RMI$_MWAIT},\n    {4,   RMI$_CEF},\n    {4,   RMI$_PFW},\n    {4,   RMI$_LEF},\n    {4,   RMI$_LEFO},\n    {4,   RMI$_HIB},\n    {4,   RMI$_HIBO},\n    {4,   RMI$_SUSP},\n    {4,   RMI$_SUSPO},\n    {4,   RMI$_FPG},\n    {4,   RMI$_COM},\n    {4,   RMI$_COMO},\n    {4,   RMI$_CUR},\n#if defined __alpha\n    {4,   RMI$_FRLIST},\n    {4,   RMI$_MODLIST},\n#endif\n    {4,   RMI$_FAULTS},\n    {4,   RMI$_PREADS},\n    {4,   RMI$_PWRITES},\n    {4,   RMI$_PWRITIO},\n    {4,   RMI$_PREADIO},\n    {4,   RMI$_GVALFLTS},\n    {4,   RMI$_WRTINPROG},\n    {4,   RMI$_FREFLTS},\n    {4,   RMI$_DZROFLTS},\n    {4,   RMI$_SYSFAULTS},\n    {4,   RMI$_ISWPCNT},\n    {4,   RMI$_DIRIO},\n    {4,   RMI$_BUFIO},\n    {4,   RMI$_MBREADS},\n    {4,   RMI$_MBWRITES},\n    {4,   RMI$_LOGNAM},\n    {4,   RMI$_FCPCALLS},\n    {4,   RMI$_FCPREAD},\n    {4,   RMI$_FCPWRITE},\n    {4,   RMI$_FCPCACHE},\n    {4,   RMI$_FCPCPU},\n    {4,   RMI$_FCPHIT},\n    {4,   RMI$_FCPSPLIT},\n    {4,   RMI$_FCPFAULT},\n    {4,   RMI$_ENQNEW},\n    {4,   RMI$_ENQCVT},\n    {4,   RMI$_DEQ},\n    {4,   RMI$_BLKAST},\n    {4,   RMI$_ENQWAIT},\n    {4,   RMI$_ENQNOTQD},\n    {4,   RMI$_DLCKSRCH},\n    {4,   RMI$_DLCKFND},\n    {4,   RMI$_NUMLOCKS},\n    {4,   RMI$_NUMRES},\n    {4,   RMI$_ARRLOCPK},\n    {4,   RMI$_DEPLOCPK},\n    {4,   RMI$_ARRTRAPK},\n    {4,   RMI$_TRCNGLOS},\n    {4,   RMI$_RCVBUFFL},\n    {4,   RMI$_ENQNEWLOC},\n    {4,   RMI$_ENQNEWIN},\n    {4,   RMI$_ENQNEWOUT},\n    {4,   RMI$_ENQCVTLOC},\n    {4,   RMI$_ENQCVTIN},\n    {4,   RMI$_ENQCVTOUT},\n    {4,   RMI$_DEQLOC},\n    {4,   RMI$_DEQIN},\n    {4,   RMI$_DEQOUT},\n    {4,   RMI$_BLKLOC},\n    {4,   RMI$_BLKIN},\n    {4,   RMI$_BLKOUT},\n    {4,   RMI$_DIRIN},\n    {4,   RMI$_DIROUT},\n    /* We currently get a fault when trying these.  TODO: To be figured out. */\n#if 0\n    {140, RMI$_MSCP_EVERYTHING},   /* 35 32-bit words */\n    {152, RMI$_DDTM_ALL},          /* 38 32-bit words */\n    {80,  RMI$_TMSCP_EVERYTHING}   /* 20 32-bit words */\n#endif\n    {4,   RMI$_LPZ_PAGCNT},\n    {4,   RMI$_LPZ_HITS},\n    {4,   RMI$_LPZ_MISSES},\n    {4,   RMI$_LPZ_EXPCNT},\n    {4,   RMI$_LPZ_ALLOCF},\n    {4,   RMI$_LPZ_ALLOC2},\n    {4,   RMI$_ACCESS},\n    {4,   RMI$_ALLOC},\n    {4,   RMI$_FCPCREATE},\n    {4,   RMI$_VOLWAIT},\n    {4,   RMI$_FCPTURN},\n    {4,   RMI$_FCPERASE},\n    {4,   RMI$_OPENS},\n    {4,   RMI$_FIDHIT},\n    {4,   RMI$_FIDMISS},\n    {4,   RMI$_FILHDR_HIT},\n    {4,   RMI$_DIRFCB_HIT},\n    {4,   RMI$_DIRFCB_MISS},\n    {4,   RMI$_DIRDATA_HIT},\n    {4,   RMI$_EXTHIT},\n    {4,   RMI$_EXTMISS},\n    {4,   RMI$_QUOHIT},\n    {4,   RMI$_QUOMISS},\n    {4,   RMI$_STORAGMAP_HIT},\n    {4,   RMI$_VOLLCK},\n    {4,   RMI$_SYNCHLCK},\n    {4,   RMI$_SYNCHWAIT},\n    {4,   RMI$_ACCLCK},\n    {4,   RMI$_XQPCACHEWAIT},\n    {4,   RMI$_DIRDATA_MISS},\n    {4,   RMI$_FILHDR_MISS},\n    {4,   RMI$_STORAGMAP_MISS},\n    {4,   RMI$_PROCCNTMAX},\n    {4,   RMI$_PROCBATCNT},\n    {4,   RMI$_PROCINTCNT},\n    {4,   RMI$_PROCNETCNT},\n    {4,   RMI$_PROCSWITCHCNT},\n    {4,   RMI$_PROCBALSETCNT},\n    {4,   RMI$_PROCLOADCNT},\n    {4,   RMI$_BADFLTS},\n    {4,   RMI$_EXEFAULTS},\n    {4,   RMI$_HDRINSWAPS},\n    {4,   RMI$_HDROUTSWAPS},\n    {4,   RMI$_IOPAGCNT},\n    {4,   RMI$_ISWPCNTPG},\n    {4,   RMI$_OSWPCNT},\n    {4,   RMI$_OSWPCNTPG},\n    {4,   RMI$_RDFAULTS},\n    {4,   RMI$_TRANSFLTS},\n    {4,   RMI$_WRTFAULTS},\n#if defined __alpha\n    {4,   RMI$_USERPAGES},\n#endif\n    {4,   RMI$_VMSPAGES},\n    {4,   RMI$_TTWRITES},\n    {4,   RMI$_BUFOBJPAG},\n    {4,   RMI$_BUFOBJPAGPEAK},\n    {4,   RMI$_BUFOBJPAGS01},\n    {4,   RMI$_BUFOBJPAGS2},\n    {4,   RMI$_BUFOBJPAGMAXS01},\n    {4,   RMI$_BUFOBJPAGMAXS2},\n    {4,   RMI$_BUFOBJPAGPEAKS01},\n    {4,   RMI$_BUFOBJPAGPEAKS2},\n    {4,   RMI$_BUFOBJPGLTMAXS01},\n    {4,   RMI$_BUFOBJPGLTMAXS2},\n    {4,   RMI$_DLCK_INCMPLT},\n    {4,   RMI$_DLCKMSGS_IN},\n    {4,   RMI$_DLCKMSGS_OUT},\n    {4,   RMI$_MCHKERRS},\n    {4,   RMI$_MEMERRS},\n};\n\nstatic const struct item_st RMI_item_data_64bit[] = {\n#if defined __ia64\n    {8,   RMI$_FRLIST},\n    {8,   RMI$_MODLIST},\n#endif\n    {8,   RMI$_LCKMGR_REQCNT},\n    {8,   RMI$_LCKMGR_REQTIME},\n    {8,   RMI$_LCKMGR_SPINCNT},\n    {8,   RMI$_LCKMGR_SPINTIME},\n    {8,   RMI$_CPUINTSTK},\n    {8,   RMI$_CPUMPSYNCH},\n    {8,   RMI$_CPUKERNEL},\n    {8,   RMI$_CPUEXEC},\n    {8,   RMI$_CPUSUPER},\n    {8,   RMI$_CPUUSER},\n#if defined __ia64\n    {8,   RMI$_USERPAGES},\n#endif\n    {8,   RMI$_TQETOTAL},\n    {8,   RMI$_TQESYSUB},\n    {8,   RMI$_TQEUSRTIMR},\n    {8,   RMI$_TQEUSRWAKE},\n};\n\nstatic const struct item_st SYI_item_data[] = {\n    {4,   SYI$_PAGEFILE_FREE},\n};\n\n/*\n * Input:\n * items_data           - an array of lengths and codes\n * items_data_num       - number of elements in that array\n *\n * Output:\n * items                - pre-allocated ILE3 array to be filled.\n *                        It's assumed to have items_data_num elements plus\n *                        one extra for the terminating NULL element\n * databuffer           - pre-allocated 32-bit word array.\n *\n * Returns the number of elements used in databuffer\n */\nstatic size_t prepare_item_list(const struct item_st *items_input,\n                                size_t items_input_num,\n                                ILE3 *items,\n                                uint32_t__ptr32 databuffer)\n{\n    size_t data_sz = 0;\n\n    for (; items_input_num-- > 0; items_input++, items++) {\n\n        items->ile3$w_code = items_input->code;\n        /* Special treatment of JPI$_FINALEXC */\n        if (items->ile3$w_code == JPI$_FINALEXC)\n            items->ile3$w_length = 4;\n        else\n            items->ile3$w_length = items_input->length;\n\n        items->ile3$ps_bufaddr = databuffer;\n        items->ile3$ps_retlen_addr = 0;\n\n        databuffer += items_input->length / sizeof(databuffer[0]);\n        data_sz += items_input->length;\n    }\n    /* Terminating NULL entry */\n    items->ile3$w_length = items->ile3$w_code = 0;\n    items->ile3$ps_bufaddr = items->ile3$ps_retlen_addr = NULL;\n\n    return data_sz / sizeof(databuffer[0]);\n}\n\nstatic void massage_JPI(ILE3 *items)\n{\n    /*\n     * Special treatment of JPI$_FINALEXC\n     * The result of that item's data buffer is a 32-bit address to a list of\n     * 4 32-bit words.\n     */\n    for (; items->ile3$w_length != 0; items++) {\n        if (items->ile3$w_code == JPI$_FINALEXC) {\n            uint32_t *data = items->ile3$ps_bufaddr;\n            uint32_t *ptr = (uint32_t *)*data;\n            size_t j;\n\n            /*\n             * We know we made space for 4 32-bit words, so we can do in-place\n             * replacement.\n             */\n            for (j = 0; j < 4; j++)\n                data[j] = ptr[j];\n\n            break;\n        }\n    }\n}\n\n/*\n * This number expresses how many bits of data contain 1 bit of entropy.\n *\n * For the moment, we assume about 0.05 entropy bits per data bit, or 1\n * bit of entropy per 20 data bits.\n */\n#define ENTROPY_FACTOR  20\n\nsize_t data_collect_method(RAND_POOL *pool)\n{\n    ILE3 JPI_items_64bit[OSSL_NELEM(JPI_item_data_64bit) + 1];\n    ILE3 RMI_items_64bit[OSSL_NELEM(RMI_item_data_64bit) + 1];\n    ILE3 DVI_items[OSSL_NELEM(DVI_item_data) + 1];\n    ILE3 JPI_items[OSSL_NELEM(JPI_item_data) + 1];\n    ILE3 RMI_items[OSSL_NELEM(RMI_item_data) + 1];\n    ILE3 SYI_items[OSSL_NELEM(SYI_item_data) + 1];\n    union {\n        /* This ensures buffer starts at 64 bit boundary */\n        uint64_t dummy;\n        uint32_t buffer[OSSL_NELEM(JPI_item_data_64bit) * 2\n                        + OSSL_NELEM(RMI_item_data_64bit) * 2\n                        + OSSL_NELEM(DVI_item_data)\n                        + OSSL_NELEM(JPI_item_data)\n                        + OSSL_NELEM(RMI_item_data)\n                        + OSSL_NELEM(SYI_item_data)\n                        + 4 /* For JPI$_FINALEXC */];\n    } data;\n    size_t total_elems = 0;\n    size_t total_length = 0;\n    size_t bytes_needed = rand_pool_bytes_needed(pool, ENTROPY_FACTOR);\n    size_t bytes_remaining = rand_pool_bytes_remaining(pool);\n\n    /* Take all the 64-bit items first, to ensure proper alignment of data */\n    total_elems +=\n        prepare_item_list(JPI_item_data_64bit, OSSL_NELEM(JPI_item_data_64bit),\n                          JPI_items_64bit, &data.buffer[total_elems]);\n    total_elems +=\n        prepare_item_list(RMI_item_data_64bit, OSSL_NELEM(RMI_item_data_64bit),\n                          RMI_items_64bit, &data.buffer[total_elems]);\n    /* Now the 32-bit items */\n    total_elems += prepare_item_list(DVI_item_data, OSSL_NELEM(DVI_item_data),\n                                     DVI_items, &data.buffer[total_elems]);\n    total_elems += prepare_item_list(JPI_item_data, OSSL_NELEM(JPI_item_data),\n                                     JPI_items, &data.buffer[total_elems]);\n    total_elems += prepare_item_list(RMI_item_data, OSSL_NELEM(RMI_item_data),\n                                     RMI_items, &data.buffer[total_elems]);\n    total_elems += prepare_item_list(SYI_item_data, OSSL_NELEM(SYI_item_data),\n                                     SYI_items, &data.buffer[total_elems]);\n    total_length = total_elems * sizeof(data.buffer[0]);\n\n    /* Fill data.buffer with various info bits from this process */\n    {\n        uint32_t status;\n        uint32_t efn;\n        IOSB iosb;\n        $DESCRIPTOR(SYSDEVICE,\"SYS$SYSDEVICE:\");\n\n        if ((status = sys$getdviw(EFN$C_ENF, 0, &SYSDEVICE, DVI_items,\n                                  0, 0, 0, 0, 0)) != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n        if ((status = sys$getjpiw(EFN$C_ENF, 0, 0, JPI_items_64bit, 0, 0, 0))\n            != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n        if ((status = sys$getjpiw(EFN$C_ENF, 0, 0, JPI_items, 0, 0, 0))\n            != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n        if ((status = sys$getsyiw(EFN$C_ENF, 0, 0, SYI_items, 0, 0, 0))\n            != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n        /*\n         * The RMI service is a bit special, as there is no synchronous\n         * variant, so we MUST create an event flag to synchronise on.\n         */\n        if ((status = lib$get_ef(&efn)) != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n        if ((status = sys$getrmi(efn, 0, 0, RMI_items_64bit, &iosb, 0, 0))\n            != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n        if ((status = sys$synch(efn, &iosb)) != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n        if (iosb.iosb$l_getxxi_status != SS$_NORMAL) {\n            lib$signal(iosb.iosb$l_getxxi_status);\n            return 0;\n        }\n        if ((status = sys$getrmi(efn, 0, 0, RMI_items, &iosb, 0, 0))\n            != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n        if ((status = sys$synch(efn, &iosb)) != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n        if (iosb.iosb$l_getxxi_status != SS$_NORMAL) {\n            lib$signal(iosb.iosb$l_getxxi_status);\n            return 0;\n        }\n        if ((status = lib$free_ef(&efn)) != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n    }\n\n    massage_JPI(JPI_items);\n\n    /*\n     * If we can't feed the requirements from the caller, we're in deep trouble.\n     */\n    if (!ossl_assert(total_length >= bytes_needed)) {\n        char buf[100];           /* That should be enough */\n\n        BIO_snprintf(buf, sizeof(buf), \"Needed: %zu, Available: %zu\",\n                     bytes_needed, total_length);\n        RANDerr(RAND_F_DATA_COLLECT_METHOD, RAND_R_RANDOM_POOL_UNDERFLOW);\n        ERR_add_error_data(1, buf);\n        return 0;\n    }\n\n    /*\n     * Try not to overfeed the pool\n     */\n    if (total_length > bytes_remaining)\n        total_length = bytes_remaining;\n\n    /* We give the pessimistic value for the amount of entropy */\n    rand_pool_add(pool, (unsigned char *)data.buffer, total_length,\n                  8 * total_length / ENTROPY_FACTOR);\n    return rand_pool_entropy_available(pool);\n}\n\nint rand_pool_add_nonce_data(RAND_POOL *pool)\n{\n    struct {\n        pid_t pid;\n        CRYPTO_THREAD_ID tid;\n        uint64_t time;\n    } data = { 0 };\n\n    /*\n     * Add process id, thread id, and a high resolution timestamp\n     * (where available, which is OpenVMS v8.4 and up) to ensure that\n     * the nonce is unique with high probability for different process\n     * instances.\n     */\n    data.pid = getpid();\n    data.tid = CRYPTO_THREAD_get_current_id();\n#if __CRTL_VER >= 80400000\n    sys$gettim_prec(&data.time);\n#else\n    sys$gettim((void*)&data.time);\n#endif\n\n    return rand_pool_add(pool, (unsigned char *)&data, sizeof(data), 0);\n}\n\n/*\n * SYS$GET_ENTROPY METHOD\n * ======================\n *\n * This is a high entropy method based on a new system service that is\n * based on getentropy() from FreeBSD 12.  It's only used if available,\n * and its availability is detected at run-time.\n *\n * We assume that this function provides full entropy random output.\n */\n#define PUBLIC_VECTORS \"SYS$LIBRARY:SYS$PUBLIC_VECTORS.EXE\"\n#define GET_ENTROPY \"SYS$GET_ENTROPY\"\n\nstatic int get_entropy_address_flag = 0;\nstatic int (*get_entropy_address)(void *buffer, size_t buffer_size) = NULL;\nstatic int init_get_entropy_address(void)\n{\n    if (get_entropy_address_flag == 0)\n        get_entropy_address = dlsym(dlopen(PUBLIC_VECTORS, 0), GET_ENTROPY);\n    get_entropy_address_flag = 1;\n    return get_entropy_address != NULL;\n}\n\nsize_t get_entropy_method(RAND_POOL *pool)\n{\n    /*\n     * The documentation says that SYS$GET_ENTROPY will give a maximum of\n     * 256 bytes of data.\n     */\n    unsigned char buffer[256];\n    size_t bytes_needed;\n    size_t bytes_to_get = 0;\n    uint32_t status;\n\n    for (bytes_needed = rand_pool_bytes_needed(pool, 1);\n         bytes_needed > 0;\n         bytes_needed -= bytes_to_get) {\n        bytes_to_get =\n            bytes_needed > sizeof(buffer) ? sizeof(buffer) : bytes_needed;\n\n        status = get_entropy_address(buffer, bytes_to_get);\n        if (status == SS$_RETRY) {\n            /* Set to zero so the loop doesn't diminish |bytes_needed| */\n            bytes_to_get = 0;\n            /* Should sleep some amount of time */\n            continue;\n        }\n\n        if (status != SS$_NORMAL) {\n            lib$signal(status);\n            return 0;\n        }\n\n        rand_pool_add(pool, buffer, bytes_to_get, 8 * bytes_to_get);\n    }\n\n    return rand_pool_entropy_available(pool);\n}\n\n/*\n * MAIN ENTROPY ACQUISITION FUNCTIONS\n * ==================================\n *\n * These functions are called by the RAND / DRBG functions\n */\n\nsize_t rand_pool_acquire_entropy(RAND_POOL *pool)\n{\n    if (init_get_entropy_address())\n        return get_entropy_method(pool);\n    return data_collect_method(pool);\n}\n\n\nint rand_pool_add_additional_data(RAND_POOL *pool)\n{\n    struct {\n        CRYPTO_THREAD_ID tid;\n        uint64_t time;\n    } data = { 0 };\n\n    /*\n     * Add some noise from the thread id and a high resolution timer.\n     * The thread id adds a little randomness if the drbg is accessed\n     * concurrently (which is the case for the <master> drbg).\n     */\n    data.tid = CRYPTO_THREAD_get_current_id();\n#if __CRTL_VER >= 80400000\n    sys$gettim_prec(&data.time);\n#else\n    sys$gettim((void*)&data.time);\n#endif\n\n    return rand_pool_add(pool, (unsigned char *)&data, sizeof(data), 0);\n}\n\nint rand_pool_init(void)\n{\n    return 1;\n}\n\nvoid rand_pool_cleanup(void)\n{\n}\n\nvoid rand_pool_keep_random_devices_open(int keep)\n{\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/crypto/dso/dso_dlfcn.c": "/*\n * Copyright 2000-2019 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n/*\n * We need to do this early, because stdio.h includes the header files that\n * handle _GNU_SOURCE and other similar macros.  Defining it later is simply\n * too late, because those headers are protected from re- inclusion.\n */\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE            /* make sure dladdr is declared */\n#endif\n\n#include \"dso_local.h\"\n#include \"e_os.h\"\n\n#ifdef DSO_DLFCN\n\n# ifdef HAVE_DLFCN_H\n#  ifdef __osf__\n#   define __EXTENSIONS__\n#  endif\n#  include <dlfcn.h>\n#  define HAVE_DLINFO 1\n#  if defined(__SCO_VERSION__) || defined(_SCO_ELF) || \\\n     (defined(__osf__) && !defined(RTLD_NEXT))     || \\\n     (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \\\n        defined(__ANDROID__)\n#   undef HAVE_DLINFO\n#  endif\n# endif\n\n/* Part of the hack in \"dlfcn_load\" ... */\n# define DSO_MAX_TRANSLATED_SIZE 256\n\nstatic int dlfcn_load(DSO *dso);\nstatic int dlfcn_unload(DSO *dso);\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname);\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename);\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2);\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz);\nstatic void *dlfcn_globallookup(const char *name);\n\nstatic DSO_METHOD dso_meth_dlfcn = {\n    \"OpenSSL 'dlfcn' shared library method\",\n    dlfcn_load,\n    dlfcn_unload,\n    dlfcn_bind_func,\n    NULL,                       /* ctrl */\n    dlfcn_name_converter,\n    dlfcn_merger,\n    NULL,                       /* init */\n    NULL,                       /* finish */\n    dlfcn_pathbyaddr,\n    dlfcn_globallookup\n};\n\nDSO_METHOD *DSO_METHOD_openssl(void)\n{\n    return &dso_meth_dlfcn;\n}\n\n/*\n * Prior to using the dlopen() function, we should decide on the flag we\n * send. There's a few different ways of doing this and it's a messy\n * venn-diagram to match up which platforms support what. So as we don't have\n * autoconf yet, I'm implementing a hack that could be hacked further\n * relatively easily to deal with cases as we find them. Initially this is to\n * cope with OpenBSD.\n */\n# if defined(__OpenBSD__) || defined(__NetBSD__)\n#  ifdef DL_LAZY\n#   define DLOPEN_FLAG DL_LAZY\n#  else\n#   ifdef RTLD_NOW\n#    define DLOPEN_FLAG RTLD_NOW\n#   else\n#    define DLOPEN_FLAG 0\n#   endif\n#  endif\n# else\n#  define DLOPEN_FLAG RTLD_NOW  /* Hope this works everywhere else */\n# endif\n\n/*\n * For this DSO_METHOD, our meth_data STACK will contain; (i) the handle\n * (void*) returned from dlopen().\n */\n\nstatic int dlfcn_load(DSO *dso)\n{\n    void *ptr = NULL;\n    /* See applicable comments in dso_dl.c */\n    char *filename = DSO_convert_filename(dso, NULL);\n    int flags = DLOPEN_FLAG;\n    int saveerrno = get_last_sys_error();\n\n    if (filename == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);\n        goto err;\n    }\n# ifdef RTLD_GLOBAL\n    if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)\n        flags |= RTLD_GLOBAL;\n# endif\n# ifdef _AIX\n    if (filename[strlen(filename) - 1] == ')')\n        flags |= RTLD_MEMBER;\n# endif\n    ptr = dlopen(filename, flags);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);\n        ERR_add_error_data(4, \"filename(\", filename, \"): \", dlerror());\n        goto err;\n    }\n    /*\n     * Some dlopen() implementations (e.g. solaris) do no preserve errno, even\n     * on a successful call.\n     */\n    set_sys_error(saveerrno);\n    if (!sk_void_push(dso->meth_data, (char *)ptr)) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);\n        goto err;\n    }\n    /* Success */\n    dso->loaded_filename = filename;\n    return 1;\n err:\n    /* Cleanup! */\n    OPENSSL_free(filename);\n    if (ptr != NULL)\n        dlclose(ptr);\n    return 0;\n}\n\nstatic int dlfcn_unload(DSO *dso)\n{\n    void *ptr;\n    if (dso == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    if (sk_void_num(dso->meth_data) < 1)\n        return 1;\n    ptr = sk_void_pop(dso->meth_data);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);\n        /*\n         * Should push the value back onto the stack in case of a retry.\n         */\n        sk_void_push(dso->meth_data, ptr);\n        return 0;\n    }\n    /* For now I'm not aware of any errors associated with dlclose() */\n    dlclose(ptr);\n    return 1;\n}\n\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)\n{\n    void *ptr;\n    union {\n        DSO_FUNC_TYPE sym;\n        void *dlret;\n    } u;\n\n    if ((dso == NULL) || (symname == NULL)) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if (sk_void_num(dso->meth_data) < 1) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_STACK_ERROR);\n        return NULL;\n    }\n    ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_NULL_HANDLE);\n        return NULL;\n    }\n    u.dlret = dlsym(ptr, symname);\n    if (u.dlret == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_SYM_FAILURE);\n        ERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\n        return NULL;\n    }\n    return u.sym;\n}\n\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2)\n{\n    char *merged;\n\n    if (!filespec1 && !filespec2) {\n        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    /*\n     * If the first file specification is a rooted path, it rules. same goes\n     * if the second file specification is missing.\n     */\n    if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\n        merged = OPENSSL_strdup(filespec1);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n    }\n    /*\n     * If the first file specification is missing, the second one rules.\n     */\n    else if (!filespec1) {\n        merged = OPENSSL_strdup(filespec2);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n    } else {\n        /*\n         * This part isn't as trivial as it looks.  It assumes that the\n         * second file specification really is a directory, and makes no\n         * checks whatsoever.  Therefore, the result becomes the\n         * concatenation of filespec2 followed by a slash followed by\n         * filespec1.\n         */\n        int spec2len, len;\n\n        spec2len = strlen(filespec2);\n        len = spec2len + strlen(filespec1);\n\n        if (spec2len && filespec2[spec2len - 1] == '/') {\n            spec2len--;\n            len--;\n        }\n        merged = OPENSSL_malloc(len + 2);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n        strcpy(merged, filespec2);\n        merged[spec2len] = '/';\n        strcpy(&merged[spec2len + 1], filespec1);\n    }\n    return merged;\n}\n\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename)\n{\n    char *translated;\n    int len, rsize, transform;\n\n    len = strlen(filename);\n    rsize = len + 1;\n    transform = (strstr(filename, \"/\") == NULL);\n    if (transform) {\n        /* We will convert this to \"%s.so\" or \"lib%s.so\" etc */\n        rsize += strlen(DSO_EXTENSION);    /* The length of \".so\" */\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            rsize += 3;         /* The length of \"lib\" */\n    }\n    translated = OPENSSL_malloc(rsize);\n    if (translated == NULL) {\n        DSOerr(DSO_F_DLFCN_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);\n        return NULL;\n    }\n    if (transform) {\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            sprintf(translated, \"lib%s\" DSO_EXTENSION, filename);\n        else\n            sprintf(translated, \"%s\" DSO_EXTENSION, filename);\n    } else\n        sprintf(translated, \"%s\", filename);\n    return translated;\n}\n\n# ifdef __sgi\n/*-\nThis is a quote from IRIX manual for dladdr(3c):\n\n     <dlfcn.h> does not contain a prototype for dladdr or definition of\n     Dl_info.  The #include <dlfcn.h>  in the SYNOPSIS line is traditional,\n     but contains no dladdr prototype and no IRIX library contains an\n     implementation.  Write your own declaration based on the code below.\n\n     The following code is dependent on internal interfaces that are not\n     part of the IRIX compatibility guarantee; however, there is no future\n     intention to change this interface, so on a practical level, the code\n     below is safe to use on IRIX.\n*/\n#  include <rld_interface.h>\n#  ifndef _RLD_INTERFACE_DLFCN_H_DLADDR\n#   define _RLD_INTERFACE_DLFCN_H_DLADDR\ntypedef struct Dl_info {\n    const char *dli_fname;\n    void *dli_fbase;\n    const char *dli_sname;\n    void *dli_saddr;\n    int dli_version;\n    int dli_reserved1;\n    long dli_reserved[4];\n} Dl_info;\n#  else\ntypedef struct Dl_info Dl_info;\n#  endif\n#  define _RLD_DLADDR             14\n\nstatic int dladdr(void *address, Dl_info *dl)\n{\n    void *v;\n    v = _rld_new_interface(_RLD_DLADDR, address, dl);\n    return (int)v;\n}\n# endif                         /* __sgi */\n\n# ifdef _AIX\n/*-\n * See IBM's AIX Version 7.2, Technical Reference:\n *  Base Operating System and Extensions, Volume 1 and 2\n *  https://www.ibm.com/support/knowledgecenter/ssw_aix_72/com.ibm.aix.base/technicalreferences.htm\n */\n#  include <sys/ldr.h>\n#  include <errno.h>\n/* ~ 64 * (sizeof(struct ld_info) + _XOPEN_PATH_MAX + _XOPEN_NAME_MAX) */\n#  define DLFCN_LDINFO_SIZE 86976\ntypedef struct Dl_info {\n    const char *dli_fname;\n} Dl_info;\n/*\n * This dladdr()-implementation will also find the ptrgl (Pointer Glue) virtual\n * address of a function, which is just located in the DATA segment instead of\n * the TEXT segment.\n */\nstatic int dladdr(void *ptr, Dl_info *dl)\n{\n    uintptr_t addr = (uintptr_t)ptr;\n    unsigned int found = 0;\n    struct ld_info *ldinfos, *next_ldi, *this_ldi;\n\n    if ((ldinfos = OPENSSL_malloc(DLFCN_LDINFO_SIZE)) == NULL) {\n        errno = ENOMEM;\n        dl->dli_fname = NULL;\n        return 0;\n    }\n\n    if ((loadquery(L_GETINFO, (void *)ldinfos, DLFCN_LDINFO_SIZE)) < 0) {\n        /*-\n         * Error handling is done through errno and dlerror() reading errno:\n         *  ENOMEM (ldinfos buffer is too small),\n         *  EINVAL (invalid flags),\n         *  EFAULT (invalid ldinfos ptr)\n         */\n        OPENSSL_free((void *)ldinfos);\n        dl->dli_fname = NULL;\n        return 0;\n    }\n    next_ldi = ldinfos;\n\n    do {\n        this_ldi = next_ldi;\n        if (((addr >= (uintptr_t)this_ldi->ldinfo_textorg)\n             && (addr < ((uintptr_t)this_ldi->ldinfo_textorg +\n                         this_ldi->ldinfo_textsize)))\n            || ((addr >= (uintptr_t)this_ldi->ldinfo_dataorg)\n                && (addr < ((uintptr_t)this_ldi->ldinfo_dataorg +\n                            this_ldi->ldinfo_datasize)))) {\n            char *buffer, *member;\n            size_t buffer_sz, member_len;\n\n            buffer_sz = strlen(this_ldi->ldinfo_filename) + 1;\n            member = this_ldi->ldinfo_filename + buffer_sz;\n            if ((member_len = strlen(member)) > 0)\n                buffer_sz += 1 + member_len + 1;\n            found = 1;\n            if ((buffer = OPENSSL_malloc(buffer_sz)) != NULL) {\n                OPENSSL_strlcpy(buffer, this_ldi->ldinfo_filename, buffer_sz);\n                if (member_len > 0) {\n                    /*\n                     * Need to respect a possible member name and not just\n                     * returning the path name in this case. See docs:\n                     * sys/ldr.h, loadquery() and dlopen()/RTLD_MEMBER.\n                     */\n                    OPENSSL_strlcat(buffer, \"(\", buffer_sz);\n                    OPENSSL_strlcat(buffer, member, buffer_sz);\n                    OPENSSL_strlcat(buffer, \")\", buffer_sz);\n                }\n                dl->dli_fname = buffer;\n            } else {\n                errno = ENOMEM;\n            }\n        } else {\n            next_ldi = (struct ld_info *)((uintptr_t)this_ldi +\n                                          this_ldi->ldinfo_next);\n        }\n    } while (this_ldi->ldinfo_next && !found);\n    OPENSSL_free((void *)ldinfos);\n    return (found && dl->dli_fname != NULL);\n}\n# endif                         /* _AIX */\n\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz)\n{\n# ifdef HAVE_DLINFO\n    Dl_info dli;\n    int len;\n\n    if (addr == NULL) {\n        union {\n            int (*f) (void *, char *, int);\n            void *p;\n        } t = {\n            dlfcn_pathbyaddr\n        };\n        addr = t.p;\n    }\n\n    if (dladdr(addr, &dli)) {\n        len = (int)strlen(dli.dli_fname);\n        if (sz <= 0) {\n#  ifdef _AIX\n            OPENSSL_free((void *)dli.dli_fname);\n#  endif\n            return len + 1;\n        }\n        if (len >= sz)\n            len = sz - 1;\n        memcpy(path, dli.dli_fname, len);\n        path[len++] = 0;\n#  ifdef _AIX\n        OPENSSL_free((void *)dli.dli_fname);\n#  endif\n        return len;\n    }\n\n    ERR_add_error_data(2, \"dlfcn_pathbyaddr(): \", dlerror());\n# endif\n    return -1;\n}\n\nstatic void *dlfcn_globallookup(const char *name)\n{\n    void *ret = NULL, *handle = dlopen(NULL, RTLD_LAZY);\n\n    if (handle) {\n        ret = dlsym(handle, name);\n        dlclose(handle);\n    }\n\n    return ret;\n}\n#endif                          /* DSO_DLFCN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/shlibloadtest.c": "/*\n * Copyright 2016-2019 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <openssl/opensslv.h>\n#include <openssl/ssl.h>\n#include <openssl/ossl_typ.h>\n#include \"crypto/dso_conf.h\"\n\ntypedef void DSO;\n\ntypedef const SSL_METHOD * (*TLS_method_t)(void);\ntypedef SSL_CTX * (*SSL_CTX_new_t)(const SSL_METHOD *meth);\ntypedef void (*SSL_CTX_free_t)(SSL_CTX *);\ntypedef int (*OPENSSL_init_crypto_t)(uint64_t, void *);\ntypedef int (*OPENSSL_atexit_t)(void (*handler)(void));\ntypedef unsigned long (*ERR_get_error_t)(void);\ntypedef unsigned long (*OpenSSL_version_num_t)(void);\ntypedef DSO * (*DSO_dsobyaddr_t)(void (*addr)(void), int flags);\ntypedef int (*DSO_free_t)(DSO *dso);\n\ntypedef enum test_types_en {\n    CRYPTO_FIRST,\n    SSL_FIRST,\n    JUST_CRYPTO,\n    DSO_REFTEST,\n    NO_ATEXIT\n} TEST_TYPE;\n\nstatic TEST_TYPE test_type;\nstatic const char *path_crypto;\nstatic const char *path_ssl;\nstatic const char *path_atexit;\n\n#ifdef DSO_DLFCN\n\n# include <dlfcn.h>\n\n# define SHLIB_INIT NULL\n\ntypedef void *SHLIB;\ntypedef void *SHLIB_SYM;\n\nstatic int shlib_load(const char *filename, SHLIB *lib)\n{\n    int dl_flags = (RTLD_GLOBAL|RTLD_LAZY);\n#ifdef _AIX\n    if (filename[strlen(filename) - 1] == ')')\n        dl_flags |= RTLD_MEMBER;\n#endif\n    *lib = dlopen(filename, dl_flags);\n    return *lib == NULL ? 0 : 1;\n}\n\nstatic int shlib_sym(SHLIB lib, const char *symname, SHLIB_SYM *sym)\n{\n    *sym = dlsym(lib, symname);\n    return *sym != NULL;\n}\n\nstatic int shlib_close(SHLIB lib)\n{\n    return dlclose(lib) != 0 ? 0 : 1;\n}\n#endif\n\n#ifdef DSO_WIN32\n\n# include <windows.h>\n\n# define SHLIB_INIT 0\n\ntypedef HINSTANCE SHLIB;\ntypedef void *SHLIB_SYM;\n\nstatic int shlib_load(const char *filename, SHLIB *lib)\n{\n    *lib = LoadLibraryA(filename);\n    return *lib == NULL ? 0 : 1;\n}\n\nstatic int shlib_sym(SHLIB lib, const char *symname, SHLIB_SYM *sym)\n{\n    *sym = (SHLIB_SYM)GetProcAddress(lib, symname);\n    return *sym != NULL;\n}\n\nstatic int shlib_close(SHLIB lib)\n{\n    return FreeLibrary(lib) == 0 ? 0 : 1;\n}\n#endif\n\n\n#if defined(DSO_DLFCN) || defined(DSO_WIN32)\n\nstatic int atexit_handler_done = 0;\n\nstatic void atexit_handler(void)\n{\n    FILE *atexit_file = fopen(path_atexit, \"w\");\n\n    if (atexit_file == NULL)\n        return;\n\n    fprintf(atexit_file, \"atexit() run\\n\");\n    fclose(atexit_file);\n    atexit_handler_done++;\n}\n\nstatic int test_lib(void)\n{\n    SHLIB ssllib = SHLIB_INIT;\n    SHLIB cryptolib = SHLIB_INIT;\n    SSL_CTX *ctx;\n    union {\n        void (*func)(void);\n        SHLIB_SYM sym;\n    } symbols[3];\n    TLS_method_t myTLS_method;\n    SSL_CTX_new_t mySSL_CTX_new;\n    SSL_CTX_free_t mySSL_CTX_free;\n    ERR_get_error_t myERR_get_error;\n    OpenSSL_version_num_t myOpenSSL_version_num;\n    OPENSSL_atexit_t myOPENSSL_atexit;\n    int result = 0;\n\n    switch (test_type) {\n    case JUST_CRYPTO:\n    case DSO_REFTEST:\n    case NO_ATEXIT:\n    case CRYPTO_FIRST:\n        if (!shlib_load(path_crypto, &cryptolib)) {\n            fprintf(stderr, \"Failed to load libcrypto\\n\");\n            goto end;\n        }\n        if (test_type != CRYPTO_FIRST)\n            break;\n        /* Fall through */\n\n    case SSL_FIRST:\n        if (!shlib_load(path_ssl, &ssllib)) {\n            fprintf(stderr, \"Failed to load libssl\\n\");\n            goto end;\n        }\n        if (test_type != SSL_FIRST)\n            break;\n        if (!shlib_load(path_crypto, &cryptolib)) {\n            fprintf(stderr, \"Failed to load libcrypto\\n\");\n            goto end;\n        }\n        break;\n    }\n\n    if (test_type == NO_ATEXIT) {\n        OPENSSL_init_crypto_t myOPENSSL_init_crypto;\n\n        if (!shlib_sym(cryptolib, \"OPENSSL_init_crypto\", &symbols[0].sym)) {\n            fprintf(stderr, \"Failed to load OPENSSL_init_crypto symbol\\n\");\n            goto end;\n        }\n        myOPENSSL_init_crypto = (OPENSSL_init_crypto_t)symbols[0].func;\n        if (!myOPENSSL_init_crypto(OPENSSL_INIT_NO_ATEXIT, NULL)) {\n            fprintf(stderr, \"Failed to initialise libcrypto\\n\");\n            goto end;\n        }\n    }\n\n    if (test_type != JUST_CRYPTO\n            && test_type != DSO_REFTEST\n            && test_type != NO_ATEXIT) {\n        if (!shlib_sym(ssllib, \"TLS_method\", &symbols[0].sym)\n                || !shlib_sym(ssllib, \"SSL_CTX_new\", &symbols[1].sym)\n                || !shlib_sym(ssllib, \"SSL_CTX_free\", &symbols[2].sym)) {\n            fprintf(stderr, \"Failed to load libssl symbols\\n\");\n            goto end;\n        }\n        myTLS_method = (TLS_method_t)symbols[0].func;\n        mySSL_CTX_new = (SSL_CTX_new_t)symbols[1].func;\n        mySSL_CTX_free = (SSL_CTX_free_t)symbols[2].func;\n        ctx = mySSL_CTX_new(myTLS_method());\n        if (ctx == NULL) {\n            fprintf(stderr, \"Failed to create SSL_CTX\\n\");\n            goto end;\n        }\n        mySSL_CTX_free(ctx);\n    }\n\n    if (!shlib_sym(cryptolib, \"ERR_get_error\", &symbols[0].sym)\n           || !shlib_sym(cryptolib, \"OpenSSL_version_num\", &symbols[1].sym)\n           || !shlib_sym(cryptolib, \"OPENSSL_atexit\", &symbols[2].sym)) {\n        fprintf(stderr, \"Failed to load libcrypto symbols\\n\");\n        goto end;\n    }\n    myERR_get_error = (ERR_get_error_t)symbols[0].func;\n    if (myERR_get_error() != 0) {\n        fprintf(stderr, \"Unexpected ERR_get_error() response\\n\");\n        goto end;\n    }\n\n    myOpenSSL_version_num = (OpenSSL_version_num_t)symbols[1].func;\n    if (myOpenSSL_version_num()  != OPENSSL_VERSION_NUMBER) {\n        fprintf(stderr, \"Invalid library version number\\n\");\n        goto end;\n    }\n\n    myOPENSSL_atexit = (OPENSSL_atexit_t)symbols[2].func;\n    if (!myOPENSSL_atexit(atexit_handler)) {\n        fprintf(stderr, \"Failed to register atexit handler\\n\");\n        goto end;\n    }\n\n    if (test_type == DSO_REFTEST) {\n# ifdef DSO_DLFCN\n        DSO_dsobyaddr_t myDSO_dsobyaddr;\n        DSO_free_t myDSO_free;\n\n        /*\n         * This is resembling the code used in ossl_init_base() and\n         * OPENSSL_atexit() to block unloading the library after dlclose().\n         * We are not testing this on Windows, because it is done there in a\n         * completely different way. Especially as a call to DSO_dsobyaddr()\n         * will always return an error, because DSO_pathbyaddr() is not\n         * implemented there.\n         */\n        if (!shlib_sym(cryptolib, \"DSO_dsobyaddr\", &symbols[0].sym)\n                || !shlib_sym(cryptolib, \"DSO_free\", &symbols[1].sym)) {\n            fprintf(stderr, \"Unable to load DSO symbols\\n\");\n            goto end;\n        }\n\n        myDSO_dsobyaddr = (DSO_dsobyaddr_t)symbols[0].func;\n        myDSO_free = (DSO_free_t)symbols[1].func;\n\n        {\n            DSO *hndl;\n            /* use known symbol from crypto module */\n            hndl = myDSO_dsobyaddr((void (*)(void))myERR_get_error, 0);\n            if (hndl == NULL) {\n                fprintf(stderr, \"DSO_dsobyaddr() failed\\n\");\n                goto end;\n            }\n            myDSO_free(hndl);\n        }\n# endif /* DSO_DLFCN */\n    }\n\n    if (!shlib_close(cryptolib)) {\n        fprintf(stderr, \"Failed to close libcrypto\\n\");\n        goto end;\n    }\n\n    if (test_type == CRYPTO_FIRST || test_type == SSL_FIRST) {\n        if (!shlib_close(ssllib)) {\n            fprintf(stderr, \"Failed to close libssl\\n\");\n            goto end;\n        }\n    }\n\n# if defined(OPENSSL_NO_PINSHARED) \\\n    && defined(__GLIBC__) \\\n    && defined(__GLIBC_PREREQ) \\\n    && defined(OPENSSL_SYS_LINUX)\n#  if __GLIBC_PREREQ(2, 3)\n    /*\n     * If we didn't pin the so then we are hopefully on a platform that supports\n     * running atexit() on so unload. If not we might crash. We know this is\n     * true on linux since glibc 2.2.3\n     */\n    if (test_type != NO_ATEXIT && atexit_handler_done != 1) {\n        fprintf(stderr, \"atexit() handler did not run\\n\");\n        goto end;\n    }\n#  endif\n# endif\n\n    result = 1;\nend:\n    return result;\n}\n#endif\n\n\n/*\n * shlibloadtest should not use the normal test framework because we don't want\n * it to link against libcrypto (which the framework uses). The point of the\n * test is to check dynamic loading and unloading of libcrypto/libssl.\n */\nint main(int argc, char *argv[])\n{\n    const char *p;\n\n    if (argc != 5) {\n        fprintf(stderr, \"Incorrect number of arguments\\n\");\n        return 1;\n    }\n\n    p = argv[1];\n\n    if (strcmp(p, \"-crypto_first\") == 0) {\n        test_type = CRYPTO_FIRST;\n    } else if (strcmp(p, \"-ssl_first\") == 0) {\n        test_type = SSL_FIRST;\n    } else if (strcmp(p, \"-just_crypto\") == 0) {\n        test_type = JUST_CRYPTO;\n    } else if (strcmp(p, \"-dso_ref\") == 0) {\n        test_type = DSO_REFTEST;\n    } else if (strcmp(p, \"-no_atexit\") == 0) {\n        test_type = NO_ATEXIT;\n    } else {\n        fprintf(stderr, \"Unrecognised argument\\n\");\n        return 1;\n    }\n    path_crypto = argv[2];\n    path_ssl = argv[3];\n    path_atexit = argv[4];\n    if (path_crypto == NULL || path_ssl == NULL) {\n        fprintf(stderr, \"Invalid libcrypto/libssl path\\n\");\n        return 1;\n    }\n\n#if defined(DSO_DLFCN) || defined(DSO_WIN32)\n    if (!test_lib())\n        return 1;\n#endif\n    return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/shibboleth.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/d2i-tests/bad-cms.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/d2i-tests/high_tag.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/d2i-tests/intminus1.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/d2i-tests/bad_bio.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/d2i-tests/bad_cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/d2i-tests/bad_generalname.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/d2i-tests/bad-int-padminus1.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/recipes/ocsp-response.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/recipes/80-test_cms_data/ct_multiple_attr.cms",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/recipes/80-test_cms_data/no_md_attr.cms",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/recipes/80-test_cms_data/bad_signtime_attr.cms",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.1e-bsgwuvdn776rk7z7wgt2mw2kul6ca337/spack-src/test/recipes/80-test_cms_data/no_ct_attr.cms"
    ],
    "total_files": 3016
}