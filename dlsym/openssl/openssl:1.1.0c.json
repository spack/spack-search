{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0c-6jcu5o2gruelgqyvzklzi6bnlugqfqez/spack-src/crypto/dso/dso_dlfcn.c": "/*\n * Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n/*\n * We need to do this early, because stdio.h includes the header files that\n * handle _GNU_SOURCE and other similar macros.  Defining it later is simply\n * too late, because those headers are protected from re- inclusion.\n */\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE            /* make sure dladdr is declared */\n#endif\n\n#include \"dso_locl.h\"\n\n#ifdef DSO_DLFCN\n\n# ifdef HAVE_DLFCN_H\n#  ifdef __osf__\n#   define __EXTENSIONS__\n#  endif\n#  include <dlfcn.h>\n#  define HAVE_DLINFO 1\n#  if defined(_AIX) || defined(__CYGWIN__) || \\\n     defined(__SCO_VERSION__) || defined(_SCO_ELF) || \\\n     (defined(__osf__) && !defined(RTLD_NEXT))     || \\\n     (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \\\n        defined(__ANDROID__)\n#   undef HAVE_DLINFO\n#  endif\n# endif\n\n/* Part of the hack in \"dlfcn_load\" ... */\n# define DSO_MAX_TRANSLATED_SIZE 256\n\nstatic int dlfcn_load(DSO *dso);\nstatic int dlfcn_unload(DSO *dso);\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname);\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename);\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2);\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz);\nstatic void *dlfcn_globallookup(const char *name);\n\nstatic DSO_METHOD dso_meth_dlfcn = {\n    \"OpenSSL 'dlfcn' shared library method\",\n    dlfcn_load,\n    dlfcn_unload,\n    dlfcn_bind_func,\n    NULL,                       /* ctrl */\n    dlfcn_name_converter,\n    dlfcn_merger,\n    NULL,                       /* init */\n    NULL,                       /* finish */\n    dlfcn_pathbyaddr,\n    dlfcn_globallookup\n};\n\nDSO_METHOD *DSO_METHOD_openssl(void)\n{\n    return &dso_meth_dlfcn;\n}\n\n/*\n * Prior to using the dlopen() function, we should decide on the flag we\n * send. There's a few different ways of doing this and it's a messy\n * venn-diagram to match up which platforms support what. So as we don't have\n * autoconf yet, I'm implementing a hack that could be hacked further\n * relatively easily to deal with cases as we find them. Initially this is to\n * cope with OpenBSD.\n */\n# if defined(__OpenBSD__) || defined(__NetBSD__)\n#  ifdef DL_LAZY\n#   define DLOPEN_FLAG DL_LAZY\n#  else\n#   ifdef RTLD_NOW\n#    define DLOPEN_FLAG RTLD_NOW\n#   else\n#    define DLOPEN_FLAG 0\n#   endif\n#  endif\n# else\n#  define DLOPEN_FLAG RTLD_NOW  /* Hope this works everywhere else */\n# endif\n\n/*\n * For this DSO_METHOD, our meth_data STACK will contain; (i) the handle\n * (void*) returned from dlopen().\n */\n\nstatic int dlfcn_load(DSO *dso)\n{\n    void *ptr = NULL;\n    /* See applicable comments in dso_dl.c */\n    char *filename = DSO_convert_filename(dso, NULL);\n    int flags = DLOPEN_FLAG;\n\n    if (filename == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);\n        goto err;\n    }\n# ifdef RTLD_GLOBAL\n    if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)\n        flags |= RTLD_GLOBAL;\n# endif\n    ptr = dlopen(filename, flags);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);\n        ERR_add_error_data(4, \"filename(\", filename, \"): \", dlerror());\n        goto err;\n    }\n    if (!sk_void_push(dso->meth_data, (char *)ptr)) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);\n        goto err;\n    }\n    /* Success */\n    dso->loaded_filename = filename;\n    return (1);\n err:\n    /* Cleanup! */\n    OPENSSL_free(filename);\n    if (ptr != NULL)\n        dlclose(ptr);\n    return (0);\n}\n\nstatic int dlfcn_unload(DSO *dso)\n{\n    void *ptr;\n    if (dso == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);\n        return (0);\n    }\n    if (sk_void_num(dso->meth_data) < 1)\n        return (1);\n    ptr = sk_void_pop(dso->meth_data);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);\n        /*\n         * Should push the value back onto the stack in case of a retry.\n         */\n        sk_void_push(dso->meth_data, ptr);\n        return (0);\n    }\n    /* For now I'm not aware of any errors associated with dlclose() */\n    dlclose(ptr);\n    return (1);\n}\n\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)\n{\n    void *ptr;\n    union {\n        DSO_FUNC_TYPE sym;\n        void *dlret;\n    } u;\n\n    if ((dso == NULL) || (symname == NULL)) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\n        return (NULL);\n    }\n    if (sk_void_num(dso->meth_data) < 1) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_STACK_ERROR);\n        return (NULL);\n    }\n    ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_NULL_HANDLE);\n        return (NULL);\n    }\n    u.dlret = dlsym(ptr, symname);\n    if (u.dlret == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_SYM_FAILURE);\n        ERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\n        return (NULL);\n    }\n    return u.sym;\n}\n\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2)\n{\n    char *merged;\n\n    if (!filespec1 && !filespec2) {\n        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\n        return (NULL);\n    }\n    /*\n     * If the first file specification is a rooted path, it rules. same goes\n     * if the second file specification is missing.\n     */\n    if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\n        merged = OPENSSL_strdup(filespec1);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n    }\n    /*\n     * If the first file specification is missing, the second one rules.\n     */\n    else if (!filespec1) {\n        merged = OPENSSL_strdup(filespec2);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n    } else {\n        /*\n         * This part isn't as trivial as it looks.  It assumes that the\n         * second file specification really is a directory, and makes no\n         * checks whatsoever.  Therefore, the result becomes the\n         * concatenation of filespec2 followed by a slash followed by\n         * filespec1.\n         */\n        int spec2len, len;\n\n        spec2len = strlen(filespec2);\n        len = spec2len + strlen(filespec1);\n\n        if (spec2len && filespec2[spec2len - 1] == '/') {\n            spec2len--;\n            len--;\n        }\n        merged = OPENSSL_malloc(len + 2);\n        if (merged == NULL) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n        strcpy(merged, filespec2);\n        merged[spec2len] = '/';\n        strcpy(&merged[spec2len + 1], filespec1);\n    }\n    return (merged);\n}\n\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename)\n{\n    char *translated;\n    int len, rsize, transform;\n\n    len = strlen(filename);\n    rsize = len + 1;\n    transform = (strstr(filename, \"/\") == NULL);\n    if (transform) {\n        /* We will convert this to \"%s.so\" or \"lib%s.so\" etc */\n        rsize += strlen(DSO_EXTENSION);    /* The length of \".so\" */\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            rsize += 3;         /* The length of \"lib\" */\n    }\n    translated = OPENSSL_malloc(rsize);\n    if (translated == NULL) {\n        DSOerr(DSO_F_DLFCN_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);\n        return (NULL);\n    }\n    if (transform) {\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            sprintf(translated, \"lib%s\" DSO_EXTENSION, filename);\n        else\n            sprintf(translated, \"%s\" DSO_EXTENSION, filename);\n    } else\n        sprintf(translated, \"%s\", filename);\n    return (translated);\n}\n\n# ifdef __sgi\n/*-\nThis is a quote from IRIX manual for dladdr(3c):\n\n     <dlfcn.h> does not contain a prototype for dladdr or definition of\n     Dl_info.  The #include <dlfcn.h>  in the SYNOPSIS line is traditional,\n     but contains no dladdr prototype and no IRIX library contains an\n     implementation.  Write your own declaration based on the code below.\n\n     The following code is dependent on internal interfaces that are not\n     part of the IRIX compatibility guarantee; however, there is no future\n     intention to change this interface, so on a practical level, the code\n     below is safe to use on IRIX.\n*/\n#  include <rld_interface.h>\n#  ifndef _RLD_INTERFACE_DLFCN_H_DLADDR\n#   define _RLD_INTERFACE_DLFCN_H_DLADDR\ntypedef struct Dl_info {\n    const char *dli_fname;\n    void *dli_fbase;\n    const char *dli_sname;\n    void *dli_saddr;\n    int dli_version;\n    int dli_reserved1;\n    long dli_reserved[4];\n} Dl_info;\n#  else\ntypedef struct Dl_info Dl_info;\n#  endif\n#  define _RLD_DLADDR             14\n\nstatic int dladdr(void *address, Dl_info *dl)\n{\n    void *v;\n    v = _rld_new_interface(_RLD_DLADDR, address, dl);\n    return (int)v;\n}\n# endif                         /* __sgi */\n\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz)\n{\n# ifdef HAVE_DLINFO\n    Dl_info dli;\n    int len;\n\n    if (addr == NULL) {\n        union {\n            int (*f) (void *, char *, int);\n            void *p;\n        } t = {\n            dlfcn_pathbyaddr\n        };\n        addr = t.p;\n    }\n\n    if (dladdr(addr, &dli)) {\n        len = (int)strlen(dli.dli_fname);\n        if (sz <= 0)\n            return len + 1;\n        if (len >= sz)\n            len = sz - 1;\n        memcpy(path, dli.dli_fname, len);\n        path[len++] = 0;\n        return len;\n    }\n\n    ERR_add_error_data(2, \"dlfcn_pathbyaddr(): \", dlerror());\n# endif\n    return -1;\n}\n\nstatic void *dlfcn_globallookup(const char *name)\n{\n    void *ret = NULL, *handle = dlopen(NULL, RTLD_LAZY);\n\n    if (handle) {\n        ret = dlsym(handle, name);\n        dlclose(handle);\n    }\n\n    return ret;\n}\n#endif                          /* DSO_DLFCN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0c-6jcu5o2gruelgqyvzklzi6bnlugqfqez/spack-src/test/shlibloadtest.c": "/*\n * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.\n *\n * Licensed under the OpenSSL license (the \"License\").  You may not use\n * this file except in compliance with the License.  You can obtain a copy\n * in the file LICENSE in the source distribution or at\n * https://www.openssl.org/source/license.html\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <openssl/opensslv.h>\n\n/* The test is only currently implemented for DSO_DLFCN and DSO_WIN32 */\n#if defined(DSO_DLFCN) || defined(DSO_WIN32)\n\n#define SSL_CTX_NEW \"SSL_CTX_new\"\n#define SSL_CTX_FREE \"SSL_CTX_free\"\n#define TLS_METHOD \"TLS_method\"\n\n#define ERR_GET_ERROR \"ERR_get_error\"\n#define OPENSSL_VERSION_NUM_FUNC \"OpenSSL_version_num\"\n\ntypedef struct ssl_ctx_st SSL_CTX;\ntypedef struct ssl_method_st SSL_METHOD;\ntypedef const SSL_METHOD * (*TLS_method_t)(void);\ntypedef SSL_CTX * (*SSL_CTX_new_t)(const SSL_METHOD *meth);\ntypedef void (*SSL_CTX_free_t)(SSL_CTX *);\n\ntypedef unsigned long (*ERR_get_error_t)(void);\ntypedef unsigned long (*OpenSSL_version_num_t)(void);\n\nstatic TLS_method_t TLS_method;\nstatic SSL_CTX_new_t SSL_CTX_new;\nstatic SSL_CTX_free_t SSL_CTX_free;\n\nstatic ERR_get_error_t ERR_get_error;\nstatic OpenSSL_version_num_t OpenSSL_version_num;\n\n#ifdef DSO_DLFCN\n\n# include <dlfcn.h>\n\ntypedef void * SHLIB;\ntypedef void * SHLIB_SYM;\n# define SHLIB_INIT NULL\n\nstatic int shlib_load(const char *filename, SHLIB *lib)\n{\n    *lib = dlopen(filename, RTLD_GLOBAL | RTLD_LAZY);\n\n    if (*lib == NULL)\n        return 0;\n\n    return 1;\n}\n\nstatic int shlib_sym(SHLIB lib, const char *symname, SHLIB_SYM *sym)\n{\n    *sym = dlsym(lib, symname);\n\n    return *sym != NULL;\n}\n\nstatic int shlib_close(SHLIB lib)\n{\n    if (dlclose(lib) != 0)\n        return 0;\n\n    return 1;\n}\n\n#elif defined(DSO_WIN32)\n\n# include <windows.h>\n\ntypedef HINSTANCE SHLIB;\ntypedef void * SHLIB_SYM;\n# define SHLIB_INIT 0\n\nstatic int shlib_load(const char *filename, SHLIB *lib)\n{\n    *lib = LoadLibraryA(filename);\n    if (*lib == NULL)\n        return 0;\n\n    return 1;\n}\n\nstatic int shlib_sym(SHLIB lib, const char *symname, SHLIB_SYM *sym)\n{\n    *sym = (SHLIB_SYM)GetProcAddress(lib, symname);\n\n    return *sym != NULL;\n}\n\nstatic int shlib_close(SHLIB lib)\n{\n    if (FreeLibrary(lib) == 0)\n        return 0;\n\n    return 1;\n}\n\n#endif\n\n# define CRYPTO_FIRST_OPT    \"-crypto_first\"\n# define SSL_FIRST_OPT       \"-ssl_first\"\n# define JUST_CRYPTO_OPT     \"-just_crypto\"\n\nenum test_types_en {\n    CRYPTO_FIRST,\n    SSL_FIRST,\n    JUST_CRYPTO\n};\n\nint main(int argc, char **argv)\n{\n    SHLIB ssllib = SHLIB_INIT, cryptolib = SHLIB_INIT;\n    SSL_CTX *ctx;\n    union {\n        void (*func) (void);\n        SHLIB_SYM sym;\n    } tls_method_sym, ssl_ctx_new_sym, ssl_ctx_free_sym, err_get_error_sym,\n    openssl_version_num_sym;\n    enum test_types_en test_type;\n    int i;\n\n    if (argc != 4) {\n        printf(\"Unexpected number of arguments\\n\");\n        return 1;\n    }\n\n    if (strcmp(argv[1], CRYPTO_FIRST_OPT) == 0) {\n        test_type = CRYPTO_FIRST;\n    } else if (strcmp(argv[1], SSL_FIRST_OPT) == 0) {\n            test_type = SSL_FIRST;\n    } else if (strcmp(argv[1], JUST_CRYPTO_OPT) == 0) {\n            test_type = JUST_CRYPTO;\n    } else {\n        printf(\"Unrecognised argument\\n\");\n        return 1;\n    }\n\n    for (i = 0; i < 2; i++) {\n        if ((i == 0 && (test_type == CRYPTO_FIRST\n                       || test_type == JUST_CRYPTO))\n               || (i == 1 && test_type == SSL_FIRST)) {\n            if (!shlib_load(argv[2], &cryptolib)) {\n                printf(\"Unable to load libcrypto\\n\");\n                return 1;\n            }\n        }\n        if ((i == 0 && test_type == SSL_FIRST)\n                || (i == 1 && test_type == CRYPTO_FIRST)) {\n            if (!shlib_load(argv[3], &ssllib)) {\n                printf(\"Unable to load libssl\\n\");\n                return 1;\n            }\n        }\n    }\n\n    if (test_type != JUST_CRYPTO) {\n        if (!shlib_sym(ssllib, TLS_METHOD, &tls_method_sym.sym)\n                || !shlib_sym(ssllib, SSL_CTX_NEW, &ssl_ctx_new_sym.sym)\n                || !shlib_sym(ssllib, SSL_CTX_FREE, &ssl_ctx_free_sym.sym)) {\n            printf(\"Unable to load ssl symbols\\n\");\n            return 1;\n        }\n\n        TLS_method = (TLS_method_t)tls_method_sym.func;\n        SSL_CTX_new = (SSL_CTX_new_t)ssl_ctx_new_sym.func;\n        SSL_CTX_free = (SSL_CTX_free_t)ssl_ctx_free_sym.func;\n\n        ctx = SSL_CTX_new(TLS_method());\n        if (ctx == NULL) {\n            printf(\"Unable to create SSL_CTX\\n\");\n            return 1;\n        }\n        SSL_CTX_free(ctx);\n    }\n\n    if (!shlib_sym(cryptolib, ERR_GET_ERROR, &err_get_error_sym.sym)\n            || !shlib_sym(cryptolib, OPENSSL_VERSION_NUM_FUNC,\n                          &openssl_version_num_sym.sym)) {\n        printf(\"Unable to load crypto symbols\\n\");\n        return 1;\n    }\n\n    ERR_get_error = (ERR_get_error_t)err_get_error_sym.func;\n    OpenSSL_version_num = (OpenSSL_version_num_t)openssl_version_num_sym.func;\n\n    if (ERR_get_error() != 0) {\n        printf(\"Unexpected error in error queue\\n\");\n        return 1;\n    }\n\n    if (OpenSSL_version_num() != OPENSSL_VERSION_NUMBER) {\n        printf(\"Unexpected library version loaded\\n\");\n        return 1;\n    }\n\n    for (i = 0; i < 2; i++) {\n        if ((i == 0 && test_type == CRYPTO_FIRST)\n                || (i == 1 && test_type == SSL_FIRST)) {\n            if (!shlib_close(ssllib)) {\n                printf(\"Unable to close libssl\\n\");\n                return 1;\n            }\n        }\n        if ((i == 0 && (test_type == SSL_FIRST\n                       || test_type == JUST_CRYPTO))\n                || (i == 1 && test_type == CRYPTO_FIRST)) {\n            if (!shlib_close(cryptolib)) {\n                printf(\"Unable to close libcrypto\\n\");\n                return 1;\n            }\n        }\n    }\n\n    printf(\"Success\\n\");\n    return 0;\n}\n#else\nint main(void)\n{\n    printf(\"Test not implemented on this platform\\n\");\n    return 0;\n}\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0c-6jcu5o2gruelgqyvzklzi6bnlugqfqez/spack-src/test/shibboleth.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0c-6jcu5o2gruelgqyvzklzi6bnlugqfqez/spack-src/test/d2i-tests/bad-cms.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0c-6jcu5o2gruelgqyvzklzi6bnlugqfqez/spack-src/test/d2i-tests/high_tag.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0c-6jcu5o2gruelgqyvzklzi6bnlugqfqez/spack-src/test/d2i-tests/intminus1.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0c-6jcu5o2gruelgqyvzklzi6bnlugqfqez/spack-src/test/d2i-tests/bad_bio.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0c-6jcu5o2gruelgqyvzklzi6bnlugqfqez/spack-src/test/d2i-tests/bad_cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0c-6jcu5o2gruelgqyvzklzi6bnlugqfqez/spack-src/test/d2i-tests/bad_generalname.der",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.1.0c-6jcu5o2gruelgqyvzklzi6bnlugqfqez/spack-src/test/d2i-tests/bad-int-padminus1.der"
    ],
    "total_files": 2343
}