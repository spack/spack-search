{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.2t-jtvkehfwbhgaokodgjb7ctthkt6yqab3/spack-src/crypto/sparcv9cap.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <openssl/bn.h>\n\n#include \"sparc_arch.h\"\n\n#if defined(__GNUC__) && defined(__linux)\n__attribute__ ((visibility(\"hidden\")))\n#endif\nunsigned int OPENSSL_sparcv9cap_P[2] = { SPARCV9_TICK_PRIVILEGED, 0 };\n\nint bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\n                const BN_ULONG *np, const BN_ULONG *n0, int num)\n{\n    int bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\n                         const BN_ULONG *np, const BN_ULONG *n0, int num);\n    int bn_mul_mont_fpu(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\n                        const BN_ULONG *np, const BN_ULONG *n0, int num);\n    int bn_mul_mont_int(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\n                        const BN_ULONG *np, const BN_ULONG *n0, int num);\n\n    if (!(num & 1) && num >= 6) {\n        if ((num & 15) == 0 && num <= 64 &&\n            (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n            (CFR_MONTMUL | CFR_MONTSQR)) {\n            typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\n                                          const BN_ULONG *bp,\n                                          const BN_ULONG *np,\n                                          const BN_ULONG *n0);\n            int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap,\n                                 const BN_ULONG *bp, const BN_ULONG *np,\n                                 const BN_ULONG *n0);\n            int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\n                                  const BN_ULONG *bp, const BN_ULONG *np,\n                                  const BN_ULONG *n0);\n            int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\n                                  const BN_ULONG *bp, const BN_ULONG *np,\n                                  const BN_ULONG *n0);\n            int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\n                                  const BN_ULONG *bp, const BN_ULONG *np,\n                                  const BN_ULONG *n0);\n            static const bn_mul_mont_f funcs[4] = {\n                bn_mul_mont_t4_8, bn_mul_mont_t4_16,\n                bn_mul_mont_t4_24, bn_mul_mont_t4_32\n            };\n            bn_mul_mont_f worker = funcs[num / 16 - 1];\n\n            if ((*worker) (rp, ap, bp, np, n0))\n                return 1;\n            /* retry once and fall back */\n            if ((*worker) (rp, ap, bp, np, n0))\n                return 1;\n            return bn_mul_mont_vis3(rp, ap, bp, np, n0, num);\n        }\n        if ((OPENSSL_sparcv9cap_P[0] & SPARCV9_VIS3))\n            return bn_mul_mont_vis3(rp, ap, bp, np, n0, num);\n        else if (num >= 8 &&\n                 (OPENSSL_sparcv9cap_P[0] &\n                  (SPARCV9_PREFER_FPU | SPARCV9_VIS1)) ==\n                 (SPARCV9_PREFER_FPU | SPARCV9_VIS1))\n            return bn_mul_mont_fpu(rp, ap, bp, np, n0, num);\n    }\n    return bn_mul_mont_int(rp, ap, bp, np, n0, num);\n}\n\nunsigned long _sparcv9_rdtick(void);\nvoid _sparcv9_vis1_probe(void);\nunsigned long _sparcv9_vis1_instrument(void);\nvoid _sparcv9_vis2_probe(void);\nvoid _sparcv9_fmadd_probe(void);\nunsigned long _sparcv9_rdcfr(void);\nvoid _sparcv9_vis3_probe(void);\nunsigned long _sparcv9_random(void);\nsize_t _sparcv9_vis1_instrument_bus(unsigned int *, size_t);\nsize_t _sparcv9_vis1_instrument_bus2(unsigned int *, size_t, size_t);\n\nunsigned long OPENSSL_rdtsc(void)\n{\n    if (OPENSSL_sparcv9cap_P[0] & SPARCV9_TICK_PRIVILEGED)\n#if defined(__sun) && defined(__SVR4)\n        return gethrtime();\n#else\n        return 0;\n#endif\n    else\n        return _sparcv9_rdtick();\n}\n\nsize_t OPENSSL_instrument_bus(unsigned int *out, size_t cnt)\n{\n    if ((OPENSSL_sparcv9cap_P[0] & (SPARCV9_TICK_PRIVILEGED | SPARCV9_BLK)) ==\n        SPARCV9_BLK)\n        return _sparcv9_vis1_instrument_bus(out, cnt);\n    else\n        return 0;\n}\n\nsize_t OPENSSL_instrument_bus2(unsigned int *out, size_t cnt, size_t max)\n{\n    if ((OPENSSL_sparcv9cap_P[0] & (SPARCV9_TICK_PRIVILEGED | SPARCV9_BLK)) ==\n        SPARCV9_BLK)\n        return _sparcv9_vis1_instrument_bus2(out, cnt, max);\n    else\n        return 0;\n}\n\n#if 0 && defined(__sun) && defined(__SVR4)\n/*\n * This code path is disabled, because of incompatibility of libdevinfo.so.1\n * and libmalloc.so.1 (see below for details)\n */\n# include <malloc.h>\n# include <dlfcn.h>\n# include <libdevinfo.h>\n# include <sys/systeminfo.h>\n\ntypedef di_node_t(*di_init_t) (const char *, uint_t);\ntypedef void (*di_fini_t) (di_node_t);\ntypedef char *(*di_node_name_t) (di_node_t);\ntypedef int (*di_walk_node_t) (di_node_t, uint_t, di_node_name_t,\n                               int (*)(di_node_t, di_node_name_t));\n\n# define DLLINK(h,name) (name=(name##_t)dlsym((h),#name))\n\nstatic int walk_nodename(di_node_t node, di_node_name_t di_node_name)\n{\n    char *name = (*di_node_name) (node);\n\n    /* This is expected to catch all UltraSPARC flavors prior T1 */\n    if (!strcmp(name, \"SUNW,UltraSPARC\") ||\n        /* covers II,III,IV */\n        !strncmp(name, \"SUNW,UltraSPARC-I\", 17)) {\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_PREFER_FPU | SPARCV9_VIS1;\n\n        /* %tick is privileged only on UltraSPARC-I/II, but not IIe */\n        if (name[14] != '\\0' && name[17] != '\\0' && name[18] != '\\0')\n            OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\n\n        return DI_WALK_TERMINATE;\n    }\n    /* This is expected to catch remaining UltraSPARCs, such as T1 */\n    else if (!strncmp(name, \"SUNW,UltraSPARC\", 15)) {\n        OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\n\n        return DI_WALK_TERMINATE;\n    }\n\n    return DI_WALK_CONTINUE;\n}\n\nvoid OPENSSL_cpuid_setup(void)\n{\n    void *h;\n    char *e, si[256];\n    static int trigger = 0;\n\n    if (trigger)\n        return;\n    trigger = 1;\n\n    if ((e = getenv(\"OPENSSL_sparcv9cap\"))) {\n        OPENSSL_sparcv9cap_P[0] = strtoul(e, NULL, 0);\n        return;\n    }\n\n    if (sysinfo(SI_MACHINE, si, sizeof(si)) > 0) {\n        if (strcmp(si, \"sun4v\"))\n            /* FPU is preferred for all CPUs, but US-T1/2 */\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_PREFER_FPU;\n    }\n\n    if (sysinfo(SI_ISALIST, si, sizeof(si)) > 0) {\n        if (strstr(si, \"+vis\"))\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS1 | SPARCV9_BLK;\n        if (strstr(si, \"+vis2\")) {\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS2;\n            OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\n            return;\n        }\n    }\n# ifdef M_KEEP\n    /*\n     * Solaris libdevinfo.so.1 is effectively incomatible with\n     * libmalloc.so.1. Specifically, if application is linked with\n     * -lmalloc, it crashes upon startup with SIGSEGV in\n     * free(3LIBMALLOC) called by di_fini. Prior call to\n     * mallopt(M_KEEP,0) somehow helps... But not always...\n     */\n    if ((h = dlopen(NULL, RTLD_LAZY))) {\n        union {\n            void *p;\n            int (*f) (int, int);\n        } sym;\n        if ((sym.p = dlsym(h, \"mallopt\")))\n            (*sym.f) (M_KEEP, 0);\n        dlclose(h);\n    }\n# endif\n    if ((h = dlopen(\"libdevinfo.so.1\", RTLD_LAZY)))\n        do {\n            di_init_t di_init;\n            di_fini_t di_fini;\n            di_walk_node_t di_walk_node;\n            di_node_name_t di_node_name;\n            di_node_t root_node;\n\n            if (!DLLINK(h, di_init))\n                break;\n            if (!DLLINK(h, di_fini))\n                break;\n            if (!DLLINK(h, di_walk_node))\n                break;\n            if (!DLLINK(h, di_node_name))\n                break;\n\n            if ((root_node = (*di_init) (\"/\", DINFOSUBTREE)) != DI_NODE_NIL) {\n                (*di_walk_node) (root_node, DI_WALK_SIBFIRST,\n                                 di_node_name, walk_nodename);\n                (*di_fini) (root_node);\n            }\n        } while (0);\n\n    if (h)\n        dlclose(h);\n}\n\n#else\n\nstatic sigjmp_buf common_jmp;\nstatic void common_handler(int sig)\n{\n    siglongjmp(common_jmp, sig);\n}\n\n#if defined(__sun) && defined(__SVR4)\n# if defined(__GNUC__) && __GNUC__>=2\nextern unsigned int getisax(unsigned int vec[], unsigned int sz) __attribute__ ((weak));\n# elif defined(__SUNPRO_C)\n#pragma weak getisax\nextern unsigned int getisax(unsigned int vec[], unsigned int sz);\n# else\nstatic unsigned int (*getisax) (unsigned int vec[], unsigned int sz) = NULL;\n# endif\n#endif\n\nvoid OPENSSL_cpuid_setup(void)\n{\n    char *e;\n    struct sigaction common_act, ill_oact, bus_oact;\n    sigset_t all_masked, oset;\n    static int trigger = 0;\n\n    if (trigger)\n        return;\n    trigger = 1;\n\n    if ((e = getenv(\"OPENSSL_sparcv9cap\"))) {\n        OPENSSL_sparcv9cap_P[0] = strtoul(e, NULL, 0);\n        if ((e = strchr(e, ':')))\n            OPENSSL_sparcv9cap_P[1] = strtoul(e + 1, NULL, 0);\n        return;\n    }\n\n#if defined(__sun) && defined(__SVR4)\n    if (getisax != NULL) {\n        unsigned int vec[1];\n\n        if (getisax (vec,1)) {\n            if (vec[0]&0x0020) OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS1;\n            if (vec[0]&0x0040) OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS2;\n            if (vec[0]&0x0080) OPENSSL_sparcv9cap_P[0] |= SPARCV9_BLK;\n            if (vec[0]&0x0100) OPENSSL_sparcv9cap_P[0] |= SPARCV9_FMADD;\n            if (vec[0]&0x0400) OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS3;\n\n            /* reconstruct %cfr copy */\n            OPENSSL_sparcv9cap_P[1] = (vec[0]>>17)&0x3ff;\n            OPENSSL_sparcv9cap_P[1] |= (OPENSSL_sparcv9cap_P[1]&CFR_MONTMUL)<<1;\n            if (vec[0]&0x20000000) OPENSSL_sparcv9cap_P[1] |= CFR_CRC32C;\n\n            /* Some heuristics */\n            /* all known VIS2-capable CPUs have unprivileged tick counter */\n            if (OPENSSL_sparcv9cap_P[0]&SPARCV9_VIS2)\n                OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\n\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_PREFER_FPU;\n\n            /* detect UltraSPARC-Tx, see sparccpud.S for details... */\n            if ((OPENSSL_sparcv9cap_P[0]&SPARCV9_VIS1) &&\n                _sparcv9_vis1_instrument() >= 12)\n                OPENSSL_sparcv9cap_P[0] &= ~(SPARCV9_VIS1 | SPARCV9_PREFER_FPU);\n        }\n\n        if (sizeof(size_t) == 8)\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_64BIT_STACK;\n\n        return;\n    }\n#endif\n\n    /* Initial value, fits UltraSPARC-I&II... */\n    OPENSSL_sparcv9cap_P[0] = SPARCV9_PREFER_FPU | SPARCV9_TICK_PRIVILEGED;\n\n    sigfillset(&all_masked);\n    sigdelset(&all_masked, SIGILL);\n    sigdelset(&all_masked, SIGTRAP);\n# ifdef SIGEMT\n    sigdelset(&all_masked, SIGEMT);\n# endif\n    sigdelset(&all_masked, SIGFPE);\n    sigdelset(&all_masked, SIGBUS);\n    sigdelset(&all_masked, SIGSEGV);\n    sigprocmask(SIG_SETMASK, &all_masked, &oset);\n\n    memset(&common_act, 0, sizeof(common_act));\n    common_act.sa_handler = common_handler;\n    common_act.sa_mask = all_masked;\n\n    sigaction(SIGILL, &common_act, &ill_oact);\n    sigaction(SIGBUS, &common_act, &bus_oact); /* T1 fails 16-bit ldda [on\n                                                * Linux] */\n\n    if (sigsetjmp(common_jmp, 1) == 0) {\n        _sparcv9_rdtick();\n        OPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\n    }\n\n    if (sigsetjmp(common_jmp, 1) == 0) {\n        _sparcv9_vis1_probe();\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS1 | SPARCV9_BLK;\n        /* detect UltraSPARC-Tx, see sparccpud.S for details... */\n        if (_sparcv9_vis1_instrument() >= 12)\n            OPENSSL_sparcv9cap_P[0] &= ~(SPARCV9_VIS1 | SPARCV9_PREFER_FPU);\n        else {\n            _sparcv9_vis2_probe();\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS2;\n        }\n    }\n\n    if (sigsetjmp(common_jmp, 1) == 0) {\n        _sparcv9_fmadd_probe();\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_FMADD;\n    }\n\n    /*\n     * VIS3 flag is tested independently from VIS1, unlike VIS2 that is,\n     * because VIS3 defines even integer instructions.\n     */\n    if (sigsetjmp(common_jmp, 1) == 0) {\n        _sparcv9_vis3_probe();\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS3;\n    }\n# if 0                          /* was planned at some point but never\n                                 * implemented in hardware */\n    if (sigsetjmp(common_jmp, 1) == 0) {\n        (void)_sparcv9_random();\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_RANDOM;\n    }\n# endif\n\n    /*\n     * In wait for better solution _sparcv9_rdcfr is masked by\n     * VIS3 flag, because it goes to uninterruptable endless\n     * loop on UltraSPARC II running Solaris. Things might be\n     * different on Linux...\n     */\n    if ((OPENSSL_sparcv9cap_P[0] & SPARCV9_VIS3) &&\n        sigsetjmp(common_jmp, 1) == 0) {\n        OPENSSL_sparcv9cap_P[1] = (unsigned int)_sparcv9_rdcfr();\n    }\n\n    sigaction(SIGBUS, &bus_oact, NULL);\n    sigaction(SIGILL, &ill_oact, NULL);\n\n    sigprocmask(SIG_SETMASK, &oset, NULL);\n\n    if (sizeof(size_t) == 8)\n        OPENSSL_sparcv9cap_P[0] |= SPARCV9_64BIT_STACK;\n# ifdef __linux\n    else {\n        int ret = syscall(340);\n\n        if (ret >= 0 && ret & 1)\n            OPENSSL_sparcv9cap_P[0] |= SPARCV9_64BIT_STACK;\n    }\n# endif\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.2t-jtvkehfwbhgaokodgjb7ctthkt6yqab3/spack-src/crypto/dso/dso_dlfcn.c": "/* dso_dlfcn.c */\n/*\n * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project\n * 2000.\n */\n/* ====================================================================\n * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n/*\n * We need to do this early, because stdio.h includes the header files that\n * handle _GNU_SOURCE and other similar macros.  Defining it later is simply\n * too late, because those headers are protected from re- inclusion.\n */\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE            /* make sure dladdr is declared */\n#endif\n\n#include <stdio.h>\n#include \"cryptlib.h\"\n#include <openssl/dso.h>\n\n#ifndef DSO_DLFCN\nDSO_METHOD *DSO_METHOD_dlfcn(void)\n{\n    return NULL;\n}\n#else\n\n# ifdef HAVE_DLFCN_H\n#  ifdef __osf__\n#   define __EXTENSIONS__\n#  endif\n#  include <dlfcn.h>\n#  define HAVE_DLINFO 1\n#  if defined(_AIX) || defined(__CYGWIN__) || \\\n     defined(__SCO_VERSION__) || defined(_SCO_ELF) || \\\n     (defined(__osf__) && !defined(RTLD_NEXT))     || \\\n     (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \\\n        defined(__ANDROID__)\n#   undef HAVE_DLINFO\n#  endif\n# endif\n\n/* Part of the hack in \"dlfcn_load\" ... */\n# define DSO_MAX_TRANSLATED_SIZE 256\n\nstatic int dlfcn_load(DSO *dso);\nstatic int dlfcn_unload(DSO *dso);\nstatic void *dlfcn_bind_var(DSO *dso, const char *symname);\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname);\n# if 0\nstatic int dlfcn_unbind(DSO *dso, char *symname, void *symptr);\nstatic int dlfcn_init(DSO *dso);\nstatic int dlfcn_finish(DSO *dso);\nstatic long dlfcn_ctrl(DSO *dso, int cmd, long larg, void *parg);\n# endif\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename);\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2);\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz);\nstatic void *dlfcn_globallookup(const char *name);\n\nstatic DSO_METHOD dso_meth_dlfcn = {\n    \"OpenSSL 'dlfcn' shared library method\",\n    dlfcn_load,\n    dlfcn_unload,\n    dlfcn_bind_var,\n    dlfcn_bind_func,\n/* For now, \"unbind\" doesn't exist */\n# if 0\n    NULL,                       /* unbind_var */\n    NULL,                       /* unbind_func */\n# endif\n    NULL,                       /* ctrl */\n    dlfcn_name_converter,\n    dlfcn_merger,\n    NULL,                       /* init */\n    NULL,                       /* finish */\n    dlfcn_pathbyaddr,\n    dlfcn_globallookup\n};\n\nDSO_METHOD *DSO_METHOD_dlfcn(void)\n{\n    return (&dso_meth_dlfcn);\n}\n\n/*\n * Prior to using the dlopen() function, we should decide on the flag we\n * send. There's a few different ways of doing this and it's a messy\n * venn-diagram to match up which platforms support what. So as we don't have\n * autoconf yet, I'm implementing a hack that could be hacked further\n * relatively easily to deal with cases as we find them. Initially this is to\n * cope with OpenBSD.\n */\n# if defined(__OpenBSD__) || defined(__NetBSD__)\n#  ifdef DL_LAZY\n#   define DLOPEN_FLAG DL_LAZY\n#  else\n#   ifdef RTLD_NOW\n#    define DLOPEN_FLAG RTLD_NOW\n#   else\n#    define DLOPEN_FLAG 0\n#   endif\n#  endif\n# else\n#  ifdef OPENSSL_SYS_SUNOS\n#   define DLOPEN_FLAG 1\n#  else\n#   define DLOPEN_FLAG RTLD_NOW /* Hope this works everywhere else */\n#  endif\n# endif\n\n/*\n * For this DSO_METHOD, our meth_data STACK will contain; (i) the handle\n * (void*) returned from dlopen().\n */\n\nstatic int dlfcn_load(DSO *dso)\n{\n    void *ptr = NULL;\n    /* See applicable comments in dso_dl.c */\n    char *filename = DSO_convert_filename(dso, NULL);\n    int flags = DLOPEN_FLAG;\n\n    if (filename == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);\n        goto err;\n    }\n# ifdef RTLD_GLOBAL\n    if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)\n        flags |= RTLD_GLOBAL;\n# endif\n    ptr = dlopen(filename, flags);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);\n        ERR_add_error_data(4, \"filename(\", filename, \"): \", dlerror());\n        goto err;\n    }\n    if (!sk_void_push(dso->meth_data, (char *)ptr)) {\n        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);\n        goto err;\n    }\n    /* Success */\n    dso->loaded_filename = filename;\n    return (1);\n err:\n    /* Cleanup! */\n    if (filename != NULL)\n        OPENSSL_free(filename);\n    if (ptr != NULL)\n        dlclose(ptr);\n    return (0);\n}\n\nstatic int dlfcn_unload(DSO *dso)\n{\n    void *ptr;\n    if (dso == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);\n        return (0);\n    }\n    if (sk_void_num(dso->meth_data) < 1)\n        return (1);\n    ptr = sk_void_pop(dso->meth_data);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);\n        /*\n         * Should push the value back onto the stack in case of a retry.\n         */\n        sk_void_push(dso->meth_data, ptr);\n        return (0);\n    }\n    /* For now I'm not aware of any errors associated with dlclose() */\n    dlclose(ptr);\n    return (1);\n}\n\nstatic void *dlfcn_bind_var(DSO *dso, const char *symname)\n{\n    void *ptr, *sym;\n\n    if ((dso == NULL) || (symname == NULL)) {\n        DSOerr(DSO_F_DLFCN_BIND_VAR, ERR_R_PASSED_NULL_PARAMETER);\n        return (NULL);\n    }\n    if (sk_void_num(dso->meth_data) < 1) {\n        DSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_STACK_ERROR);\n        return (NULL);\n    }\n    ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_NULL_HANDLE);\n        return (NULL);\n    }\n    sym = dlsym(ptr, symname);\n    if (sym == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_SYM_FAILURE);\n        ERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\n        return (NULL);\n    }\n    return (sym);\n}\n\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)\n{\n    void *ptr;\n    union {\n        DSO_FUNC_TYPE sym;\n        void *dlret;\n    } u;\n\n    if ((dso == NULL) || (symname == NULL)) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\n        return (NULL);\n    }\n    if (sk_void_num(dso->meth_data) < 1) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_STACK_ERROR);\n        return (NULL);\n    }\n    ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\n    if (ptr == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_NULL_HANDLE);\n        return (NULL);\n    }\n    u.dlret = dlsym(ptr, symname);\n    if (u.dlret == NULL) {\n        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_SYM_FAILURE);\n        ERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\n        return (NULL);\n    }\n    return u.sym;\n}\n\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\n                          const char *filespec2)\n{\n    char *merged;\n\n    if (!filespec1 && !filespec2) {\n        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\n        return (NULL);\n    }\n    /*\n     * If the first file specification is a rooted path, it rules. same goes\n     * if the second file specification is missing.\n     */\n    if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\n        merged = OPENSSL_malloc(strlen(filespec1) + 1);\n        if (!merged) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n        strcpy(merged, filespec1);\n    }\n    /*\n     * If the first file specification is missing, the second one rules.\n     */\n    else if (!filespec1) {\n        merged = OPENSSL_malloc(strlen(filespec2) + 1);\n        if (!merged) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n        strcpy(merged, filespec2);\n    } else {\n        /*\n         * This part isn't as trivial as it looks.  It assumes that the\n         * second file specification really is a directory, and makes no\n         * checks whatsoever.  Therefore, the result becomes the\n         * concatenation of filespec2 followed by a slash followed by\n         * filespec1.\n         */\n        int spec2len, len;\n\n        spec2len = strlen(filespec2);\n        len = spec2len + strlen(filespec1);\n\n        if (spec2len && filespec2[spec2len - 1] == '/') {\n            spec2len--;\n            len--;\n        }\n        merged = OPENSSL_malloc(len + 2);\n        if (!merged) {\n            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n        strcpy(merged, filespec2);\n        merged[spec2len] = '/';\n        strcpy(&merged[spec2len + 1], filespec1);\n    }\n    return (merged);\n}\n\n# ifdef OPENSSL_SYS_MACOSX\n#  define DSO_ext \".dylib\"\n#  define DSO_extlen 6\n# else\n#  define DSO_ext \".so\"\n#  define DSO_extlen 3\n# endif\n\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename)\n{\n    char *translated;\n    int len, rsize, transform;\n\n    len = strlen(filename);\n    rsize = len + 1;\n    transform = (strstr(filename, \"/\") == NULL);\n    if (transform) {\n        /* We will convert this to \"%s.so\" or \"lib%s.so\" etc */\n        rsize += DSO_extlen;    /* The length of \".so\" */\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            rsize += 3;         /* The length of \"lib\" */\n    }\n    translated = OPENSSL_malloc(rsize);\n    if (translated == NULL) {\n        DSOerr(DSO_F_DLFCN_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);\n        return (NULL);\n    }\n    if (transform) {\n        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\n            sprintf(translated, \"lib%s\" DSO_ext, filename);\n        else\n            sprintf(translated, \"%s\" DSO_ext, filename);\n    } else\n        sprintf(translated, \"%s\", filename);\n    return (translated);\n}\n\n# ifdef __sgi\n/*-\nThis is a quote from IRIX manual for dladdr(3c):\n\n     <dlfcn.h> does not contain a prototype for dladdr or definition of\n     Dl_info.  The #include <dlfcn.h>  in the SYNOPSIS line is traditional,\n     but contains no dladdr prototype and no IRIX library contains an\n     implementation.  Write your own declaration based on the code below.\n\n     The following code is dependent on internal interfaces that are not\n     part of the IRIX compatibility guarantee; however, there is no future\n     intention to change this interface, so on a practical level, the code\n     below is safe to use on IRIX.\n*/\n#  include <rld_interface.h>\n#  ifndef _RLD_INTERFACE_DLFCN_H_DLADDR\n#   define _RLD_INTERFACE_DLFCN_H_DLADDR\ntypedef struct Dl_info {\n    const char *dli_fname;\n    void *dli_fbase;\n    const char *dli_sname;\n    void *dli_saddr;\n    int dli_version;\n    int dli_reserved1;\n    long dli_reserved[4];\n} Dl_info;\n#  else\ntypedef struct Dl_info Dl_info;\n#  endif\n#  define _RLD_DLADDR             14\n\nstatic int dladdr(void *address, Dl_info *dl)\n{\n    void *v;\n    v = _rld_new_interface(_RLD_DLADDR, address, dl);\n    return (int)v;\n}\n# endif                         /* __sgi */\n\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz)\n{\n# ifdef HAVE_DLINFO\n    Dl_info dli;\n    int len;\n\n    if (addr == NULL) {\n        union {\n            int (*f) (void *, char *, int);\n            void *p;\n        } t = {\n            dlfcn_pathbyaddr\n        };\n        addr = t.p;\n    }\n\n    if (dladdr(addr, &dli)) {\n        len = (int)strlen(dli.dli_fname);\n        if (sz <= 0)\n            return len + 1;\n        if (len >= sz)\n            len = sz - 1;\n        memcpy(path, dli.dli_fname, len);\n        path[len++] = 0;\n        return len;\n    }\n\n    ERR_add_error_data(2, \"dlfcn_pathbyaddr(): \", dlerror());\n# endif\n    return -1;\n}\n\nstatic void *dlfcn_globallookup(const char *name)\n{\n    void *ret = NULL, *handle = dlopen(NULL, RTLD_LAZY);\n\n    if (handle) {\n        ret = dlsym(handle, name);\n        dlclose(handle);\n    }\n\n    return ret;\n}\n#endif                          /* DSO_DLFCN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.2t-jtvkehfwbhgaokodgjb7ctthkt6yqab3/spack-src/crypto/dso/dso.h": "/* dso.h */\n/*\n * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project\n * 2000.\n */\n/* ====================================================================\n * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n\n#ifndef HEADER_DSO_H\n# define HEADER_DSO_H\n\n# include <openssl/crypto.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* These values are used as commands to DSO_ctrl() */\n# define DSO_CTRL_GET_FLAGS      1\n# define DSO_CTRL_SET_FLAGS      2\n# define DSO_CTRL_OR_FLAGS       3\n\n/*\n * By default, DSO_load() will translate the provided filename into a form\n * typical for the platform (more specifically the DSO_METHOD) using the\n * dso_name_converter function of the method. Eg. win32 will transform \"blah\"\n * into \"blah.dll\", and dlfcn will transform it into \"libblah.so\". The\n * behaviour can be overriden by setting the name_converter callback in the\n * DSO object (using DSO_set_name_converter()). This callback could even\n * utilise the DSO_METHOD's converter too if it only wants to override\n * behaviour for one or two possible DSO methods. However, the following flag\n * can be set in a DSO to prevent *any* native name-translation at all - eg.\n * if the caller has prompted the user for a path to a driver library so the\n * filename should be interpreted as-is.\n */\n# define DSO_FLAG_NO_NAME_TRANSLATION            0x01\n/*\n * An extra flag to give if only the extension should be added as\n * translation.  This is obviously only of importance on Unix and other\n * operating systems where the translation also may prefix the name with\n * something, like 'lib', and ignored everywhere else. This flag is also\n * ignored if DSO_FLAG_NO_NAME_TRANSLATION is used at the same time.\n */\n# define DSO_FLAG_NAME_TRANSLATION_EXT_ONLY      0x02\n\n/*\n * The following flag controls the translation of symbol names to upper case.\n * This is currently only being implemented for OpenVMS.\n */\n# define DSO_FLAG_UPCASE_SYMBOL                  0x10\n\n/*\n * This flag loads the library with public symbols. Meaning: The exported\n * symbols of this library are public to all libraries loaded after this\n * library. At the moment only implemented in unix.\n */\n# define DSO_FLAG_GLOBAL_SYMBOLS                 0x20\n\ntypedef void (*DSO_FUNC_TYPE) (void);\n\ntypedef struct dso_st DSO;\n\n/*\n * The function prototype used for method functions (or caller-provided\n * callbacks) that transform filenames. They are passed a DSO structure\n * pointer (or NULL if they are to be used independantly of a DSO object) and\n * a filename to transform. They should either return NULL (if there is an\n * error condition) or a newly allocated string containing the transformed\n * form that the caller will need to free with OPENSSL_free() when done.\n */\ntypedef char *(*DSO_NAME_CONVERTER_FUNC)(DSO *, const char *);\n/*\n * The function prototype used for method functions (or caller-provided\n * callbacks) that merge two file specifications. They are passed a DSO\n * structure pointer (or NULL if they are to be used independantly of a DSO\n * object) and two file specifications to merge. They should either return\n * NULL (if there is an error condition) or a newly allocated string\n * containing the result of merging that the caller will need to free with\n * OPENSSL_free() when done. Here, merging means that bits and pieces are\n * taken from each of the file specifications and added together in whatever\n * fashion that is sensible for the DSO method in question.  The only rule\n * that really applies is that if the two specification contain pieces of the\n * same type, the copy from the first string takes priority.  One could see\n * it as the first specification is the one given by the user and the second\n * being a bunch of defaults to add on if they're missing in the first.\n */\ntypedef char *(*DSO_MERGER_FUNC)(DSO *, const char *, const char *);\n\ntypedef struct dso_meth_st {\n    const char *name;\n    /*\n     * Loads a shared library, NB: new DSO_METHODs must ensure that a\n     * successful load populates the loaded_filename field, and likewise a\n     * successful unload OPENSSL_frees and NULLs it out.\n     */\n    int (*dso_load) (DSO *dso);\n    /* Unloads a shared library */\n    int (*dso_unload) (DSO *dso);\n    /* Binds a variable */\n    void *(*dso_bind_var) (DSO *dso, const char *symname);\n    /*\n     * Binds a function - assumes a return type of DSO_FUNC_TYPE. This should\n     * be cast to the real function prototype by the caller. Platforms that\n     * don't have compatible representations for different prototypes (this\n     * is possible within ANSI C) are highly unlikely to have shared\n     * libraries at all, let alone a DSO_METHOD implemented for them.\n     */\n    DSO_FUNC_TYPE (*dso_bind_func) (DSO *dso, const char *symname);\n/* I don't think this would actually be used in any circumstances. */\n# if 0\n    /* Unbinds a variable */\n    int (*dso_unbind_var) (DSO *dso, char *symname, void *symptr);\n    /* Unbinds a function */\n    int (*dso_unbind_func) (DSO *dso, char *symname, DSO_FUNC_TYPE symptr);\n# endif\n    /*\n     * The generic (yuck) \"ctrl()\" function. NB: Negative return values\n     * (rather than zero) indicate errors.\n     */\n    long (*dso_ctrl) (DSO *dso, int cmd, long larg, void *parg);\n    /*\n     * The default DSO_METHOD-specific function for converting filenames to a\n     * canonical native form.\n     */\n    DSO_NAME_CONVERTER_FUNC dso_name_converter;\n    /*\n     * The default DSO_METHOD-specific function for converting filenames to a\n     * canonical native form.\n     */\n    DSO_MERGER_FUNC dso_merger;\n    /* [De]Initialisation handlers. */\n    int (*init) (DSO *dso);\n    int (*finish) (DSO *dso);\n    /* Return pathname of the module containing location */\n    int (*pathbyaddr) (void *addr, char *path, int sz);\n    /* Perform global symbol lookup, i.e. among *all* modules */\n    void *(*globallookup) (const char *symname);\n} DSO_METHOD;\n\n/**********************************************************************/\n/* The low-level handle type used to refer to a loaded shared library */\n\nstruct dso_st {\n    DSO_METHOD *meth;\n    /*\n     * Standard dlopen uses a (void *). Win32 uses a HANDLE. VMS doesn't use\n     * anything but will need to cache the filename for use in the dso_bind\n     * handler. All in all, let each method control its own destiny.\n     * \"Handles\" and such go in a STACK.\n     */\n    STACK_OF(void) *meth_data;\n    int references;\n    int flags;\n    /*\n     * For use by applications etc ... use this for your bits'n'pieces, don't\n     * touch meth_data!\n     */\n    CRYPTO_EX_DATA ex_data;\n    /*\n     * If this callback function pointer is set to non-NULL, then it will be\n     * used in DSO_load() in place of meth->dso_name_converter. NB: This\n     * should normally set using DSO_set_name_converter().\n     */\n    DSO_NAME_CONVERTER_FUNC name_converter;\n    /*\n     * If this callback function pointer is set to non-NULL, then it will be\n     * used in DSO_load() in place of meth->dso_merger. NB: This should\n     * normally set using DSO_set_merger().\n     */\n    DSO_MERGER_FUNC merger;\n    /*\n     * This is populated with (a copy of) the platform-independant filename\n     * used for this DSO.\n     */\n    char *filename;\n    /*\n     * This is populated with (a copy of) the translated filename by which\n     * the DSO was actually loaded. It is NULL iff the DSO is not currently\n     * loaded. NB: This is here because the filename translation process may\n     * involve a callback being invoked more than once not only to convert to\n     * a platform-specific form, but also to try different filenames in the\n     * process of trying to perform a load. As such, this variable can be\n     * used to indicate (a) whether this DSO structure corresponds to a\n     * loaded library or not, and (b) the filename with which it was actually\n     * loaded.\n     */\n    char *loaded_filename;\n};\n\nDSO *DSO_new(void);\nDSO *DSO_new_method(DSO_METHOD *method);\nint DSO_free(DSO *dso);\nint DSO_flags(DSO *dso);\nint DSO_up_ref(DSO *dso);\nlong DSO_ctrl(DSO *dso, int cmd, long larg, void *parg);\n\n/*\n * This function sets the DSO's name_converter callback. If it is non-NULL,\n * then it will be used instead of the associated DSO_METHOD's function. If\n * oldcb is non-NULL then it is set to the function pointer value being\n * replaced. Return value is non-zero for success.\n */\nint DSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb,\n                           DSO_NAME_CONVERTER_FUNC *oldcb);\n/*\n * These functions can be used to get/set the platform-independant filename\n * used for a DSO. NB: set will fail if the DSO is already loaded.\n */\nconst char *DSO_get_filename(DSO *dso);\nint DSO_set_filename(DSO *dso, const char *filename);\n/*\n * This function will invoke the DSO's name_converter callback to translate a\n * filename, or if the callback isn't set it will instead use the DSO_METHOD's\n * converter. If \"filename\" is NULL, the \"filename\" in the DSO itself will be\n * used. If the DSO_FLAG_NO_NAME_TRANSLATION flag is set, then the filename is\n * simply duplicated. NB: This function is usually called from within a\n * DSO_METHOD during the processing of a DSO_load() call, and is exposed so\n * that caller-created DSO_METHODs can do the same thing. A non-NULL return\n * value will need to be OPENSSL_free()'d.\n */\nchar *DSO_convert_filename(DSO *dso, const char *filename);\n/*\n * This function will invoke the DSO's merger callback to merge two file\n * specifications, or if the callback isn't set it will instead use the\n * DSO_METHOD's merger.  A non-NULL return value will need to be\n * OPENSSL_free()'d.\n */\nchar *DSO_merge(DSO *dso, const char *filespec1, const char *filespec2);\n/*\n * If the DSO is currently loaded, this returns the filename that it was\n * loaded under, otherwise it returns NULL. So it is also useful as a test as\n * to whether the DSO is currently loaded. NB: This will not necessarily\n * return the same value as DSO_convert_filename(dso, dso->filename), because\n * the DSO_METHOD's load function may have tried a variety of filenames (with\n * and/or without the aid of the converters) before settling on the one it\n * actually loaded.\n */\nconst char *DSO_get_loaded_filename(DSO *dso);\n\nvoid DSO_set_default_method(DSO_METHOD *meth);\nDSO_METHOD *DSO_get_default_method(void);\nDSO_METHOD *DSO_get_method(DSO *dso);\nDSO_METHOD *DSO_set_method(DSO *dso, DSO_METHOD *meth);\n\n/*\n * The all-singing all-dancing load function, you normally pass NULL for the\n * first and third parameters. Use DSO_up and DSO_free for subsequent\n * reference count handling. Any flags passed in will be set in the\n * constructed DSO after its init() function but before the load operation.\n * If 'dso' is non-NULL, 'flags' is ignored.\n */\nDSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags);\n\n/* This function binds to a variable inside a shared library. */\nvoid *DSO_bind_var(DSO *dso, const char *symname);\n\n/* This function binds to a function inside a shared library. */\nDSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname);\n\n/*\n * This method is the default, but will beg, borrow, or steal whatever method\n * should be the default on any particular platform (including\n * DSO_METH_null() if necessary).\n */\nDSO_METHOD *DSO_METHOD_openssl(void);\n\n/*\n * This method is defined for all platforms - if a platform has no DSO\n * support then this will be the only method!\n */\nDSO_METHOD *DSO_METHOD_null(void);\n\n/*\n * If DSO_DLFCN is defined, the standard dlfcn.h-style functions (dlopen,\n * dlclose, dlsym, etc) will be used and incorporated into this method. If\n * not, this method will return NULL.\n */\nDSO_METHOD *DSO_METHOD_dlfcn(void);\n\n/*\n * If DSO_DL is defined, the standard dl.h-style functions (shl_load,\n * shl_unload, shl_findsym, etc) will be used and incorporated into this\n * method. If not, this method will return NULL.\n */\nDSO_METHOD *DSO_METHOD_dl(void);\n\n/* If WIN32 is defined, use DLLs. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_win32(void);\n\n/* If VMS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_vms(void);\n\n/*\n * This function writes null-terminated pathname of DSO module containing\n * 'addr' into 'sz' large caller-provided 'path' and returns the number of\n * characters [including trailing zero] written to it. If 'sz' is 0 or\n * negative, 'path' is ignored and required amount of charachers [including\n * trailing zero] to accomodate pathname is returned. If 'addr' is NULL, then\n * pathname of cryptolib itself is returned. Negative or zero return value\n * denotes error.\n */\nint DSO_pathbyaddr(void *addr, char *path, int sz);\n\n/*\n * This function should be used with caution! It looks up symbols in *all*\n * loaded modules and if module gets unloaded by somebody else attempt to\n * dereference the pointer is doomed to have fatal consequences. Primary\n * usage for this function is to probe *core* system functionality, e.g.\n * check if getnameinfo(3) is available at run-time without bothering about\n * OS-specific details such as libc.so.versioning or where does it actually\n * reside: in libc itself or libsocket.\n */\nvoid *DSO_global_lookup(const char *name);\n\n/* If BeOS is defined, use shared images. If not, return NULL. */\nDSO_METHOD *DSO_METHOD_beos(void);\n\n/* BEGIN ERROR CODES */\n/*\n * The following lines are auto generated by the script mkerr.pl. Any changes\n * made after this point may be overwritten when the script is next run.\n */\nvoid ERR_load_DSO_strings(void);\n\n/* Error codes for the DSO functions. */\n\n/* Function codes. */\n# define DSO_F_BEOS_BIND_FUNC                             144\n# define DSO_F_BEOS_BIND_VAR                              145\n# define DSO_F_BEOS_LOAD                                  146\n# define DSO_F_BEOS_NAME_CONVERTER                        147\n# define DSO_F_BEOS_UNLOAD                                148\n# define DSO_F_DLFCN_BIND_FUNC                            100\n# define DSO_F_DLFCN_BIND_VAR                             101\n# define DSO_F_DLFCN_LOAD                                 102\n# define DSO_F_DLFCN_MERGER                               130\n# define DSO_F_DLFCN_NAME_CONVERTER                       123\n# define DSO_F_DLFCN_UNLOAD                               103\n# define DSO_F_DL_BIND_FUNC                               104\n# define DSO_F_DL_BIND_VAR                                105\n# define DSO_F_DL_LOAD                                    106\n# define DSO_F_DL_MERGER                                  131\n# define DSO_F_DL_NAME_CONVERTER                          124\n# define DSO_F_DL_UNLOAD                                  107\n# define DSO_F_DSO_BIND_FUNC                              108\n# define DSO_F_DSO_BIND_VAR                               109\n# define DSO_F_DSO_CONVERT_FILENAME                       126\n# define DSO_F_DSO_CTRL                                   110\n# define DSO_F_DSO_FREE                                   111\n# define DSO_F_DSO_GET_FILENAME                           127\n# define DSO_F_DSO_GET_LOADED_FILENAME                    128\n# define DSO_F_DSO_GLOBAL_LOOKUP                          139\n# define DSO_F_DSO_LOAD                                   112\n# define DSO_F_DSO_MERGE                                  132\n# define DSO_F_DSO_NEW_METHOD                             113\n# define DSO_F_DSO_PATHBYADDR                             140\n# define DSO_F_DSO_SET_FILENAME                           129\n# define DSO_F_DSO_SET_NAME_CONVERTER                     122\n# define DSO_F_DSO_UP_REF                                 114\n# define DSO_F_GLOBAL_LOOKUP_FUNC                         138\n# define DSO_F_PATHBYADDR                                 137\n# define DSO_F_VMS_BIND_SYM                               115\n# define DSO_F_VMS_LOAD                                   116\n# define DSO_F_VMS_MERGER                                 133\n# define DSO_F_VMS_UNLOAD                                 117\n# define DSO_F_WIN32_BIND_FUNC                            118\n# define DSO_F_WIN32_BIND_VAR                             119\n# define DSO_F_WIN32_GLOBALLOOKUP                         142\n# define DSO_F_WIN32_GLOBALLOOKUP_FUNC                    143\n# define DSO_F_WIN32_JOINER                               135\n# define DSO_F_WIN32_LOAD                                 120\n# define DSO_F_WIN32_MERGER                               134\n# define DSO_F_WIN32_NAME_CONVERTER                       125\n# define DSO_F_WIN32_PATHBYADDR                           141\n# define DSO_F_WIN32_SPLITTER                             136\n# define DSO_F_WIN32_UNLOAD                               121\n\n/* Reason codes. */\n# define DSO_R_CTRL_FAILED                                100\n# define DSO_R_DSO_ALREADY_LOADED                         110\n# define DSO_R_EMPTY_FILE_STRUCTURE                       113\n# define DSO_R_FAILURE                                    114\n# define DSO_R_FILENAME_TOO_BIG                           101\n# define DSO_R_FINISH_FAILED                              102\n# define DSO_R_INCORRECT_FILE_SYNTAX                      115\n# define DSO_R_LOAD_FAILED                                103\n# define DSO_R_NAME_TRANSLATION_FAILED                    109\n# define DSO_R_NO_FILENAME                                111\n# define DSO_R_NO_FILE_SPECIFICATION                      116\n# define DSO_R_NULL_HANDLE                                104\n# define DSO_R_SET_FILENAME_FAILED                        112\n# define DSO_R_STACK_ERROR                                105\n# define DSO_R_SYM_FAILURE                                106\n# define DSO_R_UNLOAD_FAILED                              107\n# define DSO_R_UNSUPPORTED                                108\n\n#ifdef  __cplusplus\n}\n#endif\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openssl-1.0.2t-jtvkehfwbhgaokodgjb7ctthkt6yqab3/spack-src/ms/.rnd"
    ],
    "total_files": 2123
}