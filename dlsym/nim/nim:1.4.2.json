{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/tests/realtimeGC/cmain.c": "#ifdef WIN\n#include <windows.h>\n#else\n#include <dlfcn.h>\n#include <unistd.h> /* for sleep(3) */\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\n#define RUNTIME (15*60)\n\n\ntypedef void (*pFunc)(void);\n\nint main(int argc, char* argv[])\n{\n    int i;\n    void* hndl;\n    pFunc status;\n    pFunc count;\n    pFunc checkOccupiedMem;\n\n#ifdef WIN\n    hndl = (void*) LoadLibrary((char const*)\"./tests/realtimeGC/shared.dll\");\n    status = (pFunc)GetProcAddress((HMODULE) hndl, (char const*)\"status\");\n    count = (pFunc)GetProcAddress((HMODULE) hndl, (char const*)\"count\");\n    checkOccupiedMem = (pFunc)GetProcAddress((HMODULE) hndl, (char const*)\"checkOccupiedMem\");\n#else /* OSX || NIX */\n    hndl = (void*) dlopen((char const*)\"./tests/realtimeGC/libshared.so\", RTLD_LAZY);\n    status = (pFunc) dlsym(hndl, (char const*)\"status\");\n    count = (pFunc) dlsym(hndl, (char const*)\"count\");\n    checkOccupiedMem = (pFunc) dlsym(hndl, (char const*)\"checkOccupiedMem\");\n#endif\n\n    assert(hndl);\n    assert(status);\n    assert(count);\n    assert(checkOccupiedMem);\n\n    time_t startTime = time((time_t*)0);\n    time_t runTime = (time_t)(RUNTIME);\n    time_t accumTime = 0;\n    while (accumTime < runTime) {\n        for (i = 0; i < 10; i++)\n            count();\n        /* printf(\"1. sleeping...\\n\"); */\n        sleep(1);\n        for (i = 0; i < 10; i++)\n            status();\n        /* printf(\"2. sleeping...\\n\"); */\n        sleep(1);\n        checkOccupiedMem();\n        accumTime = time((time_t*)0) - startTime;\n        /* printf(\"--- Minutes left to run: %d\\n\", (int)(runTime-accumTime)/60); */\n    }\n    printf(\"Cleaning up the shared object pointer...\\n\");\n#ifdef WIN\n    FreeLibrary((HMODULE)hndl);\n#else /* OSX || NIX */\n    dlclose(hndl);\n#endif\n    printf(\"Done\\n\");\n    return 0;\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/doc/intern.rst": "=========================================\n    Internals of the Nim Compiler\n=========================================\n\n\n:Author: Andreas Rumpf\n:Version: |nimversion|\n\n.. contents::\n\n  \"Abstraction is layering ignorance on top of reality.\" -- Richard Gabriel\n\n\nDirectory structure\n===================\n\nThe Nim project's directory structure is:\n\n============   ===================================================\nPath           Purpose\n============   ===================================================\n``bin``        generated binary files\n``build``      generated C code for the installation\n``compiler``   the Nim compiler itself; note that this\n               code has been translated from a bootstrapping\n               version written in Pascal, so the code is **not**\n               a poster child of good Nim code\n``config``     configuration files for Nim\n``dist``       additional packages for the distribution\n``doc``        the documentation; it is a bunch of\n               reStructuredText files\n``lib``        the Nim library\n``web``        website of Nim; generated by ``nimweb``\n               from the ``*.txt`` and ``*.nimf`` files\n============   ===================================================\n\n\nBootstrapping the compiler\n==========================\n\nCompiling the compiler is a simple matter of running::\n\n  nim c koch.nim\n  ./koch boot\n\nFor a release version use::\n\n  nim c koch.nim\n  ./koch boot -d:release\n\nAnd for a debug version compatible with GDB::\n\n  nim c koch.nim\n  ./koch boot --debuginfo --linedir:on\n\nThe ``koch`` program is Nim's maintenance script. It is a replacement for\nmake and shell scripting with the advantage that it is much more portable.\nMore information about its options can be found in the `koch <koch.html>`_\ndocumentation.\n\n\nCoding Guidelines\n=================\n\n* Use CamelCase, not underscored_identifiers.\n* Indent with two spaces.\n* Max line length is 80 characters.\n* Provide spaces around binary operators if that enhances readability.\n* Use a space after a colon, but not before it.\n* [deprecated] Start types with a capital ``T``, unless they are\n  pointers/references which start with ``P``.\n\nSee also the `API naming design <apis.html>`_ document.\n\n\nPorting to new platforms\n========================\n\nPorting Nim to a new architecture is pretty easy, since C is the most\nportable programming language (within certain limits) and Nim generates\nC code, porting the code generator is not necessary.\n\nPOSIX-compliant systems on conventional hardware are usually pretty easy to\nport: Add the platform to ``platform`` (if it is not already listed there),\ncheck that the OS, System modules work and recompile Nim.\n\nThe only case where things aren't as easy is when the garbage\ncollector needs some assembler tweaking to work. The standard\nversion of the GC uses C's ``setjmp`` function to store all registers\non the hardware stack. It may be necessary that the new platform needs to\nreplace this generic code by some assembler code.\n\n\nRuntime type information\n========================\n\n*Runtime type information* (RTTI) is needed for several aspects of the Nim\nprogramming language:\n\nGarbage collection\n  The most important reason for RTTI. Generating\n  traversal procedures produces bigger code and is likely to be slower on\n  modern hardware as dynamic procedure binding is hard to predict.\n\nComplex assignments\n  Sequences and strings are implemented as\n  pointers to resizeable buffers, but Nim requires copying for\n  assignments. Apart from RTTI the compiler could generate copy procedures\n  for any type that needs one. However, this would make the code bigger and\n  the RTTI is likely already there for the GC.\n\nWe already know the type information as a graph in the compiler.\nThus we need to serialize this graph as RTTI for C code generation.\nLook at the file ``lib/system/hti.nim`` for more information.\n\nRebuilding the compiler\n========================\n\nAfter an initial build via `sh build_all.sh` on posix or `build_all.bat` on windows,\nyou can rebuild the compiler as follows:\n* `nim c koch` if you need to rebuild koch\n* `./koch boot -d:release` this ensures the compiler can rebuild itself\n  (use `koch` instead of `./koch` on windows), which builds the compiler 3 times.\n\nA faster approach if you don't need to run the full bootstrapping implied by `koch boot`,\nis the following:\n* `pathto/nim c --lib:lib -d:release -o:bin/nim_temp compiler/nim.nim`\nWhere `pathto/nim` is any nim binary sufficiently recent (e.g. `bin/nim_cources`\nbuilt during bootstrap or `$HOME/.nimble/bin/nim` installed by `choosenim 1.2.0`)\n\nYou can pass any additional options such as `-d:leanCompiler` if you don't need\ncertain features or `-d:debug --stacktrace:on --excessiveStackTrace --stackTraceMsgs`\nfor debugging the compiler. See also\n[Debugging the compiler](intern.html#debugging-the-compiler).\n\nDebugging the compiler\n======================\n\nYou can of course use GDB or Visual Studio to debug the\ncompiler (via ``--debuginfo --lineDir:on``). However, there\nare also lots of procs that aid in debugging:\n\n\n.. code-block:: nim\n  # pretty prints the Nim AST\n  echo renderTree(someNode)\n  # outputs some JSON representation\n  debug(someNode)\n  # pretty prints some type\n  echo typeToString(someType)\n  debug(someType)\n  echo symbol.name.s\n  debug(symbol)\n  # pretty prints the Nim ast, but annotates symbol IDs:\n  echo renderTree(someNode, {renderIds})\n  if `??`(conf, n.info, \"temp.nim\"):\n    # only output when it comes from \"temp.nim\"\n    echo renderTree(n)\n  if `??`(conf, n.info, \"temp.nim\"):\n    # why does it process temp.nim here?\n    writeStackTrace()\n\nThese procs may not be imported by a module. You can import them directly for debugging:\n\n.. code-block:: nim\n  from astalgo import debug\n  from types import typeToString\n  from renderer import renderTree\n  from msgs import `??`\n\nTo create a new compiler for each run, use ``koch temp``::\n\n  ./koch temp c /tmp/test.nim\n\n``koch temp`` creates a debug build of the compiler, which is useful\nto create stacktraces for compiler debugging. See also\n[Rebuilding the compiler](intern.html#rebuilding-the-compiler) if you need\nmore control.\n\nBisecting for regressions\n=========================\n\n``koch temp`` returns 125 as the exit code in case the compiler\ncompilation fails. This exit code tells ``git bisect`` to skip the\ncurrent commit.::\n\n  git bisect start bad-commit good-commit\n  git bisect run ./koch temp -r c test-source.nim\n\nYou can also bisect using custom options to build the compiler, for example if\nyou don't need a debug version of the compiler (which runs slower), you can replace\n`./koch temp` by explicit compilation command, see\n[Rebuilding the compiler](intern.html#rebuilding-the-compiler).\n\nThe compiler's architecture\n===========================\n\nNim uses the classic compiler architecture: A lexer/scanner feds tokens to a\nparser. The parser builds a syntax tree that is used by the code generator.\nThis syntax tree is the interface between the parser and the code generator.\nIt is essential to understand most of the compiler's code.\n\nIn order to compile Nim correctly, type-checking has to be separated from\nparsing. Otherwise generics cannot work.\n\n.. include:: filelist.txt\n\n\nThe syntax tree\n---------------\nThe syntax tree consists of nodes which may have an arbitrary number of\nchildren. Types and symbols are represented by other nodes, because they\nmay contain cycles. The AST changes its shape after semantic checking. This\nis needed to make life easier for the code generators. See the \"ast\" module\nfor the type definitions. The `macros <macros.html>`_ module contains many\nexamples how the AST represents each syntactic structure.\n\n\nHow the RTL is compiled\n=======================\n\nThe ``system`` module contains the part of the RTL which needs support by\ncompiler magic (and the stuff that needs to be in it because the spec\nsays so). The C code generator generates the C code for it, just like any other\nmodule. However, calls to some procedures like ``addInt`` are inserted by\nthe CCG. Therefore the module ``magicsys`` contains a table (``compilerprocs``)\nwith all symbols that are marked as ``compilerproc``. ``compilerprocs`` are\nneeded by the code generator. A ``magic`` proc is not the same as a\n``compilerproc``: A ``magic`` is a proc that needs compiler magic for its\nsemantic checking, a ``compilerproc`` is a proc that is used by the code\ngenerator.\n\n\nCompilation cache\n=================\n\nThe implementation of the compilation cache is tricky: There are lots\nof issues to be solved for the front- and backend.\n\n\nGeneral approach: AST replay\n----------------------------\n\nWe store a module's AST of a successful semantic check in a SQLite\ndatabase. There are plenty of features that require a sub sequence\nto be re-applied, for example:\n\n.. code-block:: nim\n  {.compile: \"foo.c\".} # even if the module is loaded from the DB,\n                       # \"foo.c\" needs to be compiled/linked.\n\nThe solution is to **re-play** the module's top level statements.\nThis solves the problem without having to special case the logic\nthat fills the internal seqs which are affected by the pragmas.\n\nIn fact, this describes how the AST should be stored in the database,\nas a \"shallow\" tree. Let's assume we compile module ``m`` with the\nfollowing contents:\n\n.. code-block:: nim\n  import strutils\n\n  var x*: int = 90\n  {.compile: \"foo.c\".}\n  proc p = echo \"p\"\n  proc q = echo \"q\"\n  static:\n    echo \"static\"\n\nConceptually this is the AST we store for the module:\n\n.. code-block:: nim\n  import strutils\n\n  var x*\n  {.compile: \"foo.c\".}\n  proc p\n  proc q\n  static:\n    echo \"static\"\n\nThe symbol's ``ast`` field is loaded lazily, on demand. This is where most\nsavings come from, only the shallow outer AST is reconstructed immediately.\n\nIt is also important that the replay involves the ``import`` statement so\nthat dependencies are resolved properly.\n\n\nShared global compiletime state\n-------------------------------\n\nNim allows ``.global, compiletime`` variables that can be filled by macro\ninvocations across different modules. This feature breaks modularity in a\nsevere way. Plenty of different solutions have been proposed:\n\n- Restrict the types of global compiletime variables to ``Set[T]`` or\n  similar unordered, only-growable collections so that we can track\n  the module's write effects to these variables and reapply the changes\n  in a different order.\n- In every module compilation, reset the variable to its default value.\n- Provide a restrictive API that can load/save the compiletime state to\n  a file.\n\n(These solutions are not mutually exclusive.)\n\nSince we adopt the \"replay the top level statements\" idea, the natural\nsolution to this problem is to emit pseudo top level statements that\nreflect the mutations done to the global variable. However, this is\nMUCH harder than it sounds, for example ``squeaknim`` uses this\nsnippet:\n\n.. code-block:: nim\n  apicall.add(\") module: '\" & dllName & \"'>\\C\" &\n              \"\\t^self externalCallFailed\\C!\\C\\C\")\n  stCode.add(st & \"\\C\\t\\\"Generated by NimSqueak\\\"\\C\\t\" & apicall)\n\nWe can \"replay\" ``stCode.add`` only if the values of ``st``\nand ``apicall`` are known. And even then a hash table's ``add`` with its\nhashing mechanism is too hard to replay.\n\nIn practice, things are worse still, consider ``someGlobal[i][j].add arg``.\nWe only know the root is ``someGlobal`` but the concrete path to the data\nis unknown as is the value that is added. We could compute a \"diff\" between\nthe global states and use that to compute a symbol patchset, but this is\nquite some work, expensive to do at runtime (it would need to run after\nevery module has been compiled) and would also break for hash tables.\n\nWe need an API that hides the complex aliasing problems by not relying\non Nim's global variables. The obvious solution is to use string keys\ninstead of global variables:\n\n.. code-block:: nim\n\n  proc cachePut*(key: string; value: string)\n  proc cacheGet*(key: string): string\n\nHowever, the values being strings/json is quite problematic: Many\nlookup tables that are built at compiletime embed *proc vars* and\ntypes which have no obvious string representation... Seems like\nAST diffing is still the best idea as it will not require to use\nan alien API and works with some existing Nimble packages, at least.\n\nOn the other hand, in Nim's future I would like to replace the VM\nby native code. A diff algorithm wouldn't work for that.\nInstead the native code would work with an API like ``put``, ``get``:\n\n.. code-block:: nim\n\n  proc cachePut*(key: string; value: NimNode)\n  proc cacheGet*(key: string): NimNode\n\nThe API should embrace the AST diffing notion: See the\nmodule ``macrocache`` for the final details.\n\n\n\nMethods and type converters\n---------------------------\n\nIn the following\nsections *global* means *shared between modules* or *property of the whole\nprogram*.\n\nNim contains language features that are *global*. The best example for that\nare multi methods: Introducing a new method with the same name and some\ncompatible object parameter means that the method's dispatcher needs to take\nthe new method into account. So the dispatching logic is only completely known\nafter the whole program has been translated!\n\nOther features that are *implicitly* triggered cause problems for modularity\ntoo. Type converters fall into this category:\n\n.. code-block:: nim\n  # module A\n  converter toBool(x: int): bool =\n    result = x != 0\n\n.. code-block:: nim\n  # module B\n  import A\n\n  if 1:\n    echo \"ugly, but should work\"\n\nIf in the above example module ``B`` is re-compiled, but ``A`` is not then\n``B`` needs to be aware of ``toBool`` even though  ``toBool`` is not referenced\nin ``B`` *explicitly*.\n\nBoth the multi method and the type converter problems are solved by the\nAST replay implementation.\n\n\nGenerics\n~~~~~~~~\n\nWe cache generic instantiations and need to ensure this caching works\nwell with the incremental compilation feature. Since the cache is\nattached to the ``PSym`` datastructure, it should work without any\nspecial logic.\n\n\nBackend issues\n--------------\n\n- Init procs must not be \"forgotten\" to be called.\n- Files must not be \"forgotten\" to be linked.\n- Method dispatchers are global.\n- DLL loading via ``dlsym`` is global.\n- Emulated thread vars are global.\n\nHowever the biggest problem is that dead code elimination breaks modularity!\nTo see why, consider this scenario: The module ``G`` (for example the huge\nGtk2 module...) is compiled with dead code elimination turned on. So none\nof ``G``'s procs is generated at all.\n\nThen module ``B`` is compiled that requires ``G.P1``. Ok, no problem,\n``G.P1`` is loaded from the symbol file and ``G.c`` now contains ``G.P1``.\n\nThen module ``A`` (that depends on ``B`` and ``G``) is compiled and ``B``\nand ``G`` are left unchanged. ``A`` requires ``G.P2``.\n\nSo now ``G.c`` MUST contain both ``P1`` and ``P2``, but we haven't even\nloaded ``P1`` from the symbol file, nor do we want to because we then quickly\nwould restore large parts of the whole program.\n\n\nSolution\n~~~~~~~~\n\nThe backend must have some logic so that if the currently processed module\nis from the compilation cache, the ``ast`` field is not accessed. Instead\nthe generated C(++) for the symbol's body needs to be cached too and\ninserted back into the produced C file. This approach seems to deal with\nall the outlined problems above.\n\n\nDebugging Nim's memory management\n=================================\n\nThe following paragraphs are mostly a reminder for myself. Things to keep\nin mind:\n\n* If an assertion in Nim's memory manager or GC fails, the stack trace\n  keeps allocating memory! Thus a stack overflow may happen, hiding the\n  real issue.\n* What seem to be C code generation problems is often a bug resulting from\n  not producing prototypes, so that some types default to ``cint``. Testing\n  without the ``-w`` option helps!\n\n\nThe Garbage Collector\n=====================\n\nIntroduction\n------------\n\nI use the term *cell* here to refer to everything that is traced\n(sequences, refs, strings).\nThis section describes how the GC works.\n\nThe basic algorithm is *Deferrent Reference Counting* with cycle detection.\nReferences on the stack are not counted for better performance and easier C\ncode generation.\n\nEach cell has a header consisting of a RC and a pointer to its type\ndescriptor. However the program does not know about these, so they are placed at\nnegative offsets. In the GC code the type ``PCell`` denotes a pointer\ndecremented by the right offset, so that the header can be accessed easily. It\nis extremely important that ``pointer`` is not confused with a ``PCell``\nas this would lead to a memory corruption.\n\n\nThe CellSet data structure\n--------------------------\n\nThe GC depends on an extremely efficient datastructure for storing a\nset of pointers - this is called a ``TCellSet`` in the source code.\nInserting, deleting and searching are done in constant time. However,\nmodifying a ``TCellSet`` during traversal leads to undefined behaviour.\n\n.. code-block:: Nim\n  type\n    TCellSet # hidden\n\n  proc cellSetInit(s: var TCellSet) # initialize a new set\n  proc cellSetDeinit(s: var TCellSet) # empty the set and free its memory\n  proc incl(s: var TCellSet, elem: PCell) # include an element\n  proc excl(s: var TCellSet, elem: PCell) # exclude an element\n\n  proc `in`(elem: PCell, s: TCellSet): bool # tests membership\n\n  iterator elements(s: TCellSet): (elem: PCell)\n\n\nAll the operations have to perform efficiently. Because a Cellset can\nbecome huge a hash table alone is not suitable for this.\n\nWe use a mixture of bitset and hash table for this. The hash table maps *pages*\nto a page descriptor. The page descriptor contains a bit for any possible cell\naddress within this page. So including a cell is done as follows:\n\n- Find the page descriptor for the page the cell belongs to.\n- Set the appropriate bit in the page descriptor indicating that the\n  cell points to the start of a memory block.\n\nRemoving a cell is analogous - the bit has to be set to zero.\nSingle page descriptors are never deleted from the hash table. This is not\nneeded as the data structures needs to be rebuilt periodically anyway.\n\nComplete traversal is done in this way::\n\n  for each page descriptor d:\n    for each bit in d:\n      if bit == 1:\n        traverse the pointer belonging to this bit\n\n\nFurther complications\n---------------------\n\nIn Nim the compiler cannot always know if a reference\nis stored on the stack or not. This is caused by var parameters.\nConsider this example:\n\n.. code-block:: Nim\n  proc setRef(r: var ref TNode) =\n    new(r)\n\n  proc usage =\n    var\n      r: ref TNode\n    setRef(r) # here we should not update the reference counts, because\n              # r is on the stack\n    setRef(r.left) # here we should update the refcounts!\n\nWe have to decide at runtime whether the reference is on the stack or not.\nThe generated code looks roughly like this:\n\n.. code-block:: C\n  void setref(TNode** ref) {\n    unsureAsgnRef(ref, newObj(TNode_TI, sizeof(TNode)))\n  }\n  void usage(void) {\n    setRef(&r)\n    setRef(&r->left)\n  }\n\nNote that for systems with a continuous stack (which most systems have)\nthe check whether the ref is on the stack is very cheap (only two\ncomparisons).\n\n\nCode generation for closures\n============================\n\nCode generation for closures is implemented by `lambda lifting`:idx:.\n\n\nDesign\n------\n\nA ``closure`` proc var can call ordinary procs of the default Nim calling\nconvention. But not the other way round! A closure is implemented as a\n``tuple[prc, env]``. ``env`` can be nil implying a call without a closure.\nThis means that a call through a closure generates an ``if`` but the\ninteroperability is worth the cost of the ``if``. Thunk generation would be\npossible too, but it's slightly more effort to implement.\n\nTests with GCC on Amd64 showed that it's really beneficial if the\n'environment' pointer is passed as the last argument, not as the first argument.\n\nProper thunk generation is harder because the proc that is to wrap\ncould stem from a complex expression:\n\n.. code-block:: nim\n  receivesClosure(returnsDefaultCC[i])\n\nA thunk would need to call 'returnsDefaultCC[i]' somehow and that would require\nan *additional* closure generation... Ok, not really, but it requires to pass\nthe function to call. So we'd end up with 2 indirect calls instead of one.\nAnother much more severe problem which this solution is that it's not GC-safe\nto pass a proc pointer around via a generic ``ref`` type.\n\n\nExample code:\n\n.. code-block:: nim\n  proc add(x: int): proc (y: int): int {.closure.} =\n    return proc (y: int): int =\n      return x + y\n\n  var add2 = add(2)\n  echo add2(5) #OUT 7\n\nThis should produce roughly this code:\n\n.. code-block:: nim\n  type\n    PEnv = ref object\n      x: int # data\n\n  proc anon(y: int, c: PEnv): int =\n    return y + c.x\n\n  proc add(x: int): tuple[prc, data] =\n    var env: PEnv\n    new env\n    env.x = x\n    result = (anon, env)\n\n  var add2 = add(2)\n  let tmp = if add2.data == nil: add2.prc(5) else: add2.prc(5, add2.data)\n  echo tmp\n\n\nBeware of nesting:\n\n.. code-block:: nim\n  proc add(x: int): proc (y: int): proc (z: int): int {.closure.} {.closure.} =\n    return lambda (y: int): proc (z: int): int {.closure.} =\n      return lambda (z: int): int =\n        return x + y + z\n\n  var add24 = add(2)(4)\n  echo add24(5) #OUT 11\n\nThis should produce roughly this code:\n\n.. code-block:: nim\n  type\n    PEnvX = ref object\n      x: int # data\n\n    PEnvY = ref object\n      y: int\n      ex: PEnvX\n\n  proc lambdaZ(z: int, ey: PEnvY): int =\n    return ey.ex.x + ey.y + z\n\n  proc lambdaY(y: int, ex: PEnvX): tuple[prc, data: PEnvY] =\n    var ey: PEnvY\n    new ey\n    ey.y = y\n    ey.ex = ex\n    result = (lambdaZ, ey)\n\n  proc add(x: int): tuple[prc, data: PEnvX] =\n    var ex: PEnvX\n    ex.x = x\n    result = (labmdaY, ex)\n\n  var tmp = add(2)\n  var tmp2 = tmp.fn(4, tmp.data)\n  var add24 = tmp2.fn(4, tmp2.data)\n  echo add24(5)\n\n\nWe could get rid of nesting environments by always inlining inner anon procs.\nMore useful is escape analysis and stack allocation of the environment,\nhowever.\n\n\nAlternative\n-----------\n\nProcess the closure of all inner procs in one pass and accumulate the\nenvironments. This is however not always possible.\n\n\nAccumulator\n-----------\n\n.. code-block:: nim\n  proc getAccumulator(start: int): proc (): int {.closure} =\n    var i = start\n    return lambda: int =\n      inc i\n      return i\n\n  proc p =\n    var delta = 7\n    proc accumulator(start: int): proc(): int =\n      var x = start-1\n      result = proc (): int =\n        x = x + delta\n        inc delta\n        return x\n\n    var a = accumulator(3)\n    var b = accumulator(4)\n    echo a() + b()\n\n\nInternals\n---------\n\nLambda lifting is implemented as part of the ``transf`` pass. The ``transf``\npass generates code to setup the environment and to pass it around. However,\nthis pass does not change the types! So we have some kind of mismatch here; on\nthe one hand the proc expression becomes an explicit tuple, on the other hand\nthe tyProc(ccClosure) type is not changed. For C code generation it's also\nimportant the hidden formal param is ``void*`` and not something more\nspecialized. However the more specialized env type needs to passed to the\nbackend somehow. We deal with this by modifying ``s.ast[paramPos]`` to contain\nthe formal hidden parameter, but not ``s.typ``!\n\n\nInteger literals:\n-----------------\n\nIn Nim, there is a redundant way to specify the type of an\ninteger literal. First of all, it should be unsurprising that every\nnode has a node kind. The node of an integer literal can be any of the\nfollowing values:\n\n    nkIntLit, nkInt8Lit, nkInt16Lit, nkInt32Lit, nkInt64Lit,\n    nkUIntLit, nkUInt8Lit, nkUInt16Lit, nkUInt32Lit, nkUInt64Lit\n\nOn top of that, there is also the `typ` field for the type. It the\nkind of the `typ` field can be one of the following ones, and it\nshould be matching the literal kind:\n\n    tyInt, tyInt8, tyInt16, tyInt32, tyInt64, tyUInt, tyUInt8,\n    tyUInt16, tyUInt32, tyUInt64\n\nThen there is also the integer literal type. This is a specific type\nthat is implicitly convertible into the requested type if the\nrequested type can hold the value. For this to work, the type needs to\nknow the concrete value of the literal. For example an expression\n`321` will be of type `int literal(321)`. This type is implicitly\nconvertible to all integer types and ranges that contain the value\n`321`. That would be all builtin integer types except `uint8` and\n`int8` where `321` would be out of range. When this literal type is\nassigned to a new `var` or `let` variable, it's type will be resolved\nto just `int`, not `int literal(321)` unlike constants. A constant\nkeeps the full `int literal(321)` type. Here is an example where that\ndifference matters.\n\n\n.. code-block:: nim\n\n   proc foo(arg: int8) =\n     echo \"def\"\n\n   const tmp1 = 123\n   foo(tmp1)  # OK\n\n   let tmp2 = 123\n   foo(tmp2) # Error\n\nIn a context with multiple overloads, the integer literal kind will\nalways prefer the `int` type over all other types. If none of the\noverloads is of type `int`, then there will be an error because of\nambiguity.\n\n.. code-block:: nim\n\n   proc foo(arg: int) =\n     echo \"abc\"\n   proc foo(arg: int8) =\n     echo \"def\"\n   foo(123) # output: abc\n\n   proc bar(arg: int16) =\n     echo \"abc\"\n   proc bar(arg: int8) =\n     echo \"def\"\n\n   bar(123) # Error ambiguous call\n\nIn the compiler these integer literal types are represented with the\nnode kind `nkIntLit`, type kind `tyInt` and the member `n` of the type\npointing back to the integer literal node in the ast containing the\ninteger value. These are the properties that hold true for integer\nliteral types.\n\n    n.kind == nkIntLit\n    n.typ.kind == tyInt\n    n.typ.n == n\n\nOther literal types, such as `uint literal(123)` that would\nautomatically convert to other integer types, but prefers to\nbecome a `uint` are not part of the Nim language.\n\nIn an unchecked AST, the `typ` field is nil. The type checker will set\nthe `typ` field accordingly to the node kind. Nodes of kind `nkIntLit`\nwill get the integer literal type (e.g. `int literal(123)`). Nodes of\nkind `nkUIntLit` will get type `uint` (kind `tyUint`), etc.\n\nThis also means that it is not possible to write a literal in an\nunchecked AST that will after sem checking just be of type `int` and\nnot implicitly convertible to other integer types. This only works for\nall integer types that are not `int`.\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/lib/pure/dynlib.nim": "#\n#\n#            Nim's Runtime Library\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n## This module implements the ability to access symbols from shared\n## libraries. On POSIX this uses the ``dlsym`` mechanism, on\n## Windows ``LoadLibrary``.\n##\n## Examples\n## ========\n##\n## Loading a simple C function\n## ---------------------------\n##\n## The following example demonstrates loading a function called 'greet'\n## from a library that is determined at runtime based upon a language choice.\n## If the library fails to load or the function 'greet' is not found,\n## it quits with a failure error code.\n##\n## .. code-block::nim\n##\n##   import dynlib\n##\n##   type\n##     greetFunction = proc(): cstring {.gcsafe, stdcall.}\n##\n##   let lang = stdin.readLine()\n##\n##   let lib = case lang\n##   of \"french\":\n##     loadLib(\"french.dll\")\n##   else:\n##     loadLib(\"english.dll\")\n##\n##   if lib == nil:\n##     echo \"Error loading library\"\n##     quit(QuitFailure)\n##\n##   let greet = cast[greetFunction](lib.symAddr(\"greet\"))\n##\n##   if greet == nil:\n##     echo \"Error loading 'greet' function from library\"\n##     quit(QuitFailure)\n##\n##   let greeting = greet()\n##\n##   echo greeting\n##\n##   unloadLib(lib)\n##\n\nimport strutils\n\ntype\n  LibHandle* = pointer ## a handle to a dynamically loaded library\n\nproc loadLib*(path: string, globalSymbols = false): LibHandle {.gcsafe.}\n  ## loads a library from `path`. Returns nil if the library could not\n  ## be loaded.\n\nproc loadLib*(): LibHandle {.gcsafe.}\n  ## gets the handle from the current executable. Returns nil if the\n  ## library could not be loaded.\n\nproc unloadLib*(lib: LibHandle) {.gcsafe.}\n  ## unloads the library `lib`\n\nproc raiseInvalidLibrary*(name: cstring) {.noinline, noreturn.} =\n  ## raises an `EInvalidLibrary` exception.\n  raise newException(LibraryError, \"could not find symbol: \" & $name)\n\nproc symAddr*(lib: LibHandle, name: cstring): pointer {.gcsafe.}\n  ## retrieves the address of a procedure/variable from `lib`. Returns nil\n  ## if the symbol could not be found.\n\nproc checkedSymAddr*(lib: LibHandle, name: cstring): pointer =\n  ## retrieves the address of a procedure/variable from `lib`. Raises\n  ## `EInvalidLibrary` if the symbol could not be found.\n  result = symAddr(lib, name)\n  if result == nil: raiseInvalidLibrary(name)\n\nproc libCandidates*(s: string, dest: var seq[string]) =\n  ## given a library name pattern `s` write possible library names to `dest`.\n  var le = strutils.find(s, '(')\n  var ri = strutils.find(s, ')', le+1)\n  if le >= 0 and ri > le:\n    var prefix = substr(s, 0, le - 1)\n    var suffix = substr(s, ri + 1)\n    for middle in split(substr(s, le + 1, ri - 1), '|'):\n      libCandidates(prefix & middle & suffix, dest)\n  else:\n    add(dest, s)\n\nproc loadLibPattern*(pattern: string, globalSymbols = false): LibHandle =\n  ## loads a library with name matching `pattern`, similar to what `dynlib`\n  ## pragma does. Returns nil if the library could not be loaded.\n  ## Warning: this proc uses the GC and so cannot be used to load the GC.\n  var candidates = newSeq[string]()\n  libCandidates(pattern, candidates)\n  for c in candidates:\n    result = loadLib(c, globalSymbols)\n    if not result.isNil: break\n\nwhen defined(posix) and not defined(nintendoswitch):\n  #\n  # =========================================================================\n  # This is an implementation based on the dlfcn interface.\n  # The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n  # NetBSD, AIX 4.2, HPUX 11, and probably most other Unix flavors, at least\n  # as an emulation layer on top of native functions.\n  # =========================================================================\n  #\n  import posix\n\n  proc loadLib(path: string, globalSymbols = false): LibHandle =\n    let flags =\n      if globalSymbols: RTLD_NOW or RTLD_GLOBAL\n      else: RTLD_NOW\n\n    dlopen(path, flags)\n\n  proc loadLib(): LibHandle = dlopen(nil, RTLD_NOW)\n  proc unloadLib(lib: LibHandle) = discard dlclose(lib)\n  proc symAddr(lib: LibHandle, name: cstring): pointer = dlsym(lib, name)\n\nelif defined(nintendoswitch):\n  #\n  # =========================================================================\n  # Nintendo switch DevkitPro sdk does not have these. Raise an error if called.\n  # =========================================================================\n  #\n\n  proc dlclose(lib: LibHandle) =\n    raise newException(OSError, \"dlclose not implemented on Nintendo Switch!\")\n  proc dlopen(path: cstring, mode: int): LibHandle =\n    raise newException(OSError, \"dlopen not implemented on Nintendo Switch!\")\n  proc dlsym(lib: LibHandle, name: cstring): pointer =\n    raise newException(OSError, \"dlsym not implemented on Nintendo Switch!\")\n  proc loadLib(path: string, global_symbols = false): LibHandle =\n    raise newException(OSError, \"loadLib not implemented on Nintendo Switch!\")\n  proc loadLib(): LibHandle =\n    raise newException(OSError, \"loadLib not implemented on Nintendo Switch!\")\n  proc unloadLib(lib: LibHandle) =\n    raise newException(OSError, \"unloadLib not implemented on Nintendo Switch!\")\n  proc symAddr(lib: LibHandle, name: cstring): pointer =\n    raise newException(OSError, \"symAddr not implemented on Nintendo Switch!\")\n\nelif defined(windows) or defined(dos):\n  #\n  # =======================================================================\n  # Native Windows Implementation\n  # =======================================================================\n  #\n  type\n    HMODULE {.importc: \"HMODULE\".} = pointer\n    FARPROC {.importc: \"FARPROC\".} = pointer\n\n  proc FreeLibrary(lib: HMODULE) {.importc, header: \"<windows.h>\", stdcall.}\n  proc winLoadLibrary(path: cstring): HMODULE {.\n      importc: \"LoadLibraryA\", header: \"<windows.h>\", stdcall.}\n  proc getProcAddress(lib: HMODULE, name: cstring): FARPROC {.\n      importc: \"GetProcAddress\", header: \"<windows.h>\", stdcall.}\n\n  proc loadLib(path: string, globalSymbols = false): LibHandle =\n    result = cast[LibHandle](winLoadLibrary(path))\n  proc loadLib(): LibHandle =\n    result = cast[LibHandle](winLoadLibrary(nil))\n  proc unloadLib(lib: LibHandle) = FreeLibrary(cast[HMODULE](lib))\n\n  proc symAddr(lib: LibHandle, name: cstring): pointer =\n    result = cast[pointer](getProcAddress(cast[HMODULE](lib), name))\n\nelse:\n  {.error: \"no implementation for dynlib\".}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/lib/posix/posix.nim": "#\n#\n#            Nim's Runtime Library\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n# Until std_arg!!\n# done: ipc, pwd, stat, semaphore, sys/types, sys/utsname, pthread, unistd,\n# statvfs, mman, time, wait, signal, nl_types, sched, spawn, select, ucontext,\n# net/if, sys/socket, sys/uio, netinet/in, netinet/tcp, netdb\n\n## This is a raw POSIX interface module. It does not not provide any\n## convenience: cstrings are used instead of proper Nim strings and\n## return codes indicate errors. If you want exceptions\n## and a proper Nim-like interface, use the OS module or write a wrapper.\n##\n## For high-level wrappers specialized for Linux and BSDs see:\n## `posix_utils <posix_utils.html>`_\n##\n## Coding conventions:\n## ALL types are named the same as in the POSIX standard except that they start\n## with 'T' or 'P' (if they are pointers) and without the '_t' suffix to be\n## consistent with Nim conventions. If an identifier is a Nim keyword\n## the \\`identifier\\` notation is used.\n##\n## This library relies on the header files of your C compiler. The\n## resulting C code will just ``#include <XYZ.h>`` and *not* define the\n## symbols declared here.\n\n# Dead code elimination ensures that we don't accidentally generate #includes\n# for files that might not exist on a specific platform! The user will get an\n# error only if they actually try to use the missing declaration\n\nwhen defined(nimHasStyleChecks):\n  {.push styleChecks: off.}\n\n# TODO these constants don't seem to be fetched from a header file for unknown\n#      platforms - where do they come from and why are they here?\nwhen false:\n  const\n    C_IRUSR = 0o000400 ## Read by owner.\n    C_IWUSR = 0o000200 ## Write by owner.\n    C_IXUSR = 0o000100 ## Execute by owner.\n    C_IRGRP = 0o000040 ## Read by group.\n    C_IWGRP = 0o000020 ## Write by group.\n    C_IXGRP = 0o000010 ## Execute by group.\n    C_IROTH = 0o000004 ## Read by others.\n    C_IWOTH = 0o000002 ## Write by others.\n    C_IXOTH = 0o000001 ## Execute by others.\n    C_ISUID = 0o004000 ## Set user ID.\n    C_ISGID = 0o002000 ## Set group ID.\n    C_ISVTX = 0o001000 ## On directories, restricted deletion flag.\n    C_ISDIR = 0o040000 ## Directory.\n    C_ISFIFO = 0o010000 ##FIFO.\n    C_ISREG = 0o100000 ## Regular file.\n    C_ISBLK = 0o060000 ## Block special.\n    C_ISCHR = 0o020000 ## Character special.\n    C_ISCTG = 0o110000 ## Reserved.\n    C_ISLNK = 0o120000 ## Symbolic link.</p>\n    C_ISSOCK = 0o140000 ## Socket.\n\nconst\n  MM_NULLLBL* = nil\n  MM_NULLSEV* = 0\n  MM_NULLMC* = 0\n  MM_NULLTXT* = nil\n  MM_NULLACT* = nil\n  MM_NULLTAG* = nil\n\n  STDERR_FILENO* = 2 ## File number of stderr;\n  STDIN_FILENO* = 0  ## File number of stdin;\n  STDOUT_FILENO* = 1 ## File number of stdout;\n\n  DT_UNKNOWN* = 0 ## Unknown file type.\n  DT_FIFO* = 1    ## Named pipe, or FIFO.\n  DT_CHR* = 2     ## Character device.\n  DT_DIR* = 4     ## Directory.\n  DT_BLK* = 6     ## Block device.\n  DT_REG* = 8     ## Regular file.\n  DT_LNK* = 10    ## Symbolic link.\n  DT_SOCK* = 12   ## UNIX domain socket.\n  DT_WHT* = 14\n\n# Special types\ntype Sighandler = proc (a: cint) {.noconv.}\n\nconst StatHasNanoseconds* = defined(linux) or defined(freebsd) or\n    defined(osx) or defined(openbsd) or defined(dragonfly) or defined(haiku) ## \\\n  ## Boolean flag that indicates if the system supports nanosecond time\n  ## resolution in the fields of ``Stat``. Note that the nanosecond based fields\n  ## (``Stat.st_atim``, ``Stat.st_mtim`` and ``Stat.st_ctim``) can be accessed\n  ## without checking this flag, because this module defines fallback procs\n  ## when they are not available.\n\n# Platform specific stuff\n\nwhen (defined(linux) and not defined(android)) and defined(amd64):\n  include posix_linux_amd64\nelif defined(openbsd) and defined(amd64):\n  include posix_openbsd_amd64\nelif (defined(macos) or defined(macosx) or defined(bsd)) and defined(cpu64):\n  include posix_macos_amd64\nelif defined(nintendoswitch):\n  include posix_nintendoswitch\nelif defined(haiku):\n  include posix_haiku\nelse:\n  include posix_other\n\n# There used to be this name in posix.nim a long time ago, not sure why!\n\nwhen StatHasNanoseconds:\n  proc st_atime*(s: Stat): Time {.inline.} =\n    ## Second-granularity time of last access.\n    result = s.st_atim.tv_sec\n  proc st_mtime*(s: Stat): Time {.inline.} =\n    ## Second-granularity time of last data modification.\n    result = s.st_mtim.tv_sec\n  proc st_ctime*(s: Stat): Time {.inline.} =\n    ## Second-granularity time of last status change.\n    result = s.st_ctim.tv_sec\nelse:\n  proc st_atim*(s: Stat): Timespec {.inline.} =\n    ## Nanosecond-granularity time of last access.\n    result.tv_sec = s.st_atime\n  proc st_mtim*(s: Stat): Timespec {.inline.} =\n    ## Nanosecond-granularity time of last data modification.\n    result.tv_sec = s.st_mtime\n  proc st_ctim*(s: Stat): Timespec {.inline.} =\n    ## Nanosecond-granularity time of last data modification.\n    result.tv_sec = s.st_ctime\n\nwhen hasAioH:\n  proc aio_cancel*(a1: cint, a2: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}\n  proc aio_error*(a1: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}\n  proc aio_fsync*(a1: cint, a2: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}\n  proc aio_read*(a1: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}\n  proc aio_return*(a1: ptr Taiocb): int {.importc, header: \"<aio.h>\".}\n  proc aio_suspend*(a1: ptr ptr Taiocb, a2: cint, a3: ptr Timespec): cint {.\n                   importc, header: \"<aio.h>\".}\n  proc aio_write*(a1: ptr Taiocb): cint {.importc, header: \"<aio.h>\".}\n  proc lio_listio*(a1: cint, a2: ptr ptr Taiocb, a3: cint,\n               a4: ptr SigEvent): cint {.importc, header: \"<aio.h>\".}\n\n# arpa/inet.h\nproc htonl*(a1: uint32): uint32 {.importc, header: \"<arpa/inet.h>\".}\nproc htons*(a1: uint16): uint16 {.importc, header: \"<arpa/inet.h>\".}\nproc ntohl*(a1: uint32): uint32 {.importc, header: \"<arpa/inet.h>\".}\nproc ntohs*(a1: uint16): uint16 {.importc, header: \"<arpa/inet.h>\".}\n\nproc inet_addr*(a1: cstring): InAddrT {.importc, header: \"<arpa/inet.h>\".}\nproc inet_ntoa*(a1: InAddr): cstring {.importc, header: \"<arpa/inet.h>\".}\nproc inet_ntop*(a1: cint, a2: pointer, a3: cstring, a4: int32): cstring {.\n  importc:\"(char *)$1\", header: \"<arpa/inet.h>\".}\nproc inet_pton*(a1: cint, a2: cstring, a3: pointer): cint {.\n  importc, header: \"<arpa/inet.h>\".}\n\nvar\n  in6addr_any* {.importc, header: \"<netinet/in.h>\".}: In6Addr\n  in6addr_loopback* {.importc, header: \"<netinet/in.h>\".}: In6Addr\n\nproc IN6ADDR_ANY_INIT* (): In6Addr {.importc, header: \"<netinet/in.h>\".}\nproc IN6ADDR_LOOPBACK_INIT* (): In6Addr {.importc, header: \"<netinet/in.h>\".}\n\n# dirent.h\nproc closedir*(a1: ptr DIR): cint  {.importc, header: \"<dirent.h>\".}\nproc opendir*(a1: cstring): ptr DIR {.importc, header: \"<dirent.h>\", sideEffect.}\nproc readdir*(a1: ptr DIR): ptr Dirent  {.importc, header: \"<dirent.h>\", sideEffect.}\nproc readdir_r*(a1: ptr DIR, a2: ptr Dirent, a3: ptr ptr Dirent): cint  {.\n                importc, header: \"<dirent.h>\", sideEffect.}\nproc rewinddir*(a1: ptr DIR)  {.importc, header: \"<dirent.h>\".}\nproc seekdir*(a1: ptr DIR, a2: int)  {.importc, header: \"<dirent.h>\".}\nproc telldir*(a1: ptr DIR): int {.importc, header: \"<dirent.h>\".}\n\n# dlfcn.h\nproc dlclose*(a1: pointer): cint {.importc, header: \"<dlfcn.h>\", sideEffect.}\nproc dlerror*(): cstring {.importc, header: \"<dlfcn.h>\", sideEffect.}\nproc dlopen*(a1: cstring, a2: cint): pointer {.importc, header: \"<dlfcn.h>\", sideEffect.}\nproc dlsym*(a1: pointer, a2: cstring): pointer {.importc, header: \"<dlfcn.h>\", sideEffect.}\n\nproc creat*(a1: cstring, a2: Mode): cint {.importc, header: \"<fcntl.h>\", sideEffect.}\nproc fcntl*(a1: cint | SocketHandle, a2: cint): cint {.varargs, importc, header: \"<fcntl.h>\", sideEffect.}\nproc open*(a1: cstring, a2: cint): cint {.varargs, importc, header: \"<fcntl.h>\", sideEffect.}\nproc posix_fadvise*(a1: cint, a2, a3: Off, a4: cint): cint {.\n  importc, header: \"<fcntl.h>\".}\nproc posix_fallocate*(a1: cint, a2, a3: Off): cint {.\n  importc, header: \"<fcntl.h>\".}\n\nwhen not defined(haiku) and not defined(OpenBSD):\n  proc fmtmsg*(a1: int, a2: cstring, a3: cint,\n              a4, a5, a6: cstring): cint {.importc, header: \"<fmtmsg.h>\".}\n\nproc fnmatch*(a1, a2: cstring, a3: cint): cint {.importc, header: \"<fnmatch.h>\".}\nproc ftw*(a1: cstring,\n         a2: proc (x1: cstring, x2: ptr Stat, x3: cint): cint {.noconv.},\n         a3: cint): cint {.importc, header: \"<ftw.h>\".}\nwhen not (defined(linux) and defined(amd64)) and not defined(nintendoswitch):\n  proc nftw*(a1: cstring,\n            a2: proc (x1: cstring, x2: ptr Stat,\n                      x3: cint, x4: ptr FTW): cint {.noconv.},\n            a3: cint,\n            a4: cint): cint {.importc, header: \"<ftw.h>\".}\n\nproc glob*(a1: cstring, a2: cint,\n          a3: proc (x1: cstring, x2: cint): cint {.noconv.},\n          a4: ptr Glob): cint {.importc, header: \"<glob.h>\", sideEffect.}\n  ## Filename globbing. Use `os.walkPattern() <os.html#glob_1>`_ and similar.\n\nproc globfree*(a1: ptr Glob) {.importc, header: \"<glob.h>\".}\n\nproc getgrgid*(a1: Gid): ptr Group {.importc, header: \"<grp.h>\".}\nproc getgrnam*(a1: cstring): ptr Group {.importc, header: \"<grp.h>\".}\nproc getgrgid_r*(a1: Gid, a2: ptr Group, a3: cstring, a4: int,\n                 a5: ptr ptr Group): cint {.importc, header: \"<grp.h>\".}\nproc getgrnam_r*(a1: cstring, a2: ptr Group, a3: cstring,\n                  a4: int, a5: ptr ptr Group): cint {.\n                 importc, header: \"<grp.h>\".}\nproc getgrent*(): ptr Group {.importc, header: \"<grp.h>\".}\nproc endgrent*() {.importc, header: \"<grp.h>\".}\nproc setgrent*() {.importc, header: \"<grp.h>\".}\n\n\nproc iconv_open*(a1, a2: cstring): Iconv {.importc, header: \"<iconv.h>\".}\nproc iconv*(a1: Iconv, a2: var cstring, a3: var int, a4: var cstring,\n            a5: var int): int {.importc, header: \"<iconv.h>\".}\nproc iconv_close*(a1: Iconv): cint {.importc, header: \"<iconv.h>\".}\n\nproc nl_langinfo*(a1: Nl_item): cstring {.importc, header: \"<langinfo.h>\".}\n\nproc basename*(a1: cstring): cstring {.importc, header: \"<libgen.h>\".}\nproc dirname*(a1: cstring): cstring {.importc, header: \"<libgen.h>\".}\n\nproc localeconv*(): ptr Lconv {.importc, header: \"<locale.h>\".}\nproc setlocale*(a1: cint, a2: cstring): cstring {.\n                importc, header: \"<locale.h>\", sideEffect.}\n\nproc strfmon*(a1: cstring, a2: int, a3: cstring): int {.varargs,\n   importc, header: \"<monetary.h>\".}\n\nwhen not defined(nintendoswitch):\n  proc mq_close*(a1: Mqd): cint {.importc, header: \"<mqueue.h>\".}\n  proc mq_getattr*(a1: Mqd, a2: ptr MqAttr): cint {.\n    importc, header: \"<mqueue.h>\".}\n  proc mq_notify*(a1: Mqd, a2: ptr SigEvent): cint {.\n    importc, header: \"<mqueue.h>\".}\n  proc mq_open*(a1: cstring, a2: cint): Mqd {.\n    varargs, importc, header: \"<mqueue.h>\".}\n  proc mq_receive*(a1: Mqd, a2: cstring, a3: int, a4: var int): int {.\n    importc, header: \"<mqueue.h>\".}\n  proc mq_send*(a1: Mqd, a2: cstring, a3: int, a4: int): cint {.\n    importc, header: \"<mqueue.h>\".}\n  proc mq_setattr*(a1: Mqd, a2, a3: ptr MqAttr): cint {.\n    importc, header: \"<mqueue.h>\".}\n\n  proc mq_timedreceive*(a1: Mqd, a2: cstring, a3: int, a4: int,\n                        a5: ptr Timespec): int {.importc, header: \"<mqueue.h>\".}\n  proc mq_timedsend*(a1: Mqd, a2: cstring, a3: int, a4: int,\n                     a5: ptr Timespec): cint {.importc, header: \"<mqueue.h>\".}\n  proc mq_unlink*(a1: cstring): cint {.importc, header: \"<mqueue.h>\".}\n\n\nproc getpwnam*(a1: cstring): ptr Passwd {.importc, header: \"<pwd.h>\".}\nproc getpwuid*(a1: Uid): ptr Passwd {.importc, header: \"<pwd.h>\".}\nproc getpwnam_r*(a1: cstring, a2: ptr Passwd, a3: cstring, a4: int,\n                 a5: ptr ptr Passwd): cint {.importc, header: \"<pwd.h>\".}\nproc getpwuid_r*(a1: Uid, a2: ptr Passwd, a3: cstring,\n      a4: int, a5: ptr ptr Passwd): cint {.importc, header: \"<pwd.h>\".}\nproc endpwent*() {.importc, header: \"<pwd.h>\".}\nproc getpwent*(): ptr Passwd {.importc, header: \"<pwd.h>\".}\nproc setpwent*() {.importc, header: \"<pwd.h>\".}\n\nproc uname*(a1: var Utsname): cint {.importc, header: \"<sys/utsname.h>\".}\n\nproc strerror*(errnum: cint): cstring {.importc, header: \"<string.h>\".}\n\nproc pthread_atfork*(a1, a2, a3: proc () {.noconv.}): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_destroy*(a1: ptr Pthread_attr): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_getdetachstate*(a1: ptr Pthread_attr, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_getguardsize*(a1: ptr Pthread_attr, a2: var cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_getinheritsched*(a1: ptr Pthread_attr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getschedparam*(a1: ptr Pthread_attr,\n          a2: ptr Sched_param): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getschedpolicy*(a1: ptr Pthread_attr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getscope*(a1: ptr Pthread_attr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getstack*(a1: ptr Pthread_attr,\n         a2: var pointer, a3: var int): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getstackaddr*(a1: ptr Pthread_attr,\n          a2: var pointer): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_getstacksize*(a1: ptr Pthread_attr,\n          a2: var int): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_init*(a1: ptr Pthread_attr): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setdetachstate*(a1: ptr Pthread_attr, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setguardsize*(a1: ptr Pthread_attr, a2: int): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setinheritsched*(a1: ptr Pthread_attr, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setschedparam*(a1: ptr Pthread_attr,\n          a2: ptr Sched_param): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_attr_setschedpolicy*(a1: ptr Pthread_attr, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setscope*(a1: ptr Pthread_attr, a2: cint): cint {.importc,\n  header: \"<pthread.h>\".}\nproc pthread_attr_setstack*(a1: ptr Pthread_attr, a2: pointer, a3: int): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setstackaddr*(a1: ptr Pthread_attr, a2: pointer): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_attr_setstacksize*(a1: ptr Pthread_attr, a2: int): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_barrier_destroy*(a1: ptr Pthread_barrier): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_barrier_init*(a1: ptr Pthread_barrier,\n         a2: ptr Pthread_barrierattr, a3: cint): cint {.\n         importc, header: \"<pthread.h>\".}\nproc pthread_barrier_wait*(a1: ptr Pthread_barrier): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_barrierattr_destroy*(a1: ptr Pthread_barrierattr): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_barrierattr_getpshared*(\n          a1: ptr Pthread_barrierattr, a2: var cint): cint {.\n          importc, header: \"<pthread.h>\".}\nproc pthread_barrierattr_init*(a1: ptr Pthread_barrierattr): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_barrierattr_setpshared*(a1: ptr Pthread_barrierattr,\n  a2: cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_cancel*(a1: Pthread): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_cleanup_push*(a1: proc (x: pointer) {.noconv.}, a2: pointer) {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_cleanup_pop*(a1: cint) {.importc, header: \"<pthread.h>\".}\nproc pthread_cond_broadcast*(a1: ptr Pthread_cond): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_cond_destroy*(a1: ptr Pthread_cond): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_cond_init*(a1: ptr Pthread_cond,\n          a2: ptr Pthread_condattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_cond_signal*(a1: ptr Pthread_cond): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_cond_timedwait*(a1: ptr Pthread_cond,\n          a2: ptr Pthread_mutex, a3: ptr Timespec): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_cond_wait*(a1: ptr Pthread_cond,\n          a2: ptr Pthread_mutex): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_condattr_destroy*(a1: ptr Pthread_condattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_condattr_getclock*(a1: ptr Pthread_condattr,\n          a2: var ClockId): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_condattr_getpshared*(a1: ptr Pthread_condattr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_condattr_init*(a1: ptr Pthread_condattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_condattr_setclock*(a1: ptr Pthread_condattr,a2: ClockId): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_condattr_setpshared*(a1: ptr Pthread_condattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_create*(a1: ptr Pthread, a2: ptr Pthread_attr,\n          a3: proc (x: pointer): pointer {.noconv.}, a4: pointer): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_detach*(a1: Pthread): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_equal*(a1, a2: Pthread): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_exit*(a1: pointer) {.importc, header: \"<pthread.h>\".}\nproc pthread_getconcurrency*(): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_getcpuclockid*(a1: Pthread, a2: var ClockId): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_getschedparam*(a1: Pthread,  a2: var cint,\n          a3: ptr Sched_param): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_getspecific*(a1: Pthread_key): pointer {.importc, header: \"<pthread.h>\".}\nproc pthread_join*(a1: Pthread, a2: ptr pointer): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_key_create*(a1: ptr Pthread_key, a2: proc (x: pointer) {.noconv.}): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_key_delete*(a1: Pthread_key): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_mutex_destroy*(a1: ptr Pthread_mutex): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_getprioceiling*(a1: ptr Pthread_mutex,\n         a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_init*(a1: ptr Pthread_mutex,\n          a2: ptr Pthread_mutexattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_lock*(a1: ptr Pthread_mutex): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_setprioceiling*(a1: ptr Pthread_mutex,a2: cint,\n          a3: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_timedlock*(a1: ptr Pthread_mutex,\n          a2: ptr Timespec): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_trylock*(a1: ptr Pthread_mutex): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutex_unlock*(a1: ptr Pthread_mutex): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_destroy*(a1: ptr Pthread_mutexattr): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_mutexattr_getprioceiling*(\n          a1: ptr Pthread_mutexattr, a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_getprotocol*(a1: ptr Pthread_mutexattr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_getpshared*(a1: ptr Pthread_mutexattr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_gettype*(a1: ptr Pthread_mutexattr,\n          a2: var cint): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_mutexattr_init*(a1: ptr Pthread_mutexattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_setprioceiling*(a1: ptr Pthread_mutexattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_setprotocol*(a1: ptr Pthread_mutexattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_setpshared*(a1: ptr Pthread_mutexattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_mutexattr_settype*(a1: ptr Pthread_mutexattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_once*(a1: ptr Pthread_once, a2: proc () {.noconv.}): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_rwlock_destroy*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_init*(a1: ptr Pthread_rwlock,\n          a2: ptr Pthread_rwlockattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_rdlock*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_timedrdlock*(a1: ptr Pthread_rwlock,\n          a2: ptr Timespec): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_timedwrlock*(a1: ptr Pthread_rwlock,\n          a2: ptr Timespec): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_rwlock_tryrdlock*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_trywrlock*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_unlock*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlock_wrlock*(a1: ptr Pthread_rwlock): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlockattr_destroy*(a1: ptr Pthread_rwlockattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlockattr_getpshared*(\n          a1: ptr Pthread_rwlockattr, a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlockattr_init*(a1: ptr Pthread_rwlockattr): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_rwlockattr_setpshared*(a1: ptr Pthread_rwlockattr, a2: cint): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_self*(): Pthread {.importc, header: \"<pthread.h>\".}\nproc pthread_setcancelstate*(a1: cint, a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_setcanceltype*(a1: cint, a2: var cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_setconcurrency*(a1: cint): cint {.importc, header: \"<pthread.h>\".}\nproc pthread_setschedparam*(a1: Pthread, a2: cint,\n          a3: ptr Sched_param): cint {.importc, header: \"<pthread.h>\".}\n\nproc pthread_setschedprio*(a1: Pthread, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_setspecific*(a1: Pthread_key, a2: pointer): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_spin_destroy*(a1: ptr Pthread_spinlock): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_spin_init*(a1: ptr Pthread_spinlock, a2: cint): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_spin_lock*(a1: ptr Pthread_spinlock): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_spin_trylock*(a1: ptr Pthread_spinlock): cint{.\n  importc, header: \"<pthread.h>\".}\nproc pthread_spin_unlock*(a1: ptr Pthread_spinlock): cint {.\n  importc, header: \"<pthread.h>\".}\nproc pthread_testcancel*() {.importc, header: \"<pthread.h>\".}\n\n\nproc exitnow*(code: int): void {.importc: \"_exit\", header: \"<unistd.h>\".}\nproc access*(a1: cstring, a2: cint): cint {.importc, header: \"<unistd.h>\".}\nproc alarm*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc chdir*(a1: cstring): cint {.importc, header: \"<unistd.h>\".}\nproc chown*(a1: cstring, a2: Uid, a3: Gid): cint {.importc, header: \"<unistd.h>\".}\nproc close*(a1: cint | SocketHandle): cint {.importc, header: \"<unistd.h>\".}\nproc confstr*(a1: cint, a2: cstring, a3: int): int {.importc, header: \"<unistd.h>\".}\nproc crypt*(a1, a2: cstring): cstring {.importc, header: \"<unistd.h>\".}\nproc ctermid*(a1: cstring): cstring {.importc, header: \"<unistd.h>\".}\nproc dup*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc dup2*(a1, a2: cint): cint {.importc, header: \"<unistd.h>\".}\nproc encrypt*(a1: array[0..63, char], a2: cint) {.importc, header: \"<unistd.h>\".}\n\nproc execl*(a1, a2: cstring): cint {.varargs, importc, header: \"<unistd.h>\", sideEffect.}\nproc execle*(a1, a2: cstring): cint {.varargs, importc, header: \"<unistd.h>\", sideEffect.}\nproc execlp*(a1, a2: cstring): cint {.varargs, importc, header: \"<unistd.h>\", sideEffect.}\nproc execv*(a1: cstring, a2: cstringArray): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc execve*(a1: cstring, a2, a3: cstringArray): cint {.\n  importc, header: \"<unistd.h>\", sideEffect.}\nproc execvp*(a1: cstring, a2: cstringArray): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc execvpe*(a1: cstring, a2: cstringArray, a3: cstringArray): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc fchown*(a1: cint, a2: Uid, a3: Gid): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc fchdir*(a1: cint): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc fdatasync*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc fork*(): Pid {.importc, header: \"<unistd.h>\", sideEffect.}\nproc fpathconf*(a1, a2: cint): int {.importc, header: \"<unistd.h>\".}\nproc fsync*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\n ## synchronize a file's buffer cache to the storage device\n\nproc ftruncate*(a1: cint, a2: Off): cint {.importc, header: \"<unistd.h>\".}\nproc getcwd*(a1: cstring, a2: int): cstring {.importc, header: \"<unistd.h>\", sideEffect.}\nproc getuid*(): Uid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the real user ID of the calling process\n\nproc geteuid*(): Uid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the effective user ID of the calling process\n\nproc getgid*(): Gid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the real group ID of the calling process\n\nproc getegid*(): Gid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the effective group ID of the calling process\n\nproc getgroups*(a1: cint, a2: ptr array[0..255, Gid]): cint {.\n  importc, header: \"<unistd.h>\".}\nproc gethostid*(): int {.importc, header: \"<unistd.h>\", sideEffect.}\nproc gethostname*(a1: cstring, a2: int): cint {.importc, header: \"<unistd.h>\", sideEffect.}\nproc getlogin*(): cstring {.importc, header: \"<unistd.h>\", sideEffect.}\nproc getlogin_r*(a1: cstring, a2: int): cint {.importc, header: \"<unistd.h>\", sideEffect.}\n\nproc getopt*(a1: cint, a2: cstringArray, a3: cstring): cint {.\n  importc, header: \"<unistd.h>\".}\nproc getpgid*(a1: Pid): Pid {.importc, header: \"<unistd.h>\".}\nproc getpgrp*(): Pid {.importc, header: \"<unistd.h>\".}\nproc getpid*(): Pid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns  the process ID (PID) of the calling process\n\nproc getppid*(): Pid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the process ID of the parent of the calling process\n\nproc getsid*(a1: Pid): Pid {.importc, header: \"<unistd.h>\", sideEffect.}\n ## returns the session ID of the calling process\n\nproc getwd*(a1: cstring): cstring {.importc, header: \"<unistd.h>\".}\nproc isatty*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc lchown*(a1: cstring, a2: Uid, a3: Gid): cint {.importc, header: \"<unistd.h>\".}\nproc link*(a1, a2: cstring): cint {.importc, header: \"<unistd.h>\".}\n\nproc lockf*(a1, a2: cint, a3: Off): cint {.importc, header: \"<unistd.h>\".}\nproc lseek*(a1: cint, a2: Off, a3: cint): Off {.importc, header: \"<unistd.h>\".}\nproc nice*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc pathconf*(a1: cstring, a2: cint): int {.importc, header: \"<unistd.h>\".}\n\nproc pause*(): cint {.importc, header: \"<unistd.h>\".}\nproc pclose*(a: File): cint {.importc, header: \"<stdio.h>\".}\nproc pipe*(a: array[0..1, cint]): cint {.importc, header: \"<unistd.h>\".}\nproc popen*(a1, a2: cstring): File {.importc, header: \"<stdio.h>\".}\nproc pread*(a1: cint, a2: pointer, a3: int, a4: Off): int {.\n  importc, header: \"<unistd.h>\".}\nproc pwrite*(a1: cint, a2: pointer, a3: int, a4: Off): int {.\n  importc, header: \"<unistd.h>\".}\nproc read*(a1: cint, a2: pointer, a3: int): int {.importc, header: \"<unistd.h>\".}\nproc readlink*(a1, a2: cstring, a3: int): int {.importc, header: \"<unistd.h>\".}\nproc ioctl*(f: FileHandle, device: uint): int {.importc: \"ioctl\",\n      header: \"<sys/ioctl.h>\", varargs, tags: [WriteIOEffect].}\n  ## A system call for device-specific input/output operations and other\n  ## operations which cannot be expressed by regular system calls\n\nproc rmdir*(a1: cstring): cint {.importc, header: \"<unistd.h>\".}\nproc setegid*(a1: Gid): cint {.importc, header: \"<unistd.h>\".}\nproc seteuid*(a1: Uid): cint {.importc, header: \"<unistd.h>\".}\nproc setgid*(a1: Gid): cint {.importc, header: \"<unistd.h>\".}\n\nproc setpgid*(a1, a2: Pid): cint {.importc, header: \"<unistd.h>\".}\nproc setpgrp*(): Pid {.importc, header: \"<unistd.h>\".}\nproc setregid*(a1, a2: Gid): cint {.importc, header: \"<unistd.h>\".}\nproc setreuid*(a1, a2: Uid): cint {.importc, header: \"<unistd.h>\".}\nproc setsid*(): Pid {.importc, header: \"<unistd.h>\".}\nproc setuid*(a1: Uid): cint {.importc, header: \"<unistd.h>\".}\nproc sleep*(a1: cint): cint {.importc, header: \"<unistd.h>\".}\nproc swab*(a1, a2: pointer, a3: int) {.importc, header: \"<unistd.h>\".}\nproc symlink*(a1, a2: cstring): cint {.importc, header: \"<unistd.h>\".}\nproc sync*() {.importc, header: \"<unistd.h>\".}\nproc sysconf*(a1: cint): int {.importc, header: \"<unistd.h>\".}\nproc tcgetpgrp*(a1: cint): Pid {.importc, header: \"<unistd.h>\".}\nproc tcsetpgrp*(a1: cint, a2: Pid): cint {.importc, header: \"<unistd.h>\".}\nproc truncate*(a1: cstring, a2: Off): cint {.importc, header: \"<unistd.h>\".}\nproc ttyname*(a1: cint): cstring {.importc, header: \"<unistd.h>\".}\nproc ttyname_r*(a1: cint, a2: cstring, a3: int): cint {.\n  importc, header: \"<unistd.h>\".}\nproc ualarm*(a1, a2: Useconds): Useconds {.importc, header: \"<unistd.h>\".}\nproc unlink*(a1: cstring): cint {.importc, header: \"<unistd.h>\".}\nproc usleep*(a1: Useconds): cint {.importc, header: \"<unistd.h>\".}\nproc vfork*(): Pid {.importc, header: \"<unistd.h>\".}\nproc write*(a1: cint, a2: pointer, a3: int): int {.importc, header: \"<unistd.h>\".}\n\nproc sem_close*(a1: ptr Sem): cint {.importc, header: \"<semaphore.h>\".}\nproc sem_destroy*(a1: ptr Sem): cint {.importc, header: \"<semaphore.h>\".}\nproc sem_getvalue*(a1: ptr Sem, a2: var cint): cint {.\n  importc, header: \"<semaphore.h>\".}\nproc sem_init*(a1: ptr Sem, a2: cint, a3: cint): cint {.\n  importc, header: \"<semaphore.h>\".}\nproc sem_open*(a1: cstring, a2: cint): ptr Sem {.\n  varargs, importc, header: \"<semaphore.h>\".}\nproc sem_post*(a1: ptr Sem): cint {.importc, header: \"<semaphore.h>\".}\nproc sem_timedwait*(a1: ptr Sem, a2: ptr Timespec): cint {.\n  importc, header: \"<semaphore.h>\".}\nproc sem_trywait*(a1: ptr Sem): cint {.importc, header: \"<semaphore.h>\".}\nproc sem_unlink*(a1: cstring): cint {.importc, header: \"<semaphore.h>\".}\nproc sem_wait*(a1: ptr Sem): cint {.importc, header: \"<semaphore.h>\".}\n\nproc ftok*(a1: cstring, a2: cint): Key {.importc, header: \"<sys/ipc.h>\".}\n\nproc statvfs*(a1: cstring, a2: var Statvfs): cint {.\n  importc, header: \"<sys/statvfs.h>\".}\nproc fstatvfs*(a1: cint, a2: var Statvfs): cint {.\n  importc, header: \"<sys/statvfs.h>\".}\n\nproc chmod*(a1: cstring, a2: Mode): cint {.importc, header: \"<sys/stat.h>\", sideEffect.}\nproc fchmod*(a1: cint, a2: Mode): cint {.importc, header: \"<sys/stat.h>\", sideEffect.}\nproc fstat*(a1: cint, a2: var Stat): cint {.importc, header: \"<sys/stat.h>\", sideEffect.}\nproc lstat*(a1: cstring, a2: var Stat): cint {.importc, header: \"<sys/stat.h>\", sideEffect.}\nproc mkdir*(a1: cstring, a2: Mode): cint {.importc, header: \"<sys/stat.h>\", sideEffect.}\n  ## Use `os.createDir() <os.html#createDir,string>`_ and similar.\n\nproc mkfifo*(a1: cstring, a2: Mode): cint {.importc, header: \"<sys/stat.h>\".}\nproc mknod*(a1: cstring, a2: Mode, a3: Dev): cint {.\n  importc, header: \"<sys/stat.h>\".}\nproc stat*(a1: cstring, a2: var Stat): cint {.importc, header: \"<sys/stat.h>\".}\nproc umask*(a1: Mode): Mode {.importc, header: \"<sys/stat.h>\".}\n\nproc S_ISBLK*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a block special file.\nproc S_ISCHR*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a character special file.\nproc S_ISDIR*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a directory.\nproc S_ISFIFO*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a pipe or FIFO special file.\nproc S_ISREG*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a regular file.\nproc S_ISLNK*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a symbolic link.\nproc S_ISSOCK*(m: Mode): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a socket.\n\nproc S_TYPEISMQ*(buf: var Stat): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a message queue.\nproc S_TYPEISSEM*(buf: var Stat): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a semaphore.\nproc S_TYPEISSHM*(buf: var Stat): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test for a shared memory object.\n\nproc S_TYPEISTMO*(buf: var Stat): bool {.importc, header: \"<sys/stat.h>\".}\n  ## Test macro for a typed memory object.\n\nproc mlock*(a1: pointer, a2: int): cint {.importc, header: \"<sys/mman.h>\".}\nproc mlockall*(a1: cint): cint {.importc, header: \"<sys/mman.h>\".}\nproc mmap*(a1: pointer, a2: int, a3, a4, a5: cint, a6: Off): pointer {.\n  importc, header: \"<sys/mman.h>\".}\nproc mprotect*(a1: pointer, a2: int, a3: cint): cint {.\n  importc, header: \"<sys/mman.h>\".}\nproc msync*(a1: pointer, a2: int, a3: cint): cint {.importc, header: \"<sys/mman.h>\".}\n\nproc munlock*(a1: pointer, a2: int): cint {.importc, header: \"<sys/mman.h>\".}\nproc munlockall*(): cint {.importc, header: \"<sys/mman.h>\".}\nproc munmap*(a1: pointer, a2: int): cint {.importc, header: \"<sys/mman.h>\".}\nproc posix_madvise*(a1: pointer, a2: int, a3: cint): cint {.\n  importc, header: \"<sys/mman.h>\".}\nproc posix_mem_offset*(a1: pointer, a2: int, a3: var Off,\n           a4: var int, a5: var cint): cint {.importc, header: \"<sys/mman.h>\".}\nwhen not (defined(linux) and defined(amd64)) and not defined(nintendoswitch) and\n     not defined(haiku):\n  proc posix_typed_mem_get_info*(a1: cint,\n    a2: var Posix_typed_mem_info): cint {.importc, header: \"<sys/mman.h>\".}\nproc posix_typed_mem_open*(a1: cstring, a2, a3: cint): cint {.\n  importc, header: \"<sys/mman.h>\".}\nproc shm_open*(a1: cstring, a2: cint, a3: Mode): cint {.\n  importc, header: \"<sys/mman.h>\".}\nproc shm_unlink*(a1: cstring): cint {.importc, header: \"<sys/mman.h>\".}\n\nproc asctime*(a1: var Tm): cstring{.importc, header: \"<time.h>\".}\n\nproc asctime_r*(a1: var Tm, a2: cstring): cstring {.importc, header: \"<time.h>\".}\nproc clock*(): Clock {.importc, header: \"<time.h>\", sideEffect.}\nproc clock_getcpuclockid*(a1: Pid, a2: var ClockId): cint {.\n  importc, header: \"<time.h>\", sideEffect.}\nproc clock_getres*(a1: ClockId, a2: var Timespec): cint {.\n  importc, header: \"<time.h>\", sideEffect.}\nproc clock_gettime*(a1: ClockId, a2: var Timespec): cint {.\n  importc, header: \"<time.h>\", sideEffect.}\nproc clock_nanosleep*(a1: ClockId, a2: cint, a3: var Timespec,\n               a4: var Timespec): cint {.importc, header: \"<time.h>\", sideEffect.}\nproc clock_settime*(a1: ClockId, a2: var Timespec): cint {.\n  importc, header: \"<time.h>\", sideEffect.}\n\nproc `==`*(a, b: Time): bool {.borrow.}\nproc `-`*(a, b: Time): Time {.borrow.}\nproc ctime*(a1: var Time): cstring {.importc, header: \"<time.h>\".}\nproc ctime_r*(a1: var Time, a2: cstring): cstring {.importc, header: \"<time.h>\".}\nproc difftime*(a1, a2: Time): cdouble {.importc, header: \"<time.h>\".}\nproc getdate*(a1: cstring): ptr Tm {.importc, header: \"<time.h>\".}\nproc gmtime*(a1: var Time): ptr Tm {.importc, header: \"<time.h>\".}\nproc gmtime_r*(a1: var Time, a2: var Tm): ptr Tm {.importc, header: \"<time.h>\".}\nproc localtime*(a1: var Time): ptr Tm {.importc, header: \"<time.h>\".}\nproc localtime_r*(a1: var Time, a2: var Tm): ptr Tm {.importc, header: \"<time.h>\".}\nproc mktime*(a1: var Tm): Time  {.importc, header: \"<time.h>\".}\nproc timegm*(a1: var Tm): Time  {.importc, header: \"<time.h>\".}\nproc nanosleep*(a1, a2: var Timespec): cint {.importc, header: \"<time.h>\", sideEffect.}\nproc strftime*(a1: cstring, a2: int, a3: cstring,\n           a4: var Tm): int {.importc, header: \"<time.h>\".}\nproc strptime*(a1, a2: cstring, a3: var Tm): cstring {.importc, header: \"<time.h>\".}\nproc time*(a1: var Time): Time {.importc, header: \"<time.h>\", sideEffect.}\nproc timer_create*(a1: ClockId, a2: var SigEvent,\n               a3: var Timer): cint {.importc, header: \"<time.h>\".}\nproc timer_delete*(a1: Timer): cint {.importc, header: \"<time.h>\".}\nproc timer_gettime*(a1: Timer, a2: var Itimerspec): cint {.\n  importc, header: \"<time.h>\".}\nproc timer_getoverrun*(a1: Timer): cint {.importc, header: \"<time.h>\".}\nproc timer_settime*(a1: Timer, a2: cint, a3: var Itimerspec,\n               a4: var Itimerspec): cint {.importc, header: \"<time.h>\".}\nproc tzset*() {.importc, header: \"<time.h>\".}\n\n\nproc wait*(a1: ptr cint): Pid {.importc, discardable, header: \"<sys/wait.h>\", sideEffect.}\nproc waitid*(a1: cint, a2: Id, a3: var SigInfo, a4: cint): cint {.\n  importc, header: \"<sys/wait.h>\", sideEffect.}\nproc waitpid*(a1: Pid, a2: var cint, a3: cint): Pid {.\n  importc, header: \"<sys/wait.h>\", sideEffect.}\n\ntype Rusage* {.importc: \"struct rusage\", header: \"<sys/resource.h>\",\n               bycopy.} = object\n  ru_utime*, ru_stime*: Timeval                       # User and system time\n  ru_maxrss*, ru_ixrss*, ru_idrss*, ru_isrss*,        # memory sizes\n    ru_minflt*, ru_majflt*, ru_nswap*,                # paging activity\n    ru_inblock*, ru_oublock*, ru_msgsnd*, ru_msgrcv*, # IO activity\n    ru_nsignals*, ru_nvcsw*, ru_nivcsw*: clong        # switching activity\n\nproc wait4*(pid: Pid, status: ptr cint, options: cint, rusage: ptr Rusage): Pid\n  {.importc, header: \"<sys/wait.h>\", sideEffect.}\n\nconst\n  RUSAGE_SELF* = cint(0)\n  RUSAGE_CHILDREN* = cint(-1)\n  RUSAGE_THREAD* = cint(1)    # This one is less std; Linux, BSD agree though.\n\n# This can only fail if `who` is invalid or `rusage` ptr is invalid.\nproc getrusage*(who: cint, rusage: ptr Rusage): cint\n  {.importc, header: \"<sys/resource.h>\", discardable.}\n\nproc bsd_signal*(a1: cint, a2: proc (x: pointer) {.noconv.}) {.\n  importc, header: \"<signal.h>\".}\nproc kill*(a1: Pid, a2: cint): cint {.importc, header: \"<signal.h>\", sideEffect.}\nproc killpg*(a1: Pid, a2: cint): cint {.importc, header: \"<signal.h>\", sideEffect.}\nproc pthread_kill*(a1: Pthread, a2: cint): cint {.importc, header: \"<signal.h>\".}\nproc pthread_sigmask*(a1: cint, a2, a3: var Sigset): cint {.\n  importc, header: \"<signal.h>\".}\nproc `raise`*(a1: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigaction*(a1: cint, a2, a3: var Sigaction): cint {.\n  importc, header: \"<signal.h>\".}\n\nproc sigaction*(a1: cint, a2: var Sigaction; a3: ptr Sigaction = nil): cint {.\n  importc, header: \"<signal.h>\".}\n\nproc sigaddset*(a1: var Sigset, a2: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigaltstack*(a1, a2: var Stack): cint {.importc, header: \"<signal.h>\".}\nproc sigdelset*(a1: var Sigset, a2: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigemptyset*(a1: var Sigset): cint {.importc, header: \"<signal.h>\".}\nproc sigfillset*(a1: var Sigset): cint {.importc, header: \"<signal.h>\".}\nproc sighold*(a1: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigignore*(a1: cint): cint {.importc, header: \"<signal.h>\".}\nproc siginterrupt*(a1, a2: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigismember*(a1: var Sigset, a2: cint): cint {.importc, header: \"<signal.h>\".}\nproc signal*(a1: cint, a2: Sighandler) {.\n  importc, header: \"<signal.h>\".}\nproc sigpause*(a1: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigpending*(a1: var Sigset): cint {.importc, header: \"<signal.h>\".}\nproc sigprocmask*(a1: cint, a2, a3: var Sigset): cint {.\n  importc, header: \"<signal.h>\".}\nproc sigqueue*(a1: Pid, a2: cint, a3: SigVal): cint {.\n  importc, header: \"<signal.h>\".}\nproc sigrelse*(a1: cint): cint {.importc, header: \"<signal.h>\".}\nproc sigset*(a1: int, a2: proc (x: cint) {.noconv.}) {.\n  importc, header: \"<signal.h>\".}\nproc sigsuspend*(a1: var Sigset): cint {.importc, header: \"<signal.h>\".}\n\nwhen defined(android):\n  proc syscall(arg: clong): clong {.varargs, importc: \"syscall\", header: \"<unistd.h>\".}\n  var NR_rt_sigtimedwait {.importc: \"__NR_rt_sigtimedwait\", header: \"<sys/syscall.h>\".}: clong\n  var NSIGMAX {.importc: \"NSIG\", header: \"<signal.h>\".}: clong\n\n  proc sigtimedwait*(a1: var Sigset, a2: var SigInfo, a3: var Timespec): cint =\n    result = cint(syscall(NR_rt_sigtimedwait, addr(a1), addr(a2), addr(a3), NSIGMAX div 8))\nelse:\n  proc sigtimedwait*(a1: var Sigset, a2: var SigInfo,\n                     a3: var Timespec): cint {.importc, header: \"<signal.h>\".}\n\nproc sigwait*(a1: var Sigset, a2: var cint): cint {.\n  importc, header: \"<signal.h>\".}\nproc sigwaitinfo*(a1: var Sigset, a2: var SigInfo): cint {.\n  importc, header: \"<signal.h>\".}\n\nwhen not defined(nintendoswitch):\n  proc catclose*(a1: Nl_catd): cint {.importc, header: \"<nl_types.h>\".}\n  proc catgets*(a1: Nl_catd, a2, a3: cint, a4: cstring): cstring {.\n    importc, header: \"<nl_types.h>\".}\n  proc catopen*(a1: cstring, a2: cint): Nl_catd {.\n    importc, header: \"<nl_types.h>\".}\n\nproc sched_get_priority_max*(a1: cint): cint {.importc, header: \"<sched.h>\".}\nproc sched_get_priority_min*(a1: cint): cint {.importc, header: \"<sched.h>\".}\nproc sched_getparam*(a1: Pid, a2: var Sched_param): cint {.\n  importc, header: \"<sched.h>\".}\nproc sched_getscheduler*(a1: Pid): cint {.importc, header: \"<sched.h>\".}\nproc sched_rr_get_interval*(a1: Pid, a2: var Timespec): cint {.\n  importc, header: \"<sched.h>\".}\nproc sched_setparam*(a1: Pid, a2: var Sched_param): cint {.\n  importc, header: \"<sched.h>\".}\nproc sched_setscheduler*(a1: Pid, a2: cint, a3: var Sched_param): cint {.\n  importc, header: \"<sched.h>\".}\nproc sched_yield*(): cint {.importc, header: \"<sched.h>\".}\n\nproc hstrerror*(herrnum: cint): cstring {.importc:\"(char *)$1\", header: \"<netdb.h>\".}\n\nproc FD_CLR*(a1: cint, a2: var TFdSet) {.importc, header: \"<sys/select.h>\".}\nproc FD_ISSET*(a1: cint | SocketHandle, a2: var TFdSet): cint {.\n  importc, header: \"<sys/select.h>\".}\nproc FD_SET*(a1: cint | SocketHandle, a2: var TFdSet) {.\n  importc: \"FD_SET\", header: \"<sys/select.h>\".}\nproc FD_ZERO*(a1: var TFdSet) {.importc, header: \"<sys/select.h>\".}\n\nproc pselect*(a1: cint, a2, a3, a4: ptr TFdSet, a5: ptr Timespec,\n         a6: var Sigset): cint  {.importc, header: \"<sys/select.h>\".}\nproc select*(a1: cint | SocketHandle, a2, a3, a4: ptr TFdSet, a5: ptr Timeval): cint {.\n             importc, header: \"<sys/select.h>\".}\n\nwhen hasSpawnH:\n  proc posix_spawn*(a1: var Pid, a2: cstring,\n            a3: var Tposix_spawn_file_actions,\n            a4: var Tposix_spawnattr,\n            a5, a6: cstringArray): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawn_file_actions_addclose*(a1: var Tposix_spawn_file_actions,\n            a2: cint): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawn_file_actions_adddup2*(a1: var Tposix_spawn_file_actions,\n            a2, a3: cint): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawn_file_actions_addopen*(a1: var Tposix_spawn_file_actions,\n            a2: cint, a3: cstring, a4: cint, a5: Mode): cint {.\n            importc, header: \"<spawn.h>\".}\n  proc posix_spawn_file_actions_destroy*(\n    a1: var Tposix_spawn_file_actions): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawn_file_actions_init*(\n    a1: var Tposix_spawn_file_actions): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_destroy*(a1: var Tposix_spawnattr): cint {.\n    importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getsigdefault*(a1: var Tposix_spawnattr,\n            a2: var Sigset): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getflags*(a1: var Tposix_spawnattr,\n            a2: var cshort): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getpgroup*(a1: var Tposix_spawnattr,\n            a2: var Pid): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getschedparam*(a1: var Tposix_spawnattr,\n            a2: var Sched_param): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getschedpolicy*(a1: var Tposix_spawnattr,\n            a2: var cint): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_getsigmask*(a1: var Tposix_spawnattr,\n            a2: var Sigset): cint {.importc, header: \"<spawn.h>\".}\n\n  proc posix_spawnattr_init*(a1: var Tposix_spawnattr): cint {.\n    importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_setsigdefault*(a1: var Tposix_spawnattr,\n            a2: var Sigset): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_setflags*(a1: var Tposix_spawnattr, a2: cint): cint {.\n    importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_setpgroup*(a1: var Tposix_spawnattr, a2: Pid): cint {.\n    importc, header: \"<spawn.h>\".}\n\n  proc posix_spawnattr_setschedparam*(a1: var Tposix_spawnattr,\n            a2: var Sched_param): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_setschedpolicy*(a1: var Tposix_spawnattr,\n                                       a2: cint): cint {.\n                                       importc, header: \"<spawn.h>\".}\n  proc posix_spawnattr_setsigmask*(a1: var Tposix_spawnattr,\n            a2: var Sigset): cint {.importc, header: \"<spawn.h>\".}\n  proc posix_spawnp*(a1: var Pid, a2: cstring,\n            a3: var Tposix_spawn_file_actions,\n            a4: var Tposix_spawnattr,\n            a5, a6: cstringArray): cint {.importc, header: \"<spawn.h>\".}\n\nwhen not defined(nintendoswitch):\n  proc getcontext*(a1: var Ucontext): cint {.importc, header: \"<ucontext.h>\".}\n  proc makecontext*(a1: var Ucontext, a4: proc (){.noconv.}, a3: cint) {.\n    varargs, importc, header: \"<ucontext.h>\".}\n  proc setcontext*(a1: var Ucontext): cint {.importc, header: \"<ucontext.h>\".}\n  proc swapcontext*(a1, a2: var Ucontext): cint {.importc, header: \"<ucontext.h>\".}\n\nproc readv*(a1: cint, a2: ptr IOVec, a3: cint): int {.\n  importc, header: \"<sys/uio.h>\".}\nproc writev*(a1: cint, a2: ptr IOVec, a3: cint): int {.\n  importc, header: \"<sys/uio.h>\".}\n\nproc CMSG_DATA*(cmsg: ptr Tcmsghdr): cstring {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc CMSG_NXTHDR*(mhdr: ptr Tmsghdr, cmsg: ptr Tcmsghdr): ptr Tcmsghdr {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc CMSG_FIRSTHDR*(mhdr: ptr Tmsghdr): ptr Tcmsghdr {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc CMSG_SPACE*(len: csize): csize {.\n  importc, header: \"<sys/socket.h>\", deprecated: \"argument `len` should be of type `csize_t`\".}\n\nproc CMSG_SPACE*(len: csize_t): csize_t {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc CMSG_LEN*(len: csize): csize {.\n  importc, header: \"<sys/socket.h>\", deprecated: \"argument `len` should be of type `csize_t`\".}\n\nproc CMSG_LEN*(len: csize_t): csize_t {.\n  importc, header: \"<sys/socket.h>\".}\n\nconst\n  INVALID_SOCKET* = SocketHandle(-1)\n\nproc `==`*(x, y: SocketHandle): bool {.borrow.}\n\nproc accept*(a1: SocketHandle, a2: ptr SockAddr, a3: ptr SockLen): SocketHandle {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\n\nwhen defined(linux) or defined(bsd):\n  proc accept4*(a1: SocketHandle, a2: ptr SockAddr, a3: ptr SockLen,\n                flags: cint): SocketHandle {.importc, header: \"<sys/socket.h>\".}\n\nproc bindSocket*(a1: SocketHandle, a2: ptr SockAddr, a3: SockLen): cint {.\n  importc: \"bind\", header: \"<sys/socket.h>\".}\n  ## is Posix's ``bind``, because ``bind`` is a reserved word\n\nproc connect*(a1: SocketHandle, a2: ptr SockAddr, a3: SockLen): cint {.\n  importc, header: \"<sys/socket.h>\".}\nproc getpeername*(a1: SocketHandle, a2: ptr SockAddr, a3: ptr SockLen): cint {.\n  importc, header: \"<sys/socket.h>\".}\nproc getsockname*(a1: SocketHandle, a2: ptr SockAddr, a3: ptr SockLen): cint {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc getsockopt*(a1: SocketHandle, a2, a3: cint, a4: pointer, a5: ptr SockLen): cint {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc listen*(a1: SocketHandle, a2: cint): cint {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc recv*(a1: SocketHandle, a2: pointer, a3: int, a4: cint): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc recvfrom*(a1: SocketHandle, a2: pointer, a3: int, a4: cint,\n        a5: ptr SockAddr, a6: ptr SockLen): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc recvmsg*(a1: SocketHandle, a2: ptr Tmsghdr, a3: cint): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc send*(a1: SocketHandle, a2: pointer, a3: int, a4: cint): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc sendmsg*(a1: SocketHandle, a2: ptr Tmsghdr, a3: cint): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc sendto*(a1: SocketHandle, a2: pointer, a3: int, a4: cint, a5: ptr SockAddr,\n             a6: SockLen): int {.\n  importc, header: \"<sys/socket.h>\", sideEffect.}\nproc setsockopt*(a1: SocketHandle, a2, a3: cint, a4: pointer, a5: SockLen): cint {.\n  importc, header: \"<sys/socket.h>\".}\nproc shutdown*(a1: SocketHandle, a2: cint): cint {.\n  importc, header: \"<sys/socket.h>\".}\nproc socket*(a1, a2, a3: cint): SocketHandle {.\n  importc, header: \"<sys/socket.h>\".}\nproc sockatmark*(a1: cint): cint {.\n  importc, header: \"<sys/socket.h>\".}\nproc socketpair*(a1, a2, a3: cint, a4: var array[0..1, cint]): cint {.\n  importc, header: \"<sys/socket.h>\".}\n\nproc if_nametoindex*(a1: cstring): cint {.importc, header: \"<net/if.h>\".}\nproc if_indextoname*(a1: cint, a2: cstring): cstring {.\n  importc, header: \"<net/if.h>\".}\nproc if_nameindex*(): ptr Tif_nameindex {.importc, header: \"<net/if.h>\".}\nproc if_freenameindex*(a1: ptr Tif_nameindex) {.importc, header: \"<net/if.h>\".}\n\nproc IN6_IS_ADDR_UNSPECIFIED* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Unspecified address.\nproc IN6_IS_ADDR_LOOPBACK* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Loopback address.\nproc IN6_IS_ADDR_MULTICAST* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast address.\nproc IN6_IS_ADDR_LINKLOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Unicast link-local address.\nproc IN6_IS_ADDR_SITELOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Unicast site-local address.\nwhen defined(lwip):\n  proc IN6_IS_ADDR_V4MAPPED*(ipv6_address: ptr In6Addr): cint =\n    var bits32: ptr array[4, uint32] = cast[ptr array[4, uint32]](ipv6_address)\n    return (bits32[1] == 0'u32 and bits32[2] == htonl(0x0000FFFF)).cint\nelse:\n  proc IN6_IS_ADDR_V4MAPPED* (a1: ptr In6Addr): cint {.\n    importc, header: \"<netinet/in.h>\".}\n    ## IPv4 mapped address.\n\nproc IN6_IS_ADDR_V4COMPAT* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## IPv4-compatible address.\nproc IN6_IS_ADDR_MC_NODELOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast node-local address.\nproc IN6_IS_ADDR_MC_LINKLOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast link-local address.\nproc IN6_IS_ADDR_MC_SITELOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast site-local address.\nproc IN6_IS_ADDR_MC_ORGLOCAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast organization-local address.\nproc IN6_IS_ADDR_MC_GLOBAL* (a1: ptr In6Addr): cint {.\n  importc, header: \"<netinet/in.h>\".}\n  ## Multicast global address.\n\nproc endhostent*() {.importc, header: \"<netdb.h>\".}\nproc endnetent*() {.importc, header: \"<netdb.h>\".}\nproc endprotoent*() {.importc, header: \"<netdb.h>\".}\nproc endservent*() {.importc, header: \"<netdb.h>\".}\nproc freeaddrinfo*(a1: ptr AddrInfo) {.importc, header: \"<netdb.h>\".}\n\nproc gai_strerror*(a1: cint): cstring {.importc:\"(char *)$1\", header: \"<netdb.h>\".}\n\nproc getaddrinfo*(a1, a2: cstring, a3: ptr AddrInfo,\n                  a4: var ptr AddrInfo): cint {.importc, header: \"<netdb.h>\".}\n\nwhen not defined(android4):\n  proc gethostbyaddr*(a1: pointer, a2: SockLen, a3: cint): ptr Hostent {.\n                      importc, header: \"<netdb.h>\".}\nelse:\n  proc gethostbyaddr*(a1: cstring, a2: cint, a3: cint): ptr Hostent {.\n                      importc, header: \"<netdb.h>\".}\nproc gethostbyname*(a1: cstring): ptr Hostent {.importc, header: \"<netdb.h>\".}\nproc gethostent*(): ptr Hostent {.importc, header: \"<netdb.h>\".}\n\nproc getnameinfo*(a1: ptr SockAddr, a2: SockLen,\n                  a3: cstring, a4: SockLen, a5: cstring,\n                  a6: SockLen, a7: cint): cint {.importc, header: \"<netdb.h>\".}\n\nproc getnetbyaddr*(a1: int32, a2: cint): ptr Tnetent {.importc, header: \"<netdb.h>\".}\nproc getnetbyname*(a1: cstring): ptr Tnetent {.importc, header: \"<netdb.h>\".}\nproc getnetent*(): ptr Tnetent {.importc, header: \"<netdb.h>\".}\n\nproc getprotobyname*(a1: cstring): ptr Protoent {.importc, header: \"<netdb.h>\".}\nproc getprotobynumber*(a1: cint): ptr Protoent {.importc, header: \"<netdb.h>\".}\nproc getprotoent*(): ptr Protoent {.importc, header: \"<netdb.h>\".}\n\nproc getservbyname*(a1, a2: cstring): ptr Servent {.importc, header: \"<netdb.h>\".}\nproc getservbyport*(a1: cint, a2: cstring): ptr Servent {.\n  importc, header: \"<netdb.h>\".}\nproc getservent*(): ptr Servent {.importc, header: \"<netdb.h>\".}\n\nproc sethostent*(a1: cint) {.importc, header: \"<netdb.h>\".}\nproc setnetent*(a1: cint) {.importc, header: \"<netdb.h>\".}\nproc setprotoent*(a1: cint) {.importc, header: \"<netdb.h>\".}\nproc setservent*(a1: cint) {.importc, header: \"<netdb.h>\".}\n\nwhen not defined(lwip):\n  proc poll*(a1: ptr TPollfd, a2: Tnfds, a3: int): cint {.\n    importc, header: \"<poll.h>\", sideEffect.}\n\nproc realpath*(name, resolved: cstring): cstring {.\n  importc: \"realpath\", header: \"<stdlib.h>\".}\n\nproc mkstemp*(tmpl: cstring): cint {.importc, header: \"<stdlib.h>\", sideEffect.}\n  ## Creates a unique temporary file.\n  ##\n  ## **Warning**: The `tmpl` argument is written to by `mkstemp` and thus\n  ## can't be a string literal. If in doubt make a copy of the cstring before\n  ## passing it in.\n\nproc mkstemps*(tmpl: cstring, suffixlen: int): cint {.importc, header: \"<stdlib.h>\", sideEffect.}\n  ## Creates a unique temporary file.\n  ##\n  ## **Warning**: The `tmpl` argument is written to by `mkstemps` and thus\n  ## can't be a string literal. If in doubt make a copy of the cstring before\n  ## passing it in.\n\nproc mkdtemp*(tmpl: cstring): pointer {.importc, header: \"<stdlib.h>\", sideEffect.}\n\nwhen defined(linux) or defined(bsd) or defined(osx):\n  proc mkostemp*(tmpl: cstring, oflags: cint): cint {.importc, header: \"<stdlib.h>\", sideEffect.}\n  proc mkostemps*(tmpl: cstring, suffixlen: cint, oflags: cint): cint {.importc, header: \"<stdlib.h>\", sideEffect.}\n\n  proc posix_memalign*(memptr: pointer, alignment: csize_t, size: csize_t): cint {.importc, header: \"<stdlib.h>\".}\n\nproc utimes*(path: cstring, times: ptr array[2, Timeval]): int {.\n  importc: \"utimes\", header: \"<sys/time.h>\", sideEffect.}\n  ## Sets file access and modification times.\n  ##\n  ## Pass the filename and an array of times to set the access and modification\n  ## times respectively. If you pass nil as the array both attributes will be\n  ## set to the current time.\n  ##\n  ## Returns zero on success.\n  ##\n  ## For more information read http://www.unix.com/man-page/posix/3/utimes/.\n\nproc handle_signal(sig: cint, handler: proc (a: cint) {.noconv.}) {.importc: \"signal\", header: \"<signal.h>\".}\n\ntemplate onSignal*(signals: varargs[cint], body: untyped) =\n  ## Setup code to be executed when Unix signals are received. The\n  ## currently handled signal is injected as ``sig`` into the calling\n  ## scope.\n  ##\n  ## Example:\n  ##\n  ## .. code-block::\n  ##   from posix import SIGINT, SIGTERM, onSignal\n  ##   onSignal(SIGINT, SIGTERM):\n  ##     echo \"bye from signal \", sig\n\n  for s in signals:\n    handle_signal(s,\n      proc (signal: cint) {.noconv.} =\n        let sig {.inject.} = signal\n        body\n    )\n\ntype\n  RLimit* {.importc: \"struct rlimit\",\n            header: \"<sys/resource.h>\", pure, final.} = object\n    rlim_cur*: int\n    rlim_max*: int\n  ## The getrlimit() and setrlimit() system calls get and set resource limits respectively.\n  ## Each resource has an associated soft and hard limit, as defined by the RLimit structure\n\nproc setrlimit*(resource: cint, rlp: var RLimit): cint\n      {.importc: \"setrlimit\",header: \"<sys/resource.h>\".}\n  ## The setrlimit() system calls sets resource limits.\n\nproc getrlimit*(resource: cint, rlp: var RLimit): cint\n      {.importc: \"getrlimit\",header: \"<sys/resource.h>\".}\n  ## The getrlimit() system call gets resource limits.\n\nwhen defined(nimHasStyleChecks):\n  {.pop.} # {.push styleChecks: off.}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/lib/system/dyncalls.nim": "#\n#\n#            Nim's Runtime Library\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n# This file implements the ability to call native procs from libraries.\n# It is not possible to do this in a platform independent way, unfortunately.\n# However, the interface has been designed to take platform differences into\n# account and been ported to all major platforms.\n\n{.push stack_trace: off.}\n\nconst\n  NilLibHandle: LibHandle = nil\n\nproc nimLoadLibraryError(path: string) =\n  # carefully written to avoid memory allocation:\n  const prefix = \"could not load: \"\n  cstderr.rawWrite(prefix)\n  cstderr.rawWrite(path)\n  when not defined(nimDebugDlOpen) and not defined(windows):\n    cstderr.rawWrite(\"\\n(compile with -d:nimDebugDlOpen for more information)\")\n  when defined(windows):\n    const badExe = \"\\n(bad format; library may be wrong architecture)\"\n    let loadError = GetLastError()\n    if loadError == ERROR_BAD_EXE_FORMAT:\n      cstderr.rawWrite(badExe)\n    when defined(guiapp):\n      # Because console output is not shown in GUI apps, display the error as a\n      # message box instead:\n      var\n        msg: array[1000, char]\n        msgLeft = msg.len - 1 # leave (at least) one for nullchar\n        msgIdx = 0\n      copyMem(msg[msgIdx].addr, prefix.cstring, prefix.len)\n      msgLeft -= prefix.len\n      msgIdx += prefix.len\n      let pathLen = min(path.len, msgLeft)\n      copyMem(msg[msgIdx].addr, path.cstring, pathLen)\n      msgLeft -= pathLen\n      msgIdx += pathLen\n      if loadError == ERROR_BAD_EXE_FORMAT and msgLeft >= badExe.len:\n        copyMem(msg[msgIdx].addr, badExe.cstring, badExe.len)\n      discard MessageBoxA(nil, msg[0].addr, nil, 0)\n  cstderr.rawWrite(\"\\n\")\n  quit(1)\n\nproc procAddrError(name: cstring) {.compilerproc, nonReloadable, hcrInline.} =\n  # carefully written to avoid memory allocation:\n  cstderr.rawWrite(\"could not import: \")\n  cstderr.rawWrite(name)\n  cstderr.rawWrite(\"\\n\")\n  quit(1)\n\n# this code was inspired from Lua's source code:\n# Lua - An Extensible Extension Language\n# Tecgraf: Computer Graphics Technology Group, PUC-Rio, Brazil\n# http://www.lua.org\n# mailto:info@lua.org\n\nwhen defined(posix):\n  #\n  # =========================================================================\n  # This is an implementation based on the dlfcn interface.\n  # The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n  # NetBSD, AIX 4.2, HPUX 11, and probably most other Unix flavors, at least\n  # as an emulation layer on top of native functions.\n  # =========================================================================\n  #\n\n  # c stuff:\n  when defined(linux) or defined(macosx):\n    const RTLD_NOW = cint(2)\n  else:\n    var\n      RTLD_NOW {.importc: \"RTLD_NOW\", header: \"<dlfcn.h>\".}: cint\n\n  proc dlclose(lib: LibHandle) {.importc, header: \"<dlfcn.h>\".}\n  proc dlopen(path: cstring, mode: cint): LibHandle {.\n      importc, header: \"<dlfcn.h>\".}\n  proc dlsym(lib: LibHandle, name: cstring): ProcAddr {.\n      importc, header: \"<dlfcn.h>\".}\n\n  proc dlerror(): cstring {.importc, header: \"<dlfcn.h>\".}\n\n  proc nimUnloadLibrary(lib: LibHandle) =\n    dlclose(lib)\n\n  proc nimLoadLibrary(path: string): LibHandle =\n    let flags =\n      when defined(globalSymbols): RTLD_NOW or RTLD_GLOBAL\n      else: RTLD_NOW\n    result = dlopen(path, flags)\n    when defined(nimDebugDlOpen):\n      let error = dlerror()\n      if error != nil:\n        cstderr.rawWrite(error)\n        cstderr.rawWrite(\"\\n\")\n\n  proc nimGetProcAddr(lib: LibHandle, name: cstring): ProcAddr =\n    result = dlsym(lib, name)\n    if result == nil: procAddrError(name)\n\nelif defined(windows) or defined(dos):\n  #\n  # =======================================================================\n  # Native Windows Implementation\n  # =======================================================================\n  #\n  when defined(cpp):\n    type\n      THINSTANCE {.importc: \"HINSTANCE\".} = object\n        x: pointer\n    proc getProcAddress(lib: THINSTANCE, name: cstring): ProcAddr {.\n        importcpp: \"(void*)GetProcAddress(@)\", header: \"<windows.h>\", stdcall.}\n  else:\n    type\n      THINSTANCE {.importc: \"HINSTANCE\".} = pointer\n    proc getProcAddress(lib: THINSTANCE, name: cstring): ProcAddr {.\n        importc: \"GetProcAddress\", header: \"<windows.h>\", stdcall.}\n\n  proc freeLibrary(lib: THINSTANCE) {.\n      importc: \"FreeLibrary\", header: \"<windows.h>\", stdcall.}\n  proc winLoadLibrary(path: cstring): THINSTANCE {.\n      importc: \"LoadLibraryA\", header: \"<windows.h>\", stdcall.}\n\n  proc nimUnloadLibrary(lib: LibHandle) =\n    freeLibrary(cast[THINSTANCE](lib))\n\n  proc nimLoadLibrary(path: string): LibHandle =\n    result = cast[LibHandle](winLoadLibrary(path))\n\n  proc nimGetProcAddr(lib: LibHandle, name: cstring): ProcAddr =\n    result = getProcAddress(cast[THINSTANCE](lib), name)\n    if result != nil: return\n    const decoratedLength = 250\n    var decorated: array[decoratedLength, char]\n    decorated[0] = '_'\n    var m = 1\n    while m < (decoratedLength - 5):\n      if name[m - 1] == '\\x00': break\n      decorated[m] = name[m - 1]\n      inc(m)\n    decorated[m] = '@'\n    for i in countup(0, 50):\n      var k = i * 4\n      if k div 100 == 0:\n        if k div 10 == 0:\n          m = m + 1\n        else:\n          m = m + 2\n      else:\n        m = m + 3\n      decorated[m + 1] = '\\x00'\n      while true:\n        decorated[m] = chr(ord('0') + (k %% 10))\n        dec(m)\n        k = k div 10\n        if k == 0: break\n      when defined(nimNoArrayToCstringConversion):\n        result = getProcAddress(cast[THINSTANCE](lib), addr decorated)\n      else:\n        result = getProcAddress(cast[THINSTANCE](lib), decorated)\n      if result != nil: return\n    procAddrError(name)\n\nelif defined(genode):\n\n  proc nimUnloadLibrary(lib: LibHandle) {.\n    error: \"nimUnloadLibrary not implemented\".}\n\n  proc nimLoadLibrary(path: string): LibHandle {.\n    error: \"nimLoadLibrary not implemented\".}\n\n  proc nimGetProcAddr(lib: LibHandle, name: cstring): ProcAddr {.\n    error: \"nimGetProcAddr not implemented\".}\n\nelif defined(nintendoswitch) or defined(freertos):\n  proc nimUnloadLibrary(lib: LibHandle) =\n    cstderr.rawWrite(\"nimUnLoadLibrary not implemented\")\n    cstderr.rawWrite(\"\\n\")\n    quit(1)\n\n  proc nimLoadLibrary(path: string): LibHandle =\n    cstderr.rawWrite(\"nimLoadLibrary not implemented\")\n    cstderr.rawWrite(\"\\n\")\n    quit(1)\n\n\n  proc nimGetProcAddr(lib: LibHandle, name: cstring): ProcAddr =\n    cstderr.rawWrite(\"nimGetProAddr not implemented\")\n    cstderr.rawWrite(name)\n    cstderr.rawWrite(\"\\n\")\n    quit(1)\n\nelse:\n  {.error: \"no implementation for dyncalls\".}\n\n{.pop.}\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/tests/stdlib/tjsontestsuite.nim",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/nim_icon.o",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/koch_icon.o",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/nim.ico",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/koch.res",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/nim.res",
        "/var/tmp/sochat1/spack-stage/spack-stage-nim-1.4.2-clhxocckl4vjqcsapqox2ghfzra4c4ma/spack-src/icons/koch.ico"
    ],
    "total_files": 10915
}