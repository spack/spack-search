{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocm-validation-suite-3.9.0-bf4er35ybtm3yrwto4xjmuvdzidpv27c/spack-src/rvs/src/rvsmodule.cpp": "/********************************************************************************\n *\n * Copyright (c) 2018 ROCm Developer Tools\n *\n * MIT LICENSE:\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n *******************************************************************************/\n#include \"include/rvsmodule.h\"\n\n#include <dlfcn.h>\n#include <stdio.h>\n\n#include <utility>\n#include <string>\n#include <map>\n#include <memory>\n#include <iostream>\n#include <fstream>\n\n#include \"include/rvsliblogger.h\"\n#include \"include/rvsif0.h\"\n#include \"include/rvsif1.h\"\n#include \"include/rvsaction.h\"\n#include \"include/rvsliblog.h\"\n#include \"include/rvsoptions.h\"\n\n#define MODULE_NAME_CAPS \"CLI\"\n\nstd::map<std::string, rvs::module*> rvs::module::modulemap;\nstd::map<std::string, std::string>  rvs::module::filemap;\nYAML::Node rvs::module::config;\n\nusing std::string;\n\n/**\n * @brief Constructor\n *\n * @param pModuleName Module name\n * @param pSoLib .so library which implements module\n *\n */\nrvs::module::module(const char* pModuleName, void* pSoLib)\n:\npsolib(pSoLib),\nname(pModuleName) {\n}\n\n//! Destructor\nrvs::module::~module() {\n}\n\n/**\n * @brief Module manager initialization method\n *\n * Reads module name -> .so file mapping from configuration file name\n * specified by pConfig\n *\n * @param pConfig Name of configuration file\n * @return 0 - success, non-zero otherwise\n *\n */\nint rvs::module::initialize(const char* pConfig) {\n  // Check if pConfig file exists\n  std::ifstream file(pConfig);\n\n  if (!file.good()) {\n    char buff[1024];\n    snprintf(buff, sizeof(buff), \"file does not exist: %s\", pConfig);\n    rvs::logger::Err(buff, MODULE_NAME_CAPS);\n    return -1;\n  } else {\n    file.close();\n  }\n\n  // load list of supported modules from config file\n  YAML::Node config = YAML::LoadFile(pConfig);\n\n  // verify that that the file format is supported\n  YAML::const_iterator it = config.begin();\n  if (it == config.end()) {\n    rvs::logger::Err(\"unsupported file format. Version string not found.\",\n                     MODULE_NAME_CAPS);\n    return -1;\n  }\n\n    std::string key = it->first.as<std::string>();\n    std::string value = it->second.as<std::string>();\n\n  if (key != \"version\") {\n    rvs::logger::Err(\"unsupported file format. Version string not found.\",\n                     MODULE_NAME_CAPS);\n    return -1;\n  }\n\n  if (value != \"1\") {\n    char buff[1024];\n    snprintf(buff, sizeof(buff), \"file version is %s, expected 1\",\n             value.c_str());\n    rvs::logger::Err(buff, MODULE_NAME_CAPS);\n    return -1;\n  }\n\n  // load nam-file pairs:\n  for (it++; it != config.end(); ++it) {\n    key = it->first.as<std::string>();\n    value = it->second.as<std::string>();\n    filemap.insert(std::pair<string, string>(key, value));\n  }\n\n  return 0;\n}\n\n/**\n * @brief Given module name, return pointer to module instance\n *\n * This method will load and initialize module if needed.\n *\n * @param name Name of configuration file\n * @return Pointer to module instance\n *\n */\nrvs::module* rvs::module::find_create_module(const char* name) {\n  module* m = nullptr;\n\n  // find module based on short name\n  auto it = modulemap.find(std::string(name));\n\n  // not found...\n  if (it == modulemap.end()) {\n    // ... try opening .so\n\n    // first find proper .so filename\n    auto it = filemap.find(std::string(name));\n\n    // not found...\n    if (it == filemap.end()) {\n      // this should never happen if .config is OK\n      char buff[1024];\n      snprintf(buff, sizeof(buff),\n               \"module '%s' not found in configuration.\", name);\n      rvs::logger::Err(buff, MODULE_NAME_CAPS);\n      return NULL;\n    }\n\n    // open .so\n    string libpath;\n    if (rvs::options::has_option(\"-m\", &libpath)) {\n      libpath += \"/\";\n    } else {\n      rvs::options::has_option(\"pwd\", &libpath);\n      libpath += \"/\";\n    }\n    string sofullname(libpath + it->second);\n    void* psolib = dlopen(sofullname.c_str(), RTLD_NOW);\n\n    // error?\n    if (!psolib) {\n      char buff[1024];\n      snprintf(buff, sizeof(buff),\n               \"could not load .so '%s'\", sofullname.c_str());\n      rvs::logger::Err(buff, MODULE_NAME_CAPS);\n      snprintf(buff, sizeof(buff),\n               \"reason: '%s'\", dlerror());\n      rvs::logger::Err(buff, MODULE_NAME_CAPS);\n      return NULL;  // fail\n    }\n\n    // create module object\n    m = new rvs::module(name, psolib);\n    if (!m) {\n      dlclose(psolib);\n      return NULL;\n    }\n\n    // initialize API function pointers\n    if (m->init_interfaces()) {\n      char buff[1024];\n      snprintf(buff, sizeof(buff),\n               \"could not init interfaces for '%s'\", it->second.c_str());\n      rvs::logger::Err(buff, MODULE_NAME_CAPS);\n      dlclose(psolib);\n      delete m;\n      return nullptr;\n    }\n\n    // initialize newly loaded module\n    if (m->initialize()) {\n      char buff[1024];\n      snprintf(buff, sizeof(buff),\n               \"could not initialize '%s'\", it->second.c_str());\n      rvs::logger::Err(buff, MODULE_NAME_CAPS);\n      dlclose(psolib);\n      delete m;\n      return nullptr;\n    }\n\n    // add to map\n    modulemap.insert(t_mmpair(name, m));\n  } else {\n    m = it->second;\n  }\n\n  return m;\n}\n\n/**\n * @brief Module instance initialization method\n *\n * Fills module initialization structure with pointers to\n * Logger API and passes it to module Initialize() API.\n *\n * @return 0 - success, non-zero otherwise\n *\n */\nint rvs::module::initialize() {\n  T_MODULE_INIT d;\n\n  d.cbLog             = rvs::logger::Log;\n  d.cbLogExt          = rvs::logger::LogExt;\n  d.cbLogRecordCreate = rvs::logger::LogRecordCreate;\n  d.cbLogRecordFlush   = rvs::logger::LogRecordFlush;\n  d.cbCreateNode      = rvs::logger::CreateNode;\n  d.cbAddString       = rvs::logger::AddString;\n  d.cbAddInt          = rvs::logger::AddInt;\n  d.cbAddNode         = rvs::logger::AddNode;\n  d.cbStop            = rvs::logger::Stop;\n  d.cbStopping        = rvs::logger::Stopping;\n  d.cbErr             = rvs::logger::Err;\n\n  return (*rvs_module_init)(reinterpret_cast<void*>(&d));\n}\n\n\n/**\n * @brief Given module name, create module action\n *\n * @param name Module name\n * @return Pointer to action instance created in module\n *\n */\nrvs::action* rvs::module::action_create(const char* name) {\n  // find module\n  rvs::module* m = module::find_create_module(name);\n  if (!m) {\n    char buff[1024];\n    snprintf(buff, sizeof(buff),\n              \"module '%s' not available.\", name);\n    rvs::logger::Err(buff, MODULE_NAME_CAPS);\n    return nullptr;\n  }\n\n  // create lib action objct\n  void* plibaction = m->action_create();\n  if (!plibaction)  {\n    char buff[1024];\n    snprintf(buff, sizeof(buff),\n              \"module '%s' could not create lib action.\", name);\n    rvs::logger::Err(buff, MODULE_NAME_CAPS);\n    return nullptr;\n  }\n\n  // create action proxy object\n  rvs::action* pa = new rvs::action(name, plibaction);\n  if (!pa) {\n    char buff[1024];\n    snprintf(buff, sizeof(buff),\n              \"module '%s' could not create action proxy.\", name);\n    rvs::logger::Err(buff, MODULE_NAME_CAPS);\n    return nullptr;\n  }\n\n  // create interfaces for the proxy\n  // clone from module and assign libaction ptr\n\n  for (auto it = m->ifmap.begin(); it != m->ifmap.end(); it++) {\n    std::shared_ptr<rvs::ifbase> sptrif(it->second->clone());\n    sptrif->plibaction = plibaction;\n    pa->ifmap.insert(rvs::action::t_impair(it->first, sptrif));\n  }\n\n  return pa;\n}\n\n/**\n * @brief Create module action\n *\n * Note: internal, used by static action_create()\n *\n * @return Pointer to action instance created in module\n *\n */\nvoid* rvs::module::action_create() {\n  return (*rvs_module_action_create)();\n}\n\n\n/**\n * @brief Destroy module action\n *\n * Note: after this call, proxy action is also destroyed and its\n * pointer can no\n * @param paction Pointer to action proxy instance\n * @return 0 - success, non-zero otherwise\n *\n */\nint rvs::module::action_destroy(rvs::action* paction) {\n  // find module\n  rvs::module* m = module::find_create_module(paction->name.c_str());\n  if (!m)\n    return -1;\n\n  return m->action_destroy_internal(paction);\n}\n\n/**\n * @brief Destroy module action\n *\n * Note: internal, used by static action_destroy()\n *\n * @param paction Pointer to action proxy instance\n * @return 0 - success, non-zero otherwise\n *\n */\nint rvs::module::action_destroy_internal(rvs::action* paction) {\n  int sts = (*rvs_module_action_destroy)(paction->plibaction);\n  delete paction;\n\n  return sts;\n}\n\n/**\n * @brief Cleanup module manager\n *\n * @return 0 - success, non-zero otherwise\n *\n */\nint rvs::module::terminate() {\n  for (auto it = rvs::module::modulemap.begin();\n       it != rvs::module::modulemap.end(); it++) {\n    it->second->terminate_internal();\n    //dlclose(it->second->psolib);\n    delete it->second;\n  }\n\n  modulemap.clear();\n\n  return 0;\n}\n\n/**\n * @brief Cleanup module instance\n *\n * @return 0 - success, non-zero otherwise\n *\n */\nint rvs::module::terminate_internal() {\n  return (*rvs_module_terminate)();\n}\n\n\n/**\n * @brief Init module interfaces\n *\n * Module interfaces are initialized upon loading of module.\n * Pointer to starndard RVS API functions are obtained by calling ldsym()\n * given API function names. Action proxy interfaces are also created at this\n * point and later cloned into particular action proxy upon creation of action.\n *\n * @return 0 - success, non-zero otherwise\n *\n */\nint rvs::module::init_interfaces() {\n  // init global helper methods for this library\n  int sts = 0;\n\n  if (init_interface_method(\n    reinterpret_cast<void**>(&rvs_module_init), \"rvs_module_init\")) {\n    --sts;\n    }\n\n  if (init_interface_method(\n    reinterpret_cast<void**>(&rvs_module_terminate), \"rvs_module_terminate\")) {\n    --sts;\n  }\n\n  if (init_interface_method(\n    reinterpret_cast<void**>(&rvs_module_action_create),\n                            \"rvs_module_action_create\")) {\n    --sts;\n  }\n\n  if (init_interface_method(\n    reinterpret_cast<void**>(&rvs_module_action_destroy),\n                            \"rvs_module_action_destroy\")) {\n    --sts;\n  }\n\n  if (init_interface_method(\n    reinterpret_cast<void**>(&rvs_module_has_interface),\n                            \"rvs_module_has_interface\")) {\n    --sts;\n  }\n\n  if (sts)\n    return sts;\n\n  if (init_interface_0()) {\n    return --sts;\n  }\n\n  if (init_interface_1()) {\n    --sts;\n  }\n\n  return sts;\n}\n\n/**\n * @brief Initialize function pointer\n *\n * Initialize function pointer by searching function by name in .so library\n *\n * @param ppfunc pointer to function pointer to be initialized\n * @param pMethodName Method name\n *\n * @return 0 - success, non-zero otherwise\n *\n */\nint rvs::module::init_interface_method(void** ppfunc, const char* pMethodName) {\n  if (!psolib) {\n    rvs::logger::Err(\"psolib is null.\", MODULE_NAME_CAPS);\n    return -1;\n  }\n  void* pf = dlsym(psolib, pMethodName);\n  if (!pf) {\n    char buff[1024];\n    snprintf(buff, sizeof(buff),\n              \"could not find .so method '%s'\", pMethodName);\n    rvs::logger::Err(buff, MODULE_NAME_CAPS);\n    return -1;\n  }\n\n  *ppfunc = pf;\n\n  return 0;\n}\n\n/**\n * @brief Init RVS IF0 interfaces\n *\n * @return 0 - success, non-zero otherwise\n *\n */\nint rvs::module::init_interface_0(void) {\n  if (!(*rvs_module_has_interface)(0)) {\n    rvs::logger::Err(\"Interface IF0 not available.\", MODULE_NAME_CAPS);\n    return -1;\n  }\n\n  rvs::if0* pif0 = new rvs::if0();\n  if (!pif0)\n    return -1;\n\n  int sts = 0;\n\n  pif0->rvs_module_has_interface = rvs_module_has_interface;\n  if (init_interface_method(\n    reinterpret_cast<void**>(&(pif0->rvs_module_get_description)),\n                            \"rvs_module_get_description\"))\n    sts--;\n\n  if (init_interface_method(\n    reinterpret_cast<void**>(&(pif0->rvs_module_get_config)),\n                            \"rvs_module_get_config\"))\n    sts--;\n\n  if (init_interface_method(\n    reinterpret_cast<void**>(&(pif0->rvs_module_get_output)),\n                            \"rvs_module_get_output\"))\n    sts--;\n\n  if (sts) {\n    delete pif0;\n    return sts;\n  }\n\n  std::shared_ptr<rvs::ifbase> sptr((rvs::ifbase*)pif0);\n  ifmap.insert(rvs::action::t_impair(0, sptr));\n\n  return 0;\n}\n\n/**\n * @brief Init RVS IF1 interfaces\n *\n * @return 0 - success, non-zero otherwise\n *\n */\nint rvs::module::init_interface_1(void) {\n  if (!(*rvs_module_has_interface)(1)) {\n    rvs::logger::Err(\"Interface IF1 not available.\", MODULE_NAME_CAPS);\n    return -1;\n  }\n\n  rvs::if1* pif1 = new rvs::if1();\n  if (!pif1)\n    return -1;\n\n  int sts = 0;\n\n  pif1->rvs_module_has_interface = rvs_module_has_interface;\n\n  if (init_interface_method(\n    reinterpret_cast<void**>(&(pif1->rvs_module_action_property_set)),\n                            \"rvs_module_action_property_set\"))\n    sts--;\n\n  if (init_interface_method(\n    reinterpret_cast<void**>(&(pif1->rvs_module_action_run)),\n                            \"rvs_module_action_run\"))\n    sts--;\n\n  if (sts) {\n    delete pif1;\n    return sts;\n  }\n\n  std::shared_ptr<rvs::ifbase> sptr((rvs::ifbase*)pif1);\n  ifmap.insert(rvs::action::t_impair(1, sptr));\n\n  return 0;\n}\n\n/**\n * @brief Lists available modules\n *\n */\nvoid rvs::module::do_list_modules(void) {\n  // for all modules\n  for (auto it = filemap.begin(); it != filemap.end(); it++) {\n    // create action\n    rvs::action* pa = rvs::module::action_create(it->first.c_str());\n    if (!pa) {\n      char buff[1024];\n      snprintf(buff, sizeof(buff),\n                \"could not open module '%s'\", it->first.c_str());\n      rvs::logger::Err(buff, MODULE_NAME_CAPS);\n      continue;\n    }\n\n    // output module name\n    std::cout << \"\\t\" << it->first.c_str() << \":\" << std::endl;\n\n    // obtain IF0\n    rvs::if0* pif0 = dynamic_cast<rvs::if0*>(pa->get_interface(0));\n    if (!pif0) {\n      // action no longer needed so destroy it\n      rvs::module::action_destroy(pa);\n      rvs::logger::Err(\"could not obtain interface if0\", MODULE_NAME_CAPS);\n      continue;\n    }\n\n    // output info\n    std::cout << \"\\t\\tDescription: \" << pif0->get_description() << std::endl;\n    std::cout << \"\\t\\tconfig: \" << pif0->get_config() << std::endl;\n    std::cout << \"\\t\\toutput: \" << pif0->get_output() << std::endl;\n\n    // action no longer needed so destroy it\n    rvs::module::action_destroy(pa);\n  }\n}\n\n\n\n\n\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-rocm-validation-suite-3.9.0-bf4er35ybtm3yrwto4xjmuvdzidpv27c/spack-src/edp.so/rocm_edp_helper/rocm_edp_helper.o",
        "/tmp/vanessa/spack-stage/spack-stage-rocm-validation-suite-3.9.0-bf4er35ybtm3yrwto4xjmuvdzidpv27c/spack-src/babel.so/doc/saahpc_09.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-rocm-validation-suite-3.9.0-bf4er35ybtm3yrwto4xjmuvdzidpv27c/spack-src/mem.so/doc/saahpc_09.pdf"
    ],
    "total_files": 580
}