{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libfastcommon-1.0.40-tznqsralykovgznymnushizuujoowafq/spack-src/src/ini_file_reader.c": "/**\n* Copyright (C) 2008 Happy Fish / YuQing\n*\n* FastDFS may be copied only under the terms of the GNU General\n* Public License V3, which may be found in the FastDFS source kit.\n* Please visit the FastDFS Home Page http://www.csource.org/ for more detail.\n**/\n\n//ini_file_reader.c\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n#include <dlfcn.h>\n#include \"shared_func.h\"\n#include \"logger.h\"\n#include \"http_func.h\"\n#include \"local_ip_func.h\"\n#include \"ini_file_reader.h\"\n\n#define _LINE_BUFFER_SIZE\t   512\n#define _INIT_ALLOC_ITEM_COUNT\t32\n\n#define _PREPROCESS_TAG_STR_IF  \"#@if \"\n#define _PREPROCESS_TAG_STR_ELSE \"#@else\"\n#define _PREPROCESS_TAG_STR_ENDIF \"#@endif\"\n#define _PREPROCESS_TAG_STR_FOR \"#@for \"\n#define _PREPROCESS_TAG_STR_ENDFOR \"#@endfor\"\n#define _PREPROCESS_TAG_STR_SET \"#@set \"\n\n#define _PREPROCESS_TAG_LEN_IF (sizeof(_PREPROCESS_TAG_STR_IF) - 1)\n#define _PREPROCESS_TAG_LEN_ELSE (sizeof(_PREPROCESS_TAG_STR_ELSE) - 1)\n#define _PREPROCESS_TAG_LEN_ENDIF (sizeof(_PREPROCESS_TAG_STR_ENDIF) - 1)\n#define _PREPROCESS_TAG_LEN_FOR (sizeof(_PREPROCESS_TAG_STR_FOR) - 1)\n#define _PREPROCESS_TAG_LEN_ENDFOR (sizeof(_PREPROCESS_TAG_STR_ENDFOR) - 1)\n#define _PREPROCESS_TAG_LEN_SET (sizeof(_PREPROCESS_TAG_STR_SET) - 1)\n\n#define _PREPROCESS_VARIABLE_STR_LOCAL_IP \"%{LOCAL_IP}\"\n#define _PREPROCESS_VARIABLE_STR_LOCAL_HOST \"%{LOCAL_HOST}\"\n\n#define _PREPROCESS_VARIABLE_LEN_LOCAL_IP \\\n    (sizeof(_PREPROCESS_VARIABLE_STR_LOCAL_IP) - 1)\n#define _PREPROCESS_VARIABLE_LEN_LOCAL_HOST \\\n    (sizeof(_PREPROCESS_VARIABLE_STR_LOCAL_HOST) - 1)\n\n#define _PREPROCESS_TAG_STR_FOR_FROM   \"from\"\n#define _PREPROCESS_TAG_LEN_FOR_FROM   (sizeof(_PREPROCESS_TAG_STR_FOR_FROM) - 1)\n#define _PREPROCESS_TAG_STR_FOR_TO     \"to\"\n#define _PREPROCESS_TAG_LEN_FOR_TO     (sizeof(_PREPROCESS_TAG_STR_FOR_TO) - 1)\n#define _PREPROCESS_TAG_STR_FOR_STEP   \"step\"\n#define _PREPROCESS_TAG_LEN_FOR_STEP   (sizeof(_PREPROCESS_TAG_STR_FOR_STEP) - 1)\n\n#define _MAX_DYNAMIC_CONTENTS     8\n#define _BUILTIN_ANNOTATION_COUNT 3\n\nstatic AnnotationEntry *g_annotations = NULL;\nstatic int g_annotation_count = 0;\n\ntypedef struct {\n    int count;\n    int alloc_count;\n    char **contents;\n} DynamicContents;\n\ntypedef struct {\n    int offset;  //deal offset\n    HashArray *vars;  //variables with #@set\n} SetDirectiveVars;\n\ntypedef struct {\n    int count;\n    int alloc_count;\n    AnnotationEntry *annotations;\n} DynamicAnnotations;\n\ntypedef struct {\n    bool used;\n    IniContext *context;\n    DynamicContents dynamicContents;\n    SetDirectiveVars set;\n    DynamicAnnotations dynamicAnnotations;\n} CDCPair;\n\n//dynamic alloced contents which will be freed when destroy\nstatic int g_dynamic_content_count = 0;\nstatic int g_dynamic_content_index = 0;\nstatic CDCPair g_dynamic_contents[_MAX_DYNAMIC_CONTENTS] = {{false, NULL,\n    {0, 0, NULL}, {0, NULL}, {0, 0, NULL}}};\n\nstatic int remallocSection(IniSection *pSection, IniItem **pItem);\nstatic int iniDoLoadFromFile(const char *szFilename, \\\n\t\tIniContext *pContext);\nstatic int iniLoadItemsFromBuffer(char *content, \\\n\t\tIniContext *pContext);\nstatic DynamicAnnotations *iniAllocAnnotations(IniContext *pContext,\n        const int annotation_count);\nstatic AnnotationEntry *iniGetAnnotations(IniContext *pContext);\nstatic SetDirectiveVars *iniGetVars(IniContext *pContext);\n\n#define STR_TRIM(pStr) \\\n    do { \\\n        trim_right(pStr); \\\n        trim_left(pStr);  \\\n    } while (0)\n\nstatic void iniDoSetAnnotations(AnnotationEntry *src, const int src_count,\n        AnnotationEntry *dest, int *dest_count)\n{\n    AnnotationEntry *pSrc;\n    AnnotationEntry *pSrcEnd;\n    AnnotationEntry *pDest;\n    AnnotationEntry *pDestEnd;\n\n    pSrcEnd = src + src_count;\n    pDestEnd = dest + *dest_count;\n    for (pSrc=src; pSrc<pSrcEnd; pSrc++)\n    {\n        for (pDest=dest; pDest<pDestEnd; pDest++)\n        {\n            if (strcmp(pSrc->func_name, pDest->func_name) == 0)\n            {\n                break;\n            }\n        }\n\n        pDest->func_name = pSrc->func_name;\n        pDest->arg = pSrc->arg;\n        pDest->func_init = pSrc->func_init;\n        pDest->func_destroy = pSrc->func_destroy;\n        pDest->func_get = pSrc->func_get;\n        pDest->func_free = pSrc->func_free;\n        pDest->dlhandle = pSrc->dlhandle;\n        pDest->inited = false;\n        if (pDest == pDestEnd)  //insert\n        {\n            ++(*dest_count);\n            pDestEnd = dest + *dest_count;\n        }\n    }\n}\n\n\nstatic AnnotationEntry *iniFindAnnotation(AnnotationEntry *annotatios,\n        const char *func_name)\n{\n    AnnotationEntry *pAnnoEntry;\n\n    if (annotatios == NULL)\n    {\n        return NULL;\n    }\n\n    pAnnoEntry = annotatios;\n    while (pAnnoEntry->func_name != NULL)\n    {\n        if (strcmp(func_name, pAnnoEntry->func_name) == 0)\n        {\n            return pAnnoEntry;\n        }\n        pAnnoEntry++;\n    }\n\n    return NULL;\n}\n\nstatic int iniAnnotationFuncLocalIpGet(IniContext *context,\n        struct ini_annotation_entry *annotation,\n        const IniItem *item, char **pOutValue, int max_values)\n{\n    bool need_private_ip;\n    int count;\n    int index;\n    char param[FAST_INI_ITEM_VALUE_SIZE];\n    const char *next_ip;\n    char *square_start;\n    char name_part[16];\n\n    strcpy(param, item->value);\n    memset(name_part, 0, sizeof(name_part));\n    square_start = strchr(param, '[');\n    if (square_start != NULL && param[strlen(param) - 1] == ']') {\n        snprintf(name_part, sizeof(name_part) - 1, \"%.*s\",\n                (int)(square_start - param), param);\n        index = atoi(square_start + 1);\n    } else {\n        snprintf(name_part, sizeof(name_part) - 1, \"%s\", param);\n        index = -2;\n    }\n\n    need_private_ip = strcasecmp(name_part, \"inner\") == 0 ||\n        strcasecmp(name_part, \"private\") == 0;\n    next_ip = NULL;\n    count = 0;\n    while ((next_ip=get_next_local_ip(next_ip)) != NULL) {\n        if (count >= max_values) {\n            break;\n        }\n        if (is_private_ip(next_ip)) {\n            if (need_private_ip) {\n                pOutValue[count++] = (char *)next_ip;\n            }\n        } else {\n            if (!need_private_ip) {\n                pOutValue[count++] = (char *)next_ip;\n            }\n        }\n    }\n\n    if (count == 0) {\n        pOutValue[count++] = \"\";\n    } else if (index > -2) {\n        if (index == -1) {  //get the last one\n            if (count > 1) {\n                pOutValue[0] = pOutValue[count - 1];\n            }\n        } else if (index >= count) { //index overflow\n            logWarning(\"file: \"__FILE__\", line: %d, \"\n                    \"index: %d >= count: %d, set value to empty\",\n                    __LINE__, index, count);\n            pOutValue[0] = \"\";\n        } else if (index > 0) {\n            pOutValue[0] = pOutValue[index];\n        }\n        count = 1;\n    }\n    return count;\n}\n\nstatic int iniAnnotationFuncShellExec(IniContext *context,\n        struct ini_annotation_entry *annotation,\n        const IniItem *item, char **pOutValue, int max_values)\n{\n    int count;\n    int result;\n    char *output;\n\n    count = 0;\n    output = (char *)malloc(FAST_INI_ITEM_VALUE_SIZE);\n    if (output == NULL) {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"malloc %d bytes fail\",\n                __LINE__, FAST_INI_ITEM_VALUE_LEN + 1);\n        return count;\n    }\n\n    if ((result=getExecResult(item->value, output, FAST_INI_ITEM_VALUE_SIZE)) != 0)\n    {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"exec %s fail, errno: %d, error info: %s\",\n                __LINE__, item->value, result, STRERROR(result));\n        free(output);\n        return count;\n    }\n    if (*output == '\\0')\n    {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"empty reply when exec: %s\", __LINE__, item->value);\n    }\n    pOutValue[count++] = fc_trim(output);\n    return count;\n}\n\nstatic int iniCopyBuffer(char *dest, const int size, const char *src, int len)\n{\n    if (len == 0) {\n        return 0;\n    }\n\n    if (len >= size) {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"length: %d exceeds: %d\",\n                __LINE__, len, size);\n        len = size - 1;\n        if (len < 0) {\n            len = 0;\n        }\n    }\n\n    if (len > 0) {\n        memcpy(dest, src, len);\n    }\n    return len;\n}\n\nstatic char *doReplaceVars(IniContext *pContext, const char *param,\n        const int max_size)\n{\n#define VARIABLE_TAG_MIN_LENGTH  4   //%{v}\n\n    SetDirectiveVars *set;\n    const char *p;\n    const char *e;\n    char name[64];\n    const char *start;\n    const char *value;\n    const char *pLoopEnd;\n    const char *pEnd;\n    char *pDest;\n    char *output;\n    int name_len;\n    int len;\n\n    output = (char *)malloc(max_size);\n    if (output == NULL) {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"malloc %d bytes fail\",\n                __LINE__, FAST_INI_ITEM_VALUE_SIZE);\n        return NULL;\n    }\n\n    set = iniGetVars(pContext);\n    if (set == NULL || set->vars == NULL) {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"NO set directives before, set value to %s\",\n                __LINE__, param);\n        snprintf(output, FAST_INI_ITEM_VALUE_SIZE, \"%s\", param);\n        return output;\n    }\n\n    pEnd = param + strlen(param);\n    pLoopEnd = pEnd - (VARIABLE_TAG_MIN_LENGTH - 1);\n    p = param;\n    pDest = output;\n    while (p < pLoopEnd) {\n        if (*p == '%' && *(p+1) == '{') {\n            start = e = p + 2;\n            while (e < pEnd && *e != '}') {\n                e++;\n            }\n            if (e == pEnd) {\n                break;\n            }\n            name_len = e - start;\n            p = e + 1;\n\n            if (name_len >= sizeof(name)) {\n                logWarning(\"file: \"__FILE__\", line: %d, \"\n                        \"name: %.*s is too long, truncate to length: %d\",\n                        __LINE__, name_len, start, (int)(sizeof(name) - 1));\n                name_len = sizeof(name) - 1;\n            }\n            if (name_len > 0) {\n                memcpy(name, start, name_len);\n            }\n            *(name + name_len) = '\\0';\n            trim(name);\n            name_len = strlen(name);\n            if (name_len > 0) {\n                value = (char *)hash_find(set->vars, name, name_len);\n            } else {\n                value = NULL;\n            }\n            if (value != NULL) {\n                len = strlen(value);\n            }\n            else {\n                logWarning(\"file: \"__FILE__\", line: %d, \"\n                        \"name: %s NOT found, keep the origin\",\n                        __LINE__, name);\n                value = start - 2;\n                len = p - value;\n            }\n            pDest += iniCopyBuffer(pDest, FAST_INI_ITEM_VALUE_SIZE -\n                    (pDest - output), value, len);\n        }\n        else {\n            if (pDest - output < FAST_INI_ITEM_VALUE_LEN) {\n                *pDest++ = *p++;\n            }\n            else {\n                logWarning(\"file: \"__FILE__\", line: %d, \"\n                        \"value too long, exceeds: %d\",\n                        __LINE__, (int)sizeof(output));\n                break;\n            }\n        }\n    }\n\n    len = pEnd - p;\n    pDest += iniCopyBuffer(pDest, FAST_INI_ITEM_VALUE_SIZE - (pDest - output), p, len);\n    *pDest = '\\0';\n    return output;\n}\n\nstatic int iniAnnotationReplaceVars(IniContext *pContext,\n        struct ini_annotation_entry *annotation,\n        const IniItem *item, char **pOutValue, int max_values)\n{\n    char *output;\n    output = doReplaceVars(pContext, item->value, FAST_INI_ITEM_VALUE_SIZE);\n    if (output == NULL) {\n        return 0;\n    }\n    else {\n        pOutValue[0] = output;\n        return 1;\n    }\n}\n\nvoid iniAnnotationFreeValues(struct ini_annotation_entry *annotation,\n        char **values, const int count)\n{\n    int i;\n    for (i=0; i<count; i++) {\n        free(values[i]);\n        values[i] = NULL;\n    }\n}\n\nstatic void iniSetBuiltinAnnotations(IniContext *pContext,\n        AnnotationEntry *dest, int *dest_count)\n{\n    AnnotationEntry builtins[_BUILTIN_ANNOTATION_COUNT];\n    AnnotationEntry *pAnnotation;\n\n    memset(builtins, 0, sizeof(builtins));\n    pAnnotation = builtins;\n    pAnnotation->func_name = \"LOCAL_IP_GET\";\n    pAnnotation->func_get = iniAnnotationFuncLocalIpGet;\n    pAnnotation++;\n\n    pAnnotation->func_name = \"REPLACE_VARS\";\n    pAnnotation->func_get = iniAnnotationReplaceVars;\n    pAnnotation->func_free = iniAnnotationFreeValues;\n    pAnnotation++;\n\n    if ((pContext->flags & FAST_INI_FLAGS_SHELL_EXECUTE) != 0)\n    {\n        pAnnotation->func_name = \"SHELL_EXEC\";\n        pAnnotation->func_get = iniAnnotationFuncShellExec;\n        pAnnotation->func_free = iniAnnotationFreeValues;\n        pAnnotation++;\n    }\n\n    iniDoSetAnnotations(builtins, pAnnotation - builtins, dest, dest_count);\n}\n\nstatic int iniSetAnnotations(IniContext *pContext, const char annotation_type,\n        AnnotationEntry *annotations, const int count)\n{\n    DynamicAnnotations *pDynamicAnnotations;\n\n    pContext->annotation_type = annotation_type;\n    if (pContext->annotation_type == FAST_INI_ANNOTATION_DISABLE)\n    {\n        return 0;\n    }\n    if (pContext->annotation_type == FAST_INI_ANNOTATION_WITHOUT_BUILTIN &&\n            annotations == NULL)\n    {\n        return 0;\n    }\n\n    if ((pDynamicAnnotations=iniAllocAnnotations(pContext,\n                    _BUILTIN_ANNOTATION_COUNT + count)) == NULL)\n    {\n        return ENOMEM;\n    }\n    if (pContext->annotation_type == FAST_INI_ANNOTATION_WITH_BUILTIN)\n    {\n        iniSetBuiltinAnnotations(pContext, pDynamicAnnotations->annotations,\n                &pDynamicAnnotations->count);\n    }\n\n    if (annotations != NULL)\n    {\n        iniDoSetAnnotations(annotations, count, pDynamicAnnotations->annotations,\n                &pDynamicAnnotations->count);\n    }\n    return 0;\n}\n\nint iniSetAnnotationCallBack(AnnotationEntry *annotations, int count)\n{\n    int bytes;\n\n    if (count <= 0)\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n\t\t\t\"iniSetAnnotationCallBack fail, count(%d) is invalid.\",\n\t\t\t__LINE__, count);\n        return EINVAL;\n    }\n\n    bytes = sizeof(AnnotationEntry) * (g_annotation_count + count + 1);\n    g_annotations = (AnnotationEntry *)realloc(g_annotations, bytes);\n    if (g_annotations == NULL)\n    {\n\t\tlogError(\"file: \"__FILE__\", line: %d, \"\n\t\t\t\"realloc %d fail, errno: %d, error info: %s\",\n\t\t\t__LINE__, bytes, errno, STRERROR(errno));\n        return ENOMEM;\n    }\n\n    memset(g_annotations + g_annotation_count, 0,\n            sizeof(AnnotationEntry) * (count + 1));\n    iniDoSetAnnotations(annotations, count, g_annotations, &g_annotation_count);\n    return 0;\n}\n\nvoid iniDestroyAnnotationCallBack()\n{\n    AnnotationEntry *pAnnoEntry;\n\n    if (g_annotations == NULL)\n    {\n        return;\n    }\n\n    pAnnoEntry = g_annotations;\n    while (pAnnoEntry->func_name)\n    {\n        if (pAnnoEntry->func_destroy != NULL)\n        {\n            pAnnoEntry->func_destroy(pAnnoEntry);\n        }\n        if (pAnnoEntry->dlhandle != NULL)\n        {\n            dlclose(pAnnoEntry->dlhandle);\n        }\n        pAnnoEntry++;\n    }\n\n    free(g_annotations);\n    g_annotations = NULL;\n    g_annotation_count = 0;\n\n}\n\nstatic int iniCompareByItemName(const void *p1, const void *p2)\n{\n\treturn strcmp(((IniItem *)p1)->name, ((IniItem *)p2)->name);\n}\n\nstatic int iniInitContext(IniContext *pContext, const char annotation_type,\n        AnnotationEntry *annotations, const int count,\n        const char flags)\n{\n\tint result;\n\n\tmemset(pContext, 0, sizeof(IniContext));\n\tpContext->current_section = &pContext->global;\n\tif ((result=hash_init(&pContext->sections, Time33Hash, 32, 0.75)) != 0)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"hash_init fail, errno: %d, error info: %s\", \\\n\t\t\t__LINE__, result, STRERROR(result));\n\t}\n\n\tpContext->flags = flags;\n    return iniSetAnnotations(pContext, annotation_type, annotations, count);\n}\n\nstatic int iniSortHashData(const int index, const HashData *data, void *args)\n{\n\tIniSection *pSection;\n\n\tpSection = (IniSection *)data->value;\n\tif (pSection->count > 1)\n\t{\n\t\tqsort(pSection->items, pSection->count, \\\n\t\t\tsizeof(IniItem), iniCompareByItemName);\n\t}\n\n\treturn 0;\n}\n\nstatic void iniSortItems(IniContext *pContext)\n{\n\tif (pContext->global.count > 1)\n\t{\n\t\tqsort(pContext->global.items, pContext->global.count, \\\n\t\t\tsizeof(IniItem), iniCompareByItemName);\n\t}\n\n\thash_walk(&pContext->sections, iniSortHashData, NULL);\n}\n\nint iniLoadFromFile(const char *szFilename, IniContext *pContext)\n{\n    return iniLoadFromFileEx(szFilename, pContext,\n            FAST_INI_ANNOTATION_WITH_BUILTIN,\n            NULL, 0, FAST_INI_FLAGS_NONE);\n}\n\nstatic void iniDestroyAnnotations(const int old_annotation_count)\n{\n    AnnotationEntry *pAnnoEntry;\n\n    if (g_annotations == NULL)\n    {\n        return;\n    }\n\n    logDebug(\"iniDestroyAnnotations, old_annotation_count: %d, \"\n            \"g_annotation_count: %d\",\n            old_annotation_count, g_annotation_count);\n    if (old_annotation_count == 0)\n    {\n        iniDestroyAnnotationCallBack();\n        return;\n    }\n\n    pAnnoEntry = g_annotations + old_annotation_count;\n    while (pAnnoEntry->func_name)\n    {\n        if (pAnnoEntry->func_destroy != NULL)\n        {\n            pAnnoEntry->func_destroy(pAnnoEntry);\n        }\n        if (pAnnoEntry->dlhandle != NULL)\n        {\n            dlclose(pAnnoEntry->dlhandle);\n        }\n        pAnnoEntry++;\n    }\n\n    memset(g_annotations + old_annotation_count, 0,\n            sizeof(AnnotationEntry) * (g_annotation_count - old_annotation_count));\n    g_annotation_count = old_annotation_count;\n}\n\nint iniLoadFromFileEx(const char *szFilename, IniContext *pContext,\n    const char annotation_type, AnnotationEntry *annotations, const int count,\n    const char flags)\n{\n\tint result;\n\tint len;\n\tchar *pLast;\n\tchar full_filename[MAX_PATH_SIZE];\n    int old_annotation_count;\n\n\tif ((result=iniInitContext(pContext, annotation_type,\n                    annotations, count, flags)) != 0)\n\t{\n\t\treturn result;\n\t}\n\n\tif (strncasecmp(szFilename, \"http://\", 7) == 0)\n\t{\n\t\t*pContext->config_path = '\\0';\n\t\tsnprintf(full_filename, sizeof(full_filename),\"%s\",szFilename);\n\t}\n\telse\n\t{\n\t\tif (*szFilename == '/')\n\t\t{\n\t\t\tpLast = strrchr(szFilename, '/');\n\t\t\tlen = pLast - szFilename;\n\t\t\tif (len >= sizeof(pContext->config_path))\n\t\t\t{\n\t\t\t\tlogError(\"file: \"__FILE__\", line: %d, \"\\\n\t\t\t\t\t\"the path of the config file: %s is \" \\\n\t\t\t\t\t\"too long!\", __LINE__, szFilename);\n\t\t\t\treturn ENOSPC;\n\t\t\t}\n\n\t\t\tmemcpy(pContext->config_path, szFilename, len);\n\t\t\t*(pContext->config_path + len) = '\\0';\n\t\t\tsnprintf(full_filename, sizeof(full_filename), \\\n\t\t\t\t\"%s\", szFilename);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(pContext->config_path, 0, \\\n\t\t\t\tsizeof(pContext->config_path));\n\t\t\tif (getcwd(pContext->config_path, sizeof( \\\n\t\t\t\tpContext->config_path)) == NULL)\n\t\t\t{\n\t\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\t\"getcwd fail, errno: %d, \" \\\n\t\t\t\t\t\"error info: %s\", \\\n\t\t\t\t\t__LINE__, errno, STRERROR(errno));\n\t\t\t\treturn errno != 0 ? errno : EPERM;\n\t\t\t}\n\n\t\t\tlen = strlen(pContext->config_path);\n\t\t\tif (len > 0 && pContext->config_path[len - 1] == '/')\n\t\t\t{\n\t\t\t\tlen--;\n\t\t\t\t*(pContext->config_path + len) = '\\0';\n\t\t\t}\n\n\t\t\tsnprintf(full_filename, sizeof(full_filename), \\\n\t\t\t\t\"%s/%s\", pContext->config_path, szFilename);\n\n\t\t\tpLast = strrchr(szFilename, '/');\n\t\t\tif (pLast != NULL)\n\t\t\t{\n\t\t\t\tint tail_len;\n\n\t\t\t\ttail_len = pLast - szFilename;\n\t\t\t\tif (len + 1 + tail_len >= sizeof( \\\n\t\t\t\t\t\tpContext->config_path))\n\t\t\t\t{\n\t\t\t\t\tlogError(\"file: \"__FILE__\", line: %d, \"\\\n\t\t\t\t\t\t\"the path of the config \" \\\n\t\t\t\t\t\t\"file: %s is too long!\", \\\n\t\t\t\t\t\t__LINE__, szFilename);\n\t\t\t\t\treturn ENOSPC;\n\t\t\t\t}\n\n                *(pContext->config_path + len++) = '/';\n\t\t\t\tmemcpy(pContext->config_path + len, \\\n\t\t\t\t\tszFilename, tail_len);\n\t\t\t\tlen += tail_len;\n\t\t\t\t*(pContext->config_path + len) = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\n    old_annotation_count = g_annotation_count;\n\tresult = iniDoLoadFromFile(full_filename, pContext);\n    if (g_annotation_count > old_annotation_count)\n    {\n        iniDestroyAnnotations(old_annotation_count);\n    }\n\n\tif (result == 0)\n\t{\n\t\tiniSortItems(pContext);\n\t}\n\telse\n\t{\n\t\tiniFreeContext(pContext);\n\t}\n\n\treturn result;\n}\n\nstatic int iniDoLoadFromFile(const char *szFilename, \\\n\t\tIniContext *pContext)\n{\n\tchar *content;\n\tint result;\n\tint http_status;\n\tint content_len;\n\tint64_t file_size;\n\tchar error_info[512];\n\n\tif (strncasecmp(szFilename, \"http://\", 7) == 0)\n\t{\n\t\tif ((result=get_url_content(szFilename, 10, 60, &http_status, \\\n\t\t\t\t&content, &content_len, error_info)) != 0)\n\t\t{\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"get_url_content fail, \" \\\n\t\t\t\t\"url: %s, error info: %s\", \\\n\t\t\t\t__LINE__, szFilename, error_info);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (http_status != 200)\n\t\t{\n\t\t\tfree(content);\n\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\"HTTP status code: %d != 200, url: %s\", \\\n\t\t\t\t__LINE__, http_status, szFilename);\n\t\t\treturn EINVAL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif ((result=getFileContent(szFilename, &content, \\\n\t\t\t\t&file_size)) != 0)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tresult = iniLoadItemsFromBuffer(content, pContext);\n\tfree(content);\n\n\treturn result;\n}\n\nint iniLoadFromBufferEx(char *content, IniContext *pContext,\n    const char annotation_type, AnnotationEntry *annotations, const int count,\n    const char flags)\n{\n\tint result;\n    int old_annotation_count;\n\n\tif ((result=iniInitContext(pContext, annotation_type,\n                    annotations, count, flags)) != 0)\n\t{\n\t\treturn result;\n\t}\n\n    old_annotation_count = g_annotation_count;\n\tresult = iniLoadItemsFromBuffer(content, pContext);\n    if (g_annotation_count > old_annotation_count)\n    {\n        iniDestroyAnnotations(old_annotation_count);\n    }\n\n\tif (result == 0)\n\t{\n\t\tiniSortItems(pContext);\n\t}\n\telse\n\t{\n\t\tiniFreeContext(pContext);\n\t}\n\n\treturn result;\n}\n\nint iniLoadFromBuffer(char *content, IniContext *pContext)\n{\n    return iniLoadFromBufferEx(content, pContext,\n            FAST_INI_ANNOTATION_WITH_BUILTIN,\n            NULL, 0, FAST_INI_FLAGS_NONE);\n}\n\n\ntypedef int (*init_annotation_func0)(AnnotationEntry *annotation);\ntypedef int (*init_annotation_func1)(AnnotationEntry *annotation,\n        const char *arg1);\ntypedef int (*init_annotation_func2)(AnnotationEntry *annotation,\n        const char *arg1, const char *arg2);\ntypedef int (*init_annotation_func3)(AnnotationEntry *annotation,\n        const char *arg1, const char *arg2, const char *arg3);\n\nstatic int iniAddAnnotation(char *params)\n{\n#define MAX_PARAMS   5\n    char *cols[MAX_PARAMS];\n    char *func_name;\n    char *library;\n    AnnotationEntry annotation;\n    void *dlhandle;\n    void *init_func;\n    char symbol[64];\n    int argc;\n    int count;\n    int result;\n\n    trim(params);\n    count = fc_split_string(params, \" \\t\", cols, MAX_PARAMS);\n    if (count < 2)\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"invalid format, correct format: \"\n                \"#@add_annotation FUNC_NAME library ...\", __LINE__);\n        return EINVAL;\n    }\n\n    func_name = fc_trim(cols[0]);\n    library = fc_trim(cols[1]);\n    if (*func_name == '\\0')\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"empty func name, correct format: \"\n                \"#@add_annotation FUNC_NAME library ...\", __LINE__);\n        return EINVAL;\n    }\n    if (*library == '\\0')\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"empty library, correct format: \"\n                \"#@add_annotation FUNC_NAME library ...\", __LINE__);\n        return EINVAL;\n    }\n\n    if (iniFindAnnotation(g_annotations, func_name) != NULL)\n    {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"function %s already exist\", __LINE__, func_name);\n        return EEXIST;\n    }\n\n    if (strcmp(library, \"-\") == 0)\n    {\n        library = NULL;\n    }\n    else if (!fileExists(library))\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"library %s not exist\", __LINE__, library);\n        return ENOENT;\n    }\n\n    dlhandle = dlopen(library, RTLD_LAZY);\n    if (dlhandle == NULL)\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"dlopen %s fail, error info: %s\",\n                __LINE__, library != NULL ? library : \"\",\n                dlerror());\n        return EFAULT;\n    }\n\n    snprintf(symbol, sizeof(symbol), \"%s_init_annotation\", func_name);\n    init_func = dlsym(dlhandle, symbol);\n    if (init_func == NULL)\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"dlsym function %s fail, error info: %s\",\n                __LINE__, symbol, dlerror());\n        dlclose(dlhandle);\n        return ENOENT;\n    }\n\n    memset(&annotation, 0, sizeof(annotation));\n    argc = count - 2;\n    switch (argc)\n    {\n        case 0:\n            result = ((init_annotation_func0)init_func)(&annotation);\n            break;\n        case 1:\n            result = ((init_annotation_func1)init_func)(&annotation, cols[2]);\n            break;\n        case 2:\n            result = ((init_annotation_func2)init_func)(&annotation,\n                    cols[2], cols[3]);\n            break;\n        case 3:\n            result = ((init_annotation_func3)init_func)(&annotation,\n                    cols[2], cols[3], cols[4]);\n            break;\n        default:\n            result = 0;\n            break;\n    }\n\n    if (result != 0)\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"call function %s fail, ret: %d\",\n                __LINE__, symbol, result);\n        dlclose(dlhandle);\n        return EFAULT;\n    }\n\n    annotation.dlhandle = dlhandle;\n    return iniSetAnnotationCallBack(&annotation, 1);\n}\n\nstatic int iniDoLoadItemsFromBuffer(char *content, IniContext *pContext)\n{\n\tIniSection *pSection;\n\tIniItem *pItem;\n\tchar *pLine;\n\tchar *pLastEnd;\n\tchar *pEqualChar;\n    char pItemName[FAST_INI_ITEM_NAME_LEN + 1];\n    char *pAnnoItemLine;\n\tchar *pIncludeFilename;\n    char *pItemValues[100];\n    char pFuncName[FAST_INI_ITEM_NAME_LEN + 1];\n\tchar full_filename[MAX_PATH_SIZE];\n    int i;\n\tint nLineLen;\n\tint nNameLen;\n    int nItemCnt;\n\tint nValueLen;\n\tint result;\n    int isAnnotation;\n\n\tresult = 0;\n    pAnnoItemLine = NULL;\n    isAnnotation = 0;\n    *pFuncName = '\\0';\n\tpLastEnd = content - 1;\n\tpSection = pContext->current_section;\n    pItem = pSection->items + pSection->count;\n\n\twhile (pLastEnd != NULL)\n\t{\n\t\tpLine = pLastEnd + 1;\n\t\tpLastEnd = strchr(pLine, '\\n');\n\t\tif (pLastEnd != NULL)\n\t\t{\n\t\t\t*pLastEnd = '\\0';\n\t\t}\n\n        if (isAnnotation && pLine != pAnnoItemLine)\n        {\n            logWarning(\"file: \"__FILE__\", line: %d, \" \\\n                \"the @function annotation line \" \\\n                \"must follow by key=value line!\", __LINE__);\n            isAnnotation = 0;\n        }\n\n\t\tSTR_TRIM(pLine);\n\t\tif (*pLine == '#' && \\\n\t\t\tstrncasecmp(pLine+1, \"include\", 7) == 0 && \\\n\t\t\t(*(pLine+8) == ' ' || *(pLine+8) == '\\t'))\n\t\t{\n\t\t\tpIncludeFilename = strdup(pLine + 9);\n\t\t\tif (pIncludeFilename == NULL)\n\t\t\t{\n\t\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\t\"strdup %d bytes fail\", __LINE__, \\\n\t\t\t\t\t(int)strlen(pLine + 9) + 1);\n\t\t\t\tresult = errno != 0 ? errno : ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSTR_TRIM(pIncludeFilename);\n\t\t\tif (strncasecmp(pIncludeFilename, \"http://\", 7) == 0)\n\t\t\t{\n\t\t\t\tsnprintf(full_filename, sizeof(full_filename),\\\n\t\t\t\t\t\"%s\", pIncludeFilename);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (*pIncludeFilename == '/')\n\t\t\t\t{\n\t\t\t\tsnprintf(full_filename, sizeof(full_filename), \\\n\t\t\t\t\t\"%s\", pIncludeFilename);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tsnprintf(full_filename, sizeof(full_filename), \\\n\t\t\t\t\t\"%s/%s\", pContext->config_path, \\\n\t\t\t\t\t pIncludeFilename);\n\t\t\t\t}\n\n\t\t\t\tif (!fileExists(full_filename))\n\t\t\t\t{\n\t\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\t\"include file \\\"%s\\\" not exists, \" \\\n\t\t\t\t\t\"line: \\\"%s\\\"\", __LINE__, \\\n\t\t\t\t\tpIncludeFilename, pLine);\n\t\t\t\tfree(pIncludeFilename);\n\t\t\t\tresult = ENOENT;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n            pContext->current_section = &pContext->global;\n\t\t\tresult = iniDoLoadFromFile(full_filename, pContext);\n\t\t\tif (result != 0)\n\t\t\t{\n\t\t\t\tfree(pIncludeFilename);\n\t\t\t\tbreak;\n\t\t\t}\n\n            pContext->current_section = &pContext->global;\n\t\t\tpSection = pContext->current_section;\n            pItem = pSection->items + pSection->count;  //must re-asign\n\n\t\t\tfree(pIncludeFilename);\n\t\t\tcontinue;\n\t\t}\n        else if (*pLine == '#')\n        {\n            if (pContext->annotation_type == FAST_INI_ANNOTATION_DISABLE)\n            {\n                continue;\n            }\n\n            if (strncasecmp(pLine+1, \"@function\", 9) == 0 &&\n                    (*(pLine+10) == ' ' || *(pLine+10) == '\\t'))\n            {\n                nNameLen = strlen(pLine + 11);\n                if (nNameLen > FAST_INI_ITEM_NAME_LEN)\n                {\n                    nNameLen = FAST_INI_ITEM_NAME_LEN;\n                }\n                memcpy(pFuncName, pLine + 11, nNameLen);\n                pFuncName[nNameLen] = '\\0';\n                STR_TRIM(pFuncName);\n                if ((int)strlen(pFuncName) > 0)\n                {\n                    isAnnotation = 1;\n                    pAnnoItemLine = pLastEnd + 1;\n                }\n                else\n                {\n                    logWarning(\"file: \"__FILE__\", line: %d, \" \\\n                            \"the function name of annotation line is empty\", \\\n                            __LINE__);\n                }\n            }\n            else if (strncasecmp(pLine+1, \"@add_annotation\", 15) == 0 &&\n                    (*(pLine+16) == ' ' || *(pLine+16) == '\\t'))\n            {\n                result = iniAddAnnotation(pLine + 17);\n                if (!(result == 0 || result == EEXIST))\n                {\n                    break;\n                }\n            }\n\n            continue;\n        }\n\n\t\tif (*pLine == '\\0')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tnLineLen = strlen(pLine);\n\t\tif (*pLine == '[' && *(pLine + (nLineLen - 1)) == ']') //section\n\t\t{\n\t\t\tchar *section_name;\n\t\t\tint section_len;\n\n\t\t\t*(pLine + (nLineLen - 1)) = '\\0';\n\t\t\tsection_name = pLine + 1; //skip [\n\n\t\t\tSTR_TRIM(section_name);\n\t\t\tif (*section_name == '\\0') //global section\n\t\t\t{\n\t\t\t\tpContext->current_section = &pContext->global;\n\t\t\t\tpSection = pContext->current_section;\n                pItem = pSection->items + pSection->count;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsection_len = strlen(section_name);\n\t\t\tpSection = (IniSection *)hash_find(&pContext->sections,\\\n\t\t\t\t\tsection_name, section_len);\n\t\t\tif (pSection == NULL)\n\t\t\t{\n\t\t\t\tpSection = (IniSection *)malloc(sizeof(IniSection));\n\t\t\t\tif (pSection == NULL)\n\t\t\t\t{\n\t\t\t\t\tresult = errno != 0 ? errno : ENOMEM;\n\t\t\t\t\tlogError(\"file: \"__FILE__\", line: %d, \"\\\n\t\t\t\t\t\t\"malloc %d bytes fail, \" \\\n\t\t\t\t\t\t\"errno: %d, error info: %s\", \\\n\t\t\t\t\t\t__LINE__, \\\n\t\t\t\t\t\t(int)sizeof(IniSection), \\\n\t\t\t\t\t\tresult, STRERROR(result));\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemset(pSection, 0, sizeof(IniSection));\n\t\t\t\tresult = hash_insert(&pContext->sections, \\\n\t\t\t\t\t  section_name, section_len, pSection);\n\t\t\t\tif (result < 0)\n\t\t\t\t{\n\t\t\t\t\tresult *= -1;\n\t\t\t\t\tlogError(\"file: \"__FILE__\", line: %d, \"\\\n\t\t\t\t\t\t\"insert into hash table fail, \"\\\n\t\t\t\t\t\t\"errno: %d, error info: %s\", \\\n\t\t\t\t\t\t__LINE__, result, \\\n\t\t\t\t\t\tSTRERROR(result));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpContext->current_section = pSection;\n            pItem = pSection->items + pSection->count;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpEqualChar = strchr(pLine, '=');\n\t\tif (pEqualChar == NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tnNameLen = pEqualChar - pLine;\n\t\tnValueLen = strlen(pLine) - (nNameLen + 1);\n\t\tif (nNameLen > FAST_INI_ITEM_NAME_LEN)\n\t\t{\n            logWarning(\"file: \"__FILE__\", line: %d, \"\n                    \"name length: %d exceeds %d, \"\n                    \"truncate it to \\\"%.*s\\\"\", __LINE__,\n                    nNameLen, FAST_INI_ITEM_NAME_LEN,\n                    FAST_INI_ITEM_NAME_LEN, pLine);\n\t\t\tnNameLen = FAST_INI_ITEM_NAME_LEN;\n\t\t}\n\n\t\tif (nValueLen > FAST_INI_ITEM_VALUE_LEN)\n\t\t{\n            logWarning(\"file: \"__FILE__\", line: %d, \"\n                    \"value length: %d exceeds %d, \"\n                    \"truncate it to \\\"%.*s\\\"\", __LINE__,\n                    nValueLen, FAST_INI_ITEM_VALUE_LEN,\n                    FAST_INI_ITEM_VALUE_LEN, pEqualChar + 1);\n\t\t\tnValueLen = FAST_INI_ITEM_VALUE_LEN;\n\t\t}\n\n\t\tif (pSection->count >= pSection->alloc_count)\n        {\n            result = remallocSection(pSection, &pItem);\n            if (result != 0)\n            {\n                break;\n            }\n\t\t}\n\n\t\tmemcpy(pItem->name, pLine, nNameLen);\n\t\tmemcpy(pItem->value, pEqualChar + 1, nValueLen);\n\n\t\tSTR_TRIM(pItem->name);\n\t\tSTR_TRIM(pItem->value);\n\n        if (isAnnotation)\n        {\n            AnnotationEntry *pAnnoEntryBase;\n            AnnotationEntry *pAnnoEntry = NULL;\n\n            isAnnotation = 0;\n            if ((pAnnoEntryBase=iniGetAnnotations(pContext)) == NULL)\n            {\n                pAnnoEntryBase = g_annotations;\n            }\n            if (pAnnoEntryBase == NULL)\n            {\n                logWarning(\"file: \"__FILE__\", line: %d, \" \\\n                    \"not set annotationMap and (%s) will use \" \\\n                    \"the item value (%s)\", __LINE__, pItem->name,\n                    pItem->value);\n                pSection->count++;\n                pItem++;\n                continue;\n            }\n\n            nItemCnt = -1;\n            for (i=0; i<2; i++)\n            {\n                pAnnoEntry = iniFindAnnotation(pAnnoEntryBase, pFuncName);\n                if (pAnnoEntry != NULL)\n                {\n                    if (pAnnoEntry->func_init != NULL && !pAnnoEntry->inited)\n                    {\n                        pAnnoEntry->inited = true;\n                        pAnnoEntry->func_init(pAnnoEntry);\n                    }\n\n                    if (pAnnoEntry->func_get != NULL)\n                    {\n                        nItemCnt = pAnnoEntry->func_get(pContext,\n                                pAnnoEntry, pItem, pItemValues, 100);\n                    }\n                    break;\n                }\n\n                if (g_annotations != NULL && pAnnoEntryBase != g_annotations)\n                {\n                    pAnnoEntryBase = g_annotations;\n                }\n                else\n                {\n                    break;\n                }\n            }\n\n            if (nItemCnt == -1)\n            {\n                logWarning(\"file: \"__FILE__\", line: %d, \" \\\n                    \"not found corresponding annotation function: %s, \" \\\n                    \"\\\"%s\\\" will use the item value \\\"%s\\\"\", __LINE__,\n                    pFuncName, pItem->name, pItem->value);\n                pSection->count++;\n                pItem++;\n                continue;\n            }\n            else if (nItemCnt == 0)\n            {\n                logWarning(\"file: \"__FILE__\", line: %d, \" \\\n                    \"annotation function %s execute fail, \" \\\n                    \"\\\"%s\\\" will use the item value \\\"%s\\\"\", __LINE__,\n                    pFuncName, pItem->name, pItem->value);\n                pSection->count++;\n                pItem++;\n                continue;\n            }\n\n            strcpy(pItemName, pItem->name);\n            nNameLen = strlen(pItemName);\n            for (i = 0; i < nItemCnt; i++)\n            {\n                nValueLen = strlen(pItemValues[i]);\n                if (nValueLen > FAST_INI_ITEM_VALUE_LEN)\n                {\n                    logWarning(\"file: \"__FILE__\", line: %d, \"\n                            \"value length: %d exceeds %d, \"\n                            \"truncate it to \\\"%.*s\\\"\", __LINE__,\n                            nValueLen, FAST_INI_ITEM_VALUE_LEN,\n                            FAST_INI_ITEM_VALUE_LEN, pItemValues[i]);\n                    nValueLen = FAST_INI_ITEM_VALUE_LEN;\n                }\n                strcpy(pItem->name, pItemName);\n                memcpy(pItem->value, pItemValues[i], nValueLen);\n                pItem->value[nValueLen] = '\\0';\n                pSection->count++;\n                pItem++;\n                if (pSection->count >= pSection->alloc_count)\n                {\n                    result = remallocSection(pSection, &pItem);\n                    if (result != 0)\n                    {\n                        break;\n                    }\n                }\n            }\n\n            if (pAnnoEntry != NULL && pAnnoEntry->func_free != NULL)\n            {\n                pAnnoEntry->func_free(pAnnoEntry, pItemValues, nItemCnt);\n            }\n            continue;\n        }\n\n\t\tpSection->count++;\n\t\tpItem++;\n\t}\n\n    if (result == 0 && isAnnotation)\n    {\n        logWarning(\"file: \"__FILE__\", line: %d, \" \\\n            \"the @function annotation line \" \\\n            \"must follow by key=value line!\", __LINE__);\n    }\n\n\treturn result;\n}\n\nstatic CDCPair *iniGetCDCPair(IniContext *pContext)\n{\n    int i;\n    if (g_dynamic_contents[g_dynamic_content_index].context == pContext)\n    {\n        return g_dynamic_contents + g_dynamic_content_index;\n    }\n\n    if (g_dynamic_content_count > 0)\n    {\n        for (i=0; i<_MAX_DYNAMIC_CONTENTS; i++)\n        {\n            if (g_dynamic_contents[i].context == pContext)\n            {\n                g_dynamic_content_index = i;\n                return g_dynamic_contents + g_dynamic_content_index;\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic CDCPair *iniAllocCDCPair(IniContext *pContext)\n{\n    int i;\n    CDCPair *pair;\n    if ((pair=iniGetCDCPair(pContext)) != NULL)\n    {\n        return pair;\n    }\n\n    if (g_dynamic_content_count == _MAX_DYNAMIC_CONTENTS)\n    {\n        return NULL;\n    }\n\n    for (i=0; i<_MAX_DYNAMIC_CONTENTS; i++)\n    {\n        if (!g_dynamic_contents[i].used)\n        {\n            g_dynamic_contents[i].used = true;\n            g_dynamic_contents[i].context = pContext;\n            g_dynamic_content_index = i;\n            g_dynamic_content_count++;\n            return g_dynamic_contents + g_dynamic_content_index;\n        }\n    }\n\n    return NULL;\n}\n\nstatic DynamicContents *iniAllocDynamicContent(IniContext *pContext)\n{\n    static CDCPair *pair;\n\n    pair = iniAllocCDCPair(pContext);\n    if (pair == NULL)\n    {\n        return NULL;\n    }\n    return &pair->dynamicContents;\n}\n\nstatic SetDirectiveVars *iniGetVars(IniContext *pContext)\n{\n    static CDCPair *pair;\n\n    pair = iniGetCDCPair(pContext);\n    if (pair == NULL)\n    {\n        return NULL;\n    }\n    return &pair->set;\n}\n\nstatic DynamicAnnotations *iniAllocDynamicAnnotation(IniContext *pContext)\n{\n    static CDCPair *pair;\n\n    pair = iniAllocCDCPair(pContext);\n    if (pair == NULL)\n    {\n        return NULL;\n    }\n    return &pair->dynamicAnnotations;\n}\n\nstatic AnnotationEntry *iniGetAnnotations(IniContext *pContext)\n{\n    static CDCPair *pair;\n\n    pair = iniGetCDCPair(pContext);\n    if (pair == NULL)\n    {\n        return NULL;\n    }\n    return pair->dynamicAnnotations.annotations;\n}\n\nstatic SetDirectiveVars *iniAllocVars(IniContext *pContext, const bool initVars)\n{\n    static CDCPair *pair;\n    SetDirectiveVars *set;\n\n    set = iniGetVars(pContext);\n    if (set == NULL)\n    {\n        pair = iniAllocCDCPair(pContext);\n        if (pair == NULL)\n        {\n            return NULL;\n        }\n        set = &pair->set;\n    }\n\n    if (initVars && set->vars == NULL)\n    {\n        set->vars = (HashArray *)malloc(sizeof(HashArray));\n        if (set->vars == NULL)\n        {\n            logWarning(\"file: \"__FILE__\", line: %d, \"\n                    \"malloc %d bytes fail\",\n                    __LINE__, (int)sizeof(HashArray));\n            return NULL;\n        }\n        if (hash_init_ex(set->vars, simple_hash, 17, 0.75, 0, true) != 0)\n        {\n            free(set->vars);\n            set->vars = NULL;\n            return NULL;\n        }\n    }\n\n    return set;\n}\n\nstatic void iniFreeDynamicContent(IniContext *pContext)\n{\n    CDCPair *pCDCPair;\n    DynamicContents *pDynamicContents;\n    DynamicAnnotations *pDynamicAnnotations;\n    int i;\n\n    if (g_dynamic_content_count == 0)\n    {\n        return;\n    }\n\n    if (g_dynamic_contents[g_dynamic_content_index].context == pContext)\n    {\n        pCDCPair = g_dynamic_contents + g_dynamic_content_index;\n    }\n    else\n    {\n        pCDCPair = NULL;\n        for (i=0; i<_MAX_DYNAMIC_CONTENTS; i++)\n        {\n            if (g_dynamic_contents[i].context == pContext)\n            {\n                pCDCPair = g_dynamic_contents + i;\n                break;\n            }\n        }\n        if (pCDCPair == NULL)\n        {\n            return;\n        }\n    }\n\n    pDynamicContents = &pCDCPair->dynamicContents;\n    if (pDynamicContents->contents != NULL)\n    {\n        for (i=0; i<pDynamicContents->count; i++)\n        {\n            if (pDynamicContents->contents[i] != NULL)\n            {\n                free(pDynamicContents->contents[i]);\n            }\n        }\n        free(pDynamicContents->contents);\n        pDynamicContents->contents = NULL;\n        pDynamicContents->alloc_count = 0;\n        pDynamicContents->count = 0;\n    }\n\n    pDynamicAnnotations = &pCDCPair->dynamicAnnotations;\n    if (pDynamicAnnotations->annotations != NULL)\n    {\n        free(pDynamicAnnotations->annotations);\n        pDynamicAnnotations->annotations = NULL;\n        pDynamicAnnotations->alloc_count = 0;\n        pDynamicAnnotations->count = 0;\n    }\n\n    pCDCPair->used = false;\n    pCDCPair->context = NULL;\n    g_dynamic_content_count--;\n}\n\nstatic char *iniAllocContent(IniContext *pContext, const int content_len)\n{\n    char *buff;\n    DynamicContents *pDynamicContents;\n    pDynamicContents = iniAllocDynamicContent(pContext);\n    if (pDynamicContents == NULL)\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"malloc dynamic contents fail\", __LINE__);\n        return NULL;\n    }\n    if (pDynamicContents->count >= pDynamicContents->alloc_count)\n    {\n        int alloc_count;\n        int bytes;\n        char **contents;\n        if (pDynamicContents->alloc_count == 0)\n        {\n            alloc_count = 8;\n        }\n        else\n        {\n            alloc_count = pDynamicContents->alloc_count * 2;\n        }\n        bytes = sizeof(char *) * alloc_count;\n        contents = (char **)malloc(bytes);\n        if (contents == NULL)\n        {\n            logError(\"file: \"__FILE__\", line: %d, \"\n                    \"malloc %d bytes fail\", __LINE__, bytes);\n            return NULL;\n        }\n        memset(contents, 0, bytes);\n        if (pDynamicContents->count > 0)\n        {\n            memcpy(contents, pDynamicContents->contents,\n                    sizeof(char *) * pDynamicContents->count);\n            free(pDynamicContents->contents);\n        }\n        pDynamicContents->contents = contents;\n        pDynamicContents->alloc_count = alloc_count;\n    }\n\n    buff = malloc(content_len);\n    if (buff == NULL)\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"malloc %d bytes fail\", __LINE__, content_len);\n        return NULL;\n    }\n    pDynamicContents->contents[pDynamicContents->count++] = buff;\n    return buff;\n}\n\nstatic int iniCheckAllocAnnotations(DynamicAnnotations *pDynamicAnnotations,\n        const int annotation_count)\n{\n    int alloc_count;\n    int bytes;\n    AnnotationEntry *annotations;\n\n    if (pDynamicAnnotations->count + annotation_count <\n            pDynamicAnnotations->alloc_count)\n    {\n        return 0;\n    }\n\n    if (pDynamicAnnotations->alloc_count == 0)\n    {\n        alloc_count = 8;\n    }\n    else\n    {\n        alloc_count = pDynamicAnnotations->alloc_count * 2;\n    }\n    while (alloc_count <= pDynamicAnnotations->count + annotation_count)\n    {\n        alloc_count *= 2;\n    }\n    bytes = sizeof(AnnotationEntry) * alloc_count;\n    annotations = (AnnotationEntry *)malloc(bytes);\n    if (annotations == NULL)\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"malloc %d bytes fail\", __LINE__, bytes);\n        return ENOMEM;\n    }\n    memset(annotations, 0, bytes);\n    if (pDynamicAnnotations->count > 0)\n    {\n        memcpy(annotations, pDynamicAnnotations->annotations,\n                sizeof(AnnotationEntry) * pDynamicAnnotations->count);\n        free(pDynamicAnnotations->annotations);\n    }\n    pDynamicAnnotations->annotations = annotations;\n    pDynamicAnnotations->alloc_count = alloc_count;\n    return 0;\n}\n\nstatic DynamicAnnotations *iniAllocAnnotations(IniContext *pContext,\n        const int annotation_count)\n{\n    DynamicAnnotations *pDynamicAnnotations;\n    pDynamicAnnotations = iniAllocDynamicAnnotation(pContext);\n    if (pDynamicAnnotations == NULL)\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"malloc dynamic annotations fail\", __LINE__);\n        return NULL;\n    }\n    if (iniCheckAllocAnnotations(pDynamicAnnotations, annotation_count) == 0)\n    {\n        return pDynamicAnnotations;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\nstatic bool iniMatchValue(const char *target, char **values, const int count)\n{\n    int i;\n    for (i=0; i<count; i++)\n    {\n        if (strcmp(target, values[i]) == 0)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\nstatic bool iniMatchCIDR(const char *target, const char *ip_addr,\n        const char *pSlash)\n{\n\tchar *pReservedEnd;\n\tchar ip_part[IP_ADDRESS_SIZE];\n\tint ip_len;\n\tint network_bits;\n\tstruct in_addr addr;\n\tuint32_t network_hip;\n\tuint32_t target_hip;\n    uint32_t network_mask;\n\n\tip_len = pSlash - ip_addr;\n\tif (ip_len == 0 || ip_len >= IP_ADDRESS_SIZE)\n\t{\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n\t\t\t\"invalid ip address: %s\", __LINE__, ip_addr);\n\t\treturn false;\n\t}\n\tmemcpy(ip_part, ip_addr, ip_len);\n\t*(ip_part + ip_len) = '\\0';\n\t\n\tpReservedEnd = NULL;\n\tnetwork_bits = strtol(pSlash + 1, &pReservedEnd, 10);\n\tif (!(pReservedEnd == NULL || *pReservedEnd == '\\0'))\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"ip address: %s, invalid network bits: %s\",\n\t\t\t__LINE__, ip_addr, pSlash + 1);\n\t\treturn false;\n\t}\n\n\tif (network_bits < 8 || network_bits > 30)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"ip address: %s, invalid network bits: %d, \" \\\n\t\t\t\"it should >= 8 and <= 30\", \\\n\t\t\t__LINE__, ip_addr, network_bits);\n\t\treturn false;\n\t}\n\n\tif (inet_pton(AF_INET, ip_part, &addr) != 1)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"ip address: %s, invalid ip part: %s\", \\\n\t\t\t__LINE__, ip_addr, ip_part);\n\t\treturn false;\n\t}\n\tnetwork_hip = ntohl(addr.s_addr);\n\n\tif (inet_pton(AF_INET, target, &addr) != 1)\n\t{\n\t\tlogError(\"file: \"__FILE__\", line: %d, \"\n\t\t\t\"invalid ip: %s\", __LINE__, target);\n\t\treturn false;\n\t}\n\ttarget_hip = ntohl(addr.s_addr);\n\n    network_mask = ((1 << network_bits) - 1) << (32 - network_bits);\n    return (target_hip & network_mask) == (network_hip & network_mask);\n}\n\nstatic bool iniMatchIP(const char *target, char **values, const int count)\n{\n    int i;\n\tchar *pSlash;\n\n    for (i=0; i<count; i++)\n    {\n        pSlash = strchr(values[i], '/');\n        if (pSlash == NULL)\n        {\n            if (strcmp(target, values[i]) == 0)\n            {\n                return true;\n            }\n        }\n        else\n        {\n            if (iniMatchCIDR(target, values[i], pSlash))\n            {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nstatic bool iniCalcCondition(char *condition, const int condition_len,\n         IniContext *pContext)\n{\n    /*\n     * current only support %{VARIABLE} in [x,y,..]\n     * support variables are: LOCAL_IP, LOCAL_HOST and\n     * variables by #@set directive.\n     * such as: %{LOCAL_IP} in [10.0.11.89,10.0.11.99]\n     * local ip support CIDR addresses such as 172.16.12.0/22\n     **/\n#define _PREPROCESS_VARIABLE_TYPE_LOCAL_IP   1\n#define _PREPROCESS_VARIABLE_TYPE_LOCAL_HOST 2\n#define _PREPROCESS_VARIABLE_TYPE_SET        3\n#define _PREPROCESS_MAX_LIST_VALUE_COUNT    32\n    char *p;\n    char *pEnd;\n    char *pBraceEnd;\n    char *pSquareEnd;\n    char *values[_PREPROCESS_MAX_LIST_VALUE_COUNT];\n    char *varStr = NULL;\n    int varLen = 0;\n    int varType;\n    int count;\n    int len;\n    int i;\n\n    pEnd = condition + condition_len;\n    p = pEnd - 1;\n    while (p > condition && (*p == ' ' || *p == '\\t'))\n    {\n        p--;\n    }\n    if (*p != ']')\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"expect \\\"]\\\", condition: %.*s\", __LINE__,\n                condition_len, condition);\n        return false;\n    }\n    pSquareEnd = p;\n\n    p = condition;\n    while (p < pEnd && (*p == ' ' || *p == '\\t'))\n    {\n        p++;\n    }\n\n    len = pEnd - p;\n    if (len < 8 || !(*p == '%' && *(p+1) == '{'))\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid condition: %.*s, \"\n                \"correct format: %%{variable} in [...]\",\n                __LINE__, condition_len, condition);\n        return false;\n    }\n\n    if ((len > _PREPROCESS_VARIABLE_LEN_LOCAL_IP) &&\n            (memcmp(p, _PREPROCESS_VARIABLE_STR_LOCAL_IP,\n                _PREPROCESS_VARIABLE_LEN_LOCAL_IP) == 0))\n    {\n        varType = _PREPROCESS_VARIABLE_TYPE_LOCAL_IP;\n        p += _PREPROCESS_VARIABLE_LEN_LOCAL_IP;\n    }\n    else if ((len > _PREPROCESS_VARIABLE_LEN_LOCAL_HOST) &&\n            memcmp(p, _PREPROCESS_VARIABLE_STR_LOCAL_HOST,\n                _PREPROCESS_VARIABLE_LEN_LOCAL_HOST) == 0)\n    {\n        varType = _PREPROCESS_VARIABLE_TYPE_LOCAL_HOST;\n        p += _PREPROCESS_VARIABLE_LEN_LOCAL_HOST;\n    }\n    else\n    {\n        varType = _PREPROCESS_VARIABLE_TYPE_SET;\n        pBraceEnd = (char *)memchr(p + 2, '}', len - 2);\n        if (pBraceEnd == NULL)\n        {\n            logWarning(\"file: \"__FILE__\", line: %d, \"\n                    \"invalid condition: %.*s, expect }\",\n                    __LINE__, condition_len, condition);\n            return false;\n        }\n\n        varStr = p + 2;\n        varLen = pBraceEnd - varStr;\n        if (varLen == 0)\n        {\n            logWarning(\"file: \"__FILE__\", line: %d, \"\n                    \"invalid condition: %.*s, \"\n                    \"expect variable name\", __LINE__,\n                    condition_len, condition);\n            return false;\n        }\n        p = pBraceEnd + 1;\n    }\n\n    while (p < pEnd && (*p == ' ' || *p == '\\t'))\n    {\n        p++;\n    }\n    if (pEnd - p < 4 || memcmp(p, \"in\", 2) != 0)\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"expect \\\"in\\\", condition: %.*s\", __LINE__,\n                condition_len, condition);\n        return false;\n    }\n    p += 2;  //skip in\n\n    while (p < pEnd && (*p == ' ' || *p == '\\t'))\n    {\n        p++;\n    }\n    if (*p != '[')\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"expect \\\"[\\\", condition: %.*s\", __LINE__,\n                condition_len, condition);\n        return false;\n    }\n\n    *pSquareEnd = '\\0';\n    count = splitEx(p + 1, ',', values,\n            _PREPROCESS_MAX_LIST_VALUE_COUNT);\n    for (i=0; i<count; i++)\n    {\n        values[i] = fc_trim(values[i]);\n    }\n    if (varType == _PREPROCESS_VARIABLE_TYPE_LOCAL_HOST)\n    {\n        char host[128];\n        if (gethostname(host, sizeof(host)) != 0)\n        {\n            logWarning(\"file: \"__FILE__\", line: %d, \"\n                    \"call gethostname fail, \"\n                    \"errno: %d, error info: %s\", __LINE__,\n                    errno, STRERROR(errno));\n            return false;\n        }\n        return iniMatchValue(host, values, count);\n    }\n    else if (varType == _PREPROCESS_VARIABLE_TYPE_LOCAL_IP)\n    {\n        const char *local_ip;\n        local_ip = get_first_local_ip();\n        while (local_ip != NULL)\n        {\n            if (iniMatchIP(local_ip, values, count))\n            {\n                return true;\n            }\n            local_ip = get_next_local_ip(local_ip);\n        }\n    }\n    else\n    {\n        char *value;\n        SetDirectiveVars *set;\n\n        set = iniGetVars(pContext);\n        if (set != NULL && set->vars != NULL)\n        {\n            value = (char *)hash_find(set->vars, varStr, varLen);\n            if (value == NULL)\n            {\n                logWarning(\"file: \"__FILE__\", line: %d, \"\n                        \"variable \\\"%.*s\\\" not exist\", __LINE__,\n                        varLen, varStr);\n            }\n            else\n            {\n                return iniMatchValue(value, values, count);\n            }\n        }\n        else\n        {\n            logWarning(\"file: \"__FILE__\", line: %d, \"\n                    \"variable \\\"%.*s\\\" not exist\", __LINE__,\n                    varLen, varStr);\n            return false;\n        }\n    }\n\n    return false;\n}\n\nstatic char *iniFindTag(char *content, char *pStart,\n        const char *tagStr, const int tagLen)\n{\n    char *p;\n\n    while (1)\n    {\n        p = strstr(pStart, tagStr);\n        if (p == NULL)\n        {\n            return NULL;\n        }\n        if (isLeadingSpacesLine(content, p))\n        {\n            return p;\n        }\n        pStart = p + tagLen;\n    }\n}\n\nstatic char *iniFindAloneTag(char *content, const int content_len,\n        char *pStart, const char *tagStr, const int tagLen)\n{\n    char *p;\n\n    while ((p=iniFindTag(content, pStart, tagStr, tagLen)) != NULL)\n    {\n        if (isTrailingSpacesLine(p + tagLen, content + content_len))\n        {\n            return p;\n        }\n    }\n\n    return NULL;\n}\n\nstatic int iniDoProccessSet(char *pSet, char **ppSetEnd,\n        IniContext *pContext)\n{\n    char *pStart;\n    char buff[FAST_INI_ITEM_NAME_LEN + FAST_INI_ITEM_VALUE_LEN + 1];\n    char output[256];\n    int result;\n    int len;\n    bool is_exec;\n    char *parts[2];\n    char *key;\n    char *value;\n    int value_len;\n    char *new_value;\n    SetDirectiveVars *set;\n\n    pStart = pSet + _PREPROCESS_TAG_LEN_SET;\n    *ppSetEnd = strchr(pStart, '\\n');\n    if (*ppSetEnd == NULL) {\n        return EINVAL;\n    }\n\n    len = *ppSetEnd - pStart;\n    if (len <= 1 || len >= (int)sizeof(buff)) {\n        return EINVAL;\n    }\n\n    memcpy(buff, pStart, len);\n    *(buff + len) = '\\0';\n    if (splitEx(buff, '=', parts, 2) != 2) {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid set format: %s%s\",\n                __LINE__, _PREPROCESS_TAG_STR_SET, buff);\n        return EFAULT;\n    }\n\n    if ((set=iniAllocVars(pContext, true)) == NULL) {\n        return ENOMEM;\n    }\n\n    key = fc_trim(parts[0]);\n    value = fc_trim(parts[1]);\n    value_len = strlen(value);\n    is_exec = (value_len > 3 && (*value == '$' && *(value + 1) == '(')\n            &&  *(value + value_len - 1) == ')');\n\n    pStart = strstr(value, \"%{\");\n    if (pStart != NULL && strchr(pStart + 2, '}') != NULL) {\n        new_value = doReplaceVars(pContext, value, _LINE_BUFFER_SIZE);\n        if (new_value != NULL) {\n            value_len = strlen(new_value);\n        }\n        else {\n            new_value = value;  //rollback\n        }\n    }\n    else {\n        new_value = value;\n    }\n\n    if (is_exec) {\n        char *cmd;\n        cmd = new_value + 2;\n        *(new_value + value_len - 1) = '\\0'; //remove ')'\n        logDebug(\"file: \"__FILE__\", line: %d, cmd: %s\", __LINE__, cmd);\n\n        if ((pContext->flags & FAST_INI_FLAGS_SHELL_EXECUTE) != 0) {\n            if ((result=getExecResult(cmd, output, sizeof(output))) != 0) {\n                logWarning(\"file: \"__FILE__\", line: %d, \"\n                        \"exec %s fail, errno: %d, error info: %s\",\n                        __LINE__, cmd, result, STRERROR(result));\n                return result;\n            }\n            if (*output == '\\0') {\n                logWarning(\"file: \"__FILE__\", line: %d, \"\n                        \"empty reply when exec: %s\", __LINE__, cmd);\n            }\n\n            fc_trim(output);\n            value_len = strlen(output);\n            if (new_value != value) {\n                free(new_value);\n            }\n            new_value = strdup(output);\n            if (new_value == NULL) {\n                logWarning(\"file: \"__FILE__\", line: %d, \"\n                        \"malloc %d bytes fail\", __LINE__, value_len + 1);\n                new_value = value;\n                value_len = 0;\n            }\n        }\n        else {\n            logWarning(\"file: \"__FILE__\", line: %d, \"\n                    \"shell execute disabled, cmd: %s\", __LINE__, cmd);\n            *new_value = '\\0';\n            value_len = 0;\n        }\n    }\n\n    result = hash_insert_ex(set->vars, key, strlen(key),\n            new_value, value_len + 1, false);\n    if (new_value != value) {\n        free(new_value);\n    }\n    return result >= 0 ? 0 : -1 * result;\n}\n\nstatic int iniProccessSet(char *content, char *pEnd,\n        IniContext *pContext)\n{\n    int result;\n    SetDirectiveVars *set;\n    char *pStart;\n    char *pSet;\n    char *pSetEnd;\n\n    if ((set=iniAllocVars(pContext, false)) == NULL)\n    {\n        return ENOMEM;\n    }\n\n    pStart = content + set->offset;\n    while (pStart < pEnd)\n    {\n        pSet = iniFindTag(content, pStart, _PREPROCESS_TAG_STR_SET,\n                _PREPROCESS_TAG_LEN_SET);\n        if (pSet == NULL || pSet >= pEnd)\n        {\n            break;\n        }\n\n        if ((result=iniDoProccessSet(pSet, &pSetEnd, pContext)) == 0)\n        {\n            pStart = pSetEnd;\n        }\n        else\n        {\n            if (result == EINVAL)\n            {\n                char *pNewLine;;\n                pNewLine = pSet + _PREPROCESS_TAG_LEN_SET;\n                while (pNewLine < pEnd && *pNewLine != '\\n')\n                {\n                    ++pNewLine;\n                }\n                logWarning(\"file: \"__FILE__\", line: %d, \"\n                        \"invalid set format: %.*s\", __LINE__,\n                        (int)(pNewLine - pSet), pSet);\n            }\n            pStart = pSet + _PREPROCESS_TAG_LEN_SET;\n        }\n    }\n\n    set->offset = pEnd - content;\n    return 0;\n}\n\nstatic char *iniProccessIf(char *content, const int content_len,\n        int *offset, IniContext *pContext, int *new_content_len)\n{\n    char *pStart;\n    char *pEnd;\n    char *pCondition;\n    char *pElse;\n    char *pIfPart;\n    char *pElsePart;\n    int conditionLen;\n    int ifPartLen;\n    int elsePartLen;\n    int copyLen;\n    char *newContent;\n    char *pDest;\n\n    *new_content_len = content_len;\n    pStart = iniFindTag(content, content + (*offset),\n            _PREPROCESS_TAG_STR_IF, _PREPROCESS_TAG_LEN_IF);\n    if (pStart == NULL)\n    {\n        *offset = *new_content_len;\n        iniProccessSet(content, content + content_len, pContext);\n        return content;\n    }\n\n    iniProccessSet(content, pStart, pContext);\n\n    pCondition = pStart + _PREPROCESS_TAG_LEN_IF;\n    pIfPart = strchr(pCondition, '\\n');\n    if (pIfPart == NULL)\n    {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"expect new line (\\\\n) for %s\",\n                __LINE__, pStart);\n        *offset = *new_content_len;\n        return content;\n    }\n    conditionLen = pIfPart - pCondition;\n\n    pEnd = iniFindAloneTag(content, content_len, pIfPart,\n            _PREPROCESS_TAG_STR_ENDIF, _PREPROCESS_TAG_LEN_ENDIF);\n    if (pEnd == NULL)\n    {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"expect %s for %.*s\",\n                __LINE__, _PREPROCESS_TAG_STR_ENDIF,\n                (int)(pIfPart - pStart), pStart);\n        *offset = *new_content_len;\n        return content;\n    }\n\n    pElse = iniFindAloneTag(content, content_len, pIfPart,\n            _PREPROCESS_TAG_STR_ELSE, _PREPROCESS_TAG_LEN_ELSE);\n    if (pElse == NULL || pElse > pEnd)\n    {\n        ifPartLen = pEnd - pIfPart;\n        pElsePart = NULL;\n        elsePartLen = 0;\n    }\n    else\n    {\n        ifPartLen = pElse - pIfPart;\n        pElsePart = strchr(pElse + _PREPROCESS_TAG_LEN_ELSE, '\\n');\n        if (pElsePart == NULL)\n        {\n            *offset = (pEnd + _PREPROCESS_TAG_LEN_ENDIF) - content;\n            return content;\n        }\n\n        elsePartLen = pEnd - pElsePart;\n    }\n\n    newContent = iniAllocContent(pContext, content_len);\n    if (newContent == NULL)\n    {\n        *offset = (pEnd + _PREPROCESS_TAG_LEN_ENDIF) - content;\n        return NULL;\n    }\n\n    pDest = newContent;\n    copyLen = pStart - content;\n    if (copyLen > 0)\n    {\n        memcpy(pDest, content, copyLen);\n        pDest += copyLen;\n    }\n    *offset = copyLen;\n\n    if (iniCalcCondition(pCondition, conditionLen, pContext))\n    {\n        if (ifPartLen > 0)\n        {\n            memcpy(pDest, pIfPart, ifPartLen);\n            pDest += ifPartLen;\n        }\n    }\n    else\n    {\n        if (elsePartLen > 0)\n        {\n            memcpy(pDest, pElsePart, elsePartLen);\n            pDest += elsePartLen;\n        }\n    }\n\n    copyLen = (content + content_len) - (pEnd + _PREPROCESS_TAG_LEN_ENDIF);\n    if (copyLen > 0)\n    {\n        memcpy(pDest, pEnd + _PREPROCESS_TAG_LEN_ENDIF, copyLen);\n        pDest += copyLen;\n    }\n\n    *pDest = '\\0';\n    *new_content_len = pDest - newContent;\n    return newContent;\n}\n\nstatic char *iniGetInteger(char *str, char *pEnd, int *nlen)\n{\n    char *p;\n    char *pNumber;\n\n    p = str;\n    while (p < pEnd && (*p == ' ' || *p == '\\t'))\n    {\n        p++;\n    }\n\n    pNumber = p;\n    while (p < pEnd && (*p >= '0' && *p <= '9'))\n    {\n        p++;\n    }\n\n    *nlen = p - pNumber;\n    return pNumber;\n}\n\nstatic int iniParseForRange(char *range, const int range_len,\n        char **id, int *idLen, int *start, int *end, int *step)\n{\n    /**\n     *\n     * #@for i from 0 to 15 step 1\n     */\n\n\n    char *p;\n    char *pEnd;\n    char *pNumber;\n    int nlen;\n\n    pEnd = range + range_len;\n    p = range;\n    while (p < pEnd && (*p == ' ' || *p == '\\t'))\n    {\n        p++;\n    }\n\n    if (pEnd - p < 10)\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"unkown for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n\n    *id = p;\n    while (p < pEnd && !(*p == ' ' || *p == '\\t'))\n    {\n        p++;\n    }\n    *idLen = p - *id;\n    if (*idLen == 0 || *idLen > 64)\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n\n    if (pEnd - p < 8)\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n\n    p++;\n    while (p < pEnd && (*p == ' ' || *p == '\\t'))\n    {\n        p++;\n    }\n    if (!(memcmp(p, _PREPROCESS_TAG_STR_FOR_FROM,\n                    _PREPROCESS_TAG_LEN_FOR_FROM) == 0 &&\n                (*(p+_PREPROCESS_TAG_LEN_FOR_FROM) == ' ' ||\n                 *(p+_PREPROCESS_TAG_LEN_FOR_FROM) == '\\t')))\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n    p += _PREPROCESS_TAG_LEN_FOR_FROM + 1;\n    pNumber = iniGetInteger(p, pEnd, &nlen);\n    if (nlen == 0)\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n    *start = atoi(pNumber);\n    p = pNumber + nlen;\n\n    if (pEnd - p < 4 || !(*p == ' ' || *p == '\\t'))\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n    p++;\n    while (p < pEnd && (*p == ' ' || *p == '\\t'))\n    {\n        p++;\n    }\n    if (!(memcmp(p, _PREPROCESS_TAG_STR_FOR_TO,\n                    _PREPROCESS_TAG_LEN_FOR_TO) == 0 &&\n                (*(p+_PREPROCESS_TAG_LEN_FOR_TO) == ' ' ||\n                 *(p+_PREPROCESS_TAG_LEN_FOR_TO) == '\\t')))\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"unkown for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n    p += _PREPROCESS_TAG_LEN_FOR_TO + 1;\n    pNumber = iniGetInteger(p, pEnd, &nlen);\n    if (nlen == 0)\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n    *end = atoi(pNumber);\n    p = pNumber + nlen;\n\n    if (p == pEnd)\n    {\n        *step = 1;\n        return 0;\n    }\n\n    if (!(*p == ' ' || *p == '\\t'))\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n    while (p < pEnd && (*p == ' ' || *p == '\\t'))\n    {\n        p++;\n    }\n    if (!(memcmp(p, _PREPROCESS_TAG_STR_FOR_STEP,\n                    _PREPROCESS_TAG_LEN_FOR_STEP) == 0 &&\n                (*(p+_PREPROCESS_TAG_LEN_FOR_STEP) == ' ' ||\n                 *(p+_PREPROCESS_TAG_LEN_FOR_STEP) == '\\t')))\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"unkown for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n    p += _PREPROCESS_TAG_LEN_FOR_STEP + 1;\n    pNumber = iniGetInteger(p, pEnd, &nlen);\n    if (nlen == 0)\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n    *step = atoi(pNumber);\n    p = pNumber + nlen;\n    while (p < pEnd && (*p == ' ' || *p == '\\t'))\n    {\n        p++;\n    }\n    if (p != pEnd)\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid for range: %.*s\", __LINE__,\n                range_len, range);\n        return EINVAL;\n    }\n\n    return 0;\n}\n\nstatic char *iniProccessFor(char *content, const int content_len,\n        int *offset, IniContext *pContext, int *new_content_len)\n{\n    char *pStart;\n    char *pEnd;\n    char *pForRange;\n    char *pForBlock;\n    char *id;\n    char tag[80];\n    char value[16];\n    int idLen;\n    int rangeLen;\n    int forBlockLen;\n    int start;\n    int end;\n    int step;\n    int count;\n    int i;\n    int copyLen;\n    int tagLen;\n    int valueLen;\n    char *newContent;\n    char *pDest;\n\n    *new_content_len = content_len;\n    pStart = iniFindTag(content, content + (*offset),\n            _PREPROCESS_TAG_STR_FOR, _PREPROCESS_TAG_LEN_FOR);\n    if (pStart == NULL)\n    {\n        *offset = *new_content_len;\n        return content;\n    }\n    pForRange = pStart + _PREPROCESS_TAG_LEN_FOR;\n    pForBlock = strchr(pForRange, '\\n');\n    if (pForBlock == NULL)\n    {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"expect new line (\\\\n) for %s\",\n                __LINE__, pStart);\n        *offset = *new_content_len;\n        return content;\n    }\n    rangeLen = pForBlock - pForRange;\n\n    pEnd = iniFindAloneTag(content, content_len, pForBlock,\n            _PREPROCESS_TAG_STR_ENDFOR, _PREPROCESS_TAG_LEN_ENDFOR);\n    if (pEnd == NULL)\n    {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"expect %s for %s\", __LINE__,\n                _PREPROCESS_TAG_STR_ENDFOR, pStart);\n        *offset = *new_content_len;\n        return content;\n    }\n    forBlockLen = pEnd - pForBlock;\n\n    if (iniParseForRange(pForRange, rangeLen, &id, &idLen,\n                &start, &end, &step) != 0)\n    {\n        logWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid statement: %.*s\",\n                __LINE__, (int)(pForBlock - pStart), pStart);\n        *offset = (pEnd + _PREPROCESS_TAG_LEN_ENDFOR) - content;\n        return content;\n    }\n    if (step == 0)\n    {\n\t\tlogWarning(\"file: \"__FILE__\", line: %d, \"\n                \"invalid step: %d for range: %.*s, set step to 1\",\n                __LINE__, step, rangeLen, pForRange);\n        *offset = (pEnd + _PREPROCESS_TAG_LEN_ENDFOR) - content;\n        return content;\n    }\n    else\n    {\n        count = (end - start) / step;\n        if (count < 0)\n        {\n            logWarning(\"file: \"__FILE__\", line: %d, \"\n                    \"invalid step: %d for range: %.*s\", __LINE__,\n                    step, rangeLen, pForRange);\n            *offset = (pEnd + _PREPROCESS_TAG_LEN_ENDFOR) - content;\n            return content;\n        }\n    }\n\n    newContent = iniAllocContent(pContext, content_len +\n            (forBlockLen + 16) * count);\n    if (newContent == NULL)\n    {\n        *offset = (pEnd + _PREPROCESS_TAG_LEN_ENDFOR) - content;\n        return NULL;\n    }\n\n    pDest = newContent;\n    copyLen = pStart - content;\n    if (copyLen > 0)\n    {\n        memcpy(pDest, content, copyLen);\n        pDest += copyLen;\n    }\n    *offset = copyLen;\n\n    tagLen = sprintf(tag, \"{$%.*s}\", idLen, id);\n    for (i=start; i<=end; i+=step)\n    {\n        char *p;\n        char *pRemain;\n        int remainLen;\n\n        valueLen = sprintf(value, \"%d\", i);\n\n        pRemain = pForBlock;\n        remainLen = forBlockLen;\n        while (remainLen >= tagLen)\n        {\n            p = (char *)memmem(pRemain, remainLen, tag, tagLen);\n            if (p == NULL)\n            {\n                memcpy(pDest, pRemain, remainLen);\n                pDest += remainLen;\n                break;\n            }\n\n            copyLen = p - pRemain;\n            if (copyLen > 0)\n            {\n                memcpy(pDest, pRemain, copyLen);\n                pDest += copyLen;\n            }\n            memcpy(pDest, value, valueLen);\n            pDest += valueLen;\n\n            pRemain = p + tagLen;\n            remainLen -= copyLen + tagLen;\n        }\n    }\n\n    copyLen = (content + content_len) - (pEnd + _PREPROCESS_TAG_LEN_ENDFOR);\n    if (copyLen > 0)\n    {\n        memcpy(pDest, pEnd + _PREPROCESS_TAG_LEN_ENDFOR, copyLen);\n        pDest += copyLen;\n    }\n\n    *pDest = '\\0';\n    *new_content_len = pDest - newContent;\n    return newContent;\n}\n\nstatic int iniLoadItemsFromBuffer(char *content, IniContext *pContext)\n{\n    char *pContent;\n    char *new_content;\n    int content_len;\n    int new_content_len;\n    int offset;\n\n    new_content = content;\n    new_content_len = strlen(content);\n\n    do\n    {\n        offset = 0;\n        pContent = new_content;\n        content_len = new_content_len;\n        if ((new_content=iniProccessIf(pContent, content_len,\n                        &offset, pContext, &new_content_len)) == NULL)\n        {\n            return ENOMEM;\n        }\n    } while (offset < new_content_len);\n\n    do\n    {\n        offset = 0;\n        pContent = new_content;\n        content_len = new_content_len;\n        if ((new_content=iniProccessFor(pContent, content_len,\n                        &offset, pContext, &new_content_len)) == NULL)\n        {\n            return ENOMEM;\n        }\n    } while (offset < new_content_len);\n\n    return iniDoLoadItemsFromBuffer(new_content, pContext);\n}\n\nstatic int remallocSection(IniSection *pSection, IniItem **pItem)\n{\n    int bytes;\n    int result;\n    int alloc_count;\n    IniItem *pNew;\n\n    if (pSection->alloc_count == 0)\n    {\n        alloc_count = _INIT_ALLOC_ITEM_COUNT;\n    }\n    else\n    {\n        alloc_count = pSection->alloc_count * 2;\n    }\n    bytes = sizeof(IniItem) * alloc_count;\n    pNew = (IniItem *)malloc(bytes);\n    if (pNew == NULL)\n    {\n        logError(\"file: \"__FILE__\", line: %d, \" \\\n            \"malloc %d bytes fail\", __LINE__, bytes);\n        result = errno != 0 ? errno : ENOMEM;\n        return result;\n    }\n\n    if (pSection->count > 0)\n    {\n        memcpy(pNew, pSection->items,\n                sizeof(IniItem) * pSection->count);\n        free(pSection->items);\n    }\n\n    pSection->alloc_count = alloc_count;\n    pSection->items = pNew;\n    *pItem = pSection->items + pSection->count;\n    memset(*pItem, 0, sizeof(IniItem) *\n        (pSection->alloc_count - pSection->count));\n\n    return 0;\n}\n\nstatic int iniFreeHashData(const int index, const HashData *data, void *args)\n{\n\tIniSection *pSection;\n\n\tpSection = (IniSection *)data->value;\n\tif (pSection == NULL)\n\t{\n\t\treturn 0;\n\t}\n\n\tif (pSection->items != NULL)\n\t{\n\t\tfree(pSection->items);\n\t\tmemset(pSection, 0, sizeof(IniSection));\n\t}\n\n\tfree(pSection);\n\t((HashData *)data)->value = NULL;\n\treturn 0;\n}\n\nvoid iniFreeContext(IniContext *pContext)\n{\n    SetDirectiveVars *set;\n\tif (pContext == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tif (pContext->global.items != NULL)\n\t{\n\t\tfree(pContext->global.items);\n\t\tmemset(&pContext->global, 0, sizeof(IniSection));\n\t}\n\n\thash_walk(&pContext->sections, iniFreeHashData, NULL);\n\thash_destroy(&pContext->sections);\n\n    set = iniGetVars(pContext);\n    if (set != NULL && set->vars != NULL)\n    {\n        hash_destroy(set->vars);\n        free(set->vars);\n        set->vars = NULL;\n        set->offset = 0;\n    }\n    iniFreeDynamicContent(pContext);\n}\n\n#define INI_FIND_ITEM(szSectionName, szItemName, pContext, pSection, \\\n        targetItem, pItem, return_val) \\\ndo { \\\n    if (szSectionName == NULL || *szSectionName == '\\0') \\\n    { \\\n        pSection = &pContext->global; \\\n    } \\\n    else \\\n    { \\\n        pSection = (IniSection *)hash_find(&pContext->sections, \\\n                szSectionName, strlen(szSectionName)); \\\n        if (pSection == NULL) \\\n        { \\\n            return return_val; \\\n        } \\\n    } \\\n    \\\n    if (pSection->count <= 0) \\\n    { \\\n        return return_val; \\\n    } \\\n    \\\n    snprintf(targetItem.name, sizeof(targetItem.name), \"%s\", szItemName); \\\n    pItem = (IniItem *)bsearch(&targetItem, pSection->items, \\\n            pSection->count, sizeof(IniItem), iniCompareByItemName); \\\n} while (0)\n\n\nchar *iniGetStrValue(const char *szSectionName, const char *szItemName, \\\n\t\tIniContext *pContext)\n{\n\tIniItem targetItem;\n\tIniSection *pSection;\n\tIniItem *pFound;\n\tIniItem *pItem;\n\tIniItem *pItemEnd;\n\n\tINI_FIND_ITEM(szSectionName, szItemName, pContext, pSection, \\\n\t\t\ttargetItem, pFound, NULL);\n\tif (pFound == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tpItemEnd = pSection->items + pSection->count;\n\tfor (pItem=pFound+1; pItem<pItemEnd; pItem++)\n\t{\n\t\tif (strcmp(pItem->name, szItemName) != 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n        pFound = pItem;\n\t}\n\n    return pFound->value;\n}\n\nint64_t iniGetInt64Value(const char *szSectionName, const char *szItemName, \\\n\t\tIniContext *pContext, const int64_t nDefaultValue)\n{\n\tchar *pValue;\n\n\tpValue = iniGetStrValue(szSectionName, szItemName, pContext);\n\tif (pValue == NULL)\n\t{\n\t\treturn nDefaultValue;\n\t}\n\telse\n\t{\n\t\treturn strtoll(pValue, NULL, 10);\n\t}\n}\n\nint iniGetIntValue(const char *szSectionName, const char *szItemName, \\\n\t\tIniContext *pContext, const int nDefaultValue)\n{\n\tchar *pValue;\n\n\tpValue = iniGetStrValue(szSectionName, szItemName, pContext);\n\tif (pValue == NULL)\n\t{\n\t\treturn nDefaultValue;\n\t}\n\telse\n\t{\n\t\treturn atoi(pValue);\n\t}\n}\n\ndouble iniGetDoubleValue(const char *szSectionName, const char *szItemName, \\\n\t\tIniContext *pContext, const double dbDefaultValue)\n{\n\tchar *pValue;\n\n\tpValue = iniGetStrValue(szSectionName, szItemName, pContext);\n\tif (pValue == NULL)\n\t{\n\t\treturn dbDefaultValue;\n\t}\n\telse\n\t{\n\t\treturn strtod(pValue, NULL);\n\t}\n}\n\nbool iniGetBoolValue(const char *szSectionName, const char *szItemName, \\\n\t\tIniContext *pContext, const bool bDefaultValue)\n{\n\tchar *pValue;\n\n\tpValue = iniGetStrValue(szSectionName, szItemName, pContext);\n\tif (pValue == NULL)\n\t{\n\t\treturn bDefaultValue;\n\t}\n\telse\n\t{\n\t\treturn FAST_INI_STRING_IS_TRUE(pValue);\n\t}\n}\n\nint iniGetValues(const char *szSectionName, const char *szItemName, \\\n\t\tIniContext *pContext, char **szValues, const int max_values)\n{\n\tIniItem *pItem;\n\tIniItem *pItemEnd;\n\tchar **ppValues;\n\tint count;\n\n\tif (max_values <= 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tpItem = iniGetValuesEx(szSectionName, szItemName,\n\t\t\tpContext, &count);\n\tif (count == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (count > max_values)\n\t{\n\t\tcount = max_values;\n\t}\n\n\tppValues = szValues;\n\tpItemEnd = pItem + count;\n\tfor (; pItem<pItemEnd; pItem++)\n\t{\n\t\t*ppValues++ = pItem->value;\n\t}\n\n\treturn count;\n}\n\nIniItem *iniGetValuesEx(const char *szSectionName, const char *szItemName, \\\n\t\tIniContext *pContext, int *nTargetCount)\n{\n\tIniItem targetItem;\n\tIniSection *pSection;\n\tIniItem *pFound;\n\tIniItem *pItem;\n\tIniItem *pItemEnd;\n\tIniItem *pItemStart;\n\n\t*nTargetCount = 0;\n\tINI_FIND_ITEM(szSectionName, szItemName, pContext, pSection, \\\n\t\t\ttargetItem, pFound, NULL);\n\tif (pFound == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\t*nTargetCount = 1;\n\tfor (pItem=pFound-1; pItem>=pSection->items; pItem--)\n\t{\n\t\tif (strcmp(pItem->name, szItemName) != 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t(*nTargetCount)++;\n\t}\n\tpItemStart = pFound - (*nTargetCount) + 1;\n\n\tpItemEnd = pSection->items + pSection->count;\n\tfor (pItem=pFound+1; pItem<pItemEnd; pItem++)\n\t{\n\t\tif (strcmp(pItem->name, szItemName) != 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t(*nTargetCount)++;\n\t}\n\n\treturn pItemStart;\n}\n\nstatic int iniPrintHashData(const int index, const HashData *data, void *args)\n{\n\tIniSection *pSection;\n\tIniItem *pItem;\n\tIniItem *pItemEnd;\n\tchar section_name[256];\n\tint section_len;\n\tint i;\n\n\tpSection = (IniSection *)data->value;\n\tif (pSection == NULL)\n\t{\n\t\treturn 0;\n\t}\n\n\tsection_len = data->key_len;\n\tif (section_len >= sizeof(section_name))\n\t{\n\t\tsection_len = sizeof(section_name) - 1;\n\t}\n\n\tmemcpy(section_name, data->key, section_len);\n\t*(section_name + section_len) = '\\0';\n\n\tprintf(\"section: %s, item count: %d\\n\", section_name, pSection->count);\n\tif (pSection->count > 0)\n\t{\n\t\ti = 0;\n\t\tpItemEnd = pSection->items + pSection->count;\n\t\tfor (pItem=pSection->items; pItem<pItemEnd; pItem++)\n\t\t{\n\t\t\tprintf(\"%d. %s=%s\\n\", ++i, pItem->name, pItem->value);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\nvoid iniPrintItems(IniContext *pContext)\n{\n\tIniItem *pItem;\n\tIniItem *pItemEnd;\n\tint i;\n\n\tprintf(\"global section, item count: %d\\n\", pContext->global.count);\n\tif (pContext->global.count > 0)\n\t{\n\t\ti = 0;\n\t\tpItemEnd = pContext->global.items + pContext->global.count;\n\t\tfor (pItem=pContext->global.items; pItem<pItemEnd; pItem++)\n\t\t{\n\t\t\tprintf(\"%d. %s=%s\\n\", ++i, pItem->name, pItem->value);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\n\thash_walk(&pContext->sections, iniPrintHashData, NULL);\n}\n\nstruct section_walk_arg {\n    IniSectionInfo *sections;\n    int count;\n    int size;\n};\n\nstatic int iniSectionWalkCallback(const int index, const HashData *data,\n        void *args)\n{\n    struct section_walk_arg *walk_arg;\n\tIniSection *pSection;\n    char *section_name;\n\tint section_len;\n\n\tpSection = (IniSection *)data->value;\n\tif (pSection == NULL)\n\t{\n\t\treturn 0;\n\t}\n\n    walk_arg = (struct section_walk_arg *)args;\n    if (walk_arg->count >= walk_arg->size)\n    {\n        return ENOSPC;\n    }\n\n\tsection_len = data->key_len;\n\tif (section_len > FAST_INI_ITEM_NAME_LEN)\n\t{\n        section_len = FAST_INI_ITEM_NAME_LEN;\n\t}\n\n    section_name = walk_arg->sections[walk_arg->count].section_name;\n\tmemcpy(section_name, data->key, section_len);\n\t*(section_name + section_len) = '\\0';\n\n    walk_arg->sections[walk_arg->count].pSection = pSection;\n    walk_arg->count++;\n    return 0;\n}\n\nint iniGetSectionNames(IniContext *pContext, IniSectionInfo *sections,\n        const int max_size, int *nCount)\n{\n    struct section_walk_arg walk_arg;\n    int result;\n\n    walk_arg.sections = sections;\n    walk_arg.count = 0;\n    walk_arg.size = max_size;\n\tresult = hash_walk(&pContext->sections, iniSectionWalkCallback, &walk_arg);\n    *nCount = walk_arg.count;\n    return result;\n}\n\nIniItem *iniGetSectionItems(const char *szSectionName, IniContext *pContext,\n        int *nCount)\n{\n\tIniSection *pSection;\n\n\tif (szSectionName == NULL || *szSectionName == '\\0')\n\t{\n\t\tpSection = &pContext->global;\n\t}\n\telse\n\t{\n\t\tpSection = (IniSection *)hash_find(&pContext->sections,\n\t\t\t\tszSectionName, strlen(szSectionName));\n\t\tif (pSection == NULL)\n\t\t{\n            *nCount = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n    *nCount = pSection->count;\n    return pSection->items;\n}\n\nchar *iniGetRequiredStrValueEx(const char *szSectionName, const char *szItemName,\n\t\tIniContext *pContext, const int nMinLength)\n{\n    char *value;\n    value = iniGetStrValue(szSectionName, szItemName, pContext);\n    if (value == NULL)\n    {\n        logError(\"file: \"__FILE__\", line: %d, \"\n                \"item: %s not exist\", __LINE__, szItemName);\n        return NULL;\n    }\n\n    if (nMinLength > 0)\n    {\n        if (nMinLength == 1 && *value == '\\0')\n        {\n            logError(\"file: \"__FILE__\", line: %d, \"\n                    \"item: %s, value is empty\", __LINE__, szItemName);\n            return NULL;\n        }\n        else\n        {\n            int len;\n            len = strlen(value);\n            if (len < nMinLength)\n            {\n                logError(\"file: \"__FILE__\", line: %d, \"\n                        \"item: %s, value length: %d < min length: %d\",\n                        __LINE__, szItemName, len, nMinLength);\n                return NULL;\n            }\n        }\n    }\n    return value;\n}\n\n"
    },
    "skipped": [],
    "total_files": 108
}