{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-abseil-cpp-20200923.2-quppvwvcqeavfdolh7fcp2rdzt5jiz7n/spack-src/absl/random/internal/randen_detect.cc": "// Copyright 2017 The Abseil Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the\"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an\"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// HERMETIC NOTE: The randen_hwaes target must not introduce duplicate\n// symbols from arbitrary system and other headers, since it may be built\n// with different flags from other targets, using different levels of\n// optimization, potentially introducing ODR violations.\n\n#include \"absl/random/internal/randen_detect.h\"\n\n#include <cstdint>\n#include <cstring>\n\n#include \"absl/random/internal/platform.h\"\n\n#if defined(ABSL_ARCH_X86_64)\n#define ABSL_INTERNAL_USE_X86_CPUID\n#elif defined(ABSL_ARCH_PPC) || defined(ABSL_ARCH_ARM) || \\\n    defined(ABSL_ARCH_AARCH64)\n#if defined(__ANDROID__)\n#define ABSL_INTERNAL_USE_ANDROID_GETAUXVAL\n#define ABSL_INTERNAL_USE_GETAUXVAL\n#elif defined(__linux__)\n#define ABSL_INTERNAL_USE_LINUX_GETAUXVAL\n#define ABSL_INTERNAL_USE_GETAUXVAL\n#endif\n#endif\n\n#if defined(ABSL_INTERNAL_USE_X86_CPUID)\n#if defined(_WIN32) || defined(_WIN64)\n#include <intrin.h>  // NOLINT(build/include_order)\n#pragma intrinsic(__cpuid)\n#else\n// MSVC-equivalent __cpuid intrinsic function.\nstatic void __cpuid(int cpu_info[4], int info_type) {\n  __asm__ volatile(\"cpuid \\n\\t\"\n                   : \"=a\"(cpu_info[0]), \"=b\"(cpu_info[1]), \"=c\"(cpu_info[2]),\n                     \"=d\"(cpu_info[3])\n                   : \"a\"(info_type), \"c\"(0));\n}\n#endif\n#endif  // ABSL_INTERNAL_USE_X86_CPUID\n\n// On linux, just use the c-library getauxval call.\n#if defined(ABSL_INTERNAL_USE_LINUX_GETAUXVAL)\n\nextern \"C\" unsigned long getauxval(unsigned long type);  // NOLINT(runtime/int)\n\nstatic uint32_t GetAuxval(uint32_t hwcap_type) {\n  return static_cast<uint32_t>(getauxval(hwcap_type));\n}\n\n#endif\n\n// On android, probe the system's C library for getauxval().\n// This is the same technique used by the android NDK cpu features library\n// as well as the google open-source cpu_features library.\n//\n// TODO(absl-team): Consider implementing a fallback of directly reading\n// /proc/self/auxval.\n#if defined(ABSL_INTERNAL_USE_ANDROID_GETAUXVAL)\n#include <dlfcn.h>\n\nstatic uint32_t GetAuxval(uint32_t hwcap_type) {\n  // NOLINTNEXTLINE(runtime/int)\n  typedef unsigned long (*getauxval_func_t)(unsigned long);\n\n  dlerror();  // Cleaning error state before calling dlopen.\n  void* libc_handle = dlopen(\"libc.so\", RTLD_NOW);\n  if (!libc_handle) {\n    return 0;\n  }\n  uint32_t result = 0;\n  void* sym = dlsym(libc_handle, \"getauxval\");\n  if (sym) {\n    getauxval_func_t func;\n    memcpy(&func, &sym, sizeof(func));\n    result = static_cast<uint32_t>((*func)(hwcap_type));\n  }\n  dlclose(libc_handle);\n  return result;\n}\n\n#endif\n\nnamespace absl {\nABSL_NAMESPACE_BEGIN\nnamespace random_internal {\n\n// The default return at the end of the function might be unreachable depending\n// on the configuration. Ignore that warning.\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code-return\"\n#endif\n\n// CPUSupportsRandenHwAes returns whether the CPU is a microarchitecture\n// which supports the crpyto/aes instructions or extensions necessary to use the\n// accelerated RandenHwAes implementation.\n//\n// 1. For x86 it is sufficient to use the CPUID instruction to detect whether\n//    the cpu supports AES instructions. Done.\n//\n// Fon non-x86 it is much more complicated.\n//\n// 2. When ABSL_INTERNAL_USE_GETAUXVAL is defined, use getauxval() (either\n//    the direct c-library version, or the android probing version which loads\n//    libc), and read the hardware capability bits.\n//    This is based on the technique used by boringssl uses to detect\n//    cpu capabilities, and should allow us to enable crypto in the android\n//    builds where it is supported.\n//\n// 3. Use the default for the compiler architecture.\n//\n\nbool CPUSupportsRandenHwAes() {\n#if defined(ABSL_INTERNAL_USE_X86_CPUID)\n  // 1. For x86: Use CPUID to detect the required AES instruction set.\n  int regs[4];\n  __cpuid(reinterpret_cast<int*>(regs), 1);\n  return regs[2] & (1 << 25);  // AES\n\n#elif defined(ABSL_INTERNAL_USE_GETAUXVAL)\n  // 2. Use getauxval() to read the hardware bits and determine\n  // cpu capabilities.\n\n#define AT_HWCAP 16\n#define AT_HWCAP2 26\n#if defined(ABSL_ARCH_PPC)\n  // For Power / PPC: Expect that the cpu supports VCRYPTO\n  // See https://members.openpowerfoundation.org/document/dl/576\n  // VCRYPTO should be present in POWER8 >= 2.07.\n  // Uses Linux kernel constants from arch/powerpc/include/uapi/asm/cputable.h\n  static const uint32_t kVCRYPTO = 0x02000000;\n  const uint32_t hwcap = GetAuxval(AT_HWCAP2);\n  return (hwcap & kVCRYPTO) != 0;\n\n#elif defined(ABSL_ARCH_ARM)\n  // For ARM: Require crypto+neon\n  // http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0500f/CIHBIBBA.html\n  // Uses Linux kernel constants from arch/arm64/include/asm/hwcap.h\n  static const uint32_t kNEON = 1 << 12;\n  uint32_t hwcap = GetAuxval(AT_HWCAP);\n  if ((hwcap & kNEON) == 0) {\n    return false;\n  }\n\n  // And use it again to detect AES.\n  static const uint32_t kAES = 1 << 0;\n  const uint32_t hwcap2 = GetAuxval(AT_HWCAP2);\n  return (hwcap2 & kAES) != 0;\n\n#elif defined(ABSL_ARCH_AARCH64)\n  // For AARCH64: Require crypto+neon\n  // http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0500f/CIHBIBBA.html\n  static const uint32_t kNEON = 1 << 1;\n  static const uint32_t kAES = 1 << 3;\n  const uint32_t hwcap = GetAuxval(AT_HWCAP);\n  return ((hwcap & kNEON) != 0) && ((hwcap & kAES) != 0);\n#endif\n\n#else  // ABSL_INTERNAL_USE_GETAUXVAL\n  // 3. By default, assume that the compiler default.\n  return ABSL_HAVE_ACCELERATED_AES ? true : false;\n\n#endif\n  // NOTE: There are some other techniques that may be worth trying:\n  //\n  // * Use an environment variable: ABSL_RANDOM_USE_HWAES\n  //\n  // * Rely on compiler-generated target-based dispatch.\n  // Using x86/gcc it might look something like this:\n  //\n  // int __attribute__((target(\"aes\"))) HasAes() { return 1; }\n  // int __attribute__((target(\"default\"))) HasAes() { return 0; }\n  //\n  // This does not work on all architecture/compiler combinations.\n  //\n  // * On Linux consider reading /proc/cpuinfo and/or /proc/self/auxv.\n  // These files have lines which are easy to parse; for ARM/AARCH64 it is quite\n  // easy to find the Features: line and extract aes / neon. Likewise for\n  // PPC.\n  //\n  // * Fork a process and test for SIGILL:\n  //\n  // * Many architectures have instructions to read the ISA. Unfortunately\n  //   most of those require that the code is running in ring 0 /\n  //   protected-mode.\n  //\n  //   There are several examples. e.g. Valgrind detects PPC ISA 2.07:\n  //   https://github.com/lu-zero/valgrind/blob/master/none/tests/ppc64/test_isa_2_07_part1.c\n  //\n  //   MRS <Xt>, ID_AA64ISAR0_EL1 ; Read ID_AA64ISAR0_EL1 into Xt\n  //\n  //   uint64_t val;\n  //   __asm __volatile(\"mrs %0, id_aa64isar0_el1\" :\"=&r\" (val));\n  //\n  // * Use a CPUID-style heuristic database.\n  //\n  // * On Apple (__APPLE__), AES is available on Arm v8.\n  //   https://stackoverflow.com/questions/45637888/how-to-determine-armv8-features-at-runtime-on-ios\n}\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n}  // namespace random_internal\nABSL_NAMESPACE_END\n}  // namespace absl\n",
        "/tmp/vanessa/spack-stage/spack-stage-abseil-cpp-20200923.2-quppvwvcqeavfdolh7fcp2rdzt5jiz7n/spack-src/absl/time/internal/cctz/src/time_zone_lookup.cc": "// Copyright 2016 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   https://www.apache.org/licenses/LICENSE-2.0\n//\n//   Unless required by applicable law or agreed to in writing, software\n//   distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//   See the License for the specific language governing permissions and\n//   limitations under the License.\n\n#include \"absl/base/config.h\"\n#include \"absl/time/internal/cctz/include/cctz/time_zone.h\"\n\n#if defined(__ANDROID__)\n#include <sys/system_properties.h>\n#if defined(__ANDROID_API__) && __ANDROID_API__ >= 21\n#include <dlfcn.h>\n#endif\n#endif\n\n#if defined(__APPLE__)\n#include <CoreFoundation/CFTimeZone.h>\n\n#include <vector>\n#endif\n\n#include <cstdlib>\n#include <cstring>\n#include <string>\n\n#include \"time_zone_fixed.h\"\n#include \"time_zone_impl.h\"\n\nnamespace absl {\nABSL_NAMESPACE_BEGIN\nnamespace time_internal {\nnamespace cctz {\n\n#if defined(__ANDROID__) && defined(__ANDROID_API__) && __ANDROID_API__ >= 21\nnamespace {\n// Android 'L' removes __system_property_get() from the NDK, however\n// it is still a hidden symbol in libc so we use dlsym() to access it.\n// See Chromium's base/sys_info_android.cc for a similar example.\n\nusing property_get_func = int (*)(const char*, char*);\n\nproperty_get_func LoadSystemPropertyGet() {\n  int flag = RTLD_LAZY | RTLD_GLOBAL;\n#if defined(RTLD_NOLOAD)\n  flag |= RTLD_NOLOAD;  // libc.so should already be resident\n#endif\n  if (void* handle = dlopen(\"libc.so\", flag)) {\n    void* sym = dlsym(handle, \"__system_property_get\");\n    dlclose(handle);\n    return reinterpret_cast<property_get_func>(sym);\n  }\n  return nullptr;\n}\n\nint __system_property_get(const char* name, char* value) {\n  static property_get_func system_property_get = LoadSystemPropertyGet();\n  return system_property_get ? system_property_get(name, value) : -1;\n}\n\n}  // namespace\n#endif\n\nstd::string time_zone::name() const { return effective_impl().Name(); }\n\ntime_zone::absolute_lookup time_zone::lookup(\n    const time_point<seconds>& tp) const {\n  return effective_impl().BreakTime(tp);\n}\n\ntime_zone::civil_lookup time_zone::lookup(const civil_second& cs) const {\n  return effective_impl().MakeTime(cs);\n}\n\nbool time_zone::next_transition(const time_point<seconds>& tp,\n                                civil_transition* trans) const {\n  return effective_impl().NextTransition(tp, trans);\n}\n\nbool time_zone::prev_transition(const time_point<seconds>& tp,\n                                civil_transition* trans) const {\n  return effective_impl().PrevTransition(tp, trans);\n}\n\nstd::string time_zone::version() const { return effective_impl().Version(); }\n\nstd::string time_zone::description() const {\n  return effective_impl().Description();\n}\n\nconst time_zone::Impl& time_zone::effective_impl() const {\n  if (impl_ == nullptr) {\n    // Dereferencing an implicit-UTC time_zone is expected to be\n    // rare, so we don't mind paying a small synchronization cost.\n    return *time_zone::Impl::UTC().impl_;\n  }\n  return *impl_;\n}\n\nbool load_time_zone(const std::string& name, time_zone* tz) {\n  return time_zone::Impl::LoadTimeZone(name, tz);\n}\n\ntime_zone utc_time_zone() {\n  return time_zone::Impl::UTC();  // avoid name lookup\n}\n\ntime_zone fixed_time_zone(const seconds& offset) {\n  time_zone tz;\n  load_time_zone(FixedOffsetToName(offset), &tz);\n  return tz;\n}\n\ntime_zone local_time_zone() {\n  const char* zone = \":localtime\";\n#if defined(__ANDROID__)\n  char sysprop[PROP_VALUE_MAX];\n  if (__system_property_get(\"persist.sys.timezone\", sysprop) > 0) {\n    zone = sysprop;\n  }\n#endif\n#if defined(__APPLE__)\n  std::vector<char> buffer;\n  CFTimeZoneRef tz_default = CFTimeZoneCopyDefault();\n  if (CFStringRef tz_name = CFTimeZoneGetName(tz_default)) {\n    CFStringEncoding encoding = kCFStringEncodingUTF8;\n    CFIndex length = CFStringGetLength(tz_name);\n    buffer.resize(CFStringGetMaximumSizeForEncoding(length, encoding) + 1);\n    if (CFStringGetCString(tz_name, &buffer[0], buffer.size(), encoding)) {\n      zone = &buffer[0];\n    }\n  }\n  CFRelease(tz_default);\n#endif\n\n  // Allow ${TZ} to override to default zone.\n  char* tz_env = nullptr;\n#if defined(_MSC_VER)\n  _dupenv_s(&tz_env, nullptr, \"TZ\");\n#else\n  tz_env = std::getenv(\"TZ\");\n#endif\n  if (tz_env) zone = tz_env;\n\n  // We only support the \"[:]<zone-name>\" form.\n  if (*zone == ':') ++zone;\n\n  // Map \"localtime\" to a system-specific name, but\n  // allow ${LOCALTIME} to override the default name.\n  char* localtime_env = nullptr;\n  if (strcmp(zone, \"localtime\") == 0) {\n#if defined(_MSC_VER)\n    // System-specific default is just \"localtime\".\n    _dupenv_s(&localtime_env, nullptr, \"LOCALTIME\");\n#else\n    zone = \"/etc/localtime\";  // System-specific default.\n    localtime_env = std::getenv(\"LOCALTIME\");\n#endif\n    if (localtime_env) zone = localtime_env;\n  }\n\n  const std::string name = zone;\n#if defined(_MSC_VER)\n  free(localtime_env);\n  free(tz_env);\n#endif\n\n  time_zone tz;\n  load_time_zone(name, &tz);  // Falls back to UTC.\n  // TODO: Follow the RFC3339 \"Unknown Local Offset Convention\" and\n  // arrange for %z to generate \"-0000\" when we don't know the local\n  // offset because the load_time_zone() failed and we're using UTC.\n  return tz;\n}\n\n}  // namespace cctz\n}  // namespace time_internal\nABSL_NAMESPACE_END\n}  // namespace absl\n"
    },
    "skipped": [],
    "total_files": 689
}